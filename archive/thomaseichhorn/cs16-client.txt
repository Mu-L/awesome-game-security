Project Path: arc_thomaseichhorn_cs16-client_e808_n9o

Source Tree:

```txt
arc_thomaseichhorn_cs16-client_e808_n9o
├── 3rdparty
│   ├── Android.mk
│   ├── extras
│   ├── regamelite
│   └── yapb
├── Android.mk
├── LICENSE
├── README.md
├── android
│   ├── AndroidManifest.xml
│   ├── build
│   ├── build.xml
│   ├── clean
│   ├── jni
│   │   ├── Android.mk
│   │   ├── Application.mk
│   │   ├── bs_config.mk
│   │   └── cs-client
│   ├── makepak.py
│   ├── project.properties
│   ├── res
│   │   ├── drawable-hdpi
│   │   │   └── ic_launcher.png
│   │   ├── drawable-mdpi
│   │   │   └── ic_launcher.png
│   │   ├── drawable-xhdpi
│   │   │   └── ic_launcher.png
│   │   ├── drawable-xxhdpi
│   │   │   └── ic_launcher.png
│   │   ├── layout
│   │   │   └── activity_launcher.xml
│   │   ├── values
│   │   │   ├── dimens.xml
│   │   │   └── strings.xml
│   │   ├── values-es
│   │   │   └── strings.xml
│   │   ├── values-fa
│   │   │   └── strings.xml
│   │   ├── values-pt-rBR
│   │   │   └── strings.xml
│   │   ├── values-ru
│   │   │   └── strings.xml
│   │   ├── values-tr
│   │   │   └── strings.xml
│   │   └── values-zh
│   │       └── strings.xml
│   ├── src
│   │   └── in
│   │       └── celest
│   │           └── xash3d
│   │               └── cs16client
│   │                   ├── InstallReceiver.java
│   │                   └── LauncherActivity.java
│   └── update
├── cl_dll
│   ├── Android.mk
│   ├── CMakeLists.txt
│   ├── Makefile
│   ├── Makefile.mingw
│   ├── cdll_int.cpp
│   ├── cl_dll.dsp
│   ├── com_weapons.cpp
│   ├── cs_wpn
│   │   ├── com_weapons.cpp
│   │   ├── cs_baseentity.cpp
│   │   └── cs_weapons.cpp
│   ├── demo.cpp
│   ├── draw_util.cpp
│   ├── entity.cpp
│   ├── ev_common.cpp
│   ├── ev_hldm.cpp
│   ├── events
│   │   ├── ev_cs16.cpp
│   │   ├── event_ak47.cpp
│   │   ├── event_aug.cpp
│   │   ├── event_awp.cpp
│   │   ├── event_createexplo.cpp
│   │   ├── event_createsmoke.cpp
│   │   ├── event_deagle.cpp
│   │   ├── event_decal_reset.cpp
│   │   ├── event_elite_left.cpp
│   │   ├── event_elite_right.cpp
│   │   ├── event_famas.cpp
│   │   ├── event_fiveseven.cpp
│   │   ├── event_g3sg1.cpp
│   │   ├── event_galil.cpp
│   │   ├── event_glock18.cpp
│   │   ├── event_knife.cpp
│   │   ├── event_m249.cpp
│   │   ├── event_m3.cpp
│   │   ├── event_m4a1.cpp
│   │   ├── event_mac10.cpp
│   │   ├── event_mp5n.cpp
│   │   ├── event_p228.cpp
│   │   ├── event_p90.cpp
│   │   ├── event_scout.cpp
│   │   ├── event_sg550.cpp
│   │   ├── event_sg552.cpp
│   │   ├── event_tmp.cpp
│   │   ├── event_ump45.cpp
│   │   ├── event_usp.cpp
│   │   ├── event_vehicle.cpp
│   │   ├── event_xm1014.cpp
│   │   └── hl_events.cpp
│   ├── hud
│   │   ├── MOTD.cpp
│   │   ├── ammo.cpp
│   │   ├── ammo_secondary.cpp
│   │   ├── ammohistory.cpp
│   │   ├── battery.cpp
│   │   ├── death.cpp
│   │   ├── flashlight.cpp
│   │   ├── geiger.cpp
│   │   ├── health.cpp
│   │   ├── hud.cpp
│   │   ├── hud_msg.cpp
│   │   ├── hud_redraw.cpp
│   │   ├── hud_spectator.cpp
│   │   ├── hud_update.cpp
│   │   ├── menu.cpp
│   │   ├── message.cpp
│   │   ├── money.cpp
│   │   ├── nvg.cpp
│   │   ├── radar.cpp
│   │   ├── radio.cpp
│   │   ├── saytext.cpp
│   │   ├── scoreboard.cpp
│   │   ├── sniperscope.cpp
│   │   ├── spectator_gui.cpp
│   │   ├── status_icons.cpp
│   │   ├── statusbar.cpp
│   │   ├── text_message.cpp
│   │   ├── timer.cpp
│   │   └── train.cpp
│   ├── in_camera.cpp
│   ├── include
│   │   ├── camera.h
│   │   ├── cl_dll.h
│   │   ├── cl_util.h
│   │   ├── com_weapons.h
│   │   ├── csprite.h
│   │   ├── demo.h
│   │   ├── draw_util.h
│   │   ├── ev_hldm.h
│   │   ├── events.h
│   │   ├── eventscripts.h
│   │   ├── hud
│   │   │   ├── ammo.h
│   │   │   ├── ammohistory.h
│   │   │   ├── health.h
│   │   │   ├── hud.h
│   │   │   ├── hud_iface.h
│   │   │   ├── hud_spectator.h
│   │   │   └── radar.h
│   │   ├── in_defs.h
│   │   ├── input.h
│   │   ├── kbutton.h
│   │   ├── math
│   │   │   ├── neon_mathfun.h
│   │   │   └── sse_mathfun.h
│   │   ├── overview.h
│   │   ├── parsemsg.h
│   │   ├── rain.h
│   │   ├── studio
│   │   │   ├── GameStudioModelRenderer.h
│   │   │   ├── StudioModelRenderer.h
│   │   │   └── studio_util.h
│   │   ├── tf_defs.h
│   │   ├── unicode_strtools.h
│   │   ├── util_vector.h
│   │   ├── vgui_parser.h
│   │   ├── view.h
│   │   └── wrect.h
│   ├── input.cpp
│   ├── input_sdl.cpp
│   ├── input_xash3d.cpp
│   ├── inputw32.cpp
│   ├── rain.cpp
│   ├── readme.txt
│   ├── studio
│   │   ├── GameStudioModelRenderer.cpp
│   │   ├── StudioModelRenderer.cpp
│   │   └── studio_util.cpp
│   ├── tri.cpp
│   ├── unicode_strtools.cpp
│   ├── util.cpp
│   ├── vgui_parser.cpp
│   └── view.cpp
├── common
│   ├── beamdef.h
│   ├── cl_entity.h
│   ├── com_model.h
│   ├── con_nprint.h
│   ├── const.h
│   ├── crc.h
│   ├── cvardef.h
│   ├── demo_api.h
│   ├── director_cmds.h
│   ├── dlight.h
│   ├── dll_state.h
│   ├── engine_launcher_api.h
│   ├── entity_state.h
│   ├── entity_types.h
│   ├── event_api.h
│   ├── event_args.h
│   ├── event_flags.h
│   ├── exefuncs.h
│   ├── gameinfo.h
│   ├── hltv.h
│   ├── in_buttons.h
│   ├── interface.cpp
│   ├── interface.h
│   ├── ivoicetweak.h
│   ├── kbutton.h
│   ├── lightstyle.h
│   ├── mathlib.h
│   ├── net_api.h
│   ├── netadr.h
│   ├── nowin.h
│   ├── particledef.h
│   ├── pmtrace.h
│   ├── port.h
│   ├── qfont.h
│   ├── r_efx.h
│   ├── r_studioint.h
│   ├── ref_params.h
│   ├── render_api.h
│   ├── screenfade.h
│   ├── studio_event.h
│   ├── triangleapi.h
│   ├── usercmd.h
│   ├── weaponinfo.h
│   └── wrect.h
├── dlls
│   ├── activity.h
│   ├── basemonster.h
│   ├── cbase.h
│   ├── cdll_dll.h
│   ├── effects.h
│   ├── enginecallback.h
│   ├── exportdef.h
│   ├── extdll.h
│   ├── gamerules.h
│   ├── hintmessage.h
│   ├── monsterevent.h
│   ├── monsters.h
│   ├── nodes.h
│   ├── player.h
│   ├── saverestore.h
│   ├── schedule.h
│   ├── skill.h
│   ├── soundent.h
│   ├── stdafx.h
│   ├── util.h
│   ├── vector.h
│   ├── weapons.h
│   └── wpn_shared
│       ├── wpn_ak47.cpp
│       ├── wpn_aug.cpp
│       ├── wpn_awp.cpp
│       ├── wpn_c4.cpp
│       ├── wpn_deagle.cpp
│       ├── wpn_elite.cpp
│       ├── wpn_famas.cpp
│       ├── wpn_fiveseven.cpp
│       ├── wpn_flashbang.cpp
│       ├── wpn_g3sg1.cpp
│       ├── wpn_galil.cpp
│       ├── wpn_glock18.cpp
│       ├── wpn_hegrenade.cpp
│       ├── wpn_knife.cpp
│       ├── wpn_m249.cpp
│       ├── wpn_m3.cpp
│       ├── wpn_m4a1.cpp
│       ├── wpn_mac10.cpp
│       ├── wpn_mp5navy.cpp
│       ├── wpn_p228.cpp
│       ├── wpn_p90.cpp
│       ├── wpn_scout.cpp
│       ├── wpn_sg550.cpp
│       ├── wpn_sg552.cpp
│       ├── wpn_smokegrenade.cpp
│       ├── wpn_tmp.cpp
│       ├── wpn_ump45.cpp
│       ├── wpn_usp.cpp
│       └── wpn_xm1014.cpp
├── engine
│   ├── Sequence.h
│   ├── anorms.h
│   ├── archtypes.h
│   ├── cdll_int.h
│   ├── custom.h
│   ├── customentity.h
│   ├── edict.h
│   ├── eiface.h
│   ├── keydefs.h
│   ├── menu_int.h
│   ├── mobility_int.h
│   ├── progdefs.h
│   ├── progs.h
│   ├── shake.h
│   └── studio.h
├── game_shared
│   ├── bitvec.h
│   ├── voice_banmgr.cpp
│   ├── voice_banmgr.h
│   ├── voice_common.h
│   ├── voice_gamemgr.cpp
│   ├── voice_gamemgr.h
│   ├── voice_status.cpp
│   └── voice_status.h
├── mainui
│   ├── Android.mk
│   ├── CMakeLists.txt
│   ├── basemenu.cpp
│   ├── basemenu.h
│   ├── enginecallback.h
│   ├── extdll.h
│   ├── legacy
│   │   ├── menu_playdemo.cpp
│   │   ├── menu_playrec.cpp
│   │   └── menu_recdemo.cpp
│   ├── menu_advcontrols.cpp
│   ├── menu_audio.cpp
│   ├── menu_btns.cpp
│   ├── menu_btnsbmp_table.h
│   ├── menu_configuration.cpp
│   ├── menu_controls.cpp
│   ├── menu_creategame.cpp
│   ├── menu_credits.cpp
│   ├── menu_filedialog.cpp
│   ├── menu_gameoptions.cpp
│   ├── menu_gamepad.cpp
│   ├── menu_internetgames.cpp
│   ├── menu_langame.cpp
│   ├── menu_main.cpp
│   ├── menu_multiplayer.cpp
│   ├── menu_playersetup.cpp
│   ├── menu_strings.cpp
│   ├── menu_strings.h
│   ├── menu_touch.cpp
│   ├── menu_touchbuttons.cpp
│   ├── menu_touchedit.cpp
│   ├── menu_touchoptions.cpp
│   ├── menu_vidoptions.cpp
│   ├── menufont.h
│   ├── udll_int.cpp
│   ├── ui_title_anim.cpp
│   ├── ui_title_anim.h
│   ├── utils.cpp
│   └── utils.h
├── network
│   └── delta.lst
├── pm_shared
│   ├── pm_debug.cpp
│   ├── pm_debug.h
│   ├── pm_defs.h
│   ├── pm_info.h
│   ├── pm_materials.h
│   ├── pm_math.cpp
│   ├── pm_math.h
│   ├── pm_movevars.h
│   ├── pm_shared.cpp
│   └── pm_shared.h
├── projects
│   ├── client.sln
│   ├── client.vcxproj
│   ├── client.vcxproj.filters
│   ├── mainui.sln
│   ├── mainui.vcxproj
│   ├── mainui.vcxproj.filters
│   ├── server.sln
│   ├── server.vcxproj
│   └── server.vcxproj.filters
└── public
    └── tier1
        ├── UtlMemory.h
        └── UtlVector.h

```

`3rdparty/Android.mk`:

```mk
include $(call all-subdir-makefiles)

```

`Android.mk`:

```mk
include $(call all-subdir-makefiles)

```

`LICENSE`:

```
CS16Client LICENSE
==================

Copyright (C) 2015-2016 Flying With Gauss

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.


Half Life 1 SDK LICENSE
======================

Half Life 1 SDK Copyright(C) Valve Corp.  

THIS DOCUMENT DESCRIBES A CONTRACT BETWEEN YOU AND VALVE CORPORATION (?Valve?).  PLEASE READ IT BEFORE DOWNLOADING OR USING THE HALF LIFE 1 SDK (?SDK?). BY DOWNLOADING AND/OR USING THE SOURCE ENGINE SDK YOU ACCEPT THIS LICENSE. IF YOU DO NOT AGREE TO THE TERMS OF THIS LICENSE PLEASE DON?T DOWNLOAD OR USE THE SDK.

You may, free of charge, download and use the SDK to develop a modified Valve game running on the Source engine.  You may distribute your modified Valve game in source and object code form, but only for free. Terms of use for Valve games are found in the Steam Subscriber Agreement located here: http://store.steampowered.com/subscriber_agreement/ 

You may copy, modify, and distribute the SDK and any modifications you make to the SDK in source and object code form, but only for free.  Any distribution of this SDK must include this license.txt and third_party_licenses.txt.  
 
Any distribution of the SDK or a substantial portion of the SDK must include the above copyright notice and the following: 

DISCLAIMER OF WARRANTIES.  THE SOURCE SDK AND ANY OTHER MATERIAL DOWNLOADED BY LICENSEE IS PROVIDED ?AS IS?.  VALVE AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES WITH RESPECT TO THE SDK, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, TITLE AND FITNESS FOR A PARTICULAR PURPOSE.  

LIMITATION OF LIABILITY.  IN NO EVENT SHALL VALVE OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THE ENGINE AND/OR THE SDK, EVEN IF VALVE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  
 
 
If you would like to use the SDK for a commercial purpose, please contact Valve at sourceengine@valvesoftware.com.

```

`README.md`:

```md
# CS16Client
## Counter-Strike 1.6 client.dll rewrite project.

* Based on HLSDK 2.3. 
* Works without VGUI.
* Runs on your phone.
* Helpful for modders.

[Latest stable release](https://github.com/SDLash3D/cs16-client/releases/latest)

## How to run

**Install**:

1) Install the APK from [GitHub Releases](https://github.com/SDLash3D/cs16-client/releases/latest). 
* If you have **multi-core** device, choose APK with `omp` postfix. 
* If you have **single-core** device or you have **problems** with OMP version, choose APK with `noomp` postfix.

2) Install the latest [Xash3D Android](https://github.com/SDLash3D/xash3d-android-project/releases/latest).

3) Copy `cstrike` and `valve` folders from your **Steam CS1.6** installation to `xash` folder on SDCard.

4) Run CS16Client and enjoy!

## Contributing

There is many things must be done. For example:

* Translations!
* Better and user-friendly Java Launcher design.
* Better weapon prediction system, animation fixes.
* Fixing crashes.
* Ports to another platforms.
* CZero support.

### Issues

**Issues temporarily disabled due to spam. Sorry about that.**

#### CS1.6 incompability
1) Explain what's wrong with cs16-client.

2) Attach a screenshot from Steam version of CS1.6. Please, please, don't send issues about modificated servers!

#### Crashes or bugs
1) Explain what's wrong with cs16-client

2) Attach a screenshot with cs16-client. Attach an engine.log. (if engine.log isn't written, rerun engine with `-log` parameter)

If you are experiencing bug on Android, attach an ADB log. 

### Code guide

For some reason, originally client is more "C with classes" than "C++". Someday it will be refactored, but now I recommend to use "C++" if it looks more convenient. 

For example, if you need to work with vectors, use `Vector` class, instead of `float[3]`. They are data-compatible, but `Vector` is more convenient for C++ code.

For code-style guide: Use `.clang-format`, Luke!

```

`android/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="in.celest.xash3d.cs16client"
      android:versionCode="520"
      android:versionName="1.33">
    <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="23"/>
    <application android:label="@string/app_name"
                 android:debuggable="false"
                 android:icon="@drawable/ic_launcher">
	<meta-data android:name="com.google.android.gms.version"
    		android:value="@integer/google_play_services_version" />
        <activity android:name=".LauncherActivity"
                  android:label="@string/app_name"
			android:windowSoftInputMode="stateHidden">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
<!--		<activity android:name=".ShortcutActivity" android:label="@string/text_shortcut" android:theme="@android:style/Theme.Dialog" 
			android:windowSoftInputMode="adjustResize">
			<intent-filter>
				<action android:name="android.intent.action.CREATE_SHORTCUT" />
				<category android:name="android.intent.category.DEFAULT" />
			</intent-filter>
		</activity>-->
        <activity android:name="com.google.android.gms.ads.AdActivity"
            android:configChanges="keyboard|keyboardHidden|orientation|screenLayout|uiMode|screenSize|smallestScreenSize"
            android:theme="@android:style/Theme.Translucent" />
		<receiver android:name=".InstallReceiver">
			<intent-filter android:priority="100">
				<category android:name="android.intent.category.DEFAULT" />
				<action android:name="android.intent.action.PACKAGE_ADDED"  />
				<action android:name="android.intent.action.PACKAGE_CHANGED" />
				<action android:name="android.intent.action.PACKAGE_INSTALL" />
				<action android:name="android.intent.action.PACKAGE_REMOVED" />
				<action android:name="android.intent.action.PACKAGE_REPLACED" />
				<data android:scheme="package" />
			</intent-filter>
		</receiver>
	</application>
	<uses-permission android:name="android.permission.INTERNET"/>
	<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
</manifest> 

```

`android/build`:

```
#!/bin/bash

if [[ "$1" = "--help" ]]; then
	echo "Usage: ./build.sh <release|debug> <omp|noomp>"
	exit 0
fi

if [[ "$#" -ne "2" ]]; then
	echo "Illegal number of parameters, see ./build.sh --help"
	exit 0
fi

if [[ "$1" = "release" ]]; then
	VERBOSE="0"
	RELEASE="0"
else
	RELEASE="1 APP_CFLAGS=\"-gdwarf-3\""
	VERBOSE="1"
fi

if [[ "$2" = "omp" ]]; then
	OMP="1"
	NAME_POSTFIX="omp"
else
	OMP="0"
	NAME_POSTFIX="noomp"
fi

echo "*****************************************"
echo "* OMP: $OMP "
echo "* RELEASETYPE: $RELEASE "
echo "*****************************************"

set -x

# Regenerate PAK file
mkdir -p pak/
mkdir -p assets/
cp -r ../3rdparty/extras/* pak/
python2 makepak.py pak/ assets/extras.pak

# Build
ndk-build -j8 NDK_TOOLCHAIN_VERSION=4.8 _CS16CLIENT_ENABLE_OPENMP=$OMP NDK_DEBUG=$RELEASE V=$VERBOSE
ant $1

if [[ "$1" = "release" ]]; then
	jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore ../../myks.keystore bin/cs16-client-$1-unsigned.apk xashdroid -tsa https://timestamp.geotrust.com/tsa
	$HOME/.android/android-sdk-linux/build-tools/23.0.3/zipalign 4 bin/cs16-client-$1-unsigned.apk bin/cs16-client.apk
fi
mv bin/cs16-client.apk cs16-client-$1-$NAME_POSTFIX.apk


```

`android/build.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project name="cs16-client" default="help">

    <!-- The local.properties file is created and updated by the 'android' tool.
         It contains the path to the SDK. It should *NOT* be checked into
         Version Control Systems. -->
    <property file="local.properties" />

    <!-- The ant.properties file can be created by you. It is only edited by the
         'android' tool to add properties to it.
         This is the place to change some Ant specific build properties.
         Here are some properties you may want to change/update:

         source.dir
             The name of the source directory. Default is 'src'.
         out.dir
             The name of the output directory. Default is 'bin'.

         For other overridable properties, look at the beginning of the rules
         files in the SDK, at tools/ant/build.xml

         Properties related to the SDK location or the project target should
         be updated using the 'android' tool with the 'update' action.

         This file is an integral part of the build system for your
         application and should be checked into Version Control Systems.

         -->
    <property file="ant.properties" />

    <!-- if sdk.dir was not set from one of the property file, then
         get it from the ANDROID_HOME env var.
         This must be done before we load project.properties since
         the proguard config can use sdk.dir -->
    <property environment="env" />
    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
        <isset property="env.ANDROID_HOME" />
    </condition>

    <!-- The project.properties file is created and updated by the 'android'
         tool, as well as ADT.

         This contains project specific properties such as project target, and library
         dependencies. Lower level build properties are stored in ant.properties
         (or in .classpath for Eclipse projects).

         This file is an integral part of the build system for your
         application and should be checked into Version Control Systems. -->
    <loadproperties srcFile="project.properties" />

    <!-- quick check on sdk.dir -->
    <fail
            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
            unless="sdk.dir"
    />

    <!--
        Import per project custom build rules if present at the root of the project.
        This is the place to put custom intermediary targets such as:
            -pre-build
            -pre-compile
            -post-compile (This is typically used for code obfuscation.
                           Compiled code location: ${out.classes.absolute.dir}
                           If this is not done in place, override ${out.dex.input.absolute.dir})
            -post-package
            -post-build
            -pre-clean
    -->
    <import file="custom_rules.xml" optional="true" />

    <!-- Import the actual build file.

         To customize existing targets, there are two options:
         - Customize only one target:
             - copy/paste the target into this file, *before* the
               <import> task.
             - customize it to your needs.
         - Customize the whole content of build.xml
             - copy/paste the content of the rules files (minus the top node)
               into this file, replacing the <import> task.
             - customize to your needs.

         ***********************
         ****** IMPORTANT ******
         ***********************
         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
         in order to avoid having your file be overridden by tools such as "android update project"
    -->
    <!-- version-tag: 1 -->
    <import file="${sdk.dir}/tools/ant/build.xml" />

</project>

```

`android/clean`:

```
#!/bin/bash

echo " ------- CLEANING ------- "

rm -rf obj/ libs/armeabi-v7a libs/armeabi libs/x86 bin/ gen/ assets/ pak/

```

`android/jni/Android.mk`:

```mk
override TARGET_arm_release_CFLAGS :=
override TARGET_thumb_release_CFLAGS :=
override TARGET_arm_debug_CFLAGS :=
override TARGET_thumb_debug_CFLAGS :=
override TARGET_CFLAGS :=
include $(call all-subdir-makefiles)

```

`android/jni/Application.mk`:

```mk
CFLAGS_OPT :=  -O3 -fomit-frame-pointer -funsafe-math-optimizations -ftree-vectorize -fgraphite-identity -floop-interchange -floop-block -funsafe-loop-optimizations -finline-limit=1024
CFLAGS_OPT_ARM := -mthumb -mfpu=neon -mcpu=cortex-a9 -pipe -mvectorize-with-neon-quad -DVECTORIZE_SINCOS
CFLAGS_OPT_ARMv5 :=-march=armv6 -mfpu=vfp -marm -pipe
CFLAGS_OPT_X86 := -mtune=atom -march=atom -mssse3 -mfpmath=sse -funroll-loops -pipe -DVECTORIZE_SINCOS
CFLAGS_HARDFP := -D_NDK_MATH_NO_SOFTFP=1 -mhard-float -mfloat-abi=hard -DLOAD_HARDFP -DSOFTFP_LINK
APPLICATIONMK_PATH = $(call my-dir)

XASH3D_CONFIG := $(APPLICATIONMK_PATH)/bs_config.mk

APP_ABI := x86 armeabi-v7a-hard armeabi
APP_MODULES := menu client server yapb
APP_PLATFORM := android-9
APP_STL := gnustl_static

```

`android/jni/bs_config.mk`:

```mk
#LOCAL_LDFLAGS += -fopenmp
#LOCAL_CFLAGS += -ftree-parallelize-loops=4 -fopenmp

ifeq ($(_CS16CLIENT_ENABLE_OPENMP), 1)
LOCAL_LDFLAGS += -fopenmp
LOCAL_CFLAGS += -ftree-parallelize-loops=4 -fopenmp
endif

LOCAL_CFLAGS += $(CFLAGS_OPT)
ifeq ($(TARGET_ARCH_ABI),armeabi-v7a-hard)
LOCAL_CFLAGS += $(CFLAGS_OPT_ARM) $(CFLAGS_HARDFP)
endif
ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)
LOCAL_CFLAGS += $(CFLAGS_OPT_ARM) -mfloat-abi=softfp
endif
ifeq ($(TARGET_ARCH_ABI),armeabi)
LOCAL_CFLAGS += $(CFLAGS_OPT_ARMv5)
endif
ifeq ($(TARGET_ARCH_ABI),x86)
LOCAL_CFLAGS += $(CFLAGS_OPT_X86)
endif

ifeq ($(NDK_DEBUG),1)
LOCAL_CFLAGS += -ggdb -DDEBUG
else
LOCAL_CFLAGS += -DNDEBUG
endif

```

`android/makepak.py`:

```py
import sys
import struct
import os

#dummy class for stuffing the file headers into
class FileEntry:
    pass

#arguments are source directory, then target filename e.g. "pak1.pak"
rootdir = sys.argv[1]
pakfilename = sys.argv[2]

pakfile = open(pakfilename,"wb")

#write a dummy header to start with
pakfile.write(struct.Struct("<4s2l").pack(b"PACK",0,0))

#walk the directory recursively, add the files and record the file entries
offset = 12
i = 0
fileentries = []
for root, subFolders, files in os.walk(rootdir):
    for file in files:
        entry = FileEntry()
        impfilename = os.path.join(root,file)
        entry.filename = os.path.relpath(impfilename,rootdir).replace("\\","/")
        if(entry.filename.startswith(".git")):continue
	# print "pak: "+entry.filename
        with open(impfilename, "rb") as importfile:
            pakfile.write(importfile.read())
            entry.offset = offset
            entry.length = importfile.tell()
            offset = offset + entry.length
        fileentries.append(entry)
        i += 1
tablesize = 0

#after all the file data, write the list of entries
for entry in fileentries:
    pakfile.write(struct.Struct("<56s").pack(entry.filename.encode("ascii")))
    pakfile.write(struct.Struct("<l").pack(entry.offset))
    pakfile.write(struct.Struct("<l").pack(entry.length))
    tablesize = tablesize + 64

print "Done. " + str(i) + " files packed to " + pakfilename + "."

#return to the header and write the values correctly
pakfile.seek(0)
pakfile.write(struct.Struct("<4s2l").pack(b"PACK",offset,tablesize))

```

`android/project.properties`:

```properties
# This file is automatically generated by Android Tools.
# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
# 
# This file must be checked in Version Control Systems.
# 
# To customize properties used by the Ant build system use,
# "build.properties", and override values to adapt the script to your
# project structure.

# Project target.
target=android-23

android.library.reference.1=libs/google-play-services_lib

```

`android/res/layout/activity_launcher.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
	xmlns:android="http://schemas.android.com/apk/res/android"
	xmlns:ads="http://schemas.android.com/apk/res-auto"
	xmlns:tools="http://schemas.android.com/tools"
	android:id="@+id/layout_shortcut"
	android:layout_width="match_parent"
	android:layout_height="match_parent"
	android:orientation="vertical"
	android:background="#252525"
	android:weightSum="1"
	tools:context="in.celest.xash3d.LauncherActivity" >
	<LinearLayout
		android:layout_width="fill_parent"
		android:layout_height="wrap_content"
		android:orientation="horizontal"
		android:layout_marginRight="5dp"
		android:layout_marginTop="20dp"
		android:layout_marginLeft="5dp"
		android:background="#555555" >
		<TextView
			android:id="@+id/textView_tittle"
			android:layout_width="wrap_content"
			android:layout_height="50dp"
			android:background="#555555"
			android:drawableLeft="@drawable/ic_launcher"
			android:drawablePadding="5dp"
			android:singleLine="true"
			android:gravity="center_vertical"
			android:clickable="true"
			android:onClick="onTitleClick" />
		<TextView
			android:id="@+id/textView_title"
			android:layout_width="fill_parent"
			android:layout_height="50dp"
			android:layout_marginRight="1dp"
			android:layout_marginTop="1dp"
			android:layout_marginBottom="1dp"
			android:layout_marginLeft="1dp"
			android:text="@string/app_name"
			android:textAppearance="?android:attr/textAppearanceMedium"
			android:textSize="25sp"
			android:singleLine="true"
			android:gravity="center_vertical" />
	</LinearLayout>
	<LinearLayout
		android:layout_width="match_parent"
		android:layout_height="match_parent"
		android:background="#555555"
		android:orientation="vertical"
		android:layout_weight="1.20"
		android:layout_marginBottom="5dp"
		android:layout_marginLeft="5dp"
		android:layout_marginRight="5dp"
		android:layout_marginTop="10dp">
		<ScrollView
			android:layout_width="match_parent"
			android:layout_height="match_parent"
			android:id="@+id/scrollView2">
			<LinearLayout 
				android:layout_width="match_parent"
				android:layout_height="match_parent"
				android:layout_marginBottom="10dp"
				android:layout_marginLeft="10dp"
				android:layout_marginRight="10dp"
				android:layout_marginTop="10dp"
				android:background="#444444"
				android:orientation="vertical"
				android:weightSum="1">
				<TextView
					android:id="@+id/textView_args"
					android:layout_width="wrap_content"
					android:layout_height="wrap_content"
					android:layout_marginBottom="1dp"
					android:layout_marginLeft="10dp"
					android:layout_marginRight="10dp"
					android:layout_marginTop="10dp"
					android:text="@string/cmd_args_text"
					android:textAppearance="?android:attr/textAppearanceMedium" />
				<TextView
					android:id="@+id/textView_args"
					android:layout_width="wrap_content"
					android:layout_height="wrap_content"
					android:layout_marginBottom="1dp"
					android:layout_marginLeft="10dp"
					android:layout_marginRight="10dp"
					android:layout_marginTop="1dp"
					android:text="@string/cmd_args_text2"
					android:textAppearance="?android:attr/textAppearanceSmall" />
				<EditText
					android:id="@+id/cmdArgs"
					android:layout_width="match_parent"
					android:layout_height="wrap_content"
					android:layout_marginBottom="10dp"
					android:layout_marginLeft="10dp"
					android:layout_marginRight="10dp"
					android:layout_marginTop="1dp"
					android:hint="@string/defCmdArgs"/>
				<ToggleButton
					android:id="@+id/use_zbot"
					android:layout_width="match_parent"
					android:layout_height="wrap_content"
					android:layout_margin="10dp"
					android:layout_marginLeft="10dp"
					android:layout_marginRight="10dp"
					android:layout_marginTop="10dp"
					android:text="nothing"
					android:textOff="@string/zbot_off"
					android:textOn="@string/zbot_on" />
				<ToggleButton
					android:id="@+id/use_yapb"
					android:layout_width="match_parent"
					android:layout_height="wrap_content"
					android:layout_margin="10dp"
					android:layout_marginLeft="10dp"
					android:layout_marginRight="10dp"
					android:layout_marginTop="10dp"
					android:text="nothing"
					android:textOff="@string/yapb_off"
					android:textOn="@string/yapb_on" />
				<ToggleButton
					android:id="@+id/enableczero"
					android:layout_width="match_parent"
					android:layout_height="wrap_content"
					android:layout_margin="10dp"
					android:layout_marginLeft="10dp"
					android:layout_marginRight="10dp"
					android:layout_marginTop="10dp"
					android:text="nothing"
					android:textOff="@string/czero_off"
					android:textOn="@string/czero_on" />
			</LinearLayout>
		</ScrollView>
	</LinearLayout>
	<com.google.android.gms.ads.AdView
		android:id="@+id/adView"
		android:layout_width="fill_parent"
		android:layout_height="wrap_content"
		android:layout_gravity="center"
		ads:adSize="BANNER"
		ads:adUnitId="@string/ad_unit_id" />
	<LinearLayout
		android:layout_width="match_parent"
		android:layout_height="50dp"
		android:background="#444444"
		android:layout_marginBottom="-20dp"
		android:paddingTop="5dp"
		android:layout_gravity="bottom"
		android:orientation="horizontal">
		<Button
			android:id="@+id/button_launch"
			android:layout_width="match_parent"
			android:layout_height="wrap_content"
			android:layout_marginLeft="0dp"
			android:onClick="startXash"
			android:text="@string/launch_button" >
			<requestFocus />
		</Button>
	</LinearLayout>
</LinearLayout>


```

`android/res/values-es/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">CS16Client</string>
    <string name="title_activity_launcher">CS16Client Launcher</string>
    <string name="launch_button">¡Iniciar cs16-client!</string>
    <string name="cmd_args_text">Parámetros de línea de comandos:</string>
    <string name="cmd_args_text2">¡No tocar si no sabes por qué necesitas esto!</string>
    <string name="not_found_msg">Nada fue encontrado. Revisa tu APK o elige otro servidor</string>
    <string name="not_found_title">Algo salió mal...</string>
    <string name="not_implemented_msg">Esta característica no está implementada todavía</string>
    <string name="not_implemented_title">¡No implementado!</string>
        <string name="enablezbot">Habilitar bots ZBot</string>
        <string name="enableyapb">Habilitar bots YaPB</string>
        <string name="defCmdArgs">-console -game cstrike -bots, etc</string>
        <string name="basedir_text">Definir ruta para directorio del juego:</string>
        <string name="basedir_text2">Dejar vacío para utilizar las preferencias de Xash3D Android.</string>

</resources>

```

`android/res/values-fa/strings.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
  <string name="app_name">CS16Client</string>
  <string name="title_activity_launcher">CS16-Client اجرا کننده</string>
  <string name="launch_button">!CS16-client اجرای</string>
  <string name="cmd_args_text">Command line arguments:</string>
  <string name="cmd_args_text2">!اگر نمی دانید چرا به این نیاز دارید دست کاری نکنید</string>
  <string name="not_found_msg">خود را چک کنید یا سرور دیگری را انتخاب کنیدAPK .موردی یافت نشد</string>
  <string name="not_found_title">...اشکالی رخ داد</string>
  <string name="not_implemented_msg">...این ویژگی هنوز پشتیبانی نمی شود</string>
  <string name="not_implemented_title">!پشتیبانی نمیشود</string>
  <string name="enablezbot">ZBot فعال کردن بات های</string>
  <string name="enableyapb">YaPB فعال کردن بات های</string>
  <string name="defCmdArgs">-console -game cstrike -bots, etc</string>
  <string name="basedir_text">:مسیرمحل بازی</string>
  <string name="basedir_text2">.استفاده شود Xash3D Android خالی بگذارید تا از تنظیمات</string>
</resources>

```

`android/res/values-pt-rBR/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">CS16Client</string>
    <string name="title_activity_launcher">Lançador CS16Client</string>
    <string name="launch_button">Iniciar CS 1.6!</string>
    <string name="cmd_args_text">Parâmetros:</string>
    <string name="cmd_args_text2">Não encoste se não sabe para que serve</string>
    <string name="not_found_msg">Opss... Não encontramos nada. Verifique seu APK ou escolha outro servidor</string>
    <string name="not_found_title">Algo deu errado...</string>
    <string name="not_implemented_msg">Este recurso ainda não foi implementado</string>
    <string name="not_implemented_title">Não implementado!</string>
    <string name="enablezbot">Habilitar bots ZBot</string>
    <string name="enableyapb">Habilitar bots YaPB</string>
    <string name="defCmdArgs">-console -game cstrike -bots, etc</string>
    <string name="basedir_text">Definir diretório do jogo:</string>
    <string name="basedir_text2">Deixe em branco para usar as preferências do Xash3D Android.</string>

</resources>

```

`android/res/values-ru/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string name="title_activity_launcher">Лаунчер CS16Client</string>
	<string name="launch_button">Запустить CS16Client!</string>
	<string name="cmd_args_text">Аргументы командной строки:</string>
	<string name="cmd_args_text2">Не трогайте, если не знаете нужно ли оно вам!</string>
	<string name="not_found_msg">Ничего не найдено. Проверьте вашу установку.</string>
	<string name="not_found_title">Что-то пошло не так...</string>
	<string name="not_implemented_msg">Эта функция ещё не реализована</string>
	<string name="not_implemented_title">Ещё не реализовано!</string>
	<string name="not_implemented_fully">Не готово! Багрепорты не будут приниматься, если эта функция включена.</string>
	<string name="zbot_on">Включить ZBot боты</string>
	<string name="zbot_off">Выключить ZBot боты</string>
	<string name="yapb_on">Включить YaPB боты</string>
	<string name="yapb_off">Выключить YaPB боты</string>
	<string name="czero_on">Включить поддержку Condition Zero</string>
	<string name="czero_off">Выключить поддержку Condition Zero</string>
	<string name="defCmdArgs">-console -game cstrike -bots, etc</string>
	<string name="xash_not_installed_title">Движок не найден</string>
	<string name="xash_not_installed_msg">Для того, чтобы продолжить вам необходимо установить Xash3D на ваше устройство</string>
	<string name="install_xash">Установить</string>
	<string name="cancel">Отмена</string>
	<string name="first_run_reminder_title">Напоминание при первом запуске</string>
	<string name="first_run_reminder_msg">Добро пожаловать в CS16Client! Хочу лишний раз напомнить, что для игры вам необходимы папки "cstrike" и "valve с оригинальной Steam установки Counter-Strike 1.6. Приятной игры!</string>
	<string name="ok">Хорошо!</string>
</resources>

```

`android/res/values-tr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">CS16Client</string>
    <string name="title_activity_launcher">CS16Client Başlatıcısı</string>
    <string name="launch_button">CS16-client\'i Başlat!</string>
    <string name="cmd_args_text">Komut satırı argümanları:</string>
    <string name="cmd_args_text2">Buna niye ihtiyacınız olduğunu bilmeden dokunmayın!</string>
    <string name="not_found_msg">Hiçbir şey bulunamadı. APK\'yi kontrol edin veya başka sunucu seçin.</string>
    <string name="not_found_title">Bir şeyler yolunda gitmedi...</string>
    <string name="not_implemented_msg">Bu özellik henüz tamamlanmadı.</string>
    <string name="not_implemented_title">Tamamlanmadı!</string>
	<string name="enablezbot">ZBot botlarını aktif et</string>
	<string name="enableyapb">YaPB botlarını aktif et</string>
	<string name="defCmdArgs">-console -game cstrike -bots</string>
	<string name="basedir_text">Yolu oyun dizinine ayarlayın:</string>
	<string name="basedir_text2">Xash3D Android tercihlerini kullanmak için boş bırakın.</string>
	<!--<string name="ad_unit_id">Не дам! :P</string>-->
    <!--
	<string name="text_shortcut">SoHL shortcut</string>
	<string name="shortcut_button_save">Save shortcut</string>
	<string name="gamedir">Mod directory</string>
	<string name="shortcut_name">Shortcut name</string>-->
</resources>

```

`android/res/values-zh/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
<string name="app_name">CS16Client</string>
<string name="title_activity_launcher">CS16客户端启动器</string>
<string name="launch_button">启动 CS16Client!</string>
<string name="cmd_args_text">命令行参数:</string>
<string name="cmd_args_text2">如果不清楚不要随意修改！</string>
<string name="not_found_msg">什么都没有找到…请检查您的APK或选择另一台服务器 </string>
<string name="not_found_title">出现了一些问题……</string>
<string name="not_implemented_msg">此功能尚未实现</string>
<string name="not_implemented_title">未实现！</string>
<string name="enablezbot">使用 ZBot 机器人</string>
<string name="enableyapb">使用 YaPB 机器人</string>
<string name="defCmdArgs">-console -game cstrike -bots, etc</string>
<string name="basedir_text">设置游戏路径：</string>
<string name="basedir_text2">如果留空则使用Xash3D的目录</string>
</resources>

```

`android/res/values/dimens.xml`:

```xml
<resources>
    <!-- Default screen margins, per the Android Design guidelines. -->
    <dimen name="activity_horizontal_margin">16dp</dimen>
    <dimen name="activity_vertical_margin">16dp</dimen>
</resources>

```

`android/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string name="app_name" translatable="false">CS16Client</string>
	<string name="defCmdArgs" translatable="false">-console -game cstrike -bots, etc</string>
	<string name="title_activity_launcher">CS16Client Launcher</string>
	<string name="launch_button">Launch cs16-client!</string>
	<string name="cmd_args_text">Command line arguments:</string>
	<string name="cmd_args_text2">Don\'t touch if you don\'t know why you need this!</string>
	<string name="not_found_msg">Nothing was found. Check your installation</string>
	<string name="not_found_title">Something got wrong...</string>
	<string name="not_implemented_msg">This feature is not implemented yet</string>
	<string name="not_implemented_title">Not implemented!</string>
	<string name="not_implemented_fully">This is not ready! Bugreports are not accepted when this feature is on.</string>
	<string name="zbot_on">ZBot Enabled</string>
	<string name="zbot_off">ZBot Disabled</string>
	<string name="yapb_on">YaPB Enabled</string>
	<string name="yapb_off">YaPB Disabled</string>
	<string name="czero_on">Condition Zero Enabled</string>
	<string name="czero_off">Condition Zero Disabled</string>
	<string name="xash_not_installed_title">No engine found</string>
	<string name="xash_not_installed_msg">To continue, you must install Xash3D engine on your device</string>
	<string name="install_xash">Install</string>
	<string name="cancel">Cancel</string>
	<string name="first_run_reminder_title">First run reminder</string>
	<string name="first_run_reminder_msg">Welcome to CS16Client! I just want to remind you that to play this game you must copy original Counter-Strike 1.6 files(only "cstrike" and "valve" folders) from your Steam installation of the game to your device. Good luck, have fun!</string>
	<string name="ok">OK!</string>
	<!--<string name="ad_unit_id">Не дам! :P</string>-->
</resources>

```

`android/src/in/celest/xash3d/cs16client/InstallReceiver.java`:

```java
package in.celest.xash3d.cs16client;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;
import android.content.SharedPreferences;
import java.io.FileOutputStream;
import java.io.File;
import java.io.InputStream;
import java.lang.reflect.Method;

public class InstallReceiver extends BroadcastReceiver 
{
	private static final String TAG = "CS16CLIENT_LAUNCHER";
	static SharedPreferences mPref;
	@Override
	public void onReceive( Context context, Intent arg1 ) 
	{
		Log.d( TAG, "Install received, extracting PAK" );
		extractPAK( context, true );
    }
    
    private static int chmod(String path, int mode) {
		int ret = -1;
		try
		{
			ret = Runtime.getRuntime().exec("chmod " + Integer.toOctalString(mode) + " " + path).waitFor();
			Log.d(TAG, "chmod " + Integer.toOctalString(mode) + " " + path + ": " + ret );
		}
		catch(Exception e)
		{
			ret = -1;
			Log.d(TAG, "chmod: Runtime not worked: " + e.toString() );
		}
		try
		{
			Class fileUtils = Class.forName("android.os.FileUtils");
			Method setPermissions = fileUtils.getMethod("setPermissions",
				String.class, int.class, int.class, int.class);
			ret = (Integer) setPermissions.invoke(null, path,
				mode, -1, -1);
		}
		catch(Exception e)
		{
			ret = -1;
			Log.d(TAG, "chmod: FileUtils not worked: " + e.toString() );
		}
		return ret;
	 }

	 private static void extractFile(Context context, String path) 
	 {
		try
		{
			InputStream is = null;
			FileOutputStream os = null;
			is = context.getAssets().open(path);
			File out = new File(context.getFilesDir().getPath()+'/'+path);
			out.getParentFile().mkdirs();
			chmod( out.getParent(), 0777 );
			os = new FileOutputStream(out);
			byte[] buffer = new byte[1024];
			int length;
			while ((length = is.read(buffer)) > 0) 
			{
				os.write(buffer, 0, length);
			}
			os.close();
			is.close();
			chmod( context.getFilesDir().getPath()+'/'+path, 0777 );
		} 
		catch( Exception e )
		{
			Log.e( TAG, "Failed to extract file:" + e.toString() );
			e.printStackTrace();
		}
	 }

	private static synchronized void extractPAK(Context context, Boolean force) 
	{
		InputStream is = null;
		FileOutputStream os = null;
		try 
		{
			if( mPref == null )
				mPref = context.getSharedPreferences("mod", 0);
			synchronized( mPref )
			{
				if( mPref.getInt( "pakversion", 0 ) == LauncherActivity.PAK_VERSION && !force )
					return;
				extractFile(context, "extras.pak");
				SharedPreferences.Editor editor = mPref.edit();
				editor.putInt( "pakversion", LauncherActivity.PAK_VERSION );
				editor.commit();
			}
		} 
		catch( Exception e )
		{
			Log.e( TAG, "Failed to extract PAK:" + e.toString() );
		}
	}
}

```

`android/src/in/celest/xash3d/cs16client/LauncherActivity.java`:

```java
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
package in.celest.xash3d.cs16client;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.Intent;
import android.content.ComponentName;
import android.content.pm.PackageManager;
import android.content.SharedPreferences;
import android.content.DialogInterface;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import android.widget.EditText;
import android.widget.CheckBox;
import android.widget.ToggleButton;
import android.widget.TextView;
import android.widget.TabHost;
import android.os.Environment;
import android.os.Build;
import android.net.Uri;
import android.util.DisplayMetrics;
import java.io.FileOutputStream;
import java.io.File;
import java.io.InputStream;
import java.lang.reflect.Method;

import com.google.android.gms.ads.*;
import com.google.android.gms.common.GoogleApiAvailability;
import com.google.android.gms.common.ConnectionResult;

import in.celest.xash3d.cs16client.R;

public class LauncherActivity extends Activity {
	public static final int PAK_VERSION = 4;
	public final static int sdk = Integer.valueOf(Build.VERSION.SDK);
	public final static String TAG = "LauncherActivity";
	
	public static Context mContext;
	static SharedPreferences mPref;
	static EditText mCmdArgs;
	static EditText mBaseDir;
	static ToggleButton mEnableZBot;
	static ToggleButton mEnableYaPB;
	static ToggleButton mEnableCZero;
	static AdView   mAdView;
	static TextView mTitle;
	static Boolean isExtracting = false;
	static int mClicks;
	static Boolean mDev;
	static Boolean mFirstTime;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		this.requestWindowFeature(Window.FEATURE_NO_TITLE);
		
		// disable as there is not stupid holo blue tabs
		//if ( sdk >= 21 )
		//	super.setTheme( 0x01030224 );
		//else super.setTheme( 0x01030005 );

		setContentView(R.layout.activity_launcher);
		
		mContext = getApplicationContext();
		
		// get preferences
		mPref          = getSharedPreferences("mod", 0);
		
		mCmdArgs       = (EditText)findViewById(R.id.cmdArgs);
		mEnableZBot    = (ToggleButton)findViewById(R.id.use_zbot);
		mEnableYaPB    = (ToggleButton)findViewById(R.id.use_yapb);
		mEnableCZero   = (ToggleButton)findViewById(R.id.enableczero); // TODO
		mAdView        = (AdView)  findViewById(R.id.adView);
		mTitle         = (TextView) findViewById(R.id.textView_tittle);
		mClicks = 0;
		mDev = mPref.getBoolean("dev", false);
		
		// TODO: extend firsttime with requesting player nickname!
		mFirstTime = mPref.getBoolean( "firsttime", true );
		
		mCmdArgs.   setText   (mPref.getString ("argv"   , "-console"));
		mEnableZBot.setChecked(mPref.getBoolean("zbots"  , true ));
		mEnableYaPB.setChecked(mPref.getBoolean("yapbs"  , false));
		mEnableCZero.setChecked(mPref.getBoolean("czero" , false)); // TODO
		
		if( !mDev )
			mEnableCZero.setVisibility(View.GONE);
		
		try
		{
			AdRequest adRequest = new AdRequest.Builder()
				.addTestDevice(AdRequest.DEVICE_ID_EMULATOR)
				.build();
			mAdView.loadAd(adRequest);
		}
		catch(Throwable e)
		{
			// Very dirty hack!
			// AdMob uses some methods that are not available on some devices
			// Just don't let app crash.
			Log.e( TAG, "Something happened during load ad. " + e.getMessage() );
		}
		
		if( mFirstTime )
		{
			showTutorial();
		}
	}

	public void startXash(View view)
	{
		SharedPreferences.Editor editor = mPref.edit();
		String argv    = mCmdArgs.getText().toString();
		String gamedir = "cstrike";

		editor.putString("argv", argv);
		editor.putBoolean("zbots", mEnableZBot.isChecked());
		editor.putBoolean("yapbs", mEnableYaPB.isChecked());
		if( mFirstTime ) editor.putBoolean("firsttime", false);
		editor.commit();

		extractPAK(this, false);

		if( mEnableYaPB.isChecked() )
		{
			String fullPath = getFilesDir().getAbsolutePath().replace("/files","/lib");
			File yapb_hardfp = new File( fullPath + "/libyapb_hardfp.so" );
			File yapb = new File( fullPath + "/libyapb.so" );
			if( yapb_hardfp.exists() && !yapb_hardfp.isDirectory() )
				argv = argv + " -dll " + yapb_hardfp.getAbsolutePath();
			else if( yapb.exists() && !yapb.isDirectory() )
				argv = argv + " -dll " + yapb.getAbsolutePath();
			else
			{
				Log.v(TAG, "YaPB not found!");
				AlertDialog.Builder notFoundDialogBuilder = new AlertDialog.Builder(this);
				notFoundDialogBuilder.setMessage(R.string.not_found_msg)
					.setTitle(R.string.not_found_title);
				notFoundDialogBuilder.create().show();
				return;
			}
		}
		
		if( mEnableZBot.isChecked() )
		{
			argv = argv + " -bots";
		}
		
		if( mEnableCZero.isChecked() ) // TODO
		{
			AlertDialog.Builder notImplementedDialogBuilder = new AlertDialog.Builder(this);
			notImplementedDialogBuilder.setMessage(R.string.not_implemented_msg)
				.setTitle(R.string.not_implemented_fully);
			notImplementedDialogBuilder.create().show();
			
			gamedir = "czero"; // use when czero will be done
		}
		
		// TODO:
		// Check is installed engine is Google Play version
		// Check myself for GP version
		argv = argv + " -noch"; 
		
		if( mFirstTime )
		{
			argv = argv + " -firsttime umu"; // pass argument, because xash have a bug related to client's CheckParm
		}
		
		Intent intent = new Intent();
		intent.setAction("in.celest.xash3d.START");
		intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

		intent.putExtra("argv",       argv);
		intent.putExtra("gamedir",    gamedir );
		intent.putExtra("gamelibdir", getFilesDir().getAbsolutePath().replace("/files","/lib"));
		intent.putExtra("pakfile",    getFilesDir().getAbsolutePath() + "/extras.pak" );
		
		PackageManager pm = getPackageManager();
		if( intent.resolveActivity( pm ) != null )
		{
			startActivity( intent );
		}
		else
		{
			showXashInstallDialog( );
		}
	}
	
	public void showTutorial( )
	{
		AlertDialog.Builder builder = new AlertDialog.Builder( this );
		
		// TODO: must be less dumb someday...
		builder.setTitle( R.string.first_run_reminder_title )
			.setMessage( R.string.first_run_reminder_msg )
			.setNeutralButton( R.string.ok, new DialogInterface.OnClickListener() { public void onClick( DialogInterface dialog, int which ) { } } )
			.show();
	}

	
	public void showXashInstallDialog( )
	{
		AlertDialog.Builder builder = new AlertDialog.Builder( this );
		
		builder.setTitle( R.string.xash_not_installed_title )
			.setMessage( R.string.xash_not_installed_msg )
			.setPositiveButton( R.string.install_xash, 
			new DialogInterface.OnClickListener()
			{
				@Override
				public void onClick( DialogInterface dialog, int which )
				{
					GoogleApiAvailability api = GoogleApiAvailability.getInstance();
					int avail = api.isGooglePlayServicesAvailable( LauncherActivity.mContext );
					
					if( avail == ConnectionResult.SUCCESS )
					{
						// open GP
						try 
						{
							startActivity( 
								new Intent( Intent.ACTION_VIEW, 
									Uri.parse("market://details?id=in.celest.xash3d.hl") ) );
						} 
						catch( android.content.ActivityNotFoundException e ) 
						{
							startActivity(
								new Intent( Intent.ACTION_VIEW, 
									Uri.parse("https://play.google.com/store/apps/details?id=in.celest.xash3d.hl" ) ) );
						}
					}
					else
					{
						try
						{
							startActivity( 
								new Intent( Intent.ACTION_VIEW, 
									Uri.parse("https://github.com/FWGS/xash3d/releases/latest") ) );
						}
						catch( Exception e )
						{ }
					}
				}
			} )
			.setNegativeButton( R.string.cancel, 
			new DialogInterface.OnClickListener()
			{
				@Override
				public void onClick( DialogInterface dialog, int which )
				{
					dialog.cancel();
				}
			} )
			.show();
	}
	
	public void onTitleClick(View view)
	{
		if( mDev )
			return;
		
		if( mClicks++ > 10 )
		{
			SharedPreferences.Editor editor = mPref.edit();
			editor.putBoolean("dev", true);
			editor.commit();
			
			mDev = true;
			
			mEnableCZero.setVisibility(View.VISIBLE);
		}
	}

	@Override
	public void onResume() {
		super.onResume();
		if(mAdView != null)
			mAdView.resume();
	}

	@Override
	public void onDestroy() {
		if(mAdView != null)
			mAdView.destroy();

		super.onDestroy();
	}

	@Override
	public void onPause() {
		if(mAdView != null)
			mAdView.pause();
	
		super.onPause();
	}
	
	private static int chmod(String path, int mode) {
		int ret = -1;
		try
		{
			ret = Runtime.getRuntime().exec("chmod " + Integer.toOctalString(mode) + " " + path).waitFor();
			Log.d(TAG, "chmod " + Integer.toOctalString(mode) + " " + path + ": " + ret );
		}
		catch(Exception e)
		{
			ret = -1;
			Log.d(TAG, "chmod: Runtime not worked: " + e.toString() );
		}
		try
		{
			Class fileUtils = Class.forName("android.os.FileUtils");
			Method setPermissions = fileUtils.getMethod("setPermissions",
				String.class, int.class, int.class, int.class);
			ret = (Integer) setPermissions.invoke(null, path,
				mode, -1, -1);
		}
		catch(Exception e)
		{
			ret = -1;
			Log.d(TAG, "chmod: FileUtils not worked: " + e.toString() );
		}
		return ret;
	 }

	 private static void extractFile(Context context, String path) 
	 {
		try
		{
			InputStream is = null;
			FileOutputStream os = null;
			is = context.getAssets().open(path);
			File out = new File(context.getFilesDir().getPath()+'/'+path);
			out.getParentFile().mkdirs();
			chmod( out.getParent(), 0777 );
			os = new FileOutputStream(out);
			byte[] buffer = new byte[1024];
			int length;
			while ((length = is.read(buffer)) > 0) 
			{
				os.write(buffer, 0, length);
			}
			os.close();
			is.close();
			chmod( context.getFilesDir().getPath()+'/'+path, 0777 );
		} 
		catch( Exception e )
		{
			Log.e( TAG, "Failed to extract file:" + e.toString() );
			e.printStackTrace();
		}
	 }

	public static void extractPAK(Context context, Boolean force) 
	{
		InputStream is = null;
		FileOutputStream os = null;
		try 
		{
			if( mPref == null )
				mPref = context.getSharedPreferences("mod", 0);
			
			if( mPref.getInt( "pakversion", 0 ) == PAK_VERSION && !force )
					return;
			extractFile(context, "extras.pak");
			SharedPreferences.Editor editor = mPref.edit();
			editor.putInt( "pakversion", PAK_VERSION );
			editor.commit();
		} 
		catch( Exception e )
		{
			Log.e( TAG, "Failed to extract PAK:" + e.toString() );
		}
	}
}


```

`android/update`:

```
#!/bin/bash

echo " ------- UPDATING SUBMODULES ------- "
git submodule foreach git pull origin master

```

`cl_dll/Android.mk`:

```mk
#hlsdk-2.3 client port for android
#Copyright (c) mittorn

LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE := client
APP_PLATFORM := android-8
LOCAL_CONLYFLAGS += -std=c99

include $(XASH3D_CONFIG)

ifeq ($(TARGET_ARCH_ABI),armeabi-v7a-hard)
LOCAL_MODULE_FILENAME = libclient_hardfp
endif

LOCAL_CFLAGS += -fsigned-char -DCLIENT_DLL=1 -DCLIENT_WEAPONS=1
LOCAL_CPPFLAGS += -std=c++0x
SRCS := \
	./cdll_int.cpp \
	./demo.cpp \
	./entity.cpp \
	./in_camera.cpp \
	./input.cpp \
	./rain.cpp \
	./tri.cpp \
	./util.cpp \
	./view.cpp \
	./input_xash3d.cpp \
	./vgui_parser.cpp \
	./unicode_strtools.cpp \
	./draw_util.cpp \
	../pm_shared/pm_debug.cpp \
	../pm_shared/pm_math.cpp \
	../pm_shared/pm_shared.cpp \
	./studio/GameStudioModelRenderer.cpp \
	./studio/StudioModelRenderer.cpp \
	./studio/studio_util.cpp \
	./hud/ammo.cpp \
	./hud/ammo_secondary.cpp \
	./hud/ammohistory.cpp \
	./hud/battery.cpp \
	./hud/geiger.cpp \
	./hud/health.cpp \
	./hud/hud.cpp \
	./hud/hud_msg.cpp \
	./hud/hud_redraw.cpp \
	./hud/hud_spectator.cpp \
	./hud/hud_update.cpp \
	./hud/sniperscope.cpp \
	./hud/nvg.cpp \
	./hud/menu.cpp \
	./hud/message.cpp \
	./hud/status_icons.cpp \
	./hud/statusbar.cpp \
	./hud/text_message.cpp \
	./hud/train.cpp \
	./hud/scoreboard.cpp \
	./hud/MOTD.cpp \
	./hud/radio.cpp \
	./hud/radar.cpp \
	./hud/timer.cpp \
	./hud/money.cpp \
	./hud/flashlight.cpp \
	./hud/death.cpp \
	./hud/saytext.cpp \
	./hud/spectator_gui.cpp \
	./com_weapons.cpp \
	./cs_wpn/cs_baseentity.cpp \
	./cs_wpn/cs_weapons.cpp \
	../dlls/wpn_shared/wpn_ak47.cpp \
	../dlls/wpn_shared/wpn_aug.cpp \
	../dlls/wpn_shared/wpn_awp.cpp \
	../dlls/wpn_shared/wpn_c4.cpp \
	../dlls/wpn_shared/wpn_deagle.cpp \
	../dlls/wpn_shared/wpn_elite.cpp \
	../dlls/wpn_shared/wpn_famas.cpp \
	../dlls/wpn_shared/wpn_fiveseven.cpp \
	../dlls/wpn_shared/wpn_flashbang.cpp \
	../dlls/wpn_shared/wpn_g3sg1.cpp \
	../dlls/wpn_shared/wpn_galil.cpp \
	../dlls/wpn_shared/wpn_glock18.cpp \
	../dlls/wpn_shared/wpn_hegrenade.cpp \
	../dlls/wpn_shared/wpn_knife.cpp \
	../dlls/wpn_shared/wpn_m249.cpp \
	../dlls/wpn_shared/wpn_m3.cpp \
	../dlls/wpn_shared/wpn_m4a1.cpp \
	../dlls/wpn_shared/wpn_mac10.cpp \
	../dlls/wpn_shared/wpn_mp5navy.cpp \
	../dlls/wpn_shared/wpn_p228.cpp \
	../dlls/wpn_shared/wpn_p90.cpp \
	../dlls/wpn_shared/wpn_scout.cpp \
	../dlls/wpn_shared/wpn_sg550.cpp \
	../dlls/wpn_shared/wpn_sg552.cpp \
	../dlls/wpn_shared/wpn_smokegrenade.cpp \
	../dlls/wpn_shared/wpn_tmp.cpp \
	../dlls/wpn_shared/wpn_ump45.cpp \
	../dlls/wpn_shared/wpn_usp.cpp \
	../dlls/wpn_shared/wpn_xm1014.cpp \
	./events/ev_cs16.cpp \
	./events/event_ak47.cpp \
	./events/event_aug.cpp \
	./events/event_awp.cpp \
	./events/event_createexplo.cpp \
	./events/event_createsmoke.cpp \
	./events/event_deagle.cpp \
	./events/event_decal_reset.cpp \
	./events/event_elite_left.cpp \
	./events/event_elite_right.cpp \
	./events/event_famas.cpp \
	./events/event_fiveseven.cpp \
	./events/event_g3sg1.cpp \
	./events/event_galil.cpp \
	./events/event_glock18.cpp \
	./events/event_knife.cpp \
	./events/event_m249.cpp \
	./events/event_m3.cpp \
	./events/event_m4a1.cpp \
	./events/event_mac10.cpp \
	./events/event_mp5n.cpp \
	./events/event_p228.cpp \
	./events/event_p90.cpp \
	./events/event_scout.cpp \
	./events/event_sg550.cpp \
	./events/event_sg552.cpp \
	./events/event_tmp.cpp \
	./events/event_ump45.cpp \
	./events/event_usp.cpp \
	./events/event_vehicle.cpp \
	./events/event_xm1014.cpp \
	./events/hl_events.cpp \
	./ev_common.cpp

DEFINES = -Wno-write-strings -DLINUX -D_LINUX -Dstricmp=strcasecmp -D_strnicmp=strncasecmp -Dstrnicmp=strncasecmp -DCLIENT_WEAPONS -DCLIENT_DLL -Wl,--no-undefined

LOCAL_C_INCLUDES := $(LOCAL_PATH) \
	$(LOCAL_PATH)/include \
	$(LOCAL_PATH)/include/hud \
	$(LOCAL_PATH)/include/studio \
	$(LOCAL_PATH)/include/math \
	$(LOCAL_PATH)/../common \
	$(LOCAL_PATH)/../engine \
	$(LOCAL_PATH)/../game_shared \
	$(LOCAL_PATH)/../dlls \
	$(LOCAL_PATH)/../pm_shared \
	$(LOCAL_PATH)/../public
LOCAL_CFLAGS += $(DEFINES)

LOCAL_SRC_FILES := $(SRCS)

include $(BUILD_SHARED_LIBRARY)

```

`cl_dll/CMakeLists.txt`:

```txt
#
# Copyright (c) 2015 Pavlo Lavrenenko
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

cmake_minimum_required(VERSION 2.6.0)
project (CLDLL)

# set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -pedantic")
if (APPLE)
set (CMAKE_C_FLAGS "${CMAKE_CXX_FLAGS} -march=native -Wall -Wextra -Wpedantic -Wno-unused-parameter -ggdb")
else()
set (CMAKE_C_FLAGS "${CMAKE_CXX_FLAGS} -march=native -Wall -Wextra -Wpedantic -Wno-unused-parameter -Wl,--no-undefined -ggdb")
endif()
set (CMAKE_C_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -ggdb")
set (CMAKE_C_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}  -O3")
set (CMAKE_C_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL} -Os")
set (CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -ggdb -O3")

if (APPLE)
set (CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=c++11 -stdlib=libc++")
else()
set (CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=c++11 -static-libstdc++")
endif()
set (CMAKE_CXX_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} ")
set (CMAKE_CXX_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}")
set (CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_C_FLAGS_MINSIZEREL} ")
set (CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELWITHDEBINFO} ")

# force build 32bit libraries
if(CMAKE_SIZEOF_VOID_P MATCHES "8")
    if(APPLE)
        SET(CMAKE_OSX_ARCHITECTURES "i386")
    else()
        SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -m32")
        SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32")
    endif()
endif()

#find_package(SDL2 REQUIRED)

set (CLDLL_LIBRARY client)

set (WEAPONEVENT_SRCS
	./events/ev_cs16.cpp
	./events/event_ak47.cpp
	./events/event_aug.cpp
	./events/event_awp.cpp
	./events/event_createexplo.cpp
	./events/event_createsmoke.cpp
	./events/event_deagle.cpp
	./events/event_decal_reset.cpp
	./events/event_elite_left.cpp
	./events/event_elite_right.cpp
	./events/event_famas.cpp
	./events/event_fiveseven.cpp
	./events/event_g3sg1.cpp
	./events/event_galil.cpp
	./events/event_glock18.cpp
	./events/event_knife.cpp
	./events/event_m249.cpp
	./events/event_m3.cpp
	./events/event_m4a1.cpp
	./events/event_mac10.cpp
	./events/event_mp5n.cpp
	./events/event_p228.cpp
	./events/event_p90.cpp
	./events/event_scout.cpp
	./events/event_sg550.cpp
	./events/event_sg552.cpp
	./events/event_tmp.cpp
	./events/event_ump45.cpp
	./events/event_usp.cpp
	./events/event_vehicle.cpp
	./events/event_xm1014.cpp
	./events/hl_events.cpp
	./ev_common.cpp
)

set (CLWEAPON_SRCS
	./com_weapons.cpp
	./cs_wpn/cs_baseentity.cpp
	./cs_wpn/cs_weapons.cpp
	../dlls/wpn_shared/wpn_ak47.cpp
	../dlls/wpn_shared/wpn_aug.cpp
	../dlls/wpn_shared/wpn_awp.cpp
	../dlls/wpn_shared/wpn_c4.cpp
	../dlls/wpn_shared/wpn_deagle.cpp
	../dlls/wpn_shared/wpn_elite.cpp
	../dlls/wpn_shared/wpn_famas.cpp
	../dlls/wpn_shared/wpn_fiveseven.cpp
	../dlls/wpn_shared/wpn_flashbang.cpp
	../dlls/wpn_shared/wpn_g3sg1.cpp
	../dlls/wpn_shared/wpn_galil.cpp
	../dlls/wpn_shared/wpn_glock18.cpp
	../dlls/wpn_shared/wpn_hegrenade.cpp
	../dlls/wpn_shared/wpn_knife.cpp
	../dlls/wpn_shared/wpn_m249.cpp
	../dlls/wpn_shared/wpn_m3.cpp
	../dlls/wpn_shared/wpn_m4a1.cpp
	../dlls/wpn_shared/wpn_mac10.cpp
	../dlls/wpn_shared/wpn_mp5navy.cpp
	../dlls/wpn_shared/wpn_p228.cpp
	../dlls/wpn_shared/wpn_p90.cpp
	../dlls/wpn_shared/wpn_scout.cpp
	../dlls/wpn_shared/wpn_sg550.cpp
	../dlls/wpn_shared/wpn_sg552.cpp
	../dlls/wpn_shared/wpn_smokegrenade.cpp
	../dlls/wpn_shared/wpn_tmp.cpp
	../dlls/wpn_shared/wpn_ump45.cpp
	../dlls/wpn_shared/wpn_usp.cpp
	../dlls/wpn_shared/wpn_xm1014.cpp
)

set (HUD_SRCS
	./hud/ammo.cpp
	./hud/ammo_secondary.cpp
	./hud/ammohistory.cpp
	./hud/battery.cpp
	./hud/geiger.cpp
	./hud/health.cpp
	./hud/hud.cpp
	./hud/hud_msg.cpp
	./hud/hud_redraw.cpp
	./hud/hud_spectator.cpp
	./hud/hud_update.cpp
	./hud/sniperscope.cpp
	./hud/nvg.cpp
	./hud/menu.cpp
	./hud/message.cpp
	./hud/status_icons.cpp
	./hud/statusbar.cpp
	./hud/text_message.cpp
	./hud/train.cpp
	./hud/scoreboard.cpp
	./hud/MOTD.cpp
	./hud/radio.cpp
	./hud/radar.cpp
	./hud/timer.cpp
	./hud/money.cpp
	./hud/flashlight.cpp
	./hud/death.cpp
	./hud/saytext.cpp
	./hud/spectator_gui.cpp
	./include/hud/ammo.h
	./include/hud/ammohistory.h
	./include/hud/health.h
	./include/hud/hud.h
	./include/hud/hud_iface.h
	./include/hud/hud_spectator.h
	./include/hud/radar.h
)

set (STUDIORENDER_SRCS
	./studio/GameStudioModelRenderer.cpp
	./studio/StudioModelRenderer.cpp
	./studio/studio_util.cpp

	./include/studio/GameStudioModelRenderer.h
	./include/studio/StudioModelRenderer.h
	./include/studio/studio_util.h

)

set (PLAYERMOVE_SRCS
	../pm_shared/pm_debug.cpp
	../pm_shared/pm_math.cpp
	../pm_shared/pm_shared.cpp
)

set (CLDLL_SOURCES
	./cdll_int.cpp
    ./demo.cpp
    ./entity.cpp
    ./in_camera.cpp
    ./input.cpp
	./rain.cpp
    ./tri.cpp
	./util.cpp
	./view.cpp
	./input_xash3d.cpp
	#./input_sdl.cpp
    ./vgui_parser.cpp
    ./unicode_strtools.cpp
	./draw_util.cpp
	./include/camera.h
	./include/cl_dll.h
	./include/cl_util.h
	./include/com_weapons.h
	./include/csprite.h
	./include/demo.h
	./include/draw_util.h
	./include/eventscripts.h
	./include/events.h
	./include/ev_hldm.h
	./include/overview.h
	./include/parsemsg.h
	./include/rain.h
	./include/tf_defs.h
	./include/unicode_strtools.h
	./include/util_vector.h
	./include/vgui_parser.h
	./include/view.h
	./include/wrect.h
	./include/math/neon_mathfun.h
	./include/math/sse_mathfun.h

	${PLAYERMOVE_SRCS}
	${HUD_SRCS}
	${WEAPONEVENT_SRCS}
	${CLWEAPON_SRCS}
	${STUDIORENDER_SRCS}
)

include_directories (
	include/
	include/hud/
	include/studio/
	include/math/
	../cl_dll/
	../common/
	../engine/
	../pm_shared/
	../dlls/
	../game_shared/
	../public/
	${SDL2_INCLUDE_DIR})
add_library (${CLDLL_LIBRARY} SHARED ${CLDLL_SOURCES})
add_definitions( -D_CS16CLIENT_ENABLE_GSRC_SUPPORT
	-DLINUX -D_LINUX -DCLIENT_WEAPONS -DCLIENT_DLL
	-D_DEBUG  -D_CS16CLIENT_ALLOW_SPECIAL_SCRIPTING
	-Dstricmp=strcasecmp -D_strnicmp=strncasecmp -Dstrnicmp=strncasecmp )

target_link_libraries( ${CLDLL_LIBRARY} ${CMAKE_DL_LIBS} ${SDL2_LIBRARY} )


set_target_properties (${CLDLL_SHARED} PROPERTIES
	VERSION 1.6 SOVERSION 1.6
	POSITION_INDEPENDENT_CODE 1)

```

`cl_dll/Makefile`:

```
CC= gcc -m32
CXX = g++ -m32
SRCS+=../dlls/crossbow.cpp
SRCS+=../dlls/crowbar.cpp
SRCS+=../dlls/egon.cpp
SRCS+=./ev_hldm.cpp
SRCS+=../dlls/gauss.cpp
SRCS+=../dlls/handgrenade.cpp
SRCS+=./hl/hl_baseentity.cpp
SRCS+=./hl/hl_events.cpp
SRCS+=./hl/hl_objects.cpp
SRCS+=./hl/hl_weapons.cpp
SRCS+=../dlls/wpn_shared/hl_wpn_glock.cpp
SRCS+=../dlls/hornetgun.cpp
SRCS+=../common/interface.cpp
SRCS+=../dlls/mp5.cpp
SRCS+=../dlls/python.cpp
SRCS+=../dlls/rpg.cpp
SRCS+=../dlls/satchel.cpp
SRCS+=../dlls/shotgun.cpp
SRCS+=../dlls/squeakgrenade.cpp
SRCS+=../dlls/tripmine.cpp
#SRCS+=../game_shared/voice_banmgr.cpp
#SRCS+=../game_shared/voice_status.cpp
SRCS+=./ammo.cpp
SRCS+=./ammo_secondary.cpp
SRCS+=./ammohistory.cpp
SRCS+=./battery.cpp
SRCS+=./cdll_int.cpp
SRCS+=./com_weapons.cpp
SRCS+=./death.cpp
SRCS+=./demo.cpp
SRCS+=./entity.cpp
SRCS+=./ev_common.cpp
SRCS+=./events.cpp
SRCS+=./flashlight.cpp
SRCS+=./GameStudioModelRenderer.cpp
SRCS+=./geiger.cpp
SRCS+=./health.cpp
SRCS+=./hud.cpp
SRCS+=./hud_msg.cpp
SRCS+=./hud_redraw.cpp
#SRCS+=./hud_servers.cpp
SRCS+=./hud_spectator.cpp
SRCS+=./hud_update.cpp
SRCS+=./in_camera.cpp
SRCS+=./input.cpp
#SRCS+=./inputw32.cpp
SRCS+=./menu.cpp
SRCS+=./message.cpp
SRCS+=./overview.cpp
SRCS+=./parsemsg.cpp
SRCS_C+=../pm_shared/pm_debug.c
SRCS_C+=../pm_shared/pm_math.c
SRCS_C+=../pm_shared/pm_shared.c
SRCS+=./saytext.cpp
SRCS+=./status_icons.cpp
SRCS+=./statusbar.cpp
SRCS+=./studio_util.cpp
SRCS+=./StudioModelRenderer.cpp
SRCS+=./text_message.cpp
SRCS+=./train.cpp
SRCS+=./tri.cpp
SRCS+=./util.cpp
SRCS+=./view.cpp
SRCS+=./input_xash3d.cpp
SRCS+=./scoreboard.cpp
SRCS+=./MOTD.cpp
INCLUDES =  -I../common -I. -I../game_shared -I../pm_shared -I../engine -I../dlls
DEFINES = -Wno-write-strings -DLINUX -D_LINUX -Dstricmp=strcasecmp -D_strnicmp=strncasecmp -Dstrnicmp=strncasecmp -DCLIENT_WEAPONS -DCLIENT_DLL -fpermissive -w
CFLAGS = -Og -ggdb
OBJS = $(SRCS:.cpp=.o) $(SRCS_C:.c=.o)
%.o : %.c
	$(CC) $(CFLAGS) $(INCLUDES) $(DEFINES) -fPIC -c $< -o $@

%.o : %.cpp
	$(CXX) $(CFLAGS) $(INCLUDES) $(DEFINES) -fPIC -c $< -o $@
client.so : $(OBJS)
	$(CXX) $(OBJS) -o client.so -shared -Wl,--no-undefined -fPIC -lm -ldl

clean:
	$(RM) $(OBJS)

```

`cl_dll/Makefile.mingw`:

```mingw
CC= gcc -m32
CXX = g++ -m32
SRCS := \
	./cdll_int.cpp \
	./demo.cpp \
	./entity.cpp \
	./in_camera.cpp \
	./input.cpp \
	./rain.cpp \
	./tri.cpp \
	./util.cpp \
	./view.cpp \
	./input_xash3d.cpp \
	./vgui_parser.cpp \
	./unicode_strtools.cpp \
	./draw_util.cpp \
	./studio/GameStudioModelRenderer.cpp \
	./studio/StudioModelRenderer.cpp \
	./studio/studio_util.cpp \
	./hud/ammo.cpp \
	./hud/ammo_secondary.cpp \
	./hud/ammohistory.cpp \
	./hud/battery.cpp \
	./hud/geiger.cpp \
	./hud/health.cpp \
	./hud/hud.cpp \
	./hud/hud_msg.cpp \
	./hud/hud_redraw.cpp \
	./hud/hud_spectator.cpp \
	./hud/hud_update.cpp \
	./hud/sniperscope.cpp \
	./hud/nvg.cpp \
	./hud/menu.cpp \
	./hud/message.cpp \
	./hud/status_icons.cpp \
	./hud/statusbar.cpp \
	./hud/text_message.cpp \
	./hud/train.cpp \
	./hud/scoreboard.cpp \
	./hud/MOTD.cpp \
	./hud/radio.cpp \
	./hud/radar.cpp \
	./hud/timer.cpp \
	./hud/money.cpp \
	./hud/flashlight.cpp \
	./hud/death.cpp \
	./hud/saytext.cpp \
	./hud/spectator_gui.cpp \
	./com_weapons.cpp \
	./cs_wpn/cs_baseentity.cpp \
	./cs_wpn/cs_weapons.cpp \
	../dlls/wpn_shared/wpn_ak47.cpp \
	../dlls/wpn_shared/wpn_aug.cpp \
	../dlls/wpn_shared/wpn_awp.cpp \
	../dlls/wpn_shared/wpn_c4.cpp \
	../dlls/wpn_shared/wpn_deagle.cpp \
	../dlls/wpn_shared/wpn_elite.cpp \
	../dlls/wpn_shared/wpn_famas.cpp \
	../dlls/wpn_shared/wpn_fiveseven.cpp \
	../dlls/wpn_shared/wpn_flashbang.cpp \
	../dlls/wpn_shared/wpn_g3sg1.cpp \
	../dlls/wpn_shared/wpn_galil.cpp \
	../dlls/wpn_shared/wpn_glock18.cpp \
	../dlls/wpn_shared/wpn_hegrenade.cpp \
	../dlls/wpn_shared/wpn_knife.cpp \
	../dlls/wpn_shared/wpn_m249.cpp \
	../dlls/wpn_shared/wpn_m3.cpp \
	../dlls/wpn_shared/wpn_m4a1.cpp \
	../dlls/wpn_shared/wpn_mac10.cpp \
	../dlls/wpn_shared/wpn_mp5navy.cpp \
	../dlls/wpn_shared/wpn_p228.cpp \
	../dlls/wpn_shared/wpn_p90.cpp \
	../dlls/wpn_shared/wpn_scout.cpp \
	../dlls/wpn_shared/wpn_sg550.cpp \
	../dlls/wpn_shared/wpn_sg552.cpp \
	../dlls/wpn_shared/wpn_smokegrenade.cpp \
	../dlls/wpn_shared/wpn_tmp.cpp \
	../dlls/wpn_shared/wpn_ump45.cpp \
	../dlls/wpn_shared/wpn_usp.cpp \
	../dlls/wpn_shared/wpn_xm1014.cpp \
	./events/ev_cs16.cpp \
	./events/event_ak47.cpp \
	./events/event_aug.cpp \
	./events/event_awp.cpp \
	./events/event_createexplo.cpp \
	./events/event_createsmoke.cpp \
	./events/event_deagle.cpp \
	./events/event_decal_reset.cpp \
	./events/event_elite_left.cpp \
	./events/event_elite_right.cpp \
	./events/event_famas.cpp \
	./events/event_fiveseven.cpp \
	./events/event_g3sg1.cpp \
	./events/event_galil.cpp \
	./events/event_glock18.cpp \
	./events/event_knife.cpp \
	./events/event_m249.cpp \
	./events/event_m3.cpp \
	./events/event_m4a1.cpp \
	./events/event_mac10.cpp \
	./events/event_mp5n.cpp \
	./events/event_p228.cpp \
	./events/event_p90.cpp \
	./events/event_scout.cpp \
	./events/event_sg550.cpp \
	./events/event_sg552.cpp \
	./events/event_tmp.cpp \
	./events/event_ump45.cpp \
	./events/event_usp.cpp \
	./events/event_vehicle.cpp \
	./events/event_xm1014.cpp \
	./events/hl_events.cpp \
	./ev_common.cpp \
	../pm_shared/pm_debug.cpp \
	../pm_shared/pm_math.cpp \
	../pm_shared/pm_shared.cpp 

INCLUDES =  -Iinclude -Iinclude/hud -Iinclude/studio -Iinclude/math -I../common -I. -I../game_shared -I../pm_shared -I../engine -I../dlls -I../public
DEFINES = -Wno-write-strings -DCLIENT_DLL=1 -DCLIENT_WEAPONS=1
CFLAGS = -Og -ggdb
OBJS = $(SRCS:.cpp=.o)

%.o : %.cpp
	$(CXX) $(CFLAGS) -std=gnu++11 $(INCLUDES) $(DEFINES) -fpermissive -c $< -o $@
client.dll : $(OBJS)
	g++ -static-libgcc -static-libstdc++ -shared -Wl,--add-stdcall-alias -o client.dll $(OBJS)
#$(CXX) $(OBJS) -shared -o client.dll -Wl,--no-undefined -lm
clean:
	$(RM) $(OBJS)

```

`cl_dll/cdll_int.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_int.c
//
// this implementation handles the linking of the engine to the DLL
//

#include "hud.h"
#include "cl_util.h"
#include "netadr.h"
#include "pmtrace.h"

#include "pm_shared.h"

#include <string.h>
//#include "interface.h" // not used here
#include "render_api.h"
#include "mobility_int.h"
#include "vgui_parser.h"

cl_enginefunc_t gEngfuncs = { };
render_api_t gRenderAPI = { };
mobile_engfuncs_t gMobileAPI = { };
CHud gHUD;
int g_iXash = 0; // indicates a buildnum
int g_iMobileAPIVersion = 0;

void InitInput (void);
void Game_HookEvents( void );
void IN_Commands( void );
void Input_Shutdown (void);

/*
========================== 
    Initialize

Called when the DLL is first loaded.
==========================
*/
int DLLEXPORT Initialize( cl_enginefunc_t *pEnginefuncs, int iVersion )
{
	if (iVersion != CLDLL_INTERFACE_VERSION)
		return 0;

	gEngfuncs = *pEnginefuncs;

	g_iXash = (int)CVAR_GET_FLOAT("build");

	Game_HookEvents();

	return 1;
}


/*
=============
HUD_Shutdown

=============
*/
void DLLEXPORT HUD_Shutdown( void )
{
	gHUD.Shutdown();
	Input_Shutdown();
	Localize_Free();
}


/*
================================
HUD_GetHullBounds

  Engine calls this to enumerate player collision hulls, for prediction.  Return 0 if the hullnumber doesn't exist.
================================
*/
int DLLEXPORT HUD_GetHullBounds( int hullnumber, float *mins, float *maxs )
{
	int iret = 0;

	switch ( hullnumber )
	{
	case 0:				// Normal player
		Vector(-16, -16, -36).CopyToArray(mins);
		Vector(16, 16, 36).CopyToArray(maxs);
		iret = 1;
		break;
	case 1:				// Crouched player
		Vector(-16, -16, -18).CopyToArray(mins);
		Vector(16, 16, 18).CopyToArray(maxs);
		iret = 1;
		break;
	case 2:				// Point based hull
		Vector(0, 0, 0).CopyToArray(mins);
		Vector(0, 0, 0).CopyToArray(maxs);
		iret = 1;
		break;
	}

	return iret;
}

/*
================================
HUD_ConnectionlessPacket

 Return 1 if the packet is valid.  Set response_buffer_size if you want to send a response packet.  Incoming, it holds the max
  size of the response_buffer, so you must zero it out if you choose not to respond.
================================
*/
int	DLLEXPORT HUD_ConnectionlessPacket( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size )
{
	// Parse stuff from args
	// int max_buffer_size = *response_buffer_size;

	// Zero it out since we aren't going to respond.
	// If we wanted to response, we'd write data into response_buffer
	*response_buffer_size = 0;

	// Since we don't listen for anything here, just respond that it's a bogus message
	// If we didn't reject the message, we'd return 1 for success instead.
	return 0;
}

void DLLEXPORT HUD_PlayerMoveInit( struct playermove_s *ppmove )
{
	PM_Init( ppmove );
}

char DLLEXPORT HUD_PlayerMoveTexture( char *name )
{
	return PM_FindTextureType( name );
}

void DLLEXPORT HUD_PlayerMove( struct playermove_s *ppmove, int server )
{
	PM_Move( ppmove, server );
}

#ifdef _CS16CLIENT_ENABLE_GSRC_SUPPORT
/*
=================
HUD_GetRect

VGui stub
=================
*/
int *HUD_GetRect( void )
{
	static int extent[4];

	extent[0] = gEngfuncs.GetWindowCenterX() - ScreenWidth / 2;
	extent[1] = gEngfuncs.GetWindowCenterY() - ScreenHeight / 2;
	extent[2] = gEngfuncs.GetWindowCenterX() + ScreenWidth / 2;
	extent[3] = gEngfuncs.GetWindowCenterY() + ScreenHeight / 2;

	return extent;
}
#endif

/*
==========================
	HUD_VidInit

Called when the game initializes
and whenever the vid_mode is changed
so the HUD can reinitialize itself.
==========================
*/

bool isLoaded = false;

int DLLEXPORT HUD_VidInit( void )
{
	gHUD.VidInit();

	isLoaded = true;

	//VGui_Startup();

	return 1;
}

/*
==========================
	HUD_Init

Called whenever the client connects
to a server.  Reinitializes all 
the hud variables.
==========================
*/

void DLLEXPORT HUD_Init( void )
{
	InitInput();
	gHUD.Init();
	//Scheme_Init();
}


/*
==========================
	HUD_Redraw

called every screen frame to
redraw the HUD.
===========================
*/

int DLLEXPORT HUD_Redraw( float time, int intermission )
{
	gHUD.Redraw( time, intermission );

	return 1;
}


/*
==========================
	HUD_UpdateClientData

called every time shared client
dll/engine data gets changed,
and gives the cdll a chance
to modify the data.

returns 1 if anything has been changed, 0 otherwise.
==========================
*/

int DLLEXPORT HUD_UpdateClientData(client_data_t *pcldata, float flTime )
{
	IN_Commands();

	return gHUD.UpdateClientData(pcldata, flTime );
}

/*
==========================
	HUD_Reset

Called at start and end of demos to restore to "non"HUD state.
==========================
*/

void DLLEXPORT HUD_Reset( void )
{
	gHUD.VidInit();
}

/*
==========================
HUD_Frame

Called by engine every frame that client .dll is loaded
==========================
*/

void DLLEXPORT HUD_Frame( double time )
{
#ifdef _CS16CLIENT_ENABLE_GSRC_SUPPORT
	gEngfuncs.VGui_ViewportPaintBackground(HUD_GetRect());
#endif
}


/*
==========================
HUD_VoiceStatus

Called when a player starts or stops talking.
==========================
*/

void DLLEXPORT HUD_VoiceStatus(int entindex, qboolean bTalking)
{
	gHUD.m_Radio.Voice( entindex, bTalking );
}

/*
==========================
HUD_DirectorEvent

Called when a director event message was received
==========================
*/

void DLLEXPORT HUD_DirectorMessage( int iSize, void *pbuf )
{
	 gHUD.m_Spectator.DirectorMessage( iSize, pbuf );
}

/*
==========================
HUD_GetRenderInterface

Called when Xash3D sends render api to us
==========================
*/

int DLLEXPORT HUD_GetRenderInterface( int version, render_api_t *renderfuncs, render_interface_t *callback )
{
	if( version != CL_RENDER_INTERFACE_VERSION )
	{
		return false;
	}

	gRenderAPI = *renderfuncs;

	// we didn't send callbacks to engine, because we don't use it
	// *callback = renderInterface;

	// we have here a Host_Error, so check Xash for version
#ifdef __ANDROID__
	if( g_iXash < 3224 )
	{
		gRenderAPI.Host_Error("Xash3D Android version check failed!\nPlease update your Xash3D Android!\n");
	}
#endif

	return true;
}

/*
========================
HUD_MobilityInterface
========================
*/
int DLLEXPORT HUD_MobilityInterface( mobile_engfuncs_t *mobileapi )
{
	if( mobileapi->version != MOBILITY_API_VERSION )
	{
		gEngfuncs.Con_Printf("Client Error: Mobile API version mismatch. Got: %i, want: %i\n",
			mobileapi->version, MOBILITY_API_VERSION);

#ifdef __ANDROID__
		if( gRenderAPI.Host_Error )
		{
			gRenderAPI.Host_Error("Xash3D Android version check failed!\nPlease update your Xash3D Android!\n");
		}
#endif
		return 1;
	}

	g_iMobileAPIVersion = MOBILITY_API_VERSION;
	gMobileAPI = *mobileapi;

	return 0;
}

```

`cl_dll/cl_dll.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="cl_dll" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102

CFG=cl_dll - Win32 Release
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "cl_dll.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "cl_dll.mak" CFG="cl_dll - Win32 Release"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "cl_dll - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE "cl_dll - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
MTL=midl.exe
RSC=rc.exe

!IF  "$(CFG)" == "cl_dll - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir ".\Release"
# PROP BASE Intermediate_Dir ".\Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir ".\Release"
# PROP Intermediate_Dir ".\Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /c
# ADD CPP /nologo /MT /W3 /GX /Zi /O2 /I "..\utils\vgui\include" /I "..\engine" /I "..\common" /I "..\pm_shared" /I "..\dlls" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "CLIENT_DLL" /D "CLIENT_WEAPONS" /YX /FD /c
# ADD BASE MTL /nologo /D "NDEBUG" /win32
# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x409 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib winmm.lib ../utils/vgui/lib/win32_vc6/vgui.lib wsock32.lib /nologo /subsystem:windows /dll /map /machine:I386 /out:".\Release\client.dll"

!ELSEIF  "$(CFG)" == "cl_dll - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir ".\Debug"
# PROP BASE Intermediate_Dir ".\Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir ".\Debug"
# PROP Intermediate_Dir ".\Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /c
# ADD CPP /nologo /G5 /MTd /W3 /Gm /GR /GX /ZI /Od /I "..\dlls" /I "..\common" /I "..\pm_shared" /I "..\engine" /I "..\utils\vgui\include" /I "..\game_shared" /D "_DEBUG" /D "_MBCS" /D "WIN32" /D "_WINDOWS" /D "CLIENT_DLL" /D "CLIENT_WEAPONS" /FR /YX /FD /c
# ADD BASE MTL /nologo /D "_DEBUG" /win32
# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x409 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386
# ADD LINK32 oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib winmm.lib ../utils/vgui/lib/win32_vc6/vgui.lib wsock32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:".\Debug\client.dll"

!ENDIF 

# Begin Target

# Name "cl_dll - Win32 Release"
# Name "cl_dll - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat;for;f90"
# Begin Group "hl"

# PROP Default_Filter "*.CPP"
# Begin Source File

SOURCE=..\dlls\crossbow.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\crowbar.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\egon.cpp
# End Source File
# Begin Source File

SOURCE=.\ev_hldm.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\gauss.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\handgrenade.cpp
# End Source File
# Begin Source File

SOURCE=.\hl\hl_baseentity.cpp
# End Source File
# Begin Source File

SOURCE=.\hl\hl_events.cpp
# End Source File
# Begin Source File

SOURCE=.\hl\hl_objects.cpp
# End Source File
# Begin Source File

SOURCE=.\hl\hl_weapons.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\wpn_shared\hl_wpn_glock.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\hornetgun.cpp
# End Source File
# Begin Source File

SOURCE=..\common\interface.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\mp5.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\python.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\rpg.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\satchel.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\shotgun.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\squeakgrenade.cpp
# End Source File
# Begin Source File

SOURCE=..\dlls\tripmine.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_scrollbar2.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_slider2.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_banmgr.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_status.cpp
# End Source File
# End Group
# Begin Source File

SOURCE=.\ammo.cpp
# End Source File
# Begin Source File

SOURCE=.\ammo_secondary.cpp
# End Source File
# Begin Source File

SOURCE=.\ammohistory.cpp
# End Source File
# Begin Source File

SOURCE=.\battery.cpp
# End Source File
# Begin Source File

SOURCE=.\cdll_int.cpp
# End Source File
# Begin Source File

SOURCE=.\com_weapons.cpp
# End Source File
# Begin Source File

SOURCE=.\death.cpp
# End Source File
# Begin Source File

SOURCE=.\demo.cpp
# End Source File
# Begin Source File

SOURCE=.\entity.cpp
# End Source File
# Begin Source File

SOURCE=.\ev_common.cpp
# End Source File
# Begin Source File

SOURCE=.\events.cpp
# End Source File
# Begin Source File

SOURCE=.\flashlight.cpp
# End Source File
# Begin Source File

SOURCE=.\GameStudioModelRenderer.cpp
# End Source File
# Begin Source File

SOURCE=.\geiger.cpp
# End Source File
# Begin Source File

SOURCE=.\health.cpp
# End Source File
# Begin Source File

SOURCE=.\hud.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_msg.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_redraw.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_servers.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_spectator.cpp
# End Source File
# Begin Source File

SOURCE=.\hud_update.cpp
# End Source File
# Begin Source File

SOURCE=.\in_camera.cpp
# End Source File
# Begin Source File

SOURCE=.\input.cpp
# End Source File
# Begin Source File

SOURCE=.\inputw32.cpp
# End Source File
# Begin Source File

SOURCE=.\menu.cpp
# End Source File
# Begin Source File

SOURCE=.\message.cpp
# End Source File
# Begin Source File

SOURCE=.\overview.cpp
# PROP Exclude_From_Build 1
# End Source File
# Begin Source File

SOURCE=.\parsemsg.cpp
# End Source File
# Begin Source File

SOURCE=.\parsemsg.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_debug.c
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_math.c
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_shared.c
# End Source File
# Begin Source File

SOURCE=.\saytext.cpp
# End Source File
# Begin Source File

SOURCE=.\status_icons.cpp
# End Source File
# Begin Source File

SOURCE=.\statusbar.cpp
# End Source File
# Begin Source File

SOURCE=.\studio_util.cpp
# End Source File
# Begin Source File

SOURCE=.\StudioModelRenderer.cpp
# End Source File
# Begin Source File

SOURCE=.\text_message.cpp
# End Source File
# Begin Source File

SOURCE=.\train.cpp
# End Source File
# Begin Source File

SOURCE=.\tri.cpp
# End Source File
# Begin Source File

SOURCE=.\util.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_checkbutton2.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ClassMenu.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ConsolePanel.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ControlConfigPanel.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_CustomObjects.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_grid.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_helpers.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_int.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_listbox.cpp
# End Source File
# Begin Source File

SOURCE=..\game_shared\vgui_loadtga.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_MOTDWindow.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_SchemeManager.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ScorePanel.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_ServerBrowser.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_SpectatorPanel.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_TeamFortressViewport.cpp
# End Source File
# Begin Source File

SOURCE=.\vgui_teammenu.cpp
# End Source File
# Begin Source File

SOURCE=.\view.cpp
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl;fi;fd"
# Begin Source File

SOURCE=.\ammo.h
# End Source File
# Begin Source File

SOURCE=.\ammohistory.h
# End Source File
# Begin Source File

SOURCE=.\camera.h
# End Source File
# Begin Source File

SOURCE=.\cl_dll.h
# End Source File
# Begin Source File

SOURCE=.\com_weapons.h
# End Source File
# Begin Source File

SOURCE=.\demo.h
# End Source File
# Begin Source File

SOURCE=.\ev_hldm.h
# End Source File
# Begin Source File

SOURCE=.\eventscripts.h
# End Source File
# Begin Source File

SOURCE=.\GameStudioModelRenderer.h
# End Source File
# Begin Source File

SOURCE=.\health.h
# End Source File
# Begin Source File

SOURCE=.\hud.h
# End Source File
# Begin Source File

SOURCE=.\hud_iface.h
# End Source File
# Begin Source File

SOURCE=.\hud_servers.h
# End Source File
# Begin Source File

SOURCE=.\hud_servers_priv.h
# End Source File
# Begin Source File

SOURCE=.\hud_spectator.h
# End Source File
# Begin Source File

SOURCE=.\in_defs.h
# End Source File
# Begin Source File

SOURCE=..\common\itrackeruser.h
# End Source File
# Begin Source File

SOURCE=.\kbutton.h
# End Source File
# Begin Source File

SOURCE=.\overview.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_debug.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_defs.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_info.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_materials.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_movevars.h
# End Source File
# Begin Source File

SOURCE=..\pm_shared\pm_shared.h
# End Source File
# Begin Source File

SOURCE=.\studio_util.h
# End Source File
# Begin Source File

SOURCE=.\StudioModelRenderer.h
# End Source File
# Begin Source File

SOURCE=.\util.h
# End Source File
# Begin Source File

SOURCE=.\util_vector.h
# End Source File
# Begin Source File

SOURCE=.\vgui_ConsolePanel.h
# End Source File
# Begin Source File

SOURCE=.\vgui_ControlConfigPanel.h
# End Source File
# Begin Source File

SOURCE=.\vgui_int.h
# End Source File
# Begin Source File

SOURCE=.\vgui_SchemeManager.h
# End Source File
# Begin Source File

SOURCE=.\vgui_ScorePanel.h
# End Source File
# Begin Source File

SOURCE=.\vgui_ServerBrowser.h
# End Source File
# Begin Source File

SOURCE=.\vgui_SpectatorPanel.h
# End Source File
# Begin Source File

SOURCE=.\vgui_TeamFortressViewport.h
# End Source File
# Begin Source File

SOURCE=.\view.h
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_banmgr.h
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_status.h
# End Source File
# Begin Source File

SOURCE=..\game_shared\voice_vgui_tweakdlg.h
# End Source File
# Begin Source File

SOURCE=.\wrect.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`cl_dll/com_weapons.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Com_Weapons.cpp
// Shared weapons common/shared functions
#include <stdarg.h>
#include "hud.h"
#include "cl_util.h"
#include "com_weapons.h"

#include "const.h"
#include "entity_state.h"
#include "r_efx.h"

// g_runfuncs is true if this is the first time we've "predicated" a particular movement/firing
//  command.  If it is 1, then we should play events/sounds etc., otherwise, we just will be
//  updating state info, but not firing events
int	g_runfuncs = 0;

// During our weapon prediction processing, we'll need to reference some data that is part of
//  the final state passed into the postthink functionality.  We'll set this pointer and then
//  reset it to NULL as appropriate
struct local_state_s *g_finalstate = NULL;

/*
====================
COM_Log

Log debug messages to file ( appends )
====================
*/
void COM_Log( char *pszFile, char *fmt, ...)
{
	va_list		argptr;
	char		string[1024];
	FILE *fp;
	const char *pfilename;
	
	if ( !pszFile )
	{
		pfilename = "c:\\hllog.txt";
	}
	else
	{
		pfilename = pszFile;
	}

	va_start (argptr,fmt);
	vsprintf (string, fmt,argptr);
	va_end (argptr);

	fp = fopen( pfilename, "a+t");
	if (fp)
	{
		fprintf(fp, "%s", string);
		fclose(fp);
	}
}

// remember the current animation for the view model, in case we get out of sync with
//  server.
static int g_currentanim;
static int g_currentweapon;

/*
=====================
HUD_SendWeaponAnim

Change weapon model animation
=====================
*/
void HUD_SendWeaponAnim( int iAnim, int iWeaponId, int iBody, int iForce )
{
	if( g_runfuncs || iForce )
	{
		g_currentanim = iAnim;
		g_currentweapon = iWeaponId;

		// Tell animation system new info
		gEngfuncs.pfnWeaponAnim( iAnim, iBody );
	}
}

/*
=====================
HUD_GetWeaponAnim

Retrieve current predicted weapon animation
=====================
*/
int HUD_GetWeaponAnim( void )
{
	return g_currentanim;
}

/*
=====================
HUD_GetWeapon

Retrieve current predicted weapon id
=====================
*/
int HUD_GetWeapon( void )
{
	return g_currentweapon;
}

/*
=====================
HUD_PlaySound

Play a sound, if we are seeing this command for the first time
=====================
*/
void HUD_PlaySound( char *sound, float volume )
{
	if ( !g_runfuncs || !g_finalstate )
		return;

	gEngfuncs.pfnPlaySoundByNameAtLocation( sound, volume, (float *)&g_finalstate->playerstate.origin );
}

/*
=====================
HUD_PlaybackEvent

Directly queue up an event on the client
=====================
*/
void HUD_PlaybackEvent( int flags, const edict_t *pInvoker, unsigned short eventindex, float delay,
	float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 )
{
	if ( !g_runfuncs || !g_finalstate )
	     return;

	Vector org;
	Vector ang;

	// Weapon prediction events are assumed to occur at the player's origin
	org	= g_finalstate->playerstate.origin;
	ang	= v_angles;
	gEngfuncs.pfnPlaybackEvent( flags, pInvoker, eventindex, delay, org, ang,
								fparam1, fparam2,
								iparam1, iparam2,
								bparam1, bparam2 );
}

/*
=====================
UTIL_WeaponTimeBase

Always 0.0 on client, even if not predicting weapons ( won't get called
 in that case )
=====================
*/
/*
moved in util.h

float UTIL_WeaponTimeBase( void )
{
	return 0.0;
}
*/

static unsigned int glSeed = 0; 

unsigned int seed_table[ 256 ] =
{
	28985, 27138, 26457, 9451, 17764, 10909, 28790, 8716, 6361, 4853, 17798, 21977, 19643, 20662, 10834, 20103,
	27067, 28634, 18623, 25849, 8576, 26234, 23887, 18228, 32587, 4836, 3306, 1811, 3035, 24559, 18399, 315,
	26766, 907, 24102, 12370, 9674, 2972, 10472, 16492, 22683, 11529, 27968, 30406, 13213, 2319, 23620, 16823,
	10013, 23772, 21567, 1251, 19579, 20313, 18241, 30130, 8402, 20807, 27354, 7169, 21211, 17293, 5410, 19223,
	10255, 22480, 27388, 9946, 15628, 24389, 17308, 2370, 9530, 31683, 25927, 23567, 11694, 26397, 32602, 15031,
	18255, 17582, 1422, 28835, 23607, 12597, 20602, 10138, 5212, 1252, 10074, 23166, 19823, 31667, 5902, 24630,
	18948, 14330, 14950, 8939, 23540, 21311, 22428, 22391, 3583, 29004, 30498, 18714, 4278, 2437, 22430, 3439,
	28313, 23161, 25396, 13471, 19324, 15287, 2563, 18901, 13103, 16867, 9714, 14322, 15197, 26889, 19372, 26241,
	31925, 14640, 11497, 8941, 10056, 6451, 28656, 10737, 13874, 17356, 8281, 25937, 1661, 4850, 7448, 12744,
	21826, 5477, 10167, 16705, 26897, 8839, 30947, 27978, 27283, 24685, 32298, 3525, 12398, 28726, 9475, 10208,
	617, 13467, 22287, 2376, 6097, 26312, 2974, 9114, 21787, 28010, 4725, 15387, 3274, 10762, 31695, 17320,
	18324, 12441, 16801, 27376, 22464, 7500, 5666, 18144, 15314, 31914, 31627, 6495, 5226, 31203, 2331, 4668,
	12650, 18275, 351, 7268, 31319, 30119, 7600, 2905, 13826, 11343, 13053, 15583, 30055, 31093, 5067, 761,
	9685, 11070, 21369, 27155, 3663, 26542, 20169, 12161, 15411, 30401, 7580, 31784, 8985, 29367, 20989, 14203,
	29694, 21167, 10337, 1706, 28578, 887, 3373, 19477, 14382, 675, 7033, 15111, 26138, 12252, 30996, 21409,
	25678, 18555, 13256, 23316, 22407, 16727, 991, 9236, 5373, 29402, 6117, 15241, 27715, 19291, 19888, 19847
};

unsigned int U_Random( void ) 
{ 
	glSeed *= 69069; 
	glSeed += seed_table[ glSeed & 0xff ];
 
	return ( ++glSeed & 0x0fffffff ); 
} 

void U_Srand( unsigned int seed )
{
	glSeed = seed_table[ seed & 0xff ];
}

/*
=====================
UTIL_SharedRandomLong
=====================
*/
int UTIL_SharedRandomLong( unsigned int seed, int low, int high )
{
	unsigned int range;

	U_Srand( (int)seed + low + high );

	range = high - low + 1;
	if ( !(range - 1) )
	{
		return low;
	}
	else
	{
		int offset;
		int rnum;

		rnum = U_Random();

		offset = rnum % range;

		return (low + offset);
	}
}

/*
=====================
UTIL_SharedRandomFloat
=====================
*/
float UTIL_SharedRandomFloat( unsigned int seed, float low, float high )
{
	//
	unsigned int range;

	U_Srand( (int)seed + *(int *)&low + *(int *)&high );

	U_Random();
	U_Random();

	range = high - low;
	if ( !range )
	{
		return low;
	}
	else
	{
		int tensixrand;
		float offset;

		tensixrand = U_Random() & 65535;

		offset = (float)tensixrand / 65536.0;

		return (low + offset * range );
	}
}

```

`cl_dll/cs_wpn/com_weapons.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Com_Weapons.cpp
// Shared weapons common/shared functions
#include <stdarg.h>
#include "hud.h"
#include "cl_util.h"
#include "com_weapons.h"

#include "const.h"
#include "entity_state.h"
#include "r_efx.h"

// g_runfuncs is true if this is the first time we've "predicated" a particular movement/firing
//  command.  If it is 1, then we should play events/sounds etc., otherwise, we just will be
//  updating state info, but not firing events
int	g_runfuncs = 0;

// During our weapon prediction processing, we'll need to reference some data that is part of
//  the final state passed into the postthink functionality.  We'll set this pointer and then
//  reset it to NULL as appropriate
struct local_state_s *g_finalstate = NULL;

/*
====================
COM_Log

Log debug messages to file ( appends )
====================
*/
void COM_Log( char *pszFile, char *fmt, ...)
{
	va_list		argptr;
	char		string[1024];
	FILE *fp;
	char *pfilename;
	
	if ( !pszFile )
	{
		pfilename = "c:\\hllog.txt";
	}
	else
	{
		pfilename = pszFile;
	}

	va_start (argptr,fmt);
	vsprintf (string, fmt,argptr);
	va_end (argptr);

	fp = fopen( pfilename, "a+t");
	if (fp)
	{
		fprintf(fp, "%s", string);
		fclose(fp);
	}
}

// remember the current animation for the view model, in case we get out of sync with
//  server.
static int g_currentanim;

/*
=====================
HUD_SendWeaponAnim

Change weapon model animation
=====================
*/
void HUD_SendWeaponAnim( int iAnim, int body, int force )
{
	// Don't actually change it.
	if ( !g_runfuncs && !force )
		return;

	g_currentanim = iAnim;

	// Tell animation system new info
	gEngfuncs.pfnWeaponAnim( iAnim, body );
}

/*
=====================
HUD_GetWeaponAnim

Retrieve current predicted weapon animation
=====================
*/
int HUD_GetWeaponAnim( void )
{
	return g_currentanim;
}

/*
=====================
HUD_PlaySound

Play a sound, if we are seeing this command for the first time
=====================
*/
void HUD_PlaySound( char *sound, float volume )
{
	if ( !g_runfuncs || !g_finalstate )
		return;

	gEngfuncs.pfnPlaySoundByNameAtLocation( sound, volume, (float *)&g_finalstate->playerstate.origin );
}

/*
=====================
HUD_PlaybackEvent

Directly queue up an event on the client
=====================
*/
void HUD_PlaybackEvent( int flags, const edict_t *pInvoker, unsigned short eventindex, float delay,
	float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 )
{
	vec3_t org;
	vec3_t ang;

	if ( !g_runfuncs || !g_finalstate )
	     return;

	// Weapon prediction events are assumed to occur at the player's origin
	org			= g_finalstate->playerstate.origin;
	ang			= v_angles;
	gEngfuncs.pfnPlaybackEvent( flags, pInvoker, eventindex, delay, (float *)&org, (float *)&ang, fparam1, fparam2, iparam1, iparam2, bparam1, bparam2 );
}

/*
=====================
HUD_SetMaxSpeed

=====================
*/
void HUD_SetMaxSpeed( const edict_t *ed, float speed )
{
}


/*
=====================
UTIL_WeaponTimeBase

Always 0.0 on client, even if not predicting weapons ( won't get called
 in that case )
=====================
*/
float UTIL_WeaponTimeBase( void )
{
	return 0.0;
}

static unsigned int glSeed = 0; 

unsigned int seed_table[ 256 ] =
{
	28985, 27138, 26457, 9451, 17764, 10909, 28790, 8716, 6361, 4853, 17798, 21977, 19643, 20662, 10834, 20103,
	27067, 28634, 18623, 25849, 8576, 26234, 23887, 18228, 32587, 4836, 3306, 1811, 3035, 24559, 18399, 315,
	26766, 907, 24102, 12370, 9674, 2972, 10472, 16492, 22683, 11529, 27968, 30406, 13213, 2319, 23620, 16823,
	10013, 23772, 21567, 1251, 19579, 20313, 18241, 30130, 8402, 20807, 27354, 7169, 21211, 17293, 5410, 19223,
	10255, 22480, 27388, 9946, 15628, 24389, 17308, 2370, 9530, 31683, 25927, 23567, 11694, 26397, 32602, 15031,
	18255, 17582, 1422, 28835, 23607, 12597, 20602, 10138, 5212, 1252, 10074, 23166, 19823, 31667, 5902, 24630,
	18948, 14330, 14950, 8939, 23540, 21311, 22428, 22391, 3583, 29004, 30498, 18714, 4278, 2437, 22430, 3439,
	28313, 23161, 25396, 13471, 19324, 15287, 2563, 18901, 13103, 16867, 9714, 14322, 15197, 26889, 19372, 26241,
	31925, 14640, 11497, 8941, 10056, 6451, 28656, 10737, 13874, 17356, 8281, 25937, 1661, 4850, 7448, 12744,
	21826, 5477, 10167, 16705, 26897, 8839, 30947, 27978, 27283, 24685, 32298, 3525, 12398, 28726, 9475, 10208,
	617, 13467, 22287, 2376, 6097, 26312, 2974, 9114, 21787, 28010, 4725, 15387, 3274, 10762, 31695, 17320,
	18324, 12441, 16801, 27376, 22464, 7500, 5666, 18144, 15314, 31914, 31627, 6495, 5226, 31203, 2331, 4668,
	12650, 18275, 351, 7268, 31319, 30119, 7600, 2905, 13826, 11343, 13053, 15583, 30055, 31093, 5067, 761,
	9685, 11070, 21369, 27155, 3663, 26542, 20169, 12161, 15411, 30401, 7580, 31784, 8985, 29367, 20989, 14203,
	29694, 21167, 10337, 1706, 28578, 887, 3373, 19477, 14382, 675, 7033, 15111, 26138, 12252, 30996, 21409,
	25678, 18555, 13256, 23316, 22407, 16727, 991, 9236, 5373, 29402, 6117, 15241, 27715, 19291, 19888, 19847
};

unsigned int U_Random( void ) 
{ 
	glSeed *= 69069; 
	glSeed += seed_table[ glSeed & 0xff ];
 
	return ( ++glSeed & 0x0fffffff ); 
} 

void U_Srand( unsigned int seed )
{
	glSeed = seed_table[ seed & 0xff ];
}

/*
=====================
UTIL_SharedRandomLong
=====================
*/
int UTIL_SharedRandomLong( unsigned int seed, int low, int high )
{
	unsigned int range;

	U_Srand( (int)seed + low + high );

	range = high - low + 1;
	if ( !(range - 1) )
	{
		return low;
	}
	else
	{
		int offset;
		int rnum;

		rnum = U_Random();

		offset = rnum % range;

		return (low + offset);
	}
}

/*
=====================
UTIL_SharedRandomFloat
=====================
*/
float UTIL_SharedRandomFloat( unsigned int seed, float low, float high )
{
	//
	unsigned int range;

	U_Srand( (int)seed + *(int *)&low + *(int *)&high );

	U_Random();
	U_Random();

	range = high - low;
	if ( !range )
	{
		return low;
	}
	else
	{
		int tensixrand;
		float offset;

		tensixrand = U_Random() & 65535;

		offset = (float)tensixrand / 65536.0;

		return (low + offset * range );
	}
}


/*
======================
stub_*

stub functions for such things as precaching.  So we don't have to modify weapons code that
 is compiled into both game and client .dlls.
======================
*/
int				stub_PrecacheModel		( char* s ) { return 0; }
int				stub_PrecacheSound		( char* s ) { return 0; }
unsigned short	stub_PrecacheEvent		( int type, const char *s ) { return 0; }
const char		*stub_NameForFunction	( unsigned int function ) { return "func"; }
void			stub_SetModel			( edict_t *e, const char *m ) {}

```

`cl_dll/cs_wpn/cs_baseentity.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

/*
==========================
This file contains "stubs" of class member implementations so that we can predict certain
 weapons client side.  From time to time you might find that you need to implement part of the
 these functions.  If so, cut it from here, paste it in hl_weapons.cpp or somewhere else and
 add in the functionality you need.
==========================
*/
#include    "port.h"
#include	"extdll.h"
#include	"util.h"
#include	"cbase.h"
#include	"player.h"
#include	"weapons.h"
#include	"nodes.h"
#include	"soundent.h"
#include	"skill.h"

// Globals used by game logic
const Vector g_vecZero = Vector( 0, 0, 0 );
int gmsgWeapPickup = 0;
enginefuncs_t g_engfuncs;
globalvars_t  *gpGlobals;
ItemInfo CBasePlayerItem::ItemInfoArray[MAX_WEAPONS];


```

`cl_dll/cs_wpn/cs_weapons.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "port.h"

#include "extdll.h"
#include "util.h"
#include "cbase.h"
#include "monsters.h"

#define PLAYER_H
#include "weapons.h"
#undef PLAYER_H

#include "nodes.h"
#include "player.h"

#include "usercmd.h"
#include "entity_state.h"
#include "demo_api.h"
#include "pm_defs.h"
#include "event_api.h"
#include "r_efx.h"

#include "hud_iface.h"
#include "com_weapons.h"
#include "demo.h"

#include "cl_entity.h"

#include "pm_shared.h"

#ifndef min
#define min(a,b)  (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b)  (((a) > (b)) ? (a) : (b))
#endif

extern globalvars_t *gpGlobals;
extern int g_iUser1;
extern bool g_bGlockBurstMode;
extern int g_rseq;
extern int g_gaitseq;
extern Vector g_clorg;
extern Vector g_clang;

// Pool of client side entities/entvars_t
static entvars_t	ev[ 32 ];
static int			num_ents = 0;

// The entity we'll use to represent the local client
static CBasePlayer	player;

// Local version of game .dll global variables ( time, etc. )
static globalvars_t	Globals = { };

static CBasePlayerWeapon *g_pWpns[ 32 ];


// CS Weapon placeholder entities
static CAK47 g_AK47;
static CAUG g_AUG;
static CAWP g_AWP;
static CC4 g_C4;
static CDEAGLE g_DEAGLE;
static CELITE g_ELITE;
static CFamas g_Famas;
static CFiveSeven g_FiveSeven;
static CFlashbang g_Flashbang;
static CG3SG1 g_G3SG1;
static CGalil g_Galil;
static CGLOCK18 g_GLOCK18;
static CHEGrenade g_HEGrenade;
static CKnife g_Knife;
static CM249 g_M249;
static CM3 g_M3;
static CM4A1 g_M4A1;
static CMAC10 g_MAC10;
static CMP5N g_MP5N;
static CP228 g_P228;
static CP90 g_P90;
static CSCOUT g_SCOUT;
static CSG550 g_SG550;
static CSG552 g_SG552;
static CSmokeGrenade g_SmokeGrenade;
static CTMP g_TMP;
static CUMP45 g_UMP45;
static CUSP g_USP;
static CXM1014 g_XM1014;

int    g_iWeaponFlags;
bool   g_bInBombZone;
int    g_iFreezeTimeOver;
bool   g_bHoldingShield;
bool   g_bHoldingKnife;
float  g_flPlayerSpeed;
int    g_iPlayerFlags;
Vector g_vPlayerVelocity;

/*
======================
AlertMessage

Print debug messages to console
======================
*/
void AlertMessage( ALERT_TYPE atype, const char *szFmt, ... )
{
	va_list		argptr;
	static char	string[1024];

	va_start (argptr, szFmt);
	vsprintf (string, szFmt,argptr);
	va_end (argptr);

	gEngfuncs.Con_Printf( "cl:  " );
	gEngfuncs.Con_Printf( string );
}

/*
=====================
HUD_PrepEntity

Links the raw entity to an entvars_s holder.  If a player is passed in as the owner, then
we set up the m_pPlayer field.
=====================
*/
edict_t *EHANDLE::Get(void)
{
	if (!m_pent)
		return NULL;

	if (m_pent->serialnumber != m_serialnumber)
		return NULL;

	return m_pent;
}

edict_t *EHANDLE::Set(edict_t *pent)
{
	m_pent = pent;

	if (pent)
		m_serialnumber = m_pent->serialnumber;

	return pent;
}

EHANDLE::operator CBaseEntity *(void)
{
	return (CBaseEntity *)GET_PRIVATE(Get());
}

CBaseEntity *EHANDLE::operator = (CBaseEntity *pEntity)
{
	if (pEntity)
	{
		m_pent = ENT(pEntity->pev);

		if (m_pent)
			m_serialnumber = m_pent->serialnumber;
	}
	else
	{
		m_pent = NULL;
		m_serialnumber = 0;
	}

	return pEntity;
}

EHANDLE::operator int(void)
{
	return Get() != NULL;
}

CBaseEntity *EHANDLE::operator ->(void)
{
	return (CBaseEntity *)GET_PRIVATE(Get());
}


void HUD_PrepEntity( CBaseEntity *pEntity, CBasePlayer *pWeaponOwner )
{
	memset( &ev[ num_ents ], 0, sizeof( entvars_t ) );
	pEntity->pev = &ev[ num_ents++ ];

	pEntity->Precache();
	pEntity->Spawn();

	if ( pWeaponOwner )
	{
		ItemInfo info;
		memset( &info, 0, sizeof( ItemInfo ) );

		((CBasePlayerWeapon *)pEntity)->m_pPlayer = pWeaponOwner;

		((CBasePlayerWeapon *)pEntity)->GetItemInfo( &info );

		g_pWpns[ info.iId ] = (CBasePlayerWeapon *)pEntity;
		CBasePlayerItem::ItemInfoArray[ info.iId ] = info;
	}
}

/*
=====================
CBaseEntity :: Killed

If weapons code "kills" an entity, just set its effects to EF_NODRAW
=====================
*/
void CBaseEntity :: Killed( entvars_t *pevAttacker, int iGib )
{
	pev->effects |= EF_NODRAW;
}

/*
=====================
CBasePlayerWeapon :: DefaultReload
=====================
*/
BOOL CBasePlayerWeapon :: DefaultReload( int iClipSize, int iAnim, float fDelay, int body )
{
	if( !m_pPlayer->m_pActiveItem )
		return FALSE;

	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		return FALSE;

	int j = min(iClipSize - m_iClip, player.m_rgAmmo[m_iPrimaryAmmoType]);

	if (j == 0)
		return FALSE;

	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + fDelay;

	//!!UNDONE -- reload sound goes here !!!
	SendWeaponAnim( iAnim, UseDecrement() );

	m_fInReload = TRUE;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + fDelay + 0.5f;
	return TRUE;
}

/*
=====================
CBasePlayerWeapon :: CanDeploy
=====================
*/
BOOL CBasePlayerWeapon :: CanDeploy( void )
{
#if 0
	BOOL bHasAmmo = 0;

	if ( !pszAmmo1() )
	{
		// this weapon doesn't use ammo, can always deploy.
		return TRUE;
	}

	if ( pszAmmo1() )
	{
		bHasAmmo |= (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] != 0);
	}
	if ( pszAmmo2() )
	{
		bHasAmmo |= (m_pPlayer->m_rgAmmo[m_iSecondaryAmmoType] != 0);
	}
	if (m_iClip > 0)
	{
		bHasAmmo |= 1;
	}
	if (!bHasAmmo)
	{
		return FALSE;
	}

	return TRUE;
#else
	return TRUE;
#endif
}
/*
=====================
CBasePlayer :: HasShield

=====================
*/
bool CBasePlayer::HasShield()
{
	return g_bHoldingShield;
}

/*
=====================
CBasePlayerWeapon::HasSecondaryAttack()

=====================
*/
bool CBasePlayerWeapon::HasSecondaryAttack()
{
	if (g_bHoldingShield == false)
	{
		if (m_iId == WEAPON_AK47 || m_iId == WEAPON_XM1014 || m_iId == WEAPON_MAC10 || m_iId == WEAPON_ELITE || m_iId == WEAPON_FIVESEVEN || m_iId == WEAPON_MP5N || m_iId == WEAPON_M249 || m_iId == WEAPON_M3 || m_iId == WEAPON_TMP || m_iId == WEAPON_DEAGLE || m_iId == WEAPON_P228 || m_iId == WEAPON_P90 || m_iId == WEAPON_C4 || m_iId == WEAPON_GALIL)
			return false;
	}

	return true;
}

void CBasePlayerWeapon::FireRemaining(int &shotsFired, float &shootTime, BOOL isGlock18)
{
	m_iClip--;

	if (m_iClip < 0)
	{
		m_iClip = 0;
		shotsFired = 3;
		shootTime = 0;
		return;
	}

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	Vector vecDir;

	if (isGlock18)
	{
		vecDir = m_pPlayer->FireBullets3(m_pPlayer->GetGunPosition(), gpGlobals->v_forward, 0.05, 8192, 1, BULLET_PLAYER_9MM, 18, 0.9, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);
		PLAYBACK_EVENT_FULL(FEV_NOTHOST, ENT(m_pPlayer->pev), m_usFireGlock18, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 10000), (int)(m_pPlayer->pev->punchangle.y * 10000), m_iClip != 0, FALSE);
		m_pPlayer->ammo_9mm--;
	}
	else
	{
		vecDir = m_pPlayer->FireBullets3(m_pPlayer->GetGunPosition(), gpGlobals->v_forward, m_fBurstSpread, 8192, 2, BULLET_PLAYER_556MM, 30, 0.96, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);
		PLAYBACK_EVENT_FULL(FEV_NOTHOST, ENT(m_pPlayer->pev), m_usFireFamas, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 10000000), (int)(m_pPlayer->pev->punchangle.y * 10000000), m_iClip != 0, FALSE);
		m_pPlayer->ammo_556nato--;
	}

	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	shotsFired++;

	if (shotsFired == 3)
		shootTime = 0;
	else
		shootTime = gpGlobals->time + 0.1;
}

bool CBasePlayerWeapon::ShieldSecondaryFire(int up_anim, int down_anim)
{
	if (m_pPlayer->HasShield() == false)
		return false;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(down_anim, UseDecrement() != FALSE);
		strncpy(m_pPlayer->m_szAnimExtention, "shieldgun", sizeof(m_pPlayer->m_szAnimExtention));
		m_fMaxSpeed = 250;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(up_anim, UseDecrement() != FALSE);
		strncpy(m_pPlayer->m_szAnimExtention, "shielded", sizeof(m_pPlayer->m_szAnimExtention));
		m_fMaxSpeed = 180;
		m_pPlayer->m_bShieldDrawn = true;
	}

#ifndef CLIENT_DLL
	m_pPlayer->UpdateShieldCrosshair((m_iWeaponState & WPNSTATE_SHIELD_DRAWN) ? true : false);
	m_pPlayer->ResetMaxSpeed();
#endif
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.6;
	return true;
}

void CBasePlayerWeapon::KickBack(float up_base, float lateral_base, float up_modifier, float lateral_modifier, float up_max, float lateral_max, int direction_change)
{

}

void CBasePlayerWeapon::SetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strncpy(m_pPlayer->m_szAnimExtention, "shield", sizeof(m_pPlayer->m_szAnimExtention));
		else
			strncpy(m_pPlayer->m_szAnimExtention, "shieldgun", sizeof(m_pPlayer->m_szAnimExtention));
	}
}

void CBasePlayerWeapon::ResetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strncpy(m_pPlayer->m_szAnimExtention, "shieldgun", sizeof(m_pPlayer->m_szAnimExtention));
	}
}

/*
=====================
CBasePlayerWeapon :: DefaultDeploy

=====================
*/
BOOL CBasePlayerWeapon :: DefaultDeploy( const char *szViewModel, const char *szWeaponModel, int iAnim, const char *szAnimExt, int skiplocal )
{
	if ( !CanDeploy() )
		return FALSE;

	gEngfuncs.CL_LoadModel( szViewModel, &m_pPlayer->pev->viewmodel );

	SendWeaponAnim( iAnim, skiplocal );

	m_pPlayer->m_flNextAttack = 0.75f;
	m_flTimeWeaponIdle = 1.5f;
	return TRUE;
}

/*
=====================
CBasePlayerWeapon :: PlayEmptySound

=====================
*/
BOOL CBasePlayerWeapon :: PlayEmptySound( void )
{
#if 0
	if (m_iPlayEmptySound)
	{
		switch (m_iId)
		{
		case WEAPON_USP:
		case WEAPON_GLOCK18:
		case WEAPON_P228:
		case WEAPON_DEAGLE:
		case WEAPON_ELITE:
		case WEAPON_FIVESEVEN:
			HUD_PlaySound("weapons/dryfire_pistol.wav", 0.8);
			break;
		default:
			HUD_PlaySound("weapons/dryfire_rifle.wav",  0.8);
			break;
		}
	}
#endif
	return 0;
}

/*
=====================
CBasePlayerWeapon :: ResetEmptySound

=====================
*/
void CBasePlayerWeapon :: ResetEmptySound( void )
{
	m_iPlayEmptySound = 1;
}

/*
=====================
CBasePlayerWeapon::Holster

Put away weapon
=====================
*/
void CBasePlayerWeapon::Holster( int skiplocal /* = 0 */ )
{
	m_fInReload = FALSE; // cancel any reload in progress.
	m_pPlayer->pev->viewmodel = 0;
}

/*
=====================
CBasePlayerWeapon::SendWeaponAnim

Animate weapon model
=====================
*/
void CBasePlayerWeapon::SendWeaponAnim( int iAnim, int skiplocal )
{
	//gEngfuncs.Con_DPrintf( "Predict::SendWeaponAnim( %i )\n", iAnim );

	m_pPlayer->pev->weaponanim = iAnim;
	HUD_SendWeaponAnim( iAnim, m_iId, 0, 0 );
}

void CBasePlayerWeapon::RetireWeapon()
{
	// TODO: Implement
	//UTIL_GetNextBestWeapon( m_pPlayer, this );
}

Vector CBaseEntity::FireBullets3 ( Vector vecSrc, Vector vecDirShooting, float flSpread, float flDistance, int iPenetration, int iBulletType, int iDamage, float flRangeModifier, entvars_t *pevAttacker, bool bPistol, int shared_rand )
{
	float x, y, z;

	if ( pevAttacker )
	{
		x = UTIL_SharedRandomFloat(shared_rand, -0.5, 0.5) + UTIL_SharedRandomFloat(shared_rand + 1, -0.5, 0.5);
		y = UTIL_SharedRandomFloat(shared_rand + 2, -0.5, 0.5) + UTIL_SharedRandomFloat(shared_rand + 3, -0.5, 0.5);
	}
	else
	{
		do
		{
			x = RANDOM_FLOAT(-0.5, 0.5) + RANDOM_FLOAT(-0.5, 0.5);
			y = RANDOM_FLOAT(-0.5, 0.5) + RANDOM_FLOAT(-0.5, 0.5);
			z = x * x + y * y;
		}
		while (z > 1);
	}

	return Vector(x * flSpread, y * flSpread, 0);
}
/*
=====================
CBasePlayerWeapon::ItemPostFrame

Handles weapon firing, reloading, etc.
=====================
*/
void CBasePlayerWeapon::ItemPostFrame( void )
{
	int button = m_pPlayer->pev->button;

	if (!HasSecondaryAttack())
		button &= ~IN_ATTACK2;

	if (m_flGlock18Shoot != 0)
	{
		m_iClip--;
		if( m_iClip < 0 )
		{
			m_iClip = m_iGlock18ShotsFired = 0;
		}
		FireRemaining(m_iGlock18ShotsFired, m_flGlock18Shoot, TRUE);
	}
	else if (gpGlobals->time > m_flFamasShoot && m_flFamasShoot != 0)
	{
		m_iClip--;
		if( m_iClip < 0 )
		{
			m_iClip = m_iFamasShotsFired = 0;
		}
		FireRemaining(m_iFamasShotsFired, m_flFamasShoot, FALSE);
	}

	if (m_flNextPrimaryAttack <= UTIL_WeaponTimeBase() )
	{
		if (m_pPlayer->m_bResumeZoom)
		{
			m_pPlayer->pev->fov = m_pPlayer->m_iFOV = m_pPlayer->m_iLastZoom;

			if (m_pPlayer->m_iFOV == m_pPlayer->m_iLastZoom)
			{
				m_pPlayer->m_bResumeZoom = false;
				// viewmodel hide is implemented elsewhere
			}
		}
	}

	if ( m_pPlayer->HasShield() )
	{
		if (m_fInReload && m_pPlayer->pev->button & IN_ATTACK2)
		{
			SecondaryAttack();
			m_pPlayer->pev->button &= ~IN_ATTACK2;
			m_fInReload = FALSE;
			m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase();
		}
	}

	if ((m_fInReload) && m_pPlayer->m_flNextAttack <= UTIL_WeaponTimeBase())
	{
		int j = min(iMaxClip() - m_iClip, m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]);

		m_iClip += j;
		m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] -= j;
		m_fInReload = FALSE;
	}

	if ((button & IN_ATTACK2) && m_flNextSecondaryAttack <= UTIL_WeaponTimeBase())
	{
		if (pszAmmo2() && !m_pPlayer->m_rgAmmo[SecondaryAmmoIndex()])
			m_fFireOnEmpty = TRUE;

		SecondaryAttack();
		m_pPlayer->pev->button &= ~IN_ATTACK2;
	}
	else if ((m_pPlayer->pev->button & IN_ATTACK) && m_flNextPrimaryAttack <= UTIL_WeaponTimeBase())
	{
		if ((!m_iClip && pszAmmo1()) || (iMaxClip() == WEAPON_NOCLIP && !m_pPlayer->m_rgAmmo[PrimaryAmmoIndex()]))
			m_fFireOnEmpty = TRUE;

		if (m_pPlayer->m_bCanShoot == true)
			PrimaryAttack();
	}
	else if (m_pPlayer->pev->button & IN_RELOAD && iMaxClip() != WEAPON_NOCLIP && !m_fInReload)
	{
		if (m_flNextPrimaryAttack < UTIL_WeaponTimeBase())
		{
			if (m_flFamasShoot == 0 && m_flGlock18Shoot == 0)
			{
				if (!(m_iWeaponState & WPNSTATE_SHIELD_DRAWN))
					Reload();
			}
		}
	}
	else if (!(button & (IN_ATTACK | IN_ATTACK2)))
	{
		if (m_bDelayFire == true)
		{
			m_bDelayFire = false;

			if (m_iShotsFired > 15)
				m_iShotsFired = 15;

			m_flDecreaseShotsFired = gpGlobals->time + 0.4;
		}

		m_fFireOnEmpty = FALSE;

		if (m_iId != WEAPON_USP && m_iId != WEAPON_GLOCK18 && m_iId != WEAPON_P228 && m_iId != WEAPON_DEAGLE && m_iId != WEAPON_ELITE && m_iId != WEAPON_FIVESEVEN)
		{
			if (m_iShotsFired > 0)
			{
				if (gpGlobals->time > m_flDecreaseShotsFired)
				{
					m_iShotsFired--;
					m_flDecreaseShotsFired = gpGlobals->time + 0.0225;
				}
			}
		}
		else
			m_iShotsFired = 0;


		if (!(m_iWeaponState & WPNSTATE_SHIELD_DRAWN))
		{

			if (m_iClip == 0 && !(iFlags() & ITEM_FLAG_NOAUTORELOAD)
					&& m_flNextPrimaryAttack < UTIL_WeaponTimeBase())
			{
				if (m_flFamasShoot == 0 && m_flGlock18Shoot == 0)
				{
					Reload();
					return;
				}
			}
		}

		WeaponIdle();
		return;
	}
}

/*
=====================
CBasePlayer::SelectLastItem

=====================
*/
void CBasePlayer::SelectLastItem(void)
{
	if (!m_pLastItem)
	{
		return;
	}

	if ( m_pActiveItem && !m_pActiveItem->CanHolster() )
	{
		return;
	}

	if (m_pActiveItem)
		m_pActiveItem->Holster( );

	CBasePlayerItem *pTemp = m_pActiveItem;
	m_pActiveItem = m_pLastItem;
	m_pLastItem = pTemp;
	m_pActiveItem->Deploy( );
}

/*
=====================
CBasePlayer::Killed

=====================
*/
void CBasePlayer::Killed( entvars_t *pevAttacker, int iGib )
{
	// Holster weapon immediately, to allow it to cleanup
	if ( m_pActiveItem )
		 m_pActiveItem->Holster( );
}

/*
=====================
CBasePlayer::Spawn

=====================
*/
void CBasePlayer::Spawn( void )
{
	if (m_pActiveItem)
		m_pActiveItem->Deploy( );
}

Vector CBasePlayer::GetGunPosition()
{
	Vector origin = pev->origin;
	Vector view_ofs;

	gEngfuncs.pEventAPI->EV_LocalPlayerViewheight(view_ofs);

	return origin + view_ofs;
}

/*
=====================
UTIL_TraceLine

Don't actually trace, but act like the trace didn't hit anything.
=====================
*/
void UTIL_TraceLine( const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, edict_t *pentIgnore, TraceResult *ptr )
{
	memset( ptr, 0, sizeof( *ptr ) );
#if 0
	static float flLastFraction = 1.0f;

	if( g_runfuncs )
	{
		Vector vStart = vecStart, vEnd = vecEnd;
		pmtrace_t pmtrace;

		gEngfuncs.pEventAPI->EV_SetTraceHull( 0 );
		gEngfuncs.pEventAPI->EV_PlayerTrace( vStart, vEnd, 0, -1, &pmtrace );
		flLastFraction = ptr->flFraction = pmtrace.fraction;
		ptr->vecEndPos = pmtrace.endpos;
	}
	else
	{
		ptr->flFraction = flLastFraction;
	}
#else
	ptr->flFraction = 1.0f;
#endif
}

char UTIL_TextureHit(TraceResult *ptr, Vector vecSrc, Vector vecEnd)
{
	char chTextureType;
	float rgfl1[3], rgfl2[3];
	const char *pTextureName;
	char szbuffer[64];
	CBaseEntity *pEntity;

	if( ptr->pHit == NULL )
		return CHAR_TEX_FLESH;

	pEntity = CBaseEntity::Instance(ptr->pHit);

	if (pEntity && pEntity->Classify() != CLASS_NONE && pEntity->Classify() != CLASS_MACHINE)
		return CHAR_TEX_FLESH;

	vecSrc.CopyToArray(rgfl1);
	vecEnd.CopyToArray(rgfl2);

	if (pEntity)
		pTextureName = TRACE_TEXTURE(ENT(pEntity->pev), rgfl1, rgfl2);
	else
		pTextureName = TRACE_TEXTURE(ENT(0), rgfl1, rgfl2);

	if (pTextureName)
	{
		if (*pTextureName == '-' || *pTextureName == '+')
			pTextureName += 2;

		if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')
			pTextureName++;

		strncpy(szbuffer, pTextureName, sizeof(szbuffer));
		szbuffer[CBTEXTURENAMEMAX - 1] = 0;
		chTextureType = PM_FindTextureType(szbuffer);
	}
	else
		chTextureType = 0;

	return chTextureType;
}

CBaseEntity *UTIL_PlayerByIndex(int playerIndex)
{
	CBaseEntity *pPlayer = NULL;

	if (playerIndex > 0 && playerIndex <= gpGlobals->maxClients)
	{
		edict_t *pPlayerEdict = INDEXENT(playerIndex);

		if (pPlayerEdict && !pPlayerEdict->free)
			pPlayer = CBaseEntity::Instance(pPlayerEdict);
	}

	return pPlayer;
}

void UTIL_MakeVectors( const Vector &vec )
{
	gEngfuncs.pfnAngleVectors( vec, gpGlobals->v_forward, gpGlobals->v_right, gpGlobals->v_up );
}


/*
=====================
CBasePlayerWeapon::PrintState

For debugging, print out state variables to log file
=====================
*/
/*void CBasePlayerWeapon::PrintState( void )
{
	COM_Log( "c:\\hl.log", "%.4f ", gpGlobals->time );
	COM_Log( "c:\\hl.log", "%.4f ", m_pPlayer->m_flNextAttack );
	COM_Log( "c:\\hl.log", "%.4f ", m_flNextPrimaryAttack );
	COM_Log( "c:\\hl.log", "%.4f ", m_flTimeWeaponIdle - gpGlobals->time);
	COM_Log( "c:\\hl.log", "%i ", m_iClip );
}*/

int RandomLong( int a, int b )
{
	return gEngfuncs.pfnRandomLong( a, b );
}

/*
=====================
HUD_InitClientWeapons

Set up weapons, player and functions needed to run weapons code client-side.
=====================
*/
void HUD_InitClientWeapons( void )
{
	static int initialized = 0;
	if ( initialized )
		return;

	initialized = 1;

	// Set up pointer ( dummy object )
	gpGlobals = &Globals;

	// Fill in current time ( probably not needed )
	gpGlobals->time = gEngfuncs.GetClientTime();

	// Fake functions
	//g_engfuncs.pfnSetClientMaxspeed = HUD_SetMaxSpeed;

	// Handled locally
	g_engfuncs.pfnPlaybackEvent		= HUD_PlaybackEvent;
	g_engfuncs.pfnAlertMessage		= AlertMessage;

	// Pass through to engine
	g_engfuncs.pfnPrecacheEvent		= gEngfuncs.pfnPrecacheEvent;
	g_engfuncs.pfnRandomFloat		= gEngfuncs.pfnRandomFloat;
	g_engfuncs.pfnRandomLong		= RandomLong;

	// Allocate a slot for the local player
	HUD_PrepEntity( &player		, NULL );

	// Allocate slot(s) for each weapon that we are going to be predicting
	HUD_PrepEntity( &g_P228, &player);
	HUD_PrepEntity( &g_SCOUT, &player);
	HUD_PrepEntity( &g_HEGrenade, &player);
	HUD_PrepEntity( &g_XM1014, &player);
	HUD_PrepEntity( &g_C4, &player);
	HUD_PrepEntity( &g_MAC10, &player);
	HUD_PrepEntity( &g_AUG, &player);
	HUD_PrepEntity( &g_SmokeGrenade, &player);
	HUD_PrepEntity( &g_ELITE, &player);
	HUD_PrepEntity( &g_FiveSeven, &player);
	HUD_PrepEntity( &g_UMP45, &player);
	HUD_PrepEntity( &g_SG550, &player);
	HUD_PrepEntity( &g_Galil, &player);
	HUD_PrepEntity( &g_Famas, &player);
	HUD_PrepEntity( &g_USP, &player);
	HUD_PrepEntity( &g_GLOCK18, &player);
	HUD_PrepEntity( &g_AWP, &player);
	HUD_PrepEntity( &g_MP5N, &player);
	HUD_PrepEntity( &g_M249, &player);
	HUD_PrepEntity( &g_M4A1, &player);
	HUD_PrepEntity( &g_M3, &player );
	HUD_PrepEntity( &g_TMP, &player);
	HUD_PrepEntity( &g_G3SG1, &player);
	HUD_PrepEntity( &g_Flashbang, &player);
	HUD_PrepEntity( &g_DEAGLE, &player);
	HUD_PrepEntity( &g_SG552, &player);
	HUD_PrepEntity( &g_AK47, &player);
	HUD_PrepEntity( &g_Knife, &player);
	HUD_PrepEntity( &g_P90, &player );
}


int GetWeaponAccuracyFlags( int weaponid )
{
	int result = 0;

	if( weaponid <= WEAPON_P90 )
	{
		switch( weaponid )
		{
		case WEAPON_AUG:
		case WEAPON_GALIL:
		case WEAPON_M249:
		case WEAPON_SG552:
		case WEAPON_AK47:
		case WEAPON_P90:
			result = ACCURACY_AIR | ACCURACY_SPEED;
			break;
		case WEAPON_P228:
		case WEAPON_FIVESEVEN:
		case WEAPON_DEAGLE:
			result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK;
			break;
		case WEAPON_GLOCK18:
			if( g_iWeaponFlags & WPNSTATE_GLOCK18_BURST_MODE)
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK;
			}
			else
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK | ACCURACY_MULTIPLY_BY_14_2;
			}
			break;
		case WEAPON_MAC10:
		case WEAPON_UMP45:
		case WEAPON_MP5N:
		case WEAPON_TMP:
			result = ACCURACY_AIR;
			break;
		case WEAPON_M4A1:
			if(g_iWeaponFlags & WPNSTATE_USP_SILENCED)
			{
				result = ACCURACY_AIR | ACCURACY_SPEED;
			}
			else
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_MULTIPLY_BY_14;
			}
			break;
		case WEAPON_FAMAS:
			if(g_iWeaponFlags & WPNSTATE_FAMAS_BURST_MODE)
			{
				result = ACCURACY_AIR | ACCURACY_SPEED;
			}
			else
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | (1<<4);
			}
			break;
		case WEAPON_USP:
			if(g_iWeaponFlags & WPNSTATE_USP_SILENCED)
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK;
			}
			else
			{
				result = ACCURACY_AIR | ACCURACY_SPEED | ACCURACY_DUCK | ACCURACY_MULTIPLY_BY_14;
			}
			break;
		}
	}

	return result;
}


// Name says it!
// Override stupid Xash(or even GoldSrc?) bug with overwriting
// already predicted values, like maxspeed or punchangle vector
#define _CS16CLIENT_TAKE_PREDICTED_INFO_FOR_WEAPON_PREDICTION

#ifdef _CS16CLIENT_TAKE_PREDICTED_INFO_FOR_WEAPON_PREDICTION
#define STATE to
#else
#define STATE from
#endif

/*
=====================
HUD_WeaponsPostThink

Run Weapon firing code on client
=====================
*/
void HUD_WeaponsPostThink( local_state_s *from, local_state_s *to, usercmd_t *cmd, double time, unsigned int random_seed )
{
	int i;
	int buttonsChanged;
	CBasePlayerWeapon *pWeapon = NULL;
	static int lasthealth;
	int flags;

	HUD_InitClientWeapons();

	// Get current clock
	gpGlobals->time = time;

	// Fill in data based on selected weapon
	switch ( from->client.m_iId )
	{
		case WEAPON_P228:
			pWeapon = &g_P228;
			break;

		case WEAPON_SCOUT:
			pWeapon = &g_SCOUT;
			break;

		case WEAPON_HEGRENADE:
			pWeapon = &g_HEGrenade;
			break;

		case WEAPON_XM1014:
			pWeapon = &g_XM1014;
			break;

		case WEAPON_C4:
			pWeapon = &g_C4;
			break;

		case WEAPON_MAC10:
			pWeapon = &g_MAC10;
			break;

		case WEAPON_AUG:
			pWeapon = &g_AUG;
			break;

		case WEAPON_SMOKEGRENADE:
			pWeapon = &g_SmokeGrenade;
			break;

		case WEAPON_ELITE:
			pWeapon = &g_ELITE;
			break;

		case WEAPON_FIVESEVEN:
			pWeapon = &g_FiveSeven;
			break;

		case WEAPON_UMP45:
			pWeapon = &g_UMP45;
			break;

		case WEAPON_SG550:
			pWeapon = &g_SG550;
			break;

		case WEAPON_GALIL:
			pWeapon = &g_Galil;
			break;

		case WEAPON_FAMAS:
			pWeapon = &g_Famas;
			break;

		case WEAPON_USP:
			pWeapon = &g_USP;
			break;

		case WEAPON_GLOCK18:
			pWeapon = &g_GLOCK18;
			break;

		case WEAPON_AWP:
			pWeapon = &g_AWP;
			break;

		case WEAPON_MP5N:
			pWeapon = &g_MP5N;
			break;

		case WEAPON_M249:
			pWeapon = &g_M249;
			break;

		case WEAPON_M3:
			pWeapon = &g_M3;
			break;

		case WEAPON_M4A1:
			pWeapon = &g_M4A1;
			break;

		case WEAPON_TMP:
			pWeapon = &g_TMP;
			break;

		case WEAPON_G3SG1:
			pWeapon = &g_G3SG1;
			break;

		case WEAPON_FLASHBANG:
			pWeapon = &g_Flashbang;
			break;

		case WEAPON_DEAGLE:
			pWeapon = &g_DEAGLE;
			break;

		case WEAPON_SG552:
			pWeapon = &g_SG552;
			break;

		case WEAPON_AK47:
			pWeapon = &g_AK47;
			break;

		case WEAPON_KNIFE:
			pWeapon = &g_Knife;
			break;

		case WEAPON_P90:
			pWeapon = &g_P90;
			break;

		/*case WEAPON_NONE:
			break;

		case WEAPON_GLOCK:
		default:
			gEngfuncs.Con_Printf("VALVEWHY: Unknown Weapon %i is active.\n", from->client.m_iId );
			break;*/
	}

	// Store pointer to our destination entity_state_t so we can get our origin, etc. from it
	//  for setting up events on the client
	g_finalstate = to;

	// If we are running events/etc. go ahead and see if we
	//  managed to die between last frame and this one
	// If so, run the appropriate player killed or spawn function
	if ( g_runfuncs )
	{
		if ( to->client.health <= 0 && lasthealth > 0 )
			player.Killed( NULL, 0 );
		else if ( to->client.health > 0 && lasthealth <= 0 )
			player.Spawn();

		lasthealth = to->client.health;
	}

	// We are not predicting the current weapon, just bow out here.
	if ( !pWeapon )
		return;

	for ( i = 0; i < MAX_WEAPONS; i++ )
	{
		CBasePlayerWeapon *pCurrent = g_pWpns[ i ];
		if ( !pCurrent )
			continue;

		weapon_data_t *pfrom = from->weapondata + i;

		pCurrent->m_fInReload			= pfrom->m_fInReload;
		pCurrent->m_fInSpecialReload	= pfrom->m_fInSpecialReload;
		pCurrent->m_iClip				= pfrom->m_iClip;
		pCurrent->m_flNextPrimaryAttack	= pfrom->m_flNextPrimaryAttack;
		pCurrent->m_flNextSecondaryAttack = pfrom->m_flNextSecondaryAttack;
		pCurrent->m_flTimeWeaponIdle	= pfrom->m_flTimeWeaponIdle;
		pCurrent->m_flStartThrow		= pfrom->fuser2;
		pCurrent->m_flReleaseThrow		= pfrom->fuser3;
		pCurrent->m_iSwing				= pfrom->iuser1;
		pCurrent->m_iWeaponState		= pfrom->m_iWeaponState;
		pCurrent->m_flLastFire			= pfrom->m_fAimedDamage;
		pCurrent->m_iShotsFired			= pfrom->m_fInZoom;
	}

	if( from->client.vuser4.x < 0 || from->client.vuser4.x > MAX_AMMO_TYPES )
		pWeapon->m_iPrimaryAmmoType = 0;
	else
	{
		pWeapon->m_iPrimaryAmmoType = (int)from->client.vuser4.x;
		player.m_rgAmmo[ pWeapon->m_iPrimaryAmmoType ]  = (int)from->client.vuser4.y;
	}


	g_iWeaponFlags = pWeapon->m_iWeaponState;

	// For random weapon events, use this seed to seed random # generator
	player.random_seed = random_seed;

	// Get old buttons from previous state.
	player.m_afButtonLast = from->playerstate.oldbuttons;

	// Which buttsons chave changed
	buttonsChanged = (player.m_afButtonLast ^ cmd->buttons);	// These buttons have changed this frame

	// Debounced button codes for pressed/released
	// The changed ones still down are "pressed"
	player.m_afButtonPressed =  buttonsChanged & cmd->buttons;
	// The ones not down are "released"
	player.m_afButtonReleased = buttonsChanged & (~cmd->buttons);

	// Set player variables that weapons code might check/alter
	player.pev->button = cmd->buttons;

	player.pev->velocity = from->client.velocity;

	player.pev->deadflag   = from->client.deadflag;
	player.pev->waterlevel = from->client.waterlevel;
	player.pev->maxspeed   = STATE->client.maxspeed; //!!! Taking "to"
	player.pev->punchangle = STATE->client.punchangle; //!!! Taking "to"
	player.pev->fov        = from->client.fov;
	player.pev->weaponanim = from->client.weaponanim;
	player.pev->viewmodel  = from->client.viewmodel;
	player.m_flNextAttack  = from->client.m_flNextAttack;

	g_iPlayerFlags    = player.pev->flags = from->client.flags;
	g_vPlayerVelocity = player.pev->velocity;
	g_flPlayerSpeed	  = player.pev->velocity.Length();

	//Stores all our ammo info, so the client side weapons can use them.
	player.ammo_9mm			= from->client.ammo_nails;
	player.ammo_556nato		= from->client.ammo_cells;
	player.ammo_buckshot	= from->client.ammo_shells;
	player.ammo_556natobox	= from->client.ammo_rockets;
	player.ammo_762nato		= (int)from->client.vuser2.x;
	player.ammo_45acp		= (int)from->client.vuser2.y;
	player.ammo_50ae		= (int)from->client.vuser2.z;
	player.ammo_338mag		= (int)from->client.vuser3.x;
	player.ammo_57mm		= (int)from->client.vuser3.y;
	player.ammo_357sig		= (int)from->client.vuser3.z;

	cl_entity_t *pplayer = gEngfuncs.GetLocalPlayer();
	if( pplayer )
	{
		player.pev->origin = STATE->client.origin; //!!! Taking "to"
		player.pev->angles	= pplayer->angles;
		player.pev->v_angle = v_angles;
	}

	flags = from->client.iuser3;
	g_bHoldingKnife		= pWeapon->m_iId == WEAPON_KNIFE;
	player.m_bCanShoot	= (flags & PLAYER_CAN_SHOOT) != 0;
	g_iFreezeTimeOver	= !(flags & PLAYER_FREEZE_TIME_OVER);
	g_bInBombZone		= (flags & PLAYER_IN_BOMB_ZONE) != 0;
	g_bHoldingShield	= (flags & PLAYER_HOLDING_SHIELD) != 0;

	// Point to current weapon object
	if ( from->client.m_iId )
		player.m_pActiveItem = pWeapon;

	// Don't go firing anything if we have died.
	// Or if we don't have a weapon model deployed
	if ( ( player.pev->deadflag != ( DEAD_DISCARDBODY + 1 ) ) &&
		 !CL_IsDead() && player.pev->viewmodel && !g_iUser1 )
	{
		if( g_bHoldingKnife && pWeapon->m_iClientWeaponState &&
				player.pev->button & IN_FORWARD )
			player.m_flNextAttack = 0;
		else if( player.m_flNextAttack <= 0 )
		{
			pWeapon->ItemPostFrame();
		}
	}

	// Assume that we are not going to switch weapons
	to->client.m_iId					= from->client.m_iId;

	// Now see if we issued a changeweapon command ( and we're not dead )
	if ( cmd->weaponselect && ( player.pev->deadflag != ( DEAD_DISCARDBODY + 1 ) ) )
	{
		// Switched to a different weapon?
		if ( from->weapondata[ cmd->weaponselect ].m_iId == cmd->weaponselect )
		{
			CBasePlayerWeapon *pNew = g_pWpns[ cmd->weaponselect ];
			if ( pNew && ( pNew != pWeapon ) )
			{
				// Put away old weapon
				if (player.m_pActiveItem)
					player.m_pActiveItem->Holster( );

				player.m_pLastItem = player.m_pActiveItem;
				player.m_pActiveItem = pNew;

				// Deploy new weapon
				if (player.m_pActiveItem)
				{
					player.m_pActiveItem->Deploy( );
				}

				// Update weapon id so we can predict things correctly.
				to->client.m_iId = cmd->weaponselect;
			}
		}
	}

	// Copy in results of prediction code
	to->client.viewmodel				= player.pev->viewmodel;
	to->client.fov						= player.pev->fov;
	to->client.weaponanim				= player.pev->weaponanim;
	to->client.m_flNextAttack			= player.m_flNextAttack;
	to->client.maxspeed					= player.pev->maxspeed;
	to->client.punchangle				= player.pev->punchangle;


	to->client.ammo_nails = player.ammo_9mm;
	to->client.ammo_cells = player.ammo_556nato;
	to->client.ammo_shells = player.ammo_buckshot;
	to->client.ammo_rockets = player.ammo_556natobox;
	to->client.vuser2.x = player.ammo_762nato;
	to->client.vuser2.y = player.ammo_45acp;
	to->client.vuser2.z = player.ammo_50ae;
	to->client.vuser3.x = player.ammo_338mag;
	to->client.vuser3.y = player.ammo_57mm;
	to->client.vuser3.z = player.ammo_357sig;
	to->client.iuser3 = flags;




	// Make sure that weapon animation matches what the game .dll is telling us
	//  over the wire ( fixes some animation glitches )
	if ( g_runfuncs && ( HUD_GetWeaponAnim() != to->client.weaponanim ) )
		// Force a fixed anim down to viewmodel
		HUD_SendWeaponAnim( to->client.weaponanim, to->client.m_iId, 2, 1 );

	if (pWeapon->m_iPrimaryAmmoType < MAX_AMMO_TYPES)
	{
		to->client.vuser4.x = pWeapon->m_iPrimaryAmmoType;
		to->client.vuser4.y = player.m_rgAmmo[ pWeapon->m_iPrimaryAmmoType ];
	}
	else
	{
		to->client.vuser4.x = -1.0;
		to->client.vuser4.y = 0;
	}

	for ( i = 0; i < MAX_WEAPONS; i++ )
	{
		CBasePlayerWeapon *pCurrent = g_pWpns[ i ];

		weapon_data_t *pto = to->weapondata + i;

		if ( !pCurrent )
		{
			memset( pto, 0, sizeof( weapon_data_t ) );
			continue;
		}

		pto->m_iClip					= pCurrent->m_iClip;

		pto->m_flNextPrimaryAttack		= pCurrent->m_flNextPrimaryAttack;
		pto->m_flNextSecondaryAttack	= pCurrent->m_flNextSecondaryAttack;
		pto->m_flTimeWeaponIdle			= pCurrent->m_flTimeWeaponIdle;

		pto->m_fInReload				= pCurrent->m_fInReload;
		pto->m_fInSpecialReload			= pCurrent->m_fInSpecialReload;
		pto->m_flNextReload				= pCurrent->m_flNextReload;
		pto->fuser2						= pCurrent->m_flStartThrow;
		pto->fuser3						= pCurrent->m_flReleaseThrow;
		pto->iuser1						= pCurrent->m_iSwing;
		pto->m_iWeaponState				= pCurrent->m_iWeaponState;
		pto->m_fInZoom					= pCurrent->m_iShotsFired;
		pto->m_fAimedDamage				= pCurrent->m_flLastFire;

		// Decrement weapon counters, server does this at same time ( during post think, after doing everything else )
		pto->m_flNextReload				-= cmd->msec / 1000.0f;
		pto->m_fNextAimBonus			-= cmd->msec / 1000.0f;
		pto->m_flNextPrimaryAttack		-= cmd->msec / 1000.0f;
		pto->m_flNextSecondaryAttack	-= cmd->msec / 1000.0f;
		pto->m_flTimeWeaponIdle			-= cmd->msec / 1000.0f;


		if( pto->m_flPumpTime != -9999.0f )
		{
			pto->m_flPumpTime -= cmd->msec / 1000.0f;
			if( pto->m_flPumpTime < -1.0f )
				pto->m_flPumpTime = 1.0f;
		}

		if ( pto->m_fNextAimBonus < -1.0 )
		{
			pto->m_fNextAimBonus = -1.0;
		}

		if ( pto->m_flNextPrimaryAttack < -1.0 )
		{
			pto->m_flNextPrimaryAttack = -1.0;
		}

		if ( pto->m_flNextSecondaryAttack < -0.001 )
		{
			pto->m_flNextSecondaryAttack = -0.001;
		}

		if ( pto->m_flTimeWeaponIdle < -0.001 )
		{
			pto->m_flTimeWeaponIdle = -0.001;
		}

		if ( pto->m_flNextReload < -0.001 )
		{
			pto->m_flNextReload = -0.001;
		}

		/*if ( pto->fuser1 < -0.001 )
		{
			pto->fuser1 = -0.001;
		}*/
	}

	// m_flNextAttack is now part of the weapons, but is part of the player instead
	to->client.m_flNextAttack -= cmd->msec / 1000.0f;
	if ( to->client.m_flNextAttack < -0.001 )
	{
		to->client.m_flNextAttack = -0.001;
	}

	// Wipe it so we can't use it after this frame
	g_finalstate = NULL;
}

/*
=====================
HUD_PostRunCmd

Client calls this during prediction, after it has moved the player and updated any info changed into to->
time is the current client clock based on prediction
cmd is the command that caused the movement, etc
runfuncs is 1 if this is the first time we've predicted this command.  If so, sounds and effects should play, otherwise, they should
be ignored
=====================
*/
void DLLEXPORT HUD_PostRunCmd( local_state_t *from, local_state_t *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed )
{
	g_runfuncs = runfuncs;

	HUD_WeaponsPostThink( from, to, cmd, time, random_seed );
	to->client.fov = g_lastFOV;

	if ( g_runfuncs )
	{
		g_gaitseq	= to->playerstate.gaitsequence;
		g_rseq		= to->playerstate.sequence;
		g_clang		= cmd->viewangles;
		g_clorg		= to->playerstate.origin;
	}
}

```

`cl_dll/demo.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#include "hud.h"
#include "cl_util.h"
#include "demo.h"
#include "demo_api.h"
#include <memory.h>

int g_demosniper = 0;
int g_demosniperdamage = 0;
float g_demosniperorg[3];
float g_demosniperangles[3];
float g_demozoom;

// FIXME:  There should be buffer helper functions to avoid all of the *(int *)& crap.

/*
=====================
Demo_WriteBuffer

Write some data to the demo stream
=====================
*/
void Demo_WriteBuffer( int type, int size, unsigned char *buffer )
{
	int pos = 0;
	unsigned char buf[ 32 * 1024 ];
	*( int * )&buf[pos] = type;
	pos+=sizeof( int );

	memcpy( &buf[pos], buffer, size );

	// Write full buffer out
	gEngfuncs.pDemoAPI->WriteBuffer( size + sizeof( int ), buf );
}

/*
=====================
Demo_ReadBuffer

Engine wants us to parse some data from the demo stream
=====================
*/
void DLLEXPORT Demo_ReadBuffer( int size, unsigned char *buffer )
{
	int type;
	int i = 0;

	type = *( int * )buffer;
	i += sizeof( int );
	switch ( type )
	{
	case TYPE_SNIPERDOT:
		g_demosniper = *(int * )&buffer[ i ];
		i += sizeof( int );
		
		if ( g_demosniper )
		{
			g_demosniperdamage = *( int * )&buffer[ i ];
			i += sizeof( int );

			g_demosniperangles[ 0 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperangles[ 1 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperangles[ 2 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperorg[ 0 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperorg[ 1 ] = *(float *)&buffer[i];
			i += sizeof( float );
			g_demosniperorg[ 2 ] = *(float *)&buffer[i];
			i += sizeof( float );
		}
		break;
	case TYPE_ZOOM:
		g_demozoom = *(float * )&buffer[ i ];
		i += sizeof( float );
		break;
	default:
		gEngfuncs.Con_DPrintf( "Unknown demo buffer type, skipping.\n" );
		break;
	}
}

```

`cl_dll/draw_util.cpp`:

```cpp
/*
draw_util.cpp - Draw Utils
Copyright (C) 2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/

#include "hud.h"
#include "cl_util.h"
#include "draw_util.h"
#include "triangleapi.h"
#include <string.h>

float DrawUtils::color[3];

#define IsColorString( p )	( p && *( p ) == '^' && *(( p ) + 1) && *(( p ) + 1) >= '0' && *(( p ) + 1 ) <= '9' )
#define ColorIndex( c )	((( c ) - '0' ) & 7 )

// console color typeing
byte g_color_table[][4] =
{
{100, 100, 100, 255},	// should be black, but hud font is additive, so printing black characters is impossible
{255,   0,   0, 255},	// red
{  0, 255,   0, 255},	// green
{255, 255,   0, 255},	// yellow
{  0,   0, 255, 255},	// blue
{  0, 255, 255, 255},	// cyan
{255,   0, 255, 255},	// magenta
{240, 180,  24, 255},	// default color (can be changed by user)
};


int DrawUtils::DrawHudString( int xpos, int ypos, int iMaxX, const char *str, int r, int g, int b, float scale, bool drawing )
{
	char *szIt = (char *)str;
	// draw the string until we hit the null character or a newline character
	for ( ; *szIt != 0 && *szIt != '\n'; szIt++ )
	{
		int next = xpos + gHUD.GetCharWidth((unsigned char)*szIt); // variable-width fonts look cool
		if ( next > iMaxX )
			return xpos;

		if ( *szIt == '\\' && *( szIt + 1 ) != '\n' && *( szIt + 1 ) != 0 )
		{
			// an escape character

			switch ( *( ++szIt ) )
			{
			case 'y':
				UnpackRGB( r, g, b, RGB_YELLOWISH );
				continue;
			case 'w':
				r = g = b = 255;
				continue;
			case 'd':
				continue;
			case 'R':
				//if( drawing ) return xpos;
				//return DrawHudStringReverse( iMaxX, ypos, first_xpos, szIt, r, g, b, true ); // set 'drawing' to true, to stop when '\R' is catched
				xpos = iMaxX - gHUD.GetCharWidth('M') * 10;
				++szIt;
			}
		}
		else if( IsColorString( szIt ) )
		{
			szIt++;
			if( gHUD.hud_colored->value )
			{
				r = g_color_table[ColorIndex( *szIt )][0];
				g = g_color_table[ColorIndex( *szIt )][1];
				b = g_color_table[ColorIndex( *szIt )][2];
			}
			continue;
		}

		xpos += TextMessageDrawChar( xpos, ypos, *szIt, r, g, b, scale );
	}

	return xpos;
}


int DrawUtils::DrawHudStringReverse( int xpos, int ypos, int iMinX, const char *szString, int r, int g, int b, float scale, bool drawing )
{
	// iterate throug the string in reverse
	for ( signed int i = strlen( szString ); i >= 0; i-- )
	{
		int next = xpos - gHUD.GetCharWidth((unsigned char)szString[i]); // variable-width fonts look cool
		if ( next < iMinX )
			return xpos;
		xpos = next;

		if ( i > 1 )
		{
			if( szString[i - 1] == '\\' )
			{
				// an escape character

				switch ( szString[i] )
				{
				case 'y':
					UnpackRGB( r, g, b, RGB_YELLOWISH );
					break;
				case 'w':
					r = g = b = 255;
					break;
				case 'R':
				//if( drawing ) return xpos;
				//else return DrawHudString( iMinX, ypos, first_xpos, &szString[i - 1], r, g, b, true ); // set 'drawing' to true, to stop when '\R' is catched
				//xpos = iMinX + gHUD.m_scrinfo.charWidths['M'] * i ;
				case 'd':
					break;
				}
				continue;
			}
			else if( IsColorString( szString - 1 ) )
			{
				if( gHUD.hud_colored->value )
				{
					r = g_color_table[ColorIndex( *szString )][0];
					g = g_color_table[ColorIndex( *szString )][1];
					b = g_color_table[ColorIndex( *szString )][2];
				}
				i--;
				continue;
			}
		}

		TextMessageDrawChar( xpos, ypos, szString[i], r, g, b, scale );
	}

	return xpos;
}

int DrawUtils::DrawHudNumber( int x, int y, int iFlags, int iNumber, int r, int g, int b )
{
	int iWidth = gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ).right - gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ).left;
	int k;

	if ( iNumber > 0 )
	{
		// SPR_Draw 100's
		if ( iNumber >= 100 )
		{
			k = iNumber / 100;
			SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
			SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
			x += iWidth;
		}
		else if ( iFlags & ( DHN_3DIGITS ) )
		{
			//SPR_DrawAdditive( 0, x, y, &rc );
			x += iWidth;
		}

		// SPR_Draw 10's
		if ( iNumber >= 10 )
		{
			k = ( iNumber % 100 ) / 10;
			SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
			SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
			x += iWidth;
		}
		else if ( iFlags & ( DHN_3DIGITS | DHN_2DIGITS ) )
		{
			//SPR_DrawAdditive( 0, x, y, &rc );
			x += iWidth;
		}

		// SPR_Draw ones
		k = iNumber % 10;
		SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
		x += iWidth;
	}
	else if ( iFlags & DHN_DRAWZERO )
	{
		SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 ), r, g, b );

		// SPR_Draw 100's
		if ( iFlags & ( DHN_3DIGITS ) )
		{
			//SPR_DrawAdditive( 0, x, y, &rc );
			x += iWidth;
		}

		if ( iFlags & ( DHN_3DIGITS | DHN_2DIGITS ) )
		{
			//SPR_DrawAdditive( 0, x, y, &rc );
			x += iWidth;
		}

		// SPR_Draw ones

		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ) );
		x += iWidth;
	}

	return x;
}

int DrawUtils::DrawHudNumber2( int x, int y, bool DrawZero, int iDigits, int iNumber, int r, int g, int b )
{
	int iWidth = gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ).right - gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ).left;
	x += ( iDigits - 1 ) * iWidth;

	int ResX = x + iWidth;
	do
	{
		int k = iNumber % 10;
		iNumber /= 10;
		SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
		x -= iWidth;
		iDigits--;
	} while ( iNumber > 0 || ( iDigits > 0 && DrawZero ) );

	return ResX;
}

int DrawUtils::DrawHudNumber2( int x, int y, int iNumber, int r, int g, int b )
{
	int iWidth = gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ).right - gHUD.GetSpriteRect( gHUD.m_HUD_number_0 ).left;

	int iDigits = 0;
	int temp    = iNumber;
	do
	{
		iDigits++;
		temp /= 10;
	} while ( temp > 0 );

	x += ( iDigits - 1 ) * iWidth;

	int ResX = x + iWidth;
	do
	{
		int k = iNumber % 10;
		iNumber /= 10;
		SPR_Set( gHUD.GetSprite( gHUD.m_HUD_number_0 + k ), r, g, b );
		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect( gHUD.m_HUD_number_0 + k ) );
		x -= iWidth;
	} while ( iNumber > 0 );

	return ResX;
}

void DrawUtils::Draw2DQuad( float x1, float y1, float x2, float y2 )
{
	gEngfuncs.pTriAPI->Begin( TRI_QUADS );

	gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
	gEngfuncs.pTriAPI->Vertex3f( x1, y1, 0 );

	gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
	gEngfuncs.pTriAPI->Vertex3f( x1, y2, 0 );

	gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
	gEngfuncs.pTriAPI->Vertex3f( x2, y2, 0 );

	gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
	gEngfuncs.pTriAPI->Vertex3f( x2, y1, 0 );

	gEngfuncs.pTriAPI->End( );
}

int DrawUtils::HudStringLen( const char *szIt, float scale )
{
	int l;
	// count length until we hit the null character or a newline character
	for ( l = 0; *szIt != 0 && *szIt != '\n'; szIt++ )
	{
		if( szIt[0] == '\\' && szIt[1] != '\n' &&
			(szIt[1] == 'y' || szIt[1] == 'w' || szIt[1] == 'd' || szIt[1] == 'R') ) // not sure is reversing handled correctly
		{
			szIt++;
			continue;
		}

		if( IsColorString( szIt ) ) // suck down, unreadable nicknames. Check even if hud_colored is off
		{
			szIt++;
			continue;
		}

		l += gHUD.m_scrinfo.charWidths[(unsigned char)*szIt] * scale;
	}
	return l;
}

```

`cl_dll/entity.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// Client side entity management functions

#include <memory.h>

#include "hud.h"
#include "pm_defs.h"
#include "pmtrace.h"
#include "pm_shared.h"
#include "cl_util.h"
#include "const.h"
#include "entity_types.h"
#include "studio_event.h" // def. of mstudioevent_t
#include "r_efx.h"
#include "event_api.h"

extern vec3_t v_origin;

int iOnTrain[MAX_PLAYERS];

/*
========================
HUD_AddEntity
	Return 0 to filter entity from visible list for rendering
========================
*/
int DLLEXPORT HUD_AddEntity( int type, struct cl_entity_s *ent, const char *modelname )
{
	switch ( type )
	{
	case ET_NORMAL:
	case ET_PLAYER:
		if(ent->player && iOnTrain[ent->index])
		{
			VectorCopy(ent->curstate.origin, ent->origin);
			VectorCopy(ent->curstate.angles, ent->angles);
		}
		break;
	case ET_BEAM:
	case ET_TEMPENTITY:
	case ET_FRAGMENTED:
	default:
		break;
	}
	// each frame every entity passes this function, so the overview hooks it to filter the overview entities
	// in spectator mode:
	// each frame every entity passes this function, so the overview hooks 
	// it to filter the overview entities

	if ( g_iUser1 )
	{
		gHUD.m_Spectator.AddOverviewEntity( type, ent, modelname );

		if ( (	g_iUser1 == OBS_IN_EYE || gHUD.m_Spectator.m_pip->value == INSET_IN_EYE ) &&
				ent->index == g_iUser2 )
			return 0;	// don't draw the player we are following in eye

	}

	return 1;
}

/*
=========================
HUD_TxferLocalOverrides

The server sends us our origin with extra precision as part of the clientdata structure, not during the normal
playerstate update in entity_state_t.  In order for these overrides to eventually get to the appropriate playerstate
structure, we need to copy them into the state structure at this point.
=========================
*/
void DLLEXPORT HUD_TxferLocalOverrides( struct entity_state_s *state, const struct clientdata_s *client )
{
	VectorCopy( client->origin, state->origin );

	// Spectator
	state->iuser1 = client->iuser1;
	state->iuser2 = client->iuser2;

	// Duck prevention
	state->iuser3 = client->iuser3;

	// Fire prevention
	state->iuser4 = client->iuser4;
}

/*
=========================
HUD_ProcessPlayerState

We have received entity_state_t for this player over the network.  We need to copy appropriate fields to the
playerstate structure
=========================
*/
void DLLEXPORT HUD_ProcessPlayerState( struct entity_state_s *dst, const struct entity_state_s *src )
{
	// Copy in network data
	VectorCopy( src->origin, dst->origin );
	VectorCopy( src->angles, dst->angles );

	VectorCopy( src->velocity, dst->velocity );

	dst->frame					= src->frame;
	dst->modelindex				= src->modelindex;
	dst->skin					= src->skin;
	dst->effects				= src->effects;
	dst->weaponmodel			= src->weaponmodel;
	dst->movetype				= src->movetype;
	dst->sequence				= src->sequence;
	dst->animtime				= src->animtime;
	
	dst->solid					= src->solid;
	
	dst->rendermode				= src->rendermode;
	dst->renderamt				= src->renderamt;	
	dst->rendercolor.r			= src->rendercolor.r;
	dst->rendercolor.g			= src->rendercolor.g;
	dst->rendercolor.b			= src->rendercolor.b;
	dst->renderfx				= src->renderfx;

	dst->framerate				= src->framerate;
	dst->body					= src->body;

	memcpy( &dst->controller[0], &src->controller[0], 4 * sizeof( byte ) );
	memcpy( &dst->blending[0], &src->blending[0], 2 * sizeof( byte ) );

	VectorCopy( src->basevelocity, dst->basevelocity );

	dst->friction				= src->friction;
	dst->gravity				= src->gravity;
	dst->gaitsequence			= src->gaitsequence;
	dst->spectator				= src->spectator;
	dst->usehull				= src->usehull;
	dst->playerclass			= src->playerclass;
	dst->team					= src->team;
	dst->colormap				= src->colormap;

	// Save off some data so other areas of the Client DLL can get to it
	cl_entity_t *player = gEngfuncs.GetLocalPlayer();	// Get the local player's index
	if ( dst->number == player->index )
	{
		g_iTeamNumber = g_PlayerExtraInfo[dst->number].teamnumber;

		dst->iuser1 = g_iUser1 = src->iuser1;
		dst->iuser2 = g_iUser2 = src->iuser2;
		dst->iuser3 = g_iUser3 = src->iuser3;
	}
	dst->fuser2					= src->fuser2;
	if( src->number > 0 && src->number < MAX_PLAYERS )
	{
		iOnTrain[src->number]		= src->iuser4;
	}
}

/*
=========================
HUD_TxferPredictionData

Because we can predict an arbitrary number of frames before the server responds with an update, we need to be able to copy client side prediction data in
 from the state that the server ack'd receiving, which can be anywhere along the predicted frame path ( i.e., we could predict 20 frames into the future and the server ack's
 up through 10 of those frames, so we need to copy persistent client-side only state from the 10th predicted frame to the slot the server
 update is occupying.
=========================
*/
void DLLEXPORT HUD_TxferPredictionData ( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd )
{
	ps->oldbuttons = pps->oldbuttons;
	ps->flFallVelocity = pps->flFallVelocity;
	ps->iStepLeft = pps->iStepLeft;
	ps->playerclass	= pps->playerclass;
	ps->iuser4 = pps->iuser4;

	pcd->viewmodel = ppcd->viewmodel;
	pcd->m_iId = ppcd->m_iId;
	pcd->ammo_shells = ppcd->ammo_shells;
	pcd->ammo_nails	= ppcd->ammo_nails;
	pcd->ammo_cells	= ppcd->ammo_cells;
	pcd->ammo_rockets = ppcd->ammo_rockets;
	pcd->m_flNextAttack	= ppcd->m_flNextAttack;
	pcd->fov = ppcd->fov;
	pcd->weaponanim = ppcd->weaponanim;
	pcd->tfstate = ppcd->tfstate;
	pcd->maxspeed = ppcd->maxspeed;
	pcd->deadflag = ppcd->deadflag;
	if( gEngfuncs.IsSpectateOnly() )
	{
		pcd->iuser1 = g_iUser1;	// observer mode
		pcd->iuser2 = g_iUser2; // first target
		pcd->iuser3 = g_iUser3; // second target
	}
	else
	{
		pcd->iuser1	= ppcd->iuser1;
		pcd->iuser2	= ppcd->iuser2;
		pcd->iuser3 = ppcd->iuser3;
	}
	pcd->iuser4 = ppcd->iuser4;
	pcd->fuser2	= ppcd->fuser2;
	pcd->fuser3	= ppcd->fuser3;
	pcd->vuser2 = ppcd->vuser2;
	pcd->vuser3 = ppcd->vuser3;
	pcd->vuser4 = ppcd->vuser4;

	memcpy( wd, pwd, sizeof( weapon_data_t ) * 32 );
}

/*
=========================
HUD_CreateEntities
	
Gives us a chance to add additional entities to the render this frame
=========================
*/
void DLLEXPORT HUD_CreateEntities( void )
{
	// Add in any game specific objects

	//GetClientVoiceMgr()->CreateEntities();
}

/*
=========================
HUD_StudioEvent

The entity's studio model description indicated an event was
fired during this frame, handle the event by it's tag ( e.g., muzzleflash, sound )
=========================
*/
void DLLEXPORT HUD_StudioEvent( const struct mstudioevent_s *event, const struct cl_entity_s *entity )
{
	switch( event->event )
	{
	case 5001:
		gEngfuncs.pEfxAPI->R_MuzzleFlash( (float *)&entity->attachment[0], atoi( event->options) );
		break;
	case 5011:
		gEngfuncs.pEfxAPI->R_MuzzleFlash( (float *)&entity->attachment[1], atoi( event->options) );
		break;
	case 5021:
		gEngfuncs.pEfxAPI->R_MuzzleFlash( (float *)&entity->attachment[2], atoi( event->options) );
		break;
	case 5031:
		gEngfuncs.pEfxAPI->R_MuzzleFlash( (float *)&entity->attachment[3], atoi( event->options) );
		break;
	case 5002:
		gEngfuncs.pEfxAPI->R_SparkEffect( (float *)&entity->attachment[0], atoi( event->options), -100, 100 );
		break;
	// Client side sound
	case 5004:		
		gEngfuncs.pfnPlaySoundByNameAtLocation( (char *)event->options, 1.0, (float *)&entity->attachment[0] );
		break;
	default:
		break;
	}
}

/*
=================
CL_UpdateTEnts

Simulation and cleanup of temporary entities
=================
*/
void DLLEXPORT HUD_TempEntUpdate (
	double frametime,   // Simulation time
	double client_time, // Absolute time on client
	double cl_gravity,  // True gravity on client
	TEMPENTITY **ppTempEntFree,   // List of freed temporary ents
	TEMPENTITY **ppTempEntActive, // List 
	int		( *Callback_AddVisibleEntity )( cl_entity_t *pEntity ),
	void	( *Callback_TempEntPlaySound )( TEMPENTITY *pTemp, float damp ) )
{
	static int gTempEntFrame = 0;
	int			i;
	TEMPENTITY	*pTemp, *pnext, *pprev;
	float		gravity, gravitySlow, life, fastFreq;

	// Nothing to simulate
	if ( !*ppTempEntActive )		
		return;

	// in order to have tents collide with players, we have to run the player prediction code so
	// that the client has the player list. We run this code once when we detect any COLLIDEALL 
	// tent, then set this BOOL to true so the code doesn't get run again if there's more than
	// one COLLIDEALL ent for this update. (often are).
	gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );

	// Store off the old count
	gEngfuncs.pEventAPI->EV_PushPMStates();

	// Now add in all of the players.
	gEngfuncs.pEventAPI->EV_SetSolidPlayers ( -1 );	

	// !!!BUGBUG	-- This needs to be time based
	gTempEntFrame = (gTempEntFrame+1) & 31;

	pTemp = *ppTempEntActive;

	// !!! Don't simulate while paused....  This is sort of a hack, revisit.
	if ( frametime <= 0 )
	{
		while ( pTemp )
		{
			if ( !(pTemp->flags & FTENT_NOMODEL ) )
			{
				Callback_AddVisibleEntity( &pTemp->entity );
			}
			pTemp = pTemp->next;
		}
		goto finish;
	}

	pprev = NULL;
	fastFreq = client_time * 5.5;
	gravity = -frametime * cl_gravity;
	gravitySlow = gravity * 0.5;

	while ( pTemp )
	{
		int active;

		active = 1;

		life = pTemp->die - client_time;
		pnext = pTemp->next;
		if ( life < 0 )
		{
			if ( pTemp->flags & FTENT_FADEOUT )
			{
				if (pTemp->entity.curstate.rendermode == kRenderNormal)
					pTemp->entity.curstate.rendermode = kRenderTransTexture;
				pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt * ( 1 + life * pTemp->fadeSpeed );
				if ( pTemp->entity.curstate.renderamt <= 0 )
					active = 0;

			}
			else 
				active = 0;
		}
		if ( !active )		// Kill it
		{
			pTemp->next = *ppTempEntFree;
			*ppTempEntFree = pTemp;
			if ( !pprev )	// Deleting at head of list
				*ppTempEntActive = pnext;
			else
				pprev->next = pnext;
		}
		else
		{
			pprev = pTemp;
			
			VectorCopy( pTemp->entity.origin, pTemp->entity.prevstate.origin );

			if ( pTemp->flags & FTENT_SPARKSHOWER )
			{
				// Adjust speed if it's time
				// Scale is next think time
				if ( client_time > pTemp->entity.baseline.scale )
				{
					// Show Sparks
					gEngfuncs.pEfxAPI->R_SparkEffect( pTemp->entity.origin, 8, -200, 200 );

					// Reduce life
					pTemp->entity.baseline.framerate -= 0.1;

					if ( pTemp->entity.baseline.framerate <= 0.0 )
					{
						pTemp->die = client_time;
					}
					else
					{
						// So it will die no matter what
						pTemp->die = client_time + 0.5;

						// Next think
						pTemp->entity.baseline.scale = client_time + 0.1;
					}
				}
			}
			else if ( pTemp->flags & FTENT_PLYRATTACHMENT )
			{
				cl_entity_t *pClient;

				pClient = gEngfuncs.GetEntityByIndex( pTemp->clientIndex );

				VectorAdd( pClient->origin, pTemp->tentOffset, pTemp->entity.origin );
			}
			else if ( pTemp->flags & FTENT_SINEWAVE )
			{
				pTemp->x += pTemp->entity.baseline.origin[0] * frametime;
				pTemp->y += pTemp->entity.baseline.origin[1] * frametime;

				pTemp->entity.origin[0] = pTemp->x + sin( pTemp->entity.baseline.origin[2] + client_time * pTemp->entity.prevstate.frame ) * (10*pTemp->entity.curstate.framerate);
				pTemp->entity.origin[1] = pTemp->y + sin( pTemp->entity.baseline.origin[2] + fastFreq + 0.7 ) * (8*pTemp->entity.curstate.framerate);
				pTemp->entity.origin[2] += pTemp->entity.baseline.origin[2] * frametime;
			}
			else if ( pTemp->flags & FTENT_SPIRAL )
			{
				/*
				float s, c;
				s = sin( pTemp->entity.baseline.origin[2] + fastFreq );
				c = cos( pTemp->entity.baseline.origin[2] + fastFreq );
				*/

				pTemp->entity.origin[0] += pTemp->entity.baseline.origin[0] * frametime + 8 * sin( client_time * 20 + (long long)(void*)pTemp );
				pTemp->entity.origin[1] += pTemp->entity.baseline.origin[1] * frametime + 4 * sin( client_time * 30 + (long long)(void*)pTemp );
				pTemp->entity.origin[2] += pTemp->entity.baseline.origin[2] * frametime;
			}
			
			else 
			{
				for ( i = 0; i < 3; i++ ) 
					pTemp->entity.origin[i] += pTemp->entity.baseline.origin[i] * frametime;
			}
			
			if ( pTemp->flags & FTENT_SPRANIMATE )
			{
				pTemp->entity.curstate.frame += frametime * pTemp->entity.curstate.framerate;
				if ( pTemp->entity.curstate.frame >= pTemp->frameMax )
				{
					pTemp->entity.curstate.frame = pTemp->entity.curstate.frame - (int)(pTemp->entity.curstate.frame);

					if ( !(pTemp->flags & FTENT_SPRANIMATELOOP) )
					{
						// this animating sprite isn't set to loop, so destroy it.
						pTemp->die = client_time;
						pTemp = pnext;
						continue;
					}
				}
			}
			else if ( pTemp->flags & FTENT_SPRCYCLE )
			{
				pTemp->entity.curstate.frame += frametime * 10;
				if ( pTemp->entity.curstate.frame >= pTemp->frameMax )
				{
					pTemp->entity.curstate.frame = pTemp->entity.curstate.frame - (int)(pTemp->entity.curstate.frame);
				}
			}
// Experiment
#if 0
			if ( pTemp->flags & FTENT_SCALE )
				pTemp->entity.curstate.framerate += 20.0 * (frametime / pTemp->entity.curstate.framerate);
#endif

			if ( pTemp->flags & FTENT_ROTATE )
			{
				pTemp->entity.angles[0] += pTemp->entity.baseline.angles[0] * frametime;
				pTemp->entity.angles[1] += pTemp->entity.baseline.angles[1] * frametime;
				pTemp->entity.angles[2] += pTemp->entity.baseline.angles[2] * frametime;

				VectorCopy( pTemp->entity.angles, pTemp->entity.latched.prevangles );
			}

			if ( pTemp->flags & (FTENT_COLLIDEALL | FTENT_COLLIDEWORLD) && !(pTemp->flags & FTENT_IGNOREGRAVITY))
			{
				vec3_t	traceNormal;
				float	traceFraction = 1;

				if ( pTemp->flags & FTENT_COLLIDEALL )
				{
					pmtrace_t pmtrace;
					physent_t *pe;
				
					gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );

					gEngfuncs.pEventAPI->EV_PlayerTrace( pTemp->entity.prevstate.origin, pTemp->entity.origin, PM_STUDIO_BOX, -1, &pmtrace );

					if ( pmtrace.fraction != 1 )
					{
						pe = gEngfuncs.pEventAPI->EV_GetPhysent( pmtrace.ent );

						if ( !pmtrace.ent || ( pe->info != pTemp->clientIndex ) )
						{
							traceFraction = pmtrace.fraction;
							VectorCopy( pmtrace.plane.normal, traceNormal );

							if ( pTemp->hitcallback )
							{
								(*pTemp->hitcallback)( pTemp, &pmtrace );
							}
						}
					}
				}
				else if ( pTemp->flags & FTENT_COLLIDEWORLD )
				{
					pmtrace_t pmtrace;
					
					gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );

					gEngfuncs.pEventAPI->EV_PlayerTrace( pTemp->entity.prevstate.origin, pTemp->entity.origin, PM_STUDIO_BOX | PM_WORLD_ONLY, -1, &pmtrace );					

					if ( pmtrace.fraction != 1 )
					{
						traceFraction = pmtrace.fraction;
						VectorCopy( pmtrace.plane.normal, traceNormal );

						if ( pTemp->flags & FTENT_SPARKSHOWER )
						{
							// Chop spark speeds a bit more
							//
							VectorScale( pTemp->entity.baseline.origin, 0.6, pTemp->entity.baseline.origin );

							if ( pTemp->entity.baseline.origin.Length() < 10 )
							{
								pTemp->entity.baseline.framerate = 0.0;								
							}
						}

						if ( pTemp->hitcallback )
						{
							(*pTemp->hitcallback)( pTemp, &pmtrace );
						}
					}
				}
				
				if ( traceFraction != 1 )	// Decent collision now, and damping works
				{
					float  proj, damp;

					// Place at contact point
					VectorMA( pTemp->entity.prevstate.origin, traceFraction*frametime, pTemp->entity.baseline.origin, pTemp->entity.origin );
					// Damp velocity
					damp = pTemp->bounceFactor;
					if ( pTemp->flags & (FTENT_GRAVITY|FTENT_SLOWGRAVITY) )
					{
						damp *= 0.5;
						if ( traceNormal[2] > 0.9 )		// Hit floor?
						{
							if ( pTemp->entity.baseline.origin[2] <= 0 && pTemp->entity.baseline.origin[2] >= gravity*3 )
							{
								damp = 0;		// Stop
								pTemp->flags &= ~(FTENT_ROTATE|FTENT_GRAVITY|FTENT_SLOWGRAVITY|FTENT_COLLIDEWORLD|FTENT_SMOKETRAIL);
								pTemp->entity.angles[0] = 0;
								pTemp->entity.angles[2] = 0;
							}
						}
					}

					if (pTemp->hitSound)
					{
						Callback_TempEntPlaySound(pTemp, damp);
					}

					if (pTemp->flags & FTENT_COLLIDEKILL)
					{
						// die on impact
						pTemp->flags &= ~FTENT_FADEOUT;	
						pTemp->die = client_time;			
					}
					else
					{
						// Reflect velocity
						if ( damp != 0 )
						{
							proj = DotProduct( pTemp->entity.baseline.origin, traceNormal );
							VectorMA( pTemp->entity.baseline.origin, -proj*2, traceNormal, pTemp->entity.baseline.origin );
							// Reflect rotation (fake)

							pTemp->entity.angles[1] = -pTemp->entity.angles[1];
						}
						
						if ( damp != 1 )
						{

							VectorScale( pTemp->entity.baseline.origin, damp, pTemp->entity.baseline.origin );
							VectorScale( pTemp->entity.angles, 0.9, pTemp->entity.angles );
						}
					}
				}
			}


			if ( (pTemp->flags & FTENT_FLICKER) && gTempEntFrame == pTemp->entity.curstate.effects )
			{
				dlight_t *dl = gEngfuncs.pEfxAPI->CL_AllocDlight (0);
				VectorCopy (pTemp->entity.origin, dl->origin);
				dl->radius = 60;
				dl->color.r = 255;
				dl->color.g = 120;
				dl->color.b = 0;
				dl->die = client_time + 0.01;
			}

			if ( pTemp->flags & FTENT_SMOKETRAIL )
			{
				gEngfuncs.pEfxAPI->R_RocketTrail (pTemp->entity.prevstate.origin, pTemp->entity.origin, 1);
			}

			if( !(pTemp->flags & FTENT_IGNOREGRAVITY) )
			{
				if ( pTemp->flags & FTENT_GRAVITY )
					pTemp->entity.baseline.origin[2] += gravity;
				else if ( pTemp->flags & FTENT_SLOWGRAVITY )
					pTemp->entity.baseline.origin[2] += gravitySlow;
			}

			if ( pTemp->flags & FTENT_CLIENTCUSTOM )
			{
				if ( pTemp->callback )
				{
					( *pTemp->callback )( pTemp, frametime, client_time );
				}
			}

			// Cull to PVS (not frustum cull, just PVS)
			if ( !(pTemp->flags & FTENT_NOMODEL ) )
			{
				if ( !Callback_AddVisibleEntity( &pTemp->entity ) )
				{
					if ( !(pTemp->flags & FTENT_PERSIST) ) 
					{
						pTemp->die = client_time;			// If we can't draw it this frame, just dump it.
						pTemp->flags &= ~FTENT_FADEOUT;	// Don't fade out, just die
					}
				}
			}
		}
		pTemp = pnext;
	}

finish:
	// Restore state info
	gEngfuncs.pEventAPI->EV_PopPMStates();
}

/*
=================
HUD_GetUserEntity

If you specify negative numbers for beam start and end point entities, then
  the engine will call back into this function requesting a pointer to a cl_entity_t 
  object that describes the entity to attach the beam onto.

Indices must start at 1, not zero.
=================
*/
cl_entity_t DLLEXPORT *HUD_GetUserEntity( int index )
{
	return NULL;
}


```

`cl_dll/ev_common.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// shared event functions
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"

#include "r_efx.h"

#include "eventscripts.h"
#include "event_api.h"
#include "pm_shared.h"

/*
=================
EV_GetGunPosition

Figure out the height of the gun
=================
*/
void EV_GetGunPosition( event_args_t *args, float *pos, float *origin )
{
	int idx;
	Vector view_ofs(0, 0, 0);

	idx = args->entindex;

	view_ofs[2] = DEFAULT_VIEWHEIGHT;

	if ( EV_IsPlayer( idx ) )
	{
		// in spec mode use entity viewheigh, not own
		if ( EV_IsLocal( idx ) && !IS_FIRSTPERSON_SPEC )
		{
			// Grab predicted result for local player
			gEngfuncs.pEventAPI->EV_LocalPlayerViewheight( view_ofs );
		}
		else if ( args->ducking == 1 )
		{
			view_ofs[2] = VEC_DUCK_VIEW;
		}
	}

	VectorAdd( origin, view_ofs, pos );
}

/*
=================
EV_GetDefaultShellInfo

Determine where to eject shells from
=================
*/
void EV_GetDefaultShellInfo( event_args_t *args, float *origin, float *velocity, float *ShellVelocity, float *ShellOrigin, float *forward, float *right, float *up, float forwardScale, float upScale, float rightScale, bool bReverseDirection )
{
	int idx = args->entindex;

	vec3_t view_ofs = { 0, 0, DEFAULT_VIEWHEIGHT };
	if ( EV_IsPlayer( idx ) )
	{
		if ( EV_IsLocal( idx ) )
		{
			gEngfuncs.pEventAPI->EV_LocalPlayerViewheight( view_ofs );
		}
		else if ( args->ducking == 1 )
		{
			view_ofs[2] = VEC_DUCK_VIEW;
		}
	}

	float fR = gEngfuncs.pfnRandomFloat( 50, 70 );
	float fU = gEngfuncs.pfnRandomFloat( 75, 175 );
	float fF = gEngfuncs.pfnRandomFloat( 25, 250 );
	float fDirection = rightScale > 0.0f ? -1.0f : 1.0f;

	for ( int i = 0; i < 3; i++ )
	{
		if( bReverseDirection )
		{
			ShellVelocity[i] = velocity[i] * 0.5f - right[i] * fR * fDirection + up[i] * fU + forward[i] * fF;
		}
		else
		{
			ShellVelocity[i] = velocity[i] * 0.5f + right[i] * fR * fDirection + up[i] * fU + forward[i] * fF;
		}
		ShellOrigin[i]   = velocity[i] * 0.1f + origin[i] + view_ofs[i] +
				upScale * up[i] + forwardScale * forward[i] + rightScale * right[i];
	}
}

```

`cl_dll/ev_hldm.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "entity_types.h"
#include "usercmd.h"
#include "pm_defs.h"
#include "pm_materials.h"

#include "eventscripts.h"
#include "ev_hldm.h"

#include "r_efx.h"
#include "event_api.h"
#include "event_args.h"
#include "in_defs.h"

#include <string.h>

#include "r_studioint.h"
#include "com_model.h"

extern engine_studio_api_t IEngineStudio;

static int tracerCount[ 32 ];

extern "C" char PM_FindTextureType( char *name );

void V_PunchAxis( int axis, float punch );
void VectorAngles( const float *forward, float *angles );

extern cvar_t *cl_lw;

extern "C"
{

// HLDM
void EV_FireGlock1( struct event_args_s *args  );
void EV_FireGlock2( struct event_args_s *args  );
void EV_FireShotGunSingle( struct event_args_s *args  );
void EV_FireShotGunDouble( struct event_args_s *args  );
void EV_FireMP5( struct event_args_s *args  );
void EV_FireMP52( struct event_args_s *args  );
void EV_FirePython( struct event_args_s *args  );
void EV_FireGauss( struct event_args_s *args  );
void EV_SpinGauss( struct event_args_s *args  );
void EV_Crowbar( struct event_args_s *args  );
void EV_FireCrossbow( struct event_args_s *args  );
void EV_FireCrossbow2( struct event_args_s *args  );
void EV_FireRpg( struct event_args_s *args  );
void EV_EgonFire( struct event_args_s *args  );
void EV_EgonStop( struct event_args_s *args  );
void EV_HornetGunFire( struct event_args_s *args  );
void EV_TripmineFire( struct event_args_s *args  );
void EV_SnarkFire( struct event_args_s *args  );
void EV_Dummy( struct event_args_s *args );

void EV_TrainPitchAdjust( struct event_args_s *args );
}

#define VECTOR_CONE_1DEGREES Vector( 0.00873, 0.00873, 0.00873 )
#define VECTOR_CONE_2DEGREES Vector( 0.01745, 0.01745, 0.01745 )
#define VECTOR_CONE_3DEGREES Vector( 0.02618, 0.02618, 0.02618 )
#define VECTOR_CONE_4DEGREES Vector( 0.03490, 0.03490, 0.03490 )
#define VECTOR_CONE_5DEGREES Vector( 0.04362, 0.04362, 0.04362 )
#define VECTOR_CONE_6DEGREES Vector( 0.05234, 0.05234, 0.05234 )
#define VECTOR_CONE_7DEGREES Vector( 0.06105, 0.06105, 0.06105 )	
#define VECTOR_CONE_8DEGREES Vector( 0.06976, 0.06976, 0.06976 )
#define VECTOR_CONE_9DEGREES Vector( 0.07846, 0.07846, 0.07846 )
#define VECTOR_CONE_10DEGREES Vector( 0.08716, 0.08716, 0.08716 )
#define VECTOR_CONE_15DEGREES Vector( 0.13053, 0.13053, 0.13053 )
#define VECTOR_CONE_20DEGREES Vector( 0.17365, 0.17365, 0.17365 )

// play a strike sound based on the texture that was hit by the attack traceline.  VecSrc/VecEnd are the
// original traceline endpoints used by the attacker, iBulletType is the type of bullet that hit the texture.
// returns volume of strike instrument (crowbar) to play
float EV_HLDM_PlayTextureSound( int idx, pmtrace_t *ptr, float *vecSrc, float *vecEnd, int iBulletType )
{
	// hit the world, try to play sound based on texture material type
	char chTextureType = CHAR_TEX_CONCRETE;
	float fvol;
	float fvolbar;
	char *rgsz[4];
	int cnt;
	float fattn = ATTN_NORM;
	int entity;
	char *pTextureName;
	char texname[ 64 ];
	char szbuffer[ 64 ];

	entity = gEngfuncs.pEventAPI->EV_IndexFromTrace( ptr );

	// FIXME check if playtexture sounds movevar is set
	//

	chTextureType = 0;

	// Player
	if ( entity >= 1 && entity <= gEngfuncs.GetMaxClients() )
	{
		// hit body
		chTextureType = CHAR_TEX_FLESH;
	}
	else if ( entity == 0 )
	{
		// get texture from entity or world (world is ent(0))
		pTextureName = (char *)gEngfuncs.pEventAPI->EV_TraceTexture( ptr->ent, vecSrc, vecEnd );
		
		if ( pTextureName )
		{
			strcpy( texname, pTextureName );
			pTextureName = texname;

			// strip leading '-0' or '+0~' or '{' or '!'
			if (*pTextureName == '-' || *pTextureName == '+')
			{
				pTextureName += 2;
			}

			if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')
			{
				pTextureName++;
			}
			
			// '}}'
			strcpy( szbuffer, pTextureName );
			szbuffer[ CBTEXTURENAMEMAX - 1 ] = 0;
				
			// get texture type
			chTextureType = PM_FindTextureType( szbuffer );	
		}
	}
	
	switch (chTextureType)
	{
	default:
	case CHAR_TEX_CONCRETE: fvol = 0.9;	fvolbar = 0.6;
		rgsz[0] = "player/pl_step1.wav";
		rgsz[1] = "player/pl_step2.wav";
		cnt = 2;
		break;
	case CHAR_TEX_METAL: fvol = 0.9; fvolbar = 0.3;
		rgsz[0] = "player/pl_metal1.wav";
		rgsz[1] = "player/pl_metal2.wav";
		cnt = 2;
		break;
	case CHAR_TEX_DIRT:	fvol = 0.9; fvolbar = 0.1;
		rgsz[0] = "player/pl_dirt1.wav";
		rgsz[1] = "player/pl_dirt2.wav";
		rgsz[2] = "player/pl_dirt3.wav";
		cnt = 3;
		break;
	case CHAR_TEX_VENT:	fvol = 0.5; fvolbar = 0.3;
		rgsz[0] = "player/pl_duct1.wav";
		rgsz[1] = "player/pl_duct1.wav";
		cnt = 2;
		break;
	case CHAR_TEX_GRATE: fvol = 0.9; fvolbar = 0.5;
		rgsz[0] = "player/pl_grate1.wav";
		rgsz[1] = "player/pl_grate4.wav";
		cnt = 2;
		break;
	case CHAR_TEX_TILE:	fvol = 0.8; fvolbar = 0.2;
		rgsz[0] = "player/pl_tile1.wav";
		rgsz[1] = "player/pl_tile3.wav";
		rgsz[2] = "player/pl_tile2.wav";
		rgsz[3] = "player/pl_tile4.wav";
		cnt = 4;
		break;
	case CHAR_TEX_SLOSH: fvol = 0.9; fvolbar = 0.0;
		rgsz[0] = "player/pl_slosh1.wav";
		rgsz[1] = "player/pl_slosh3.wav";
		rgsz[2] = "player/pl_slosh2.wav";
		rgsz[3] = "player/pl_slosh4.wav";
		cnt = 4;
		break;
	case CHAR_TEX_WOOD: fvol = 0.9; fvolbar = 0.2;
		rgsz[0] = "debris/wood1.wav";
		rgsz[1] = "debris/wood2.wav";
		rgsz[2] = "debris/wood3.wav";
		cnt = 3;
		break;
	case CHAR_TEX_GLASS:
	case CHAR_TEX_COMPUTER:
		fvol = 0.8; fvolbar = 0.2;
		rgsz[0] = "debris/glass1.wav";
		rgsz[1] = "debris/glass2.wav";
		rgsz[2] = "debris/glass3.wav";
		cnt = 3;
		break;
	case CHAR_TEX_FLESH:
		if (iBulletType == BULLET_PLAYER_CROWBAR)
			return 0.0; // crowbar already makes this sound
		fvol = 1.0;	fvolbar = 0.2;
		rgsz[0] = "weapons/bullet_hit1.wav";
		rgsz[1] = "weapons/bullet_hit2.wav";
		fattn = 1.0;
		cnt = 2;
		break;
	}

	// play material hit sound
	gEngfuncs.pEventAPI->EV_PlaySound( 0, ptr->endpos, CHAN_STATIC, rgsz[gEngfuncs.pfnRandomLong(0,cnt-1)], fvol, fattn, 0, 96 + gEngfuncs.pfnRandomLong(0,0xf) );
	return fvolbar;
}

char *EV_HLDM_DamageDecal( physent_t *pe )
{
	static char decalname[ 32 ];
	int idx;

	if ( pe->classnumber == 1 )
	{
		idx = gEngfuncs.pfnRandomLong( 0, 2 );
		sprintf( decalname, "{break%i", idx + 1 );
	}
	else if ( pe->rendermode != kRenderNormal )
	{
		sprintf( decalname, "{bproof1" );
	}
	else
	{
		idx = gEngfuncs.pfnRandomLong( 0, 4 );
		sprintf( decalname, "{shot%i", idx + 1 );
	}
	return decalname;
}

void EV_HLDM_GunshotDecalTrace( pmtrace_t *pTrace, char *decalName )
{
	int iRand;
	physent_t *pe;

	gEngfuncs.pEfxAPI->R_BulletImpactParticles( pTrace->endpos );

	iRand = gEngfuncs.pfnRandomLong(0,0x7FFF);
	if ( iRand < (0x7fff/2) )// not every bullet makes a sound.
	{
		switch( iRand % 5)
		{
		case 0:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric1.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		case 1:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric2.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		case 2:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric3.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		case 3:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric4.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		case 4:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric5.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
		}
	}

	pe = gEngfuncs.pEventAPI->EV_GetPhysent( pTrace->ent );

	// Only decal brush models such as the world etc.
	if (  decalName && decalName[0] && pe && ( pe->solid == SOLID_BSP || pe->movetype == MOVETYPE_PUSHSTEP ) )
	{
		if ( CVAR_GET_FLOAT( "r_decals" ) )
		{
			gEngfuncs.pEfxAPI->R_DecalShoot( 
				gEngfuncs.pEfxAPI->Draw_DecalIndex( gEngfuncs.pEfxAPI->Draw_DecalIndexFromName( decalName ) ), 
				gEngfuncs.pEventAPI->EV_IndexFromTrace( pTrace ), 0, pTrace->endpos, 0 );
		}
	}
}

void EV_HLDM_DecalGunshot( pmtrace_t *pTrace, int iBulletType )
{
	physent_t *pe;

	pe = gEngfuncs.pEventAPI->EV_GetPhysent( pTrace->ent );

	if ( pe && pe->solid == SOLID_BSP )
	{
		switch( iBulletType )
		{
		case BULLET_PLAYER_9MM:
		case BULLET_MONSTER_9MM:
		case BULLET_PLAYER_MP5:
		case BULLET_MONSTER_MP5:
		case BULLET_PLAYER_BUCKSHOT:
		case BULLET_PLAYER_357:
		default:
			// smoke and decal
			EV_HLDM_GunshotDecalTrace( pTrace, EV_HLDM_DamageDecal( pe ) );
			break;
		}
	}
}

int EV_HLDM_CheckTracer( int idx, float *vecSrc, float *end, float *forward, float *right, int iBulletType, int iTracerFreq, int *tracerCount )
{
	int tracer = 0;
	int i;
	qboolean player = idx >= 1 && idx <= gEngfuncs.GetMaxClients() ? true : false;

	if ( iTracerFreq != 0 && ( (*tracerCount)++ % iTracerFreq) == 0 )
	{
		vec3_t vecTracerSrc;

		if ( player )
		{
			vec3_t offset( 0, 0, -4 );

			// adjust tracer position for player
			for ( i = 0; i < 3; i++ )
			{
				vecTracerSrc[ i ] = vecSrc[ i ] + offset[ i ] + right[ i ] * 2 + forward[ i ] * 16;
			}
		}
		else
		{
			VectorCopy( vecSrc, vecTracerSrc );
		}
		
		if ( iTracerFreq != 1 )		// guns that always trace also always decal
			tracer = 1;

		switch( iBulletType )
		{
		case BULLET_PLAYER_MP5:
		case BULLET_MONSTER_MP5:
		case BULLET_MONSTER_9MM:
		case BULLET_MONSTER_12MM:
		default:
			EV_CreateTracer( vecTracerSrc, end );
			break;
		}
	}

	return tracer;
}


/*
================
FireBullets

Go to the trouble of combining multiple pellets into a single damage call.
================
*/
void EV_HLDM_FireBullets( int idx, float *forward, float *right, float *up, int cShots, float *vecSrc, float *vecDirShooting, float flDistance, int iBulletType, int iTracerFreq, int *tracerCount, float flSpreadX, float flSpreadY )
{
	int i;
	pmtrace_t tr;
	int iShot;
	int tracer;
	
	for ( iShot = 1; iShot <= cShots; iShot++ )	
	{
		vec3_t vecDir, vecEnd;
			
		float x, y, z;
		//We randomize for the Shotgun.
		if ( iBulletType == BULLET_PLAYER_BUCKSHOT )
		{
			do {
				x = gEngfuncs.pfnRandomFloat(-0.5,0.5) + gEngfuncs.pfnRandomFloat(-0.5,0.5);
				y = gEngfuncs.pfnRandomFloat(-0.5,0.5) + gEngfuncs.pfnRandomFloat(-0.5,0.5);
				z = x*x+y*y;
			} while (z > 1);

			for ( i = 0 ; i < 3; i++ )
			{
				vecDir[i] = vecDirShooting[i] + x * flSpreadX * right[ i ] + y * flSpreadY * up [ i ];
				vecEnd[i] = vecSrc[ i ] + flDistance * vecDir[ i ];
			}
		}//But other guns already have their spread randomized in the synched spread.
		else
		{

			for ( i = 0 ; i < 3; i++ )
			{
				vecDir[i] = vecDirShooting[i] + flSpreadX * right[ i ] + flSpreadY * up [ i ];
				vecEnd[i] = vecSrc[ i ] + flDistance * vecDir[ i ];
			}
		}

		gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );
	
		// Store off the old count
		gEngfuncs.pEventAPI->EV_PushPMStates();
	
		// Now add in all of the players.
		gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	

		gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
		gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecEnd, PM_STUDIO_BOX, -1, &tr );

		tracer = EV_HLDM_CheckTracer( idx, vecSrc, tr.endpos, forward, right, iBulletType, iTracerFreq, tracerCount );

		// do damage, paint decals
		if ( tr.fraction != 1.0 )
		{
			switch(iBulletType)
			{
			default:
			case BULLET_PLAYER_9MM:		
				
				EV_HLDM_PlayTextureSound( idx, &tr, vecSrc, vecEnd, iBulletType );
				EV_HLDM_DecalGunshot( &tr, iBulletType );
			
					break;
			case BULLET_PLAYER_MP5:		
				
				if ( !tracer )
				{
					EV_HLDM_PlayTextureSound( idx, &tr, vecSrc, vecEnd, iBulletType );
					EV_HLDM_DecalGunshot( &tr, iBulletType );
				}
				break;
			case BULLET_PLAYER_BUCKSHOT:
				
				EV_HLDM_DecalGunshot( &tr, iBulletType );
			
				break;
			case BULLET_PLAYER_357:
				
				EV_HLDM_PlayTextureSound( idx, &tr, vecSrc, vecEnd, iBulletType );
				EV_HLDM_DecalGunshot( &tr, iBulletType );
				
				break;

			}
		}

		gEngfuncs.pEventAPI->EV_PopPMStates();
	}
}

//======================
//	    GLOCK START
//======================
void EV_FireGlock1( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	int empty;

	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t up, right, forward;
	
	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	empty = args->bparam1;
	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shell.mdl");// brass shell

	if ( EV_IsLocal( idx ) )
	{
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( empty ? GLOCK_SHOOT_EMPTY : GLOCK_SHOOT, 2 );

		V_PunchAxis( 0, -2.0 );
	}

	EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20, -12, 4 );

	EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHELL ); 

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/pl_gun3.wav", gEngfuncs.pfnRandomFloat(0.92, 1.0), ATTN_NORM, 0, 98 + gEngfuncs.pfnRandomLong( 0, 3 ) );

	EV_GetGunPosition( args, vecSrc, origin );
	
	VectorCopy( forward, vecAiming );

	EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_9MM, 0, 0, args->fparam1, args->fparam2 );
}

void EV_FireGlock2( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t vecSpread;
	vec3_t up, right, forward;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shell.mdl");// brass shell

	if ( EV_IsLocal( idx ) )
	{
		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( GLOCK_SHOOT, 2 );

		V_PunchAxis( 0, -2.0 );
	}

	EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20, -12, 4 );

	EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHELL ); 

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/pl_gun3.wav", gEngfuncs.pfnRandomFloat(0.92, 1.0), ATTN_NORM, 0, 98 + gEngfuncs.pfnRandomLong( 0, 3 ) );

	EV_GetGunPosition( args, vecSrc, origin );
	
	VectorCopy( forward, vecAiming );

	EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_9MM, 0, &tracerCount[idx-1], args->fparam1, args->fparam2 );
	
}
//======================
//	   GLOCK END
//======================

//======================
//	  SHOTGUN START
//======================
void EV_FireShotGunDouble( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	int j;
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t vecSpread;
	vec3_t up, right, forward;
	float flSpread = 0.01;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shotgunshell.mdl");// brass shell

	if ( EV_IsLocal( idx ) )
	{
		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( SHOTGUN_FIRE2, 2 );
		V_PunchAxis( 0, -10.0 );
	}

	for ( j = 0; j < 2; j++ )
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32, -12, 6 );

		EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHOTSHELL ); 
	}

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/dbarrel1.wav", gEngfuncs.pfnRandomFloat(0.98, 1.0), ATTN_NORM, 0, 85 + gEngfuncs.pfnRandomLong( 0, 0x1f ) );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );

	if ( gEngfuncs.GetMaxClients() > 1 )
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 8, vecSrc, vecAiming, 2048, BULLET_PLAYER_BUCKSHOT, 0, &tracerCount[idx-1], 0.17365, 0.04362 );
	}
	else
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 12, vecSrc, vecAiming, 2048, BULLET_PLAYER_BUCKSHOT, 0, &tracerCount[idx-1], 0.08716, 0.08716 );
	}
}

void EV_FireShotGunSingle( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t vecSpread;
	vec3_t up, right, forward;
	float flSpread = 0.01;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shotgunshell.mdl");// brass shell

	if ( EV_IsLocal( idx ) )
	{
		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( SHOTGUN_FIRE, 2 );

		V_PunchAxis( 0, -5.0 );
	}

	EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32, -12, 6 );

	EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHOTSHELL ); 

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/sbarrel1.wav", gEngfuncs.pfnRandomFloat(0.95, 1.0), ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong( 0, 0x1f ) );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );

	if ( gEngfuncs.GetMaxClients() > 1 )
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 4, vecSrc, vecAiming, 2048, BULLET_PLAYER_BUCKSHOT, 0, &tracerCount[idx-1], 0.08716, 0.04362 );
	}
	else
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 6, vecSrc, vecAiming, 2048, BULLET_PLAYER_BUCKSHOT, 0, &tracerCount[idx-1], 0.08716, 0.08716 );
	}
}
//======================
//	   SHOTGUN END
//======================

//======================
//	    MP5 START
//======================
void EV_FireMP5( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	int shell;
	vec3_t vecSrc, vecAiming;
	vec3_t up, right, forward;
	float flSpread = 0.01;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	shell = gEngfuncs.pEventAPI->EV_FindModelIndex ("models/shell.mdl");// brass shell
	
	if ( EV_IsLocal( idx ) )
	{
		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( MP5_FIRE1 + gEngfuncs.pfnRandomLong(0,2), 2 );

		V_PunchAxis( 0, gEngfuncs.pfnRandomFloat( -2, 2 ) );
	}

	EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20, -12, 4 );

	EV_EjectBrass ( ShellOrigin, ShellVelocity, angles[ YAW ], shell, TE_BOUNCE_SHELL ); 

	switch( gEngfuncs.pfnRandomLong( 0, 1 ) )
	{
	case 0:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/hks1.wav", 1, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 0xf ) );
		break;
	case 1:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/hks2.wav", 1, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 0xf ) );
		break;
	}

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );

	if ( gEngfuncs.GetMaxClients() > 1 )
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_MP5, 2, &tracerCount[idx-1], args->fparam1, args->fparam2 );
	}
	else
	{
		EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_MP5, 2, &tracerCount[idx-1], args->fparam1, args->fparam2 );
	}
}

// We only predict the animation and sound
// The grenade is still launched from the server.
void EV_FireMP52( event_args_t *args )
{
	int idx;
	vec3_t origin;
	
	idx = args->entindex;
	VectorCopy( args->origin, origin );

	if ( EV_IsLocal( idx ) )
	{
		gEngfuncs.pEventAPI->EV_WeaponAnimation( MP5_LAUNCH, 2 );
		V_PunchAxis( 0, -10 );
	}
	
	switch( gEngfuncs.pfnRandomLong( 0, 1 ) )
	{
	case 0:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/glauncher.wav", 1, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 0xf ) );
		break;
	case 1:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/glauncher2.wav", 1, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 0xf ) );
		break;
	}
}
//======================
//		 MP5 END
//======================

//======================
//	   PHYTON START 
//	     ( .357 )
//======================
void EV_FirePython( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	vec3_t vecSrc, vecAiming;
	vec3_t up, right, forward;
	float flSpread = 0.01;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		// Python uses different body in multiplayer versus single player
		int multiplayer = gEngfuncs.GetMaxClients() == 1 ? 0 : 1;

		// Add muzzle flash to current weapon model
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( PYTHON_FIRE1, multiplayer ? 1 : 0 );

		V_PunchAxis( 0, -10.0 );
	}

	switch( gEngfuncs.pfnRandomLong( 0, 1 ) )
	{
	case 0:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/357_shot1.wav", gEngfuncs.pfnRandomFloat(0.8, 0.9), ATTN_NORM, 0, PITCH_NORM );
		break;
	case 1:
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/357_shot2.wav", gEngfuncs.pfnRandomFloat(0.8, 0.9), ATTN_NORM, 0, PITCH_NORM );
		break;
	}

	EV_GetGunPosition( args, vecSrc, origin );
	
	VectorCopy( forward, vecAiming );

	EV_HLDM_FireBullets( idx, forward, right, up, 1, vecSrc, vecAiming, 8192, BULLET_PLAYER_357, 0, 0, args->fparam1, args->fparam2 );
}
//======================
//	    PHYTON END 
//	     ( .357 )
//======================

//======================
//	   GAUSS START 
//======================
#define SND_CHANGE_PITCH	(1<<7)		// duplicated in protocol.h change sound pitch

void EV_SpinGauss( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	int iSoundState = 0;

	int pitch;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	pitch = args->iparam1;

	iSoundState = args->bparam1 ? SND_CHANGE_PITCH : 0;

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "ambience/pulsemachine.wav", 1.0, ATTN_NORM, iSoundState, pitch );
}

/*
==============================
EV_StopPreviousGauss

==============================
*/
void EV_StopPreviousGauss( int idx )
{
	// Make sure we don't have a gauss spin event in the queue for this guy
	gEngfuncs.pEventAPI->EV_KillEvents( idx, "events/gaussspin.sc" );
	gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_WEAPON, "ambience/pulsemachine.wav" );
}

extern float g_flApplyVel;

void EV_FireGauss( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;
	float flDamage = args->fparam1;
	int primaryfire = args->bparam1;

	int m_fPrimaryFire = args->bparam1;
	int m_iWeaponVolume = GAUSS_PRIMARY_FIRE_VOLUME;
	vec3_t vecSrc;
	vec3_t vecDest;
	edict_t		*pentIgnore;
	pmtrace_t tr, beam_tr;
	float flMaxFrac = 1.0;
	int	nTotal = 0;
	int fHasPunched = 0;
	int fFirstBeam = 1;
	int	nMaxHits = 10;
	physent_t *pEntity;
	int m_iBeam, m_iGlow, m_iBalls;
	vec3_t up, right, forward;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	VectorCopy( args->velocity, velocity );

	if ( args->bparam2 )
	{
		EV_StopPreviousGauss( idx );
		return;
	}

//	Con_Printf( "Firing gauss with %f\n", flDamage );
	EV_GetGunPosition( args, vecSrc, origin );

	m_iBeam = gEngfuncs.pEventAPI->EV_FindModelIndex( "sprites/smoke.spr" );
	m_iBalls = m_iGlow = gEngfuncs.pEventAPI->EV_FindModelIndex( "sprites/hotglow.spr" );
	
	AngleVectors( angles, forward, right, up );

	VectorMA( vecSrc, 8192, forward, vecDest );

	if ( EV_IsLocal( idx ) )
	{
		V_PunchAxis( 0, -2.0 );
		gEngfuncs.pEventAPI->EV_WeaponAnimation( GAUSS_FIRE2, 2 );

		if ( m_fPrimaryFire == false )
			 g_flApplyVel = flDamage;	
			 
	}

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/gauss2.wav", 0.5 + flDamage * (1.0 / 400.0), ATTN_NORM, 0, 85 + gEngfuncs.pfnRandomLong( 0, 0x1f ) );

	while (flDamage > 10 && nMaxHits > 0)
	{
		nMaxHits--;

		gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );
		
		// Store off the old count
		gEngfuncs.pEventAPI->EV_PushPMStates();
	
		// Now add in all of the players.
		gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	

		gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
		gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecDest, PM_STUDIO_BOX, -1, &tr );

		gEngfuncs.pEventAPI->EV_PopPMStates();

		if ( tr.allsolid )
			break;

		if (fFirstBeam)
		{
			if ( EV_IsLocal( idx ) )
			{
				// Add muzzle flash to current weapon model
				EV_MuzzleFlash();
			}
			fFirstBeam = 0;

			gEngfuncs.pEfxAPI->R_BeamEntPoint( 
				idx | 0x1000,
				tr.endpos,
				m_iBeam,
				0.1,
				m_fPrimaryFire ? 1.0 : 2.5,
				0.0,
				m_fPrimaryFire ? 128.0 : flDamage,
				0,
				0,
				0,
				m_fPrimaryFire ? 255 : 255,
				m_fPrimaryFire ? 128 : 255,
				m_fPrimaryFire ? 0 : 255
			);
		}
		else
		{
			gEngfuncs.pEfxAPI->R_BeamPoints( vecSrc,
				tr.endpos,
				m_iBeam,
				0.1,
				m_fPrimaryFire ? 1.0 : 2.5,
				0.0,
				m_fPrimaryFire ? 128.0 : flDamage,
				0,
				0,
				0,
				m_fPrimaryFire ? 255 : 255,
				m_fPrimaryFire ? 128 : 255,
				m_fPrimaryFire ? 0 : 255
			);
		}

		pEntity = gEngfuncs.pEventAPI->EV_GetPhysent( tr.ent );
		if ( pEntity == NULL )
			break;

		if ( pEntity->solid == SOLID_BSP )
		{
			float n;

			pentIgnore = NULL;

			n = -DotProduct( tr.plane.normal, forward );

			if (n < 0.5) // 60 degrees	
			{
				// ALERT( at_console, "reflect %f\n", n );
				// reflect
				vec3_t r;
			
				VectorMA( forward, 2.0 * n, tr.plane.normal, r );

				flMaxFrac = flMaxFrac - tr.fraction;
				
				VectorCopy( r, forward );

				VectorMA( tr.endpos, 8.0, forward, vecSrc );
				VectorMA( vecSrc, 8192.0, forward, vecDest );

				gEngfuncs.pEfxAPI->R_TempSprite( tr.endpos, vec3_origin, 0.2, m_iGlow, kRenderGlow, kRenderFxNoDissipation, flDamage * n / 255.0, flDamage * n * 0.5 * 0.1, FTENT_FADEOUT );

				vec3_t fwd;
				VectorAdd( tr.endpos, tr.plane.normal, fwd );

				gEngfuncs.pEfxAPI->R_Sprite_Trail( TE_SPRITETRAIL, tr.endpos, fwd, m_iBalls, 3, 0.1, gEngfuncs.pfnRandomFloat( 10, 20 ) / 100.0, 100,
									255, 100 );

				// lose energy
				if ( n == 0 )
				{
					n = 0.1;
				}
				
				flDamage = flDamage * (1 - n);

			}
			else
			{
				// tunnel
				EV_HLDM_DecalGunshot( &tr, BULLET_MONSTER_12MM );

				gEngfuncs.pEfxAPI->R_TempSprite( tr.endpos, vec3_origin, 1.0, m_iGlow, kRenderGlow, kRenderFxNoDissipation, flDamage / 255.0, 6.0, FTENT_FADEOUT );

				// limit it to one hole punch
				if (fHasPunched)
				{
					break;
				}
				fHasPunched = 1;
				
				// try punching through wall if secondary attack (primary is incapable of breaking through)
				if ( !m_fPrimaryFire )
				{
					vec3_t start;

					VectorMA( tr.endpos, 8.0, forward, start );

					// Store off the old count
					gEngfuncs.pEventAPI->EV_PushPMStates();
						
					// Now add in all of the players.
					gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );

					gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
					gEngfuncs.pEventAPI->EV_PlayerTrace( start, vecDest, PM_STUDIO_BOX, -1, &beam_tr );

					if ( !beam_tr.allsolid )
					{
						vec3_t delta;
						float n;

						// trace backwards to find exit point

						gEngfuncs.pEventAPI->EV_PlayerTrace( beam_tr.endpos, tr.endpos, PM_STUDIO_BOX, -1, &beam_tr );

						VectorSubtract( beam_tr.endpos, tr.endpos, delta );
						
						n = Length( delta );

						if (n < flDamage)
						{
							if (n == 0)
								n = 1;
							flDamage -= n;

							// absorption balls
							{
								vec3_t fwd;
								VectorSubtract( tr.endpos, forward, fwd );
								gEngfuncs.pEfxAPI->R_Sprite_Trail( TE_SPRITETRAIL, tr.endpos, fwd, m_iBalls, 3, 0.1, gEngfuncs.pfnRandomFloat( 10, 20 ) / 100.0, 100,
									255, 100 );
							}

	//////////////////////////////////// WHAT TO DO HERE
							// CSoundEnt::InsertSound ( bits_SOUND_COMBAT, pev->origin, NORMAL_EXPLOSION_VOLUME, 3.0 );

							EV_HLDM_DecalGunshot( &beam_tr, BULLET_MONSTER_12MM );
							
							gEngfuncs.pEfxAPI->R_TempSprite( beam_tr.endpos, vec3_origin, 0.1, m_iGlow, kRenderGlow, kRenderFxNoDissipation, flDamage / 255.0, 6.0, FTENT_FADEOUT );
			
							// balls
							{
								vec3_t fwd;
								VectorSubtract( beam_tr.endpos, forward, fwd );
								gEngfuncs.pEfxAPI->R_Sprite_Trail( TE_SPRITETRAIL, beam_tr.endpos, fwd, m_iBalls, (int)(flDamage * 0.3), 0.1, gEngfuncs.pfnRandomFloat( 10, 20 ) / 100.0, 200,
									255, 40 );
							}
							
							VectorAdd( beam_tr.endpos, forward, vecSrc );
						}
					}
					else
					{
						flDamage = 0;
					}

					gEngfuncs.pEventAPI->EV_PopPMStates();
				}
				else
				{
					if ( m_fPrimaryFire )
					{
						// slug doesn't punch through ever with primary 
						// fire, so leave a little glowy bit and make some balls
						gEngfuncs.pEfxAPI->R_TempSprite( tr.endpos, vec3_origin, 0.2, m_iGlow, kRenderGlow, kRenderFxNoDissipation, 200.0 / 255.0, 0.3, FTENT_FADEOUT );
			
						{
							vec3_t fwd;
							VectorAdd( tr.endpos, tr.plane.normal, fwd );
							gEngfuncs.pEfxAPI->R_Sprite_Trail( TE_SPRITETRAIL, tr.endpos, fwd, m_iBalls, 8, 0.6, gEngfuncs.pfnRandomFloat( 10, 20 ) / 100.0, 100,
								255, 200 );
						}
					}

					flDamage = 0;
				}
			}
		}
		else
		{
			VectorAdd( tr.endpos, forward, vecSrc );
		}
	}
}
//======================
//	   GAUSS END 
//======================

//======================
//	   CROWBAR START
//======================

enum crowbar_e {
	CROWBAR_IDLE = 0,
	CROWBAR_DRAW,
	CROWBAR_HOLSTER,
	CROWBAR_ATTACK1HIT,
	CROWBAR_ATTACK1MISS,
	CROWBAR_ATTACK2MISS,
	CROWBAR_ATTACK2HIT,
	CROWBAR_ATTACK3MISS,
	CROWBAR_ATTACK3HIT
};

int g_iSwing;

//Only predict the miss sounds, hit sounds are still played 
//server side, so players don't get the wrong idea.
void EV_Crowbar( event_args_t *args )
{
	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	
	//Play Swing sound
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/cbar_miss1.wav", 1, ATTN_NORM, 0, PITCH_NORM); 

	if ( EV_IsLocal( idx ) )
	{
		gEngfuncs.pEventAPI->EV_WeaponAnimation( CROWBAR_ATTACK1MISS, 1 );

		switch( (g_iSwing++) % 3 )
		{
			case 0:
				gEngfuncs.pEventAPI->EV_WeaponAnimation ( CROWBAR_ATTACK1MISS, 1 ); break;
			case 1:
				gEngfuncs.pEventAPI->EV_WeaponAnimation ( CROWBAR_ATTACK2MISS, 1 ); break;
			case 2:
				gEngfuncs.pEventAPI->EV_WeaponAnimation ( CROWBAR_ATTACK3MISS, 1 ); break;
		}
	}
}
//======================
//	   CROWBAR END 
//======================

//======================
//	  CROSSBOW START
//======================
enum crossbow_e {
	CROSSBOW_IDLE1 = 0,	// full
	CROSSBOW_IDLE2,		// empty
	CROSSBOW_FIDGET1,	// full
	CROSSBOW_FIDGET2,	// empty
	CROSSBOW_FIRE1,		// full
	CROSSBOW_FIRE2,		// reload
	CROSSBOW_FIRE3,		// empty
	CROSSBOW_RELOAD,	// from empty
	CROSSBOW_DRAW1,		// full
	CROSSBOW_DRAW2,		// empty
	CROSSBOW_HOLSTER1,	// full
	CROSSBOW_HOLSTER2,	// empty
};

//=====================
// EV_BoltCallback
// This function is used to correct the origin and angles 
// of the bolt, so it looks like it's stuck on the wall.
//=====================
void EV_BoltCallback ( struct tempent_s *ent, float frametime, float currenttime )
{
	ent->entity.origin = ent->entity.baseline.vuser1;
	ent->entity.angles = ent->entity.baseline.vuser2;
}

void EV_FireCrossbow2( event_args_t *args )
{
	vec3_t vecSrc, vecEnd;
	vec3_t up, right, forward;
	pmtrace_t tr;

	int idx;
	vec3_t origin;
	vec3_t angles;
	vec3_t velocity;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );

	VectorCopy( args->velocity, velocity );
	
	AngleVectors( angles, forward, right, up );

	EV_GetGunPosition( args, vecSrc, origin );

	VectorMA( vecSrc, 8192, forward, vecEnd );

	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/xbow_fire1.wav", 1, ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong(0,0xF) );
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_ITEM, "weapons/xbow_reload1.wav", gEngfuncs.pfnRandomFloat(0.95, 1.0), ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong(0,0xF) );

	if ( EV_IsLocal( idx ) )
	{
		if ( args->iparam1 )
			gEngfuncs.pEventAPI->EV_WeaponAnimation( CROSSBOW_FIRE1, 1 );
		else if ( args->iparam2 )
			gEngfuncs.pEventAPI->EV_WeaponAnimation( CROSSBOW_FIRE3, 1 );
	}

	// Store off the old count
	gEngfuncs.pEventAPI->EV_PushPMStates();

	// Now add in all of the players.
	gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	
	gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
	gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecEnd, PM_STUDIO_BOX, -1, &tr );
	
	//We hit something
	if ( tr.fraction < 1.0 )
	{
		physent_t *pe = gEngfuncs.pEventAPI->EV_GetPhysent( tr.ent ); 

		//Not the world, let's assume we hit something organic ( dog, cat, uncle joe, etc ).
		if ( pe->solid != SOLID_BSP )
		{
			switch( gEngfuncs.pfnRandomLong(0,1) )
			{
			case 0:
				gEngfuncs.pEventAPI->EV_PlaySound( idx, tr.endpos, CHAN_BODY, "weapons/xbow_hitbod1.wav", 1, ATTN_NORM, 0, PITCH_NORM ); break;
			case 1:
				gEngfuncs.pEventAPI->EV_PlaySound( idx, tr.endpos, CHAN_BODY, "weapons/xbow_hitbod2.wav", 1, ATTN_NORM, 0, PITCH_NORM ); break;
			}
		}
		//Stick to world but don't stick to glass, it might break and leave the bolt floating. It can still stick to other non-transparent breakables though.
		else if ( pe->rendermode == kRenderNormal ) 
		{
			gEngfuncs.pEventAPI->EV_PlaySound( 0, tr.endpos, CHAN_BODY, "weapons/xbow_hit1.wav", gEngfuncs.pfnRandomFloat(0.95, 1.0), ATTN_NORM, 0, PITCH_NORM );
		
			//Not underwater, do some sparks...
			if ( gEngfuncs.PM_PointContents( tr.endpos, NULL ) != CONTENTS_WATER)
				 gEngfuncs.pEfxAPI->R_SparkShower( tr.endpos );

			vec3_t vBoltAngles;
			int iModelIndex = gEngfuncs.pEventAPI->EV_FindModelIndex( "models/crossbow_bolt.mdl" );

			VectorAngles( forward, vBoltAngles );

			TEMPENTITY *bolt = gEngfuncs.pEfxAPI->R_TempModel( tr.endpos - forward * 10, Vector( 0, 0, 0), vBoltAngles , 5, iModelIndex, TE_BOUNCE_NULL );
			
			if ( bolt )
			{
				bolt->flags |= ( FTENT_CLIENTCUSTOM ); //So it calls the callback function.
				bolt->entity.baseline.vuser1 = tr.endpos - forward * 10; // Pull out a little bit
				bolt->entity.baseline.vuser2 = vBoltAngles; //Look forward!
				bolt->callback = EV_BoltCallback; //So we can set the angles and origin back. (Stick the bolt to the wall)
			}
		}
	}

	gEngfuncs.pEventAPI->EV_PopPMStates();
}

//TODO: Fully predict the fliying bolt.
void EV_FireCrossbow( event_args_t *args )
{
	int idx;
	vec3_t origin;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/xbow_fire1.wav", 1, ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong(0,0xF) );
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_ITEM, "weapons/xbow_reload1.wav", gEngfuncs.pfnRandomFloat(0.95, 1.0), ATTN_NORM, 0, 93 + gEngfuncs.pfnRandomLong(0,0xF) );

	//Only play the weapon anims if I shot it. 
	if ( EV_IsLocal( idx ) )
	{
		if ( args->iparam1 )
			gEngfuncs.pEventAPI->EV_WeaponAnimation( CROSSBOW_FIRE1, 1 );
		else if ( args->iparam2 )
			gEngfuncs.pEventAPI->EV_WeaponAnimation( CROSSBOW_FIRE3, 1 );

		V_PunchAxis( 0, -2.0 );
	}
}
//======================
//	   CROSSBOW END 
//======================

//======================
//	    RPG START 
//======================
enum rpg_e {
	RPG_IDLE = 0,
	RPG_FIDGET,
	RPG_RELOAD,		// to reload
	RPG_FIRE2,		// to empty
	RPG_HOLSTER1,	// loaded
	RPG_DRAW1,		// loaded
	RPG_HOLSTER2,	// unloaded
	RPG_DRAW_UL,	// unloaded
	RPG_IDLE_UL,	// unloaded idle
	RPG_FIDGET_UL,	// unloaded fidget
};

void EV_FireRpg( event_args_t *args )
{
	int idx;
	vec3_t origin;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "weapons/rocketfire1.wav", 0.9, ATTN_NORM, 0, PITCH_NORM );
	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_ITEM, "weapons/glauncher.wav", 0.7, ATTN_NORM, 0, PITCH_NORM );

	//Only play the weapon anims if I shot it. 
	if ( EV_IsLocal( idx ) )
	{
		gEngfuncs.pEventAPI->EV_WeaponAnimation( RPG_FIRE2, 1 );
	
		V_PunchAxis( 0, -5.0 );
	}
}
//======================
//	     RPG END 
//======================

//======================
//	    EGON END 
//======================
enum egon_e {
	EGON_IDLE1 = 0,
	EGON_FIDGET1,
	EGON_ALTFIREON,
	EGON_ALTFIRECYCLE,
	EGON_ALTFIREOFF,
	EGON_FIRE1,
	EGON_FIRE2,
	EGON_FIRE3,
	EGON_FIRE4,
	EGON_DRAW,
	EGON_HOLSTER
};

int g_fireAnims1[] = { EGON_FIRE1, EGON_FIRE2, EGON_FIRE3, EGON_FIRE4 };
int g_fireAnims2[] = { EGON_ALTFIRECYCLE };

enum EGON_FIRESTATE { FIRE_OFF, FIRE_CHARGE };
enum EGON_FIREMODE { FIRE_NARROW, FIRE_WIDE};

#define	EGON_PRIMARY_VOLUME		450
#define EGON_BEAM_SPRITE		"sprites/xbeam1.spr"
#define EGON_FLARE_SPRITE		"sprites/XSpark1.spr"
#define EGON_SOUND_OFF			"weapons/egon_off1.wav"
#define EGON_SOUND_RUN			"weapons/egon_run3.wav"
#define EGON_SOUND_STARTUP		"weapons/egon_windup2.wav"

#define ARRAYSIZE(p)		(sizeof(p)/sizeof(p[0]))

BEAM *pBeam;
BEAM *pBeam2;

void EV_EgonFire( event_args_t *args )
{
	int idx, iFireState, iFireMode;
	vec3_t origin;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	iFireState = args->iparam1;
	iFireMode = args->iparam2;
	int iStartup = args->bparam1;


	if ( iStartup )
	{
		if ( iFireMode == FIRE_WIDE )
			gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, EGON_SOUND_STARTUP, 0.98, ATTN_NORM, 0, 125 );
		else
			gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, EGON_SOUND_STARTUP, 0.9, ATTN_NORM, 0, 100 );
	}
	else
	{
		if ( iFireMode == FIRE_WIDE )
			gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, EGON_SOUND_RUN, 0.98, ATTN_NORM, 0, 125 );
		else
			gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, EGON_SOUND_RUN, 0.9, ATTN_NORM, 0, 100 );
	}

	//Only play the weapon anims if I shot it.
	if ( EV_IsLocal( idx ) )
		gEngfuncs.pEventAPI->EV_WeaponAnimation ( g_fireAnims1[ gEngfuncs.pfnRandomLong( 0, 3 ) ], 1 );

	if ( iStartup == 1 && EV_IsLocal( idx ) && !pBeam && !pBeam2 && cl_lw->value ) //Adrian: Added the cl_lw check for those lital people that hate weapon prediction.
	{
		vec3_t vecSrc, vecEnd, origin, angles, forward, right, up;
		pmtrace_t tr;

		cl_entity_t *pl = gEngfuncs.GetEntityByIndex( idx );

		if ( pl )
		{
			VectorCopy( gHUD.m_vecAngles, angles );
			
			AngleVectors( angles, forward, right, up );

			EV_GetGunPosition( args, vecSrc, pl->origin );

			VectorMA( vecSrc, 2048, forward, vecEnd );

			gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );	
				
			// Store off the old count
			gEngfuncs.pEventAPI->EV_PushPMStates();
			
			// Now add in all of the players.
			gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	

			gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
			gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecEnd, PM_STUDIO_BOX, -1, &tr );

			gEngfuncs.pEventAPI->EV_PopPMStates();

			int iBeamModelIndex = gEngfuncs.pEventAPI->EV_FindModelIndex( EGON_BEAM_SPRITE );

			float r = 50.0f;
			float g = 50.0f;
			float b = 125.0f;

			if ( IEngineStudio.IsHardware() )
			{
				r /= 100.0f;
				g /= 100.0f;
			}
				
		
			pBeam = gEngfuncs.pEfxAPI->R_BeamEntPoint ( idx | 0x1000, tr.endpos, iBeamModelIndex, 99999, 3.5, 0.2, 0.7, 55, 0, 0, r, g, b );

			if ( pBeam )
				 pBeam->flags |= ( FBEAM_SINENOISE );
 
			pBeam2 = gEngfuncs.pEfxAPI->R_BeamEntPoint ( idx | 0x1000, tr.endpos, iBeamModelIndex, 99999, 5.0, 0.08, 0.7, 25, 0, 0, r, g, b );
		}
	}
}

void EV_EgonStop( event_args_t *args )
{
	int idx;
	vec3_t origin;

	idx = args->entindex;
	VectorCopy ( args->origin, origin );

	gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_STATIC, EGON_SOUND_RUN );
	
	if ( args->iparam1 )
		 gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, EGON_SOUND_OFF, 0.98, ATTN_NORM, 0, 100 );

	if ( EV_IsLocal( idx ) ) 
	{
		if ( pBeam )
		{
			pBeam->die = 0.0;
			pBeam = NULL;
		}
			
		
		if ( pBeam2 )
		{
			pBeam2->die = 0.0;
			pBeam2 = NULL;
		}
	}
}
//======================
//	    EGON END 
//======================

//======================
//	   HORNET START
//======================
enum hgun_e {
	HGUN_IDLE1 = 0,
	HGUN_FIDGETSWAY,
	HGUN_FIDGETSHAKE,
	HGUN_DOWN,
	HGUN_UP,
	HGUN_SHOOT
};

void EV_HornetGunFire( event_args_t *args )
{
	int idx, iFireMode;
	vec3_t origin, angles, vecSrc, forward, right, up;

	idx = args->entindex;
	VectorCopy( args->origin, origin );
	VectorCopy( args->angles, angles );
	iFireMode = args->iparam1;

	//Only play the weapon anims if I shot it.
	if ( EV_IsLocal( idx ) )
	{
		V_PunchAxis( 0, gEngfuncs.pfnRandomLong ( 0, 2 ) );
		gEngfuncs.pEventAPI->EV_WeaponAnimation ( HGUN_SHOOT, 1 );
	}

	switch ( gEngfuncs.pfnRandomLong ( 0 , 2 ) )
	{
		case 0:	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "agrunt/ag_fire1.wav", 1, ATTN_NORM, 0, 100 );	break;
		case 1:	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "agrunt/ag_fire2.wav", 1, ATTN_NORM, 0, 100 );	break;
		case 2:	gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, "agrunt/ag_fire3.wav", 1, ATTN_NORM, 0, 100 );	break;
	}
}
//======================
//	   HORNET END
//======================

//======================
//	   TRIPMINE START
//======================
enum tripmine_e {
	TRIPMINE_IDLE1 = 0,
	TRIPMINE_IDLE2,
	TRIPMINE_ARM1,
	TRIPMINE_ARM2,
	TRIPMINE_FIDGET,
	TRIPMINE_HOLSTER,
	TRIPMINE_DRAW,
	TRIPMINE_WORLD,
	TRIPMINE_GROUND,
};

//We only check if it's possible to put a trip mine
//and if it is, then we play the animation. Server still places it.
void EV_TripmineFire( event_args_t *args )
{
	int idx;
	vec3_t vecSrc, angles, view_ofs, forward;
	pmtrace_t tr;

	idx = args->entindex;
	VectorCopy( args->origin, vecSrc );
	VectorCopy( args->angles, angles );

	AngleVectors ( angles, forward, NULL, NULL );
		
	if ( !EV_IsLocal ( idx ) )
		return;

	// Grab predicted result for local player
	gEngfuncs.pEventAPI->EV_LocalPlayerViewheight( view_ofs );

	vecSrc = vecSrc + view_ofs;

	// Store off the old count
	gEngfuncs.pEventAPI->EV_PushPMStates();

	// Now add in all of the players.
	gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	
	gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
	gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc, vecSrc + forward * 128, PM_NORMAL, -1, &tr );

	//Hit something solid
	if ( tr.fraction < 1.0 )
		 gEngfuncs.pEventAPI->EV_WeaponAnimation ( TRIPMINE_DRAW, 0 );
	
	gEngfuncs.pEventAPI->EV_PopPMStates();
}
//======================
//	   TRIPMINE END
//======================

//======================
//	   SQUEAK START
//======================
enum squeak_e {
	SQUEAK_IDLE1 = 0,
	SQUEAK_FIDGETFIT,
	SQUEAK_FIDGETNIP,
	SQUEAK_DOWN,
	SQUEAK_UP,
	SQUEAK_THROW
};

#define VEC_HULL_MIN		Vector(-16, -16, -36)
#define VEC_DUCK_HULL_MIN	Vector(-16, -16, -18 )

void EV_SnarkFire( event_args_t *args )
{
	int idx;
	vec3_t vecSrc, angles, view_ofs, forward;
	pmtrace_t tr;

	idx = args->entindex;
	VectorCopy( args->origin, vecSrc );
	VectorCopy( args->angles, angles );

	AngleVectors ( angles, forward, NULL, NULL );
		
	if ( !EV_IsLocal ( idx ) )
		return;
	
	if ( args->ducking )
		vecSrc = vecSrc - ( VEC_HULL_MIN - VEC_DUCK_HULL_MIN );
	
	// Store off the old count
	gEngfuncs.pEventAPI->EV_PushPMStates();

	// Now add in all of the players.
	gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );	
	gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
	gEngfuncs.pEventAPI->EV_PlayerTrace( vecSrc + forward * 20, vecSrc + forward * 64, PM_NORMAL, -1, &tr );

	//Find space to drop the thing.
	if ( tr.allsolid == 0 && tr.startsolid == 0 && tr.fraction > 0.25 )
		 gEngfuncs.pEventAPI->EV_WeaponAnimation ( SQUEAK_THROW, 0 );
	
	gEngfuncs.pEventAPI->EV_PopPMStates();
}
//======================
//	   SQUEAK END
//======================

void EV_TrainPitchAdjust( event_args_t *args )
{
	int idx;
	vec3_t origin;

	unsigned short us_params;
	int noise;
	float m_flVolume;
	int pitch;
	int stop;
	
	char sz[ 256 ];

	idx = args->entindex;
	
	VectorCopy( args->origin, origin );

	us_params = (unsigned short)args->iparam1;
	stop	  = args->bparam1;

	m_flVolume	= (float)(us_params & 0x003f)/40.0;
	noise		= (int)(((us_params) >> 12 ) & 0x0007);
	pitch		= (int)( 10.0 * (float)( ( us_params >> 6 ) & 0x003f ) );

	switch ( noise )
	{
	case 1: strcpy( sz, "plats/ttrain1.wav"); break;
	case 2: strcpy( sz, "plats/ttrain2.wav"); break;
	case 3: strcpy( sz, "plats/ttrain3.wav"); break; 
	case 4: strcpy( sz, "plats/ttrain4.wav"); break;
	case 5: strcpy( sz, "plats/ttrain6.wav"); break;
	case 6: strcpy( sz, "plats/ttrain7.wav"); break;
	default:
		// no sound
		strcpy( sz, "" );
		return;
	}

	if ( stop )
	{
		gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_STATIC, sz );
	}
	else
	{
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, sz, m_flVolume, ATTN_NORM, SND_CHANGE_PITCH, pitch );
	}
}

int EV_TFC_IsAllyTeam( int iTeam1, int iTeam2 )
{
	return 0;
}

void EV_Dummy( struct event_args_s *args )
{
	gEngfuncs.pEventAPI->EV_WeaponAnimation( 1, 1 );
	return;
}


```

`cl_dll/events/ev_cs16.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "entity_types.h"
#include "usercmd.h"
#include "pm_defs.h"
#include "pm_materials.h"

#include "eventscripts.h"
#include "ev_hldm.h"

#include "r_efx.h"
#include "triangleapi.h"
#include "event_api.h"
#include "event_args.h"
#include "in_defs.h"

#include <string.h>

#include "r_studioint.h"
#include "com_model.h"

#include <assert.h>

#include "pm_shared.h"

extern float g_flRoundTime;

// play a strike sound based on the texture that was hit by the attack traceline.  VecSrc/VecEnd are the
// original traceline endpoints used by the attacker, iBulletType is the type of bullet that hit the texture.
// returns volume of strike instrument (crowbar) to play
void EV_HLDM_NewExplode( float x, float y, float z, float ScaleExplode1 )
{

	int  iNewExplode = gEngfuncs.pEventAPI->EV_FindModelIndex ("sprites/dexplo.spr");
	TEMPENTITY *pTemp = gEngfuncs.pEfxAPI->R_TempSprite( Vector( x, y, z + 5 ),
														 Vector( 0, 0, 0 ),
														 ScaleExplode1, iNewExplode, kRenderTransAdd, kRenderFxNone, 1.0, 0.5, FTENT_SPRANIMATE | FTENT_FADEOUT | FTENT_COLLIDEKILL );

	if(pTemp)
	{
		pTemp->fadeSpeed = 90.0;
		pTemp->entity.curstate.framerate = 37.0;
		pTemp->entity.curstate.renderamt = 155;
		pTemp->entity.curstate.rendercolor.r = 255;
		pTemp->entity.curstate.rendercolor.g = 255;
		pTemp->entity.curstate.rendercolor.b = 255;
	}

	iNewExplode = gEngfuncs.pEventAPI->EV_FindModelIndex ("sprites/fexplo.spr");
	pTemp = gEngfuncs.pEfxAPI->R_TempSprite( Vector( x, y, z + 10),
											 Vector( 0, 0, 0 ),
											 ScaleExplode1, iNewExplode, kRenderTransAdd, kRenderFxNone, 1.0, 0.5, FTENT_SPRANIMATE | FTENT_FADEOUT | FTENT_COLLIDEKILL );

	if(pTemp)
	{
		pTemp->fadeSpeed = 90.0;
		pTemp->entity.curstate.framerate = 35.0;
		pTemp->entity.curstate.renderamt = 150;
		pTemp->entity.curstate.rendercolor.r = 255;
		pTemp->entity.curstate.rendercolor.g = 255;
		pTemp->entity.curstate.rendercolor.b = 255;
		pTemp->entity.angles = Vector( 90, 0, 0 );
	}

	for( int i = 1; i <= 10; i++ )
	{
		int  iSmokeSprite = gEngfuncs.pEventAPI->EV_FindModelIndex ("sprites/smoke.spr");
		TEMPENTITY *pTemp = gEngfuncs.pEfxAPI->R_TempSprite( Vector( x, y, z ),
															 Vector( (int)Com_RandomLong( -100, 100 ), (int)Com_RandomLong( -100, 100 ), (int)Com_RandomLong( -100, 100 ) ),
															 5, iSmokeSprite, kRenderTransAlpha, kRenderFxNone, 1.0, 0.5, FTENT_FADEOUT | FTENT_PERSIST );

		if(pTemp)
		{
			pTemp->fadeSpeed = 0.6;
			pTemp->entity.curstate.framerate = 1;
			pTemp->entity.curstate.renderamt = 255;
			int Color = Com_RandomLong( 0, 140 );
			pTemp->entity.curstate.rendercolor.r = Color;
			pTemp->entity.curstate.rendercolor.g = Color;
			pTemp->entity.curstate.rendercolor.b = Color;
		}
	}

}

char EV_HLDM_PlayTextureSound( int idx, pmtrace_t *ptr, float *vecSrc, float *vecEnd, int iBulletType, bool& isSky )
{
	// hit the world, try to play sound based on texture material type
	char chTextureType = CHAR_TEX_CONCRETE;
	float fvol;
	const char *rgsz[4];
	int cnt;
	float fattn = ATTN_NORM;
	int entity;
	char *pTextureName;
	char texname[ 64 ];
	char szbuffer[ 64 ];

	entity = gEngfuncs.pEventAPI->EV_IndexFromTrace( ptr );

	// FIXME check if playtexture sounds movevar is set
	//

	chTextureType = 0;
	isSky = false;

	// Player
	if ( entity >= 1 && entity <= gEngfuncs.GetMaxClients() )
	{
		// hit body
		chTextureType = CHAR_TEX_FLESH;
	}
	else if ( entity == 0 )
	{
		// get texture from entity or world (world is ent(0))
		pTextureName = (char *)gEngfuncs.pEventAPI->EV_TraceTexture( ptr->ent, vecSrc, vecEnd );

		if ( pTextureName )
		{
			strncpy( texname, pTextureName, sizeof( texname ) );
			pTextureName = texname;

			if( !strcmp( pTextureName, "sky" ) )
			{
				isSky = true;
			}
			// strip leading '-0' or '+0~' or '{' or '!'
			else if (*pTextureName == '-' || *pTextureName == '+')
			{
				pTextureName += 2;
			}
			else if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')
			{
				pTextureName++;
			}

			// '}}'
			strncpy( szbuffer, pTextureName, sizeof(szbuffer) );
			szbuffer[ CBTEXTURENAMEMAX - 1 ] = 0;

			// get texture type
			chTextureType = PM_FindTextureType( szbuffer );
		}
	}

	switch (chTextureType)
	{
	default:
	case CHAR_TEX_CONCRETE:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_step1.wav";
		rgsz[1] = "player/pl_step2.wav";
		cnt = 2;
		break;
	}
	case CHAR_TEX_METAL:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_metal1.wav";
		rgsz[1] = "player/pl_metal2.wav";
		cnt = 2;
		break;
	}
	case CHAR_TEX_DIRT:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_dirt1.wav";
		rgsz[1] = "player/pl_dirt2.wav";
		rgsz[2] = "player/pl_dirt3.wav";
		cnt = 3;
		break;
	}
	case CHAR_TEX_VENT:
	{
		fvol = 0.5;
		rgsz[0] = "player/pl_duct1.wav";
		rgsz[1] = "player/pl_duct1.wav";
		cnt = 2;
		break;
	}
	case CHAR_TEX_GRATE:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_grate1.wav";
		rgsz[1] = "player/pl_grate4.wav";
		cnt = 2;
		break;
	}
	case CHAR_TEX_TILE:
	{
		fvol = 0.8;
		rgsz[0] = "player/pl_tile1.wav";
		rgsz[1] = "player/pl_tile3.wav";
		rgsz[2] = "player/pl_tile2.wav";
		rgsz[3] = "player/pl_tile4.wav";
		cnt = 4;
		break;
	}
	case CHAR_TEX_SLOSH:
	{
		fvol = 0.9;
		rgsz[0] = "player/pl_slosh1.wav";
		rgsz[1] = "player/pl_slosh3.wav";
		rgsz[2] = "player/pl_slosh2.wav";
		rgsz[3] = "player/pl_slosh4.wav";
		cnt = 4;
		break;
	}
	case CHAR_TEX_SNOW:
	{
		fvol = 0.7;
		rgsz[0] = "debris/pl_snow1.wav";
		rgsz[1] = "debris/pl_snow2.wav";
		rgsz[2] = "debris/pl_snow3.wav";
		rgsz[3] = "debris/pl_snow4.wav";
		cnt = 4;
		break;
	}
	case CHAR_TEX_WOOD:
	{
		fvol = 0.9;
		rgsz[0] = "debris/wood1.wav";
		rgsz[1] = "debris/wood2.wav";
		rgsz[2] = "debris/wood3.wav";
		cnt = 3;
		break;
	}
	case CHAR_TEX_GLASS:
	case CHAR_TEX_COMPUTER:
	{
		fvol = 0.8;
		rgsz[0] = "debris/glass1.wav";
		rgsz[1] = "debris/glass2.wav";
		rgsz[2] = "debris/glass3.wav";
		cnt = 3;
		break;
	}
	case CHAR_TEX_FLESH:
	{
		fvol = 1.0;
		rgsz[0] = "weapons/bullet_hit1.wav";
		rgsz[1] = "weapons/bullet_hit2.wav";
		fattn = 1.0;
		cnt = 2;
		break;
	}
	}

	// play material hit sound
	gEngfuncs.pEventAPI->EV_PlaySound( 0, ptr->endpos, CHAN_STATIC, rgsz[Com_RandomLong(0,cnt-1)], fvol, fattn, 0, 96 + Com_RandomLong(0,0xf) );

	return chTextureType;
}

char *EV_HLDM_DamageDecal( physent_t *pe )
{
	static char decalname[ 32 ];
	int idx;

	if ( pe->classnumber == 1 )
	{
		idx = Com_RandomLong( 0, 2 );
		sprintf( decalname, "{break%i", idx + 1 );
	}
	else if ( pe->rendermode != kRenderNormal )
	{
		sprintf( decalname, "{bproof1" );
	}
	else
	{
		idx = Com_RandomLong( 0, 4 );
		sprintf( decalname, "{shot%i", idx + 1 );
	}
	return decalname;
}

void EV_HLDM_GunshotDecalTrace( pmtrace_t *pTrace, char *decalName, char chTextureType )
{
	int iRand;
	physent_t *pe;

	gEngfuncs.pEfxAPI->R_BulletImpactParticles( pTrace->endpos );


	iRand = Com_RandomLong(0,0x7FFF);
	if ( iRand < (0x7fff/2) )// not every bullet makes a sound.
	{
		if( chTextureType == CHAR_TEX_VENT || chTextureType == CHAR_TEX_METAL )
		{
			switch( iRand % 2 )
			{
			case 0: gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric_metal-1.wav", 1.0f, ATTN_NORM, 0, PITCH_NORM); break;
			case 1: gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric_metal-2.wav", 1.0f, ATTN_NORM, 0, PITCH_NORM); break;
			}
		}
		else
		{
			switch( iRand % 7)
			{
			case 0:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric1.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 1:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric2.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 2:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric3.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 3:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric4.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 4:	gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric5.wav", 1.0, ATTN_NORM, 0, PITCH_NORM ); break;
			case 5: gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric_conc-1.wav", 1.0f, ATTN_NORM, 0, PITCH_NORM); break;
			case 6: gEngfuncs.pEventAPI->EV_PlaySound( -1, pTrace->endpos, 0, "weapons/ric_conc-2.wav", 1.0f, ATTN_NORM, 0, PITCH_NORM); break;
			}
		}

	}

	pe = gEngfuncs.pEventAPI->EV_GetPhysent( pTrace->ent );

	// Only decal brush models such as the world etc.
	if (  decalName && decalName[0] && pe && ( pe->solid == SOLID_BSP || pe->movetype == MOVETYPE_PUSHSTEP ) )
	{
		if ( CVAR_GET_FLOAT( "r_decals" ) )
		{
			gEngfuncs.pEfxAPI->R_DecalShoot(
						gEngfuncs.pEfxAPI->Draw_DecalIndex( gEngfuncs.pEfxAPI->Draw_DecalIndexFromName( decalName ) ),
						gEngfuncs.pEventAPI->EV_IndexFromTrace( pTrace ), 0, pTrace->endpos, 0 );

		}
	}
}


void EV_WallPuff_Wind( struct tempent_s *te, float frametime, float currenttime )
{
	static bool xWindDirection = true;
	static bool yWindDirection = true;
	static float xWindMagnitude;
	static float yWindMagnitude;

	if ( te->entity.curstate.frame > 7.0 )
	{
		te->entity.baseline.origin.x = 0.97 * te->entity.baseline.origin.x;
		te->entity.baseline.origin.y = 0.97 * te->entity.baseline.origin.y;
		te->entity.baseline.origin.z = 0.97 * te->entity.baseline.origin.z + 0.7;
		if ( te->entity.baseline.origin.z > 70.0 )
			te->entity.baseline.origin.z = 70.0;
	}

	if ( te->entity.curstate.frame > 6.0 )
	{
		xWindMagnitude += 0.075;
		if ( xWindMagnitude > 5.0 )
			xWindMagnitude = 5.0;

		yWindMagnitude += 0.075;
		if ( yWindMagnitude > 5.0 )
			yWindMagnitude = 5.0;

		if( xWindDirection )
			te->entity.baseline.origin.x += xWindMagnitude;
		else
			te->entity.baseline.origin.x -= xWindMagnitude;

		if( yWindDirection )
			te->entity.baseline.origin.y += yWindMagnitude;
		else
			te->entity.baseline.origin.y -= yWindMagnitude;

		if ( !Com_RandomLong(0, 10) && yWindMagnitude > 3.0 )
		{
			yWindMagnitude = 0;
			yWindDirection = !yWindDirection;
		}
		if ( !Com_RandomLong(0, 10) && xWindMagnitude > 3.0 )
		{
			xWindMagnitude = 0;
			xWindDirection = !xWindDirection;
		}
	}
}

void EV_SmokeRise( struct tempent_s *te, float frametime, float currenttime )
{
	if ( te->entity.curstate.frame > 7.0 )
	{
		te->entity.baseline.origin = 0.97f * te->entity.baseline.origin;
		te->entity.baseline.origin.z += 0.7f;

		if( te->entity.baseline.origin.z > 70.0f )
			te->entity.baseline.origin.z = 70.0f;
	}
}

void EV_HugWalls(TEMPENTITY *te, pmtrace_s *ptr)
{
	Vector norm = te->entity.baseline.origin.Normalize();
	float len = te->entity.baseline.origin.Length();

	Vector v =
	{
		ptr->plane.normal.y * norm.x - norm.y * ptr->plane.normal.x,
		ptr->plane.normal.x * norm.z - norm.x * ptr->plane.normal.z,
		ptr->plane.normal.z * norm.y - norm.z * ptr->plane.normal.y
	};
	Vector v2 =
	{
		ptr->plane.normal.y * v.z - v.y * ptr->plane.normal.x,
		ptr->plane.normal.x * v.x - v.z * ptr->plane.normal.z,
		ptr->plane.normal.z * v.y - v.x * ptr->plane.normal.y
	};

	if( len <= 2000.0f )
		len *= 1.5;
	else len = 3000.0f;

	te->entity.baseline.origin.x = v2.z * len * 1.5;
	te->entity.baseline.origin.y = v2.y * len * 1.5;
	te->entity.baseline.origin.z = v2.x * len * 1.5;
}

void EV_CS16Client_CreateSmoke(int type, Vector origin, Vector dir, int speed, float scale, int r, int g, int b , bool wind, Vector velocity, int framerate )
{
	TEMPENTITY *te = NULL;
	void ( *callback )( struct tempent_s *ent, float frametime, float currenttime ) = NULL;
	char path[64];

	switch( type )
	{
	case SMOKE_WALLPUFF:
		if( !gHUD.fastsprites->value )
		{
			strcpy( path, "sprites/wall_puff1.spr" );

			path[17] += Com_RandomLong(0, 3); // randomize a bit
		}
		else
		{
			strcpy( path, "sprites/fast_wallpuff1.spr" );
			te = gEngfuncs.pEfxAPI->R_DefaultSprite( origin,
								gEngfuncs.pEventAPI->EV_FindModelIndex("sprites/fast_wallpuff1.spr"), 30.0f );
		}
		break;
	case SMOKE_RIFLE:
		strcpy( path, "sprites/rifle_smoke1.spr" );
		path[19] += Com_RandomLong(0, 2); // randomize a bit


		break;
	case SMOKE_PISTOL:
		strcpy( path, "sprites/pistol_smoke1.spr" );
		path[20] += Com_RandomLong(0, 1);  // randomize a bit


		break;
	case SMOKE_BLACK:
		strcpy( path, "sprites/black_smoke1.spr" );
		path[19] += Com_RandomLong(0, 3); // randomize a bit


		break;
	default:
		assert(("Unknown smoketype!"));
	}

	if( wind )
		callback = EV_WallPuff_Wind;
	else
		callback = EV_SmokeRise;


	te = gEngfuncs.pEfxAPI->R_DefaultSprite( origin, gEngfuncs.pEventAPI->EV_FindModelIndex( path ), framerate );

	if( te )
	{
		te->callback = callback;
		te->hitcallback = EV_HugWalls;
		te->flags |= FTENT_COLLIDEALL | FTENT_CLIENTCUSTOM;
		te->entity.curstate.rendermode = kRenderTransAdd;
		te->entity.curstate.rendercolor.r = r;
		te->entity.curstate.rendercolor.g = g;
		te->entity.curstate.rendercolor.b = b;
		te->entity.curstate.renderamt = Com_RandomLong( 100, 180 );
		te->entity.curstate.scale = scale;
		te->entity.baseline.origin = speed * dir;

		if( !velocity.IsNull() )
		{
			velocity.x *= 0.5;
			velocity.y *= 0.5;
			velocity.z *= 0.9;
			te->entity.baseline.origin = te->entity.baseline.origin + velocity;
		}
	}
}


void EV_HLDM_DecalGunshot(pmtrace_t *pTrace, int iBulletType, float scale, int r, int g, int b, bool bCreateWallPuff, bool bCreateSparks, char cTextureType, bool isSky)
{
	physent_t *pe;

	if( isSky )
		return; // don't try to draw decals, spawn wall puff on skybox?

	pe = gEngfuncs.pEventAPI->EV_GetPhysent( pTrace->ent );

	if ( pe && pe->solid == SOLID_BSP )
	{
		EV_HLDM_GunshotDecalTrace( pTrace, EV_HLDM_DamageDecal( pe ), cTextureType );

		// create sparks
		if( gHUD.cl_weapon_sparks && gHUD.cl_weapon_sparks->value && bCreateSparks )
		{
			Vector dir = pTrace->plane.normal;
			dir.x = dir.x * dir.x * gEngfuncs.pfnRandomFloat( 4.0f, 12.0f );
			dir.y = dir.y * dir.y * gEngfuncs.pfnRandomFloat( 4.0f, 12.0f );
			dir.z = dir.z * dir.z * gEngfuncs.pfnRandomFloat( 4.0f, 12.0f );
			gEngfuncs.pEfxAPI->R_StreakSplash( pTrace->endpos, dir, 4, Com_RandomLong( 5, 10 ), dir.z, -75.0f, 75.0f );
		}

		// create wallpuff
		if( gHUD.cl_weapon_wallpuff && gHUD.cl_weapon_wallpuff->value && bCreateWallPuff )
		{
			/*TEMPENTITY *te = NULL;
			if( gHUD.fastsprites && !gHUD.fastsprites->value )
			{
				char path[] = "sprites/wall_puff1.spr";

				path[17] += Com_RandomLong(0, 3);
				te = gEngfuncs.pEfxAPI->R_DefaultSprite( pTrace->endpos,
									gEngfuncs.pEventAPI->EV_FindModelIndex(path), 30.0f );
			}
			else
			{
				te = gEngfuncs.pEfxAPI->R_DefaultSprite( pTrace->endpos,
									gEngfuncs.pEventAPI->EV_FindModelIndex("sprites/fast_wallpuff1.spr"), 30.0f );
			}

			if( te )
			{
				te->callback = EV_WallPuff_Wind;
				te->hitcallback = EV_HugWalls;
				te->flags |= FTENT_COLLIDEALL | FTENT_CLIENTCUSTOM;
				te->entity.curstate.rendermode = kRenderTransAdd;
				te->entity.curstate.rendercolor.r = r;
				te->entity.curstate.rendercolor.g = g;
				te->entity.curstate.rendercolor.b = b;
				te->entity.curstate.renderamt = Com_RandomLong( 100, 180 );
				te->entity.curstate.scale = 0.5;
				te->entity.baseline.origin = (25 + Com_RandomLong( 0, 4 ) ) * pTrace->plane.normal;
			}*/

			EV_CS16Client_CreateSmoke( SMOKE_WALLPUFF, pTrace->endpos, pTrace->plane.normal, 25, 0.5, r, g, b, true );
		}
	}
}

/*
============
EV_DescribeBulletTypeParameters

Sets iPenetrationPower and flPenetrationDistance.
If iBulletType is unknown, calls assert() and sets these two vars to 0
============
*/
void EV_DescribeBulletTypeParameters(int iBulletType, int &iPenetrationPower, float &flPenetrationDistance)
{
	switch (iBulletType)
	{
	case BULLET_PLAYER_9MM:
	{
		iPenetrationPower = 21;
		flPenetrationDistance = 800;
		break;
	}

	case BULLET_PLAYER_45ACP:
	{
		iPenetrationPower = 15;
		flPenetrationDistance = 500;
		break;
	}

	case BULLET_PLAYER_50AE:
	{
		iPenetrationPower = 30;
		flPenetrationDistance = 1000;
		break;
	}

	case BULLET_PLAYER_762MM:
	{
		iPenetrationPower = 39;
		flPenetrationDistance = 5000;
		break;
	}

	case BULLET_PLAYER_556MM:
	{
		iPenetrationPower = 35;
		flPenetrationDistance = 4000;
		break;
	}

	case BULLET_PLAYER_338MAG:
	{
		iPenetrationPower = 45;
		flPenetrationDistance = 8000;
		break;
	}

	case BULLET_PLAYER_57MM:
	{
		iPenetrationPower = 30;
		flPenetrationDistance = 2000;
		break;
	}

	case BULLET_PLAYER_357SIG:
	{
		iPenetrationPower = 25;
		flPenetrationDistance = 800;
		break;
	}

	default:
	{
		iPenetrationPower = 0;
		flPenetrationDistance = 0;
		break;
	}
	}
}



/*
================
EV_HLDM_FireBullets

Go to the trouble of combining multiple pellets into a single damage call.
================
*/
void EV_HLDM_FireBullets(int idx,
						 float *forward, float *right, float *up,
						 int cShots,
						 float *vecSrc, float *vecDirShooting, float *vecSpread,
						 float flDistance, int iBulletType, int iPenetration)
{
	int i;
	pmtrace_t tr;
	int iShot;
	int iPenetrationPower;
	float flPenetrationDistance;
	bool isSky;

	EV_DescribeBulletTypeParameters( iBulletType, iPenetrationPower, flPenetrationDistance );

	for ( iShot = 1; iShot <= cShots; iShot++ )
	{
		Vector vecShotSrc = vecSrc;
		int iShotPenetration = iPenetration;
		Vector vecDir, vecEnd;

		if ( iBulletType == BULLET_PLAYER_BUCKSHOT )
		{
			//We randomize for the Shotgun.
			float x, y, z;
			do {
				x = gEngfuncs.pfnRandomFloat(-0.5,0.5) + gEngfuncs.pfnRandomFloat(-0.5,0.5);
				y = gEngfuncs.pfnRandomFloat(-0.5,0.5) + gEngfuncs.pfnRandomFloat(-0.5,0.5);
				z = x*x+y*y;
			} while (z > 1);

			for ( i = 0 ; i < 3; i++ )
			{
				vecDir[i] = vecDirShooting[i] + x * vecSpread[0] * right[ i ] + y * vecSpread[1] * up [ i ];
				vecEnd[i] = vecShotSrc[ i ] + flDistance * vecDir[ i ];
			}
		}
		else //But other guns already have their spread randomized in the synched spread.
		{
			for ( i = 0 ; i < 3; i++ )
			{
				vecDir[i] = vecDirShooting[i] + vecSpread[0] * right[ i ] + vecSpread[1] * up [ i ];
				vecEnd[i] = vecShotSrc[ i ] + flDistance * vecDir[ i ];
			}
		}

		gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );

		// Store off the old count
		gEngfuncs.pEventAPI->EV_PushPMStates();

		// Now add in all of the players.
		gEngfuncs.pEventAPI->EV_SetSolidPlayers ( idx - 1 );

		while (iShotPenetration != 0)
		{
			gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
			gEngfuncs.pEventAPI->EV_PlayerTrace( vecShotSrc, vecEnd, 0, -1, &tr );

			float flCurrentDistance = tr.fraction * flDistance;

			if( flCurrentDistance == 0.0f )
			{
				break;
			}

			if ( flCurrentDistance > flPenetrationDistance )
				iShotPenetration = 0;
			else iShotPenetration--;

			char cTextureType = EV_HLDM_PlayTextureSound(idx, &tr, vecShotSrc, vecEnd, iBulletType, isSky );
			bool bSparks = true;
			int r_smoke, g_smoke, b_smoke;
			r_smoke = g_smoke = b_smoke = 40;

			switch (cTextureType)
			{
			case CHAR_TEX_METAL:
				iPenetrationPower *= 0.15;
				break;
			case CHAR_TEX_CONCRETE:
				r_smoke = g_smoke = b_smoke = 65;
				iPenetrationPower *= 0.25;
				break;
			case CHAR_TEX_VENT:
			case CHAR_TEX_GRATE:
				iPenetrationPower *= 0.5;
				break;
			case CHAR_TEX_TILE:
				iPenetrationPower *= 0.65;
				break;
			case CHAR_TEX_COMPUTER:
				iPenetrationPower *= 0.4;
				break;
			case CHAR_TEX_WOOD:
				bSparks = false;
				r_smoke = 75;
				g_smoke = 42;
				b_smoke = 15;
				break;
			}

			// do damage, paint decals
			EV_HLDM_DecalGunshot( &tr, iBulletType, 0, r_smoke, g_smoke, b_smoke, true, bSparks, cTextureType, isSky );

			if(/* iBulletType == BULLET_PLAYER_BUCKSHOT ||*/ iShotPenetration <= 0 )
			{
				break;
			}

			flDistance = (flDistance - flCurrentDistance) * 0.5;
			for( int i = 0; i < 3; i++ )
			{
				vecShotSrc[i] = tr.endpos[i]  + iPenetrationPower * vecDir[i];
				vecEnd[i]     = vecShotSrc[i] + flDistance        * vecDir[i];
			}


			// trace back, so we will have a decal on the other side of solid area
			pmtrace_t trOriginal;
			gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
			gEngfuncs.pEventAPI->EV_PlayerTrace(vecShotSrc, vecSrc, 0, -1, &trOriginal);
			if( !trOriginal.startsolid )
				EV_HLDM_DecalGunshot( &trOriginal, iBulletType, 0, r_smoke, g_smoke, b_smoke, true, bSparks, cTextureType, isSky );
		}
		gEngfuncs.pEventAPI->EV_PopPMStates();
	}

}

void EV_CS16Client_KillEveryRound( TEMPENTITY *te, float frametime, float current_time )
{
	if( g_flRoundTime > te->entity.curstate.fuser4 )
	{
		// Mark it die on next TempEntUpdate
		te->die = 0.0f;
		// Set null renderamt, so it will be invisible now
		// Also it will die immediately, if FTEMP_FADEOUT was set
		te->entity.curstate.renderamt = 0;
	}
}

void RemoveBody(TEMPENTITY *te, float frametime, float current_time)
{
	// go underground...
	/*if ( current_time >= 2 * te->entity.curstate.fuser2 + 5.0 )
		te->entity.origin.z -= 5.0 * frametime;*/
}

void HitBody(TEMPENTITY *ent, pmtrace_s *ptr)
{
	/*if ( ptr->plane.normal.z > 0.0 )
		ent->flags |= FTENT_NONE;*/
}


void CreateCorpse(Vector *p_vOrigin, Vector *p_vAngles, const char *pModel, float flAnimTime, int iSequence, int iBody)
{
	int modelIdx = gEngfuncs.pEventAPI->EV_FindModelIndex(pModel);
	vec3_t null(0, 0, 0);
	TEMPENTITY *model = gEngfuncs.pEfxAPI->R_TempModel( (float*)p_vOrigin,
														null,
														(float*)p_vAngles,
														gEngfuncs.pfnGetCvarFloat("cl_corpsestay"),
														modelIdx,
														0 );

	if(model)
	{
		//model->frameMax = -1;
		model->entity.curstate.animtime = flAnimTime;
		model->entity.curstate.framerate = 1.0;
		model->entity.curstate.frame = 0;
		model->entity.curstate.sequence = iSequence;
		model->entity.curstate.body = iBody;
		model->entity.curstate.fuser1 = gHUD.m_flTime + 1.0;
		model->entity.curstate.fuser2 = gEngfuncs.pfnGetCvarFloat("cl_corpsestay") + gHUD.m_flTime;
		model->hitcallback = HitBody;
		model->callback = RemoveBody;
	}
}

```

`cl_dll/events/event_ak47.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum ak47_e
{
	AK47_IDLE1 = 0,
	AK47_RELOAD,
	AK47_DRAW,
	AK47_SHOOT1,
	AK47_SHOOT2,
	AK47_SHOOT3
};

static const char *SOUNDS_NAME[] =
{
	"weapons/ak47-1.wav",
	"weapons/ak47-2.wav"
};

void EV_FireAK47( event_args_t *args )
{
	vec3_t ShellVelocity, ShellOrigin;
	vec3_t vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2] );
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(AK47_SHOOT1, AK47_SHOOT3), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, 10.0, 0);
		}

		if( gHUD.cl_gunsmoke->value )
		{
			cl_entity_t *ent = gEngfuncs.GetViewModel();

			if( ent )
			{
				EV_CS16Client_CreateSmoke( SMOKE_RIFLE, ent->attachment[0], forward, 3, 0.3, 20, 20, 20, false, velocity );
			}
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );

	Vector vSpread( args->fparam1, args->fparam2, 0.0f );
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_762MM,
		2 );
}

```

`cl_dll/events/event_aug.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
enum aug_e
{
	AUG_IDLE = 0,
	AUG_RELOAD,
	AUG_DRAW,
	AUG_SHOOT1,
	AUG_SHOOT2,
	AUG_SHOOT3
};

static const char *SOUNDS_NAME = "weapons/aug-1.wav";

void EV_FireAUG( struct event_args_s *args )
{
	vec3_t ShellVelocity, ShellOrigin;
	vec3_t vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2] );
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(AUG_SHOOT1, AUG_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_awp.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum awp_e
{
	AWP_IDLE = 0,
	AWP_SHOOT1,
	AWP_SHOOT2,
	AWP_SHOOT3,
	AWP_RELOAD,
	AWP_DRAW
};

static const char *SOUNDS_NAME = "weapons/awp1.wav";

void EV_FireAWP( event_args_t *args )
{
	vec3_t vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( Com_RandomLong(AWP_SHOOT1, AWP_SHOOT3), 2 );
	}

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_338MAG,
		3 );
}

```

`cl_dll/events/event_createexplo.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

void EV_CreateExplo(event_args_s *args)
{
	gEngfuncs.Con_DPrintf("^3 CREATE EXPLO EXPLO EXPLO EXPLO!!!111");
}

```

`cl_dll/events/event_createsmoke.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

#include "com_model.h"

#define SMOKE_CLOUDS 20

void EV_Smoke_FadeOut( struct tempent_s *te, float frametime, float currenttime )
{
	if( te->entity.curstate.renderamt > 0 && currenttime >= te->entity.curstate.fuser3 )
	{
		te->entity.curstate.renderamt = 255.0f - (currenttime - te->entity.curstate.fuser3) * te->entity.baseline.renderamt ;
		if( te->entity.curstate.renderamt < 0 ) te->entity.curstate.renderamt = 0;
	}
	EV_CS16Client_KillEveryRound( te, frametime, currenttime );
}


void EV_CreateSmoke(event_args_s *args)
{
	TEMPENTITY *pTemp;

	if( !args->bparam2 ) //first explosion
	{
		const model_t *pGasModel = gEngfuncs.GetSpritePointer(gHUD.m_hGasPuff);

		for( int i = 0; i < SMOKE_CLOUDS; i++ )
		{
			// randomize smoke cloud position
			Vector org = args->origin;
			org.x += Com_RandomFloat(-100.0f, 100.0f);
			org.y += Com_RandomFloat(-100.0f, 100.0f);
			org.z += 30; 

			pTemp = gEngfuncs.pEfxAPI->CL_TempEntAlloc( org, (model_s*)pGasModel );
			if( pTemp )
			{
				// don't die when animation is ended
				pTemp->flags |= (FTENT_SPRANIMATELOOP | FTENT_COLLIDEWORLD | FTENT_CLIENTCUSTOM);
				pTemp->die = gEngfuncs.GetClientTime() + 30.0f;
				pTemp->callback = EV_Smoke_FadeOut;
				pTemp->entity.curstate.fuser3 = gEngfuncs.GetClientTime() + 15.0f; // start fading after 15 sec
				pTemp->entity.curstate.fuser4 = gEngfuncs.GetClientTime(); // entity creation time

				pTemp->entity.curstate.renderamt = 255;
				pTemp->entity.curstate.rendermode = kRenderTransTexture;
				pTemp->entity.curstate.rendercolor.r = Com_RandomLong(210, 230);
				pTemp->entity.curstate.rendercolor.g = Com_RandomLong(210, 230);
				pTemp->entity.curstate.rendercolor.b = Com_RandomLong(210, 230);
				pTemp->entity.curstate.scale = 5.0f;

				// make it move slowly
				pTemp->entity.baseline.origin.x = Com_RandomLong(-5, 5);
				pTemp->entity.baseline.origin.y = Com_RandomLong(-5, 5);
				pTemp->entity.baseline.renderamt = 18;
			}
		}
	}
	else // second and other
	{
		pTemp = gEngfuncs.pEfxAPI->R_DefaultSprite( args->origin, g_iBlackSmoke, 6.0f );

		if( pTemp )
		{
			pTemp->flags |= (FTENT_CLIENTCUSTOM | FTENT_COLLIDEWORLD);
			pTemp->callback = EV_CS16Client_KillEveryRound;
			pTemp->entity.curstate.fuser4 = gEngfuncs.GetClientTime();

			pTemp->entity.curstate.rendermode = kRenderTransTexture;
			pTemp->entity.curstate.renderfx = kRenderFxNone;
			pTemp->entity.curstate.rendercolor.r = Com_RandomLong(210, 230);
			pTemp->entity.curstate.rendercolor.g = Com_RandomLong(210, 230);
			pTemp->entity.curstate.rendercolor.b = Com_RandomLong(210, 230);
			pTemp->entity.curstate.renderamt = Com_RandomLong(180, 200);

			pTemp->entity.baseline.origin[0] = Com_RandomLong(10, 30);
		}
	}
}

```

`cl_dll/events/event_deagle.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum deagle_e
{
	DEAGLE_IDLE1 = 0,
	DEAGLE_SHOOT1,
	DEAGLE_SHOOT2,
	DEAGLE_SHOOT_EMPTY,
	DEAGLE_RELOAD,
	DEAGLE_DRAW
};

static const char *SOUNDS_NAME[] =
{
	"weapons/deagle-1.wav",
	"weapons/deagle-2.wav"
};

void EV_FireDEAGLE( event_args_t *args )
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector velocity( args->velocity );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
	);
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		if( args->bparam1 )
		{
			gEngfuncs.pEventAPI->EV_WeaponAnimation( Com_RandomLong(DEAGLE_SHOOT1, DEAGLE_SHOOT2), 2 );
		}
		else
		{
			gEngfuncs.pEventAPI->EV_WeaponAnimation( DEAGLE_SHOOT_EMPTY, 2 );
		}
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -11.0, -16.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -11.0, 16.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	Vector vSpread( args->fparam1, args->fparam2, 0.0f );
	
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, forward,
		vSpread, 8192.0, BULLET_PLAYER_50AE,
		2 );
}

```

`cl_dll/events/event_decal_reset.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

#include <math.h>

float g_flRoundTime = 0.0f;

void EV_DecalReset(event_args_s *args)
{
	int decalnum = (int)(gEngfuncs.pfnGetCvarFloat("r_decals"));

	for( int i = 0; i < decalnum; i++ )
		gEngfuncs.pEfxAPI->R_DecalRemoveAll(i);

	g_flRoundTime = gEngfuncs.GetClientTime();
}

```

`cl_dll/events/event_elite_left.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum elite_e
{
	ELITE_IDLE,
	ELITE_IDLE_LEFTEMPTY,
	ELITE_SHOOTLEFT1,
	ELITE_SHOOTLEFT2,
	ELITE_SHOOTLEFT3,
	ELITE_SHOOTLEFT4,
	ELITE_SHOOTLEFT5,
	ELITE_SHOOTLEFTLAST,
	ELITE_SHOOTRIGHT1,
	ELITE_SHOOTRIGHT2,
	ELITE_SHOOTRIGHT3,
	ELITE_SHOOTRIGHT4,
	ELITE_SHOOTRIGHT5,
	ELITE_SHOOTRIGHTLAST,
	ELITE_RELOAD,
	ELITE_DRAW
};

static const char *SOUNDS_NAME = "weapons/elite_fire.wav";

void EV_FireElite( event_args_s *args, int sequence )
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;

	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles( args->angles );
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(sequence, 2);
		if( sequence >= ELITE_SHOOTRIGHT1 )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -11.0, -16.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -11.0, 16.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}
	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_9MM,
		2 );
}

void EV_FireEliteLeft(event_args_s *args)
{
	EV_FireElite( args, Com_RandomLong( ELITE_SHOOTLEFT1, ELITE_SHOOTLEFT4 ));
}

void EV_FireEliteRight( event_args_s *args )
{
	EV_FireElite( args, Com_RandomLong( ELITE_SHOOTRIGHT1, ELITE_SHOOTRIGHT4 ));
}

```

`cl_dll/events/event_elite_right.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
// Hi! :+)

```

`cl_dll/events/event_famas.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum famas_e
{
	FAMAS_IDLE = 0,
	FAMAS_RELOAD,
	FAMAS_DRAW,
	FAMAS_SHOOT1,
	FAMAS_SHOOT2,
	FAMAS_SHOOT3
};

static const char *SOUNDS_NAME[] =
{
	"weapons/famas-1.wav", "weapons/famas-2.wav"
};

void EV_FireFAMAS( event_args_t *args )
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 10000000.0f + args->angles[0],
		args->iparam2 / 10000000.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(FAMAS_SHOOT1,FAMAS_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_fiveseven.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum fiveseven_e
{
	FIVESEVEN_IDLE,
	FIVESEVEN_SHOOT1,
	FIVESEVEN_SHOOT2,
	FIVESEVEN_SHOOT_EMPTY,
	FIVESEVEN_RELOAD,
	FIVESEVEN_DRAW
};

static const char *SOUNDS_NAME = "weapons/fiveseven-1.wav";


void EV_Fire57(event_args_t *args)
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		if( args->bparam1 )
		{
			gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(FIVESEVEN_SHOOT1, FIVESEVEN_SHOOT2), 2);
		}
		else
		{
			gEngfuncs.pEventAPI->EV_WeaponAnimation(FIVESEVEN_SHOOT_EMPTY, 2);
		}

		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_57MM,
		2 );
}

```

`cl_dll/events/event_g3sg1.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum g3sg1_e
{
	G3SG1_IDLE,
	G3SG1_SHOOT,
	G3SG1_SHOOT2,
	G3SG1_RELOAD,
	G3SG1_DRAW
};

static const char *SOUNDS_NAME = "weapons/g3sg1-1.wav";

void EV_FireG3SG1(event_args_s *args)
{
	vec3_t ShellVelocity, ShellOrigin;
	vec3_t vecSrc, vecAiming;

	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(G3SG1_SHOOT, G3SG1_SHOOT2), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_762MM,
		2 );
}

```

`cl_dll/events/event_galil.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum galil_e
{
	GALIL_IDLE = 0,
	GALIL_RELOAD,
	GALIL_DRAW,
	GALIL_SHOOT1,
	GALIL_SHOOT2,
	GALIL_SHOOT3
};

static const char *SOUNDS_NAME[] =
{
	"weapons/galil-1.wav", "weapons/galil-2.wav"
};


void EV_FireGALIL( event_args_t *args )
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;


	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(GALIL_SHOOT1 + Com_RandomLong(0,2), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong( 0, 1 )] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;

	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_glock18.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

bool g_bGlockBurstMode = false;

enum glock18_e
{
	GLOCK18_IDLE1 = 0,
	GLOCK18_IDLE2,
	GLOCK18_IDLE3,
	GLOCK18_SHOOT1,
	GLOCK18_SHOOT2,
	GLOCK18_SHOOT3,
	GLOCK18_SHOOT_EMPTY,
	GLOCK18_RELOAD,
	GLOCK18_DRAW,
	GLOCK18_HOLSTER,
	GLOCK18_ADD_SILENCER,
	GLOCK18_DRAW2,
	GLOCK18_RELOAD2
};

enum glock18_shield_e
{
	GLOCK18_SHIELD_IDLE1,
	GLOCK18_SHIELD_SHOOT,
	GLOCK18_SHIELD_SHOOT2,
	GLOCK18_SHIELD_SHOOT_EMPTY,
	GLOCK18_SHIELD_RELOAD,
	GLOCK18_SHIELD_DRAW,
	GLOCK18_SHIELD_IDLE,
	GLOCK18_SHIELD_UP,
	GLOCK18_SHIELD_DOWN
};

static const char *SOUNDS_NAME[] =
{
	"weapons/glock18-1.wav", "weapons/glock18-2.wav"
};

void EV_Fireglock18( event_args_t *args )
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;

	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		int seq;
		if( args->bparam1 )
		{
			if( g_bHoldingShield )
				seq = GLOCK18_SHIELD_SHOOT;
			else
				seq = (g_iWeaponFlags & WPNSTATE_GLOCK18_BURST_MODE) != 0 || g_bGlockBurstMode? GLOCK18_SHOOT1: GLOCK18_SHOOT3;
		}
		else
		{
			if( g_bHoldingShield )
				seq = GLOCK18_SHIELD_SHOOT_EMPTY;
			else
				seq = GLOCK18_SHOOT_EMPTY;
		}
		gEngfuncs.pEventAPI->EV_WeaponAnimation(seq, 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( ((g_iWeaponFlags & WPNSTATE_GLOCK18_BURST_MODE) != 0 || g_bGlockBurstMode )
						&& !g_bHoldingShield ? SOUNDS_NAME[0] : SOUNDS_NAME[1] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 4096.0, BULLET_PLAYER_9MM,
		2 );
}

```

`cl_dll/events/event_knife.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum knife_e
{
	KNIFE_IDLE1 = 0,
	KNIFE_SLASH1,
	KNIFE_SLASH2,
	KNIFE_DRAW,
	KNIFE_STAB,
	KNIFE_STAB_MISS,
	KNIFE_MIDSLASH1,
	KNIFE_MIDSLASH2
};

static const char *SOUNDS_NAME = "weapons/knife_miss1.wav";

void EV_Knife( struct event_args_s *args )
{
	int    idx = args->entindex;
	Vector origin( args->origin );

	if( EV_IsLocal( idx ))
		gEngfuncs.pEventAPI->EV_WeaponAnimation( args->iparam1, 2 );

	//Play Swing sound
	PLAY_EVENT_SOUND( SOUNDS_NAME );
}

```

`cl_dll/events/event_m249.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum m249_e
{
	M249_IDLE1,
	M249_SHOOT1,
	M249_SHOOT2,
	M249_RELOAD,
	M249_DRAW
};

static const char *SOUNDS_NAME[] =
{
	 "weapons/m249-1.wav", "weapons/m249-2.wav"
};

void EV_FireM249(event_args_s *args)
{
	vec3_t ShellVelocity, ShellOrigin;
	vec3_t vecSrc, vecAiming;

	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;
	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(M249_SHOOT1, M249_SHOOT2), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -10.0, -13.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -10.0, 13.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_m3.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum m3_e
{
	M3_IDLE1 = 0,
	M3_SHOOT1,
	M3_SHOOT2,
	M3_INSERT,
	M3_AFTER_RELOAD,
	M3_START_RELOAD,
	M3_DRAW
};

static const char *SOUNDS_NAME = "weapons/m3-1.wav";

void EV_FireM3( event_args_t *args )
{
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(M3_SHOOT1, M3_SHOOT2), 2);
	}

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = 0.0725;
	vSpread.y = 0.0725;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		9, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_BUCKSHOT,
		1 );
}

```

`cl_dll/events/event_m4a1.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum m4a1_e
{
	M4A1_IDLE1 = 0,
	M4A1_SHOOT1,
	M4A1_SHOOT2,
	M4A1_SHOOT3,
	M4A1_RELOAD,
	M4A1_DRAW,
	M4A1_ADD_SILENCER,
	M4A1_IDLE_UNSIL,
	M4A1_SHOOT1_UNSIL,
	M4A1_SHOOT2_UNSIL,
	M4A1_SHOOT3_UNSIL,
	M4A1_RELOAD_UNSIL,
	M4A1_DRAW_UNSIL,
	M4A1_DETACH_SILENCER
};

static const char *SOUNDS_NAME[] =
{
	"weapons/m4a1-1.wav",
	"weapons/m4a1_unsil-1.wav",
	"weapons/m4a1_unsil-2.wav"
};

void EV_FireM4A1( event_args_t *args )
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    sequence, idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		if( args->bparam1 )
		{
			sequence = Com_RandomLong( M4A1_SHOOT1, M4A1_SHOOT3 );
		}
		else
		{
			sequence = Com_RandomLong( M4A1_SHOOT1_UNSIL, M4A1_SHOOT3_UNSIL );
		}
		gEngfuncs.pEventAPI->EV_WeaponAnimation(sequence, 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( args->bparam1 ? SOUNDS_NAME[0] : SOUNDS_NAME[Com_RandomLong( 1, 2 )]);

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_mac10.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum mac10_e
{
	MAC10_IDLE1,
	MAC10_RELOAD,
	MAC10_DRAW,
	MAC10_SHOOT1,
	MAC10_SHOOT2,
	MAC10_SHOOT3
};

static const char *SOUNDS_NAME = "weapons/mac10-1.wav";

void EV_FireMAC10(event_args_s *args)
{
	vec3_t ShellVelocity, ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(MAC10_SHOOT1, MAC10_SHOOT3), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32.0, -9.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32.0, -9.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_45ACP,
		2 );
}

```

`cl_dll/events/event_mp5n.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum mp5n_e
{
	MP5N_IDLE = 0,
	MP5N_RELOAD,
	MP5N_DRAW,
	MP5N_SHOOT1,
	MP5N_SHOOT2,
	MP5N_SHOOT3
};

static const char *SOUNDS_NAME[] =
{
	"weapons/mp5-1.wav",
	"weapons/mp5-2.wav"
};

void EV_FireMP5( event_args_t *args )
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(MP5N_SHOOT1 + Com_RandomLong(0,2), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -10.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -10.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_9MM,
		2 );
}

```

`cl_dll/events/event_p228.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum p228_e
{
	P228_IDLE,
	P228_SHOOT1,
	P228_SHOOT2,
	P228_SHOOT3,
	P228_SHOOT_EMPTY,
	P228_RELOAD,
	P228_DRAW
};

enum p228_shield_e
{
	P228_SHIELD_IDLE,
	P228_SHIELD_SHOOT1,
	P228_SHIELD_SHOOT2,
	P228_SHIELD_SHOOT_EMPTY,
	P228_SHIELD_RELOAD,
	P228_SHIELD_DRAW,
	P228_SHIELD_IDLE_UP,
	P228_SHIELD_UP,
	P228_SHIELD_DOWN
};

static const char *SOUNDS_NAME = "weapons/p228-1.wav";

void EV_FireP228(event_args_s *args)
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		int seq;
		if( args->bparam1 )
		{
			if( g_bHoldingShield )
				seq = Com_RandomLong(P228_SHIELD_SHOOT1, P228_SHIELD_SHOOT2);
			else
				seq = Com_RandomLong(P228_SHOOT1, P228_SHOOT3);
		}
		else
		{
			seq = g_bHoldingShield ? (int)P228_SHIELD_SHOOT_EMPTY : (int)P228_SHOOT_EMPTY;
		}
		gEngfuncs.pEventAPI->EV_WeaponAnimation(seq, 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);
	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_357SIG,
		2 );
}

```

`cl_dll/events/event_p90.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"
enum p90_e
{
	P90_IDLE1,
	P90_RELOAD,
	P90_DRAW,
	P90_SHOOT1,
	P90_SHOOT2,
	P90_SHOOT3
};

static const char *SOUNDS_NAME = "weapons/p90-1.wav";

void EV_FireP90(event_args_s *args)
{
	vec3_t ShellVelocity, ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( args->entindex ) )
	{
		++g_iShotsFired;
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(P90_SHOOT1, P90_SHOOT3), 2);
		EV_MuzzleFlash();
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -16.0, -22.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 35.0, -16.0, 22.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_57MM,
		2 );
}

```

`cl_dll/events/event_scout.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum scout_e
{
	SCOUT_IDLE,
	SCOUT_SHOOT,
	SCOUT_SHOOT2,
	SCOUT_RELOAD,
	SCOUT_DRAW
};

static const char *SOUNDS_NAME = "weapons/scout_fire-1.wav";

void EV_FireScout(event_args_s *args)
{
	vec3_t vecSrc, vecAiming;

	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( Com_RandomLong(SCOUT_SHOOT, SCOUT_SHOOT2), 2 );
	}

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1 / 1000.0f;
	vSpread.y = args->fparam2 / 1000.0f;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_762MM,
		2 );
}

```

`cl_dll/events/event_sg550.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum sg550_e
{
	SG550_IDLE,
	SG550_SHOOT,
	SG550_SHOOT2,
	SG550_RELOAD,
	SG550_DRAW
};

static const char *SOUNDS_NAME = "weapons/sg550-1.wav";

void EV_FireSG550(event_args_s *args)
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation( Com_RandomLong(SG550_SHOOT, SG550_SHOOT2), 2 );
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 17.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );


	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_sg552.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum sg552_e
{
	SG552_IDLE = 0,
	SG552_RELOAD,
	SG552_DRAW,
	SG552_SHOOT1,
	SG552_SHOOT2,
	SG552_SHOOT3
};

static const char *SOUNDS_NAME[] =
{
	"weapons/sg552-1.wav", "weapons/sg552-2.wav"
};

void EV_FireSG552( event_args_t *args )
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(SG552_SHOOT1, SG552_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, -10.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -8.0, 10.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iRShell, TE_BOUNCE_SHELL);
	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_556MM,
		2 );
}

```

`cl_dll/events/event_tmp.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum tmp_e
{
	TMP_IDLE1,
	TMP_RELOAD,
	TMP_DRAW,
	TMP_SHOOT1,
	TMP_SHOOT2,
	TMP_SHOOT3
};

static const char *SOUNDS_NAME[] =
{
	"weapons/tmp-1.wav", "weapons/tmp-2.wav"
};

void EV_FireTMP(event_args_s *args)
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(TMP_SHOOT1, TMP_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32.0, -6.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 32.0, -6.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);
	PLAY_EVENT_SOUND( SOUNDS_NAME[Com_RandomLong( 0, 1 )] );
	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_9MM,
		2 );
}

```

`cl_dll/events/event_ump45.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum ump45_e
{
	UMP45_IDLE1,
	UMP45_RELOAD,
	UMP45_DRAW,
	UMP45_SHOOT1,
	UMP45_SHOOT2,
	UMP45_SHOOT3
};

static const char *SOUNDS_NAME = "weapons/ump45-1.wav";

void EV_FireUMP45(event_args_s *args)
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(UMP45_SHOOT1, UMP45_SHOOT3), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 34.0, -10.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 34.0, -10.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);
	PLAY_EVENT_SOUND( SOUNDS_NAME );
	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_45ACP,
		2 );
}

```

`cl_dll/events/event_usp.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum usp_e
{
	USP_IDLE,
	USP_SHOOT1,
	USP_SHOOT2,
	USP_SHOOT3,
	USP_SHOOT_EMPTY,
	USP_RELOAD,
	USP_DRAW,
	USP_ATTACH_SILENCER,
	USP_UNSIL_IDLE,
	USP_UNSIL_SHOOT1,
	USP_UNSIL_SHOOT2,
	USP_UNSIL_SHOOT3,
	USP_UNSIL_SHOOT_EMPTY,
	USP_UNSIL_RELOAD,
	USP_UNSIL_DRAW,
	USP_DETACH_SILENCER
};

enum usp_shield_e
{
	USP_SHIELD_IDLE,
	USP_SHIELD_SHOOT1,
	USP_SHIELD_SHOOT2,
	USP_SHIELD_SHOOT_EMPTY,
	USP_SHIELD_RELOAD,
	USP_SHIELD_DRAW,
	USP_SHIELD_UP_IDLE,
	USP_SHIELD_UP,
	USP_SHIELD_DOWN
};

static const char *SOUNDS_NAME[] =
{
	"weapons/usp1.wav",
	"weapons/usp2.wav",
	"weapons/usp_unsil-1.wav",
};
void EV_FireUSP( event_args_t *args )
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;

	bool silencer_on = !args->bparam2;
	bool empty		 = !args->bparam1;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		int seq;
		if( g_bHoldingShield )
		{
			if( !empty )
				seq = Com_RandomLong(USP_SHIELD_SHOOT1, USP_SHIELD_SHOOT2);
			else seq = USP_SHIELD_SHOOT_EMPTY;
		}
		else if ( silencer_on )
		{
			if( !empty )
				seq = Com_RandomLong(USP_UNSIL_SHOOT1, USP_UNSIL_SHOOT3);
			else seq = USP_UNSIL_SHOOT_EMPTY;
		}
		else
		{
			EV_MuzzleFlash();
			if( !empty )
				seq = Com_RandomLong(USP_SHOOT1, USP_SHOOT3);
			else seq = USP_SHOOT_EMPTY;
		}

		gEngfuncs.pEventAPI->EV_WeaponAnimation(seq, 2);


		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, -14.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 36.0, -14.0, 14.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}


	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iPShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( silencer_on? SOUNDS_NAME[2] : SOUNDS_NAME[Com_RandomLong(0, 1)] );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = args->fparam1;
	vSpread.y = args->fparam2;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		1, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_45ACP,
		2 );
}

```

`cl_dll/events/event_vehicle.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

#include <string.h>

static const char *SOUNDS_NAME[] =
{
	"plats/vehicle1.wav",
	"plats/vehicle2.wav",
	"plats/vehicle3.wav",
	"plats/vehicle4.wav",
	"plats/vehicle6.wav",
	"plats/vehicle7.wav"
};

static const char *SOUNDS_NAME_TRAIN[] =
{
	"plats/ttrain1.wav",
	"plats/ttrain2.wav",
	"plats/ttrain3.wav",
	"plats/ttrain4.wav",
	"plats/ttrain6.wav",
	"plats/ttrain7.wav"
};


void EV_Vehicle(event_args_s *args)
{
	Vector origin(args->origin);
	int idx = args->entindex;
	unsigned short us_params = (unsigned short)args->iparam1;
	int stop	  = args->bparam1;
	float m_flVolume	= (float)(us_params & 0x003f)/40.0;
	int noise		= (int)(((us_params) >> 12 ) & 0x0007);
	int pitch		= (int)( 10.0 * (float)( ( us_params >> 6 ) & 0x003f ) );


	if( noise < 0 || noise > 5 )
		return;

	if ( stop )
	{
		gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_STATIC, SOUNDS_NAME[noise] );
	}
	else
	{
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, SOUNDS_NAME[noise], m_flVolume, ATTN_NORM, 0, pitch );
	}
}


void EV_TrainPitchAdjust( event_args_t *args )
{
	Vector origin(args->origin);
	int idx = args->entindex;
	unsigned short us_params = (unsigned short)args->iparam1;
	int stop	  = args->bparam1;
	float m_flVolume	= (float)(us_params & 0x003f)/40.0;
	int noise		= (int)(((us_params) >> 12 ) & 0x0007);
	int pitch		= (int)( 10.0 * (float)( ( us_params >> 6 ) & 0x003f ) );

	if( noise < 0 || noise > 5 )
		return;

	if ( stop )
	{
		gEngfuncs.pEventAPI->EV_StopSound( idx, CHAN_STATIC, SOUNDS_NAME_TRAIN[noise] );
	}
	else
	{
		gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_STATIC, SOUNDS_NAME_TRAIN[noise], m_flVolume, ATTN_NORM, 0, pitch );
	}
}

```

`cl_dll/events/event_xm1014.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include "events.h"

enum xm1014_e
{
	XM1014_IDLE,
	XM1014_FIRE1,
	XM1014_FIRE2,
	XM1014_RELOAD,
	XM1014_PUMP,
	XM1014_START_RELOAD,
	XM1014_DRAW
};

static const char *SOUNDS_NAME = "weapons/xm1014-1.wav";

void EV_FireXM1014(event_args_s *args)
{
	vec3_t ShellVelocity;
	vec3_t ShellOrigin;
	vec3_t vecSrc, vecAiming;
	int    idx = args->entindex;
	Vector origin( args->origin );
	Vector angles(
		args->iparam1 / 100.0f + args->angles[0],
		args->iparam2 / 100.0f + args->angles[1],
		args->angles[2]
		);
	Vector velocity( args->velocity );
	Vector forward, right, up;

	AngleVectors( angles, forward, right, up );

	if ( EV_IsLocal( idx ) )
	{
		++g_iShotsFired;
		EV_MuzzleFlash();
		gEngfuncs.pEventAPI->EV_WeaponAnimation(Com_RandomLong(XM1014_FIRE1, XM1014_FIRE2), 2);
		if( !gHUD.cl_righthand->value )
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 22.0, -9.0, -11.0, 0);
		}
		else
		{
			EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 22.0, -9.0, 11.0, 0);
		}
	}
	else
	{
		EV_GetDefaultShellInfo( args, origin, velocity, ShellVelocity, ShellOrigin, forward, right, up, 20.0, -12.0, 4.0, 0);
	}

	EV_EjectBrass(ShellOrigin, ShellVelocity, angles[ YAW ], g_iShotgunShell, TE_BOUNCE_SHELL);

	PLAY_EVENT_SOUND( SOUNDS_NAME );

	EV_GetGunPosition( args, vecSrc, origin );
	VectorCopy( forward, vecAiming );
	Vector vSpread;
	
	vSpread.x = 0.0725;
	vSpread.y = 0.0725;
	EV_HLDM_FireBullets( idx,
		forward, right,	up,
		6, vecSrc, vecAiming,
		vSpread, 8192.0, BULLET_PLAYER_BUCKSHOT,
		1 );
}

```

`cl_dll/events/hl_events.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#include "events.h"

int g_iRShell, g_iPShell, g_iBlackSmoke, g_iShotgunShell;

/*
======================
Game_HookEvents

Associate script file name with callback functions.  Callback's must be extern "C" so
 the engine doesn't get confused about name mangling stuff.  Note that the format is
 always the same.  Of course, a clever mod team could actually embed parameters, behavior
 into the actual .sc files and create a .sc file parser and hook their functionality through
 that.. i.e., a scripting system.

That was what we were going to do, but we ran out of time...oh well.
======================
*/
void Game_HookEvents( void )
{
	HOOK_EVENT( ak47, FireAK47 );
	HOOK_EVENT( aug, FireAUG );
	HOOK_EVENT( awp, FireAWP );
	HOOK_EVENT( createexplo, CreateExplo );
	HOOK_EVENT( createsmoke, CreateSmoke );
	HOOK_EVENT( deagle, FireDEAGLE );
	HOOK_EVENT( decal_reset, DecalReset );
	HOOK_EVENT( elite_left, FireEliteLeft );
	HOOK_EVENT( elite_right, FireEliteRight );
	HOOK_EVENT( famas, FireFAMAS );
	HOOK_EVENT( fiveseven, Fire57 );
	HOOK_EVENT( g3sg1, FireG3SG1 );
	HOOK_EVENT( galil, FireGALIL );
	HOOK_EVENT( glock18, Fireglock18 );
	HOOK_EVENT( knife, Knife );
	HOOK_EVENT( m249, FireM249 );
	HOOK_EVENT( m3, FireM3 );
	HOOK_EVENT( m4a1, FireM4A1 );
	HOOK_EVENT( mac10, FireMAC10 );
	HOOK_EVENT( mp5n, FireMP5 );
	HOOK_EVENT( p228, FireP228 );
	HOOK_EVENT( p90, FireP90 );
	HOOK_EVENT( scout, FireScout );
	HOOK_EVENT( sg550, FireSG550 );
	HOOK_EVENT( sg552, FireSG552 );
	HOOK_EVENT( tmp, FireTMP );
	HOOK_EVENT( ump45, FireUMP45 );
	HOOK_EVENT( usp, FireUSP );
	HOOK_EVENT( vehicle, Vehicle );
	HOOK_EVENT( xm1014, FireXM1014 );
}

```

`cl_dll/hud/MOTD.cpp`:

```cpp
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// MOTD.cpp
//
// for displaying a server-sent message of the day
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "kbutton.h"
#include "triangleapi.h"
#include <string.h>
#include <stdio.h>
#include "draw_util.h"

DECLARE_MESSAGE( m_MOTD, MOTD )

int CHudMOTD :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( MOTD );

	m_bShow = false;

	m_iFlags &= ~HUD_DRAW;  // start out inactive
	m_szMOTD[0] = 0;
	cl_hide_motd = CVAR_CREATE("cl_hide_motd", "0", FCVAR_ARCHIVE); // hide motd

	return 1;
}

int CHudMOTD :: VidInit( void )
{
	// Load sprites here
	return 1;
}

void CHudMOTD :: Reset( void )
{
	m_iFlags &= ~HUD_DRAW;  // start out inactive
	m_szMOTD[0] = 0;
	m_iLines = 0;
	m_bShow = 0;
	ignoreThisMotd = false;
}

#define LINE_HEIGHT  13
#define ROW_GAP  13
#define ROW_RANGE_MIN 30
#define ROW_RANGE_MAX ( ScreenHeight - 100 )
int CHudMOTD :: Draw( float fTime )
{
	gHUD.m_iNoConsolePrint &= ~( 1 << 1 );
	if( !m_bShow )
		return 1;

	if( cl_hide_motd->value )
	{
		Reset();
		return 1;
	}

	gHUD.m_iNoConsolePrint |= 1 << 1;
	// find the top of where the MOTD should be drawn,  so the whole thing is centered in the screen
	int ypos = (ScreenHeight - LINE_HEIGHT * m_iLines)/2; // shift it up slightly
	char *ch = m_szMOTD;
	int xpos = (ScreenWidth - gHUD.GetCharWidth( 'M' ) * m_iMaxLength) / 2;
	if( xpos < 30 ) xpos = 30;
	int xmax = xpos + gHUD.GetCharWidth( 'M' ) * m_iMaxLength;
	int height = LINE_HEIGHT * m_iLines;
	int ypos_r=ypos;
	if( height > ROW_RANGE_MAX )
	{
		ypos = ROW_RANGE_MIN + 7 + scroll;
		if( ypos  > ROW_RANGE_MIN + 4 )
			scroll-= (ypos - ( ROW_RANGE_MIN + 4))/3.0;
		if( ypos + height < ROW_RANGE_MAX )
			scroll+= (ROW_RANGE_MAX - (ypos + height))/ 3.0;
		ypos_r = ROW_RANGE_MIN;
		height = ROW_RANGE_MAX;
	}
	if( xmax > ScreenWidth - 30 ) xmax = ScreenWidth - 30;
	char *next_line;
	DrawUtils::DrawRectangle(xpos-5, ypos_r - 5, xmax - xpos+10, height + 10);
	while ( *ch )
	{
		int line_length = 0;  // count the length of the current line
		for ( next_line = ch; *next_line != '\n' && *next_line != 0; next_line++ )
			line_length += gHUD.GetCharWidth( (unsigned char)*next_line );
		char *top = next_line;
		if ( *top == '\n' )
			*top = 0;
		else
			top = NULL;

		// find where to start drawing the line
		if( (ypos > ROW_RANGE_MIN) && (ypos + LINE_HEIGHT <= ypos_r + height) )
			DrawUtils::DrawHudString( xpos, ypos, xmax, ch, 255, 180, 0 );

		ypos += LINE_HEIGHT;

		if ( top )  // restore 
			*top = '\n';
		ch = next_line;
		if ( *ch == '\n' )
			ch++;

		if ( ypos > (ScreenHeight - 20) )
			break;  // don't let it draw too low
	}
	
	return 1;
}

int CHudMOTD :: MsgFunc_MOTD( const char *pszName, int iSize, void *pbuf )
{
	if( cl_hide_motd->value )
		return 1;

	if ( m_iFlags & HUD_DRAW )
	{
		Reset(); // clear the current MOTD in prep for this one
	}

	if( ignoreThisMotd )
		return 1;

	BufferReader reader( pszName, pbuf, iSize );

	int is_finished = reader.ReadByte();
	strcat( m_szMOTD, reader.ReadString() );

	// we still don't support html tags in motd :(
	if( strcmp( m_szMOTD, "<!DOCTYPE HTML>" ) )
	{
		Reset();
		ignoreThisMotd = true;
	}

	if ( is_finished )
	{
		int length = 0;
		
		m_iMaxLength = 0;
		m_iFlags |= HUD_DRAW;


		for ( char *sz = m_szMOTD; *sz != 0; sz++ )  // count the number of lines in the MOTD
		{
			if ( *sz == '\n' )
			{
				m_iLines++;
				if( length > m_iMaxLength )
				{
					m_iMaxLength = length;
					length = 0;
				}
			}
			length++;
		}
		
		m_iLines++;
		if( length > m_iMaxLength )
		{
			m_iMaxLength = length;
			length = 0;
		}
		m_bShow = true;
	}

	return 1;
}

```

`cl_dll/hud/ammo.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Ammo.cpp
//
// implementation of CHudAmmo class
//

#include "hud.h"
#include "cvardef.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "pm_shared.h"

#include <string.h>
#include <stdio.h>

#include "ammohistory.h"
#include "eventscripts.h"
#include "com_weapons.h"
#include "draw_util.h"

enum WeaponIdType
{
	WEAPON_NONE,
	WEAPON_P228,
	WEAPON_GLOCK,
	WEAPON_SCOUT,
	WEAPON_HEGRENADE,
	WEAPON_XM1014,
	WEAPON_C4,
	WEAPON_MAC10,
	WEAPON_AUG,
	WEAPON_SMOKEGRENADE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_UMP45,
	WEAPON_SG550,
	WEAPON_GALIL,
	WEAPON_FAMAS,
	WEAPON_USP,
	WEAPON_GLOCK18,
	WEAPON_AWP,
	WEAPON_MP5N,
	WEAPON_M249,
	WEAPON_M3,
	WEAPON_M4A1,
	WEAPON_TMP,
	WEAPON_G3SG1,
	WEAPON_FLASHBANG,
	WEAPON_DEAGLE,
	WEAPON_SG552,
	WEAPON_AK47,
	WEAPON_KNIFE,
	WEAPON_P90,
	WEAPON_SHIELDGUN = 99
};
//#include "vgui_TeamFortressViewport.h"

#ifndef __linux__

void sincosf (float rad, float *sine, float *cosine)
{
   *sine = sinf (rad);
   *cosine = cosf (rad);
}

#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

#endif

WEAPON *gpActiveSel;	// NULL means off, 1 means just the menu bar, otherwise
						// this points to the active weapon menu item
WEAPON *gpLastSel;		// Last weapon menu selection 

client_sprite_t *GetSpriteList(client_sprite_t *pList, const char *psz, int iRes, int iCount);

WeaponsResource gWR;

int g_weaponselect = 0;
int g_iShotsFired;

void WeaponsResource :: LoadAllWeaponSprites( void )
{
	for (int i = 0; i < MAX_WEAPONS; i++)
	{
		if ( rgWeapons[i].iId )
			LoadWeaponSprites( &rgWeapons[i] );
	}
}

int WeaponsResource :: CountAmmo( int iId ) 
{ 
	if ( iId < 0 )
		return 0;

	return riAmmo[iId];
}

int WeaponsResource :: HasAmmo( WEAPON *p )
{
	if ( !p )
		return FALSE;

	// weapons with no max ammo can always be selected
	if ( p->iMax1 == -1 )
		return TRUE;

	return (p->iAmmoType == -1) || p->iClip > 0 || CountAmmo(p->iAmmoType) 
		|| CountAmmo(p->iAmmo2Type) || ( p->iFlags & WEAPON_FLAGS_SELECTONEMPTY );
}


void WeaponsResource :: LoadWeaponSprites( WEAPON *pWeapon )
{
	int i, iRes = 640;

	char sz[128];

	if ( !pWeapon )
		return;

	memset( &pWeapon->rcActive, 0, sizeof(wrect_t) );
	memset( &pWeapon->rcInactive, 0, sizeof(wrect_t) );
	memset( &pWeapon->rcAmmo, 0, sizeof(wrect_t) );
	memset( &pWeapon->rcAmmo2, 0, sizeof(wrect_t) );
	pWeapon->hInactive = 0;
	pWeapon->hActive = 0;
	pWeapon->hAmmo = 0;
	pWeapon->hAmmo2 = 0;

	sprintf(sz, "sprites/%s.txt", pWeapon->szName);
	client_sprite_t *pList = SPR_GetList(sz, &i);

	if (!pList)
		return;

	client_sprite_t *p;
	
	p = GetSpriteList( pList, "crosshair", iRes, i );
	if (p)
	{
		sprintf(sz, "sprites/%s.spr", p->szSprite);
		pWeapon->hCrosshair = SPR_Load(sz);
		pWeapon->rcCrosshair = p->rc;
	}
	else
		pWeapon->hCrosshair = 0;

	p = GetSpriteList(pList, "autoaim", iRes, i);
	if (p)
	{
		sprintf(sz, "sprites/%s.spr", p->szSprite);
		pWeapon->hAutoaim = SPR_Load(sz);
		pWeapon->rcAutoaim = p->rc;
	}
	else
		pWeapon->hAutoaim = 0;

	p = GetSpriteList( pList, "zoom", iRes, i );
	if (p)
	{
		sprintf(sz, "sprites/%s.spr", p->szSprite);
		pWeapon->hZoomedCrosshair = SPR_Load(sz);
		pWeapon->rcZoomedCrosshair = p->rc;
	}
	else
	{
		pWeapon->hZoomedCrosshair = pWeapon->hCrosshair; //default to non-zoomed crosshair
		pWeapon->rcZoomedCrosshair = pWeapon->rcCrosshair;
	}

	p = GetSpriteList(pList, "zoom_autoaim", iRes, i);
	if (p)
	{
		sprintf(sz, "sprites/%s.spr", p->szSprite);
		pWeapon->hZoomedAutoaim = SPR_Load(sz);
		pWeapon->rcZoomedAutoaim = p->rc;
	}
	else
	{
		pWeapon->hZoomedAutoaim = pWeapon->hZoomedCrosshair;  //default to zoomed crosshair
		pWeapon->rcZoomedAutoaim = pWeapon->rcZoomedCrosshair;
	}

	p = GetSpriteList(pList, "weapon", iRes, i);
	if (p)
	{
		sprintf(sz, "sprites/%s.spr", p->szSprite);
		pWeapon->hInactive = SPR_Load(sz);
		pWeapon->rcInactive = p->rc;

		gHR.iHistoryGap = max( gHR.iHistoryGap, pWeapon->rcActive.bottom - pWeapon->rcActive.top );
	}
	else
		pWeapon->hInactive = 0;

	p = GetSpriteList(pList, "weapon_s", iRes, i);
	if (p)
	{
		sprintf(sz, "sprites/%s.spr", p->szSprite);
		pWeapon->hActive = SPR_Load(sz);
		pWeapon->rcActive = p->rc;
	}
	else
		pWeapon->hActive = 0;

	p = GetSpriteList(pList, "ammo", iRes, i);
	if (p)
	{
		sprintf(sz, "sprites/%s.spr", p->szSprite);
		pWeapon->hAmmo = SPR_Load(sz);
		pWeapon->rcAmmo = p->rc;

		gHR.iHistoryGap = max( gHR.iHistoryGap, pWeapon->rcActive.bottom - pWeapon->rcActive.top );
	}
	else
		pWeapon->hAmmo = 0;

	p = GetSpriteList(pList, "ammo2", iRes, i);
	if (p)
	{
		sprintf(sz, "sprites/%s.spr", p->szSprite);
		pWeapon->hAmmo2 = SPR_Load(sz);
		pWeapon->rcAmmo2 = p->rc;

		gHR.iHistoryGap = max( gHR.iHistoryGap, pWeapon->rcActive.bottom - pWeapon->rcActive.top );
	}
	else
		pWeapon->hAmmo2 = 0;

}

// Returns the first weapon for a given slot.
WEAPON *WeaponsResource :: GetFirstPos( int iSlot )
{
	WEAPON *pret = NULL;

	for (int i = 0; i < MAX_WEAPON_POSITIONS; i++)
	{
		if ( rgSlots[iSlot][i] /*&& HasAmmo( rgSlots[iSlot][i] )*/ )
		{
			pret = rgSlots[iSlot][i];
			break;
		}
	}

	return pret;
}


WEAPON* WeaponsResource :: GetNextActivePos( int iSlot, int iSlotPos )
{
	if ( iSlotPos >= MAX_WEAPON_POSITIONS || iSlot >= MAX_WEAPON_SLOTS )
		return NULL;

	WEAPON *p = gWR.rgSlots[ iSlot ][ iSlotPos+1 ];
	
	if ( !p || !gWR.HasAmmo(p) )
		return GetNextActivePos( iSlot, iSlotPos + 1 );

	return p;
}


int giBucketHeight, giBucketWidth, giABHeight, giABWidth; // Ammo Bar width and height

HSPRITE ghsprBuckets;					// Sprite for top row of weapons menu

DECLARE_MESSAGE(m_Ammo, CurWeapon ) // Current weapon and clip
DECLARE_MESSAGE(m_Ammo, WeaponList) // new weapon type
DECLARE_MESSAGE(m_Ammo, AmmoX)      // update known ammo type's count
DECLARE_MESSAGE(m_Ammo, AmmoPickup) // flashes an ammo pickup record
DECLARE_MESSAGE(m_Ammo, WeapPickup) // flashes a weapon pickup record
DECLARE_MESSAGE(m_Ammo, HideWeapon) // hides the weapon, ammo, and crosshair displays temporarily
DECLARE_MESSAGE(m_Ammo, ItemPickup)
DECLARE_MESSAGE(m_Ammo, Crosshair)
DECLARE_MESSAGE(m_Ammo, Brass)

DECLARE_COMMAND(m_Ammo, Slot1)
DECLARE_COMMAND(m_Ammo, Slot2)
DECLARE_COMMAND(m_Ammo, Slot3)
DECLARE_COMMAND(m_Ammo, Slot4)
DECLARE_COMMAND(m_Ammo, Slot5)
DECLARE_COMMAND(m_Ammo, Slot6)
DECLARE_COMMAND(m_Ammo, Slot7)
DECLARE_COMMAND(m_Ammo, Slot8)
DECLARE_COMMAND(m_Ammo, Slot9)
DECLARE_COMMAND(m_Ammo, Slot10)
DECLARE_COMMAND(m_Ammo, Close)
DECLARE_COMMAND(m_Ammo, NextWeapon)
DECLARE_COMMAND(m_Ammo, PrevWeapon)
DECLARE_COMMAND(m_Ammo, Adjust_Crosshair)
DECLARE_COMMAND(m_Ammo, Rebuy)
DECLARE_COMMAND(m_Ammo, Autobuy)

// width of ammo fonts
#define AMMO_SMALL_WIDTH 10
#define AMMO_LARGE_WIDTH 20

#define HISTORY_DRAW_TIME	"5"

int CHudAmmo::Init(void)
{
	gHUD.AddHudElem(this);

	HOOK_MESSAGE(CurWeapon);
	HOOK_MESSAGE(WeaponList);
	HOOK_MESSAGE(AmmoPickup);
	HOOK_MESSAGE(WeapPickup);
	HOOK_MESSAGE(ItemPickup);
	HOOK_MESSAGE(HideWeapon);
	HOOK_MESSAGE(AmmoX);
	HOOK_MESSAGE(Crosshair);
	HOOK_MESSAGE(Brass);

	HOOK_COMMAND("slot1", Slot1);
	HOOK_COMMAND("slot2", Slot2);
	HOOK_COMMAND("slot3", Slot3);
	HOOK_COMMAND("slot4", Slot4);
	HOOK_COMMAND("slot5", Slot5);
	HOOK_COMMAND("slot6", Slot6);
	HOOK_COMMAND("slot7", Slot7);
	HOOK_COMMAND("slot8", Slot8);
	HOOK_COMMAND("slot9", Slot9);
	HOOK_COMMAND("slot10", Slot10);
	HOOK_COMMAND("cancelselect", Close);
	HOOK_COMMAND("invnext", NextWeapon);
	HOOK_COMMAND("invprev", PrevWeapon);
	HOOK_COMMAND("adjust_crosshair", Adjust_Crosshair);
	HOOK_COMMAND("rebuy", Rebuy);
	HOOK_COMMAND("autobuy", Autobuy);

	Reset();

	m_pHud_DrawHistory_Time = CVAR_CREATE( "hud_drawhistory_time", HISTORY_DRAW_TIME, 0 );
	m_pHud_FastSwitch = CVAR_CREATE( "hud_fastswitch", "0", FCVAR_ARCHIVE );		// controls whether or not weapons can be selected in one keypress
	CVAR_CREATE( "cl_observercrosshair", "1", 0 );
	m_pClCrosshairColor = (convar_t*)CVAR_CREATE( "cl_crosshair_color", "50 250 50", FCVAR_ARCHIVE );
	m_pClCrosshairTranslucent = (convar_t*)CVAR_CREATE( "cl_crosshair_translucent", "1", FCVAR_ARCHIVE );
	m_pClCrosshairSize = (convar_t*)CVAR_CREATE( "cl_crosshair_size", "auto", FCVAR_ARCHIVE );
	m_pClDynamicCrosshair = CVAR_CREATE("cl_dynamiccrosshair", "1", FCVAR_ARCHIVE);

	m_iFlags = HUD_DRAW | HUD_THINK; //!!!
	m_R = 50;
	m_G = 250;
	m_B = 50;
	m_iAlpha = 200;

	m_cvarB = m_cvarR = m_cvarG = -1;
	m_iCurrentCrosshair = 0;
	m_bAdditive = true;
	m_iCrosshairScaleBase = -1;
	m_bDrawCrosshair = true;

	gWR.Init();
	gHR.Init();

	return 1;
}

void CHudAmmo::Reset(void)
{
	m_fFade = 0;

	gpActiveSel = NULL;
	gHUD.m_iHideHUDDisplay = 0;

	gWR.Reset();
	gHR.Reset();

	//	VidInit();

}

int CHudAmmo::VidInit(void)
{
	// Load sprites for buckets (top row of weapon menu)
	m_HUD_bucket0 = gHUD.GetSpriteIndex( "bucket1" );
	m_HUD_selection = gHUD.GetSpriteIndex( "selection" );

	ghsprBuckets = gHUD.GetSprite(m_HUD_bucket0);
	giBucketWidth = gHUD.GetSpriteRect(m_HUD_bucket0).right - gHUD.GetSpriteRect(m_HUD_bucket0).left;
	giBucketHeight = gHUD.GetSpriteRect(m_HUD_bucket0).bottom - gHUD.GetSpriteRect(m_HUD_bucket0).top;

	gHR.iHistoryGap = max( gHR.iHistoryGap, gHUD.GetSpriteRect(m_HUD_bucket0).bottom - gHUD.GetSpriteRect(m_HUD_bucket0).top);

	// If we've already loaded weapons, let's get new sprites
	gWR.LoadAllWeaponSprites();

	if (ScreenWidth >= 640)
	{
		giABWidth = 20;
		giABHeight = 4;
	}
	else
	{
		giABWidth = 10;
		giABHeight = 2;
	}

	return 1;
}

//
// Think:
//  Used for selection of weapon menu item.
//
void CHudAmmo::Think(void)
{
	if ( gHUD.m_fPlayerDead )
		return;

	if ( gHUD.m_iWeaponBits != gWR.iOldWeaponBits )
	{
		gWR.iOldWeaponBits = gHUD.m_iWeaponBits;

		for (int i = 0; i < MAX_WEAPONS-1; i++ )
		{
			WEAPON *p = gWR.GetWeapon(i);

			if ( p )
			{
				if ( gHUD.m_iWeaponBits & ( 1 << p->iId ) )
				{
					gWR.PickupWeapon( p );
				}
				else
				{
					gWR.DropWeapon( p );
				}
			}
		}
	}

	if (!gpActiveSel)
		return;

	// has the player selected one?
	if (gHUD.m_iKeyBits & IN_ATTACK)
	{
		if (gpActiveSel != (WEAPON *)1)
		{
			ServerCmd(gpActiveSel->szName);
			g_weaponselect = gpActiveSel->iId;
		}

		gpLastSel = gpActiveSel;
		gpActiveSel = NULL;
		gHUD.m_iKeyBits &= ~IN_ATTACK;

		PlaySound("common/wpn_select.wav", 1);
	}

}

//
// Helper function to return a Ammo pointer from id
//

HSPRITE* WeaponsResource :: GetAmmoPicFromWeapon( int iAmmoId, wrect_t& rect )
{
	for ( int i = 0; i < MAX_WEAPONS; i++ )
	{
		if ( rgWeapons[i].iAmmoType == iAmmoId )
		{
			rect = rgWeapons[i].rcAmmo;
			return &rgWeapons[i].hAmmo;
		}
		else if ( rgWeapons[i].iAmmo2Type == iAmmoId )
		{
			rect = rgWeapons[i].rcAmmo2;
			return &rgWeapons[i].hAmmo2;
		}
	}

	return NULL;
}


// Menu Selection Code

void WeaponsResource :: SelectSlot( int iSlot, int fAdvance, int iDirection )
{
	if ( gHUD.m_Menu.m_fMenuDisplayed && (fAdvance == FALSE) && (iDirection == 1) )	
	{ // menu is overriding slot use commands
		gHUD.m_Menu.SelectMenuItem( iSlot + 1 );  // slots are one off the key numbers
		return;
	}

	if ( iSlot > MAX_WEAPON_SLOTS )
		return;

	if ( gHUD.m_fPlayerDead || gHUD.m_iHideHUDDisplay & ( HIDEHUD_WEAPONS | HIDEHUD_ALL ) )
		return;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return;

	if ( ! ( gHUD.m_iWeaponBits & ~(1<<(WEAPON_SUIT)) ))
		return;

	WEAPON *p = NULL;
	bool fastSwitch = gHUD.m_Ammo.m_pHud_FastSwitch->value != 0.0f;

	if ( (gpActiveSel == NULL) || (gpActiveSel == (WEAPON *)1) || (iSlot != gpActiveSel->iSlot) )
	{
		PlaySound( "common/wpn_hudon.wav", 1 );
		p = GetFirstPos( iSlot );

		if ( p && fastSwitch ) // check for fast weapon switch mode
		{
			// if fast weapon switch is on, then weapons can be selected in a single keypress
			// but only if there is only one item in the bucket
			WEAPON *p2 = GetNextActivePos( p->iSlot, p->iSlotPos );
			if ( !p2 )
			{	// only one active item in bucket, so change directly to weapon
				ServerCmd( p->szName );
				g_weaponselect = p->iId;
				return;
			}
		}
	}
	else
	{
		PlaySound("common/wpn_moveselect.wav", 1);
		if ( gpActiveSel )
			p = GetNextActivePos( gpActiveSel->iSlot, gpActiveSel->iSlotPos );
		if ( !p )
			p = GetFirstPos( iSlot );
	}

	
	if ( !p )  // no selection found
	{
		// just display the weapon list, unless fastswitch is on just ignore it
		if ( !fastSwitch )
			gpActiveSel = (WEAPON *)1;
		else
			gpActiveSel = NULL;
	}
	else 
		gpActiveSel = p;
}

//------------------------------------------------------------------------
// Message Handlers
//------------------------------------------------------------------------

//
// AmmoX  -- Update the count of a known type of ammo
// 
int CHudAmmo::MsgFunc_AmmoX(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	int iIndex = reader.ReadByte();
	int iCount = reader.ReadByte();

	gWR.SetAmmo( iIndex, abs(iCount) );

	return 1;
}

int CHudAmmo::MsgFunc_AmmoPickup( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	int iIndex = reader.ReadByte();
	int iCount = reader.ReadByte();

	// Add ammo to the history
	gHR.AddToHistory( HISTSLOT_AMMO, iIndex, abs(iCount) );

	return 1;
}

int CHudAmmo::MsgFunc_WeapPickup( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	int iIndex = reader.ReadByte();

	// Add the weapon to the history
	gHR.AddToHistory( HISTSLOT_WEAP, iIndex );

	return 1;
}

int CHudAmmo::MsgFunc_ItemPickup( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	const char *szName = reader.ReadString();

	// Add the weapon to the history
	gHR.AddToHistory( HISTSLOT_ITEM, szName );

	return 1;
}


int CHudAmmo::MsgFunc_HideWeapon( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	
	gHUD.m_iHideHUDDisplay = reader.ReadByte();

	if (gEngfuncs.IsSpectateOnly())
		return 1;

	if ( gHUD.m_iHideHUDDisplay & ( HIDEHUD_WEAPONS | HIDEHUD_FLASHLIGHT | HIDEHUD_ALL ) )
	{
		gpActiveSel = NULL;
		SetCrosshair( 0, nullrc, 0, 0, 0 );
	}
	else
	{
		if ( m_pWeapon )
			SetCrosshair( m_pWeapon->hCrosshair, m_pWeapon->rcCrosshair, 255, 255, 255 );
	}

	return 1;
}

// 
//  CurWeapon: Update hud state with the current weapon and clip count. Ammo
//  counts are updated with AmmoX. Server assures that the Weapon ammo type 
//  numbers match a real ammo type.
//
int CHudAmmo::MsgFunc_CurWeapon(const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int iState = reader.ReadByte();
	int iId = reader.ReadChar();
	int iClip = reader.ReadChar();

	if ( iId < 1 )
	{
		SetCrosshair(0, nullrc, 0, 0, 0);
		return 0;
	}

	if ( g_iUser1 != OBS_IN_EYE )
	{
		// Is player dead???
		if ((iId == -1) && (iClip == -1))
		{
			gHUD.m_fPlayerDead = TRUE;
			gpActiveSel = NULL;
			return 1;
		}
		gHUD.m_fPlayerDead = FALSE;
	}

	WEAPON *pWeapon = gWR.GetWeapon( iId );

	if ( !pWeapon )
		return 0;

	if ( iClip < -1 )
		pWeapon->iClip = abs(iClip);
	else
		pWeapon->iClip = iClip;


	if ( iState == 0 )	// we're not the current weapon, so update no more
		return 1;

	m_pWeapon = pWeapon;

	/*if( gHUD.m_iFOV <= 40 )
	{ // zoomed crosshairs
		if (fOnTarget && m_pWeapon->hZoomedAutoaim)
			SetCrosshair(m_pWeapon->hZoomedAutoaim, m_pWeapon->rcZoomedAutoaim, 255, 255, 255);
		else
			SetCrosshair(m_pWeapon->hZoomedCrosshair, m_pWeapon->rcZoomedCrosshair, 255, 255, 255);

	}
	else
	{
		SetCrosshair( 0, nullrc, 0, 0, 0);
	}*/


	m_fFade = 200.0f; //!!!

	return 1;
}

//
// WeaponList -- Tells the hud about a new weapon type.
//
int CHudAmmo::MsgFunc_WeaponList(const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	
	WEAPON Weapon;

	strncpy( Weapon.szName, reader.ReadString(), MAX_WEAPON_NAME );
	Weapon.iAmmoType = (int)reader.ReadChar();
	
	Weapon.iMax1 = reader.ReadByte();
	if (Weapon.iMax1 == 255)
		Weapon.iMax1 = -1;

	Weapon.iAmmo2Type = reader.ReadChar();
	Weapon.iMax2 = reader.ReadByte();
	if (Weapon.iMax2 == 255)
		Weapon.iMax2 = -1;

	Weapon.iSlot = reader.ReadChar();
	Weapon.iSlotPos = reader.ReadChar();
	Weapon.iId = reader.ReadChar();
	Weapon.iFlags = reader.ReadByte();
	Weapon.iClip = 0;

	gWR.AddWeapon( &Weapon );

	return 1;

}

int CHudAmmo::MsgFunc_Crosshair(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	if( reader.ReadByte() > 0)
	{
		m_bDrawCrosshair = true;
	}
	else
	{
		m_bDrawCrosshair = false;
	}
   return 0;
}

int CHudAmmo::MsgFunc_Brass( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	reader.ReadByte(); // unused!

	Vector origin, velocity;
	origin.x = reader.ReadCoord();
	origin.y = reader.ReadCoord();
	origin.z = reader.ReadCoord();
	reader.ReadCoord(); // unused!
	reader.ReadCoord(); // unused!
	reader.ReadCoord(); // unused!
	velocity.x = reader.ReadCoord();
	velocity.y = reader.ReadCoord();
	velocity.z = reader.ReadCoord();

	float Rotation = M_PI * reader.ReadAngle() / 180.0f;
	int ModelIndex = reader.ReadShort();
	int BounceSoundType = reader.ReadByte();
	int Life = reader.ReadByte();
	int Client = reader.ReadByte();

	float sin, cos, x, y;
	sincosf( fabs(Rotation), &sin, &cos );

	if( gHUD.cl_righthand->value != 0.0f && EV_IsLocal( Client ) )
	{
		velocity.x += sin * -120.0;
		velocity.y += cos * 120.0;
		x = 9.0 * sin;
		y = -9.0 * cos;
	}
	else
	{
		x = -9.0 * sin;
		y = 9.0 * cos;
	}

	origin.x += x;
	origin.y += y;
	EV_EjectBrass( origin, velocity, Rotation, ModelIndex, BounceSoundType, Life );
	return 1;
}

//------------------------------------------------------------------------
// Command Handlers
//------------------------------------------------------------------------
// Slot button pressed
void CHudAmmo::SlotInput( int iSlot )
{
	// Let the Viewport use it first, for menus
	//if ( gViewPort && gViewPort->SlotInput( iSlot ) )
		//return;

	gWR.SelectSlot(iSlot, FALSE, 1);
}

void CHudAmmo::UserCmd_Slot1(void)
{
	SlotInput( 0 );
}

void CHudAmmo::UserCmd_Slot2(void)
{
	SlotInput( 1 );
}

void CHudAmmo::UserCmd_Slot3(void)
{
	SlotInput( 2 );
}

void CHudAmmo::UserCmd_Slot4(void)
{
	SlotInput( 3 );
}

void CHudAmmo::UserCmd_Slot5(void)
{
	SlotInput( 4 );
}

void CHudAmmo::UserCmd_Slot6(void)
{
	SlotInput( 5 );
}

void CHudAmmo::UserCmd_Slot7(void)
{
	SlotInput( 6 );
}

void CHudAmmo::UserCmd_Slot8(void)
{
	SlotInput( 7 );
}

void CHudAmmo::UserCmd_Slot9(void)
{
	SlotInput( 8 );
}

void CHudAmmo::UserCmd_Slot10(void)
{
	SlotInput( 9 );
}

void CHudAmmo::UserCmd_Adjust_Crosshair()
{
	int newCrosshair;
	int oldCrosshair = m_iCurrentCrosshair;

	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		newCrosshair = (oldCrosshair + 1) % 5;
	}
	else
	{
		const char *arg = gEngfuncs.Cmd_Argv(1);
		newCrosshair = atoi(arg) % 10;
	}

	m_iCurrentCrosshair = newCrosshair;
	if ( newCrosshair <= 9 )
	{
		switch ( newCrosshair )
		{
		case 0:
		case 5:
			m_R = 50;
			m_G = 250;
			m_B = 50;
			break;
		case 1:
		case 6:
			m_R = 250;
			m_G = 50;
			m_B = 50;
			break;
		case 2:
		case 7:
			m_R = 50;
			m_G = 50;
			m_B = 250;
			break;
		case 3:
		case 8:
			m_R = 250;
			m_G = 250;
			m_B = 50;
			break;
		case 4:
		case 9:
			m_R = 50;
			m_G = 250;
			m_B = 250;
			break;
		}
		m_bAdditive = newCrosshair < 5 ? true: false;
	}
	else
	{
		m_R = 50;
		m_G = 250;
		m_B = 50;
		m_bAdditive = 1;
	}

	char s[16];
	sprintf(s, "%d %d %d", m_R, m_G, m_B);
	gEngfuncs.Cvar_Set("cl_crosshair_color", s);
	gEngfuncs.Cvar_Set("cl_crosshair_translucent", (char*)(m_bAdditive ? "1" : "0"));
}


void CHudAmmo::UserCmd_Close(void)
{
	if (gpActiveSel)
	{
		gpLastSel = gpActiveSel;
		gpActiveSel = NULL;
		PlaySound("common/wpn_hudoff.wav", 1);
	}
	else
		ClientCmd("escape");
}


// Selects the next item in the weapon menu
void CHudAmmo::UserCmd_NextWeapon(void)
{
	if ( gHUD.m_fPlayerDead || (gHUD.m_iHideHUDDisplay & (HIDEHUD_WEAPONS | HIDEHUD_ALL)) )
		return;

	if ( !gpActiveSel || gpActiveSel == (WEAPON*)1 )
		gpActiveSel = m_pWeapon;

	int pos = 0;
	int slot = 0;
	if ( gpActiveSel )
	{
		pos = gpActiveSel->iSlotPos + 1;
		slot = gpActiveSel->iSlot;
	}

	for ( int loop = 0; loop <= 1; loop++ )
	{
		for ( ; slot < MAX_WEAPON_SLOTS; slot++ )
		{
			for ( ; pos < MAX_WEAPON_POSITIONS; pos++ )
			{
				WEAPON *wsp = gWR.GetWeaponSlot( slot, pos );

				if ( wsp /*&& gWR.HasAmmo(wsp)*/ )
				{
					gpActiveSel = wsp;
					return;
				}
			}

			pos = 0;
		}

		slot = 0;  // start looking from the first slot again
	}

	gpActiveSel = NULL;
}

// Selects the previous item in the menu
void CHudAmmo::UserCmd_PrevWeapon(void)
{
	if ( gHUD.m_fPlayerDead || (gHUD.m_iHideHUDDisplay & (HIDEHUD_WEAPONS | HIDEHUD_ALL)) )
		return;

	if ( !gpActiveSel || gpActiveSel == (WEAPON*)1 )
		gpActiveSel = m_pWeapon;

	int pos = MAX_WEAPON_POSITIONS-1;
	int slot = MAX_WEAPON_SLOTS-1;
	if ( gpActiveSel )
	{
		pos = gpActiveSel->iSlotPos - 1;
		slot = gpActiveSel->iSlot;
	}
	
	for ( int loop = 0; loop <= 1; loop++ )
	{
		for ( ; slot >= 0; slot-- )
		{
			for ( ; pos >= 0; pos-- )
			{
				WEAPON *wsp = gWR.GetWeaponSlot( slot, pos );

				if ( wsp /*&& gWR.HasAmmo(wsp)*/ )
				{
					gpActiveSel = wsp;
					return;
				}
			}

			pos = MAX_WEAPON_POSITIONS-1;
		}
		
		slot = MAX_WEAPON_SLOTS-1;
	}

	gpActiveSel = NULL;
}

void CHudAmmo::UserCmd_Autobuy()
{
	char *afile = (char*)gEngfuncs.COM_LoadFile("autobuy.txt", 5, NULL);
	char *pfile = afile;
	char token[256];
	char szCmd[1024];

	if( !pfile )
	{
		ConsolePrint( "Can't open autobuy.txt file.\n" );
		return;
	}

	strncpy(szCmd, "cl_setautobuy", sizeof(szCmd));

	while((pfile = gEngfuncs.COM_ParseFile( pfile, token )))
	{
		// append space first
		strcat(szCmd, " ");
		strcat(szCmd, token);
	}

	ConsolePrint( szCmd );
	gEngfuncs.pfnServerCmd( szCmd );

	gEngfuncs.COM_FreeFile( afile );
}

void CHudAmmo::UserCmd_Rebuy()
{
	char *afile = (char*)gEngfuncs.COM_LoadFile("rebuy.txt", 5, NULL);
	char *pfile = afile;
	char token[64];
	char szCmd[1024];
	int lastCh;

	if( !pfile )
	{
		ConsolePrint( "Can't open rebuy.txt file.\n" );
		return;
	}

	// start with \"
	strncpy(szCmd, "cl_setrebuy \"", sizeof(szCmd));



	while((pfile = gEngfuncs.COM_ParseFile( pfile, token )))
	{
		strcat(szCmd, token);
		// append space after token
		strcat(szCmd, " ");
	}
	// replace last space with ", before terminator
	lastCh = strlen(szCmd);
	szCmd[lastCh - 1] = '\"';

	ConsolePrint(szCmd);
	gEngfuncs.pfnServerCmd(szCmd);

	gEngfuncs.COM_FreeFile( afile );
}


//-------------------------------------------------------------------------
// Drawing code
//-------------------------------------------------------------------------

int CHudAmmo::Draw(float flTime)
{
	int a, x, y, r, g, b;
	int AmmoWidth;
	static bool switchCrosshairType = false;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return 1;

	// place it here, so pretty dynamic crosshair will work even in spectator!
	if( gHUD.m_iFOV > 40 )
	{
		if( switchCrosshairType )
		{
			SetCrosshair( 0, nullrc, 0, 0, 0);
			switchCrosshairType = false;
		}
		// draw a dynamic crosshair
		DrawCrosshair(flTime);
	}
	else
	{
		if( !switchCrosshairType )
		{
			SetCrosshair(m_pWeapon->hZoomedCrosshair, m_pWeapon->rcZoomedCrosshair, 255, 255, 255);
			switchCrosshairType = true;
		}
	}

	if ( (gHUD.m_iHideHUDDisplay & ( HIDEHUD_WEAPONS | HIDEHUD_ALL )) )
		return 1;

	// Draw Weapon Menu
	DrawWList(flTime);

	// Draw ammo pickup history
	gHR.DrawAmmoHistory( flTime );

	if (!m_pWeapon)
		return 0;

	WEAPON *pw = m_pWeapon; // shorthand

	// SPR_Draw Ammo
	if ((pw->iAmmoType < 0) && (pw->iAmmo2Type < 0))
		return 0;

	int iFlags = DHN_DRAWZERO; // draw 0 values

	AmmoWidth = gHUD.GetSpriteRect(gHUD.m_HUD_number_0).right - gHUD.GetSpriteRect(gHUD.m_HUD_number_0).left;

	a = (int) max( MIN_ALPHA, m_fFade );

	if (m_fFade > 0)
		m_fFade -= (gHUD.m_flTimeDelta * 20);

	DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);

	DrawUtils::ScaleColors(r, g, b, a );

	// Does this weapon have a clip?
	y = ScreenHeight - gHUD.m_iFontHeight - gHUD.m_iFontHeight/2;

	// Does weapon have any ammo at all?
	if (m_pWeapon->iAmmoType > 0)
	{
		int iIconWidth = m_pWeapon->rcAmmo.right - m_pWeapon->rcAmmo.left;
		
		if (pw->iClip >= 0)
		{
			// room for the number and the '|' and the current ammo
			
			x = ScreenWidth - (8 * AmmoWidth) - iIconWidth;
			x = DrawUtils::DrawHudNumber(x, y, iFlags | DHN_3DIGITS, pw->iClip, r, g, b);

			int iBarWidth =  AmmoWidth/10;

			x += AmmoWidth/2;

			DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);

			// draw the | bar
			FillRGBA(x, y, iBarWidth, gHUD.m_iFontHeight, r, g, b, a);

			x += iBarWidth + AmmoWidth/2;;

			// GL Seems to need this
			DrawUtils::ScaleColors(r, g, b, a );
			x = DrawUtils::DrawHudNumber(x, y, iFlags | DHN_3DIGITS, gWR.CountAmmo(pw->iAmmoType), r, g, b);


		}
		else
		{
			// SPR_Draw a bullets only line
			x = ScreenWidth - 4 * AmmoWidth - iIconWidth;
			x = DrawUtils::DrawHudNumber(x, y, iFlags | DHN_3DIGITS, gWR.CountAmmo(pw->iAmmoType), r, g, b);
		}

		// Draw the ammo Icon
		int iOffset = (m_pWeapon->rcAmmo.bottom - m_pWeapon->rcAmmo.top)/8;
		SPR_Set(m_pWeapon->hAmmo, r, g, b);
		SPR_DrawAdditive(0, x, y - iOffset, &m_pWeapon->rcAmmo);
	}

	// Does weapon have seconday ammo?
	if (pw->iAmmo2Type > 0) 
	{
		int iIconWidth = m_pWeapon->rcAmmo2.right - m_pWeapon->rcAmmo2.left;

		// Do we have secondary ammo?
		if ((pw->iAmmo2Type != 0) && (gWR.CountAmmo(pw->iAmmo2Type) > 0))
		{
			y -= gHUD.m_iFontHeight + gHUD.m_iFontHeight/4;
			x = ScreenWidth - 4 * AmmoWidth - iIconWidth;
			x = DrawUtils::DrawHudNumber(x, y, iFlags|DHN_3DIGITS, gWR.CountAmmo(pw->iAmmo2Type), r, g, b);

			// Draw the ammo Icon
			SPR_Set(m_pWeapon->hAmmo2, r, g, b);
			int iOffset = (m_pWeapon->rcAmmo2.bottom - m_pWeapon->rcAmmo2.top)/8;
			SPR_DrawAdditive(0, x, y - iOffset, &m_pWeapon->rcAmmo2);
		}
	}

	return 1;
}

#define WEST_XPOS (ScreenWidth / 2 - flCrosshairDistance - iLength + 1)
#define EAST_XPOS (flCrosshairDistance + ScreenWidth / 2)
#define EAST_WEST_YPOS (ScreenHeight / 2)

#define NORTH_YPOS (ScreenHeight / 2 - flCrosshairDistance - iLength + 1)
#define SOUTH_YPOS (ScreenHeight / 2 + flCrosshairDistance)
#define NORTH_SOUTH_XPOS (ScreenWidth / 2)

int Distances[30][2] =
{
{ 8, 3 }, // 0
{ 4, 3 }, // 1
{ 5, 3 }, // 2
{ 8, 3 }, // 3
{ 9, 4 }, // 4
{ 6, 3 }, // 5
{ 9, 3 }, // 6
{ 3, 3 }, // 7
{ 8, 3 }, // 8
{ 4, 3 }, // 9
{ 8, 3 }, // 10
{ 6, 3 }, // 11
{ 5, 3 }, // 12
{ 4, 3 }, // 13
{ 4, 3 }, // 14
{ 8, 3 }, // 15
{ 8, 3 }, // 16
{ 8, 3 }, // 17
{ 6, 3 }, // 18
{ 6, 3 }, // 19
{ 8, 6 }, // 20
{ 4, 3 }, // 21
{ 7, 3 }, // 22
{ 6, 4 }, // 23
{ 8, 3 }, // 24
{ 8, 3 }, // 25
{ 5, 3 }, // 26
{ 4, 4 }, // 27
{ 7, 3 }, // 28
{ 7, 3 }, // 29
};

void CHudAmmo::DrawCrosshair( float flTime )
{
	int flags, iDeltaDistance, iDistance, iLength, weaponid;
	float flCrosshairDistance;

	if( !m_pWeapon )
		return;

	weaponid = m_pWeapon->iId;

	if(    weaponid == WEAPON_AWP 
		|| weaponid == WEAPON_SCOUT 
		|| weaponid == WEAPON_SG550 
		|| weaponid == WEAPON_G3SG1 )
		return;

	if ( g_iWeaponFlags & WPNSTATE_SHIELD_DRAWN )
		return;

	if( weaponid <= 30 )
	{
		iDistance = Distances[weaponid - 1][0];
		iDeltaDistance = Distances[weaponid - 1][1];
	}
	else
	{
		iDistance = 4;
		iDeltaDistance = 3;
	}
	
	flags = GetWeaponAccuracyFlags( weaponid );
	if ( flags && m_pClDynamicCrosshair->value && !(gHUD.m_iHideHUDDisplay & 1) )
	{
		if ( g_iPlayerFlags & FL_ONGROUND || !( flags & ACCURACY_AIR ) )
		{
			if ( ( g_iPlayerFlags & FL_DUCKING ) && ( flags & ACCURACY_DUCK ) )
			{
				iDistance *= 0.5;
			}
			else
			{
				int iWeaponSpeed = 0;

				switch( weaponid )
				{
				case WEAPON_P90: // p90
					iWeaponSpeed = 170;
					break;
				case WEAPON_AUG: // aug
				case WEAPON_GALIL: // galil
				case WEAPON_FAMAS: // famas
				case WEAPON_M249: // m249
				case WEAPON_M4A1: // m4a1
				case WEAPON_SG552: // sg552
				case WEAPON_AK47: // ak47
					iWeaponSpeed = 140;
					break;
				}

				if ( (flags & ACCURACY_SPEED) && (g_flPlayerSpeed >= iWeaponSpeed) )
					iDistance *= 1.5;
			}
		}
		else 
		{
			iDistance *= 2;
		}
		if ( flags & ACCURACY_MULTIPLY_BY_14 )
			iDistance *= 1.4;
		if ( flags & ACCURACY_MULTIPLY_BY_14_2 )
			iDistance *= 1.4;
	}

	if ( m_iAmmoLastCheck >= g_iShotsFired )
	{
		m_flCrosshairDistance -= (m_flCrosshairDistance * 0.013 + 0.1 );
		m_iAlpha += 2;
	}
	else
	{
		m_flCrosshairDistance = min( m_flCrosshairDistance + iDeltaDistance, 15.0f );
		m_iAlpha = max( m_iAlpha - 40, 120 );
	}

	if ( g_iShotsFired > 600 )
		g_iShotsFired = 1;

	CalcCrosshairColor();
	CalcCrosshairDrawMode();
	CalcCrosshairSize();

	m_iAmmoLastCheck = g_iShotsFired;
	m_flCrosshairDistance = max( m_flCrosshairDistance, iDistance );
	iLength = (m_flCrosshairDistance - iDistance) * 0.5 + 5;
	
	if ( m_iAlpha > 255 )
		m_iAlpha = 255;
	
	if ( ScreenWidth != m_iCrosshairScaleBase )
	{
		flCrosshairDistance = ScreenWidth * m_flCrosshairDistance / m_iCrosshairScaleBase;
		iLength = ScreenWidth * iLength / m_iCrosshairScaleBase;
	}
	else
	{
		flCrosshairDistance = m_flCrosshairDistance;
	}


	// drawing
	if ( gHUD.m_NVG.m_iFlags )
	{
		FillRGBABlend(WEST_XPOS, EAST_WEST_YPOS,	iLength, 1, 250, 50, 50, m_iAlpha);
		FillRGBABlend(EAST_XPOS, EAST_WEST_YPOS,	iLength, 1, 250, 50, 50, m_iAlpha);
		FillRGBABlend(NORTH_SOUTH_XPOS, NORTH_YPOS, 1, iLength, 250, 50, 50, m_iAlpha);
		FillRGBABlend(NORTH_SOUTH_XPOS, SOUTH_YPOS, 1, iLength, 250, 50, 50, m_iAlpha);
	}
	else if ( m_bAdditive )
	{
		FillRGBA(WEST_XPOS, EAST_WEST_YPOS,		iLength, 1, m_R, m_G, m_B, m_iAlpha);
		FillRGBA(EAST_XPOS, EAST_WEST_YPOS,		iLength, 1, m_R, m_G, m_B, m_iAlpha);
		FillRGBA(NORTH_SOUTH_XPOS,	NORTH_YPOS,	1, iLength, m_R, m_G, m_B, m_iAlpha);
		FillRGBA(NORTH_SOUTH_XPOS, SOUTH_YPOS,	1, iLength, m_R, m_G, m_B, m_iAlpha);
	}
	else
	{
		FillRGBABlend(WEST_XPOS, EAST_WEST_YPOS,	iLength, 1, m_R, m_G, m_B, m_iAlpha);
		FillRGBABlend(EAST_XPOS, EAST_WEST_YPOS,	iLength, 1, m_R, m_G, m_B, m_iAlpha);
		FillRGBABlend(NORTH_SOUTH_XPOS, NORTH_YPOS, 1, iLength, m_R, m_G, m_B, m_iAlpha);
		FillRGBABlend(NORTH_SOUTH_XPOS, SOUTH_YPOS, 1, iLength, m_R, m_G, m_B, m_iAlpha);
	}
	return;
}

void CHudAmmo::CalcCrosshairSize()
{
	static char prevSize[64] = { 0 };
	const char *size = m_pClCrosshairSize->string;

	if( !strncmp( prevSize, size, sizeof(prevSize) ) )
		return;
	
	strncpy( prevSize, size, sizeof(prevSize) );
	
	if( !stricmp(size, "auto") )
	{
		if( ScreenWidth <= 640 )
		{
			m_iCrosshairScaleBase = 1024;
		}
		else if( ScreenWidth <= 1024 )
		{
			m_iCrosshairScaleBase = 800;
		}
		else
		{
			m_iCrosshairScaleBase = 640;
		}
	}
	else if( !stricmp( size, "small" ))
	{
		m_iCrosshairScaleBase = 1024;
	}
	else if( !stricmp( size, "medium" ))
	{
		m_iCrosshairScaleBase = 800;
	}
	else if( !stricmp( size, "large" ))
	{
		m_iCrosshairScaleBase = 640;
	}
	return;
}

void CHudAmmo::CalcCrosshairDrawMode()
{
	static float prevDrawMode = -1;
	float drawMode = m_pClCrosshairTranslucent->value;
	
	if( drawMode == prevDrawMode )
		return;
	
	if ( drawMode == 0.0f )
	{
		m_bAdditive = 0;
	}
	else if ( drawMode == 1.0f )
	{
		m_bAdditive = 1;
	}
	else
	{
		gEngfuncs.Con_Printf("usage: cl_crosshair_translucent <1|0>\n");
		gEngfuncs.Cvar_Set("cl_crosshair_translucent", (char*)"1");
	}
	
	prevDrawMode = drawMode;
}

void CHudAmmo::CalcCrosshairColor()
{
	static char prevColors[64] = { 0 };
	const char *colors = m_pClCrosshairColor->string;

	if( strncmp( prevColors, colors, 64 ) )
	{
		strncpy( prevColors, colors, 64 );
	
		sscanf( colors, "%d %d %d", &m_cvarR, &m_cvarG, &m_cvarB);

		m_R = m_cvarR = bound( 0, m_cvarR, 255 );
		m_G = m_cvarG = bound( 0, m_cvarG, 255 );
		m_B = m_cvarB = bound( 0, m_cvarB, 255 );
	}
}

//
// Draws the ammo bar on the hud
//
int DrawBar(int x, int y, int width, int height, float f)
{
	int r, g, b;

	f = bound( 0, f, 1 );
	
	if (f)
	{
		int w = f * width;

		// Always show at least one pixel if we have ammo.
		if (w <= 0)
			w = 1;
		DrawUtils::UnpackRGB(r, g, b, RGB_GREENISH);
		FillRGBA(x, y, w, height, r, g, b, 255);
		x += w;
		width -= w;
	}

	DrawUtils::UnpackRGB(r, g, b, RGB_YELLOWISH);

	FillRGBA(x, y, width, height, r, g, b, 128);

	return (x + width);
}



void DrawAmmoBar(WEAPON *p, int x, int y, int width, int height)
{
	if ( !p )
		return;
	
	if (p->iAmmoType != -1)
	{
		if (!gWR.CountAmmo(p->iAmmoType))
			return;

		float f = (float)gWR.CountAmmo(p->iAmmoType)/(float)p->iMax1;
		
		x = DrawBar(x, y, width, height, f);


		// Do we have secondary ammo too?

		if (p->iAmmo2Type != -1)
		{
			f = (float)gWR.CountAmmo(p->iAmmo2Type)/(float)p->iMax2;

			x += 5; //!!!

			DrawBar(x, y, width, height, f);
		}
	}
}




//
// Draw Weapon Menu
//
int CHudAmmo::DrawWList(float flTime)
{
	int r,g,b,x,y,a,i;

	if ( !gpActiveSel )
		return 0;

	int iActiveSlot;

	if ( gpActiveSel == (WEAPON *)1 )
		iActiveSlot = -1;	// current slot has no weapons
	else 
		iActiveSlot = gpActiveSel->iSlot;

	x = gHUD.m_Radar.m_hRadar.rect.right + 10; //!!!
	y = 10; //!!!
	

	// Ensure that there are available choices in the active slot
	if ( iActiveSlot > 0 )
	{
		if ( !gWR.GetFirstPos( iActiveSlot ) )
		{
			gpActiveSel = (WEAPON *)1;
			iActiveSlot = -1;
		}
	}
		
	// Draw top line
	for ( i = 0; i < MAX_WEAPON_SLOTS; i++ )
	{
		int iWidth;

		DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);
	
		if ( iActiveSlot == i )
			a = 255;
		else
			a = 192;

		DrawUtils::ScaleColors(r, g, b, 255);
		SPR_Set(gHUD.GetSprite(m_HUD_bucket0 + i), r, g, b );

		// make active slot wide enough to accommodate gun pictures
		if ( i == iActiveSlot )
		{
			WEAPON *p = gWR.GetFirstPos(iActiveSlot);
			if ( p )
				iWidth = p->rcActive.right - p->rcActive.left;
			else
				iWidth = giBucketWidth;
		}
		else
			iWidth = giBucketWidth;

		SPR_DrawAdditive(0, x, y, &gHUD.GetSpriteRect(m_HUD_bucket0 + i));
		
		x += iWidth + 5;
	}


	a = 128; //!!!
	x = gHUD.m_Radar.m_hRadar.rect.right + 10; //!!!;

	// Draw all of the buckets
	for (i = 0; i < MAX_WEAPON_SLOTS; i++)
	{
		y = giBucketHeight + 10;

		// If this is the active slot, draw the bigger pictures,
		// otherwise just draw boxes
		if ( i == iActiveSlot )
		{
			WEAPON *p = gWR.GetFirstPos( i );
			int iWidth = giBucketWidth;
			if ( p )
				iWidth = p->rcActive.right - p->rcActive.left;

			for ( int iPos = 0; iPos < MAX_WEAPON_POSITIONS; iPos++ )
			{
				p = gWR.GetWeaponSlot( i, iPos );

				if ( !p || !p->iId )
					continue;

			
				// if active, then we must have ammo.
				if ( gWR.HasAmmo(p) )
				{
					DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH );
					DrawUtils::ScaleColors(r, g, b, 192);
				}
				else
				{
					DrawUtils::UnpackRGB(r,g,b, RGB_REDISH);
					DrawUtils::ScaleColors(r, g, b, 128);
				}


				if ( gpActiveSel == p )
				{
					SPR_Set(p->hActive, r, g, b );
					SPR_DrawAdditive(0, x, y, &p->rcActive);

					SPR_Set(gHUD.GetSprite(m_HUD_selection), r, g, b );
					SPR_DrawAdditive(0, x, y, &gHUD.GetSpriteRect(m_HUD_selection));
				}
				else
				{
					// Draw Weapon if Red if no ammo
					SPR_Set( p->hInactive, r, g, b );
					SPR_DrawAdditive( 0, x, y, &p->rcInactive );
				}

				// Draw Ammo Bar

				DrawAmmoBar(p, x + giABWidth/2, y, giABWidth, giABHeight);
				
				y += p->rcActive.bottom - p->rcActive.top + 5;
			}

			x += iWidth + 5;

		}
		else
		{
			// Draw Row of weapons.

			DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);

			for ( int iPos = 0; iPos < MAX_WEAPON_POSITIONS; iPos++ )
			{
				WEAPON *p = gWR.GetWeaponSlot( i, iPos );
				
				if ( !p || !p->iId )
					continue;

				if ( gWR.HasAmmo(p) )
				{
					DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);
					a = 128;
				}
				else
				{
					DrawUtils::UnpackRGB(r,g,b, RGB_REDISH);
					a = 96;
				}

				FillRGBA( x, y, giBucketWidth, giBucketHeight, r, g, b, a );

				y += giBucketHeight + 5;
			}

			x += giBucketWidth + 5;
		}
	}	

	return 1;

}


/*
=================================
	GetSpriteList

Finds and returns the matching 
sprite name 'psz' and resolution 'iRes'
in the given sprite list 'pList'
iCount is the number of items in the pList
=================================
*/
client_sprite_t *GetSpriteList(client_sprite_t *pList, const char *psz, int iRes, int iCount)
{
	if (!pList)
		return NULL;

	int i = iCount;
	client_sprite_t *p = pList;

	while(i--)
	{
		if ((!strcmp(psz, p->szName)) && (p->iRes == iRes))
			return p;
		p++;
	}

	return NULL;
}

```

`cl_dll/hud/ammo_secondary.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// ammo_secondary.cpp
//
// implementation of CHudAmmoSecondary class
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "draw_util.h"

DECLARE_MESSAGE( m_AmmoSecondary, SecAmmoVal )
DECLARE_MESSAGE( m_AmmoSecondary, SecAmmoIcon )

int CHudAmmoSecondary :: Init( void )
{
	HOOK_MESSAGE( SecAmmoVal );
	HOOK_MESSAGE( SecAmmoIcon );

	gHUD.AddHudElem(this);
	m_HUD_ammoicon = 0;

	for ( int i = 0; i < MAX_SEC_AMMO_VALUES; i++ )
		m_iAmmoAmounts[i] = -1;  // -1 means don't draw this value

	Reset();

	return 1;
}

void CHudAmmoSecondary :: Reset( void )
{
	m_fFade = 0;
}

int CHudAmmoSecondary :: VidInit( void )
{
	return 1;
}

int CHudAmmoSecondary :: Draw(float flTime)
{
	if ( (gHUD.m_iHideHUDDisplay & ( HIDEHUD_WEAPONS | HIDEHUD_ALL )) )
		return 1;

	// draw secondary ammo icons above normal ammo readout
	int a, x, y, r, g, b, AmmoWidth;
	DrawUtils::UnpackRGB( r, g, b, RGB_YELLOWISH );
	a = (int) max( MIN_ALPHA, m_fFade );
	if (m_fFade > 0)
		m_fFade -= (gHUD.m_flTimeDelta * 20);  // slowly lower alpha to fade out icons
	DrawUtils::ScaleColors( r, g, b, a );

	AmmoWidth = gHUD.GetSpriteRect(gHUD.m_HUD_number_0).right - gHUD.GetSpriteRect(gHUD.m_HUD_number_0).left;

	y = ScreenHeight - (gHUD.m_iFontHeight*4);  // this is one font height higher than the weapon ammo values
	x = ScreenWidth - AmmoWidth;

	if ( m_HUD_ammoicon )
	{
		// Draw the ammo icon
		x -= (gHUD.GetSpriteRect(m_HUD_ammoicon).right - gHUD.GetSpriteRect(m_HUD_ammoicon).left);
		y -= (gHUD.GetSpriteRect(m_HUD_ammoicon).top - gHUD.GetSpriteRect(m_HUD_ammoicon).bottom);

		SPR_Set( gHUD.GetSprite(m_HUD_ammoicon), r, g, b );
		SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect(m_HUD_ammoicon) );
	}
	else
	{  // move the cursor by the '0' char instead, since we don't have an icon to work with
		x -= AmmoWidth;
		y -= (gHUD.GetSpriteRect(gHUD.m_HUD_number_0).top - gHUD.GetSpriteRect(gHUD.m_HUD_number_0).bottom);
	}

	// draw the ammo counts, in reverse order, from right to left
	for ( int i = MAX_SEC_AMMO_VALUES-1; i >= 0; i-- )
	{
		if ( m_iAmmoAmounts[i] < 0 )
			continue; // negative ammo amounts imply that they shouldn't be drawn

		// half a char gap between the ammo number and the previous pic
		x -= (AmmoWidth / 2);

		// draw the number, right-aligned
		x -= (DrawUtils::GetNumWidth( m_iAmmoAmounts[i], DHN_DRAWZERO ) * AmmoWidth);
		DrawUtils::DrawHudNumber( x, y, DHN_DRAWZERO, m_iAmmoAmounts[i], r, g, b );

		if ( i != 0 )
		{
			// draw the divider bar
			x -= (AmmoWidth / 2);
			FillRGBA(x, y, (AmmoWidth/10), gHUD.m_iFontHeight, r, g, b, a);
		}
	}

	return 1;
}

// Message handler for Secondary Ammo Value
// accepts one value:
//		string:  sprite name
int CHudAmmoSecondary :: MsgFunc_SecAmmoIcon( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	m_HUD_ammoicon = gHUD.GetSpriteIndex( reader.ReadString() );

	return 1;
}

// Message handler for Secondary Ammo Icon
// Sets an ammo value
// takes two values:
//		byte:  ammo index
//		byte:  ammo value
int CHudAmmoSecondary :: MsgFunc_SecAmmoVal( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int index = reader.ReadByte();
	if ( index < 0 || index >= MAX_SEC_AMMO_VALUES )
		return 1;

	m_iAmmoAmounts[index] = reader.ReadByte();
	m_iFlags |= HUD_DRAW;

	// check to see if there is anything left to draw
	int count = 0;
	for ( int i = 0; i < MAX_SEC_AMMO_VALUES; i++ )
	{
		count += max( 0, m_iAmmoAmounts[i] );
	}

	if ( count == 0 ) 
	{	// the ammo fields are all empty, so turn off this hud area
		m_iFlags &= ~HUD_DRAW;
		return 1;
	}

	// make the icons light up
	m_fFade = 200.0f;

	return 1;
}



```

`cl_dll/hud/ammohistory.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  ammohistory.cpp
//


#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>

#include "ammohistory.h"
#include "draw_util.h"

HistoryResource gHR;

#define AMMO_PICKUP_GAP (gHR.iHistoryGap+5)
#define AMMO_PICKUP_PICK_HEIGHT		(gHUD.m_iFontHeight * 3 + (gHR.iHistoryGap * 2))
#define AMMO_PICKUP_HEIGHT_MAX		(ScreenHeight - 100)

#define MAX_ITEM_NAME	32
int HISTORY_DRAW_TIME = 5;

// keep a list of items
struct ITEM_INFO
{
	char szName[MAX_ITEM_NAME];
	HSPRITE spr;
	wrect_t rect;
};

void HistoryResource :: AddToHistory( int iType, int iId, int iCount )
{
	if ( iType == HISTSLOT_AMMO && !iCount )
		return;  // no amount, so don't add

	if ( (((AMMO_PICKUP_GAP * iCurrentHistorySlot) + AMMO_PICKUP_PICK_HEIGHT) > AMMO_PICKUP_HEIGHT_MAX) || (iCurrentHistorySlot >= MAX_HISTORY) )
	{	// the pic would have to be drawn too high
		// so start from the bottom
		iCurrentHistorySlot = 0;
	}
	
	HIST_ITEM *freeslot = &rgAmmoHistory[iCurrentHistorySlot++];  // default to just writing to the first slot
	HISTORY_DRAW_TIME = gHUD.m_Ammo.m_pHud_DrawHistory_Time->value;

	freeslot->type = iType;
	freeslot->iId = iId;
	freeslot->iCount = iCount;
	freeslot->DisplayTime = gHUD.m_flTime + HISTORY_DRAW_TIME;
}

void HistoryResource :: AddToHistory( int iType, const char *szName, int iCount )
{
	if ( iType != HISTSLOT_ITEM )
		return;

	if ( (((AMMO_PICKUP_GAP * iCurrentHistorySlot) + AMMO_PICKUP_PICK_HEIGHT) > AMMO_PICKUP_HEIGHT_MAX) || (iCurrentHistorySlot >= MAX_HISTORY) )
	{	// the pic would have to be drawn too high
		// so start from the bottom
		iCurrentHistorySlot = 0;
	}

	HIST_ITEM *freeslot = &rgAmmoHistory[iCurrentHistorySlot++];  // default to just writing to the first slot

	// I am really unhappy with all the code in this file
	// I am too, -- a1batross

	int i = gHUD.GetSpriteIndex( szName );
	if ( i == -1 )
		return;  // unknown sprite name, don't add it to history

	freeslot->iId = i;
	freeslot->type = iType;
	freeslot->iCount = iCount;

	HISTORY_DRAW_TIME = gHUD.m_Ammo.m_pHud_DrawHistory_Time->value;
	freeslot->DisplayTime = gHUD.m_flTime + HISTORY_DRAW_TIME;
}


void HistoryResource :: CheckClearHistory( void )
{
	for ( int i = 0; i < MAX_HISTORY; i++ )
	{
		if ( rgAmmoHistory[i].type )
			return;
	}

	iCurrentHistorySlot = 0;
}

//
// Draw Ammo pickup history
//
int HistoryResource :: DrawAmmoHistory( float flTime )
{
	for ( int i = 0; i < MAX_HISTORY; i++ )
	{
		if ( rgAmmoHistory[i].type )
		{
			rgAmmoHistory[i].DisplayTime = min( rgAmmoHistory[i].DisplayTime, gHUD.m_flTime + HISTORY_DRAW_TIME );

			if ( rgAmmoHistory[i].DisplayTime <= flTime )
			{  // pic drawing time has expired
				memset( &rgAmmoHistory[i], 0, sizeof(HIST_ITEM) );
				CheckClearHistory();
			}
			else if ( rgAmmoHistory[i].type == HISTSLOT_AMMO )
			{
				wrect_t rcPic;
				HSPRITE *spr = gWR.GetAmmoPicFromWeapon( rgAmmoHistory[i].iId, rcPic );

				int r, g, b;
				DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);
				float scale = (rgAmmoHistory[i].DisplayTime - flTime) * 80;
				DrawUtils::ScaleColors(r, g, b, min(scale, 255) );

				// Draw the pic
				int ypos = ScreenHeight - (AMMO_PICKUP_PICK_HEIGHT + (AMMO_PICKUP_GAP * i));
				int xpos = ScreenWidth - 24;
				if ( spr && *spr )    // weapon isn't loaded yet so just don't draw the pic
				{ // the dll has to make sure it has sent info the weapons you need
					SPR_Set( *spr, r, g, b );
					SPR_DrawAdditive( 0, xpos, ypos, &rcPic );
				}

				// Draw the number
				DrawUtils::DrawHudNumberString( xpos - 10, ypos, xpos - 100, rgAmmoHistory[i].iCount, r, g, b );
			}
			else if ( rgAmmoHistory[i].type == HISTSLOT_WEAP )
			{
				WEAPON *weap = gWR.GetWeapon( rgAmmoHistory[i].iId );

				if ( !weap )
					continue;  // we don't know about the weapon yet, so don't draw anything

				int r, g, b;
				DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);

				if ( !gWR.HasAmmo( weap ) )
					DrawUtils::UnpackRGB(r,g,b, RGB_REDISH);	// if the weapon doesn't have ammo, display it as red

				float scale = (rgAmmoHistory[i].DisplayTime - flTime) * 80;
				DrawUtils::ScaleColors(r, g, b, min(scale, 255) );

				int ypos = ScreenHeight - (AMMO_PICKUP_PICK_HEIGHT + (AMMO_PICKUP_GAP * i));
				int xpos = ScreenWidth - (weap->rcInactive.right - weap->rcInactive.left);
				SPR_Set( weap->hInactive, r, g, b );
				SPR_DrawAdditive( 0, xpos, ypos, &weap->rcInactive );
			}
			else if ( rgAmmoHistory[i].type == HISTSLOT_ITEM )
			{
				int r, g, b;

				if ( !rgAmmoHistory[i].iId )
					continue;  // sprite not loaded

				wrect_t rect = gHUD.GetSpriteRect( rgAmmoHistory[i].iId );

				DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);
				float scale = (rgAmmoHistory[i].DisplayTime - flTime) * 80;
				DrawUtils::ScaleColors(r, g, b, min(scale, 255) );

				int ypos = ScreenHeight - (AMMO_PICKUP_PICK_HEIGHT + (AMMO_PICKUP_GAP * i));
				int xpos = ScreenWidth - (rect.right - rect.left) - 10;

				SPR_Set( gHUD.GetSprite( rgAmmoHistory[i].iId ), r, g, b );
				SPR_DrawAdditive( 0, xpos, ypos, &rect );
			}
		}
	}


	return 1;
}



```

`cl_dll/hud/battery.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// battery.cpp
//
// implementation of CHudBattery class
//

#include "hud.h"
#include "parsemsg.h"
#include "cl_util.h"
#include "draw_util.h"

DECLARE_MESSAGE( m_Battery, Battery )
DECLARE_MESSAGE( m_Battery, ArmorType )

int CHudBattery::Init( void )
{
	m_iBat = 0;
	m_fFade = 0;
	m_iFlags = 0;
	m_enArmorType = Vest;

	HOOK_MESSAGE( Battery );
	HOOK_MESSAGE( ArmorType );
	gHUD.AddHudElem( this );

	return 1;
}

int CHudBattery::VidInit( void )
{
	m_hEmpty[Vest].SetSpriteByName("suit_empty");
	m_hFull[Vest].SetSpriteByName("suit_full");
	m_hEmpty[VestHelm].SetSpriteByName("suithelmet_empty");
	m_hFull[VestHelm].SetSpriteByName("suithelmet_full");

	m_iHeight = m_hFull[Vest].rect.bottom - m_hEmpty[Vest].rect.top;
	m_fFade = 0;

	return 1;
}

void CHudBattery::InitHUDData( void )
{
	m_enArmorType = Vest;
}

int CHudBattery:: MsgFunc_Battery(const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	m_iFlags |= HUD_DRAW;
	int x = reader.ReadShort();

	if( x != m_iBat )
	{
		m_fFade = FADE_TIME;
		m_iBat = x;
	}

	return 1;
}

int CHudBattery::Draw( float flTime )
{
	if( gHUD.m_iHideHUDDisplay & HIDEHUD_HEALTH )
		return 1;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return 1;

	int r, g, b, x, y, a;
	wrect_t rc;

	rc = m_hEmpty[m_enArmorType].rect;

	// battery can go from 0 to 100 so * 0.01 goes from 0 to 1
	rc.top += m_iHeight * ((float)( 100 - ( min( 100, m_iBat ))) * 0.01f );

	DrawUtils::UnpackRGB( r, g, b, RGB_YELLOWISH );

	// Has health changed? Flash the health #
	if( m_fFade )
	{
		if( m_fFade > FADE_TIME )
			m_fFade = FADE_TIME;

		m_fFade -= (gHUD.m_flTimeDelta * 20);

		if( m_fFade <= 0 )
		{
			a = 128;
			m_fFade = 0;
		}

		// Fade the health number back to dim
		a = MIN_ALPHA +  (m_fFade / FADE_TIME) * 128;

	}
	else
	{
		a = MIN_ALPHA;
	}

	DrawUtils::ScaleColors( r, g, b, a );
	
	y = ScreenHeight - gHUD.m_iFontHeight - gHUD.m_iFontHeight / 2;
	x = ScreenWidth / 5;

	// make sure we have the right sprite handles
	SPR_Set( m_hFull[m_enArmorType].spr, r, g, b );
	SPR_DrawAdditive( 0, x, y, &m_hFull[m_enArmorType].rect );

	if( rc.bottom > rc.top )
	{
		SPR_Set( m_hEmpty[m_enArmorType].spr, r, g, b );
		SPR_DrawAdditive( 0, x, y + (rc.top - m_hEmpty[m_enArmorType].rect.top), &rc );
	}

	x += (m_hEmpty[m_enArmorType].rect.right - m_hEmpty[m_enArmorType].rect.left);
	x = DrawUtils::DrawHudNumber( x, y, DHN_3DIGITS|DHN_DRAWZERO, m_iBat, r, g, b );

	return 1;
}

int CHudBattery::MsgFunc_ArmorType(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	m_enArmorType = (armortype_t)reader.ReadByte();

	return 1;
}

```

`cl_dll/hud/death.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// death notice
//
#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>
#include "draw_util.h"

float color[3];

DECLARE_MESSAGE( m_DeathNotice, DeathMsg )

struct DeathNoticeItem {
	char szKiller[MAX_PLAYER_NAME_LENGTH*2];
	char szVictim[MAX_PLAYER_NAME_LENGTH*2];
	int iId;	// the index number of the associated sprite
	bool bSuicide;
	bool bTeamKill;
	bool bNonPlayerKill;
	float flDisplayTime;
	float *KillerColor;
	float *VictimColor;
	int iHeadShotId;
};

#define MAX_DEATHNOTICES	4
static int DEATHNOTICE_DISPLAY_TIME = 6;

#define DEATHNOTICE_TOP		32

DeathNoticeItem rgDeathNoticeList[ MAX_DEATHNOTICES + 1 ];

int CHudDeathNotice :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( DeathMsg );

	hud_deathnotice_time = CVAR_CREATE( "hud_deathnotice_time", "6", 0 );
	m_iFlags = 0;

	return 1;
}


void CHudDeathNotice :: InitHUDData( void )
{
	memset( rgDeathNoticeList, 0, sizeof(rgDeathNoticeList) );
}


int CHudDeathNotice :: VidInit( void )
{
	m_HUD_d_skull = gHUD.GetSpriteIndex( "d_skull" );
	m_HUD_d_headshot = gHUD.GetSpriteIndex("d_headshot");

	return 1;
}

int CHudDeathNotice :: Draw( float flTime )
{
	int x, y, r, g, b, i;

	for( i = 0; i < MAX_DEATHNOTICES; i++ )
	{
		if ( rgDeathNoticeList[i].iId == 0 )
			break;  // we've gone through them all

		if ( rgDeathNoticeList[i].flDisplayTime < flTime )
		{ // display time has expired
			// remove the current item from the list
			memmove( &rgDeathNoticeList[i], &rgDeathNoticeList[i+1], sizeof(DeathNoticeItem) * (MAX_DEATHNOTICES - i) );
			i--;  // continue on the next item;  stop the counter getting incremented
			continue;
		}

		rgDeathNoticeList[i].flDisplayTime = min( rgDeathNoticeList[i].flDisplayTime, flTime + DEATHNOTICE_DISPLAY_TIME );

		// Hide when scoreboard drawing. It will break triapi
		//if ( gViewPort && gViewPort->AllowedToPrintText() )
		//if ( !gHUD.m_iNoConsolePrint )
		{
			// Draw the death notice
			if( !g_iUser1 )
			{
				y = YRES(DEATHNOTICE_TOP) + 2 + (20 * i);  //!!!
			}
			else
			{
				y = ScreenHeight / 5 + 2 + (20 * i);
			}

			int id = (rgDeathNoticeList[i].iId == -1) ? m_HUD_d_skull : rgDeathNoticeList[i].iId;
			x = ScreenWidth - DrawUtils::ConsoleStringLen(rgDeathNoticeList[i].szVictim) - (gHUD.GetSpriteRect(id).right - gHUD.GetSpriteRect(id).left);
			if( rgDeathNoticeList[i].iHeadShotId )
				x -= gHUD.GetSpriteRect(m_HUD_d_headshot).right - gHUD.GetSpriteRect(m_HUD_d_headshot).left;

			if ( !rgDeathNoticeList[i].bSuicide )
			{
				x -= (5 + DrawUtils::ConsoleStringLen( rgDeathNoticeList[i].szKiller ) );

				// Draw killers name
				if ( rgDeathNoticeList[i].KillerColor )
					DrawUtils::SetConsoleTextColor( rgDeathNoticeList[i].KillerColor[0], rgDeathNoticeList[i].KillerColor[1], rgDeathNoticeList[i].KillerColor[2] );
				x = 5 + DrawUtils::DrawConsoleString( x, y, rgDeathNoticeList[i].szKiller );
			}

			r = 255;  g = 80;	b = 0;
			if ( rgDeathNoticeList[i].bTeamKill )
			{
				r = 10;	g = 240; b = 10;  // display it in sickly green
			}

			// Draw death weapon
			SPR_Set( gHUD.GetSprite(id), r, g, b );
			SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect(id) );

			x += (gHUD.GetSpriteRect(id).right - gHUD.GetSpriteRect(id).left);

			if( rgDeathNoticeList[i].iHeadShotId)
			{
				SPR_Set( gHUD.GetSprite(m_HUD_d_headshot), r, g, b );
				SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect(m_HUD_d_headshot));
				x += (gHUD.GetSpriteRect(m_HUD_d_headshot).right - gHUD.GetSpriteRect(m_HUD_d_headshot).left);
			}

			// Draw victims name (if it was a player that was killed)
			if (!rgDeathNoticeList[i].bNonPlayerKill)
			{
				if ( rgDeathNoticeList[i].VictimColor )
					DrawUtils::SetConsoleTextColor( rgDeathNoticeList[i].VictimColor[0], rgDeathNoticeList[i].VictimColor[1], rgDeathNoticeList[i].VictimColor[2] );
				x = DrawUtils::DrawConsoleString( x, y, rgDeathNoticeList[i].szVictim );
			}
		}
	}

	if( i == 0 )
		m_iFlags &= ~HUD_DRAW; // disable hud item

	return 1;
}

// This message handler may be better off elsewhere
int CHudDeathNotice :: MsgFunc_DeathMsg( const char *pszName, int iSize, void *pbuf )
{
	m_iFlags |= HUD_DRAW;

	BufferReader reader( pszName, pbuf, iSize );

	int killer = reader.ReadByte();
	int victim = reader.ReadByte();
	int headshot = reader.ReadByte();

	char killedwith[32];
	strncpy( killedwith, "d_", sizeof(killedwith) );
	strcat( killedwith, reader.ReadString() );

	//if (gViewPort)
	//	gViewPort->DeathMsg( killer, victim );
	gHUD.m_Scoreboard.DeathMsg( killer, victim );

	gHUD.m_Spectator.DeathMessage(victim);
	int i;
	for ( i = 0; i < MAX_DEATHNOTICES; i++ )
	{
		if ( rgDeathNoticeList[i].iId == 0 )
			break;
	}
	if ( i == MAX_DEATHNOTICES )
	{ // move the rest of the list forward to make room for this item
		memmove( rgDeathNoticeList, rgDeathNoticeList+1, sizeof(DeathNoticeItem) * MAX_DEATHNOTICES );
		i = MAX_DEATHNOTICES - 1;
	}

	//if (gViewPort)
		//gViewPort->GetAllPlayersInfo();
	gHUD.m_Scoreboard.GetAllPlayersInfo();

	// Get the Killer's name
	const char *killer_name = g_PlayerInfoList[ killer ].name;
	if ( !killer_name )
	{
		killer_name = "";
		rgDeathNoticeList[i].szKiller[0] = 0;
	}
	else
	{
		rgDeathNoticeList[i].KillerColor = GetClientColor( killer );
		strncpy( rgDeathNoticeList[i].szKiller, killer_name, MAX_PLAYER_NAME_LENGTH );
		rgDeathNoticeList[i].szKiller[MAX_PLAYER_NAME_LENGTH-1] = 0;
	}

	// Get the Victim's name
	const char *victim_name = NULL;
	// If victim is -1, the killer killed a specific, non-player object (like a sentrygun)
	if ( ((char)victim) != -1 )
		victim_name = g_PlayerInfoList[ victim ].name;
	if ( !victim_name )
	{
		victim_name = "";
		rgDeathNoticeList[i].szVictim[0] = 0;
	}
	else
	{
		rgDeathNoticeList[i].VictimColor = GetClientColor( victim );
		strncpy( rgDeathNoticeList[i].szVictim, victim_name, MAX_PLAYER_NAME_LENGTH );
		rgDeathNoticeList[i].szVictim[MAX_PLAYER_NAME_LENGTH-1] = 0;
	}

	// Is it a non-player object kill?
	if ( ((char)victim) == -1 )
	{
		rgDeathNoticeList[i].bNonPlayerKill = true;

		// Store the object's name in the Victim slot (skip the d_ bit)
		strncpy( rgDeathNoticeList[i].szVictim, killedwith+2, sizeof(killedwith) );
	}
	else
	{
		if ( killer == victim || killer == 0 )
			rgDeathNoticeList[i].bSuicide = true;

		if ( !strncmp( killedwith, "d_teammate", sizeof(killedwith)  ) )
			rgDeathNoticeList[i].bTeamKill = true;
	}

	rgDeathNoticeList[i].iHeadShotId = headshot;

	// Find the sprite in the list
	int spr = gHUD.GetSpriteIndex( killedwith );

	rgDeathNoticeList[i].iId = spr;

	rgDeathNoticeList[i].flDisplayTime = gHUD.m_flTime + hud_deathnotice_time->value;


	if (rgDeathNoticeList[i].bNonPlayerKill)
	{
		ConsolePrint( rgDeathNoticeList[i].szKiller );
		ConsolePrint( " killed a " );
		ConsolePrint( rgDeathNoticeList[i].szVictim );
		ConsolePrint( "\n" );
	}
	else
	{
		// record the death notice in the console
		if ( rgDeathNoticeList[i].bSuicide )
		{
			ConsolePrint( rgDeathNoticeList[i].szVictim );

			if ( !strncmp( killedwith, "d_world", sizeof(killedwith)  ) )
			{
				ConsolePrint( " died" );
			}
			else
			{
				ConsolePrint( " killed self" );
			}
		}
		else if ( rgDeathNoticeList[i].bTeamKill )
		{
			ConsolePrint( rgDeathNoticeList[i].szKiller );
			ConsolePrint( " killed his teammate " );
			ConsolePrint( rgDeathNoticeList[i].szVictim );
		}
		else
		{
			if( headshot )
				ConsolePrint( "*** ");
			ConsolePrint( rgDeathNoticeList[i].szKiller );
			ConsolePrint( " killed " );
			ConsolePrint( rgDeathNoticeList[i].szVictim );
		}

		if ( *killedwith && (*killedwith > 13 ) && strncmp( killedwith, "d_world", sizeof(killedwith) ) && !rgDeathNoticeList[i].bTeamKill )
		{
			if ( headshot )
				ConsolePrint(" with a headshot from ");
			else
				ConsolePrint(" with ");

			ConsolePrint( killedwith+2 ); // skip over the "d_" part
		}

		if( headshot ) ConsolePrint( " ***");
		ConsolePrint( "\n" );
	}

	return 1;
}





```

`cl_dll/hud/flashlight.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// flashlight.cpp
//
// implementation of CHudFlashlight class
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>

#include "draw_util.h"


DECLARE_MESSAGE(m_Flash, FlashBat)
DECLARE_MESSAGE(m_Flash, Flashlight)

#define BAT_NAME "sprites/%d_Flashlight.spr"

int CHudFlashlight::Init(void)
{
	m_fFade = 0;
	m_fOn = 0;

	HOOK_MESSAGE(Flashlight);
	HOOK_MESSAGE(FlashBat);

	m_iFlags |= HUD_DRAW;

	gHUD.AddHudElem(this);

	return 1;
}

void CHudFlashlight::Reset(void)
{
	m_fFade = 0;
	m_fOn = 0;
}

int CHudFlashlight::VidInit(void)
{
	m_hSprite1.SetSpriteByName("flash_empty");
	m_hSprite2.SetSpriteByName("flash_full");
	m_hBeam.SetSpriteByName("flash_beam");
	m_iWidth = m_hSprite1.rect.right - m_hSprite1.rect.left;

	return 1;
}

int CHudFlashlight:: MsgFunc_FlashBat(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	int x = reader.ReadByte();
	m_iBat = x;
	m_flBat = ((float)x)/100.0;

	return 1;
}

int CHudFlashlight:: MsgFunc_Flashlight(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	m_fOn = reader.ReadByte();
	int x = reader.ReadByte();
	m_iBat = x;
	m_flBat = ((float)x)/100.0;

	return 1;
}

int CHudFlashlight::Draw(float flTime)
{
	if ( gHUD.m_iHideHUDDisplay & ( HIDEHUD_FLASHLIGHT | HIDEHUD_ALL ) )
		return 1;

	int r, g, b, x, y, a;
	wrect_t rc;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return 1;

	if (m_fOn)
		a = 225;
	else
		a = MIN_ALPHA;

	if (m_flBat < 0.20)
		DrawUtils::UnpackRGB(r,g,b, RGB_REDISH);
	else
		DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);

	DrawUtils::ScaleColors(r, g, b, a);

	y = (m_hSprite1.rect.bottom - m_hSprite1.rect.top)/2;
	x = ScreenWidth - m_iWidth - m_iWidth/2 ;

	// Draw the flashlight casing
	SPR_Set(m_hSprite1.spr, r, g, b );
	SPR_DrawAdditive( 0,  x, y, &m_hSprite1.rect);

	if ( m_fOn )
	{  // draw the flashlight beam
		x = ScreenWidth - m_iWidth/2;

		SPR_Set( m_hBeam.spr, r, g, b );
		SPR_DrawAdditive( 0, x, y, &m_hBeam.rect );
	}

	// draw the flashlight energy level
	x = ScreenWidth - m_iWidth - m_iWidth/2 ;
	int iOffset = m_iWidth * (1.0 - m_flBat);
	if (iOffset < m_iWidth)
	{
		rc = m_hSprite2.rect;
		rc.left += iOffset;

		SPR_Set(m_hSprite2.spr, r, g, b );
		SPR_DrawAdditive( 0, x + iOffset, y, &rc);
	}


	return 1;
}

```

`cl_dll/hud/geiger.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Geiger.cpp
//
// implementation of CHudAmmo class
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <time.h>
#include <stdio.h>

#include "parsemsg.h"

DECLARE_MESSAGE(m_Geiger, Geiger )

int CHudGeiger::Init(void)
{
	HOOK_MESSAGE( Geiger );

	m_iGeigerRange = 0;
	m_iFlags = 0;

	gHUD.AddHudElem(this);

	srand( (unsigned)time( NULL ) );

	return 1;
}

int CHudGeiger::VidInit(void)
{
	return 1;
}

int CHudGeiger::MsgFunc_Geiger(const char *pszName,  int iSize, void *pbuf)
{

	BufferReader reader( pszName, pbuf, iSize );

	// update geiger data
	m_iGeigerRange = reader.ReadByte() << 2;

	if( m_iGeigerRange < 0 || m_iGeigerRange > 1000 )
		m_iFlags &= ~HUD_DRAW;
	else
		m_iFlags |= HUD_DRAW;

	return 1;
}

int CHudGeiger::Draw (float flTime)
{
	int pct = 0;
	float flvol = 0.0f;
	int i = 0;
	
	if (m_iGeigerRange < 1000 && m_iGeigerRange > 0)
	{
		// peicewise linear is better than continuous formula for this
		if (m_iGeigerRange > 800)
		{
			pct = 0;			//Con_Printf ( "range > 800\n");
		}
		else if (m_iGeigerRange > 600)
		{
			pct = 2;
			flvol = 0.4;		//Con_Printf ( "range > 600\n");
			i = 2;
		}
		else if (m_iGeigerRange > 500)
		{
			pct = 4;
			flvol = 0.5;		//Con_Printf ( "range > 500\n");
			i = 2;
		}
		else if (m_iGeigerRange > 400)
		{
			pct = 8;
			flvol = 0.6;		//Con_Printf ( "range > 400\n");
			i = 3;
		}
		else if (m_iGeigerRange > 300)
		{
			pct = 8;
			flvol = 0.7;		//Con_Printf ( "range > 300\n");
			i = 3;
		}
		else if (m_iGeigerRange > 200)
		{
			pct = 28;
			flvol = 0.78;		//Con_Printf ( "range > 200\n");
			i = 3;
		}
		else if (m_iGeigerRange > 150)
		{
			pct = 40;
			flvol = 0.80;		//Con_Printf ( "range > 150\n");
			i = 3;
		}
		else if (m_iGeigerRange > 100)
		{
			pct = 60;
			flvol = 0.85;		//Con_Printf ( "range > 100\n");
			i = 3;
		}
		else if (m_iGeigerRange > 75)
		{
			pct = 80;
			flvol = 0.9;		//Con_Printf ( "range > 75\n");
			//gflGeigerDelay = cl.time + GEIGERDELAY * 0.75;
			i = 3;
		}
		else if (m_iGeigerRange > 50)
		{
			pct = 90;
			flvol = 0.95;		//Con_Printf ( "range > 50\n");
			i = 2;
		}
		else
		{
			pct = 95;
			flvol = 1.0;		//Con_Printf ( "range < 50\n");
			i = 2;
		}

		flvol = Com_RandomFloat(0.25, 25);

		if( pct && (rand() & 127) < pct )
		{
			//S_StartDynamicSound (-1, 0, rgsfx[rand() % i], r_origin, flvol, 1.0, 0, 100);	
			char sz[256];
			
			int j = rand() & 1;
			if( i > 2 )
				j += rand() & 1;

			sprintf( sz, "player/geiger%d.wav", j + 1 );
			PlaySound( sz, flvol );
			
		}
	}

	return 1;
}

```

`cl_dll/hud/health.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Health.cpp
//
// implementation of CHudHealth class
//

#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include <string.h>
#include "eventscripts.h"

#include "draw_util.h"

DECLARE_MESSAGE(m_Health, Health )
DECLARE_MESSAGE(m_Health, Damage )
DECLARE_MESSAGE(m_Health, ScoreAttrib )
DECLARE_MESSAGE(m_Health, ClCorpse )

#define PAIN_NAME "sprites/%d_pain.spr"
#define DAMAGE_NAME "sprites/%d_dmg.spr"
#define EPSILON 0.4f

int giDmgHeight, giDmgWidth;

float g_LocationColor[3];

int giDmgFlags[NUM_DMG_TYPES] = 
{
	DMG_POISON,
	DMG_ACID,
	DMG_FREEZE|DMG_SLOWFREEZE,
	DMG_DROWN,
	DMG_BURN|DMG_SLOWBURN,
	DMG_NERVEGAS,
	DMG_RADIATION,
	DMG_SHOCK,
	DMG_CALTROP,
	DMG_TRANQ,
	DMG_CONCUSS,
	DMG_HALLUC
};

enum
{
	ATK_FRONT = 0,
	ATK_RIGHT,
	ATK_REAR,
	ATK_LEFT
};

int CHudHealth::Init(void)
{
	HOOK_MESSAGE(Health);
	HOOK_MESSAGE(Damage);
	HOOK_MESSAGE(ScoreAttrib);
	HOOK_MESSAGE(ClCorpse);

	m_iHealth = 100;
	m_fFade = 0;
	m_iFlags = 0;
	m_bitsDamage = 0;
	giDmgHeight = 0;
	giDmgWidth = 0;

	for( int i = 0; i < 4; i++ )
		m_fAttack[i] = 0;

	memset(m_dmg, 0, sizeof(DAMAGE_IMAGE) * NUM_DMG_TYPES);

	CVAR_CREATE("cl_corpsestay", "600", FCVAR_ARCHIVE);
	gHUD.AddHudElem(this);
	return 1;
}

void CHudHealth::Reset( void )
{
	// make sure the pain compass is cleared when the player respawns
	for( int i = 0; i < 4; i++ )
		m_fAttack[i] = 0;


	// force all the flashing damage icons to expire
	m_bitsDamage = 0;
	for ( int i = 0; i < NUM_DMG_TYPES; i++ )
	{
		m_dmg[i].fExpire = 0;
	}
}

int CHudHealth::VidInit(void)
{
	m_hSprite = LoadSprite(PAIN_NAME);

	m_vAttackPos[ATK_FRONT].x = ScreenWidth  / 2 - SPR_Width ( m_hSprite, 0 ) / 2;
	m_vAttackPos[ATK_FRONT].y = ScreenHeight / 2 - SPR_Height( m_hSprite, 0 ) * 3;

	m_vAttackPos[ATK_RIGHT].x = ScreenWidth  / 2 + SPR_Width ( m_hSprite, 1 ) * 2;
	m_vAttackPos[ATK_RIGHT].y = ScreenHeight / 2 - SPR_Height( m_hSprite, 1 ) / 2;

	m_vAttackPos[ATK_REAR ].x = ScreenWidth  / 2 - SPR_Width ( m_hSprite, 2 ) / 2;
	m_vAttackPos[ATK_REAR ].y = ScreenHeight / 2 + SPR_Height( m_hSprite, 2 ) * 2;

	m_vAttackPos[ATK_LEFT ].x = ScreenWidth  / 2 - SPR_Width ( m_hSprite, 3 ) * 3;
	m_vAttackPos[ATK_LEFT ].y = ScreenHeight / 2 - SPR_Height( m_hSprite, 3 ) / 2;


	m_HUD_dmg_bio = gHUD.GetSpriteIndex( "dmg_bio" ) + 1;
	m_HUD_cross = gHUD.GetSpriteIndex( "cross" );

	giDmgHeight = gHUD.GetSpriteRect(m_HUD_dmg_bio).right - gHUD.GetSpriteRect(m_HUD_dmg_bio).left;
	giDmgWidth = gHUD.GetSpriteRect(m_HUD_dmg_bio).bottom - gHUD.GetSpriteRect(m_HUD_dmg_bio).top;

	return 1;
}

int CHudHealth:: MsgFunc_Health(const char *pszName,  int iSize, void *pbuf )
{
	// TODO: update local health data
	BufferReader reader( pszName, pbuf, iSize );
	int x = reader.ReadByte();

	m_iFlags |= HUD_DRAW;

	// Only update the fade if we've changed health
	if (x != m_iHealth)
	{
		m_fFade = FADE_TIME;
		m_iHealth = x;
	}

	return 1;
}


int CHudHealth:: MsgFunc_Damage(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int armor = reader.ReadByte();	// armor
	int damageTaken = reader.ReadByte();	// health
	long bitsDamage = reader.ReadLong(); // damage bits

	vec3_t vecFrom;

	for ( int i = 0 ; i < 3 ; i++)
		vecFrom[i] = reader.ReadCoord();

	UpdateTiles(gHUD.m_flTime, bitsDamage);

	// Actually took damage?
	if ( damageTaken > 0 || armor > 0 )
	{
		CalcDamageDirection(vecFrom);
		if( g_iXash )
		{
			float time = damageTaken * 4.0f + armor * 2.0f;

			if( time > 200.0f ) time = 200.0f;
			gMobileAPI.pfnVibrate( time, 0 );
		}
	}
	return 1;
}

int CHudHealth:: MsgFunc_ScoreAttrib(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int index = reader.ReadByte();
	unsigned char flags = reader.ReadByte();
	g_PlayerExtraInfo[index].dead   = !!(flags & PLAYER_DEAD);
	g_PlayerExtraInfo[index].has_c4 = !!(flags & PLAYER_HAS_C4);
	g_PlayerExtraInfo[index].vip    = !!(flags & PLAYER_VIP);
	return 1;
}
// Returns back a color from the
// Green <-> Yellow <-> Red ramp
void CHudHealth::GetPainColor( int &r, int &g, int &b, int &a )
{
#if 0
	int iHealth = m_iHealth;

	if (iHealth > 25)
		iHealth -= 25;
	else if ( iHealth < 0 )
		iHealth = 0;
	g = iHealth * 255 / 100;
	r = 255 - g;
	b = 0;
#else
	if( m_iHealth <= 15 )
	{
		a = 255; // If health is getting low, make it bright red
	}
	else
	{
		// Has health changed? Flash the health #
		if (m_fFade)
		{
			m_fFade -= (gHUD.m_flTimeDelta * 20);

			if (m_fFade <= 0)
			{
				m_fFade = 0;
				a = MIN_ALPHA;
			}
			else
			{
				// Fade the health number back to dim
				a = MIN_ALPHA +  (m_fFade/FADE_TIME) * 128;
			}
		}
		else
		{
			a = MIN_ALPHA;
		}
	}

	if (m_iHealth > 25)
	{
		DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);
	}
	else
	{
		r = 250;
		g = 0;
		b = 0;
	}
#endif 
}


int CHudHealth::Draw(float flTime)
{
	if( !(gHUD.m_iHideHUDDisplay & HIDEHUD_HEALTH ) && !gEngfuncs.IsSpectateOnly() )
	{
		DrawHealthBar( flTime );
		DrawDamage( flTime );
		DrawPain( flTime );
	}

	return 1;
}

void CHudHealth::DrawHealthBar( float flTime )
{
	int r, g, b;
	int a = 0, x, y;
	int HealthWidth;

	GetPainColor( r, g, b, a );
	DrawUtils::ScaleColors(r, g, b, a );

	// Only draw health if we have the suit.
	if (gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)))
	{
		HealthWidth = gHUD.GetSpriteRect(gHUD.m_HUD_number_0).right - gHUD.GetSpriteRect(gHUD.m_HUD_number_0).left;
		int CrossWidth = gHUD.GetSpriteRect(m_HUD_cross).right - gHUD.GetSpriteRect(m_HUD_cross).left;

		y = ScreenHeight - gHUD.m_iFontHeight - gHUD.m_iFontHeight / 2;
		x = CrossWidth /2;

		SPR_Set(gHUD.GetSprite(m_HUD_cross), r, g, b);
		SPR_DrawAdditive(0, x, y, &gHUD.GetSpriteRect(m_HUD_cross));

		x = CrossWidth + HealthWidth / 2;

		x = DrawUtils::DrawHudNumber(x, y, DHN_3DIGITS | DHN_DRAWZERO, m_iHealth, r, g, b);
	}
}

void CHudHealth::CalcDamageDirection( Vector vecFrom )
{
	Vector	forward, right, up;
	float	side, front, flDistToTarget;

	if( vecFrom.IsNull() )
	{
		for( int i = 0; i < 4; i++ )
			m_fAttack[i] = 0;
		return;
	}

	vecFrom = vecFrom - gHUD.m_vecOrigin;
	flDistToTarget = vecFrom.Length();
	vecFrom = vecFrom.Normalize();
	AngleVectors (gHUD.m_vecAngles, forward, right, up);

	front = DotProduct (vecFrom, right);
	side = DotProduct (vecFrom, forward);

	if (flDistToTarget <= 50)
	{
		for( int i = 0; i < 4; i++ )
			m_fAttack[i] = 1;
	}
	else
	{
		if (side > EPSILON)
			m_fAttack[0] = max(m_fAttack[0], side);
		if (side < -EPSILON)
			m_fAttack[1] = max(m_fAttack[1], 0 - side );
		if (front > EPSILON)
			m_fAttack[2] = max(m_fAttack[2], front);
		if (front < -EPSILON)
			m_fAttack[3] = max(m_fAttack[3], 0 - front );
	}
}

void CHudHealth::DrawPain(float flTime)
{
	if (m_fAttack[0] == 0 &&
		m_fAttack[1] == 0 &&
		m_fAttack[2] == 0 &&
		m_fAttack[3] == 0)
		return;

	float a, fFade = gHUD.m_flTimeDelta * 2;

	for( int i = 0; i < 4; i++ )
	{
		if( m_fAttack[i] > EPSILON )
		{
			/*GetPainColor(r, g, b);
			shade = a * max( m_fAttack[i], 0.5 );
			DrawUtils::ScaleColors(r, g, b, shade);*/

			a = max( m_fAttack[i], 0.5 );

			SPR_Set( m_hSprite, 255 * a, 255 * a, 255 * a);
			SPR_DrawAdditive( i, m_vAttackPos[i].x, m_vAttackPos[i].y, NULL );
			m_fAttack[i] = max( 0, m_fAttack[i] - fFade );
		}
		else
			m_fAttack[i] = 0;
	}
}

void CHudHealth::DrawDamage(float flTime)
{
	int r, g, b, a;

	if (!m_bitsDamage)
		return;

	DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);
	
	a = (int)( fabs(sin(flTime*2)) * 256.0);

	DrawUtils::ScaleColors(r, g, b, a);
	int i;
	// Draw all the items
	for (i = 0; i < NUM_DMG_TYPES; i++)
	{
		if (m_bitsDamage & giDmgFlags[i])
		{
			DAMAGE_IMAGE *pdmg = &m_dmg[i];
			SPR_Set(gHUD.GetSprite(m_HUD_dmg_bio + i), r, g, b );
			SPR_DrawAdditive(0, pdmg->x, pdmg->y, &gHUD.GetSpriteRect(m_HUD_dmg_bio + i));
		}
	}


	// check for bits that should be expired
	for ( i = 0; i < NUM_DMG_TYPES; i++ )
	{
		DAMAGE_IMAGE *pdmg = &m_dmg[i];

		if ( m_bitsDamage & giDmgFlags[i] )
		{
			pdmg->fExpire = min( flTime + DMG_IMAGE_LIFE, pdmg->fExpire );

			if ( pdmg->fExpire <= flTime		// when the time has expired
				 && a < 40 )						// and the flash is at the low point of the cycle
			{
				pdmg->fExpire = 0;

				int y = pdmg->y;
				pdmg->x = pdmg->y = 0;

				// move everyone above down
				for (int j = 0; j < NUM_DMG_TYPES; j++)
				{
					pdmg = &m_dmg[j];
					if ((pdmg->y) && (pdmg->y < y))
						pdmg->y += giDmgHeight;

				}

				m_bitsDamage &= ~giDmgFlags[i];  // clear the bits
			}
		}
	}
}


void CHudHealth::UpdateTiles(float flTime, long bitsDamage)
{	
	DAMAGE_IMAGE *pdmg;

	// Which types are new?
	long bitsOn = ~m_bitsDamage & bitsDamage;
	
	for (int i = 0; i < NUM_DMG_TYPES; i++)
	{
		pdmg = &m_dmg[i];

		// Is this one already on?
		if (m_bitsDamage & giDmgFlags[i])
		{
			pdmg->fExpire = flTime + DMG_IMAGE_LIFE; // extend the duration
			if (!pdmg->fBaseline)
				pdmg->fBaseline = flTime;
		}

		// Are we just turning it on?
		if (bitsOn & giDmgFlags[i])
		{
			// put this one at the bottom
			pdmg->x = giDmgWidth/8;
			pdmg->y = ScreenHeight - giDmgHeight * 2;
			pdmg->fExpire=flTime + DMG_IMAGE_LIFE;
			
			// move everyone else up
			for (int j = 0; j < NUM_DMG_TYPES; j++)
			{
				if (j == i)
					continue;

				pdmg = &m_dmg[j];
				if (pdmg->y)
					pdmg->y -= giDmgHeight;

			}
			pdmg = &m_dmg[i];
		}
	}

	// damage bits are only turned on here;  they are turned off when the draw time has expired (in DrawDamage())
	m_bitsDamage |= bitsDamage;
}


int CHudHealth :: MsgFunc_ClCorpse(const char *pszName, int iSize, void *pbuf)
{
#if 0
	BufferReader reader(pbuf, iSize);

	char szModel[64];

	char *pModel = reader.ReadString();
	Vector origin;
	origin.x = reader.ReadLong() / 128.0f;
	origin.y = reader.ReadLong() / 128.0f;
	origin.z = reader.ReadLong() / 128.0f;
	Vector angles;
	angles.x = reader.ReadCoord();
	angles.y = reader.ReadCoord();
	angles.z = reader.ReadCoord();
	float delay = reader.ReadLong() / 100.0f;
	int sequence = reader.ReadByte();
	int classID = reader.ReadByte();
	int teamID = reader.ReadByte();
	int playerID = reader.ReadByte();

	if( !cl_minmodels->value )
	{
		if( !strstr(pModel, "models/") )
		{
			snprintf(szModel, sizeof(szModel), "models/player/%s/%s.mdl", pModel, pModel );
		}
	}
	else if( teamID == 1 ) // terrorists
	{
		int modelidx = cl_min_t->value;
		if( BIsValidTModelIndex(modelidx) )
			strncpy(szModel, sPlayerModelFiles[modelidx], sizeof(szModel));
		else strncpy(szModel, sPlayerModelFiles[1], sizeof(szModel) ); // set leet.mdl
	}
	else if( teamID == 2 ) // ct
	{
		int modelidx = cl_min_ct->value;

		if( g_PlayerExtraInfo[playerID].vip )
			strncpy( szModel, sPlayerModelFiles[3], sizeof(szModel) ); // vip.mdl
		else if( BIsValidCTModelIndex( modelidx ) )
			strncpy( szModel, sPlayerModelFiles[ modelidx ], sizeof(szModel));
		else strncpy( szModel, sPlayerModelFiles[2], sizeof(szModel) ); // gign.mdl
	}
	else strncpy( szModel, sPlayerModelFiles[0], sizeof(szModel) ); // player.mdl

	CreateCorpse( &origin, &angles, szModel, delay, sequence, classID );
#endif
   return 0;
}

/*
============
CL_IsDead

Returns 1 if health is <= 0
============
*/
bool CL_IsDead()
{
	if( gHUD.m_Health.m_iHealth <= 0 )
		return true;
	return false;
}

```

`cl_dll/hud/hud.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// hud.cpp
//
// implementation of CHud class
//

#include <new>

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include <assert.h>
#include "parsemsg.h"

#include "demo.h"
#include "demo_api.h"
#include "vgui_parser.h"
#include "rain.h"

#include "camera.h"


extern client_sprite_t *GetSpriteList(client_sprite_t *pList, const char *psz, int iRes, int iCount);

wrect_t nullrc = { 0, 0, 0, 0 };
float g_lastFOV = 0.0;
const char *sPlayerModelFiles[12] =
{
	"models/player.mdl",
	"models/player/leet/leet.mdl", // t
	"models/player/gign/gign.mdl", // ct
	"models/player/vip/vip.mdl", //ct
	"models/player/gsg9/gsg9.mdl", // ct
	"models/player/guerilla/guerilla.mdl", // t
	"models/player/arctic/arctic.mdl", // t
	"models/player/sas/sas.mdl", // ct
	"models/player/terror/terror.mdl", // t
	"models/player/urban/urban.mdl", // ct
	"models/player/spetsnaz/spetsnaz.mdl", // ct
	"models/player/militia/militia.mdl" // t
};

#define GHUD_DECLARE_MESSAGE(x) int __MsgFunc_##x(const char *pszName, int iSize, void *pbuf ) { return gHUD.MsgFunc_##x(pszName, iSize, pbuf); }

GHUD_DECLARE_MESSAGE(Logo)
GHUD_DECLARE_MESSAGE(SetFOV)
GHUD_DECLARE_MESSAGE(InitHUD)
GHUD_DECLARE_MESSAGE(Concuss)
GHUD_DECLARE_MESSAGE(ResetHUD)
GHUD_DECLARE_MESSAGE(ViewMode)
GHUD_DECLARE_MESSAGE(GameMode)
GHUD_DECLARE_MESSAGE(ShadowIdx)

void __CmdFunc_InputCommandSpecial()
{
#ifdef _CS16CLIENT_ALLOW_SPECIAL_SCRIPTING
	gEngfuncs.pfnClientCmd("_special");
#endif
}

void __CmdFunc_GunSmoke()
{
	if( gHUD.cl_gunsmoke->value )
		gEngfuncs.Cvar_SetValue( "cl_gunsmoke", 0 );
	else
		gEngfuncs.Cvar_SetValue( "cl_gunsmoke", 1 );
}

#define XASH_GENERATE_BUILDNUM

#if defined(XASH_GENERATE_BUILDNUM)
static const char *date = __DATE__;
static const char *mon[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
static char mond[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
#endif

char *Q_buildnum( void )
{
// do not touch this! Only author of Xash3D can increase buildnumbers!
// Xash3D SDL: HAHAHA! I TOUCHED THIS!
	int m = 0, d = 0, y = 0;
	static int b = 0;
	static char buildnum[16];

	if( b != 0 )
		return buildnum;

	for( m = 0; m < 11; m++ )
	{
		if( !strncasecmp( &date[0], mon[m], 3 ))
			break;
		d += mond[m];
	}

	d += atoi( &date[4] ) - 1;
	y = atoi( &date[7] ) - 1900;
	b = d + (int)((y - 1) * 365.25f );

	if((( y % 4 ) == 0 ) && m > 1 )
	{
		b += 1;
	}
	//b -= 38752; // Feb 13 2007
	b -= 41940; // Oct 29 2015.
	// Happy birthday, cs16client! :)

	snprintf( buildnum, sizeof(buildnum), "%i", b );

	return buildnum;
}

int __MsgFunc_ADStop( const char *name, int size, void *buf ) { return 1; }
int __MsgFunc_ItemStatus( const char *name, int size, void *buf ) { return 1; }
int __MsgFunc_ReqState( const char *name, int size, void *buf ) { return 1; }
int __MsgFunc_ForceCam( const char *name, int size, void *buf ) { return 1; }
int __MsgFunc_Spectator( const char *name, int size, void *buf ) { return 1; }
int __MsgFunc_ServerName( const char *name, int size, void *buf )
{
	BufferReader reader( name, buf, size );
	strncpy( gHUD.m_szServerName, reader.ReadString(), 64 );
	return 1;
}

#ifdef __ANDROID__
bool evdev_open = false;
void __CmdFunc_MouseSucksOpen( void ) { evdev_open = true; }
void __CmdFunc_MouseSucksClose( void ) { evdev_open = false; }
#endif


// This is called every time the DLL is loaded
void CHud :: Init( void )
{
	HOOK_COMMAND( "special", InputCommandSpecial );
	//HOOK_COMMAND( "gunsmoke", GunSmoke );

#ifdef __ANDROID__
	HOOK_COMMAND( "evdev_mouseopen", MouseSucksOpen );
	HOOK_COMMAND( "evdev_mouseclose", MouseSucksClose );
#endif
	
	HOOK_MESSAGE( Logo );
	HOOK_MESSAGE( ResetHUD );
	HOOK_MESSAGE( GameMode );
	HOOK_MESSAGE( InitHUD );
	HOOK_MESSAGE( ViewMode );
	HOOK_MESSAGE( SetFOV );
	HOOK_MESSAGE( Concuss );

	HOOK_MESSAGE( ADStop );
	HOOK_MESSAGE( ItemStatus );
	HOOK_MESSAGE( ReqState );
	HOOK_MESSAGE( ForceCam );
	HOOK_MESSAGE( Spectator ); // ignored due to touch menus
	HOOK_MESSAGE( ServerName );


	HOOK_MESSAGE( ShadowIdx );

	CVAR_CREATE( "_vgui_menus", "1", FCVAR_ARCHIVE | FCVAR_USERINFO );
	CVAR_CREATE( "_cl_autowepswitch", "1", FCVAR_ARCHIVE | FCVAR_USERINFO );
	CVAR_CREATE( "_ah", "0", FCVAR_ARCHIVE | FCVAR_USERINFO );

	hud_textmode = CVAR_CREATE( "hud_textmode", "0", FCVAR_ARCHIVE );
	hud_colored  = CVAR_CREATE( "hud_colored", "0", FCVAR_ARCHIVE );
	cl_righthand = CVAR_CREATE( "hand", "1", FCVAR_ARCHIVE );
	cl_weather   = CVAR_CREATE( "cl_weather", "1", FCVAR_ARCHIVE );
	cl_minmodels = CVAR_CREATE( "cl_minmodels", "0", FCVAR_ARCHIVE );
	cl_min_t     = CVAR_CREATE( "cl_min_t", "1", FCVAR_ARCHIVE );
	cl_min_ct    = CVAR_CREATE( "cl_min_ct", "2", FCVAR_ARCHIVE );
	cl_lw        = gEngfuncs.pfnGetCvarPointer( "cl_lw" );
	cl_predict   = gEngfuncs.pfnGetCvarPointer( "cl_predict" );
#ifdef __ANDROID__
	cl_android_force_defaults  = CVAR_CREATE( "cl_android_force_defaults", "1", FCVAR_ARCHIVE );
#endif
	cl_shadows   = CVAR_CREATE( "cl_shadows", "1", FCVAR_ARCHIVE );
	default_fov  = CVAR_CREATE( "default_fov", "90", 0 );
	m_pCvarDraw  = CVAR_CREATE( "hud_draw", "1", FCVAR_ARCHIVE );
	fastsprites  = CVAR_CREATE( "fastsprites", "0", FCVAR_ARCHIVE );
	cl_gunsmoke  = CVAR_CREATE( "cl_gunsmoke", "0", FCVAR_ARCHIVE );
	cl_weapon_sparks = CVAR_CREATE( "cl_weapon_sparks", "1", FCVAR_ARCHIVE );
	cl_weapon_wallpuff = CVAR_CREATE( "cl_weapon_wallpuff", "1", FCVAR_ARCHIVE );
	zoom_sens_ratio = CVAR_CREATE( "zoom_sensitivity_ratio", "1.2", 0 );
	sv_skipshield = gEngfuncs.pfnGetCvarPointer( "sv_skipshield" );

	CVAR_CREATE( "cscl_ver", Q_buildnum(), 1<<14 | FCVAR_USERINFO ); // init and userinfo

	m_iLogo = 0;
	m_iFOV = 0;

	m_pSpriteList = NULL;

	// Clear any old HUD list
	for( HUDLIST *pList = m_pHudList; pList; pList = m_pHudList )
	{
		m_pHudList = m_pHudList->pNext;
		delete pList;
	}
	m_pHudList = NULL;

	// In case we get messages before the first update -- time will be valid
	m_flTime = 1.0;
	m_iNoConsolePrint = 0;
	m_szServerName[0] = 0;

	Localize_Init();

	// fullscreen overlays
	m_SniperScope.Init();
	m_NVG.Init();
	m_SpectatorGui.Init();

	// Game HUD things
	m_Ammo.Init();
	m_Health.Init();
	m_Radio.Init();
	m_Timer.Init();
	m_Money.Init();
	m_AmmoSecondary.Init();
	m_Train.Init();
	m_Battery.Init();
	m_StatusIcons.Init();
	m_Radar.Init();

	// chat, death notice, status bars and other
	m_SayText.Init();
	m_Spectator.Init();
	m_Geiger.Init();
	m_Flash.Init();
	m_Message.Init();
	m_StatusBar.Init();
	m_DeathNotice.Init();
	m_TextMessage.Init();
	m_MOTD.Init();

	// all things that have own background and must be drawn last
	m_ProgressBar.Init();
	m_Menu.Init();
	m_Scoreboard.Init();

	InitRain();

	//ServersInit();

	gEngfuncs.Cvar_SetValue( "hand", 1 );
	gEngfuncs.Cvar_SetValue( "sv_skipshield", 1.0f );
#ifdef __ANDROID__
	gEngfuncs.Cvar_SetValue( "hud_fastswitch", 1 );
#endif

	MsgFunc_ResetHUD(0, 0, NULL );
}

// CHud destructor
// cleans up memory allocated for m_rg* arrays
CHud :: ~CHud()
{
	delete [] m_rghSprites;
	delete [] m_rgrcRects;
	delete [] m_rgszSpriteNames;

	// Clear any old HUD list
	for( HUDLIST *pList = m_pHudList; pList; pList = m_pHudList )
	{
		m_pHudList = m_pHudList->pNext;
		delete pList;
	}
	m_pHudList = NULL;
}

void CHud :: VidInit( void )
{
	static bool firstinit = true;
	m_scrinfo.iSize = sizeof( m_scrinfo );
	GetScreenInfo( &m_scrinfo );

	m_truescrinfo.iWidth = CVAR_GET_FLOAT("width");
	m_truescrinfo.iHeight = CVAR_GET_FLOAT("height");

	// ----------
	// Load Sprites
	// ---------
	//	m_hsprFont = LoadSprite("sprites/%d_font.spr");
	
	m_hsprLogo = 0;

	// assume cs16-client is launched in landscape mode
	// must be only TrueWidth, but due to bug game may sometime rotate to portait mode
	// calc scale depending on max side
	float maxScale = (float)max( TrueWidth, TrueHeight ) / 640.0f;
	
	// REMOVE LATER
	float currentScale = CVAR_GET_FLOAT("hud_scale");
	float invalidScale = (float)min( TrueWidth, TrueHeight ) / 640.0f;
	// REMOVE LATER
	
	if( currentScale > maxScale ||
		( currentScale == invalidScale &&
		  currentScale != 1.0f &&
		  currentScale != 0.0f &&
		  invalidScale <  1.0f ) )
	{
		gEngfuncs.Cvar_SetValue( "hud_scale", maxScale );
		gEngfuncs.Con_Printf("^3Maximum scale factor reached. Reset: %f\n", maxScale );
		GetScreenInfo( &m_scrinfo );
	}

	m_flScale = CVAR_GET_FLOAT( "hud_scale" );

	// give a real values to other code. It's not anymore an actual CVar value
	if( m_flScale == 0.0f )
		m_flScale = 1.0f;

	m_iRes = 640;

	// Only load this once
	if( !m_pSpriteList )
	{
		// we need to load the hud.txt, and all sprites within
		m_pSpriteList = SPR_GetList("sprites/hud.txt", &m_iSpriteCountAllRes);

		if( m_pSpriteList )
		{
			// count the number of sprites of the appropriate res
			m_iSpriteCount = 0;
			client_sprite_t *p = m_pSpriteList;
			for ( int j = 0; j < m_iSpriteCountAllRes; j++ )
			{
				if ( p->iRes == m_iRes )
					m_iSpriteCount++;
				p++;
			}

			// allocated memory for sprite handle arrays
			m_rghSprites      = new(std::nothrow) HSPRITE[m_iSpriteCount];
			m_rgrcRects       = new(std::nothrow) wrect_t[m_iSpriteCount];
			m_rgszSpriteNames = new(std::nothrow) char[m_iSpriteCount * MAX_SPRITE_NAME_LENGTH];;

			if( !m_rghSprites || !m_rgrcRects || !m_rgszSpriteNames )
			{
				gEngfuncs.pfnConsolePrint("CHud::VidInit(): Cannot allocate memory");
				if( g_iXash )
					gRenderAPI.Host_Error("CHud::VidInit(): Cannot allocate memory");
			}

			p = m_pSpriteList;
			for ( int index = 0, j = 0; j < m_iSpriteCountAllRes; j++ )
			{
				if ( p->iRes == m_iRes )
				{
					char sz[256];
					sprintf(sz, "sprites/%s.spr", p->szSprite);
					m_rghSprites[index] = SPR_Load(sz);
					m_rgrcRects[index] = p->rc;
					strncpy( &m_rgszSpriteNames[index * MAX_SPRITE_NAME_LENGTH], p->szName, MAX_SPRITE_NAME_LENGTH );

					index++;
				}

				p++;
			}
		}
	}
	else
	{
		// we have already have loaded the sprite reference from hud.txt, but
		// we need to make sure all the sprites have been loaded (we've gone through a transition, or loaded a save game)
		client_sprite_t *p = m_pSpriteList;
		int index = 0;
		for ( int j = 0; j < m_iSpriteCountAllRes; j++ )
		{
			if ( p->iRes == m_iRes )
			{
				char sz[256];
				sprintf( sz, "sprites/%s.spr", p->szSprite );
				m_rghSprites[index] = SPR_Load(sz);
				index++;
			}

			p++;
		}
	}

	// assumption: number_1, number_2, etc, are all listed and loaded sequentially
	m_HUD_number_0 = GetSpriteIndex( "number_0" );

	if( m_HUD_number_0 == -1 && g_iXash )
	{
		gRenderAPI.Host_Error( "Failed to get number_0 sprite index. Check your game data!" );
		return;
	}

	m_iFontHeight = GetSpriteRect(m_HUD_number_0).bottom - GetSpriteRect(m_HUD_number_0).top;

	m_hGasPuff = SPR_Load("sprites/gas_puff_01.spr");


	/*m_Ammo.VidInit();
	m_Health.VidInit();
	m_Spectator.VidInit();
	m_Geiger.VidInit();
	m_Train.VidInit();
	m_Battery.VidInit();
	m_Flash.VidInit();
	m_Message.VidInit();
	m_StatusBar.VidInit();
	m_DeathNotice.VidInit();
	m_SayText.VidInit();
	m_Menu.VidInit();
	m_AmmoSecondary.VidInit();
	m_TextMessage.VidInit();
	m_StatusIcons.VidInit();
	m_Scoreboard.VidInit();
	m_MOTD.VidInit();
	m_Timer.VidInit();
	m_Money.VidInit();
	m_ProgressBar.VidInit();
	m_SniperScope.VidInit();
	m_Radar.VidInit();
	m_SpectatorGui.VidInit();*/

	for( HUDLIST *pList = m_pHudList; pList; pList = pList->pNext )
		pList->p->VidInit();

	if( firstinit && gEngfuncs.CheckParm( "-firsttime", NULL ) )
	{
		ConsolePrint( "firstrun\n" );

		ClientCmd( "exec touch_presets/phone_ahsim" );
		gEngfuncs.Cvar_Set( "touch_config_file", "touch_presets/phone_ahsim.cfg" );
	}

	firstinit = false;
}

void CHud::Shutdown( void )
{
	for( HUDLIST *pList = m_pHudList; pList; pList = pList->pNext )
	{
		pList->p->Shutdown();
	}
}

int CHud::MsgFunc_Logo(const char *pszName,  int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	// update Train data
	m_iLogo = reader.ReadByte();

	return 1;
}

/*
============
COM_FileBase
============
*/
// Extracts the base name of a file (no path, no extension, assumes '/' as path separator)
void COM_FileBase ( const char *in, char *out)
{
	int len, start, end;

	len = strlen( in );
	
	// scan backward for '.'
	end = len - 1;
	while ( end && in[end] != '.' && in[end] != '/' && in[end] != '\\' )
		end--;
	
	if ( in[end] != '.' )		// no '.', copy to end
		end = len-1;
	else
		end--;					// Found ',', copy to left of '.'


	// Scan backward for '/'
	start = len-1;
	while ( start >= 0 && in[start] != '/' && in[start] != '\\' )
		start--;

	if ( in[start] != '/' && in[start] != '\\' )
		start = 0;
	else
		start++;

	// Length of new sting
	len = end - start + 1;

	// Copy partial string
	strncpy( out, &in[start], len );
	// Terminate it
	out[len] = 0;
}

/*
=================
HUD_IsGame

=================
*/
int HUD_IsGame( const char *game )
{
	const char *gamedir;
	char gd[ 1024 ];

	gamedir = gEngfuncs.pfnGetGameDirectory();
	if ( gamedir && gamedir[0] )
	{
		COM_FileBase( gamedir, gd );
		if ( !stricmp( gd, game ) )
			return 1;
	}
	return 0;
}

/*
=====================
HUD_GetFOV

Returns last FOV
=====================
*/
float HUD_GetFOV( void )
{
	if ( gEngfuncs.pDemoAPI->IsRecording() )
	{
		// Write it
		unsigned char buf[ sizeof(float) ];

		// Active
		*( float * )&buf = g_lastFOV;

		Demo_WriteBuffer( TYPE_ZOOM, sizeof(float), buf );
	}

	if ( gEngfuncs.pDemoAPI->IsPlayingback() )
	{
		g_lastFOV = g_demozoom;
	}
	return g_lastFOV;
}

int CHud::MsgFunc_SetFOV(const char *pszName,  int iSize, void *pbuf)
{
	//Weapon prediction already takes care of changing the fog. ( g_lastFOV ).
#if 0 // VALVEWHY: original client checks for "tfc" here.
	if ( cl_lw && cl_lw->value )
		return 1;
#endif

	BufferReader reader( pszName, pbuf, iSize );

	int newfov = reader.ReadByte();
	int def_fov = default_fov->value;

	g_lastFOV = newfov;
	m_iFOV = newfov ? newfov : def_fov;

	// the clients fov is actually set in the client data update section of the hud

	if ( m_iFOV == def_fov ) // reset to saved sensitivity
		m_flMouseSensitivity = 0;
	else // set a new sensitivity that is proportional to the change from the FOV default
		m_flMouseSensitivity = sensitivity->value * ((float)newfov / (float)def_fov) * zoom_sens_ratio->value;

	return 1;
}

void CHud::AddHudElem(CHudBase *phudelem)
{
	assert( phudelem );

	HUDLIST *pdl, *ptemp;

	pdl = new(std::nothrow) HUDLIST;
	if( !pdl )
	{
		ConsolePrint( "Cannot allocate memory!\n" );
		return;
	}

	pdl->p = phudelem;
	pdl->pNext = NULL;

	if (!m_pHudList)
	{
		m_pHudList = pdl;
		return;
	}

	// find last
	for( ptemp = m_pHudList; ptemp->pNext; ptemp = ptemp->pNext );

	ptemp->pNext = pdl;
}

```

`cl_dll/hud/hud_msg.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  hud_msg.cpp
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "r_efx.h"
#include "rain.h"
#include "com_model.h"
#include "studio.h"
#include "studio_util.h"
#include "StudioModelRenderer.h"
#include "GameStudioModelRenderer.h"
#include "com_weapons.h"

#include <cstring>

#include "events.h"

#define MAX_CLIENTS 32

extern float g_flRoundTime;

/// USER-DEFINED SERVER MESSAGE HANDLERS

int CHud :: MsgFunc_ResetHUD(const char *pszName, int iSize, void *pbuf )
{
	// clear all hud data
	HUDLIST *pList = m_pHudList;

	while ( pList )
	{
		if ( pList->p )
			pList->p->Reset();
		pList = pList->pNext;
	}

	// reset sensitivity
	m_flMouseSensitivity = 0;

	// reset concussion effect
	m_iConcussionEffect = 0;

	return 1;
}

void CAM_ToFirstPerson(void);

int CHud :: MsgFunc_ViewMode( const char *pszName, int iSize, void *pbuf )
{
	CAM_ToFirstPerson();
	return 1;
}

int CHud :: MsgFunc_InitHUD( const char *pszName, int iSize, void *pbuf )
{
	// prepare all hud data
	HUDLIST *pList = m_pHudList;

	while (pList)
	{
		if ( pList->p )
			pList->p->InitHUDData();
		pList = pList->pNext;
	}

	g_iFreezeTimeOver = 0;

	memset( g_PlayerExtraInfo, 0, sizeof(g_PlayerExtraInfo) );

	ResetRain();

	// reset round time
	g_flRoundTime   = 0.0f;

	// reinitialize models. We assume that server already precached all models.
	g_iRShell       = gEngfuncs.pEventAPI->EV_FindModelIndex( "models/rshell.mdl" );
	g_iPShell       = gEngfuncs.pEventAPI->EV_FindModelIndex( "models/pshell.mdl" );
	g_iShotgunShell = gEngfuncs.pEventAPI->EV_FindModelIndex( "models/shotgunshell.mdl" );
	g_iBlackSmoke   = gEngfuncs.pEventAPI->EV_FindModelIndex( "sprites/black_smoke4.spr" );

	return 1;
}


int CHud :: MsgFunc_GameMode(const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	m_Teamplay = reader.ReadByte();

	return 1;
}

int CHud :: MsgFunc_Concuss( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	m_iConcussionEffect = reader.ReadByte();
	if (m_iConcussionEffect)
		this->m_StatusIcons.EnableIcon("dmg_concuss",255,160,0);
	else
		this->m_StatusIcons.DisableIcon("dmg_concuss");
	return 1;
}

int CHud::MsgFunc_ShadowIdx(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	int idx = reader.ReadByte();
	g_StudioRenderer.StudioSetShadowSprite(idx);
	return 1;
}

```

`cl_dll/hud/hud_redraw.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// hud_redraw.cpp
//
#include <math.h>
#include "hud.h"
#include "cl_util.h"
#include "triangleapi.h"

#include <string.h>
#define MAX_LOGO_FRAMES 56

int grgLogoFrame[MAX_LOGO_FRAMES] = 
{
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 13, 13, 13, 13, 13, 12, 11, 10, 9, 8, 14, 15,
	16, 17, 18, 19, 20, 20, 20, 20, 20, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 
	29, 29, 29, 29, 29, 28, 27, 26, 25, 24, 30, 31 
};


extern int g_iVisibleMouse;

float HUD_GetFOV( void );

// Think
void CHud::Think(void)
{
	int newfov;

	for( HUDLIST *pList = m_pHudList; pList; pList = pList->pNext )
	{
		if( pList->p->m_iFlags & HUD_THINK )
			pList->p->Think();
	}

	newfov = HUD_GetFOV();
	m_iFOV = newfov ? newfov : default_fov->value;

	// the clients fov is actually set in the client data update section of the hud

	// Set a new sensitivity
	if ( m_iFOV == default_fov->value )
	{  
		// reset to saved sensitivity
		m_flMouseSensitivity = 0;
	}
	else
	{  
		// set a new sensitivity that is proportional to the change from the FOV default
		m_flMouseSensitivity = sensitivity->value * ((float)newfov / (float)default_fov->value) * zoom_sens_ratio->value;
	}

	// think about default fov
	if ( m_iFOV == 0 )
	{  // only let players adjust up in fov,  and only if they are not overriden by something else
		m_iFOV = max( default_fov->value, 90 );
	}

}

// Redraw
// step through the local data,  placing the appropriate graphics & text as appropriate
// returns 1 if they've changed, 0 otherwise
int CHud :: Redraw( float flTime, int intermission )
{
	m_fOldTime = m_flTime;	// save time of previous redraw
	m_flTime = flTime;
	m_flTimeDelta = (double)m_flTime - m_fOldTime;
	static int m_flShotTime = 0;

#ifdef __ANDROID__
	if( cl_android_force_defaults && cl_android_force_defaults->value )
	{
		if( cl_lw && !cl_lw->value )
		{
			ConsolePrint( "cl_lw is forced to 1. Set cl_android_force_defaults to 0, if you want to disable this behaviour" );
			gEngfuncs.Cvar_SetValue( "cl_lw", 1.0f );
		}
		if( cl_predict && !cl_predict->value )
		{
			ConsolePrint( "cl_predict is forced to 1. Set cl_android_force_defaults to 0, if you want to disable this behaviour" );
			gEngfuncs.Cvar_SetValue( "cl_predict", 1.0f );
		}
		if( sv_skipshield && !sv_skipshield->value )
		{
			ConsolePrint( "sv_skipshield is forced to 1. Set cl_android_force_defaults to 0, if you want to disable this behaviour" );
			gEngfuncs.Cvar_SetValue( "sv_skipshield", 1.0f );
		}
	}
#endif
	
	// Clock was reset, reset delta
	if ( m_flTimeDelta < 0 )
		m_flTimeDelta = 0;

	if (m_flShotTime && m_flShotTime < flTime)
	{
		gEngfuncs.pfnClientCmd("snapshot\n");
		m_flShotTime = 0;
	}

	m_iIntermission = intermission;

	if ( m_pCvarDraw->value && (intermission || !(m_iHideHUDDisplay & HIDEHUD_ALL) ) )
	{
		for( HUDLIST *pList = m_pHudList; pList; pList = pList->pNext )
		{
			if( pList->p->m_iFlags & HUD_DRAW )
			{
				if( intermission && !(pList->p->m_iFlags & HUD_INTERMISSION) )
					continue; // skip no-intermission during intermission

				pList->p->Draw( flTime );
			}
		}
	}

	// are we in demo mode? do we need to draw the logo in the top corner?
	if (m_iLogo)
	{
		int x, y, i;

		if (m_hsprLogo == 0)
			m_hsprLogo = LoadSprite("sprites/%d_logo.spr");

		SPR_Set(m_hsprLogo, 250, 250, 250 );
		
		x = SPR_Width(m_hsprLogo, 0);
		x = ScreenWidth - x;
		y = SPR_Height(m_hsprLogo, 0)/2;

		// Draw the logo at 20 fps
		int iFrame = (int)(flTime * 20) % MAX_LOGO_FRAMES;
		i = grgLogoFrame[iFrame] - 1;

		SPR_DrawAdditive(i, x, y, NULL);
	}

	return 1;
}

```

`cl_dll/hud/hud_spectator.cpp`:

```cpp
//========= Copyright В© 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include "cl_entity.h"
#include "triangleapi.h"
#include "hltv.h"

#include "pm_shared.h"
#include "pm_defs.h"
#include "pmtrace.h"
#include "parsemsg.h"
#include "entity_types.h"

// these are included for the math functions
#include "com_model.h"
#include "demo_api.h"
#include "event_api.h"
#include "studio_util.h"
#include "screenfade.h"
#include "draw_util.h"

#ifdef MSC_VER
#pragma warning(disable: 4244)
#endif

extern int		iJumpSpectator;
extern float	vJumpOrigin[3];
extern float	vJumpAngles[3];


extern void V_GetInEyePos(int entity, float * origin, float * angles );
extern void V_ResetChaseCam();
extern void V_GetChasePos(int target, float * cl_angles, float * origin, float * angles);
extern float * GetClientColor( int clientIndex );

extern vec3_t v_origin;		// last view origin
extern vec3_t v_angles;		// last view angle
extern vec3_t v_cl_angles;	// last client/mouse angle
extern vec3_t v_sim_org;	// last sim origin

void SpectatorMode(void)
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_mode <Main Mode> [<Inset Mode>]\n" );
		return;
	}

	// SetModes() will decide if command is executed on server or local
	if ( gEngfuncs.Cmd_Argc() == 2 )
		gHUD.m_Spectator.SetModes( atoi( gEngfuncs.Cmd_Argv(1) ), -1 );
	else if ( gEngfuncs.Cmd_Argc() == 3 )
		gHUD.m_Spectator.SetModes( atoi( gEngfuncs.Cmd_Argv(1) ), atoi( gEngfuncs.Cmd_Argv(2) )  );
}

void SpectatorSpray(void)
{
	vec3_t forward;

	if ( !gEngfuncs.IsSpectateOnly() )
		return;

	AngleVectors(v_angles,forward,NULL,NULL);
	VectorScale(forward, 128, forward);
	VectorAdd(forward, v_origin, forward);
	pmtrace_t * trace = gEngfuncs.PM_TraceLine( v_origin, forward, PM_TRACELINE_PHYSENTSONLY, 2, -1 );
	if ( trace->fraction != 1.0 )
	{
		char string[128];
		sprintf(string, "drc_spray %.2f %.2f %.2f %i",
				trace->endpos[0], trace->endpos[1], trace->endpos[2], trace->ent );
		gEngfuncs.pfnServerCmd(string);
	}

}
void SpectatorHelp(void)
{
	char *text = CHudTextMessage::BufferedLocaliseTextString( "#Spec_Help_Text" );

	if ( text )
	{
		CenterPrint( text );
	}
}

void SpectatorMenu( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_menu <0|1>\n" );
		return;
	}
	gEngfuncs.Cvar_Set( "spec_menu_internal", gEngfuncs.Cmd_Argv(1) );
}

void ToggleScores( void )
{

}

void SpecDrawNames( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_draw_names <0|1>\n" );
		return;
	}
	gEngfuncs.Cvar_Set( "spec_draw_names_internal", gEngfuncs.Cmd_Argv(1) );
}

void SpecDrawCone( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_draw_cone <0|1>\n" );
		return;
	}

	gEngfuncs.Cvar_Set( "spec_draw_cone_internal", gEngfuncs.Cmd_Argv(1) );
}

void SpecDrawStatus( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_draw_status <0|1>\n" );
		return;
	}

	gEngfuncs.Cvar_Set( "spec_draw_status_internal", gEngfuncs.Cmd_Argv(1) );
}

void SpecAutoDirector( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_auto_director <0|1>\n" );
		return;
	}

	gEngfuncs.Cvar_Set( "spec_auto_director_internal", gEngfuncs.Cmd_Argv(1) );
}

void SpecPip( void )
{
	if ( gEngfuncs.Cmd_Argc() <= 1 )
	{
		gEngfuncs.Con_Printf( "usage:  spec_pip <0|1>\n" );
		return;
	}

	gEngfuncs.Cvar_Set( "spec_pip_internal", gEngfuncs.Cmd_Argv(1) );
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
int CHudSpectator::Init()
{
	gHUD.AddHudElem(this);

	m_iFlags |= HUD_DRAW | HUD_THINK;
	m_flNextObserverInput = 0.0f;
	m_zoomDelta	= 0.0f;
	m_moveDelta = 0.0f;
	m_chatEnabled = (gHUD.m_SayText.m_HUD_saytext->value!=0);
	iJumpSpectator	= 0;

	memset( &m_OverviewData, 0, sizeof(m_OverviewData));
	memset( &m_OverviewEntities, 0, sizeof(m_OverviewEntities));
	m_lastPrimaryObject = m_lastSecondaryObject = 0;

	gEngfuncs.pfnAddCommand ("spec_mode", SpectatorMode );
	gEngfuncs.pfnAddCommand ("spec_decal", SpectatorSpray );
	gEngfuncs.pfnAddCommand ("spec_help", SpectatorHelp );
	gEngfuncs.pfnAddCommand ("spec_menu", SpectatorMenu );
	gEngfuncs.pfnAddCommand ("togglescores", ToggleScores );
	gEngfuncs.pfnAddCommand ("spec_drawnames", SpecDrawNames );
	gEngfuncs.pfnAddCommand ("spec_drawcone", SpecDrawCone );
	gEngfuncs.pfnAddCommand ("spec_drawstatus", SpecDrawStatus );
	gEngfuncs.pfnAddCommand ("spec_autodirector", SpecAutoDirector );
	gEngfuncs.pfnAddCommand ("spec_pip", SpecPip );

	m_drawnames		= gEngfuncs.pfnRegisterVariable("spec_drawnames_internal","1",0);
	m_specmode      = gEngfuncs.pfnRegisterVariable("spec_mode_internal","1",0);
	m_drawcone		= gEngfuncs.pfnRegisterVariable("spec_drawcone_internal","1",0);
	m_drawstatus	= gEngfuncs.pfnRegisterVariable("spec_drawstatus_internal","1",0);
	m_autoDirector	= gEngfuncs.pfnRegisterVariable("spec_autodirector_internal","1",0);
	m_pip			= gEngfuncs.pfnRegisterVariable("spec_pip_internal","1",0);
	m_lastAutoDirector = 0.0f;
	
	if ( !m_drawnames || !m_drawcone || !m_drawstatus || !m_autoDirector || !m_pip || !m_specmode )
	{
		gEngfuncs.Con_Printf("ERROR! Couldn't register all spectator variables.\n");
		return 0;
	}

	return 1;
}


//-----------------------------------------------------------------------------
// UTIL_StringToVector originally from ..\dlls\util.cpp, slightly changed
//-----------------------------------------------------------------------------

void UTIL_StringToVector( float * pVector, const char *pString )
{
	char *pstr, *pfront, tempString[128];
	int	j;

	strncpy( tempString, pString, sizeof(tempString) );
	pstr = pfront = tempString;
	
	for ( j = 0; j < 3; j++ )
	{
		pVector[j] = atof( pfront );
		
		while ( *pstr && *pstr != ' ' )
			pstr++;
		if (!*pstr)
			break;
		pstr++;
		pfront = pstr;
	}

	if (j < 2)
	{
		for (j = j+1;j < 3; j++)
			pVector[j] = 0;
	}
}

int UTIL_FindEntityInMap( const char * name, float * origin, float * angle)
{
	int				n,found = 0;
	char			keyname[256];
	char			token[1024];

	cl_entity_t *	pEnt = gEngfuncs.GetEntityByIndex( 0 );	// get world model

	if ( !pEnt ) return 0;

	if ( !pEnt->model )	return 0;

	char * data = pEnt->model->entities;

	while (data)
	{
		data = gEngfuncs.COM_ParseFile(data, token);
		
		if ( (token[0] == '}') ||  (token[0]==0) )
			break;

		if (!data)
		{
			gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: EOF without closing brace\n");
			return 0;
		}

		if (token[0] != '{')
		{
			gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: expected {\n");
			return 0;
		}

		// we parse the first { now parse entities properties
		
		while ( 1 )
		{
			// parse key
			data = gEngfuncs.COM_ParseFile(data, token);
			if (token[0] == '}')
				break; // finish parsing this entity

			if (!data)
			{
				gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: EOF without closing brace\n");
				return 0;
			};
			
			strncpy (keyname, token, sizeof(keyname));

			// another hack to fix keynames with trailing spaces
			n = strlen(keyname);
			while (n && keyname[n-1] == ' ')
			{
				keyname[n-1] = 0;
				n--;
			}
			
			// parse value
			data = gEngfuncs.COM_ParseFile(data, token);
			if (!data)
			{
				gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: EOF without closing brace\n");
				return 0;
			};

			if (token[0] == '}')
			{
				gEngfuncs.Con_DPrintf("UTIL_FindEntityInMap: closing brace without data");
				return 0;
			}

			if (!strcmp(keyname,"classname"))
			{
				if (!strcmp(token, name ))
				{
					found = 1;	// thats our entity
				}
			};

			if( !strcmp( keyname, "angle" ) )
			{
				float y = atof( token );
				
				if (y >= 0)
				{
					angle[0] = 0.0f;
					angle[1] = y;
				}
				else if ((int)y == -1)
				{
					angle[0] = -90.0f;
					angle[1] =   0.0f;;
				}
				else
				{
					angle[0] = 90.0f;
					angle[1] =  0.0f;
				}

				angle[2] =  0.0f;
			}

			if( !strcmp( keyname, "angles" ) )
			{
				UTIL_StringToVector(angle, token);
			}
			
			if (!strcmp(keyname,"origin"))
			{
				UTIL_StringToVector(origin, token);

			};

		} // while (1)

		if (found)
			return 1;

	}

	return 0;	// we search all entities, but didn't found the correct

}

//-----------------------------------------------------------------------------
// SetSpectatorStartPosition(): 
// Get valid map position and 'beam' spectator to this position
//-----------------------------------------------------------------------------

void CHudSpectator::SetSpectatorStartPosition()
{
	// search for info_player start
	if ( UTIL_FindEntityInMap( "trigger_camera",  m_cameraOrigin, m_cameraAngles ) )
		iJumpSpectator = 1;

	else if ( UTIL_FindEntityInMap( "info_player_start",  m_cameraOrigin, m_cameraAngles ) )
		iJumpSpectator = 1;

	else if ( UTIL_FindEntityInMap( "info_player_deathmatch",  m_cameraOrigin, m_cameraAngles ) )
		iJumpSpectator = 1;

	else if ( UTIL_FindEntityInMap( "info_player_coop",  m_cameraOrigin, m_cameraAngles ) )
		iJumpSpectator = 1;
	else
	{
      static const Vector &nullvec = Vector (0.0, 0.0, 0.0);
		// jump to 0,0,0 if no better position was found
		VectorCopy(nullvec, m_cameraOrigin);
		VectorCopy(nullvec, m_cameraAngles);
	}
	
	VectorCopy(m_cameraOrigin, vJumpOrigin);
	VectorCopy(m_cameraAngles, vJumpAngles);

	iJumpSpectator = 1;	// jump anyway
}

//-----------------------------------------------------------------------------
// Purpose: Loads new icons
//-----------------------------------------------------------------------------
int CHudSpectator::VidInit()
{
	m_hsprPlayer		= SPR_Load("sprites/iplayer.spr");
	m_hsprPlayerBlue	= SPR_Load("sprites/iplayerblue.spr");
	m_hsprPlayerRed		= SPR_Load("sprites/iplayerred.spr");
	m_hsprPlayerDead	= SPR_Load("sprites/iplayerdead.spr");
	m_hsprPlayerVIP		= SPR_Load("sprites/iplayervip.spr");
	m_hsprPlayerC4		= SPR_Load("sprites/iplayerc4.spr");
	m_hsprUnkownMap		= SPR_Load("sprites/tile.spr");
	m_hsprBeam			= SPR_Load("sprites/laserbeam.spr");
	m_hsprCamera		= SPR_Load("sprites/camera.spr");
	m_hsprBomb			= SPR_Load("sprites/ic4.spr");
	m_hsprBackpack		= SPR_Load("sprites/ibackpack.spr");
	m_hsprHostage		= SPR_Load("sprites/ihostage.spr");
	m_hCrosshair		= SPR_Load("sprites/crosshairs.spr");
	
	return 1;
}

//-----------------------------------------------------------------------------
// Purpose: 
// Input  : flTime - 
//			intermission - 
//-----------------------------------------------------------------------------
int CHudSpectator::Draw(float flTime)
{
	int lx;

	char string[256];
	float * color;

	// draw only in spectator mode
	if ( !g_iUser1  )
		return 0;


	if ( m_lastAutoDirector != m_autoDirector->value )
	{
		m_lastAutoDirector = m_autoDirector->value;
		char cmd[64];
		snprintf(cmd, sizeof(cmd), "spec_set_ad %f", m_autoDirector->value);
		gEngfuncs.pfnClientCmd(cmd);
		if ( m_lastAutoDirector == 0.0 )
		{
			if ( m_lastAutoDirector == 0.0 && g_iUser1 == OBS_CHASE_LOCKED )
			{
				SetModes(OBS_CHASE_FREE, INSET_OFF);
			}
		}
		else if ( g_iUser1 == OBS_CHASE_FREE )
		{
			SetModes(OBS_CHASE_LOCKED, INSET_OFF);
		}
	}

	// if user pressed zoom, aplly changes
	if ( (m_zoomDelta != 0.0f) && (	g_iUser1 == OBS_MAP_FREE ) )
	{
		m_mapZoom += m_zoomDelta;

		if ( m_mapZoom > 3.0f )
			m_mapZoom = 3.0f;

		if ( m_mapZoom < 0.5f )
			m_mapZoom = 0.5f;
	}

	// if user moves in map mode, change map origin
	if ( (m_moveDelta != 0.0f) && (g_iUser1 != OBS_ROAMING) )
	{
		vec3_t	right;
		AngleVectors(v_angles, NULL, right, NULL);
		VectorNormalize(right);
		VectorScale(right, m_moveDelta, right );

		VectorAdd( m_mapOrigin, right, m_mapOrigin )

	}
	
	// Only draw the icon names only if map mode is in Main Mode
	if ( g_iUser1 < OBS_MAP_FREE  )
		return 1;
	
	if ( !m_drawnames->value )
		return 1;
	
	// make sure we have player info
	//gViewPort->GetAllPlayersInfo();
	gHUD.m_Scoreboard.GetAllPlayersInfo();


	// loop through all the players and draw additional infos to their sprites on the map
	for (int i = 0; i < MAX_PLAYERS; i++)
	{

		if ( m_vPlayerPos[i][2]<0 )	// marked as invisible ?
			continue;

		// can player exist without name?
		if( !g_PlayerInfoList[i+1].name )
			continue;
		
		// check if name would be in inset window
		if ( m_pip->value != INSET_OFF )
		{
			if (	m_vPlayerPos[i][0] > XRES( m_OverviewData.insetWindowX ) &&
					m_vPlayerPos[i][1] > YRES( m_OverviewData.insetWindowY ) &&
					m_vPlayerPos[i][0] < XRES( m_OverviewData.insetWindowX + m_OverviewData.insetWindowWidth ) &&
					m_vPlayerPos[i][1] < YRES( m_OverviewData.insetWindowY + m_OverviewData.insetWindowHeight)
					) continue;
		}

		color = GetClientColor( i+1 ); // ???

		// draw the players name and health underneath
		sprintf(string, "%s", g_PlayerInfoList[i+1].name );
		
		lx = strlen(string)*3; // 3 is avg. character length :)

		DrawUtils::SetConsoleTextColor( color[0], color[1], color[2] );
		DrawUtils::DrawConsoleString( m_vPlayerPos[i][0]-lx,m_vPlayerPos[i][1], string);
		
	}


	// Only draw the overview if Map Mode is selected for this view
	if ( m_iDrawCycle == 0 &&  ( (g_iUser1 != OBS_MAP_FREE) && (g_iUser1 != OBS_MAP_CHASE) ) )
		return 1;

	if ( m_iDrawCycle == 1 && m_pip->value < INSET_MAP_FREE )
		return 1;

	return 1;
}


void CHudSpectator::DirectorMessage( int iSize, void *pbuf )
{
	float	value;
	char *	string;

	BufferReader reader( "DRCMsg", pbuf, iSize );

	int cmd = reader.ReadByte();

	switch ( cmd )	// director command byte
	{
	case DRC_CMD_START	:
		// now we have to do some things clientside, since the proxy doesn't know our mod
		g_iTeamNumber = 0;

		// fake a InitHUD & ResetHUD message
		gHUD.MsgFunc_InitHUD(NULL,0, NULL);
		gHUD.MsgFunc_ResetHUD(NULL, 0, NULL);

		break;

	case DRC_CMD_EVENT	:
		m_lastPrimaryObject		=	reader.ReadWord();
		m_lastSecondaryObject	=	reader.ReadWord();
		m_iObserverFlags		=	reader.ReadLong();

		if ( m_autoDirector->value )
		{
			if ( (g_iUser2 != m_lastPrimaryObject) || (g_iUser3 != m_lastSecondaryObject) )
				V_ResetChaseCam();

			g_iUser2 = m_lastPrimaryObject;
			g_iUser3 = m_lastSecondaryObject;
		}

		// gEngfuncs.Con_Printf("Director Camera: %i %i\n", firstObject, secondObject);
		break;

	case DRC_CMD_MODE  :
		if ( m_autoDirector->value )
		{
			SetModes( reader.ReadByte(), -1 );
		}
		break;

	case DRC_CMD_CAMERA	:
		if ( m_autoDirector->value )
		{
			vJumpOrigin[0] = reader.ReadCoord();	// position
			vJumpOrigin[1] = reader.ReadCoord();
			vJumpOrigin[2] = reader.ReadCoord();

			vJumpAngles[0] = reader.ReadCoord();	// view angle
			vJumpAngles[1] = reader.ReadCoord();
			vJumpAngles[2] = reader.ReadCoord();

			gEngfuncs.SetViewAngles( vJumpAngles );

			iJumpSpectator = 1;
		}
		break;

	case DRC_CMD_MESSAGE:
	{
		client_textmessage_t * msg = &m_HUDMessages[m_lastHudMessage];

		msg->effect = reader.ReadByte();		// effect

		DrawUtils::UnpackRGB( (int&)msg->r1, (int&)msg->g1, (int&)msg->b1, reader.ReadLong() );		// color
		msg->r2 = msg->r1;
		msg->g2 = msg->g1;
		msg->b2 = msg->b1;
		msg->a2 = msg->a1 = 0xFF;	// not transparent

		msg->x = reader.ReadFloat();	// x pos
		msg->y = reader.ReadFloat();	// y pos

		msg->fadein		= reader.ReadFloat();	// fadein
		msg->fadeout	= reader.ReadFloat();	// fadeout
		msg->holdtime	= reader.ReadFloat();	// holdtime
		msg->fxtime		= reader.ReadFloat();	// fxtime;

		strncpy( m_HUDMessageText[m_lastHudMessage], reader.ReadString(), 128 );
		m_HUDMessageText[m_lastHudMessage][127]=0;	// text

		msg->pMessage = m_HUDMessageText[m_lastHudMessage];
		msg->pName	  = "HUD_MESSAGE";

		gHUD.m_Message.MessageAdd( msg );

		m_lastHudMessage++;
		m_lastHudMessage %= MAX_SPEC_HUD_MESSAGES;

	}

		break;

	case DRC_CMD_SOUND :
		string = reader.ReadString();
		value =  reader.ReadFloat();

		// gEngfuncs.Con_Printf("DRC_CMD_FX_SOUND: %s %.2f\n", string, value );
		gEngfuncs.pEventAPI->EV_PlaySound(0, v_origin, CHAN_BODY, string, value, ATTN_NORM, 0, PITCH_NORM );

		break;

	case DRC_CMD_TIMESCALE	:
		value = reader.ReadFloat();
		break;



	case DRC_CMD_STATUS:
		reader.ReadLong(); // total number of spectator slots
		m_iSpectatorNumber = reader.ReadLong(); // total number of spectator
		reader.ReadWord(); // total number of relay proxies

		//gViewPort->UpdateSpectatorPanel();
		break;

	case DRC_CMD_BANNER:
		// gEngfuncs.Con_DPrintf("GUI: Banner %s\n",reader.ReadString() ); // name of banner tga eg gfx/temp/7454562234563475.tga
		//gViewPort->m_pSpectatorPanel->m_TopBanner->LoadImage( reader.ReadString() );
		//gViewPort->UpdateSpectatorPanel();
		break;

		/*case DRC_CMD_FADE:
							break;*/

	case DRC_CMD_STUFFTEXT:
		ClientCmd( reader.ReadString() );
		break;

	default			:	gEngfuncs.Con_DPrintf("CHudSpectator::DirectorMessage: unknown command %i.\n", cmd );
	}
}

void CHudSpectator::FindNextPlayer(bool bReverse)
{
	// MOD AUTHORS: Modify the logic of this function if you want to restrict the observer to watching
	//				only a subset of the players. e.g. Make it check the target's team.

	int		iStart;
	cl_entity_t * pEnt = NULL;

	// if we are NOT in HLTV mode, spectator targets are set on server
	if ( !gEngfuncs.IsSpectateOnly() )
	{
		char cmdstring[32];
		// forward command to server
		sprintf(cmdstring,"follownext %i",bReverse?1:0);
		gEngfuncs.pfnServerCmd(cmdstring);
		return;
	}
	
	if ( g_iUser2 )
		iStart = g_iUser2;
	else
		iStart = 1;

	g_iUser2 = 0;

	int	    iCurrent = iStart;

	int iDir = bReverse ? -1 : 1;

	// make sure we have player info
	//gViewPort->GetAllPlayersInfo();
	gHUD.m_Scoreboard.GetAllPlayersInfo();

	do
	{
		iCurrent += iDir;

		// Loop through the clients
		if (iCurrent > MAX_PLAYERS)
			iCurrent = 1;
		if (iCurrent < 1)
			iCurrent = MAX_PLAYERS;

		pEnt = gEngfuncs.GetEntityByIndex( iCurrent );

		if ( !IsActivePlayer( pEnt ) )
			continue;

		// MOD AUTHORS: Add checks on target here.

		g_iUser2 = iCurrent;
		break;

	} while ( iCurrent != iStart );

	// Did we find a target?
	if ( !g_iUser2 )
	{
		gEngfuncs.Con_DPrintf( "No observer targets.\n" );
		// take save camera position
		VectorCopy(m_cameraOrigin, vJumpOrigin);
		VectorCopy(m_cameraAngles, vJumpAngles);
	}
	else
	{
		// use new entity position for roaming
		VectorCopy ( pEnt->origin, vJumpOrigin );
		VectorCopy ( pEnt->angles, vJumpAngles );
	}
	iJumpSpectator = 1;
}

void CHudSpectator::HandleButtonsDown( int ButtonPressed )
{
	double time = gEngfuncs.GetClientTime();

	int newMainMode		= g_iUser1;
	int newInsetMode	= m_pip->value;

	// gEngfuncs.Con_Printf(" HandleButtons:%i\n", ButtonPressed );
	//	if ( !gViewPort )

	//Not in intermission.
	if ( gHUD.m_iIntermission )
		return;

	if ( !g_iUser1 )
		return; // don't do anything if not in spectator mode

	// don't handle buttons during normal demo playback
	if ( gEngfuncs.pDemoAPI->IsPlayingback() && !gEngfuncs.IsSpectateOnly() )
		return;
	// Slow down mouse clicks.
	if ( m_flNextObserverInput > time )
		return;

	// enable spectator screen
	if ( ButtonPressed & IN_DUCK )
	{
		gHUD.m_SpectatorGui.UserCmd_ToggleSpectatorMenu();
	}

	//  'Use' changes inset window mode
	if ( ButtonPressed & IN_USE )
	{
		newInsetMode = ToggleInset(true);
	}

	// if not in HLTV mode, buttons are handled server side
	if ( gEngfuncs.IsSpectateOnly() )
	{
		// changing target or chase mode not in overviewmode without inset window

		// Jump changes main window modes
		if ( ButtonPressed & IN_JUMP )
		{
			if ( g_iUser1 == OBS_CHASE_LOCKED )
				newMainMode = OBS_CHASE_FREE;

			else if ( g_iUser1 == OBS_CHASE_FREE )
				newMainMode = OBS_IN_EYE;

			else if ( g_iUser1 == OBS_IN_EYE )
				newMainMode = OBS_ROAMING;

			else if ( g_iUser1 == OBS_ROAMING )
				newMainMode = OBS_MAP_FREE;

			else if ( g_iUser1 == OBS_MAP_FREE )
				newMainMode = OBS_MAP_CHASE;

			else
				newMainMode = OBS_CHASE_FREE;	// don't use OBS_CHASE_LOCKED anymore
		}

		// Attack moves to the next player
		if ( ButtonPressed & (IN_ATTACK | IN_ATTACK2) )
		{
			FindNextPlayer( (ButtonPressed & IN_ATTACK2) ? true:false );

			if ( g_iUser1 == OBS_ROAMING )
			{
				gEngfuncs.SetViewAngles( vJumpAngles );
				iJumpSpectator = 1;

			}
			// lease directed mode if player want to see another player
			m_autoDirector->value = 0.0f;
		}
	}

	SetModes(newMainMode, newInsetMode);

	if ( g_iUser1 == OBS_MAP_FREE )
	{
		if ( ButtonPressed & IN_FORWARD )
			m_zoomDelta =  0.01f;

		if ( ButtonPressed & IN_BACK )
			m_zoomDelta = -0.01f;
		
		if ( ButtonPressed & IN_MOVELEFT )
			m_moveDelta = -12.0f;

		if ( ButtonPressed & IN_MOVERIGHT )
			m_moveDelta =  12.0f;
	}

	m_flNextObserverInput = time + 0.2;
}

void CHudSpectator::HandleButtonsUp( int ButtonPressed )
{
	//if ( !gViewPort )
	return;

	//	if ( !gViewPort->m_pSpectatorPanel->isVisible() )
	//	return; // don't do anything if not in spectator mode

	if ( ButtonPressed & (IN_FORWARD | IN_BACK) )
		m_zoomDelta = 0.0f;
	
	if ( ButtonPressed & (IN_MOVELEFT | IN_MOVERIGHT) )
		m_moveDelta = 0.0f;
}

void CHudSpectator::SetModes(int iNewMainMode, int iNewInsetMode)
{
	// if value == -1 keep old value
	if ( iNewMainMode == -1 )
		iNewMainMode = g_iUser1;

	if ( iNewInsetMode == -1 )
		iNewInsetMode = m_pip->value;

	// inset mode is handled only clients side
	m_pip->value = iNewInsetMode;
	
	if ( iNewMainMode < OBS_CHASE_LOCKED || iNewMainMode > OBS_MAP_CHASE )
	{
		gEngfuncs.Con_Printf("Invalid spectator mode.\n");
		return;
	}
	
	// main modes ettings will override inset window settings
	if ( iNewMainMode != g_iUser1 )
	{
		// if we are NOT in HLTV mode, main spectator mode is set on server
		if ( !gEngfuncs.IsSpectateOnly() )
		{
			return;
		}

		if ( !g_iUser2 && (iNewMainMode != OBS_ROAMING ) )	// make sure we have a target
		{
			// choose last Director object if still available
			if ( IsActivePlayer( gEngfuncs.GetEntityByIndex( m_lastPrimaryObject ) ) )
			{
				g_iUser2 = m_lastPrimaryObject;
				g_iUser3 = m_lastSecondaryObject;
			}
			else
				FindNextPlayer(false); // find any target
		}

		switch ( iNewMainMode )
		{
		case OBS_CHASE_LOCKED:	g_iUser1 = OBS_CHASE_LOCKED;
			break;

		case OBS_CHASE_FREE :	g_iUser1 = OBS_CHASE_FREE;
			break;

		case OBS_ROAMING	:	// jump to current vJumpOrigin/angle
			g_iUser1 = OBS_ROAMING;
			if ( g_iUser2 )
			{
				V_GetChasePos( g_iUser2, v_cl_angles, vJumpOrigin, vJumpAngles );
				gEngfuncs.SetViewAngles( vJumpAngles );
				iJumpSpectator = 1;
			}
			break;

		case OBS_IN_EYE		:	g_iUser1 = OBS_IN_EYE;
			break;

		case OBS_MAP_FREE	:	g_iUser1 = OBS_MAP_FREE;
			// reset user values
			m_mapZoom = m_OverviewData.zoom;
			m_mapOrigin = m_OverviewData.origin;
			break;

		case OBS_MAP_CHASE	:	g_iUser1 = OBS_MAP_CHASE;
			// reset user values
			m_mapZoom = m_OverviewData.zoom;
			m_mapOrigin = m_OverviewData.origin;
			break;
		}

		if ( (g_iUser1 == OBS_IN_EYE) || (g_iUser1 == OBS_ROAMING) )
		{
			m_crosshairRect.left	 = 24;
			m_crosshairRect.top	 = 0;
			m_crosshairRect.right	 = 48;
			m_crosshairRect.bottom = 24;

			SetCrosshair( m_hCrosshair, m_crosshairRect, 255, 255, 255 );
		}
		else
		{
			memset( &m_crosshairRect,0,sizeof(m_crosshairRect) );
			SetCrosshair( 0, m_crosshairRect, 0, 0, 0 );
		}

		char string[128];
		sprintf(string, "#Spec_Mode%d", g_iUser1 );
		sprintf(string, "%c%s", HUD_PRINTCENTER, CHudTextMessage::BufferedLocaliseTextString( string ));
		gHUD.m_TextMessage.MsgFunc_TextMsg(NULL, strlen(string)+1, string );
	}

	//gViewPort->UpdateSpectatorPanel();

}

bool CHudSpectator::IsActivePlayer(cl_entity_t * ent)
{
	return ( ent &&
			 ent->player &&
			 ent->curstate.solid != SOLID_NOT &&
			ent != gEngfuncs.GetLocalPlayer() &&
			g_PlayerInfoList[ent->index].name != NULL
			);
}


bool CHudSpectator::ParseOverviewFile( )
{
	char filename[255] = { 0 };
	char levelname[255] = { 0 };
	char token[1024] = { 0 };
	float height;

	char *pfile  = NULL;

	memset( &m_OverviewData, 0, sizeof(m_OverviewData));

	// fill in standrd values
	m_OverviewData.insetWindowX = 4;	// upper left corner
	m_OverviewData.insetWindowY = 4;
	m_OverviewData.insetWindowHeight = 180;
	m_OverviewData.insetWindowWidth = 240;
	m_OverviewData.origin[0] = 0.0f;
	m_OverviewData.origin[1] = 0.0f;
	m_OverviewData.origin[2] = 0.0f;
	m_OverviewData.zoom	= 1.0f;
	m_OverviewData.layers = 0;
	m_OverviewData.layersHeights[0] = 0.0f;
	strncpy( m_OverviewData.map, gEngfuncs.pfnGetLevelName(), sizeof(m_OverviewData.map) );

	if ( strlen( m_OverviewData.map ) == 0 )
		return false; // not active yet

	strncpy(levelname, m_OverviewData.map + 5, sizeof( levelname ));
	levelname[strlen(levelname)-4] = 0;
	
	sprintf(filename, "overviews/%s.txt", levelname );

	pfile = (char *)gEngfuncs.COM_LoadFile( filename, 5, NULL);

	if (!pfile)
	{
		gEngfuncs.Con_Printf("Couldn't open file %s. Using default values for overiew mode.\n", filename );
		return false;
	}
	
	
	while (true)
	{
		pfile = gEngfuncs.COM_ParseFile(pfile, token);

		if (!pfile)
			break;

		if ( !stricmp( token, "global" ) )
		{
			// parse the global data
			pfile = gEngfuncs.COM_ParseFile(pfile, token);
			if ( stricmp( token, "{" ) )
			{
				gEngfuncs.Con_Printf("Error parsing overview file %s. (expected { )\n", filename );
				return false;
			}

			pfile = gEngfuncs.COM_ParseFile(pfile,token);

			while (stricmp( token, "}") )
			{
				if ( !stricmp( token, "zoom" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.zoom = atof( token );
				}
				else if ( !stricmp( token, "origin" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile, token);
					m_OverviewData.origin[0] = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.origin[1] = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile, token);
					m_OverviewData.origin[2] = atof( token );
				}
				else if ( !stricmp( token, "rotated" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.rotated = atoi( token );
				}
				else if ( !stricmp( token, "inset" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.insetWindowX = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.insetWindowY = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.insetWindowWidth = atof( token );
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					m_OverviewData.insetWindowHeight = atof( token );

				}
				else
				{
					gEngfuncs.Con_Printf("Error parsing overview file %s. (%s unknown)\n", filename, token );
					return false;
				}

				pfile = gEngfuncs.COM_ParseFile(pfile,token); // parse next token

			}
		}
		else if ( !stricmp( token, "layer" ) )
		{
			// parse a layer data

			if ( m_OverviewData.layers == OVERVIEW_MAX_LAYERS )
			{
				gEngfuncs.Con_Printf("Error parsing overview file %s. ( too many layers )\n", filename );
				return false;
			}

			pfile = gEngfuncs.COM_ParseFile(pfile,token);


			if ( stricmp( token, "{" ) )
			{
				gEngfuncs.Con_Printf("Error parsing overview file %s. (expected { )\n", filename );
				return false;
			}

			pfile = gEngfuncs.COM_ParseFile(pfile,token);

			while (stricmp( token, "}") )
			{
				if ( !stricmp( token, "image" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					strncpy(m_OverviewData.layersImages[ m_OverviewData.layers ], token, 255);
					
					
				}
				else if ( !stricmp( token, "height" ) )
				{
					pfile = gEngfuncs.COM_ParseFile(pfile,token);
					height = atof(token);
					m_OverviewData.layersHeights[ m_OverviewData.layers ] = height;
				}
				else
				{
					gEngfuncs.Con_Printf("Error parsing overview file %s. (%s unknown)\n", filename, token );
					return false;
				}

				pfile = gEngfuncs.COM_ParseFile(pfile,token); // parse next token
			}

			m_OverviewData.layers++;

		}
	}

	gEngfuncs.COM_FreeFile( pfile );

	m_mapZoom = m_OverviewData.zoom;
	m_mapOrigin = m_OverviewData.origin;

	return true;

}

void CHudSpectator::LoadMapSprites()
{
	// right now only support for one map layer
	if (m_OverviewData.layers > 0 )
	{
		m_MapSprite = gEngfuncs.LoadMapSprite( m_OverviewData.layersImages[0] );
	}
	else
		m_MapSprite = NULL; // the standard "unknown map" sprite will be used instead
}

void CHudSpectator::DrawOverviewLayer()
{
	float screenaspect, xs, ys, xStep, yStep, x,y,z;
	int ix,iy,i,xTiles,yTiles,frame;
	model_t *   dummySprite = (struct model_s *)gEngfuncs.GetSpritePointer( m_hsprUnkownMap);

	if ( m_MapSprite )
	{
		i = m_MapSprite->numframes / (4*3);
		i = sqrt(i);
		xTiles = i*4;
		yTiles = i*3;
	}
	else
	{
		xTiles = 8;
		yTiles = 6;
	}


	screenaspect = 4.0f/3.0f;


	xs = m_OverviewData.origin[0];
	ys = m_OverviewData.origin[1];
	z  = ( 90.0f - v_angles[0] ) / 90.0f;
	z *= m_OverviewData.layersHeights[0]; // gOverviewData.z_min - 32;

	// i = r_overviewTexture + ( layer*OVERVIEW_X_TILES*OVERVIEW_Y_TILES );
	gEngfuncs.pTriAPI->RenderMode( kRenderTransTexture );
	gEngfuncs.pTriAPI->CullFace( TRI_NONE );
	gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, 1.0 );
	frame = 0;	

	// rotated view ?
	if ( m_OverviewData.rotated )
	{
		xStep = (2*4096.0f / m_OverviewData.zoom ) / xTiles;
		yStep = -(2*4096.0f / (m_OverviewData.zoom* screenaspect) ) / yTiles;

		y = ys + (4096.0f / (m_OverviewData.zoom * screenaspect));

		for (iy = 0; iy < yTiles; iy++)
		{
			x = xs - (4096.0f / (m_OverviewData.zoom));

			for (ix = 0; ix < xTiles; ix++)
			{
				if ( m_MapSprite )
					gEngfuncs.pTriAPI->SpriteTexture( m_MapSprite, frame );
				else
					gEngfuncs.pTriAPI->SpriteTexture( dummySprite, 0 );

				gEngfuncs.pTriAPI->Begin( TRI_QUADS );
				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				gEngfuncs.pTriAPI->Vertex3f (x, y, z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				gEngfuncs.pTriAPI->Vertex3f (x+xStep ,y,  z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
				gEngfuncs.pTriAPI->Vertex3f (x+xStep, y+yStep, z);

				gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
				gEngfuncs.pTriAPI->Vertex3f (x, y+yStep, z);
				gEngfuncs.pTriAPI->End();

				frame++;
				x+= xStep;
			}

			y+=yStep;
		}
	}
	else
	{
		xStep = -(2*4096.0f / m_OverviewData.zoom ) / xTiles;
		yStep = -(2*4096.0f / (m_OverviewData.zoom* screenaspect) ) / yTiles;


		x = xs + (4096.0f / (m_OverviewData.zoom * screenaspect ));

		
		
		for (ix = 0; ix < yTiles; ix++)
		{
			
			y = ys + (4096.0f / (m_OverviewData.zoom));

			for (iy = 0; iy < xTiles; iy++)
			{
				if ( m_MapSprite )
					gEngfuncs.pTriAPI->SpriteTexture( m_MapSprite, frame );
				else
					gEngfuncs.pTriAPI->SpriteTexture( dummySprite, 0 );

				gEngfuncs.pTriAPI->Begin( TRI_QUADS );
				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				gEngfuncs.pTriAPI->Vertex3f (x, y, z);

				gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
				gEngfuncs.pTriAPI->Vertex3f (x+xStep ,y,  z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
				gEngfuncs.pTriAPI->Vertex3f (x+xStep, y+yStep, z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				gEngfuncs.pTriAPI->Vertex3f (x, y+yStep, z);
				gEngfuncs.pTriAPI->End();

				frame++;
				
				y+=yStep;
			}

			x+= xStep;
			
		}
	}
}

void CHudSpectator::DrawOverviewEntities()
{
	int				i,ir,ig,ib;
	struct model_s *hSpriteModel;
	vec3_t			origin, angles, point, forward, right, left, up, world, screen, offset;
	float			x,y,z, r,g,b, sizeScale = 4.0f;
	cl_entity_t *	ent;
	float rmatrix[3][4];	// transformation matrix
	
	float			zScale = (90.0f - v_angles[0] ) / 90.0f;


	z = m_OverviewData.layersHeights[0] * zScale;
	// get yellow/brown HUD color
	DrawUtils::UnpackRGB(ir,ig,ib, RGB_YELLOWISH);
	r = (float)ir/255.0f;
	g = (float)ig/255.0f;
	b = (float)ib/255.0f;
	
	gEngfuncs.pTriAPI->CullFace( TRI_NONE );

	for (i=0; i < MAX_PLAYERS; i++ )
		m_vPlayerPos[i][2] = -1;	// mark as invisible

	// draw all players
	for (i=0 ; i < MAX_OVERVIEW_ENTITIES ; i++)
	{
		if ( !m_OverviewEntities[i].hSprite )
			continue;

		hSpriteModel = (struct model_s *)gEngfuncs.GetSpritePointer( m_OverviewEntities[i].hSprite );
		ent = m_OverviewEntities[i].entity;
		
		gEngfuncs.pTriAPI->SpriteTexture( hSpriteModel, 0 );
		gEngfuncs.pTriAPI->RenderMode( kRenderTransTexture );

		// see R_DrawSpriteModel
		// draws players sprite

		AngleVectors(ent->angles, right, up, NULL );

		VectorCopy(ent->origin,origin);

		gEngfuncs.pTriAPI->Begin( TRI_QUADS );

		gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, 1.0 );

		gEngfuncs.pTriAPI->TexCoord2f (1, 0);
		VectorMA (origin,  16.0f * sizeScale, up, point);
		VectorMA (point,   16.0f * sizeScale, right, point);
		point[2] *= zScale;
		gEngfuncs.pTriAPI->Vertex3fv (point);

		gEngfuncs.pTriAPI->TexCoord2f (0, 0);

		VectorMA (origin,  16.0f * sizeScale, up, point);
		VectorMA (point,  -16.0f * sizeScale, right, point);
		point[2] *= zScale;
		gEngfuncs.pTriAPI->Vertex3fv (point);

		gEngfuncs.pTriAPI->TexCoord2f (0,1);
		VectorMA (origin, -16.0f * sizeScale, up, point);
		VectorMA (point,  -16.0f * sizeScale, right, point);
		point[2] *= zScale;
		gEngfuncs.pTriAPI->Vertex3fv (point);

		gEngfuncs.pTriAPI->TexCoord2f (1,1);
		VectorMA (origin, -16.0f * sizeScale, up, point);
		VectorMA (point,   16.0f * sizeScale, right, point);
		point[2] *= zScale;
		gEngfuncs.pTriAPI->Vertex3fv (point);

		gEngfuncs.pTriAPI->End ();


		if ( !ent->player)
			continue;
		// draw line under player icons
		origin[2] *= zScale;

		gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );

		hSpriteModel = (struct model_s *)gEngfuncs.GetSpritePointer( m_hsprBeam );
		gEngfuncs.pTriAPI->SpriteTexture( hSpriteModel, 0 );

		gEngfuncs.pTriAPI->Color4f(r, g, b, 0.3);

		gEngfuncs.pTriAPI->Begin ( TRI_QUADS );
		gEngfuncs.pTriAPI->TexCoord2f (1, 0);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]+4, origin[1]+4, origin[2]-zScale);
		gEngfuncs.pTriAPI->TexCoord2f (0, 0);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]-4, origin[1]-4, origin[2]-zScale);
		gEngfuncs.pTriAPI->TexCoord2f (0, 1);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]-4, origin[1]-4,z);
		gEngfuncs.pTriAPI->TexCoord2f (1, 1);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]+4, origin[1]+4,z);
		gEngfuncs.pTriAPI->End ();

		gEngfuncs.pTriAPI->Begin ( TRI_QUADS );
		gEngfuncs.pTriAPI->TexCoord2f (1, 0);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]-4, origin[1]+4, origin[2]-zScale);
		gEngfuncs.pTriAPI->TexCoord2f (0, 0);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]+4, origin[1]-4, origin[2]-zScale);
		gEngfuncs.pTriAPI->TexCoord2f (0, 1);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]+4, origin[1]-4,z);
		gEngfuncs.pTriAPI->TexCoord2f (1, 1);
		gEngfuncs.pTriAPI->Vertex3f (origin[0]-4, origin[1]+4,z);
		gEngfuncs.pTriAPI->End ();

		// calculate screen position for name and infromation in hud::draw()
		if ( gEngfuncs.pTriAPI->WorldToScreen(origin,screen) )
			continue;	// object is behind viewer

		screen[0] = XPROJECT(screen[0]);
		screen[1] = YPROJECT(screen[1]);
		screen[2] = 0.0f;

		// calculate some offset under the icon
		origin[0]+=32.0f;
		origin[1]+=32.0f;

		gEngfuncs.pTriAPI->WorldToScreen(origin,offset);

		offset[0] = XPROJECT(offset[0]);
		offset[1] = YPROJECT(offset[1]);
		offset[2] = 0.0f;

		VectorSubtract(offset, screen, offset );

		int playerNum = ent->index - 1;

		m_vPlayerPos[playerNum][0] = screen[0];
		m_vPlayerPos[playerNum][1] = screen[1] + offset.Length();
		m_vPlayerPos[playerNum][2] = 1;	// mark player as visible
	}

	if ( !m_pip->value || !m_drawcone->value )
		return;

	// get current camera position and angle

	if ( m_pip->value == INSET_IN_EYE || g_iUser1 == OBS_IN_EYE )
	{
		V_GetInEyePos( g_iUser2, origin, angles );
	}
	else if ( m_pip->value == INSET_CHASE_FREE  || g_iUser1 == OBS_CHASE_FREE )
	{
		V_GetChasePos( g_iUser2, v_cl_angles, origin, angles );
	}
	else if ( g_iUser1 == OBS_ROAMING )
	{
		VectorCopy( v_sim_org, origin );
		VectorCopy( v_cl_angles, angles );
	}
	else
		V_GetChasePos( g_iUser2, NULL, origin, angles );

	
	// draw camera sprite

	x = origin[0];
	y = origin[1];
	z = origin[2];

	angles[0] = 0; // always show horizontal camera sprite

	hSpriteModel = (struct model_s *)gEngfuncs.GetSpritePointer( m_hsprCamera );
	gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
	gEngfuncs.pTriAPI->SpriteTexture( hSpriteModel, 0 );
	
	
	gEngfuncs.pTriAPI->Color4f( r, g, b, 1.0 );

	AngleVectors(angles, forward, NULL, NULL );
	VectorScale (forward, 512.0f, forward);
	
	offset[0] =  0.0f;
	offset[1] = 45.0f;
	offset[2] =  0.0f;

	AngleMatrix(offset, rmatrix );
	VectorTransform(forward, rmatrix , right );

	offset[1]= -45.0f;
	AngleMatrix(offset, rmatrix );
	VectorTransform(forward, rmatrix , left );

	gEngfuncs.pTriAPI->Begin (TRI_TRIANGLES);
	gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
	gEngfuncs.pTriAPI->Vertex3f (x+right[0], y+right[1], (z+right[2]) * zScale);

	gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
	gEngfuncs.pTriAPI->Vertex3f (x, y, z  * zScale);

	gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
	gEngfuncs.pTriAPI->Vertex3f (x+left[0], y+left[1], (z+left[2]) * zScale);
	gEngfuncs.pTriAPI->End ();

}



void CHudSpectator::DrawOverview()
{
	static bool glClearForce = false;
	static float old_glClearValue;

	// draw only in sepctator mode
	if ( !g_iUser1 || (m_iDrawCycle == 0 &&  ( (g_iUser1 != OBS_MAP_FREE) && (g_iUser1 != OBS_MAP_CHASE) )) || (m_iDrawCycle == 1 && m_pip->value < INSET_MAP_FREE) )
	{
		// fix non clearing background for overview
		if( glClearForce )
		{
			gEngfuncs.Cvar_SetValue("gl_clear", old_glClearValue );
			glClearForce = false;
		}
		return;
	}

	// fix non clearing background for overview
	if( !glClearForce )
	{
		old_glClearValue = CVAR_GET_FLOAT("gl_clear");
		gEngfuncs.Cvar_Set("gl_clear", "1");
		glClearForce = true;
	}

	DrawOverviewLayer();
	DrawOverviewEntities();
	CheckOverviewEntities();
}
void CHudSpectator::CheckOverviewEntities()
{
	double time = gEngfuncs.GetClientTime();

	// removes old entities from list
	for ( int i = 0; i< MAX_OVERVIEW_ENTITIES; i++ )
	{
		// remove entity from list if it is too old
		if ( m_OverviewEntities[i].killTime < time )
		{
			memset( &m_OverviewEntities[i], 0, sizeof (overviewEntity_t) );
		}
	}
}

bool CHudSpectator::AddOverviewEntity( int type, struct cl_entity_s *ent, const char *modelname)
{
	HSPRITE	hSprite = 0;
	double  duration = -1.0f;	// duration -1 means show it only this frame;

	if ( !ent )
		return false;

	if ( type == ET_PLAYER )
	{
		if ( ent->curstate.solid != SOLID_NOT)
		{
			switch ( g_PlayerExtraInfo[ent->index].teamnumber )
			{
			// blue and red teams are swapped in CS and TFC
			case TEAM_TERRORIST: hSprite = m_hsprPlayerRed; break;
			case TEAM_CT: hSprite = m_hsprPlayerBlue; break;
			default: hSprite = m_hsprPlayer; break;
			}

			if( g_PlayerExtraInfo[ent->index].has_c4 )
				hSprite = m_hsprPlayerC4;
			else if( g_PlayerExtraInfo[ent->index].vip )
				hSprite = m_hsprPlayerVIP;

			return AddOverviewEntityToList(hSprite, ent, gEngfuncs.GetClientTime() + duration );
		}
		else
			return false;	// it's an spectator
	}
	/*else if (type == ET_NORMAL)
	{
		return false;
	}
	else
	{
		else return false;
	}*/

	if( !stricmp( modelname, "models/w_c4.mdl" ))
		hSprite = m_hsprBomb;
	else if( !stricmp( modelname, "models/w_backpack.mdl" ))
		hSprite = m_hsprBackpack;
	else if( strstr( modelname, "models/hostage") || strstr( modelname, "models/scientist"))
		hSprite = m_hsprHostage;
	else return false;

	return AddOverviewEntityToList(hSprite, ent, gEngfuncs.GetClientTime() + duration );
}

void CHudSpectator::DeathMessage(int victim)
{
	// find out where the victim is
	cl_entity_t *pl = gEngfuncs.GetEntityByIndex(victim);

	if (pl && pl->player)
		AddOverviewEntityToList(m_hsprPlayerDead, pl, gEngfuncs.GetClientTime() + 2.0f );
}

bool CHudSpectator::AddOverviewEntityToList(HSPRITE sprite, cl_entity_t *ent, double killTime)
{
	for ( int i = 0; i< MAX_OVERVIEW_ENTITIES; i++ )
	{
		// find empty entity slot
		if ( m_OverviewEntities[i].entity == NULL)
		{
			m_OverviewEntities[i].entity = ent;
			m_OverviewEntities[i].hSprite = sprite;
			m_OverviewEntities[i].killTime = killTime;
			return true;
		}
	}

	return false;	// maximum overview entities reached
}
void CHudSpectator::CheckSettings()
{
	// disallow same inset mode as main mode:

	m_pip->value = (int)m_pip->value;
	
	if ( ( g_iUser1 < OBS_MAP_FREE ) && ( m_pip->value == INSET_CHASE_FREE || m_pip->value == INSET_IN_EYE ) )
	{
		// otherwise both would show in World picures
		m_pip->value = INSET_MAP_FREE;
	}

	if ( ( g_iUser1 >= OBS_MAP_FREE ) && ( m_pip->value >= INSET_MAP_FREE ) )
	{
		// both would show map views
		m_pip->value = INSET_CHASE_FREE;
	}

	// disble in intermission screen
	if ( gHUD.m_iIntermission )
		m_pip->value = INSET_OFF;

	// check chat mode
	if ( m_chatEnabled != (gHUD.m_SayText.m_HUD_saytext->value!=0) )
	{
		// hud_saytext changed
		m_chatEnabled = (gHUD.m_SayText.m_HUD_saytext->value!=0);

		if ( gEngfuncs.IsSpectateOnly() )
		{
			// tell proxy our new chat mode
			char chatcmd[32];
			sprintf(chatcmd, "ignoremsg %i", m_chatEnabled?0:1 );
			gEngfuncs.pfnServerCmd(chatcmd);
		}
	}

	// HL/TFC has no oberserver corsshair, so set it client side
	if ( (g_iUser1 == OBS_IN_EYE) || (g_iUser1 == OBS_ROAMING) )
	{
		m_crosshairRect.left	 = 24;
		m_crosshairRect.top	 = 0;
		m_crosshairRect.right	 = 48;
		m_crosshairRect.bottom = 24;

		SetCrosshair( m_hCrosshair, m_crosshairRect, 255, 255, 255 );
	}
	else
	{
		memset( &m_crosshairRect,0,sizeof(m_crosshairRect) );
		SetCrosshair( 0, m_crosshairRect, 0, 0, 0 );
	}



	// if we are a real player on server don't allow inset window
	// in First Person mode since this is our restricted forcecamera mode 2
	// team number 3 = SPECTATOR see player.h

	if ( ( (g_iTeamNumber == 1) || (g_iTeamNumber == 2)) && (g_iUser1 == OBS_IN_EYE) )
		m_pip->value = INSET_OFF;

	// draw small border around inset view, adjust upper black bar
	//	gViewPort->m_pSpectatorPanel->EnableInsetView( m_pip->value != INSET_OFF );
}

int CHudSpectator::ToggleInset(bool allowOff)
{
	int newInsetMode = (int)m_pip->value + 1;

	if ( g_iUser1 < OBS_MAP_FREE )
	{
		if ( newInsetMode > INSET_MAP_CHASE )
		{
			if (allowOff)
				newInsetMode = INSET_OFF;
			else
				newInsetMode = INSET_MAP_FREE;
		}

		if ( newInsetMode == INSET_CHASE_FREE )
			newInsetMode = INSET_MAP_FREE;
	}
	else
	{
		if ( newInsetMode > INSET_IN_EYE )
		{
			if (allowOff)
				newInsetMode = INSET_OFF;
			else
				newInsetMode = INSET_CHASE_FREE;
		}
	}

	return newInsetMode;
}
void CHudSpectator::Reset()
{
	// Reset HUD
	if ( strcmp( m_OverviewData.map, gEngfuncs.pfnGetLevelName() ) )
	{
		// update level overview if level changed
		ParseOverviewFile();
		LoadMapSprites();
	}

	memset( &m_OverviewEntities, 0, sizeof(m_OverviewEntities));

	SetSpectatorStartPosition();
}

void CHudSpectator::InitHUDData()
{
	m_lastPrimaryObject = m_lastSecondaryObject = 0;
	m_flNextObserverInput = 0.0f;
	m_lastHudMessage = 0;
	m_iSpectatorNumber = 0;
	iJumpSpectator	= 0;
	g_iUser1 = g_iUser2 = 0;

	memset( &m_OverviewData, 0, sizeof(m_OverviewData));
	memset( &m_OverviewEntities, 0, sizeof(m_OverviewEntities));

	if ( gEngfuncs.IsSpectateOnly() || gEngfuncs.pDemoAPI->IsPlayingback() )
		m_autoDirector->value = 1.0f;
	else
		m_autoDirector->value = 0.0f;

	Reset();

	SetModes( OBS_CHASE_FREE, INSET_OFF );

	g_iUser2 = 0; // fake not target until first camera command

	// reset HUD FOV
	gHUD.m_iFOV =  CVAR_GET_FLOAT("default_fov");
}

int CHudSpectator::MsgFunc_Spectator(const char *pszName, int iSize, void *buf)
{
	return 1;
}

int CHudSpectator::MsgFunc_ADStop(const char *pszName, int iSize, void *buf)
{
	m_autoDirector->value = 0;
	return 1;
}

```

`cl_dll/hud/hud_update.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  hud_update.cpp
//

#include <math.h>
#include "hud.h"
#include "cl_util.h"
#include <stdlib.h>
#include <memory.h>

int CL_ButtonBits( int );
void CL_ResetButtonBits( int bits );

extern float v_idlescale;
extern void HUD_SetCmdBits( int bits );

int CHud::UpdateClientData(client_data_t *cdata, float time)
{
	m_vecOrigin = cdata->origin;
	m_vecAngles = cdata->viewangles;

	m_iKeyBits = CL_ButtonBits( 0 );
	m_iWeaponBits = cdata->iWeaponBits;

	Think();

	cdata->fov = m_iFOV;
	
	v_idlescale = m_iConcussionEffect;

	CL_ResetButtonBits( m_iKeyBits );

	// return 1 if in anything in the client_data struct has been changed, 0 otherwise
	return 1;
}



```

`cl_dll/hud/menu.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// menu.cpp
//
// generic menu handler
//
#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>
#include "draw_util.h"

//#include "vgui_TeamFortressViewport.h"

#define MAX_MENU_STRING	512

char g_szMenuString[MAX_MENU_STRING];
char g_szPrelocalisedMenuString[MAX_MENU_STRING];

int KB_ConvertString( char *in, char **ppout );

DECLARE_MESSAGE( m_Menu, ShowMenu )
DECLARE_MESSAGE( m_Menu, VGUIMenu )
DECLARE_MESSAGE( m_Menu, BuyClose )
DECLARE_MESSAGE( m_Menu, AllowSpec )

DECLARE_COMMAND( m_Menu, OldStyleMenuOpen )
DECLARE_COMMAND( m_Menu, OldStyleMenuClose )
DECLARE_COMMAND( m_Menu, ShowVGUIMenu )

int CHudMenu :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( ShowMenu );
	HOOK_MESSAGE( VGUIMenu );
	HOOK_MESSAGE( BuyClose );
	HOOK_MESSAGE( AllowSpec );
	HOOK_COMMAND( "client_buy_open", OldStyleMenuOpen );
	HOOK_COMMAND( "client_buy_close", OldStyleMenuClose );
	HOOK_COMMAND( "showvguimenu", ShowVGUIMenu );

	_extended_menus = CVAR_CREATE("_extended_menus", "1", FCVAR_ARCHIVE);

	InitHUDData();

	m_bAllowSpec = true; // by default, spectating is allowed

	return 1;
}

void CHudMenu :: InitHUDData( void )
{
	m_fMenuDisplayed = 0;
	m_bitsValidSlots = 0;
	Reset();
}

void CHudMenu :: Reset( void )
{
	g_szPrelocalisedMenuString[0] = 0;
	m_fWaitingForMore = FALSE;
}

int CHudMenu :: VidInit( void )
{
	return 1;
}

int CHudMenu :: Draw( float flTime )
{
	// check for if menu is set to disappear
	if ( m_flShutoffTime > 0 )
	{
		if ( m_flShutoffTime <= gHUD.m_flTime )
		{  // times up, shutoff
			m_fMenuDisplayed = 0;
			m_iFlags &= ~HUD_DRAW;
			return 1;
		}
	}

	// don't draw the menu if the scoreboard is being shown
	//if ( gViewPort && gViewPort->IsScoreBoardVisible() )
		//return 1;

	// draw the menu, along the left-hand side of the screen

	// count the number of newlines
	int nlc = 0;
	int i;
	for ( i = 0; i < MAX_MENU_STRING && g_szMenuString[i] != '\0'; i++ )
	{
		if ( g_szMenuString[i] == '\n' )
			nlc++;
	}

	// center it
	int y = (ScreenHeight/2) - ((nlc/2)*12) - 40; // make sure it is above the say text
	int x = 20;

	i = 0;
	while ( i < MAX_MENU_STRING && g_szMenuString[i] != '\0' )
	{
		DrawUtils::DrawHudString( x, y, 320, g_szMenuString + i, 255, 255, 255 );
		y += 24;

		while ( i < MAX_MENU_STRING && g_szMenuString[i] != '\0' && g_szMenuString[i] != '\n' )
			i++;
		if ( g_szMenuString[i] == '\n' )
			i++;
	}
	
	return 1;
}

// selects an item from the menu
void CHudMenu :: SelectMenuItem( int menu_item )
{
	// if menu_item is in a valid slot,  send a menuselect command to the server
	if ( (menu_item > 0) && (m_bitsValidSlots & (1 << (menu_item-1))) )
	{
		char szbuf[32];
		sprintf( szbuf, "menuselect %d\n", menu_item );
		ClientCmd( szbuf );

		// remove the menu
		m_fMenuDisplayed = 0;
		m_iFlags &= ~HUD_DRAW;
	}
}


// Message handler for ShowMenu message
// takes four values:
//		short: a bitfield of keys that are valid input
//		char : the duration, in seconds, the menu should stay up. -1 means is stays until something is chosen.
//		byte : a boolean, TRUE if there is more string yet to be received before displaying the menu, FALSE if it's the last string
//		string: menu string to display
// if this message is never received, then scores will simply be the combined totals of the players.
int CHudMenu :: MsgFunc_ShowMenu( const char *pszName, int iSize, void *pbuf )
{
	char *temp = NULL, *menustring;

	BufferReader reader( pszName, pbuf, iSize );

	m_bitsValidSlots = reader.ReadShort();
	int DisplayTime = reader.ReadChar();
	int NeedMore = reader.ReadByte();

	if ( DisplayTime > 0 )
		m_flShutoffTime = DisplayTime + gHUD.m_flTime;
	else
		m_flShutoffTime = -1;

	if ( !m_bitsValidSlots )
	{
		m_fMenuDisplayed = 0; // no valid slots means that the menu should be turned off
		m_iFlags &= ~HUD_DRAW;
		ClientCmd("touch_removebutton _menu_*");
		return 1;
	}

	menustring = reader.ReadString();

	// menu will be replaced by scripted touch config
	// so execute it and exit
	if( _extended_menus->value != 0.0f )
	{
		if( !strncmp(menustring, "#Radio", 6 ) )
		{
			if( menustring[6] == 'A' )
			{
				ShowVGUIMenu(MENU_RADIOA); return 1;
			}
			else if( menustring[6] == 'B' )
			{
				ShowVGUIMenu(MENU_RADIOB); return 1;
			}
			else if( menustring[6] == 'C' )
			{
				ShowVGUIMenu(MENU_RADIOC); return 1;
			}
			else ShowVGUIMenu( MENU_NUMERICAL_MENU ); // we just show touch screen numbers
		}
		else ShowVGUIMenu(MENU_NUMERICAL_MENU);
	}
	else ShowVGUIMenu(MENU_NUMERICAL_MENU);

	if ( !m_fWaitingForMore ) // this is the start of a new menu
	{
		strncpy( g_szPrelocalisedMenuString, menustring, MAX_MENU_STRING );
	}
	else
	{  // append to the current menu string
		strncat( g_szPrelocalisedMenuString, menustring, MAX_MENU_STRING - strlen(g_szPrelocalisedMenuString) );
	}
	g_szPrelocalisedMenuString[MAX_MENU_STRING-1] = 0;  // ensure null termination (strncat/strncpy does not)

	if ( !NeedMore )
	{  // we have the whole string, so we can localise it now
		strncpy( g_szMenuString, gHUD.m_TextMessage.BufferedLocaliseTextString( g_szPrelocalisedMenuString ), MAX_MENU_STRING );

		// Swap in characters
		if ( KB_ConvertString( g_szMenuString, &temp ) )
		{
			strncpy( g_szMenuString, temp, MAX_MENU_STRING );
			free( temp );
		}
	}

	m_fMenuDisplayed = 1;
	m_iFlags |= HUD_DRAW;

	m_fWaitingForMore = NeedMore;

	return 1;
}

int CHudMenu::MsgFunc_VGUIMenu( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int menuType = reader.ReadByte();
	m_bitsValidSlots = reader.ReadShort(); // is ignored

	ShowVGUIMenu(menuType);
	return 1;
}

int CHudMenu::MsgFunc_BuyClose(const char *pszName, int iSize, void *pbuf)
{
	UserCmd_OldStyleMenuClose();
	gMobileAPI.pfnTouchRemoveButton("_menu_*");
	return 1;
}

int CHudMenu::MsgFunc_AllowSpec(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	m_bAllowSpec = (bool)reader.ReadByte();

	return 1;
}

void CHudMenu::UserCmd_OldStyleMenuOpen()
{
	m_flShutoffTime = -1; // stay open until user will not close it
	strncpy( g_szMenuString, gHUD.m_TextMessage.BufferedLocaliseTextString("Buy"), MAX_MENU_STRING );
}

void CHudMenu::UserCmd_OldStyleMenuClose()
{
	m_fMenuDisplayed = 0; // no valid slots means that the menu should be turned off
	m_iFlags &= ~HUD_DRAW;
	gMobileAPI.pfnTouchRemoveButton("_menu_*");
}

// lol, no real VGUI here
// it's really good only for touchscreen

void CHudMenu::ShowVGUIMenu( int menuType )
{
	const char *szCmd;

	switch(menuType)
	{
	case MENU_TEAM:
		szCmd = "exec touch/chooseteam.cfg";
		break;
	case MENU_CLASS_T:
		szCmd = "exec touch/chooseteam_tr.cfg";
		break;
	case MENU_CLASS_CT:
		szCmd = "exec touch/chooseteam_ct.cfg";
		break;
	case MENU_BUY:
		szCmd = "exec touch/buy.cfg";
		break;
	case MENU_BUY_PISTOL:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_pistol_t.cfg";
		else szCmd = "exec touch/buy_pistol_ct.cfg";
		break;
	case MENU_BUY_SHOTGUN:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_shotgun_t.cfg";
		else szCmd = "exec touch/buy_shotgun_ct.cfg";
		break;
	case MENU_BUY_RIFLE:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_rifle_t.cfg";
		else szCmd ="exec touch/buy_rifle_ct.cfg";
		break;
	case MENU_BUY_SUBMACHINEGUN:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_submachinegun_t.cfg";
		else szCmd = "exec touch/buy_submachinegun_ct.cfg";
		break;
	case MENU_BUY_MACHINEGUN:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_machinegun_t.cfg";
		else szCmd = "exec touch/buy_machinegun_ct.cfg";
		break;
	case MENU_BUY_ITEM:
		if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
			szCmd = "exec touch/buy_item_t.cfg";
		else szCmd = "exec touch/buy_item_ct.cfg";
		break;
	case MENU_RADIOA:
		szCmd = "exec touch/radioa.cfg";
		break;
	case MENU_RADIOB:
		szCmd = "exec touch/radiob.cfg";
		break;
	case MENU_RADIOC:
		szCmd = "exec touch/radioc.cfg";
		break;
	case MENU_RADIOSELECTOR:
		szCmd = "exec touch/radioselector.cfg";
		break;
	case MENU_NUMERICAL_MENU:
		szCmd = "exec touch/numerical_menu.cfg";
		break;
	default:
		szCmd = "touch_removebutton _menu_*"; // back to the default touch page
		m_fMenuDisplayed = 0;
		break;
	}

	m_fMenuDisplayed = 1;
	ClientCmd(szCmd);
}

void CHudMenu::UserCmd_ShowVGUIMenu()
{
	if( gEngfuncs.Cmd_Argc() < 2 )
	{
		ConsolePrint("usage: showvguimenu <menuType>\n");
		return;
	}

	int menuType = atoi(gEngfuncs.Cmd_Argv(1));
	ShowVGUIMenu(menuType);
}

```

`cl_dll/hud/message.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Message.cpp
//
// implementation of CHudMessage class
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "vgui_parser.h"
#include "draw_util.h"

DECLARE_MESSAGE( m_Message, HudText )
DECLARE_MESSAGE( m_Message, GameTitle )
DECLARE_MESSAGE( m_Message, HudTextPro )
DECLARE_MESSAGE( m_Message, HudTextArgs )

// 1 Global client_textmessage_t for custom messages that aren't in the titles.txt
client_textmessage_t	g_pCustomMessage;

int CHudMessage::Init(void)
{
	HOOK_MESSAGE( HudText );
	HOOK_MESSAGE( GameTitle );
	HOOK_MESSAGE( HudTextPro );
	HOOK_MESSAGE( HudTextArgs );

	gHUD.AddHudElem(this);
	Reset();

	return 1;
}

int CHudMessage::VidInit( void )
{
	m_HUD_title_half = gHUD.GetSpriteIndex( "title_half" );
	m_HUD_title_life = gHUD.GetSpriteIndex( "title_life" );

	return 1;
}


void CHudMessage::Reset( void )
{
 	memset( m_pMessages, 0, sizeof( m_pMessages[0] ) * maxHUDMessages );
	memset( m_startTime, 0, sizeof( m_startTime[0] ) * maxHUDMessages );
	
	m_gameTitleTime = 0;
	m_pGameTitle = NULL;
}


float CHudMessage::FadeBlend( float fadein, float fadeout, float hold, float localTime )
{
	float fadeTime = fadein + hold;
	float fadeBlend;

	if ( localTime < 0 )
		return 0;

	if ( localTime < fadein )
	{
		fadeBlend = 1 - ((fadein - localTime) / fadein);
	}
	else if ( localTime > fadeTime )
	{
		if ( fadeout > 0 )
			fadeBlend = 1 - ((localTime - fadeTime) / fadeout);
		else
			fadeBlend = 0;
	}
	else
		fadeBlend = 1;

	return fadeBlend;
}


int	CHudMessage::XPosition( float x, int width, int totalWidth )
{
	int xPos;

	if ( x == -1 )
	{
		xPos = (ScreenWidth - width) / 2;
	}
	else
	{
		if ( x < 0 )
			xPos = (1.0 + x) * ScreenWidth - totalWidth;	// Alight right
		else
			xPos = x * ScreenWidth;
	}

	if ( xPos + width > ScreenWidth )
		xPos = ScreenWidth - width;
	else if ( xPos < 0 )
		xPos = 0;

	return xPos;
}


int CHudMessage::YPosition( float y, int height )
{
	int yPos;

	if ( y == -1 )	// Centered?
		yPos = (ScreenHeight - height) * 0.5;
	else
	{
		// Alight bottom?
		if ( y < 0 )
			yPos = (1.0 + y) * ScreenHeight - height;	// Alight bottom
		else // align top
			yPos = y * ScreenHeight;
	}

	if ( yPos + height > ScreenHeight )
		yPos = ScreenHeight - height;
	else if ( yPos < 0 )
		yPos = 0;

	return yPos;
}


void CHudMessage::MessageScanNextChar( void )
{
	int srcRed = m_parms.pMessage->r1;
	int srcGreen = m_parms.pMessage->g1;
	int srcBlue = m_parms.pMessage->b1;
	int destRed, destGreen, destBlue, blend;
	destRed = destGreen = destBlue = blend = 0;

	switch( m_parms.pMessage->effect )
	{
	// Fade-in / Fade-out
	case 0:
	case 1:
		destRed = destGreen = destBlue = 0;
		blend = m_parms.fadeBlend;
		break;

	case 2:
		m_parms.charTime += m_parms.pMessage->fadein;
		if ( m_parms.charTime > m_parms.time )
		{
			srcRed = srcGreen = srcBlue = 0;
			blend = 0;	// pure source
		}
		else
		{
			float deltaTime = m_parms.time - m_parms.charTime;

			destRed = destGreen = destBlue = 0;
			if ( m_parms.time > m_parms.fadeTime )
			{
				blend = m_parms.fadeBlend;
			}
			else if ( deltaTime > m_parms.pMessage->fxtime )
				blend = 0;	// pure dest
			else
			{
				destRed = m_parms.pMessage->r2;
				destGreen = m_parms.pMessage->g2;
				destBlue = m_parms.pMessage->b2;
				blend = 255 - (deltaTime * (1.0/m_parms.pMessage->fxtime) * 255.0 + 0.5);
			}
		}
		break;
	}
	if ( blend > 255 )
		blend = 255;
	else if ( blend < 0 )
		blend = 0;

	m_parms.r = ((srcRed * (255-blend)) + (destRed * blend)) >> 8;
	m_parms.g = ((srcGreen * (255-blend)) + (destGreen * blend)) >> 8;
	m_parms.b = ((srcBlue * (255-blend)) + (destBlue * blend)) >> 8;

	if ( m_parms.pMessage->effect == 1 && m_parms.charTime != 0 )
	{
		if ( m_parms.x >= 0 && m_parms.y >= 0 && (m_parms.x + gHUD.GetCharWidth( m_parms.text )) <= ScreenWidth )
			DrawUtils::TextMessageDrawChar( m_parms.x, m_parms.y, m_parms.text, m_parms.pMessage->r2, m_parms.pMessage->g2, m_parms.pMessage->b2 );
	}
}


void CHudMessage::MessageScanStart( void )
{
	switch( m_parms.pMessage->effect )
	{
	// Fade-in / out with flicker
	case 1:
	case 0:
		m_parms.fadeTime = m_parms.pMessage->fadein + m_parms.pMessage->holdtime;
		

		if ( m_parms.time < m_parms.pMessage->fadein )
		{
			m_parms.fadeBlend = ((m_parms.pMessage->fadein - m_parms.time) * (1.0/m_parms.pMessage->fadein) * 255);
		}
		else if ( m_parms.time > m_parms.fadeTime )
		{
			if ( m_parms.pMessage->fadeout > 0 )
				m_parms.fadeBlend = (((m_parms.time - m_parms.fadeTime) / m_parms.pMessage->fadeout) * 255);
			else
				m_parms.fadeBlend = 255; // Pure dest (off)
		}
		else
			m_parms.fadeBlend = 0;	// Pure source (on)
		m_parms.charTime = 0;

		if ( m_parms.pMessage->effect == 1 && (rand()%100) < 10 )
			m_parms.charTime = 1;
		break;

	case 2:
		m_parms.fadeTime = (m_parms.pMessage->fadein * m_parms.length) + m_parms.pMessage->holdtime;
		
		if ( m_parms.time > m_parms.fadeTime && m_parms.pMessage->fadeout > 0 )
			m_parms.fadeBlend = (((m_parms.time - m_parms.fadeTime) / m_parms.pMessage->fadeout) * 255);
		else
			m_parms.fadeBlend = 0;
		break;
	}
}


void CHudMessage::MessageDrawScan( client_textmessage_t *pMessage, float time )
{
	int i, j, length, width;
	const char *pText;
	unsigned char line[80];

	pText = pMessage->pMessage;
	// Count lines
	m_parms.lines = 1;
	m_parms.time = time;
	m_parms.pMessage = pMessage;
	length = 0;
	width = 0;
	m_parms.totalWidth = 0;
	while ( *pText )
	{
		if ( *pText == '\n' )
		{
			m_parms.lines++;
			if ( width > m_parms.totalWidth )
				m_parms.totalWidth = width;
			width = 0;
		}
		else
			width += gHUD.GetCharWidth((unsigned char)*pText);
		pText++;
		length++;
	}
	m_parms.length = length;
	m_parms.totalHeight = (m_parms.lines * gHUD.GetCharHeight());


	m_parms.y = YPosition( pMessage->y, m_parms.totalHeight );
	pText = pMessage->pMessage;

	m_parms.charTime = 0;

	MessageScanStart();

	for ( i = 0; i < m_parms.lines; i++ )
	{
		m_parms.lineLength = 0;
		m_parms.width = 0;
		while ( *pText && *pText != '\n' )
		{
			unsigned char c = *pText;
			line[m_parms.lineLength] = c;
			m_parms.width += gHUD.GetCharWidth(c);
			m_parms.lineLength++;
			pText++;
		}
		pText++;		// Skip LF
		line[m_parms.lineLength] = 0;

		m_parms.x = XPosition( pMessage->x, m_parms.width, m_parms.totalWidth );

		for ( j = 0; j < m_parms.lineLength; j++ )
		{
			m_parms.text = line[j];
			int next = m_parms.x + gHUD.GetCharWidth( m_parms.text );
			MessageScanNextChar();
			
			if ( m_parms.x >= 0 && m_parms.y >= 0 && next <= ScreenWidth )
				DrawUtils::TextMessageDrawChar( m_parms.x, m_parms.y, m_parms.text, m_parms.r, m_parms.g, m_parms.b );
			m_parms.x = next;
		}

		m_parms.y += gHUD.GetCharHeight();
	}
}


int CHudMessage::Draw( float fTime )
{
	int i, drawn;
	client_textmessage_t *pMessage;
	float endTime;

	drawn = 0;

	if ( m_gameTitleTime > 0 )
	{
		float localTime = gHUD.m_flTime - m_gameTitleTime;
		float brightness;

		// Maybe timer isn't set yet
		if ( m_gameTitleTime > gHUD.m_flTime )
			m_gameTitleTime = gHUD.m_flTime;

		if ( localTime > (m_pGameTitle->fadein + m_pGameTitle->holdtime + m_pGameTitle->fadeout) )
			m_gameTitleTime = 0;
		else
		{
			brightness = FadeBlend( m_pGameTitle->fadein, m_pGameTitle->fadeout, m_pGameTitle->holdtime, localTime );

			int halfWidth = gHUD.GetSpriteRect(m_HUD_title_half).right - gHUD.GetSpriteRect(m_HUD_title_half).left;
			int fullWidth = halfWidth + gHUD.GetSpriteRect(m_HUD_title_life).right - gHUD.GetSpriteRect(m_HUD_title_life).left;
			int fullHeight = gHUD.GetSpriteRect(m_HUD_title_half).bottom - gHUD.GetSpriteRect(m_HUD_title_half).top;

			int x = XPosition( m_pGameTitle->x, fullWidth, fullWidth );
			int y = YPosition( m_pGameTitle->y, fullHeight );


			SPR_Set( gHUD.GetSprite(m_HUD_title_half), brightness * m_pGameTitle->r1, brightness * m_pGameTitle->g1, brightness * m_pGameTitle->b1 );
			SPR_DrawAdditive( 0, x, y, &gHUD.GetSpriteRect(m_HUD_title_half) );

			SPR_Set( gHUD.GetSprite(m_HUD_title_life), brightness * m_pGameTitle->r1, brightness * m_pGameTitle->g1, brightness * m_pGameTitle->b1 );
			SPR_DrawAdditive( 0, x + halfWidth, y, &gHUD.GetSpriteRect(m_HUD_title_life) );

			drawn = 1;
		}
	}
	// Fixup level transitions
	for ( i = 0; i < maxHUDMessages; i++ )
	{
		// Assume m_parms.time contains last time
		if ( m_pMessages[i] )
		{
			pMessage = m_pMessages[i];
			if ( m_startTime[i] > gHUD.m_flTime )
				m_startTime[i] = gHUD.m_flTime + m_parms.time - m_startTime[i] + 0.2;	// Server takes 0.2 seconds to spawn, adjust for this
		}
	}

	for ( i = 0; i < maxHUDMessages; i++ )
	{
		if ( m_pMessages[i] )
		{
			pMessage = m_pMessages[i];

			// This is when the message is over
			switch( pMessage->effect )
			{
			case 0:
			case 1:
				endTime = m_startTime[i] + pMessage->fadein + pMessage->fadeout + pMessage->holdtime;
				break;
			
			// Fade in is per character in scanning messages
			case 2:
				endTime = m_startTime[i] + (pMessage->fadein * strlen( pMessage->pMessage )) + pMessage->fadeout + pMessage->holdtime;
				break;
			}

			if ( fTime <= endTime )
			{
				float messageTime = fTime - m_startTime[i];

				// Draw the message
				// effect 0 is fade in/fade out
				// effect 1 is flickery credits
				// effect 2 is write out (training room)
				MessageDrawScan( pMessage, messageTime );

				drawn++;
			}
			else
			{
				// The message is over
				if( !strcmp( m_pMessages[i]->pName, "Custom" ) )
				{
					delete[] m_pMessages[i]->pName;
					delete[] m_pMessages[i]->pMessage;
				}
				delete m_pMessages[i];
				m_pMessages[i] = NULL;
			}
		}
	}

	// Remember the time -- to fix up level transitions
	m_parms.time = gHUD.m_flTime;
	// Don't call until we get another message
	if ( !drawn )
		m_iFlags &= ~HUD_DRAW;

	return 1;
}


void CHudMessage::MessageAdd( const char *pName, float time )
{
	int i,j;
	client_textmessage_t *tempMessage;

	for ( i = 0; i < maxHUDMessages; i++ )
	{
		if ( !m_pMessages[i] )
		{
			// Trim off a leading # if it's there
			if ( pName[0] == '#' ) 
				tempMessage = TextMessageGet( pName+1 );
			else
				tempMessage = TextMessageGet( pName );

			client_textmessage_t *message = new client_textmessage_t;
			if( tempMessage )
			{
				*message = *tempMessage;

				// localize again, if it need
				if( message->pMessage[0] == '#' )
				{
					char *szCustomName = new char[10];
					char *szCustomText = new char[1024];
					strcpy( szCustomName, "Custom" );
					strcpy( szCustomText, pName );
					message->pMessage = szCustomText;
					message->pName = szCustomName;
				}
			}
			else
			{
				char *szCustomName = new char[10];
				char *szCustomText = new char[1024];
				strcpy( szCustomName, "Custom" );
				strcpy( szCustomText, pName );

				// If we couldnt find it in the titles.txt, just create it
				message->effect = 2;
				message->r1 = message->g1 = message->b1 = message->a1 = 100;
				message->r2 = 240;
				message->g2 = 110;
				message->b2 = 0;
				message->a2 = 0;
				message->x = -1;		// Centered
				message->y = 0.7;
				message->fadein = 0.01;
				message->fadeout = 1.5;
				message->fxtime = 0.25;
				message->holdtime = 5;
				message->pName = szCustomName;
				message->pMessage = szCustomText;
			}

			for ( j = 0; j < maxHUDMessages; j++ )
			{
				if ( m_pMessages[j] )
				{
					// is this message already in the list
					if ( !strcmp( message->pMessage, m_pMessages[j]->pMessage ) )
					{
						return;
					}

					// get rid of any other messages in same location (only one displays at a time)
					if ( fabs( message->y - m_pMessages[j]->y ) < 0.0001 && fabs( message->x - m_pMessages[j]->x ) < 0.0001 )
					{
						if( !strcmp( m_pMessages[j]->pName, "Custom" ) )
						{
							delete[] m_pMessages[j]->pName;
							delete[] m_pMessages[j]->pMessage;
						}
						delete m_pMessages[j];
						m_pMessages[j] = NULL;
					}
				}
			}

			m_pMessages[i] = message;
			m_startTime[i] = time;
			return;
		}
	}
}


int CHudMessage::MsgFunc_HudText( const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	char *pString = reader.ReadString();

	MessageAdd( pString, gHUD.m_flTime );
	// Remember the time -- to fix up level transitions
	m_parms.time = gHUD.m_flTime;

	// Turn on drawing
	m_iFlags |= HUD_DRAW;

	return 1;
}


int CHudMessage::MsgFunc_GameTitle( const char *pszName,  int iSize, void *pbuf )
{
	m_pGameTitle = TextMessageGet( "GAMETITLE" );
	if ( m_pGameTitle != NULL )
	{
		m_gameTitleTime = gHUD.m_flTime;

		// Turn on drawing
		m_iFlags |= HUD_DRAW;
	}

	return 1;
}

void CHudMessage::MessageAdd(client_textmessage_t * newMessage )
{
	m_parms.time = gHUD.m_flTime;

	// Turn on drawing
	m_iFlags |= HUD_DRAW;
	
	for ( int i = 0; i < maxHUDMessages; i++ )
	{
		if ( !m_pMessages[i] )
		{
			m_pMessages[i] = newMessage;
			m_startTime[i] = gHUD.m_flTime;
			return;
		}
	}

}


int CHudMessage::MsgFunc_HudTextPro( const char *pszName, int iSize, void *pbuf )
{
	const char *sz;
	int hint;
	BufferReader reader( pszName, pbuf, iSize );
	sz = reader.ReadString();
	hint = reader.ReadByte();

	MessageAdd(sz, gHUD.m_flTime/*, hint, Newfont*/); // TODO

	// Remember the time -- to fix up level transitions
	m_parms.time = gHUD.m_flTime;

	// Turn on drawing
	m_iFlags |= HUD_DRAW;
	return 1;
}

int CHudMessage::MsgFunc_HudTextArgs( const char *pszName, int iSize, void *pbuf )
{
	/*BufferReader reader( pszName, pbuf, iSize );

	const char *sz = reader.ReadString();
	int hint = reader.ReadByte();

	MessageAdd(sz, gHUD.m_flTime, hint, Newfont); // TODO

	// Remember the time -- to fix up level transitions
	m_parms.time = gHUD.m_flTime;

	// Turn on drawing
	if ( !(m_iFlags & HUD_ACTIVE) )
		m_iFlags |= HUD_ACTIVE;*/

	return 1;
}

```

`cl_dll/hud/money.cpp`:

```cpp
/*
money.cpp -- Money HUD Widget
Copyright (C) 2015-2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/


#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include <string.h>
#include "vgui_parser.h"
#include "draw_util.h"
DECLARE_MESSAGE( m_Money, Money )
DECLARE_MESSAGE( m_Money, BlinkAcct )

int CHudMoney::Init( )
{
	HOOK_MESSAGE( Money );
	HOOK_MESSAGE( BlinkAcct );
	gHUD.AddHudElem(this);
	m_fFade = 0;
	m_iFlags = 0;
	return 1;
}

int CHudMoney::VidInit()
{
	m_hDollar.SetSpriteByName("dollar");
	m_hMinus.SetSpriteByName("minus");
	m_hPlus.SetSpriteByName("plus");

	return 1;
}

int CHudMoney::Draw(float flTime)
{
	if(( gHUD.m_iHideHUDDisplay & ( HIDEHUD_HEALTH ) ))
		return 1;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT))))
		return 1;

	int r, g, b, alphaBalance;
	m_fFade -= gHUD.m_flTimeDelta;
	if( m_fFade < 0)
	{
		m_fFade = 0.0f;
		m_iDelta = 0;
	}
	float interpolate = ( 5 - m_fFade ) / 5;

	int iDollarWidth = m_hDollar.rect.right - m_hDollar.rect.left;

	int x = ScreenWidth - iDollarWidth * 7;
	int y = MONEY_YPOS;

	if( m_iBlinkAmt )
	{
		m_fBlinkTime += gHUD.m_flTimeDelta;
		DrawUtils::UnpackRGB( r, g, b, m_fBlinkTime > 0.5f? RGB_REDISH : RGB_YELLOWISH );

		if( m_fBlinkTime > 1.0f )
		{
			m_fBlinkTime = 0.0f;
			--m_iBlinkAmt;
		}
	}
	else
	{
		if( m_iDelta != 0 )
		{
			int iDeltaR, iDeltaG, iDeltaB;
			int iDollarHeight = m_hDollar.rect.bottom - m_hDollar.rect.top;
			int iDeltaAlpha = 255 - interpolate * (255);

			DrawUtils::UnpackRGB  (iDeltaR, iDeltaG, iDeltaB, m_iDelta < 0 ? RGB_REDISH : RGB_GREENISH);
			DrawUtils::ScaleColors(iDeltaR, iDeltaG, iDeltaB, iDeltaAlpha);

			if( m_iDelta > 0 )
			{
				r = interpolate * ((RGB_YELLOWISH & 0xFF0000) >> 16);
				g = (RGB_GREENISH & 0xFF00) >> 8;
				b = (RGB_GREENISH & 0xFF);

				// draw delta
				SPR_Set(m_hPlus.spr, iDeltaR, iDeltaG, iDeltaB );
				SPR_DrawAdditive(0, x, y - iDollarHeight * 1.5, &m_hPlus.rect );
			}
			else if( m_iDelta < 0)
			{
				r = (RGB_REDISH & 0xFF0000) >> 16;
				g = ((RGB_REDISH & 0xFF00) >> 8) + interpolate * (((RGB_YELLOWISH & 0xFF00) >> 8) - ((RGB_REDISH & 0xFF00) >> 8));
				b = (RGB_REDISH & 0xFF) - interpolate * (RGB_REDISH & 0xFF);

				SPR_Set(m_hMinus.spr, iDeltaR, iDeltaG, iDeltaB );
				SPR_DrawAdditive(0, x, y - iDollarHeight * 1.5, &m_hMinus.rect );
			}

			DrawUtils::DrawHudNumber2( x + iDollarWidth, y - iDollarHeight * 1.5 , false, 5,
									   m_iDelta < 0 ? -m_iDelta : m_iDelta,
									   iDeltaR, iDeltaG, iDeltaB);
			FillRGBA(x + iDollarWidth / 4, y - iDollarHeight * 1.5 + gHUD.m_iFontHeight / 4, 2, 2, iDeltaR, iDeltaG, iDeltaB, iDeltaAlpha );
		}
		else DrawUtils::UnpackRGB(r, g, b, RGB_YELLOWISH );
	}

	alphaBalance = 255 - interpolate * (255 - MIN_ALPHA);


	DrawUtils::ScaleColors( r, g, b, alphaBalance );

	SPR_Set(m_hDollar.spr, r, g, b);
	SPR_DrawAdditive(0, x, y, &m_hDollar.rect);

	DrawUtils::DrawHudNumber2( x + iDollarWidth, y, false, 5, m_iMoneyCount, r, g, b );
	FillRGBA(x + iDollarWidth / 4, y + gHUD.m_iFontHeight / 4, 2, 2, r, g, b, alphaBalance );
	return 1;
}

int CHudMoney::MsgFunc_Money(const char *pszName, int iSize, void *pbuf)
{
	BufferReader buf( pszName, pbuf, iSize );
	int iOldCount = m_iMoneyCount;
	m_iMoneyCount = buf.ReadLong();
	m_iDelta = m_iMoneyCount - iOldCount;
	m_fFade = 5.0f; //fade for 5 seconds
	m_iFlags |= HUD_DRAW;
	return 1;
}

int CHudMoney::MsgFunc_BlinkAcct(const char *pszName, int iSize, void *pbuf)
{
	BufferReader buf( pszName, pbuf, iSize );

	m_iBlinkAmt = buf.ReadByte();
	m_fBlinkTime = 0;
	return 1;
}

```

`cl_dll/hud/nvg.cpp`:

```cpp
/*
nvg.cpp - Night Vision Googles
Copyright (C) 2015-2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.

*/

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "r_efx.h"
#include "dlight.h"

DECLARE_MESSAGE(m_NVG, NVGToggle)
DECLARE_COMMAND(m_NVG, NVGAdjustDown)
DECLARE_COMMAND(m_NVG, NVGAdjustUp)

int CHudNVG::Init()
{
	HOOK_MESSAGE(NVGToggle)
	HOOK_COMMAND("+nvgadjust", NVGAdjustUp);
	HOOK_COMMAND("-nvgadjust", NVGAdjustDown);

	cl_fancy_nvg = CVAR_CREATE( "cl_fancy_nvg", "0", FCVAR_ARCHIVE );

	gHUD.AddHudElem(this);
	m_iFlags = 0;
	m_iAlpha = 110; // 220 is max, 30 is min

   return 0;
}


int CHudNVG::Draw(float flTime)
{
	if( gEngfuncs.IsSpectateOnly() )
	{
		return 1;
	}

	gEngfuncs.pfnFillRGBABlend(0, 0, ScreenWidth, ScreenHeight, 50, 225, 50, m_iAlpha);

	// draw a dynamic light on player's origin
	if( cl_fancy_nvg->value )
	{
		// recreate new dlight every frame

		dlight_t *dl = gEngfuncs.pEfxAPI->CL_AllocDlight ( 0 );
		dl->origin = gHUD.m_vecOrigin;
		dl->radius = Com_RandomLong( 750, 800 );
		dl->die = flTime + 0.1f;
		dl->color.r = 50;
		dl->color.g = 255;
		dl->color.b = 50;
	}
	else
	{
		// recreate if died
		if( !m_pLight || m_pLight->die < flTime )
		{
			m_pLight = gEngfuncs.pEfxAPI->CL_AllocDlight( 0 );

			// I hope no one is crazy so much to keep NVG for 9999 seconds
			m_pLight->die = flTime + 9999.0f;
			m_pLight->color.r = 50;
			m_pLight->color.g = 255;
			m_pLight->color.b = 50;
		}

		// just update origin
		if( m_pLight )
		{
			m_pLight->origin = gHUD.m_vecOrigin;
			m_pLight->radius = Com_RandomLong( 750, 800 );
		}
	}
	return 1;
}

int CHudNVG::MsgFunc_NVGToggle(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	m_iFlags = reader.ReadByte() ? HUD_DRAW : 0;

	if( m_pLight )
	{
		m_pLight->die = 0; // engine will remove this immediately

		m_pLight = NULL; // it's safe to set it 0 now
	}
	return 1;
}

void CHudNVG::UserCmd_NVGAdjustDown()
{
	m_iAlpha = max( 220, m_iAlpha + 20 );
}

void CHudNVG::UserCmd_NVGAdjustUp()
{
	m_iAlpha = min( 30, m_iAlpha - 20 );
}

```

`cl_dll/hud/radar.cpp`:

```cpp
/*
radar.cpp - Radar
Copyright (C) 2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "draw_util.h"
#include "triangleapi.h"
#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

DECLARE_COMMAND( m_Radar, ShowRadar )
DECLARE_COMMAND( m_Radar, HideRadar )

DECLARE_MESSAGE( m_Radar, Radar )
DECLARE_MESSAGE( m_Radar, HostageK )
DECLARE_MESSAGE( m_Radar, HostagePos )
DECLARE_MESSAGE( m_Radar, BombDrop )
DECLARE_MESSAGE( m_Radar, BombPickup )


static byte	r_RadarCross[8][8] =
{
{1,1,0,0,0,0,1,1},
{1,1,1,0,0,1,1,1},
{0,1,1,1,1,1,1,0},
{0,0,1,1,1,1,0,0},
{0,0,1,1,1,1,0,0},
{0,1,1,1,1,1,1,0},
{1,1,1,0,0,1,1,1},
{1,1,0,0,0,0,1,1}
};

static byte	r_RadarT[8][8] =
{
{1,1,1,1,1,1,1,1},
{1,1,1,1,1,1,1,1},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0}
};

static byte	r_RadarFlippedT[8][8] =
{
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{0,0,0,1,1,0,0,0},
{1,1,1,1,1,1,1,1},
{1,1,1,1,1,1,1,1}
};

#define BLOCK_SIZE_MAX 1024

static byte	data2D[BLOCK_SIZE_MAX*4];	// intermediate texbuffer

int CHudRadar::Init()
{
	HOOK_MESSAGE( Radar );
	HOOK_COMMAND( "drawradar", ShowRadar );
	HOOK_COMMAND( "hideradar", HideRadar );
	HOOK_MESSAGE( HostageK );
	HOOK_MESSAGE( HostagePos );
	HOOK_MESSAGE( BombDrop );
	HOOK_MESSAGE( BombPickup );

	m_iFlags = HUD_DRAW;

	cl_radartype = CVAR_CREATE( "cl_radartype", "0", FCVAR_ARCHIVE );

	bTexturesInitialized = bUseRenderAPI = false;

	gHUD.AddHudElem( this );
	return 1;
}

void CHudRadar::Reset()
{
	// make radar don't draw old players after new map
	for( int i = 0; i < 34; i++ )
	{
		g_PlayerExtraInfo[i].radarflashes = 0;

		if( i <= MAX_HOSTAGES ) g_HostageInfo[i].radarflashes = 0;
	}
}

static void Radar_InitBitmap( int w, int h, byte *buf )
{
	for( int x = 0; x < w; x++ )
	{
		for( int y = 0; y < h; y++ )
		{
			data2D[(y * 8 + x) * 4 + 0] = 255;
			data2D[(y * 8 + x) * 4 + 1] = 255;
			data2D[(y * 8 + x) * 4 + 2] = 255;
			data2D[(y * 8 + x) * 4 + 3] = buf[y*h + x]  * 255;
		}
	}
}

int CHudRadar::InitBuiltinTextures( void )
{
	texFlags_t defFlags = (texFlags_t)(TF_NOMIPMAP | TF_NOPICMIP | TF_NEAREST | TF_CLAMP | TF_HAS_ALPHA);

	if( bTexturesInitialized )
		return 1;

	const struct
	{
		const char	*name;
		byte	*buf;
		int		*texnum;
		int		w, h;
		void	(*init)( int w, int h, byte *buf );
		int	texType;
	}
	textures[] =
	{
	{ "radarT",		   (byte*)r_RadarT,      &hT,		 8, 8, Radar_InitBitmap, TEX_CUSTOM },
	{ "radarcross",    (byte*)r_RadarCross,    &hCross,    8, 8, Radar_InitBitmap, TEX_CUSTOM },
	{ "radarflippedT", (byte*)r_RadarFlippedT, &hFlippedT, 8, 8, Radar_InitBitmap, TEX_CUSTOM }
	};
	size_t	i, num_builtin_textures = sizeof( textures ) / sizeof( textures[0] );

	for( i = 0; i < num_builtin_textures; i++ )
	{
		textures[i].init( textures[i].w, textures[i].h, textures[i].buf );
		*textures[i].texnum = gRenderAPI.GL_CreateTexture( textures[i].name, textures[i].w, textures[i].h, data2D, defFlags );
		if( *textures[i].texnum == 0 )
		{
			for( size_t j = 0; j < i; i++ )
			{
				gRenderAPI.GL_FreeTexture( *textures[i].texnum );
			}
			return 0;
		}

		gRenderAPI.GL_SetTextureType( *textures[i].texnum, textures[i].texType );
	}

	hDot = gRenderAPI.GL_LoadTexture( "*white", NULL, 0, 0 );

	bTexturesInitialized = true;

	return 1;
}

void CHudRadar::Shutdown( void )
{
	// GL_FreeTexture( hDot ); engine inner texture
	if( bTexturesInitialized )
	{
		gRenderAPI.GL_FreeTexture( hT );
		gRenderAPI.GL_FreeTexture( hFlippedT );
		gRenderAPI.GL_FreeTexture( hCross );
	}
}

int CHudRadar::VidInit(void)
{
	bUseRenderAPI = g_iXash && InitBuiltinTextures();

	m_hRadar.SetSpriteByName( "radar" );
	m_hRadarOpaque.SetSpriteByName( "radaropaque" );
	iMaxRadius = (m_hRadar.rect.right - m_hRadar.rect.left) / 2.0f;
	return 1;
}

void CHudRadar::UserCmd_HideRadar()
{
	m_iFlags &= ~HUD_DRAW;
}

void CHudRadar::UserCmd_ShowRadar()
{
	m_iFlags |= HUD_DRAW;
}

int CHudRadar::MsgFunc_Radar(const char *pszName,  int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int index = reader.ReadByte();
	g_PlayerExtraInfo[index].origin.x = reader.ReadCoord();
	g_PlayerExtraInfo[index].origin.y = reader.ReadCoord();
	g_PlayerExtraInfo[index].origin.z = reader.ReadCoord();
	return 1;
}

bool CHudRadar::FlashTime( float flTime, extra_player_info_t *pplayer )
{
	// radar flashing
	if( pplayer->radarflashes )
	{
		if( flTime > pplayer->radarflashtime )
		{
			pplayer->nextflash = !pplayer->nextflash;
			pplayer->radarflashtime += pplayer->radarflashtimedelta;
			pplayer->radarflashes--;
		}
	}
	else
	{
		return true;
	}

	return pplayer->nextflash;
}

bool CHudRadar::HostageFlashTime( float flTime, hostage_info_t *pplayer )
{
	// radar flashing
	if( pplayer->radarflashes )
	{
		if( flTime > pplayer->radarflashtime )
		{
			pplayer->nextflash = !pplayer->nextflash;
			pplayer->radarflashtime += pplayer->radarflashtimedelta;
			pplayer->radarflashes--;
		}
	}
	else
	{
		return false; // non-flashing hostage must be never drawn on radar!
	}

	return pplayer->nextflash;
}

void CHudRadar::DrawZAxis( Vector pos, int r, int g, int b, int a )
{
	const float diff = 128;

	if( pos.z > -diff && pos.z < diff )
	{
		DrawRadarDot( pos.x, pos.y, r, g, b, a );
	}
	else if( pos.z <= -diff )
	{
		// higher than player
		DrawT( pos.x, pos.y, r, g, b, a );
	}
	else
	{
		// lower than player
		DrawFlippedT( pos.x, pos.y, r, g, b, a );
	}
}

int CHudRadar::Draw(float flTime)
{
	if ( (gHUD.m_iHideHUDDisplay & HIDEHUD_HEALTH) ||
		 gEngfuncs.IsSpectateOnly() ||
		 !(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT))) ||
		 gHUD.m_fPlayerDead )
		return 1;

	int iTeamNumber = g_PlayerExtraInfo[ gHUD.m_Scoreboard.m_iPlayerNum ].teamnumber;
	int r, g, b;

	if( cl_radartype->value )
	{
		SPR_Set(m_hRadarOpaque.spr, 200, 200, 200);
		SPR_DrawHoles(0, 0, 0, &m_hRadarOpaque.rect);
	}
	else
	{
		SPR_Set( m_hRadar.spr, 25, 75, 25 );
		SPR_DrawAdditive( 0, 0, 0, &m_hRadarOpaque.rect );
	}

	if( bUseRenderAPI )
	{
		gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
		gEngfuncs.pTriAPI->CullFace( TRI_NONE );
		gEngfuncs.pTriAPI->Brightness( 1 );
		gRenderAPI.GL_SelectTexture( 0 );
	}

	for(int i = 0; i < 33; i++)
	{
		// skip local player and dead players
		if( i == gHUD.m_Scoreboard.m_iPlayerNum || g_PlayerExtraInfo[i].dead )
			continue;

		// skip non-teammates
		if( g_PlayerExtraInfo[i].teamnumber != iTeamNumber )
			continue;

		// decide should player draw at this time. For flashing.
		// Always true for non-flashing players
		if( !FlashTime( flTime, &g_PlayerExtraInfo[i]) )
			continue;

		// player with C4 must be red
		if( g_PlayerExtraInfo[i].has_c4 )
		{
			DrawUtils::UnpackRGB( r, g, b, RGB_REDISH );
		}
		else
		{
			// white
			DrawUtils::UnpackRGB( r, g, b, RGB_WHITE );
		}

		// calc radar position
		Vector pos = WorldToRadar(gHUD.m_vecOrigin, g_PlayerExtraInfo[i].origin, gHUD.m_vecAngles);

		DrawZAxis( pos, r, g, b, 255 );
	}

	// Terrorist specific code( C4 Bomb )
	if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_TERRORIST )
	{
		if ( !g_PlayerExtraInfo[33].dead &&
			 g_PlayerExtraInfo[33].radarflashes &&
			 FlashTime( flTime, &g_PlayerExtraInfo[33] ))
		{
			Vector pos = WorldToRadar(gHUD.m_vecOrigin, g_PlayerExtraInfo[33].origin, gHUD.m_vecAngles);
			if( g_PlayerExtraInfo[33].playerclass ) // bomb planted
			{
				DrawCross( pos.x, pos.y, 255, 0, 0, 255 );
			}
			else
			{
				DrawZAxis( pos, 255, 0, 0, 255 );
			}
		}
	}
	// Counter-Terrorist specific code( hostages )
	else if( g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].teamnumber == TEAM_CT )
	{
		// draw hostages for CT
		for( int i = 0; i < MAX_HOSTAGES; i++ )
		{
			if( !HostageFlashTime( flTime, g_HostageInfo + i ) )
			{
				continue;
			}

			Vector pos = WorldToRadar(gHUD.m_vecOrigin, g_HostageInfo[i].origin, gHUD.m_vecAngles);
			if( g_HostageInfo[i].dead )
			{
				DrawZAxis( pos, 255, 0, 0, 255 );
			}
			else
			{
				DrawZAxis( pos, 4, 25, 110, 255 );
			}
		}
	}

	return 0;
}

void CHudRadar::DrawPlayerLocation()
{
	DrawUtils::DrawConsoleString( 30, 30, g_PlayerExtraInfo[gHUD.m_Scoreboard.m_iPlayerNum].location );
}

inline void CHudRadar::DrawColoredTexture( int x, int y, int size, byte r, byte g, byte b, byte a, int texHandle )
{
	gRenderAPI.GL_Bind( 0, texHandle );
	gEngfuncs.pTriAPI->Color4ub( r, g, b, a );
	DrawUtils::Draw2DQuad( (iMaxRadius + x - size * 2) * gHUD.m_flScale,
						   (iMaxRadius + y - size * 2) * gHUD.m_flScale,
						   (iMaxRadius + x + size * 2) * gHUD.m_flScale,
						   (iMaxRadius + y + size * 2) * gHUD.m_flScale);
}


void CHudRadar::DrawRadarDot( int x, int y, int r, int g, int b, int a )
{
	const int size = 1;
	if( bUseRenderAPI )
	{
		DrawColoredTexture( x, y, size, r, g, b, a, hDot );
	}
	else
	{
		FillRGBA(iMaxRadius + x - size*2, iMaxRadius + y - size*2, size*4, size*4, r, g, b, a);
	}
}


void CHudRadar::DrawCross( int x, int y, int r, int g, int b, int a )
{
	const int size = 2;
	if( bUseRenderAPI )
	{
		DrawColoredTexture( x, y, size, r, g, b, a, hCross );
	}
	else
	{
		FillRGBA(iMaxRadius + x, iMaxRadius + y, size, size, r, g, b, a);
		FillRGBA(iMaxRadius + x - size, iMaxRadius + y - size, size, size, r, g, b, a);
		FillRGBA(iMaxRadius + x - size, iMaxRadius + y + size, size, size, r, g, b, a);
		FillRGBA(iMaxRadius + x + size, iMaxRadius + y - size, size, size, r, g, b, a);
		FillRGBA(iMaxRadius + x + size, iMaxRadius + y + size, size, size, r, g, b, a);
	}
}

void CHudRadar::DrawT( int x, int y, int r, int g, int b, int a )
{
	const int size = 2;

	if( bUseRenderAPI )
	{
		DrawColoredTexture( x, y, size, r, g, b, a, hT );
	}
	else
	{
		FillRGBA( iMaxRadius + x - size, iMaxRadius + y - size, size * 3, size, r, g, b, a);
		FillRGBA( iMaxRadius + x, iMaxRadius + y, size, size * 2, r, g, b, a);
	}
}

void CHudRadar::DrawFlippedT( int x, int y, int r, int g, int b, int a )
{
	const int size = 2;
	if( bUseRenderAPI )
	{
		DrawColoredTexture( x, y, size, r, g, b, a, hFlippedT );
	}
	else
	{
		FillRGBA( iMaxRadius + x, iMaxRadius + y - size, size, size*2, r, g, b, a);
		FillRGBA( iMaxRadius + x - size, iMaxRadius + y + size, size*3, size, r, g, b, a);
	}
}


Vector CHudRadar::WorldToRadar(const Vector vPlayerOrigin, const Vector vObjectOrigin, const Vector vAngles  )
{
	Vector2D diff = vObjectOrigin.Make2D() - vPlayerOrigin.Make2D();
	const float RADAR_SCALE = 32.0f;

	// Supply epsilon values to avoid divide-by-zero
	if( diff.x == 0 )
		diff.x = 0.00001f;
	if( diff.y == 0 )
		diff.y = 0.00001f;

	float flOffset = DEG2RAD( vAngles.y - RAD2DEG( atan2( diff.y, diff.x ) ) );

	// this magic 32.0f just scales position on radar
	float iRadius = min( diff.Length() / RADAR_SCALE, iMaxRadius );

	// transform origin difference to radar source
	Vector ret( (float)(iRadius * sin(flOffset)),
				(float)(iRadius * -cos(flOffset)),
				(float)(vPlayerOrigin.z - vObjectOrigin.z) );

	return ret;
}

int CHudRadar::MsgFunc_BombDrop(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	g_PlayerExtraInfo[33].origin.x = reader.ReadCoord();
	g_PlayerExtraInfo[33].origin.y = reader.ReadCoord();
	g_PlayerExtraInfo[33].origin.z = reader.ReadCoord();

	g_PlayerExtraInfo[33].radarflashes = 99999;
	g_PlayerExtraInfo[33].radarflashtime = gHUD.m_flTime;
	g_PlayerExtraInfo[33].radarflashtimedelta = 0.5f;
	strncpy(g_PlayerExtraInfo[33].teamname, "TERRORIST", MAX_TEAM_NAME);
	g_PlayerExtraInfo[33].dead = false;
	g_PlayerExtraInfo[33].nextflash = true;

	int Flag = reader.ReadByte();
	g_PlayerExtraInfo[33].playerclass = Flag;

	if( Flag ) // bomb planted
	{
		gHUD.m_SpectatorGui.m_bBombPlanted = 0;
		gHUD.m_Timer.m_iFlags = 0;
	}
	return 1;
}

int CHudRadar::MsgFunc_BombPickup(const char *pszName, int iSize, void *pbuf)
{
	g_PlayerExtraInfo[33].radarflashes = false;
	g_PlayerExtraInfo[33].dead = true;

	return 1;
}

int CHudRadar::MsgFunc_HostagePos(const char *pszName, int iSize, void *pbuf)
{

	BufferReader reader( pszName, pbuf, iSize );
	int Flag = reader.ReadByte();
	int idx = reader.ReadByte();
	if( idx <= MAX_HOSTAGES )
	{
		g_HostageInfo[idx].origin.x = reader.ReadCoord();
		g_HostageInfo[idx].origin.y = reader.ReadCoord();
		g_HostageInfo[idx].origin.z = reader.ReadCoord();
		g_HostageInfo[idx].dead = false;

		if( Flag == 1 ) // first message about this hostage, start flashing
		{
			g_HostageInfo[idx].radarflashes = 99999;
			g_HostageInfo[idx].radarflashtime = gHUD.m_flTime;
			g_HostageInfo[idx].radarflashtimedelta = 0.5f;
		}
	}

	return 1;
}

int CHudRadar::MsgFunc_HostageK(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );
	int idx = reader.ReadByte();
	if ( idx <= MAX_HOSTAGES )
	{
		g_HostageInfo[idx].dead = true;
		g_HostageInfo[idx].radarflashtime = gHUD.m_flTime;
		g_HostageInfo[idx].radarflashes = 15;
		g_HostageInfo[idx].radarflashtimedelta = 0.1f;
	}

	return 1;
}

```

`cl_dll/hud/radio.cpp`:

```cpp
/*
radio.cpp -- Radio HUD implementation
Copyright (C) 2015-2016 a1batross
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/
#include "hud.h"
#include "parsemsg.h"
#include "cl_util.h"
#include "r_efx.h"
#include "event_api.h"
#include "com_model.h"
#include <string.h>

DECLARE_MESSAGE( m_Radio, SendAudio )
DECLARE_MESSAGE( m_Radio, ReloadSound )
DECLARE_MESSAGE( m_Radio, BotVoice )

int CHudRadio::Init( )
{
	HOOK_MESSAGE( SendAudio );
	HOOK_MESSAGE( ReloadSound );
	HOOK_MESSAGE( BotVoice );
	gHUD.AddHudElem( this );
	m_iFlags = 0;
	return 1;
}


void Broadcast( const char *msg, int pitch )
{
	if ( msg[0] == '%' && msg[1] == '!' )
		gEngfuncs.pfnPlaySoundVoiceByName( &msg[1], 1.0f, pitch );
	else
		gEngfuncs.pfnPlaySoundVoiceByName( msg, 1.0f, pitch );
}

int CHudRadio::MsgFunc_SendAudio( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int SenderID = reader.ReadByte( );
	char *sentence = reader.ReadString( );
	int pitch = reader.ReadShort( );

	Broadcast( sentence, pitch );

	if( SenderID <= MAX_PLAYERS )
	{
		g_PlayerExtraInfo[SenderID].radarflashes = 22;
		g_PlayerExtraInfo[SenderID].radarflashtime = gHUD.m_flTime;
		g_PlayerExtraInfo[SenderID].radarflashtimedelta = 0.5f;
	}
	return 1;
}

int CHudRadio::MsgFunc_ReloadSound( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int vol = reader.ReadByte( );
	if ( reader.ReadByte( ) )
	{
		gEngfuncs.pfnPlaySoundByName( "weapon/generic_reload.wav", vol / 255.0f );
	}
	else
	{
		gEngfuncs.pfnPlaySoundByName( "weapon/generic_shot_reload.wav", vol / 255.0f );
	}
	return 1;
}


static void VoiceIconCallback(struct tempent_s *ent, float frametime, float currenttime)
{
	int entIndex = ent->clientIndex;
	if( !g_PlayerExtraInfo[entIndex].talking )
	{
		g_PlayerExtraInfo[entIndex].talking = false;
		ent->die = 0.0f;
	}
}

void CHudRadio::Voice(int entindex, bool bTalking)
{
	extra_player_info_t *pplayer;
	TEMPENTITY *temp;
	int spr;

	if( entindex < 0 || entindex > MAX_PLAYERS - 1) // bomb can't talk!
		return;

	pplayer = g_PlayerExtraInfo + entindex;

	if( bTalking == pplayer->talking )
		return; // user is talking already

	if( !bTalking && pplayer->talking )
	{
		pplayer->talking = false;
		return; // stop talking
	}

	spr = gEngfuncs.pEventAPI->EV_FindModelIndex( "sprites/voiceicon.spr" );
	if( !spr ) return;

	temp = gEngfuncs.pEfxAPI->R_DefaultSprite( vec3_origin, spr, 0 );
	if( !temp ) return;

	pplayer->talking = true; // sprite is created

	temp->flags = FTENT_SPRANIMATELOOP | FTENT_CLIENTCUSTOM | FTENT_PLYRATTACHMENT;
	temp->tentOffset.z = 40;
	temp->clientIndex = entindex;
	temp->callback = VoiceIconCallback;
	temp->entity.curstate.scale = 0.60f;
	temp->entity.curstate.rendermode = kRenderTransAdd;
	temp->die = gHUD.m_flTime + 60.0f; // 60 seconds must be enough?
}

int CHudRadio::MsgFunc_BotVoice( const char *pszName, int iSize, void *buf )
{
	BufferReader reader( pszName, buf, iSize );

	int enable   = reader.ReadByte();
	int entIndex = reader.ReadByte();

	Voice( entIndex, enable );

	return 1;
}

```

`cl_dll/hud/saytext.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// saytext.cpp
//
// implementation of CHudSayText class
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include "vgui_parser.h"
#include "draw_util.h"
#include "com_weapons.h"
//#include "vgui_TeamFortressViewport.h"

extern float *GetClientColor( int clientIndex );

#define MAX_LINES	5
#define MAX_CHARS_PER_LINE	256  /* it can be less than this, depending on char size */

// allow 20 pixels on either side of the text
#define MAX_LINE_WIDTH  ( ScreenWidth - 40 )
#define LINE_START  10

static char g_szLineBuffer[ MAX_LINES + 1 ][ MAX_CHARS_PER_LINE ];
static float *g_pflNameColors[ MAX_LINES + 1 ];
static int g_iNameLengths[ MAX_LINES + 1 ];
static float flScrollTime = 0;  // the time at which the lines next scroll up

static int Y_START = 0;
static int line_height = 0;

DECLARE_MESSAGE( m_SayText, SayText )

int CHudSayText :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( SayText );

	InitHUDData();

	m_HUD_saytext =			gEngfuncs.pfnRegisterVariable( "hud_saytext", "1", 0 );
	m_HUD_saytext_time =	gEngfuncs.pfnRegisterVariable( "hud_saytext_time", "5", 0 );

	m_iFlags |= HUD_INTERMISSION; // is always drawn during an intermission

	return 1;
}


void CHudSayText :: InitHUDData( void )
{
	memset( g_szLineBuffer, 0, sizeof g_szLineBuffer );
	memset( g_pflNameColors, 0, sizeof g_pflNameColors );
	memset( g_iNameLengths, 0, sizeof g_iNameLengths );
}

int CHudSayText :: VidInit( void )
{
	return 1;
}


int ScrollTextUp( void )
{
	g_szLineBuffer[MAX_LINES][0] = 0;
	memmove( g_szLineBuffer[0], g_szLineBuffer[1], sizeof(g_szLineBuffer) - sizeof(g_szLineBuffer[0]) ); // overwrite the first line
	memmove( &g_pflNameColors[0], &g_pflNameColors[1], sizeof(g_pflNameColors) - sizeof(g_pflNameColors[0]) );
	memmove( &g_iNameLengths[0], &g_iNameLengths[1], sizeof(g_iNameLengths) - sizeof(g_iNameLengths[0]) );
	g_szLineBuffer[MAX_LINES-1][0] = 0;

	if ( g_szLineBuffer[0][0] == ' ' ) // also scroll up following lines
	{
		g_szLineBuffer[0][0] = 2;
		return 1 + ScrollTextUp();
	}

	return 1;
}

int CHudSayText :: Draw( float flTime )
{
	int y = Y_START;

	//if ( ( gViewPort && gViewPort->AllowedToPrintText() == FALSE) || !m_HUD_saytext->value )
		//return 1;

	// make sure the scrolltime is within reasonable bounds,  to guard against the clock being reset
	flScrollTime = min( flScrollTime, flTime + m_HUD_saytext_time->value );

	// make sure the scrolltime is within reasonable bounds,  to guard against the clock being reset
	flScrollTime = min( flScrollTime, flTime + m_HUD_saytext_time->value );

	if ( flScrollTime <= flTime )
	{
		if ( *g_szLineBuffer[0] )
		{
			flScrollTime = flTime + m_HUD_saytext_time->value;
			// push the console up
			ScrollTextUp();
		}
		else
		{ // buffer is empty,  just disable drawing of this section
			m_iFlags &= ~HUD_DRAW;
		}
	}

	for ( int i = 0; i < MAX_LINES; i++ )
	{
		if ( *g_szLineBuffer[i] )
		{
			if ( *g_szLineBuffer[i] == 2 && g_pflNameColors[i] )
			{
				// it's a saytext string
				static char buf[MAX_PLAYER_NAME_LENGTH+32];

				// draw the first x characters in the player color
				strncpy( buf, g_szLineBuffer[i], min(g_iNameLengths[i], MAX_PLAYER_NAME_LENGTH+32) );
				buf[ min(g_iNameLengths[i], MAX_PLAYER_NAME_LENGTH+31) ] = 0;
				DrawUtils::SetConsoleTextColor( g_pflNameColors[i][0], g_pflNameColors[i][1], g_pflNameColors[i][2] );
				int x = DrawUtils::DrawConsoleString( LINE_START, y, buf );

				// color is reset after each string draw
				DrawUtils::DrawConsoleString( x, y, g_szLineBuffer[i] + g_iNameLengths[i] );
			}
			else
			{
				// normal draw
				DrawUtils::DrawConsoleString( LINE_START, y, g_szLineBuffer[i] );
			}
		}

		y += line_height;
	}


	return 1;
}

enum
{
	CHAT_CT = 0,
	CHAT_T,
	CHAT_CT_DEAD,
	CHAT_T_DEAD,
	CHAT_SPEC,
	CHAT_ALL,
	CHAT_ALLDEAD,
	CHAT_ALLSPEC,
	CHAT_NAME_CHANGE
};

struct CSimpleMap
{
	const char key[32];
	const char value[64];
};

CSimpleMap sayTextFmt[] =
{
{"#Cstrike_Chat_CT",	"\x02(Counter-Terrorist) %s :  %s"},
{"#Cstrike_Chat_T", "\x02(Terrorist) %s :  %s"},
{"#Cstrike_Chat_CT_Dead", "\x02*DEAD*(Counter-Terrorist) %s :  %s"},
{"#Cstrike_Chat_T_Dead", "\x02*DEAD*(Terrorist) %s :  %s"},
{"#Cstrike_Chat_Spec", "\x02(Spectator) %s :  %s"},
{"#Cstrike_Chat_All", "\x02%s :  %s"},
{"#Cstrike_Chat_AllDead", "\x02*DEAD* %s:  %s"},
{"#Cstrike_Chat_AllSpec", "\x02*SPEC* %s:  %s"},
{"#Cstrike_Name_Change", "\x02* %s changed name to %s"},
};

int CHudSayText :: MsgFunc_SayText( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	char szBuf[3][64] = { 0 };

	int client_index = reader.ReadByte();		// the client who spoke the message
	strncpy( szBuf[0], reader.ReadString(), sizeof(szBuf[0]));
	strncpy( szBuf[1], reader.ReadString(), sizeof(szBuf[1]));
	strncpy( szBuf[2], reader.ReadString(), sizeof(szBuf[2]));

	const char *fmt =  "\x02%s";
	int i = 0;
	for( i = CHAT_CT; i < CHAT_NAME_CHANGE; i++ )
	{
		if( !strncmp( szBuf[0], sayTextFmt[i].key, sizeof( szBuf ) ) )
		{
			fmt = sayTextFmt[i].value;
			break;
		}
	}


#if 1
	// If text is sent from dead player or spectator
	// don't draw it, until local player isn't specator or dead.
	switch( i )
	{
	case CHAT_CT_DEAD:
	case CHAT_T_DEAD:
	case CHAT_ALLDEAD:
	case CHAT_ALLSPEC:
	case CHAT_SPEC:
		if( !CL_IsDead() && !g_iUser1 )
			return 1;
	}
#endif

	char dst[256];
	if( i == CHAT_NAME_CHANGE )
	{
		snprintf( dst, sizeof( dst ), fmt, szBuf[1], szBuf[2]);
	}
	else if( szBuf[1][0] == '\0' && szBuf[2][0] == '\0' )
	{
		snprintf( dst, sizeof( dst ), fmt, szBuf[0] );
	}
	else
	{
		GetPlayerInfo( client_index, &g_PlayerInfoList[client_index] );
		const char *pName = g_PlayerInfoList[client_index].name;
		snprintf( dst, sizeof( dst ), fmt, pName, szBuf[2]);
	}
	SayTextPrint( dst, strlen(dst),  client_index );
	
	return 1;
}

void CHudSayText :: SayTextPrint( const char *pszBuf, int iBufSize, int clientIndex )
{
	// find an empty string slot
	int i;
	for ( i = 0; i < MAX_LINES; i++ )
	{
		if ( ! *g_szLineBuffer[i] )
			break;
	}
	if ( i == MAX_LINES )
	{
		// force scroll buffer up
		ScrollTextUp();
		i = MAX_LINES - 1;
	}

	g_iNameLengths[i] = 0;
	g_pflNameColors[i] = NULL;

#if 1
	// if it's a say message, search for the players name in the string
	if ( *pszBuf == 2 && clientIndex > 0 )
	{
		GetPlayerInfo( clientIndex, &g_PlayerInfoList[clientIndex] );
		const char *pName = g_PlayerInfoList[clientIndex].name;

		if ( pName )
		{
			const char *nameInString = strstr( pszBuf, pName );

			if ( nameInString )
			{
				g_iNameLengths[i] = strlen( pName ) + (nameInString - pszBuf);
				g_pflNameColors[i] = GetClientColor( clientIndex );
			}
		}
	}
#endif


	strncpy( g_szLineBuffer[i], pszBuf, max(iBufSize -1, MAX_CHARS_PER_LINE-1) );

	// make sure the text fits in one line
	EnsureTextFitsInOneLineAndWrapIfHaveTo( i );

	// Set scroll time
	if ( i == 0 )
	{
		flScrollTime = gHUD.m_flTime + m_HUD_saytext_time->value;
	}

	m_iFlags |= HUD_DRAW;
	PlaySound( "misc/talk.wav", 1 );

	if( !g_iUser1 )
	{
		Y_START = ScreenHeight - 60;
	}
	else
	{
		Y_START = ScreenHeight * 4 / 5;
	}
	Y_START -= (line_height * (MAX_LINES+1));

}

void CHudSayText :: EnsureTextFitsInOneLineAndWrapIfHaveTo( int line )
{
	int line_width = 0;
	DrawUtils::ConsoleStringSize(g_szLineBuffer[line], &line_width, &line_height );

	if ( (line_width + LINE_START) > MAX_LINE_WIDTH )
	{ // string is too long to fit on line
		// scan the string until we find what word is too long,  and wrap the end of the sentence after the word
		int length = LINE_START;
		int tmp_len = 0;
		char *last_break = NULL;
		for ( char *x = g_szLineBuffer[line]; *x != 0; x++ )
		{
			// check for a color change, if so skip past it
			if ( x[0] == '/' && x[1] == '(' )
			{
				x += 2;
				// skip forward until past mode specifier
				while ( *x != 0 && *x != ')' )
					x++;

				if ( *x != 0 )
					x++;

				if ( *x == 0 )
					break;
			}

			char buf[2];
			buf[1] = 0;

			if ( *x == ' ' && x != g_szLineBuffer[line] )  // store each line break,  except for the very first character
				last_break = x;

			buf[0] = *x;  // get the length of the current character
			DrawUtils::ConsoleStringSize( buf, &tmp_len, &line_height );
			length += tmp_len;

			if ( length > MAX_LINE_WIDTH )
			{  // needs to be broken up
				if ( !last_break )
					last_break = x-1;

				x = last_break;

				// find an empty string slot
				int j;
				do 
				{
					for ( j = 0; j < MAX_LINES; j++ )
					{
						if ( ! *g_szLineBuffer[j] )
							break;
					}
					if ( j == MAX_LINES )
					{
						// need to make more room to display text, scroll stuff up then fix the pointers
						int linesmoved = ScrollTextUp();
						line -= linesmoved;
						last_break = last_break - (sizeof(g_szLineBuffer[0]) * linesmoved);
					}
				}
				while ( j == MAX_LINES );

				// copy remaining string into next buffer,  making sure it starts with a space character
				if ( (char)*last_break == (char)' ' )
				{
					int linelen = strlen(g_szLineBuffer[j]);
					int remaininglen = strlen(last_break);

					if ( (linelen - remaininglen) <= MAX_CHARS_PER_LINE )
						strcat( g_szLineBuffer[j], last_break );
				}
				else
				{
					if ( (strlen(g_szLineBuffer[j]) - strlen(last_break) - 2) < MAX_CHARS_PER_LINE )
					{
						strcat( g_szLineBuffer[j], " " );
						strcat( g_szLineBuffer[j], last_break );
					}
				}

				*last_break = 0; // cut off the last string

				EnsureTextFitsInOneLineAndWrapIfHaveTo( j );
				break;
			}
		}
	}
}

```

`cl_dll/hud/scoreboard.cpp`:

```cpp
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Scoreboard.cpp
//
// implementation of CHudScoreboard class
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "triangleapi.h"
#include "com_weapons.h"
#include "cdll_dll.h"

#include <string.h>
#include <stdio.h>
#include "draw_util.h"

hud_player_info_t   g_PlayerInfoList[MAX_PLAYERS+1]; // player info from the engine
extra_player_info_t	g_PlayerExtraInfo[MAX_PLAYERS+1]; // additional player info sent directly to the client dll
team_info_t         g_TeamInfo[MAX_TEAMS+1];
hostage_info_t      g_HostageInfo[MAX_HOSTAGES+1];
int g_iUser1;
int g_iUser2;
int g_iUser3;
int g_iTeamNumber;


// X positions

int xstart, xend;
int ystart, yend;
// relative to the side of the scoreboard
inline int NAME_POS_START()		{ return xstart + 15; }
inline int NAME_POS_END()		{ return xend - 210; }
// 10 pixels gap
inline int ATTRIB_POS_START()	{ return xend - 210; }
inline int ATTRIB_POS_END()		{ return xend - 150; }
// 10 pixels gap
inline int KILLS_POS_START()	{ return xend - 140; }
inline int KILLS_POS_END()		{ return xend - 110; }
// 10 pixels gap
inline int DEATHS_POS_START()	{ return xend - 100; }
inline int DEATHS_POS_END()		{ return xend - 40; }
// 20 pixels gap
inline int PING_POS_START()		{ return xend - 40; }
inline int PING_POS_END()		{ return xend - 10; }

//#include "vgui_TeamFortressViewport.h"

DECLARE_COMMAND( m_Scoreboard, ShowScores )
DECLARE_COMMAND( m_Scoreboard, HideScores )
DECLARE_COMMAND( m_Scoreboard, ShowScoreboard2 )
DECLARE_COMMAND( m_Scoreboard, HideScoreboard2 )

DECLARE_MESSAGE( m_Scoreboard, ScoreInfo )
DECLARE_MESSAGE( m_Scoreboard, TeamInfo )
DECLARE_MESSAGE( m_Scoreboard, TeamScore )

int CHudScoreboard :: Init( void )
{
	gHUD.AddHudElem( this );

	// Hook messages & commands here
	HOOK_COMMAND( "+showscores", ShowScores );
	HOOK_COMMAND( "-showscores", HideScores );
	HOOK_COMMAND( "showscoreboard2", ShowScoreboard2 );
	HOOK_COMMAND( "hidescoreboard2", HideScoreboard2 );

	HOOK_MESSAGE( ScoreInfo );
	HOOK_MESSAGE( TeamScore );
	HOOK_MESSAGE( TeamInfo );

	InitHUDData();

	cl_showpacketloss = CVAR_CREATE( "cl_showpacketloss", "0", FCVAR_ARCHIVE );

	return 1;
}


int CHudScoreboard :: VidInit( void )
{
	xstart = ScreenWidth * 0.125f;
	xend = ScreenWidth - xstart;
	ystart = 100;
	yend = ScreenHeight - ystart;
	m_bForceDraw = false;

	// Load sprites here
	return 1;
}

void CHudScoreboard :: InitHUDData( void )
{
	memset( g_PlayerExtraInfo, 0, sizeof g_PlayerExtraInfo );
	m_iLastKilledBy = 0;
	m_fLastKillTime = 0;
	m_iPlayerNum = 0;
	m_iNumTeams = 0;
	memset( g_TeamInfo, 0, sizeof g_TeamInfo );

	m_iFlags &= ~HUD_DRAW;  // starts out inactive

	m_iFlags |= HUD_INTERMISSION; // is always drawn during an intermission
}

// Y positions
#define ROW_GAP  15

int CHudScoreboard :: Draw( float flTime )
{
	if( !m_bForceDraw )
	{
		if ( (!m_bShowscoresHeld && gHUD.m_Health.m_iHealth > 0 && !gHUD.m_iIntermission) )
			return 1;
		else
		{
			xstart     = 0.125f * ScreenWidth;
			xend       = ScreenWidth - xstart;
			ystart     = 90;
			yend       = ScreenHeight - ystart;
			m_colors.r = 0;
			m_colors.g = 0;
			m_colors.b = 0;
			m_colors.a = 153;
			m_bDrawStroke = true;
		}
	}

	return DrawScoreboard(flTime);
}

int CHudScoreboard :: DrawScoreboard( float fTime )
{
	GetAllPlayersInfo();
	char ServerName[90];

//	Packetloss removed on Kelly 'shipping nazi' Bailey's orders
//	if ( cl_showpacketloss && cl_showpacketloss->value && ( ScreenWidth >= 400 ) )
//	{
//		can_show_packetloss = 1;
//	}

	// just sort the list on the fly
	// list is sorted first by frags, then by deaths
	float list_slot = 0;

	// print the heading line

	DrawUtils::DrawRectangle(xstart, ystart, xend - xstart, yend - ystart,
		m_colors.r, m_colors.g, m_colors.b, m_colors.a, m_bDrawStroke);

	int ypos = ystart + (list_slot * ROW_GAP) + 5;

	if( gHUD.m_szServerName[0] )
		snprintf( ServerName, 80, "%s SERVER: %s", (char*)(gHUD.m_Teamplay ? "TEAMS" : "PLAYERS"), gHUD.m_szServerName );
	else
		strncpy( ServerName, gHUD.m_Teamplay ? "TEAMS" : "PLAYERS", 80 );

	DrawUtils::DrawHudString( NAME_POS_START(), ypos, NAME_POS_END(), ServerName, 255, 140, 0 );
	DrawUtils::DrawHudStringReverse( KILLS_POS_END(), ypos, 0, "KILLS", 255, 140, 0 );
	DrawUtils::DrawHudString( DEATHS_POS_START(), ypos, DEATHS_POS_END(), "DEATHS", 255, 140, 0 );
	DrawUtils::DrawHudStringReverse( PING_POS_END(), ypos, PING_POS_START(), "PING", 255, 140, 0 );

	list_slot += 2;
	ypos = ystart + (list_slot * ROW_GAP);
	FillRGBA( xstart, ypos, xend - xstart, 1, 255, 140, 0, 255);  // draw the separator line
	
	list_slot += 0.8;

	if ( gHUD.m_Teamplay )
	{
		DrawTeams( list_slot );
	}
	else
	{
		// it's not teamplay,  so just draw a simple player list
		DrawPlayers( list_slot );
	}
	return 1;
}

int CHudScoreboard :: DrawTeams( float list_slot )
{
	int j;
	int ypos = ystart + (list_slot * ROW_GAP) + 5;

	// clear out team scores
	for ( int i = 1; i <= m_iNumTeams; i++ )
	{
		if ( !g_TeamInfo[i].scores_overriden )
			g_TeamInfo[i].frags = g_TeamInfo[i].deaths = 0;
		g_TeamInfo[i].sumping = 0;
		g_TeamInfo[i].players = 0;
		g_TeamInfo[i].already_drawn = FALSE;
	}

	// recalc the team scores, then draw them
	for ( int i = 1; i < MAX_PLAYERS; i++ )
	{
		if ( !g_PlayerInfoList[i].name || !g_PlayerInfoList[i].name[0] )
			continue; // empty player slot, skip

		if ( g_PlayerExtraInfo[i].teamname[0] == 0 )
			continue; // skip over players who are not in a team

		// find what team this player is in
		for ( j = 1; j <= m_iNumTeams; j++ )
		{
			if ( !stricmp( g_PlayerExtraInfo[i].teamname, g_TeamInfo[j].name ) )
				break;
		}

		if ( j > m_iNumTeams )  // player is not in a team, skip to the next guy
			continue;

		if ( !g_TeamInfo[j].scores_overriden )
		{
			g_TeamInfo[j].frags += g_PlayerExtraInfo[i].frags;
			g_TeamInfo[j].deaths += g_PlayerExtraInfo[i].deaths;
		}

		g_TeamInfo[j].sumping += g_PlayerInfoList[i].ping;

		if ( g_PlayerInfoList[i].thisplayer )
			g_TeamInfo[j].ownteam = TRUE;
		else
			g_TeamInfo[j].ownteam = FALSE;

		g_TeamInfo[j].players++;
	}

	// Draw the teams
	int iSpectatorPos = -1;

	while( true )
	{
		int highest_frags = -99999; int lowest_deaths = 99999;
		int best_team = 0;

		for ( int i = 1; i <= m_iNumTeams; i++ )
		{
			// don't draw team without players
			if ( g_TeamInfo[i].players <= 0 )
				continue;

			if (!strnicmp(g_TeamInfo[i].name, "SPECTATOR", MAX_TEAM_NAME))
			{
				iSpectatorPos = i;
				continue;
			}

			if ( !g_TeamInfo[i].already_drawn && g_TeamInfo[i].frags >= highest_frags )
			{
				if ( g_TeamInfo[i].frags > highest_frags || g_TeamInfo[i].deaths < lowest_deaths )
				{
					best_team = i;
					lowest_deaths = g_TeamInfo[i].deaths;
					highest_frags = g_TeamInfo[i].frags;
				}
			}
		}

		// draw the best team on the scoreboard
		if ( !best_team )
		{
			// if spectators is found and still not drawn
			if( iSpectatorPos != -1 && g_TeamInfo[iSpectatorPos].already_drawn == FALSE )
				best_team = iSpectatorPos;
			else break;
		}
		// draw out the best team
		team_info_t *team_info = &g_TeamInfo[best_team];

		// don't draw team without players
		if ( team_info->players <= 0 )
			continue;

		ypos = ystart + (list_slot * ROW_GAP);

		// check we haven't drawn too far down
		if ( ypos > yend )  // don't draw to close to the lower border
			break;

		int r, g, b;
		char teamName[64];

		GetTeamColor( r, g, b, team_info->teamnumber );
		switch( team_info->teamnumber )
		{
		case TEAM_TERRORIST:
			snprintf(teamName, sizeof(teamName), "Terrorists   -   %i players", team_info->players);
			DrawUtils::DrawHudNumberString( KILLS_POS_END(),  ypos, KILLS_POS_START(),  team_info->frags,  r, g, b );
			break;
		case TEAM_CT:
			snprintf(teamName, sizeof(teamName), "Counter-Terrorists   -   %i players", team_info->players);
			DrawUtils::DrawHudNumberString( KILLS_POS_END(),  ypos, KILLS_POS_START(),  team_info->frags,  r, g, b );
			break;
		case TEAM_SPECTATOR:
		case TEAM_UNASSIGNED:
			strncpy( teamName, "Spectators", sizeof(teamName) );
			break;
		}

		DrawUtils::DrawHudString( NAME_POS_START(),		 ypos, NAME_POS_END(),   teamName,   r, g, b );
		DrawUtils::DrawHudNumberString( PING_POS_END(),  ypos, PING_POS_START(),  team_info->sumping / team_info->players,  r, g, b );

		team_info->already_drawn = TRUE;  // set the already_drawn to be TRUE, so this team won't get drawn again

		// draw underline
		list_slot += 1.2f;
		FillRGBA( xstart, ystart + (list_slot * ROW_GAP), xend - xstart, 1, r, g, b, 255);

		list_slot += 0.4f;
		// draw all the players that belong to this team, indented slightly
		list_slot = DrawPlayers( list_slot, 10, team_info->name );
	}

	// draw all the players who are not in a team
	list_slot += 4.0f;
	DrawPlayers( list_slot, 0, "" );

	return 1;
}

// returns the ypos where it finishes drawing
int CHudScoreboard :: DrawPlayers( float list_slot, int nameoffset, const char *team )
{
	// draw the players, in order,  and restricted to team if set
	while ( 1 )
	{
		// Find the top ranking player
		int highest_frags = -99999;	int lowest_deaths = 99999;
		int best_player = 0;

		for ( int i = 1; i < MAX_PLAYERS; i++ )
		{
			if ( g_PlayerInfoList[i].name && g_PlayerExtraInfo[i].frags >= highest_frags )
			{
				if ( !(team && stricmp(g_PlayerExtraInfo[i].teamname, team)) )  // make sure it is the specified team
				{
					extra_player_info_t *pl_info = &g_PlayerExtraInfo[i];
					if ( pl_info->frags > highest_frags || pl_info->deaths < lowest_deaths )
					{
						best_player = i;
						lowest_deaths = pl_info->deaths;
						highest_frags = pl_info->frags;
					}
				}
			}
		}

		if ( !best_player )
			break;

		// draw out the best player
		hud_player_info_t *pl_info = &g_PlayerInfoList[best_player];

		int ypos = ystart + (list_slot * ROW_GAP);

		// check we haven't drawn too far down
		if ( ypos > yend )  // don't draw to close to the lower border
			break;

		int r = 255, g = 255, b = 255;
		float *colors = GetClientColor( best_player );
		r *= colors[0];
		g *= colors[1];
		b *= colors[2];

		if(pl_info->thisplayer) // hey, it's me!
		{
			FillRGBABlend( xstart, ypos, xend - xstart, ROW_GAP, 255, 255, 255, 15 );
		}

		DrawUtils::DrawHudString( NAME_POS_START() + nameoffset, ypos, NAME_POS_END(), pl_info->name, r, g, b );

		// draw bomb( if player have the bomb )
		if( g_PlayerExtraInfo[best_player].dead )
			DrawUtils::DrawHudString( ATTRIB_POS_START(), ypos, ATTRIB_POS_END(), "Dead", r, g, b );
		else if( g_PlayerExtraInfo[best_player].has_c4 )
			DrawUtils::DrawHudString( ATTRIB_POS_START(), ypos, ATTRIB_POS_END(), "Bomb", r, g, b );
		else if( g_PlayerExtraInfo[best_player].vip )
			DrawUtils::DrawHudString( ATTRIB_POS_START(), ypos, ATTRIB_POS_END(), "VIP",  r, g, b );

		// draw kills (right to left)
		DrawUtils::DrawHudNumberString( KILLS_POS_END(), ypos, KILLS_POS_START(), g_PlayerExtraInfo[best_player].frags, r, g, b );

		// draw deaths
		DrawUtils::DrawHudNumberString( DEATHS_POS_END(), ypos, DEATHS_POS_START(), g_PlayerExtraInfo[best_player].deaths, r, g, b );

		// draw ping & packetloss
		const char *value;
		if( pl_info->ping <= 5  // must be 0, until Xash's bug not fixed
			&& ( value = gEngfuncs.PlayerInfo_ValueForKey( best_player, "*bot" ) )
			&& atoi( value ) > 0 )
		{
			DrawUtils::DrawHudStringReverse( PING_POS_END(), ypos, PING_POS_START(), "BOT", r, g, b );
		}
		else
		{
			static char buf[64];
			sprintf( buf, "%d", pl_info->ping );
			DrawUtils::DrawHudStringReverse( PING_POS_END(), ypos, PING_POS_START(), buf, r, g, b );
		}
	
		pl_info->name = NULL;  // set the name to be NULL, so this client won't get drawn again
		list_slot++;
	}

	list_slot += 2.0f;

	return list_slot;
}


void CHudScoreboard :: GetAllPlayersInfo( void )
{
	for ( int i = 1; i < MAX_PLAYERS; i++ )
	{
		GetPlayerInfo( i, &g_PlayerInfoList[i] );

		if ( g_PlayerInfoList[i].thisplayer )
			m_iPlayerNum = i;  // !!!HACK: this should be initialized elsewhere... maybe gotten from the engine
	}
}

int CHudScoreboard :: MsgFunc_ScoreInfo( const char *pszName, int iSize, void *pbuf )
{
	m_iFlags |= HUD_DRAW;

	BufferReader reader( pszName, pbuf, iSize );
	short cl = reader.ReadByte();
	short frags = reader.ReadShort();
	short deaths = reader.ReadShort();
	short playerclass = reader.ReadShort();
	short teamnumber = reader.ReadShort();

	if ( cl > 0 && cl <= MAX_PLAYERS )
	{
		g_PlayerExtraInfo[cl].frags = frags;
		g_PlayerExtraInfo[cl].deaths = deaths;
		g_PlayerExtraInfo[cl].playerclass = playerclass;
		g_PlayerExtraInfo[cl].teamnumber = teamnumber;

		//gViewPort->UpdateOnPlayerInfo();
	}

	return 1;
}

// Message handler for TeamInfo message
// accepts two values:
//		byte: client number
//		string: client team name
int CHudScoreboard :: MsgFunc_TeamInfo( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	short cl = reader.ReadByte();
	int teamNumber = 0;

	if ( cl > 0 && cl <= MAX_PLAYERS )
	{
		// set the players team
		char teamName[MAX_TEAM_NAME];
		strncpy( teamName, reader.ReadString(), MAX_TEAM_NAME );

		if( !strcmp( teamName, "TERRORIST") )
			teamNumber = TEAM_TERRORIST;
		else if( !strcmp( teamName, "CT") )
			teamNumber = TEAM_CT;
		else if( !strcmp( teamName, "SPECTATOR" ) || !strcmp( teamName, "UNASSIGNED" ) )
		{
			teamNumber = TEAM_SPECTATOR;
			strncpy( teamName, "SPECTATOR", MAX_TEAM_NAME );
		}
		// just in case
		else teamNumber = TEAM_UNASSIGNED;

		strncpy( g_PlayerExtraInfo[cl].teamname, teamName, MAX_TEAM_NAME );
		g_PlayerExtraInfo[cl].teamnumber = teamNumber;
	}

	// rebuild the list of teams

	// clear out player counts from teams
	for ( int i = 1; i <= m_iNumTeams; i++ )
	{
		g_TeamInfo[i].players = 0;
	}

	// rebuild the team list
	GetAllPlayersInfo();
	m_iNumTeams = 0;

	for ( int i = 1; i < MAX_PLAYERS; i++ )
	{
		int j;
		//if ( g_PlayerInfoList[i].name == NULL )
		//	continue;

		if ( g_PlayerExtraInfo[i].teamname[0] == 0 )
			continue; // skip over players who are not in a team

		// is this player in an existing team?
		for ( j = 1; j <= m_iNumTeams; j++ )
		{
			if ( g_TeamInfo[j].name[0] == '\0' )
				break;

			if ( !stricmp( g_PlayerExtraInfo[i].teamname, g_TeamInfo[j].name ) )
				break;
		}

		if ( j > m_iNumTeams )
		{
			// they aren't in a listed team, so make a new one
			for ( j = 1; j <= m_iNumTeams; j++ )
			{
				if ( g_TeamInfo[j].name[0] == '\0' )
					break;
			}


			m_iNumTeams = max( j, m_iNumTeams );

			strncpy( g_TeamInfo[j].name, g_PlayerExtraInfo[i].teamname, MAX_TEAM_NAME );
			g_TeamInfo[j].teamnumber = g_PlayerExtraInfo[i].teamnumber;
			g_TeamInfo[j].players = 0;
		}

		g_TeamInfo[j].players++;
	}

	// clear out any empty teams
	for ( int i = 1; i <= m_iNumTeams; i++ )
	{
		if ( g_TeamInfo[i].players < 1 )
			memset( &g_TeamInfo[i], 0, sizeof(team_info_t) );
	}

	return 1;
}

// Message handler for TeamScore message
// accepts three values:
//		string: team name
//		short: teams kills
//		short: teams deaths 
// if this message is never received, then scores will simply be the combined totals of the players.
int CHudScoreboard :: MsgFunc_TeamScore( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );
	char *TeamName = reader.ReadString();
	int i;

	// find the team matching the name
	for ( i = 1; i <= m_iNumTeams; i++ )
	{
		if ( !stricmp( TeamName, g_TeamInfo[i].name ) )
			break;
	}
	if ( i > m_iNumTeams )
		return 1;

	// use this new score data instead of combined player scores
	g_TeamInfo[i].scores_overriden = TRUE;
	g_TeamInfo[i].frags = reader.ReadShort();
	g_TeamInfo[i].deaths = reader.ReadShort();
	
	return 1;
}

void CHudScoreboard :: DeathMsg( int killer, int victim )
{
	// if we were the one killed,  or the world killed us, set the scoreboard to indicate suicide
	if ( victim == m_iPlayerNum || killer == 0 )
	{
		m_iLastKilledBy = killer ? killer : m_iPlayerNum;
		m_fLastKillTime = gHUD.m_flTime + 10;	// display who we were killed by for 10 seconds

		if ( killer == m_iPlayerNum )
			m_iLastKilledBy = m_iPlayerNum;
	}
}



void CHudScoreboard :: UserCmd_ShowScores( void )
{
	m_bForceDraw = false;
	m_bShowscoresHeld = true;
}

void CHudScoreboard :: UserCmd_HideScores( void )
{
	m_bForceDraw = m_bShowscoresHeld = false;
}


void CHudScoreboard	:: UserCmd_ShowScoreboard2()
{
	if( gEngfuncs.Cmd_Argc() != 9 )
	{
		ConsolePrint("showscoreboard2 <xstart> <xend> <ystart> <yend> <r> <g> <b> <a>");
	}

	xstart     = atof(gEngfuncs.Cmd_Argv(1)) * ScreenWidth;
	xend       = atof(gEngfuncs.Cmd_Argv(2)) * ScreenWidth;
	ystart     = atof(gEngfuncs.Cmd_Argv(3)) * ScreenHeight;
	yend       = atof(gEngfuncs.Cmd_Argv(4)) * ScreenHeight;
	m_colors.r = atoi(gEngfuncs.Cmd_Argv(5));
	m_colors.b = atoi(gEngfuncs.Cmd_Argv(6));
	m_colors.b = atoi(gEngfuncs.Cmd_Argv(7));
	m_colors.a = atoi(gEngfuncs.Cmd_Argv(8));
	m_bDrawStroke = false;
	m_bForceDraw = true;
}

void CHudScoreboard :: UserCmd_HideScoreboard2()
{
	m_bForceDraw = m_bShowscoresHeld = false; // and disable it
}

```

`cl_dll/hud/sniperscope.cpp`:

```cpp
/*
hud_overlays.cpp - HUD Overlays
Copyright (C) 2015-2016 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.

*/

#include "hud.h"
#include "triangleapi.h"
#include "r_efx.h"
#include "cl_util.h"

#include "draw_util.h"

int CHudSniperScope::Init()
{
	gHUD.AddHudElem(this);
	m_iFlags = HUD_DRAW;
	m_iScopeArc[0] = m_iScopeArc[1] =m_iScopeArc[2] = m_iScopeArc[3]  = 0;
	return 1;
}

int CHudSniperScope::VidInit()
{
	if( g_iXash == 0 )
	{
		ConsolePrint("^3No Xash Found Warning^7: CHudSniperScope is disabled!\n");
		m_iFlags = 0;
		return 0;
	}

	m_iScopeArc[0] = gRenderAPI.GL_LoadTexture("sprites/scope_arc_nw.tga", NULL, 0, TF_NEAREST |TF_NOPICMIP|TF_NOMIPMAP|TF_CLAMP);
	m_iScopeArc[1] = gRenderAPI.GL_LoadTexture("sprites/scope_arc_ne.tga", NULL, 0, TF_NEAREST |TF_NOPICMIP|TF_NOMIPMAP|TF_CLAMP);
	m_iScopeArc[2] = gRenderAPI.GL_LoadTexture("sprites/scope_arc.tga",    NULL, 0, TF_NEAREST |TF_NOPICMIP|TF_NOMIPMAP|TF_CLAMP);
	m_iScopeArc[3] = gRenderAPI.GL_LoadTexture("sprites/scope_arc_sw.tga", NULL, 0, TF_NEAREST |TF_NOPICMIP|TF_NOMIPMAP|TF_CLAMP);

	if( !m_iScopeArc[0] || !m_iScopeArc[1] || !m_iScopeArc[2] || !m_iScopeArc[3] )
	{
		gRenderAPI.Host_Error( "^3Error^7: Cannot load Sniper Scope arcs. Check sprites/scope_arc*.tga files\n" );
	}
	left = (TrueWidth - TrueHeight)/2;
	right = left + TrueHeight;
	centerx = TrueWidth/2;
	centery = TrueHeight/2;
	return 1;
}

int CHudSniperScope::Draw(float flTime)
{
	if(gHUD.m_iFOV > 40)
		return 1;
	gEngfuncs.pTriAPI->RenderMode(kRenderTransColor);
	gEngfuncs.pTriAPI->Brightness(1.0);
	gEngfuncs.pTriAPI->Color4ub(0, 0, 0, 255);
	gEngfuncs.pTriAPI->CullFace(TRI_NONE);

	gRenderAPI.GL_SelectTexture(0);

	gRenderAPI.GL_Bind(0, m_iScopeArc[0]);
	DrawUtils::Draw2DQuad(left, 0, centerx, centery);

	gRenderAPI.GL_Bind(0, m_iScopeArc[1]);
	DrawUtils::Draw2DQuad(centerx, 0, right, centery);

	gRenderAPI.GL_Bind(0, m_iScopeArc[2]);
	DrawUtils::Draw2DQuad(centerx, centery, right, TrueHeight);

	gRenderAPI.GL_Bind(0, m_iScopeArc[3]);
	DrawUtils::Draw2DQuad(left, centery, centerx, TrueHeight);

	FillRGBABlend( 0, 0, (ScreenWidth - ScreenHeight) / 2 + 2, ScreenHeight, 0, 0, 0, 255 );
	FillRGBABlend( (ScreenWidth - ScreenHeight) / 2 - 2 + ScreenHeight, 0, (ScreenWidth - ScreenHeight) / 2 + 2, ScreenHeight, 0, 0, 0, 255 );

	FillRGBABlend(0,                  ScreenHeight/2, ScreenWidth/2 - 20, 1,  0, 0, 0, 255);
	FillRGBABlend(ScreenWidth/2 + 20, ScreenHeight/2, ScreenWidth       , 1,  0, 0, 0, 255);

	FillRGBABlend(ScreenWidth/2, 0                  , 1, ScreenHeight/2 - 20, 0, 0, 0, 255);
	FillRGBABlend(ScreenWidth/2, ScreenHeight/2 + 20, 1, ScreenHeight       , 0, 0, 0, 255);

	return 0;
}

void CHudSniperScope::Shutdown()
{
	for( int i = 0; i < 4; i++ )
		gRenderAPI.GL_FreeTexture( m_iScopeArc[i] );
}

```

`cl_dll/hud/spectator_gui.cpp`:

```cpp
/*
spectator_gui.cpp - HUD Overlays
Copyright (C) 2015 a1batross

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/

#include <string.h>

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include "vgui_parser.h"
#include "triangleapi.h"
#include "draw_util.h"

/*
 * We will draw all elements inside a box. It's size 16x10.
 */

#define XPOS( x ) ( (x) / 16.0f )
#define YPOS( y ) ( (y) / 10.0f  )

#define INT_XPOS(x) int(XPOS(x) * ScreenWidth)
#define INT_YPOS(y) int(YPOS(y) * ScreenHeight)

DECLARE_MESSAGE( m_SpectatorGui, SpecHealth )
DECLARE_MESSAGE( m_SpectatorGui, SpecHealth2 )

DECLARE_COMMAND( m_SpectatorGui, ToggleSpectatorMenu )

DECLARE_COMMAND( m_SpectatorGui, ToggleSpectatorMenuOptions )
// close
// help
// settings
// pip
// autodirector
// showscores

DECLARE_COMMAND( m_SpectatorGui, ToggleSpectatorMenuOptionsSettings )
// settings
// // chat msgs
// // show status
// // view cone
// // player names

DECLARE_COMMAND( m_SpectatorGui, ToggleSpectatorMenuSpectateOptions )
// chase map overview
// free map overview
// first person
// free look
// free chase camera
// locked chase camera

float CHudSpectatorGui::m_fTextScale = 1.0f;

void __CmdFunc_FindNextPlayerReverse( void )
{
	gHUD.m_Spectator.FindNextPlayer(true);
}

void __CmdFunc_FindNextPlayer( void )
{
	gHUD.m_Spectator.FindNextPlayer(false);
}

int CHudSpectatorGui::Init()
{
	HOOK_MESSAGE( SpecHealth );
	HOOK_MESSAGE( SpecHealth2 );

	HOOK_COMMAND( "_spec_toggle_menu", ToggleSpectatorMenu );
	HOOK_COMMAND( "_spec_toggle_menu_options", ToggleSpectatorMenuOptions );
	HOOK_COMMAND( "_spec_toggle_menu_options_settings", ToggleSpectatorMenuOptionsSettings );
	HOOK_COMMAND( "_spec_toggle_menu_spectate_options", ToggleSpectatorMenuSpectateOptions );
	HOOK_COMMAND( "_spec_find_next_player_reverse", FindNextPlayerReverse );
	HOOK_COMMAND( "_spec_find_next_player", FindNextPlayer );

	gHUD.AddHudElem(this);
	m_iFlags = HUD_DRAW;
	m_menuFlags = 0;
	m_fTextScale = 1.0f;
	m_hTimerTexture = 0;
	return 1;
}

int CHudSpectatorGui::VidInit()
{
	if( !g_iXash )
	{
		ConsolePrint("Warning: CHudSpectatorGui is disabled! Dude, are you running me on old GoldSrc?\n");
		m_iFlags = 0;
		return 0;
	}

	m_fTextScale = ScreenWidth / 1024.0f;
	if( m_fTextScale < 1.0f )
		m_fTextScale = 1.0f;
	m_hTimerTexture = gRenderAPI.GL_LoadTexture("gfx/vgui/timer.tga", NULL, 0, TF_NEAREST |TF_NOPICMIP|TF_NOMIPMAP|TF_CLAMP );
	return 1;
}

void CHudSpectatorGui::Shutdown()
{
	gRenderAPI.GL_FreeTexture( m_hTimerTexture );
}

inline void DrawButtonWithText( int x1, int y1, int wide, int tall, const char *sz, int r, int g, int b )
{
	DrawUtils::DrawRectangle(x1, y1, wide, tall);
	DrawUtils::DrawHudString(x1 + INT_XPOS(0.5), y1 + tall*0.5 - gHUD.GetCharHeight() * CHudSpectatorGui::m_fTextScale * 0.5, x1 + wide, sz,
							 r, g, b, CHudSpectatorGui::m_fTextScale );
}

int CHudSpectatorGui::Draw( float flTime )
{
	if( !g_iUser1 )
	{
		if( m_menuFlags & ROOT_MENU )
		{
			UserCmd_ToggleSpectatorMenu(); // this will remove any submenus;
			m_menuFlags = 0;
		}
		return 1;
	}

	// check for scoreboard. We will don't draw it, because screen space econodmy
	/*if( gHUD.m_Scoreboard.m_bForceDraw || !(!gHUD.m_Scoreboard.m_bShowscoresHeld && gHUD.m_Health.m_iHealth > 0 && !gHUD.m_iIntermission ))
		return 1;*/

	// function name says it
	CalcAllNeededData( );

	int r = 255, g = 140, b = 0;

	// at first, draw these silly black bars
	int startpos = 0;
	if( gHUD.m_Spectator.m_pip->value != INSET_OFF ) // pip adjust
	{
		startpos = XRES(gHUD.m_Spectator.m_OverviewData.insetWindowWidth) + XRES(gHUD.m_Spectator.m_OverviewData.insetWindowX);
		startpos *= ScreenWidth / TrueWidth; // hud_scale adjust
	}
	FillRGBABlend(startpos, 0, ScreenWidth - startpos, INT_YPOS(2), 0, 0, 0, 153);
	FillRGBABlend(0, ScreenHeight - INT_YPOS(2), ScreenWidth, INT_YPOS(2), 0, 0, 0, 153);

	// divider
	FillRGBABlend( INT_XPOS(12.5), INT_YPOS(2) * 0.25, 1, INT_YPOS(2) * 0.5, r, g, b, 255 );

	{ // mapname. extradata
		DrawUtils::DrawHudString( INT_XPOS(12.5) + 10, INT_YPOS(2) * 0.25, ScreenWidth, label.m_szMap, r, g, b, m_fTextScale );

		if( !m_bBombPlanted ) // timer remaining
		{
			if( m_hTimerTexture )
			{
				gRenderAPI.GL_SelectTexture( 0 );
				gRenderAPI.GL_Bind(0, m_hTimerTexture);
				gEngfuncs.pTriAPI->RenderMode( kRenderTransAlpha );
				DrawUtils::Draw2DQuad( (INT_XPOS(12.5) + 10) * gHUD.m_flScale,
									   (INT_YPOS(2) * 0.5) * gHUD.m_flScale,
									   (INT_XPOS(12.5) + 10 + gHUD.GetCharHeight() * m_fTextScale) * gHUD.m_flScale,
									   (INT_YPOS(2) * 0.5 + gHUD.GetCharHeight() * m_fTextScale) * gHUD.m_flScale );
			}
			DrawUtils::DrawHudString( INT_XPOS(12.5) + gHUD.GetCharHeight() * 1.5 * m_fTextScale + gHUD.GetCharWidth('M') * m_fTextScale, INT_YPOS(2) * 0.5, ScreenWidth,
									  label.m_szTimer, r, g, b, m_fTextScale );
		}
	}


	{ // draw team here
		int iLen = DrawUtils::HudStringLen("Counter-Terrorists:", m_fTextScale );

		DrawUtils::DrawHudString( INT_XPOS(12.5) - iLen - 50 , INT_YPOS(2) * 0.25, INT_XPOS(12.5) - 50, "Counter-Terrorists:", r, g, b, m_fTextScale );
		DrawUtils::DrawHudString( INT_XPOS(12.5) - iLen - 50, INT_YPOS(2) * 0.5, INT_XPOS(12.5) - 50, "Terrorists:", r, g, b, m_fTextScale );
		// count
		DrawUtils::DrawHudNumberString( INT_XPOS(12.5) - 10, INT_YPOS(2) * 0.25, INT_XPOS(12.5) - 50, label.m_iCounterTerrorists, r, g, b, m_fTextScale );
		DrawUtils::DrawHudNumberString( INT_XPOS(12.5) - 10, INT_YPOS(2) * 0.5,  INT_XPOS(12.5) - 50, label.m_iTerrorists,        r, g, b, m_fTextScale );
	}

	if( m_menuFlags & ROOT_MENU )
	{
		// draw the root menu
		DrawButtonWithText(INT_XPOS(0.5),  INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), "Options", r, g, b);
		DrawButtonWithText(INT_XPOS(5),    INT_YPOS(8.5), INT_XPOS(1), INT_YPOS(1), "<", r, g, b);

		DrawUtils::DrawRectangle(INT_XPOS(6), INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1));
		// name will be drawn later

		DrawButtonWithText(INT_XPOS(10),   INT_YPOS(8.5), INT_XPOS(1), INT_YPOS(1), ">", r, g, b );
		DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(8.5), INT_XPOS(4), INT_YPOS(1), "Spectate Options", r, g, b);
		if( m_menuFlags & MENU_OPTIONS )
		{
			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(2.5), INT_XPOS(4), INT_YPOS(1), "Close", r, g, b );
			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(3.5), INT_XPOS(4), INT_YPOS(1), "Help", r, g, b );
			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(4.5), INT_XPOS(4), INT_YPOS(1), "Settings", r, g, b );
			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(5.5), INT_XPOS(4), INT_YPOS(1), "Picture-in-Picture", r, g, b );
			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(6.5), INT_XPOS(4), INT_YPOS(1), "Autodirector", r, g, b );
			DrawButtonWithText(INT_XPOS(0.5), INT_YPOS(7.5), INT_XPOS(4), INT_YPOS(1), "Show scores", r, g, b );
			if( m_menuFlags & MENU_OPTIONS_SETTINGS )
			{
				DrawButtonWithText(INT_XPOS(4.5), INT_YPOS(4.5), INT_XPOS(4), INT_YPOS(1), "Chat messages", r, g, b );
				DrawButtonWithText(INT_XPOS(4.5), INT_YPOS(5.5), INT_XPOS(4), INT_YPOS(1), "Show status", r, g, b );
				DrawButtonWithText(INT_XPOS(4.5), INT_YPOS(6.5), INT_XPOS(4), INT_YPOS(1), "View cone", r, g, b );
				DrawButtonWithText(INT_XPOS(4.5), INT_YPOS(7.5), INT_XPOS(4), INT_YPOS(1), "Player names", r, g, b );
			}
		}

		if( m_menuFlags & MENU_SPEC_OPTIONS )
		{
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(2.5), INT_XPOS(4), INT_YPOS(1), "Chase Map Overview", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(3.5), INT_XPOS(4), INT_YPOS(1), "Free Map Overview", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(4.5), INT_XPOS(4), INT_YPOS(1), "First Person", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(5.5), INT_XPOS(4), INT_YPOS(1), "Free look", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(6.5), INT_XPOS(4), INT_YPOS(1), "Free Chase Camera", r, g, b );
			DrawButtonWithText(INT_XPOS(11.5), INT_YPOS(7.5), INT_XPOS(4), INT_YPOS(1), "Locked Chase Camera", r, g, b );
		}
	}

	//if( !label.m_szNameAndHealth[0] )
	//{
		int iLen = DrawUtils::HudStringLen( label.m_szNameAndHealth, m_fTextScale );
		GetTeamColor( r, g, b, g_PlayerExtraInfo[ g_iUser2 ].teamnumber );
		DrawUtils::DrawHudString( ScreenWidth * 0.5 - iLen * 0.5, INT_YPOS(9) - gHUD.GetCharHeight() * 0.5 * m_fTextScale, ScreenWidth,
								  label.m_szNameAndHealth, r, g, b, m_fTextScale );
	//}

	return 1;
}

void CHudSpectatorGui::CalcAllNeededData( )
{
	// mapname
	if( !label.m_szMap[0] )
	{
		static char szMapNameStripped[55];
		const char *szMapName = gEngfuncs.pfnGetLevelName(); //  "maps/%s.bsp"
		strncpy( szMapNameStripped, szMapName + 5, sizeof( szMapNameStripped ) );
		szMapNameStripped[strlen(szMapNameStripped) - 4] = '\0';
		snprintf( label.m_szMap, sizeof( label.m_szMap ), "Map: %s", szMapNameStripped );
	}

	// team
	/*label.m_iTerrorists        = 0;
	label.m_iCounterTerrorists = 0;
	for( int i = 0; i < MAX_PLAYERS; i++ )
	{
		if( g_PlayerExtraInfo[i].dead )
			continue; // show remaining

		switch( g_PlayerExtraInfo[i].teamnumber )
		{
		case TEAM_CT:
			label.m_iCounterTerrorists++;
		case TEAM_TERRORIST:
			label.m_iTerrorists++;
		}
	}*/

	label.m_iCounterTerrorists = 0;
	label.m_iTerrorists = 0;
	for( int i = 0; i < gHUD.m_Scoreboard.m_iNumTeams; i++ )
	{
		switch( g_TeamInfo[i].teamnumber )
		{
		case TEAM_CT:
			label.m_iCounterTerrorists = g_TeamInfo[i].frags;
			break;
		case TEAM_TERRORIST:
			label.m_iTerrorists = g_TeamInfo[i].frags;
			break;
		}
	}

	// timer
	// time must be positive
	if( !m_bBombPlanted )
	{
		int iMinutes = max( 0, (int)( gHUD.m_Timer.m_iTime + gHUD.m_Timer.m_fStartTime - gHUD.m_flTime ) / 60);
		int iSeconds = max( 0, (int)( gHUD.m_Timer.m_iTime + gHUD.m_Timer.m_fStartTime - gHUD.m_flTime ) - (iMinutes * 60));

		sprintf( label.m_szTimer, "%i:%i", iMinutes, iSeconds );
	}

	// player name
	if( g_iUser2 > 0 && g_iUser2 < MAX_PLAYERS )
	{
		hud_player_info_t sInfo;
		GetPlayerInfo( g_iUser2, &sInfo );

		snprintf( label.m_szNameAndHealth, sizeof( label.m_szNameAndHealth ),
				  "%s (%i)",  sInfo.name, g_PlayerExtraInfo[g_iUser2].health );
	}
	else label.m_szNameAndHealth[0] = '\0';
}

void CHudSpectatorGui::InitHUDData()
{
	m_bBombPlanted = false;
	label.m_szMap[0] = '\0';
}

void CHudSpectatorGui::Reset()
{
	m_bBombPlanted = false;
	if( m_menuFlags & ROOT_MENU )
	{
		UserCmd_ToggleSpectatorMenu(); // this will remove any submenus;
		m_menuFlags = 0;
	}
}

int CHudSpectatorGui::MsgFunc_SpecHealth(const char *pszName, int iSize, void *buf)
{
	BufferReader reader( pszName, buf, iSize );

	int health = reader.ReadByte();

	g_PlayerExtraInfo[g_iUser2].health = health;
	m_iPlayerLastPointedAt = g_iUser2;

	return 1;
}

int CHudSpectatorGui::MsgFunc_SpecHealth2(const char *pszName, int iSize, void *buf)
{
	BufferReader reader( pszName, buf, iSize );

	int health = reader.ReadByte();
	int client = reader.ReadByte();

	g_PlayerExtraInfo[client].health = health;
	m_iPlayerLastPointedAt = g_iUser2;

	return 1;
}

#define PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y(x, y) XPOS(x), YPOS(y), XPOS(x + 4.0f), YPOS(y + 1.0f)

void CHudSpectatorGui::UserCmd_ToggleSpectatorMenu()
{
	static byte color[4] = {0, 0, 0, 0};

	if( !g_iMobileAPIVersion )
		return;

	gMobileAPI.pfnTouchSetClientOnly( !(m_menuFlags & ROOT_MENU) );

	if( !(m_menuFlags & ROOT_MENU) )
	{
		m_menuFlags |= ROOT_MENU;

		gMobileAPI.pfnTouchAddClientButton( "_spec_menu_options", "*white", "_spec_toggle_menu_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 8.5f ), color, 0, 1.0f, 0 );

		gMobileAPI.pfnTouchAddClientButton( "_spec_menu_find_next_player_reverse", "*white", "_spec_find_next_player_reverse",
			XPOS(5.0f), YPOS(8.5f), XPOS(6.0f), YPOS(9.5f), color, 0, 1.0f, 0 );

		gMobileAPI.pfnTouchAddClientButton( "_spec_menu_find_next_player", "*white", "_spec_find_next_player",
			XPOS(10.0f),YPOS(8.5f), XPOS(11.0f),YPOS(9.5f), color, 0, 1.0f, 0 );

		gMobileAPI.pfnTouchAddClientButton( "_spec_menu_spectate_options", "*white", "_spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 8.5f ),color, 0, 1.0f, 0 );
	}
	else
	{
		m_menuFlags &= ~ROOT_MENU;
		m_menuFlags &= ~MENU_OPTIONS;
		m_menuFlags &= ~MENU_OPTIONS_SETTINGS;
		m_menuFlags &= ~MENU_SPEC_OPTIONS;
		gMobileAPI.pfnTouchRemoveButton( "_spec_*" );
	}
}

void CHudSpectatorGui::UserCmd_ToggleSpectatorMenuOptions()
{
	static byte color[4] = {0, 0, 0, 0};

	if( !(m_menuFlags & ROOT_MENU) || !g_iMobileAPIVersion )
		return;

	if( !(m_menuFlags & MENU_OPTIONS) )
	{
		m_menuFlags |= MENU_OPTIONS;
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_close", "*white", "_spec_toggle_menu",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 2.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_help", "*white", "spec_help; _spec_toggle_menu_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 3.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_settings", "*white", "_spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 4.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_pip", "*white", "toggle spec_pip_internal; _spec_toggle_menu_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 5.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_ad", "*white", "toggle spec_autodirector_internal; _spec_toggle_menu_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 6.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_showscores", "*white", "scoreboard; _spec_toggle_menu_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 0.5f, 7.5f ), color, 0, 1.0f, 0 );
	}
	else
	{
		m_menuFlags &= ~MENU_OPTIONS;
		m_menuFlags &= ~MENU_OPTIONS_SETTINGS;
		gMobileAPI.pfnTouchRemoveButton( "_spec_opt_*" );
	}
}

void CHudSpectatorGui::UserCmd_ToggleSpectatorMenuOptionsSettings()
{
	static byte color[4] = {0, 0, 0, 0};

	if( !(m_menuFlags & ROOT_MENU) || !g_iMobileAPIVersion )
		return;

	if( !(m_menuFlags & MENU_OPTIONS_SETTINGS) )
	{
		m_menuFlags |= MENU_OPTIONS_SETTINGS;
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_chat_msgs", "*white", "messagemode; _spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 4.5f, 4.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_set_status", "*white", "toggle spec_drawstatus_internal; _spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 4.5f, 5.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_draw_cones", "*white", "toggle spec_drawcone_internal; _spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 4.5f, 6.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_opt_draw_names", "*white", "toggle spec_drawnames_internal; _spec_toggle_menu_options_settings",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 4.5f, 7.5f ), color, 0, 1.0f, 0 );
	}
	else
	{
		m_menuFlags &= ~MENU_OPTIONS_SETTINGS;
		gMobileAPI.pfnTouchRemoveButton( "_spec_opt_set_*" );
	}
}

void CHudSpectatorGui::UserCmd_ToggleSpectatorMenuSpectateOptions()
{
	static byte color[4] = {0, 0, 0, 0};

	if( !(m_menuFlags & ROOT_MENU) || !g_iMobileAPIVersion )
		return;

	if( !(m_menuFlags & MENU_SPEC_OPTIONS) )
	{
		m_menuFlags |= MENU_SPEC_OPTIONS;
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_6", "*white", "spec_mode 6; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 2.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_5", "*white", "spec_mode 5; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 3.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_4", "*white", "spec_mode 4; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 4.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_3", "*white", "spec_mode 3; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 5.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_2", "*white", "spec_mode 2; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 6.5f ), color, 0, 1.0f, 0 );
		gMobileAPI.pfnTouchAddClientButton( "_spec_spec_1", "*white", "spec_mode 1; _spec_toggle_menu_spectate_options",
			PLACE_DEFAULT_SIZE_BUTTON_AT_X_Y( 11.5f, 7.5f ), color, 0, 1.0f, 0 );
	}
	else
	{
		m_menuFlags &= ~MENU_SPEC_OPTIONS;
		gMobileAPI.pfnTouchRemoveButton( "_spec_spec_*" );
	}
}

```

`cl_dll/hud/status_icons.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// status_icons.cpp
//
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "event_api.h"
#include "com_weapons.h"

DECLARE_MESSAGE( m_StatusIcons, StatusIcon )

int CHudStatusIcons::Init( void )
{
	HOOK_MESSAGE( StatusIcon );

	gHUD.AddHudElem( this );

	Reset();

	return 1;
}

int CHudStatusIcons::VidInit( void )
{
	return 1;
}

void CHudStatusIcons::Reset( void )
{
	memset( m_IconList, 0, sizeof m_IconList );
	m_iFlags &= ~HUD_DRAW;
}

// Draw status icons along the left-hand side of the screen
int CHudStatusIcons::Draw( float flTime )
{
	if (gEngfuncs.IsSpectateOnly())
		return 1;
	// find starting position to draw from, along right-hand side of screen
	int x = 5;
	int y = ScreenHeight / 2;

	// loop through icon list, and draw any valid icons drawing up from the middle of screen
	for ( int i = 0; i < MAX_ICONSPRITES; i++ )
	{
		if ( m_IconList[i].spr )
		{
			y -= ( m_IconList[i].rc.bottom - m_IconList[i].rc.top ) + 5;
			
			if( g_bInBombZone && !strcmp(m_IconList[i].szSpriteName, "c4") && ((int)(flTime * 10) % 2))
				SPR_Set( m_IconList[i].spr, 255, 16, 16 );
			else SPR_Set( m_IconList[i].spr, m_IconList[i].r, m_IconList[i].g, m_IconList[i].b );
			SPR_DrawAdditive( 0, x, y, &m_IconList[i].rc );
		}
	}
	
	return 1;
}

// Message handler for StatusIcon message
// accepts five values:
//		byte   : TRUE = ENABLE icon, FALSE = DISABLE icon
//		string : the sprite name to display
//		byte   : red
//		byte   : green
//		byte   : blue
int CHudStatusIcons::MsgFunc_StatusIcon( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int ShouldEnable = reader.ReadByte();
	char *pszIconName = reader.ReadString();

	if ( ShouldEnable )
	{
		int r = reader.ReadByte();
		int g = reader.ReadByte();
		int b = reader.ReadByte();
		EnableIcon( pszIconName, r, g, b );
		m_iFlags |= HUD_DRAW;
	}
	else
	{
		DisableIcon( pszIconName );
	}

	return 1;
}

// add the icon to the icon list, and set it's drawing color
void CHudStatusIcons::EnableIcon( const char *pszIconName, unsigned char red, unsigned char green, unsigned char blue )
{
	// check to see if the sprite is in the current list
	int i;
	for ( i = 0; i < MAX_ICONSPRITES; i++ )
	{
		if ( !stricmp( m_IconList[i].szSpriteName, pszIconName ) )
			break;
	}

	if ( i == MAX_ICONSPRITES )
	{
		// icon not in list, so find an empty slot to add to
		for ( i = 0; i < MAX_ICONSPRITES; i++ )
		{
			if ( !m_IconList[i].spr )
				break;
		}
	}

	// if we've run out of space in the list, overwrite the first icon
	if ( i == MAX_ICONSPRITES )
	{
		i = 0;
	}

	// Load the sprite and add it to the list
	// the sprite must be listed in hud.txt
	int spr_index = gHUD.GetSpriteIndex( pszIconName );
	m_IconList[i].spr = gHUD.GetSprite( spr_index );
	m_IconList[i].rc = gHUD.GetSpriteRect( spr_index );
	m_IconList[i].r = red;
	m_IconList[i].g = green;
	m_IconList[i].b = blue;
	strncpy( m_IconList[i].szSpriteName, pszIconName, MAX_ICONSPRITENAME_LENGTH );

	// Hack: Play Timer sound when a grenade icon is played (in 0.8 seconds)
	if ( strstr(m_IconList[i].szSpriteName, "grenade") )
	{
		cl_entity_t *pthisplayer = gEngfuncs.GetLocalPlayer();
		gEngfuncs.pEventAPI->EV_PlaySound( pthisplayer->index, pthisplayer->origin, CHAN_STATIC, "weapons/timer.wav", 1.0, ATTN_NORM, 0, PITCH_NORM );
	}
}

void CHudStatusIcons::DisableIcon( const char *pszIconName )
{
	// find the sprite is in the current list
	for ( int i = 0; i < MAX_ICONSPRITES; i++ )
	{
		if ( !stricmp( m_IconList[i].szSpriteName, pszIconName ) )
		{
			// clear the item from the list
			memset( &m_IconList[i], 0, sizeof( icon_sprite_t ) );
			return;
		}
	}
}

```

`cl_dll/hud/statusbar.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// statusbar.cpp
//
// generic text status bar, set by game dll
// runs across bottom of screen
//

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"

#include <string.h>
#include <stdio.h>
#include "draw_util.h"

DECLARE_MESSAGE( m_StatusBar, StatusText )
DECLARE_MESSAGE( m_StatusBar, StatusValue )

#define STATUSBAR_ID_LINE		0

inline void InsertTextMsg( char *szDst, size_t sLen, const char *szMsgName)
{
	client_textmessage_t *msg = TextMessageGet(szMsgName);
	if( msg )
	{
		strncpy( szDst, msg->pMessage, sLen );
	}
	else strncpy( szDst, szMsgName, sLen );
}

int CHudStatusBar :: Init( void )
{
	gHUD.AddHudElem( this );

	HOOK_MESSAGE( StatusText );
	HOOK_MESSAGE( StatusValue );

	Reset();

	hud_centerid = CVAR_CREATE( "hud_centerid", "0", FCVAR_ARCHIVE );

	return 1;
}

int CHudStatusBar :: VidInit( void )
{
	// Load sprites here

	return 1;
}

void CHudStatusBar :: Reset( void )
{
	int i = 0;

	m_iFlags &= ~HUD_DRAW;  // start out inactive
	for ( i = 0; i < MAX_STATUSBAR_LINES; i++ )
		m_szStatusText[i][0] = 0;
	memset( m_iStatusValues, 0, sizeof m_iStatusValues );

	m_iStatusValues[0] = 1;  // 0 is the special index, which always returns true

	// reset our colors for the status bar lines (yellow is default)
	for ( i = 0; i < MAX_STATUSBAR_LINES; i++ )
		m_pflNameColors[i] = g_ColorYellow;
}

void CHudStatusBar :: ParseStatusString( int line_num )
{
	// localise string first
	char szBuffer[MAX_STATUSTEXT_LENGTH];
	memset( szBuffer, 0, sizeof szBuffer );
	gHUD.m_TextMessage.LocaliseTextString( m_szStatusText[line_num], szBuffer, MAX_STATUSTEXT_LENGTH );

	// parse m_szStatusText & m_iStatusValues into m_szStatusBar
	memset( m_szStatusBar[line_num], 0, MAX_STATUSTEXT_LENGTH );
	char *src = szBuffer;
	char *dst = m_szStatusBar[line_num];

	char *src_start = src, *dst_start = dst;

	while ( *src != 0 )
	{
		while ( *src == '\n' )
			src++;  // skip over any newlines

		if ( ((src - src_start) >= MAX_STATUSTEXT_LENGTH) || ((dst - dst_start) >= MAX_STATUSTEXT_LENGTH) )
			break;

		int index = atoi( src );
		// should we draw this line?
		if ( (index >= 0 && index < MAX_STATUSBAR_VALUES) && (m_iStatusValues[index] != 0) )
		{  // parse this line and append result to the status bar
			while ( *src >= '0' && *src <= '9' )
				src++;

			if ( *src == '\n' || *src == 0 )
				continue; // no more left in this text line

			// copy the text, char by char, until we hit a % or a \n
			while ( *src != '\n' && *src != 0 )
			{
				if ( *src != '%' )
				{  // just copy the character
					*dst = *src;
					dst++, src++;
				}
				else
				{
					// get the descriptor
					char valtype = *(++src); // move over %

					// if it's a %, draw a % sign
					if ( valtype == '%' )
					{
						*dst = valtype;
						dst++, src++;
						continue;
					}

					// move over descriptor, then get and move over the index
					index = atoi( ++src ); 
					while ( *src >= '0' && *src <= '9' )
						src++;

					if ( index >= 0 && index < MAX_STATUSBAR_VALUES )
					{
						int indexval = m_iStatusValues[index];

						// get the string to substitute in place of the %XX
						char szRepString[MAX_PLAYER_NAME_LENGTH];
						switch ( valtype )
						{
						case 'p':  // player name
							GetPlayerInfo( indexval, &g_PlayerInfoList[indexval] );
							if ( g_PlayerInfoList[indexval].name != NULL )
							{
								strncpy( szRepString, g_PlayerInfoList[indexval].name, MAX_PLAYER_NAME_LENGTH );
								m_pflNameColors[line_num] = GetClientColor( indexval );
							}
							else
							{
								strncpy( szRepString, "******", MAX_PLAYER_NAME_LENGTH );
							}

							break;
						case 'i':  // number
							sprintf( szRepString, "%d", indexval );
							break;
						case 'h':  // health
							InsertTextMsg(szRepString, MAX_PLAYER_NAME_LENGTH, "Health");
							break;
						case 'c':
							if( indexval == 1 )
							{
								InsertTextMsg(szRepString, MAX_PLAYER_NAME_LENGTH, "Friend");
							}
							else if( indexval == 2 )
							{
								InsertTextMsg(szRepString, MAX_PLAYER_NAME_LENGTH, "Enemy");
							}
							else if( indexval == 3 )
							{
								InsertTextMsg(szRepString, MAX_PLAYER_NAME_LENGTH, "Hostage");
							}
							else szRepString[0] = 0;
							break;
						default:
							szRepString[0] = 0;
						}

						for ( char *cp = szRepString; *cp != 0 && ((dst - dst_start) < MAX_STATUSTEXT_LENGTH); cp++, dst++ )
							*dst = *cp;
					}
				}
			}
		}
		else
		{
			// skip to next line of text
			while ( *src != 0 && *src != '\n' )
				src++;
		}
	}
}

int CHudStatusBar :: Draw( float fTime )
{
	if ( m_bReparseString )
	{
		for ( int i = 0; i < MAX_STATUSBAR_LINES; i++ )
		{
			m_pflNameColors[i] = g_ColorYellow;
			ParseStatusString( i );
		}
		m_bReparseString = FALSE;
	}

	if( g_iUser1 > 0 )
	{
		// this is a spectator, so don't draw any statusbars
		return 1;
	}

	int Y_START = ScreenHeight - YRES(32 + 4);

	// Draw the status bar lines
	for ( int i = 0; i < MAX_STATUSBAR_LINES; i++ )
	{
		int TextHeight, TextWidth;
		DrawUtils::ConsoleStringSize( m_szStatusBar[i], &TextWidth, &TextHeight );

		int x = 4;
		int y = Y_START - ( 4 + TextHeight * i ); // draw along bottom of screen

		// let user set status ID bar centering
		if ( i == STATUSBAR_ID_LINE &&
			 hud_centerid->value != 0.0f )
		{
			x = max( 0, max(2, (ScreenWidth - TextWidth)) / 2 );
			y = (ScreenHeight / 2) + (TextHeight * hud_centerid->value );
		}

		if ( m_pflNameColors[i] )
			DrawUtils::SetConsoleTextColor( m_pflNameColors[i][0], m_pflNameColors[i][1], m_pflNameColors[i][2] );
		DrawUtils::DrawConsoleString( x, y, m_szStatusBar[i] );
	}

	return 1;
}

// Message handler for StatusText message
// accepts two values:
//		byte: line number of status bar text 
//		string: status bar text
// this string describes how the status bar should be drawn
// a semi-regular expression:
// ( slotnum ([a..z] [%pX] [%iX])*)*
// where slotnum is an index into the Value table (see below)
// if slotnum is 0, the string is always drawn
// if StatusValue[slotnum] != 0, the following string is drawn, up to the next newline - otherwise the text is skipped up to next newline
// %pX, where X is an integer, will substitute a player name here, getting the player index from StatusValue[X]
// %iX, where X is an integer, will substitute a number here, getting the number from StatusValue[X]
int CHudStatusBar :: MsgFunc_StatusText( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int line = reader.ReadByte();

	if ( line < 0 || line >= MAX_STATUSBAR_LINES )
		return 1;

	strncpy( m_szStatusText[line], reader.ReadString(), MAX_STATUSTEXT_LENGTH );
	m_szStatusText[line][MAX_STATUSTEXT_LENGTH-1] = 0;  // ensure it's null terminated ( strncpy() won't null terminate if read string too long)

	if ( m_szStatusText[0] == 0 )
		m_iFlags &= ~HUD_DRAW;
	else
		m_iFlags |= HUD_DRAW;  // we have status text, so turn on the status bar

	m_bReparseString = TRUE;

	return 1;
}

// Message handler for StatusText message
// accepts two values:
//		byte: index into the status value array
//		short: value to store
int CHudStatusBar :: MsgFunc_StatusValue( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int index = reader.ReadByte();
	if ( index < 1 || index >= MAX_STATUSBAR_VALUES )
		return 1; // index out of range

	m_iStatusValues[index] = reader.ReadShort();

	m_bReparseString = TRUE;
	
	return 1;
}

```

`cl_dll/hud/text_message.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// text_message.cpp
//
// implementation of CHudTextMessage class
//
// this class routes messages through titles.txt for localisation
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "vgui_parser.h"
#include "ctype.h"
#include "draw_util.h"

DECLARE_MESSAGE( m_TextMessage, TextMsg )

int CHudTextMessage::Init(void)
{
	HOOK_MESSAGE( TextMsg );

	gHUD.AddHudElem( this );
	m_iFlags = 0;

	return 1;
}

// Searches through the string for any msg names (indicated by a '#')
// any found are looked up in titles.txt and the new message substituted
// the new value is pushed into dst_buffer
char *CHudTextMessage::LocaliseTextString( const char *msg, char *dst_buffer, int buffer_size )
{
	char *dst = dst_buffer;
	for ( char *src = (char*)msg; *src != 0 && buffer_size > 0; buffer_size-- )
	{
		if ( *src == '#' )
		{
			// cut msg name out of string
			static char word_buf[255];
			char *wdst = word_buf, *word_start = src;
			for ( ++src ; (*src >= 'A' && *src <= 'z') || (*src >= '0' && *src <= '9'); wdst++, src++ )
			{
				*wdst = *src;
			}
			*wdst = 0;

			// lookup msg name in titles.txt
			client_textmessage_t *clmsg = TextMessageGet( word_buf );
			if ( !clmsg || !(clmsg->pMessage) )
			{
				src = word_start;
				*dst = *src;
				dst++, src++;
				continue;
			}

			if(clmsg->pMessage[0] == '#') strncpy(dst, Localize(clmsg->pMessage+1), buffer_size);

			// copy string into message over the msg name
			for ( char *wsrc = (char*)clmsg->pMessage; *wsrc != 0; wsrc++, dst++ )
			{
				*dst = *wsrc;
			}
			*dst = 0;
		}
		else
		{
			*dst = *src;
			dst++, src++;
			*dst = 0;
		}
	}

	dst_buffer[buffer_size-1] = 0; // ensure null termination
	return dst_buffer;
}

// As above, but with a local static buffer
char *CHudTextMessage::BufferedLocaliseTextString( const char *msg )
{
	static char dst_buffer[1024];
	LocaliseTextString( msg, dst_buffer, 1024 );
	return dst_buffer;
}

// Simplified version of LocaliseTextString;  assumes string is only one word
char *CHudTextMessage::LookupString( char *msg, int *msg_dest )
{
	if ( !msg )
		return (char*)"";

	// '#' character indicates this is a reference to a string in titles.txt, and not the string itself
	if ( msg[0] == '#' ) 
	{
		// this is a message name, so look up the real message
		client_textmessage_t *clmsg = TextMessageGet( msg+1 );

		if ( !clmsg || !(clmsg->pMessage) )
			return (char*)msg; // lookup failed, so return the original string
				
		if ( msg_dest )
		{
			// check to see if titles.txt info overrides msg destination
			// if clmsg->effect is less than 0, then clmsg->effect holds -1 * message_destination
			if ( clmsg->effect < 0 )  // 
				*msg_dest = -clmsg->effect;
		}

		if( clmsg->pMessage[0] == '#')
			return (char *)Localize( clmsg->pMessage + 1);

		return (char*)clmsg->pMessage;
	}
	else
	{  // nothing special about this message, so just return the same string
		return (char*)msg;
	}
}

void StripEndNewlineFromString( char *str )
{
	int s = strlen( str ) - 1;
	if ( str[s] == '\n' || str[s] == '\r' )
		str[s] = 0;
}

// converts all '\r' characters to '\n', so that the engine can deal with the properly
// returns a pointer to str
char* ConvertCRtoNL( char *str )
{
	for ( char *ch = str; *ch != 0; ch++ )
		if ( *ch == '\r' )
			*ch = '\n';
	return str;
}

// Message handler for text messages
// displays a string, looking them up from the titles.txt file, which can be localised
// parameters:
//   byte:   message direction  ( HUD_PRINTCONSOLE, HUD_PRINTNOTIFY, HUD_PRINTCENTER, HUD_PRINTTALK )
//   string: message
// optional parameters:
//   string: message parameter 1
//   string: message parameter 2
//   string: message parameter 3
//   string: message parameter 4
// any string that starts with the character '#' is a message name, and is used to look up the real message in titles.txt
// the next (optional) one to four strings are parameters for that string (which can also be message names if they begin with '#')
#define MAX_TEXTMSG_STRING 256
int CHudTextMessage::MsgFunc_TextMsg( const char *pszName, int iSize, void *pbuf )
{
	BufferReader reader( pszName, pbuf, iSize );

	int msg_dest = reader.ReadByte();

	static char szBuf[6][MAX_TEXTMSG_STRING];
	char *msg_text = LookupString( reader.ReadString(), &msg_dest );
	msg_text = strncpy( szBuf[0], msg_text, MAX_TEXTMSG_STRING );

	// keep reading strings and using C format strings for substituting the strings into the localised text string
	char *sstr1 = LookupString( reader.ReadString() );
	sstr1 = strncpy( szBuf[1], sstr1, MAX_TEXTMSG_STRING );
	StripEndNewlineFromString( sstr1 );  // these strings are meant for subsitution into the main strings, so cull the automatic end newlines
	char *sstr2 = LookupString( reader.ReadString() );
	sstr2 = strncpy( szBuf[2], sstr2, MAX_TEXTMSG_STRING );
	StripEndNewlineFromString( sstr2 );
	char *sstr3 = LookupString( reader.ReadString() );
	sstr3 = strncpy( szBuf[3], sstr3, MAX_TEXTMSG_STRING );
	StripEndNewlineFromString( sstr3 );
	char *sstr4 = LookupString( reader.ReadString() );
	sstr4 = strncpy( szBuf[4], sstr4, MAX_TEXTMSG_STRING );
	StripEndNewlineFromString( sstr4 );
	char *psz = szBuf[5];

	// Remove numbers after %s.
	// VALVEWHY?
	if( strlen(msg_text) >= 3 )
	{
		for( size_t i = 0; i < strlen(msg_text) - 2; i++)
		{
			if( msg_text[i] == '%' && msg_text[i + 1] == 's' && isdigit(msg_text[i + 2]))
			{
				char *first = &msg_text[i + 2];
				char *second = &msg_text[i + 3];

				memmove( first, second, strlen( second ));
				first[strlen(first)] = '\0';
			}
		}
	}


	switch ( msg_dest )
	{
	case HUD_PRINTCENTER:
	{
		snprintf( psz, MAX_TEXTMSG_STRING, msg_text, sstr1, sstr2, sstr3, sstr4 );

		/*ConvertCRtoNL( psz );

		int len = DrawUtils::ConsoleStringLen( psz );

		DrawUtils::DrawConsoleString( (ScreenWidth - len) / 2, ScreenHeight / 3, psz );*/

		CenterPrint( ConvertCRtoNL( psz ) );
		break;
	}
	case HUD_PRINTNOTIFY:
		psz[0] = 1;  // mark this message to go into the notify buffer
		snprintf( psz+1, MAX_TEXTMSG_STRING - 1, msg_text, sstr1, sstr2, sstr3, sstr4 );
		ConsolePrint( ConvertCRtoNL( psz ) );
		break;

	case HUD_PRINTTALK:
		psz[0] = 2; // mark, so SayTextPrint will color it
		snprintf( psz+1, MAX_TEXTMSG_STRING-1, msg_text, sstr1, sstr2, sstr3, sstr4 );
		gHUD.m_SayText.SayTextPrint( ConvertCRtoNL( psz ), 128 );
		break;

	case HUD_PRINTCONSOLE:
		snprintf( psz, MAX_TEXTMSG_STRING, msg_text, sstr1, sstr2, sstr3, sstr4 );
		ConsolePrint( ConvertCRtoNL( psz ) );
		break;

	case HUD_PRINTRADIO:
		// For some reason, HUD_PRINTRADIO always have "1" in msg_text
		for( int i = 1; i < MAX_PLAYERS; i++ )
		{
			if( g_PlayerInfoList[i].name && !strncmp(g_PlayerInfoList[i].name, sstr2, strlen(sstr2)) )
			{
				psz[0] = 2;
				snprintf( psz + 1, MAX_TEXTMSG_STRING-1, sstr1, sstr2, sstr3, sstr4 );
				gHUD.m_SayText.SayTextPrint( ConvertCRtoNL( psz ), 128, i );
				break;
			}
		}
		break;
	}

	return 1;
}

```

`cl_dll/hud/timer.cpp`:

```cpp
/*
timer.cpp -- HUD timer, progress bars, etc
Copyright (C) 2015-2016 a1batross
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

In addition, as a special exception, the author gives permission to
link the code of this program with the Half-Life Game Engine ("HL
Engine") and Modified Game Libraries ("MODs") developed by Valve,
L.L.C ("Valve").  You must obey the GNU General Public License in all
respects for all of the code used other than the HL Engine and MODs
from Valve.  If you modify this file, you may extend this exception
to your version of the file, but you are not obligated to do so.  If
you do not wish to do so, delete this exception statement from your
version.
*/

#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#include "hud.h"
#include "cl_util.h"
#include "parsemsg.h"
#include "vgui_parser.h"
#include <string.h>
#include "draw_util.h"

DECLARE_MESSAGE( m_Timer, RoundTime )
DECLARE_MESSAGE( m_Timer, ShowTimer )

int CHudTimer::Init()
{
	HOOK_MESSAGE( RoundTime );
	HOOK_MESSAGE( ShowTimer );
	m_iFlags = 0;
	m_bPanicColorChange = false;
	gHUD.AddHudElem(this);
	return 1;
}

int CHudTimer::VidInit()
{
	m_HUD_timer = gHUD.GetSpriteIndex( "stopwatch" );
	return 1;
}

int CHudTimer::Draw( float fTime )
{
	if ( ( gHUD.m_iHideHUDDisplay & HIDEHUD_HEALTH ) )
        return 1;

	if (!(gHUD.m_iWeaponBits & (1<<(WEAPON_SUIT)) ))
		return 1;
	int r, g, b;
	// time must be positive
	int minutes = max( 0, (int)( m_iTime + m_fStartTime - gHUD.m_flTime ) / 60);
	int seconds = max( 0, (int)( m_iTime + m_fStartTime - gHUD.m_flTime ) - (minutes * 60));

	if( minutes * 60 + seconds > 20 )
	{
		DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH );
	}
	else
	{
		m_flPanicTime += gHUD.m_flTimeDelta;
		// add 0.1 sec, so it's not flicker fast
		if( m_flPanicTime > ((float)seconds / 40.0f) + 0.1f)
		{
			m_flPanicTime = 0;
			m_bPanicColorChange = !m_bPanicColorChange;
		}
		DrawUtils::UnpackRGB( r, g, b, m_bPanicColorChange ? RGB_YELLOWISH : RGB_REDISH );
	}

	DrawUtils::ScaleColors( r, g, b, MIN_ALPHA );

    
    int iWatchWidth = gHUD.GetSpriteRect(m_HUD_timer).right - gHUD.GetSpriteRect(m_HUD_timer).left;
    
	int x = ScreenWidth/2;
	int y = ScreenHeight - 1.5 * gHUD.m_iFontHeight ;
    
    SPR_Set(gHUD.GetSprite(m_HUD_timer), r, g, b);
    SPR_DrawAdditive(0, x, y, &gHUD.GetSpriteRect(m_HUD_timer));
        
	x = DrawUtils::DrawHudNumber2( x + iWatchWidth / 4, y, false, 2, minutes, r, g, b );
	// draw :
	FillRGBA(x + iWatchWidth / 4, y + gHUD.m_iFontHeight / 4, 2, 2, r, g, b, 100);
	FillRGBA(x + iWatchWidth / 4, y + gHUD.m_iFontHeight - gHUD.m_iFontHeight / 4, 2, 2, r, g, b, 100);

	DrawUtils::DrawHudNumber2( x + iWatchWidth / 2, y, true, 2, seconds, r, g, b );
	return 1;
}

int CHudTimer::MsgFunc_RoundTime(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );
	m_iTime = reader.ReadShort();
	m_fStartTime = gHUD.m_flTime;
	m_iFlags = HUD_DRAW;
	return 1;
}

int CHudTimer::MsgFunc_ShowTimer(const char *pszName, int iSize, void *pbuf)
{
	m_iFlags = HUD_DRAW;
	return 1;
}

#define UPDATE_BOTPROGRESS 0
#define CREATE_BOTPROGRESS 1
#define REMOVE_BOTPROGRESS 2

DECLARE_MESSAGE( m_ProgressBar, BarTime )
DECLARE_MESSAGE( m_ProgressBar, BarTime2 )
DECLARE_MESSAGE( m_ProgressBar, BotProgress )

int CHudProgressBar::Init()
{
	HOOK_MESSAGE( BarTime );
	HOOK_MESSAGE( BarTime2 );
	HOOK_MESSAGE( BotProgress );
	m_iFlags = 0;
	m_szLocalizedHeader = NULL;
	m_szHeader[0] = '\0';
	m_fStartTime = m_fPercent = 0.0f;

	gHUD.AddHudElem(this);
	return 1;
}

int CHudProgressBar::VidInit()
{
	return 1;
}

int CHudProgressBar::Draw( float flTime )
{
	// allow only 0.0..1.0
	if( (m_fPercent < 0.0f) || (m_fPercent > 1.0f) )
	{
		m_iFlags = 0;
		m_fPercent = 0.0f;
		return 1;
	}

	if( m_szLocalizedHeader && m_szLocalizedHeader[0] )
	{
		int r, g, b;
		DrawUtils::UnpackRGB( r, g, b, RGB_YELLOWISH );
		DrawUtils::DrawHudString( ScreenWidth / 4, ScreenHeight / 2, ScreenWidth, (char*)m_szLocalizedHeader, r, g, b );

		DrawUtils::DrawRectangle( ScreenWidth/ 4, ScreenHeight / 2 + gHUD.GetCharHeight(), ScreenWidth/2, ScreenHeight/30 );
		FillRGBA( ScreenWidth/4+2, ScreenHeight/2 + gHUD.GetCharHeight() + 2, m_fPercent * (ScreenWidth/2-4), ScreenHeight/30-4, 255, 140, 0, 255 );
		return 1;
	}

	// prevent SIGFPE
	if( m_iDuration != 0.0f )
	{
		m_fPercent = ((flTime - m_fStartTime) / m_iDuration);
	}
	else
	{
		m_fPercent = 0.0f;
		m_iFlags = 0;
		return 1;
	}

	DrawUtils::DrawRectangle( ScreenWidth/4, ScreenHeight*2/3, ScreenWidth/2, 10 );
	FillRGBA( ScreenWidth/4+2, ScreenHeight*2/3+2, m_fPercent * (ScreenWidth/2-4), 6, 255, 140, 0, 255 );

	return 1;
}

int CHudProgressBar::MsgFunc_BarTime(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	m_iDuration = reader.ReadShort();
	m_fPercent = 0.0f;

	m_fStartTime = gHUD.m_flTime;

	m_iFlags = HUD_DRAW;
	return 1;
}

int CHudProgressBar::MsgFunc_BarTime2(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	m_iDuration = reader.ReadShort();
	m_fPercent = m_iDuration * (float)reader.ReadShort() / 100.0f;

	m_fStartTime = gHUD.m_flTime;

	m_iFlags = HUD_DRAW;
	return 1;
}

int CHudProgressBar::MsgFunc_BotProgress(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );
	m_iDuration = 0.0f; // don't update our progress bar
	m_iFlags = HUD_DRAW;

	float fNewPercent;
	int flag = reader.ReadByte();
	switch( flag )
	{
	case UPDATE_BOTPROGRESS:
	case CREATE_BOTPROGRESS:
		fNewPercent = (float)reader.ReadByte() / 100.0f;
		// cs behavior:
		// just don't decrease percent values
		if( m_fPercent < fNewPercent )
		{
			m_fPercent = fNewPercent;
		}
		strncpy(m_szHeader, reader.ReadString(), sizeof(m_szHeader));
		if( m_szHeader[0] == '#' )
			m_szLocalizedHeader = Localize(m_szHeader + 1);
		else
			m_szLocalizedHeader = m_szHeader;
		break;
	case REMOVE_BOTPROGRESS:
	default:
		m_fPercent = 0.0f;
		m_szHeader[0] = '\0';
		m_iFlags = 0;
		m_szLocalizedHeader = NULL;
		break;
	}

	return 1;
}

```

`cl_dll/hud/train.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// Train.cpp
//
// implementation of CHudAmmo class
//

#include "hud.h"
#include "cl_util.h"
#include <string.h>
#include <stdio.h>
#include "parsemsg.h"
#include "draw_util.h"

DECLARE_MESSAGE(m_Train, Train )


int CHudTrain::Init(void)
{
	HOOK_MESSAGE( Train );

	m_iPos = 0;
	m_iFlags = 0;
	gHUD.AddHudElem(this);

	return 1;
}

int CHudTrain::VidInit(void)
{
	m_hSprite = 0;

	return 1;
}

int CHudTrain::Draw(float fTime)
{
	if ( !m_hSprite )
		m_hSprite = LoadSprite("sprites/%d_train.spr");

	if (m_iPos)
	{
		int r, g, b, x, y;

		DrawUtils::UnpackRGB(r,g,b, RGB_YELLOWISH);
		SPR_Set(m_hSprite, r, g, b );

		// This should show up to the right and part way up the armor number
		y = ScreenHeight - SPR_Height(m_hSprite,0) - gHUD.m_iFontHeight;
		x = ScreenWidth/3 + SPR_Width(m_hSprite,0)/4;

		SPR_DrawAdditive( m_iPos - 1,  x, y, NULL);

	}

	return 1;
}


int CHudTrain::MsgFunc_Train(const char *pszName,  int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize );

	// update Train data
	m_iPos = reader.ReadByte();

	if (m_iPos)
		m_iFlags |= HUD_DRAW;
	else
		m_iFlags &= ~HUD_DRAW;

	return 1;
}

```

`cl_dll/in_camera.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include "hud.h"
#include "cl_util.h"
#include "camera.h"
#include "kbutton.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"
#include "camera.h"
#include "in_defs.h"
#ifdef _WIN32
#include "port.h"
#endif
float CL_KeyState (kbutton_t *key);

extern cl_enginefunc_t gEngfuncs;

//-------------------------------------------------- Constants

#define CAM_DIST_DELTA 1.0
#define CAM_ANGLE_DELTA 2.5
#define CAM_ANGLE_SPEED 2.5
#define CAM_MIN_DIST 30.0
#define CAM_ANGLE_MOVE .5
#define MAX_ANGLE_DIFF 10.0
#define PITCH_MAX 90.0
#define PITCH_MIN 0
#define YAW_MAX  135.0
#define YAW_MIN	 -135.0

enum ECAM_Command
{
	CAM_COMMAND_NONE = 0,
	CAM_COMMAND_TOTHIRDPERSON = 1,
	CAM_COMMAND_TOFIRSTPERSON = 2
};

//-------------------------------------------------- Global Variables

cvar_t	*cam_command;
cvar_t	*cam_snapto;
cvar_t	*cam_idealyaw;
cvar_t	*cam_idealpitch;
cvar_t	*cam_idealdist;
cvar_t	*cam_contain;

cvar_t	*c_maxpitch;
cvar_t	*c_minpitch;
cvar_t	*c_maxyaw;
cvar_t	*c_minyaw;
cvar_t	*c_maxdistance;
cvar_t	*c_mindistance;

// pitch, yaw, dist
vec3_t cam_ofs;

// In third person
int cam_thirdperson;
int cam_mousemove; //true if we are moving the cam with the mouse, False if not
int iMouseInUse=0;
int cam_distancemove;
extern int mouse_x, mouse_y;  //used to determine what the current x and y values are
int cam_old_mouse_x, cam_old_mouse_y; //holds the last ticks mouse movement
POINT		cam_mouse;
//-------------------------------------------------- Local Variables

static kbutton_t cam_pitchup, cam_pitchdown, cam_yawleft, cam_yawright;
static kbutton_t cam_in, cam_out;

//-------------------------------------------------- Prototypes

void CAM_ToThirdPerson(void);
void CAM_ToFirstPerson(void);
void CAM_StartDistance(void);
void CAM_EndDistance(void);


//-------------------------------------------------- Local Functions

float MoveToward( float cur, float goal, float maxspeed )
{
	if( cur != goal )
	{
		if( fabs( cur - goal ) > 180.0 )
		{
			if( cur < goal )
				cur += 360.0;
			else
				cur -= 360.0;
		}

		if( cur < goal )
		{
			if( cur < goal - 1.0 )
				cur += ( goal - cur ) / 4.0;
			else
				cur = goal;
		}
		else
		{
			if( cur > goal + 1.0 )
				cur -= ( cur - goal ) / 4.0;
			else
				cur = goal;
		}
	}


	// bring cur back into range
	if( cur < 0 )
		cur += 360.0;
	else if( cur >= 360 )
		cur -= 360;

	return cur;
}


//-------------------------------------------------- Global Functions

struct moveclip_t
{
	vec3_t		boxmins, boxmaxs;// enclose the test object along entire move
	float		*mins, *maxs;	// size of the moving object
	vec3_t		mins2, maxs2;	// size when clipping against mosnters
	float		*start, *end;
	trace_t		trace;
	int			type;
	edict_t		*passedict;
	qboolean	monsterclip;
};

void DLLEXPORT CAM_Think( void )
{
	vec3_t origin;
	vec3_t ext, pnt, camForward, camRight, camUp;
	moveclip_t	clip;
	float dist;
	vec3_t camAngles;
	float flSensitivity;
	vec3_t viewangles;

	switch( (int) cam_command->value )
	{
		case CAM_COMMAND_TOTHIRDPERSON:
			CAM_ToThirdPerson();
			break;

		case CAM_COMMAND_TOFIRSTPERSON:
			CAM_ToFirstPerson();
			break;

		case CAM_COMMAND_NONE:
		default:
			break;
	}

	if( !cam_thirdperson )
		return;
	
	camAngles[ PITCH ] = cam_idealpitch->value;
	camAngles[ YAW ] = cam_idealyaw->value;
	dist = cam_idealdist->value;
	//
	//movement of the camera with the mouse
	//
	if (cam_mousemove)
	{
	    //get windows cursor position
		GetCursorPos (&cam_mouse);
		//check for X delta values and adjust accordingly
		//eventually adjust YAW based on amount of movement
	  //don't do any movement of the cam using YAW/PITCH if we are zooming in/out the camera	
	  if (!cam_distancemove)
	  {
		
		//keep the camera within certain limits around the player (ie avoid certain bad viewing angles)  
		if (cam_mouse.x>gEngfuncs.GetWindowCenterX())
		{
			//if ((camAngles[YAW]>=225.0)||(camAngles[YAW]<135.0))
			if (camAngles[YAW]<c_maxyaw->value)
			{
				camAngles[ YAW ] += (CAM_ANGLE_MOVE)*((cam_mouse.x-gEngfuncs.GetWindowCenterX())/2);
			}
			if (camAngles[YAW]>c_maxyaw->value)
			{
				
				camAngles[YAW]=c_maxyaw->value;
			}
		}
		else if (cam_mouse.x<gEngfuncs.GetWindowCenterX())
		{
			//if ((camAngles[YAW]<=135.0)||(camAngles[YAW]>225.0))
			if (camAngles[YAW]>c_minyaw->value)
			{
			   camAngles[ YAW ] -= (CAM_ANGLE_MOVE)* ((gEngfuncs.GetWindowCenterX()-cam_mouse.x)/2);
			   	
			}
			if (camAngles[YAW]<c_minyaw->value)
			{
				camAngles[YAW]=c_minyaw->value;
				
			}
		}

		//check for y delta values and adjust accordingly
		//eventually adjust PITCH based on amount of movement
		//also make sure camera is within bounds
		if (cam_mouse.y>gEngfuncs.GetWindowCenterY())
		{
			if(camAngles[PITCH]<c_maxpitch->value)
			{
			    camAngles[PITCH] +=(CAM_ANGLE_MOVE)* ((cam_mouse.y-gEngfuncs.GetWindowCenterY())/2);
			}
			if (camAngles[PITCH]>c_maxpitch->value)
			{
				camAngles[PITCH]=c_maxpitch->value;
			}
		}
		else if (cam_mouse.y<gEngfuncs.GetWindowCenterY())
		{
			if (camAngles[PITCH]>c_minpitch->value)
			{
			   camAngles[PITCH] -= (CAM_ANGLE_MOVE)*((gEngfuncs.GetWindowCenterY()-cam_mouse.y)/2);
			}
			if (camAngles[PITCH]<c_minpitch->value)
			{
				camAngles[PITCH]=c_minpitch->value;
			}
		}

		//set old mouse coordinates to current mouse coordinates
		//since we are done with the mouse

		if ( ( flSensitivity = gHUD.GetSensitivity() ) != 0 )
		{
			cam_old_mouse_x=cam_mouse.x*flSensitivity;
			cam_old_mouse_y=cam_mouse.y*flSensitivity;
		}
		else
		{
			cam_old_mouse_x=cam_mouse.x;
			cam_old_mouse_y=cam_mouse.y;
		}
		SetCursorPos (gEngfuncs.GetWindowCenterX(), gEngfuncs.GetWindowCenterY());
	  }
	}

	//Nathan code here
	if( CL_KeyState( &cam_pitchup ) )
		camAngles[ PITCH ] += CAM_ANGLE_DELTA;
	else if( CL_KeyState( &cam_pitchdown ) )
		camAngles[ PITCH ] -= CAM_ANGLE_DELTA;

	if( CL_KeyState( &cam_yawleft ) )
		camAngles[ YAW ] -= CAM_ANGLE_DELTA;
	else if( CL_KeyState( &cam_yawright ) )
		camAngles[ YAW ] += CAM_ANGLE_DELTA;

	if( CL_KeyState( &cam_in ) )
	{
		dist -= CAM_DIST_DELTA;
		if( dist < CAM_MIN_DIST )
		{
			// If we go back into first person, reset the angle
			camAngles[ PITCH ] = 0;
			camAngles[ YAW ] = 0;
			dist = CAM_MIN_DIST;
		}

	}
	else if( CL_KeyState( &cam_out ) )
		dist += CAM_DIST_DELTA;

	if (cam_distancemove)
	{
		if (cam_mouse.y>gEngfuncs.GetWindowCenterY())
		{
			if(dist<c_maxdistance->value)
			{
			    dist +=CAM_DIST_DELTA * ((cam_mouse.y-gEngfuncs.GetWindowCenterY())/2);
			}
			if (dist>c_maxdistance->value)
			{
				dist=c_maxdistance->value;
			}
		}
		else if (cam_mouse.y<gEngfuncs.GetWindowCenterY())
		{
			if (dist>c_mindistance->value)
			{
			   dist -= (CAM_DIST_DELTA)*((gEngfuncs.GetWindowCenterY()-cam_mouse.y)/2);
			}
			if (dist<c_mindistance->value)
			{
				dist=c_mindistance->value;
			}
		}
		//set old mouse coordinates to current mouse coordinates
		//since we are done with the mouse
		cam_old_mouse_x=cam_mouse.x*gHUD.GetSensitivity();
		cam_old_mouse_y=cam_mouse.y*gHUD.GetSensitivity();
		SetCursorPos (gEngfuncs.GetWindowCenterX(), gEngfuncs.GetWindowCenterY());
	}
	// update ideal
	cam_idealpitch->value = camAngles[ PITCH ];
	cam_idealyaw->value = camAngles[ YAW ];
	cam_idealdist->value = dist;

	// Move towards ideal
	VectorCopy( cam_ofs, camAngles );

	gEngfuncs.GetViewAngles( (float *)viewangles );

	if( cam_snapto->value )
	{
		camAngles[ YAW ] = cam_idealyaw->value + viewangles[ YAW ];
		camAngles[ PITCH ] = cam_idealpitch->value + viewangles[ PITCH ];
		camAngles[ 2 ] = cam_idealdist->value;
	}
	else
	{
		if( camAngles[ YAW ] - viewangles[ YAW ] != cam_idealyaw->value )
			camAngles[ YAW ] = MoveToward( camAngles[ YAW ], cam_idealyaw->value + viewangles[ YAW ], CAM_ANGLE_SPEED );

		if( camAngles[ PITCH ] - viewangles[ PITCH ] != cam_idealpitch->value )
			camAngles[ PITCH ] = MoveToward( camAngles[ PITCH ], cam_idealpitch->value + viewangles[ PITCH ], CAM_ANGLE_SPEED );

		if( fabs( camAngles[ 2 ] - cam_idealdist->value ) < 2.0 )
			camAngles[ 2 ] = cam_idealdist->value;
		else
			camAngles[ 2 ] += ( cam_idealdist->value - camAngles[ 2 ] ) / 4.0;
	}
	cam_ofs[ 0 ] = camAngles[ 0 ];
	cam_ofs[ 1 ] = camAngles[ 1 ];
	cam_ofs[ 2 ] = dist;
}

extern void KeyDown (kbutton_t *b);	// HACK
extern void KeyUp (kbutton_t *b);	// HACK

void CAM_PitchUpDown(void) { KeyDown( &cam_pitchup ); }
void CAM_PitchUpUp(void) { KeyUp( &cam_pitchup ); }
void CAM_PitchDownDown(void) { KeyDown( &cam_pitchdown ); }
void CAM_PitchDownUp(void) { KeyUp( &cam_pitchdown ); }
void CAM_YawLeftDown(void) { KeyDown( &cam_yawleft ); }
void CAM_YawLeftUp(void) { KeyUp( &cam_yawleft ); }
void CAM_YawRightDown(void) { KeyDown( &cam_yawright ); }
void CAM_YawRightUp(void) { KeyUp( &cam_yawright ); }
void CAM_InDown(void) { KeyDown( &cam_in ); }
void CAM_InUp(void) { KeyUp( &cam_in ); }
void CAM_OutDown(void) { KeyDown( &cam_out ); }
void CAM_OutUp(void) { KeyUp( &cam_out ); }

void CAM_ToThirdPerson(void)
{ 
	vec3_t viewangles;

#if !defined( _DEBUG )
	if ( gEngfuncs.GetMaxClients() > 1 )
	{
		// no thirdperson in multiplayer.
		return;
	}
#endif

	gEngfuncs.GetViewAngles( (float *)viewangles );

	if( !cam_thirdperson )
	{
		cam_thirdperson = 1; 
		
		cam_ofs[ YAW ] = viewangles[ YAW ]; 
		cam_ofs[ PITCH ] = viewangles[ PITCH ]; 
		cam_ofs[ 2 ] = CAM_MIN_DIST; 
	}

	gEngfuncs.Cvar_SetValue( "cam_command", 0 );
}

void CAM_ToFirstPerson(void) 
{ 
	cam_thirdperson = 0;
	
	gEngfuncs.Cvar_SetValue( "cam_command", 0 );
}

void CAM_ToggleSnapto( void )
{ 
	cam_snapto->value = !cam_snapto->value;
}

void CAM_Init( void )
{
	gEngfuncs.pfnAddCommand( "+campitchup", CAM_PitchUpDown );
	gEngfuncs.pfnAddCommand( "-campitchup", CAM_PitchUpUp );
	gEngfuncs.pfnAddCommand( "+campitchdown", CAM_PitchDownDown );
	gEngfuncs.pfnAddCommand( "-campitchdown", CAM_PitchDownUp );
	gEngfuncs.pfnAddCommand( "+camyawleft", CAM_YawLeftDown );
	gEngfuncs.pfnAddCommand( "-camyawleft", CAM_YawLeftUp );
	gEngfuncs.pfnAddCommand( "+camyawright", CAM_YawRightDown );
	gEngfuncs.pfnAddCommand( "-camyawright", CAM_YawRightUp );
	gEngfuncs.pfnAddCommand( "+camin", CAM_InDown );
	gEngfuncs.pfnAddCommand( "-camin", CAM_InUp );
	gEngfuncs.pfnAddCommand( "+camout", CAM_OutDown );
	gEngfuncs.pfnAddCommand( "-camout", CAM_OutUp );
	gEngfuncs.pfnAddCommand( "thirdperson", CAM_ToThirdPerson );
	gEngfuncs.pfnAddCommand( "firstperson", CAM_ToFirstPerson );
	gEngfuncs.pfnAddCommand( "+cammousemove",CAM_StartMouseMove);
	gEngfuncs.pfnAddCommand( "-cammousemove",CAM_EndMouseMove);
	gEngfuncs.pfnAddCommand( "+camdistance", CAM_StartDistance );
	gEngfuncs.pfnAddCommand( "-camdistance", CAM_EndDistance );
	gEngfuncs.pfnAddCommand( "snapto", CAM_ToggleSnapto );

	cam_command				= gEngfuncs.pfnRegisterVariable ( "cam_command", "0", 0 );	 // tells camera to go to thirdperson
	cam_snapto				= gEngfuncs.pfnRegisterVariable ( "cam_snapto", "0", 0 );	 // snap to thirdperson view
	cam_idealyaw			= gEngfuncs.pfnRegisterVariable ( "cam_idealyaw", "90", 0 );	 // thirdperson yaw
	cam_idealpitch			= gEngfuncs.pfnRegisterVariable ( "cam_idealpitch", "0", 0 );	 // thirperson pitch
	cam_idealdist			= gEngfuncs.pfnRegisterVariable ( "cam_idealdist", "64", 0 );	 // thirdperson distance
	cam_contain				= gEngfuncs.pfnRegisterVariable ( "cam_contain", "0", 0 );	// contain camera to world

	c_maxpitch				= gEngfuncs.pfnRegisterVariable ( "c_maxpitch", "90.0", 0 );
	c_minpitch				= gEngfuncs.pfnRegisterVariable ( "c_minpitch", "0.0", 0 );
	c_maxyaw				= gEngfuncs.pfnRegisterVariable ( "c_maxyaw",   "135.0", 0 );
	c_minyaw				= gEngfuncs.pfnRegisterVariable ( "c_minyaw",   "-135.0", 0 );
	c_maxdistance			= gEngfuncs.pfnRegisterVariable ( "c_maxdistance",   "200.0", 0 );
	c_mindistance			= gEngfuncs.pfnRegisterVariable ( "c_mindistance",   "30.0", 0 );
}

void CAM_ClearStates( void )
{
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );

	cam_pitchup.state = 0;
	cam_pitchdown.state = 0;
	cam_yawleft.state = 0;
	cam_yawright.state = 0;
	cam_in.state = 0;
	cam_out.state = 0;

	cam_thirdperson = 0;
	cam_command->value = 0;
	cam_mousemove=0;

	cam_snapto->value = 0;
	cam_distancemove = 0;

	cam_ofs[ 0 ] = 0.0;
	cam_ofs[ 1 ] = 0.0;
	cam_ofs[ 2 ] = CAM_MIN_DIST;

	cam_idealpitch->value = viewangles[ PITCH ];
	cam_idealyaw->value = viewangles[ YAW ];
	cam_idealdist->value = CAM_MIN_DIST;
}

void CAM_StartMouseMove(void)
{
	float flSensitivity;
		
	//only move the cam with mouse if we are in third person.
	if (cam_thirdperson)
	{
		//set appropriate flags and initialize the old mouse position
		//variables for mouse camera movement
		if (!cam_mousemove)
		{
			cam_mousemove=1;
			iMouseInUse=1;
			GetCursorPos (&cam_mouse);

			if ( ( flSensitivity = gHUD.GetSensitivity() ) != 0 )
			{
				cam_old_mouse_x=cam_mouse.x*flSensitivity;
				cam_old_mouse_y=cam_mouse.y*flSensitivity;
			}
			else
			{
				cam_old_mouse_x=cam_mouse.x;
				cam_old_mouse_y=cam_mouse.y;
			}
		}
	}
	//we are not in 3rd person view..therefore do not allow camera movement
	else
	{   
		cam_mousemove=0;
		iMouseInUse=0;
	}
}

//the key has been released for camera movement
//tell the engine that mouse camera movement is off
void CAM_EndMouseMove(void)
{
   cam_mousemove=0;
   iMouseInUse=0;
}


//----------------------------------------------------------
//routines to start the process of moving the cam in or out 
//using the mouse
//----------------------------------------------------------
void CAM_StartDistance(void)
{
	//only move the cam with mouse if we are in third person.
	if (cam_thirdperson)
	{
	  //set appropriate flags and initialize the old mouse position
	  //variables for mouse camera movement
	  if (!cam_distancemove)
	  {
		  cam_distancemove=1;
		  cam_mousemove=1;
		  iMouseInUse=1;
		  GetCursorPos (&cam_mouse);
		  cam_old_mouse_x=cam_mouse.x*gHUD.GetSensitivity();
		  cam_old_mouse_y=cam_mouse.y*gHUD.GetSensitivity();
	  }
	}
	//we are not in 3rd person view..therefore do not allow camera movement
	else
	{   
		cam_distancemove=0;
		cam_mousemove=0;
		iMouseInUse=0;
	}
}

//the key has been released for camera movement
//tell the engine that mouse camera movement is off
void CAM_EndDistance(void)
{
   cam_distancemove=0;
   cam_mousemove=0;
   iMouseInUse=0;
}

int DLLEXPORT CL_IsThirdPerson( void )
{
	return (cam_thirdperson ? 1 : 0) || (g_iUser1 && gEngfuncs.GetLocalPlayer() && (g_iUser2 == gEngfuncs.GetLocalPlayer()->index) );
}

void DLLEXPORT CL_CameraOffset( float *ofs )
{
	VectorCopy( cam_ofs, ofs );
}

```

`cl_dll/include/camera.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// Camera.h  --  defines and such for a 3rd person camera
// NOTE: must include quakedef.h first
#pragma once
#ifndef _CAMERA_H_
#define _CAMEA_H_

// pitch, yaw, dist
extern vec3_t cam_ofs;
// Using third person camera
extern int cam_thirdperson;

void CAM_Init( void );
void CAM_ClearStates( void );
void CAM_StartMouseMove(void);
void CAM_EndMouseMove(void);

#endif		// _CAMERA_H_

```

`cl_dll/include/cl_dll.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cl_dll.h
//

// 4-23-98  JOHN
#pragma once
#ifndef CL_DLL_H
#define CL_DLL_H
//
//  This DLL is linked by the client when they first initialize.
// This DLL is responsible for the following tasks:
//		- Loading the HUD graphics upon initialization
//		- Drawing the HUD graphics every frame
//		- Handling the custum HUD-update packets
//
typedef unsigned char byte;
typedef unsigned short word;
typedef float vec_t;
typedef int (*pfnUserMsgHook)(const char *pszName, int iSize, void *pbuf);

#include "util_vector.h"

#include "../engine/cdll_int.h"
#include "../dlls/cdll_dll.h"

#include "exportdef.h"

#include "render_api.h"
#include "mobility_int.h"

extern "C"
{
int        DLLEXPORT Initialize( cl_enginefunc_t *pEnginefuncs, int iVersion );
int        DLLEXPORT HUD_VidInit( void );
void       DLLEXPORT HUD_Init( void );
int        DLLEXPORT HUD_Redraw( float flTime, int intermission );
int        DLLEXPORT HUD_UpdateClientData( client_data_t *cdata, float flTime );
void       DLLEXPORT HUD_Reset( void );
void       DLLEXPORT HUD_PlayerMove( struct playermove_s *ppmove, int server );
void       DLLEXPORT HUD_PlayerMoveInit( struct playermove_s *ppmove );
char       DLLEXPORT HUD_PlayerMoveTexture( char *name );
int        DLLEXPORT HUD_ConnectionlessPacket( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );
int        DLLEXPORT HUD_GetHullBounds( int hullnumber, float *mins, float *maxs );
void       DLLEXPORT HUD_Frame( double time );
void       DLLEXPORT HUD_VoiceStatus( int entindex, qboolean bTalking );
void       DLLEXPORT HUD_DirectorMessage( int iSize, void *pbuf );
int        DLLEXPORT HUD_GetRenderInterface( int version, render_api_t *renderfuncs, render_interface_t *callback );
int        DLLEXPORT HUD_MobilityInterface( mobile_engfuncs_t *mobileapi );
void       DLLEXPORT HUD_PostRunCmd( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
int        DLLEXPORT HUD_AddEntity( int type, struct cl_entity_s *ent, const char *modelname );
void       DLLEXPORT HUD_CreateEntities( void );
void       DLLEXPORT HUD_StudioEvent( const struct mstudioevent_s *event, const struct cl_entity_s *entity );
void       DLLEXPORT HUD_TxferLocalOverrides( struct entity_state_s *state, const struct clientdata_s *client );
void       DLLEXPORT HUD_ProcessPlayerState( struct entity_state_s *dst, const struct entity_state_s *src );
void       DLLEXPORT HUD_TxferPredictionData( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd );
void       DLLEXPORT HUD_TempEntUpdate( double frametime, double client_time, double cl_gravity, struct tempent_s **ppTempEntFree, struct tempent_s **ppTempEntActive, int ( *Callback_AddVisibleEntity )( struct cl_entity_s *pEntity ), void ( *Callback_TempEntPlaySound )( struct tempent_s *pTemp, float damp ) );
void       DLLEXPORT HUD_Shutdown( void );
int        DLLEXPORT HUD_Key_Event( int eventcode, int keynum, const char *pszCurrentBinding );
int        DLLEXPORT HUD_GetStudioModelInterface( int version, struct r_studio_interface_s **ppinterface, struct engine_studio_api_s *pstudio );
void       DLLEXPORT HUD_DrawNormalTriangles( void );
void       DLLEXPORT HUD_DrawTransparentTriangles( void );
void       DLLEXPORT CAM_Think( void );
int        DLLEXPORT CL_IsThirdPerson( void );
void       DLLEXPORT CL_CameraOffset( float *ofs );
void       DLLEXPORT CL_CreateMove( float frametime, struct usercmd_s *cmd, int active );
void       DLLEXPORT IN_ActivateMouse( void );
void       DLLEXPORT IN_DeactivateMouse( void );
void       DLLEXPORT IN_MouseEvent( int mstate );
void       DLLEXPORT IN_Accumulate( void );
void       DLLEXPORT IN_ClearStates( void );
void       DLLEXPORT V_CalcRefdef( struct ref_params_s *pparams );
void       DLLEXPORT Demo_ReadBuffer( int size, unsigned char *buffer );
struct cl_entity_s DLLEXPORT *HUD_GetUserEntity( int index );
struct kbutton_s   DLLEXPORT *KB_Find( const char *name );

void       DLLEXPORT IN_ClientMoveEvent( float forwardmove, float sidemove );
void       DLLEXPORT IN_ClientLookEvent( float relyaw, float relpitch );
}


extern cl_enginefunc_t gEngfuncs;
extern render_api_t gRenderAPI;
extern mobile_engfuncs_t gMobileAPI;
extern int g_iXash; // indicates buildnum
extern int g_iMobileAPIVersion; // indicates version. 0 if no mobile API
#endif // CL_DLL_H

```

`cl_dll/include/cl_util.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// cl_util.h
//
#pragma once
#include "cvardef.h"
#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

extern cvar_t *hud_textmode;

#ifdef _MSC_VER
#pragma warning(disable : 4244) // 'argument': conversion from 'float' to 'int', possible loss of data
#pragma warning(disable : 4101) // unreferenced local variable
#endif

// Macros to hook function calls into the HUD object
#define HOOK_MESSAGE(x) gEngfuncs.pfnHookUserMsg(#x, __MsgFunc_##x );

#define DECLARE_MESSAGE(y, x) int __MsgFunc_##x(const char *pszName, int iSize, void *pbuf) \
{ \
	return gHUD.y.MsgFunc_##x(pszName, iSize, pbuf ); \
	}

#define HOOK_COMMAND(x, y) gEngfuncs.pfnAddCommand( x, __CmdFunc_##y );
#define DECLARE_COMMAND(y, x) void __CmdFunc_##x( void ) \
{ \
	gHUD.y.UserCmd_##x( ); \
	}

inline float CVAR_GET_FLOAT( const char *x ) {	return gEngfuncs.pfnGetCvarFloat( (char*)x ); }
inline char* CVAR_GET_STRING( const char *x ) {	return gEngfuncs.pfnGetCvarString( (char*)x ); }
inline struct cvar_s *CVAR_CREATE( const char *cv, const char *val, const int flags ) {	return gEngfuncs.pfnRegisterVariable( (char*)cv, (char*)val, flags ); }

#define SPR_Load (*gEngfuncs.pfnSPR_Load)
#define SPR_Set (*gEngfuncs.pfnSPR_Set)
#define SPR_Frames (*gEngfuncs.pfnSPR_Frames)
#define SPR_GetList (*gEngfuncs.pfnSPR_GetList)

// SPR_Draw  draws a the current sprite as solid
#define SPR_Draw (*gEngfuncs.pfnSPR_Draw)
// SPR_DrawHoles  draws the current sprites,  with color index255 not drawn (transparent)
#define SPR_DrawHoles (*gEngfuncs.pfnSPR_DrawHoles)
// SPR_DrawAdditive  adds the sprites RGB values to the background  (additive transulency)
#define SPR_DrawAdditive (*gEngfuncs.pfnSPR_DrawAdditive)

// SPR_EnableScissor  sets a clipping rect for HUD sprites.  (0,0) is the top-left hand corner of the screen.
#define SPR_EnableScissor (*gEngfuncs.pfnSPR_EnableScissor)
// SPR_DisableScissor  disables the clipping rect
#define SPR_DisableScissor (*gEngfuncs.pfnSPR_DisableScissor)
//
#define FillRGBA (*gEngfuncs.pfnFillRGBA)
#define FillRGBABlend (*gEngfuncs.pfnFillRGBABlend)


// ScreenHeight returns the height of the screen, in pixels
#define ScreenHeight (gHUD.m_scrinfo.iHeight)
// ScreenWidth returns the width of the screen, in pixels
#define ScreenWidth (gHUD.m_scrinfo.iWidth)

#define TrueHeight (gHUD.m_truescrinfo.iHeight)
#define TrueWidth (gHUD.m_truescrinfo.iWidth)

// Use this to set any co-ords in 640x480 space
#define XRES(x)		((int)(float(x)  * ((float)ScreenWidth / 640.0f) + 0.5f))
#define YRES(y)		((int)(float(y)  * ((float)ScreenHeight / 480.0f) + 0.5f))

// use this to project world coordinates to screen coordinates
#define XPROJECT(x)	( (1.0f+(x))*ScreenWidth*0.5f )
#define YPROJECT(y) ( (1.0f-(y))*ScreenHeight*0.5f )

#define GetScreenInfo (*gEngfuncs.pfnGetScreenInfo)
#define ServerCmd (*gEngfuncs.pfnServerCmd)
#define ClientCmd (*gEngfuncs.pfnClientCmd)
#define SetCrosshair (*gEngfuncs.pfnSetCrosshair)
#define AngleVectors (*gEngfuncs.pfnAngleVectors)
#define Com_RandomLong (*gEngfuncs.pfnRandomLong)
#define Com_RandomFloat (*gEngfuncs.pfnRandomFloat)

extern float color[3]; // hud.cpp

// Gets the height & width of a sprite,  at the specified frame
inline int SPR_Height( HSPRITE x, int f )
{
	return gEngfuncs.pfnSPR_Height(x, f);
}
inline int SPR_Width( HSPRITE x, int f )
{
	return gEngfuncs.pfnSPR_Width(x, f);
}

inline client_textmessage_t *TextMessageGet( const char *pName )
{
	return gEngfuncs.pfnTextMessageGet( pName );
}

inline void ConsolePrint( const char *string )
{
	gEngfuncs.pfnConsolePrint( string );
}

inline void CenterPrint( const char *string )
{
	gEngfuncs.pfnCenterPrint( string );
}

// returns the players name of entity no.
#define GetPlayerInfo (*gEngfuncs.pfnGetPlayerInfo)

// sound functions
inline void PlaySound( const char *szSound, float vol ) { gEngfuncs.pfnPlaySoundByName( szSound, vol ); }
inline void PlaySound( int iSound, float vol ) { gEngfuncs.pfnPlaySoundByIndex( iSound, vol ); }

#define max(a, b)  (((a) > (b)) ? (a) : (b))
#define min(a, b)  (((a) < (b)) ? (a) : (b))
#ifndef __APPLE__
#define fabs(x)	   ((x) > 0 ? (x) : 0 - (x))
#endif
#define DotProduct(x,y) ((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
#define VectorSubtract(a,b,c) {(c)[0]=(a)[0]-(b)[0];(c)[1]=(a)[1]-(b)[1];(c)[2]=(a)[2]-(b)[2];}
#define VectorAdd(a,b,c) {(c)[0]=(a)[0]+(b)[0];(c)[1]=(a)[1]+(b)[1];(c)[2]=(a)[2]+(b)[2];}
#define VectorCopy(a,b) {(b)[0]=(a)[0];(b)[1]=(a)[1];(b)[2]=(a)[2];}
inline void VectorClear(float *a) { a[0]=0.0;a[1]=0.0;a[2]=0.0;}
#define DotProduct(x,y) ((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
#define VectorLength(a) ( sqrt( DotProduct( a, a )))
#define VectorMA(a, scale, b, c) ((c)[0] = (a)[0] + (scale) * (b)[0],(c)[1] = (a)[1] + (scale) * (b)[1],(c)[2] = (a)[2] + (scale) * (b)[2])
#define VectorScale(in, scale, out) ((out)[0] = (in)[0] * (scale),(out)[1] = (in)[1] * (scale),(out)[2] = (in)[2] * (scale))
float VectorNormalize (float *v);
#define VectorInverse(x) ((x)[0] = -(x)[0], (x)[1] = -(x)[1], (x)[2] = -(x)[2])

extern vec3_t vec3_origin;

#ifdef MSC_VER
// disable 'possible loss of data converting float to int' warning message
#pragma warning( disable: 4244 )
// disable 'truncation from 'const double' to 'float' warning message
#pragma warning( disable: 4305 )
#endif

float *GetClientColor( int clientIndex );
inline HSPRITE LoadSprite(const char *pszName)
{
	char sz[256];
	snprintf(sz, 256, pszName, 640);

	return SPR_Load(sz);
}

extern vec3_t g_ColorRed, g_ColorBlue, g_ColorYellow, g_ColorGrey;

inline void GetTeamColor( int &r, int &g, int &b, int teamIndex )
{
	r = 255;
	g = 255;
	b = 255;
	switch( teamIndex )
	{
	case TEAM_TERRORIST:
		r *= g_ColorRed[0];
		g *= g_ColorRed[1];
		b *= g_ColorRed[2];
		break;
	case TEAM_CT:
		r *= g_ColorBlue[0];
		g *= g_ColorBlue[1];
		b *= g_ColorBlue[2];
		break;
	case TEAM_SPECTATOR:
	case TEAM_UNASSIGNED:
		r *= g_ColorYellow[0];
		g *= g_ColorYellow[1];
		b *= g_ColorYellow[2];
		break;
	default:
		r *= g_ColorGrey[0];
		g *= g_ColorGrey[1];
		b *= g_ColorGrey[2];
		break;
	}
}

#define bound( min, num, max ) ((num) >= (min) ? ((num) < (max) ? (num) : (max)) : (min))
#define RAD2DEG( x )	((float)(x) * (float)(180.f / M_PI))
#define DEG2RAD( x )	((float)(x) * (float)(M_PI / 180.f))


```

`cl_dll/include/com_weapons.h`:

```h
//========= Copyright пїЅ 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
// com_weapons.h
// Shared weapons common function prototypes
#if !defined( COM_WEAPONSH )
#define COM_WEAPONSH


#include "hud_iface.h"

#define PLAYER_CAN_SHOOT (1 << 0)
#define PLAYER_FREEZE_TIME_OVER ( 1 << 1 )
#define PLAYER_IN_BOMB_ZONE (1 << 2)
#define PLAYER_HOLDING_SHIELD (1 << 3)

#define CROSSHAIR_
#define ACCURACY_AIR (1 << 0) // accuracy depends on FL_ONGROUND
#define ACCURACY_SPEED (1 << 1)
#define ACCURACY_DUCK (1 << 2) // more accurate when ducking
#define ACCURACY_MULTIPLY_BY_14 (1 << 3) // accuracy multiply to 1.4
#define ACCURACY_MULTIPLY_BY_14_2 (1 << 4) // accuracy multiply to 1.4

#ifndef WPNSTATE_USP_SILENCED
#define WPNSTATE_USP_SILENCED (1<<0)
#define WPNSTATE_GLOCK18_BURST_MODE (1<<1)
#define WPNSTATE_M4A1_SILENCED (1<<2)
#define WPNSTATE_ELITE_LEFT (1<<3)
#define WPNSTATE_FAMAS_BURST_MODE (1<<4)
#define WPNSTATE_SHIELD_DRAWN (1<<5)
#endif


extern "C"
{
	void _DLLEXPORT HUD_PostRunCmd( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
}

void			COM_Log( char *pszFile, char *fmt, ...);
bool			CL_IsDead();

float			UTIL_SharedRandomFloat( unsigned int seed, float low, float high );
int				UTIL_SharedRandomLong( unsigned int seed, int low, int high );

int				HUD_GetWeaponAnim( void );
void			HUD_SendWeaponAnim(int iAnim, int iWeaponId, int iBody, int iForce = 0 );
int				HUD_GetWeapon( void );
void			HUD_PlaySound( char *sound, float volume );
void			HUD_PlaybackEvent( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
//void			HUD_SetMaxSpeed( const struct edict_s *ed, float speed );
int				GetWeaponAccuracyFlags( int weaponid );

extern cvar_t *cl_lw;

extern int g_runfuncs;
extern vec3_t v_angles;
extern float g_lastFOV;
extern int g_iWeaponFlags;
extern bool g_bInBombZone;
extern int g_iFreezeTimeOver;
extern bool g_bHoldingShield;
extern bool g_bHoldingKnife;
extern int g_iPlayerFlags;
extern float g_flPlayerSpeed;
extern Vector g_vPlayerVelocity;
extern struct local_state_s *g_curstate;
extern struct local_state_s *g_finalstate;
extern int g_iShotsFired;

#endif

```

`cl_dll/include/csprite.h`:

```h

/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#pragma once
#ifndef CSPRITE_H
#define CSPRITE_H

// defined in util.cpp
HSPRITE HUD_GetSprite( int index );
wrect_t HUD_GetSpriteRect( int index );
int HUD_GetSpriteIndexByName( const char *sz );

class CClientSprite {
public:
	inline CClientSprite(const char *sprName)
	{
		SetSpriteByName(sprName);
	}
	inline CClientSprite()
	{
		spr = 0;
		rect.bottom = rect.left = rect.right = rect.top = 0;
	}

	inline void SetSpriteByName( const char *sprName )
	{
		index = HUD_GetSpriteIndexByName(sprName);
		spr	= HUD_GetSprite(index);
		rect = HUD_GetSpriteRect(index);
	}

	int index;
	HSPRITE spr;
	wrect_t rect;
};

#endif 

```

`cl_dll/include/demo.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( DEMOH )
#define DEMOH

// Types of demo messages we can write/parse
enum
{
	TYPE_SNIPERDOT = 0,
	TYPE_ZOOM
};

void Demo_WriteBuffer( int type, int size, unsigned char *buffer );

extern int g_demosniper;
extern int g_demosniperdamage;
extern float g_demosniperorg[3];
extern float g_demosniperangles[3];
extern float g_demozoom;

#endif
```

`cl_dll/include/draw_util.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once
#ifndef DRAW_UTIL_H
#define DRAW_UTIL_H
// Drawing primitives

#define DHN_DRAWZERO 1
#define DHN_2DIGITS  2
#define DHN_3DIGITS  4


class DrawUtils
{
public:
	static int DrawHudNumber(int x, int y, int iFlags, int iNumber,
						 int r, int g, int b );

	static int DrawHudNumber2( int x, int y, bool DrawZero, int iDigits, int iNumber,
						   int r, int g, int b);

	static int DrawHudNumber2( int x, int y, int iNumber,
						   int r, int g, int b);

	static int DrawHudString(int x, int y, int iMaxX, const char *szString,
						 int r, int g, int b, float scale = 0.0f, bool drawing = false );

	static int DrawHudStringReverse( int xpos, int ypos, int iMinX, const char *szString,
								 int r, int g, int b, float scale = 0.0f, bool drawing = false );

	static inline int DrawHudNumberString( int xpos, int ypos, int iMinX, int iNumber,
								int r, int g, int b, float scale = 0.0f )
	{
		char szString[16];
		snprintf( szString, sizeof(szString), "%d", iNumber );
		return DrawHudStringReverse( xpos, ypos, iMinX, szString, r, g, b, scale );
	}

	static int HudStringLen( const char *szIt, float scale = 1 );

	// legacy shit came with Valve
	static inline int GetNumWidth(int iNumber, int iFlags)
	{
		if ( iFlags & ( DHN_3DIGITS ) )
			return 3;

		if ( iFlags & ( DHN_2DIGITS ) )
			return 2;

		if ( iNumber <= 0 )
			return iFlags & DHN_DRAWZERO ? 1 : 0;

		if ( iNumber < 10 )
			return 1;

		if ( iNumber < 100 )
			return 2;

		return 3;
	}

	static inline int DrawConsoleString(int x, int y, const char *string)
	{
		if ( gHUD.hud_textmode->value )
		{
			int ret  = DrawHudString( x, y, 9999, (char *)string, color[0] * 255, color[1] * 255, color[2] * 255 );
			color[0] = color[1] = color[2] = 1.0f;
			return ret;
		}
		else
			return gEngfuncs.pfnDrawConsoleString( x, y, (char *)string );
	}

	static inline void SetConsoleTextColor( float r, float g, float b )
	{
		if ( gHUD.hud_textmode->value )
			color[0] = r, color[1] = g, color[2] = b;
		else
			gEngfuncs.pfnDrawSetTextColor( r, g, b );
	}

	static inline void SetConsoleTextColor( unsigned char r, unsigned char g, unsigned char b )
	{
		if ( gHUD.hud_textmode->value )
			color[0] = r / 255.0f, color[1] = g / 255.0f, color[2] = b / 255.0f;
		else
			gEngfuncs.pfnDrawSetTextColor( r / 255.0f, g / 255.0f, b / 255.0f );
	}

	static inline int ConsoleStringLen(  const char *szIt )
	{
		if ( gHUD.hud_textmode->value )
		{
			return HudStringLen( (char *)szIt );
		}
		else
		{
			int _width;

			gEngfuncs.pfnDrawConsoleStringLen( szIt, &_width, NULL );
			return _width;
		}
	}

	static inline void ConsoleStringSize( const char *szIt, int *width, int *height )
	{
		if ( gHUD.hud_textmode->value )
			*height = 13, *width = HudStringLen( (char *)szIt );
		else
			gEngfuncs.pfnDrawConsoleStringLen( szIt, width, height );
	}

	static inline int TextMessageDrawChar( int x, int y, int number, int r, int g, int b, float scale = 0.0f )
	{
		int ret;
		if( scale && g_iMobileAPIVersion )
			ret = gMobileAPI.pfnDrawScaledCharacter( x, y, number, r, g, b, scale ) / gHUD.m_flScale;
		else
			ret = gEngfuncs.pfnDrawCharacter( x, y, number, r, g, b );
		return ret;
	}

	static inline void UnpackRGB( int &r, int &g, int &b, const unsigned long ulRGB )
	{
		r = (ulRGB & 0xFF0000) >>16;
		g = (ulRGB & 0xFF00) >> 8;
		b = ulRGB & 0xFF;
	}

	static inline void ScaleColors( int &r, int &g, int &b, const int a )
	{
		r *= a / 255.0f;
		g *= a / 255.0f;
		b *= a / 255.0f;
	}

	static inline void DrawRectangle( int x, int y, int wide, int tall,
						   int r = 0, int g = 0, int b = 0, int a = 153,
						   bool drawStroke = true )
	{
		FillRGBABlend( x, y, wide, tall, r, g, b, a );
		if ( drawStroke )
		{
			// TODO: remove this hardcoded hardcore
			FillRGBA( x + 1,        y,            wide - 1, 1,        255, 140, 0, 255 );
			FillRGBA( x,            y,            1,        tall - 1, 255, 140, 0, 255 );
			FillRGBA( x + wide - 1, y + 1,        1,        tall - 1, 255, 140, 0, 255 );
			FillRGBA( x,            y + tall - 1, wide - 1, 1,        255, 140, 0, 255 );
		}
	}

	static void Draw2DQuad( float x1, float y1, float x2, float y2 );

private:
	// console string color
	static float color[3];
};

#endif // DRAW_UTIL_H

```

`cl_dll/include/ev_hldm.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined ( EV_HLDMH )
#define EV_HLDMH

// bullet types
typedef enum
{
	BULLET_NONE = 0,
	BULLET_PLAYER_9MM,
	BULLET_PLAYER_MP5,
	BULLET_PLAYER_357,
	BULLET_PLAYER_BUCKSHOT,
	BULLET_PLAYER_CROWBAR,

	BULLET_MONSTER_9MM,
	BULLET_MONSTER_MP5,
	BULLET_MONSTER_12MM,

	BULLET_PLAYER_45ACP,
	BULLET_PLAYER_338MAG,
	BULLET_PLAYER_762MM,
	BULLET_PLAYER_556MM,
	BULLET_PLAYER_50AE,
	BULLET_PLAYER_57MM,
	BULLET_PLAYER_357SIG
}
Bullet;

enum
{
	SMOKE_WALLPUFF = 0,
	SMOKE_RIFLE,
	SMOKE_PISTOL,
	SMOKE_BLACK
};

void EV_HLDM_GunshotDecalTrace(pmtrace_t *pTrace, char *decalName , char chTextureType);
void EV_HLDM_DecalGunshot(pmtrace_t *pTrace, int iBulletType, float scale, int r, int g, int b, bool bCreateSparks, char cTextureType, bool isSky);
void EV_HLDM_FireBullets(int idx,
						 float *forward, float *right, float *up,
						 int cShots,
						 float *vecSrc, float *vecDirShooting, float *vecSpread,
						 float flDistance, int iBulletType, int iPenetration);
void EV_CS16Client_KillEveryRound( struct tempent_s *te, float frametime, float currenttime );
void EV_CS16Client_CreateSmoke(int type, Vector origin, Vector dir, int speed, float scale, int r, int g, int b , bool wind, Vector velocity = Vector(0, 0, 0), int framerate = 35 );
#endif // EV_HLDMH

```

`cl_dll/include/events.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once
#ifndef EVENTS_H
#define EVENTS_H

#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"

#include "r_efx.h"

#include "eventscripts.h"
#include "event_api.h"
#include "pm_defs.h"
#include "ev_hldm.h"
#include "com_weapons.h"

#ifndef PITCH
// MOVEMENT INFO
// up / down
#define	PITCH	0
// left / right
#define	YAW		1
// fall over
#define	ROLL	2
#endif

#define DECLARE_EVENT( x ) void EV_##x( struct event_args_s *args )
#define HOOK_EVENT( x, y ) gEngfuncs.pfnHookEvent( "events/" #x ".sc", EV_##y )

#define PLAY_EVENT_SOUND( x ) gEngfuncs.pEventAPI->EV_PlaySound( idx, origin, CHAN_WEAPON, (x), VOL_NORM, ATTN_NORM, 0, 94 + gEngfuncs.pfnRandomLong( 0, 15 ) )


// enable it until fix isn't applied in Xash3D
//#define _CS16CLIENT_FIX_EVENT_ORIGIN

extern int g_iPShell;
extern int g_iRShell;
extern int g_iShotgunShell;
extern int g_iBlackSmoke;

extern "C"
{
DECLARE_EVENT(FireAK47);
DECLARE_EVENT(FireAUG);
DECLARE_EVENT(FireAWP);
DECLARE_EVENT(CreateExplo);
DECLARE_EVENT(CreateSmoke);
DECLARE_EVENT(FireDEAGLE);
DECLARE_EVENT(DecalReset);
DECLARE_EVENT(FireEliteLeft);
DECLARE_EVENT(FireEliteRight);
DECLARE_EVENT(FireFAMAS);
DECLARE_EVENT(Fire57);
DECLARE_EVENT(FireG3SG1);
DECLARE_EVENT(FireGALIL);
DECLARE_EVENT(Fireglock18);
DECLARE_EVENT(Knife);
DECLARE_EVENT(FireM249);
DECLARE_EVENT(FireM3);
DECLARE_EVENT(FireM4A1);
DECLARE_EVENT(FireMAC10);
DECLARE_EVENT(FireMP5);
DECLARE_EVENT(FireP228);
DECLARE_EVENT(FireP90);
DECLARE_EVENT(FireScout);
DECLARE_EVENT(FireSG550);
DECLARE_EVENT(FireSG552);
DECLARE_EVENT(FireTMP);
DECLARE_EVENT(FireUMP45);
DECLARE_EVENT(FireUSP);
DECLARE_EVENT(Vehicle);
DECLARE_EVENT(FireXM1014);
DECLARE_EVENT(TrainPitchAdjust);
}

void Game_HookEvents( void );

#endif

```

`cl_dll/include/eventscripts.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
// eventscripts.h
#if !defined ( EVENTSCRIPTSH )
#define EVENTSCRIPTSH

#include "pmtrace.h"
#include "pm_shared.h"
#include "event_api.h"
#include "r_efx.h"

// defaults for clientinfo messages
#define	DEFAULT_VIEWHEIGHT	28
#define VEC_DUCK_VIEW 12

#define FTENT_FADEOUT			0x00000080

#define DMG_GENERIC			0			// generic damage was done
#define DMG_CRUSH			(1 << 0)	// crushed by falling or moving object
#define DMG_BULLET			(1 << 1)	// shot
#define DMG_SLASH			(1 << 2)	// cut, clawed, stabbed
#define DMG_BURN			(1 << 3)	// heat burned
#define DMG_FREEZE			(1 << 4)	// frozen
#define DMG_FALL			(1 << 5)	// fell too far
#define DMG_BLAST			(1 << 6)	// explosive blast damage
#define DMG_CLUB			(1 << 7)	// crowbar, punch, headbutt
#define DMG_SHOCK			(1 << 8)	// electric shock
#define DMG_SONIC			(1 << 9)	// sound pulse shockwave
#define DMG_ENERGYBEAM		(1 << 10)	// laser or other high energy beam 
#define DMG_NEVERGIB		(1 << 12)	// with this bit OR'd in, no damage type will be able to gib victims upon death
#define DMG_ALWAYSGIB		(1 << 13)	// with this bit OR'd in, any damage type can be made to gib victims upon death.

// time-based damage
//mask off TF-specific stuff too
#define DMG_TIMEBASED		(~(0xff003fff))	// mask for time-based damage

#define DMG_DROWN			(1 << 14)	// Drowning
#define DMG_FIRSTTIMEBASED  DMG_DROWN

#define DMG_PARALYZE		(1 << 15)	// slows affected creature down
#define DMG_NERVEGAS		(1 << 16)	// nerve toxins, very bad
#define DMG_POISON			(1 << 17)	// blood poisioning
#define DMG_RADIATION		(1 << 18)	// radiation exposure
#define DMG_DROWNRECOVER	(1 << 19)	// drowning recovery
#define DMG_ACID			(1 << 20)	// toxic chemicals or acid burns
#define DMG_SLOWBURN		(1 << 21)	// in an oven
#define DMG_SLOWFREEZE		(1 << 22)	// in a subzero freezer
#define DMG_MORTAR			(1 << 23)	// Hit by air raid (done to distinguish grenade from mortar)

//TF ADDITIONS
#define DMG_IGNITE			(1 << 24)	// Players hit by this begin to burn
#define DMG_RADIUS_MAX		(1 << 25)	// Radius damage with this flag doesn't decrease over distance
#define DMG_RADIUS_QUAKE	(1 << 26)	// Radius damage is done like Quake. 1/2 damage at 1/2 radius.
#define DMG_IGNOREARMOR		(1 << 27)	// Damage ignores target's armor
#define DMG_AIMED			(1 << 28)   // Does Hit location damage
#define DMG_WALLPIERCING	(1 << 29)	// Blast Damages ents through walls

#define DMG_CALTROP				(1<<30)
#define DMG_HALLUC				(1<<31)

#define IS_FIRSTPERSON_SPEC ( g_iUser1 == OBS_IN_EYE || (g_iUser1 && (gHUD.m_Spectator.m_pip->value == INSET_IN_EYE)) )

// Some of these are HL/TFC specific?
void EV_GetGunPosition( struct event_args_s *args, float *pos, float *origin );
void EV_GetDefaultShellInfo( struct event_args_s *args, float *origin, float *velocity, float *ShellVelocity, float *ShellOrigin, float *forward, float *right, float *up, float forwardScale, float upScale, float rightScale, bool bReverseDirection = false );
void CreateCorpse(Vector *p_vOrigin, Vector *p_vAngles, const char *pModel, float flAnimTime, int iSequence, int iBody);


// Very simple and little functions that can be inlined

/*
=================
EV_MuzzleFlash

Flag weapon/view model for muzzle flash
=================
*/
inline void EV_MuzzleFlash( void )
{
	if( gHUD.cl_lw->value )
		return;

	// Add muzzle flash to current weapon model
	cl_entity_t *ent = gEngfuncs.GetViewModel();
	if ( !ent )
		return;

	// Or in the muzzle flash
	ent->curstate.effects |= EF_MUZZLEFLASH;
}

/*
=================
EV_IsPlayer

Is the entity's index in the player range?
=================
*/
inline bool EV_IsPlayer( int idx )
{
	if ( idx >= 1 && idx <= gEngfuncs.GetMaxClients() )
		return true;

	return false;
}


/*
=================
EV_IsLocal

Is the entity == the local player
=================
*/
inline bool EV_IsLocal( int idx )
{
	// check if we are in some way in first person spec mode
	if ( IS_FIRSTPERSON_SPEC  )
		return (g_iUser2 == idx);
	else
		return gEngfuncs.pEventAPI->EV_IsLocal( idx - 1 ) ? true : false;
}

/*
=================
EV_EjectBrass

Bullet shell casings
=================
*/
inline void EV_EjectBrass( float *origin, float *velocity, float rotation, int model, int soundtype, float life = 2.5f )
{
	Vector angles(0.0f, 0.0f, rotation);
	gEngfuncs.pEfxAPI->R_TempModel( origin, velocity, angles, life, model, soundtype );
}


#endif // EVENTSCRIPTS_H

```

`cl_dll/include/hud/ammo.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#pragma once
#ifndef __AMMO_H__
#define __AMMO_H__

#define MAX_WEAPON_NAME 128


#define WEAPON_FLAGS_SELECTONEMPTY	1

#define WEAPON_IS_ONTARGET 0x40

struct WEAPON
{
	char	szName[MAX_WEAPON_NAME];
	int		iAmmoType;
	int		iAmmo2Type;
	int		iMax1;
	int		iMax2;
	int		iSlot;
	int		iSlotPos;
	int		iFlags;
	int		iId;
	int		iClip;

	int		iCount;		// # of itesm in plist

	HSPRITE hActive;
	wrect_t rcActive;
	HSPRITE hInactive;
	wrect_t rcInactive;
	HSPRITE	hAmmo;
	wrect_t rcAmmo;
	HSPRITE hAmmo2;
	wrect_t rcAmmo2;
	HSPRITE hCrosshair;
	wrect_t rcCrosshair;
	HSPRITE hAutoaim;
	wrect_t rcAutoaim;
	HSPRITE hZoomedCrosshair;
	wrect_t rcZoomedCrosshair;
	HSPRITE hZoomedAutoaim;
	wrect_t rcZoomedAutoaim;
};

typedef int AMMO;


#endif
```

`cl_dll/include/hud/ammohistory.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// ammohistory.h
//
#pragma once
// this is the max number of items in each bucket
#define MAX_WEAPON_POSITIONS		19

class WeaponsResource
{
private:
	// Information about weapons & ammo
	WEAPON		rgWeapons[MAX_WEAPONS];	// Weapons Array

	// counts of weapons * ammo
	WEAPON*		rgSlots[MAX_WEAPON_SLOTS+1][MAX_WEAPON_POSITIONS+1];	// The slots currently in use by weapons.  The value is a pointer to the weapon;  if it's NULL, no weapon is there
	int			riAmmo[MAX_AMMO_TYPES];							// count of each ammo type

public:
	void Init( void )
	{
		memset( rgWeapons, 0, sizeof rgWeapons );
		Reset();
	}

	void Reset( void )
	{
		iOldWeaponBits = 0;
		memset( rgSlots, 0, sizeof rgSlots );
		memset( riAmmo, 0, sizeof riAmmo );
	}

///// WEAPON /////
	int			iOldWeaponBits;

	WEAPON *GetWeapon( int iId ) { return &rgWeapons[iId]; }
	void AddWeapon( WEAPON *wp ) 
	{ 
		rgWeapons[ wp->iId ] = *wp;	
		LoadWeaponSprites( &rgWeapons[ wp->iId ] );
	}

	void PickupWeapon( WEAPON *wp )
	{
		rgSlots[ wp->iSlot ][ wp->iSlotPos ] = wp;
	}

	void DropWeapon( WEAPON *wp )
	{
		rgSlots[ wp->iSlot ][ wp->iSlotPos ] = NULL;
	}

	void DropAllWeapons( void )
	{
		for ( int i = 0; i < MAX_WEAPONS; i++ )
		{
			if ( rgWeapons[i].iId )
				DropWeapon( &rgWeapons[i] );
		}
	}

	WEAPON* GetWeaponSlot( int slot, int pos ) { return rgSlots[slot][pos]; }

	void LoadWeaponSprites( WEAPON* wp );
	void LoadAllWeaponSprites( void );
	WEAPON* GetFirstPos( int iSlot );
	void SelectSlot( int iSlot, int fAdvance, int iDirection );
	WEAPON* GetNextActivePos( int iSlot, int iSlotPos );

	int HasAmmo( WEAPON *p );

///// AMMO /////
	AMMO GetAmmo( int iId ) { return iId; }

	void SetAmmo( int iId, int iCount ) { riAmmo[ iId ] = iCount;	}

	int CountAmmo( int iId );

	HSPRITE* GetAmmoPicFromWeapon( int iAmmoId, wrect_t& rect );
};

extern WeaponsResource gWR;


#define MAX_HISTORY 12
enum {
	HISTSLOT_EMPTY,
	HISTSLOT_AMMO,
	HISTSLOT_WEAP,
	HISTSLOT_ITEM,
};

class HistoryResource
{
private:
	struct HIST_ITEM {
		int type;
		float DisplayTime;  // the time at which this item should be removed from the history
		int iCount;
		int iId;
	};

	HIST_ITEM rgAmmoHistory[MAX_HISTORY];

public:

	void Init( void )
	{
		Reset();
	}

	void Reset( void )
	{
		memset( rgAmmoHistory, 0, sizeof rgAmmoHistory );
	}

	int iHistoryGap;
	int iCurrentHistorySlot;

	void AddToHistory( int iType, int iId, int iCount = 0 );
	void AddToHistory( int iType, const char *szName, int iCount = 0 );

	void CheckClearHistory( void );
	int DrawAmmoHistory( float flTime );
};

extern HistoryResource gHR;




```

`cl_dll/include/hud/health.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#pragma once
#define DMG_IMAGE_LIFE		2	// seconds that image is up

#define DMG_IMAGE_POISON	0
#define DMG_IMAGE_ACID		1
#define DMG_IMAGE_COLD		2
#define DMG_IMAGE_DROWN		3
#define DMG_IMAGE_BURN		4
#define DMG_IMAGE_NERVE		5
#define DMG_IMAGE_RAD		6
#define DMG_IMAGE_SHOCK		7
//tf defines
#define DMG_IMAGE_CALTROP	8
#define DMG_IMAGE_TRANQ		9
#define DMG_IMAGE_CONCUSS	10
#define DMG_IMAGE_HALLUC	11
#define NUM_DMG_TYPES		12
// instant damage

#define DMG_GENERIC			0			// generic damage was done
#define DMG_CRUSH			(1 << 0)	// crushed by falling or moving object
#define DMG_BULLET			(1 << 1)	// shot
#define DMG_SLASH			(1 << 2)	// cut, clawed, stabbed
#define DMG_BURN			(1 << 3)	// heat burned
#define DMG_FREEZE			(1 << 4)	// frozen
#define DMG_FALL			(1 << 5)	// fell too far
#define DMG_BLAST			(1 << 6)	// explosive blast damage
#define DMG_CLUB			(1 << 7)	// crowbar, punch, headbutt
#define DMG_SHOCK			(1 << 8)	// electric shock
#define DMG_SONIC			(1 << 9)	// sound pulse shockwave
#define DMG_ENERGYBEAM		(1 << 10)	// laser or other high energy beam 
#define DMG_NEVERGIB		(1 << 12)	// with this bit OR'd in, no damage type will be able to gib victims upon death
#define DMG_ALWAYSGIB		(1 << 13)	// with this bit OR'd in, any damage type can be made to gib victims upon death.


// time-based damage
//mask off TF-specific stuff too
#define DMG_TIMEBASED		(~(0xff003fff))	// mask for time-based damage


#define DMG_DROWN			(1 << 14)	// Drowning
#define DMG_FIRSTTIMEBASED  DMG_DROWN

#define DMG_PARALYZE		(1 << 15)	// slows affected creature down
#define DMG_NERVEGAS		(1 << 16)	// nerve toxins, very bad
#define DMG_POISON			(1 << 17)	// blood poisioning
#define DMG_RADIATION		(1 << 18)	// radiation exposure
#define DMG_DROWNRECOVER	(1 << 19)	// drowning recovery
#define DMG_ACID			(1 << 20)	// toxic chemicals or acid burns
#define DMG_SLOWBURN		(1 << 21)	// in an oven
#define DMG_SLOWFREEZE		(1 << 22)	// in a subzero freezer
#define DMG_MORTAR			(1 << 23)	// Hit by air raid (done to distinguish grenade from mortar)

//TF ADDITIONS
#define DMG_IGNITE			(1 << 24)	// Players hit by this begin to burn
#define DMG_RADIUS_MAX		(1 << 25)	// Radius damage with this flag doesn't decrease over distance
#define DMG_RADIUS_QUAKE	(1 << 26)	// Radius damage is done like Quake. 1/2 damage at 1/2 radius.
#define DMG_IGNOREARMOR		(1 << 27)	// Damage ignores target's armor
#define DMG_AIMED			(1 << 28)   // Does Hit location damage
#define DMG_WALLPIERCING	(1 << 29)	// Blast Damages ents through walls

#define DMG_CALTROP				(1<<30)
#define DMG_HALLUC				(1<<31)

// TF Healing Additions for TakeHealth
#define DMG_IGNORE_MAXHEALTH	DMG_IGNITE
// TF Redefines since we never use the originals
#define DMG_NAIL				DMG_SLASH
#define DMG_NOT_SELF			DMG_FREEZE


#define DMG_TRANQ				DMG_MORTAR
#define DMG_CONCUSS				DMG_SONIC


struct DAMAGE_IMAGE
{
	float fExpire;
	float fBaseline;
	int	x, y;
};
	
//
//-----------------------------------------------------
//
class CHudHealth: public CHudBase
{
public:
	virtual int Init( void );
	virtual int VidInit( void );
	virtual int Draw(float fTime);
	virtual void Reset( void );

	int MsgFunc_Health(const char *pszName,  int iSize, void *pbuf);
	int MsgFunc_Damage(const char *pszName,  int iSize, void *pbuf);
	int MsgFunc_ScoreAttrib(const char *pszName,  int iSize, void *pbuf);
	int MsgFunc_ClCorpse(const char *pszName,  int iSize, void *pbuf);


	int m_iHealth;
	int m_HUD_dmg_bio;
	int m_HUD_cross;
	//float m_fAttackFront, m_fAttackRear, m_fAttackLeft, m_fAttackRight;
	float m_fAttack[4];
	void GetPainColor(int &r, int &g, int &b , int &a);
	float m_fFade;
private:
	void DrawPain( float fTime );
	void DrawDamage( float fTime );
	void DrawHealthBar( float flTime );
	void CalcDamageDirection( Vector vecFrom );
	void UpdateTiles( float fTime, long bits );
	void DrawPlayerLocation( void );

	HSPRITE m_hSprite;
	HSPRITE m_hDamage;
	Vector2D m_vAttackPos[4];
	DAMAGE_IMAGE m_dmg[NUM_DMG_TYPES];
	float m_flTimeFlash;
	int	m_bitsDamage;
	cvar_t *cl_radartype;
};

```

`cl_dll/include/hud/hud.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//			
//  hud.h
//
// class CHud declaration
//
// CHud handles the message, calculation, and drawing the HUD
//
#pragma once

#define RGB_YELLOWISH 0x00FFA000 //255,160,0
#define RGB_REDISH 0x00FF1010 //255,16,16
#define RGB_GREENISH 0x0000A000 //0,160,0
#define RGB_WHITE 0x00FFFFFF

#include <assert.h>
#include <string.h>

#include "wrect.h"
#include "cl_dll.h"
#include "ammo.h"

#include "csprite.h"
#include "cvardef.h"

#define MIN_ALPHA	 100	
#define	HUDELEM_ACTIVE	1
#define CHudMsgFunc(x) int MsgFunc_##x(const char *pszName, int iSize, void *buf)
#define CHudUserCmd(x) void UserCmd_##x()

class RGBA
{
public:
	unsigned char r, g, b, a;
};

enum 
{ 
	MAX_PLAYERS = 33, // including the bomb
	MAX_TEAMS = 3,
	MAX_TEAM_NAME = 16,
	MAX_HOSTAGES = 24,
};

extern const char *sPlayerModelFiles[];
extern wrect_t nullrc;

class CClientSprite;

inline bool BIsValidTModelIndex( int i )
{
	if ( i == 1 || i == 5 || i == 6 || i == 8 || i == 11 )
		return true;
	else
		return false;
}

inline bool BIsValidCTModelIndex( int i )
{
	if ( i == 7 || i == 2 || i == 10 || i == 4 || i == 9)
		return true;
	else
		return false;
}

#define HUD_DRAW         (1 << 0)
#define HUD_THINK        (1 << 1)
#define HUD_ACTIVE       (HUD_DRAW | HUD_THINK)
#define HUD_INTERMISSION (1 << 2)

#define MAX_PLAYER_NAME_LENGTH		32

#define	MAX_MOTD_LENGTH				1536

//
//-----------------------------------------------------
//
class CHudBase
{
public:
	int	  m_iFlags; // active, moving,
	virtual		~CHudBase() {}
	virtual int Init( void ) {return 0;}
	virtual int VidInit( void ) {return 0;}
	virtual int Draw(float flTime) {return 0;}
	virtual void Think(void) {return;}
	virtual void Reset(void) {return;}
	virtual void InitHUDData( void ) {}		// called every time a server is connected to
	virtual void Shutdown( void ) {}

};

struct HUDLIST {
	CHudBase	*p;
	HUDLIST		*pNext;
};



//
//-----------------------------------------------------
//
//#include "voice_status.h"
#include "hud_spectator.h"


//
//-----------------------------------------------------
//
class CHudAmmo: public CHudBase
{
	friend class WeaponsResource;
	friend class HistoryResource;

public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	void Think(void);
	void Reset(void);

	void DrawCrosshair(float flTime);
	void CalcCrosshairSize();
	void CalcCrosshairDrawMode();
	void CalcCrosshairColor();

	int DrawWList(float flTime);
	CHudMsgFunc(CurWeapon);
	CHudMsgFunc(WeaponList);
	CHudMsgFunc(AmmoX);
	CHudMsgFunc(AmmoPickup);
	CHudMsgFunc(WeapPickup);
	CHudMsgFunc(ItemPickup);
	CHudMsgFunc(HideWeapon);
	CHudMsgFunc(Crosshair);
	CHudMsgFunc(Brass);


	void SlotInput( int iSlot );
	CHudUserCmd(Slot1);
	CHudUserCmd(Slot2);
	CHudUserCmd(Slot3);
	CHudUserCmd(Slot4);
	CHudUserCmd(Slot5);
	CHudUserCmd(Slot6);
	CHudUserCmd(Slot7);
	CHudUserCmd(Slot8);
	CHudUserCmd(Slot9);
	CHudUserCmd(Slot10);
	CHudUserCmd(Close);
	CHudUserCmd(NextWeapon);
	CHudUserCmd(PrevWeapon);
	CHudUserCmd(Adjust_Crosshair);
	CHudUserCmd(Rebuy);
	CHudUserCmd(Autobuy);

private:
	float m_fFade;
	RGBA  m_rgba;
	WEAPON *m_pWeapon;
	int	m_HUD_bucket0;
	int m_HUD_selection;

	int m_iAlpha;
	int m_R, m_G, m_B;
	int m_cvarR, m_cvarG, m_cvarB;
	int m_iCurrentCrosshair;
	int m_iCrosshairScaleBase;
	float m_flCrosshairDistance;
	bool m_bAdditive;
	bool m_bObserverCrosshair ;
	bool m_bDrawCrosshair;
	int m_iAmmoLastCheck;

	convar_t *m_pClCrosshairColor;
	convar_t *m_pClCrosshairTranslucent;
	convar_t *m_pClCrosshairSize;
	cvar_t *m_pClDynamicCrosshair;
	cvar_t *m_pHud_FastSwitch;
	cvar_t *m_pHud_DrawHistory_Time;

};

//
//-----------------------------------------------------
//

class CHudAmmoSecondary: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	void Reset( void );
	int Draw(float flTime);

	CHudMsgFunc(SecAmmoVal);
	CHudMsgFunc(SecAmmoIcon);

private:
	enum {
		MAX_SEC_AMMO_VALUES = 4
	};

	int m_HUD_ammoicon; // sprite indices
	int m_iAmmoAmounts[MAX_SEC_AMMO_VALUES];
	float m_fFade;
};


#include "health.h"
#include "radar.h"

#define FADE_TIME 100


//
//-----------------------------------------------------
//
class CHudGeiger: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	CHudMsgFunc(Geiger);
	
private:
	int m_iGeigerRange;

};

//
//-----------------------------------------------------
//
class CHudTrain: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	CHudMsgFunc(Train);

private:
	HSPRITE m_hSprite;
	int m_iPos;

};

//
//-----------------------------------------------------
//
//  MOTD in cs16 must render HTML, so it disabled
//

class CHudMOTD : public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Reset( void );

	CHudMsgFunc(MOTD);
	void Scroll( int dir );
	void Scroll( float amount );
	float scroll;
	bool m_bShow;
	cvar_t *cl_hide_motd;

protected:
	static int MOTD_DISPLAY_TIME;
	char m_szMOTD[ MAX_MOTD_LENGTH ];
	
	int m_iLines;
	int m_iMaxLength;
	bool ignoreThisMotd;
};


class CHudScoreboard: public CHudBase
{
	friend class CHudSpectatorGui;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );

	int DrawScoreboard( float flTime );
	int DrawTeams( float listslot );
	int DrawPlayers( float listslot, int nameoffset = 0, const char *team = NULL ); // returns the ypos where it finishes drawing

	void DeathMsg( int killer, int victim );
	void SetScoreboardDefaults( void );
	void GetAllPlayersInfo( void );

	CHudUserCmd(ShowScores);
	CHudUserCmd(HideScores);
	CHudUserCmd(ShowScoreboard2);
	CHudUserCmd(HideScoreboard2);

	CHudMsgFunc(ScoreInfo);
	CHudMsgFunc(TeamInfo);
	CHudMsgFunc(TeamScore);
	CHudMsgFunc(TeamScores);
	CHudMsgFunc(TeamNames);

	int m_iPlayerNum;
	int m_iNumTeams;

private:
	int m_iLastKilledBy;
	int m_fLastKillTime;
	RGBA m_colors;
	bool m_bDrawStroke;
	bool m_bForceDraw; // if called by showscoreboard2
	bool m_bShowscoresHeld;
	cvar_t *cl_showpacketloss;
};

//
//-----------------------------------------------------
//
class CHudStatusBar : public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Reset( void );
	void ParseStatusString( int line_num );

	CHudMsgFunc(StatusText);
	CHudMsgFunc(StatusValue);

protected:
	enum {
		MAX_STATUSTEXT_LENGTH = 128,
		MAX_STATUSBAR_VALUES = 8,
		MAX_STATUSBAR_LINES = 2,
	};

	char m_szStatusText[MAX_STATUSBAR_LINES][MAX_STATUSTEXT_LENGTH];  // a text string describing how the status bar is to be drawn
	char m_szStatusBar[MAX_STATUSBAR_LINES][MAX_STATUSTEXT_LENGTH];	// the constructed bar that is drawn
	int m_iStatusValues[MAX_STATUSBAR_VALUES];  // an array of values for use in the status bar

	int m_bReparseString; // set to TRUE whenever the m_szStatusBar needs to be recalculated

	// an array of colors...one color for each line
	float *m_pflNameColors[MAX_STATUSBAR_LINES];

	cvar_t *hud_centerid;
};

struct extra_player_info_t 
{
	short frags;
	short deaths;
	short playerclass;
	short teamnumber;
	char teamname[MAX_TEAM_NAME];
	bool has_c4;
	bool vip;
	bool dead;
	bool showhealth;
	bool nextflash;
	bool talking;
	Vector origin;
	int health;
	int radarflashes;
	float radarflashtime;
	float radarflashtimedelta;
	char location[32];
};

struct team_info_t 
{
	char name[MAX_TEAM_NAME];
	short frags;
	short deaths;
	short ownteam;
	short players;
	int already_drawn;
	int scores_overriden;
	int sumping;
	int teamnumber;
};

struct hostage_info_t
{
	vec3_t origin;
	float radarflashtimedelta;
	float radarflashtime;
	bool dead;
	bool nextflash;
	int radarflashes;
};

extern hud_player_info_t	g_PlayerInfoList[MAX_PLAYERS+1];	   // player info from the engine
extern extra_player_info_t  g_PlayerExtraInfo[MAX_PLAYERS+1];   // additional player info sent directly to the client dll
extern team_info_t			g_TeamInfo[MAX_TEAMS+1];
extern hostage_info_t		g_HostageInfo[MAX_HOSTAGES+1];
extern int					g_IsSpectator[MAX_PLAYERS+1];


//
//-----------------------------------------------------
//
class CHudDeathNotice : public CHudBase
{
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	CHudMsgFunc(DeathMsg);

private:
	int m_HUD_d_skull;  // sprite index of skull icon
	int m_HUD_d_headshot;
	cvar_t *hud_deathnotice_time;
};

//
//-----------------------------------------------------
//
class CHudMenu : public CHudBase
{
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	void Reset( void );
	int Draw( float flTime );

	CHudMsgFunc(ShowMenu);
	CHudMsgFunc(BuyClose);
	CHudMsgFunc(VGUIMenu);
	// server sends false when spectating is not allowed, and true when allowed
	CHudMsgFunc(AllowSpec);

	CHudUserCmd(OldStyleMenuClose);
	CHudUserCmd(OldStyleMenuOpen);
	CHudUserCmd(ShowVGUIMenu);

	void ShowVGUIMenu( int menuType ); // cs16client extension

	void SelectMenuItem( int menu_item );

	int m_fMenuDisplayed;
	bool m_bAllowSpec;
	cvar_t *_extended_menus;
	int m_bitsValidSlots;
	float m_flShutoffTime;
	int m_fWaitingForMore;

};

//
//-----------------------------------------------------
//
class CHudSayText : public CHudBase
{
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	CHudMsgFunc(SayText);
	void SayTextPrint( const char *pszBuf, int iBufSize, int clientIndex = -1 );
	void SayTextPrint( char szBuf[3][256] );
	void EnsureTextFitsInOneLineAndWrapIfHaveTo( int line );
	friend class CHudSpectator;

private:

	struct cvar_s *	m_HUD_saytext;
	struct cvar_s *	m_HUD_saytext_time;
};

//
//-----------------------------------------------------
//
class CHudBattery: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	void InitHUDData( void );
	CHudMsgFunc(Battery);
	CHudMsgFunc(ArmorType);
	
private:
	enum armortype_t {
		Vest = 0,
		VestHelm
	} m_enArmorType;

	CClientSprite m_hEmpty[VestHelm + 1];
	CClientSprite m_hFull[VestHelm + 1];
	int	  m_iBat;
	float m_fFade;
	int	  m_iHeight;		// width of the battery innards
};


//
//-----------------------------------------------------
//
class CHudFlashlight: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	void Reset( void );
	CHudMsgFunc(Flashlight);
	CHudMsgFunc(FlashBat);
	
private:
	CClientSprite m_hSprite1;
	CClientSprite m_hSprite2;
	CClientSprite m_hBeam;
	float m_flBat;
	int	  m_iBat;
	int	  m_fOn;
	float m_fFade;
	int	  m_iWidth;		// width of the battery innards
};

//
//-----------------------------------------------------
//
const int maxHUDMessages = 16;
struct message_parms_t
{
	client_textmessage_t	*pMessage;
	float	time;
	int x, y;
	int	totalWidth, totalHeight;
	int width;
	int lines;
	int lineLength;
	int length;
	int r, g, b;
	int text;
	int fadeBlend;
	float charTime;
	float fadeTime;
};

//
//-----------------------------------------------------
//

class CHudTextMessage: public CHudBase
{
public:
	int Init( void );
	static char *LocaliseTextString( const char *msg, char *dst_buffer, int buffer_size );
	static char *BufferedLocaliseTextString( const char *msg );
	static char *LookupString( char *msg_name, int *msg_dest = NULL );
	CHudMsgFunc(TextMsg);
};

//
//-----------------------------------------------------
//

class CHudMessage: public CHudBase
{
public:
	friend class CHudTextMessage;
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	CHudMsgFunc(HudText);
	CHudMsgFunc(GameTitle);
	CHudMsgFunc(HudTextArgs);
	CHudMsgFunc(HudTextPro);

	float FadeBlend( float fadein, float fadeout, float hold, float localTime );
	int	XPosition( float x, int width, int lineWidth );
	int YPosition( float y, int height );

	void MessageAdd( const char *pName, float time );
	void MessageAdd(client_textmessage_t * newMessage );
	void MessageDrawScan( client_textmessage_t *pMessage, float time );
	void MessageScanStart( void );
	void MessageScanNextChar( void );
	void Reset( void );

private:
	client_textmessage_t		*m_pMessages[maxHUDMessages];
	float						m_startTime[maxHUDMessages];
	message_parms_t				m_parms;
	float						m_gameTitleTime;
	client_textmessage_t		*m_pGameTitle;

	int m_HUD_title_life;
	int m_HUD_title_half;
};

//
//-----------------------------------------------------
//
#define MAX_SPRITE_NAME_LENGTH	24

class CHudStatusIcons: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	void Reset( void );
	int Draw(float flTime);
	CHudMsgFunc(StatusIcon);

	enum {
		MAX_ICONSPRITENAME_LENGTH = MAX_SPRITE_NAME_LENGTH,
		MAX_ICONSPRITES = 4,
	};

	
	//had to make these public so CHud could access them (to enable concussion icon)
	//could use a friend declaration instead...
	void EnableIcon( const char *pszIconName, unsigned char red, unsigned char green, unsigned char blue );
	void DisableIcon( const char *pszIconName );

	friend class CHudScoreboard;

private:

	typedef struct
	{
		char szSpriteName[MAX_ICONSPRITENAME_LENGTH];
		HSPRITE spr;
		wrect_t rc;
		unsigned char r, g, b;
		unsigned char secR, secG, secB;
		float flTimeToChange;
	} icon_sprite_t;

	icon_sprite_t m_IconList[MAX_ICONSPRITES];
};


//
//-----------------------------------------------------
//
#define MONEY_YPOS ScreenHeight - 3 * gHUD.m_iFontHeight

class CHudMoney : public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	CHudMsgFunc(Money);
	CHudMsgFunc(BlinkAcct);

private:
	int m_iMoneyCount;
	int m_iDelta;
	int m_iBlinkAmt;
	float m_fBlinkTime;
	float m_fFade;
	CClientSprite m_hDollar;
	CClientSprite m_hPlus;
	CClientSprite m_hMinus;
};
//
//-----------------------------------------------------
//
class CHudRadio: public CHudBase
{
public:
	int Init( void );
	void Voice(int entindex, bool bTalking );
	// play a sentence from a radio
	// [byte] unknown (always 1)
	// [string] sentence name
	// [short] unknown. (always 100, it's a volume?)
	CHudMsgFunc(SendAudio);
	CHudMsgFunc(ReloadSound);
	CHudMsgFunc(BotVoice);
};

//
//-----------------------------------------------------
//
class CHudTimer: public CHudBase
{
	friend class CHudSpectatorGui;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float fTime);
	// set up the timer.
	// [short]
	CHudMsgFunc(RoundTime);
	// show the timer
	// [empty]
	CHudMsgFunc(ShowTimer);
private:
	int m_HUD_timer;
	int m_iTime;
	float m_fStartTime;
	bool m_bPanicColorChange;
	float m_flPanicTime;
};
//
//-----------------------------------------------------
//
class CHudProgressBar: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );

	// start progress bar
	// [short] Duration
	CHudMsgFunc(BarTime);

	// [short] Duration
	// [short] percent
	CHudMsgFunc(BarTime2);
	CHudMsgFunc(BotProgress);

private:
	int m_iDuration;
	float m_fPercent;
	float m_fStartTime;
	char m_szHeader[256];
	const char *m_szLocalizedHeader;
};

//
//-----------------------------------------------------
//
// class for drawing sniper scope
class CHudSniperScope: public CHudBase
{
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Shutdown( void );

private:
	float left, right, centerx, centery;
	int m_iScopeArc[4];
};

//
//-----------------------------------------------------
//

class CHudNVG: public CHudBase
{
public:
	int Init( void );
	int Draw( float flTime );
	CHudMsgFunc(NVGToggle);

	CHudUserCmd(NVGAdjustUp);
	CHudUserCmd(NVGAdjustDown);
private:
	int m_iAlpha;
	cvar_t *cl_fancy_nvg;
	dlight_t *m_pLight;
};

//
//-----------------------------------------------------
//

class CHudSpectatorGui: public CHudBase
{
public:
	int Init();
	int VidInit();
	int Draw( float flTime );
	void InitHUDData();
	void Reset();
	void Shutdown();

	CHudMsgFunc( SpecHealth );
	CHudMsgFunc( SpecHealth2 );

	CHudUserCmd( ToggleSpectatorMenu );
	CHudUserCmd( ToggleSpectatorMenuOptions );
	CHudUserCmd( ToggleSpectatorMenuOptionsSettings );
	CHudUserCmd( ToggleSpectatorMenuSpectateOptions );

	void CalcAllNeededData( );

	bool m_bBombPlanted;
	int m_iPlayerLastPointedAt;
	static float m_fTextScale;

private:	
	// szMapName is 64 bytes only. Removing "maps/" and ".bsp" gived me this result
	class Labels
	{
	public:
		short m_iTerrorists;
		short m_iCounterTerrorists;
		char m_szTimer[64];
		char m_szMap[64];
		char m_szNameAndHealth[80];
	} label;
	int m_hTimerTexture;

	enum {
		ROOT_MENU = (1<<0),
		MENU_OPTIONS = (1<<1),
		MENU_OPTIONS_SETTINGS = (1<<2),
		MENU_SPEC_OPTIONS = (1<<3)
	};
	byte m_menuFlags;
};

//
//-----------------------------------------------------
//



class CHud
{
public:
	CHud() : m_pHudList(NULL), m_iSpriteCount(0)  {}
	~CHud();			// destructor, frees allocated memory // thanks, Captain Obvious

	void Init( void );
	void VidInit( void );
	void Think( void );
	void Shutdown( void );
	int Redraw( float flTime, int intermission );
	int UpdateClientData( client_data_t *cdata, float time );
	void AddHudElem(CHudBase *p);

	inline float GetSensitivity() { return m_flMouseSensitivity; }
	inline HSPRITE GetSprite( int index )
	{
		assert( index >= -1 && index <= m_iSpriteCount );

		return (index >= 0) ? m_rghSprites[index] : 0;
	}

	inline wrect_t& GetSpriteRect( int index )
	{
		assert( index >= -1 && index <= m_iSpriteCount );

		return (index >= 0) ? m_rgrcRects[index]: nullrc;
	}

	// GetSpriteIndex()
	// searches through the sprite list loaded from hud.txt for a name matching SpriteName
	// returns an index into the gHUD.m_rghSprites[] array
	// returns -1 if sprite not found
	inline int GetSpriteIndex( const char *SpriteName )
	{
		// look through the loaded sprite name list for SpriteName
		for ( int i = 0; i < m_iSpriteCount; i++ )
		{
			if ( strncmp( SpriteName, m_rgszSpriteNames + (i * MAX_SPRITE_NAME_LENGTH), MAX_SPRITE_NAME_LENGTH ) == 0 )
				return i;
		}

		gEngfuncs.Con_Printf( "GetSpriteIndex: %s sprite not found", SpriteName );
		return -1; // invalid sprite
	}

	inline short GetCharWidth ( unsigned char ch )
	{
		return m_scrinfo.charWidths[ ch ];
	}
	inline int GetCharHeight( )
	{
		return m_scrinfo.iCharHeight;
	}

	inline bool IsCZero( )
	{
		return m_bIsCZero;
	}


	float   m_flTime;      // the current client time
	float   m_fOldTime;    // the time at which the HUD was last redrawn
	double  m_flTimeDelta; // the difference between flTime and fOldTime
	float   m_flScale;     // hud_scale->value
	Vector	m_vecOrigin;
	Vector	m_vecAngles;
	int		m_iKeyBits;
	int		m_iHideHUDDisplay;
	int		m_iFOV;
	int		m_Teamplay;
	int		m_iRes;
	cvar_t *m_pCvarDraw;
	cvar_t *cl_shadows;
	cvar_t *fastsprites;
	cvar_t *cl_predict;
	cvar_t *cl_weapon_wallpuff;
	cvar_t *cl_weapon_sparks;
	cvar_t *zoom_sens_ratio;
	cvar_t *cl_lw;
	cvar_t *cl_righthand;
	cvar_t *cl_weather;
	cvar_t *cl_minmodels;
	cvar_t *cl_min_t;
	cvar_t *cl_min_ct;
	cvar_t *cl_gunsmoke;
	cvar_t *default_fov;
	cvar_t *hud_textmode;
	cvar_t *hud_colored;
	cvar_t *sv_skipshield;
#ifdef __ANDROID__
	cvar_t *cl_android_force_defaults;
#endif

	HSPRITE m_hGasPuff;

	int m_iFontHeight;
	CHudAmmo        m_Ammo;
	CHudHealth      m_Health;
	CHudSpectator   m_Spectator;
	CHudGeiger      m_Geiger;
	CHudBattery	    m_Battery;
	CHudTrain       m_Train;
	CHudFlashlight  m_Flash;
	CHudMessage     m_Message;
	CHudStatusBar   m_StatusBar;
	CHudDeathNotice m_DeathNotice;
	CHudSayText     m_SayText;
	CHudMenu        m_Menu;
	CHudAmmoSecondary m_AmmoSecondary;
	CHudTextMessage m_TextMessage;
	CHudStatusIcons m_StatusIcons;
	CHudScoreboard  m_Scoreboard;
	CHudMOTD        m_MOTD;
	CHudMoney       m_Money;
	CHudTimer       m_Timer;
	CHudRadio       m_Radio;
	CHudProgressBar m_ProgressBar;
	CHudSniperScope m_SniperScope;
	CHudNVG         m_NVG;
	CHudRadar       m_Radar;
	CHudSpectatorGui m_SpectatorGui;

	// user messages
	CHudMsgFunc(Damage);
	CHudMsgFunc(GameMode);
	CHudMsgFunc(Logo);
	CHudMsgFunc(ResetHUD);
	CHudMsgFunc(InitHUD);
	CHudMsgFunc(ViewMode);
	CHudMsgFunc(SetFOV);
	CHudMsgFunc(Concuss);
	CHudMsgFunc(ShadowIdx);

	// Screen information
	SCREENINFO	m_scrinfo;
	// As Xash3D can fake m_scrinfo for hud scailing
	// we will use a real screen parameters
	SCREENINFO  m_truescrinfo;

	int	m_iWeaponBits;
	int	m_fPlayerDead;
	int m_iIntermission;
	int m_iNoConsolePrint;

	// sprite indexes
	int m_HUD_number_0;

	char m_szServerName[64];

private:
	HUDLIST	*m_pHudList;
	HSPRITE	m_hsprLogo;
	int	m_iLogo;
	client_sprite_t	*m_pSpriteList;
	int	m_iSpriteCount;
	int	m_iSpriteCountAllRes;
	float m_flMouseSensitivity;
	int	m_iConcussionEffect;
	int	m_iForceCamera;
	int m_iForceChaseCam;
	int m_iFadeToBlack;
	bool m_bIsCZero;

	// the memory for these arrays are allocated in the first call to CHud::VidInit(), when the hud.txt and associated sprites are loaded.
	// freed in ~CHud()
	HSPRITE *m_rghSprites;	/*[HUD_SPRITE_COUNT]*/			// the sprites loaded from hud.txt
	wrect_t *m_rgrcRects;	/*[HUD_SPRITE_COUNT]*/
	char *m_rgszSpriteNames; /*[HUD_SPRITE_COUNT][MAX_SPRITE_NAME_LENGTH]*/
};

extern CHud gHUD;
extern cvar_t *sensitivity;

extern int g_iTeamNumber;
extern int g_iUser1;
extern int g_iUser2;
extern int g_iUser3;

```

`cl_dll/include/hud/hud_iface.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( HUD_IFACEH )
#define HUD_IFACEH

#include "exportdef.h"

typedef int (*pfnUserMsgHook)(const char *pszName, int iSize, void *pbuf);
#include "wrect.h"
#include "../engine/cdll_int.h"
extern cl_enginefunc_t gEngfuncs;

#endif

```

`cl_dll/include/hud/hud_spectator.h`:

```h
//========= Copyright ? 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose:
//
// $NoKeywords: $
//=============================================================================
#pragma once
#ifndef SPECTATOR_H
#define SPECTATOR_H

#include "cl_entity.h"
#include "hud.h"


#define INSET_OFF				0
#define	INSET_CHASE_FREE		1
#define	INSET_IN_EYE			2
#define	INSET_MAP_FREE			3
#define	INSET_MAP_CHASE			4

#define MAX_SPEC_HUD_MESSAGES	8



#define OVERVIEW_TILE_SIZE		256		// don't change this
#define OVERVIEW_MAX_LAYERS		1

//-----------------------------------------------------------------------------
// Purpose: Handles the drawing of the spectator stuff (camera & top-down map and all the things on it )
//-----------------------------------------------------------------------------

typedef struct overviewInfo_s {
	char		map[64];	// cl.levelname or empty
	vec3_t		origin;		// center of map
	float		zoom;		// zoom of map images
	int			layers;		// how may layers do we have
	float		layersHeights[OVERVIEW_MAX_LAYERS];
	char		layersImages[OVERVIEW_MAX_LAYERS][255];
	qboolean	rotated;	// are map images rotated (90 degrees) ?

	int			insetWindowX;
	int			insetWindowY;
	int			insetWindowHeight;
	int			insetWindowWidth;
} overviewInfo_t;

typedef struct overviewEntity_s {

	HSPRITE					hSprite;
	struct cl_entity_s *	entity;
	double					killTime;
} overviewEntity_t;

#define	 MAX_OVERVIEW_ENTITIES		128

class CHudSpectator : public CHudBase
{
public:
	void Reset();
	int  ToggleInset(bool allowOff);
	void CheckSettings();
	void InitHUDData( void );
	bool AddOverviewEntityToList( HSPRITE sprite, cl_entity_t * ent, double killTime);
	void DeathMessage(int victim);
	bool AddOverviewEntity( int type, struct cl_entity_s *ent, const char *modelname );
	void CheckOverviewEntities();
	void DrawOverview();
	void DrawOverviewEntities();
	void GetMapPosition( float * returnvec );
	void DrawOverviewLayer();
	void LoadMapSprites();
	bool ParseOverviewFile();
	bool IsActivePlayer(cl_entity_t * ent);
	void SetModes(int iMainMode, int iInsetMode);
	void HandleButtonsDown(int ButtonPressed);
	void HandleButtonsUp(int ButtonPressed);
	void FindNextPlayer( bool bReverse );
	void DirectorMessage( int iSize, void *pbuf );
	void SetSpectatorStartPosition();
	CHudMsgFunc(Spectator);
	CHudMsgFunc(ADStop);
	int Init();
	int VidInit();

	int Draw(float flTime);

	int m_iDrawCycle;
	client_textmessage_t m_HUDMessages[MAX_SPEC_HUD_MESSAGES];
	char				m_HUDMessageText[MAX_SPEC_HUD_MESSAGES][128];
	int					m_lastHudMessage;
	overviewInfo_t		m_OverviewData;
	overviewEntity_t	m_OverviewEntities[MAX_OVERVIEW_ENTITIES];
	int					m_iObserverFlags;
	int					m_iSpectatorNumber;

	float				m_mapZoom;		// zoom the user currently uses
	vec3_t				m_mapOrigin;	// origin where user rotates around
	cvar_t *			m_drawnames;
	cvar_t *            m_specmode;
	cvar_t *			m_drawcone;
	cvar_t *			m_drawstatus;
	cvar_t *			m_autoDirector;
	float				m_lastAutoDirector;
	cvar_t *			m_pip;


	qboolean			m_chatEnabled;

	vec3_t				m_cameraOrigin;	// a help camera
	vec3_t				m_cameraAngles;	// and it's angles


private:
	vec3_t		m_vPlayerPos[MAX_PLAYERS];
	HSPRITE		m_hsprPlayerC4;
	HSPRITE		m_hsprPlayerVIP;
	HSPRITE		m_hsprHostage;
	HSPRITE		m_hsprBackpack;
	HSPRITE		m_hsprBomb;
	HSPRITE		m_hsprPlayerBlue;
	HSPRITE		m_hsprPlayerRed;
	HSPRITE		m_hsprPlayer;
	HSPRITE		m_hsprCamera;
	HSPRITE		m_hsprPlayerDead;
	HSPRITE		m_hsprViewcone;
	HSPRITE		m_hsprUnkownMap;
	HSPRITE		m_hsprBeam;
	HSPRITE		m_hCrosshair;

	wrect_t		m_crosshairRect;

	struct model_s * m_MapSprite;	// each layer image is saved in one sprite, where each tile is a sprite frame
	float		m_flNextObserverInput;
	float		m_zoomDelta;
	float		m_moveDelta;
	int			m_lastPrimaryObject;
	int			m_lastSecondaryObject;
};

#endif // SPECTATOR_H

```

`cl_dll/include/hud/radar.h`:

```h
/*
radar.h
Copyright (C) 2015 a1batross
*/
#pragma once
#ifndef RADAR_H
#define RADAR_H

class CClientSprite;

class CHudRadar: public CHudBase
{
public:
	virtual int Init();
	virtual int VidInit();
	virtual int Draw( float flTime );
	virtual void Reset();
	virtual void Shutdown();

	int MsgFunc_Radar(const char *pszName,  int iSize, void *pbuf);

	void UserCmd_ShowRadar();
	void UserCmd_HideRadar();
	CClientSprite m_hRadar;
	CClientSprite m_hRadarOpaque;

	int MsgFunc_BombDrop(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_BombPickup(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_HostagePos(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_HostageK(const char *pszName, int iSize, void *pbuf);
private:

	cvar_t *cl_radartype;

	int InitBuiltinTextures();
	void DrawPlayerLocation();
	void DrawRadarDot(int x, int y, int r, int g, int b, int a);
	void DrawCross(int x, int y, int r, int g, int b, int a );

	// Call DrawT, DrawFlippedT or DrawRadarDot considering z value
	inline void DrawZAxis( Vector pos, int r, int g, int b, int a );

	void DrawT( int x, int y, int r, int g, int b, int a );
	void DrawFlippedT( int x, int y, int r, int g, int b, int a );
	bool HostageFlashTime( float flTime, struct hostage_info_t *pplayer );
	bool FlashTime( float flTime, struct extra_player_info_t *pplayer );
	Vector WorldToRadar(const Vector vPlayerOrigin, const Vector vObjectOrigin, const Vector vAngles );
	inline void DrawColoredTexture( int x, int y, int size, byte r, byte g, byte b, byte a, int texHandle );

	bool bUseRenderAPI, bTexturesInitialized;
	int hDot, hCross, hT, hFlippedT;
	int iMaxRadius;
};

#endif // RADAR_H

```

`cl_dll/include/in_defs.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( IN_DEFSH )
#define IN_DEFSH

// up / down
#define	PITCH	0
// left / right
#define	YAW		1
// fall over
#define	ROLL	2 

#ifdef _WIN32
#include <port.h>
#include <windows.h>
#else
#ifndef PORT_H
typedef struct point_s{
	int x;
	int y;
} POINT;
#endif
#define GetCursorPos(x)
#define SetCursorPos(x,y)
#endif

#endif

```

`cl_dll/include/input.h`:

```h
#pragma once
#ifndef INPUT_H
#define INPUT_H

extern kbutton_t	in_strafe;
extern kbutton_t	in_mlook;
extern kbutton_t	in_speed;
extern kbutton_t	in_jlook;
extern kbutton_t	in_forward;
extern kbutton_t	in_back;
extern kbutton_t	in_moveleft;
extern kbutton_t	in_moveright;

extern cvar_t	*m_pitch;
extern cvar_t	*m_yaw;
extern cvar_t	*m_forward;
extern cvar_t	*m_side;

extern cvar_t *lookstrafe;
extern cvar_t *lookspring;
extern cvar_t *cl_pitchdown;
extern cvar_t *cl_pitchup;
extern cvar_t *cl_yawspeed;
extern cvar_t *cl_sidespeed;
extern cvar_t *cl_forwardspeed;
extern cvar_t *cl_pitchspeed;
extern cvar_t *cl_movespeedkey;

#endif // INPUT_H

```

`cl_dll/include/kbutton.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( KBUTTONH )
#define KBUTTONH

typedef struct kbutton_s
{
	int		down[2];		// key nums holding it down
	int		state;			// low bit is down state
} kbutton_t;

#endif // !KBUTTONH
```

`cl_dll/include/math/neon_mathfun.h`:

```h
/* NEON implementation of sin, cos, exp and log

   Inspired by Intel Approximate Math library, and based on the
   corresponding algorithms of the cephes math library
*/

/* Copyright (C) 2011  Julien Pommier

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  (this is the zlib license)
*/

#include <arm_neon.h>

typedef float32x4_t v4sf;  // vector of 4 float
typedef uint32x4_t v4su;  // vector of 4 uint32
typedef int32x4_t v4si;  // vector of 4 uint32

#define c_inv_mant_mask ~0x7f800000u
#define c_cephes_SQRTHF 0.707106781186547524
#define c_cephes_log_p0 7.0376836292E-2
#define c_cephes_log_p1 - 1.1514610310E-1
#define c_cephes_log_p2 1.1676998740E-1
#define c_cephes_log_p3 - 1.2420140846E-1
#define c_cephes_log_p4 + 1.4249322787E-1
#define c_cephes_log_p5 - 1.6668057665E-1
#define c_cephes_log_p6 + 2.0000714765E-1
#define c_cephes_log_p7 - 2.4999993993E-1
#define c_cephes_log_p8 + 3.3333331174E-1
#define c_cephes_log_q1 -2.12194440e-4
#define c_cephes_log_q2 0.693359375

/* natural logarithm computed for 4 simultaneous float 
   return NaN for x <= 0
*/
v4sf log_ps(v4sf x) {
  v4sf one = vdupq_n_f32(1);

  x = vmaxq_f32(x, vdupq_n_f32(0)); /* force flush to zero on denormal values */
  v4su invalid_mask = vcleq_f32(x, vdupq_n_f32(0));

  v4si ux = vreinterpretq_s32_f32(x);
  
  v4si emm0 = vshrq_n_s32(ux, 23);

  /* keep only the fractional part */
  ux = vandq_s32(ux, vdupq_n_s32(c_inv_mant_mask));
  ux = vorrq_s32(ux, vreinterpretq_s32_f32(vdupq_n_f32(0.5f)));
  x = vreinterpretq_f32_s32(ux);

  emm0 = vsubq_s32(emm0, vdupq_n_s32(0x7f));
  v4sf e = vcvtq_f32_s32(emm0);

  e = vaddq_f32(e, one);

  /* part2: 
     if( x < SQRTHF ) {
       e -= 1;
       x = x + x - 1.0;
     } else { x = x - 1.0; }
  */
  v4su mask = vcltq_f32(x, vdupq_n_f32(c_cephes_SQRTHF));
  v4sf tmp = vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(x), mask));
  x = vsubq_f32(x, one);
  e = vsubq_f32(e, vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(one), mask)));
  x = vaddq_f32(x, tmp);

  v4sf z = vmulq_f32(x,x);

  v4sf y = vdupq_n_f32(c_cephes_log_p0);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p1));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p2));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p3));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p4));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p5));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p6));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p7));
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, vdupq_n_f32(c_cephes_log_p8));
  y = vmulq_f32(y, x);

  y = vmulq_f32(y, z);
  

  tmp = vmulq_f32(e, vdupq_n_f32(c_cephes_log_q1));
  y = vaddq_f32(y, tmp);


  tmp = vmulq_f32(z, vdupq_n_f32(0.5f));
  y = vsubq_f32(y, tmp);

  tmp = vmulq_f32(e, vdupq_n_f32(c_cephes_log_q2));
  x = vaddq_f32(x, y);
  x = vaddq_f32(x, tmp);
  x = vreinterpretq_f32_u32(vorrq_u32(vreinterpretq_u32_f32(x), invalid_mask)); // negative arg will be NAN
  return x;
}

#define c_exp_hi 88.3762626647949f
#define c_exp_lo -88.3762626647949f

#define c_cephes_LOG2EF 1.44269504088896341
#define c_cephes_exp_C1 0.693359375
#define c_cephes_exp_C2 -2.12194440e-4

#define c_cephes_exp_p0 1.9875691500E-4
#define c_cephes_exp_p1 1.3981999507E-3
#define c_cephes_exp_p2 8.3334519073E-3
#define c_cephes_exp_p3 4.1665795894E-2
#define c_cephes_exp_p4 1.6666665459E-1
#define c_cephes_exp_p5 5.0000001201E-1

/* exp() computed for 4 float at once */
v4sf exp_ps(v4sf x) {
  v4sf tmp, fx;

  v4sf one = vdupq_n_f32(1);
  x = vminq_f32(x, vdupq_n_f32(c_exp_hi));
  x = vmaxq_f32(x, vdupq_n_f32(c_exp_lo));

  /* express exp(x) as exp(g + n*log(2)) */
  fx = vmlaq_f32(vdupq_n_f32(0.5f), x, vdupq_n_f32(c_cephes_LOG2EF));

  /* perform a floorf */
  tmp = vcvtq_f32_s32(vcvtq_s32_f32(fx));

  /* if greater, subtract 1 */
  v4su mask = vcgtq_f32(tmp, fx);    
  mask = vandq_u32(mask, vreinterpretq_u32_f32(one));


  fx = vsubq_f32(tmp, vreinterpretq_f32_u32(mask));

  tmp = vmulq_f32(fx, vdupq_n_f32(c_cephes_exp_C1));
  v4sf z = vmulq_f32(fx, vdupq_n_f32(c_cephes_exp_C2));
  x = vsubq_f32(x, tmp);
  x = vsubq_f32(x, z);

  static const float cephes_exp_p[6] = { c_cephes_exp_p0, c_cephes_exp_p1, c_cephes_exp_p2, c_cephes_exp_p3, c_cephes_exp_p4, c_cephes_exp_p5 };
  v4sf y = vld1q_dup_f32(cephes_exp_p+0);
  v4sf c1 = vld1q_dup_f32(cephes_exp_p+1); 
  v4sf c2 = vld1q_dup_f32(cephes_exp_p+2); 
  v4sf c3 = vld1q_dup_f32(cephes_exp_p+3); 
  v4sf c4 = vld1q_dup_f32(cephes_exp_p+4); 
  v4sf c5 = vld1q_dup_f32(cephes_exp_p+5);

  y = vmulq_f32(y, x);
  z = vmulq_f32(x,x);
  y = vaddq_f32(y, c1);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, c2);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, c3);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, c4);
  y = vmulq_f32(y, x);
  y = vaddq_f32(y, c5);
  
  y = vmulq_f32(y, z);
  y = vaddq_f32(y, x);
  y = vaddq_f32(y, one);

  /* build 2^n */
  int32x4_t mm;
  mm = vcvtq_s32_f32(fx);
  mm = vaddq_s32(mm, vdupq_n_s32(0x7f));
  mm = vshlq_n_s32(mm, 23);
  v4sf pow2n = vreinterpretq_f32_s32(mm);

  y = vmulq_f32(y, pow2n);
  return y;
}

#define c_minus_cephes_DP1 -0.78515625
#define c_minus_cephes_DP2 -2.4187564849853515625e-4
#define c_minus_cephes_DP3 -3.77489497744594108e-8
#define c_sincof_p0 -1.9515295891E-4
#define c_sincof_p1  8.3321608736E-3
#define c_sincof_p2 -1.6666654611E-1
#define c_coscof_p0  2.443315711809948E-005
#define c_coscof_p1 -1.388731625493765E-003
#define c_coscof_p2  4.166664568298827E-002
#define c_cephes_FOPI 1.27323954473516 // 4 / M_PI

/* evaluation of 4 sines & cosines at once.

   The code is the exact rewriting of the cephes sinf function.
   Precision is excellent as long as x < 8192 (I did not bother to
   take into account the special handling they have for greater values
   -- it does not return garbage for arguments over 8192, though, but
   the extra precision is missing).

   Note that it is such that sinf((float)M_PI) = 8.74e-8, which is the
   surprising but correct result.

   Note also that when you compute sin(x), cos(x) is available at
   almost no extra price so both sin_ps and cos_ps make use of
   sincos_ps..
  */
void sincos_ps(v4sf x, v4sf *ysin, v4sf *ycos) { // any x
  v4sf xmm1, xmm2, xmm3, y;

  v4su emm2;
  
  v4su sign_mask_sin, sign_mask_cos;
  sign_mask_sin = vcltq_f32(x, vdupq_n_f32(0));
  x = vabsq_f32(x);

  /* scale by 4/Pi */
  y = vmulq_f32(x, vdupq_n_f32(c_cephes_FOPI));

  /* store the integer part of y in mm0 */
  emm2 = vcvtq_u32_f32(y);
  /* j=(j+1) & (~1) (see the cephes sources) */
  emm2 = vaddq_u32(emm2, vdupq_n_u32(1));
  emm2 = vandq_u32(emm2, vdupq_n_u32(~1));
  y = vcvtq_f32_u32(emm2);

  /* get the polynom selection mask 
     there is one polynom for 0 <= x <= Pi/4
     and another one for Pi/4<x<=Pi/2

     Both branches will be computed.
  */
  v4su poly_mask = vtstq_u32(emm2, vdupq_n_u32(2));
  
  /* The magic pass: "Extended precision modular arithmetic" 
     x = ((x - y * DP1) - y * DP2) - y * DP3; */
  xmm1 = vmulq_n_f32(y, c_minus_cephes_DP1);
  xmm2 = vmulq_n_f32(y, c_minus_cephes_DP2);
  xmm3 = vmulq_n_f32(y, c_minus_cephes_DP3);
  x = vaddq_f32(x, xmm1);
  x = vaddq_f32(x, xmm2);
  x = vaddq_f32(x, xmm3);

  sign_mask_sin = veorq_u32(sign_mask_sin, vtstq_u32(emm2, vdupq_n_u32(4)));
  sign_mask_cos = vtstq_u32(vsubq_u32(emm2, vdupq_n_u32(2)), vdupq_n_u32(4));

  /* Evaluate the first polynom  (0 <= x <= Pi/4) in y1, 
     and the second polynom      (Pi/4 <= x <= 0) in y2 */
  v4sf z = vmulq_f32(x,x);
  v4sf y1, y2;

  y1 = vmulq_n_f32(z, c_coscof_p0);
  y2 = vmulq_n_f32(z, c_sincof_p0);
  y1 = vaddq_f32(y1, vdupq_n_f32(c_coscof_p1));
  y2 = vaddq_f32(y2, vdupq_n_f32(c_sincof_p1));
  y1 = vmulq_f32(y1, z);
  y2 = vmulq_f32(y2, z);
  y1 = vaddq_f32(y1, vdupq_n_f32(c_coscof_p2));
  y2 = vaddq_f32(y2, vdupq_n_f32(c_sincof_p2));
  y1 = vmulq_f32(y1, z);
  y2 = vmulq_f32(y2, z);
  y1 = vmulq_f32(y1, z);
  y2 = vmulq_f32(y2, x);
  y1 = vsubq_f32(y1, vmulq_f32(z, vdupq_n_f32(0.5f)));
  y2 = vaddq_f32(y2, x);
  y1 = vaddq_f32(y1, vdupq_n_f32(1));

  /* select the correct result from the two polynoms */  
  v4sf ys = vbslq_f32(poly_mask, y1, y2);
  v4sf yc = vbslq_f32(poly_mask, y2, y1);
  *ysin = vbslq_f32(sign_mask_sin, vnegq_f32(ys), ys);
  *ycos = vbslq_f32(sign_mask_cos, yc, vnegq_f32(yc));
}

v4sf sin_ps(v4sf x) {
  v4sf ysin, ycos; 
  sincos_ps(x, &ysin, &ycos); 
  return ysin;
}

v4sf cos_ps(v4sf x) {
  v4sf ysin, ycos; 
  sincos_ps(x, &ysin, &ycos); 
  return ycos;
}



```

`cl_dll/include/math/sse_mathfun.h`:

```h
/* SIMD (SSE1+MMX or SSE2) implementation of sin, cos, exp and log

   Inspired by Intel Approximate Math library, and based on the
   corresponding algorithms of the cephes math library

   The default is to use the SSE1 version. If you define USE_SSE2 the
   the SSE2 intrinsics will be used in place of the MMX intrinsics. Do
   not expect any significant performance improvement with SSE2.
*/

/* Copyright (C) 2007  Julien Pommier

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  (this is the zlib license)
*/

#include <xmmintrin.h>

/* yes I know, the top of this file is quite ugly */

#ifdef _MSC_VER /* visual c++ */
# define ALIGN16_BEG __declspec(align(16))
# define ALIGN16_END 
#else /* gcc or icc */
# define ALIGN16_BEG
# define ALIGN16_END __attribute__((aligned(16)))
#endif

/* __m128 is ugly to write */
typedef __m128 v4sf;  // vector of 4 float (sse1)

#ifdef USE_SSE2
# include <emmintrin.h>
typedef __m128i v4si; // vector of 4 int (sse2)
#else
typedef __m64 v2si;   // vector of 2 int (mmx)
#endif

/* declare some SSE constants -- why can't I figure a better way to do that? */
#define _PS_CONST(Name, Val)                                            \
  static const ALIGN16_BEG float _ps_##Name[4] ALIGN16_END = { Val, Val, Val, Val }
#define _PI32_CONST(Name, Val)                                            \
  static const ALIGN16_BEG int _pi32_##Name[4] ALIGN16_END = { Val, Val, Val, Val }
#define _PS_CONST_TYPE(Name, Type, Val)                                 \
  static const ALIGN16_BEG Type _ps_##Name[4] ALIGN16_END = { Val, Val, Val, Val }

_PS_CONST(1  , 1.0f);
_PS_CONST(0p5, 0.5f);
/* the smallest non denormalized float number */
_PS_CONST_TYPE(min_norm_pos, int, 0x00800000);
_PS_CONST_TYPE(mant_mask, int, 0x7f800000);
_PS_CONST_TYPE(inv_mant_mask, int, ~0x7f800000);

_PS_CONST_TYPE(sign_mask, int, (int)0x80000000);
_PS_CONST_TYPE(inv_sign_mask, int, ~0x80000000);

_PI32_CONST(1, 1);
_PI32_CONST(inv1, ~1);
_PI32_CONST(2, 2);
_PI32_CONST(4, 4);
_PI32_CONST(0x7f, 0x7f);

_PS_CONST(cephes_SQRTHF, 0.707106781186547524);
_PS_CONST(cephes_log_p0, 7.0376836292E-2);
_PS_CONST(cephes_log_p1, - 1.1514610310E-1);
_PS_CONST(cephes_log_p2, 1.1676998740E-1);
_PS_CONST(cephes_log_p3, - 1.2420140846E-1);
_PS_CONST(cephes_log_p4, + 1.4249322787E-1);
_PS_CONST(cephes_log_p5, - 1.6668057665E-1);
_PS_CONST(cephes_log_p6, + 2.0000714765E-1);
_PS_CONST(cephes_log_p7, - 2.4999993993E-1);
_PS_CONST(cephes_log_p8, + 3.3333331174E-1);
_PS_CONST(cephes_log_q1, -2.12194440e-4);
_PS_CONST(cephes_log_q2, 0.693359375);

#ifndef USE_SSE2
typedef union xmm_mm_union {
  __m128 xmm;
  __m64 mm[2];
} xmm_mm_union;

#define COPY_XMM_TO_MM(xmm_, mm0_, mm1_) {          \
    xmm_mm_union u; u.xmm = xmm_;                   \
    mm0_ = u.mm[0];                                 \
    mm1_ = u.mm[1];                                 \
}

#define COPY_MM_TO_XMM(mm0_, mm1_, xmm_) {                         \
    xmm_mm_union u; u.mm[0]=mm0_; u.mm[1]=mm1_; xmm_ = u.xmm;      \
  }

#endif // USE_SSE2

/* natural logarithm computed for 4 simultaneous float 
   return NaN for x <= 0
*/
v4sf log_ps(v4sf x) {
#ifdef USE_SSE2
  v4si emm0;
#else
  v2si mm0, mm1;
#endif
  v4sf one = *(v4sf*)_ps_1;

  v4sf invalid_mask = _mm_cmple_ps(x, _mm_setzero_ps());

  x = _mm_max_ps(x, *(v4sf*)_ps_min_norm_pos);  /* cut off denormalized stuff */

#ifndef USE_SSE2
  /* part 1: x = frexpf(x, &e); */
  COPY_XMM_TO_MM(x, mm0, mm1);
  mm0 = _mm_srli_pi32(mm0, 23);
  mm1 = _mm_srli_pi32(mm1, 23);
#else
  emm0 = _mm_srli_epi32(_mm_castps_si128(x), 23);
#endif
  /* keep only the fractional part */
  x = _mm_and_ps(x, *(v4sf*)_ps_inv_mant_mask);
  x = _mm_or_ps(x, *(v4sf*)_ps_0p5);

#ifndef USE_SSE2
  /* now e=mm0:mm1 contain the really base-2 exponent */
  mm0 = _mm_sub_pi32(mm0, *(v2si*)_pi32_0x7f);
  mm1 = _mm_sub_pi32(mm1, *(v2si*)_pi32_0x7f);
  v4sf e = _mm_cvtpi32x2_ps(mm0, mm1);
  _mm_empty(); /* bye bye mmx */
#else
  emm0 = _mm_sub_epi32(emm0, *(v4si*)_pi32_0x7f);
  v4sf e = _mm_cvtepi32_ps(emm0);
#endif

  e = _mm_add_ps(e, one);

  /* part2: 
     if( x < SQRTHF ) {
       e -= 1;
       x = x + x - 1.0;
     } else { x = x - 1.0; }
  */
  v4sf mask = _mm_cmplt_ps(x, *(v4sf*)_ps_cephes_SQRTHF);
  v4sf tmp = _mm_and_ps(x, mask);
  x = _mm_sub_ps(x, one);
  e = _mm_sub_ps(e, _mm_and_ps(one, mask));
  x = _mm_add_ps(x, tmp);


  v4sf z = _mm_mul_ps(x,x);

  v4sf y = *(v4sf*)_ps_cephes_log_p0;
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p1);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p2);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p3);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p4);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p5);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p6);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p7);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_log_p8);
  y = _mm_mul_ps(y, x);

  y = _mm_mul_ps(y, z);
  

  tmp = _mm_mul_ps(e, *(v4sf*)_ps_cephes_log_q1);
  y = _mm_add_ps(y, tmp);


  tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
  y = _mm_sub_ps(y, tmp);

  tmp = _mm_mul_ps(e, *(v4sf*)_ps_cephes_log_q2);
  x = _mm_add_ps(x, y);
  x = _mm_add_ps(x, tmp);
  x = _mm_or_ps(x, invalid_mask); // negative arg will be NAN
  return x;
}

_PS_CONST(exp_hi,	88.3762626647949f);
_PS_CONST(exp_lo,	-88.3762626647949f);

_PS_CONST(cephes_LOG2EF, 1.44269504088896341);
_PS_CONST(cephes_exp_C1, 0.693359375);
_PS_CONST(cephes_exp_C2, -2.12194440e-4);

_PS_CONST(cephes_exp_p0, 1.9875691500E-4);
_PS_CONST(cephes_exp_p1, 1.3981999507E-3);
_PS_CONST(cephes_exp_p2, 8.3334519073E-3);
_PS_CONST(cephes_exp_p3, 4.1665795894E-2);
_PS_CONST(cephes_exp_p4, 1.6666665459E-1);
_PS_CONST(cephes_exp_p5, 5.0000001201E-1);

v4sf exp_ps(v4sf x) {
  v4sf tmp = _mm_setzero_ps(), fx;
#ifdef USE_SSE2
  v4si emm0;
#else
  v2si mm0, mm1;
#endif
  v4sf one = *(v4sf*)_ps_1;

  x = _mm_min_ps(x, *(v4sf*)_ps_exp_hi);
  x = _mm_max_ps(x, *(v4sf*)_ps_exp_lo);

  /* express exp(x) as exp(g + n*log(2)) */
  fx = _mm_mul_ps(x, *(v4sf*)_ps_cephes_LOG2EF);
  fx = _mm_add_ps(fx, *(v4sf*)_ps_0p5);

  /* how to perform a floorf with SSE: just below */
#ifndef USE_SSE2
  /* step 1 : cast to int */
  tmp = _mm_movehl_ps(tmp, fx);
  mm0 = _mm_cvttps_pi32(fx);
  mm1 = _mm_cvttps_pi32(tmp);
  /* step 2 : cast back to float */
  tmp = _mm_cvtpi32x2_ps(mm0, mm1);
#else
  emm0 = _mm_cvttps_epi32(fx);
  tmp  = _mm_cvtepi32_ps(emm0);
#endif
  /* if greater, subtract 1 */
  v4sf mask = _mm_cmpgt_ps(tmp, fx);    
  mask = _mm_and_ps(mask, one);
  fx = _mm_sub_ps(tmp, mask);

  tmp = _mm_mul_ps(fx, *(v4sf*)_ps_cephes_exp_C1);
  v4sf z = _mm_mul_ps(fx, *(v4sf*)_ps_cephes_exp_C2);
  x = _mm_sub_ps(x, tmp);
  x = _mm_sub_ps(x, z);

  z = _mm_mul_ps(x,x);
  
  v4sf y = *(v4sf*)_ps_cephes_exp_p0;
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p1);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p2);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p3);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p4);
  y = _mm_mul_ps(y, x);
  y = _mm_add_ps(y, *(v4sf*)_ps_cephes_exp_p5);
  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, x);
  y = _mm_add_ps(y, one);

  /* build 2^n */
#ifndef USE_SSE2
  z = _mm_movehl_ps(z, fx);
  mm0 = _mm_cvttps_pi32(fx);
  mm1 = _mm_cvttps_pi32(z);
  mm0 = _mm_add_pi32(mm0, *(v2si*)_pi32_0x7f);
  mm1 = _mm_add_pi32(mm1, *(v2si*)_pi32_0x7f);
  mm0 = _mm_slli_pi32(mm0, 23); 
  mm1 = _mm_slli_pi32(mm1, 23);
  
  v4sf pow2n; 
  COPY_MM_TO_XMM(mm0, mm1, pow2n);
  _mm_empty();
#else
  emm0 = _mm_cvttps_epi32(fx);
  emm0 = _mm_add_epi32(emm0, *(v4si*)_pi32_0x7f);
  emm0 = _mm_slli_epi32(emm0, 23);
  v4sf pow2n = _mm_castsi128_ps(emm0);
#endif
  y = _mm_mul_ps(y, pow2n);
  return y;
}

_PS_CONST(minus_cephes_DP1, -0.78515625);
_PS_CONST(minus_cephes_DP2, -2.4187564849853515625e-4);
_PS_CONST(minus_cephes_DP3, -3.77489497744594108e-8);
_PS_CONST(sincof_p0, -1.9515295891E-4);
_PS_CONST(sincof_p1,  8.3321608736E-3);
_PS_CONST(sincof_p2, -1.6666654611E-1);
_PS_CONST(coscof_p0,  2.443315711809948E-005);
_PS_CONST(coscof_p1, -1.388731625493765E-003);
_PS_CONST(coscof_p2,  4.166664568298827E-002);
_PS_CONST(cephes_FOPI, 1.27323954473516); // 4 / M_PI


/* evaluation of 4 sines at onces, using only SSE1+MMX intrinsics so
   it runs also on old athlons XPs and the pentium III of your grand
   mother.

   The code is the exact rewriting of the cephes sinf function.
   Precision is excellent as long as x < 8192 (I did not bother to
   take into account the special handling they have for greater values
   -- it does not return garbage for arguments over 8192, though, but
   the extra precision is missing).

   Note that it is such that sinf((float)M_PI) = 8.74e-8, which is the
   surprising but correct result.

   Performance is also surprisingly good, 1.33 times faster than the
   macos vsinf SSE2 function, and 1.5 times faster than the
   __vrs4_sinf of amd's ACML (which is only available in 64 bits). Not
   too bad for an SSE1 function (with no special tuning) !
   However the latter libraries probably have a much better handling of NaN,
   Inf, denormalized and other special arguments..

   On my core 1 duo, the execution of this function takes approximately 95 cycles.

   From what I have observed on the experiments with Intel AMath lib, switching to an
   SSE2 version would improve the perf by only 10%.

   Since it is based on SSE intrinsics, it has to be compiled at -O2 to
   deliver full speed.
*/
v4sf sin_ps(v4sf x) { // any x
  v4sf xmm1, xmm2 = _mm_setzero_ps(), xmm3, sign_bit, y;

#ifdef USE_SSE2
  v4si emm0, emm2;
#else
  v2si mm0, mm1, mm2, mm3;
#endif
  sign_bit = x;
  /* take the absolute value */
  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
  /* extract the sign bit (upper one) */
  sign_bit = _mm_and_ps(sign_bit, *(v4sf*)_ps_sign_mask);
  
  /* scale by 4/Pi */
  y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);

#ifdef USE_SSE2
  /* store the integer part of y in mm0 */
  emm2 = _mm_cvttps_epi32(y);
  /* j=(j+1) & (~1) (see the cephes sources) */
  emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
  y = _mm_cvtepi32_ps(emm2);

  /* get the swap sign flag */
  emm0 = _mm_and_si128(emm2, *(v4si*)_pi32_4);
  emm0 = _mm_slli_epi32(emm0, 29);
  /* get the polynom selection mask 
     there is one polynom for 0 <= x <= Pi/4
     and another one for Pi/4<x<=Pi/2

     Both branches will be computed.
  */
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
  emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
  
  v4sf swap_sign_bit = _mm_castsi128_ps(emm0);
  v4sf poly_mask = _mm_castsi128_ps(emm2);
  sign_bit = _mm_xor_ps(sign_bit, swap_sign_bit);
  
#else
  /* store the integer part of y in mm0:mm1 */
  xmm2 = _mm_movehl_ps(xmm2, y);
  mm2 = _mm_cvttps_pi32(y);
  mm3 = _mm_cvttps_pi32(xmm2);
  /* j=(j+1) & (~1) (see the cephes sources) */
  mm2 = _mm_add_pi32(mm2, *(v2si*)_pi32_1);
  mm3 = _mm_add_pi32(mm3, *(v2si*)_pi32_1);
  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_inv1);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_inv1);
  y = _mm_cvtpi32x2_ps(mm2, mm3);
  /* get the swap sign flag */
  mm0 = _mm_and_si64(mm2, *(v2si*)_pi32_4);
  mm1 = _mm_and_si64(mm3, *(v2si*)_pi32_4);
  mm0 = _mm_slli_pi32(mm0, 29);
  mm1 = _mm_slli_pi32(mm1, 29);
  /* get the polynom selection mask */
  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_2);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_2);
  mm2 = _mm_cmpeq_pi32(mm2, _mm_setzero_si64());
  mm3 = _mm_cmpeq_pi32(mm3, _mm_setzero_si64());
  v4sf swap_sign_bit, poly_mask;
  COPY_MM_TO_XMM(mm0, mm1, swap_sign_bit);
  COPY_MM_TO_XMM(mm2, mm3, poly_mask);
  sign_bit = _mm_xor_ps(sign_bit, swap_sign_bit);
  _mm_empty(); /* good-bye mmx */
#endif
  
  /* The magic pass: "Extended precision modular arithmetic" 
     x = ((x - y * DP1) - y * DP2) - y * DP3; */
  xmm1 = *(v4sf*)_ps_minus_cephes_DP1;
  xmm2 = *(v4sf*)_ps_minus_cephes_DP2;
  xmm3 = *(v4sf*)_ps_minus_cephes_DP3;
  xmm1 = _mm_mul_ps(y, xmm1);
  xmm2 = _mm_mul_ps(y, xmm2);
  xmm3 = _mm_mul_ps(y, xmm3);
  x = _mm_add_ps(x, xmm1);
  x = _mm_add_ps(x, xmm2);
  x = _mm_add_ps(x, xmm3);

  /* Evaluate the first polynom  (0 <= x <= Pi/4) */
  y = *(v4sf*)_ps_coscof_p0;
  v4sf z = _mm_mul_ps(x,x);

  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p1);
  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p2);
  y = _mm_mul_ps(y, z);
  y = _mm_mul_ps(y, z);
  v4sf tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
  y = _mm_sub_ps(y, tmp);
  y = _mm_add_ps(y, *(v4sf*)_ps_1);
  
  /* Evaluate the second polynom  (Pi/4 <= x <= 0) */

  v4sf y2 = *(v4sf*)_ps_sincof_p0;
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_mul_ps(y2, x);
  y2 = _mm_add_ps(y2, x);

  /* select the correct result from the two polynoms */  
  xmm3 = poly_mask;
  y2 = _mm_and_ps(xmm3, y2); //, xmm3);
  y = _mm_andnot_ps(xmm3, y);
  y = _mm_add_ps(y,y2);
  /* update the sign */
  y = _mm_xor_ps(y, sign_bit);
  return y;
}

/* almost the same as sin_ps */
v4sf cos_ps(v4sf x) { // any x
  v4sf xmm1, xmm2 = _mm_setzero_ps(), xmm3, y;
#ifdef USE_SSE2
  v4si emm0, emm2;
#else
  v2si mm0, mm1, mm2, mm3;
#endif
  /* take the absolute value */
  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
  
  /* scale by 4/Pi */
  y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);
  
#ifdef USE_SSE2
  /* store the integer part of y in mm0 */
  emm2 = _mm_cvttps_epi32(y);
  /* j=(j+1) & (~1) (see the cephes sources) */
  emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
  y = _mm_cvtepi32_ps(emm2);

  emm2 = _mm_sub_epi32(emm2, *(v4si*)_pi32_2);
  
  /* get the swap sign flag */
  emm0 = _mm_andnot_si128(emm2, *(v4si*)_pi32_4);
  emm0 = _mm_slli_epi32(emm0, 29);
  /* get the polynom selection mask */
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
  emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
  
  v4sf sign_bit = _mm_castsi128_ps(emm0);
  v4sf poly_mask = _mm_castsi128_ps(emm2);
#else
  /* store the integer part of y in mm0:mm1 */
  xmm2 = _mm_movehl_ps(xmm2, y);
  mm2 = _mm_cvttps_pi32(y);
  mm3 = _mm_cvttps_pi32(xmm2);

  /* j=(j+1) & (~1) (see the cephes sources) */
  mm2 = _mm_add_pi32(mm2, *(v2si*)_pi32_1);
  mm3 = _mm_add_pi32(mm3, *(v2si*)_pi32_1);
  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_inv1);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_inv1);

  y = _mm_cvtpi32x2_ps(mm2, mm3);


  mm2 = _mm_sub_pi32(mm2, *(v2si*)_pi32_2);
  mm3 = _mm_sub_pi32(mm3, *(v2si*)_pi32_2);

  /* get the swap sign flag in mm0:mm1 and the 
     polynom selection mask in mm2:mm3 */

  mm0 = _mm_andnot_si64(mm2, *(v2si*)_pi32_4);
  mm1 = _mm_andnot_si64(mm3, *(v2si*)_pi32_4);
  mm0 = _mm_slli_pi32(mm0, 29);
  mm1 = _mm_slli_pi32(mm1, 29);

  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_2);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_2);

  mm2 = _mm_cmpeq_pi32(mm2, _mm_setzero_si64());
  mm3 = _mm_cmpeq_pi32(mm3, _mm_setzero_si64());

  v4sf sign_bit, poly_mask;
  COPY_MM_TO_XMM(mm0, mm1, sign_bit);
  COPY_MM_TO_XMM(mm2, mm3, poly_mask);
  _mm_empty(); /* good-bye mmx */
#endif
  /* The magic pass: "Extended precision modular arithmetic" 
     x = ((x - y * DP1) - y * DP2) - y * DP3; */
  xmm1 = *(v4sf*)_ps_minus_cephes_DP1;
  xmm2 = *(v4sf*)_ps_minus_cephes_DP2;
  xmm3 = *(v4sf*)_ps_minus_cephes_DP3;
  xmm1 = _mm_mul_ps(y, xmm1);
  xmm2 = _mm_mul_ps(y, xmm2);
  xmm3 = _mm_mul_ps(y, xmm3);
  x = _mm_add_ps(x, xmm1);
  x = _mm_add_ps(x, xmm2);
  x = _mm_add_ps(x, xmm3);
  
  /* Evaluate the first polynom  (0 <= x <= Pi/4) */
  y = *(v4sf*)_ps_coscof_p0;
  v4sf z = _mm_mul_ps(x,x);

  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p1);
  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p2);
  y = _mm_mul_ps(y, z);
  y = _mm_mul_ps(y, z);
  v4sf tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
  y = _mm_sub_ps(y, tmp);
  y = _mm_add_ps(y, *(v4sf*)_ps_1);
  
  /* Evaluate the second polynom  (Pi/4 <= x <= 0) */

  v4sf y2 = *(v4sf*)_ps_sincof_p0;
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_mul_ps(y2, x);
  y2 = _mm_add_ps(y2, x);

  /* select the correct result from the two polynoms */  
  xmm3 = poly_mask;
  y2 = _mm_and_ps(xmm3, y2); //, xmm3);
  y = _mm_andnot_ps(xmm3, y);
  y = _mm_add_ps(y,y2);
  /* update the sign */
  y = _mm_xor_ps(y, sign_bit);

  return y;
}

/* since sin_ps and cos_ps are almost identical, sincos_ps could replace both of them..
   it is almost as fast, and gives you a free cosine with your sine */
void sincos_ps(v4sf x, v4sf *s, v4sf *c) {
  v4sf xmm1, xmm2, xmm3 = _mm_setzero_ps(), sign_bit_sin, y;
#ifdef USE_SSE2
  v4si emm0, emm2, emm4;
#else
  v2si mm0, mm1, mm2, mm3, mm4, mm5;
#endif
  sign_bit_sin = x;
  /* take the absolute value */
  x = _mm_and_ps(x, *(v4sf*)_ps_inv_sign_mask);
  /* extract the sign bit (upper one) */
  sign_bit_sin = _mm_and_ps(sign_bit_sin, *(v4sf*)_ps_sign_mask);
  
  /* scale by 4/Pi */
  y = _mm_mul_ps(x, *(v4sf*)_ps_cephes_FOPI);
    
#ifdef USE_SSE2
  /* store the integer part of y in emm2 */
  emm2 = _mm_cvttps_epi32(y);

  /* j=(j+1) & (~1) (see the cephes sources) */
  emm2 = _mm_add_epi32(emm2, *(v4si*)_pi32_1);
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_inv1);
  y = _mm_cvtepi32_ps(emm2);

  emm4 = emm2;

  /* get the swap sign flag for the sine */
  emm0 = _mm_and_si128(emm2, *(v4si*)_pi32_4);
  emm0 = _mm_slli_epi32(emm0, 29);
  v4sf swap_sign_bit_sin = _mm_castsi128_ps(emm0);

  /* get the polynom selection mask for the sine*/
  emm2 = _mm_and_si128(emm2, *(v4si*)_pi32_2);
  emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());
  v4sf poly_mask = _mm_castsi128_ps(emm2);
#else
  /* store the integer part of y in mm2:mm3 */
  xmm3 = _mm_movehl_ps(xmm3, y);
  mm2 = _mm_cvttps_pi32(y);
  mm3 = _mm_cvttps_pi32(xmm3);

  /* j=(j+1) & (~1) (see the cephes sources) */
  mm2 = _mm_add_pi32(mm2, *(v2si*)_pi32_1);
  mm3 = _mm_add_pi32(mm3, *(v2si*)_pi32_1);
  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_inv1);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_inv1);

  y = _mm_cvtpi32x2_ps(mm2, mm3);

  mm4 = mm2;
  mm5 = mm3;

  /* get the swap sign flag for the sine */
  mm0 = _mm_and_si64(mm2, *(v2si*)_pi32_4);
  mm1 = _mm_and_si64(mm3, *(v2si*)_pi32_4);
  mm0 = _mm_slli_pi32(mm0, 29);
  mm1 = _mm_slli_pi32(mm1, 29);
  v4sf swap_sign_bit_sin;
  COPY_MM_TO_XMM(mm0, mm1, swap_sign_bit_sin);

  /* get the polynom selection mask for the sine */

  mm2 = _mm_and_si64(mm2, *(v2si*)_pi32_2);
  mm3 = _mm_and_si64(mm3, *(v2si*)_pi32_2);
  mm2 = _mm_cmpeq_pi32(mm2, _mm_setzero_si64());
  mm3 = _mm_cmpeq_pi32(mm3, _mm_setzero_si64());
  v4sf poly_mask;
  COPY_MM_TO_XMM(mm2, mm3, poly_mask);
#endif

  /* The magic pass: "Extended precision modular arithmetic" 
     x = ((x - y * DP1) - y * DP2) - y * DP3; */
  xmm1 = *(v4sf*)_ps_minus_cephes_DP1;
  xmm2 = *(v4sf*)_ps_minus_cephes_DP2;
  xmm3 = *(v4sf*)_ps_minus_cephes_DP3;
  xmm1 = _mm_mul_ps(y, xmm1);
  xmm2 = _mm_mul_ps(y, xmm2);
  xmm3 = _mm_mul_ps(y, xmm3);
  x = _mm_add_ps(x, xmm1);
  x = _mm_add_ps(x, xmm2);
  x = _mm_add_ps(x, xmm3);

#ifdef USE_SSE2
  emm4 = _mm_sub_epi32(emm4, *(v4si*)_pi32_2);
  emm4 = _mm_andnot_si128(emm4, *(v4si*)_pi32_4);
  emm4 = _mm_slli_epi32(emm4, 29);
  v4sf sign_bit_cos = _mm_castsi128_ps(emm4);
#else
  /* get the sign flag for the cosine */
  mm4 = _mm_sub_pi32(mm4, *(v2si*)_pi32_2);
  mm5 = _mm_sub_pi32(mm5, *(v2si*)_pi32_2);
  mm4 = _mm_andnot_si64(mm4, *(v2si*)_pi32_4);
  mm5 = _mm_andnot_si64(mm5, *(v2si*)_pi32_4);
  mm4 = _mm_slli_pi32(mm4, 29);
  mm5 = _mm_slli_pi32(mm5, 29);
  v4sf sign_bit_cos;
  COPY_MM_TO_XMM(mm4, mm5, sign_bit_cos);
  _mm_empty(); /* good-bye mmx */
#endif

  sign_bit_sin = _mm_xor_ps(sign_bit_sin, swap_sign_bit_sin);

  
  /* Evaluate the first polynom  (0 <= x <= Pi/4) */
  v4sf z = _mm_mul_ps(x,x);
  y = *(v4sf*)_ps_coscof_p0;

  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p1);
  y = _mm_mul_ps(y, z);
  y = _mm_add_ps(y, *(v4sf*)_ps_coscof_p2);
  y = _mm_mul_ps(y, z);
  y = _mm_mul_ps(y, z);
  v4sf tmp = _mm_mul_ps(z, *(v4sf*)_ps_0p5);
  y = _mm_sub_ps(y, tmp);
  y = _mm_add_ps(y, *(v4sf*)_ps_1);
  
  /* Evaluate the second polynom  (Pi/4 <= x <= 0) */

  v4sf y2 = *(v4sf*)_ps_sincof_p0;
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p1);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_add_ps(y2, *(v4sf*)_ps_sincof_p2);
  y2 = _mm_mul_ps(y2, z);
  y2 = _mm_mul_ps(y2, x);
  y2 = _mm_add_ps(y2, x);

  /* select the correct result from the two polynoms */  
  xmm3 = poly_mask;
  v4sf ysin2 = _mm_and_ps(xmm3, y2);
  v4sf ysin1 = _mm_andnot_ps(xmm3, y);
  y2 = _mm_sub_ps(y2,ysin2);
  y = _mm_sub_ps(y, ysin1);

  xmm1 = _mm_add_ps(ysin1,ysin2);
  xmm2 = _mm_add_ps(y,y2);
 
  /* update the sign */
  *s = _mm_xor_ps(xmm1, sign_bit_sin);
  *c = _mm_xor_ps(xmm2, sign_bit_cos);
}


```

`cl_dll/include/overview.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#ifndef OVERVIEW_H
#define OVERVIEW_H


//-----------------------------------------------------------------------------
// Purpose: Handles the drawing of the top-down map and all the things on it
//-----------------------------------------------------------------------------
class CHudOverview : public CHudBase
{
public:
	int Init();
	int VidInit();

	int Draw(float flTime);
	void InitHUDData( void );

private:
	HSPRITE m_hsprPlayer;
	HSPRITE m_hsprViewcone;
};


#endif // OVERVIEW_H

```

`cl_dll/include/parsemsg.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  parsemsg.h
//
#pragma once
#define ASSERT( x )

#include <stdint.h>

class BufferReader
{
public:
	BufferReader( const char *name, void *buf, int size ) :
		m_szMsgName( name ), m_pBuf( (uint8_t*)buf ), m_iSize( size ), m_iRead( 0 ), m_bBad( false ) {}
	BufferReader( void *buf, int size ) : BufferReader( "not set", buf, size ) {}

#ifdef _DEBUG
	inline ~BufferReader( void );
#endif

	template<typename T> T Read( void );

	int8_t ReadChar( void );
	uint8_t ReadByte( void );
	int16_t ReadShort( void );
	int16_t ReadWord( void );
	int32_t ReadLong( void ); // no mistake here, we assume that long is 32 bit.
	char *ReadString( void );
	float ReadFloat( void );
	float ReadCoord( void );
	float ReadAngle( void );
	float ReadHiResAngle( void );
private:
	const char *m_szMsgName;
	uint8_t *m_pBuf;
	size_t   m_iSize;
	size_t   m_iRead;
	bool     m_bBad;
};

template<typename T>
inline T BufferReader::Read( void )
{
	if( m_bBad )
		return -1;

	// don't go out of bounds
	if( m_iRead + sizeof( T ) > m_iSize )
	{
		m_bBad = true;

		// may occur, but safe
		//gEngfuncs.Con_DPrintf( "BufferReader(%s): buffer overrun. Expected %i\n", m_szMsgName, m_iSize );
		return -1;
	}

	if( sizeof( T ) == 1 )
		return m_pBuf[m_iRead++];

	T t = *(T*)(m_pBuf + m_iRead);
	m_iRead += sizeof( T );

	return t;
}


template<>
inline char* BufferReader::Read( void )
{
	static char string[2048];

	if( m_bBad )
		return (char*)""; // do not return NULL, may break strcpy's

	size_t l;
	for( l = 0; l < sizeof(string) - 1; l++)
	{
		if( m_iRead > m_iSize )
			break;

		int8_t c = ReadChar();
		if( c == -1 || c == 0 )
			break;

		string[l] = c;
	}

	string[l] = 0;

	return string;

}

template<>
inline float BufferReader::Read( void )
{
	union
	{
		unsigned char b[4];
		float f;
	} tr;

	if( m_bBad )
		return -1.0f;

	if( m_iRead + 4 > m_iSize )
	{
		m_bBad = true;
		return -1.0f;
	}

	for( int i = 0; i < 4; i++ )
		tr.b[i] = m_pBuf[m_iRead + i];

	m_iRead += 4;

	return tr.f;
}

inline int8_t BufferReader::ReadChar( void )
{
	return Read<int8_t>();
}

inline uint8_t BufferReader::ReadByte( void )
{
	return Read<uint8_t>();
}

inline int16_t BufferReader::ReadShort( void )
{
	return Read<int16_t>();
}

inline int16_t BufferReader::ReadWord( void )
{
	return ReadShort();
}

inline int32_t BufferReader::ReadLong( void )
{
	return Read<int32_t>();
}

inline char *BufferReader::ReadString( void )
{
	return Read<char*>();
}

inline float BufferReader::ReadFloat( void )
{
	return Read<float>();
}

inline float BufferReader::ReadCoord( void )
{
	return ReadShort() * 0.125f;
}

inline float BufferReader::ReadAngle( void )
{
	return ReadChar() * 360.0f / 256.0f;
}

inline float BufferReader::ReadHiResAngle( void )
{
	return ReadShort() * 360.0f / 65536.0f;
}

#ifdef _DEBUG
BufferReader::~BufferReader()
{
	if( m_iRead < m_iSize )
		gEngfuncs.Con_DPrintf( "BufferReader(%s): destroyed before reaching end. Expected %i, read %i\n", m_szMsgName, m_iSize, m_iRead );
}
#endif

/*
void BEGIN_READ( void *buf, int size );
int READ_CHAR( void );
int READ_BYTE( void );
int READ_SHORT( void );
int READ_WORD( void );
int READ_LONG( void );
float READ_FLOAT( void );
char* READ_STRING( void );
float READ_COORD( void );
float READ_ANGLE( void );
float READ_HIRESANGLE( void );
*/









```

`cl_dll/include/rain.h`:

```h
/***
*
*	Copyright (c) 1996-2004, Shambler Team. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Shambler Team.  All other use, distribution, or modification is prohibited
*   without written permission from Shambler Team.
*
****/
/*
====== rain.h ========================================================
*/
#pragma once
#ifndef __RAIN_H__
#define __RAIN_H__

void ProcessRain( void );
void ProcessFXObjects( void );
void ResetRain( void );
void InitRain( void );
void DrawRain( void );
void DrawFXObjects( void );

#endif

```

`cl_dll/include/studio/GameStudioModelRenderer.h`:

```h

/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Big thanks to Chicken Fortress developers
// for this code.

#pragma once
#if !defined (GAMESTUDIOMODELRENDERER_H)
#define GAMESTUDIOMODELRENDERER_H

enum BoneIndex
{
	BONE_HEAD,
	BONE_PELVIS,
	BONE_SPINE1,
	BONE_SPINE2,
	BONE_SPINE3,
	BONE_MAX,
};

struct client_anim_state_t
{
	vec3_t origin;
	vec3_t angles;

	vec3_t realangles;

	float animtime;
	float frame;
	int sequence;
	int gaitsequence;
	float framerate;

	int m_fSequenceLoops;
	int m_fSequenceFinished;

	byte controller[4];
	byte blending[2];

	latchedvars_t lv;
};

class CGameStudioModelRenderer : public CStudioModelRenderer
{
public:
	CGameStudioModelRenderer(void);

public:
	virtual void StudioSetupBones(void);
	virtual void StudioEstimateGait(entity_state_t *pplayer);
	virtual void StudioProcessGait(entity_state_t *pplayer);
	virtual int StudioDrawPlayer(int flags, entity_state_t *pplayer);
	virtual int _StudioDrawPlayer(int flags, entity_state_t *pplayer);
	virtual void StudioFxTransform(cl_entity_t *ent, float transform[3][4]);
	virtual void StudioPlayerBlend(mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch);
	virtual void CalculateYawBlend(entity_state_t *pplayer);
	virtual void CalculatePitchBlend(entity_state_t *pplayer);

private:
	void SavePlayerState(entity_state_t *pplayer);
	void SetupClientAnimation(entity_state_t *pplayer);
	void RestorePlayerState(entity_state_t *pplayer);
	mstudioanim_t* LookupAnimation(mstudioseqdesc_t *pseqdesc, int index);

private:
	int m_nPlayerGaitSequences[MAX_CLIENTS];
	bool m_bLocal;
};

extern CGameStudioModelRenderer g_StudioRenderer;

#endif

```

`cl_dll/include/studio/StudioModelRenderer.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Big thanks to Chicken Fortress developers
// for this code.
#pragma once
#ifndef STUDIOMODELRENDERER_H
#define STUDIOMODELRENDERER_H

class CStudioModelRenderer
{
public:
	CStudioModelRenderer(void);
	virtual ~CStudioModelRenderer(void);

public:
	virtual void Init(void);
	virtual int StudioDrawModel(int flags);
	virtual int StudioDrawPlayer(int flags, struct entity_state_s *pplayer);

public:
	virtual mstudioanim_t *StudioGetAnim(model_t *m_pSubModel, mstudioseqdesc_t *pseqdesc);
	virtual void StudioSetUpTransform(int trivial_accept);
	virtual void StudioSetupBones(void);
	virtual void StudioCalcAttachments(void);
	virtual void StudioSaveBones(void);
	virtual void StudioMergeBones(model_t *m_pSubModel);
	virtual float StudioEstimateInterpolant(void);
	virtual float StudioEstimateFrame(mstudioseqdesc_t *pseqdesc);
	virtual void StudioFxTransform(cl_entity_t *ent, float transform[3][4]);
	virtual void StudioSlerpBones(vec4_t q1[], float pos1[][3], vec4_t q2[], float pos2[][3], float s);
	virtual void StudioCalcBoneAdj(float dadt, float *adj, const byte *pcontroller1, const byte *pcontroller2, byte mouthopen);
	virtual void StudioCalcBoneQuaterion(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *q);
	virtual void StudioCalcBonePosition(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *pos);
	virtual void StudioCalcRotations(float pos[][3], vec4_t *q, mstudioseqdesc_t *pseqdesc, mstudioanim_t *panim, float f);
	virtual void StudioRenderModel(float *lightdir);
	virtual void StudioRenderFinal(void);
	virtual void StudioRenderFinal_Software(void);
	virtual void StudioRenderFinal_Hardware(void);
	virtual void StudioPlayerBlend(mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch);
	virtual void StudioEstimateGait(entity_state_t *pplayer);
	virtual void StudioProcessGait(entity_state_t *pplayer);
	virtual void StudioSetShadowSprite(int idx);
	virtual void StudioDrawShadow(Vector origin, float scale);


public:
	double m_clTime;
	double m_clOldTime;
	int m_fDoInterp;
	int m_iShadowSprite;
	int m_fGaitEstimation;
	int m_nFrameCount;
	cvar_t *m_pCvarHiModels;
	cvar_t *m_pCvarDeveloper;
	cvar_t *m_pCvarDrawEntities;
	cl_entity_t *m_pCurrentEntity;
	model_t *m_pRenderModel;
	player_info_t *m_pPlayerInfo;
	int m_nPlayerIndex;
	float m_flGaitMovement;
	studiohdr_t *m_pStudioHeader;
	mstudiobodyparts_t *m_pBodyPart;
	mstudiomodel_t *m_pSubModel;
	int m_nTopColor;
	int m_nBottomColor;
	model_t *m_pChromeSprite;
	int m_nCachedBones;
	char m_nCachedBoneNames[MAXSTUDIOBONES][32];
	float m_rgCachedBoneTransform[MAXSTUDIOBONES][3][4];
	float m_rgCachedLightTransform[MAXSTUDIOBONES][3][4];
	float m_fSoftwareXScale, m_fSoftwareYScale;
	float m_vUp[3];
	float m_vRight[3];
	float m_vNormal[3];
	float m_vRenderOrigin[3];
	int *m_pStudioModelCount;
	int *m_pModelsDrawn;
	float (*m_protationmatrix)[3][4];
	float (*m_paliastransform)[3][4];
	float (*m_pbonetransform)[MAXSTUDIOBONES][3][4];
	float (*m_plighttransform)[MAXSTUDIOBONES][3][4];
};

#endif

```

`cl_dll/include/studio/studio_util.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined( STUDIO_UTIL_H )
#define STUDIO_UTIL_H


#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

#ifndef PITCH
// MOVEMENT INFO
// up / down
#define	PITCH	0
// left / right
#define	YAW		1
// fall over
#define	ROLL	2
#endif

#define FDotProduct( a, b ) (fabs((a[0])*(b[0])) + fabs((a[1])*(b[1])) + fabs((a[2])*(b[2])))

void	AngleMatrix (const float *angles, float (*matrix)[4] );
int		VectorCompare (const float *v1, const float *v2);
void	CrossProduct (const float *v1, const float *v2, float *cross);
void	VectorTransform (const float *in1, float in2[3][4], float *out);
void	ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4]);
void	MatrixCopy( float in[3][4], float out[3][4] );
void	QuaternionMatrix( vec4_t quaternion, float (*matrix)[4] );
void	QuaternionSlerp( vec4_t p, vec4_t q, float t, vec4_t qt );
void	AngleQuaternion( float *angles, vec4_t quaternion );

#endif // STUDIO_UTIL_H
```

`cl_dll/include/tf_defs.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
****/

#ifndef __TF_DEFS_H
#define __TF_DEFS_H

//===========================================================================
// OLD OPTIONS.QC
//===========================================================================
#define DEFAULT_AUTOZOOM		 FALSE
#define WEINER_SNIPER                           // autoaiming for sniper rifle
#define FLAME_MAXWORLDNUM        20             // maximum number of flames in the world. DO NOT PUT BELOW 20.

//#define MAX_WORLD_PIPEBOMBS      15             // This is divided between teams - this is the most you should have on a net server
#define MAX_PLAYER_PIPEBOMBS	 8				// maximum number of pipebombs any 1 player can have active
#define MAX_PLAYER_AMMOBOXES  3				// maximum number of ammoboxes any 1 player can have active

//#define MAX_WORLD_FLARES         9              // This is the total number of flares allowed in the world at one time
//#define MAX_WORLD_AMMOBOXES      20             // This is divided between teams - this is the most you should have on a net server
#define GR_TYPE_MIRV_NO          4              // Number of Mirvs a Mirv Grenade breaks into
#define GR_TYPE_NAPALM_NO        8              // Number of flames napalm grenade breaks into (unused if net server)
#define MEDIKIT_IS_BIOWEAPON					// Medikit acts as a bioweapon against enemies

#define TEAM_HELP_RATE   60     // used only if teamplay bit 64 (help team with lower score) is set.  
								// 60 is a mild setting, and won't make too much difference
								// increasing it _decreases_ the amount of help the losing team gets
								// Minimum setting is 1, which would really help the losing team

#define DISPLAY_CLASS_HELP			TRUE            // Change this to #OFF if you don't want the class help to 
													// appear whenever a player connects
#define NEVER_TEAMFRAGS				FALSE			// teamfrags options always off 
#define ALWAYS_TEAMFRAGS			FALSE			// teamfrags options always on 
#define CHECK_SPEEDS				TRUE            // makes sure players aren't moving too fast
#define SNIPER_RIFLE_RELOAD_TIME    1.5				// seconds

#define MAPBRIEFING_MAXTEXTLENGTH	512
#define PLAYER_PUSH_VELOCITY			 50			// Players push teammates if they're moving under this speed

// Debug Options
//#define MAP_DEBUG                     // Debug for Map code. I suggest running in a hi-res
										// mode and/or piping the output from the server to a file.
#ifdef MAP_DEBUG
	#define MDEBUG(x) x
#else
	#define MDEBUG(x)
#endif
//#define VERBOSE                       // Verbose Debugging on/off

//===========================================================================
// OLD QUAKE Defs
//===========================================================================
// items
#define IT_AXE					4096 
#define IT_SHOTGUN				1 
#define IT_SUPER_SHOTGUN		2 
#define IT_NAILGUN				4 
#define IT_SUPER_NAILGUN		8 
#define IT_GRENADE_LAUNCHER		16 
#define IT_ROCKET_LAUNCHER		32 
#define IT_LIGHTNING			64 
#define IT_EXTRA_WEAPON			128 

#define IT_SHELLS				256 
#define IT_NAILS				512 
#define IT_ROCKETS				1024 
#define IT_CELLS				2048 

#define IT_ARMOR1				8192 
#define IT_ARMOR2				16384 
#define IT_ARMOR3				32768 
#define IT_SUPERHEALTH			65536 

#define IT_KEY1					131072 
#define IT_KEY2					262144 

#define IT_INVISIBILITY			524288 
#define IT_INVULNERABILITY		1048576 
#define IT_SUIT					2097152
#define IT_QUAD					4194304 
#define IT_HOOK					8388608

#define IT_KEY3					16777216	// Stomp invisibility
#define IT_KEY4					33554432	// Stomp invulnerability

//===========================================================================
// TEAMFORTRESS Defs
//===========================================================================
// TeamFortress State Flags
#define TFSTATE_GRENPRIMED		1 	// Whether the player has a primed grenade
#define TFSTATE_RELOADING		2 	// Whether the player is reloading
#define TFSTATE_ALTKILL			4  	// #TRUE if killed with a weapon not in self.weapon: NOT USED ANYMORE
#define TFSTATE_RANDOMPC		8   // Whether Playerclass is random, new one each respawn
#define TFSTATE_INFECTED		16 	// set when player is infected by the bioweapon
#define TFSTATE_INVINCIBLE		32 	// Player has permanent Invincibility (Usually by GoalItem)
#define TFSTATE_INVISIBLE		64 	// Player has permanent Invisibility (Usually by GoalItem)
#define TFSTATE_QUAD			128 // Player has permanent Quad Damage (Usually by GoalItem)
#define TFSTATE_RADSUIT			256 // Player has permanent Radsuit (Usually by GoalItem)
#define TFSTATE_BURNING			512 // Is on fire
#define TFSTATE_GRENTHROWING	1024  // is throwing a grenade
#define TFSTATE_AIMING			2048  // is using the laser sight
#define TFSTATE_ZOOMOFF			4096  // doesn't want the FOV changed when zooming
#define TFSTATE_RESPAWN_READY	8192  // is waiting for respawn, and has pressed fire
#define TFSTATE_HALLUCINATING  16384  // set when player is hallucinating
#define TFSTATE_TRANQUILISED   32768  // set when player is tranquilised
#define TFSTATE_CANT_MOVE	   65536  // set when player is setting a detpack
#define TFSTATE_RESET_FLAMETIME 131072 // set when the player has to have his flames increased in health

// Defines used by TF_T_Damage (see combat.qc)
#define TF_TD_IGNOREARMOUR	1  // Bypasses the armour of the target
#define TF_TD_NOTTEAM		2  // Doesn't damage a team member (indicates direct fire weapon)
#define TF_TD_NOTSELF		4  // Doesn't damage self

#define TF_TD_OTHER			0  // Ignore armorclass
#define TF_TD_SHOT			1  // Bullet damage
#define TF_TD_NAIL			2  // Nail damage
#define TF_TD_EXPLOSION		4  // Explosion damage
#define TF_TD_ELECTRICITY	8  // Electric damage
#define TF_TD_FIRE			16  // Fire damage
#define TF_TD_NOSOUND		256 // Special damage. Makes no sound/painframe, etc

/*==================================================*/
/* Toggleable Game Settings							*/
/*==================================================*/
#define TF_RESPAWNDELAY1	5 	// seconds of waiting before player can respawn
#define TF_RESPAWNDELAY2	10 	// seconds of waiting before player can respawn
#define TF_RESPAWNDELAY3	20 	// seconds of waiting before player can respawn

#define TEAMPLAY_NORMAL			 1			
#define TEAMPLAY_HALFDIRECT		 2
#define TEAMPLAY_NODIRECT		 4
#define TEAMPLAY_HALFEXPLOSIVE	 8
#define TEAMPLAY_NOEXPLOSIVE	 16
#define TEAMPLAY_LESSPLAYERSHELP 32
#define TEAMPLAY_LESSSCOREHELP	 64
#define TEAMPLAY_HALFDIRECTARMOR 128
#define TEAMPLAY_NODIRECTARMOR 	 256
#define TEAMPLAY_HALFEXPARMOR	 512
#define TEAMPLAY_NOEXPARMOR		 1024
#define TEAMPLAY_HALFDIRMIRROR	 2048
#define TEAMPLAY_FULLDIRMIRROR	 4096
#define TEAMPLAY_HALFEXPMIRROR	 8192
#define TEAMPLAY_FULLEXPMIRROR	 16384

#define TEAMPLAY_TEAMDAMAGE		(TEAMPLAY_NODIRECT | TEAMPLAY_HALFDIRECT | TEAMPLAY_HALFEXPLOSIVE | TEAMPLAY_NOEXPLOSIVE)
// FortressMap stuff
#define TEAM1_CIVILIANS 1	
#define TEAM2_CIVILIANS 2
#define TEAM3_CIVILIANS 4	
#define TEAM4_CIVILIANS 8	

// Defines for the playerclass
#define PC_UNDEFINED	0 

#define PC_SCOUT		1 
#define PC_SNIPER		2 
#define PC_SOLDIER		3 
#define PC_DEMOMAN		4 
#define PC_MEDIC		5 
#define PC_HVYWEAP		6 
#define PC_PYRO			7
#define PC_SPY			8
#define PC_ENGINEER		9

// Insert new class definitions here

// PC_RANDOM _MUST_ be the third last class
#define PC_RANDOM		10 		// Random playerclass
#define PC_CIVILIAN		11		// Civilians are a special class. They cannot
								// be chosen by players, only enforced by maps
#define PC_LASTCLASS	12 		// Use this as the high-boundary for any loops
								// through the playerclass.

#define SENTRY_COLOR	10		// will be in the PC_RANDOM slot for team colors

// These are just for the scanner
#define SCAN_SENTRY		13
#define SCAN_GOALITEM	14

// Values returned by CheckArea
enum
{
	CAREA_CLEAR,
	CAREA_BLOCKED,
	CAREA_NOBUILD
};

/*==================================================*/
/* Impulse Defines		                        	*/
/*==================================================*/
// Alias check to see whether they already have the aliases
#define TF_ALIAS_CHECK		13 

// CTF Support Impulses
#define HOOK_IMP1		22
#define FLAG_INFO		23
#define HOOK_IMP2		39

// Axe
#define AXE_IMP			40

// Camera Impulse
#define TF_CAM_TARGET			50
#define TF_CAM_ZOOM				51
#define TF_CAM_ANGLE			52
#define TF_CAM_VEC				53
#define TF_CAM_PROJECTILE		54
#define TF_CAM_PROJECTILE_Z		55
#define TF_CAM_REVANGLE			56
#define TF_CAM_OFFSET			57
#define TF_CAM_DROP				58	
#define TF_CAM_FADETOBLACK		59
#define TF_CAM_FADEFROMBLACK	60
#define TF_CAM_FADETOWHITE		61
#define TF_CAM_FADEFROMWHITE	62

// Last Weapon impulse
#define TF_LAST_WEAPON			69

// Status Bar Resolution Settings.  Same as CTF to maintain ease of use.
#define TF_STATUSBAR_RES_START	71
#define TF_STATUSBAR_RES_END	81

// Clan Messages
#define TF_MESSAGE_1			82
#define TF_MESSAGE_2			83
#define TF_MESSAGE_3			84
#define TF_MESSAGE_4			85
#define TF_MESSAGE_5			86

#define TF_CHANGE_CLASS			99	// Bring up the Class Change menu

// Added to PC_??? to get impulse to use if this clashes with your 
// own impulses, just change this value, not the PC_??
#define TF_CHANGEPC			100 
// The next few impulses are all the class selections
//PC_SCOUT		101 
//PC_SNIPER		102 
//PC_SOLDIER	103 
//PC_DEMOMAN	104 
//PC_MEDIC		105 
//PC_HVYWEAP	106 
//PC_PYRO		107 
//PC_RANDOM		108
//PC_CIVILIAN	109  // Cannot be used
//PC_SPY		110
//PC_ENGINEER	111

// Help impulses
#define TF_DISPLAYLOCATION  118
#define TF_STATUS_QUERY		119

#define TF_HELP_MAP			131

// Information impulses
#define TF_INVENTORY		135
#define TF_SHOWTF			136 
#define TF_SHOWLEGALCLASSES	137

// Team Impulses
#define TF_TEAM_1			140   // Join Team 1
#define TF_TEAM_2			141   // Join Team 2
#define TF_TEAM_3			142   // Join Team 3
#define TF_TEAM_4			143   // Join Team 4
#define TF_TEAM_CLASSES		144   // Impulse to display team classes
#define TF_TEAM_SCORES		145   // Impulse to display team scores
#define TF_TEAM_LIST		146   // Impulse to display the players in each team.

// Grenade Impulses
#define TF_GRENADE_1		150   // Prime grenade type 1
#define TF_GRENADE_2		151   // Prime grenade type 2
#define TF_GRENADE_T		152   // Throw primed grenade

// Impulses for new items
//#define TF_SCAN				159		// Scanner Pre-Impulse
#define TF_AUTO_SCAN		159		// Scanner On/Off
#define TF_SCAN_ENEMY		160		// Impulses to toggle scanning of enemies
#define TF_SCAN_FRIENDLY	161		// Impulses to toggle scanning of friendlies 
//#define TF_SCAN_10			162		// Scan using 10 enery (1 cell)
#define TF_SCAN_SOUND		162		// Scanner sounds on/off
#define TF_SCAN_30			163		// Scan using 30 energy (2 cells)
#define TF_SCAN_100			164		// Scan using 100 energy (5 cells)
#define TF_DETPACK_5		165		// Detpack set to 5 seconds
#define TF_DETPACK_20		166		// Detpack set to 20 seconds
#define TF_DETPACK_50		167		// Detpack set to 50 seconds
#define TF_DETPACK			168		// Detpack Pre-Impulse
#define TF_DETPACK_STOP		169		// Impulse to stop setting detpack
#define TF_PB_DETONATE		170		// Detonate Pipebombs

// Special skill
#define TF_SPECIAL_SKILL	171

// Ammo Drop impulse
#define TF_DROP_AMMO        172

// Reload impulse
#define TF_RELOAD			173

// auto-zoom toggle
#define TF_AUTOZOOM			174

// drop/pass commands
#define TF_DROPKEY			175

// Select Medikit		
#define TF_MEDIKIT			176

// Spy Impulses
#define TF_SPY_SPY			177		// On net, go invisible, on LAN, change skin/color
#define TF_SPY_DIE			178		// Feign Death

// Engineer Impulses
#define TF_ENGINEER_BUILD	179
#define TF_ENGINEER_SANDBAG	180

// Medic
#define TF_MEDIC_HELPME		181

// Status bar
#define TF_STATUSBAR_ON		182
#define TF_STATUSBAR_OFF	183

// Discard impulse
#define TF_DISCARD 	  		184

// ID Player impulse
#define TF_ID	 	  		185

// Clan Battle impulses
#define TF_SHOWIDS			186

// More Engineer Impulses
#define TF_ENGINEER_DETDISP 187
#define TF_ENGINEER_DETSENT 188

// Admin Commands
#define TF_ADMIN_DEAL_CYCLE		189
#define TF_ADMIN_KICK			190
#define TF_ADMIN_BAN			191
#define TF_ADMIN_COUNTPLAYERS	192
#define TF_ADMIN_CEASEFIRE		193

// Drop Goal Items
#define TF_DROPGOALITEMS 		194

// More Admin Commands
#define TF_ADMIN_NEXT			195

// More Engineer Impulses
#define TF_ENGINEER_DETEXIT 	196
#define TF_ENGINEER_DETENTRANCE	197

// Yet MORE Admin Commands
#define TF_ADMIN_LISTIPS		198

// Silent Spy Feign
#define TF_SPY_SILENTDIE		199


/*==================================================*/
/* Defines for the ENGINEER's Building ability		*/
/*==================================================*/
// Ammo costs
#define AMMO_COST_SHELLS		2		// Metal needed to make 1 shell
#define AMMO_COST_NAILS			1
#define AMMO_COST_ROCKETS		2
#define AMMO_COST_CELLS			2

// Building types
#define BUILD_DISPENSER				1
#define BUILD_SENTRYGUN				2
#define BUILD_MORTAR				3
#define BUILD_TELEPORTER_ENTRANCE	4
#define BUILD_TELEPORTER_EXIT		5

// Building metal costs
#define BUILD_COST_DISPENSER	100		// Metal needed to built 
#define BUILD_COST_SENTRYGUN	130		
#define BUILD_COST_MORTAR		150		
#define BUILD_COST_TELEPORTER	125		

#define BUILD_COST_SANDBAG		20		// Built with a separate alias

// Building times
#define BUILD_TIME_DISPENSER	2		// seconds to build
#define BUILD_TIME_SENTRYGUN	5		
#define BUILD_TIME_MORTAR		5		
#define BUILD_TIME_TELEPORTER	4		

// Building health levels
#define BUILD_HEALTH_DISPENSER	150		// Health of the building
#define BUILD_HEALTH_SENTRYGUN	150		
#define BUILD_HEALTH_MORTAR		200		
#define BUILD_HEALTH_TELEPORTER 80

// Dispenser's maximum carrying capability
#define BUILD_DISPENSER_MAX_SHELLS  400
#define BUILD_DISPENSER_MAX_NAILS   600
#define BUILD_DISPENSER_MAX_ROCKETS 300
#define BUILD_DISPENSER_MAX_CELLS   400
#define BUILD_DISPENSER_MAX_ARMOR   500

// Build state sent down to client
#define BS_BUILDING			(1<<0)
#define BS_HAS_DISPENSER	(1<<1)
#define BS_HAS_SENTRYGUN	(1<<2)
#define BS_CANB_DISPENSER	(1<<3)
#define BS_CANB_SENTRYGUN	(1<<4)
/*==================================================*/
/* Ammo quantities for dropping & dispenser use		*/
/*==================================================*/
#define DROP_SHELLS   20
#define DROP_NAILS    20
#define DROP_ROCKETS  10
#define DROP_CELLS    10
#define DROP_ARMOR	  40

/*==================================================*/
/* Team Defines				            			*/
/*==================================================*/
#define TM_MAX_NO	4 			// Max number of teams. Simply changing this value isn't enough.
								// A new global to hold new team colors is needed, and more flags
								// in the spawnpoint spawnflags may need to be used.
								// Basically, don't change this unless you know what you're doing :)

/*==================================================*/
/* New Weapon Defines		                        */
/*==================================================*/
#define WEAP_HOOK				1
#define WEAP_BIOWEAPON			2
#define WEAP_MEDIKIT			4
#define WEAP_SPANNER			8
#define WEAP_AXE				16
#define WEAP_SNIPER_RIFLE		32
#define WEAP_AUTO_RIFLE			64
#define WEAP_SHOTGUN			128
#define WEAP_SUPER_SHOTGUN		256
#define WEAP_NAILGUN			512
#define WEAP_SUPER_NAILGUN		1024
#define WEAP_GRENADE_LAUNCHER	2048
#define WEAP_FLAMETHROWER		4096
#define WEAP_ROCKET_LAUNCHER	8192
#define WEAP_INCENDIARY			16384
#define WEAP_ASSAULT_CANNON		32768
#define WEAP_LIGHTNING			65536
#define WEAP_DETPACK			131072
#define WEAP_TRANQ				262144
#define WEAP_LASER				524288
// still room for 12 more weapons
// but we can remove some by giving the weapons
// a weapon mode (like the rifle)

// HL-compatible weapon numbers
#define WEAPON_HOOK				1
#define WEAPON_BIOWEAPON		(WEAPON_HOOK+1)
#define WEAPON_MEDIKIT			(WEAPON_HOOK+2)
#define WEAPON_SPANNER			(WEAPON_HOOK+3)
#define WEAPON_AXE				(WEAPON_HOOK+4)
#define WEAPON_SNIPER_RIFLE		(WEAPON_HOOK+5)
#define WEAPON_AUTO_RIFLE		(WEAPON_HOOK+6)
#define WEAPON_TF_SHOTGUN		(WEAPON_HOOK+7)
#define WEAPON_SUPER_SHOTGUN	(WEAPON_HOOK+8)
#define WEAPON_NAILGUN			(WEAPON_HOOK+9)
#define WEAPON_SUPER_NAILGUN	(WEAPON_HOOK+10)
#define WEAPON_GRENADE_LAUNCHER	(WEAPON_HOOK+11)
#define WEAPON_FLAMETHROWER		(WEAPON_HOOK+12)
#define WEAPON_ROCKET_LAUNCHER	(WEAPON_HOOK+13)
#define WEAPON_INCENDIARY		(WEAPON_HOOK+14)
#define WEAPON_ASSAULT_CANNON	(WEAPON_HOOK+16)
#define WEAPON_LIGHTNING		(WEAPON_HOOK+17)
#define WEAPON_DETPACK			(WEAPON_HOOK+18)
#define WEAPON_TRANQ			(WEAPON_HOOK+19)
#define WEAPON_LASER			(WEAPON_HOOK+20)
#define WEAPON_PIPEBOMB_LAUNCHER (WEAPON_HOOK+21)
#define WEAPON_KNIFE			(WEAPON_HOOK+22)
#define WEAPON_BENCHMARK		(WEAPON_HOOK+23)

/*==================================================*/
/* New Weapon Related Defines		                */
/*==================================================*/
// shots per reload 
#define RE_SHOTGUN			8
#define RE_SUPER_SHOTGUN	16 // 8 shots
#define RE_GRENADE_LAUNCHER	6 
#define RE_ROCKET_LAUNCHER	4 

// reload times
#define RE_SHOTGUN_TIME				2 
#define RE_SUPER_SHOTGUN_TIME		3 
#define RE_GRENADE_LAUNCHER_TIME	4 
#define RE_ROCKET_LAUNCHER_TIME		5 

// Maximum velocity you can move and fire the Sniper Rifle
#define WEAP_SNIPER_RIFLE_MAX_MOVE	50 

// Medikit
#define WEAP_MEDIKIT_HEAL	200  // Amount medikit heals per hit
#define WEAP_MEDIKIT_OVERHEAL 50 // Amount of superhealth over max_health the medikit will dispense

// Spanner
#define WEAP_SPANNER_REPAIR 10

// Detpack
#define WEAP_DETPACK_DISARMTIME		3   	// Time it takes to disarm a Detpack
#define WEAP_DETPACK_SETTIME		3   	// Time it takes to set a Detpack
#define WEAP_DETPACK_SIZE			700	 	// Explosion Size
#define WEAP_DETPACK_GOAL_SIZE		1500 	// Explosion Size for goal triggering
#define WEAP_DETPACK_BITS_NO		12  	// Bits that detpack explodes into

// Tranquiliser Gun
#define TRANQ_TIME			15

// Grenades
#define GR_PRIMETIME		3
#define GR_CALTROP_PRIME	0.5
#define GR_TYPE_NONE		0 
#define GR_TYPE_NORMAL		1 
#define GR_TYPE_CONCUSSION	2 
#define GR_TYPE_NAIL		3 
#define GR_TYPE_MIRV		4 
#define GR_TYPE_NAPALM		5 
//#define GR_TYPE_FLARE		6 
#define GR_TYPE_GAS			7
#define GR_TYPE_EMP			8
#define GR_TYPE_CALTROP		9
//#define GR_TYPE_FLASH		10

// Defines for WeaponMode
#define GL_NORMAL	0 
#define GL_PIPEBOMB	1

// Defines for OLD Concussion Grenade
#define GR_OLD_CONCUSS_TIME		5 
#define GR_OLD_CONCUSS_DEC		20 

// Defines for Concussion Grenade
#define GR_CONCUSS_TIME		0.25 
#define GR_CONCUSS_DEC		10
#define MEDIUM_PING			150
#define HIGH_PING			200

// Defines for the Gas Grenade
#define GR_HALLU_TIME		0.3
#define GR_OLD_HALLU_TIME	0.5
#define GR_HALLU_DEC		2.5

// Defines for the BioInfection
#define BIO_JUMP_RADIUS 128		// The distance the bioinfection can jump between players

/*==================================================*/
/* New Items			                        	*/
/*==================================================*/
#define NIT_SCANNER				1 

#define NIT_SILVER_DOOR_OPENED 	#IT_KEY1	// 131072 
#define NIT_GOLD_DOOR_OPENED 	#IT_KEY2	// 262144

/*==================================================*/
/* New Item Flags		                        	*/
/*==================================================*/
#define NIT_SCANNER_ENEMY		1 	// Detect enemies
#define NIT_SCANNER_FRIENDLY	2 	// Detect friendlies (team members)
#define NIT_SCANNER_SOUND		4 	// Motion detection. Only report moving entities.

/*==================================================*/
/* New Item Related Defines		                    */
/*==================================================*/
#define NIT_SCANNER_POWER			25	// The amount of power spent on a scan with the scanner
										// is multiplied by this to get the scanrange.
#define NIT_SCANNER_MAXCELL			50 	// The maximum number of cells than can be used in one scan
#define NIT_SCANNER_MIN_MOVEMENT	50 	// The minimum velocity an entity must have to be detected
										// by scanners that only detect movement

/*==================================================*/
/* Variables used for New Weapons and Reloading     */
/*==================================================*/
// Armor Classes : Bitfields. Use the "armorclass" of armor for the Armor Type.
#define AT_SAVESHOT			1   // Kevlar  	 : Reduces bullet damage by 15%
#define AT_SAVENAIL			2   // Wood :) 	 : Reduces nail damage by 15%
#define AT_SAVEEXPLOSION	4  	// Blast   	 : Reduces explosion damage by 15%
#define AT_SAVEELECTRICITY	8 	// Shock	 : Reduces electricity damage by 15%
#define AT_SAVEFIRE			16 	// Asbestos	 : Reduces fire damage by 15%

/*==========================================================================*/
/* TEAMFORTRESS CLASS DETAILS												*/
/*==========================================================================*/
// Class Details for SCOUT
#define PC_SCOUT_SKIN				4 		// Skin for this class when Classkin is on.
#define PC_SCOUT_MAXHEALTH			75 		// Maximum Health Level
#define PC_SCOUT_MAXSPEED			400		// Maximum movement speed
#define PC_SCOUT_MAXSTRAFESPEED		400		// Maximum strafing movement speed
#define PC_SCOUT_MAXARMOR			50 		// Maximum Armor Level, of any armor class
#define PC_SCOUT_INITARMOR			25 		// Armor level when respawned
#define PC_SCOUT_MAXARMORTYPE		0.3		// Maximum level of Armor absorption
#define PC_SCOUT_INITARMORTYPE		0.3		// Absorption Level of armor when respawned
#define PC_SCOUT_ARMORCLASSES		3 		// #AT_SAVESHOT | #AT_SAVENAIL   		<-Armor Classes allowed for this class
#define PC_SCOUT_INITARMORCLASS		0 		// Armorclass worn when respawned
#define PC_SCOUT_WEAPONS			WEAP_AXE | WEAP_SHOTGUN | WEAP_NAILGUN
#define PC_SCOUT_MAXAMMO_SHOT		50 		// Maximum amount of shot ammo this class can carry
#define PC_SCOUT_MAXAMMO_NAIL		200		// Maximum amount of nail ammo this class can carry
#define PC_SCOUT_MAXAMMO_CELL		100		// Maximum amount of cell ammo this class can carry
#define PC_SCOUT_MAXAMMO_ROCKET		25 		// Maximum amount of rocket ammo this class can carry
#define PC_SCOUT_INITAMMO_SHOT		25 		// Amount of shot ammo this class has when respawned
#define PC_SCOUT_INITAMMO_NAIL		100		// Amount of nail ammo this class has when respawned
#define PC_SCOUT_INITAMMO_CELL		50 		// Amount of cell ammo this class has when respawned
#define PC_SCOUT_INITAMMO_ROCKET	0 		// Amount of rocket ammo this class has when respawned
#define PC_SCOUT_GRENADE_TYPE_1		GR_TYPE_CALTROP			 //    <- 1st Type of Grenade this class has
#define PC_SCOUT_GRENADE_TYPE_2		GR_TYPE_CONCUSSION      //    <- 2nd Type of Grenade this class has
#define PC_SCOUT_GRENADE_INIT_1		2 		// Number of grenades of Type 1 this class has when respawned
#define PC_SCOUT_GRENADE_INIT_2		3 		// Number of grenades of Type 2 this class has when respawned
#define PC_SCOUT_TF_ITEMS			NIT_SCANNER  // <- TeamFortress Items this class has

#define PC_SCOUT_MOTION_MIN_I		0.5 	// < Short range
#define PC_SCOUT_MOTION_MIN_MOVE	50 		// Minimum vlen of player velocity to be picked up by motion detector
#define PC_SCOUT_SCAN_TIME			2		// # of seconds between each scan pulse
#define PC_SCOUT_SCAN_RANGE			100		// Default scanner range
#define PC_SCOUT_SCAN_COST			2		// Default scanner cell usage per scan

// Class Details for SNIPER
#define PC_SNIPER_SKIN				5 
#define PC_SNIPER_MAXHEALTH			90 
#define PC_SNIPER_MAXSPEED			300 		
#define PC_SNIPER_MAXSTRAFESPEED	300 
#define PC_SNIPER_MAXARMOR			50 
#define PC_SNIPER_INITARMOR			0 
#define PC_SNIPER_MAXARMORTYPE		0.3 
#define PC_SNIPER_INITARMORTYPE		0.3 
#define PC_SNIPER_ARMORCLASSES		3 		// #AT_SAVESHOT | #AT_SAVENAIL
#define PC_SNIPER_INITARMORCLASS	0 
#define PC_SNIPER_WEAPONS			WEAP_SNIPER_RIFLE | WEAP_AUTO_RIFLE | WEAP_AXE | WEAP_NAILGUN
#define PC_SNIPER_MAXAMMO_SHOT		75 
#define PC_SNIPER_MAXAMMO_NAIL		100 
#define PC_SNIPER_MAXAMMO_CELL		50 
#define PC_SNIPER_MAXAMMO_ROCKET	25 
#define PC_SNIPER_INITAMMO_SHOT		60 
#define PC_SNIPER_INITAMMO_NAIL		50 
#define PC_SNIPER_INITAMMO_CELL		0 
#define PC_SNIPER_INITAMMO_ROCKET	0 
#define PC_SNIPER_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_SNIPER_GRENADE_TYPE_2	GR_TYPE_NONE
#define PC_SNIPER_GRENADE_INIT_1	2 	 
#define PC_SNIPER_GRENADE_INIT_2	0
#define PC_SNIPER_TF_ITEMS			0 

// Class Details for SOLDIER
#define PC_SOLDIER_SKIN				6 			
#define PC_SOLDIER_MAXHEALTH		100	 
#define PC_SOLDIER_MAXSPEED			240 
#define PC_SOLDIER_MAXSTRAFESPEED	240 
#define PC_SOLDIER_MAXARMOR			200 
#define PC_SOLDIER_INITARMOR		100 
#define PC_SOLDIER_MAXARMORTYPE		0.8 
#define PC_SOLDIER_INITARMORTYPE	0.8 
#define PC_SOLDIER_ARMORCLASSES		31 		// ALL
#define PC_SOLDIER_INITARMORCLASS	0 
#define PC_SOLDIER_WEAPONS		 	WEAP_AXE | WEAP_SHOTGUN | WEAP_SUPER_SHOTGUN | WEAP_ROCKET_LAUNCHER
#define PC_SOLDIER_MAXAMMO_SHOT		100 
#define PC_SOLDIER_MAXAMMO_NAIL		100 
#define PC_SOLDIER_MAXAMMO_CELL		50 
#define PC_SOLDIER_MAXAMMO_ROCKET	50 
#define PC_SOLDIER_INITAMMO_SHOT	50 
#define PC_SOLDIER_INITAMMO_NAIL	0 
#define PC_SOLDIER_INITAMMO_CELL	0 
#define PC_SOLDIER_INITAMMO_ROCKET	10 
#define PC_SOLDIER_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_SOLDIER_GRENADE_TYPE_2	GR_TYPE_NAIL
#define PC_SOLDIER_GRENADE_INIT_1	2
#define PC_SOLDIER_GRENADE_INIT_2	1 	 
#define PC_SOLDIER_TF_ITEMS			0 

#define MAX_NAIL_GRENS				2	// Can only have 2 Nail grens active
#define MAX_NAPALM_GRENS			2	// Can only have 2 Napalm grens active
#define MAX_GAS_GRENS				2	// Can only have 2 Gas grenades active
#define MAX_MIRV_GRENS				2	// Can only have 2 Mirv's
#define MAX_CONCUSSION_GRENS		3
#define MAX_CALTROP_CANS			3

// Class Details for DEMOLITION MAN
#define PC_DEMOMAN_SKIN				1 
#define PC_DEMOMAN_MAXHEALTH		90 
#define PC_DEMOMAN_MAXSPEED			280 		
#define PC_DEMOMAN_MAXSTRAFESPEED	280 
#define PC_DEMOMAN_MAXARMOR			120 
#define PC_DEMOMAN_INITARMOR		50 
#define PC_DEMOMAN_MAXARMORTYPE		0.6 
#define PC_DEMOMAN_INITARMORTYPE	0.6 
#define PC_DEMOMAN_ARMORCLASSES		31 		// ALL
#define PC_DEMOMAN_INITARMORCLASS	0 		
#define PC_DEMOMAN_WEAPONS			WEAP_AXE | WEAP_SHOTGUN | WEAP_GRENADE_LAUNCHER | WEAP_DETPACK
#define PC_DEMOMAN_MAXAMMO_SHOT		75 
#define PC_DEMOMAN_MAXAMMO_NAIL		50 
#define PC_DEMOMAN_MAXAMMO_CELL		50 
#define PC_DEMOMAN_MAXAMMO_ROCKET	50 
#define PC_DEMOMAN_MAXAMMO_DETPACK	1 
#define PC_DEMOMAN_INITAMMO_SHOT	30 
#define PC_DEMOMAN_INITAMMO_NAIL	0 
#define PC_DEMOMAN_INITAMMO_CELL	0 
#define PC_DEMOMAN_INITAMMO_ROCKET	20 
#define PC_DEMOMAN_INITAMMO_DETPACK	1 
#define PC_DEMOMAN_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_DEMOMAN_GRENADE_TYPE_2	GR_TYPE_MIRV
#define PC_DEMOMAN_GRENADE_INIT_1	2
#define PC_DEMOMAN_GRENADE_INIT_2	2 	 
#define PC_DEMOMAN_TF_ITEMS			0 

// Class Details for COMBAT MEDIC
#define PC_MEDIC_SKIN				3 
#define PC_MEDIC_MAXHEALTH			90 
#define PC_MEDIC_MAXSPEED			320 
#define PC_MEDIC_MAXSTRAFESPEED		320 
#define PC_MEDIC_MAXARMOR			100
#define PC_MEDIC_INITARMOR			50 
#define PC_MEDIC_MAXARMORTYPE		0.6 
#define PC_MEDIC_INITARMORTYPE		0.3 
#define PC_MEDIC_ARMORCLASSES		11 		// ALL except EXPLOSION
#define PC_MEDIC_INITARMORCLASS		0 
#define PC_MEDIC_WEAPONS			WEAP_BIOWEAPON | WEAP_MEDIKIT | WEAP_SHOTGUN | WEAP_SUPER_SHOTGUN | WEAP_SUPER_NAILGUN
#define PC_MEDIC_MAXAMMO_SHOT		75 
#define PC_MEDIC_MAXAMMO_NAIL		150 
#define PC_MEDIC_MAXAMMO_CELL		50 
#define PC_MEDIC_MAXAMMO_ROCKET		25 
#define PC_MEDIC_MAXAMMO_MEDIKIT	100 
#define PC_MEDIC_INITAMMO_SHOT		50 
#define PC_MEDIC_INITAMMO_NAIL		50 
#define PC_MEDIC_INITAMMO_CELL		0 
#define PC_MEDIC_INITAMMO_ROCKET	0 
#define PC_MEDIC_INITAMMO_MEDIKIT	50 
#define PC_MEDIC_GRENADE_TYPE_1		GR_TYPE_NORMAL
#define PC_MEDIC_GRENADE_TYPE_2		GR_TYPE_CONCUSSION
#define PC_MEDIC_GRENADE_INIT_1		2
#define PC_MEDIC_GRENADE_INIT_2		2 	 
#define PC_MEDIC_TF_ITEMS			0 
#define PC_MEDIC_REGEN_TIME			3   // Number of seconds between each regen.
#define PC_MEDIC_REGEN_AMOUNT		2 	// Amount of health regenerated each regen.

// Class Details for HVYWEAP
#define PC_HVYWEAP_SKIN				2 
#define PC_HVYWEAP_MAXHEALTH		100 
#define PC_HVYWEAP_MAXSPEED			230		
#define PC_HVYWEAP_MAXSTRAFESPEED	230
#define PC_HVYWEAP_MAXARMOR			300 
#define PC_HVYWEAP_INITARMOR		150 
#define PC_HVYWEAP_MAXARMORTYPE		0.8 
#define PC_HVYWEAP_INITARMORTYPE	0.8 
#define PC_HVYWEAP_ARMORCLASSES		31 			// ALL
#define PC_HVYWEAP_INITARMORCLASS	0 		
#define PC_HVYWEAP_WEAPONS			WEAP_ASSAULT_CANNON | WEAP_AXE | WEAP_SHOTGUN | WEAP_SUPER_SHOTGUN
#define PC_HVYWEAP_MAXAMMO_SHOT		200 
#define PC_HVYWEAP_MAXAMMO_NAIL		200 
#define PC_HVYWEAP_MAXAMMO_CELL		50 
#define PC_HVYWEAP_MAXAMMO_ROCKET	25 
#define PC_HVYWEAP_INITAMMO_SHOT	200 
#define PC_HVYWEAP_INITAMMO_NAIL	0 
#define PC_HVYWEAP_INITAMMO_CELL	30 
#define PC_HVYWEAP_INITAMMO_ROCKET	0 
#define PC_HVYWEAP_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_HVYWEAP_GRENADE_TYPE_2	GR_TYPE_MIRV
#define PC_HVYWEAP_GRENADE_INIT_1	2
#define PC_HVYWEAP_GRENADE_INIT_2	1 	 
#define PC_HVYWEAP_TF_ITEMS			0 
#define PC_HVYWEAP_CELL_USAGE		7	// Amount of cells spent to power up assault cannon



// Class Details for PYRO
#define PC_PYRO_SKIN			21 
#define PC_PYRO_MAXHEALTH		100 
#define PC_PYRO_MAXSPEED		300 
#define PC_PYRO_MAXSTRAFESPEED	300
#define PC_PYRO_MAXARMOR		150 
#define PC_PYRO_INITARMOR		50 
#define PC_PYRO_MAXARMORTYPE	0.6 
#define PC_PYRO_INITARMORTYPE	0.6 
#define PC_PYRO_ARMORCLASSES	27 		// ALL except EXPLOSION
#define PC_PYRO_INITARMORCLASS	16  	// #AT_SAVEFIRE
#define PC_PYRO_WEAPONS			WEAP_INCENDIARY | WEAP_FLAMETHROWER | WEAP_AXE | WEAP_SHOTGUN
#define PC_PYRO_MAXAMMO_SHOT	40 
#define PC_PYRO_MAXAMMO_NAIL	50 
#define PC_PYRO_MAXAMMO_CELL	200 
#define PC_PYRO_MAXAMMO_ROCKET	20 
#define PC_PYRO_INITAMMO_SHOT	20 
#define PC_PYRO_INITAMMO_NAIL	0 
#define PC_PYRO_INITAMMO_CELL	120 
#define PC_PYRO_INITAMMO_ROCKET	5 
#define PC_PYRO_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_PYRO_GRENADE_TYPE_2	GR_TYPE_NAPALM
#define PC_PYRO_GRENADE_INIT_1	2
#define PC_PYRO_GRENADE_INIT_2	4 	 
#define PC_PYRO_TF_ITEMS		0
#define PC_PYRO_ROCKET_USAGE	3	// Number of rockets per incendiary cannon shot

// Class Details for SPY
#define PC_SPY_SKIN				22 
#define PC_SPY_MAXHEALTH		90 
#define PC_SPY_MAXSPEED			300 
#define PC_SPY_MAXSTRAFESPEED	300 
#define PC_SPY_MAXARMOR			100 
#define PC_SPY_INITARMOR		25 
#define PC_SPY_MAXARMORTYPE		0.6		// Was 0.3 
#define PC_SPY_INITARMORTYPE	0.6		// Was 0.3
#define PC_SPY_ARMORCLASSES		27 		// ALL except EXPLOSION
#define PC_SPY_INITARMORCLASS	0  
#define PC_SPY_WEAPONS			WEAP_AXE | WEAP_TRANQ | WEAP_SUPER_SHOTGUN | WEAP_NAILGUN
#define PC_SPY_MAXAMMO_SHOT		40 
#define PC_SPY_MAXAMMO_NAIL		100 
#define PC_SPY_MAXAMMO_CELL		30 
#define PC_SPY_MAXAMMO_ROCKET	15 
#define PC_SPY_INITAMMO_SHOT	40 
#define PC_SPY_INITAMMO_NAIL	50 
#define PC_SPY_INITAMMO_CELL	10 
#define PC_SPY_INITAMMO_ROCKET	0 
#define PC_SPY_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_SPY_GRENADE_TYPE_2	GR_TYPE_GAS
#define PC_SPY_GRENADE_INIT_1	2 	 
#define PC_SPY_GRENADE_INIT_2	2 	 
#define PC_SPY_TF_ITEMS			0 
#define PC_SPY_CELL_REGEN_TIME		5	
#define PC_SPY_CELL_REGEN_AMOUNT	1
#define PC_SPY_CELL_USAGE			3	// Amount of cells spent while invisible
#define PC_SPY_GO_UNDERCOVER_TIME	4	// Time it takes to go undercover

// Class Details for ENGINEER
#define PC_ENGINEER_SKIN			22 		// Not used anymore
#define PC_ENGINEER_MAXHEALTH		80 
#define PC_ENGINEER_MAXSPEED		300 
#define PC_ENGINEER_MAXSTRAFESPEED	300
#define PC_ENGINEER_MAXARMOR		50
#define PC_ENGINEER_INITARMOR		25 
#define PC_ENGINEER_MAXARMORTYPE	0.6 
#define PC_ENGINEER_INITARMORTYPE	0.3 
#define PC_ENGINEER_ARMORCLASSES	31 		// ALL
#define PC_ENGINEER_INITARMORCLASS	0  
#define PC_ENGINEER_WEAPONS			WEAP_SPANNER | WEAP_LASER | WEAP_SUPER_SHOTGUN
#define PC_ENGINEER_MAXAMMO_SHOT	50
#define PC_ENGINEER_MAXAMMO_NAIL	50 
#define PC_ENGINEER_MAXAMMO_CELL	200		// synonymous with metal 
#define PC_ENGINEER_MAXAMMO_ROCKET	30 
#define PC_ENGINEER_INITAMMO_SHOT	20 
#define PC_ENGINEER_INITAMMO_NAIL	25 
#define PC_ENGINEER_INITAMMO_CELL	100 	// synonymous with metal 
#define PC_ENGINEER_INITAMMO_ROCKET	0 
#define PC_ENGINEER_GRENADE_TYPE_1	GR_TYPE_NORMAL
#define PC_ENGINEER_GRENADE_TYPE_2	GR_TYPE_EMP
#define PC_ENGINEER_GRENADE_INIT_1	2 	 
#define PC_ENGINEER_GRENADE_INIT_2	2 	 
#define PC_ENGINEER_TF_ITEMS		0 

// Class Details for CIVILIAN
#define PC_CIVILIAN_SKIN			22 
#define PC_CIVILIAN_MAXHEALTH		50
#define PC_CIVILIAN_MAXSPEED		240
#define PC_CIVILIAN_MAXSTRAFESPEED	240
#define PC_CIVILIAN_MAXARMOR		0
#define PC_CIVILIAN_INITARMOR		0 
#define PC_CIVILIAN_MAXARMORTYPE	0
#define PC_CIVILIAN_INITARMORTYPE	0 
#define PC_CIVILIAN_ARMORCLASSES	0 		
#define PC_CIVILIAN_INITARMORCLASS	0
#define PC_CIVILIAN_WEAPONS			WEAP_AXE
#define PC_CIVILIAN_MAXAMMO_SHOT	0
#define PC_CIVILIAN_MAXAMMO_NAIL	0 
#define PC_CIVILIAN_MAXAMMO_CELL	0 
#define PC_CIVILIAN_MAXAMMO_ROCKET	0 
#define PC_CIVILIAN_INITAMMO_SHOT	0 
#define PC_CIVILIAN_INITAMMO_NAIL	0 
#define PC_CIVILIAN_INITAMMO_CELL	0 
#define PC_CIVILIAN_INITAMMO_ROCKET	0 
#define PC_CIVILIAN_GRENADE_TYPE_1	0
#define PC_CIVILIAN_GRENADE_TYPE_2	0
#define PC_CIVILIAN_GRENADE_INIT_1	0 	 
#define PC_CIVILIAN_GRENADE_INIT_2	0 	 
#define PC_CIVILIAN_TF_ITEMS		0 


/*==========================================================================*/
/* TEAMFORTRESS GOALS														*/
/*==========================================================================*/
// For all these defines, see the tfortmap.txt that came with the zip
// for complete descriptions.
// Defines for Goal Activation types : goal_activation (in goals)
#define TFGA_TOUCH			1  // Activated when touched
#define TFGA_TOUCH_DETPACK	2  // Activated when touched by a detpack explosion
#define TFGA_REVERSE_AP		4  // Activated when AP details are _not_ met
#define TFGA_SPANNER		8  // Activated when hit by an engineer's spanner
#define TFGA_DROPTOGROUND	2048 // Drop to Ground when spawning

// Defines for Goal Effects types : goal_effect
#define TFGE_AP				  1  // AP is affected. Default.
#define TFGE_AP_TEAM		  2  // All of the AP's team.
#define TFGE_NOT_AP_TEAM	  4  // All except AP's team.
#define TFGE_NOT_AP			  8  // All except AP.
#define TFGE_WALL			  16 // If set, walls stop the Radius effects
#define TFGE_SAME_ENVIRONMENT 32 // If set, players in a different environment to the Goal are not affected
#define TFGE_TIMER_CHECK_AP	  64 // If set, Timer Goals check their critera for all players fitting their effects

// Defines for Goal Result types : goal_result
#define TFGR_SINGLE				1  // Goal can only be activated once
#define TFGR_ADD_BONUSES		2 	// Any Goals activated by this one give their bonuses
#define TFGR_ENDGAME			4 	// Goal fires Intermission, displays scores, and ends level
#define TFGR_NO_ITEM_RESULTS	8	// GoalItems given by this Goal don't do results
#define TFGR_REMOVE_DISGUISE	16 // Prevent/Remove undercover from any Spy
#define TFGR_FORCE_RESPAWN		32 // Forces the player to teleport to a respawn point
#define TFGR_DESTROY_BUILDINGS	64 // Destroys this player's buildings, if anys

// Defines for Goal Group Result types : goal_group
// None!
// But I'm leaving this variable in there, since it's fairly likely
// that some will show up sometime.

// Defines for Goal Item types, : goal_activation (in items)
#define TFGI_GLOW			1   // Players carrying this GoalItem will glow
#define TFGI_SLOW			2   // Players carrying this GoalItem will move at half-speed
#define TFGI_DROP			4   // Players dying with this item will drop it
#define TFGI_RETURN_DROP	8   // Return if a player with it dies
#define TFGI_RETURN_GOAL	16  // Return if a player with it has it removed by a goal's activation
#define TFGI_RETURN_REMOVE	32  // Return if it is removed by TFGI_REMOVE
#define TFGI_REVERSE_AP		64  // Only pickup if the player _doesn't_ match AP Details
#define TFGI_REMOVE			128 // Remove if left untouched for 2 minutes after being dropped
#define TFGI_KEEP			256 // Players keep this item even when they die
#define TFGI_ITEMGLOWS		512	// Item glows when on the ground
#define TFGI_DONTREMOVERES	1024 // Don't remove results when the item is removed
#define TFGI_DROPTOGROUND	2048 // Drop To Ground when spawning
#define TFGI_CANBEDROPPED	4096 // Can be voluntarily dropped by players
#define TFGI_SOLID			8192 // Is solid... blocks bullets, etc

// Defines for methods of GoalItem returning
#define GI_RET_DROP_DEAD 	0		// Dropped by a dead player
#define GI_RET_DROP_LIVING 	1		// Dropped by a living player
#define GI_RET_GOAL			2		// Returned by a Goal
#define GI_RET_TIME			3		// Returned due to timeout

// Defines for TeamSpawnpoints : goal_activation (in teamspawns)
#define TFSP_MULTIPLEITEMS	1  // Give out the GoalItem multiple times
#define TFSP_MULTIPLEMSGS	2  // Display the message multiple times

// Defines for TeamSpawnpoints : goal_effects (in teamspawns)
#define TFSP_REMOVESELF		1  // Remove itself after being spawned on

// Defines for Goal States
#define TFGS_ACTIVE		1 
#define TFGS_INACTIVE	2 
#define TFGS_REMOVED	3 
#define TFGS_DELAYED	4

// Defines for GoalItem Removing from Player Methods
#define GI_DROP_PLAYERDEATH	  0		// Dropped by a dying player
#define GI_DROP_REMOVEGOAL	  1		// Removed by a Goal
#define GI_DROP_PLAYERDROP	  2		// Dropped by a player

// Legal Playerclass Handling
#define TF_ILL_SCOUT 		1
#define TF_ILL_SNIPER		2
#define TF_ILL_SOLDIER		4
#define TF_ILL_DEMOMAN		8
#define TF_ILL_MEDIC		16
#define TF_ILL_HVYWEP		32
#define TF_ILL_PYRO			64
#define TF_ILL_RANDOMPC		128
#define TF_ILL_SPY			256
#define TF_ILL_ENGINEER		512

// Addition classes
#define CLASS_TFGOAL					128
#define CLASS_TFGOAL_TIMER			129
#define CLASS_TFGOAL_ITEM			130
#define CLASS_TFSPAWN				   131

/*==========================================================================*/
/* Flamethrower																*/
/*==========================================================================*/
#define FLAME_PLYRMAXTIME	5.0 // lifetime in seconds of a flame on a player
#define FLAME_MAXBURNTIME	8  	// lifetime in seconds of a flame on the world (big ones)
#define NAPALM_MAXBURNTIME	20 	// lifetime in seconds of flame from a napalm grenade
#define FLAME_MAXPLYRFLAMES	4 	// maximum number of flames on a player
#define FLAME_NUMLIGHTS		1 	// maximum number of light flame 
#define FLAME_BURNRATIO		0.3 // the chance of a flame not 'sticking'
#define GR_TYPE_FLAMES_NO	15 	// number of flames spawned when a grenade explode
#define FLAME_DAMAGE_TIME	1	// Interval between damage burns from flames
#define FLAME_EFFECT_TIME	0.2	// frequency at which we display flame effects.
#define FLAME_THINK_TIME	0.1	// Seconds between times the flame checks burn
#define PER_FLAME_DAMAGE	2	// Damage taken per second per flame by burning players

/*==================================================*/
/* CTF Support defines 								*/
/*==================================================*/
#define CTF_FLAG1 		1
#define CTF_FLAG2 		2
#define CTF_DROPOFF1 	3
#define CTF_DROPOFF2 	4
#define CTF_SCORE1   	5
#define CTF_SCORE2   	6

//.float	hook_out;

/*==================================================*/
/* Camera defines	 								*/
/*==================================================*/
/*
float live_camera;
.float camdist;
.vector camangle;
.entity camera_list;
*/

/*==================================================*/
/* QuakeWorld defines 								*/
/*==================================================*/
/*
float already_chosen_map;

// grappling hook variables
.entity	hook;	
.float	on_hook;
.float  fire_held_down;// flag - TRUE if player is still holding down the
                       // fire button after throwing a hook.
*/
/*==================================================*/
/* Server Settings								    */
/*==================================================*/
// Admin modes
#define ADMIN_MODE_NONE	0
#define ADMIN_MODE_DEAL	1

/*==================================================*/
/* Death Message defines							*/
/*==================================================*/
#define DMSG_SHOTGUN			1
#define DMSG_SSHOTGUN			2
#define DMSG_NAILGUN			3
#define DMSG_SNAILGUN			4
#define DMSG_GRENADEL			5
#define DMSG_ROCKETL			6
#define DMSG_LIGHTNING			7
#define DMSG_GREN_HAND			8
#define DMSG_GREN_NAIL			9
#define DMSG_GREN_MIRV			10
#define DMSG_GREN_PIPE			11
#define DMSG_DETPACK			12
#define DMSG_BIOWEAPON			13
#define DMSG_BIOWEAPON_ATT		14
#define DMSG_FLAME				15
#define DMSG_DETPACK_DIS		16
#define DMSG_AXE				17
#define DMSG_SNIPERRIFLE		18
#define DMSG_AUTORIFLE			19
#define DMSG_ASSAULTCANNON		20
#define DMSG_HOOK				21
#define DMSG_BACKSTAB			22
#define DMSG_MEDIKIT			23
#define DMSG_GREN_GAS			24
#define DMSG_TRANQ				25
#define DMSG_LASERBOLT			26
#define DMSG_SENTRYGUN_BULLET 	27
#define DMSG_SNIPERLEGSHOT		28
#define DMSG_SNIPERHEADSHOT		29
#define DMSG_GREN_EMP			30
#define DMSG_GREN_EMP_AMMO		31
#define DMSG_SPANNER			32
#define DMSG_INCENDIARY			33
#define DMSG_SENTRYGUN_ROCKET	34
#define DMSG_GREN_FLASH			35
#define DMSG_TRIGGER			36
#define DMSG_MIRROR				37
#define DMSG_SENTRYDEATH		38
#define DMSG_DISPENSERDEATH		39
#define DMSG_GREN_AIRPIPE		40
#define DMSG_CALTROP			41

/*==================================================*/
// TOGGLEFLAGS
/*==================================================*/
// Some of the toggleflags aren't used anymore, but the bits are still
// there to provide compatibility with old maps
#define TFLAG_CLASS_PERSIST			(1 << 0)  		// Persistent Classes Bit
#define TFLAG_CHEATCHECK			(1 << 1) 		// Cheatchecking Bit
#define TFLAG_RESPAWNDELAY			(1 << 2) 		// RespawnDelay bit
//#define TFLAG_UN					(1 << 3)		// NOT USED ANYMORE
#define TFLAG_OLD_GRENS				(1 << 3)		// Use old concussion grenade and flash grenade
#define TFLAG_UN2					(1 << 4)		// NOT USED ANYMORE
#define TFLAG_UN3					(1 << 5)		// NOT USED ANYMORE
#define TFLAG_UN4					(1 << 6)		// NOT USED ANYMORE: Was Autoteam. CVAR tfc_autoteam used now.
#define TFLAG_TEAMFRAGS				(1 << 7)		// Individual Frags, or Frags = TeamScore
#define TFLAG_FIRSTENTRY			(1 << 8)		// Used to determine the first time toggleflags is set
													// In a map. Cannot be toggled by players.
#define TFLAG_SPYINVIS				(1 << 9)		// Spy invisible only
#define TFLAG_GRAPPLE				(1 << 10)	// Grapple on/off
//#define TFLAG_FULLTEAMSCORE		(1 << 11)  	// Each Team's score is TeamScore + Frags
#define TFLAG_FLAGEMULATION			(1 << 12)  	// Flag emulation on for old TF maps
#define TFLAG_USE_STANDARD			(1 << 13)  	// Use the TF War standard for Flag emulation

#define TFLAG_FRAGSCORING			(1 << 14)	// Use frag scoring only

/*======================*/
//      Menu stuff      //
/*======================*/

#define MENU_DEFAULT				1
#define MENU_TEAM 					2
#define MENU_CLASS 					3
#define MENU_MAPBRIEFING			4
#define MENU_INTRO 					5
#define MENU_CLASSHELP				6
#define MENU_CLASSHELP2 			7
#define MENU_REPEATHELP 			8

#define MENU_SPECHELP				9


#define MENU_SPY					12
#define MENU_SPY_SKIN				13
#define MENU_SPY_COLOR				14
#define MENU_ENGINEER				15
#define MENU_ENGINEER_FIX_DISPENSER	16
#define MENU_ENGINEER_FIX_SENTRYGUN	17
#define MENU_ENGINEER_FIX_MORTAR	18
#define MENU_DISPENSER				19
#define MENU_CLASS_CHANGE			20
#define MENU_TEAM_CHANGE			21

#define MENU_REFRESH_RATE 			25

#define MENU_VOICETWEAK				50

//============================
// Timer Types
#define TF_TIMER_ANY				0
#define TF_TIMER_CONCUSSION			1
#define TF_TIMER_INFECTION			2
#define TF_TIMER_HALLUCINATION		3
#define TF_TIMER_TRANQUILISATION	4
#define TF_TIMER_ROTHEALTH			5
#define TF_TIMER_REGENERATION		6
#define TF_TIMER_GRENPRIME			7
#define TF_TIMER_CELLREGENERATION	8
#define TF_TIMER_DETPACKSET			9
#define TF_TIMER_DETPACKDISARM		10
#define TF_TIMER_BUILD				11
#define TF_TIMER_CHECKBUILDDISTANCE 12
#define TF_TIMER_DISGUISE			13
#define TF_TIMER_DISPENSERREFILL	14

// Non Player timers
#define TF_TIMER_RETURNITEM			100
#define TF_TIMER_DELAYEDGOAL		101
#define TF_TIMER_ENDROUND			102

//============================
// Teamscore printing
#define TS_PRINT_SHORT				1
#define TS_PRINT_LONG				2
#define TS_PRINT_LONG_TO_ALL		3

#ifndef TF_DEFS_ONLY

typedef struct
{
	int topColor;
	int bottomColor;
} team_color_t;


/*==================================================*/
/* GLOBAL VARIABLES									*/
/*==================================================*/
// FortressMap stuff
extern float number_of_teams;	// number of teams supported by the map
extern int   illegalclasses[5];	// Illegal playerclasses for all teams
extern int   civilianteams;		// Bitfield holding Civilian teams
extern Vector  rgbcolors[5];		 // RGB colors for each of the 4 teams

extern team_color_t teamcolors[5][PC_LASTCLASS]; // Colors for each of the 4 teams

extern int   teamscores[5];		// Goal Score of each team
extern int	 g_iOrderedTeams[5]; // Teams ordered into order of winners->losers
extern int	 teamfrags[5];		// Total Frags for each team
extern int   teamlives[5];		// Number of lives each team's players have
extern int   teammaxplayers[5];	// Max number of players allowed in each team
extern float teamadvantage[5];	// only used if the teamplay equalisation bits are set
								// stores the damage ratio players take/give
extern int   teamallies[5];		// Keeps track of which teams are allied
extern string_t	team_names[5];

extern BOOL  CTF_Map;
extern BOOL  birthday;
extern BOOL  christmas;

extern float num_world_flames;

// Clan Battle stuff
extern float clan_scores_dumped;
extern float cb_prematch_time;
extern float fOldPrematch;
extern float fOldCeaseFire;
extern float cb_ceasefire_time;
extern float last_id;
extern float spy_off;
extern float old_grens;		
extern float flagem_checked;
extern float flNextEqualisationCalc;
extern BOOL  cease_fire;
extern BOOL  no_cease_fire_text;
extern BOOL  initial_cease_fire;
extern BOOL  last_cease_fire;
// Autokick stuff
extern float autokick_kills;

extern float deathmsg;		// Global, which is set before every T_Damage, to indicate
							// the death message that should be used.

extern char *sTeamSpawnNames[];
extern char *sClassNames[];
extern char *sNewClassModelFiles[];
extern char *sOldClassModelFiles[];
extern char *sClassModels[];
extern char *sClassCfgs[];
extern char *sGrenadeNames[];
extern string_t	team_menu_string;	

extern int toggleflags;					// toggleable flags

extern CBaseEntity* g_pLastSpawns[5];
extern BOOL g_bFirstClient;

extern float g_fNextPrematchAlert;

typedef struct
{
	int			ip;
	edict_t	*pEdict;
} ip_storage_t;

extern ip_storage_t g_IpStorage[32];

class CGhost;
/*==========================================================================*/
BOOL ClassIsRestricted(float tno, int pc);
char* GetTeamName(int tno);
int TeamFortress_GetNoPlayers();
void DestroyBuilding(CBaseEntity *eng, char *bld);
void teamsprint( int tno, CBaseEntity *ignore, int msg_dest, const char *st, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL );
float anglemod( float v );

// Team Funcs
BOOL TeamFortress_TeamIsCivilian(float tno);
void TeamFortress_TeamShowScores(BOOL bLong, CBasePlayer *pPlayer);
BOOL TeamFortress_TeamPutPlayerInTeam();
void TeamFortress_TeamSetColor(int tno);
void TeamFortress_TeamIncreaseScore(int tno, int scoretoadd);
int TeamFortress_TeamGetScoreFrags(int tno);
int TeamFortress_TeamGetNoPlayers(int tno);
float TeamEqualiseDamage(CBaseEntity *targ, CBaseEntity *attacker, float damage);
BOOL IsSpawnPointValid( Vector &pos );
BOOL TeamFortress_SortTeams( void );
void DumpClanScores( void );
void CalculateTeamEqualiser();

// mapscript funcs
void ParseTFServerSettings();
void ParseTFMapSettings();
CBaseEntity* Finditem(int ino);
CBaseEntity* Findgoal(int gno);
CBaseEntity* Findteamspawn(int gno);
void RemoveGoal(CBaseEntity *Goal);
void tfgoalitem_GiveToPlayer(CBaseEntity *Item, CBasePlayer *AP, CBaseEntity *Goal);
void dremove( CBaseEntity *te );
void tfgoalitem_RemoveFromPlayer(CBaseEntity *Item, CBasePlayer *AP, int iMethod);
void tfgoalitem_drop(CBaseEntity *Item, BOOL PAlive, CBasePlayer *P);
void DisplayItemStatus(CBaseEntity *Goal, CBasePlayer *Player, CBaseEntity *Item);
void tfgoalitem_checkgoalreturn(CBaseEntity *Item);
void DoGoalWork(CBaseEntity *Goal, CBasePlayer *AP);
void DoResults(CBaseEntity *Goal, CBasePlayer *AP, BOOL bAddBonuses);
void DoGroupWork(CBaseEntity *Goal, CBasePlayer *AP);
// hooks into the mapscript for all entities
BOOL ActivateDoResults(CBaseEntity *Goal, CBasePlayer *AP, CBaseEntity *ActivatingGoal);
BOOL ActivationSucceeded(CBaseEntity *Goal, CBasePlayer *AP, CBaseEntity *ActivatingGoal);

// prematch & ceasefire
void Display_Prematch();
void Check_Ceasefire();

// admin
void KickPlayer( CBaseEntity *pTarget );
void BanPlayer( CBaseEntity *pTarget );
CGhost *FindGhost( int iGhostID );
int GetBattleID( edict_t *pEntity );

extern cvar_t	tfc_spam_penalty1;// the initial gag penalty for a spammer (seconds)
extern cvar_t	tfc_spam_penalty2;// incremental gag penalty (seconds) for each time gagged spammer continues to speak.
extern cvar_t	tfc_spam_limit; // at this many points, gag the spammer
extern cvar_t	tfc_clanbattle, tfc_clanbattle_prematch, tfc_prematch, tfc_clanbattle_ceasefire, tfc_balance_teams, tfc_balance_scores;
extern cvar_t   tfc_clanbattle_locked, tfc_birthday, tfc_autokick_kills, tfc_fragscoring, tfc_autokick_time, tfc_adminpwd;
extern cvar_t	weaponstay, footsteps, flashlight, aimcrosshair, falldamage, teamplay;
extern cvar_t	allow_spectators;

/*==========================================================================*/
class CTFFlame : public CBaseMonster
{
public:
	void	Spawn( void );
	void	Precache( void );
	void	EXPORT FlameThink( void );
	static  CTFFlame *FlameSpawn( CBaseEntity *pOwner, CBaseEntity *pTarget );
	void	FlameDestroy( void );

	float	m_flNextDamageTime;
};

/*==========================================================================*/
// MAPSCRIPT CLASSES
class CTFGoal : public CBaseAnimating
{
public:
	void	Spawn( void );
	void	StartGoal( void );
	void	EXPORT PlaceGoal( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int		Classify ( void ) { return	CLASS_TFGOAL; }

	void	SetObjectCollisionBox( void );
};
 
class CTFGoalItem : public CTFGoal
{
public:
	void	Spawn( void );
	void	StartItem( void );
	void	EXPORT PlaceItem( void );
	int		Classify ( void ) { return	CLASS_TFGOAL_ITEM; }

	float	m_flDroppedAt;
};

class CTFTimerGoal : public CTFGoal
{
public:
	void	Spawn( void );
	int		Classify ( void ) { return	CLASS_TFGOAL_TIMER; }
};

class CTFSpawn : public CBaseEntity
{
public:
	void	Spawn( void );
	void	Activate( void );
	int		Classify ( void ) { return	CLASS_TFSPAWN; }
	BOOL	CheckTeam( int iTeamNo );

	EHANDLE m_pTeamCheck;
};

class CTFDetect : public CBaseEntity
{
public:
	void	Spawn( void );
	int		Classify ( void ) { return	CLASS_TFGOAL; }
};

class CTelefragDeath : public CBaseEntity
{
public:
	void		Spawn( void );
	void		EXPORT	DeathTouch( CBaseEntity *pOther );
};

class CTeamCheck : public CBaseDelay
{
public:
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	BOOL TeamMatches( int iTeam );
};

class CTeamSet : public CBaseDelay
{
public:
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};

#endif // TF_DEFS_ONLY
#endif // __TF_DEFS_H



```

`cl_dll/include/unicode_strtools.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once
#ifndef UNICODE_STR_TOOLS_H
#define UNICODE_STR_TOOLS_H


#ifdef _WIN32

typedef wchar_t uchar16;
typedef unsigned int uchar32;

#else

typedef unsigned short uchar16;
typedef unsigned int uchar32;

#endif // _WIN32

enum EStringConvertErrorPolicy
{
	_STRINGCONVERTFLAG_SKIP = 1,
	_STRINGCONVERTFLAG_FAIL = 2,
	_STRINGCONVERTFLAG_ASSERT = 4,

	STRINGCONVERT_REPLACE = 0,
	STRINGCONVERT_SKIP = 1,
	STRINGCONVERT_FAIL = 2,

	STRINGCONVERT_ASSERT_REPLACE = 4,
	STRINGCONVERT_ASSERT_SKIP = 5,
	STRINGCONVERT_ASSERT_FAIL = 6,
};

bool Q_IsValidUChar32(uchar32 uVal);
int Q_UTF32ToUChar32(const uchar32 *pUTF32, uchar32 &uVal, bool &bErr);
int Q_UChar32ToUTF32Len(uchar32 uVal);
int Q_UChar32ToUTF32(uchar32 uVal, uchar32 *pUTF32);
int Q_UChar32ToUTF8Len(uchar32 uVal);
int Q_UChar32ToUTF16Len(uchar32 uVal);
int Q_UChar32ToUTF16(uchar32 uVal, uchar16 *pUTF16Out);
int Q_UChar32ToUTF8(uchar32 uVal, char *pUTF8Out);
int Q_UTF16ToUChar32(const uchar16 *pUTF16, uchar32 &uValueOut, bool &bErrorOut);
int Q_UTF8ToUTF16(const char *pUTF8, uchar16 *pUTF16, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF8ToUTF32(const char *pUTF8, uchar32 *pUTF32, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF16ToUTF8(const uchar16 *pUTF16, char *pUTF8, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF16ToUTF32(const uchar16 *pUTF16, uchar32 *pUTF32, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF32ToUTF8(const uchar32 *pUTF32, char *pUTF8, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF32ToUTF16(const uchar32 *pUTF32, uchar16 *pUTF16, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy);
int Q_UTF8ToUChar32(const char *pUTF8_, uchar32 &uValueOut, bool &bErrorOut);
qboolean Q_UnicodeValidate(const char *pUTF8);
int Q_UnicodeLength(const char *pUTF8);
char *Q_UnicodeAdvance(char *pUTF8, int nChars);
//bool Q_IsMeanSpaceW(uchar16 wch);
bool Q_IsDeprecatedW(uchar16 wch);
uchar16 *StripUnprintableWorker(uchar16 *pwch, bool *pbStrippedAny);
qboolean Q_StripUnprintableAndSpace(char *pch);
qboolean V_UTF8ToUChar32(const char *pUTF8_, uchar32 *uValueOut);
int Q_UnicodeRepair(char *pUTF8);
wchar_t *Q_AdvanceSpace (wchar_t *start);
wchar_t *Q_ReadUToken (wchar_t *start, wchar_t *token, int tokenBufferSize, bool &quoted);

#endif // UNICODE_STR_TOOLS_H

```

`cl_dll/include/util_vector.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//  Vector.h
// A subset of the extdll.h in the project HL Entity DLL
//
#pragma once
// Misc C-runtime library headers
#include "stdio.h"
#include "stdlib.h"
#include "math.h"

float rsqrt( float x );

// Header file containing definition of globalvars_t and entvars_t
typedef int	func_t;					//
typedef int	string_t;				// from engine's pr_comp.h;
typedef float vec_t;				// needed before including progdefs.h

//=========================================================
// 2DVector - used for many pathfinding and many other 
// operations that are treated as planar rather than 3d.
//=========================================================
class Vector2D
{
public:
	inline Vector2D(void)									{ }
	inline Vector2D(float X, float Y)						{ x = X; y = Y; }
	inline Vector2D operator+(const Vector2D& v)	const	{ return Vector2D(x+v.x, y+v.y);	}
	inline Vector2D operator-(const Vector2D& v)	const	{ return Vector2D(x-v.x, y-v.y);	}
	inline Vector2D operator*(float fl)				const	{ return Vector2D(x*fl, y*fl);	}
	inline Vector2D operator/(float fl)				const	{ return Vector2D(x/fl, y/fl);	}
	
	inline float Length(void)						const	{ return (float)sqrt(x*x + y*y );		}

	inline Vector2D Normalize ( void ) const
	{
		float flLen = rsqrt( x * x + y * y );
		if ( flLen == 0 ) return Vector2D( 0.0f, 0.0f );
		else return Vector2D( x * flLen, y * flLen );
	}

	vec_t	x, y;
};

inline float DotProduct(const Vector2D& a, const Vector2D& b) { return( a.x*b.x + a.y*b.y ); }
inline Vector2D operator*(float fl, const Vector2D& v)	{ return v * fl; }

//=========================================================
// 3D Vector
//=========================================================
class Vector						// same data-layout as engine's vec3_t,
{								//		which is a vec_t[3]
public:
	// Construction/destruction
	inline Vector(void)								{ }
	inline Vector(float X, float Y, float Z)		{ x = X; y = Y; z = Z;						}
	inline Vector(double X, double Y, double Z)		{ x = (float)X; y = (float)Y; z = (float)Z;	}
	inline Vector(int X, int Y, int Z)				{ x = (float)X; y = (float)Y; z = (float)Z;	}
	inline Vector(const Vector& v)					{ x = v.x; y = v.y; z = v.z;				} 
	inline Vector(float rgfl[3])					{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];	}

	// Operators
	inline Vector operator-(void) const				{ return Vector(-x,-y,-z);				}
	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	}
	inline int operator!=(const Vector& v) const	{ return !(*this==v);					}
	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	}
	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	}
	inline Vector operator*(float fl) const			{ return Vector(x*fl, y*fl, z*fl);		}
	inline Vector operator/(float fl) const			{ return Vector(x/fl, y/fl, z/fl);		}
	
	// Methods
	inline void CopyToArray(float* rgfl) const		{ rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; }
	inline float Length(void) const					{ return (float)sqrt(x*x + y*y + z*z); }
	operator float *()								{ return &x; } // Vectors will now automatically convert to float * when needed
	operator const float *() const					{ return &x; } // Vectors will now automatically convert to float * when needed
	inline Vector Normalize(void) const
	{
		/*float flLen = Length();
		if (flLen == 0) return Vector(0,0,1); // ????
		flLen = 1 / flLen;*/

		float flLen = rsqrt( x * x + y * y + z * z );
		if( flLen == 0.0f ) return Vector( 0, 0, 1 ); // ????
		return Vector(x * flLen, y * flLen, z * flLen);
	}

	inline Vector2D Make2D ( void ) const
	{
		Vector2D	Vec2;

		Vec2.x = x;
		Vec2.y = y;

		return Vec2;
	}
	inline float Length2D(void) const					{ return (float)sqrt(x*x + y*y); }
	inline bool IsNull(void) const { return !x && !y && !z; }

	// Members
	vec_t x, y, z;
};
inline Vector operator*(float fl, const Vector& v)	{ return v * fl; }
inline float DotProduct(const Vector& a, const Vector& b) { return(a.x*b.x+a.y*b.y+a.z*b.z); }
inline Vector CrossProduct(const Vector& a, const Vector& b) { return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }

#define vec3_t Vector

```

`cl_dll/include/vgui_parser.h`:

```h
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#pragma once
#ifndef VGUI_PARSER_H
#define VGUI_PARSER_H

#define MAX_TOLOCALIZE_STRING_SIZE 256
#define MAX_LOCALIZEDSTRING_SIZE 2048

void Localize_Init( );
void Localize_Free( );

const char* Localize( const char* string );
void StripEndNewlineFromString( char *str );
#endif

```

`cl_dll/include/view.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================
#pragma once
#if !defined ( VIEWH )
#define VIEWH 

void V_StartPitchDrift( void );
void V_StopPitchDrift( void );

#endif // !VIEWH
```

`cl_dll/include/wrect.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#pragma once
#if !defined( WRECTH )
#define WRECTH

typedef struct rect_s
{
	int				left, right, top, bottom;
} wrect_t;

#endif
```

`cl_dll/input.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// cl.input.c  -- builds an intended movement command to send to the server

//xxxxxx Move bob and pitch drifting code here and other stuff from view if needed

// Quake is a trademark of Id Software, Inc., (c) 1996 Id Software, Inc. All
// rights reserved.
#include "hud.h"
#include "cl_util.h"
#include "camera.h"
#include "kbutton.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"
#include "camera.h"
#include "in_defs.h"
#include "view.h"
#include <string.h>
#include <ctype.h>

#include "vgui_parser.h"
#include "com_weapons.h"

extern int g_weaponselect;
extern cl_enginefunc_t gEngfuncs;

// Defined in pm_math.c
float anglemod( float a );

void IN_Init (void);
void IN_Move ( float frametime, usercmd_t *cmd);
void IN_Shutdown( void );
void V_Init( void );
void VectorAngles( const float *forward, float *angles );
int CL_ButtonBits( int );

// xxx need client dll function to get and clear impuse
extern cvar_t *in_joystick;

int	in_impulse	= 0;
int	in_cancel	= 0;

cvar_t	*m_pitch;
cvar_t	*m_yaw;
cvar_t	*m_forward;
cvar_t	*m_side;

cvar_t	*lookstrafe;
cvar_t	*lookspring;
cvar_t	*cl_pitchup;
cvar_t	*cl_pitchdown;
cvar_t	*cl_upspeed;
cvar_t	*cl_forwardspeed;
cvar_t	*cl_backspeed;
cvar_t	*cl_sidespeed;
cvar_t	*cl_movespeedkey;
cvar_t	*cl_yawspeed;
cvar_t	*cl_pitchspeed;
cvar_t	*cl_anglespeedkey;
cvar_t	*cl_vsmoothing;
/*
===============================================================================

KEY BUTTONS

Continuous button event tracking is complicated by the fact that two different
input sources (say, mouse button 1 and the control key) can both press the
same button, but the button should only be released when both of the
pressing key have been released.

When a key event issues a button command (+forward, +attack, etc), it appends
its key number as a parameter to the command so it can be matched up with
the release.

state bit 0 is the current state of the key
state bit 1 is edge triggered on the up to down transition
state bit 2 is edge triggered on the down to up transition

===============================================================================
*/


kbutton_t	in_mlook;
kbutton_t	in_klook;
kbutton_t	in_jlook;
kbutton_t	in_left;
kbutton_t	in_right;
kbutton_t	in_forward;
kbutton_t	in_back;
kbutton_t	in_lookup;
kbutton_t	in_lookdown;
kbutton_t	in_moveleft;
kbutton_t	in_moveright;
kbutton_t	in_strafe;
kbutton_t	in_speed;
kbutton_t	in_use;
kbutton_t	in_jump;
kbutton_t	in_attack;
kbutton_t	in_attack2;
kbutton_t	in_up;
kbutton_t	in_down;
kbutton_t	in_duck;
kbutton_t	in_reload;
kbutton_t	in_alt1;
kbutton_t	in_score;
kbutton_t	in_break;
kbutton_t	in_graph;  // Display the netgraph

struct kblist_t
{
	kblist_t *next;
	kbutton_t *pkey;
	char name[32];
};

kblist_t *g_kbkeys = NULL;

/*
============
KB_ConvertString

Removes references to +use and replaces them with the keyname in the output string.  If
 a binding is unfound, then the original text is retained.
NOTE:  Only works for text with +word in it.
============
*/
int KB_ConvertString( char *in, char **ppout )
{
	char sz[ 4096 ];
	char binding[ 64 ];
	char *p;
	char *pOut;
	char *pEnd;
	const char *pBinding;

	if ( !ppout )
		return 0;

	*ppout = NULL;
	p = in;
	pOut = sz;
	while ( *p )
	{
		if ( *p == '+' )
		{
			pEnd = binding;
			while ( *p && ( isalnum( *p ) || ( pEnd == binding ) ) && ( ( pEnd - binding ) < 63 ) )
			{
				*pEnd++ = *p++;
			}

			*pEnd =  '\0';

			pBinding = NULL;
			if ( strlen( binding + 1 ) > 0 )
			{
				// See if there is a binding for binding?
				pBinding = gEngfuncs.Key_LookupBinding( binding + 1 );
			}

			if ( pBinding )
			{
				*pOut++ = '[';
				pEnd = (char *)pBinding;
			}
			else
			{
				pEnd = binding;
			}

			while ( *pEnd )
			{
				*pOut++ = *pEnd++;
			}

			if ( pBinding )
			{
				*pOut++ = ']';
			}
		}
		else
		{
			*pOut++ = *p++;
		}
	}

	*pOut = '\0';

	pOut = ( char * )malloc( strlen( sz ) + 1 );
	strcpy( pOut, sz );
	*ppout = pOut;

	return 1;
}

/*
============
KB_Find

Allows the engine to get a kbutton_t directly ( so it can check +mlook state, etc ) for saving out to .cfg files
============
*/
struct kbutton_s DLLEXPORT *KB_Find( const char *name )
{
	kblist_t *p;
	p = g_kbkeys;
	while ( p )
	{
		if ( !stricmp( name, p->name ) )
			return p->pkey;

		p = p->next;
	}
	return NULL;
}

/*
============
KB_Add

Add a kbutton_t * to the list of pointers the engine can retrieve via KB_Find
============
*/
void KB_Add( const char *name, kbutton_t *pkb )
{
	kblist_t *p;	
	kbutton_t *kb;

	kb = KB_Find( name );
	
	if ( kb )
		return;

	p = ( kblist_t * )malloc( sizeof( kblist_t ) );
	memset( p, 0, sizeof( *p ) );

	strcpy( p->name, name );
	p->pkey = pkb;

	p->next = g_kbkeys;
	g_kbkeys = p;
}

/*
============
KB_Init

Add kbutton_t definitions that the engine can query if needed
============
*/
void KB_Init( void )
{
	g_kbkeys = NULL;

	KB_Add( "in_graph", &in_graph );
	KB_Add( "in_mlook", &in_mlook );
	KB_Add( "in_jlook", &in_jlook );
}

/*
============
KB_Shutdown

Clear kblist
============
*/
void KB_Shutdown( void )
{
	kblist_t *p, *n;
	p = g_kbkeys;
	while ( p )
	{
		n = p->next;
		free( p );
		p = n;
	}
	g_kbkeys = NULL;
}

/*
============
KeyDown
============
*/
void KeyDown (kbutton_t *b)
{
	int		k;
	char	*c;

	c = gEngfuncs.Cmd_Argv(1);
	if (c[0])
		k = atoi(c);
	else
		k = -1;		// typed manually at the console for continuous down

	if (k == b->down[0] || k == b->down[1])
		return;		// repeating key
	
	if (!b->down[0])
		b->down[0] = k;
	else if (!b->down[1])
		b->down[1] = k;
	else
	{
		gEngfuncs.Con_DPrintf ("Three keys down for a button '%c' '%c' '%c'!\n", b->down[0], b->down[1], c);
		return;
	}
	
	if (b->state & 1)
		return;		// still down
	b->state |= 1 + 2;	// down + impulse down
}

/*
============
KeyUp
============
*/
void KeyUp (kbutton_t *b)
{
	int		k;
	char	*c;
	
	c = gEngfuncs.Cmd_Argv(1);
	if (c[0])
		k = atoi(c);
	else
	{ // typed manually at the console, assume for unsticking, so clear all
		b->down[0] = b->down[1] = 0;
		b->state = 4;	// impulse up
		return;
	}

	if (b->down[0] == k)
		b->down[0] = 0;
	else if (b->down[1] == k)
		b->down[1] = 0;
	else
		return;		// key up without coresponding down (menu pass through)
	if (b->down[0] || b->down[1])
	{
		//Con_Printf ("Keys down for button: '%c' '%c' '%c' (%d,%d,%d)!\n", b->down[0], b->down[1], c, b->down[0], b->down[1], c);
		return;		// some other key is still holding it down
	}

	if (!(b->state & 1))
		return;		// still up (this should not happen)

	b->state &= ~1;		// now up
	b->state |= 4; 		// impulse up
}

/*
============
HUD_Key_Event

Return 1 to allow engine to process the key, otherwise, act on it as needed
============
*/
int DLLEXPORT HUD_Key_Event( int down, int keynum, const char *pszCurrentBinding )
{
	return 1;
}

void IN_BreakDown( void ) { KeyDown( &in_break );}
void IN_BreakUp( void ) { KeyUp( &in_break ); }
void IN_KLookDown (void) {KeyDown(&in_klook);}
void IN_KLookUp (void) {KeyUp(&in_klook);}
void IN_JLookDown (void) {KeyDown(&in_jlook);}
void IN_JLookUp (void) {KeyUp(&in_jlook);}
void IN_MLookDown (void) {KeyDown(&in_mlook);}
void IN_UpDown(void) {KeyDown(&in_up);}
void IN_UpUp(void) {KeyUp(&in_up);}
void IN_DownDown(void) {KeyDown(&in_down);}
void IN_DownUp(void) {KeyUp(&in_down);}
void IN_LeftDown(void) {KeyDown(&in_left);}
void IN_LeftUp(void) {KeyUp(&in_left);}
void IN_RightDown(void) {KeyDown(&in_right);}
void IN_RightUp(void) {KeyUp(&in_right);}

void IN_ForwardDown(void)
{
	KeyDown(&in_forward);
	gHUD.m_Spectator.HandleButtonsDown( IN_FORWARD );
}

void IN_ForwardUp(void)
{
	KeyUp(&in_forward);
	gHUD.m_Spectator.HandleButtonsUp( IN_FORWARD );
}

void IN_BackDown(void)
{
	KeyDown(&in_back);
	gHUD.m_Spectator.HandleButtonsDown( IN_BACK );
}

void IN_BackUp(void)
{
	KeyUp(&in_back);
	gHUD.m_Spectator.HandleButtonsUp( IN_BACK );
}
void IN_LookupDown(void) {KeyDown(&in_lookup);}
void IN_LookupUp(void) {KeyUp(&in_lookup);}
void IN_LookdownDown(void) {KeyDown(&in_lookdown);}
void IN_LookdownUp(void) {KeyUp(&in_lookdown);}
void IN_MoveleftDown(void)
{
	KeyDown(&in_moveleft);
	gHUD.m_Spectator.HandleButtonsDown( IN_MOVELEFT );
}

void IN_MoveleftUp(void)
{
	KeyUp(&in_moveleft);
	gHUD.m_Spectator.HandleButtonsUp( IN_MOVELEFT );
}

void IN_MoverightDown(void)
{
	KeyDown(&in_moveright);
	gHUD.m_Spectator.HandleButtonsDown( IN_MOVERIGHT );
}

void IN_MoverightUp(void)
{
	KeyUp(&in_moveright);
	gHUD.m_Spectator.HandleButtonsUp( IN_MOVERIGHT );
}
void IN_SpeedDown(void) {KeyDown(&in_speed);}
void IN_SpeedUp(void) {KeyUp(&in_speed);}
void IN_StrafeDown(void) {KeyDown(&in_strafe);}
void IN_StrafeUp(void) {KeyUp(&in_strafe);}

// needs capture by hud/vgui also
extern void __CmdFunc_InputPlayerSpecial(void);

void IN_Attack2Down(void) 
{
	KeyDown(&in_attack2);

	gHUD.m_Spectator.HandleButtonsDown( IN_ATTACK2 );
}

void IN_Attack2Up(void) {KeyUp(&in_attack2);}
void IN_UseDown (void)
{
	KeyDown(&in_use);
	gHUD.m_Spectator.HandleButtonsDown( IN_USE );
}
void IN_UseUp (void) {KeyUp(&in_use);}
void IN_JumpDown (void)
{
	KeyDown(&in_jump);
	gHUD.m_Spectator.HandleButtonsDown( IN_JUMP );

}
void IN_JumpUp (void) {KeyUp(&in_jump);}
void IN_DuckDown(void)
{
	KeyDown(&in_duck);
	gHUD.m_Spectator.HandleButtonsDown( IN_DUCK );

}
void IN_DuckUp(void) {KeyUp(&in_duck);}
void IN_ReloadDown(void) {KeyDown(&in_reload);}
void IN_ReloadUp(void) {KeyUp(&in_reload);}
void IN_Alt1Down(void) {KeyDown(&in_alt1);}
void IN_Alt1Up(void) {KeyUp(&in_alt1);}
void IN_GraphDown(void) {KeyDown(&in_graph);}
void IN_GraphUp(void) {KeyUp(&in_graph);}

void IN_AttackDown(void)
{
	KeyDown( &in_attack );
	gHUD.m_Spectator.HandleButtonsDown( IN_ATTACK );
}

void IN_AttackUp(void)
{
	KeyUp( &in_attack );
	in_cancel = 0;
}

// Special handling
void IN_Cancel(void)
{
	in_cancel = 1;
}

void IN_Impulse (void)
{
	in_impulse = atoi( gEngfuncs.Cmd_Argv(1) );
}

void IN_ScoreDown(void)
{
	KeyDown(&in_score);
}

void IN_ScoreUp(void)
{
	KeyUp(&in_score);
}

void IN_MLookUp (void)
{
	KeyUp( &in_mlook );
#if 0
	if ( !( in_mlook.state & 1 ) && lookspring->value )
	{
		V_StartPitchDrift();
	}
#endif
}

/*
===============
CL_KeyState

Returns 0.25 if a key was pressed and released during the frame,
0.5 if it was pressed and held
0 if held then released, and
1.0 if held for the entire time
===============
*/
float CL_KeyState (kbutton_t *key)
{
	float		val = 0.0;
	int			impulsedown, impulseup, down;
	
	impulsedown = key->state & 2;
	impulseup	= key->state & 4;
	down		= key->state & 1;
	
	if ( impulsedown && !impulseup )
	{
		// pressed and held this frame?
		val = down ? 0.5 : 0.0;
	}

	if ( impulseup && !impulsedown )
	{
		// released this frame?
		val = down ? 0.0 : 0.0;
	}

	if ( !impulsedown && !impulseup )
	{
		// held the entire frame?
		val = down ? 1.0 : 0.0;
	}

	if ( impulsedown && impulseup )
	{
		if ( down )
		{
			// released and re-pressed this frame
			val = 0.75;	
		}
		else
		{
			// pressed and released this frame
			val = 0.25;	
		}
	}

	// clear impulses
	key->state &= 1;		
	return val;
}

/*
================
CL_AdjustAngles

Moves the local angle positions
================
*/
void CL_AdjustAngles ( float frametime, float *viewangles )
{
	float	speed;
	float	up, down;
	
	if (in_speed.state & 1)
	{
		speed = frametime * cl_anglespeedkey->value;
	}
	else
	{
		speed = frametime;
	}

	if (!(in_strafe.state & 1))
	{
		viewangles[YAW] -= speed*cl_yawspeed->value*CL_KeyState (&in_right);
		viewangles[YAW] += speed*cl_yawspeed->value*CL_KeyState (&in_left);
		viewangles[YAW] = anglemod(viewangles[YAW]);
	}
	if (in_klook.state & 1)
	{
		//V_StopPitchDrift ();
		viewangles[PITCH] -= speed*cl_pitchspeed->value * CL_KeyState (&in_forward);
		viewangles[PITCH] += speed*cl_pitchspeed->value * CL_KeyState (&in_back);
	}
	
	up = CL_KeyState (&in_lookup);
	down = CL_KeyState(&in_lookdown);
	
	viewangles[PITCH] -= speed*cl_pitchspeed->value * up;
	viewangles[PITCH] += speed*cl_pitchspeed->value * down;
#if 0
	if (up || down)
		V_StopPitchDrift ();
#endif
	if (viewangles[PITCH] > cl_pitchdown->value)
		viewangles[PITCH] = cl_pitchdown->value;
	if (viewangles[PITCH] < -cl_pitchup->value)
		viewangles[PITCH] = -cl_pitchup->value;

	if (viewangles[ROLL] > 50)
		viewangles[ROLL] = 50;
	if (viewangles[ROLL] < -50)
		viewangles[ROLL] = -50;
}

/*
================
CL_CreateMove

Send the intended movement message to the server
if active == 1 then we are 1) not playing back demos ( where our commands are ignored ) and
2 ) we have finished signing on to server
================
*/
void DLLEXPORT CL_CreateMove ( float frametime, struct usercmd_s *cmd, int active )
{	
	float spd;
	vec3_t viewangles;
	static vec3_t oldangles;

	if ( active )
	{
		//memset( viewangles, 0, sizeof( vec3_t ) );
		//viewangles[ 0 ] = viewangles[ 1 ] = viewangles[ 2 ] = 0.0;
		gEngfuncs.GetViewAngles( (float *)viewangles );

		CL_AdjustAngles ( frametime, viewangles );

		memset (cmd, 0, sizeof(*cmd));
		
		gEngfuncs.SetViewAngles( (float *)viewangles );

		if ( in_strafe.state & 1 )
		{
			cmd->sidemove += cl_sidespeed->value * CL_KeyState (&in_right);
			cmd->sidemove -= cl_sidespeed->value * CL_KeyState (&in_left);
		}

		cmd->sidemove += cl_sidespeed->value * CL_KeyState (&in_moveright);
		cmd->sidemove -= cl_sidespeed->value * CL_KeyState (&in_moveleft);

		cmd->upmove += cl_upspeed->value * CL_KeyState (&in_up);
		cmd->upmove -= cl_upspeed->value * CL_KeyState (&in_down);

		if ( !(in_klook.state & 1 ) )
		{	
			if(gHUD.m_MOTD.m_bShow)
			{
				gHUD.m_MOTD.scroll -= CL_KeyState (&in_forward);
				gHUD.m_MOTD.scroll += CL_KeyState (&in_back);
			}
			else
			{
				cmd->forwardmove += cl_forwardspeed->value * CL_KeyState (&in_forward);
				cmd->forwardmove -= cl_backspeed->value * CL_KeyState (&in_back);
			}
		}	

		// adjust for speed key
		if ( in_speed.state & 1 )
		{
			cmd->forwardmove *= cl_movespeedkey->value;
			cmd->sidemove *= cl_movespeedkey->value;
			cmd->upmove *= cl_movespeedkey->value;
		}

		// clip to maxspeed
		spd = gEngfuncs.GetClientMaxspeed();
		if ( spd != 0.0 )
		{
			// scale the 3 speeds so that the total velocity is not > cl.maxspeed
			float fmov = sqrt( (cmd->forwardmove*cmd->forwardmove) + (cmd->sidemove*cmd->sidemove) + (cmd->upmove*cmd->upmove) );

			if ( fmov > spd )
			{
				float fratio = spd / fmov;
				cmd->forwardmove *= fratio;
				cmd->sidemove *= fratio;
				cmd->upmove *= fratio;
			}
		}

		// Allow mice and other controllers to add their inputs
		IN_Move ( frametime, cmd );
	}

	cmd->impulse = in_impulse;
	in_impulse = 0;

	cmd->weaponselect = g_weaponselect;
	g_weaponselect = 0;
	//
	// set button and flag bits
	//
	cmd->buttons = CL_ButtonBits( 1 );

	// Using joystick?
	if ( in_joystick->value )
	{
		if ( cmd->forwardmove > 0 )
		{
			cmd->buttons |= IN_FORWARD;
		}
		else if ( cmd->forwardmove < 0 )
		{
			cmd->buttons |= IN_BACK;
		}
	}

	gEngfuncs.GetViewAngles( (float *)viewangles );
	// Set current view angles.

	if ( CL_IsDead() )
	{
		VectorCopy( oldangles, cmd->viewangles );
	}
	else
	{
		VectorCopy( viewangles, cmd->viewangles );
		VectorCopy( viewangles, oldangles );
	}

}

/*
============
CL_ButtonBits

Returns appropriate button info for keyboard and mouse state
Set bResetState to 1 to clear old state info
============
*/
int CL_ButtonBits( int bResetState )
{
	int bits = 0;

	if ( in_attack.state & 3 )
	{
		if(gHUD.m_MOTD.m_bShow)
			gHUD.m_MOTD.Reset();
		else
			bits |= IN_ATTACK;
	}
	
	if (in_duck.state & 3)
	{
		bits |= IN_DUCK;
	}
 
	if (in_jump.state & 3)
	{
		bits |= IN_JUMP;
	}

	if ( in_forward.state & 3 )
	{
		bits |= IN_FORWARD;
	}
	
	if (in_back.state & 3)
	{
		bits |= IN_BACK;
	}

	if (in_use.state & 3)
	{
		bits |= IN_USE;
	}

	if (in_cancel)
	{
		bits |= IN_CANCEL;
	}

	if ( in_left.state & 3 )
	{
		bits |= IN_LEFT;
	}
	
	if (in_right.state & 3)
	{
		bits |= IN_RIGHT;
	}
	
	if ( in_moveleft.state & 3 )
	{
		bits |= IN_MOVELEFT;
	}
	
	if (in_moveright.state & 3)
	{
		bits |= IN_MOVERIGHT;
	}

	if (in_attack2.state & 3)
	{
		bits |= IN_ATTACK2;
	}

	if (in_reload.state & 3)
	{
		bits |= IN_RELOAD;
	}

	if (in_alt1.state & 3)
	{
		bits |= IN_ALT1;
	}

	if ( in_score.state & 3 )
	{
		bits |= IN_SCORE;
	}

	// Dead or in intermission? Shore scoreboard, too
	if ( CL_IsDead() || gHUD.m_iIntermission )
	{
		bits |= IN_SCORE;
	}

	if ( bResetState )
	{
		in_attack.state &= ~2;
		in_duck.state &= ~2;
		in_jump.state &= ~2;
		in_forward.state &= ~2;
		in_back.state &= ~2;
		in_use.state &= ~2;
		in_left.state &= ~2;
		in_right.state &= ~2;
		in_moveleft.state &= ~2;
		in_moveright.state &= ~2;
		in_attack2.state &= ~2;
		in_reload.state &= ~2;
		in_alt1.state &= ~2;
		in_score.state &= ~2;
	}

	return bits;
}

/*
============
CL_ResetButtonBits

============
*/
void CL_ResetButtonBits( int bits )
{
	int bitsNew = CL_ButtonBits( 0 ) ^ bits;

	// Has the attack button been changed
	if ( bitsNew & IN_ATTACK )
	{
		// Was it pressed? or let go?
		if ( bits & IN_ATTACK )
		{
			KeyDown( &in_attack );
		}
		else
		{
			// totally clear state
			in_attack.state &= ~7;
		}
	}
}

/*
============
InitInput
============
*/
void InitInput (void)
{
	gEngfuncs.pfnAddCommand ("+moveup",IN_UpDown);
	gEngfuncs.pfnAddCommand ("-moveup",IN_UpUp);
	gEngfuncs.pfnAddCommand ("+movedown",IN_DownDown);
	gEngfuncs.pfnAddCommand ("-movedown",IN_DownUp);
	gEngfuncs.pfnAddCommand ("+left",IN_LeftDown);
	gEngfuncs.pfnAddCommand ("-left",IN_LeftUp);
	gEngfuncs.pfnAddCommand ("+right",IN_RightDown);
	gEngfuncs.pfnAddCommand ("-right",IN_RightUp);
	gEngfuncs.pfnAddCommand ("+forward",IN_ForwardDown);
	gEngfuncs.pfnAddCommand ("-forward",IN_ForwardUp);
	gEngfuncs.pfnAddCommand ("+back",IN_BackDown);
	gEngfuncs.pfnAddCommand ("-back",IN_BackUp);
	gEngfuncs.pfnAddCommand ("+lookup", IN_LookupDown);
	gEngfuncs.pfnAddCommand ("-lookup", IN_LookupUp);
	gEngfuncs.pfnAddCommand ("+lookdown", IN_LookdownDown);
	gEngfuncs.pfnAddCommand ("-lookdown", IN_LookdownUp);
	gEngfuncs.pfnAddCommand ("+strafe", IN_StrafeDown);
	gEngfuncs.pfnAddCommand ("-strafe", IN_StrafeUp);
	gEngfuncs.pfnAddCommand ("+moveleft", IN_MoveleftDown);
	gEngfuncs.pfnAddCommand ("-moveleft", IN_MoveleftUp);
	gEngfuncs.pfnAddCommand ("+moveright", IN_MoverightDown);
	gEngfuncs.pfnAddCommand ("-moveright", IN_MoverightUp);
	gEngfuncs.pfnAddCommand ("+speed", IN_SpeedDown);
	gEngfuncs.pfnAddCommand ("-speed", IN_SpeedUp);
	gEngfuncs.pfnAddCommand ("+attack", IN_AttackDown);
	gEngfuncs.pfnAddCommand ("-attack", IN_AttackUp);
	gEngfuncs.pfnAddCommand ("+attack2", IN_Attack2Down);
	gEngfuncs.pfnAddCommand ("-attack2", IN_Attack2Up);
	gEngfuncs.pfnAddCommand ("+use", IN_UseDown);
	gEngfuncs.pfnAddCommand ("-use", IN_UseUp);
	gEngfuncs.pfnAddCommand ("+jump", IN_JumpDown);
	gEngfuncs.pfnAddCommand ("-jump", IN_JumpUp);
	gEngfuncs.pfnAddCommand ("impulse", IN_Impulse);
	gEngfuncs.pfnAddCommand ("+klook", IN_KLookDown);
	gEngfuncs.pfnAddCommand ("-klook", IN_KLookUp);
	gEngfuncs.pfnAddCommand ("+mlook", IN_MLookDown);
	gEngfuncs.pfnAddCommand ("-mlook", IN_MLookUp);
	gEngfuncs.pfnAddCommand ("+jlook", IN_JLookDown);
	gEngfuncs.pfnAddCommand ("-jlook", IN_JLookUp);
	gEngfuncs.pfnAddCommand ("+duck", IN_DuckDown);
	gEngfuncs.pfnAddCommand ("-duck", IN_DuckUp);
	gEngfuncs.pfnAddCommand ("+reload", IN_ReloadDown);
	gEngfuncs.pfnAddCommand ("-reload", IN_ReloadUp);
	gEngfuncs.pfnAddCommand ("+alt1", IN_Alt1Down);
	gEngfuncs.pfnAddCommand ("-alt1", IN_Alt1Up);
	gEngfuncs.pfnAddCommand ("+score", IN_ScoreDown);
	gEngfuncs.pfnAddCommand ("-score", IN_ScoreUp);
	gEngfuncs.pfnAddCommand ("+graph", IN_GraphDown);
	gEngfuncs.pfnAddCommand ("-graph", IN_GraphUp);
	gEngfuncs.pfnAddCommand ("+break",IN_BreakDown);
	gEngfuncs.pfnAddCommand ("-break",IN_BreakUp);

	lookstrafe			= gEngfuncs.pfnRegisterVariable ( "lookstrafe", "0", FCVAR_ARCHIVE );
	lookspring			= gEngfuncs.pfnRegisterVariable ( "lookspring", "0", FCVAR_ARCHIVE );
	cl_anglespeedkey	= gEngfuncs.pfnRegisterVariable ( "cl_anglespeedkey", "0.67", 0 );
	cl_yawspeed			= gEngfuncs.pfnRegisterVariable ( "cl_yawspeed", "210", 0 );
	cl_pitchspeed		= gEngfuncs.pfnRegisterVariable ( "cl_pitchspeed", "225", 0 );
	cl_upspeed			= gEngfuncs.pfnRegisterVariable ( "cl_upspeed", "320", 0 );
	cl_forwardspeed		= gEngfuncs.pfnRegisterVariable ( "cl_forwardspeed", "400", FCVAR_ARCHIVE );
	cl_backspeed		= gEngfuncs.pfnRegisterVariable ( "cl_backspeed", "400", FCVAR_ARCHIVE );
	cl_sidespeed		= gEngfuncs.pfnRegisterVariable ( "cl_sidespeed", "400", 0 );
	cl_movespeedkey		= gEngfuncs.pfnRegisterVariable ( "cl_movespeedkey", "0.3", 0 );
	cl_pitchup			= gEngfuncs.pfnRegisterVariable ( "cl_pitchup", "89", 0 );
	cl_pitchdown		= gEngfuncs.pfnRegisterVariable ( "cl_pitchdown", "89", 0 );

	cl_vsmoothing		= gEngfuncs.pfnRegisterVariable ( "cl_vsmoothing", "0.05", FCVAR_ARCHIVE );

	m_pitch			    = gEngfuncs.pfnRegisterVariable ( "m_pitch","0.022", FCVAR_ARCHIVE );
	m_yaw				= gEngfuncs.pfnRegisterVariable ( "m_yaw","0.022", FCVAR_ARCHIVE );
	m_forward			= gEngfuncs.pfnRegisterVariable ( "m_forward","1", FCVAR_ARCHIVE );
	m_side				= gEngfuncs.pfnRegisterVariable ( "m_side","0.8", FCVAR_ARCHIVE );

	// Initialize third person camera controls.
	CAM_Init();
	// Initialize inputs
	IN_Init();
	// Initialize keyboard
	KB_Init();
	// Initialize view system
	V_Init();
}

/*
============
Input_Shutdown
============
*/
void Input_Shutdown (void)
{
	IN_Shutdown();
	KB_Shutdown();
}

```

`cl_dll/input_sdl.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// in_win.c -- windows 95 mouse and joystick code
// 02/21/97 JCB Added extended DirectInput code to support external controllers.

#include "port.h"

#include "hud.h"
#include "cl_util.h"
#include "camera.h"
#include "kbutton.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"
#include "camera.h"
#include "in_defs.h"
#include "../engine/keydefs.h"
#include "view.h"
#include "input.h"

#include <SDL2/SDL_mouse.h>
#include <SDL2/SDL_gamecontroller.h>

#define MOUSE_BUTTON_COUNT 5

// Set this to 1 to show mouse cursor.  Experimental
int	g_iVisibleMouse = 0;

extern int iMouseInUse;


// mouse variables
cvar_t		*m_filter;
cvar_t		*sensitivity;

// Custom mouse acceleration (0 disable, 1 to enable, 2 enable with separate yaw/pitch rescale)
static cvar_t *m_customaccel;
//Formula: mousesensitivity = ( rawmousedelta^m_customaccel_exponent ) * m_customaccel_scale + sensitivity
// If mode is 2, then x and y sensitivity are scaled by m_pitch and m_yaw respectively.
// Custom mouse acceleration value.
static cvar_t *m_customaccel_scale;
//Max mouse move scale factor, 0 for no limit
static cvar_t *m_customaccel_max;
//Mouse move is raised to this power before being scaled by scale factor
static cvar_t *m_customaccel_exponent;

int			mouse_buttons;
int			mouse_oldbuttonstate;
POINT		current_pos;
int			old_mouse_x, old_mouse_y, mx_accum, my_accum;
float		mouse_x, mouse_y;

static int	mouseactive = 0;
int			mouseinitialized;

// joystick defines and variables
// where should defines be moved?
#define JOY_ABSOLUTE_AXIS	0x00000000		// control like a joystick
#define JOY_RELATIVE_AXIS	0x00000010		// control like a mouse, spinner, trackball
#define	JOY_MAX_AXES		6				// X, Y, Z, R, U, V
#define JOY_AXIS_X			0
#define JOY_AXIS_Y			1
#define JOY_AXIS_Z			2
#define JOY_AXIS_R			3
#define JOY_AXIS_U			4
#define JOY_AXIS_V			5

enum _ControlList
{
	AxisNada = 0,
	AxisForward,
	AxisLook,
	AxisSide,
	AxisTurn
};



DWORD	dwAxisMap[ JOY_MAX_AXES ];
DWORD	dwControlMap[ JOY_MAX_AXES ];
int	pdwRawValue[ JOY_MAX_AXES ];
DWORD		joy_oldbuttonstate, joy_oldpovstate;

int			joy_id;
DWORD		joy_numbuttons;

SDL_GameController *s_pJoystick = NULL;

// none of these cvars are saved over a session
// this means that advanced controller configuration needs to be executed
// each time.  this avoids any problems with getting back to a default usage
// or when changing from one controller to another.  this way at least something
// works.
cvar_t	*in_joystick;
cvar_t	*joy_name;
cvar_t	*joy_advanced;
cvar_t	*joy_advaxisx;
cvar_t	*joy_advaxisy;
cvar_t	*joy_advaxisz;
cvar_t	*joy_advaxisr;
cvar_t	*joy_advaxisu;
cvar_t	*joy_advaxisv;
cvar_t	*joy_forwardthreshold;
cvar_t	*joy_sidethreshold;
cvar_t	*joy_pitchthreshold;
cvar_t	*joy_yawthreshold;
cvar_t	*joy_forwardsensitivity;
cvar_t	*joy_sidesensitivity;
cvar_t	*joy_pitchsensitivity;
cvar_t	*joy_yawsensitivity;
cvar_t	*joy_wwhack1;
cvar_t	*joy_wwhack2;

int			joy_avail, joy_advancedinit, joy_haspov;

#ifdef _WIN32
DWORD	s_hMouseThreadId = 0;
HANDLE	s_hMouseThread = 0;
HANDLE	s_hMouseQuitEvent = 0;
HANDLE	s_hMouseDoneQuitEvent = 0;
#endif

/*
===========
Force_CenterView_f
===========
*/
void Force_CenterView_f (void)
{
	vec3_t viewangles;

	if (!iMouseInUse)
	{
		gEngfuncs.GetViewAngles( (float *)viewangles );
	    viewangles[PITCH] = 0;
		gEngfuncs.SetViewAngles( (float *)viewangles );
	}
}

#ifdef _WIN32
long s_mouseDeltaX = 0;
long s_mouseDeltaY = 0;
POINT		old_mouse_pos;

long ThreadInterlockedExchange( long *pDest, long value )
{
	return InterlockedExchange( pDest, value );
}


DWORD WINAPI MousePos_ThreadFunction( LPVOID p )
{
	s_hMouseDoneQuitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	while ( 1 )
	{
		if ( WaitForSingleObject( s_hMouseQuitEvent, (int)m_mousethread_sleep->value ) == WAIT_OBJECT_0 )
		{
			return 0;
		}

		if ( mouseactive )
		{
			POINT		mouse_pos;
			GetCursorPos(&mouse_pos);

			volatile int mx = mouse_pos.x - old_mouse_pos.x + s_mouseDeltaX;
			volatile int my = mouse_pos.y - old_mouse_pos.y + s_mouseDeltaY;
 
			ThreadInterlockedExchange( &old_mouse_pos.x, mouse_pos.x );
			ThreadInterlockedExchange( &old_mouse_pos.y, mouse_pos.y );

			ThreadInterlockedExchange( &s_mouseDeltaX, mx );
			ThreadInterlockedExchange( &s_mouseDeltaY, my );
		}
	}

	SetEvent( s_hMouseDoneQuitEvent );

	return 0;
}
#endif

/*
===========
IN_ActivateMouse
===========
*/
void DLLEXPORT IN_ActivateMouse (void)
{
	if (mouseinitialized)
	{
#ifdef _WIN32
		if (mouseparmsvalid)
			restore_spi = SystemParametersInfo (SPI_SETMOUSE, 0, newmouseparms, 0);

#endif
		mouseactive = 1;
	}
}


/*
===========
IN_DeactivateMouse
===========
*/
void DLLEXPORT IN_DeactivateMouse (void)
{
	if (mouseinitialized)
	{
#ifdef _WIN32
		if (restore_spi)
			SystemParametersInfo (SPI_SETMOUSE, 0, originalmouseparms, 0);

#endif

		mouseactive = 0;
	}
}

/*
===========
IN_StartupMouse
===========
*/
void IN_StartupMouse (void)
{
	if ( gEngfuncs.CheckParm ("-nomouse", NULL ) ) 
		return; 

	mouseinitialized = 1;
#ifdef _WIN32
	mouseparmsvalid = SystemParametersInfo (SPI_GETMOUSE, 0, originalmouseparms, 0);

	if (mouseparmsvalid)
	{
		if ( gEngfuncs.CheckParm ("-noforcemspd", NULL ) ) 
			newmouseparms[2] = originalmouseparms[2];

		if ( gEngfuncs.CheckParm ("-noforcemaccel", NULL ) ) 
		{
			newmouseparms[0] = originalmouseparms[0];
			newmouseparms[1] = originalmouseparms[1];
		}

		if ( gEngfuncs.CheckParm ("-noforcemparms", NULL ) ) 
		{
			newmouseparms[0] = originalmouseparms[0];
			newmouseparms[1] = originalmouseparms[1];
			newmouseparms[2] = originalmouseparms[2];
		}
	}
#endif
	
	mouse_buttons = MOUSE_BUTTON_COUNT;
}

/*
===========
IN_Shutdown
===========
*/
void IN_Shutdown (void)
{
	IN_DeactivateMouse ();

#ifdef _WIN32
	if ( s_hMouseQuitEvent )
	{
		SetEvent( s_hMouseQuitEvent );
		WaitForSingleObject( s_hMouseDoneQuitEvent, 100 );
	}
	
	if ( s_hMouseThread )
	{
		TerminateThread( s_hMouseThread, 0 );
		CloseHandle( s_hMouseThread );
		s_hMouseThread = (HANDLE)0;
	}
	
	if ( s_hMouseQuitEvent )
	{
		CloseHandle( s_hMouseQuitEvent );
		s_hMouseQuitEvent = (HANDLE)0;
	}
	
	
	if ( s_hMouseDoneQuitEvent )
	{
		CloseHandle( s_hMouseDoneQuitEvent );
		s_hMouseDoneQuitEvent = (HANDLE)0;
	}
#endif
}

/*
===========
IN_GetMousePos

Ask for mouse position from engine
===========
*/
void IN_GetMousePos( int *mx, int *my )
{
	gEngfuncs.GetMousePosition( mx, my );
}

/*
===========
IN_ResetMouse

FIXME: Call through to engine?
===========
*/
void IN_ResetMouse( void )
{
	// no work to do in SDL
#ifdef _WIN32
	if ( !m_bRawInput && mouseactive && gEngfuncs.GetWindowCenterX && gEngfuncs.GetWindowCenterY )
	{

		SetCursorPos ( gEngfuncs.GetWindowCenterX(), gEngfuncs.GetWindowCenterY() );
		ThreadInterlockedExchange( &old_mouse_pos.x, gEngfuncs.GetWindowCenterX() );
		ThreadInterlockedExchange( &old_mouse_pos.y, gEngfuncs.GetWindowCenterY() );
	}

	if ( gpGlobals && gpGlobals->time - s_flRawInputUpdateTime > 1.0f )
	{
		s_flRawInputUpdateTime = gpGlobals->time;
		m_bRawInput = CVAR_GET_FLOAT( "m_rawinput" ) != 0;
	}
#endif
}

/*
===========
IN_MouseEvent
===========
*/
void DLLEXPORT IN_MouseEvent (int mstate)
{
	int		i;

	if ( iMouseInUse || g_iVisibleMouse )
		return;

	// perform button actions
	for (i=0 ; i<mouse_buttons ; i++)
	{
		if ( (mstate & (1<<i)) &&
			!(mouse_oldbuttonstate & (1<<i)) )
		{
			gEngfuncs.Key_Event (K_MOUSE1 + i, 1);
		}

		if ( !(mstate & (1<<i)) &&
			(mouse_oldbuttonstate & (1<<i)) )
		{
			gEngfuncs.Key_Event (K_MOUSE1 + i, 0);
		}
	}	
	
	mouse_oldbuttonstate = mstate;
}

//-----------------------------------------------------------------------------
// Purpose: Allows modulation of mouse scaling/senstivity value and application
//  of custom algorithms.
// Input  : *x - 
//			*y - 
//-----------------------------------------------------------------------------
void IN_ScaleMouse( float *x, float *y )
{
	float mx = *x;
	float my = *y;

	// This is the default sensitivity
	float mouse_senstivity = ( gHUD.GetSensitivity() != 0 ) ? gHUD.GetSensitivity() : sensitivity->value;

	// Using special accleration values
	if ( m_customaccel->value != 0 ) 
	{ 
		float raw_mouse_movement_distance = sqrt( mx * mx + my * my );
		float acceleration_scale = m_customaccel_scale->value;
		float accelerated_sensitivity_max = m_customaccel_max->value;
		float accelerated_sensitivity_exponent = m_customaccel_exponent->value;
		float accelerated_sensitivity = ( (float)pow( raw_mouse_movement_distance, accelerated_sensitivity_exponent ) * acceleration_scale + mouse_senstivity );

		if ( accelerated_sensitivity_max > 0.0001f && 
			accelerated_sensitivity > accelerated_sensitivity_max )
		{
			accelerated_sensitivity = accelerated_sensitivity_max;
		}

		*x *= accelerated_sensitivity; 
		*y *= accelerated_sensitivity; 

		// Further re-scale by yaw and pitch magnitude if user requests alternate mode 2
		// This means that they will need to up their value for m_customaccel_scale greatly (>40x) since m_pitch/yaw default
		//  to 0.022
		if ( m_customaccel->value == 2 )
		{ 
			*x *= m_yaw->value; 
			*y *= m_pitch->value; 
		} 
	}
	else
	{ 
		// Just apply the default
		*x *= mouse_senstivity;
		*y *= mouse_senstivity;
	}
}

/*
===========
IN_MouseMove
===========
*/
void IN_MouseMove ( float frametime, usercmd_t *cmd)
{
	int		mx, my;
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );

	//jjb - this disbles normal mouse control if the user is trying to 
	//      move the camera, or if the mouse cursor is visible or if we're in intermission
	if ( !iMouseInUse && !gHUD.m_iIntermission && !g_iVisibleMouse )
	{
		int deltaX, deltaY;
#ifdef _WIN32
		if ( !m_bRawInput )
		{
			if ( m_bMouseThread )
			{
				ThreadInterlockedExchange( &current_pos.x, s_mouseDeltaX );
				ThreadInterlockedExchange( &current_pos.y, s_mouseDeltaY );
				ThreadInterlockedExchange( &s_mouseDeltaX, 0 );
				ThreadInterlockedExchange( &s_mouseDeltaY, 0 );
			}
			else
			{
				GetCursorPos (&current_pos);
			}
		}
		else
#endif
		{
			SDL_GetRelativeMouseState( &deltaX, &deltaY );
			current_pos.x = deltaX;
			current_pos.y = deltaY;	
		}
		
#ifdef _WIN32
		if ( !m_bRawInput )
		{
			if ( m_bMouseThread )
			{
				mx = current_pos.x;
				my = current_pos.y;
			}
			else
			{
				mx = current_pos.x - gEngfuncs.GetWindowCenterX() + mx_accum;
				my = current_pos.y - gEngfuncs.GetWindowCenterY() + my_accum;
			}
		}
		else
#endif
		{
			mx = deltaX + mx_accum;
			my = deltaY + my_accum;
		}
		
		mx_accum = 0;
		my_accum = 0;

		if (m_filter && m_filter->value)
		{
			mouse_x = (mx + old_mouse_x) * 0.5;
			mouse_y = (my + old_mouse_y) * 0.5;
		}
		else
		{
			mouse_x = mx;
			mouse_y = my;
		}

		old_mouse_x = mx;
		old_mouse_y = my;

		// Apply custom mouse scaling/acceleration
		IN_ScaleMouse( &mouse_x, &mouse_y );

		// add mouse X/Y movement to cmd
		if ( (in_strafe.state & 1) || (lookstrafe->value && (in_mlook.state & 1) ))
			cmd->sidemove += m_side->value * mouse_x;
		else
			viewangles[YAW] -= m_yaw->value * mouse_x;

		if ( (in_mlook.state & 1) && !(in_strafe.state & 1))
		{
			viewangles[PITCH] += m_pitch->value * mouse_y;
			if (viewangles[PITCH] > cl_pitchdown->value)
				viewangles[PITCH] = cl_pitchdown->value;
			if (viewangles[PITCH] < -cl_pitchup->value)
				viewangles[PITCH] = -cl_pitchup->value;
		}
		else
		{
			if ((in_strafe.state & 1) && gEngfuncs.IsNoClipping() )
			{
				cmd->upmove -= m_forward->value * mouse_y;
			}
			else
			{
				cmd->forwardmove -= m_forward->value * mouse_y;
			}
		}

		// if the mouse has moved, force it to the center, so there's room to move
		if ( mx || my )
		{
			IN_ResetMouse();
		}
	}

	gEngfuncs.SetViewAngles( (float *)viewangles );

/*
//#define TRACE_TEST
#if defined( TRACE_TEST )
	{
		int mx, my;
		void V_Move( int mx, int my );
		IN_GetMousePos( &mx, &my );
		V_Move( mx, my );
	}
#endif
*/
}

/*
===========
IN_Accumulate
===========
*/
void DLLEXPORT IN_Accumulate (void)
{
	//only accumulate mouse if we are not moving the camera with the mouse
	if ( !iMouseInUse && !g_iVisibleMouse)
	{
	    if (mouseactive)
	    {
#ifdef _WIN32
			if ( !m_bRawInput )
			{
				if ( !m_bMouseThread )
				{
					GetCursorPos (&current_pos);
					
					mx_accum += current_pos.x - gEngfuncs.GetWindowCenterX();
					my_accum += current_pos.y - gEngfuncs.GetWindowCenterY();
				}
			}
			else
#endif
			{
				int deltaX, deltaY;
				SDL_GetRelativeMouseState( &deltaX, &deltaY );
				mx_accum += deltaX;
				my_accum += deltaY;	
			}
			// force the mouse to the center, so there's room to move
			IN_ResetMouse();
			
		}
	}

}

/*
===================
IN_ClearStates
===================
*/
void DLLEXPORT IN_ClearStates (void)
{
	if ( !mouseactive )
		return;

	mx_accum = 0;
	my_accum = 0;
	mouse_oldbuttonstate = 0;
}

/* 
=============== 
IN_StartupJoystick 
=============== 
*/  
void IN_StartupJoystick (void) 
{ 
	// abort startup if user requests no joystick
	if ( gEngfuncs.CheckParm ("-nojoy", NULL ) ) 
		return; 
 
 	// assume no joystick
	joy_avail = 0; 

	int nJoysticks = SDL_NumJoysticks();
	if ( nJoysticks > 0 )
	{
		for ( int i = 0; i < nJoysticks; i++ )
		{
			if ( SDL_IsGameController( i ) )
			{
				s_pJoystick = SDL_GameControllerOpen( i );
				if ( s_pJoystick )
				{
					//save the joystick's number of buttons and POV status
					joy_numbuttons = SDL_CONTROLLER_BUTTON_MAX;
					joy_haspov = 0;
					
					// old button and POV states default to no buttons pressed
					joy_oldbuttonstate = joy_oldpovstate = 0;
					
					// mark the joystick as available and advanced initialization not completed
					// this is needed as cvars are not available during initialization
					gEngfuncs.Con_Printf ("joystick found\n\n", SDL_GameControllerName(s_pJoystick)); 
					joy_avail = 1; 
					joy_advancedinit = 0;
					break;
				}

			}
		}
	}
	else
	{
		gEngfuncs.Con_DPrintf ("joystick not found -- driver not present\n\n");
	}
	
}


int RawValuePointer (int axis)
{
	switch (axis)
	{
		default:
		case JOY_AXIS_X:
			return SDL_GameControllerGetAxis( s_pJoystick, SDL_CONTROLLER_AXIS_LEFTX );
		case JOY_AXIS_Y:
			return SDL_GameControllerGetAxis( s_pJoystick, SDL_CONTROLLER_AXIS_LEFTY );
		case JOY_AXIS_Z:
			return SDL_GameControllerGetAxis( s_pJoystick, SDL_CONTROLLER_AXIS_RIGHTX );
		case JOY_AXIS_R:
			return SDL_GameControllerGetAxis( s_pJoystick, SDL_CONTROLLER_AXIS_RIGHTY );
		
	}
}

/*
===========
Joy_AdvancedUpdate_f
===========
*/
void Joy_AdvancedUpdate_f (void)
{

	// called once by IN_ReadJoystick and by user whenever an update is needed
	// cvars are now available
	int	i;
	DWORD dwTemp;

	// initialize all the maps
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		dwAxisMap[i] = AxisNada;
		dwControlMap[i] = JOY_ABSOLUTE_AXIS;
		pdwRawValue[i] = RawValuePointer(i);
	}

	if( joy_advanced->value == 0.0)
	{
		// default joystick initialization
		// 2 axes only with joystick control
		dwAxisMap[JOY_AXIS_X] = AxisTurn;
		// dwControlMap[JOY_AXIS_X] = JOY_ABSOLUTE_AXIS;
		dwAxisMap[JOY_AXIS_Y] = AxisForward;
		// dwControlMap[JOY_AXIS_Y] = JOY_ABSOLUTE_AXIS;
	}
	else
	{
		if ( strcmp ( joy_name->string, "joystick") != 0 )
		{
			// notify user of advanced controller
			gEngfuncs.Con_Printf ("\n%s configured\n\n", joy_name->string);
		}

		// advanced initialization here
		// data supplied by user via joy_axisn cvars
		dwTemp = (DWORD) joy_advaxisx->value;
		dwAxisMap[JOY_AXIS_X] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_X] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisy->value;
		dwAxisMap[JOY_AXIS_Y] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Y] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisz->value;
		dwAxisMap[JOY_AXIS_Z] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Z] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisr->value;
		dwAxisMap[JOY_AXIS_R] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_R] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisu->value;
		dwAxisMap[JOY_AXIS_U] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_U] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisv->value;
		dwAxisMap[JOY_AXIS_V] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_V] = dwTemp & JOY_RELATIVE_AXIS;
	}
}


/*
===========
IN_Commands
===========
*/
void IN_Commands (void)
{
	int		i, key_index;

	if (!joy_avail)
	{
		return;
	}

	DWORD	buttonstate, povstate;
	
	// loop through the joystick buttons
	// key a joystick event or auxiliary event for higher number buttons for each state change
	buttonstate = 0;
	for ( i = 0; i < SDL_CONTROLLER_BUTTON_MAX; i++ )
	{
		if ( SDL_GameControllerGetButton( s_pJoystick, (SDL_GameControllerButton)i ) )
		{
			buttonstate |= 1<<i;
		}
	}
	
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		pdwRawValue[i] = RawValuePointer(i);
	}

	for (i=0 ; i < (int)joy_numbuttons ; i++)
	{
		if ( (buttonstate & (1<<i)) && !(joy_oldbuttonstate & (1<<i)) )
		{
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			gEngfuncs.Key_Event (key_index + i, 1);
		}

		if ( !(buttonstate & (1<<i)) && (joy_oldbuttonstate & (1<<i)) )
		{
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			gEngfuncs.Key_Event (key_index + i, 0);
		}
	}
	joy_oldbuttonstate = buttonstate;

	if (joy_haspov)
	{
		// convert POV information into 4 bits of state information
		// this avoids any potential problems related to moving from one
		// direction to another without going through the center position
		povstate = 0;
		// determine which bits have changed and key an auxiliary event for each change
		for (i=0 ; i < 4 ; i++)
		{
			if ( (povstate & (1<<i)) && !(joy_oldpovstate & (1<<i)) )
			{
				gEngfuncs.Key_Event (K_AUX29 + i, 1);
			}

			if ( !(povstate & (1<<i)) && (joy_oldpovstate & (1<<i)) )
			{
				gEngfuncs.Key_Event (K_AUX29 + i, 0);
			}
		}
		joy_oldpovstate = povstate;
	}
}


/* 
=============== 
IN_ReadJoystick
=============== 
*/  
int IN_ReadJoystick (void)
{
	SDL_JoystickUpdate();
	return 1;
}


/*
===========
IN_JoyMove
===========
*/
void IN_JoyMove ( float frametime, usercmd_t *cmd )
{
	float	speed, aspeed;
	float	fAxisValue, fTemp;
	int		i;
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );


	// complete initialization if first time in
	// this is needed as cvars are not available at initialization time
	if( joy_advancedinit != 1 )
	{
		Joy_AdvancedUpdate_f();
		joy_advancedinit = 1;
	}

	// verify joystick is available and that the user wants to use it
	if (!joy_avail || !in_joystick->value)
	{
		return; 
	}
 
	// collect the joystick data, if possible
	if (IN_ReadJoystick () != 1)
	{
		return;
	}

	if (in_speed.state & 1)
		speed = cl_movespeedkey->value;
	else
		speed = 1;

	aspeed = speed * frametime;

	// loop through the axes
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		// get the floating point zero-centered, potentially-inverted data for the current axis
		fAxisValue = (float)pdwRawValue[i];

		if (joy_wwhack2->value != 0.0)
		{
			if (dwAxisMap[i] == AxisTurn)
			{
				// this is a special formula for the Logitech WingMan Warrior
				// y=ax^b; where a = 300 and b = 1.3
				// also x values are in increments of 800 (so this is factored out)
				// then bounds check result to level out excessively high spin rates
				fTemp = 300.0 * pow(abs(fAxisValue) / 800.0, 1.3);
				if (fTemp > 14000.0)
					fTemp = 14000.0;
				// restore direction information
				fAxisValue = (fAxisValue > 0.0) ? fTemp : -fTemp;
			}
		}

		// convert range from -32768..32767 to -1..1 
		fAxisValue /= 32768.0;

		switch (dwAxisMap[i])
		{
		case AxisForward:
			if ((joy_advanced->value == 0.0) && (in_jlook.state & 1))
			{
				// user wants forward control to become look control
				if (fabs(fAxisValue) > joy_pitchthreshold->value)
				{		
					// if mouse invert is on, invert the joystick pitch value
					// only absolute control support here (joy_advanced is 0)
					if (m_pitch->value < 0.0)
					{
						viewangles[PITCH] -= (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
					else
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
				}
			}
			else
			{
				// user wants forward control to be forward control
				if (fabs(fAxisValue) > joy_forwardthreshold->value)
				{
					cmd->forwardmove += (fAxisValue * joy_forwardsensitivity->value) * speed * cl_forwardspeed->value;
				}
			}
			break;

		case AxisSide:
			if (fabs(fAxisValue) > joy_sidethreshold->value)
			{
				cmd->sidemove += (fAxisValue * joy_sidesensitivity->value) * speed * cl_sidespeed->value;
			}
			break;

		case AxisTurn:
			if ((in_strafe.state & 1) || (lookstrafe->value && (in_jlook.state & 1)))
			{
				// user wants turn control to become side control
				if (fabs(fAxisValue) > joy_sidethreshold->value)
				{
					cmd->sidemove -= (fAxisValue * joy_sidesensitivity->value) * speed * cl_sidespeed->value;
				}
			}
			else
			{
				// user wants turn control to be turn control
				if (fabs(fAxisValue) > joy_yawthreshold->value)
				{
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						viewangles[YAW] += (fAxisValue * joy_yawsensitivity->value) * aspeed * cl_yawspeed->value;
					}
					else
					{
						viewangles[YAW] += (fAxisValue * joy_yawsensitivity->value) * speed * 180.0;
					}

				}
			}
			break;

		case AxisLook:
			if (in_jlook.state & 1)
			{
				if (fabs(fAxisValue) > joy_pitchthreshold->value)
				{
					// pitch movement detected and pitch movement desired by user
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
					else
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * speed * 180.0;
					}
				}
			}
			break;

		default:
			break;
		}
	}

	// bounds check pitch
	if (viewangles[PITCH] > cl_pitchdown->value)
		viewangles[PITCH] = cl_pitchdown->value;
	if (viewangles[PITCH] < -cl_pitchup->value)
		viewangles[PITCH] = -cl_pitchup->value;

	gEngfuncs.SetViewAngles( (float *)viewangles );
}

/*
===========
IN_Move
===========
*/
void IN_Move ( float frametime, usercmd_t *cmd)
{
	if ( !iMouseInUse && mouseactive )
	{
		IN_MouseMove ( frametime, cmd);
	}

	IN_JoyMove ( frametime, cmd);
}

/*
===========
IN_Init
===========
*/
void IN_Init (void)
{
	m_filter				= gEngfuncs.pfnRegisterVariable ( "m_filter","0", FCVAR_ARCHIVE );
	sensitivity				= gEngfuncs.pfnRegisterVariable ( "sensitivity","3", FCVAR_ARCHIVE ); // user mouse sensitivity setting.

	in_joystick				= gEngfuncs.pfnRegisterVariable ( "joystick","0", FCVAR_ARCHIVE );
	joy_name				= gEngfuncs.pfnRegisterVariable ( "joyname", "joystick", 0 );
	joy_advanced			= gEngfuncs.pfnRegisterVariable ( "joyadvanced", "0", 0 );
	joy_advaxisx			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisx", "0", 0 );
	joy_advaxisy			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisy", "0", 0 );
	joy_advaxisz			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisz", "0", 0 );
	joy_advaxisr			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisr", "0", 0 );
	joy_advaxisu			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisu", "0", 0 );
	joy_advaxisv			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisv", "0", 0 );
	joy_forwardthreshold	= gEngfuncs.pfnRegisterVariable ( "joyforwardthreshold", "0.15", 0 );
	joy_sidethreshold		= gEngfuncs.pfnRegisterVariable ( "joysidethreshold", "0.15", 0 );
	joy_pitchthreshold		= gEngfuncs.pfnRegisterVariable ( "joypitchthreshold", "0.15", 0 );
	joy_yawthreshold		= gEngfuncs.pfnRegisterVariable ( "joyyawthreshold", "0.15", 0 );
	joy_forwardsensitivity	= gEngfuncs.pfnRegisterVariable ( "joyforwardsensitivity", "-1.0", 0 );
	joy_sidesensitivity		= gEngfuncs.pfnRegisterVariable ( "joysidesensitivity", "-1.0", 0 );
	joy_pitchsensitivity	= gEngfuncs.pfnRegisterVariable ( "joypitchsensitivity", "1.0", 0 );
	joy_yawsensitivity		= gEngfuncs.pfnRegisterVariable ( "joyyawsensitivity", "-1.0", 0 );
	joy_wwhack1				= gEngfuncs.pfnRegisterVariable ( "joywwhack1", "0.0", 0 );
	joy_wwhack2				= gEngfuncs.pfnRegisterVariable ( "joywwhack2", "0.0", 0 );

	m_customaccel			= gEngfuncs.pfnRegisterVariable ( "m_customaccel", "0", FCVAR_ARCHIVE );
	m_customaccel_scale		= gEngfuncs.pfnRegisterVariable ( "m_customaccel_scale", "0.04", FCVAR_ARCHIVE );
	m_customaccel_max		= gEngfuncs.pfnRegisterVariable ( "m_customaccel_max", "0", FCVAR_ARCHIVE );
	m_customaccel_exponent	= gEngfuncs.pfnRegisterVariable ( "m_customaccel_exponent", "1", FCVAR_ARCHIVE );

#ifdef _WIN32
	m_bRawInput				= CVAR_GET_FLOAT( "m_rawinput" ) > 0;
	m_bMouseThread			= gEngfuncs.CheckParm ("-mousethread", NULL ) != NULL;
	m_mousethread_sleep			= gEngfuncs.pfnRegisterVariable ( "m_mousethread_sleep", "10", FCVAR_ARCHIVE );

	if ( !m_bRawInput && m_bMouseThread && m_mousethread_sleep ) 
	{
		s_mouseDeltaX = s_mouseDeltaY = 0;
		
		s_hMouseQuitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
		if ( s_hMouseQuitEvent )
		{
			s_hMouseThread = CreateThread( NULL, 0, MousePos_ThreadFunction, NULL, 0, &s_hMouseThreadId );
		}
	}
#endif

	gEngfuncs.pfnAddCommand ("force_centerview", Force_CenterView_f);
	gEngfuncs.pfnAddCommand ("joyadvancedupdate", Joy_AdvancedUpdate_f);

	IN_StartupMouse ();
	IN_StartupJoystick ();
}

```

`cl_dll/input_xash3d.cpp`:

```cpp
#include "hud.h"
#include "usercmd.h"
#include "cvardef.h"
#include "kbutton.h"
#include "keydefs.h"
#include "input.h"

#define	PITCH	0
#define	YAW		1
#define	ROLL	2 

cvar_t	*cl_laddermode;
cvar_t	*sensitivity;
cvar_t	*in_joystick;
cvar_t	*evdev_grab;


float ac_forwardmove;
float ac_sidemove;
int ac_movecount;
float rel_yaw;
float rel_pitch;
bool bMouseInUse = false;

extern Vector dead_viewangles;
extern bool evdev_open;

#define F 1U<<0	// Forward
#define B 1U<<1	// Back
#define L 1U<<2	// Left
#define R 1U<<3	// Right
#define T 1U<<4	// Forward stop
#define S 1U<<5	// Side stop

#define BUTTON_DOWN		1
#define IMPULSE_DOWN	2
#define IMPULSE_UP		4

bool CL_IsDead();

void IN_ToggleButtons( float forwardmove, float sidemove )
{
	static unsigned int moveflags = T | S;

	if( forwardmove )
		moveflags &= ~T;
	else
	{
		//if( in_forward.state || in_back.state ) gEngfuncs.Con_Printf("Buttons pressed f%d b%d\n", in_forward.state, in_back.state);
		if( !( moveflags & T ) )
		{
			//IN_ForwardUp();
			//IN_BackUp();
			//gEngfuncs.Con_Printf("Reset forwardmove state f%d b%d\n", in_forward.state, in_back.state);
			in_forward.state &= ~BUTTON_DOWN;
			in_back.state &= ~BUTTON_DOWN;
			moveflags |= T;
		}
	}
	if( sidemove )
		moveflags &= ~S;
	else
	{
		//gEngfuncs.Con_Printf("l%d r%d\n", in_moveleft.state, in_moveright.state);
		//if( in_moveleft.state || in_moveright.state ) gEngfuncs.Con_Printf("Buttons pressed l%d r%d\n", in_moveleft.state, in_moveright.state);
		if( !( moveflags & S ) )
		{
			//IN_MoverightUp();
			//IN_MoveleftUp();
			//gEngfuncs.Con_Printf("Reset sidemove state f%d b%d\n", in_moveleft.state, in_moveright.state);
			in_moveleft.state &= ~BUTTON_DOWN;
			in_moveright.state &= ~BUTTON_DOWN;
			moveflags |= S;
		}
	}

	if ( forwardmove > 0.7 && !( moveflags & F ))
	{
		moveflags |= F;
		in_forward.state |= BUTTON_DOWN;
	}
	if ( forwardmove < 0.7 && ( moveflags & F ))
	{
		moveflags &= ~F;
		in_forward.state &= ~BUTTON_DOWN;
	}
	if ( forwardmove < -0.7 && !( moveflags & B ))
	{
		moveflags |= B;
		in_back.state |= BUTTON_DOWN;
	}
	if ( forwardmove > -0.7 && ( moveflags & B ))
	{
		moveflags &= ~B;
		in_back.state &= ~BUTTON_DOWN;
	}
	if ( sidemove > 0.9 && !( moveflags & R ))
	{
		moveflags |= R;
		in_moveright.state |= BUTTON_DOWN;
	}
	if ( sidemove < 0.9 && ( moveflags & R ))
	{
		moveflags &= ~R;
		in_moveright.state &= ~BUTTON_DOWN;
	}
	if ( sidemove < -0.9 && !( moveflags & L ))
	{
		moveflags |= L;
		in_moveleft.state |= BUTTON_DOWN;
	}
	if ( sidemove > -0.9 && ( moveflags & L ))
	{
		moveflags &= ~L;
		in_moveleft.state &= ~BUTTON_DOWN;
	}

}

void IN_ClientMoveEvent( float forwardmove, float sidemove )
{
	//gEngfuncs.Con_Printf("IN_MoveEvent\n");

	ac_forwardmove += forwardmove;
	ac_sidemove += sidemove;
	ac_movecount++;
}

void IN_ClientLookEvent( float relyaw, float relpitch )
{
#ifdef __ANDROID__
	if( evdev_open || bMouseInUse ) return;
#endif
	rel_yaw += relyaw;
	rel_pitch += relpitch;
}

// Rotate camera and add move values to usercmd
void IN_Move( float frametime, usercmd_t *cmd )
{
#ifdef __ANDROID__
	if( bMouseInUse )
		return;
#endif
	Vector viewangles;
	bool bLadder = false;

	if( gHUD.m_iIntermission )
		return; // we can't move during intermission


	if( cl_laddermode->value != 2 )
	{
		cl_entity_t *pplayer = gEngfuncs.GetLocalPlayer();
		if( pplayer )
			bLadder = pplayer->curstate.movetype == MOVETYPE_FLY;
	}
	//if(ac_forwardmove || ac_sidemove)
	//gEngfuncs.Con_Printf("Move: %f %f %f %f\n", ac_forwardmove, ac_sidemove, rel_pitch, rel_yaw);
#if 0
	if( in_mlook.state & 1 )
	{
		V_StopPitchDrift();
	}
#endif

	if( CL_IsDead( ) )
	{
		viewangles = dead_viewangles; // HACKHACK: see below
	}
	else
	{
		gEngfuncs.GetViewAngles( viewangles );
	}

	if( gHUD.GetSensitivity() != 0 )
	{
		rel_yaw *= gHUD.GetSensitivity();
		rel_pitch *= gHUD.GetSensitivity();
	}
	else
	{
		rel_yaw *= sensitivity->value;
		rel_pitch *= sensitivity->value;
	}
	if(gHUD.m_MOTD.cl_hide_motd->value == 0.0f && gHUD.m_MOTD.m_bShow)
	{
		gHUD.m_MOTD.scroll += rel_pitch;
	}
	else
	{
		viewangles[PITCH] += rel_pitch;
		viewangles[YAW] += rel_yaw;
		if( bLadder )
		{
			if( ( cl_laddermode->value == 1 ) )
				viewangles[YAW] -= ac_sidemove * 5;
			ac_sidemove = 0;
		}
	}
	if (viewangles[PITCH] > cl_pitchdown->value)
		viewangles[PITCH] = cl_pitchdown->value;
	if (viewangles[PITCH] < -cl_pitchup->value)
		viewangles[PITCH] = -cl_pitchup->value;


	if( !CL_IsDead( ) )
	{
		gEngfuncs.SetViewAngles( viewangles );
	}

	dead_viewangles = viewangles;
	
	if( ac_movecount )
	{
		IN_ToggleButtons( ac_forwardmove / ac_movecount, ac_sidemove / ac_movecount );
		if( ac_forwardmove ) cmd->forwardmove  = ac_forwardmove * cl_forwardspeed->value / ac_movecount;
		if( ac_sidemove ) cmd->sidemove  = ac_sidemove * cl_sidespeed->value / ac_movecount;
		if (in_speed.state & 1)
		{
			cmd->forwardmove *= cl_movespeedkey->value;
			cmd->sidemove *= cl_movespeedkey->value;
		}
	}
	
	ac_sidemove = ac_forwardmove = rel_pitch = rel_yaw = 0;
	ac_movecount = 0;
}

void DLLEXPORT IN_MouseEvent( int mstate )
{
	static int mouse_oldbuttonstate;
	// perform button actions
	for( int i = 0; i < 5; i++ )
	{
		if(( mstate & (1 << i)) && !( mouse_oldbuttonstate & (1 << i)))
		{
			gEngfuncs.Key_Event( K_MOUSE1 + i, 1 );
		}

		if( !( mstate & (1 << i)) && ( mouse_oldbuttonstate & (1 << i)))
		{
			gEngfuncs.Key_Event( K_MOUSE1 + i, 0 );
		}
	}	
	
	mouse_oldbuttonstate = mstate;
	bMouseInUse = true;
}

// Stubs

void DLLEXPORT IN_ClearStates ( void )
{
	//gEngfuncs.Con_Printf("IN_ClearStates\n");
}

void  DLLEXPORT IN_ActivateMouse ( void )
{
	//gEngfuncs.Con_Printf("IN_ActivateMouse\n");
}

void DLLEXPORT  IN_DeactivateMouse ( void )
{
	//gEngfuncs.Con_Printf("IN_DeactivateMouse\n");
}

void DLLEXPORT IN_Accumulate ( void )
{
	//gEngfuncs.Con_Printf("IN_Accumulate\n");
}

void IN_Commands ( void )
{
	//gEngfuncs.Con_Printf("IN_Commands\n");
}

void IN_Shutdown ( void )
{
}
// Register cvars and reset data
void IN_Init( void )
{
	sensitivity = gEngfuncs.pfnRegisterVariable ( "sensitivity", "3", FCVAR_ARCHIVE );
	in_joystick = gEngfuncs.pfnRegisterVariable ( "joystick", "0", FCVAR_ARCHIVE );
	cl_laddermode = gEngfuncs.pfnRegisterVariable ( "cl_laddermode", "2", FCVAR_ARCHIVE );
	evdev_grab = gEngfuncs.pfnGetCvarPointer("evdev_grab");
	
	
#ifdef __ANDROID__
	gEngfuncs.Cvar_SetValue("m_yaw", -1);
	gEngfuncs.Cvar_SetValue("m_pitch", -1);
	gEngfuncs.pfnSetMouseEnable( false );
#endif

	ac_forwardmove = ac_sidemove = rel_yaw = rel_pitch = 0;
}

```

`cl_dll/inputw32.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// in_win.c -- windows 95 mouse and joystick code
// 02/21/97 JCB Added extended DirectInput code to support external controllers.

#include "hud.h"
#include "cl_util.h"
#include "camera.h"
#include "kbutton.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"
#include "camera.h"
#include "in_defs.h"
#include "../engine/keydefs.h"
#include "view.h"
#include "port.h"

#define MOUSE_BUTTON_COUNT 5

// Set this to 1 to show mouse cursor.  Experimental
int	g_iVisibleMouse = 0;

extern "C" 
{
	void DLLEXPORT IN_ActivateMouse( void );
	void DLLEXPORT IN_DeactivateMouse( void );
	void DLLEXPORT IN_MouseEvent (int mstate);
	void DLLEXPORT IN_Accumulate (void);
	void DLLEXPORT IN_ClearStates (void);
}

extern cl_enginefunc_t gEngfuncs;

extern int iMouseInUse;

extern kbutton_t	in_strafe;
extern kbutton_t	in_mlook;
extern kbutton_t	in_speed;
extern kbutton_t	in_jlook;

extern cvar_t	*m_pitch;
extern cvar_t	*m_yaw;
extern cvar_t	*m_forward;
extern cvar_t	*m_side;

extern cvar_t *lookstrafe;
extern cvar_t *lookspring;
extern cvar_t *cl_pitchdown;
extern cvar_t *cl_pitchup;
extern cvar_t *cl_yawspeed;
extern cvar_t *cl_sidespeed;
extern cvar_t *cl_forwardspeed;
extern cvar_t *cl_pitchspeed;
extern cvar_t *cl_movespeedkey;

// mouse variables
cvar_t		*m_filter;
cvar_t		*sensitivity;

int			mouse_buttons;
int			mouse_oldbuttonstate;
POINT		current_pos;
int			mouse_x, mouse_y, old_mouse_x, old_mouse_y, mx_accum, my_accum;

static int	restore_spi;
static int	originalmouseparms[3], newmouseparms[3] = {0, 0, 1};
static int	mouseactive;
int			mouseinitialized;
static int	mouseparmsvalid;
static int	mouseshowtoggle = 1;

// joystick defines and variables
// where should defines be moved?
#define JOY_ABSOLUTE_AXIS	0x00000000		// control like a joystick
#define JOY_RELATIVE_AXIS	0x00000010		// control like a mouse, spinner, trackball
#define	JOY_MAX_AXES		6				// X, Y, Z, R, U, V
#define JOY_AXIS_X			0
#define JOY_AXIS_Y			1
#define JOY_AXIS_Z			2
#define JOY_AXIS_R			3
#define JOY_AXIS_U			4
#define JOY_AXIS_V			5

enum _ControlList
{
	AxisNada = 0,
	AxisForward,
	AxisLook,
	AxisSide,
	AxisTurn
};

DWORD dwAxisFlags[JOY_MAX_AXES] =
{
	JOY_RETURNX,
	JOY_RETURNY,
	JOY_RETURNZ,
	JOY_RETURNR,
	JOY_RETURNU,
	JOY_RETURNV
};

DWORD	dwAxisMap[ JOY_MAX_AXES ];
DWORD	dwControlMap[ JOY_MAX_AXES ];
PDWORD	pdwRawValue[ JOY_MAX_AXES ];

// none of these cvars are saved over a session
// this means that advanced controller configuration needs to be executed
// each time.  this avoids any problems with getting back to a default usage
// or when changing from one controller to another.  this way at least something
// works.
cvar_t	*in_joystick;
cvar_t	*joy_name;
cvar_t	*joy_advanced;
cvar_t	*joy_advaxisx;
cvar_t	*joy_advaxisy;
cvar_t	*joy_advaxisz;
cvar_t	*joy_advaxisr;
cvar_t	*joy_advaxisu;
cvar_t	*joy_advaxisv;
cvar_t	*joy_forwardthreshold;
cvar_t	*joy_sidethreshold;
cvar_t	*joy_pitchthreshold;
cvar_t	*joy_yawthreshold;
cvar_t	*joy_forwardsensitivity;
cvar_t	*joy_sidesensitivity;
cvar_t	*joy_pitchsensitivity;
cvar_t	*joy_yawsensitivity;
cvar_t	*joy_wwhack1;
cvar_t	*joy_wwhack2;

int			joy_avail, joy_advancedinit, joy_haspov;
DWORD		joy_oldbuttonstate, joy_oldpovstate;

int			joy_id;
DWORD		joy_flags;
DWORD		joy_numbuttons;

static JOYINFOEX	ji;

/*
===========
Force_CenterView_f
===========
*/
void Force_CenterView_f (void)
{
	vec3_t viewangles;

	if (!iMouseInUse)
	{
		gEngfuncs.GetViewAngles( (float *)viewangles );
	    viewangles[PITCH] = 0;
		gEngfuncs.SetViewAngles( (float *)viewangles );
	}
}

/*
===========
IN_ActivateMouse
===========
*/
void DLLEXPORT IN_ActivateMouse (void)
{
	if (mouseinitialized)
	{
		if (mouseparmsvalid)
			restore_spi = SystemParametersInfo (SPI_SETMOUSE, 0, newmouseparms, 0);
		mouseactive = 1;
	}
}

/*
===========
IN_DeactivateMouse
===========
*/
void DLLEXPORT IN_DeactivateMouse (void)
{
	if (mouseinitialized)
	{
		if (restore_spi)
			SystemParametersInfo (SPI_SETMOUSE, 0, originalmouseparms, 0);

		mouseactive = 0;
	}
}

/*
===========
IN_StartupMouse
===========
*/
void IN_StartupMouse (void)
{
	if ( gEngfuncs.CheckParm ("-nomouse", NULL ) ) 
		return; 

	mouseinitialized = 1;
	mouseparmsvalid = SystemParametersInfo (SPI_GETMOUSE, 0, originalmouseparms, 0);

	if (mouseparmsvalid)
	{
		if ( gEngfuncs.CheckParm ("-noforcemspd", NULL ) ) 
			newmouseparms[2] = originalmouseparms[2];

		if ( gEngfuncs.CheckParm ("-noforcemaccel", NULL ) ) 
		{
			newmouseparms[0] = originalmouseparms[0];
			newmouseparms[1] = originalmouseparms[1];
		}

		if ( gEngfuncs.CheckParm ("-noforcemparms", NULL ) ) 
		{
			newmouseparms[0] = originalmouseparms[0];
			newmouseparms[1] = originalmouseparms[1];
			newmouseparms[2] = originalmouseparms[2];
		}
	}

	mouse_buttons = MOUSE_BUTTON_COUNT;
}

/*
===========
IN_Shutdown
===========
*/
void IN_Shutdown (void)
{
	IN_DeactivateMouse ();
}

/*
===========
IN_GetMousePos

Ask for mouse position from engine
===========
*/
void IN_GetMousePos( int *mx, int *my )
{
	gEngfuncs.GetMousePosition( mx, my );
}

/*
===========
IN_ResetMouse

FIXME: Call through to engine?
===========
*/
void IN_ResetMouse( void )
{
	SetCursorPos ( gEngfuncs.GetWindowCenterX(), gEngfuncs.GetWindowCenterY() );	
}

/*
===========
IN_MouseEvent
===========
*/
void DLLEXPORT IN_MouseEvent (int mstate)
{
	int		i;

	if ( iMouseInUse || g_iVisibleMouse )
		return;

	// perform button actions
	for (i=0 ; i<mouse_buttons ; i++)
	{
		if ( (mstate & (1<<i)) &&
			!(mouse_oldbuttonstate & (1<<i)) )
		{
			gEngfuncs.Key_Event (K_MOUSE1 + i, 1);
		}

		if ( !(mstate & (1<<i)) &&
			(mouse_oldbuttonstate & (1<<i)) )
		{
			gEngfuncs.Key_Event (K_MOUSE1 + i, 0);
		}
	}	
	
	mouse_oldbuttonstate = mstate;
}

/*
===========
IN_MouseMove
===========
*/
void IN_MouseMove ( float frametime, usercmd_t *cmd)
{
	int		mx, my;
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );

#if 0
	if ( in_mlook.state & 1)
	{
		V_StopPitchDrift ();
	}
#endif

	//jjb - this disbles normal mouse control if the user is trying to 
	//      move the camera, or if the mouse cursor is visible or if we're in intermission
	if ( !iMouseInUse && !g_iVisibleMouse && !gHUD.m_iIntermission )
	{
		GetCursorPos (&current_pos);

		mx = current_pos.x - gEngfuncs.GetWindowCenterX() + mx_accum;
		my = current_pos.y - gEngfuncs.GetWindowCenterY() + my_accum;

		mx_accum = 0;
		my_accum = 0;

		if (m_filter->value)
		{
			mouse_x = (mx + old_mouse_x) * 0.5;
			mouse_y = (my + old_mouse_y) * 0.5;
		}
		else
		{
			mouse_x = mx;
			mouse_y = my;
		}

		old_mouse_x = mx;
		old_mouse_y = my;

		if ( gHUD.GetSensitivity() != 0 )
		{
			mouse_x *= gHUD.GetSensitivity();
			mouse_y *= gHUD.GetSensitivity();
		}
		else
		{
			mouse_x *= sensitivity->value;
			mouse_y *= sensitivity->value;
		}

		// add mouse X/Y movement to cmd
		if ( (in_strafe.state & 1) || (lookstrafe->value && (in_mlook.state & 1) ))
			cmd->sidemove += m_side->value * mouse_x;
		else
			viewangles[YAW] -= m_yaw->value * mouse_x;

		if ( (in_mlook.state & 1) && !(in_strafe.state & 1))
		{
			viewangles[PITCH] += m_pitch->value * mouse_y;
			if (viewangles[PITCH] > cl_pitchdown->value)
				viewangles[PITCH] = cl_pitchdown->value;
			if (viewangles[PITCH] < -cl_pitchup->value)
				viewangles[PITCH] = -cl_pitchup->value;
		}
		else
		{
			if ((in_strafe.state & 1) && gEngfuncs.IsNoClipping() )
			{
				cmd->upmove -= m_forward->value * mouse_y;
			}
			else
			{
				cmd->forwardmove -= m_forward->value * mouse_y;
			}
		}

		// if the mouse has moved, force it to the center, so there's room to move
		if ( mx || my )
		{
			IN_ResetMouse();
		}
	}

	gEngfuncs.SetViewAngles( (float *)viewangles );

/*
//#define TRACE_TEST
#if defined( TRACE_TEST )
	{
		int mx, my;
		void V_Move( int mx, int my );
		IN_GetMousePos( &mx, &my );
		V_Move( mx, my );
	}
#endif
*/
}

/*
===========
IN_Accumulate
===========
*/
void DLLEXPORT IN_Accumulate (void)
{
	//only accumulate mouse if we are not moving the camera with the mouse
	if ( !iMouseInUse && !g_iVisibleMouse )
	{
	    if (mouseactive)
	    {
			GetCursorPos (&current_pos);

			mx_accum += current_pos.x - gEngfuncs.GetWindowCenterX();
			my_accum += current_pos.y - gEngfuncs.GetWindowCenterY();

			// force the mouse to the center, so there's room to move
			IN_ResetMouse();
		}
	}

}

/*
===================
IN_ClearStates
===================
*/
void DLLEXPORT IN_ClearStates (void)
{
	if ( !mouseactive )
		return;

	mx_accum = 0;
	my_accum = 0;
	mouse_oldbuttonstate = 0;
}

/* 
=============== 
IN_StartupJoystick 
=============== 
*/  
void IN_StartupJoystick (void) 
{ 
	int			numdevs;
	JOYCAPS		jc;
	MMRESULT	mmr;
 
 	// assume no joystick
	joy_avail = 0; 

	// abort startup if user requests no joystick
	if ( gEngfuncs.CheckParm ("-nojoy", NULL ) ) 
		return; 
 
	// verify joystick driver is present
	if ((numdevs = joyGetNumDevs ()) == 0)
	{
		gEngfuncs.Con_DPrintf ("joystick not found -- driver not present\n\n");
		return;
	}

	// cycle through the joystick ids for the first valid one
	for (joy_id=0 ; joy_id<numdevs ; joy_id++)
	{
		memset (&ji, 0, sizeof(ji));
		ji.dwSize = sizeof(ji);
		ji.dwFlags = JOY_RETURNCENTERED;

		if ((mmr = joyGetPosEx (joy_id, &ji)) == JOYERR_NOERROR)
			break;
	} 

	// abort startup if we didn't find a valid joystick
	if (mmr != JOYERR_NOERROR)
	{
		gEngfuncs.Con_DPrintf ("joystick not found -- no valid joysticks (%x)\n\n", mmr);
		return;
	}

	// get the capabilities of the selected joystick
	// abort startup if command fails
	memset (&jc, 0, sizeof(jc));
	if ((mmr = joyGetDevCaps (joy_id, &jc, sizeof(jc))) != JOYERR_NOERROR)
	{
		gEngfuncs.Con_DPrintf ("joystick not found -- invalid joystick capabilities (%x)\n\n", mmr); 
		return;
	}

	// save the joystick's number of buttons and POV status
	joy_numbuttons = jc.wNumButtons;
	joy_haspov = jc.wCaps & JOYCAPS_HASPOV;

	// old button and POV states default to no buttons pressed
	joy_oldbuttonstate = joy_oldpovstate = 0;

	// mark the joystick as available and advanced initialization not completed
	// this is needed as cvars are not available during initialization
	gEngfuncs.Con_Printf ("joystick found\n\n", mmr); 
	joy_avail = 1; 
	joy_advancedinit = 0;
}


/*
===========
RawValuePointer
===========
*/
PDWORD RawValuePointer (int axis)
{
	switch (axis)
	{
	case JOY_AXIS_X:
		return &ji.dwXpos;
	case JOY_AXIS_Y:
		return &ji.dwYpos;
	case JOY_AXIS_Z:
		return &ji.dwZpos;
	case JOY_AXIS_R:
		return &ji.dwRpos;
	case JOY_AXIS_U:
		return &ji.dwUpos;
	case JOY_AXIS_V:
		return &ji.dwVpos;
	}
	// FIX: need to do some kind of error
	return &ji.dwXpos;
}


/*
===========
Joy_AdvancedUpdate_f
===========
*/
void Joy_AdvancedUpdate_f (void)
{

	// called once by IN_ReadJoystick and by user whenever an update is needed
	// cvars are now available
	int	i;
	DWORD dwTemp;

	// initialize all the maps
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		dwAxisMap[i] = AxisNada;
		dwControlMap[i] = JOY_ABSOLUTE_AXIS;
		pdwRawValue[i] = RawValuePointer(i);
	}

	if( joy_advanced->value == 0.0)
	{
		// default joystick initialization
		// 2 axes only with joystick control
		dwAxisMap[JOY_AXIS_X] = AxisTurn;
		// dwControlMap[JOY_AXIS_X] = JOY_ABSOLUTE_AXIS;
		dwAxisMap[JOY_AXIS_Y] = AxisForward;
		// dwControlMap[JOY_AXIS_Y] = JOY_ABSOLUTE_AXIS;
	}
	else
	{
		if ( strcmp ( joy_name->string, "joystick") != 0 )
		{
			// notify user of advanced controller
			gEngfuncs.Con_Printf ("\n%s configured\n\n", joy_name->string);
		}

		// advanced initialization here
		// data supplied by user via joy_axisn cvars
		dwTemp = (DWORD) joy_advaxisx->value;
		dwAxisMap[JOY_AXIS_X] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_X] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisy->value;
		dwAxisMap[JOY_AXIS_Y] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Y] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisz->value;
		dwAxisMap[JOY_AXIS_Z] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Z] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisr->value;
		dwAxisMap[JOY_AXIS_R] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_R] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisu->value;
		dwAxisMap[JOY_AXIS_U] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_U] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisv->value;
		dwAxisMap[JOY_AXIS_V] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_V] = dwTemp & JOY_RELATIVE_AXIS;
	}

	// compute the axes to collect from DirectInput
	joy_flags = JOY_RETURNCENTERED | JOY_RETURNBUTTONS | JOY_RETURNPOV;
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		if (dwAxisMap[i] != AxisNada)
		{
			joy_flags |= dwAxisFlags[i];
		}
	}
}


/*
===========
IN_Commands
===========
*/
void IN_Commands (void)
{
	int		i, key_index;
	DWORD	buttonstate, povstate;

	if (!joy_avail)
	{
		return;
	}

	
	// loop through the joystick buttons
	// key a joystick event or auxiliary event for higher number buttons for each state change
	buttonstate = ji.dwButtons;
	for (i=0 ; i < (int)joy_numbuttons ; i++)
	{
		if ( (buttonstate & (1<<i)) && !(joy_oldbuttonstate & (1<<i)) )
		{
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			gEngfuncs.Key_Event (key_index + i, 1);
		}

		if ( !(buttonstate & (1<<i)) && (joy_oldbuttonstate & (1<<i)) )
		{
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			gEngfuncs.Key_Event (key_index + i, 0);
		}
	}
	joy_oldbuttonstate = buttonstate;

	if (joy_haspov)
	{
		// convert POV information into 4 bits of state information
		// this avoids any potential problems related to moving from one
		// direction to another without going through the center position
		povstate = 0;
		if(ji.dwPOV != JOY_POVCENTERED)
		{
			if (ji.dwPOV == JOY_POVFORWARD)
				povstate |= 0x01;
			if (ji.dwPOV == JOY_POVRIGHT)
				povstate |= 0x02;
			if (ji.dwPOV == JOY_POVBACKWARD)
				povstate |= 0x04;
			if (ji.dwPOV == JOY_POVLEFT)
				povstate |= 0x08;
		}
		// determine which bits have changed and key an auxiliary event for each change
		for (i=0 ; i < 4 ; i++)
		{
			if ( (povstate & (1<<i)) && !(joy_oldpovstate & (1<<i)) )
			{
				gEngfuncs.Key_Event (K_AUX29 + i, 1);
			}

			if ( !(povstate & (1<<i)) && (joy_oldpovstate & (1<<i)) )
			{
				gEngfuncs.Key_Event (K_AUX29 + i, 0);
			}
		}
		joy_oldpovstate = povstate;
	}
}


/* 
=============== 
IN_ReadJoystick
=============== 
*/  
int IN_ReadJoystick (void)
{

	memset (&ji, 0, sizeof(ji));
	ji.dwSize = sizeof(ji);
	ji.dwFlags = joy_flags;

	if (joyGetPosEx (joy_id, &ji) == JOYERR_NOERROR)
	{
		// this is a hack -- there is a bug in the Logitech WingMan Warrior DirectInput Driver
		// rather than having 32768 be the zero point, they have the zero point at 32668
		// go figure -- anyway, now we get the full resolution out of the device
		if (joy_wwhack1->value != 0.0)
		{
			ji.dwUpos += 100;
		}
		return 1;
	}
	else
	{
		// read error occurred
		// turning off the joystick seems too harsh for 1 read error,\
		// but what should be done?
		// Con_Printf ("IN_ReadJoystick: no response\n");
		// joy_avail = 0;
		return 0;
	}
}


/*
===========
IN_JoyMove
===========
*/
void IN_JoyMove ( float frametime, usercmd_t *cmd )
{
	float	speed, aspeed;
	float	fAxisValue, fTemp;
	int		i;
	vec3_t viewangles;

	gEngfuncs.GetViewAngles( (float *)viewangles );


	// complete initialization if first time in
	// this is needed as cvars are not available at initialization time
	if( joy_advancedinit != 1 )
	{
		Joy_AdvancedUpdate_f();
		joy_advancedinit = 1;
	}

	// verify joystick is available and that the user wants to use it
	if (!joy_avail || !in_joystick->value)
	{
		return; 
	}
 
	// collect the joystick data, if possible
	if (IN_ReadJoystick () != 1)
	{
		return;
	}

	if (in_speed.state & 1)
		speed = cl_movespeedkey->value;
	else
		speed = 1;

	aspeed = speed * frametime;

	// loop through the axes
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		// get the floating point zero-centered, potentially-inverted data for the current axis
		fAxisValue = (float) *pdwRawValue[i];
		// move centerpoint to zero
		fAxisValue -= 32768.0;

		if (joy_wwhack2->value != 0.0)
		{
			if (dwAxisMap[i] == AxisTurn)
			{
				// this is a special formula for the Logitech WingMan Warrior
				// y=ax^b; where a = 300 and b = 1.3
				// also x values are in increments of 800 (so this is factored out)
				// then bounds check result to level out excessively high spin rates
				fTemp = 300.0 * powf(fabs(fAxisValue) / 800.0, 1.3);
				if (fTemp > 14000.0)
					fTemp = 14000.0;
				// restore direction information
				fAxisValue = (fAxisValue > 0.0) ? fTemp : -fTemp;
			}
		}

		// convert range from -32768..32767 to -1..1 
		fAxisValue /= 32768.0;

		switch (dwAxisMap[i])
		{
		case AxisForward:
			if ((joy_advanced->value == 0.0) && (in_jlook.state & 1))
			{
				// user wants forward control to become look control
				if (fabs(fAxisValue) > joy_pitchthreshold->value)
				{		
					// if mouse invert is on, invert the joystick pitch value
					// only absolute control support here (joy_advanced is 0)
					if (m_pitch->value < 0.0)
					{
						viewangles[PITCH] -= (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
					else
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
#if 0
					V_StopPitchDrift();
#endif
				}
#if 0
				else
				{
					// no pitch movement
					// disable pitch return-to-center unless requested by user
					// *** this code can be removed when the lookspring bug is fixed
					// *** the bug always has the lookspring feature on
					if(lookspring->value == 0.0)
					{
						V_StopPitchDrift();
					}
				}
#endif
			}
			else
			{
				// user wants forward control to be forward control
				if (fabs(fAxisValue) > joy_forwardthreshold->value)
				{
					cmd->forwardmove += (fAxisValue * joy_forwardsensitivity->value) * speed * cl_forwardspeed->value;
				}
			}
			break;

		case AxisSide:
			if (fabs(fAxisValue) > joy_sidethreshold->value)
			{
				cmd->sidemove += (fAxisValue * joy_sidesensitivity->value) * speed * cl_sidespeed->value;
			}
			break;

		case AxisTurn:
			if ((in_strafe.state & 1) || (lookstrafe->value && (in_jlook.state & 1)))
			{
				// user wants turn control to become side control
				if (fabs(fAxisValue) > joy_sidethreshold->value)
				{
					cmd->sidemove -= (fAxisValue * joy_sidesensitivity->value) * speed * cl_sidespeed->value;
				}
			}
			else
			{
				// user wants turn control to be turn control
				if (fabs(fAxisValue) > joy_yawthreshold->value)
				{
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						viewangles[YAW] += (fAxisValue * joy_yawsensitivity->value) * aspeed * cl_yawspeed->value;
					}
					else
					{
						viewangles[YAW] += (fAxisValue * joy_yawsensitivity->value) * speed * 180.0;
					}

				}
			}
			break;

		case AxisLook:
			if (in_jlook.state & 1)
			{
				if (fabs(fAxisValue) > joy_pitchthreshold->value)
				{
					// pitch movement detected and pitch movement desired by user
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * aspeed * cl_pitchspeed->value;
					}
					else
					{
						viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity->value) * speed * 180.0;
					}
#if 0
					V_StopPitchDrift();
#endif
				}
#if 0
				else
				{
					// no pitch movement
					// disable pitch return-to-center unless requested by user
					// *** this code can be removed when the lookspring bug is fixed
					// *** the bug always has the lookspring feature on
					if( lookspring->value == 0.0 )
					{
						V_StopPitchDrift();
					}
				}
#endif
			}
			break;

		default:
			break;
		}
	}

	// bounds check pitch
	if (viewangles[PITCH] > cl_pitchdown->value)
		viewangles[PITCH] = cl_pitchdown->value;
	if (viewangles[PITCH] < -cl_pitchup->value)
		viewangles[PITCH] = -cl_pitchup->value;

	gEngfuncs.SetViewAngles( (float *)viewangles );

}

/*
===========
IN_Move
===========
*/
void IN_Move ( float frametime, usercmd_t *cmd)
{
	if ( !iMouseInUse && mouseactive )
	{
		IN_MouseMove ( frametime, cmd);
	}

	IN_JoyMove ( frametime, cmd);
}

/*
===========
IN_Init
===========
*/
void IN_Init (void)
{
	m_filter				= gEngfuncs.pfnRegisterVariable ( "m_filter","0", FCVAR_ARCHIVE );
	sensitivity				= gEngfuncs.pfnRegisterVariable ( "sensitivity","3", FCVAR_ARCHIVE ); // user mouse sensitivity setting.

	in_joystick				= gEngfuncs.pfnRegisterVariable ( "joystick","0", FCVAR_ARCHIVE );
	joy_name				= gEngfuncs.pfnRegisterVariable ( "joyname", "joystick", 0 );
	joy_advanced			= gEngfuncs.pfnRegisterVariable ( "joyadvanced", "0", 0 );
	joy_advaxisx			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisx", "0", 0 );
	joy_advaxisy			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisy", "0", 0 );
	joy_advaxisz			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisz", "0", 0 );
	joy_advaxisr			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisr", "0", 0 );
	joy_advaxisu			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisu", "0", 0 );
	joy_advaxisv			= gEngfuncs.pfnRegisterVariable ( "joyadvaxisv", "0", 0 );
	joy_forwardthreshold	= gEngfuncs.pfnRegisterVariable ( "joyforwardthreshold", "0.15", 0 );
	joy_sidethreshold		= gEngfuncs.pfnRegisterVariable ( "joysidethreshold", "0.15", 0 );
	joy_pitchthreshold		= gEngfuncs.pfnRegisterVariable ( "joypitchthreshold", "0.15", 0 );
	joy_yawthreshold		= gEngfuncs.pfnRegisterVariable ( "joyyawthreshold", "0.15", 0 );
	joy_forwardsensitivity	= gEngfuncs.pfnRegisterVariable ( "joyforwardsensitivity", "-1.0", 0 );
	joy_sidesensitivity		= gEngfuncs.pfnRegisterVariable ( "joysidesensitivity", "-1.0", 0 );
	joy_pitchsensitivity	= gEngfuncs.pfnRegisterVariable ( "joypitchsensitivity", "1.0", 0 );
	joy_yawsensitivity		= gEngfuncs.pfnRegisterVariable ( "joyyawsensitivity", "-1.0", 0 );
	joy_wwhack1				= gEngfuncs.pfnRegisterVariable ( "joywwhack1", "0.0", 0 );
	joy_wwhack2				= gEngfuncs.pfnRegisterVariable ( "joywwhack2", "0.0", 0 );

	gEngfuncs.pfnAddCommand ("force_centerview", Force_CenterView_f);
	gEngfuncs.pfnAddCommand ("joyadvancedupdate", Joy_AdvancedUpdate_f);

	IN_StartupMouse ();
	IN_StartupJoystick ();
}
```

`cl_dll/rain.cpp`:

```cpp
/***
*
*	Copyright (c) 2005, BUzer.
*	
*	Used with permission for Spirit of Half-Life 1.5
*
****/
/*
====== rain.cpp ========================================================
*/

#include <memory.h>
#include "hud.h"
#include "pm_math.h"
#include "cl_util.h"
#include "const.h"
#include "entity_types.h"
#include "cdll_int.h"
#include "pm_defs.h"
#include "event_api.h"

#include "rain.h"
#include "r_efx.h"
#include "con_nprint.h"
#include "triangleapi.h"
#include "parsemsg.h"
#include <new>


#define DRIPSPEED    900		// speed of raindrips (pixel per secs)
#define SNOWSPEED    200		// speed of snowflakes
#define SNOWFADEDIST 80

#define MAXDRIPS 2000	// max raindrops
#define MAXFX    3000	// max effects

#define DRIP_SPRITE_HALFHEIGHT 64
#define DRIP_SPRITE_HALFWIDTH  1
#define SNOW_SPRITE_HALFSIZE   3

// radius water rings
#define MAXRINGHALFSIZE	25

struct
{
	Vector2D wind;
	Vector2D rand;

	float    distFromPlayer;
	float    globalHeight;

	int      dripsPerSecond;
	int	     weatherMode;	// 0 - snow, 1 - rain
	int      weatherValue;

	float    curtime;    // current time
	float    oldtime;    // last time we have updated drips
	float    timedelta;  // difference between old time and current time
	float    nextspawntime;  // when the next drip should be spawned

	int dripcounter;
	int fxcounter;
	float heightFromPlayer;

	HSPRITE hsprRain;
	HSPRITE hsprSnow;
	HSPRITE hsprRipple;
} Rain;

static bool initialized = false;

enum
{
	NO_LANDING = 0,
	DEFAULT_LANDING,
	WATER_LANDING
};

struct cl_drip_t
{
	Vector		origin;
	float		birthTime;
	float		minHeight;	// minimal height to kill raindrop
	float		alpha;

	Vector2D    Delta; // side speed
	int         land;

	cl_drip_t*		p_Next;		// next drip in chain
	cl_drip_t*		p_Prev;		// previous drip in chain
} FirstChainDrip;

struct cl_rainfx_t
{
	Vector		origin;
	float		birthTime;
	float		life;
	float		alpha;

	int type;

	cl_rainfx_t*		p_Next;		// next fx in chain
	cl_rainfx_t*		p_Prev;		// previous fx in chain
} FirstChainFX;


#ifdef _DEBUG
cvar_t *debug_rain = NULL;
#endif


/*
=================================
WaterLandingEffect
=================================
*/
void LandingEffect( cl_drip_t *drip )
{
	if( drip->land == NO_LANDING )
		return;

	if (Rain.fxcounter >= MAXFX)
	{
		//gEngfuncs.Con_Printf( "Rain error: FX limit overflow!\n" );
		return;
	}

	cl_rainfx_t *newFX = new(std::nothrow) cl_rainfx_t;
	if( !newFX )
	{
		gEngfuncs.Con_Printf( "Rain error: failed to allocate FX object!\n");
		return;
	}

	newFX->alpha = gEngfuncs.pfnRandomFloat(0.6, 0.9);
	newFX->origin = drip->origin;
	newFX->origin.z = drip->minHeight; // correct position
	newFX->birthTime = Rain.curtime;
	newFX->life = gEngfuncs.pfnRandomFloat(0.7, 1);
	newFX->type = drip->land;

	// add to first place in chain
	newFX->p_Next = FirstChainFX.p_Next;
	newFX->p_Prev = &FirstChainFX;
	if (newFX->p_Next != NULL)
		newFX->p_Next->p_Prev = newFX;
	FirstChainFX.p_Next = newFX;

	Rain.fxcounter++;
}
/*
=================================
ProcessRain

Must think every frame.
=================================
*/
void ProcessRain( void )
{
	int speed = Rain.weatherMode ? SNOWSPEED : DRIPSPEED;

	Rain.oldtime = Rain.curtime; // save old time
	Rain.curtime = gEngfuncs.GetClientTime();
	Rain.timedelta = Rain.curtime - Rain.oldtime;

	if( gHUD.cl_weather->value > 3.0f )
		gEngfuncs.Cvar_Set( "cl_weather", "3" );

	Rain.weatherValue = gHUD.cl_weather->value;

	if( Rain.dripsPerSecond == 0 || !Rain.weatherValue )
		return; // disabled

	// first frame
	if( Rain.oldtime == 0 || ( Rain.dripsPerSecond == 0 && FirstChainDrip.p_Next == NULL ) )
	{
		// fix first frame bug with nextspawntime
		Rain.nextspawntime = Rain.curtime;
		return;
	}

	if( !Rain.timedelta )
		return; // not in pause

	int spawnDrips = (Rain.dripsPerSecond + (Rain.weatherValue - 1) * 150);
	double timeBetweenDrips = 1.0 / (double)(spawnDrips);

#ifdef _DEBUG
	// save debug info
	float debug_lifetime = 0;
	int debug_howmany = 0;
	int debug_attempted = 0;
	int debug_dropped = 0;
#endif

	for( cl_drip_t *curDrip = FirstChainDrip.p_Next, *nextDrip = NULL;
		 curDrip;
		 curDrip = nextDrip ) // go through list
	{
		nextDrip = curDrip->p_Next; // save pointer to next drip

		curDrip->origin.x += Rain.timedelta * curDrip->Delta.x;
		curDrip->origin.y += Rain.timedelta * curDrip->Delta.y;
		curDrip->origin.z -= Rain.timedelta * speed;

		// remove drip if its origin lower than minHeight
		if (curDrip->origin.z < curDrip->minHeight)
		{
			LandingEffect( curDrip );
#ifdef _DEBUG
			if( debug_rain->value )
			{
				debug_lifetime += ( Rain.curtime - curDrip->birthTime );
				debug_howmany++;
			}
#endif

			curDrip->p_Prev->p_Next = curDrip->p_Next; // link chain
			if( nextDrip != NULL )
				nextDrip->p_Prev = curDrip->p_Prev;
			delete curDrip;

			Rain.dripcounter--;
		}
	}

	int maxDelta = speed * Rain.timedelta; // maximum height randomize distance
	float falltime = (Rain.globalHeight + 4096) / speed;

	for( ; Rain.nextspawntime < Rain.curtime; Rain.nextspawntime += timeBetweenDrips )
	{
#ifdef _DEBUG
		if( debug_rain->value )
			debug_attempted++;
#endif
				
		if( Rain.dripcounter < spawnDrips ) // check for overflow
		{
			float deathHeight;
			Vector vecStart, vecEnd, vecStartStart;
			Vector2D Delta( Rain.wind.x + gEngfuncs.pfnRandomFloat( Rain.rand.x * -1, Rain.rand.x ),
							Rain.wind.y + gEngfuncs.pfnRandomFloat( Rain.rand.y * -1, Rain.rand.y ));
			pmtrace_t pmtrace, pmtrace2;

			vecStart.x = gEngfuncs.pfnRandomFloat( gHUD.m_vecOrigin.x - Rain.distFromPlayer, gHUD.m_vecOrigin.x + Rain.distFromPlayer );
			vecStart.y = gEngfuncs.pfnRandomFloat( gHUD.m_vecOrigin.y - Rain.distFromPlayer, gHUD.m_vecOrigin.y + Rain.distFromPlayer );
			vecStart.z = gHUD.m_vecOrigin.z + Rain.heightFromPlayer;

			// find a point at bottom of map
			vecEnd.x = falltime * Delta.x;
			vecEnd.y = falltime * Delta.y;
			vecEnd.z = -4096;

			gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
			gEngfuncs.pEventAPI->EV_PlayerTrace( vecStart, vecEnd, PM_WORLD_ONLY, -1, &pmtrace );

			if( pmtrace.startsolid )
			{
#ifdef _DEBUG
				if( debug_rain->value )
					debug_dropped++;
#endif
				continue; // drip cannot be placed
			}

			vecStartStart = vecStart;
			vecStartStart.z = 999999;

			// second trace. Check that player have a real sky above him
			const char *s = gEngfuncs.pEventAPI->EV_TraceTexture( pmtrace.ent, vecStart, vecStartStart );
			if( !s || strcmp( s, "sky" ) )
			{
#ifdef _DEBUG
				if( debug_rain->value )
					debug_dropped++;
#endif
				continue;
			}
			
			// falling to water?
			int contents = gEngfuncs.PM_PointContents( pmtrace.endpos, NULL );
			if( contents == CONTENTS_WATER )
			{
				int waterEntity = gEngfuncs.PM_WaterEntity( pmtrace.endpos );
				if( waterEntity > 0 )
				{
					cl_entity_t *pwater = gEngfuncs.GetEntityByIndex( waterEntity );
					if( pwater && ( pwater->model != NULL ) )
					{
						deathHeight = pwater->curstate.maxs[2];
					}
					else
					{
						gEngfuncs.Con_Printf("Rain error: can't get water entity\n");
						continue;
					}
				}
				else
				{
					gEngfuncs.Con_Printf("Rain error: water is not func_water entity\n");
					continue;
				}
			}
			else
			{
				deathHeight = pmtrace.endpos[2];
			}

			// just in case..
			if (deathHeight > vecStart[2])
			{
				gEngfuncs.Con_Printf("Rain error: can't create drip in water\n");
				continue;
			}

			cl_drip_t *newClDrip = new(std::nothrow) cl_drip_t;
			if( !newClDrip )
			{
				Rain.dripsPerSecond = 0; // disable rain
				gEngfuncs.Con_Printf( "Rain error: failed to allocate object!\n");
				return;
			}
			
			vecStart[2] -= gEngfuncs.pfnRandomFloat( 0, maxDelta ); // randomize a bit
			
			newClDrip->alpha     = gEngfuncs.pfnRandomFloat( 0.12, 0.2 );
			newClDrip->origin    = vecStart;
			newClDrip->Delta     = Delta;
			newClDrip->birthTime = Rain.curtime; // store time when it was spawned
			newClDrip->minHeight = deathHeight;

			if( contents == CONTENTS_WATER )
			{
				newClDrip->land = WATER_LANDING;
			}
			else
			{
				newClDrip->land = NO_LANDING;
			}
			/*else if( pmtrace->fraction < 1.0f && pmtrace->plane.normal.z > 0.71 && !pmtrace->inopen)
			{
				newClDrip->land = DEFAULT_LANDING;
			}
			else
			{
				newClDrip->land = NO_LANDING;
			}*/

			// add to first place in chain
			newClDrip->p_Next = FirstChainDrip.p_Next;
			newClDrip->p_Prev = &FirstChainDrip;
			if (newClDrip->p_Next != NULL)
				newClDrip->p_Next->p_Prev = newClDrip;
			FirstChainDrip.p_Next = newClDrip;

			Rain.dripcounter++;
		}
		else
		{
			//gEngfuncs.Con_Printf( "Rain error: Drip limit overflow!\n" );
			return;
		}
	}

#ifdef _DEBUG
	if( debug_rain->value ) // print debug info
	{
		con_nprint_t info =
		{
			1,
			0.5f,
			{1.0f, 0.6f, 0.0f }
		};
		gEngfuncs.Con_NXPrintf( &info, "Rain info: Drips exist: %i\n", Rain.dripcounter );

		info.index = 2;
		gEngfuncs.Con_NXPrintf( &info, "Rain info: FX's exist: %i\n", Rain.fxcounter );

		info.index = 3;
		gEngfuncs.Con_NXPrintf( &info, "Rain info: Attempted/Dropped: %i, %i\n", debug_attempted, debug_dropped);
		if( debug_howmany )
		{
			float ave = debug_lifetime / (float)debug_howmany;

			info.index = 4;
			gEngfuncs.Con_NXPrintf( &info, "Rain info: Average drip life time: %f\n", ave);
		}
	}
#endif
}

/*
=================================
ProcessFXObjects

Remove all fx objects with out time to live
Call every frame before ProcessRain
=================================
*/
void ProcessFXObjects( void )
{
	for( cl_rainfx_t *curFX = FirstChainFX.p_Next, *nextFX = NULL;
		 curFX;
		 curFX = nextFX )
	{
		nextFX = curFX->p_Next; // save pointer to next

		// delete current?
		if( curFX->birthTime + curFX->life < Rain.curtime )
		{
			curFX->p_Prev->p_Next = curFX->p_Next; // link chain
			if( nextFX )
				nextFX->p_Prev = curFX->p_Prev;

			delete curFX;
			Rain.fxcounter--;
		}
	}
}

/*
=================================
ResetRain

clear memory, delete all objects
=================================
*/
void ResetRain( void )
{
	// delete all drips
	for( cl_drip_t *curDrip = FirstChainDrip.p_Next; curDrip;
		 curDrip = FirstChainDrip.p_Next, Rain.dripcounter-- )
	{
		FirstChainDrip.p_Next = curDrip->p_Next;
		delete curDrip;
	}

	// delete all FX objects
	for( cl_rainfx_t *curFX = FirstChainFX.p_Next; curFX;
		 curFX = FirstChainFX.p_Next, Rain.fxcounter-- )
	{
		FirstChainFX.p_Next = curFX->p_Next;
		delete curFX;
	}

	InitRain();
	return;
}


int __MsgFunc_ReceiveW(const char *pszName, int iSize, void *pbuf)
{
	BufferReader reader( pszName, pbuf, iSize);

	int iWeatherType = reader.ReadByte();

	if( iWeatherType == 0 )
	{
		ResetRain();
		return 1;
	}

	Rain.distFromPlayer = 500;
	Rain.dripsPerSecond = 500;
	Rain.wind.x = Rain.wind.y = 30;
	Rain.rand.x = Rain.rand.y = 0;
	Rain.weatherMode = iWeatherType - 1;
	Rain.globalHeight = 100;
	Rain.heightFromPlayer = 100;

	return 1;
}

/*
=================================
InitRain
initialze system
=================================
*/
void InitRain( void )
{
	memset( &Rain, 0, sizeof(Rain) );
	memset( &FirstChainDrip, 0, sizeof( cl_drip_t ));
	memset( &FirstChainFX, 0, sizeof( cl_rainfx_t ));

#ifdef _DEBUG
	if( !debug_rain )
		debug_rain = CVAR_CREATE( "Rain.debug", "0", 0 );
#endif

	Rain.hsprRain = SPR_Load("sprites/effects/rain.spr");
	Rain.hsprSnow = SPR_Load("sprites/effects/snowflake.spr");
	Rain.hsprRipple = SPR_Load("sprites/effects/ripple.spr");

	if( !initialized )
	{
		HOOK_MESSAGE( ReceiveW );

		initialized = true;
	}
}


void SetPoint( float x, float y, float z, float (*matrix)[4])
{
	Vector point( x, y, z ), result;

	VectorTransform( point, matrix, result );

	gEngfuncs.pTriAPI->Vertex3fv( result );
}



/*
=================================
DrawRain

draw raindrips and snowflakes
=================================
*/
void DrawRain( void )
{
	if (FirstChainDrip.p_Next == NULL)
		return; // no drips to draw

	cl_entity_t *player = gEngfuncs.GetLocalPlayer();

	if( Rain.weatherMode == 0 ) // draw rain
	{
		const model_s *pTexture = gEngfuncs.GetSpritePointer( Rain.hsprRain );
		gEngfuncs.pTriAPI->SpriteTexture( (struct model_s *)pTexture, 0 );
		gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
		gEngfuncs.pTriAPI->CullFace( TRI_NONE );

		for( cl_drip_t *Drip = FirstChainDrip.p_Next; Drip; Drip = Drip->p_Next )
		{
			Vector2D toPlayer, shift(Drip->Delta * DRIP_SPRITE_HALFHEIGHT / DRIPSPEED);
			toPlayer.x = (player->origin.x - Drip->origin.x) * DRIP_SPRITE_HALFWIDTH;
			toPlayer.y = (player->origin.y - Drip->origin.y) * DRIP_SPRITE_HALFWIDTH;
			toPlayer = toPlayer.Normalize();

			// --- draw triangle --------------------------
			gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, Drip->alpha );
			gEngfuncs.pTriAPI->Begin( TRI_TRIANGLES );

				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				gEngfuncs.pTriAPI->Vertex3f( Drip->origin.x-toPlayer.y - shift.x,
						Drip->origin.y + toPlayer.x - shift.y,
						Drip->origin.z + DRIP_SPRITE_HALFHEIGHT );

				gEngfuncs.pTriAPI->TexCoord2f( 0.5, 1 );
				gEngfuncs.pTriAPI->Vertex3f( Drip->origin.x + shift.x,
						Drip->origin.y + shift.y,
						Drip->origin.z - DRIP_SPRITE_HALFHEIGHT );

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				gEngfuncs.pTriAPI->Vertex3f( Drip->origin.x+toPlayer.y - shift.x,
						Drip->origin.y - toPlayer.x - shift.y,
						Drip->origin.z + DRIP_SPRITE_HALFHEIGHT);

			gEngfuncs.pTriAPI->End();
			// --- draw triangle end ----------------------
		}
	}

	else	// draw snow
	{
		const model_s *pTexture = gEngfuncs.GetSpritePointer( Rain.hsprSnow );
		float visibleHeight = Rain.globalHeight - SNOWFADEDIST;
		vec3_t normal;
		float  matrix[3][4];

		gEngfuncs.GetViewAngles( normal );
		AngleMatrix (normal, matrix);	// calc view matrix

		gEngfuncs.pTriAPI->SpriteTexture( (struct model_s *)pTexture, 0 );
		gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
		gEngfuncs.pTriAPI->CullFace( TRI_NONE );


		for( cl_drip_t *Drip = FirstChainDrip.p_Next; Drip; Drip = Drip->p_Next )
		{
			matrix[0][3] = Drip->origin.x; // write origin to matrix
			matrix[1][3] = Drip->origin.y;
			matrix[2][3] = Drip->origin.z;

			// apply start fading effect
			float alpha = (Drip->origin.z <= visibleHeight) ?
							  Drip->alpha :
							  (((gHUD.m_vecOrigin.z + Rain.heightFromPlayer) - Drip->origin.z) / (float)SNOWFADEDIST) * Drip->alpha;

			// --- draw quad --------------------------
			gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, alpha );
			gEngfuncs.pTriAPI->Begin( TRI_QUADS );

				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				SetPoint(0, SNOW_SPRITE_HALFSIZE, SNOW_SPRITE_HALFSIZE, matrix);

				gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
				SetPoint(0, SNOW_SPRITE_HALFSIZE, -SNOW_SPRITE_HALFSIZE, matrix);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
				SetPoint(0, -SNOW_SPRITE_HALFSIZE, -SNOW_SPRITE_HALFSIZE, matrix);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				SetPoint(0, -SNOW_SPRITE_HALFSIZE, SNOW_SPRITE_HALFSIZE, matrix);

			gEngfuncs.pTriAPI->End();
			// --- draw quad end ----------------------
		}
	}
}

/*
=================================
DrawFXObjects
=================================
*/
void DrawFXObjects( void )
{
	const model_s *pTexture = gEngfuncs.GetSpritePointer( Rain.hsprRipple );
	gEngfuncs.pTriAPI->SpriteTexture( (struct model_s *)pTexture, 0 );
	gEngfuncs.pTriAPI->RenderMode( kRenderTransAdd );
	gEngfuncs.pTriAPI->CullFace( TRI_NONE );

	// go through objects list
	for( cl_rainfx_t *curFX = FirstChainFX.p_Next; curFX; curFX = curFX->p_Next )
	{
		switch( curFX->type )
		{
		case WATER_LANDING:
		{
			// fadeout
			float alpha = ((curFX->birthTime + curFX->life - Rain.curtime) / curFX->life) * curFX->alpha;
			float size = (Rain.curtime - curFX->birthTime) * MAXRINGHALFSIZE;

			// --- draw quad --------------------------
			gEngfuncs.pTriAPI->Color4f( 1.0, 1.0, 1.0, alpha );
			gEngfuncs.pTriAPI->Begin( TRI_QUADS );

				gEngfuncs.pTriAPI->TexCoord2f( 0, 0 );
				gEngfuncs.pTriAPI->Vertex3f(curFX->origin.x - size, curFX->origin.y - size, curFX->origin.z);

				gEngfuncs.pTriAPI->TexCoord2f( 0, 1 );
				gEngfuncs.pTriAPI->Vertex3f(curFX->origin.x - size, curFX->origin.y + size, curFX->origin.z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 1 );
				gEngfuncs.pTriAPI->Vertex3f(curFX->origin.x + size, curFX->origin.y + size, curFX->origin.z);

				gEngfuncs.pTriAPI->TexCoord2f( 1, 0 );
				gEngfuncs.pTriAPI->Vertex3f(curFX->origin.x + size, curFX->origin.y - size, curFX->origin.z);

			gEngfuncs.pTriAPI->End();
			// --- draw quad end ----------------------
		}
		}
	}
}

```

`cl_dll/readme.txt`:

```txt
  client dll readme.txt
-------------------------

This file details the structure of the half-life client dll,  and
how it communicates with the half-life game engine.


Engine callback functions:

Drawing functions:
	HSPRITE SPR_Load( char *picname );
		Loads a sprite into memory, and returns a handle to it.

	int  SPR_Frames( HSPRITE sprite );
		Returns the number of frames stored in the specified sprite.

	int  SPR_Height( HSPRITE x, int frame )
		Returns the height, in pixels, of a sprite at the specified frame.  
		Returns 0 is the frame number or the sprite handle is invalid.

	int  SPR_Width( HSPRITE x, int f )
		Returns the width, in pixels, of a sprite at the specified frame.  
		Returns 0 is the frame number or the sprite handle is invalid.

	int  SPR_Set( HSPRITE sprite, int r, int g, int b );
		Prepares a sprite about to be drawn.  RBG color values are applied to the sprite at this time.


	void  SPR_Draw( int frame, int x, int y );
		Precondition:  SPR_Set has already been called for a sprite.
		Draws the currently active sprite to the screen,  at position (x,y), where (0,0) is
		the top left-hand corner of the screen.


	void  SPR_DrawHoles( int frame, int x, int y );
		Precondition:  SPR_Set has already been called for a sprite.
		Draws the currently active sprite to the screen.  Color index #255 is treated as transparent.

	void  SPR_DrawAdditive( int frame, int x, int y );
		Precondition:  SPR_Set has already been called for a sprite.
		Draws the currently active sprite to the screen,  adding it's color values to the background.

	void  SPR_EnableScissor( int x, int y, int width, int height );
		Creates a clipping rectangle.  No pixels will be drawn outside the specified area.  Will
		stay in effect until either the next frame,  or SPR_DisableScissor is called.

	void  SPR_DisableScissor( void );
		Disables the effect of an SPR_EnableScissor call.

	int	 IsHighRes( void );
		returns 1 if the res mode is 640x480 or higher;  0 otherwise.

	int	 ScreenWidth( void );
		returns the screen width, in pixels.

	int	 ScreenHeight( void );
		returns the screen height, in pixels.

// Sound functions
	void PlaySound( char *szSound, int volume )
		plays the sound 'szSound' at the specified volume.  Loads the sound if it hasn't been cached.
		If it can't find the sound,  it displays an error message and plays no sound.

	void PlaySound( int iSound, int volume )
		Precondition:  iSound has been precached.
		Plays the sound, from the precache list.


// Communication functions
	void  SendClientCmd( char *szCmdString );
		sends a command to the server,  just as if the client had typed the szCmdString at the console.

	char *GetPlayerName( int entity_number );
		returns a pointer to a string, that contains the name of the specified client.  
		Returns NULL if the entity_number is not a client.
		

	DECLARE_MESSAGE(),  HOOK_MESSAGE()
		These two macros bind the message sending between the entity DLL and the client DLL to
		the CHud object.

		HOOK_MESSAGE( message_name )
			 This is used inside CHud::Init().  It calls into the engine to hook that message
			 from the incoming message stream.
			 Precondition:  There must be a function of name UserMsg_message_name declared
			 for CHud.  Eg,  CHud::UserMsg_Health() must be declared if you want to 
			 use HOOK_MESSAGE( Health );

		DECLARE_MESSAGE( message_name )
			For each HOOK_MESSAGE you must have an equivalent DECLARE_MESSAGE.  This creates
			a function which passes the hooked messages into the CHud object.


	HOOK_COMMAND(),  DECLARE_COMMAND()
		These two functions declare and hook console commands into the client dll.
		
		HOOK_COMMAND( char *command, command_name )
			Whenever the user types the 'command' at the console,  the function 'command_name'
			will be called.
			Precondition: There must be a function of the name UserCmd_command_name declared
			for CHud. Eg,  CHud::UserMsg_ShowScores() must be declared if you want to
			use HOOK_COMMAND( "+showscores", ShowScores );

		DECLARE_COMMAND( command_name )
			For each HOOK_COMMAND you must have an equivalent DECLARE_COMMAND.  This creates
			a function which passes the hooked commands into the CHud object.
		

```

`cl_dll/studio/GameStudioModelRenderer.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Big thanks to Chicken Fortress developers
// for this code.
#include <assert.h>
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "com_model.h"
#include "studio.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "dlight.h"
#include "triangleapi.h"

#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <math.h>

#include "studio_util.h"
#include "r_studioint.h"

#include "StudioModelRenderer.h"
#include "GameStudioModelRenderer.h"
#include "pm_defs.h"

#define ANIM_WALK_SEQUENCE 3
#define ANIM_JUMP_SEQUENCE 6
#define ANIM_SWIM_1 8
#define ANIM_SWIM_2 9
#define ANIM_FIRST_DEATH_SEQUENCE 101
#define ANIM_LAST_DEATH_SEQUENCE 159
#define ANIM_FIRST_EMOTION_SEQUENCE 198
#define ANIM_LAST_EMOTION_SEQUENCE 207

CGameStudioModelRenderer g_StudioRenderer;

int g_rseq;
int g_gaitseq;
vec3_t g_clorg;
vec3_t g_clang;

void CounterStrike_GetSequence(int *seq, int *gaitseq)
{
	*seq = g_rseq;
	*gaitseq = g_gaitseq;
}

void CounterStrike_GetOrientation(float *o, float *a)
{
	VectorCopy(g_clorg, o);
	VectorCopy(g_clang, a);
}

float g_flStartScaleTime;
int iPrevRenderState;
int iRenderStateChanged;

engine_studio_api_t IEngineStudio;

static client_anim_state_t g_state;
static client_anim_state_t g_clientstate;

CGameStudioModelRenderer::CGameStudioModelRenderer(void)
{
	m_bLocal = false;
}

mstudioanim_t *CGameStudioModelRenderer::LookupAnimation(mstudioseqdesc_t *pseqdesc, int index)
{
	mstudioanim_t *panim = NULL;

	panim = StudioGetAnim(m_pRenderModel, pseqdesc);

	if (index < 0)
		return panim;

	if (index > (pseqdesc->numblends - 1))
		return panim;

	panim += index * m_pStudioHeader->numbones;
	return panim;
}

void CGameStudioModelRenderer::StudioSetupBones(void)
{
	int i;
	double f;

	mstudiobone_t *pbones;
	mstudioseqdesc_t *pseqdesc;
	mstudioanim_t *panim;

	static float pos[MAXSTUDIOBONES][3];
	static vec4_t q[MAXSTUDIOBONES];
	float bonematrix[3][4];

	static float pos2[MAXSTUDIOBONES][3];
	static vec4_t q2[MAXSTUDIOBONES];
	static float pos3[MAXSTUDIOBONES][3];
	static vec4_t q3[MAXSTUDIOBONES];
	static float pos4[MAXSTUDIOBONES][3];
	static vec4_t q4[MAXSTUDIOBONES];

	if (!m_pCurrentEntity->player)
	{
		CStudioModelRenderer::StudioSetupBones();
		return;
	}

	if (m_pCurrentEntity->curstate.sequence >= m_pStudioHeader->numseq)
		m_pCurrentEntity->curstate.sequence = 0;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;
	panim = StudioGetAnim(m_pRenderModel, pseqdesc);

	f = StudioEstimateFrame(pseqdesc);

	if (m_pPlayerInfo->gaitsequence == ANIM_WALK_SEQUENCE)
	{
		if (m_pCurrentEntity->curstate.blending[0] <= 26)
		{
			m_pCurrentEntity->curstate.blending[0] = 0;
			m_pCurrentEntity->latched.prevseqblending[0] = m_pCurrentEntity->curstate.blending[0];
		}
		else
		{
			m_pCurrentEntity->curstate.blending[0] -= 26;
			m_pCurrentEntity->latched.prevseqblending[0] = m_pCurrentEntity->curstate.blending[0];
		}
	}

	if (pseqdesc->numblends == 9)
	{
		float s = m_pCurrentEntity->curstate.blending[0];
		float t = m_pCurrentEntity->curstate.blending[1];

		if (s <= 127.0)
		{
			s = (s * 2.0);

			if (t <= 127.0)
			{
				t = (t * 2.0);

				StudioCalcRotations(pos, q, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 1);
				StudioCalcRotations(pos2, q2, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 3);
				StudioCalcRotations(pos3, q3, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 4);
				StudioCalcRotations(pos4, q4, pseqdesc, panim, f);
			}
			else
			{
				t = 2.0 * (t - 127.0);

				panim = LookupAnimation(pseqdesc, 3);
				StudioCalcRotations(pos, q, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 4);
				StudioCalcRotations(pos2, q2, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 6);
				StudioCalcRotations(pos3, q3, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 7);
				StudioCalcRotations(pos4, q4, pseqdesc, panim, f);
			}
		}
		else
		{
			s = 2.0 * (s - 127.0);

			if (t <= 127.0)
			{
				t = (t * 2.0);

				panim = LookupAnimation(pseqdesc, 1);
				StudioCalcRotations(pos, q, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 2);
				StudioCalcRotations(pos2, q2, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 4);
				StudioCalcRotations(pos3, q3, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 5);
				StudioCalcRotations(pos4, q4, pseqdesc, panim, f);
			}
			else
			{
				t = 2.0 * (t - 127.0);

				panim = LookupAnimation(pseqdesc, 4);
				StudioCalcRotations(pos, q, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 5);
				StudioCalcRotations(pos2, q2, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 7);
				StudioCalcRotations(pos3, q3, pseqdesc, panim, f);
				panim = LookupAnimation(pseqdesc, 8);
				StudioCalcRotations(pos4, q4, pseqdesc, panim, f);
			}
		}

		s /= 255.0;
		t /= 255.0;

		StudioSlerpBones(q, pos, q2, pos2, s);
		StudioSlerpBones(q3, pos3, q4, pos4, s);
		StudioSlerpBones(q, pos, q3, pos3, t);
	}
	else
	{
		StudioCalcRotations(pos, q, pseqdesc, panim, f);
	}

	if (m_fDoInterp && m_pCurrentEntity->latched.sequencetime && (m_pCurrentEntity->latched.sequencetime + 0.2 > m_clTime) && (m_pCurrentEntity->latched.prevsequence < m_pStudioHeader->numseq))
	{
		static float pos1b[MAXSTUDIOBONES][3];
		static vec4_t q1b[MAXSTUDIOBONES];
		float s = m_pCurrentEntity->latched.prevseqblending[0];
		float t = m_pCurrentEntity->latched.prevseqblending[1];

		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->latched.prevsequence;
		panim = StudioGetAnim(m_pRenderModel, pseqdesc);

		if (pseqdesc->numblends == 9)
		{
			if (s <= 127.0)
			{
				s = (s * 2.0);

				if (t <= 127.0)
				{
					t = (t * 2.0);

					StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 1);
					StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 3);
					StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 4);
					StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
				}
				else
				{
					t = 2.0 * (t - 127.0);

					panim = LookupAnimation(pseqdesc, 3);
					StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 4);
					StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 6);
					StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 7);
					StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
				}
			}
			else
			{
				s = 2.0 * (s - 127.0);

				if (t <= 127.0)
				{
					t = (t * 2.0);

					panim = LookupAnimation(pseqdesc, 1);
					StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 2);
					StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 4);
					StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 5);
					StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
				}
				else
				{
					t = 2.0 * (t - 127.0);

					panim = LookupAnimation(pseqdesc, 4);
					StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 5);
					StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 7);
					StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
					panim = LookupAnimation(pseqdesc, 8);
					StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
				}
			}

			s /= 255.0;
			t /= 255.0;

			StudioSlerpBones(q1b, pos1b, q2, pos2, s);
			StudioSlerpBones(q3, pos3, q4, pos4, s);
			StudioSlerpBones(q1b, pos1b, q3, pos3, t);
		}
		else
		{
			StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);
		}

		s = 1.0 - (m_clTime - m_pCurrentEntity->latched.sequencetime) / 0.2;
		StudioSlerpBones(q, pos, q1b, pos1b, s);
	}
	else
	{
		m_pCurrentEntity->latched.prevframe = f;
	}

	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	if (m_pPlayerInfo && (m_pCurrentEntity->curstate.sequence < ANIM_FIRST_DEATH_SEQUENCE || m_pCurrentEntity->curstate.sequence > ANIM_LAST_DEATH_SEQUENCE) && (m_pCurrentEntity->curstate.sequence < ANIM_FIRST_EMOTION_SEQUENCE || m_pCurrentEntity->curstate.sequence > ANIM_LAST_EMOTION_SEQUENCE) && m_pCurrentEntity->curstate.sequence != ANIM_SWIM_1 && m_pCurrentEntity->curstate.sequence != ANIM_SWIM_2)
	{
		int copy = 1;

		if (m_pPlayerInfo->gaitsequence >= m_pStudioHeader->numseq)
			m_pPlayerInfo->gaitsequence = 0;

		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex ) + m_pPlayerInfo->gaitsequence;

		panim = StudioGetAnim(m_pRenderModel, pseqdesc);
		StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pPlayerInfo->gaitframe);

		for (i = 0; i < m_pStudioHeader->numbones; i++)
		{
			if (!strcmp(pbones[i].name, "Bip01 Spine"))
				copy = 0;
			else if (!strcmp(pbones[pbones[i].parent].name, "Bip01 Pelvis"))
				copy = 1;

			if (copy)
			{
				memcpy(pos[i], pos2[i], sizeof(pos[i]));
				memcpy(q[i], q2[i], sizeof(q[i]));
			}
		}
	}

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		QuaternionMatrix(q[i], bonematrix);

		bonematrix[0][3] = pos[i][0];
		bonematrix[1][3] = pos[i][1];
		bonematrix[2][3] = pos[i][2];

		if (pbones[i].parent == -1)
		{
			if (IEngineStudio.IsHardware())
			{
				ConcatTransforms((*m_protationmatrix), bonematrix, (*m_pbonetransform)[i]);
				MatrixCopy((*m_pbonetransform)[i], (*m_plighttransform)[i]);
			}
			else
			{
				ConcatTransforms((*m_paliastransform), bonematrix, (*m_pbonetransform)[i]);
				ConcatTransforms((*m_protationmatrix), bonematrix, (*m_plighttransform)[i]);
			}

			StudioFxTransform(m_pCurrentEntity, (*m_pbonetransform)[i]);
		}
		else
		{
			ConcatTransforms((*m_pbonetransform)[pbones[i].parent], bonematrix, (*m_pbonetransform)[i]);
			ConcatTransforms((*m_plighttransform)[pbones[i].parent], bonematrix, (*m_plighttransform)[i]);
		}
	}
}

void CGameStudioModelRenderer::StudioEstimateGait(entity_state_t *pplayer)
{
	float dt;
	vec3_t est_velocity;

	dt = (m_clTime - m_clOldTime);
	dt = max(0.0, dt);
	dt = min(1.0, dt);

	if (dt == 0 || m_pPlayerInfo->renderframe == m_nFrameCount)
	{
		m_flGaitMovement = 0;
		return;
	}

	if (m_fGaitEstimation)
	{
		VectorSubtract(m_pCurrentEntity->origin, m_pPlayerInfo->prevgaitorigin, est_velocity);
		VectorCopy(m_pCurrentEntity->origin, m_pPlayerInfo->prevgaitorigin);
		m_flGaitMovement = est_velocity.Length();

		if (dt <= 0 || m_flGaitMovement / dt < 5)
		{
			m_flGaitMovement = 0;
			est_velocity[0] = 0;
			est_velocity[1] = 0;
		}
	}
	else
	{
		VectorCopy(pplayer->velocity, est_velocity);
		m_flGaitMovement = est_velocity.Length() * dt;
	}

	if (est_velocity[1] == 0 && est_velocity[0] == 0)
	{
		float flYawDiff = m_pCurrentEntity->angles[YAW] - m_pPlayerInfo->gaityaw;
		flYawDiff = flYawDiff - (int)(flYawDiff / 360) * 360;

		if (flYawDiff > 180)
			flYawDiff -= 360;

		if (flYawDiff < -180)
			flYawDiff += 360;

		if (dt < 0.25)
			flYawDiff *= dt * 4;
		else
			flYawDiff *= dt;

		m_pPlayerInfo->gaityaw += flYawDiff;
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - (int)(m_pPlayerInfo->gaityaw / 360) * 360;

		m_flGaitMovement = 0;
	}
	else
	{
		m_pPlayerInfo->gaityaw = (atan2(est_velocity[1], est_velocity[0]) * 180 / M_PI);

		if (m_pPlayerInfo->gaityaw > 180)
			m_pPlayerInfo->gaityaw = 180;

		if (m_pPlayerInfo->gaityaw < -180)
			m_pPlayerInfo->gaityaw = -180;
	}
}

void CGameStudioModelRenderer::StudioPlayerBlend(mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch)
{
	float range = 45.0;

	*pBlend = (*pPitch * 3);

	if (*pBlend <= -range)
		*pBlend = 255;
	else if (*pBlend >= range)
		*pBlend = 0;
	else
		*pBlend = 255 * (range - *pBlend) / (2 * range);

	*pPitch = 0;
}

void CGameStudioModelRenderer::CalculatePitchBlend(entity_state_t *pplayer)
{
	mstudioseqdesc_t *pseqdesc;
	int iBlend;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	StudioPlayerBlend(pseqdesc, &iBlend, &m_pCurrentEntity->angles[PITCH]);

	m_pCurrentEntity->latched.prevangles[PITCH] = m_pCurrentEntity->angles[PITCH];
	m_pCurrentEntity->curstate.blending[1] = iBlend;
	m_pCurrentEntity->latched.prevblending[1] = m_pCurrentEntity->curstate.blending[1];
	m_pCurrentEntity->latched.prevseqblending[1] = m_pCurrentEntity->curstate.blending[1];
}

void CGameStudioModelRenderer::CalculateYawBlend(entity_state_t *pplayer)
{
	float flYaw;

	StudioEstimateGait(pplayer);

	flYaw = m_pCurrentEntity->angles[YAW] - m_pPlayerInfo->gaityaw;
	flYaw = fmod(flYaw, 360.0f);

	if (flYaw < -180)
		flYaw = flYaw + 360;
	else if (flYaw > 180)
		flYaw = flYaw - 360;

	float maxyaw = 120.0;

	if (flYaw > maxyaw)
	{
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - 180;
		m_flGaitMovement = -m_flGaitMovement;
		flYaw = flYaw - 180;
	}
	else if (flYaw < -maxyaw)
	{
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw + 180;
		m_flGaitMovement = -m_flGaitMovement;
		flYaw = flYaw + 180;
	}

	float blend_yaw = (flYaw / 90.0) * 128.0 + 127.0;

	blend_yaw = 255.0 - bound( 0.0, blend_yaw, 255.0 );

	m_pCurrentEntity->curstate.blending[0] = (int)(blend_yaw);
	m_pCurrentEntity->latched.prevblending[0] = m_pCurrentEntity->curstate.blending[0];
	m_pCurrentEntity->latched.prevseqblending[0] = m_pCurrentEntity->curstate.blending[0];

	m_pCurrentEntity->angles[YAW] = m_pPlayerInfo->gaityaw;

	if (m_pCurrentEntity->angles[YAW] < -0)
		m_pCurrentEntity->angles[YAW] += 360;

	m_pCurrentEntity->latched.prevangles[YAW] = m_pCurrentEntity->angles[YAW];
}

void CGameStudioModelRenderer::StudioProcessGait(entity_state_t *pplayer)
{
	mstudioseqdesc_t *pseqdesc;

	CalculateYawBlend(pplayer);
	CalculatePitchBlend(pplayer);


	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + pplayer->gaitsequence;

	if (pseqdesc->linearmovement[0] > 0)
		m_pPlayerInfo->gaitframe += (m_flGaitMovement / pseqdesc->linearmovement[0]) * pseqdesc->numframes;
	else
	{
		float dt = bound( 0.0, (m_clTime - m_clOldTime), 1.0 );
		m_pPlayerInfo->gaitframe += pseqdesc->fps * dt * m_pCurrentEntity->curstate.framerate;
	}

	m_pPlayerInfo->gaitframe = m_pPlayerInfo->gaitframe - (int)(m_pPlayerInfo->gaitframe / pseqdesc->numframes) * pseqdesc->numframes;

	if (m_pPlayerInfo->gaitframe < 0)
		m_pPlayerInfo->gaitframe += pseqdesc->numframes;
}

void CGameStudioModelRenderer::SavePlayerState(entity_state_t *pplayer)
{
	client_anim_state_t *st;
	cl_entity_t *ent = IEngineStudio.GetCurrentEntity();

	if (!ent)
		return;

	st = &g_state;

	st->angles = ent->curstate.angles;
	st->origin = ent->curstate.origin;

	st->realangles = ent->angles;

	st->sequence = ent->curstate.sequence;
	st->gaitsequence = pplayer->gaitsequence;
	st->animtime = ent->curstate.animtime;
	st->frame = ent->curstate.frame;
	st->framerate = ent->curstate.framerate;

	memcpy(st->blending, ent->curstate.blending, 2);
	memcpy(st->controller, ent->curstate.controller, 4);

	st->lv = ent->latched;
}

void GetSequenceInfo(void *pmodel, client_anim_state_t *pev, float *pflFrameRate, float *pflGroundSpeed)
{
	studiohdr_t *pstudiohdr;
	pstudiohdr = (studiohdr_t *)pmodel;

	if (!pstudiohdr)
		return;

	mstudioseqdesc_t *pseqdesc;

	if (pev->sequence >= pstudiohdr->numseq)
	{
		*pflFrameRate = 0.0;
		*pflGroundSpeed = 0.0;
		return;
	}

	pseqdesc = (mstudioseqdesc_t *)((byte *)pstudiohdr + pstudiohdr->seqindex) + (int)pev->sequence;

	if (pseqdesc->numframes > 1)
	{
		*pflFrameRate = 256 * pseqdesc->fps / (pseqdesc->numframes - 1);
		*pflGroundSpeed = sqrt(pseqdesc->linearmovement[0] * pseqdesc->linearmovement[0] + pseqdesc->linearmovement[1] * pseqdesc->linearmovement[1] + pseqdesc->linearmovement[2] * pseqdesc->linearmovement[2]);
		*pflGroundSpeed = *pflGroundSpeed * pseqdesc->fps / (pseqdesc->numframes - 1);
	}
	else
	{
		*pflFrameRate = 256.0;
		*pflGroundSpeed = 0.0;
	}
}

int GetSequenceFlags(void *pmodel, client_anim_state_t *pev)
{
	studiohdr_t *pstudiohdr;
	pstudiohdr = (studiohdr_t *)pmodel;

	if (!pstudiohdr || pev->sequence >= pstudiohdr->numseq)
		return 0;

	mstudioseqdesc_t *pseqdesc;
	pseqdesc = (mstudioseqdesc_t *)((byte *)pstudiohdr + pstudiohdr->seqindex) + (int)pev->sequence;

	return pseqdesc->flags;
}

float StudioFrameAdvance(client_anim_state_t *st, float framerate, float flInterval)
{
	if (flInterval == 0.0)
	{
		flInterval = (gEngfuncs.GetClientTime() - st->animtime);

		if (flInterval <= 0.001)
		{
			st->animtime = gEngfuncs.GetClientTime();
			return 0.0;
		}
	}

	if (!st->animtime)
		flInterval = 0.0;

	st->frame += flInterval * framerate * st->framerate;
	st->animtime = gEngfuncs.GetClientTime();

	if (st->frame < 0.0 || st->frame >= 256.0)
	{
		if (st->m_fSequenceLoops)
			st->frame -= (int)(st->frame / 256.0) * 256.0;
		else
			st->frame = (st->frame < 0.0) ? 0 : 255;

		st->m_fSequenceFinished = TRUE;
	}

	return flInterval;
}

void CGameStudioModelRenderer::SetupClientAnimation(entity_state_t *pplayer)
{
	static double oldtime;
	double curtime, dt;

	client_anim_state_t *st;
	float fr, gs;

	cl_entity_t *ent = IEngineStudio.GetCurrentEntity();

	if (!ent)
		return;

	curtime = gEngfuncs.GetClientTime();
	dt = bound( 0.0, (curtime - oldtime), 1.0 );

	oldtime = curtime;
	st = &g_clientstate;

	st->framerate = 1.0;

	int oldseq = st->sequence;
	CounterStrike_GetSequence(&st->sequence, &st->gaitsequence);
	CounterStrike_GetOrientation((float *)&st->origin, (float *)&st->angles);
	VectorCopy(st->angles, st->realangles);

	if (st->sequence != oldseq)
	{
		st->frame = 0.0;
		st->lv.prevsequence = oldseq;
		st->lv.sequencetime = st->animtime;

		memcpy(st->lv.prevseqblending, st->blending, 2);
		memcpy(st->lv.prevcontroller, st->controller, 4);
	}

	void *pmodel = (studiohdr_t *)IEngineStudio.Mod_Extradata(ent->model);

	if( !pmodel )
		return;


	GetSequenceInfo(pmodel, st, &fr, &gs);
	st->m_fSequenceLoops = ((GetSequenceFlags(pmodel, st) & STUDIO_LOOPING) != 0);
	StudioFrameAdvance(st, fr, dt);

	ent->angles = st->realangles;

	ent->curstate.angles = st->angles;
	ent->curstate.origin = st->origin;

	ent->curstate.sequence = st->sequence;
	pplayer->gaitsequence = st->gaitsequence;
	ent->curstate.animtime = st->animtime;
	ent->curstate.frame = st->frame;
	ent->curstate.framerate = st->framerate;

	memcpy(ent->curstate.blending, st->blending, 2);
	memcpy(ent->curstate.controller, st->controller, 4);

	ent->latched = st->lv;
}

void CGameStudioModelRenderer::RestorePlayerState(entity_state_t *pplayer)
{
	client_anim_state_t *st;
	cl_entity_t *ent = IEngineStudio.GetCurrentEntity();

	if (!ent)
		return;

	st = &g_clientstate;

	st->angles = ent->curstate.angles;
	st->origin = ent->curstate.origin;

	st->realangles = ent->angles;

	st->sequence = ent->curstate.sequence;
	st->gaitsequence = pplayer->gaitsequence;
	st->animtime = ent->curstate.animtime;
	st->frame = ent->curstate.frame;
	st->framerate = ent->curstate.framerate;

	memcpy(st->blending, ent->curstate.blending, 2);
	memcpy(st->controller, ent->curstate.controller, 4);

	st->lv = ent->latched;

	st = &g_state;

	ent->angles = st->realangles;

	ent->curstate.angles = st->angles;
	ent->curstate.origin = st->origin;

	ent->curstate.sequence = st->sequence;
	pplayer->gaitsequence = st->gaitsequence;
	ent->curstate.animtime = st->animtime;
	ent->curstate.frame = st->frame;
	ent->curstate.framerate = st->framerate;

	memcpy(ent->curstate.blending, st->blending, 2);
	memcpy(ent->curstate.controller, st->controller, 4);

	ent->latched = st->lv;
}

int CGameStudioModelRenderer::StudioDrawPlayer(int flags, entity_state_t *pplayer)
{
	int iret = 0;
	bool isLocalPlayer = false;

	if (m_bLocal && IEngineStudio.GetCurrentEntity() == gEngfuncs.GetLocalPlayer())
		isLocalPlayer = true;

	if (isLocalPlayer)
	{
		SavePlayerState(pplayer);
		SetupClientAnimation(pplayer);
	}

	iret = _StudioDrawPlayer(flags, pplayer);

	if (isLocalPlayer)
		RestorePlayerState(pplayer);

	if( gHUD.cl_shadows->value != 0.0f )
	{
		Vector chestpos;

		for( int i = 0; i < m_nCachedBones; i++ )
		{
			if( !strcmp(m_nCachedBoneNames[i], "Bip01 Spine3") )
			{
				chestpos.x = m_rgCachedBoneTransform[i][0][3];
				chestpos.y = m_rgCachedBoneTransform[i][1][3];
				chestpos.z = m_rgCachedBoneTransform[i][2][3];
				StudioDrawShadow(chestpos, 20.0f);
				break;
			}
		}
	}

	return iret;
}

bool WeaponHasAttachments(entity_state_t *pplayer)
{
	studiohdr_t *modelheader = NULL;
	model_t *pweaponmodel;

	if (!pplayer)
		return false;

	pweaponmodel = IEngineStudio.GetModelByIndex(pplayer->weaponmodel);
	modelheader = (studiohdr_t *)IEngineStudio.Mod_Extradata(pweaponmodel);

	if( !modelheader )
		return false;

	return (modelheader->numattachments != 0);
}

int CGameStudioModelRenderer::_StudioDrawPlayer(int flags, entity_state_t *pplayer)
{
	m_pCurrentEntity = IEngineStudio.GetCurrentEntity();

	IEngineStudio.GetTimes(&m_nFrameCount, &m_clTime, &m_clOldTime);
	IEngineStudio.GetViewInfo(m_vRenderOrigin, m_vUp, m_vRight, m_vNormal);
	IEngineStudio.GetAliasScale(&m_fSoftwareXScale, &m_fSoftwareYScale);

	m_nPlayerIndex = pplayer->number - 1;

	if (m_nPlayerIndex < 0 || m_nPlayerIndex >= gEngfuncs.GetMaxClients())
		return 0;

	/*m_pRenderModel = IEngineStudio.SetupPlayerModel(m_nPlayerIndex);

	if (m_pRenderModel == NULL)
		return 0;*/

	extra_player_info_t *pExtra = g_PlayerExtraInfo + pplayer->number;

	if( gHUD.cl_minmodels && gHUD.cl_minmodels->value )
	{
		int team = pExtra->teamnumber;
		if( team == TEAM_TERRORIST )
		{
			// set leet if model isn't valid
			int modelIdx = gHUD.cl_min_t && BIsValidTModelIndex(gHUD.cl_min_t->value) ? gHUD.cl_min_t->value : 1;

			m_pRenderModel = gEngfuncs.CL_LoadModel( sPlayerModelFiles[ modelIdx ], NULL );
		}
		else if( team == TEAM_CT )
		{
			if( pExtra->vip )
				m_pRenderModel = gEngfuncs.CL_LoadModel( sPlayerModelFiles[3], NULL );
			else
			{
				// set gign, if model isn't valud
				int modelIdx = gHUD.cl_min_ct && BIsValidCTModelIndex(gHUD.cl_min_ct->value) ? gHUD.cl_min_ct->value : 2;

				m_pRenderModel = gEngfuncs.CL_LoadModel( sPlayerModelFiles[ modelIdx ], NULL );
			}
		}
	}
	else
	{
		m_pRenderModel = IEngineStudio.SetupPlayerModel( m_nPlayerIndex );
	}

	if( !m_pRenderModel )
	{
		return 0;
	}

	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(m_pRenderModel);

	if( !m_pStudioHeader )
		return 0;

	IEngineStudio.StudioSetHeader(m_pStudioHeader);
	IEngineStudio.SetRenderModel(m_pRenderModel);

	if (m_pCurrentEntity->curstate.sequence >= m_pStudioHeader->numseq)
		m_pCurrentEntity->curstate.sequence = 0;

	if (pplayer->sequence >= m_pStudioHeader->numseq)
		pplayer->sequence = 0;

	if (m_pCurrentEntity->curstate.gaitsequence >= m_pStudioHeader->numseq)
		m_pCurrentEntity->curstate.gaitsequence = 0;

	if (pplayer->gaitsequence >= m_pStudioHeader->numseq)
		pplayer->gaitsequence = 0;

	if (pplayer->gaitsequence)
	{
		vec3_t orig_angles(m_pCurrentEntity->angles);
		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

		StudioProcessGait(pplayer);

		m_pPlayerInfo->gaitsequence = pplayer->gaitsequence;
		m_pPlayerInfo = NULL;

		StudioSetUpTransform(0);
		m_pCurrentEntity->angles = orig_angles;
	}
	else
	{
		m_pCurrentEntity->curstate.controller[0] = 127;
		m_pCurrentEntity->curstate.controller[1] = 127;
		m_pCurrentEntity->curstate.controller[2] = 127;
		m_pCurrentEntity->curstate.controller[3] = 127;
		m_pCurrentEntity->latched.prevcontroller[0] = m_pCurrentEntity->curstate.controller[0];
		m_pCurrentEntity->latched.prevcontroller[1] = m_pCurrentEntity->curstate.controller[1];
		m_pCurrentEntity->latched.prevcontroller[2] = m_pCurrentEntity->curstate.controller[2];
		m_pCurrentEntity->latched.prevcontroller[3] = m_pCurrentEntity->curstate.controller[3];

		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

		CalculatePitchBlend(pplayer);
		CalculateYawBlend(pplayer);

		m_pPlayerInfo->gaitsequence = 0;
		StudioSetUpTransform(0);
	}

	if (flags & STUDIO_RENDER)
	{
		(*m_pModelsDrawn)++;
		(*m_pStudioModelCount)++;

		if (m_pStudioHeader->numbodyparts == 0)
			return 1;
	}

	m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

	StudioSetupBones();
	StudioSaveBones();

	m_pPlayerInfo->renderframe = m_nFrameCount;
	m_pPlayerInfo = NULL;

	if (flags & STUDIO_EVENTS && (!(flags & STUDIO_RENDER) || !pplayer->weaponmodel || !WeaponHasAttachments(pplayer)))
	{
		StudioCalcAttachments();
		IEngineStudio.StudioClientEvents();

		if (m_pCurrentEntity->index > 0)
		{
			cl_entity_t *ent = gEngfuncs.GetEntityByIndex(m_pCurrentEntity->index);
			memcpy(ent->attachment, m_pCurrentEntity->attachment, sizeof(vec3_t) * 4);
		}
	}

	if (flags & STUDIO_RENDER)
	{
		alight_t lighting;
		vec3_t dir;

		lighting.plightvec = dir;

		IEngineStudio.StudioDynamicLight(m_pCurrentEntity, &lighting);
		IEngineStudio.StudioEntityLight(&lighting);
		IEngineStudio.StudioSetupLighting(&lighting);

		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);
		m_nTopColor = m_pPlayerInfo->topcolor;

		if (m_nTopColor < 0)
			m_nTopColor = 0;

		if (m_nTopColor > 360)
			m_nTopColor = 360;

		m_nBottomColor = m_pPlayerInfo->bottomcolor;

		if (m_nBottomColor < 0)
			m_nBottomColor = 0;

		if (m_nBottomColor > 360)
			m_nBottomColor = 360;

		IEngineStudio.StudioSetRemapColors(m_nTopColor, m_nBottomColor);

		StudioRenderModel(dir);
		m_pPlayerInfo = NULL;

		if (pplayer->weaponmodel)
		{
			studiohdr_t *saveheader = m_pStudioHeader;
			cl_entity_t saveent = *m_pCurrentEntity;

			model_t *pweaponmodel = IEngineStudio.GetModelByIndex(pplayer->weaponmodel);

			m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(pweaponmodel);
			if( !m_pStudioHeader )
				return 0;

			IEngineStudio.StudioSetHeader(m_pStudioHeader);

			StudioMergeBones(pweaponmodel);

			IEngineStudio.StudioSetupLighting(&lighting);

			StudioRenderModel(dir);

			StudioCalcAttachments();

			if (m_pCurrentEntity->index > 0)
				memcpy(saveent.attachment, m_pCurrentEntity->attachment, sizeof(vec3_t) * m_pStudioHeader->numattachments);

			*m_pCurrentEntity = saveent;
			m_pStudioHeader = saveheader;
			IEngineStudio.StudioSetHeader(m_pStudioHeader);

			if (flags & STUDIO_EVENTS)
				IEngineStudio.StudioClientEvents();
		}
	}

	return 1;
}


void CGameStudioModelRenderer::StudioFxTransform(cl_entity_t *ent, float transform[3][4])
{
	switch (ent->curstate.renderfx)
	{
	case kRenderFxDistort:
	case kRenderFxHologram:
	{
		if (Com_RandomLong(0, 49) == 0)
		{
			int axis = Com_RandomLong(0, 1);

			if (axis == 1)
				axis = 2;

			VectorScale( transform[axis], gEngfuncs.pfnRandomFloat( 1, 1.484 ), transform[axis] );
		}
		else if (Com_RandomLong(0, 49) == 0)
		{
			float offset;

			offset = gEngfuncs.pfnRandomFloat(-10, 10);
			transform[Com_RandomLong(0, 2)][3] += offset;
		}

		break;
	}

	case kRenderFxExplode:
	{
		if (iRenderStateChanged)
		{
			g_flStartScaleTime = m_clTime;
			iRenderStateChanged = FALSE;
		}

		float flTimeDelta = m_clTime - g_flStartScaleTime;

		if (flTimeDelta > 0)
		{
			float flScale = 0.001;

			if (flTimeDelta <= 2.0)
				flScale = 1.0 - (flTimeDelta / 2.0);

			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
					transform[i][j] *= flScale;
			}
		}

		break;
	}
	}
}

void R_StudioInit(void)
{
	g_StudioRenderer.Init();
}

int R_StudioDrawPlayer(int flags, entity_state_t *pplayer)
{
	return g_StudioRenderer.StudioDrawPlayer(flags, pplayer);
}

int R_StudioDrawModel(int flags)
{
	return g_StudioRenderer.StudioDrawModel(flags);
}
// The simple drawing interface we'll pass back to the engine
r_studio_interface_t studio =
{
	STUDIO_INTERFACE_VERSION,
	R_StudioDrawModel,
	R_StudioDrawPlayer,
};

/*
====================
HUD_GetStudioModelInterface
Export this function for the engine to use the studio renderer class to render objects.
====================
*/
int DLLEXPORT HUD_GetStudioModelInterface( int version, struct r_studio_interface_s **ppinterface, struct engine_studio_api_s *pstudio )
{
	if ( version != STUDIO_INTERFACE_VERSION )
		return 0;

	// Point the engine to our callbacks
	*ppinterface = &studio;

	// Copy in engine helper functions
	IEngineStudio = *pstudio;

	// Initialize local variables, etc.
	R_StudioInit();

	// Success
	return 1;
}


```

`cl_dll/studio/StudioModelRenderer.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

// Big thanks to Chicken Fortress developers
// for this code.
#include <assert.h>
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "com_model.h"
#include "studio.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "dlight.h"
#include "triangleapi.h"

#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <math.h>

#include "studio_util.h"
#include "r_studioint.h"

#include "StudioModelRenderer.h"
#include "GameStudioModelRenderer.h"

#include "event_api.h"
#include "pm_defs.h"

extern CGameStudioModelRenderer g_StudioRenderer;
extern engine_studio_api_t IEngineStudio;
typedef struct pmtrace_s pmtrace_t;

void CStudioModelRenderer::Init(void)
{
	m_pCvarHiModels = IEngineStudio.GetCvar("cl_himodels");
	m_pCvarDeveloper = IEngineStudio.GetCvar("developer");
	m_pCvarDrawEntities = IEngineStudio.GetCvar("r_drawentities");

	m_pChromeSprite = IEngineStudio.GetChromeSprite();

	IEngineStudio.GetModelCounters(&m_pStudioModelCount, &m_pModelsDrawn);

	m_pbonetransform = (float (*)[MAXSTUDIOBONES][3][4])IEngineStudio.StudioGetBoneTransform();
	m_plighttransform = (float (*)[MAXSTUDIOBONES][3][4])IEngineStudio.StudioGetLightTransform();
	m_paliastransform = (float (*)[3][4])IEngineStudio.StudioGetAliasTransform();
	m_protationmatrix = (float (*)[3][4])IEngineStudio.StudioGetRotationMatrix();
}

CStudioModelRenderer::CStudioModelRenderer(void)
{
	m_fDoInterp = 1;
	m_fGaitEstimation = 1;
	m_pCurrentEntity = NULL;
	m_pCvarHiModels = NULL;
	m_pCvarDeveloper = NULL;
	m_pCvarDrawEntities = NULL;
	m_pChromeSprite = NULL;
	m_pStudioModelCount = NULL;
	m_pModelsDrawn = NULL;
	m_protationmatrix = NULL;
	m_paliastransform = NULL;
	m_pbonetransform = NULL;
	m_plighttransform = NULL;
	m_pStudioHeader = NULL;
	m_pBodyPart = NULL;
	m_pSubModel = NULL;
	m_pPlayerInfo = NULL;
	m_pRenderModel = NULL;
	m_iShadowSprite = 0;
}

CStudioModelRenderer::~CStudioModelRenderer(void)
{
}

void CStudioModelRenderer::StudioCalcBoneAdj(float dadt, float *adj, const byte *pcontroller1, const byte *pcontroller2, byte mouthopen)
{
	int i, j;
	float value;
	mstudiobonecontroller_t *pbonecontroller;

	pbonecontroller = (mstudiobonecontroller_t *)((byte *)m_pStudioHeader + m_pStudioHeader->bonecontrollerindex);

	for (j = 0; j < m_pStudioHeader->numbonecontrollers; j++)
	{
		i = pbonecontroller[j].index;

		if (i <= 3)
		{
			if (pbonecontroller[j].type & STUDIO_RLOOP)
			{
				if (abs(pcontroller1[i] - pcontroller2[i]) > 128)
				{
					int a, b;
					a = (pcontroller1[j] + 128) % 256;
					b = (pcontroller2[j] + 128) % 256;
					value = ((a * dadt) + (b * (1 - dadt)) - 128) * (360.0 / 256.0) + pbonecontroller[j].start;
				}
				else
				{
					value = ((pcontroller1[i] * dadt + (pcontroller2[i]) * (1.0 - dadt))) * (360.0 / 256.0) + pbonecontroller[j].start;
				}
			}
			else
			{
				value = (pcontroller1[i] * dadt + pcontroller2[i] * (1.0 - dadt)) / 255.0;

				if (value < 0)
					value = 0;

				if (value > 1.0)
					value = 1.0;

				value = (1.0 - value) * pbonecontroller[j].start + value * pbonecontroller[j].end;
			}
		}
		else
		{
			value = mouthopen / 64.0;

			if (value > 1.0)
				value = 1.0;

			value = (1.0 - value) * pbonecontroller[j].start + value * pbonecontroller[j].end;
		}

		switch (pbonecontroller[j].type & STUDIO_TYPES)
		{
			case STUDIO_XR:
			case STUDIO_YR:
			case STUDIO_ZR:
			{
				adj[j] = value * (M_PI / 180.0);
				break;
			}
			case STUDIO_X:
			case STUDIO_Y:
			case STUDIO_Z:
			{
				adj[j] = value;
				break;
			}
		}
	}
}

void CStudioModelRenderer::StudioCalcBoneQuaterion(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *q)
{
	int j, k;
	vec4_t q1, q2;
	vec3_t angle1, angle2;
	mstudioanimvalue_t *panimvalue;

	for (j = 0; j < 3; j++)
	{
		if (panim->offset[j + 3] == 0)
		{
			angle2[j] = angle1[j] = pbone->value[j + 3];
		}
		else
		{
			panimvalue = (mstudioanimvalue_t *)((byte *)panim + panim->offset[j + 3]);
			k = frame;

			if (panimvalue->num.total < panimvalue->num.valid)
				k = 0;

			while (panimvalue->num.total <= k)
			{
				k -= panimvalue->num.total;
				panimvalue += panimvalue->num.valid + 1;

				if (panimvalue->num.total < panimvalue->num.valid)
					k = 0;
			}

			if (panimvalue->num.valid > k)
			{
				angle1[j] = panimvalue[k + 1].value;

				if (panimvalue->num.valid > k + 1)
				{
					angle2[j] = panimvalue[k + 2].value;
				}
				else
				{
					if (panimvalue->num.total > k + 1)
						angle2[j] = angle1[j];
					else
						angle2[j] = panimvalue[panimvalue->num.valid + 2].value;
				}
			}
			else
			{
				angle1[j] = panimvalue[panimvalue->num.valid].value;

				if (panimvalue->num.total > k + 1)
					angle2[j] = angle1[j];
				else
					angle2[j] = panimvalue[panimvalue->num.valid + 2].value;
			}

			angle1[j] = pbone->value[j + 3] + angle1[j] * pbone->scale[j + 3];
			angle2[j] = pbone->value[j + 3] + angle2[j] * pbone->scale[j + 3];
		}

		if (pbone->bonecontroller[j + 3] != -1)
		{
			angle1[j] += adj[pbone->bonecontroller[j + 3]];
			angle2[j] += adj[pbone->bonecontroller[j + 3]];
		}
	}

	if (!VectorCompare(angle1, angle2))
	{
		AngleQuaternion(angle1, q1);
		AngleQuaternion(angle2, q2);
		QuaternionSlerp(q1, q2, s, q);
	}
	else
	{
		AngleQuaternion(angle1, q);
	}
}

void CStudioModelRenderer::StudioCalcBonePosition(int frame, float s, mstudiobone_t *pbone, mstudioanim_t *panim, float *adj, float *pos)
{
	int j, k;
	mstudioanimvalue_t *panimvalue;

	for (j = 0; j < 3; j++)
	{
		pos[j] = pbone->value[j];

		if (panim->offset[j] != 0)
		{
			panimvalue = (mstudioanimvalue_t *)((byte *)panim + panim->offset[j]);
			k = frame;

			if (panimvalue->num.total < panimvalue->num.valid)
				k = 0;

			while (panimvalue->num.total <= k)
			{
				k -= panimvalue->num.total;
				panimvalue += panimvalue->num.valid + 1;

				if (panimvalue->num.total < panimvalue->num.valid)
					k = 0;
			}

			if (panimvalue->num.valid > k)
			{
				if (panimvalue->num.valid > k + 1)
					pos[j] += (panimvalue[k + 1].value * (1.0 - s) + s * panimvalue[k + 2].value) * pbone->scale[j];
				else
					pos[j] += panimvalue[k + 1].value * pbone->scale[j];
			}
			else
			{
				if (panimvalue->num.total <= k + 1)
					pos[j] += (panimvalue[panimvalue->num.valid].value * (1.0 - s) + s * panimvalue[panimvalue->num.valid + 2].value) * pbone->scale[j];
				else
					pos[j] += panimvalue[panimvalue->num.valid].value * pbone->scale[j];
			}
		}

		if (pbone->bonecontroller[j] != -1 && adj)
			pos[j] += adj[pbone->bonecontroller[j]];
	}
}

void CStudioModelRenderer::StudioSlerpBones(vec4_t q1[], float pos1[][3], vec4_t q2[], float pos2[][3], float s)
{
	int i;
	vec4_t q3;
	float s1;

	if (s < 0)
		s = 0;
	else if (s > 1.0)
		s = 1.0;

	s1 = 1.0 - s;

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		QuaternionSlerp(q1[i], q2[i], s, q3);

		q1[i][0] = q3[0];
		q1[i][1] = q3[1];
		q1[i][2] = q3[2];
		q1[i][3] = q3[3];
		pos1[i][0] = pos1[i][0] * s1 + pos2[i][0] * s;
		pos1[i][1] = pos1[i][1] * s1 + pos2[i][1] * s;
		pos1[i][2] = pos1[i][2] * s1 + pos2[i][2] * s;
	}
}

mstudioanim_t *CStudioModelRenderer::StudioGetAnim(model_t *m_pSubModel, mstudioseqdesc_t *pseqdesc)
{
	mstudioseqgroup_t *pseqgroup;
	cache_user_t *paSequences;

	pseqgroup = (mstudioseqgroup_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqgroupindex) + pseqdesc->seqgroup;

	if (pseqdesc->seqgroup == 0)
		return (mstudioanim_t *)((byte *)m_pStudioHeader + pseqgroup->data + pseqdesc->animindex);

	paSequences = (cache_user_t *)m_pSubModel->submodels;

	if (paSequences == NULL)
	{
		paSequences = (cache_user_t *)IEngineStudio.Mem_Calloc(16, sizeof(cache_user_t));
		m_pSubModel->submodels = (dmodel_t *)paSequences;
	}

	if (!IEngineStudio.Cache_Check((struct cache_user_s *)&(paSequences[pseqdesc->seqgroup])))
	{
		gEngfuncs.Con_DPrintf("loading %s\n", pseqgroup->name);
		IEngineStudio.LoadCacheFile(pseqgroup->name, (struct cache_user_s *)&paSequences[pseqdesc->seqgroup]);
	}

	return (mstudioanim_t *)((byte *)paSequences[pseqdesc->seqgroup].data + pseqdesc->animindex);
}

void CStudioModelRenderer::StudioPlayerBlend(mstudioseqdesc_t *pseqdesc, int *pBlend, float *pPitch)
{
	*pBlend = (*pPitch * 3);

	if (*pBlend < pseqdesc->blendstart[0])
	{
		*pPitch -= pseqdesc->blendstart[0] / 3.0;
		*pBlend = 0;
	}
	else if (*pBlend > pseqdesc->blendend[0])
	{
		*pPitch -= pseqdesc->blendend[0] / 3.0;
		*pBlend = 255;
	}
	else
	{
		if (pseqdesc->blendend[0] - pseqdesc->blendstart[0] < 0.1)
			*pBlend = 127;
		else
			*pBlend = 255 * (*pBlend - pseqdesc->blendstart[0]) / (pseqdesc->blendend[0] - pseqdesc->blendstart[0]);

		*pPitch = 0;
	}
}

void CStudioModelRenderer::StudioSetUpTransform(int trivial_accept)
{
	int i;
	vec3_t angles;
	vec3_t modelpos;

	VectorCopy(m_pCurrentEntity->origin, modelpos);

	angles[ROLL] = m_pCurrentEntity->curstate.angles[ROLL];
	angles[PITCH] = m_pCurrentEntity->curstate.angles[PITCH];
	angles[YAW] = m_pCurrentEntity->curstate.angles[YAW];

	if (m_pCurrentEntity->curstate.movetype == MOVETYPE_STEP)
	{
		float f = 0;
		float d;

		if ((m_clTime < m_pCurrentEntity->curstate.animtime + 1.0f) && (m_pCurrentEntity->curstate.animtime != m_pCurrentEntity->latched.prevanimtime))
			f = (m_clTime - m_pCurrentEntity->curstate.animtime) / (m_pCurrentEntity->curstate.animtime - m_pCurrentEntity->latched.prevanimtime);

		if (m_fDoInterp)
			f = f - 1.0;
		else
			f = 0;

		for (i = 0; i < 3; i++)
			modelpos[i] += (m_pCurrentEntity->origin[i] - m_pCurrentEntity->latched.prevorigin[i]) * f;

		for (i = 0; i < 3; i++)
		{
			float ang1, ang2;

			ang1 = m_pCurrentEntity->angles[i];
			ang2 = m_pCurrentEntity->latched.prevangles[i];

			d = ang1 - ang2;

			if (d > 180)
				d -= 360;
			else if (d < -180)
				d += 360;

			angles[i] += d * f;
		}
	}
	else if (m_pCurrentEntity->curstate.movetype != MOVETYPE_NONE)
	{
		VectorCopy(m_pCurrentEntity->angles, angles);
	}

	angles[PITCH] = -angles[PITCH];
	AngleMatrix(angles, (*m_protationmatrix));

	if (!IEngineStudio.IsHardware())
	{
		static float viewmatrix[3][4];

		VectorCopy(m_vRight, viewmatrix[0]);
		VectorCopy(m_vUp, viewmatrix[1]);
		VectorInverse(viewmatrix[1]);
		VectorCopy(m_vNormal, viewmatrix[2]);

		(*m_protationmatrix)[0][3] = modelpos[0] - m_vRenderOrigin[0];
		(*m_protationmatrix)[1][3] = modelpos[1] - m_vRenderOrigin[1];
		(*m_protationmatrix)[2][3] = modelpos[2] - m_vRenderOrigin[2];

		ConcatTransforms(viewmatrix, (*m_protationmatrix), (*m_paliastransform));

		if (trivial_accept)
		{
			for (i = 0; i < 4; i++)
			{
				(*m_paliastransform)[0][i] *= m_fSoftwareXScale * (1.0 / (ZISCALE * 0x10000));
				(*m_paliastransform)[1][i] *= m_fSoftwareYScale * (1.0 / (ZISCALE * 0x10000));
				(*m_paliastransform)[2][i] *= 1.0 / (ZISCALE * 0x10000);
			}
		}
	}

	(*m_protationmatrix)[0][3] = modelpos[0];
	(*m_protationmatrix)[1][3] = modelpos[1];
	(*m_protationmatrix)[2][3] = modelpos[2];
}

float CStudioModelRenderer::StudioEstimateInterpolant(void)
{
	float dadt = 1.0;

	if (m_fDoInterp && (m_pCurrentEntity->curstate.animtime >= m_pCurrentEntity->latched.prevanimtime + 0.01))
	{
		dadt = (m_clTime - m_pCurrentEntity->curstate.animtime) / 0.1;

		if (dadt > 2.0)
			dadt = 2.0;
	}

	return dadt;
}

void CStudioModelRenderer::StudioCalcRotations(float pos[][3], vec4_t *q, mstudioseqdesc_t *pseqdesc, mstudioanim_t *panim, float f)
{
	int i;
	int frame;
	mstudiobone_t *pbone;

	float s;
	float adj[MAXSTUDIOCONTROLLERS];
	float dadt;

	if (f > pseqdesc->numframes - 1)
		f = 0;
	else if (f < -0.01)
		f = -0.01;

	frame = (int)f;
	dadt = StudioEstimateInterpolant();
	s = (f - frame);

	pbone = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	StudioCalcBoneAdj(dadt, adj, m_pCurrentEntity->curstate.controller, m_pCurrentEntity->latched.prevcontroller, m_pCurrentEntity->mouth.mouthopen);

	for (i = 0; i < m_pStudioHeader->numbones; i++, pbone++, panim++)
	{
		StudioCalcBoneQuaterion(frame, s, pbone, panim, adj, q[i]);
		StudioCalcBonePosition(frame, s, pbone, panim, adj, pos[i]);
	}

	if (pseqdesc->motiontype & STUDIO_X)
		pos[pseqdesc->motionbone][0] = 0.0;

	if (pseqdesc->motiontype & STUDIO_Y)
		pos[pseqdesc->motionbone][1] = 0.0;

	if (pseqdesc->motiontype & STUDIO_Z)
		pos[pseqdesc->motionbone][2] = 0.0;

	s = 0 * ((1.0 - (f - (int)(f))) / (pseqdesc->numframes)) * m_pCurrentEntity->curstate.framerate;

	if (pseqdesc->motiontype & STUDIO_LX)
		pos[pseqdesc->motionbone][0] += s * pseqdesc->linearmovement[0];

	if (pseqdesc->motiontype & STUDIO_LY)
		pos[pseqdesc->motionbone][1] += s * pseqdesc->linearmovement[1];

	if (pseqdesc->motiontype & STUDIO_LZ)
		pos[pseqdesc->motionbone][2] += s * pseqdesc->linearmovement[2];
}

void CStudioModelRenderer::StudioFxTransform(cl_entity_t *ent, float transform[3][4])
{
	switch (ent->curstate.renderfx)
	{
		case kRenderFxDistort:
		case kRenderFxHologram:
		{
			if (Com_RandomLong(0, 49) == 0)
			{
				int axis = Com_RandomLong(0, 1);

				if (axis == 1)
					axis = 2;

				VectorScale( transform[axis], gEngfuncs.pfnRandomFloat(1,1.484), transform[axis] );
			}
			else if (Com_RandomLong(0, 49) == 0)
			{
				float offset;
				int axis = Com_RandomLong(0, 1);

				if (axis == 1)
					axis = 2;

				offset = gEngfuncs.pfnRandomFloat(-10, 10);
				transform[Com_RandomLong(0, 2)][3] += offset;
			}

			break;
		}

		case kRenderFxExplode:
		{
			float scale;

			scale = 1.0 + (m_clTime - ent->curstate.animtime) * 10.0;

			if (scale > 2)
				scale = 2;

			transform[0][1] *= scale;
			transform[1][1] *= scale;
			transform[2][1] *= scale;
			break;
		}
	}
}

float CStudioModelRenderer::StudioEstimateFrame(mstudioseqdesc_t *pseqdesc)
{
	double dfdt, f;

	if (m_fDoInterp)
	{
		if (m_clTime < m_pCurrentEntity->curstate.animtime)
			dfdt = 0;
		else
			dfdt = (m_clTime - m_pCurrentEntity->curstate.animtime) * m_pCurrentEntity->curstate.framerate * pseqdesc->fps;
	}
	else
		dfdt = 0;

	if (pseqdesc->numframes <= 1)
		f = 0;
	else
		f = (m_pCurrentEntity->curstate.frame * (pseqdesc->numframes - 1)) / 256.0;

	f += dfdt;

	if (pseqdesc->flags & STUDIO_LOOPING)
	{
		if (pseqdesc->numframes > 1)
			f -= (int)(f / (pseqdesc->numframes - 1)) * (pseqdesc->numframes - 1);

		if (f < 0)
			f += (pseqdesc->numframes - 1);
	}
	else
	{
		if (f >= pseqdesc->numframes - 1.001)
			f = pseqdesc->numframes - 1.001;

		if (f < 0.0)
			f = 0.0;
	}

	return f;
}

void CStudioModelRenderer::StudioSetupBones(void)
{
	int i;
	double f;

	mstudiobone_t *pbones;
	mstudioseqdesc_t *pseqdesc;
	mstudioanim_t *panim;

	static float pos[MAXSTUDIOBONES][3];
	static vec4_t q[MAXSTUDIOBONES];
	float bonematrix[3][4];

	static float pos2[MAXSTUDIOBONES][3];
	static vec4_t q2[MAXSTUDIOBONES];
	static float pos3[MAXSTUDIOBONES][3];
	static vec4_t q3[MAXSTUDIOBONES];
	static float pos4[MAXSTUDIOBONES][3];
	static vec4_t q4[MAXSTUDIOBONES];

	if (m_pCurrentEntity->curstate.sequence >= m_pStudioHeader->numseq)
		m_pCurrentEntity->curstate.sequence = 0;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	f = StudioEstimateFrame(pseqdesc);
	panim = StudioGetAnim(m_pRenderModel, pseqdesc);

	StudioCalcRotations(pos, q, pseqdesc, panim, f);

	if (pseqdesc->numblends > 1)
	{
		float s;
		float dadt;

		panim += m_pStudioHeader->numbones;
		StudioCalcRotations(pos2, q2, pseqdesc, panim, f);

		dadt = StudioEstimateInterpolant();
		s = (m_pCurrentEntity->curstate.blending[0] * dadt + m_pCurrentEntity->latched.prevblending[0] * (1.0 - dadt)) / 255.0;

		StudioSlerpBones(q, pos, q2, pos2, s);

		if (pseqdesc->numblends == 4)
		{
			panim += m_pStudioHeader->numbones;
			StudioCalcRotations(pos3, q3, pseqdesc, panim, f);

			panim += m_pStudioHeader->numbones;
			StudioCalcRotations(pos4, q4, pseqdesc, panim, f);

			s = (m_pCurrentEntity->curstate.blending[0] * dadt + m_pCurrentEntity->latched.prevblending[0] * (1.0 - dadt)) / 255.0;
			StudioSlerpBones(q3, pos3, q4, pos4, s);

			s = (m_pCurrentEntity->curstate.blending[1] * dadt + m_pCurrentEntity->latched.prevblending[1] * (1.0 - dadt)) / 255.0;
			StudioSlerpBones(q, pos, q3, pos3, s);
		}
	}

	if (m_fDoInterp && m_pCurrentEntity->latched.sequencetime && (m_pCurrentEntity->latched.sequencetime + 0.2 > m_clTime) && (m_pCurrentEntity->latched.prevsequence < m_pStudioHeader->numseq))
	{
		static float pos1b[MAXSTUDIOBONES][3];
		static vec4_t q1b[MAXSTUDIOBONES];
		float s;

		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->latched.prevsequence;
		panim = StudioGetAnim(m_pRenderModel, pseqdesc);

		StudioCalcRotations(pos1b, q1b, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);

		if (pseqdesc->numblends > 1)
		{
			panim += m_pStudioHeader->numbones;
			StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);

			s = (m_pCurrentEntity->latched.prevseqblending[0]) / 255.0;
			StudioSlerpBones(q1b, pos1b, q2, pos2, s);

			if (pseqdesc->numblends == 4)
			{
				panim += m_pStudioHeader->numbones;
				StudioCalcRotations(pos3, q3, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);

				panim += m_pStudioHeader->numbones;
				StudioCalcRotations(pos4, q4, pseqdesc, panim, m_pCurrentEntity->latched.prevframe);

				s = (m_pCurrentEntity->latched.prevseqblending[0]) / 255.0;
				StudioSlerpBones(q3, pos3, q4, pos4, s);

				s = (m_pCurrentEntity->latched.prevseqblending[1]) / 255.0;
				StudioSlerpBones(q1b, pos1b, q3, pos3, s);
			}
		}

		s = 1.0 - (m_clTime - m_pCurrentEntity->latched.sequencetime) / 0.2;
		StudioSlerpBones(q, pos, q1b, pos1b, s);
	}
	else
	{
		m_pCurrentEntity->latched.prevframe = f;
	}

	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	if (m_pPlayerInfo && m_pPlayerInfo->gaitsequence != 0)
	{
		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pPlayerInfo->gaitsequence;

		panim = StudioGetAnim(m_pRenderModel, pseqdesc);
		StudioCalcRotations(pos2, q2, pseqdesc, panim, m_pPlayerInfo->gaitframe);

		for (i = 0; i < m_pStudioHeader->numbones; i++)
		{
			if (strcmp(pbones[i].name, "Bip01 Spine") == 0)
				break;

			memcpy(pos[i], pos2[i], sizeof( pos[i]));
			memcpy(q[i], q2[i], sizeof( q[i]));
		}
	}

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		QuaternionMatrix(q[i], bonematrix);

		bonematrix[0][3] = pos[i][0];
		bonematrix[1][3] = pos[i][1];
		bonematrix[2][3] = pos[i][2];

		if (pbones[i].parent == -1)
		{
			if (IEngineStudio.IsHardware())
			{
				ConcatTransforms((*m_protationmatrix), bonematrix, (*m_pbonetransform)[i]);
				MatrixCopy((*m_pbonetransform)[i], (*m_plighttransform)[i]);
			}
			else
			{
				ConcatTransforms((*m_paliastransform), bonematrix, (*m_pbonetransform)[i]);
				ConcatTransforms((*m_protationmatrix), bonematrix, (*m_plighttransform)[i]);
			}

			StudioFxTransform(m_pCurrentEntity, (*m_pbonetransform)[i]);
		}
		else
		{
			ConcatTransforms((*m_pbonetransform)[pbones[i].parent], bonematrix, (*m_pbonetransform)[i]);
			ConcatTransforms((*m_plighttransform)[pbones[i].parent], bonematrix, (*m_plighttransform)[i]);
		}
	}
}

void CStudioModelRenderer::StudioSaveBones(void)
{
	int i;

	mstudiobone_t *pbones;
	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	m_nCachedBones = m_pStudioHeader->numbones;

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		strncpy(m_nCachedBoneNames[i], pbones[i].name, 32);
		MatrixCopy((*m_pbonetransform)[i], m_rgCachedBoneTransform[i]);
		MatrixCopy((*m_plighttransform)[i], m_rgCachedLightTransform[i]);
	}

}

void CStudioModelRenderer::StudioMergeBones(model_t *m_pSubModel)
{
	int i, j;
	double f;

	mstudiobone_t *pbones;
	mstudioseqdesc_t *pseqdesc;
	mstudioanim_t *panim;

	static float pos[MAXSTUDIOBONES][3];
	float bonematrix[3][4];
	static vec4_t q[MAXSTUDIOBONES];

	if( !m_pStudioHeader || !m_pCurrentEntity )
		return;

	if (m_pCurrentEntity->curstate.sequence >= m_pStudioHeader->numseq)
		m_pCurrentEntity->curstate.sequence = 0;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	f = StudioEstimateFrame(pseqdesc);

	/*if (m_pCurrentEntity->latched.prevframe > f)
	{
	}*/

	panim = StudioGetAnim(m_pSubModel, pseqdesc);
	StudioCalcRotations(pos, q, pseqdesc, panim, f);

	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	for (i = 0; i < m_pStudioHeader->numbones; i++)
	{
		for (j = 0; j < m_nCachedBones; j++)
		{
			if (stricmp(pbones[i].name, m_nCachedBoneNames[j]) == 0)
			{
				MatrixCopy(m_rgCachedBoneTransform[j], (*m_pbonetransform)[i]);
				MatrixCopy(m_rgCachedLightTransform[j], (*m_plighttransform)[i]);
				break;
			}
		}

		if (j >= m_nCachedBones)
		{
			QuaternionMatrix(q[i], bonematrix);

			bonematrix[0][3] = pos[i][0];
			bonematrix[1][3] = pos[i][1];
			bonematrix[2][3] = pos[i][2];

			if (pbones[i].parent == -1)
			{
				if (IEngineStudio.IsHardware())
				{
					ConcatTransforms((*m_protationmatrix), bonematrix, (*m_pbonetransform)[i]);
					MatrixCopy((*m_pbonetransform)[i], (*m_plighttransform)[i]);
				}
				else
				{
					ConcatTransforms((*m_paliastransform), bonematrix, (*m_pbonetransform)[i]);
					ConcatTransforms((*m_protationmatrix), bonematrix, (*m_plighttransform)[i]);
				}

				StudioFxTransform(m_pCurrentEntity, (*m_pbonetransform)[i]);
			}
			else
			{
				ConcatTransforms((*m_pbonetransform)[pbones[i].parent], bonematrix, (*m_pbonetransform)[i]);
				ConcatTransforms((*m_plighttransform)[pbones[i].parent], bonematrix, (*m_plighttransform)[i]);
			}
		}
	}
}

int CStudioModelRenderer::StudioDrawModel(int flags)
{
	m_pCurrentEntity = IEngineStudio.GetCurrentEntity();

	IEngineStudio.GetTimes(&m_nFrameCount, &m_clTime, &m_clOldTime);
	IEngineStudio.GetViewInfo(m_vRenderOrigin, m_vUp, m_vRight, m_vNormal);
	IEngineStudio.GetAliasScale(&m_fSoftwareXScale, &m_fSoftwareYScale);

	if (m_pCurrentEntity->curstate.renderfx == kRenderFxDeadPlayer)
	{
		entity_state_t deadplayer;

		int result;
		int save_interp;

		if (m_pCurrentEntity->curstate.renderamt <= 0 || m_pCurrentEntity->curstate.renderamt > gEngfuncs.GetMaxClients())
			return 0;

		deadplayer = *(IEngineStudio.GetPlayerState(m_pCurrentEntity->curstate.renderamt - 1));

		deadplayer.number = m_pCurrentEntity->curstate.renderamt;
		deadplayer.weaponmodel = 0;
		deadplayer.gaitsequence = 0;

		deadplayer.movetype = MOVETYPE_NONE;
		VectorCopy(m_pCurrentEntity->curstate.angles, deadplayer.angles);
		VectorCopy(m_pCurrentEntity->curstate.origin, deadplayer.origin);

		save_interp = m_fDoInterp;
		m_fDoInterp = 0;

		result = StudioDrawPlayer(flags, &deadplayer);

		m_fDoInterp = save_interp;
		return result;
	}

	m_pRenderModel = m_pCurrentEntity->model;
	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(m_pRenderModel);

	IEngineStudio.StudioSetHeader(m_pStudioHeader);
	IEngineStudio.SetRenderModel(m_pRenderModel);

	StudioSetUpTransform(0);

	if(m_pCurrentEntity == gEngfuncs.GetViewModel() && (gHUD.cl_righthand->value))
	{
		(*m_protationmatrix)[0][1] *= -1;
		(*m_protationmatrix)[1][1] *= -1;
		(*m_protationmatrix)[2][1] *= -1;

		//IEngineStudio.StudioSetCullState(true);
	}

	if (flags & STUDIO_RENDER)
	{
		if (!IEngineStudio.StudioCheckBBox())
			return 0;

		(*m_pModelsDrawn)++;
		(*m_pStudioModelCount)++;

		if (m_pStudioHeader->numbodyparts == 0)
			return 1;
	}

	if (m_pCurrentEntity->curstate.movetype == MOVETYPE_FOLLOW)
		StudioMergeBones(m_pRenderModel);
	else
		StudioSetupBones();

	StudioSaveBones();

	if (flags & STUDIO_EVENTS)
	{
		StudioCalcAttachments();
		IEngineStudio.StudioClientEvents();

		if (m_pCurrentEntity->index > 0)
		{
			cl_entity_t *ent = gEngfuncs.GetEntityByIndex(m_pCurrentEntity->index);
			memcpy(ent->attachment, m_pCurrentEntity->attachment, sizeof(vec3_t) * 4);
		}
	}

	if (flags & STUDIO_RENDER)
	{
		alight_t lighting;
		vec3_t dir;
		lighting.plightvec = dir;

		IEngineStudio.StudioDynamicLight(m_pCurrentEntity, &lighting);

		IEngineStudio.StudioEntityLight(&lighting);
		IEngineStudio.StudioSetupLighting(&lighting);

		m_nTopColor = m_pCurrentEntity->curstate.colormap & 0xFF;
		m_nBottomColor = (m_pCurrentEntity->curstate.colormap & 0xFF00) >> 8;

		IEngineStudio.StudioSetRemapColors(m_nTopColor, m_nBottomColor);

		StudioRenderModel(dir);
	}

	return 1;
}

void CStudioModelRenderer::StudioEstimateGait(entity_state_t *pplayer)
{
	float dt;
	vec3_t est_velocity;

	dt = (m_clTime - m_clOldTime);

	if (dt < 0)
		dt = 0;
	else if (dt > 1.0)
		dt = 1;

	if (dt == 0 || m_pPlayerInfo->renderframe == m_nFrameCount)
	{
		m_flGaitMovement = 0;
		return;
	}

	if (m_fGaitEstimation)
	{
		VectorSubtract(m_pCurrentEntity->origin, m_pPlayerInfo->prevgaitorigin, est_velocity);
		VectorCopy(m_pCurrentEntity->origin, m_pPlayerInfo->prevgaitorigin);
		m_flGaitMovement = est_velocity.Length();

		if (dt <= 0 || m_flGaitMovement / dt < 5)
		{
			m_flGaitMovement = 0;
			est_velocity[0] = 0;
			est_velocity[1] = 0;
		}
	}
	else
	{
		VectorCopy(pplayer->velocity, est_velocity);
		m_flGaitMovement = est_velocity.Length() * dt;
	}

	if (est_velocity[1] == 0 && est_velocity[0] == 0)
	{
		float flYawDiff = m_pCurrentEntity->angles[YAW] - m_pPlayerInfo->gaityaw;
		flYawDiff = flYawDiff - (int)(flYawDiff / 360) * 360;

		if (flYawDiff > 180)
			flYawDiff -= 360;
		if (flYawDiff < -180)
			flYawDiff += 360;

		if (dt < 0.25)
			flYawDiff *= dt * 4;
		else
			flYawDiff *= dt;

		m_pPlayerInfo->gaityaw += flYawDiff;
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - (int)(m_pPlayerInfo->gaityaw / 360) * 360;
		m_flGaitMovement = 0;
	}
	else
	{
		m_pPlayerInfo->gaityaw = (atan2(est_velocity[1], est_velocity[0]) * 180 / M_PI);

		if (m_pPlayerInfo->gaityaw > 180)
			m_pPlayerInfo->gaityaw = 180;

		if (m_pPlayerInfo->gaityaw < -180)
			m_pPlayerInfo->gaityaw = -180;
	}
}

void CStudioModelRenderer::StudioProcessGait(entity_state_t *pplayer)
{
	mstudioseqdesc_t *pseqdesc;
	float dt;
	int iBlend;
	float flYaw;

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pCurrentEntity->curstate.sequence;

	StudioPlayerBlend(pseqdesc, &iBlend, &m_pCurrentEntity->angles[PITCH]);

	m_pCurrentEntity->latched.prevangles[PITCH] = m_pCurrentEntity->angles[PITCH];
	m_pCurrentEntity->curstate.blending[0] = iBlend;
	m_pCurrentEntity->latched.prevblending[0] = m_pCurrentEntity->curstate.blending[0];
	m_pCurrentEntity->latched.prevseqblending[0] = m_pCurrentEntity->curstate.blending[0];

	dt = (m_clTime - m_clOldTime);

	if (dt < 0)
		dt = 0;
	else if (dt > 1.0)
		dt = 1;

	StudioEstimateGait(pplayer);

	flYaw = m_pCurrentEntity->angles[YAW] - m_pPlayerInfo->gaityaw;
	flYaw = flYaw - (int)(flYaw / 360) * 360;

	if (flYaw < -180)
		flYaw = flYaw + 360;

	if (flYaw > 180)
		flYaw = flYaw - 360;

	if (flYaw > 120)
	{
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - 180;
		m_flGaitMovement = -m_flGaitMovement;
		flYaw = flYaw - 180;
	}
	else if (flYaw < -120)
	{
		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw + 180;
		m_flGaitMovement = -m_flGaitMovement;
		flYaw = flYaw + 180;
	}

	m_pCurrentEntity->curstate.controller[0] = ((flYaw / 4.0) + 30) / (60.0 / 255.0);
	m_pCurrentEntity->curstate.controller[1] = ((flYaw / 4.0) + 30) / (60.0 / 255.0);
	m_pCurrentEntity->curstate.controller[2] = ((flYaw / 4.0) + 30) / (60.0 / 255.0);
	m_pCurrentEntity->curstate.controller[3] = ((flYaw / 4.0) + 30) / (60.0 / 255.0);
	m_pCurrentEntity->latched.prevcontroller[0] = m_pCurrentEntity->curstate.controller[0];
	m_pCurrentEntity->latched.prevcontroller[1] = m_pCurrentEntity->curstate.controller[1];
	m_pCurrentEntity->latched.prevcontroller[2] = m_pCurrentEntity->curstate.controller[2];
	m_pCurrentEntity->latched.prevcontroller[3] = m_pCurrentEntity->curstate.controller[3];

	m_pCurrentEntity->angles[YAW] = m_pPlayerInfo->gaityaw;

	if (m_pCurrentEntity->angles[YAW] < -0)
		m_pCurrentEntity->angles[YAW] += 360;

	m_pCurrentEntity->latched.prevangles[YAW] = m_pCurrentEntity->angles[YAW];

	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + pplayer->gaitsequence;

	if (pseqdesc->linearmovement[0] > 0)
		m_pPlayerInfo->gaitframe += (m_flGaitMovement / pseqdesc->linearmovement[0]) * pseqdesc->numframes;
	else
		m_pPlayerInfo->gaitframe += pseqdesc->fps * dt;

	m_pPlayerInfo->gaitframe = m_pPlayerInfo->gaitframe - (int)(m_pPlayerInfo->gaitframe / pseqdesc->numframes) * pseqdesc->numframes;

	if (m_pPlayerInfo->gaitframe < 0)
		m_pPlayerInfo->gaitframe += pseqdesc->numframes;
}

int CStudioModelRenderer::StudioDrawPlayer(int flags, entity_state_t *pplayer)
{
	m_pCurrentEntity = IEngineStudio.GetCurrentEntity();

	IEngineStudio.GetTimes(&m_nFrameCount, &m_clTime, &m_clOldTime);
	IEngineStudio.GetViewInfo(m_vRenderOrigin, m_vUp, m_vRight, m_vNormal);
	IEngineStudio.GetAliasScale(&m_fSoftwareXScale, &m_fSoftwareYScale);

	m_nPlayerIndex = pplayer->number - 1;

	if (m_nPlayerIndex < 0 || m_nPlayerIndex >= gEngfuncs.GetMaxClients())
		return 0;

	m_pRenderModel = IEngineStudio.SetupPlayerModel(m_nPlayerIndex);

	if (m_pRenderModel == NULL)
		return 0;

	m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(m_pRenderModel);

	IEngineStudio.StudioSetHeader(m_pStudioHeader);
	IEngineStudio.SetRenderModel(m_pRenderModel);

	if (pplayer->gaitsequence)
	{
		vec3_t orig_angles;
		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

		VectorCopy(m_pCurrentEntity->angles, orig_angles);

		StudioProcessGait(pplayer);

		m_pPlayerInfo->gaitsequence = pplayer->gaitsequence;
		m_pPlayerInfo = NULL;

		StudioSetUpTransform(0);
		VectorCopy(orig_angles, m_pCurrentEntity->angles);
	}
	else
	{
		m_pCurrentEntity->curstate.controller[0] = 127;
		m_pCurrentEntity->curstate.controller[1] = 127;
		m_pCurrentEntity->curstate.controller[2] = 127;
		m_pCurrentEntity->curstate.controller[3] = 127;
		m_pCurrentEntity->latched.prevcontroller[0] = m_pCurrentEntity->curstate.controller[0];
		m_pCurrentEntity->latched.prevcontroller[1] = m_pCurrentEntity->curstate.controller[1];
		m_pCurrentEntity->latched.prevcontroller[2] = m_pCurrentEntity->curstate.controller[2];
		m_pCurrentEntity->latched.prevcontroller[3] = m_pCurrentEntity->curstate.controller[3];

		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);
		m_pPlayerInfo->gaitsequence = 0;

		StudioSetUpTransform(0);
	}

	if (flags & STUDIO_RENDER)
	{
		if (!IEngineStudio.StudioCheckBBox())
			return 0;

		(*m_pModelsDrawn)++;
		(*m_pStudioModelCount)++;

		if (m_pStudioHeader->numbodyparts == 0)
			return 1;
	}

	m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

	StudioSetupBones();
	StudioSaveBones();

	m_pPlayerInfo->renderframe = m_nFrameCount;
	m_pPlayerInfo = NULL;

	if (flags & STUDIO_EVENTS)
	{
		StudioCalcAttachments();
		IEngineStudio.StudioClientEvents();

		if (m_pCurrentEntity->index > 0)
		{
			cl_entity_t *ent = gEngfuncs.GetEntityByIndex(m_pCurrentEntity->index);
			memcpy(ent->attachment, m_pCurrentEntity->attachment, sizeof(vec3_t) * 4);
		}
	}

	if (flags & STUDIO_RENDER)
	{
		if (m_pCvarHiModels->value && m_pRenderModel != m_pCurrentEntity->model)
			m_pCurrentEntity->curstate.body = 255;

		if (!(m_pCvarDeveloper->value == 0 && gEngfuncs.GetMaxClients() == 1) && (m_pRenderModel == m_pCurrentEntity->model))
			m_pCurrentEntity->curstate.body = 1;

		alight_t lighting;
		vec3_t dir;
		lighting.plightvec = dir;

		IEngineStudio.StudioDynamicLight(m_pCurrentEntity, &lighting);
		IEngineStudio.StudioEntityLight(&lighting);
		IEngineStudio.StudioSetupLighting(&lighting);

		m_pPlayerInfo = IEngineStudio.PlayerInfo(m_nPlayerIndex);

		m_nTopColor = m_pPlayerInfo->topcolor;

		if (m_nTopColor < 0)
			m_nTopColor = 0;

		if (m_nTopColor > 360)
			m_nTopColor = 360;

		m_nBottomColor = m_pPlayerInfo->bottomcolor;

		if (m_nBottomColor < 0)
			m_nBottomColor = 0;

		if (m_nBottomColor > 360)
			m_nBottomColor = 360;

		IEngineStudio.StudioSetRemapColors(m_nTopColor, m_nBottomColor);

		StudioRenderModel(dir);
		m_pPlayerInfo = NULL;

		if (pplayer->weaponmodel)
		{
			cl_entity_t saveent = *m_pCurrentEntity;
			model_t *pweaponmodel = IEngineStudio.GetModelByIndex(pplayer->weaponmodel);

			m_pStudioHeader = (studiohdr_t *)IEngineStudio.Mod_Extradata(pweaponmodel);
			IEngineStudio.StudioSetHeader(m_pStudioHeader);

			StudioMergeBones(pweaponmodel);

			IEngineStudio.StudioSetupLighting(&lighting);

			StudioRenderModel(dir);

			StudioCalcAttachments();

			*m_pCurrentEntity = saveent;
		}
	}

	return 1;
}

void CStudioModelRenderer::StudioCalcAttachments(void)
{
	int i;
	mstudioattachment_t *pattachment;

	if (m_pStudioHeader->numattachments > 4)
		gEngfuncs.Con_DPrintf("Too many attachments on %s\n", m_pCurrentEntity->model->name);

	pattachment = (mstudioattachment_t *)((byte *)m_pStudioHeader + m_pStudioHeader->attachmentindex);

	for (i = 0; i < m_pStudioHeader->numattachments; i++)
		VectorTransform(pattachment[i].org, (*m_plighttransform)[pattachment[i].bone], m_pCurrentEntity->attachment[i]);
}

void CStudioModelRenderer::StudioRenderModel(float *lightdir)
{
	IEngineStudio.SetChromeOrigin();

	int iSaveRenderMode =  m_pCurrentEntity->curstate.rendermode;
	int iSaveRenderFx = m_pCurrentEntity->curstate.renderfx;
	int iSaveRenderAmt = m_pCurrentEntity->curstate.renderamt;


	IEngineStudio.SetForceFaceFlags(0);
	StudioRenderFinal();

	if (iSaveRenderFx == kRenderFxGlowShell)
	{
		m_pCurrentEntity->curstate.renderfx = kRenderFxGlowShell;

		gEngfuncs.pTriAPI->SpriteTexture(m_pChromeSprite, 0);

		IEngineStudio.SetForceFaceFlags(STUDIO_NF_CHROME);
		StudioRenderFinal();
	}


	m_pCurrentEntity->curstate.rendermode = iSaveRenderMode;
	m_pCurrentEntity->curstate.renderfx = iSaveRenderFx;
	m_pCurrentEntity->curstate.renderamt = iSaveRenderAmt;
}

void CStudioModelRenderer::StudioRenderFinal_Software(void)
{
	int i;

	IEngineStudio.SetupRenderer(0);

	if (m_pCvarDrawEntities->value == 2)
	{
		IEngineStudio.StudioDrawBones();
	}
	else if (m_pCvarDrawEntities->value == 3)
	{
		IEngineStudio.StudioDrawHulls();
	}
	else
	{
		for (i = 0; i < m_pStudioHeader->numbodyparts; i++)
		{
			IEngineStudio.StudioSetupModel(i, (void **)&m_pBodyPart, (void **)&m_pSubModel);
			IEngineStudio.StudioDrawPoints();
		}
	}

	if (m_pCvarDrawEntities->value == 4)
	{
		gEngfuncs.pTriAPI->RenderMode(kRenderTransAdd);
		IEngineStudio.StudioDrawHulls();
		gEngfuncs.pTriAPI->RenderMode(kRenderNormal);
	}

	if (m_pCvarDrawEntities->value == 5)
		IEngineStudio.StudioDrawAbsBBox();

	IEngineStudio.RestoreRenderer();
}

void CStudioModelRenderer::StudioRenderFinal_Hardware(void)
{
	int i;
	int rendermode;

	rendermode = IEngineStudio.GetForceFaceFlags() ? kRenderTransAdd : m_pCurrentEntity->curstate.rendermode;
	IEngineStudio.SetupRenderer(rendermode);

	if (m_pCvarDrawEntities->value == 2)
	{
		IEngineStudio.StudioDrawBones();
	}
	else if (m_pCvarDrawEntities->value == 3)
	{
		IEngineStudio.StudioDrawHulls();
	}
	else
	{
		for (i = 0; i < m_pStudioHeader->numbodyparts; i++)
		{
			IEngineStudio.StudioSetupModel(i, (void **)&m_pBodyPart, (void **)&m_pSubModel);

			if (m_fDoInterp)
				m_pCurrentEntity->trivial_accept = 0;

			IEngineStudio.GL_SetRenderMode(rendermode);
			IEngineStudio.StudioSetRenderamt(m_pCurrentEntity->curstate.renderamt);
			IEngineStudio.StudioDrawPoints();
		}
	}

	if (m_pCvarDrawEntities->value == 4)
	{
		gEngfuncs.pTriAPI->RenderMode(kRenderTransAdd);
		IEngineStudio.StudioDrawHulls();
		gEngfuncs.pTriAPI->RenderMode(kRenderNormal);
	}

	IEngineStudio.RestoreRenderer();
}

void CStudioModelRenderer::StudioRenderFinal(void)
{
	if (IEngineStudio.IsHardware())
		StudioRenderFinal_Hardware();
	else
		StudioRenderFinal_Software();
}

void CStudioModelRenderer::StudioSetShadowSprite(int idx)
{
	m_iShadowSprite = idx;
}

void CStudioModelRenderer::StudioDrawShadow( Vector origin, float scale )
{
	Vector endPoint = origin;
	Vector p1, p2, p3, p4;
	pmtrace_t pmtrace;

	endPoint.z -= 150.0f;

	gEngfuncs.pEventAPI->EV_SetUpPlayerPrediction( false, true );
	gEngfuncs.pEventAPI->EV_PushPMStates( );
		gEngfuncs.pEventAPI->EV_SetSolidPlayers( -1 );
		gEngfuncs.pEventAPI->EV_SetTraceHull( 2 );
		gEngfuncs.pEventAPI->EV_PlayerTrace( origin, endPoint, PM_STUDIO_IGNORE | PM_GLASS_IGNORE, -1, &pmtrace );
	gEngfuncs.pEventAPI->EV_PopPMStates( );

	// don't allow shadow if player in solid area
	if( pmtrace.startsolid )
		return;

	// don't allow shadow if doesn't hit anything
	if( pmtrace.fraction >= 1.0f )
		return;

	pmtrace.plane.normal = pmtrace.plane.normal.Normalize( );

	// don't allow shadow on too lean planes
	if( pmtrace.plane.normal.z <= 0.7 )
		return;

	pmtrace.plane.normal = pmtrace.plane.normal * scale * ( 1.0 - pmtrace.fraction );


	// add 2.0f to Z, for avoid Z-fighting
	p1.x = pmtrace.endpos.x - pmtrace.plane.normal.z;
	p1.y = pmtrace.endpos.y + pmtrace.plane.normal.z;
	p1.z = pmtrace.endpos.z + 2.0f + pmtrace.plane.normal.x - pmtrace.plane.normal.y;

	p2.x = pmtrace.endpos.x + pmtrace.plane.normal.z;
	p2.y = pmtrace.endpos.y + pmtrace.plane.normal.z;
	p2.z = pmtrace.endpos.z + 2.0f - pmtrace.plane.normal.x - pmtrace.plane.normal.y;

	p3.x = pmtrace.endpos.x + pmtrace.plane.normal.z;
	p3.y = pmtrace.endpos.y - pmtrace.plane.normal.z;
	p3.z = pmtrace.endpos.z + 2.0f - pmtrace.plane.normal.x + pmtrace.plane.normal.y;

	p4.x = pmtrace.endpos.x - pmtrace.plane.normal.z;
	p4.y = pmtrace.endpos.y - pmtrace.plane.normal.z;
	p4.z = pmtrace.endpos.z + 2.0f + pmtrace.plane.normal.x + pmtrace.plane.normal.y;

	IEngineStudio.StudioRenderShadow( m_iShadowSprite, p1, p2, p3, p4 );
}

```

`cl_dll/studio/studio_util.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include <memory.h>
#include "hud.h"
#include "cl_util.h"
#include "const.h"
#include "com_model.h"
#include "studio_util.h"

#ifdef VECTORIZE_SINCOS

// Test shown that this is not so effictively
#if defined(__SSE__) || defined(_M_IX86_FP)
#if defined(__SSE2__) || defined(_M_IX86_FP)
  #define USE_SSE2
 #endif
#include "sse_mathfun.h"
#endif


#if defined(__ARM_NEON__) || defined(__NEON__)
	#include "neon_mathfun.h"
#endif


void SinCosFastVector(float r1, float r2, float r3, float r4,
					  float *s0, float *s1, float *s2, float *s3,
					  float *c0, float *c1, float *c2, float *c3)
{
	v4sf rad_vector = {r1, r2, r3, r4};
	v4sf sin_vector, cos_vector;

	sincos_ps(rad_vector, &sin_vector, &cos_vector);

	*s0 = sin_vector[0];
	if(s1) *s1 = sin_vector[1];
	if(s2) *s2 = sin_vector[2];
	if(s3) *s3 = sin_vector[3];

	*c0 = cos_vector[0];
	if(s1) *c1 = cos_vector[1];
	if(s2) *c2 = cos_vector[2];
	if(s3) *c3 = cos_vector[3];
}
#endif


/*
====================
AngleMatrix

====================
*/
/* // defined in pm_math.cpp
void AngleMatrix (const float *angles, float (*matrix)[4] )
{
	float		sr, sp, sy, cr, cp, cy;
	

#ifdef VECTORIZE_SINCOS
	SinCosFastVector( DEG2RAD(angles[YAW]),
					  DEG2RAD(angles[PITCH]),
					  DEG2RAD(angles[ROLL]), 0,
					  &sy, &sp, &sr, NULL,
					  &cy, &cp, &cr, NULL);
#else
	float		angle;

	angle = angles[YAW] * (M_PI*2 / 360);
	sy = sin(angle);
	cy = cos(angle);
	angle = angles[PITCH] * (M_PI*2 / 360);
	sp = sin(angle);
	cp = cos(angle);
	angle = angles[ROLL] * (M_PI*2 / 360);
	sr = sin(angle);
	cr = cos(angle);
#endif

	// matrix = (YAW * PITCH) * ROLL
	matrix[0][0] = cp*cy;
	matrix[1][0] = cp*sy;
	matrix[2][0] = -sp;
	matrix[0][1] = sr*sp*cy+cr*-sy;
	matrix[1][1] = sr*sp*sy+cr*cy;
	matrix[2][1] = sr*cp;
	matrix[0][2] = (cr*sp*cy+-sr*-sy);
	matrix[1][2] = (cr*sp*sy+-sr*cy);
	matrix[2][2] = cr*cp;
	matrix[0][3] = 0.0;
	matrix[1][3] = 0.0;
	matrix[2][3] = 0.0;
}
*/
/*
====================
VectorCompare

====================
*//* //defined in pm_math.cpp
int VectorCompare (const float *v1, const float *v2)
{
	int		i;
	
	for (i=0 ; i<3 ; i++)
		if (v1[i] != v2[i])
			return 0;
			
	return 1;
}
*/
/*
====================
CrossProduct

====================
*/
void CrossProduct (const float *v1, const float *v2, float *cross)
{
	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];
	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];
	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];
}

/*
====================
VectorTransform

====================
*/ /* defined in pm_math.cpp
void VectorTransform (const float *in1, float in2[3][4], float *out)
{
	out[0] = DotProduct(in1, in2[0]) + in2[0][3];
	out[1] = DotProduct(in1, in2[1]) + in2[1][3];
	out[2] = DotProduct(in1, in2[2]) + in2[2][3];
}*/

/*
================
ConcatTransforms

================
*/
void ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4])
{
	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] + in1[0][2] * in2[2][0];
	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] + in1[0][2] * in2[2][1];
	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +	in1[0][2] * in2[2][2];
	out[0][3] = in1[0][0] * in2[0][3] + in1[0][1] * in2[1][3] +	in1[0][2] * in2[2][3] + in1[0][3];
	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +	in1[1][2] * in2[2][0];
	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +	in1[1][2] * in2[2][1];
	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +	in1[1][2] * in2[2][2];
	out[1][3] = in1[1][0] * in2[0][3] + in1[1][1] * in2[1][3] +	in1[1][2] * in2[2][3] + in1[1][3];
	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +	in1[2][2] * in2[2][0];
	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +	in1[2][2] * in2[2][1];
	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +	in1[2][2] * in2[2][2];
	out[2][3] = in1[2][0] * in2[0][3] + in1[2][1] * in2[1][3] +	in1[2][2] * in2[2][3] + in1[2][3];
}

// angles index are not the same as ROLL, PITCH, YAW

/*
====================
AngleQuaternion

====================
*/
void AngleQuaternion( float *angles, vec4_t quaternion )
{
	float		sr, sp, sy, cr, cp, cy;

#ifdef VECTORIZE_SINCOS
	SinCosFastVector( angles[2] * 0.5,
					  angles[1] * 0.5,
					  angles[0] * 0.5, 0,
					  &sy, &sp, &sr, NULL,
					  &cy, &cp, &cr, NULL);
#else
	float		angle;

	// FIXME: rescale the inputs to 1/2 angle
	angle = angles[2] * 0.5;
	sy = sin(angle);
	cy = cos(angle);
	angle = angles[1] * 0.5;
	sp = sin(angle);
	cp = cos(angle);
	angle = angles[0] * 0.5;
	sr = sin(angle);
	cr = cos(angle);
#endif

	quaternion[0] = sr * cp * cy - cr * sp * sy; // X
	quaternion[1] = cr * sp * cy + sr * cp * sy; // Y
	quaternion[2] = cr * cp * sy - sr * sp * cy; // Z
	quaternion[3] = cr * cp * cy + sr * sp * sy; // W
}

/*
====================
QuaternionSlerp

====================
*/
void QuaternionSlerp( vec4_t p, vec4_t q, float t, vec4_t qt )
{
	int i;
	float	omega, cosom, sinom, sclp, sclq;

	// decide if one of the quaternions is backwards
	float a = 0;
	float b = 0;

	for (i = 0; i < 4; i++)
	{
		a += (p[i]-q[i])*(p[i]-q[i]);
		b += (p[i]+q[i])*(p[i]+q[i]);
	}
	if (a > b)
	{
		for (i = 0; i < 4; i++)
		{
			q[i] = -q[i];
		}
	}

	cosom = p[0]*q[0] + p[1]*q[1] + p[2]*q[2] + p[3]*q[3];

	if ((1.0 + cosom) > 0.000001)
	{
		if ((1.0 - cosom) > 0.000001)
		{
			omega = acos( cosom );
			sinom = sin( omega );
			sclp = sin( (1.0 - t)*omega) / sinom;
			sclq = sin( t*omega ) / sinom;
		}
		else
		{
			sclp = 1.0 - t;
			sclq = t;
		}
		for (i = 0; i < 4; i++) {
			qt[i] = sclp * p[i] + sclq * q[i];
		}
	}
	else
	{
		qt[0] = -q[1];
		qt[1] = q[0];
		qt[2] = -q[3];
		qt[3] = q[2];
		sclp = sin( (1.0 - t) * (0.5 * M_PI));
		sclq = sin( t * (0.5 * M_PI));
		for (i = 0; i < 3; i++)
		{
			qt[i] = sclp * p[i] + sclq * qt[i];
		}
	}
}

/*
====================
QuaternionMatrix

====================
*/
void QuaternionMatrix( vec4_t quaternion, float (*matrix)[4] )
{
	matrix[0][0] = 1.0 - 2.0 * quaternion[1] * quaternion[1] - 2.0 * quaternion[2] * quaternion[2];
	matrix[1][0] = 2.0 * quaternion[0] * quaternion[1] + 2.0 * quaternion[3] * quaternion[2];
	matrix[2][0] = 2.0 * quaternion[0] * quaternion[2] - 2.0 * quaternion[3] * quaternion[1];

	matrix[0][1] = 2.0 * quaternion[0] * quaternion[1] - 2.0 * quaternion[3] * quaternion[2];
	matrix[1][1] = 1.0 - 2.0 * quaternion[0] * quaternion[0] - 2.0 * quaternion[2] * quaternion[2];
	matrix[2][1] = 2.0 * quaternion[1] * quaternion[2] + 2.0 * quaternion[3] * quaternion[0];

	matrix[0][2] = 2.0 * quaternion[0] * quaternion[2] + 2.0 * quaternion[3] * quaternion[1];
	matrix[1][2] = 2.0 * quaternion[1] * quaternion[2] - 2.0 * quaternion[3] * quaternion[0];
	matrix[2][2] = 1.0 - 2.0 * quaternion[0] * quaternion[0] - 2.0 * quaternion[1] * quaternion[1];
}

/*
====================
MatrixCopy

====================
*/
void MatrixCopy( float in[3][4], float out[3][4] )
{
	memcpy( out, in, sizeof( float ) * 3 * 4 );
}

```

`cl_dll/tri.cpp`:

```cpp
//========= Copyright ? 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose:
//
// $NoKeywords: $
//=============================================================================

// Triangle rendering, if any
#include "hud.h"
#include "cl_util.h"

// Triangle rendering apis are in gEngfuncs.pTriAPI
#include "const.h"
#include "entity_state.h"
#include "cl_entity.h"
#include "triangleapi.h"
#include "rain.h"

/*
=================
HUD_DrawNormalTriangles

Non-transparent triangles-- add them here
=================
*/
void DLLEXPORT HUD_DrawNormalTriangles( void )
{
	gHUD.m_Spectator.DrawOverview();
}

/*
=================
HUD_DrawTransparentTriangles

Render any triangles with transparent rendermode needs here
=================
*/
void DLLEXPORT HUD_DrawTransparentTriangles( void )
{
	ProcessFXObjects();
	ProcessRain();
	DrawRain();
	DrawFXObjects();
}

```

`cl_dll/unicode_strtools.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/
#include <extdll.h>
#include "unicode_strtools.h"
#ifndef _MSC_VER
#include <wctype.h>
#endif

/* <f2fc1> ../engine/unicode_strtools.cpp:23 */
//-----------------------------------------------------------------------------
// Purpose: determine if a uchar32 represents a valid Unicode code point
//-----------------------------------------------------------------------------
bool Q_IsValidUChar32(uchar32 uVal)
{
	// Values > 0x10FFFF are explicitly invalid; ditto for UTF-16 surrogate halves,
	// values ending in FFFE or FFFF, or values in the 0x00FDD0-0x00FDEF reserved range
	return (uVal < 0x110000u) && ((uVal - 0x00D800u) > 0x7FFu) && ((uVal & 0xFFFFu) < 0xFFFEu) && ((uVal - 0x00FDD0u) > 0x1Fu);
}

/* <f38f8> ../engine/unicode_strtools.cpp:50 */
int Q_UTF32ToUChar32(const uchar32 *pUTF32, uchar32 &uVal, bool &bErr)
{
	if (Q_IsValidUChar32(pUTF32[0]))
	{
		uVal = pUTF32[0];
		bErr = false;
		return 1;
	}
	else if (pUTF32[0] - 55296 >= 0x400 || (pUTF32[1] - 56320) >= 0x400)
	{
		uVal = 63;
		bErr = true;
		return 1;
	}
	else
	{
		uVal = pUTF32[1] + ((uchar32)(pUTF32[0] - 55287) << 10);
		if (Q_IsValidUChar32(uVal))
		{
			bErr = false;
		}
		else
		{
			uVal = 63;
			bErr = true;
		}
		return 2;
	}
}

/* <f2fab> ../engine/unicode_strtools.cpp:57 */
int Q_UChar32ToUTF32Len(uchar32 uVal)
{
	return (uVal > 0xFFFF) ? 2 : 1;
}

/* <f330f> ../engine/unicode_strtools.cpp:62 */
int Q_UChar32ToUTF32(uchar32 uVal, uchar32 *pUTF32)
{
	if (uVal <= 0xFFFF)
	{
		pUTF32[0] = uVal;
		return 1;
	}
	else
	{
		pUTF32[1] = (uVal & 0x3FF) | 0xDC00;
		pUTF32[0] = ((uVal - 0x10000) >> 10) | 0xD800;
		return 2;
	}
}

/* <f4344> ../engine/unicode_strtools.cpp:70 */
template<
	typename T_IN,
	typename T_OUT,
	bool UNK,
	qboolean(*IN_TO_UCHAR32)(const T_IN *pUTF8, uchar32 &uValueOut, bool &bErrorOut),
	int(UCHAR32_TO_OUT_LEN)(uchar32 uVal),
	int(UCHAR32_TO_OUT)(uchar32 uVal, T_OUT *pUTF8Out)
>
int Q_UnicodeConvertT(const T_IN *pIn, T_OUT *pOut, int nOutBytes, EStringConvertErrorPolicy ePolicy)
{
	int nOut = 0;
	if (pOut)
	{
		int nMaxOut = nOutBytes / sizeof(T_OUT) - 1;
		if (nMaxOut <= 0)
			return 0;

		while (*pIn)
		{
			bool bErr;
			uchar32 uVal;
			pIn += IN_TO_UCHAR32(pIn, uVal, bErr);
			int nOutElems = UCHAR32_TO_OUT_LEN(uVal);
			if (nOutElems + nOut > nMaxOut)
				break;
			nOut += UCHAR32_TO_OUT(uVal, &pOut[nOut]);
			if (bErr)
			{
				if (ePolicy & STRINGCONVERT_SKIP)
				{
					nOut -= nOutElems;
				}
				else if (ePolicy & STRINGCONVERT_FAIL)
				{
					pOut[0] = 0;
					return 0;
				}

			}
		}

		pOut[nOut] = 0;
	}
	else
	{
		while (*pIn)
		{
			bool bErr;
			uchar32 uVal;
			pIn += IN_TO_UCHAR32(pIn, uVal, bErr);
			int nOutElems = UCHAR32_TO_OUT_LEN(uVal);
			if (bErr)
			{
				if (ePolicy & STRINGCONVERT_SKIP)
				{
					nOut -= nOutElems;
				}
				else if (ePolicy & STRINGCONVERT_FAIL)
				{
					pOut[0] = 0; //FIXME: pOut is always null there
					//TODO: V522 Dereferencing of the null pointer 'pOut' might take place.

					return 0;
				}

			}
		}
	}
	return (nOut + 1) * sizeof(T_OUT);
}

/* <f2fe5> ../engine/unicode_strtools.cpp:137 */
int Q_UChar32ToUTF8Len(uchar32 uVal)
{
	if (uVal <= 0x7F)
		return 1;

	if (uVal > 0x7FF)
		return (uVal > 0xFFFF) + 3;
	else
		return 2;
}

/* <f3030> ../engine/unicode_strtools.cpp:152 */
int Q_UChar32ToUTF16Len(uchar32 uVal)
{
	return (uVal > 0xFFFF) ? 2 : 1;
}

/* <f3002> ../engine/unicode_strtools.cpp:163 */
int Q_UChar32ToUTF16(uchar32 uVal, uchar16 *pUTF16Out)
{
	if (uVal <= 0xFFFF)
	{
		pUTF16Out[0] = uVal;
		return 1;
	}
	else
	{
		pUTF16Out[1] = (uVal & 0x3FF) | 0xDC00;
		pUTF16Out[0] = ((uVal - 0x10000) >> 10) | 0xD800;
		return 2;
	}
}

/* <f3192> ../engine/unicode_strtools.cpp:180 */
int Q_UChar32ToUTF8(uchar32 uVal, char *pUTF8Out)
{
	if (uVal <= 0x7F)
	{
		*pUTF8Out = uVal;
		return 1;
	}
	else if (uVal <= 0x7FF)
	{
		*pUTF8Out = (uVal >> 6) | 0xC0;
		pUTF8Out[1] = (uVal & 0x3F) | 0x80;
		return 2;
	}
	else if (uVal <= 0xFFFF)
	{
		*pUTF8Out = (uVal >> 12) | 0xE0;
		pUTF8Out[2] = (uVal & 0x3F) | 0x80;
		pUTF8Out[1] = ((uVal >> 6) & 0x3F) | 0x80;
		return 3;
	}
	else
	{
		*pUTF8Out = ((uVal >> 18) & 7) | 0xF0;
		pUTF8Out[1] = ((uVal >> 12) & 0x3F) | 0x80;
		pUTF8Out[3] = (uVal & 0x3F) | 0x80;
		pUTF8Out[2] = ((uVal >> 6) & 0x3F) | 0x80;
		return 4;
	}
}

/* <f32b4> ../engine/unicode_strtools.cpp:209 */
int Q_UTF16ToUChar32(const uchar16 *pUTF16, uchar32 &uValueOut, bool &bErrorOut)
{
	if (Q_IsValidUChar32(pUTF16[0]))
	{
		uValueOut = pUTF16[0];
		bErrorOut = false;
		return 1;
	}
	else if (pUTF16[0] - 55296 >= 0x400 || (pUTF16[1] - 56320) >= 0x400)
	{
		uValueOut = 63;
		bErrorOut = true;
		return 1;
	}
	else
	{
		uValueOut = pUTF16[1] + ((uchar32)(pUTF16[0] - 55287) << 10);
		if (Q_IsValidUChar32(uValueOut))
		{
			bErrorOut = false;
		}
		else
		{
			uValueOut = 63;
			bErrorOut = true;
		}
		return 2;
	}
}

/* <f4468> ../engine/unicode_strtools.cpp:246 */
int Q_UTF8ToUTF16(const char *pUTF8, uchar16 *pUTF16, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<char, uchar16, true, Q_UTF8ToUChar32, Q_UChar32ToUTF16Len, Q_UChar32ToUTF16>(pUTF8, pUTF16, cubDestSizeInBytes, ePolicy);
}

/* <f3822> ../engine/unicode_strtools.cpp:254 */
int Q_UTF8ToUTF32(const char *pUTF8, uchar32 *pUTF32, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<char, uchar32, true, Q_UTF8ToUChar32, Q_UChar32ToUTF32Len, Q_UChar32ToUTF32>(pUTF8, pUTF32, cubDestSizeInBytes, ePolicy);
}

/* <f3d09> ../engine/unicode_strtools.cpp:262 */
int Q_UTF16ToUTF8(const uchar16 *pUTF16, char *pUTF8, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<uchar16, char, true, Q_UTF16ToUChar32, Q_UChar32ToUTF8Len, Q_UChar32ToUTF8>(pUTF16, pUTF8, cubDestSizeInBytes, ePolicy);
}

/* <f3f0d> ../engine/unicode_strtools.cpp:270 */
int Q_UTF16ToUTF32(const uchar16 *pUTF16, uchar32 *pUTF32, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<uchar16, uchar32, true, Q_UTF16ToUChar32, Q_UChar32ToUTF32Len, Q_UChar32ToUTF32>(pUTF16, pUTF32, cubDestSizeInBytes, ePolicy);
}

/* <f38aa> ../engine/unicode_strtools.cpp:278 */
int Q_UTF32ToUTF8(const uchar32 *pUTF32, char *pUTF8, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<uchar32, char, true, Q_UTF32ToUChar32, Q_UChar32ToUTF8Len, Q_UChar32ToUTF8>(pUTF32, pUTF8, cubDestSizeInBytes, ePolicy);
}

/* <f404a> ../engine/unicode_strtools.cpp:286 */
int Q_UTF32ToUTF16(const uchar32 *pUTF32, uchar16 *pUTF16, int cubDestSizeInBytes, EStringConvertErrorPolicy ePolicy)
{
	return Q_UnicodeConvertT<uchar32, uchar16, true, Q_UTF32ToUChar32, Q_UChar32ToUTF16Len, Q_UChar32ToUTF16>(pUTF32, pUTF16, cubDestSizeInBytes, ePolicy);
}

/* <f4251> ../engine/unicode_strtools.cpp:346 */
// Decode one character from a UTF-8 encoded string. Treats 6-byte CESU-8 sequences
// as a single character, as if they were a correctly-encoded 4-byte UTF-8 sequence.
int Q_UTF8ToUChar32(const char *pUTF8_, uchar32 &uValueOut, bool &bErrorOut)
{
	const byte *pUTF8 = (const byte *)pUTF8_;

	int nBytes = 1;
	uint32 uValue = pUTF8[0];
	uint32 uMinValue = 0;

	// 0....... single byte
	if (uValue < 0x80)
		goto decodeFinishedNoCheck;

	// Expecting at least a two-byte sequence with 0xC0 <= first <= 0xF7 (110...... and 11110...)
	if ((uValue - 0xC0u) > 0x37u || (pUTF8[1] & 0xC0) != 0x80)
		goto decodeError;

	uValue = (uValue << 6) - (0xC0 << 6) + pUTF8[1] - 0x80;
	nBytes = 2;
	uMinValue = 0x80;

	// 110..... two-byte lead byte
	if (!(uValue & (0x20 << 6)))
		goto decodeFinished;

	// Expecting at least a three-byte sequence
	if ((pUTF8[2] & 0xC0) != 0x80)
		goto decodeError;

	uValue = (uValue << 6) - (0x20 << 12) + pUTF8[2] - 0x80;
	nBytes = 3;
	uMinValue = 0x800;

	// 1110.... three-byte lead byte
	if (!(uValue & (0x10 << 12)))
		goto decodeFinishedMaybeCESU8;

	// Expecting a four-byte sequence, longest permissible in UTF-8
	if ((pUTF8[3] & 0xC0) != 0x80)
		goto decodeError;

	uValue = (uValue << 6) - (0x10 << 18) + pUTF8[3] - 0x80;
	nBytes = 4;
	uMinValue = 0x10000;

	// 11110... four-byte lead byte. fall through to finished.

decodeFinished:
	if (uValue >= uMinValue && Q_IsValidUChar32(uValue))
	{
decodeFinishedNoCheck:
		uValueOut = uValue;
		bErrorOut = false;
		return nBytes;
	}
decodeError:
	uValueOut = '?';
	bErrorOut = true;
	return nBytes;

decodeFinishedMaybeCESU8:
	// Do we have a full UTF-16 surrogate pair that's been UTF-8 encoded afterwards?
	// That is, do we have 0xD800-0xDBFF followed by 0xDC00-0xDFFF? If so, decode it all.
	if ((uValue - 0xD800u) < 0x400u && pUTF8[3] == 0xED && (byte)(pUTF8[4] - 0xB0) < 0x10 && (pUTF8[5] & 0xC0) == 0x80)
	{
		uValue = 0x10000 + ((uValue - 0xD800u) << 10) + ((byte)(pUTF8[4] - 0xB0) << 6) + pUTF8[5] - 0x80;
		nBytes = 6;
		uMinValue = 0x10000;
	}
	goto decodeFinished;
}

/* <f45fd> ../engine/unicode_strtools.cpp:423 */
//-----------------------------------------------------------------------------
// Purpose: Returns false if UTF-8 string contains invalid sequences.
//-----------------------------------------------------------------------------
qboolean Q_UnicodeValidate(const char *pUTF8)
{
	bool bError = false;
	while (*pUTF8)
	{
		uchar32 uVal;
		// Our UTF-8 decoder silently fixes up 6-byte CESU-8 (improperly re-encoded UTF-16) sequences.
		// However, these are technically not valid UTF-8. So if we eat 6 bytes at once, it's an error.
		int nCharSize = Q_UTF8ToUChar32(pUTF8, uVal, bError);
		if (bError || nCharSize == 6)
			return false;
		pUTF8 += nCharSize;
	}
	return true;
}

/* <f4665> ../engine/unicode_strtools.cpp:442 */
int Q_UnicodeLength(const char *pUTF8)
{
	int nChars = 0;

	while (*pUTF8)
	{
		bool bError;
		uchar32 uVal;

		pUTF8 += Q_UTF8ToUChar32(pUTF8, uVal, bError);

		++nChars;
	}

	return nChars;
}

/* <f46d1> ../engine/unicode_strtools.cpp:459 */
char *Q_UnicodeAdvance(char *pUTF8, int nChars)
{
	uchar32 uVal = 0;
	bool bError = false;

	while (nChars > 0 && *pUTF8)
	{
		pUTF8 += Q_UTF8ToUChar32(pUTF8, uVal, bError);
		--nChars;
	}

	return pUTF8;
}

wchar_t *Q_AdvanceSpace (wchar_t *start)
{
   while (*start != 0 && iswspace (*start))
      start++;

   return start;
}

wchar_t *Q_ReadUToken (wchar_t *start, wchar_t *token, int tokenBufferSize, bool &quoted)
{
   // skip over any whitespace
   start = Q_AdvanceSpace (start);
   quoted = false;
   *token = 0;

   if (!*start)
   {
      return start;
   }

   // check to see if it's a quoted string
   if (*start == '\"')
   {
      quoted = true;
      // copy out the string until we hit an end quote
      start++;
      int count = 0;
      while (*start && *start != '\"' && count < tokenBufferSize - 1)
      {
         // check for special characters
         if (*start == '\\' && *(start + 1) == 'n')
         {
            start++;
            *token = '\n';
         }
         else if (*start == '\\' && *(start + 1) == '\"')
         {
            start++;
            *token = '\"';
         }
         else
         {
            *token = *start;
         }

         start++;
         token++;
         count++;
      }

      if (*start == '\"')
      {
         start++;
      }
   }
   else
   {
      // copy out the string until we hit a whitespace
      int count = 0;
      while (*start && !iswspace (*start) && count < tokenBufferSize - 1)
      {
         // no checking for special characters if it's not a quoted string
         *token = *start;

         start++;
         token++;
         count++;
      }
   }

   *token = 0;
   return start;
}

/* <f4737> ../engine/unicode_strtools.cpp:479 */
//-----------------------------------------------------------------------------
// Purpose: returns true if a wide character is a "mean" space; that is,
//			if it is technically a space or punctuation, but causes disruptive
//			behavior when used in names, web pages, chat windows, etc.
//
//			characters in this set are removed from the beginning and/or end of strings
//			by Q_AggressiveStripPrecedingAndTrailingWhitespaceW() 
//-----------------------------------------------------------------------------
bool Q_IsMeanSpaceW(uchar32 wch)
{
	bool bIsMean = false;

	switch (wch)
	{
	case 0x0082:	// BREAK PERMITTED HERE
	case 0x0083:	// NO BREAK PERMITTED HERE
	case 0x00A0:	// NO-BREAK SPACE
	case 0x034F:	// COMBINING GRAPHEME JOINER
	case 0x2000:	// EN QUAD
	case 0x2001:	// EM QUAD
	case 0x2002:	// EN SPACE
	case 0x2003:	// EM SPACE
	case 0x2004:	// THICK SPACE
	case 0x2005:	// MID SPACE
	case 0x2006:	// SIX SPACE
	case 0x2007:	// figure space
	case 0x2008:	// PUNCTUATION SPACE
	case 0x2009:	// THIN SPACE
	case 0x200A:	// HAIR SPACE
	case 0x200B:	// ZERO-WIDTH SPACE
	case 0x200C:	// ZERO-WIDTH NON-JOINER
	case 0x200D:	// ZERO WIDTH JOINER
	case 0x2028:	// LINE SEPARATOR
	case 0x2029:	// PARAGRAPH SEPARATOR
	case 0x202F:	// NARROW NO-BREAK SPACE
	case 0x2060:	// word joiner
	case 0xFEFF:	// ZERO-WIDTH NO BREAK SPACE
	case 0xFFFC:	// OBJECT REPLACEMENT CHARACTER
		bIsMean = true;
		break;
	}

	return bIsMean;
}

/* <f37f5> ../engine/unicode_strtools.cpp:566 */
bool Q_IsDeprecatedW(uchar16 wch)
{
	bool bIsDeprecated = false;

	switch (wch)
	{
	case 0x202A:
	case 0x202B:
	case 0x202C:
	case 0x202D:
	case 0x202E:
	case 0x206A:
	case 0x206B:
	case 0x206C:
	case 0x206D:
	case 0x206E:
	case 0x206F:
		bIsDeprecated = true;
		break;
	}

	return bIsDeprecated;
}

/* <f47bc> ../engine/unicode_strtools.cpp:600 */
//-----------------------------------------------------------------------------
// Purpose: strips trailing whitespace; returns pointer inside string just past
// any leading whitespace.
//
// bAggresive = true causes this function to also check for "mean" spaces,
// which we don't want in persona names or chat strings as they're disruptive
// to the user experience.
//-----------------------------------------------------------------------------
static uchar16 *StripWhitespaceWorker(uchar16 *pwch, int cchLength, bool *pbStrippedWhitespace)
{
	// walk backwards from the end of the string, killing any whitespace
	*pbStrippedWhitespace = false;

	uchar16 *pwchEnd = pwch + cchLength;
	while (--pwchEnd >= pwch)
	{
		if (!iswspace(*pwchEnd) && !Q_IsMeanSpaceW(*pwchEnd))
			break;

		*pwchEnd = 0;
		*pbStrippedWhitespace = true;
	}

	// walk forward in the string
	while (pwch < pwchEnd)
	{
		if (!iswspace(*pwch))
			break;

		*pbStrippedWhitespace = true;
		pwch++;
	}

	return pwch;
}

/* <f3860> ../engine/unicode_strtools.cpp:653 */
uchar16 *StripUnprintableWorker(uchar16 *pwch, bool *pbStrippedAny)
{
	uchar16 *pwchSource = pwch;
	uchar16 *pwchDest = pwch;
	*pbStrippedAny = 0;

	while (*pwchSource)
	{
		uchar16 cc = *pwchSource;
		if (*pwchSource >= 0x20u && !Q_IsDeprecatedW(cc) && cc != 0x2026)
		{
			*pwchDest = cc;
			++pwchDest;
		}
		++pwchSource;
	}

	*pwchDest = 0;
	*pbStrippedAny = pwchSource != pwchDest;
	return pwch;
}

/* <f4800> ../engine/unicode_strtools.cpp:691 */
qboolean Q_StripUnprintableAndSpace(char *pch)
{
	bool bStrippedAny;
	bool bStrippedWhitespace;
	int cch = strlen(pch);
	int cubDest = (cch + 1) * sizeof(uchar16);
	uchar16 *pwch_alloced = (uchar16 *)malloc(cubDest);
	bStrippedAny = false;
	bStrippedWhitespace = false;

	// TODO: here is using Q_UTF8ToUTF32 by DWARF
	int cwch = (unsigned int)Q_UTF8ToUTF16(pch, (uchar16 *)pwch_alloced, cubDest, _STRINGCONVERTFLAG_ASSERT) >> 1;
	uchar16 *pwch = StripUnprintableWorker(pwch_alloced, &bStrippedAny);
	pwch = StripWhitespaceWorker(pwch, cwch - 1, &bStrippedWhitespace);
	if (bStrippedWhitespace || bStrippedAny)
	{
		// TODO: here is using Q_UTF32ToUTF8 by DWARF
		Q_UTF16ToUTF8(pwch, pch, cch, STRINGCONVERT_ASSERT_REPLACE);
	}

	free(pwch_alloced);
	return bStrippedAny;
}

/* <f4a0d> ../engine/unicode_strtools.cpp:717 */
qboolean V_UTF8ToUChar32(const char *pUTF8_, uchar32 *uValueOut)
{
	bool bError = false;
	Q_UTF8ToUChar32(pUTF8_, *uValueOut, bError);
	return bError;
}

/* <f4a63> ../engine/unicode_strtools.cpp:724 */
int Q_UnicodeRepair(char *pUTF8)
{
	return Q_UnicodeConvertT<char, char, true, Q_UTF8ToUChar32, Q_UChar32ToUTF8Len, Q_UChar32ToUTF8>(pUTF8, pUTF8, 65535, STRINGCONVERT_SKIP);
}

```

`cl_dll/util.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
// util.cpp
//
// implementation of class-less helper functions
//

#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#include "hud.h"
#include "cl_util.h"
#include <string.h>

#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

//vec3_t vec3_origin( 0, 0, 0 );

//double sqrt(double x);

float rsqrt( float number )
{
	int	i;
	float	x, y;

	if( number == 0.0f )
		return 0.0f;

	x = number * 0.5f;
	i = *(int *)&number;	// evil floating point bit level hacking
	i = 0x5f3759df - (i >> 1);	// what the fuck?
	y = *(float *)&i;
	y = y * (1.5f - (x * y * y));	// first iteration

	return y;
}
/* // defined in pm_math.cpp
float Length(const float *v)
{
	int		i;
	float	length;
	
	length = 0;
	for (i=0 ; i< 3 ; i++)
		length += v[i]*v[i];
	length = sqrt (length);		// FIXME

	return length;
}
void VectorAngles( const float *forward, float *angles )
{
	float	tmp, yaw, pitch;
	
	if (forward[1] == 0 && forward[0] == 0)
	{
		yaw = 0;
		if (forward[2] > 0)
			pitch = 90;
		else
			pitch = 270;
	}
	else
	{
		yaw = (atan2(forward[1], forward[0]) * 180 / M_PI);
		if (yaw < 0)
			yaw += 360;

		tmp = sqrt (forward[0]*forward[0] + forward[1]*forward[1]);
		pitch = (atan2(forward[2], tmp) * 180 / M_PI);
		if (pitch < 0)
			pitch += 360;
	}
	
	angles[0] = pitch;
	angles[1] = yaw;
	angles[2] = 0;
}

float VectorNormalize (float *v)
{
	float	length;

	length = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
	length = rsqrt (length);

	if (length)
	{
		v[0] *= length;
		v[1] *= length;
		v[2] *= length;
	}

	return length;

}

void VectorInverse ( float *v )
{
	v[0] = -v[0];
	v[1] = -v[1];
	v[2] = -v[2];
}
void VectorScale (const float *in, float scale, float *out)
{
	out[0] = in[0]*scale;
	out[1] = in[1]*scale;
	out[2] = in[2]*scale;
}

void VectorMA (const float *veca, float scale, const float *vecb, float *vecc)
{
	vecc[0] = veca[0] + scale*vecb[0];
	vecc[1] = veca[1] + scale*vecb[1];
	vecc[2] = veca[2] + scale*vecb[2];
}
*/

int HUD_GetSpriteIndexByName( const char *sz )
{
	return gHUD.GetSpriteIndex(sz);
}

HSPRITE HUD_GetSprite( int index )
{
	return gHUD.GetSprite(index);
}

wrect_t HUD_GetSpriteRect( int index )
{
	return gHUD.GetSpriteRect( index );
}

vec3_t g_ColorBlue	= { 0.6, 0.8, 1.0 };
vec3_t g_ColorRed		= { 1.0, 0.25, 0.25 };
vec3_t g_ColorGreen	= { 0.6, 1.0, 0.6 };
vec3_t g_ColorYellow	= { 1.0, 0.7, 0.0 };
vec3_t g_ColorGrey	= { 0.8, 0.8, 0.8 };

float *GetClientColor( int clientIndex )
{
	switch ( g_PlayerExtraInfo[clientIndex].teamnumber )
	{
	case TEAM_TERRORIST:  return g_ColorRed;
	case TEAM_CT:         return g_ColorBlue;
	case TEAM_SPECTATOR:
	case TEAM_UNASSIGNED: return g_ColorYellow;
	case 4:               return g_ColorGreen;
	default:              return g_ColorGrey;
	}
}



```

`cl_dll/vgui_parser.cpp`:

```cpp
/*
*
*    This program is free software; you can redistribute it and/or modify it
*    under the terms of the GNU General Public License as published by the
*    Free Software Foundation; either version 2 of the License, or (at
*    your option) any later version.
*
*    This program is distributed in the hope that it will be useful, but
*    WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*    General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program; if not, write to the Free Software Foundation,
*    Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*    In addition, as a special exception, the author gives permission to
*    link the code of this program with the Half-Life Game Engine ("HL
*    Engine") and Modified Game Libraries ("MODs") developed by Valve,
*    L.L.C ("Valve").  You must obey the GNU General Public License in all
*    respects for all of the code used other than the HL Engine and MODs
*    from Valve.  If you modify this file, you may extend this exception
*    to your version of the file, but you are not obligated to do so.  If
*    you do not wish to do so, delete this exception statement from your
*    version.
*
*/

#include "port.h"

#include <string.h>
#include "wrect.h" // need for cl_dll.h
#include "cl_dll.h"
#include "vgui_parser.h"
#include "unicode_strtools.h"

#include "errno.h"

#include <unordered_map>
#include <string>

// for localized titles.txt strings
using namespace std;
typedef unordered_map< string, char* > CDict;

CDict gTitlesTXT;

const char *Localize( const char *szStr )
{
	StripEndNewlineFromString( (char *)szStr );
	auto got = gTitlesTXT.find( string(szStr) );

	// if iterator points to end, then 'key' not found in dictionary
	if( got == gTitlesTXT.end() )
		return szStr;

	return got->second;
}

void Localize_Init( )
{
	const char *gamedir = gEngfuncs.pfnGetGameDirectory( );

	char filename[64];
	snprintf( filename, sizeof( filename ), "%s/resource/%s_english.txt", gamedir, gamedir );

#ifndef OPENBINARY
	FILE *wf = fopen( filename, "r" );
#else
	FILE *wf = fopen( filename, "rb" );
#endif

	if( !wf )
	{
		gEngfuncs.Con_Printf( "Couldn't open file %s. Strings will not be localized!.\n", filename );
		return;
	}

	fseek( wf, 0L, SEEK_END );
	int unicodeLength = ftell( wf );
	fseek( wf, 0L, SEEK_SET );

	uchar16 *unicodeBuf = new uchar16[unicodeLength];
	int totalRead = fread( unicodeBuf, 1, unicodeLength, wf );
	if( totalRead == unicodeLength ) // no problem, so read it.
	{
		int ansiLength = totalRead / 2;
		char *afile = new char[ansiLength]; // save original pointer, so we can free it later
		char *pfile = afile;
		char *token = new char[MAX_LOCALIZEDSTRING_SIZE];

		Q_UTF16ToUTF8( unicodeBuf + 1, afile, ansiLength, STRINGCONVERT_ASSERT_REPLACE );

		while( (pfile = gEngfuncs.COM_ParseFile( pfile, token )) && gTitlesTXT.size() < gTitlesTXT.max_size() )
		{
			if( strlen( token ) > 5 )
			{
				char szLocString[MAX_LOCALIZEDSTRING_SIZE];
				pfile = gEngfuncs.COM_ParseFile( pfile, szLocString );

				if( pfile && gTitlesTXT.size() < gTitlesTXT.max_size() )
				{
					size_t iLen = strlen( szLocString ) + 1;
					char *szLocCopyString = new char[iLen];
					strncpy(szLocCopyString, szLocString, iLen );
					gTitlesTXT[ string(token) ] = szLocCopyString;
				}
			}
		}

		delete[] token;
		delete[] afile;
	}
	else
	{
		gEngfuncs.Con_Printf( "Warning: total read of %s differs from size! Error: %s\n", filename, strerror( errno ));
		gEngfuncs.Con_Printf( "Couldn't open file %s. Strings will not be localized!.\n", filename );
	}

	fclose( wf );
	delete[] unicodeBuf;
}

void Localize_Free( )
{
	for( auto it = gTitlesTXT.begin(); it != gTitlesTXT.end(); ++it )
	{
		delete[] it->second;
	}
	gTitlesTXT.clear();
	return;
}

```

`cl_dll/view.cpp`:

```cpp
//========= Copyright ? 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose:
//
// $NoKeywords: $
//=============================================================================

// view/refresh setup functions

#include <string.h>

#include "hud.h"
#include "pm_math.h"
#include "cl_util.h"
#include "cvardef.h"
#include "usercmd.h"
#include "const.h"

#include "entity_state.h"
#include "cl_entity.h"
#include "ref_params.h"
#include "in_defs.h" // PITCH YAW ROLL
#include "pm_movevars.h"
#include "pm_shared.h"
#include "pm_defs.h"
#include "pm_debug.h"
#include "event_api.h"
#include "pmtrace.h"
#include "screenfade.h"
#include "shake.h"
#include "hltv.h"
#include "r_studioint.h"
#include "com_model.h"
#include "kbutton.h"
#include "input.h"

#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

extern float	vJumpOrigin[3];
extern float	vJumpAngles[3];


extern engine_studio_api_t IEngineStudio;

/*
The view is allowed to move slightly from it's true position for bobbing,
but if it exceeds 8 pixels linear distance (spherical, not box), the list of
entities sent from the server may not include everything in the pvs, especially
when crossing a water boudnary.
*/

extern cvar_t	*cl_forwardspeed;
extern cvar_t	*chase_active;
extern cvar_t	*scr_ofsx, *scr_ofsy, *scr_ofsz;
extern cvar_t	*cl_vsmoothing;

#define	CAM_MODE_RELAX		1
#define CAM_MODE_FOCUS		2

vec3_t v_origin, v_angles, v_cl_angles, v_sim_org, v_lastAngles, ev_punchangle;
Vector dead_viewangles( 0, 0, 0 ); // fake viewangles, for fixing
float  v_frametime, v_lastDistance;
float  v_cameraRelaxAngle	= 5.0f;
float  v_cameraFocusAngle	= 35.0f;
int	   v_cameraMode = CAM_MODE_FOCUS;
bool   v_resetCamera = 1;

cvar_t	*scr_ofsx;
cvar_t	*scr_ofsy;
cvar_t	*scr_ofsz;

cvar_t	*v_centermove;
cvar_t	*v_centerspeed;

cvar_t	*cl_bobcycle;
cvar_t	*cl_bob;
cvar_t	*cl_bobup;
cvar_t	*cl_waterdist;
cvar_t	*cl_chasedist;

// These cvars are not registered (so users can't cheat), so set the ->value field directly
// Register these cvars in V_Init() if needed for easy tweaking
cvar_t	v_iyaw_cycle		= {"v_iyaw_cycle", "2", 0, 2, NULL};
cvar_t	v_iroll_cycle		= {"v_iroll_cycle", "0.5", 0, 0.5, NULL};
cvar_t	v_ipitch_cycle		= {"v_ipitch_cycle", "1", 0, 1, NULL};
cvar_t	v_iyaw_level		= {"v_iyaw_level", "0.3", 0, 0.3, NULL};
cvar_t	v_iroll_level		= {"v_iroll_level", "0.1", 0, 0.1, NULL};
cvar_t	v_ipitch_level		= {"v_ipitch_level", "0.3", 0, 0.3, NULL};

float	v_idlescale;  // used by TFC for concussion grenade effect

//=============================================================================
/*
void V_NormalizeAngles( float *angles )
{
	int i;
	// Normalize angles
	for ( i = 0; i < 3; i++ )
	{
		if ( angles[i] > 180.0 )
		{
			angles[i] -= 360.0;
		}
		else if ( angles[i] < -180.0 )
		{
			angles[i] += 360.0;
		}
	}
}
*/
/*
===================
V_InterpolateAngles

Interpolate Euler angles.
FIXME:  Use Quaternions to avoid discontinuities
Frac is 0.0 to 1.0 ( i.e., should probably be clamped, but doesn't have to be )
===================
*/
/*
void V_InterpolateAngles( float *start, float *end, float *output, float frac )
{
	int i;
	float ang1, ang2;
	float d;

	V_NormalizeAngles( start );
	V_NormalizeAngles( end );

	for ( i = 0 ; i < 3 ; i++ )
	{
		ang1 = start[i];
		ang2 = end[i];

		d = ang2 - ang1;
		if ( d > 180 )
		{
			d -= 360;
		}
		else if ( d < -180 )
		{
			d += 360;
		}

		output[i] = ang1 + d * frac;
	}

	V_NormalizeAngles( output );
} */

// Quakeworld bob code, this fixes jitters in the mutliplayer since the clock (pparams->time) isn't quite linear
float V_CalcBob ( struct ref_params_s *pparams )
{
	static	double	bobtime;
	static float	bob;
	float	cycle;
	static float	lasttime;
	vec3_t	vel;


	if ( pparams->onground == -1 ||
		 pparams->time == lasttime )
	{
		// just use old value
		return bob;
	}

	lasttime = pparams->time;

	bobtime += pparams->frametime;
	cycle = bobtime - (int)( bobtime / cl_bobcycle->value ) * cl_bobcycle->value;
	cycle /= cl_bobcycle->value;

	if ( cycle < cl_bobup->value )
	{
		cycle = M_PI * cycle / cl_bobup->value;
	}
	else
	{
		cycle = M_PI + M_PI * ( cycle - cl_bobup->value )/( 1.0 - cl_bobup->value );
	}

	// bob is proportional to simulated velocity in the xy plane
	// (don't count Z, or jumping messes it up)
	VectorCopy( pparams->simvel, vel );
	vel[2] = 0;

	bob = sqrt( vel[0] * vel[0] + vel[1] * vel[1] ) * cl_bob->value;
	bob = bob * 0.3 + bob * 0.7 * sin(cycle);
	bob = min( bob, 4 );
	bob = max( bob, -7 );
	return bob;

}

/*
===============
V_CalcRoll
Used by view and sv_user
===============
*/
float V_CalcRoll (vec3_t angles, vec3_t velocity, float rollangle, float rollspeed )
{
	float   sign;
	float   side;
	float   value;
	vec3_t  forward, right, up;

	AngleVectors ( angles, forward, right, up );

	side = DotProduct (velocity, right);
	sign = side < 0 ? -1 : 1;
	side = fabs( side );

	value = rollangle;
	if (side < rollspeed)
	{
		side = side * value / rollspeed;
	}
	else
	{
		side = value;
	}
	return side * sign;
}
#if 0
typedef struct pitchdrift_s
{
	float		pitchvel;
	int			nodrift;
	float		driftmove;
	double		laststop;
} pitchdrift_t;

static pitchdrift_t pd;

void V_StartPitchDrift( void )
{
	if ( pd.laststop == gEngfuncs.GetClientTime() )
	{
		return;		// something else is keeping it from drifting
	}

	if ( pd.nodrift || !pd.pitchvel )
	{
		pd.pitchvel = v_centerspeed->value;
		pd.nodrift = 0;
		pd.driftmove = 0;
	}
}

void V_StopPitchDrift ( void )
{
	pd.laststop = gEngfuncs.GetClientTime();
	pd.nodrift = 1;
	pd.pitchvel = 0;
}

/*
===============
V_DriftPitch

Moves the client pitch angle towards idealpitch sent by the server.

If the user is adjusting pitch manually, either with lookup/lookdown,
mlook and mouse, or klook and keyboard, pitch drifting is constantly stopped.
===============
*/
void V_DriftPitch ( struct ref_params_s *pparams )
{
	float		delta, move;

	if ( gEngfuncs.IsNoClipping() || !pparams->onground || pparams->demoplayback || pparams->spectator )
	{
		pd.driftmove = 0;
		pd.pitchvel = 0;
		return;
	}

	// don't count small mouse motion
	if (pd.nodrift)
	{
		if ( fabs( pparams->cmd->forwardmove ) < cl_forwardspeed->value )
			pd.driftmove = 0;
		else
			pd.driftmove += pparams->frametime;

		if ( pd.driftmove > v_centermove->value)
		{
			V_StartPitchDrift ();
		}
		return;
	}

	delta = pparams->idealpitch - pparams->cl_viewangles[PITCH];

	if (!delta)
	{
		pd.pitchvel = 0;
		return;
	}

	move = pparams->frametime * pd.pitchvel;
	pd.pitchvel += pparams->frametime * v_centerspeed->value;

	if (delta > 0)
	{
		if (move > delta)
		{
			pd.pitchvel = 0;
			move = delta;
		}
		pparams->cl_viewangles[PITCH] += move;
	}
	else if (delta < 0)
	{
		if (move > -delta)
		{
			pd.pitchvel = 0;
			move = -delta;
		}
		pparams->cl_viewangles[PITCH] -= move;
	}
}
#endif
/*
==============================================================================
						VIEW RENDERING
==============================================================================
*/

/*
=============
V_DropPunchAngle

=============
*/
void V_DropPunchAngle ( float frametime, float *ev_punchangle )
{
	float	len;

	len = VectorNormalize ( ev_punchangle );
	len -= (10.0 + len * 0.5) * frametime;
	len = max( len, 0.0 );
	VectorScale ( ev_punchangle, len, ev_punchangle );
}


/*
==================
V_CalcGunAngle
==================
*/
void V_CalcGunAngle ( struct ref_params_s *pparams )
{
	cl_entity_t *viewent;

	viewent = gEngfuncs.GetViewModel();
	if ( !viewent )
		return;

	viewent->angles[YAW]   =  pparams->viewangles[YAW]   + pparams->crosshairangle[YAW];
	viewent->angles[PITCH] = -pparams->viewangles[PITCH] + pparams->crosshairangle[PITCH] * 0.25;
	viewent->angles[ROLL]  -= v_idlescale * sin(pparams->time*v_iroll_cycle.value) * v_iroll_level.value;

	// don't apply all of the v_ipitch to prevent normally unseen parts of viewmodel from coming into view.
	viewent->angles[PITCH] -= v_idlescale * sin(pparams->time*v_ipitch_cycle.value) * (v_ipitch_level.value * 0.5);
	viewent->angles[YAW]   -= v_idlescale * sin(pparams->time*v_iyaw_cycle.value) * v_iyaw_level.value;

	VectorCopy( viewent->angles, viewent->curstate.angles );
	VectorCopy( viewent->angles, viewent->latched.prevangles );
}

/*
==============
V_AddIdle

Idle swaying
==============
*/
void V_AddIdle ( struct ref_params_s *pparams )
{
	pparams->viewangles[ROLL]  += v_idlescale * sin(pparams->time * v_iroll_cycle.value) * v_iroll_level.value;
	pparams->viewangles[PITCH] += v_idlescale * sin(pparams->time * v_ipitch_cycle.value) * v_ipitch_level.value;
	pparams->viewangles[YAW]   += v_idlescale * sin(pparams->time * v_iyaw_cycle.value) * v_iyaw_level.value;
}


/*
==============
V_CalcViewRoll

Roll is induced by movement and damage
==============
*/
void V_CalcViewRoll ( struct ref_params_s *pparams )
{
	float		side;
	cl_entity_t *viewentity;

	viewentity = gEngfuncs.GetEntityByIndex( pparams->viewentity );
	if ( !viewentity )
		return;

	side = V_CalcRoll ( viewentity->angles, pparams->simvel, pparams->movevars->rollangle, pparams->movevars->rollspeed );

	pparams->viewangles[ROLL] += side;

	if ( pparams->health <= 0 && ( pparams->viewheight[2] != 0 ) )
	{
		// only roll the view if the player is dead and the viewheight[2] is nonzero
		// this is so deadcam in multiplayer will work.
		pparams->viewangles[ROLL] = 80;	// dead view angle
		return;
	}
}


/*
==================
V_CalcIntermissionRefdef

==================
*/
void V_CalcIntermissionRefdef ( struct ref_params_s *pparams )
{
	cl_entity_t	*view;
	float		old;

	// view is the weapon model (only visible from inside body)
	view = gEngfuncs.GetViewModel();

	VectorCopy ( pparams->simorg, pparams->vieworg );
	VectorCopy ( pparams->cl_viewangles, pparams->viewangles );

	view->model = NULL;

	// allways idle in intermission
	old = v_idlescale;
	v_idlescale = 1;

	V_AddIdle ( pparams );

	if ( gEngfuncs.IsSpectateOnly() )
	{
		// in HLTV we must go to 'intermission' position by ourself
		VectorCopy( gHUD.m_Spectator.m_cameraOrigin, pparams->vieworg );
		VectorCopy( gHUD.m_Spectator.m_cameraAngles, pparams->viewangles );
	}

	v_idlescale = old;

	v_cl_angles = pparams->cl_viewangles;
	v_origin = pparams->vieworg;
	v_angles = pparams->viewangles;
}

#define ORIGIN_BACKUP 64
#define ORIGIN_MASK ( ORIGIN_BACKUP - 1 )

struct viewinterp_t
{
	float Origins[ ORIGIN_BACKUP ][3];
	float OriginTime[ ORIGIN_BACKUP ];

	float Angles[ ORIGIN_BACKUP ][3];
	float AngleTime[ ORIGIN_BACKUP ];

	int CurrentOrigin;
	int CurrentAngle;
};

/*
==================
V_CalcRefdef

==================
*/
void V_CalcNormalRefdef ( struct ref_params_s *pparams )
{
	cl_entity_t		*ent, *view;
	int				i;
	vec3_t			angles;
	float			bob, waterOffset;
	static viewinterp_t		ViewInterp;

	static float oldz = 0;
	static float lasttime;

	vec3_t camAngles, camForward, camRight, camUp;
	cl_entity_t *pwater;

	//V_DriftPitch ( pparams );

	if ( gEngfuncs.IsSpectateOnly() )
	{
		ent = gEngfuncs.GetEntityByIndex( g_iUser2 );
	}
	else
	{
		// ent is the player model ( visible when out of body )
		ent = gEngfuncs.GetLocalPlayer();
	}

	// view is the weapon model (only visible from inside body)
	view = gEngfuncs.GetViewModel();

	// transform the view offset by the model's matrix to get the offset from
	// model origin for the view
	bob = V_CalcBob ( pparams );

	// refresh position
	VectorCopy ( pparams->simorg, pparams->vieworg );
	pparams->vieworg[2] += ( bob );
	VectorAdd( pparams->vieworg, pparams->viewheight, pparams->vieworg );

	if( pparams->health <= 0 )
	{
		VectorCopy( dead_viewangles, pparams->viewangles );
	}
	else
	{
		VectorCopy ( pparams->cl_viewangles, pparams->viewangles );
	}

	gEngfuncs.V_CalcShake();
	gEngfuncs.V_ApplyShake( pparams->vieworg, pparams->viewangles, 1.0 );

	// never let view origin sit exactly on a node line, because a water plane can
	// disappear when viewed with the eye exactly on it.
	// FIXME, we send origin at 1/128 now, change this?
	// the server protocol only specifies to 1/16 pixel, so add 1/32 in each axis

	pparams->vieworg[0] += 1.0/32;
	pparams->vieworg[1] += 1.0/32;
	pparams->vieworg[2] += 1.0/32;

	// Check for problems around water, move the viewer artificially if necessary
	// -- this prevents drawing errors in GL due to waves

	waterOffset = 0;
	if ( pparams->waterlevel >= 2 )
	{
		int		i, contents, waterDist, waterEntity;
		vec3_t	point;
		waterDist = cl_waterdist->value;

		if ( pparams->hardware )
		{
			waterEntity = gEngfuncs.PM_WaterEntity( pparams->simorg );
			if ( waterEntity >= 0 && waterEntity < pparams->max_entities )
			{
				pwater = gEngfuncs.GetEntityByIndex( waterEntity );
				if ( pwater && ( pwater->model != NULL ) )
				{
					waterDist += ( pwater->curstate.scale * 16 );	// Add in wave height
				}
			}
		}
		else
		{
			waterEntity = 0;	// Don't need this in software
		}

		VectorCopy( pparams->vieworg, point );

		// Eyes are above water, make sure we're above the waves
		if ( pparams->waterlevel == 2 )
		{
			point[2] -= waterDist;
			for ( i = 0; i < waterDist; i++ )
			{
				contents = gEngfuncs.PM_PointContents( point, NULL );
				if ( contents > CONTENTS_WATER )
					break;
				point[2] += 1;
			}
			waterOffset = (point[2] + waterDist) - pparams->vieworg[2];
		}
		else
		{
			// eyes are under water.  Make sure we're far enough under
			point[2] += waterDist;

			for ( i = 0; i < waterDist; i++ )
			{
				contents = gEngfuncs.PM_PointContents( point, NULL );
				if ( contents <= CONTENTS_WATER )
					break;
				point[2] -= 1;
			}
			waterOffset = (point[2] - waterDist) - pparams->vieworg[2];
		}
	}

	pparams->vieworg[2] += waterOffset;

	V_CalcViewRoll ( pparams );

	V_AddIdle ( pparams );

	// offsets
	if( pparams->health <= 0 )
	{
		VectorCopy( dead_viewangles, angles );
	}
	else
	{
		VectorCopy( pparams->cl_viewangles, angles );
	}

	AngleVectors ( angles, pparams->forward, pparams->right, pparams->up );

	// don't allow cheats in multiplayer
	if ( pparams->maxclients <= 1 )
	{
		for ( i=0 ; i<3 ; i++ )
		{
			pparams->vieworg[i] += scr_ofsx->value*pparams->forward[i] + scr_ofsy->value*pparams->right[i] + scr_ofsz->value*pparams->up[i];
		}
	}

	// Treating cam_ofs[2] as the distance
	/*if( CL_IsThirdPerson() )
	{
		vec3_t ofs;

		ofs[0] = ofs[1] = ofs[2] = 0.0;

		CL_CameraOffset( (float *)&ofs );

		VectorCopy( ofs, camAngles );
		camAngles[ ROLL ]	= 0;

		AngleVectors( camAngles, camForward, camRight, camUp );

		for ( i = 0; i < 3; i++ )
		{
			pparams->vieworg[ i ] += -ofs[2] * camForward[ i ];
		}
	}*/

	// Give gun our viewangles
	if( pparams->health <= 0 )
	{
		VectorCopy( dead_viewangles, view->angles );
	}
	else
	{
		VectorCopy ( pparams->cl_viewangles, view->angles );
	}

	// set up gun position
	V_CalcGunAngle ( pparams );

	// Use predicted origin as view origin.
	VectorCopy ( pparams->simorg, view->origin );
	view->origin[2] += ( waterOffset );
	VectorAdd( view->origin, pparams->viewheight, view->origin );

	// Let the viewmodel shake at about 10% of the amplitude
	gEngfuncs.V_ApplyShake( view->origin, view->angles, 0.9 );

	for ( i = 0; i < 3; i++ )
	{
		view->origin[ i ] += bob * 0.4 * pparams->forward[ i ];
	}
	view->origin[2] += bob;

	// throw in a little tilt.
	view->angles[YAW]   -= bob * 0.5;
	view->angles[ROLL]  -= bob * 1;
	view->angles[PITCH] -= bob * 0.3;

	// pushing the view origin down off of the same X/Z plane as the ent's origin will give the
	// gun a very nice 'shifting' effect when the player looks up/down. If there is a problem
	// with view model distortion, this may be a cause. (SJB).
	view->origin[2] -= 1;

	// fudge position around to keep amount of weapon visible
	// roughly equal with different FOV
	if (pparams->viewsize == 110)
	{
		view->origin[2] += 1;
	}
	else if (pparams->viewsize == 100)
	{
		view->origin[2] += 2;
	}
	else if (pparams->viewsize == 90)
	{
		view->origin[2] += 1;
	}
	else if (pparams->viewsize == 80)
	{
		view->origin[2] += 0.5;
	}

	// Don't allow viewmodel, if we are in sniper scope
	if( gHUD.m_iFOV <= 40 )
		view->model = NULL;

	// Add in the punchangle, if any
	pparams->viewangles = pparams->viewangles + pparams->punchangle;

#if 0
	// Include client side punch, too
	VectorAdd ( pparams->viewangles, (float *)&ev_punchangle, pparams->viewangles);

	V_DropPunchAngle ( pparams->frametime, (float *)&ev_punchangle );
#endif
	// smooth out stair step ups
#if 1
	if ( !pparams->smoothing && pparams->onground && pparams->simorg[2] - oldz > 0)
	{
		float steptime;

		steptime = pparams->time - lasttime;
		if (steptime < 0)
			//FIXME		I_Error ("steptime < 0");
			steptime = 0;

		oldz += steptime * 150;
		if (oldz > pparams->simorg[2])
			oldz = pparams->simorg[2];
		if (pparams->simorg[2] - oldz > 18)
			oldz = pparams->simorg[2]- 18;
		pparams->vieworg[2] += oldz - pparams->simorg[2];
		view->origin[2] += oldz - pparams->simorg[2];
	}
	else
	{
		oldz = pparams->simorg[2];
	}
#endif

	static float lastorg[3];
	vec3_t delta;

	VectorSubtract( pparams->simorg, lastorg, delta );

	if ( Length( delta ) != 0.0 )
	{
		VectorCopy( pparams->simorg, ViewInterp.Origins[ ViewInterp.CurrentOrigin & ORIGIN_MASK ] );
		ViewInterp.OriginTime[ ViewInterp.CurrentOrigin & ORIGIN_MASK ] = pparams->time;
		ViewInterp.CurrentOrigin++;

		VectorCopy( pparams->simorg, lastorg );
	}

	// Smooth out whole view in multiplayer when on trains, lifts
	if ( cl_vsmoothing && cl_vsmoothing->value &&
		 ( pparams->smoothing && ( pparams->maxclients > 1 ) ) )
	{
		int foundidx;
		int i;
		float t;

		if ( cl_vsmoothing->value < 0.0 )
		{
			gEngfuncs.Cvar_SetValue( "cl_vsmoothing", 0.0 );
		}

		t = pparams->time - cl_vsmoothing->value;

		for ( i = 1; i < ORIGIN_MASK; i++ )
		{
			foundidx = ViewInterp.CurrentOrigin - 1 - i;
			if ( ViewInterp.OriginTime[ foundidx & ORIGIN_MASK ] <= t )
				break;
		}

		if ( i < ORIGIN_MASK &&  ViewInterp.OriginTime[ foundidx & ORIGIN_MASK ] != 0.0 )
		{
			// Interpolate
			vec3_t delta;
			double frac;
			double dt;
			vec3_t neworg;

			dt = ViewInterp.OriginTime[ (foundidx + 1) & ORIGIN_MASK ] - ViewInterp.OriginTime[ foundidx & ORIGIN_MASK ];
			if ( dt > 0.0 )
			{
				frac = ( t - ViewInterp.OriginTime[ foundidx & ORIGIN_MASK] ) / dt;
				frac = min( 1.0, frac );
				VectorSubtract( ViewInterp.Origins[ ( foundidx + 1 ) & ORIGIN_MASK ], ViewInterp.Origins[ foundidx & ORIGIN_MASK ], delta );
				VectorMA( ViewInterp.Origins[ foundidx & ORIGIN_MASK ], frac, delta, neworg );

				// Don't interpolate large changes
				if ( Length( delta ) < 64 )
				{
					VectorSubtract( neworg, pparams->simorg, delta );

					VectorAdd( pparams->simorg, delta, pparams->simorg );
					VectorAdd( pparams->vieworg, delta, pparams->vieworg );
					VectorAdd( view->origin, delta, view->origin );

				}
			}
		}
	}

	// Store off v_angles before munging for third person
	v_angles = pparams->viewangles;
	v_lastAngles = pparams->viewangles;
	//	v_cl_angles = pparams->cl_viewangles;	// keep old user mouse angles !
	if ( CL_IsThirdPerson() )
	{
		VectorCopy( camAngles, pparams->viewangles);
		float pitch = camAngles[ 0 ];

		// Normalize angles
		if ( pitch > 180 )
			pitch -= 360.0;
		else if ( pitch < -180 )
			pitch += 360;

		// Player pitch is inverted
		pitch /= -3.0;

		// Slam local player's pitch value
		ent->angles[ 0 ] = pitch;
		ent->curstate.angles[ 0 ] = pitch;
		ent->prevstate.angles[ 0 ] = pitch;
		ent->latched.prevangles[ 0 ] = pitch;
	}

	// override all previous settings if the viewent isn't the client
	if ( pparams->viewentity > pparams->maxclients )
	{
		cl_entity_t *viewentity;
		viewentity = gEngfuncs.GetEntityByIndex( pparams->viewentity );
		if ( viewentity )
		{
			VectorCopy( viewentity->origin, pparams->vieworg );
			VectorCopy( viewentity->angles, pparams->viewangles );

			// Store off overridden viewangles
			v_angles = pparams->viewangles;
		}
	}

	lasttime = pparams->time;

	v_origin = pparams->vieworg;
}

void V_SmoothInterpolateAngles( float * startAngle, float * endAngle, float * finalAngle, float degreesPerSec )
{
	float absd,frac,d,threshold;

	NormalizeAngles( startAngle );
	NormalizeAngles( endAngle );

	for ( int i = 0 ; i < 3 ; i++ )
	{
		d = endAngle[i] - startAngle[i];

		if ( d > 180.0f )
		{
			d -= 360.0f;
		}
		else if ( d < -180.0f )
		{
			d += 360.0f;
		}

		absd = fabs(d);

		if ( absd > 0.01f )
		{
			frac = degreesPerSec * v_frametime;

			threshold= degreesPerSec / 4;

			if ( absd < threshold )
			{
				float h = absd / threshold;
				h *= h;
				frac*= h;  // slow down last degrees
			}

			if ( frac >  absd )
			{
				finalAngle[i] = endAngle[i];
			}
			else
			{
				if ( d>0)
					finalAngle[i] = startAngle[i] + frac;
				else
					finalAngle[i] = startAngle[i] - frac;
			}
		}
		else
		{
			finalAngle[i] = endAngle[i];
		}

	}

	NormalizeAngles( finalAngle );
}

// Get the origin of the Observer based around the target's position and angles
void V_GetChaseOrigin( float * angles, float * origin, float distance, float * returnvec )
{
	Vector vecStart, vecEnd;
	pmtrace_t *trace;
	int maxLoops = 8;

	Vector forward, right, up;

	// trace back from the target using the player's view angles
	AngleVectors( angles, forward, right, up );
	forward = -forward;

	vecStart = origin;
	vecEnd = vecStart + forward * distance;

	int ignoreent = -1;	// first, ignore no entity
	cl_entity_t *ent = NULL;

	while( maxLoops > 0 )
	{
		trace = gEngfuncs.PM_TraceLine( vecStart, vecEnd, PM_TRACELINE_PHYSENTSONLY, 2, ignoreent );

		if( trace->ent <= 0 )
			break; // we hit the world or nothing, stop trace

		ent = gEngfuncs.GetEntityByIndex( PM_GetPhysEntInfo( trace->ent ));
		if( ent == NULL ) break;

		// hit non-player solid BSP, stop here
		if( ent->curstate.solid == SOLID_BSP && !ent->player )
			break;

		// if close enought to end pos, stop, otherwise continue trace
		if( trace->fraction < 1.0f )
		{
			break;
		}
		else
		{
			ignoreent = trace->ent;	// ignore last hit entity
			vecStart = trace->endpos;
		}
		maxLoops--;
	}

	VectorMA( trace->endpos, 8, trace->plane.normal, returnvec );
	v_lastDistance = (trace->endpos - Vector(origin)).Length();	// real distance without offset
}

void V_GetDeathCam(cl_entity_t * ent1, cl_entity_t * ent2, float * angle, float * origin)
{
	float newAngle[3];
	float newOrigin[3];
	static vec3_t nonDestructedOrigin;
	float distance = 168.0f;

	v_lastDistance += v_frametime * 96.0f;	// move unit per seconds back

	if ( v_resetCamera )
		v_lastDistance = 64.0f;

	if ( distance > v_lastDistance )
		distance = v_lastDistance;

	if (ent1->origin.x == 0 && ent1->origin.y == 0 && ent1->origin.z == 0)
		nonDestructedOrigin.CopyToArray(newOrigin);
	else
	{
		nonDestructedOrigin = ent1->origin;
		VectorCopy(ent1->origin, newOrigin);
	}

	if ( ent1->player )
		newOrigin[2]+= 17; // head level of living player

	// get new angle towards second target
	if ( ent2 )
	{
		VectorSubtract(ent2->origin, nonDestructedOrigin, newAngle);
		VectorAngles( newAngle, newAngle );
		newAngle[0] = -newAngle[0];
	}
	else
	{
		// if no second target is given, look down to dead player
		newAngle[0] = 90.0f;
		newAngle[1] = 0.0f;
		newAngle[2] = 0;
	}

	// and smooth view
	V_SmoothInterpolateAngles( v_lastAngles, newAngle, angle, 120.0f );

	V_GetChaseOrigin( angle, newOrigin, distance, origin );

	VectorCopy(angle, v_lastAngles);
}

void V_GetSingleTargetCam(cl_entity_t * ent1, float * angle, float * origin)
{
	float newAngle[3]; float newOrigin[3];

	int flags 	   = gHUD.m_Spectator.m_iObserverFlags;

	// see is target is a dead player
	bool deadPlayer = ent1->player && (ent1->curstate.solid == SOLID_NOT);

	float dfactor   = ( flags & DRC_FLAG_DRAMATIC )? -1.0f : 1.0f;

	float distance = 112.0f + ( 16.0f * dfactor ); // get close if dramatic;

	// go away in final scenes or if player just died
	if ( flags & DRC_FLAG_FINAL )
		distance*=2.0f;
	else if ( deadPlayer )
		distance*=1.5f;

	// let v_lastDistance float smoothly away
	v_lastDistance+= v_frametime * 32.0f;	// move unit per seconds back

	if ( distance > v_lastDistance )
		distance = v_lastDistance;

	VectorCopy(ent1->origin, newOrigin);

	if ( ent1->player )
	{
		if ( deadPlayer )
			newOrigin[2]+= 2;	//laying on ground
		else
			newOrigin[2]+= 17; // head level of living player

	}
	else
		newOrigin[2]+= 8;	// object, tricky, must be above bomb in CS

	// we have no second target, choose view direction based on
	// show front of primary target
	VectorCopy(ent1->angles, newAngle);

	// show dead players from front, normal players back
	if ( flags & DRC_FLAG_FACEPLAYER )
		newAngle[1]+= 180.0f;


	newAngle[0]+= 12.5f * dfactor; // lower angle if dramatic

	// if final scene (bomb), show from real high pos
	if ( flags & DRC_FLAG_FINAL )
		newAngle[0] = 22.5f;

	// choose side of object/player
	if ( flags & DRC_FLAG_SIDE )
		newAngle[1]+=22.5f;
	else
		newAngle[1]-=22.5f;

	V_SmoothInterpolateAngles( v_lastAngles, newAngle, angle, 120.0f );

	// HACK, if player is dead don't clip against his dead body, can't check this
	V_GetChaseOrigin( angle, newOrigin, distance, origin );
}

float MaxAngleBetweenAngles(  float * a1, float * a2 )
{
	float d, maxd = 0.0f;

	NormalizeAngles( a1 );
	NormalizeAngles( a2 );

	for ( int i = 0 ; i < 3 ; i++ )
	{
		d = a2[i] - a1[i];
		if ( d > 180 )
		{
			d -= 360;
		}
		else if ( d < -180 )
		{
			d += 360;
		}

		d = fabs(d);

		if ( d > maxd )
			maxd=d;
	}

	return maxd;
}

void V_GetDoubleTargetsCam(cl_entity_t	 * ent1, cl_entity_t * ent2,float * angle, float * origin)
{
	float newAngle[3]; float newOrigin[3]; float tempVec[3];

	int flags 	   = gHUD.m_Spectator.m_iObserverFlags;

	float dfactor   = ( flags & DRC_FLAG_DRAMATIC )? -1.0f : 1.0f;

	float distance = 112.0f + ( 16.0f * dfactor ); // get close if dramatic;

	// go away in final scenes or if player just died
	if ( flags & DRC_FLAG_FINAL )
		distance*=2.0f;

	// let v_lastDistance float smoothly away
	v_lastDistance+= v_frametime * 32.0f;	// move unit per seconds back

	if ( distance > v_lastDistance )
		distance = v_lastDistance;

	VectorCopy(ent1->origin, newOrigin);

	if ( ent1->player )
		newOrigin[2]+= 17; // head level of living player
	else
		newOrigin[2]+= 8;	// object, tricky, must be above bomb in CS

	// get new angle towards second target
	VectorSubtract( ent2->origin, ent1->origin, newAngle );

	VectorAngles( newAngle, newAngle );
	newAngle[0] = -newAngle[0];

	// set angle different in Dramtaic scenes
	newAngle[0]+= 12.5f * dfactor; // lower angle if dramatic

	if ( flags & DRC_FLAG_SIDE )
		newAngle[1]+=22.5f;
	else
		newAngle[1]-=22.5f;

	float d = MaxAngleBetweenAngles( v_lastAngles, newAngle );

	if ( ( d < v_cameraFocusAngle) && ( v_cameraMode == CAM_MODE_RELAX ) )
	{
		// difference is to small and we are in relax camera mode, keep viewangles
		VectorCopy(v_lastAngles, newAngle );
	}
	else if ( (d < v_cameraRelaxAngle) && (v_cameraMode == CAM_MODE_FOCUS) )
	{
		// we catched up with our target, relax again
		v_cameraMode = CAM_MODE_RELAX;
	}
	else
	{
		// target move too far away, focus camera again
		v_cameraMode = CAM_MODE_FOCUS;
	}

	// and smooth view, if not a scene cut
	if ( v_resetCamera || (v_cameraMode == CAM_MODE_RELAX) )
	{
		VectorCopy( newAngle, angle );
	}
	else
	{
		V_SmoothInterpolateAngles( v_lastAngles, newAngle, angle, 180.0f );
	}

	V_GetChaseOrigin( newAngle, newOrigin, distance, origin );

	// move position up, if very close at target
	if ( v_lastDistance < 64.0f )
		origin[2]+= 16.0f*( 1.0f - (v_lastDistance / 64.0f ) );

	// calculate angle to second target
	VectorSubtract( ent2->origin, origin, tempVec );
	VectorAngles( tempVec, tempVec );
	tempVec[0] = -tempVec[0];

	/* take middle between two viewangles
	InterpolateAngles( newAngle, tempVec, newAngle, 0.5f); */



}

void V_GetDirectedChasePosition(cl_entity_t	 * ent1, cl_entity_t * ent2,float * angle, float * origin)
{

	if ( v_resetCamera )
	{
		v_lastDistance = 4096.0f;
		// v_cameraMode = CAM_MODE_FOCUS;
	}

	if ( ( ent2 == (cl_entity_t*)0xFFFFFFFF ) || ( ent1->player && (ent1->curstate.solid == SOLID_NOT) ) )
	{
		// we have no second target or player just died
		V_GetSingleTargetCam(ent1, angle, origin);
	}
	else if ( ent2 )
	{
		// keep both target in view
		V_GetDoubleTargetsCam( ent1, ent2, angle, origin );
	}
	else
	{
		// second target disappeard somehow (dead)

		// keep last good viewangle
		float newOrigin[3];

		int flags 	   = gHUD.m_Spectator.m_iObserverFlags;

		float dfactor   = ( flags & DRC_FLAG_DRAMATIC )? -1.0f : 1.0f;

		float distance = 112.0f + ( 16.0f * dfactor ); // get close if dramatic;

		// go away in final scenes or if player just died
		if ( flags & DRC_FLAG_FINAL )
			distance*=2.0f;

		// let v_lastDistance float smoothly away
		v_lastDistance+= v_frametime * 32.0f;	// move unit per seconds back

		if ( distance > v_lastDistance )
			distance = v_lastDistance;

		VectorCopy(ent1->origin, newOrigin);

		if ( ent1->player )
			newOrigin[2]+= 17; // head level of living player
		else
			newOrigin[2]+= 8;	// object, tricky, must be above bomb in CS

		V_GetChaseOrigin( angle, newOrigin, distance, origin );
	}

	VectorCopy(angle, v_lastAngles);
}

void V_GetChasePos(int target, float * cl_angles, float * origin, float * angles)
{
	cl_entity_t	 *	ent = NULL;
	cl_entity_t *local = gEngfuncs.GetLocalPlayer();

	if ( target )
	{
		ent = gEngfuncs.GetEntityByIndex( target );
	}

	if (!ent)
	{
		// just copy a save in-map position
		VectorCopy ( vJumpAngles, angles );
		VectorCopy ( vJumpOrigin, origin );
		return;
	}


	if( ent->index == local->index )
	{
		if ( g_iUser3 && g_iUser3 != 1 )
			V_GetDeathCam( ent, gEngfuncs.GetEntityByIndex( g_iUser3 ),
						   angles, origin );
		else
			V_GetDeathCam( ent, NULL,
						   angles, origin );
	}
	else if ( gHUD.m_Spectator.m_autoDirector->value )
	{
		if ( g_iUser3 && g_iUser3 != 1 )
			V_GetDirectedChasePosition( ent, gEngfuncs.GetEntityByIndex( g_iUser3 ),
										angles, origin );
		else
			V_GetDirectedChasePosition( ent, (cl_entity_t*)0xFFFFFFFF,
										angles, origin );
	}
	else
	{
		if ( cl_angles == NULL )	// no mouse angles given, use entity angles ( locked mode )
		{
			VectorCopy ( ent->angles, angles);
			angles[0]*=-1;
		}
		else
			VectorCopy ( cl_angles, angles);


		VectorCopy ( ent->origin, origin);

		origin[2]+= 28; // DEFAULT_VIEWHEIGHT - some offset

		V_GetChaseOrigin( angles, origin, cl_chasedist->value, origin );
	}

	v_resetCamera = false;
}

void V_ResetChaseCam()
{
	v_resetCamera = true;
}


void V_GetInEyePos(int target, float * origin, float * angles )
{
	if ( !target)
	{
		// just copy a save in-map position
		VectorCopy ( vJumpAngles, angles );
		VectorCopy ( vJumpOrigin, origin );
		return;
	};


	cl_entity_t	 * ent = gEngfuncs.GetEntityByIndex( target );

	if ( !ent )
		return;

	VectorCopy ( ent->origin, origin );
	VectorCopy ( ent->angles, angles );

	angles[PITCH]*=-3.0f;	// see CL_ProcessEntityUpdate()

	if ( ent->curstate.solid == SOLID_NOT )
	{
		angles[ROLL] = 80;	// dead view angle
		origin[2]+= -8 ; // PM_DEAD_VIEWHEIGHT
	}
	else if (ent->curstate.usehull == 1 )
		origin[2]+= 12; // VEC_DUCK_VIEW;
	else
		// exacty eye position can't be calculated since it depends on
		// client values like cl_bobcycle, this offset matches the default values
		origin[2]+= 28; // DEFAULT_VIEWHEIGHT
}

void V_GetMapFreePosition( float * cl_angles, float * origin, float * angles )
{
	vec3_t forward;
	vec3_t zScaledTarget;

	VectorCopy(cl_angles, angles);

	// modify angles since we don't wanna see map's bottom
	angles[0] = 51.25f + 38.75f*(angles[0]/90.0f);

	zScaledTarget[0] = gHUD.m_Spectator.m_mapOrigin[0];
	zScaledTarget[1] = gHUD.m_Spectator.m_mapOrigin[1];
	zScaledTarget[2] = gHUD.m_Spectator.m_mapOrigin[2] * (( 90.0f - angles[0] ) / 90.0f );


	AngleVectors(angles, forward, NULL, NULL);

	VectorNormalize(forward);

	VectorMA(zScaledTarget, -( 4096.0f / gHUD.m_Spectator.m_mapZoom ), forward , origin);
}

void V_GetMapChasePosition(int target, float * cl_angles, float * origin, float * angles)
{
	vec3_t forward;

	if ( target )
	{
		cl_entity_t	 *	ent = gEngfuncs.GetEntityByIndex( target );

		if ( gHUD.m_Spectator.m_autoDirector->value )
		{
			// this is done to get the angles made by director mode
			V_GetChasePos(target, cl_angles, origin, angles);
			VectorCopy(ent->origin, origin);

			// keep fix chase angle horizontal
			angles[0] = 45.0f;
		}
		else
		{
			VectorCopy(cl_angles, angles);
			VectorCopy(ent->origin, origin);

			// modify angles since we don't wanna see map's bottom
			angles[0] = 51.25f + 38.75f*(angles[0]/90.0f);
		}
	}
	else
	{
		// keep out roaming position, but modify angles
		VectorCopy(cl_angles, angles);
		angles[0] = 51.25f + 38.75f*(angles[0]/90.0f);
	}

	origin[2] *= (( 90.0f - angles[0] ) / 90.0f );
	angles[2] = 0.0f;	// don't roll angle (if chased player is dead)

	AngleVectors(angles, forward, NULL, NULL);

	VectorNormalize(forward);

	VectorMA(origin, -1536, forward, origin);
}

int V_FindViewModelByWeaponModel( int iWeaponIndex )
{
	model_t *pWeaponModel = IEngineStudio.GetModelByIndex( iWeaponIndex );
	if ( pWeaponModel && pWeaponModel->name )
	{
		static char szViewModelName[MAX_MODEL_NAME];
		strncpy( szViewModelName, pWeaponModel->name, sizeof( szViewModelName ) );

		char *szSub = strstr( szViewModelName, "/p_" );
		if( szSub )
		{
			// szSub pointer is a part of szViewModelName
			szSub[1] = 'v';
			return gEngfuncs.pEventAPI->EV_FindModelIndex(szViewModelName);
		}
		return 0;
	}
	else
		return 0;

}


/*
==================
V_CalcSpectatorRefdef

==================
*/
void V_CalcSpectatorRefdef ( struct ref_params_s * pparams )
{
	static vec3_t			velocity ( 0.0f, 0.0f, 0.0f);

	static int lastWeaponModelIndex = 0;
	static int lastViewModelIndex = 0;

	cl_entity_t	 * ent = gEngfuncs.GetEntityByIndex( g_iUser2 );

	pparams->onlyClientDraw = false;

	// refresh position
	VectorCopy ( pparams->simorg, v_sim_org );

	// get old values
	VectorCopy ( pparams->cl_viewangles, v_cl_angles );
	VectorCopy ( pparams->viewangles, v_angles );
	VectorCopy ( pparams->vieworg, v_origin );

	if ( ( g_iUser1 == OBS_IN_EYE || gHUD.m_Spectator.m_pip->value == INSET_IN_EYE ) && ent )
	{
		// calculate player velocity
		float timeDiff = ent->curstate.msg_time - ent->prevstate.msg_time;

		if ( timeDiff > 0 )
		{
			vec3_t distance;
			VectorSubtract(ent->prevstate.origin, ent->curstate.origin, distance);
			VectorScale(distance, 1/timeDiff, distance );

			velocity[0] = velocity[0]*0.9f + distance[0]*0.1f;
			velocity[1] = velocity[1]*0.9f + distance[1]*0.1f;
			velocity[2] = velocity[2]*0.9f + distance[2]*0.1f;

			VectorCopy(velocity, pparams->simvel);
		}

		// predict missing client data and set weapon model ( in HLTV mode or inset in eye mode )
		if ( gEngfuncs.IsSpectateOnly() )
		{
			V_GetInEyePos( g_iUser2, pparams->simorg, pparams->cl_viewangles );

			pparams->health = 1;

			cl_entity_t	*gunModel = gEngfuncs.GetViewModel();

			if ( lastWeaponModelIndex != ent->curstate.weaponmodel )
			{
				// weapon model changed

				lastWeaponModelIndex = ent->curstate.weaponmodel;
				lastViewModelIndex = V_FindViewModelByWeaponModel( lastWeaponModelIndex );
				if ( lastViewModelIndex )
				{
					gEngfuncs.pfnWeaponAnim(0,0);	// reset weapon animation
				}
				else
				{
					// model not found
					gunModel->model = NULL;	// disable weapon model
					lastWeaponModelIndex = lastViewModelIndex = 0;
				}
			}

			if ( lastViewModelIndex )
			{
				gunModel->model = IEngineStudio.GetModelByIndex( lastViewModelIndex );
				gunModel->curstate.modelindex = lastViewModelIndex;
				gunModel->curstate.frame = 0;
				gunModel->curstate.colormap = 0;
				gunModel->index = g_iUser2;
			}
			else
			{
				gunModel->model = NULL;	// disable weaopn model
			}
		}
		else
		{
			// only get viewangles from entity
			VectorCopy ( ent->angles, pparams->cl_viewangles );
			pparams->cl_viewangles[PITCH]*=-3.0f;	// see CL_ProcessEntityUpdate()
		}
	}

	v_frametime = pparams->frametime;

	if ( pparams->nextView == 0 )
	{
		// first renderer cycle, full screen

		switch ( g_iUser1 )
		{
		case OBS_CHASE_LOCKED:
			V_GetChasePos( g_iUser2, NULL, v_origin, v_angles );
			break;

		case OBS_CHASE_FREE:
			V_GetChasePos( g_iUser2, v_cl_angles, v_origin, v_angles );
			break;

		case OBS_ROAMING:
			VectorCopy (v_cl_angles, v_angles);
			VectorCopy (v_sim_org, v_origin);
			break;

		case OBS_IN_EYE:
			V_CalcNormalRefdef ( pparams );
			break;

		case OBS_MAP_FREE:
			pparams->onlyClientDraw = true;
			V_GetMapFreePosition( v_cl_angles, v_origin, v_angles );
			break;

		case OBS_MAP_CHASE:
			pparams->onlyClientDraw = true;
			V_GetMapChasePosition( g_iUser2, v_cl_angles, v_origin, v_angles );
			break;
		}

		if ( gHUD.m_Spectator.m_pip->value )
			pparams->nextView = 1;	// force a second renderer view

		gHUD.m_Spectator.m_iDrawCycle = 0;

	}
	else
	{
		// second renderer cycle, inset window

		// set inset parameters
		pparams->viewport[0] = XRES(gHUD.m_Spectator.m_OverviewData.insetWindowX);	// change viewport to inset window
		pparams->viewport[1] = YRES(gHUD.m_Spectator.m_OverviewData.insetWindowY);
		pparams->viewport[2] = XRES(gHUD.m_Spectator.m_OverviewData.insetWindowWidth);
		pparams->viewport[3] = YRES(gHUD.m_Spectator.m_OverviewData.insetWindowHeight);
		pparams->nextView	 = 0;	// on further view

		// override some settings in certain modes
		switch ( (int)gHUD.m_Spectator.m_pip->value )
		{
		case INSET_CHASE_FREE:
			V_GetChasePos( g_iUser2, v_cl_angles, v_origin, v_angles );
			break;

		case INSET_IN_EYE:
			V_CalcNormalRefdef ( pparams );
			break;

		case INSET_MAP_FREE:
			pparams->onlyClientDraw = true;
			V_GetMapFreePosition( v_cl_angles, v_origin, v_angles );
			break;

		case INSET_MAP_CHASE:
			pparams->onlyClientDraw = true;

			if ( g_iUser1 == OBS_ROAMING )
				V_GetMapChasePosition( 0, v_cl_angles, v_origin, v_angles );
			else
				V_GetMapChasePosition( g_iUser2, v_cl_angles, v_origin, v_angles );

			break;
		}

		gHUD.m_Spectator.m_iDrawCycle = 1;
	}

	// write back new values into pparams
	VectorCopy ( v_cl_angles, pparams->cl_viewangles );
	VectorCopy ( v_angles, pparams->viewangles )
	VectorCopy ( v_origin, pparams->vieworg );
}

void V_CalcThirdPersonRefdef( ref_params_t *pparams )
{
	static float lasttime, oldz = 0;

	pparams->vieworg = pparams->simorg;
	pparams->vieworg = pparams->vieworg + pparams->viewheight;
	pparams->viewangles = pparams->cl_viewangles + pparams->punchangle + ev_punchangle;

	v_angles = pparams->viewangles;
	v_lastAngles = pparams->viewangles;

	// never let view origin sit exactly on a node line, because a water plane can
	// disappear when viewed with the eye exactly on it.
	// FIXME, we send origin at 1/128 now, change this?
	// the server protocol only specifies to 1/16 pixel, so add 1/32 in each axis
	pparams->vieworg[0] += 1.0f / 32;
	pparams->vieworg[1] += 1.0f / 32;
	pparams->vieworg[2] += 1.0f / 32;

	// this is smooth stair climbing in thirdperson mode but not affected for client model :(
	if( !pparams->smoothing && pparams->onground && pparams->simorg[2] - oldz > 0.0f )
	{
		float steptime;

		steptime = pparams->time - lasttime;
		if( steptime < 0 ) steptime = 0;

		oldz += steptime * 150.0f;

		if( oldz > pparams->simorg[2] )
			oldz = pparams->simorg[2];
		if( pparams->simorg[2] - oldz > pparams->movevars->stepsize )
			oldz = pparams->simorg[2] - pparams->movevars->stepsize;

		pparams->vieworg[2] += oldz - pparams->simorg[2];
	}
	else
	{
		oldz = pparams->simorg[2];
	}

	lasttime = pparams->time;

	V_GetChaseOrigin( pparams->viewangles, pparams->vieworg, cl_chasedist->value, pparams->vieworg );

	float pitch = pparams->viewangles[PITCH];

	// normalize angles
	if( pitch > 180.0f )
		pitch -= 360.0f;
	else if( pitch < -180.0f )
		pitch += 360.0f;

	// player pitch is inverted
	pitch /= -3.0;

	cl_entity_t *ent = gEngfuncs.GetLocalPlayer();

	// slam local player's pitch value
	ent->angles[PITCH] = pitch;
	ent->curstate.angles[PITCH] = pitch;
	ent->prevstate.angles[PITCH] = pitch;
	ent->latched.prevangles[PITCH] = pitch;
}

void DLLEXPORT V_CalcRefdef( struct ref_params_s *pparams )
{
	// intermission / finale rendering
	if ( pparams->intermission )
	{
		V_CalcIntermissionRefdef ( pparams );
	}
	else if ( pparams->spectator || g_iUser1 )	// g_iUser true if in spectator mode
	{
		V_CalcSpectatorRefdef ( pparams );
	}
	else if ( CL_IsThirdPerson() )
	{
		V_CalcThirdPersonRefdef ( pparams );
	}
	else
	{
		V_CalcNormalRefdef ( pparams );
	}
}

/*
=============
V_Init
=============
*/
void V_Init (void)
{
	//gEngfuncs.pfnAddCommand ("centerview", V_StartPitchDrift );

	scr_ofsx			= gEngfuncs.pfnRegisterVariable( "scr_ofsx","0", 0 );
	scr_ofsy			= gEngfuncs.pfnRegisterVariable( "scr_ofsy","0", 0 );
	scr_ofsz			= gEngfuncs.pfnRegisterVariable( "scr_ofsz","0", 0 );

	v_centermove		= gEngfuncs.pfnRegisterVariable( "v_centermove", "0.15", 0 );
	v_centerspeed		= gEngfuncs.pfnRegisterVariable( "v_centerspeed","500", 0 );

	cl_bobcycle			= gEngfuncs.pfnRegisterVariable( "cl_bobcycle","0.8", 0 );// best default for my experimental gun wag (sjb)
	cl_bob				= gEngfuncs.pfnRegisterVariable( "cl_bob","0.01", 0 );// best default for my experimental gun wag (sjb)
	cl_bobup			= gEngfuncs.pfnRegisterVariable( "cl_bobup","0.5", 0 );
	cl_waterdist		= gEngfuncs.pfnRegisterVariable( "cl_waterdist","4", 0 );
	cl_chasedist		= gEngfuncs.pfnRegisterVariable( "cl_chasedist","112", 0 );
}

```

`common/beamdef.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( BEAMDEFH )
#define BEAMDEFH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#define FBEAM_STARTENTITY		0x00000001
#define FBEAM_ENDENTITY			0x00000002
#define FBEAM_FADEIN			0x00000004
#define FBEAM_FADEOUT			0x00000008
#define FBEAM_SINENOISE			0x00000010
#define FBEAM_SOLID				0x00000020
#define FBEAM_SHADEIN			0x00000040
#define FBEAM_SHADEOUT			0x00000080
#define FBEAM_STARTVISIBLE		0x10000000		// Has this client actually seen this beam's start entity yet?
#define FBEAM_ENDVISIBLE		0x20000000		// Has this client actually seen this beam's end entity yet?
#define FBEAM_ISACTIVE			0x40000000
#define FBEAM_FOREVER			0x80000000

typedef struct beam_s BEAM;
struct beam_s
{
	BEAM		*next;
	int			type;
	int			flags;
	vec3_t		source;
	vec3_t		target;
	vec3_t		delta;
	float		t;		// 0 .. 1 over lifetime of beam
	float		freq;
	float		die;
	float		width;
	float		amplitude;
	float		r, g, b;
	float		brightness;
	float		speed;
	float		frameRate;
	float		frame;
	int			segments;
	int			startEntity;
	int			endEntity;
	int			modelIndex;
	int			frameCount;
	struct model_s		*pFollowModel;
	struct particle_s	*particles;
};

#endif

```

`common/cl_entity.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// cl_entity.h
#if !defined( CL_ENTITYH )
#define CL_ENTITYH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct efrag_s
{
	struct mleaf_s		*leaf;
	struct efrag_s		*leafnext;
	struct cl_entity_s	*entity;
	struct efrag_s		*entnext;
} efrag_t;

typedef struct
{
	byte					mouthopen;		// 0 = mouth closed, 255 = mouth agape
	byte					sndcount;		// counter for running average
	int						sndavg;			// running average
} mouth_t;

typedef struct
{
	float					prevanimtime;  
	float					sequencetime;
	byte					prevseqblending[2];
	vec3_t					prevorigin;
	vec3_t					prevangles;

	int						prevsequence;
	float					prevframe;

	byte					prevcontroller[4];
	byte					prevblending[2];
} latchedvars_t;

typedef struct
{
	// Time stamp for this movement
	float					animtime;

	vec3_t					origin;
	vec3_t					angles;
} position_history_t;

typedef struct cl_entity_s cl_entity_t;

#define HISTORY_MAX		64  // Must be power of 2
#define HISTORY_MASK	( HISTORY_MAX - 1 )


#if !defined( ENTITY_STATEH )
#include "entity_state.h"
#endif

#if !defined( PROGS_H )
#include "progs.h"
#endif

struct cl_entity_s
{
	int						index;      // Index into cl_entities ( should match actual slot, but not necessarily )

	qboolean				player;     // True if this entity is a "player"
	
	entity_state_t			baseline;   // The original state from which to delta during an uncompressed message
	entity_state_t			prevstate;  // The state information from the penultimate message received from the server
	entity_state_t			curstate;   // The state information from the last message received from server

	int						current_position;  // Last received history update index
	position_history_t		ph[ HISTORY_MAX ];   // History of position and angle updates for this player

	mouth_t					mouth;			// For synchronizing mouth movements.

	latchedvars_t			latched;		// Variables used by studio model rendering routines

	// Information based on interplocation, extrapolation, prediction, or just copied from last msg received.
	//
	float					lastmove;

	// Actual render position and angles
	vec3_t					origin;
	vec3_t					angles;

	// Attachment points
	vec3_t					attachment[4];

	// Other entity local information
	int						trivial_accept;

	struct model_s			*model;			// cl.model_precache[ curstate.modelindes ];  all visible entities have a model
	struct efrag_s			*efrag;			// linked list of efrags
	struct mnode_s			*topnode;		// for bmodels, first world node that splits bmodel, or NULL if not split

	float					syncbase;		// for client-side animations -- used by obsolete alias animation system, remove?
	int						visframe;		// last frame this entity was found in an active leaf
	colorVec				cvFloorColor;
};

#endif // !CL_ENTITYH

```

`common/com_model.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// com_model.h
#if !defined( COM_MODEL_H )
#define COM_MODEL_H
#if defined( _WIN32 )
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#define STUDIO_RENDER 1
#define STUDIO_EVENTS 2

#define MAX_CLIENTS			32
#define	MAX_EDICTS			900

#define MAX_MODEL_NAME		64
#define MAX_MAP_HULLS		4
#define	MIPLEVELS			4
#define	NUM_AMBIENTS		4		// automatic ambient sounds
#define	MAXLIGHTMAPS		4
#define	PLANE_ANYZ			5

#define ALIAS_Z_CLIP_PLANE	5

// flags in finalvert_t.flags
#define ALIAS_LEFT_CLIP				0x0001
#define ALIAS_TOP_CLIP				0x0002
#define ALIAS_RIGHT_CLIP			0x0004
#define ALIAS_BOTTOM_CLIP			0x0008
#define ALIAS_Z_CLIP				0x0010
#define ALIAS_ONSEAM				0x0020
#define ALIAS_XY_CLIP_MASK			0x000F

#define	ZISCALE	((float)0x8000)

#define CACHE_SIZE	32		// used to align key data structures

typedef enum
{
	mod_brush, 
	mod_sprite, 
	mod_alias, 
	mod_studio
} modtype_t;

// must match definition in modelgen.h
#ifndef SYNCTYPE_T
#define SYNCTYPE_T

typedef enum
{
	ST_SYNC=0,
	ST_RAND
} synctype_t;

#endif

typedef struct
{
	float		mins[3], maxs[3];
	float		origin[3];
	int			headnode[MAX_MAP_HULLS];
	int			visleafs;		// not including the solid leaf 0
	int			firstface, numfaces;
} dmodel_t;

// plane_t structure
typedef struct mplane_s
{
	vec3_t	normal;			// surface normal
	float	dist;			// closest appoach to origin
	byte	type;			// for texture axis selection and fast side tests
	byte	signbits;		// signx + signy<<1 + signz<<1
	byte	pad[2];
} mplane_t;

typedef struct
{
	vec3_t		position;
} mvertex_t;

typedef struct
{
	unsigned short	v[2];
	unsigned int	cachededgeoffset;
} medge_t;

typedef struct texture_s
{
	char		name[16];
	unsigned	width, height;
	int			anim_total;				// total tenths in sequence ( 0 = no)
	int			anim_min, anim_max;		// time for this frame min <=time< max
	struct texture_s *anim_next;		// in the animation sequence
	struct texture_s *alternate_anims;	// bmodels in frame 1 use these
	unsigned	offsets[MIPLEVELS];		// four mip maps stored
	unsigned	paloffset;
} texture_t;

typedef struct
{
	float		vecs[2][4];		// [s/t] unit vectors in world space. 
								// [i][3] is the s/t offset relative to the origin.
								// s or t = dot(3Dpoint,vecs[i])+vecs[i][3]
	float		mipadjust;		// ?? mipmap limits for very small surfaces
	texture_t	*texture;
	int			flags;			// sky or slime, no lightmap or 256 subdivision
} mtexinfo_t;

typedef struct mnode_s
{
// common with leaf
	int			contents;		// 0, to differentiate from leafs
	int			visframe;		// node needs to be traversed if current
	
	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// node specific
	mplane_t	*plane;
	struct mnode_s	*children[2];	

	unsigned short		firstsurface;
	unsigned short		numsurfaces;
} mnode_t;

typedef struct msurface_s	msurface_t;
typedef struct decal_s		decal_t;

// JAY: Compress this as much as possible
struct decal_s
{
	decal_t		*pnext;			// linked list for each surface
	msurface_t	*psurface;		// Surface id for persistence / unlinking
	short		dx;				// Offsets into surface texture (in texture coordinates, so we don't need floats)
	short		dy;
	short		texture;		// Decal texture
	byte		scale;			// Pixel scale
	byte		flags;			// Decal flags

	short		entityIndex;	// Entity this is attached to
};

typedef struct mleaf_s
{
// common with node
	int			contents;		// wil be a negative contents number
	int			visframe;		// node needs to be traversed if current

	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// leaf specific
	byte		*compressed_vis;
	struct efrag_s	*efrags;

	msurface_t	**firstmarksurface;
	int			nummarksurfaces;
	int			key;			// BSP sequence number for leaf's contents
	byte		ambient_sound_level[NUM_AMBIENTS];
} mleaf_t;

struct msurface_s
{
	int			visframe;		// should be drawn when node is crossed

	int			dlightframe;	// last frame the surface was checked by an animated light
	int			dlightbits;		// dynamically generated. Indicates if the surface illumination 
								// is modified by an animated light.

	mplane_t	*plane;			// pointer to shared plane			
	int			flags;			// see SURF_ #defines

	int			firstedge;	// look up in model->surfedges[], negative numbers
	int			numedges;	// are backwards edges
	
// surface generation data
	struct surfcache_s	*cachespots[MIPLEVELS];

	short		texturemins[2]; // smallest s/t position on the surface.
	short		extents[2];		// ?? s/t texture size, 1..256 for all non-sky surfaces

	mtexinfo_t	*texinfo;		
	
// lighting info
	byte		styles[MAXLIGHTMAPS]; // index into d_lightstylevalue[] for animated lights 
									  // no one surface can be effected by more than 4 
									  // animated lights.
	color24		*samples;
	
	decal_t		*pdecals;
};

typedef struct
{
	int			planenum;
	short		children[2];	// negative numbers are contents
} dclipnode_t;

typedef struct hull_s
{
	dclipnode_t	*clipnodes;
	mplane_t	*planes;
	int			firstclipnode;
	int			lastclipnode;
	vec3_t		clip_mins;
	vec3_t		clip_maxs;
} hull_t;

#if !defined( CACHE_USER ) && !defined( QUAKEDEF_H )
#define CACHE_USER
typedef struct cache_user_s
{
	void	*data;
} cache_user_t;
#endif

typedef struct model_s
{
	char		name[ MAX_MODEL_NAME ];
	qboolean	needload;		// bmodels and sprites don't cache normally

	modtype_t	type;
	int			numframes;
	synctype_t	synctype;
	
	int			flags;

//
// volume occupied by the model
//		
	vec3_t		mins, maxs;
	float		radius;

//
// brush model
//
	int			firstmodelsurface, nummodelsurfaces;

	int			numsubmodels;
	dmodel_t	*submodels;

	int			numplanes;
	mplane_t	*planes;

	int			numleafs;		// number of visible leafs, not counting 0
	struct mleaf_s		*leafs;

	int			numvertexes;
	mvertex_t	*vertexes;

	int			numedges;
	medge_t		*edges;

	int			numnodes;
	mnode_t		*nodes;

	int			numtexinfo;
	mtexinfo_t	*texinfo;

	int			numsurfaces;
	msurface_t	*surfaces;

	int			numsurfedges;
	int			*surfedges;

	int			numclipnodes;
	dclipnode_t	*clipnodes;

	int			nummarksurfaces;
	msurface_t	**marksurfaces;

	hull_t		hulls[MAX_MAP_HULLS];

	int			numtextures;
	texture_t	**textures;

	byte		*visdata;

	color24		*lightdata;

	char		*entities;

//
// additional model data
//
	cache_user_t	cache;		// only access through Mod_Extradata

} model_t;

typedef vec_t vec4_t[4];

typedef struct alight_s
{
	int			ambientlight;	// clip at 128
	int			shadelight;		// clip at 192 - ambientlight
	vec3_t		color;
	float		*plightvec;
} alight_t;

typedef struct auxvert_s
{
	float	fv[3];		// viewspace x, y
} auxvert_t;

#include "custom.h"

#define	MAX_INFO_STRING			256
#define	MAX_SCOREBOARDNAME		32
typedef struct player_info_s
{
	// User id on server
	int		userid;

	// User info string
	char	userinfo[ MAX_INFO_STRING ];

	// Name
	char	name[ MAX_SCOREBOARDNAME ];

	// Spectator or not, unused
	int		spectator;

	int		ping;
	int		packet_loss;

	// skin information
	char	model[MAX_QPATH];
	int		topcolor;
	int		bottomcolor;

	// last frame rendered
	int		renderframe;	

	// Gait frame estimation
	int		gaitsequence;
	float	gaitframe;
	float	gaityaw;
	vec3_t	prevgaitorigin;

	customization_t customdata;
} player_info_t;

#endif // #define COM_MODEL_H

```

`common/con_nprint.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( CON_NPRINTH )
#define CON_NPRINTH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct con_nprint_s
{
	int		index;			// Row #
	float	time_to_live;	// # of seconds before it disappears
	float	color[ 3 ];		// RGB colors ( 0.0 -> 1.0 scale )
} con_nprint_t;

void Con_NPrintf( int idx, char *fmt, ... );
void Con_NXPrintf( struct con_nprint_s *info, char *fmt, ... );

#endif

```

`common/const.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CONST_H
#define CONST_H
//
// Constants shared by the engine and dlls
// This header file included by engine files and DLL files.
// Most came from server.h

// edict->flags
#define FL_FLY		(1<<0)	// Changes the SV_Movestep() behavior to not need to be on ground
#define FL_SWIM		(1<<1)	// Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define FL_CONVEYOR		(1<<2)
#define FL_CLIENT		(1<<3)
#define FL_INWATER		(1<<4)
#define FL_MONSTER		(1<<5)
#define FL_GODMODE		(1<<6)
#define FL_NOTARGET		(1<<7)
#define FL_SKIPLOCALHOST	(1<<8)	// Don't send entity to local host, it's predicting this entity itself
#define FL_ONGROUND		(1<<9)	// At rest / on the ground
#define FL_PARTIALGROUND	(1<<10)	// not all corners are valid
#define FL_WATERJUMP	(1<<11)	// player jumping out of water
#define FL_FROZEN		(1<<12)	// Player is frozen for 3rd person camera
#define FL_FAKECLIENT	(1<<13)	// JAC: fake client, simulated server side; don't send network messages to them
#define FL_DUCKING		(1<<14)	// Player flag -- Player is fully crouched
#define FL_FLOAT		(1<<15)	// Apply floating force to this entity when in water
#define FL_GRAPHED		(1<<16)	// worldgraph has this ent listed as something that blocks a connection

// UNDONE: Do we need these?
#define FL_IMMUNE_WATER	(1<<17)
#define FL_IMMUNE_SLIME	(1<<18)
#define FL_IMMUNE_LAVA	(1<<19)

#define FL_PROXY		(1<<20)	// This is a spectator proxy
#define FL_ALWAYSTHINK	(1<<21)	// Brush model flag -- call think every frame regardless of nextthink - ltime (for constantly changing velocity/path)
#define FL_BASEVELOCITY	(1<<22)	// Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_MONSTERCLIP	(1<<23)	// Only collide in with monsters who have FL_MONSTERCLIP set
#define FL_ONTRAIN		(1<<24)	// Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_WORLDBRUSH	(1<<25)	// Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_SPECTATOR	(1<<26)	// This client is a spectator, don't run touch functions, etc.
#define FL_CUSTOMENTITY	(1<<29)	// This is a custom entity
#define FL_KILLME		(1<<30)	// This entity is marked for death -- This allows the engine to kill ents at the appropriate time
#define FL_DORMANT		(1<<31)	// Entity is dormant, no updates to client

// Goes into globalvars_t.trace_flags
#define FTRACE_SIMPLEBOX		(1<<0)	// Traceline with a simple box
#define FTRACE_IGNORE_GLASS		(1<<1)	// traceline will be ignored entities with rendermode != kRenderNormal

// walkmove modes
#define WALKMOVE_NORMAL		0	// normal walkmove
#define WALKMOVE_WORLDONLY		1	// doesn't hit ANY entities, no matter what the solid type
#define WALKMOVE_CHECKONLY		2	// move, but don't touch triggers

// edict->movetype values
#define MOVETYPE_NONE		0	// never moves
//#define	MOVETYPE_ANGLENOCLIP	1
//#define	MOVETYPE_ANGLECLIP		2
#define MOVETYPE_WALK		3	// Player only - moving on the ground
#define MOVETYPE_STEP		4	// gravity, special edge handling -- monsters use this
#define MOVETYPE_FLY		5	// No gravity, but still collides with stuff
#define MOVETYPE_TOSS		6	// gravity/collisions
#define MOVETYPE_PUSH		7	// no clip to world, push and crush
#define MOVETYPE_NOCLIP		8	// No gravity, no collisions, still do velocity/avelocity
#define MOVETYPE_FLYMISSILE		9	// extra size to monsters
#define MOVETYPE_BOUNCE		10	// Just like Toss, but reflect velocity when contacting surfaces
#define MOVETYPE_BOUNCEMISSILE	11	// bounce w/o gravity
#define MOVETYPE_FOLLOW		12	// track movement of aiment
#define MOVETYPE_PUSHSTEP		13	// BSP model that needs physics/world collisions (uses nearest hull for world collision)
#define MOVETYPE_COMPOUND		14	// glue two entities together (simple movewith)

// edict->solid values
// NOTE: Some movetypes will cause collisions independent of SOLID_NOT/SOLID_TRIGGER when the entity moves
// SOLID only effects OTHER entities colliding with this one when they move - UGH!
#define SOLID_NOT			0	// no interaction with other objects
#define SOLID_TRIGGER		1	// touch on edge, but not blocking
#define SOLID_BBOX			2	// touch on edge, block
#define SOLID_SLIDEBOX		3	// touch on edge, but not an onground
#define SOLID_BSP			4	// bsp clip, touch on edge, block
#define SOLID_CUSTOM		5	// call external callbacks for tracing

// edict->deadflag values
#define DEAD_NO			0 	// alive
#define DEAD_DYING			1 	// playing death animation or still falling off of a ledge waiting to hit ground
#define DEAD_DEAD			2 	// dead. lying still.
#define DEAD_RESPAWNABLE		3
#define DEAD_DISCARDBODY		4

#define DAMAGE_NO			0
#define DAMAGE_YES			1
#define DAMAGE_AIM			2

// entity effects
#define EF_BRIGHTFIELD		1	// swirling cloud of particles
#define EF_MUZZLEFLASH		2	// single frame ELIGHT on entity attachment 0
#define EF_BRIGHTLIGHT		4	// DLIGHT centered at entity origin
#define EF_DIMLIGHT			8	// player flashlight
#define EF_INVLIGHT			16	// get lighting from ceiling
#define EF_NOINTERP			32	// don't interpolate the next frame
#define EF_LIGHT			64	// rocket flare glow sprite
#define EF_NODRAW			128	// don't draw entity



#define EF_NOREFLECT		(1<<24)	// Entity won't reflecting in mirrors
#define EF_REFLECTONLY		(1<<25)	// Entity will be drawing only in mirrors
#define EF_NOWATERCSG		(1<<26)	// Do not remove sides for func_water entity
#define EF_FULLBRIGHT		(1<<27)	// Just get fullbright
#define EF_NOSHADOW			(1<<28)	// ignore shadow for this entity
#define EF_MERGE_VISIBILITY		(1<<29)	// this entity allowed to merge vis (e.g. env_sky or portal camera)
#define EF_REQUEST_PHS		(1<<30)	// This entity requested phs bitvector instead of pvsbitvector in AddToFullPack calls
// g-cont. one reserved bit here for me

// entity flags
#define EFLAG_SLERP			1	// do studio interpolation of this entity
		
//
// temp entity events
//
#define	TE_BEAMPOINTS		0	// beam effect between two points
// coord coord coord (start position) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_BEAMENTPOINT		1	// beam effect between point and entity
// short (start entity) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_GUNSHOT		2	// particle effect plus ricochet sound
// coord coord coord (position) 

#define	TE_EXPLOSION		3	// additive sprite, 2 dynamic lights, flickering particles, explosion sound, move vertically 8 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)
// byte (flags)
//
// The Explosion effect has some flags to control performance/aesthetic features:
#define TE_EXPLFLAG_NONE		0	// all flags clear makes default Half-Life explosion
#define TE_EXPLFLAG_NOADDITIVE	1	// sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite)
#define TE_EXPLFLAG_NODLIGHTS		2	// do not render dynamic lights
#define TE_EXPLFLAG_NOSOUND		4	// do not play client explosion sound
#define TE_EXPLFLAG_NOPARTICLES	8	// do not draw particles
#define TE_EXPLFLAG_DRAWALPHA		16	// sprite will be drawn alpha
#define TE_EXPLFLAG_ROTATE		32	// rotate the sprite randomly

#define	TE_TAREXPLOSION		4	// Quake1 "tarbaby" explosion with sound
// coord coord coord (position) 

#define	TE_SMOKE			5	// alphablend sprite, move vertically 30 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)

#define	TE_TRACER			6	// tracer effect from point to point
// coord, coord, coord (start) 
// coord, coord, coord (end)

#define	TE_LIGHTNING		7	// TE_BEAMPOINTS with simplified parameters
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// byte (life in 0.1's) 
// byte (width in 0.1's) 
// byte (amplitude in 0.01's)
// short (sprite model index)

#define	TE_BEAMENTS		8		
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_SPARKS			9	// 8 random tracers with gravity, ricochet sprite
// coord coord coord (position) 

#define	TE_LAVASPLASH		10	// Quake1 lava splash
// coord coord coord (position) 

#define	TE_TELEPORT		11	// Quake1 teleport splash
// coord coord coord (position) 

#define TE_EXPLOSION2		12	// Quake1 colormaped (base palette) particle explosion with sound
// coord coord coord (position) 
// byte (starting color)
// byte (num colors)

#define TE_BSPDECAL			13	// Decal from the .BSP file 
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// short (texture index of precached decal texture name)
// short (entity index)
// [optional - only included if previous short is non-zero (not the world)] short (index of model of above entity)

#define TE_IMPLOSION		14	// tracers moving toward a point
// coord, coord, coord (position)
// byte (radius)
// byte (count)
// byte (life in 0.1's) 

#define TE_SPRITETRAIL		15	// line of moving glow sprites with gravity, fadeout, and collisions
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// short (sprite index)
// byte (count)
// byte (life in 0.1's) 
// byte (scale in 0.1's) 
// byte (velocity along vector in 10's)
// byte (randomness of velocity in 10's)

#define TE_BEAM			16	// obsolete

#define TE_SPRITE			17	// additive sprite, plays 1 cycle
// coord, coord, coord (position) 
// short (sprite index) 
// byte (scale in 0.1's) 
// byte (brightness)

#define TE_BEAMSPRITE		18	// A beam with a sprite at the end
// coord, coord, coord (start position) 
// coord, coord, coord (end position) 
// short (beam sprite index) 
// short (end sprite index) 

#define TE_BEAMTORUS		19	// screen aligned beam ring, expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMDISK			20	// disk that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMCYLINDER		21	// cylinder that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMFOLLOW		22	// create a line of decaying beam segments until entity stops moving
// short (entity:attachment to follow)
// short (sprite index)
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte,byte,byte (color)
// byte (brightness)

#define TE_GLOWSPRITE		23		
// coord, coord, coord (pos) short (model index) byte (scale / 10)

#define TE_BEAMRING			24	// connect a beam ring to two entities
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_STREAK_SPLASH	25		// oriented shower of tracers
// coord coord coord (start position) 
// coord coord coord (direction vector) 
// byte (color)
// short (count)
// short (base speed)
// short (random velocity)

#define TE_BEAMHOSE			26	// obsolete

#define TE_DLIGHT			27	// dynamic light, effect world, minor entity effect
// coord, coord, coord (pos) 
// byte (radius in 10's) 
// byte byte byte (color)
// byte (life in 10's)
// byte (decay rate in 10's)

#define TE_ELIGHT			28	// point entity light, no world effect
// short (entity:attachment to follow)
// coord coord coord (initial position) 
// coord (radius)
// byte byte byte (color)
// byte (life in 0.1's)
// coord (decay rate)

#define TE_TEXTMESSAGE		29
// short 1.2.13 x (-1 = center)
// short 1.2.13 y (-1 = center)
// byte Effect 0 = fade in/fade out
// 1 is flickery credits
// 2 is write out (training room)
// 4 bytes r,g,b,a color1	(text color)
// 4 bytes r,g,b,a color2	(effect color)
// ushort 8.8 fadein time
// ushort 8.8  fadeout time
// ushort 8.8 hold time
// optional ushort 8.8 fxtime	(time the highlight lags behing the leading text in effect 2)
// string text message		(512 chars max sz string)
#define TE_LINE			30
// coord, coord, coord	startpos
// coord, coord, coord	endpos
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_BOX			31
// coord, coord, coord	boxmins
// coord, coord, coord	boxmaxs
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_KILLBEAM			99	// kill all beams attached to entity
// short (entity)

#define TE_LARGEFUNNEL		100
// coord coord coord (funnel position)
// short (sprite index) 
// short (flags) 

#define	TE_BLOODSTREAM		101	// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define	TE_SHOWLINE		102	// line of particles every 5 units, dies in 30 seconds
// coord coord coord (start position)
// coord coord coord (end position)

#define TE_BLOOD			103	// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define TE_DECAL			104	// Decal applied to a brush entity (not the world)
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)
// short (entity index)

#define TE_FIZZ			105	// create alpha sprites inside of entity, float upwards
// short (entity)
// short (sprite index)
// byte (density)

#define TE_MODEL			106	// create a moving model that bounces and makes a sound when it hits
// coord, coord, coord (position) 
// coord, coord, coord (velocity)
// angle (initial yaw)
// short (model index)
// byte (bounce sound type)
// byte (life in 0.1's)

#define TE_EXPLODEMODEL		107	// spherical shower of models, picks from set
// coord, coord, coord (origin)
// coord (velocity)
// short (model index)
// short (count)
// byte (life in 0.1's)

#define TE_BREAKMODEL		108	// box of models or sprites
// coord, coord, coord (position)
// coord, coord, coord (size)
// coord, coord, coord (velocity)
// byte (random velocity in 10's)
// short (sprite or model index)
// byte (count)
// byte (life in 0.1 secs)
// byte (flags)

#define TE_GUNSHOTDECAL		109	// decal and ricochet sound
// coord, coord, coord (position)
// short (entity index???)
// byte (decal???)

#define TE_SPRITE_SPRAY		110	// spay of alpha sprites
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (sprite index)
// byte (count)
// byte (speed)
// byte (noise)

#define TE_ARMOR_RICOCHET		111	// quick spark sprite, client ricochet sound. 
// coord, coord, coord (position)
// byte (scale in 0.1's)

#define TE_PLAYERDECAL		112	// ???
// byte (playerindex)
// coord, coord, coord (position)
// short (entity???)
// byte (decal number???)
// [optional] short (model index???)

#define TE_BUBBLES			113	// create alpha sprites inside of box, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BUBBLETRAIL		114	// create alpha sprites along a line, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BLOODSPRITE		115	// spray of opaque sprite1's that fall, single sprite2 for 1..2 secs (this is a high-priority tent)
// coord, coord, coord (position)
// short (sprite1 index)
// short (sprite2 index)
// byte (color)
// byte (scale)

#define TE_WORLDDECAL		116	// Decal applied to the world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)

#define TE_WORLDDECALHIGH		117	// Decal (with texture index > 256) applied to world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)

#define TE_DECALHIGH		118	// Same as TE_DECAL, but the texture index was greater than 256
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)
// short (entity index)

#define TE_PROJECTILE		119	// Makes a projectile (like a nail) (this is a high-priority tent)
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (modelindex)
// byte (life)
// byte (owner)  projectile won't collide with owner (if owner == 0, projectile will hit any client).

#define TE_SPRAY			120	// Throws a shower of sprites or models
// coord, coord, coord (position)
// coord, coord, coord (direction)
// short (modelindex)
// byte (count)
// byte (speed)
// byte (noise)
// byte (rendermode)

#define TE_PLAYERSPRITES		121	// sprites emit from a player's bounding box (ONLY use for players!)
// byte (playernum)
// short (sprite modelindex)
// byte (count)
// byte (variance) (0 = no variance in size) (10 = 10% variance in size)

#define TE_PARTICLEBURST		122	// very similar to lavasplash.
// coord (origin)
// short (radius)
// byte (particle color)
// byte (duration * 10) (will be randomized a bit)

#define TE_FIREFIELD		123	// makes a field of fire.
// coord (origin)
// short (radius) (fire is made in a square around origin. -radius, -radius to radius, radius)
// short (modelindex)
// byte (count)
// byte (flags)
// byte (duration (in seconds) * 10) (will be randomized a bit)
//
// to keep network traffic low, this message has associated flags that fit into a byte:
#define TEFIRE_FLAG_ALLFLOAT	1 // all sprites will drift upwards as they animate
#define TEFIRE_FLAG_SOMEFLOAT	2 // some of the sprites will drift upwards. (50% chance)
#define TEFIRE_FLAG_LOOP	4 // if set, sprite plays at 15 fps, otherwise plays at whatever rate stretches the animation over the sprite's duration.
#define TEFIRE_FLAG_ALPHA	8 // if set, sprite is rendered alpha blended at 50% else, opaque
#define TEFIRE_FLAG_PLANAR	16 // if set, all fire sprites have same initial Z instead of randomly filling a cube. 

#define TE_PLAYERATTACHMENT		124	// attaches a TENT to a player (this is a high-priority tent)
// byte (entity index of player)
// coord (vertical offset) ( attachment origin.z = player origin.z + vertical offset )
// short (model index)
// short (life * 10 );

#define TE_KILLPLAYERATTACHMENTS	125	// will expire all TENTS attached to a player.
// byte (entity index of player)

#define TE_MULTIGUNSHOT		126	// much more compact shotgun message
// This message is used to make a client approximate a 'spray' of gunfire.
// Any weapon that fires more than one bullet per frame and fires in a bit of a spread is
// a good candidate for MULTIGUNSHOT use. (shotguns)
//
// NOTE: This effect makes the client do traces for each bullet, these client traces ignore
// entities that have studio models.Traces are 4096 long.
//
// coord (origin)
// coord (origin)
// coord (origin)
// coord (direction)
// coord (direction)
// coord (direction)
// coord (x noise * 100)
// coord (y noise * 100)
// byte (count)
// byte (bullethole decal texture index)

#define TE_USERTRACER		127	// larger message than the standard tracer, but allows some customization.
// coord (origin)
// coord (origin)
// coord (origin)
// coord (velocity)
// coord (velocity)
// coord (velocity)
// byte ( life * 10 )
// byte ( color ) this is an index into an array of color vectors in the engine. (0 - )
// byte ( length * 10 )

#define MSG_BROADCAST		0	// unreliable to all
#define MSG_ONE			1	// reliable to one (msg_entity)
#define MSG_ALL			2	// reliable to all
#define MSG_INIT			3	// write to the init string
#define MSG_PVS			4	// Ents in PVS of org
#define MSG_PAS			5	// Ents in PAS of org
#define MSG_PVS_R			6	// Reliable to PVS
#define MSG_PAS_R			7	// Reliable to PAS
#define MSG_ONE_UNRELIABLE		8	// Send to one client, but don't put in reliable stream, put in unreliable datagram ( could be dropped )
#define MSG_SPEC			9	// Sends to all spectator proxies

// contents of a spot in the world
#define CONTENTS_EMPTY		-1
#define CONTENTS_SOLID		-2
#define CONTENTS_WATER		-3
#define CONTENTS_SLIME		-4
#define CONTENTS_LAVA		-5
#define CONTENTS_SKY		-6
// These additional contents constants are defined in bspfile.h
#define CONTENTS_ORIGIN		-7	// removed at csg time
#define CONTENTS_CLIP		-8	// changed to contents_solid
#define CONTENTS_CURRENT_0		-9
#define CONTENTS_CURRENT_90		-10
#define CONTENTS_CURRENT_180		-11
#define CONTENTS_CURRENT_270		-12
#define CONTENTS_CURRENT_UP		-13
#define CONTENTS_CURRENT_DOWN		-14
#define CONTENTS_TRANSLUCENT		-15

#define CONTENTS_LADDER		-16

#define CONTENT_FLYFIELD		-17
#define CONTENT_GRAVITY_FLYFIELD	-18
#define CONTENT_FOG			-19

#define CONTENT_EMPTY		-1
#define CONTENT_SOLID		-2
#define CONTENT_WATER		-3
#define CONTENT_SLIME		-4
#define CONTENT_LAVA		-5
#define CONTENT_SKY			-6

// channels
#define CHAN_AUTO			0
#define CHAN_WEAPON			1
#define CHAN_VOICE			2
#define CHAN_ITEM			3
#define CHAN_BODY			4
#define CHAN_STREAM			5	// allocate stream channel from the static or dynamic area
#define CHAN_STATIC			6	// allocate channel from the static area 
#define CHAN_NETWORKVOICE_BASE	7	// voice data coming across the network
#define CHAN_NETWORKVOICE_END		500	// network voice data reserves slots (CHAN_NETWORKVOICE_BASE through CHAN_NETWORKVOICE_END).

// attenuation values
#define ATTN_NONE			0
#define ATTN_NORM			(float)0.8
#define ATTN_IDLE			(float)2
#define ATTN_STATIC			(float)1.25 

// pitch values
#define PITCH_NORM			100	// non-pitch shifted
#define PITCH_LOW			95	// other values are possible - 0-255, where 255 is very high
#define PITCH_HIGH			120

// volume values
#define VOL_NORM			1.0

// plats
#define PLAT_LOW_TRIGGER		1

// Trains
#define SF_TRAIN_WAIT_RETRIGGER	1
#define SF_TRAIN_START_ON		4	// Train is initially moving
#define SF_TRAIN_PASSABLE		8	// Train is not solid -- used to make water trains

// buttons
#define IN_ATTACK			(1<<0)
#define IN_JUMP			(1<<1)
#define IN_DUCK			(1<<2)
#define IN_FORWARD			(1<<3)
#define IN_BACK			(1<<4)
#define IN_USE			(1<<5)
#define IN_CANCEL			(1<<6)
#define IN_LEFT			(1<<7)
#define IN_RIGHT			(1<<8)
#define IN_MOVELEFT			(1<<9)
#define IN_MOVERIGHT		(1<<10)
#define IN_ATTACK2			(1<<11)
#define IN_RUN			(1<<12)
#define IN_RELOAD			(1<<13)
#define IN_ALT1			(1<<14)
#define IN_SCORE			(1<<15)   // Used by client.dll for when scoreboard is held down

// Break Model Defines
#define BREAK_TYPEMASK		0x4F
#define BREAK_GLASS			0x01
#define BREAK_METAL			0x02
#define BREAK_FLESH			0x04
#define BREAK_WOOD			0x08
#define BREAK_SMOKE			0x10
#define BREAK_TRANS			0x20
#define BREAK_CONCRETE		0x40
#define BREAK_2			0x80

// Colliding temp entity sounds
#define BOUNCE_GLASS		BREAK_GLASS
#define BOUNCE_METAL		BREAK_METAL
#define BOUNCE_FLESH		BREAK_FLESH
#define BOUNCE_WOOD			BREAK_WOOD
#define BOUNCE_SHRAP		0x10
#define BOUNCE_SHELL		0x20
#define BOUNCE_CONCRETE		BREAK_CONCRETE
#define BOUNCE_SHOTSHELL		0x80

// Temp entity bounce sound types
#define TE_BOUNCE_NULL		0
#define TE_BOUNCE_SHELL		1
#define TE_BOUNCE_SHOTSHELL		2

// Rendering constants
enum 
{	
	kRenderNormal,		// src
	kRenderTransColor,		// c*a+dest*(1-a)
	kRenderTransTexture,	// src*a+dest*(1-a)
	kRenderGlow,		// src*a+dest -- No Z buffer checks
	kRenderTransAlpha,		// src*srca+dest*(1-srca)
	kRenderTransAdd,		// src*a+dest
	kRenderWorldGlow		// Same as kRenderGlow but not fixed size in screen space
};

enum 
{	
	kRenderFxNone = 0, 
	kRenderFxPulseSlow, 
	kRenderFxPulseFast, 
	kRenderFxPulseSlowWide, 
	kRenderFxPulseFastWide, 
	kRenderFxFadeSlow, 
	kRenderFxFadeFast, 
	kRenderFxSolidSlow, 
	kRenderFxSolidFast, 	   
	kRenderFxStrobeSlow, 
	kRenderFxStrobeFast, 
	kRenderFxStrobeFaster, 
	kRenderFxFlickerSlow, 
	kRenderFxFlickerFast,
	kRenderFxNoDissipation,
	kRenderFxDistort,			// Distort/scale/translate flicker
	kRenderFxHologram,			// kRenderFxDistort + distance fade
	kRenderFxDeadPlayer,		// kRenderAmt is the player index
	kRenderFxExplode,			// Scale up really big!
	kRenderFxGlowShell,			// Glowing Shell
	kRenderFxClampMinScale		// Keep this sprite from getting very small (SPRITES only!)
};

typedef int		func_t;
typedef int		string_t;

typedef unsigned char	byte;
typedef unsigned short	word;

#undef true
#undef false

#ifndef __cplusplus
typedef enum { false, true }	qboolean;
#else 
typedef int qboolean;
#endif

typedef struct
{
	byte	r, g, b;
} color24;

typedef struct
{
	unsigned	r, g, b, a;
} colorVec;

typedef struct link_s
{
	struct link_s	*prev, *next;
} link_t;

typedef struct edict_s edict_t;

typedef struct
{
	vec3_t	normal;
	float	dist;
} plane_t;

typedef struct
{
	qboolean	allsolid;		// if true, plane is not valid
	qboolean	startsolid;	// if true, the initial point was in a solid area
	qboolean	inopen, inwater;
	float	fraction;		// time completed, 1.0 = didn't hit anything
	vec3_t	endpos;		// final position
	plane_t	plane;		// surface normal at impact
	edict_t	*ent;		// entity the surface is on
	int	hitgroup;		// 0 == generic, non zero is specific body part
} trace_t;

#endif//CONST_H

```

`common/crc.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
/* crc.h */
#ifndef CRC_H
#define CRC_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// MD5 Hash
typedef struct
{
	unsigned int buf[4];
    unsigned int bits[2];
    unsigned char in[64];
} MD5Context_t;


typedef unsigned long CRC32_t;
void CRC32_Init(CRC32_t *pulCRC);
CRC32_t CRC32_Final(CRC32_t pulCRC);
void CRC32_ProcessBuffer(CRC32_t *pulCRC, void *p, int len);
void CRC32_ProcessByte(CRC32_t *pulCRC, unsigned char ch);
int CRC_File(CRC32_t *crcvalue, char *pszFileName);

unsigned char COM_BlockSequenceCRCByte (unsigned char *base, int length, int sequence);

void MD5Init(MD5Context_t *context);
void MD5Update(MD5Context_t *context, unsigned char const *buf,
               unsigned int len);
void MD5Final(unsigned char digest[16], MD5Context_t *context);
void Transform(unsigned int buf[4], unsigned int const in[16]);

int MD5_Hash_File(unsigned char digest[16], char *pszFileName, int bUsefopen, int bSeed, unsigned int seed[4]);
char *MD5_Print(unsigned char hash[16]);
int MD5_Hash_CachedFile(unsigned char digest[16], unsigned char *pCache, int nFileSize, int bSeed, unsigned int seed[4]);

int CRC_MapFile(CRC32_t *crcvalue, char *pszFileName);

#endif

```

`common/cvardef.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CVARDEF_H
#define CVARDEF_H

#define	FCVAR_ARCHIVE		(1<<0)	// set to cause it to be saved to vars.rc
#define	FCVAR_USERINFO		(1<<1)	// changes the client's info string
#define	FCVAR_SERVER		(1<<2)	// notifies players when changed
#define FCVAR_EXTDLL		(1<<3)	// defined by external DLL
#define FCVAR_CLIENTDLL     (1<<4)  // defined by the client dll
#define FCVAR_PROTECTED     (1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY        (1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define FCVAR_PRINTABLEONLY (1<<7)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
#define FCVAR_UNLOGGED		(1<<8)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log

typedef struct cvar_s
{
	const char	*name;
	const char	*string;
	int		flags;
	float	value;
	struct cvar_s *next;
} cvar_t;


typedef int qboolean;

// WARNING: Private structure from Xash3D Engine. Use with caution
typedef struct convar_s
{
	// this part shared with cvar_t
	char		*name;
	char		*string;
	int		flags;
	float		value;
	struct convar_s	*next;

	// this part unique for convar_t
	int		integer;		// atoi( string )
	qboolean		modified;		// set each time the cvar is changed
	char		*reset_string;	// cvar_restart will reset to this value
	char		*latched_string;	// for CVAR_LATCH vars
	char		*description;	// variable descrition info
} convar_t;
#endif

```

`common/demo_api.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( DEMO_APIH )
#define DEMO_APIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct demo_api_s
{
	int		( *IsRecording )	( void );
	int		( *IsPlayingback )	( void );
	int		( *IsTimeDemo )		( void );
	void	( *WriteBuffer )	( int size, unsigned char *buffer );
} demo_api_t;

extern demo_api_t demoapi;

#endif

```

`common/director_cmds.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// director_cmds.h
// sub commands for svc_director

#define DRC_ACTIVE				0	// tells client that he's an spectator and will get director command
#define DRC_STATUS				1	// send status infos about proxy 
#define DRC_CAMERA				2	// set the actual director camera position
#define DRC_EVENT				3	// informs the dircetor about ann important game event


#define DRC_FLAG_PRIO_MASK		0x0F	//	priorities between 0 and 15 (15 most important)
#define DRC_FLAG_SIDE			(1<<4)	
#define DRC_FLAG_DRAMATIC		(1<<5)



// commands of the director API function CallDirectorProc(...)

#define DRCAPI_NOP					0	// no operation
#define DRCAPI_ACTIVE				1	// de/acivates director mode in engine
#define DRCAPI_STATUS				2   // request proxy information
#define DRCAPI_SETCAM				3	// set camera n to given position and angle
#define DRCAPI_GETCAM				4	// request camera n position and angle
#define DRCAPI_DIRPLAY				5	// set director time and play with normal speed
#define DRCAPI_DIRFREEZE			6	// freeze directo at this time
#define DRCAPI_SETVIEWMODE			7	// overview or 4 cameras 
#define DRCAPI_SETOVERVIEWPARAMS	8	// sets parameter for overview mode
#define DRCAPI_SETFOCUS				9	// set the camera which has the input focus
#define DRCAPI_GETTARGETS			10	// queries engine for player list
#define DRCAPI_SETVIEWPOINTS		11	// gives engine all waypoints



```

`common/dlight.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( DLIGHTH )
#define DLIGHTH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct dlight_s
{
	vec3_t	origin;
	float	radius;
	color24	color;
	float	die;				// stop lighting after this time
	float	decay;				// drop this each second
	float	minlight;			// don't add when contributing less
	int		key;
	qboolean	dark;			// subtracts light instead of adding
} dlight_t;

#endif

```

`common/dll_state.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

//DLL State Flags

#define DLL_INACTIVE 0		// no dll
#define DLL_ACTIVE   1		// dll is running
#define DLL_PAUSED   2		// dll is paused
#define DLL_CLOSE    3		// closing down dll
#define DLL_TRANS    4 		// Level Transition

// DLL Pause reasons

#define DLL_NORMAL        0   // User hit Esc or something.
#define DLL_QUIT          4   // Quit now
#define DLL_RESTART       6   // Switch to launcher for linux, does a quit but returns 1

// DLL Substate info ( not relevant )
#define ENG_NORMAL         (1<<0)

```

`common/engine_launcher_api.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// engine/launcher interface
#if !defined( ENGINE_LAUNCHER_APIH )
#define ENGINE_LAUNCHER_APIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

//typedef void ( *xcommand_t ) ( void );

#define RENDERTYPE_UNDEFINED	0
#define RENDERTYPE_SOFTWARE		1
#define RENDERTYPE_HARDWARE		2

#define ENGINE_LAUNCHER_API_VERSION 1

typedef struct engine_api_s
{
	int		version;
	int		rendertype;
	int		size;

	// Functions
	int		( *GetEngineState )				( void );
	void	( *Cbuf_AddText )				( char *text ); // append cmd at end of buf
	void	( *Cbuf_InsertText )			( char *text ); // insert cmd at start of buf
	void	( *Cmd_AddCommand )				( char *cmd_name, void ( *funcname )( void ) );
	int		( *Cmd_Argc )					( void );
	char	*( *Cmd_Args )					( void );
	char	*( *Cmd_Argv )					( int arg );
	void	( *Con_Printf )					( char *, ... );
	void	( *Con_SafePrintf )				( char *, ... );
	void	( *Cvar_Set )					( char *var_name, char *value );
	void	( *Cvar_SetValue )				( char *var_name, float value );
	int		( *Cvar_VariableInt )			( char *var_name );
	char	*( *Cvar_VariableString )		( char *var_name );
	float	( *Cvar_VariableValue )			( char *var_name );
	void	( *ForceReloadProfile )			( void );
	int		( *GetGameInfo )				( struct GameInfo_s *pGI, char *pszChannel );
	void	( *GameSetBackground )			( int bBack );
	void	( *GameSetState )				( int iState );
	void	( *GameSetSubState )			( int iState );
	int		( *GetPauseState )				( void );
	int		( *Host_Frame )					( float time, int iState, int *stateInfo );
	void	( *Host_GetHostInfo )			( float *fps, int *nActive, int *nSpectators, int *nMaxPlayers, char *pszMap );
	void	( *Host_Shutdown )				( void );
	int		( *Game_Init )					( char *lpCmdLine, unsigned char *pMem, int iSize, struct exefuncs_s *pef, void *, int );
	void	( *IN_ActivateMouse )			( void );
	void	( *IN_ClearStates )				( void );
	void	( *IN_DeactivateMouse )			( void );
	void	( *IN_MouseEvent )				( int mstate );
	void	( *Keyboard_ReturnToGame )		( void );
	void	( *Key_ClearStates )			( void );
	void	( *Key_Event )					( int key, int down );
	int		( *LoadGame )					( const char *pszSlot );
	void	( *S_BlockSound )				( void );
	void	( *S_ClearBuffer )				( void );
	void	( *S_GetDSPointer )				( struct IDirectSound **lpDS, struct IDirectSoundBuffer **lpDSBuf );
	void 	*( *S_GetWAVPointer )			( void );
	void	( *S_UnblockSound )				( void );
	int		( *SaveGame )					( const char *pszSlot, const char *pszComment );
	void	( *SetAuth )					( void *pobj );
	void	( *SetMessagePumpDisableMode )	( int bMode );
	void	( *SetPauseState )				( int bPause );
	void	( *SetStartupMode )				( int bMode );
	void	( *SNDDMA_Shutdown )			( void );
	void	( *Snd_AcquireBuffer )			( void );
	void	( *Snd_ReleaseBuffer )			( void );
	void	( *StoreProfile )				( void );
	double	( *Sys_FloatTime )				( void );
	void	( *VID_UpdateWindowVars )		( void *prc, int x, int y );
	void	( *VID_UpdateVID )				( struct viddef_s *pvid );

	// VGUI interfaces
	void	( *VGui_CallEngineSurfaceProc )	( void* hwnd, unsigned int msg, unsigned int wparam, long lparam );

	// notifications that the launcher is taking/giving focus to the engine
	void    ( *EngineTakingFocus )			( void );
	void    ( *LauncherTakingFocus )		( void );

#ifdef _WIN32
	// Only filled in by rendertype RENDERTYPE_HARDWARE
	void	( *GL_Init )					( void );
	int		( *GL_SetMode )					( HWND hwndGame, HDC *pmaindc, HGLRC *pbaseRC, int fD3D, const char *p, const char *pszCmdLine );
	void	( *GL_Shutdown )				( HWND hwnd, HDC hdc, HGLRC hglrc );

	void	( *QGL_D3DShared )				( struct tagD3DGlobals *d3dGShared );

	int		( WINAPI *glSwapBuffers )		( HDC dc );
	void	( *DirectorProc ) ( unsigned int cmd, void * params );
#else
	// NOT USED IN LINUX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	void	( *GL_Init )					( void );
	void	( *GL_SetMode )					( void );
	void	( *GL_Shutdown )				( void );
	void	( *QGL_D3DShared )				( void );
	void	( *glSwapBuffers )				( void );
	void	( *DirectorProc )				( void );
	// LINUX
#endif

} engine_api_t;

#endif // ENGINE_LAUNCHER_APIH

```

`common/entity_state.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( ENTITY_STATEH )
#define ENTITY_STATEH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// For entityType below
#define ENTITY_NORMAL		(1<<0)
#define ENTITY_BEAM			(1<<1)

// Entity state is used for the baseline and for delta compression of a packet of 
//  entities that is sent to a client.
typedef struct entity_state_s entity_state_t;

struct entity_state_s
{
// Fields which are filled in by routines outside of delta compression
	int			entityType;
	// Index into cl_entities array for this entity.
	int			number;      
	float		msg_time;

	// Message number last time the player/entity state was updated.
	int			messagenum;		

	// Fields which can be transitted and reconstructed over the network stream
	vec3_t		origin;
	vec3_t		angles;

	int			modelindex;
	int			sequence;
	float		frame;
	int			colormap;
	short		skin;
	short		solid;
	int			effects;
	float		scale;

	byte		eflags;
	
	// Render information
	int			rendermode;
	int			renderamt;
	color24		rendercolor;
	int			renderfx;

	int			movetype;
	float		animtime;
	float		framerate;
	int			body;
	byte		controller[4];
	byte		blending[4];
	vec3_t		velocity;

	// Send bbox down to client for use during prediction.
	vec3_t		mins;    
	vec3_t		maxs;

	int			aiment;
	// If owned by a player, the index of that player ( for projectiles ).
	int			owner; 

	// Friction, for prediction.
	float		friction;       
	// Gravity multiplier
	float		gravity;		

// PLAYER SPECIFIC
	int			team;
	int			playerclass;
	int			health;
	qboolean	spectator;  
	int         weaponmodel;
	int			gaitsequence;
	// If standing on conveyor, e.g.
	vec3_t		basevelocity;   
	// Use the crouched hull, or the regular player hull.
	int			usehull;		
	// Latched buttons last time state updated.
	int			oldbuttons;     
	// -1 = in air, else pmove entity number
	int			onground;		
	int			iStepLeft;
	// How fast we are falling
	float		flFallVelocity;  

	float		fov;
	int			weaponanim;

	// Parametric movement overrides
	vec3_t				startpos;
	vec3_t				endpos;
	float				impacttime;
	float				starttime;

	// For mods
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
};

#include "pm_info.h"

typedef struct clientdata_s
{
	vec3_t				origin;
	vec3_t				velocity;

	int					viewmodel;
	vec3_t				punchangle;
	int					flags;
	int					waterlevel;
	int					watertype;
	vec3_t				view_ofs;
	float				health;

	int					bInDuck;

	int					weapons; // remove?
	
	int					flTimeStepSound;
	int					flDuckTime;
	int					flSwimTime;
	int					waterjumptime;

	float				maxspeed;

	float				fov;
	int					weaponanim;

	int					m_iId;
	int					ammo_shells;
	int					ammo_nails;
	int					ammo_cells;
	int					ammo_rockets;
	float				m_flNextAttack;
	
	int					tfstate;

	int					pushmsec;

	int					deadflag;

	char				physinfo[ MAX_PHYSINFO_STRING ];

	// For mods
	int					iuser1;
	int					iuser2;
	int					iuser3;
	int					iuser4;
	float				fuser1;
	float				fuser2;
	float				fuser3;
	float				fuser4;
	vec3_t				vuser1;
	vec3_t				vuser2;
	vec3_t				vuser3;
	vec3_t				vuser4;
} clientdata_t;

#include "weaponinfo.h"

typedef struct local_state_s
{
	entity_state_t playerstate;
	clientdata_t   client;
	weapon_data_t  weapondata[ 32 ];
} local_state_t;

#endif // !ENTITY_STATEH

```

`common/entity_types.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// entity_types.h
#if !defined( ENTITY_TYPESH )
#define ENTITY_TYPESH

#define ET_NORMAL		0
#define ET_PLAYER		1
#define ET_TEMPENTITY	2
#define ET_BEAM			3
// BMODEL or SPRITE that was split across BSP nodes
#define ET_FRAGMENTED	4

#endif // !ENTITY_TYPESH

```

`common/event_api.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( EVENT_APIH )
#define EVENT_APIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#define EVENT_API_VERSION 1

typedef struct event_api_s
{
	int		version;
	void	( *EV_PlaySound ) ( int ent, float *origin, int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch );
	void	( *EV_StopSound ) ( int ent, int channel, const char *sample );
	int		( *EV_FindModelIndex )( const char *pmodel );
	int		( *EV_IsLocal ) ( int playernum );
	int		( *EV_LocalPlayerDucking ) ( void );
	void	( *EV_LocalPlayerViewheight ) ( float * );
	void	( *EV_LocalPlayerBounds ) ( int hull, float *mins, float *maxs );
	int		( *EV_IndexFromTrace) ( struct pmtrace_s *pTrace );
	struct physent_s *( *EV_GetPhysent ) ( int idx );
	void	( *EV_SetUpPlayerPrediction ) ( int dopred, int bIncludeLocalClient );
	void	( *EV_PushPMStates ) ( void );
	void	( *EV_PopPMStates ) ( void );
	void	( *EV_SetSolidPlayers ) (int playernum);
	void	( *EV_SetTraceHull ) ( int hull );
	void	( *EV_PlayerTrace ) ( float *start, float *end, int traceFlags, int ignore_pe, struct pmtrace_s *tr );
	void	( *EV_WeaponAnimation ) ( int sequence, int body );
	unsigned short ( *EV_PrecacheEvent ) ( int type, const char* psz );
	void	( *EV_PlaybackEvent ) ( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	const char *( *EV_TraceTexture ) ( int ground, float *vstart, float *vend );
	void	( *EV_StopAllSounds ) ( int entnum, int entchannel );
	void    ( *EV_KillEvents ) ( int entnum, const char *eventname );
} event_api_t;

extern event_api_t eventapi;

#endif

```

`common/event_args.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_ARGSH )
#define EVENT_ARGSH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// Event was invoked with stated origin
#define FEVENT_ORIGIN	( 1<<0 )

// Event was invoked with stated angles
#define FEVENT_ANGLES	( 1<<1 )

typedef struct event_args_s
{
	int		flags;

	// Transmitted
	int		entindex;

	float	origin[3];
	float	angles[3];
	float	velocity[3];

	int		ducking;

	float	fparam1;
	float	fparam2;

	int		iparam1;
	int		iparam2;

	int		bparam1;
	int		bparam2;
} event_args_t;

#endif

```

`common/event_flags.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_FLAGSH )
#define EVENT_FLAGSH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// Skip local host for event send.
#define FEV_NOTHOST		(1<<0)    

// Send the event reliably.  You must specify the origin and angles and use
// PLAYBACK_EVENT_FULL for this to work correctly on the server for anything
// that depends on the event origin/angles.  I.e., the origin/angles are not
// taken from the invoking edict for reliable events.
#define FEV_RELIABLE	(1<<1)	 

// Don't restrict to PAS/PVS, send this event to _everybody_ on the server ( useful for stopping CHAN_STATIC
//  sounds started by client event when client is not in PVS anymore ( hwguy in TFC e.g. ).
#define FEV_GLOBAL		(1<<2)

// If this client already has one of these events in its queue, just update the event instead of sending it as a duplicate
//
#define FEV_UPDATE		(1<<3)

// Only send to entity specified as the invoker
#define	FEV_HOSTONLY	(1<<4)

// Only send if the event was created on the server.
#define FEV_SERVER		(1<<5)

// Only issue event client side ( from shared code )
#define FEV_CLIENT		(1<<6)

#endif

```

`common/exefuncs.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// exefuncs.h
#ifndef EXEFUNCS_H
#define EXEFUNCS_H

// Engine hands this to DLLs for functionality callbacks
typedef struct exefuncs_s
{
	int			fMMX;
	int			iCPUMhz;
	void		(*unused1)(void);
	void		(*unused2)(void);
	void		(*unused3)(void);
	void		(*unused4)(void);
	void		(*VID_ForceLockState)(int lk);
	int			(*VID_ForceUnlockedAndReturnState)(void);
	void		(*unused5)(void);
	void		(*unused6)(void);
	void		(*unused7)(void);
	void		(*unused8)(void);
	void		(*unused9)(void);
	void		(*unused10)(void);
	void		(*unused11)(void);
	void		(*unused12)(void);
	void		(*unused13)(void);
	void		(*unused14)(void);
	void		(*unused15)(void);
	void        (*ErrorMessage)(int nLevel, const char *pszErrorMessage);
	void		(*unused16)(void);
	void        (*Sys_Printf)(char *fmt, ...);
	void		(*unused17)(void);
	void		(*unused18)(void);
	void		(*unused19)(void);
	void		(*unused20)(void);
	void		(*unused21)(void);
	void		(*unused22)(void);
	void		(*unused23)(void);
	void		(*unused24)(void);
	void		(*unused25)(void);
	void		(*unused26)(void);
	void		(*unused27)(void);
} exefuncs_t;

#endif

```

`common/gameinfo.h`:

```h
/*
gameinfo.h - current game info
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef GAMEINFO_H
#define GAMEINFO_H

#define GFL_NOMODELS	(1<<0)

/*
========================================================================

GAMEINFO stuff

internal shared gameinfo structure (readonly for engine parts)
========================================================================
*/
typedef struct
{
	// filesystem info
	char		gamefolder[64];	// used for change game '-game x'
	char		startmap[64];	// map to start singleplayer game
	char		trainmap[64];	// map to start hazard course (if specified)
	char		title[64];	// Game Main Title
	char		version[14];	// game version (optional)
	short		flags;		// game flags

	// about mod info
	char		game_url[256];	// link to a developer's site
	char		update_url[256];	// link to updates page
	char		type[64];		// single, toolkit, multiplayer etc
	char		date[64];
	char		size[64];		// displayed mod size

	int		gamemode;
} GAMEINFO;

#endif//GAMEINFO_H
```

`common/hltv.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// hltv.h
// all shared consts between server, clients and proxy

#ifndef HLTV_H
#define HLTV_H

#define TYPE_CLIENT				0	// client is a normal HL client (default)
#define TYPE_PROXY				1	// client is another proxy
#define TYPE_COMMENTATOR		3	// client is a commentator
#define TYPE_DEMO				4	// client is a demo file
// sub commands of svc_hltv:
#define HLTV_ACTIVE				0	// tells client that he's an spectator and will get director commands
#define HLTV_STATUS				1	// send status infos about proxy 
#define HLTV_LISTEN				2	// tell client to listen to a multicast stream

// sub commands of svc_director:
#define DRC_CMD_NONE				0	// NULL director command
#define DRC_CMD_START				1	// start director mode
#define DRC_CMD_EVENT				2	// informs about director command
#define DRC_CMD_MODE				3	// switches camera modes
#define DRC_CMD_CAMERA				4	// sets camera registers
#define DRC_CMD_TIMESCALE			5	// sets time scale
#define DRC_CMD_MESSAGE				6	// send HUD centerprint
#define DRC_CMD_SOUND				7	// plays a particular sound
#define DRC_CMD_STATUS				8	// status info about broadcast
#define DRC_CMD_BANNER				9	// banner file name for HLTV gui
#define	DRC_CMD_FADE				10	// send screen fade command
#define DRC_CMD_SHAKE				11	// send screen shake command
#define DRC_CMD_STUFFTEXT			12	// like the normal svc_stufftext but as director command

#define DRC_CMD_LAST				12



// HLTV_EVENT event flags
#define DRC_FLAG_PRIO_MASK		0x0F	// priorities between 0 and 15 (15 most important)
#define DRC_FLAG_SIDE			(1<<4)	// 
#define DRC_FLAG_DRAMATIC		(1<<5)	// is a dramatic scene
#define DRC_FLAG_SLOWMOTION		(1<<6)  // would look good in SloMo
#define DRC_FLAG_FACEPLAYER		(1<<7)  // player is doning something (reload/defuse bomb etc)
#define DRC_FLAG_INTRO			(1<<8)	// is a introduction scene
#define DRC_FLAG_FINAL			(1<<9)	// is a final scene
#define DRC_FLAG_NO_RANDOM		(1<<10)	// don't randomize event data


#define MAX_DIRECTOR_CMD_PARAMETERS		4
#define MAX_DIRECTOR_CMD_STRING			128


#endif // HLTV_H

```

`common/in_buttons.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef IN_BUTTONS_H
#define IN_BUTTONS_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif


#ifndef CONST_H
#define IN_ATTACK	(1 << 0)
#define IN_JUMP		(1 << 1)
#define IN_DUCK		(1 << 2)
#define IN_FORWARD	(1 << 3)
#define IN_BACK		(1 << 4)
#define IN_USE		(1 << 5)
#define IN_CANCEL	(1 << 6)
#define IN_LEFT		(1 << 7)
#define IN_RIGHT	(1 << 8)
#define IN_MOVELEFT	(1 << 9)
#define IN_MOVERIGHT (1 << 10)
#define IN_ATTACK2	(1 << 11)
#define IN_RUN      (1 << 12)
#define IN_RELOAD	(1 << 13)
#define IN_ALT1		(1 << 14)
#define IN_SCORE	(1 << 15)   // Used by client.dll for when scoreboard is held down
#endif

#endif // IN_BUTTONS_H

```

`common/interface.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include <string.h>
#include <stdlib.h>
#include "interface.h"

#ifndef _WIN32  // LINUX
#include <dlfcn.h>
#include <unistd.h> // getcwd
#include <stdio.h> // sprintf
#endif


// ------------------------------------------------------------------------------------ //
// InterfaceReg.
// ------------------------------------------------------------------------------------ //
InterfaceReg *InterfaceReg::s_pInterfaceRegs = NULL;


InterfaceReg::InterfaceReg( InstantiateInterfaceFn fn, const char *pName ) :
	m_pName(pName)
{
	m_CreateFn = fn;
	m_pNext = s_pInterfaceRegs;
	s_pInterfaceRegs = this;
}



// ------------------------------------------------------------------------------------ //
// CreateInterface.
// ------------------------------------------------------------------------------------ //
EXPORT_FUNCTION IBaseInterface *CreateInterface( const char *pName, int *pReturnCode )
{
	InterfaceReg *pCur;
	
	for(pCur=InterfaceReg::s_pInterfaceRegs; pCur; pCur=pCur->m_pNext)
	{
		if(strcmp(pCur->m_pName, pName) == 0)
		{
			if ( pReturnCode )
			{
				*pReturnCode = IFACE_OK;
			}
			return pCur->m_CreateFn();
		}
	}
	
	if ( pReturnCode )
	{
		*pReturnCode = IFACE_FAILED;
	}
	return NULL;	
}


#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif


#ifdef _WIN32
HINTERFACEMODULE Sys_LoadModule(const char *pModuleName)
{
	return (HINTERFACEMODULE)LoadLibrary(pModuleName);
}

#else  // LINUX
HINTERFACEMODULE Sys_LoadModule(const char *pModuleName)
{
	// Linux dlopen() doesn't look in the current directory for libraries.
	// We tell it to, so people don't have to 'install' libraries as root.

	char szCwd[1024];
	char szAbsoluteLibFilename[1024];

	getcwd( szCwd, sizeof( szCwd ) );
	if ( szCwd[ strlen( szCwd ) - 1 ] == '/' )
		szCwd[ strlen( szCwd ) - 1 ] = 0;

	sprintf( szAbsoluteLibFilename, "%s/%s", szCwd, pModuleName );

	return (HINTERFACEMODULE)dlopen( szAbsoluteLibFilename, RTLD_NOW );
}

#endif


#ifdef _WIN32
void Sys_FreeModule(HINTERFACEMODULE hModule)
{
	if(!hModule)
		return;

	FreeLibrary((HMODULE)hModule);
}

#else  // LINUX
void Sys_FreeModule(HINTERFACEMODULE hModule)
{
	if(!hModule)
		return;

	dlclose( (void *)hModule );
}

#endif


//-----------------------------------------------------------------------------
// Purpose: returns the instance of this module
// Output : interface_instance_t
//-----------------------------------------------------------------------------
CreateInterfaceFn Sys_GetFactoryThis( void )
{
	return CreateInterface;
}


//-----------------------------------------------------------------------------
// Purpose: returns the instance of the named module
// Input  : *pModuleName - name of the module
// Output : interface_instance_t - instance of that module
//-----------------------------------------------------------------------------

#ifdef _WIN32
CreateInterfaceFn Sys_GetFactory( HINTERFACEMODULE hModule )
{
	if(!hModule)
		return NULL;

	return (CreateInterfaceFn)GetProcAddress((HMODULE)hModule, CREATEINTERFACE_PROCNAME);
}

#else  // LINUX
CreateInterfaceFn Sys_GetFactory( HINTERFACEMODULE hModule )
{
	if(!hModule)
		return NULL;

	return (CreateInterfaceFn)dlsym( (void *)hModule, CREATEINTERFACE_PROCNAME );
}

#endif

```

`common/interface.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// This header defines the interface convention used in the valve engine.
// To make an interface and expose it:
//    1. Derive from IBaseInterface.
//    2. The interface must be ALL pure virtuals, and have no data members.
//    3. Define a name for it.
//    4. In its implementation file, use EXPOSE_INTERFACE or EXPOSE_SINGLE_INTERFACE.

// Versioning
// There are two versioning cases that are handled by this:
// 1. You add functions to the end of an interface, so it is binary compatible with the previous interface. In this case, 
//    you need two EXPOSE_INTERFACEs: one to expose your class as the old interface and one to expose it as the new interface.
// 2. You update an interface so it's not compatible anymore (but you still want to be able to expose the old interface 
//    for legacy code). In this case, you need to make a new version name for your new interface, and make a wrapper interface and 
//    expose it for the old interface.

#ifndef INTERFACE_H
#define INTERFACE_H

#ifdef __cplusplus

// All interfaces derive from this.
class IBaseInterface
{
public:

	virtual			~IBaseInterface() {}
};


#define CREATEINTERFACE_PROCNAME	"CreateInterface"
typedef IBaseInterface* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);


typedef IBaseInterface* (*InstantiateInterfaceFn)();


// Used internally to register classes.
class InterfaceReg
{
public:
				InterfaceReg(InstantiateInterfaceFn fn, const char *pName);

public:

	InstantiateInterfaceFn	m_CreateFn;
	const char				*m_pName;

	InterfaceReg			*m_pNext; // For the global list.
	static InterfaceReg		*s_pInterfaceRegs;
};


// Use this to expose an interface that can have multiple instances.
// e.g.:
// EXPOSE_INTERFACE( CInterfaceImp, IInterface, "MyInterface001" )
// This will expose a class called CInterfaceImp that implements IInterface (a pure class)
// clients can receive a pointer to this class by calling CreateInterface( "MyInterface001" )
//
// In practice, the shared header file defines the interface (IInterface) and version name ("MyInterface001")
// so that each component can use these names/vtables to communicate
//
// A single class can support multiple interfaces through multiple inheritance
//
#define EXPOSE_INTERFACE_FN(functionName, interfaceName, versionName) \
	static InterfaceReg __g_Create##className##_reg(functionName, versionName);

#define EXPOSE_INTERFACE(className, interfaceName, versionName) \
	static IBaseInterface* __Create##className##_interface() {return (interfaceName *)new className;}\
	static InterfaceReg __g_Create##className##_reg(__Create##className##_interface, versionName );

// Use this to expose a singleton interface with a global variable you've created.
#define EXPOSE_SINGLE_INTERFACE_GLOBALVAR(className, interfaceName, versionName, globalVarName) \
	static IBaseInterface* __Create##className##interfaceName##_interface() {return (interfaceName *)&globalVarName;}\
	static InterfaceReg __g_Create##className##interfaceName##_reg(__Create##className##interfaceName##_interface, versionName);

// Use this to expose a singleton interface. This creates the global variable for you automatically.
#define EXPOSE_SINGLE_INTERFACE(className, interfaceName, versionName) \
	static className __g_##className##_singleton;\
	EXPOSE_SINGLE_INTERFACE_GLOBALVAR(className, interfaceName, versionName, __g_##className##_singleton)


#ifdef WIN32
	#define EXPORT_FUNCTION __attribute__ ((dllexport))
#else
	#define EXPORT_FUNCTION
#endif


// This function is automatically exported and allows you to access any interfaces exposed with the above macros.
// if pReturnCode is set, it will return one of the following values
// extend this for other error conditions/code
enum 
{
	IFACE_OK = 0,
	IFACE_FAILED
};


extern "C"
{
	EXPORT_FUNCTION IBaseInterface* CreateInterface(const char *pName, int *pReturnCode);
};


// Handle to an interface (HInterfaceModule_t* is just there for type safety).
typedef struct HInterfaceModule_t* HINTERFACEMODULE;


// Use these to load and unload a module.
extern HINTERFACEMODULE		Sys_LoadModule(const char *pModuleName);
extern void					Sys_FreeModule(HINTERFACEMODULE hModule);

// Use these to get the factory function from either a loaded module or the current module.
extern CreateInterfaceFn	Sys_GetFactory( HINTERFACEMODULE hModule );
extern CreateInterfaceFn	Sys_GetFactoryThis( void );

#endif // __cplusplus

#endif




```

`common/ivoicetweak.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef IVOICETWEAK_H
#define IVOICETWEAK_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// These provide access to the voice controls.
typedef enum
{
	MicrophoneVolume=0,			// values 0-1.
	OtherSpeakerScale			// values 0-1. Scales how loud other players are.
} VoiceTweakControl;


typedef struct IVoiceTweak_s
{
	// These turn voice tweak mode on and off. While in voice tweak mode, the user's voice is echoed back
	// without sending to the server. 
	int				(*StartVoiceTweakMode)();	// Returns 0 on error.
	void			(*EndVoiceTweakMode)();
	
	// Get/set control values.
	void			(*SetControlFloat)(VoiceTweakControl iControl, float value);
	float			(*GetControlFloat)(VoiceTweakControl iControl);
} IVoiceTweak;


#endif // IVOICETWEAK_H

```

`common/kbutton.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#pragma once
#if !defined( KBUTTONH )
#define KBUTTONH

typedef struct kbutton_s
{
	int		down[2];		// key nums holding it down
	int		state;			// low bit is down state
} kbutton_t;

#endif // !KBUTTONH

```

`common/lightstyle.h`:

```h
/*
lightstyle.h - lighstyle description
Copyright (C) 2011 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef LIGHTSTYLE_H
#define LIGHTSTYLE_H

typedef struct
{
	char		pattern[256];
	float		map[256];
	int		length;
	float		value;
	qboolean		interp;		// allow to interpolate this lightstyle
	float		time;		// local time warranties that new style begins from the start, not mid or end of the sequence
} lightstyle_t;

#endif//LIGHTSTYLE_H
```

`common/mathlib.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// mathlib.h

typedef float vec_t;
typedef vec_t vec3_t[3];
typedef vec_t vec4_t[4];	// x,y,z,w
typedef vec_t vec5_t[5];

typedef short vec_s_t;
typedef vec_s_t vec3s_t[3];
typedef vec_s_t vec4s_t[4];	// x,y,z,w
typedef vec_s_t vec5s_t[5];

typedef	int	fixed4_t;
typedef	int	fixed8_t;
typedef	int	fixed16_t;

#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

struct mplane_s;

extern vec3_t vec3_origin;
extern	int nanmask;

#define	IS_NAN(x) (((*(int *)&x)&nanmask)==nanmask)

#ifndef VECTOR_H
	#define DotProduct(x,y) ((x)[0]*(y)[0]+(x)[1]*(y)[1]+(x)[2]*(y)[2])
#endif

#define VectorSubtract(a,b,c) {(c)[0]=(a)[0]-(b)[0];(c)[1]=(a)[1]-(b)[1];(c)[2]=(a)[2]-(b)[2];}
#define VectorAdd(a,b,c) {(c)[0]=(a)[0]+(b)[0];(c)[1]=(a)[1]+(b)[1];(c)[2]=(a)[2]+(b)[2];}
#define VectorCopy(a,b) {(b)[0]=(a)[0];(b)[1]=(a)[1];(b)[2]=(a)[2];}
#define VectorClear(a) {(a)[0]=0.0;(a)[1]=0.0;(a)[2]=0.0;}

void VectorMA (const vec3_t veca, float scale, const vec3_t vecb, vec3_t vecc);

vec_t _DotProduct (vec3_t v1, vec3_t v2);
void _VectorSubtract (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorAdd (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorCopy (vec3_t in, vec3_t out);

int VectorCompare (const vec3_t v1, const vec3_t v2);
float Length (const vec3_t v);
void CrossProduct (const vec3_t v1, const vec3_t v2, vec3_t cross);
float VectorNormalize (vec3_t v);		// returns vector length
void VectorInverse (vec3_t v);
void VectorScale (const vec3_t in, vec_t scale, vec3_t out);
int Q_log2(int val);

void R_ConcatRotations (float in1[3][3], float in2[3][3], float out[3][3]);
void R_ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4]);

// Here are some "manual" INLINE routines for doing floating point to integer conversions
extern short new_cw, old_cw;

typedef union DLONG {
	int		i[2];
	double	d;
	float	f;
	} DLONG;

extern DLONG	dlong;

#ifdef _MSC_VER
void __inline set_fpu_cw(void)
{
_asm	
	{		wait
			fnstcw	old_cw
			wait
			mov		ax, word ptr old_cw
			or		ah, 0xc
			mov		word ptr new_cw,ax
			fldcw	new_cw
	}
}

int __inline quick_ftol(float f)
{
	_asm {
		// Assumes that we are already in chop mode, and only need a 32-bit int
		fld		DWORD PTR f
		fistp	DWORD PTR dlong
	}
	return dlong.i[0];
}

void __inline restore_fpu_cw(void)
{
	_asm	fldcw	old_cw
}
#else
#define set_fpu_cw() /* */
#define quick_ftol(f) ftol(f)
#define restore_fpu_cw() /* */
#endif

void FloorDivMod (double numer, double denom, int *quotient,
		int *rem);
fixed16_t Invert24To16(fixed16_t val);
int GreatestCommonDivisor (int i1, int i2);

void AngleVectors (const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
void AngleVectorsTranspose (const vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
#define AngleIVectors	AngleVectorsTranspose

void AngleMatrix (const vec3_t angles, float (*matrix)[4] );
void AngleIMatrix (const vec3_t angles, float (*matrix)[4] );
void VectorTransform (const vec3_t in1, float in2[3][4], vec3_t out);

void NormalizeAngles( vec3_t angles );
void InterpolateAngles( vec3_t start, vec3_t end, vec3_t output, float frac );
float AngleBetweenVectors( const vec3_t v1, const vec3_t v2 );


void VectorMatrix( vec3_t forward, vec3_t right, vec3_t up);
void VectorAngles( const vec3_t forward, vec3_t angles );

int InvertMatrix( const float * m, float *out );

int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct mplane_s *plane);
float anglemod(float a);

// up / down
#define	PITCH	0
// left / right
#define	YAW		1
// fall over
#define	ROLL	2


#define BOX_ON_PLANE_SIDE(emins, emaxs, p)	\
	(((p)->type < 3)?						\
	(										\
		((p)->dist <= (emins)[(p)->type])?	\
			1								\
		:									\
		(									\
			((p)->dist >= (emaxs)[(p)->type])?\
				2							\
			:								\
				3							\
		)									\
	)										\
	:										\
		BoxOnPlaneSide( (emins), (emaxs), (p)))

```

`common/net_api.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined( NET_APIH )
#define NET_APIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#if !defined ( NETADRH )
#include "netadr.h"
#endif

#define NETAPI_REQUEST_SERVERLIST	( 0 )  // Doesn't need a remote address
#define NETAPI_REQUEST_PING			( 1 )
#define NETAPI_REQUEST_RULES		( 2 )
#define NETAPI_REQUEST_PLAYERS		( 3 )
#define NETAPI_REQUEST_DETAILS		( 4 )

// Set this flag for things like broadcast requests, etc. where the engine should not
//  kill the request hook after receiving the first response
#define FNETAPI_MULTIPLE_RESPONSE ( 1<<0 )

typedef void ( *net_api_response_func_t ) ( struct net_response_s *response );

#define NET_SUCCESS						( 0 )
#define NET_ERROR_TIMEOUT				( 1<<0 )
#define NET_ERROR_PROTO_UNSUPPORTED		( 1<<1 )
#define NET_ERROR_UNDEFINED				( 1<<2 )

typedef struct net_adrlist_s
{
	struct net_adrlist_s	*next;
	netadr_t				remote_address;
} net_adrlist_t;

typedef struct net_response_s
{
	// NET_SUCCESS or an error code
	int			error;

	// Context ID
	int			context;
	// Type
	int			type;

	// Server that is responding to the request
	netadr_t	remote_address;

	// Response RTT ping time
	double		ping;
	// Key/Value pair string ( separated by backlash \ characters )
	// WARNING:  You must copy this buffer in the callback function, because it is freed
	//  by the engine right after the call!!!!
	// ALSO:  For NETAPI_REQUEST_SERVERLIST requests, this will be a pointer to a linked list of net_adrlist_t's
	void		*response;
} net_response_t;

typedef struct net_status_s
{
		// Connected to remote server?  1 == yes, 0 otherwise
	int			connected; 
	// Client's IP address
	netadr_t	local_address;
	// Address of remote server
	netadr_t	remote_address;
	// Packet Loss ( as a percentage )
	int			packet_loss;
	// Latency, in seconds ( multiply by 1000.0 to get milliseconds )
	double		latency;
	// Connection time, in seconds
	double		connection_time;
	// Rate setting ( for incoming data )
	double		rate;
} net_status_t;

typedef struct net_api_s
{
	// APIs
	void		( *InitNetworking )( void );
	void		( *Status ) ( struct net_status_s *status );
	void		( *SendRequest) ( int context, int request, int flags, double timeout, struct netadr_s *remote_address, net_api_response_func_t response );
	void		( *CancelRequest ) ( int context );
	void		( *CancelAllRequests ) ( void );
	char		*( *AdrToString ) ( struct netadr_s *a );
	int			( *CompareAdr ) ( struct netadr_s *a, struct netadr_s *b );
	int			( *StringToAdr ) ( char *s, struct netadr_s *a );
	const char *( *ValueForKey ) ( const char *s, const char *key );
	void		( *RemoveKey ) ( char *s, const char *key );
	void		( *SetValueForKey ) (char *s, const char *key, const char *value, int maxsize );
} net_api_t;

extern net_api_t netapi;

#endif // NET_APIH

```

`common/netadr.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// netadr.h
#ifndef NETADR_H
#define NETADR_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef enum
{
	NA_UNUSED,
	NA_LOOPBACK,
	NA_BROADCAST,
	NA_IP,
	NA_IPX,
	NA_BROADCAST_IPX
} netadrtype_t;

typedef struct netadr_s
{
	netadrtype_t	type;
	unsigned char	ip[4];
	unsigned char	ipx[10];
	unsigned short	port;
} netadr_t;

#endif // NETADR_H

```

`common/nowin.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef INC_NOWIN_H
#define INC_NOWIN_H
#ifndef _WIN32

#include <unistd.h>

#endif //!_WIN32
#endif //INC_NOWIN_H

```

`common/particledef.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PARTICLEDEFH )
#define PARTICLEDEFH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef enum {
	pt_static, 
	pt_grav,
	pt_slowgrav,
	pt_fire,
	pt_explode,
	pt_explode2,
	pt_blob,
	pt_blob2,
	pt_vox_slowgrav,
	pt_vox_grav,
	pt_clientcustom   // Must have callback function specified
} ptype_t;

// !!! if this is changed, it must be changed in d_ifacea.h too !!!
typedef struct particle_s
{
// driver-usable fields
	vec3_t		org;
	short		color;
	short		packedColor;
// drivers never touch the following fields
	struct particle_s	*next;
	vec3_t		vel;
	float		ramp;
	float		die;
	ptype_t		type;
	void		(*deathfunc)( struct particle_s *particle );

	// for pt_clientcusttom, we'll call this function each frame
	void		(*callback)( struct particle_s *particle, float frametime );
	
	// For deathfunc, etc.
	unsigned char context;
} particle_t;

#endif

```

`common/pmtrace.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PMTRACEH )
#define PMTRACEH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct
{
	vec3_t	normal;
	float	dist;
} pmplane_t;

typedef struct pmtrace_s pmtrace_t;

struct pmtrace_s
{
	qboolean	allsolid;	      // if true, plane is not valid
	qboolean	startsolid;	      // if true, the initial point was in a solid area
	qboolean	inopen, inwater;  // End point is in empty space or in water
	float		fraction;		  // time completed, 1.0 = didn't hit anything
	vec3_t		endpos;			  // final position
	pmplane_t	plane;		      // surface normal at impact
	int			ent;			  // entity at impact
	vec3_t      deltavelocity;    // Change in player's velocity caused by impact.  
								  // Only run on server.
	int         hitgroup;
};

#endif

```

`common/port.h`:

```h
/*
port.h -- Portability Layer for Windows types
Copyright (C) 2015 Alibek Omarov

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#pragma once
#ifndef PORT_H
#define PORT_H

#ifdef XASH_VGUI
	#if !(defined(__i386__) || defined(_X86_) || defined(_WIN32))
	#error "VGUI is exists only for x86. You must disable VGUI flag or build Xash3D for x86 target."
    #endif
#endif

#ifndef _WIN32
    #include <limits.h>
    #include <dlfcn.h>

    #ifdef __APPLE__
		#include <sys/syslimits.h>
		#define OS_LIB_EXT "dylib"
    #else
		#ifdef __linux__
			#include <linux/limits.h>
		#endif
		#define OS_LIB_EXT "so"
    #endif

    #ifdef __ANDROID__
		#define XASH_THREADS
		#ifdef LOAD_HARDFP
			#define MENUDLL "libmenu_hardfp.so"
			#define CLIENTDLL "libclient_hardfp.so"
			#define SERVERDLL "libserver_hardfp.so"
		#else
			#define MENUDLL "libmenu.so"
			#define CLIENTDLL "libclient.so"
			#define SERVERDLL "libserver.so"
		#endif
		#define GAMEPATH "/sdcard/xash"
    #else
		#define MENUDLL "libxashmenu." OS_LIB_EXT
		#define CLIENTDLL "client." OS_LIB_EXT
		#ifdef PANDORA
			#define SERVERDLL "hl." OS_LIB_EXT
			#define LIBPATH "."
			#define GAMEPATH "."
		#endif
    #endif

	#define VGUI_SUPPORT_DLL "libvgui_support." OS_LIB_EXT

    #define TRUE	    1
    #define FALSE	    0

    // Windows-specific
    #define _stdcall
    #define __stdcall
    #define __cdecl
	#define _inline	    static inline
    #define O_BINARY    0		//In Linux O_BINARY didn't exist

    // Windows functions to Linux equivalent
	#define _mkdir( x )					mkdir( x, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH )
	#define LoadLibrary( x )			dlopen( x, RTLD_NOW )
	#define GetProcAddress( x, y )		dlsym( x, y )
	#define SetCurrentDirectory( x )	(!chdir( x ))
	#define FreeLibrary( x )			dlclose( x )
	#define MAKEWORD(a,b)				((short int)(((unsigned char)(a))|(((short int)((unsigned char)(b)))<<8)))
	#define max(a, b)  (((a) > (b)) ? (a) : (b))
	#define min(a, b)  (((a) < (b)) ? (a) : (b))
	#define tell(a)						lseek(a, 0, SEEK_CUR)

    typedef unsigned char   BYTE;
    typedef unsigned char   byte;
    typedef short int	    WORD;
    typedef unsigned int    DWORD;
    typedef long int	    LONG;
    typedef unsigned long int   ULONG;
    typedef long	    WPARAM;
    typedef unsigned int    LPARAM;

    typedef void* HANDLE;
    typedef void* HMODULE;
    typedef void* HINSTANCE;

    typedef char* LPSTR;

    typedef struct tagPOINT
    {
	int x, y;
    } POINT;
#else
	#define strcasecmp _stricmp
	#define strncasecmp _strnicmp
	#define open _open
	#define read _read

	// shut-up compiler warnings
	//#pragma warning(disable : 4244)	// MIPS
	//#pragma warning(disable : 4018)	// signed/unsigned mismatch
	//#pragma warning(disable : 4305)	// truncation from const double to float
	//#pragma warning(disable : 4115)	// named type definition in parentheses
	//#pragma warning(disable : 4100)	// unreferenced formal parameter
	//#pragma warning(disable : 4127)	// conditional expression is constant
	//#pragma warning(disable : 4057)	// differs in indirection to slightly different base types
	//#pragma warning(disable : 4201)	// nonstandard extension used
	//#pragma warning(disable : 4706)	// assignment within conditional expression
	//#pragma warning(disable : 4054)	// type cast' : from function pointer
	//#pragma warning(disable : 4310)	// cast truncates constant value
	//#pragma warning(disable : 4244) // 'argument': conversion from 'float' to 'int', possible loss of data

	#define HSPRITE WINAPI_HSPRITE
	#include <windows.h>
	#undef HSPRITE

    #define OS_LIB_EXT "dll"
    #define MENUDLL "menu." OS_LIB_EXT
    #define CLIENTDLL "client." OS_LIB_EXT
	#define VGUI_SUPPORT_DLL "../vgui_support." OS_LIB_EXT
#endif

#endif

```

`common/qfont.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( QFONTH )
#define QFONTH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// Font stuff

#define NUM_GLYPHS 256

typedef struct
{
	short startoffset;
	short charwidth;
} charinfo;

typedef struct qfont_s
{
	int 		width, height;
	int			rowcount;
	int			rowheight;
	charinfo	fontinfo[ NUM_GLYPHS ];
	byte 		data[4];
} qfont_t;

#endif // qfont.h

```

`common/r_efx.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( R_EFXH )
#define R_EFXH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// particle_t
#if !defined( PARTICLEDEFH )  
#include "particledef.h"
#endif

// BEAM
#if !defined( BEAMDEFH )
#include "beamdef.h"
#endif

// dlight_t
#if !defined ( DLIGHTH )
#include "dlight.h"
#endif

// cl_entity_t
#if !defined( CL_ENTITYH )
#include "cl_entity.h"
#endif

/*
// FOR REFERENCE, These are the built-in tracer colors.  Note, color 4 is the one
//  that uses the tracerred/tracergreen/tracerblue and traceralpha cvar settings
color24 gTracerColors[] =
{
	{ 255, 255, 255 },		// White
	{ 255, 0, 0 },			// Red
	{ 0, 255, 0 },			// Green
	{ 0, 0, 255 },			// Blue
	{ 0, 0, 0 },			// Tracer default, filled in from cvars, etc.
	{ 255, 167, 17 },		// Yellow-orange sparks
	{ 255, 130, 90 },		// Yellowish streaks (garg)
	{ 55, 60, 144 },		// Blue egon streak
	{ 255, 130, 90 },		// More Yellowish streaks (garg)
	{ 255, 140, 90 },		// More Yellowish streaks (garg)
	{ 200, 130, 90 },		// More red streaks (garg)
	{ 255, 120, 70 },		// Darker red streaks (garg)
};
*/

// Temporary entity array
#define TENTPRIORITY_LOW	0
#define TENTPRIORITY_HIGH	1

// TEMPENTITY flags
#define	FTENT_NONE				0x00000000
#define	FTENT_SINEWAVE			0x00000001
#define	FTENT_GRAVITY			0x00000002
#define FTENT_ROTATE			0x00000004
#define	FTENT_SLOWGRAVITY		0x00000008
#define FTENT_SMOKETRAIL		0x00000010
#define FTENT_COLLIDEWORLD		0x00000020
#define FTENT_FLICKER			0x00000040
#define FTENT_FADEOUT			0x00000080
#define FTENT_SPRANIMATE		0x00000100
#define FTENT_HITSOUND			0x00000200
#define FTENT_SPIRAL			0x00000400
#define FTENT_SPRCYCLE			0x00000800
#define FTENT_COLLIDEALL		0x00001000 // will collide with world and slideboxes
#define FTENT_PERSIST			0x00002000 // tent is not removed when unable to draw 
#define FTENT_COLLIDEKILL		0x00004000 // tent is removed upon collision with anything
#define FTENT_PLYRATTACHMENT	0x00008000 // tent is attached to a player (owner)
#define FTENT_SPRANIMATELOOP	0x00010000 // animating sprite doesn't die when last frame is displayed
#define FTENT_SPARKSHOWER		0x00020000
#define FTENT_NOMODEL			0x00040000 // Doesn't have a model, never try to draw ( it just triggers other things )
#define FTENT_CLIENTCUSTOM		0x00080000 // Must specify callback.  Callback function is responsible for killing tempent and updating fields ( unless other flags specify how to do things )
#define FTENT_IGNOREGRAVITY		0x00200000 // CS1.6

typedef struct tempent_s	TEMPENTITY;
typedef struct tempent_s
{
	int			flags;
	float		die;
	float		frameMax;
	float		x;
	float		y;
	float		z;
	float		fadeSpeed;
	float		bounceFactor;
	int			hitSound;
	void		( *hitcallback )	( struct tempent_s *ent, struct pmtrace_s *ptr );
	void		( *callback )		( struct tempent_s *ent, float frametime, float currenttime );
	TEMPENTITY	*next;
	int			priority;
	short		clientIndex;	// if attached, this is the index of the client to stick to
								// if COLLIDEALL, this is the index of the client to ignore
								// TENTS with FTENT_PLYRATTACHMENT MUST set the clientindex! 

	vec3_t		tentOffset;		// if attached, client origin + tentOffset = tent origin.
	cl_entity_t	entity;

	// baseline.origin		- velocity
	// baseline.renderamt	- starting fadeout intensity
	// baseline.angles		- angle velocity
} TEMPENTITY;

typedef struct efx_api_s efx_api_t;

struct efx_api_s
{
	particle_t  *( *R_AllocParticle )			( void ( *callback ) ( struct particle_s *particle, float frametime ) );
	void		( *R_BlobExplosion )			( float * org );
	void		( *R_Blood )					( float * org, float * dir, int pcolor, int speed );
	void		( *R_BloodSprite )				( float * org, int colorindex, int modelIndex, int modelIndex2, float size );
	void		( *R_BloodStream )				( float * org, float * dir, int pcolor, int speed );
	void		( *R_BreakModel )				( float *pos, float *size, float *dir, float random, float life, int count, int modelIndex, char flags );
	void		( *R_Bubbles )					( float * mins, float * maxs, float height, int modelIndex, int count, float speed );
	void		( *R_BubbleTrail )				( float * start, float * end, float height, int modelIndex, int count, float speed );
	void		( *R_BulletImpactParticles )	( float * pos );
	void		( *R_EntityParticles )			( struct cl_entity_s *ent );
	void		( *R_Explosion )				( float *pos, int model, float scale, float framerate, int flags );
	void		( *R_FizzEffect )				( struct cl_entity_s *pent, int modelIndex, int density );
	void		( *R_FireField ) 				( float * org, int radius, int modelIndex, int count, int flags, float life );
	void		( *R_FlickerParticles )			( float * org );
	void		( *R_FunnelSprite )				( float *org, int modelIndex, int reverse );
	void		( *R_Implosion )				( float * end, float radius, int count, float life );
	void		( *R_LargeFunnel )				( float * org, int reverse );
	void		( *R_LavaSplash )				( float * org );
	void		( *R_MultiGunshot )				( float * org, float * dir, float * noise, int count, int decalCount, int *decalIndices );
	void		( *R_MuzzleFlash )				( float *pos1, int type );
	void		( *R_ParticleBox )				( float *mins, float *maxs, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_ParticleBurst )			( float * pos, int size, int color, float life );
	void		( *R_ParticleExplosion )		( float * org );
	void		( *R_ParticleExplosion2 )		( float * org, int colorStart, int colorLength );
	void		( *R_ParticleLine )				( float * start, float *end, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_PlayerSprites )			( int client, int modelIndex, int count, int size );
	void		( *R_Projectile )				( float * origin, float * velocity, int modelIndex, int life, int owner, void (*hitcallback)( struct tempent_s *ent, struct pmtrace_s *ptr ) );
	void		( *R_RicochetSound )			( float * pos );
	void		( *R_RicochetSprite )			( float *pos, struct model_s *pmodel, float duration, float scale );
	void		( *R_RocketFlare )				( float *pos );
	void		( *R_RocketTrail )				( float * start, float * end, int type );
	void		( *R_RunParticleEffect )		( float * org, float * dir, int color, int count );
	void		( *R_ShowLine )					( float * start, float * end );
	void		( *R_SparkEffect )				( float *pos, int count, int velocityMin, int velocityMax );
	void		( *R_SparkShower )				( float *pos );
	void		( *R_SparkStreaks )				( float * pos, int count, int velocityMin, int velocityMax );
	void		( *R_Spray )					( float * pos, float * dir, int modelIndex, int count, int speed, int spread, int rendermode );
	void		( *R_Sprite_Explode )			( TEMPENTITY *pTemp, float scale, int flags );
	void		( *R_Sprite_Smoke )				( TEMPENTITY *pTemp, float scale );
	void		( *R_Sprite_Spray )				( float * pos, float * dir, int modelIndex, int count, int speed, int iRand );
	void		( *R_Sprite_Trail )				( int type, float * start, float * end, int modelIndex, int count, float life, float size, float amplitude, int renderamt, float speed );
	void		( *R_Sprite_WallPuff )			( TEMPENTITY *pTemp, float scale );
	void		( *R_StreakSplash )				( float * pos, float * dir, int color, int count, float speed, int velocityMin, int velocityMax );
	void		( *R_TracerEffect )				( float * start, float * end );
	void		( *R_UserTracerParticle )		( float * org, float * vel, float life, int colorIndex, float length, unsigned char deathcontext, void ( *deathfunc)( struct particle_s *particle ) );
	particle_t *( *R_TracerParticles )			( float * org, float * vel, float life );
	void		( *R_TeleportSplash )			( float * org );
	void		( *R_TempSphereModel )			( float *pos, float speed, float life, int count, int modelIndex );
	TEMPENTITY	*( *R_TempModel )				( float *pos, float *dir, float *angles, float life, int modelIndex, int soundtype );
	TEMPENTITY	*( *R_DefaultSprite )			( float *pos, int spriteIndex, float framerate );
	TEMPENTITY	*( *R_TempSprite )				( float *pos, float *dir, float scale, int modelIndex, int rendermode, int renderfx, float a, float life, int flags );
	int			( *Draw_DecalIndex )			( int id );
	int			( *Draw_DecalIndexFromName )	( char *name );
	void		( *R_DecalShoot )				( int textureIndex, int entity, int modelIndex, float * position, int flags );
	void		( *R_AttachTentToPlayer )		( int client, int modelIndex, float zoffset, float life );
	void		( *R_KillAttachedTents )		( int client );
	BEAM		*( *R_BeamCirclePoints )		( int type, float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEntPoint )			( int startEnt, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEnts )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamFollow )				( int startEnt, int modelIndex, float life, float width, float r, float g, float b, float brightness );
	void		( *R_BeamKill )					( int deadEntity );
	BEAM		*( *R_BeamLightning )			( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed );
	BEAM		*( *R_BeamPoints )				( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamRing )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	dlight_t	*( *CL_AllocDlight )			( int key );
	dlight_t	*( *CL_AllocElight )			( int key );
	TEMPENTITY	*( *CL_TempEntAlloc )			( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TempEntAllocNoModel )	( float * org );
	TEMPENTITY	*( *CL_TempEntAllocHigh )		( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TentEntAllocCustom )		( float *origin, struct model_s *model, int high, void ( *callback ) ( struct tempent_s *ent, float frametime, float currenttime ) );
	void		( *R_GetPackedColor )			( short *packed, short color );
	short		( *R_LookupColor )				( unsigned char r, unsigned char g, unsigned char b );
	void		( *R_DecalRemoveAll )			( int textureIndex ); //textureIndex points to the decal index in the array, not the actual texture index.
};

extern efx_api_t efx;

#endif

```

`common/r_studioint.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined( R_STUDIOINT_H )
#define R_STUDIOINT_H
#if defined( _WIN32 )
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#define STUDIO_INTERFACE_VERSION 1

typedef struct engine_studio_api_s
{
	// Allocate number*size bytes and zero it
	void			*( *Mem_Calloc )				( int number, size_t size );
	// Check to see if pointer is in the cache
	void			*( *Cache_Check )				( struct cache_user_s *c );
	// Load file into cache ( can be swapped out on demand )
	void			( *LoadCacheFile )				( char *path, struct cache_user_s *cu );
	// Retrieve model pointer for the named model
	struct model_s	*( *Mod_ForName )				( const char *name, int crash_if_missing );
	// Retrieve pointer to studio model data block from a model
	void			*( *Mod_Extradata )				( struct model_s *mod );
	// Retrieve indexed model from client side model precache list
	struct model_s	*( *GetModelByIndex )			( int index );
	// Get entity that is set for rendering
	struct cl_entity_s * ( *GetCurrentEntity )		( void );
	// Get referenced player_info_t
	struct player_info_s *( *PlayerInfo )			( int index );
	// Get most recently received player state data from network system
	struct entity_state_s *( *GetPlayerState )		( int index );
	// Get viewentity
	struct cl_entity_s * ( *GetViewEntity )			( void );
	// Get current frame count, and last two timestampes on client
	void			( *GetTimes )					( int *framecount, double *current, double *old );
	// Get a pointer to a cvar by name
	struct cvar_s	*( *GetCvar )					( const char *name );
	// Get current render origin and view vectors ( up, right and vpn )
	void			( *GetViewInfo )				( float *origin, float *upv, float *rightv, float *vpnv );
	// Get sprite model used for applying chrome effect
	struct model_s	*( *GetChromeSprite )			( void );
	// Get model counters so we can incement instrumentation
	void			( *GetModelCounters )			( int **s, int **a );
	// Get software scaling coefficients
	void			( *GetAliasScale )				( float *x, float *y );

	// Get bone, light, alias, and rotation matrices
	float			****( *StudioGetBoneTransform ) ( void );
	float			****( *StudioGetLightTransform )( void );
	float			***( *StudioGetAliasTransform ) ( void );
	float			***( *StudioGetRotationMatrix ) ( void );

	// Set up body part, and get submodel pointers
	void			( *StudioSetupModel )			( int bodypart, void **ppbodypart, void **ppsubmodel );
	// Check if entity's bbox is in the view frustum
	int				( *StudioCheckBBox )			( void );
	// Apply lighting effects to model
	void			( *StudioDynamicLight )			( struct cl_entity_s *ent, struct alight_s *plight );
	void			( *StudioEntityLight )			( struct alight_s *plight );
	void			( *StudioSetupLighting )		( struct alight_s *plighting );

	// Draw mesh vertices
	void			( *StudioDrawPoints )			( void );

	// Draw hulls around bones
	void			( *StudioDrawHulls )			( void );
	// Draw bbox around studio models
	void			( *StudioDrawAbsBBox )			( void );
	// Draws bones
	void			( *StudioDrawBones )			( void );
	// Loads in appropriate texture for model
	void			( *StudioSetupSkin )			( void *ptexturehdr, int index );
	// Sets up for remapped colors
	void			( *StudioSetRemapColors )		( int top, int bottom );
	// Set's player model and returns model pointer
	struct model_s	*( *SetupPlayerModel )			( int index );
	// Fires any events embedded in animation
	void			( *StudioClientEvents )			( void );
	// Retrieve/set forced render effects flags
	int				( *GetForceFaceFlags )			( void );
	void			( *SetForceFaceFlags )			( int flags );
	// Tell engine the value of the studio model header
	void			( *StudioSetHeader )			( void *header );
	// Tell engine which model_t * is being renderered
	void			( *SetRenderModel )				( struct model_s *model );

	// Final state setup and restore for rendering
	void			( *SetupRenderer )				( int rendermode );
	void			( *RestoreRenderer )			( void );

	// Set render origin for applying chrome effect
	void			( *SetChromeOrigin )			( void );

	// True if using D3D/OpenGL
	int				( *IsHardware )					( void );
	
	// Only called by hardware interface
	void			( *GL_StudioDrawShadow )		( void );
	void			( *GL_SetRenderMode )			( int mode );

	void		( *StudioSetRenderamt )( int iRenderamt );
	void		( *StudioSetCullState )( int iCull );
	void		( *StudioRenderShadow )( int iSprite, float *p1, float *p2, float *p3, float *p4 );
} engine_studio_api_t;

typedef struct server_studio_api_s
{
	// Allocate number*size bytes and zero it
	void			*( *Mem_Calloc )				( int number, size_t size );
	// Check to see if pointer is in the cache
	void			*( *Cache_Check )				( struct cache_user_s *c );
	// Load file into cache ( can be swapped out on demand )
	void			( *LoadCacheFile )				( char *path, struct cache_user_s *cu );
	// Retrieve pointer to studio model data block from a model
	void			*( *Mod_Extradata )				( struct model_s *mod );
} server_studio_api_t;


// client blending
typedef struct r_studio_interface_s
{
	int				version;
	int				( *StudioDrawModel	)			( int flags );
	int				( *StudioDrawPlayer	)			( int flags, struct entity_state_s *pplayer );
} r_studio_interface_t;

extern r_studio_interface_t *pStudioAPI;

// server blending
#define SV_BLENDING_INTERFACE_VERSION 1

typedef struct sv_blending_interface_s
{
	int	version;

	void	( *SV_StudioSetupBones )( struct model_s *pModel, 
					float frame,
					int sequence,
					const vec3_t angles,
					const vec3_t origin,
					const byte *pcontroller,
					const byte *pblending,
					int iBone,
					const edict_t *pEdict );
} sv_blending_interface_t;

#endif // R_STUDIOINT_H

```

`common/ref_params.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#ifndef REF_PARAMS_H
#define REF_PARAMS_H

typedef struct ref_params_s
{
	// output
	vec3_t		vieworg;
	vec3_t		viewangles;

	vec3_t		forward;
	vec3_t		right;
	vec3_t		up;
	
	// Client frametime;
	float		frametime;
	// Client time
	float		time;

	// Misc
	int		intermission;
	int		paused;
	int		spectator;
	int		onground;
	int		waterlevel;

	vec3_t		simvel;
	vec3_t		simorg;

	vec3_t		viewheight;
	float		idealpitch;

	vec3_t		cl_viewangles;
	int		health;
	vec3_t		crosshairangle;
	float		viewsize;

	vec3_t		punchangle;
	int		maxclients;
	int		viewentity;
	int		playernum;
	int		max_entities;
	int		demoplayback;	
	int		hardware;
	int		smoothing;

	// Last issued usercmd
	struct usercmd_s	*cmd;

	// Movevars
	struct movevars_s	*movevars;

	int		viewport[4];	// the viewport coordinates x, y, width, height
	int		nextView;		// the renderer calls ClientDLL_CalcRefdef() and Renderview
					// so long in cycles until this value is 0 (multiple views)
	int		onlyClientDraw;	// if !=0 nothing is drawn by the engine except clientDraw functions
// Xash3D extension
	float		fov_x, fov_y;	// actual fov can be overriden on nextView
} ref_params_t;

// same as ref_params but for overview mode
typedef struct ref_overview_s
{
	vec3_t		origin;
	qboolean		rotated;

	float		xLeft;
	float		xRight;
	float		xTop;
	float		xBottom;
	float		zFar;
	float		zNear;
	float		flZoom;
} ref_overview_t;

#endif//REF_PARAMS_H
```

`common/render_api.h`:

```h
/*
render_api.h - Xash3D extension for client interface
Copyright (C) 2011 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef RENDER_API_H
#define RENDER_API_H

#include "lightstyle.h"
#include "dlight.h"

// changes for version 28
// replace decal_t from software declaration to hardware (matched to normal HL)
// mextrasurf_t->increased limit of reserved fields (up from 7 to 32)
// replace R_StoreEfrags with him extended version
// formed group for BSP decal manipulating
// move misc functions at end of the interface
// added new export for clearing studio decals

#define CL_RENDER_INTERFACE_VERSION	35
#define MAX_STUDIO_DECALS		4096	// + unused space of BSP decals

#define SURF_INFO( surf, mod )	((mextrasurf_t *)mod->cache.data + (surf - mod->surfaces)) 
#define INFO_SURF( surf, mod )	(mod->surfaces + (surf - (mextrasurf_t *)mod->cache.data)) 

// render info parms
#define PARM_TEX_WIDTH	1	// all parms with prefix 'TEX_' receive arg as texnum
#define PARM_TEX_HEIGHT	2	// otherwise it's not used
#define PARM_TEX_SRC_WIDTH	3
#define PARM_TEX_SRC_HEIGHT	4
#define PARM_TEX_SKYBOX	5	// second arg as skybox ordering num
#define PARM_TEX_SKYTEXNUM	6	// skytexturenum for quake sky
#define PARM_TEX_LIGHTMAP	7	// second arg as number 0 - 128
#define PARM_TEX_TARGET	8
#define PARM_TEX_TEXNUM	9
#define PARM_TEX_FLAGS	10
#define PARM_TEX_TYPE	11
#define PARM_TEX_CACHEFRAME	12	// compare with worldmodel->needload
#define PARM_TEX_GLFORMAT	13	// get a texture GL-format
// reserved
#define PARM_WORLD_VERSION	16	// return the version of bsp
#define PARM_SKY_SPHERE	17	// sky is quake sphere ?
#define PARM_MAP_HAS_MIRRORS	18	// current map has mirorrs
#define PARM_MAP_HAS_DELUXE	19	// map has deluxedata
#define PARM_MAX_ENTITIES	20
#define PARM_WIDESCREEN	21
#define PARM_FULLSCREEN	22
#define PARM_SCREEN_WIDTH	23
#define PARM_SCREEN_HEIGHT	24
#define PARM_CLIENT_INGAME	25
#define PARM_FEATURES	26	// same as movevars->features
#define PARM_ACTIVE_TMU	27	// for debug
#define PARM_CACHEFRAME	28
#define PARM_MAX_IMAGE_UNITS	29
#define PARM_CLIENT_ACTIVE	30
#define PARM_REBUILD_GAMMA	31	// if true lightmaps rebuilding for gamma change

enum
{
	// skybox ordering
	SKYBOX_RIGHT	= 0,
	SKYBOX_BACK,
	SKYBOX_LEFT,
	SKYBOX_FORWARD,
	SKYBOX_UP,
	SKYBOX_DOWN,
};

typedef enum
{
	TEX_INVALID = 0,	// free slot
	TEX_SYSTEM,	// generated by engine
	TEX_NOMIP,	// hud pics, menu etc
	TEX_BRUSH,	// a map texture
	TEX_SPRITE,	// sprite frames
	TEX_STUDIO,	// studio skins
	TEX_LIGHTMAP,	// lightmap textures
	TEX_DECAL,	// decals
	TEX_VGUI,		// vgui fonts or images
	TEX_CUBEMAP,	// cubemap textures (sky)
	TEX_DETAIL,	// detail textures
	TEX_REMAP,	// local copy of remap texture
	TEX_SCREENCOPY,	// keep screen copy e.g. for mirror
	TEX_CUSTOM,	// user created texture
	TEX_DEPTHMAP	// shadowmap texture
} texType_t;

typedef enum
{
	TF_NEAREST	= (1<<0),		// disable texfilter
	TF_KEEP_RGBDATA	= (1<<1),		// some images keep source
	TF_NOFLIP_TGA	= (1<<2),		// Steam background completely ignore tga attribute 0x20
	TF_KEEP_8BIT	= (1<<3),		// keep original 8-bit image (if present)
	TF_NOPICMIP	= (1<<4),		// ignore r_picmip resample rules
	TF_UNCOMPRESSED	= (1<<5),		// don't compress texture in video memory
	TF_CUBEMAP	= (1<<6),		// it's cubemap texture
	TF_DEPTHMAP	= (1<<7),		// custom texture filter used
	TF_INTENSITY	= (1<<8),		// monochrome intensity image
	TF_LUMINANCE	= (1<<9),		// force image to grayscale
	TF_SKYSIDE	= (1<<10),	// this is a part of skybox
	TF_CLAMP		= (1<<11),	// clamp texcoords to [0..1] range
	TF_NOMIPMAP	= (1<<12),	// don't build mips for this image
	TF_HAS_LUMA	= (1<<13),	// sets by GL_UploadTexture
	TF_MAKELUMA	= (1<<14),	// create luma from quake texture (only q1 textures contain luma-pixels)
	TF_NORMALMAP	= (1<<15),	// is a normalmap
	TF_HAS_ALPHA	= (1<<16),	// image has alpha (used only for GL_CreateTexture)
	TF_FORCE_COLOR	= (1<<17),	// force upload monochrome textures as RGB (detail textures)
	TF_TEXTURE_1D	= (1<<18),	// this is GL_TEXTURE_1D
	TF_BORDER		= (1<<19),	// zero clamp for projected textures
	TF_TEXTURE_3D	= (1<<20),	// this is GL_TEXTURE_3D
	TF_STATIC		= (1<<21),	// a marker for purge mechanism (not used by engine)
	TF_TEXTURE_RECTANGLE= (1<<22),	// this is GL_TEXTURE_RECTANGLE
	TF_ALPHA_BORDER	= (1<<23),	// clamp to (0,0,0,255) (probably no difference)
	TF_IMAGE_PROGRAM	= (1<<24),	// enable image program support like in Doom3
	TF_ALPHACONTRAST	= (1<<25),	// special texture flags for internal usage
	TF_FLOAT		= (1<<26),	// float textures
	TF_NOCOMPARE	= (1<<27),	// disable comparing for depth textures
	TF_FLOATDATA	= (1<<28),
} texFlags_t;

typedef struct beam_s BEAM;
typedef struct particle_s particle_t;

// 12 bytes here
typedef struct modelstate_s
{
	short		sequence;
	short		frame;		// 10 bits multiple by 4, should be enough
	byte		blending[2];
	byte		controller[4];
	byte		body;
	byte		skin;
} modelstate_t;

typedef struct decallist_s
{
	vec3_t		position;
	char		name[64];
	short		entityIndex;
	byte		depth;
	byte		flags;
	float		scale;

	// this is the surface plane that we hit so that
	// we can move certain decals across
	// transitions if they hit similar geometry
	vec3_t		impactPlaneNormal;

	modelstate_t	studio_state;	// studio decals only
} decallist_t;

typedef struct render_api_s
{
	// Get renderer info (doesn't changes engine state at all)
	int		(*RenderGetParm)( int parm, int arg );	// generic
	void		(*GetDetailScaleForTexture)( int texture, float *xScale, float *yScale );
	void		(*GetExtraParmsForTexture)( int texture, byte *red, byte *green, byte *blue, byte *alpha );
	lightstyle_t*	(*GetLightStyle)( int number ); 
	dlight_t*		(*GetDynamicLight)( int number );
	dlight_t*		(*GetEntityLight)( int number );
	byte		(*TextureToTexGamma)( byte color );	// software gamma support
	void		(*GetBeamChains)( BEAM ***active_beams, BEAM ***free_beams, particle_t ***free_trails );

	// Set renderer info (tell engine about changes)
	void		(*R_SetCurrentEntity)( struct cl_entity_s *ent ); // tell engine about both currententity and currentmodel
	void		(*R_SetCurrentModel)( struct model_s *mod );	// change currentmodel but leave currententity unchanged
	void		(*GL_SetWorldviewProjectionMatrix)( const float *glmatrix ); // update viewprojection matrix (tracers uses it)
	void		(*R_StoreEfrags)( struct efrag_s **ppefrag, int framecount );// store efrags for static entities

	// Texture tools
	int		(*GL_FindTexture)( const char *name );
	const char*	(*GL_TextureName)( unsigned int texnum );
	const byte*	(*GL_TextureData)( unsigned int texnum ); // may be NULL
	int		(*GL_LoadTexture)( const char *name, const byte *buf, size_t size, int flags );
	int		(*GL_CreateTexture)( const char *name, int width, int height, const void *buffer, int flags ); 
	void		(*GL_SetTextureType)( unsigned int texnum, unsigned int type );
	void		(*GL_TextureCacheFrame)( unsigned int texnum );
	void		(*GL_FreeTexture)( unsigned int texnum );

	// Decals manipulating (draw & remove)
	void		(*DrawSingleDecal)( struct decal_s *pDecal, struct msurface_s *fa );
	float		*(*R_DecalSetupVerts)( struct decal_s *pDecal, struct msurface_s *surf, int texture, int *outCount );
	void		(*R_EntityRemoveDecals)( struct model_s *mod ); // remove all the decals from specified entity (BSP only)

	// AVIkit support
	void		*(*AVI_LoadVideo)( const char *filename, int ignore_hwgamma );
	int		(*AVI_GetVideoInfo)( void *Avi, long *xres, long *yres, float *duration );
	long		(*AVI_GetVideoFrameNumber)( void *Avi, float time );
	byte		*(*AVI_GetVideoFrame)( void *Avi, long frame );
	void		(*AVI_UploadRawFrame)( int texture, int cols, int rows, int width, int height, const byte *data );
	void		(*AVI_FreeVideo)( void *Avi );
	int		(*AVI_IsActive)( void *Avi );

	// glState related calls (must use this instead of normal gl-calls to prevent de-synchornize local states between engine and the client)
	void		(*GL_Bind)( int tmu, unsigned int texnum );
	void		(*GL_SelectTexture)( int tmu );
	void		(*GL_LoadTextureMatrix)( const float *glmatrix );
	void		(*GL_TexMatrixIdentity)( void );
	void		(*GL_CleanUpTextureUnits)( int last );	// pass 0 for clear all the texture units
	void		(*GL_TexGen)( unsigned int coord, unsigned int mode );
	void		(*GL_TextureTarget)( unsigned int target ); // change texture unit mode without bind texture
	void		(*GL_TexCoordArrayMode)( unsigned int texmode );
	void		(*GL_Reserved0)( void );	// for potential interface expansion without broken compatibility
	void		(*GL_Reserved1)( void );
	void		(*GL_Reserved2)( void );
	void		(*GL_Reserved3)( void );
		
	// Misc renderer functions
	void		(*GL_DrawParticles)( const float *vieworg, const float *fwd, const float *rt, const float *up, unsigned int clipFlags );
	void		(*EnvShot)( const float *vieworg, const char *name, qboolean skyshot, int shotsize ); // creates a cubemap or skybox into gfx\env folder
	int		(*COM_CompareFileTime)( const char *filename1, const char *filename2, int *iCompare );
	void		(*Host_Error)( const char *error, ... ); // cause Host Error
	int		(*SPR_LoadExt)( const char *szPicName, unsigned int texFlags ); // extended version of SPR_Load
	void		(*TessPolygon)( struct msurface_s *surf, struct model_s *mod, float tessSize );
	struct mstudiotex_s *( *StudioGetTexture )( struct cl_entity_s *e );
	const struct ref_overview_s *( *GetOverviewParms )( void );
	void		(*S_FadeMusicVolume)( float fadePercent );	// fade background track (0-100 percents)
	void		(*SetRandomSeed)( long lSeed );		// set custom seed for RANDOM_FLOAT\RANDOM_LONG for predictable random
	// static allocations
	void		*(*pfnMemAlloc)( size_t cb, const char *filename, const int fileline );
	void		(*pfnMemFree)( void *mem, const char *filename, const int fileline );
 	// find in files
	char		**(*pfnGetFilesList)( const char *pattern, int *numFiles, int gamedironly );
	// ONLY ADD NEW FUNCTIONS TO THE END OF THIS STRUCT.  INTERFACE VERSION IS FROZEN AT 35
} render_api_t;

// render callbacks
typedef struct render_interface_s
{
	int		version;
	// passed through R_RenderFrame (0 - use engine renderer, 1 - use custom client renderer)
	int		(*GL_RenderFrame)( const struct ref_params_s *pparams, qboolean drawWorld );
	// build all the lightmaps on new level or when gamma is changed
	void		(*GL_BuildLightmaps)( void );
	// setup map bounds for ortho-projection when we in dev_overview mode
	void		(*GL_OrthoBounds)( const float *mins, const float *maxs );
	// handle decals which hit mod_studio or mod_sprite
	void		(*R_StudioDecalShoot)( int decalTexture, struct cl_entity_s *ent, const float *start, const float *pos, int flags, modelstate_t *state );
	// prepare studio decals for save
	int		(*R_CreateStudioDecalList)( decallist_t *pList, int count, qboolean changelevel );
	// clear decals by engine request (e.g. for demo recording or vid_restart)
	void		(*R_ClearStudioDecals)( void );
	// grab r_speeds message
	qboolean		(*R_SpeedsMessage)( char *out, size_t size );
	// replace with built-in R_DrawCubemapView for make skyshots or envshots
	qboolean		(*R_DrawCubemapView)( const float *origin, const float *angles, int size );
	// alloc or destroy studiomodel custom data
	void		(*Mod_ProcessUserData)( struct model_s *mod, qboolean create, const byte *buffer );
} render_interface_t;

#endif//RENDER_API_H

```

`common/screenfade.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined( SCREENFADEH )
#define SCREENFADEH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct screenfade_s
{
	float		fadeSpeed;		// How fast to fade (tics / second) (+ fade in, - fade out)
	float		fadeEnd;		// When the fading hits maximum
	float		fadeTotalEnd;	// Total End Time of the fade (used for FFADE_OUT)
	float		fadeReset;		// When to reset to not fading (for fadeout and hold)
	byte		fader, fadeg, fadeb, fadealpha;	// Fade color
	int			fadeFlags;		// Fading flags
} screenfade_t;

#endif // !SCREENFADEH

```

`common/studio_event.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( STUDIO_EVENTH )
#define STUDIO_EVENTH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct mstudioevent_s
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;

#endif // STUDIO_EVENTH

```

`common/triangleapi.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( TRIANGLEAPIH )
#define TRIANGLEAPIH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef enum 
{
	TRI_FRONT = 0,
	TRI_NONE = 1,
} TRICULLSTYLE;

#define TRI_API_VERSION		1

#define TRI_TRIANGLES		0
#define TRI_TRIANGLE_FAN	1
#define TRI_QUADS			2
#define TRI_POLYGON			3
#define TRI_LINES			4	
#define TRI_TRIANGLE_STRIP	5
#define TRI_QUAD_STRIP		6
#define TRI_POINTS			7 // Xash3D added

typedef struct triangleapi_s
{
	int			version;

	void		( *RenderMode )( int mode );
	void		( *Begin )( int primitiveCode );
	void		( *End ) ( void );

	void		( *Color4f ) ( float r, float g, float b, float a );
	void		( *Color4ub ) ( unsigned char r, unsigned char g, unsigned char b, unsigned char a );
	void		( *TexCoord2f ) ( float u, float v );
	void		( *Vertex3fv ) ( float *worldPnt );
	void		( *Vertex3f ) ( float x, float y, float z );
	void		( *Brightness ) ( float brightness );
	void		( *CullFace ) ( TRICULLSTYLE style );
	int			( *SpriteTexture ) ( struct model_s *pSpriteModel, int frame );
	int			( *WorldToScreen ) ( float *world, float *screen );  // Returns 1 if it's z clipped
	void		( *Fog ) ( float flFogColor[3], float flStart, float flEnd, int bOn ); //Works just like GL_FOG, flFogColor is r/g/b.
	void		( *ScreenToWorld ) ( float *screen, float *world  ); 
	void	(*GetMatrix)( const int pname, float *matrix );
	int	(*BoxInPVS)( float *mins, float *maxs );
	void	(*LightAtPoint)( float *pos, float *value );
	void	(*Color4fRendermode)( float r, float g, float b, float a, int rendermode );
	void	(*FogParams)( float flDensity, int iFogSkybox );


} triangleapi_t;

#endif // !TRIANGLEAPIH

```

`common/usercmd.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef USERCMD_H
#define USERCMD_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct usercmd_s
{
	short	lerp_msec;      // Interpolation time on client
	byte	msec;           // Duration in ms of command
	vec3_t	viewangles;     // Command view angles.

// intended velocities
	float	forwardmove;    // Forward velocity.
	float	sidemove;       // Sideways velocity.
	float	upmove;         // Upward velocity.
	byte	lightlevel;     // Light level at spot where we are standing.
	unsigned short  buttons;  // Attack buttons
	byte    impulse;          // Impulse command issued.
	byte	weaponselect;	// Current weapon id

// Experimental player impact stuff.
	int		impact_index;
	vec3_t	impact_position;
} usercmd_t;

#endif // USERCMD_H

```

`common/weaponinfo.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( WEAPONINFOH )
#define WEAPONINFOH
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

// Info about weapons player might have in his/her possession
typedef struct weapon_data_s
{
	int			m_iId;
	int			m_iClip;

	float		m_flNextPrimaryAttack;
	float		m_flNextSecondaryAttack;
	float		m_flTimeWeaponIdle;

	int			m_fInReload;
	int			m_fInSpecialReload;
	float		m_flNextReload;
	float		m_flPumpTime;
	float		m_fReloadTime;

	float		m_fAimedDamage;
	float		m_fNextAimBonus;
	int			m_fInZoom;
	int			m_iWeaponState;

	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
} weapon_data_t;

#endif

```

`common/wrect.h`:

```h
/*
wrect.h - rectangle definition
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef WRECT_H
#define WRECT_H

typedef struct wrect_s
{
	int	left, right, top, bottom;
} wrect_t;

#endif//WRECT_H
```

`dlls/activity.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef ACTIVITY_H
#define ACTIVITY_H

typedef enum
{
	ACT_RESET,
	ACT_IDLE,
	ACT_GUARD,
	ACT_WALK,
	ACT_RUN,
	ACT_FLY,
	ACT_SWIM,
	ACT_HOP,
	ACT_LEAP,
	ACT_FALL,
	ACT_LAND,
	ACT_STRAFE_LEFT,
	ACT_STRAFE_RIGHT,
	ACT_ROLL_LEFT,
	ACT_ROLL_RIGHT,
	ACT_TURN_LEFT,
	ACT_TURN_RIGHT,
	ACT_CROUCH,
	ACT_CROUCHIDLE,
	ACT_STAND,
	ACT_USE,
	ACT_SIGNAL1,
	ACT_SIGNAL2,
	ACT_SIGNAL3,
	ACT_TWITCH,
	ACT_COWER,
	ACT_SMALL_FLINCH,
	ACT_BIG_FLINCH,
	ACT_RANGE_ATTACK1,
	ACT_RANGE_ATTACK2,
	ACT_MELEE_ATTACK1,
	ACT_MELEE_ATTACK2,
	ACT_RELOAD,
	ACT_ARM,
	ACT_DISARM,
	ACT_EAT,
	ACT_DIESIMPLE,
	ACT_DIEBACKWARD,
	ACT_DIEFORWARD,
	ACT_DIEVIOLENT,
	ACT_BARNACLE_HIT,
	ACT_BARNACLE_PULL,
	ACT_BARNACLE_CHOMP,
	ACT_BARNACLE_CHEW,
	ACT_SLEEP,
	ACT_INSPECT_FLOOR,
	ACT_INSPECT_WALL,
	ACT_IDLE_ANGRY,
	ACT_WALK_HURT,
	ACT_RUN_HURT,
	ACT_HOVER,
	ACT_GLIDE,
	ACT_FLY_LEFT,
	ACT_FLY_RIGHT,
	ACT_DETECT_SCENT,
	ACT_SNIFF,
	ACT_BITE,
	ACT_THREAT_DISPLAY,
	ACT_FEAR_DISPLAY,
	ACT_EXCITED,
	ACT_SPECIAL_ATTACK1,
	ACT_SPECIAL_ATTACK2,
	ACT_COMBAT_IDLE,
	ACT_WALK_SCARED,
	ACT_RUN_SCARED,
	ACT_VICTORY_DANCE,
	ACT_DIE_HEADSHOT,
	ACT_DIE_CHESTSHOT,
	ACT_DIE_GUTSHOT,
	ACT_DIE_BACKSHOT,
	ACT_FLINCH_HEAD,
	ACT_FLINCH_CHEST,
	ACT_FLINCH_STOMACH,
	ACT_FLINCH_LEFTARM,
	ACT_FLINCH_RIGHTARM,
	ACT_FLINCH_LEFTLEG,
	ACT_FLINCH_RIGHTLEG,
	ACT_FLINCH,
	ACT_LARGE_FLINCH,
	ACT_HOLDBOMB,
	ACT_IDLE_FIDGET,
	ACT_IDLE_SCARED,
	ACT_IDLE_SCARED_FIDGET,
	ACT_FOLLOW_IDLE,
	ACT_FOLLOW_IDLE_FIDGET,
	ACT_FOLLOW_IDLE_SCARED,
	ACT_FOLLOW_IDLE_SCARED_FIDGET,
	ACT_CROUCH_IDLE,
	ACT_CROUCH_IDLE_FIDGET,
	ACT_CROUCH_IDLE_SCARED,
	ACT_CROUCH_IDLE_SCARED_FIDGET,
	ACT_CROUCH_WALK,
	ACT_CROUCH_WALK_SCARED,
	ACT_CROUCH_DIE,
	ACT_WALK_BACK,
	ACT_IDLE_SNEAKY,
	ACT_IDLE_SNEAKY_FIDGET,
	ACT_WALK_SNEAKY,
	ACT_WAVE,
	ACT_YES,
	ACT_NO
}
Activity;

typedef struct
{
	int type;
	char *name;
}
activity_map_t;

extern activity_map_t activity_map[];
#endif
```

`dlls/basemonster.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef BASEMONSTER_H
#define BASEMONSTER_H

class CBaseMonster : public CBaseToggle
{
public:
	virtual void KeyValue(KeyValueData *pkvd) { }
	virtual float ChangeYaw(int speed) { return 0; }
	virtual BOOL HasHumanGibs(void) { return FALSE; }
	virtual BOOL HasAlienGibs(void) { return FALSE; }
	virtual void FadeMonster(void) { }
	virtual void GibMonster(void) { }
	virtual Activity GetDeathActivity(void) { return ACT_DIE_HEADSHOT; }
	virtual void BecomeDead(void) { }
	virtual BOOL ShouldFadeOnDeath(void) { return FALSE; }
	virtual int IRelationship(CBaseEntity *pTarget) { return 0; }
	virtual int TakeHealth(float flHealth, int bitsDamageType) { return 0; }
	virtual int TakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType) { return 0; }
	virtual void Killed(entvars_t *pevAttacker, int iGib) { }
	virtual void PainSound(void) { return; }
	virtual void ResetMaxSpeed(void) {}
	virtual void ReportAIState(void) { }
	virtual void MonsterInitDead(void) { }
	virtual void Look(int iDistance) { }
	virtual CBaseEntity *BestVisibleEnemy(void) { return NULL; }
	virtual BOOL FInViewCone(CBaseEntity *pEntity) { return FALSE; }
	virtual BOOL FInViewCone(Vector *pOrigin) { return FALSE; }
	virtual int BloodColor(void) { return m_bloodColor; }
	virtual BOOL IsAlive(void) { return (pev->deadflag != DEAD_DEAD); }

public:
	void MakeIdealYaw(Vector vecTarget);
	Activity GetSmallFlinchActivity(void);
	BOOL ShouldGibMonster(int iGib);
	void CallGibMonster(void);
	BOOL FCheckAITrigger(void);
	int DeadTakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType);
	float DamageForce(float damage);
	void RadiusDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int iClassIgnore, int bitsDamageType);
	void RadiusDamage(Vector vecSrc, entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int iClassIgnore, int bitsDamageType);
	void EXPORT CorpseFallThink(void);
	CBaseEntity *CheckTraceHullAttack(float flDist, int iDamage, int iDmgType);
	void TraceAttack(entvars_t *pevAttacker, float flDamage, const Vector &vecDir, TraceResult *ptr, int bitsDamageType) {}
	void MakeDamageBloodDecal(int cCount, float flNoise, TraceResult *ptr, const Vector &vecDir);
	void BloodSplat(const Vector &vecPos, const Vector &vecDir, int hitgroup, int iDamage);

public:
	inline void SetConditions(int iConditions) { m_afConditions |= iConditions; }
	inline void ClearConditions(int iConditions) { m_afConditions &= ~iConditions; }
	inline BOOL HasConditions(int iConditions) { if (m_afConditions & iConditions) return TRUE; return FALSE; }
	inline BOOL HasAllConditions(int iConditions) { if ((m_afConditions & iConditions) == iConditions) return TRUE; return FALSE; }
	inline void Remember(int iMemory) { m_afMemory |= iMemory; }
	inline void Forget(int iMemory) { m_afMemory &= ~iMemory; }
	inline BOOL HasMemory(int iMemory) { if (m_afMemory & iMemory) return TRUE; return FALSE; }
	inline BOOL HasAllMemories(int iMemory) { if ((m_afMemory & iMemory) == iMemory) return TRUE; return FALSE; }
	inline void StopAnimation(void) { pev->framerate = 0; }

public:
	Activity m_Activity;
	Activity m_IdealActivity;
	int m_LastHitGroup;
	int m_bitsDamageType;
	BYTE m_rgbTimeBasedDamage[CDMG_TIMEBASED];
	MONSTERSTATE m_MonsterState;
	MONSTERSTATE m_IdealMonsterState;
	int m_afConditions;
	int m_afMemory;
	float m_flNextAttack;
	EHANDLE m_hEnemy;
	EHANDLE m_hTargetEnt;
	float m_flFieldOfView;
	int m_bloodColor;
	Vector m_HackedGunPos;
	Vector m_vecEnemyLKP;
};
#endif

```

`dlls/cbase.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#define FCAP_CUSTOMSAVE 0x00000001
#define FCAP_ACROSS_TRANSITION 0x00000002
#define FCAP_MUST_SPAWN 0x00000004
#define FCAP_DONT_SAVE 0x80000000
#define FCAP_IMPULSE_USE 0x00000008
#define FCAP_CONTINUOUS_USE 0x00000010
#define FCAP_ONOFF_USE 0x00000020
#define FCAP_DIRECTIONAL_USE 0x00000040
#define FCAP_MASTER 0x00000080
#define FCAP_FORCE_TRANSITION 0x00000080
#include "port.h"

#include "saverestore.h"
#include "schedule.h"

#ifndef MONSTEREVENT_H
#include "monsterevent.h"
#endif

#include <tier1/UtlVector.h>

#undef CREATE_NAMED_ENTITY
#undef REMOVE_ENTITY

edict_t *CREATE_NAMED_ENTITY(int iClass);
void REMOVE_ENTITY(edict_t *e);
void CONSOLE_ECHO(char *pszMsg, ...);
void CONSOLE_ECHO_LOGGED(char *pszMsg, ...);

#include "exportdef.h"

extern "C" EXPORT int GetEntityAPI(DLL_FUNCTIONS *pFunctionTable, int interfaceVersion);
extern "C" EXPORT int GetEntityAPI2(DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion);
extern "C" EXPORT int GetNewDLLFunctions(NEW_DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion);

typedef enum
{
	CLASSNAME
}
hash_types_e;

typedef struct hash_item_s
{
	entvars_t *pev;
	struct hash_item_s *next;
	struct hash_item_s *lastHash;
	int pevIndex;
}
hash_item_t;

extern CUtlVector<hash_item_t> stringsHashTable;

int CaseInsensitiveHash(const char *string, int iBounds);
void EmptyEntityHashTable(void);
void AddEntityHashValue(struct entvars_s *pev, const char *value, hash_types_e fieldType);
void RemoveEntityHashValue(struct entvars_s *pev, const char *value, hash_types_e fieldType);
void printEntities(void);
void loopPerformance(void);
#ifdef CLIENT_DLL
void Broadcast( const char*, int );
#endif


extern int DispatchSpawn(edict_t *pent);
extern void DispatchKeyValue(edict_t *pentKeyvalue, KeyValueData *pkvd);
extern void DispatchTouch(edict_t *pentTouched, edict_t *pentOther);
extern void DispatchUse(edict_t *pentUsed, edict_t *pentOther);
extern void DispatchThink(edict_t *pent);
extern void DispatchBlocked(edict_t *pentBlocked, edict_t *pentOther);
extern void DispatchSave(edict_t *pent, SAVERESTOREDATA *pSaveData);
extern int DispatchRestore(edict_t *pent, SAVERESTOREDATA *pSaveData, int globalEntity);
extern void DispatchObjectCollsionBox(edict_t *pent);
extern void SaveWriteFields(SAVERESTOREDATA *pSaveData, const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount);
extern void SaveReadFields(SAVERESTOREDATA *pSaveData, const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount);
extern void SaveGlobalState(SAVERESTOREDATA *pSaveData);
extern void RestoreGlobalState(SAVERESTOREDATA *pSaveData);
extern void ResetGlobalState(void);

typedef enum
{
	USE_OFF,
	USE_ON,
	USE_SET,
	USE_TOGGLE
}
USE_TYPE;

extern void FireTargets(const char *targetName, CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);

typedef void (CBaseEntity::*BASEPTR)(void);
typedef void (CBaseEntity::*ENTITYFUNCPTR)(CBaseEntity *pOther);
typedef void (CBaseEntity::*USEPTR)(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);

#define CLASS_NONE 0
#define CLASS_MACHINE 1
#define CLASS_PLAYER 2
#define CLASS_HUMAN_PASSIVE 3
#define CLASS_HUMAN_MILITARY 4
#define CLASS_ALIEN_MILITARY 5
#define CLASS_ALIEN_PASSIVE 6
#define CLASS_ALIEN_MONSTER 7
#define CLASS_ALIEN_PREY 8
#define CLASS_ALIEN_PREDATOR 9
#define CLASS_INSECT 10
#define CLASS_PLAYER_ALLY 11
#define CLASS_PLAYER_BIOWEAPON 12
#define CLASS_ALIEN_BIOWEAPON 13
#define CLASS_VEHICLE 14
#define CLASS_BARNACLE 99

class CBaseEntity;
class CBaseMonster;
class CBasePlayerItem;
class CSquadMonster;

#define SF_NORESPAWN (1<<30)

class EHANDLE
{
public:
	edict_t *Get(void);
	edict_t *Set(edict_t *pent);

	operator int ();
	operator CBaseEntity *();

	CBaseEntity *operator = (CBaseEntity *pEntity);
	CBaseEntity *operator ->();

private:
	edict_t *m_pent;
	int m_serialnumber;
};

class CBaseEntity
{
public:
	virtual void Spawn(void) {}
	virtual void Precache(void) {}
	virtual void Restart(void) {}
	virtual void KeyValue(KeyValueData *pkvd) { pkvd->fHandled = FALSE; }
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual int ObjectCaps(void) { return FCAP_ACROSS_TRANSITION; }
	virtual void Activate(void) {}
	virtual void SetObjectCollisionBox(void) {}
	virtual int Classify(void) { return CLASS_NONE; }
	virtual void DeathNotice(entvars_t *pevChild) {}
	virtual void TraceAttack(entvars_t *pevAttacker, float flDamage, const Vector &vecDir, TraceResult *ptr, int bitsDamageType) { }
	virtual int TakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType) { return 1; }
	virtual int TakeHealth(float flHealth, int bitsDamageType) { return 1; }
	virtual void Killed(entvars_t *pevAttacker, int iGib);
	virtual int BloodColor(void) { return DONT_BLEED; }
	virtual void TraceBleed(float flDamage, Vector vecDir, TraceResult *ptr, int bitsDamageType) { }
	virtual BOOL IsTriggered(CBaseEntity *pActivator) { return TRUE; }
	virtual CBaseMonster *MyMonsterPointer(void) { return NULL; }
	virtual CSquadMonster *MySquadMonsterPointer(void) { return NULL; }
	virtual int GetToggleState(void) { return TS_AT_TOP; }
	virtual void AddPoints(int score, BOOL bAllowNegativeScore) {}
	virtual void AddPointsToTeam(int score, BOOL bAllowNegativeScore) {}
	virtual BOOL AddPlayerItem(CBasePlayerItem *pItem) { return 0; }
	virtual BOOL RemovePlayerItem(CBasePlayerItem *pItem) { return 0; }
	virtual int GiveAmmo(int iAmount, char *szName, int iMax) { return -1; }
	virtual float GetDelay(void) { return 0; }
	virtual int IsMoving(void) { return pev->velocity != g_vecZero; }
	virtual void OverrideReset(void) {}
	virtual int DamageDecal(int bitsDamageType) { return -1; }
	virtual void SetToggleState(int state) {}
	virtual void StartSneaking(void) {}
	virtual void StopSneaking(void) {}
	virtual BOOL OnControls(entvars_t *onpev) { return FALSE; }
	virtual BOOL IsSneaking(void) { return FALSE; }
	virtual BOOL IsAlive(void) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }
	virtual BOOL IsBSPModel(void) { return pev->solid == SOLID_BSP || pev->movetype == MOVETYPE_PUSHSTEP; }
	virtual BOOL ReflectGauss(void) { return IsBSPModel() && !pev->takedamage; }
	virtual BOOL HasTarget(string_t targetname) { return FStrEq(STRING(targetname), STRING(pev->targetname)); }
	virtual BOOL IsInWorld(void) { return TRUE; }
	virtual BOOL IsPlayer(void) { return FALSE; }
	virtual BOOL IsNetClient(void) { return FALSE; }
	virtual const char *TeamID(void) { return ""; }
	virtual CBaseEntity *GetNextTarget(void) { return 0; }
	virtual void Think(void) { if (m_pfnThink) (this->*m_pfnThink)(); }
	virtual void Touch(CBaseEntity *pOther) { if (m_pfnTouch) (this->*m_pfnTouch)(pOther); }
	virtual void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value) { if (m_pfnUse) (this->*m_pfnUse)(pActivator, pCaller, useType, value); }
	virtual void Blocked(CBaseEntity *pOther) { if (m_pfnBlocked) (this->*m_pfnBlocked)(pOther); }
	virtual CBaseEntity *Respawn(void) { return NULL; }
	virtual void UpdateOwner(void) {}
	virtual BOOL FBecomeProne(void) { return FALSE; }
	virtual Vector Center(void) { return (pev->absmax + pev->absmin) * 0.5; }
	virtual Vector EyePosition(void) { return pev->origin + pev->view_ofs; }
	virtual Vector EarPosition(void) { return pev->origin + pev->view_ofs; }
	virtual Vector BodyTarget(const Vector &posSrc) { return Center(); }
	virtual int Illumination(void) { return GETENTITYILLUM(ENT(pev)); }
	virtual BOOL FVisible(CBaseEntity *pEntity) { return FALSE; }
	virtual BOOL FVisible(const Vector &vecOrigin) { return FALSE; }

public:
	void EXPORT SUB_Remove(void) { }
	void EXPORT SUB_DoNothing(void);
	void EXPORT SUB_StartFadeOut(void);
	void EXPORT SUB_FadeOut(void);
	void EXPORT SUB_CallUseToggle(void) { Use(this, this, USE_TOGGLE, 0); }
	void SUB_UseTargets(CBaseEntity *pActivator, USE_TYPE useType, float value);

public:
	void UpdateOnRemove(void);
	int ShouldToggle(USE_TYPE useType, BOOL currentState) { return 0; }
	void FireBullets(ULONG cShots, Vector vecSrc, Vector vecDirShooting, Vector vecSpread, float flDistance, int iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t *pevAttacker = NULL);
	Vector FireBullets3(Vector vecSrc, Vector vecDirShooting, float flSpread, float flDistance, int iPenetration, int iBulletType, int iDamage, float flRangeModifier, entvars_t *pevAttacker, bool bPistol, int shared_rand = 0);
	int Intersects(CBaseEntity *pOther) { return 0; }
	void MakeDormant(void) { }
	int IsDormant(void) { return 0; }
	BOOL IsLockedByMaster(void) { return FALSE; }

public:
	static CBaseEntity *Instance(edict_t *pent) { return (CBaseEntity *)GET_PRIVATE(pent ? pent : ENT(0)); }
	static CBaseEntity *Instance(entvars_t *instpev) { return Instance(ENT(instpev)); }
	static CBaseEntity *Instance(int inst_eoffset) { return Instance(ENT(inst_eoffset)); }

	CBaseMonster *GetMonsterPointer(entvars_t *pevMonster)
	{
		CBaseEntity *pEntity = Instance(pevMonster);

		if (pEntity)
			return pEntity->MyMonsterPointer();

		return NULL;
	}

	CBaseMonster *GetMonsterPointer(edict_t *pentMonster)
	{
		CBaseEntity *pEntity = Instance(pentMonster);

		if (pEntity)
			return pEntity->MyMonsterPointer();

		return NULL;
	}

#if defined(_DEBUG) && !defined(CLIENT_DLL)
	void FunctionCheck(void *pFunction, const char *name)
	{
		if (pFunction && !NAME_FOR_FUNCTION((unsigned long)(pFunction)))
		{ 
			ALERT(at_error, "No EXPORT: %s:%s (%08lx)\n", STRING(pev->classname), name, (unsigned long)pFunction);
			UTIL_LogPrintf("No EXPORT: %s:%s (%08lx)\n", STRING(pev->classname), name, (unsigned long)pFunction);
		}
		else
		{
			if (pFunction)
				UTIL_LogPrintf("Has EXPORT: %s:%s (%08lx)\n", STRING(pev->classname), name, (unsigned long)pFunction);
		}
	}

	BASEPTR ThinkSet(BASEPTR func, const char *name)
	{
		m_pfnThink = func;
		FunctionCheck((void *)*((int *)((char *)this + (offsetof(CBaseEntity, m_pfnThink)))), name);
		return func;
	}

	ENTITYFUNCPTR TouchSet(ENTITYFUNCPTR func, const char *name)
	{
		m_pfnTouch = func;
		FunctionCheck((void *)*((int *)((char *)this + (offsetof(CBaseEntity, m_pfnTouch)))), name);
		return func;
	}

	USEPTR UseSet(USEPTR func, const char *name)
	{
		m_pfnUse = func;
		FunctionCheck((void *)*((int *)((char *)this + (offsetof(CBaseEntity, m_pfnUse)))), name);
		return func;
	}

	ENTITYFUNCPTR BlockedSet(ENTITYFUNCPTR func, const char *name)
	{
		m_pfnBlocked = func;
		FunctionCheck((void *)*((int *)((char *)this + (offsetof(CBaseEntity, m_pfnBlocked)))), name);
		return func;
	}
#endif

	static CBaseEntity *Create(char *szName, const Vector &vecOrigin, const Vector &vecAngles, edict_t *pentOwner = NULL) { return NULL; }

	edict_t *edict(void) { return ENT(pev); }
	EOFFSET eoffset(void) { return OFFSET(pev); }
	int entindex(void) { return ENTINDEX(edict()); }

public:
	void *operator new(size_t stAllocateBlock, entvars_t *newpev) { return ALLOC_PRIVATE(ENT(newpev), stAllocateBlock); }

#if defined(_MSC_VER) && _MSC_VER >= 1200
	void operator delete(void *pMem, entvars_t *pev) { pev->flags |= FL_KILLME; }
#endif

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	entvars_t *pev;
	CBaseEntity *m_pGoalEnt;
	CBaseEntity *m_pLink;
	void (CBaseEntity::*m_pfnThink)(void);
	void (CBaseEntity::*m_pfnTouch)(CBaseEntity *pOther);
	void (CBaseEntity::*m_pfnUse)(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	void (CBaseEntity::*m_pfnBlocked)(CBaseEntity *pOther);
	int current_ammo;
	int currentammo;
	int maxammo_buckshot;
	int ammo_buckshot;
	int maxammo_9mm;
	int ammo_9mm;
	int maxammo_556nato;
	int ammo_556nato;
	int maxammo_556natobox;
	int ammo_556natobox;
	int maxammo_762nato;
	int ammo_762nato;
	int maxammo_45acp;
	int ammo_45acp;
	int maxammo_50ae;
	int ammo_50ae;
	int maxammo_338mag;
	int ammo_338mag;
	int maxammo_57mm;
	int ammo_57mm;
	int maxammo_357sig;
	int ammo_357sig;
	float m_flStartThrow;
	float m_flReleaseThrow;
	int m_iSwing;
	bool has_disconnected;
};

#if defined(_DEBUG) && !defined(CLIENT_DLL)
#define SetThink(a) ThinkSet(static_cast <void (CBaseEntity::*)(void)>(a), (char*)#a)
#define SetTouch(a) TouchSet(static_cast <void (CBaseEntity::*)(CBaseEntity *)>(a), #a)
#define SetUse(a) UseSet(static_cast <void (CBaseEntity::*)(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value)>(a), #a)
#define SetBlocked(a) BlockedSet(static_cast <void (CBaseEntity::*)(CBaseEntity *)>(a), #a)
#else
#define SetThink(a) m_pfnThink = static_cast<void (CBaseEntity::*)(void)>(a)
#define SetTouch(a) m_pfnTouch = static_cast<void (CBaseEntity::*)(CBaseEntity *)>(a)
#define SetUse(a) m_pfnUse = static_cast<void (CBaseEntity::*)(CBaseEntity *, CBaseEntity *, USE_TYPE, float)>(a)
#define SetBlocked(a) m_pfnBlocked = static_cast<void (CBaseEntity::*)(CBaseEntity *)>(a)
#endif

class CPointEntity : public CBaseEntity
{
public:
	void Spawn(void);
	int ObjectCaps(void) { return CBaseEntity::ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }
};

typedef struct locksounds
{
	string_t sLockedSound;
	string_t sLockedSentence;
	string_t sUnlockedSound;
	string_t sUnlockedSentence;
	int iLockedSentence;
	int iUnlockedSentence;
	float flwaitSound;
	float flwaitSentence;
	BYTE bEOFLocked;
	BYTE bEOFUnlocked;
}
locksound_t;

void PlayLockSounds(entvars_t *pev, locksound_t *pls, int flocked, int fbutton);

#define MAX_MULTI_TARGETS 16
#define MS_MAX_TARGETS 32

class CMultiSource : public CPointEntity
{
public:
	void Spawn(void);
	void KeyValue(KeyValueData *pkvd);
	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	int ObjectCaps(void) { return (CPointEntity::ObjectCaps() | FCAP_MASTER); }
	BOOL IsTriggered(CBaseEntity *pActivator);
	int Save(CSave &save);
	int Restore(CRestore &restore);

public:
	void EXPORT Register(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	EHANDLE m_rgEntities[MS_MAX_TARGETS];
	int m_rgTriggered[MS_MAX_TARGETS];
	int m_iTotal;
	string_t m_globalstate;
};

class CBaseDelay : public CBaseEntity
{
public:
	void KeyValue(KeyValueData *pkvd) { }
	int Save(CSave &save) { return 1; }
	int Restore(CRestore &restore) { return 1; }

public:
	void SUB_UseTargets(CBaseEntity *pActivator, USE_TYPE useType, float value);

public:
	void EXPORT DelayThink(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	float m_flDelay;
	int m_iszKillTarget;
};

class CBaseAnimating : public CBaseDelay
{
public:
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual void HandleAnimEvent(MonsterEvent_t *pEvent) {}

public:
	float StudioFrameAdvance(float flInterval = 0);
	int GetSequenceFlags(void);
	int LookupActivity(int activity) { return 0; }
	int LookupActivityHeaviest(int activity) { return 0; }
	int LookupSequence(const char *label) { return 0; }
	void ResetSequenceInfo(void) { }
	void DispatchAnimEvents(float flFutureInterval = 0.1) { }
	float SetBoneController(int iController, float flValue) { return 0; }
	void InitBoneControllers(void) { }
	float SetBlending(int iBlender, float flValue) { return 0; }
	void GetBonePosition(int iBone, Vector &origin, Vector &angles) { }
	void GetAutomovement(Vector &origin, Vector &angles, float flInterval = 0.1) { }
	int FindTransition(int iEndingSequence, int iGoalSequence, int *piDir) { return -1; }
	void GetAttachment(int iAttachment, Vector &origin, Vector &angles) { }
	void SetBodygroup(int iGroup, int iValue) {}
	int GetBodygroup(int iGroup) { return 0; }
	int ExtractBbox(int sequence, float *mins, float *maxs) { return 0; }
	void SetSequenceBox(void) { }

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	float m_flFrameRate;
	float m_flGroundSpeed;
	float m_flLastEventCheck;
	BOOL m_fSequenceFinished;
	BOOL m_fSequenceLoops;
};

#define SF_ITEM_USE_ONLY 256

class CBaseToggle : public CBaseAnimating
{
public:
	void KeyValue(KeyValueData *pkvd) { }
	int Save(CSave &save) { return 1; }
	int Restore(CRestore &restore) { return 1; }
	int GetToggleState(void) { return m_toggle_state; }
	float GetDelay(void) { return m_flWait; }

public:
	void LinearMove(Vector vecDest, float flSpeed);
	void EXPORT LinearMoveDone(void);
	void AngularMove(Vector vecDestAngle, float flSpeed);
	void EXPORT AngularMoveDone(void);
	BOOL IsLockedByMaster(void);

public:
	static float AxisValue(int flags, const Vector &angles);
	static void AxisDir(entvars_t *pev);
	static float AxisDelta(int flags, const Vector &angle1, const Vector &angle2);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	TOGGLE_STATE m_toggle_state;
	float m_flActivateFinished;
	float m_flMoveDistance;
	float m_flWait;
	float m_flLip;
	float m_flTWidth;
	float m_flTLength;
	Vector m_vecPosition1;
	Vector m_vecPosition2;
	Vector m_vecAngle1;
	Vector m_vecAngle2;
	int m_cTriggersLeft;
	float m_flHeight;
	EHANDLE m_hActivator;
	void (CBaseToggle::*m_pfnCallWhenMoveDone)(void);
	Vector m_vecFinalDest;
	Vector m_vecFinalAngle;
	int m_bitsDamageInflict;
	string_t m_sMaster;
};

#define SetMoveDone(a) m_pfnCallWhenMoveDone = static_cast<void (CBaseToggle::*)(void)>(a)

#define GIB_HEALTH_VALUE -30

#define ROUTE_SIZE 8
#define MAX_OLD_ENEMIES 4

#define bits_CAP_DUCK (1<<0)
#define bits_CAP_JUMP (1<<1)
#define bits_CAP_STRAFE (1<<2)
#define bits_CAP_SQUAD (1<<3)
#define bits_CAP_SWIM (1<<4)
#define bits_CAP_CLIMB (1<<5)
#define bits_CAP_USE (1<<6)
#define bits_CAP_HEAR (1<<7)
#define bits_CAP_AUTO_DOORS (1<<8)
#define bits_CAP_OPEN_DOORS (1<<9)
#define bits_CAP_TURN_HEAD (1<<10)
#define bits_CAP_RANGE_ATTACK1 (1<<11)
#define bits_CAP_RANGE_ATTACK2 (1<<12)
#define bits_CAP_MELEE_ATTACK1 (1<<13)
#define bits_CAP_MELEE_ATTACK2 (1<<14)
#define bits_CAP_FLY (1<<15)
#define bits_CAP_DOORS_GROUP (bits_CAP_USE | bits_CAP_AUTO_DOORS | bits_CAP_OPEN_DOORS)

#define DMG_GENERIC 0
#define DMG_CRUSH (1<<0)
#define DMG_BULLET (1<<1)
#define DMG_SLASH (1<<2)
#define DMG_BURN (1<<3)
#define DMG_FREEZE (1<<4)
#define DMG_FALL (1<<5)
#define DMG_BLAST (1<<6)
#define DMG_CLUB (1<<7)
#define DMG_SHOCK (1<<8)
#define DMG_SONIC (1<<9)
#define DMG_ENERGYBEAM (1<<10)
#define DMG_NEVERGIB (1<<12)
#define DMG_ALWAYSGIB (1<<13)
#define DMG_DROWN (1<<14)
#define DMG_TIMEBASED (~(0x3FFF))

#define DMG_PARALYZE (1<<15)
#define DMG_NERVEGAS (1<<16)
#define DMG_POISON (1<<17)
#define DMG_RADIATION (1<<18)
#define DMG_DROWNRECOVER (1<<19)
#define DMG_ACID (1<<20)
#define DMG_SLOWBURN (1<<21)
#define DMG_SLOWFREEZE (1<<22)
#define DMG_MORTAR (1<<23)
#define DMG_EXPLOSION (1<<24)
#define DMG_GIB_CORPSE (DMG_CRUSH | DMG_FALL | DMG_BLAST | DMG_SONIC | DMG_CLUB)
#define DMG_SHOWNHUD (DMG_POISON | DMG_ACID | DMG_FREEZE | DMG_SLOWFREEZE | DMG_DROWN | DMG_BURN | DMG_SLOWBURN | DMG_NERVEGAS | DMG_RADIATION | DMG_SHOCK)

#define PARALYZE_DURATION 2
#define PARALYZE_DAMAGE 1.0

#define NERVEGAS_DURATION 2
#define NERVEGAS_DAMAGE 5.0

#define POISON_DURATION 5
#define POISON_DAMAGE 2.0

#define RADIATION_DURATION 2
#define RADIATION_DAMAGE 1.0

#define ACID_DURATION 2
#define ACID_DAMAGE 5.0

#define SLOWBURN_DURATION 2
#define SLOWBURN_DAMAGE 1.0

#define SLOWFREEZE_DURATION 2
#define SLOWFREEZE_DAMAGE 1.0

#define itbd_Paralyze 0
#define itbd_NerveGas 1
#define itbd_Poison 2
#define itbd_Radiation 3
#define itbd_DrownRecover 4
#define itbd_Acid 5
#define itbd_SlowBurn 6
#define itbd_SlowFreeze 7
#define CDMG_TIMEBASED 8

#define GIB_NORMAL 0
#define GIB_NEVER 1
#define GIB_ALWAYS 2

class CBaseMonster;
class CCineMonster;
class CSound;

#include "basemonster.h"

char *ButtonSound(int sound);

class CBaseButton : public CBaseToggle
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData* pkvd);
	int ObjectCaps(void) { return (CBaseToggle:: ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | (pev->takedamage ? 0 : FCAP_IMPULSE_USE); }
	int TakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType);
	int Save(CSave &save);
	int Restore(CRestore &restore);

public:
	void RotSpawn(void);
	void ButtonActivate(void);
	void SparkSoundCache(void);

	void EXPORT ButtonShot(void);
	void EXPORT ButtonTouch(CBaseEntity *pOther);
	void EXPORT ButtonSpark(void);
	void EXPORT TriggerAndWait(void);
	void EXPORT ButtonReturn(void);
	void EXPORT ButtonBackHome(void);
	void EXPORT ButtonUse(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	enum BUTTON_CODE { BUTTON_NOTHING, BUTTON_ACTIVATE, BUTTON_RETURN };
	BUTTON_CODE ButtonResponseToTouch(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	BOOL m_fStayPushed;
	BOOL m_fRotating;
	string_t m_strChangeTarget;
	locksound_t m_ls;
	BYTE m_bLockedSound;
	BYTE m_bLockedSentence;
	BYTE m_bUnlockedSound;
	BYTE m_bUnlockedSentence;
	int m_sounds;
};

template <class T> T *GetClassPtr(T *a)
{
	entvars_t *pev = (entvars_t *)a;

	if (pev == NULL)
		pev = VARS(CREATE_ENTITY());

	a = (T *)GET_PRIVATE(ENT(pev));

	if (a == NULL)
	{
		a = new(pev) T;
		a->pev = pev;
	}

	return a;
}

class CWorld : public CBaseEntity
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData *pkvd);
};

class CClientFog : public CBaseEntity
{
public:
	void Spawn(void);
	void KeyValue(KeyValueData *pkvd);

public:
	int m_iStartDist, m_iEndDist;
	float m_fDensity;
};

```

`dlls/cdll_dll.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CDLL_DLL_H
#define CDLL_DLL_H

#define MAX_WEAPONS 32
#define MAX_WEAPON_SLOTS 5
#define MAX_ITEM_TYPES 6
#define MAX_ITEMS 4

#define HIDEHUD_WEAPONS (1<<0)
#define HIDEHUD_FLASHLIGHT (1<<1)
#define HIDEHUD_ALL (1<<2)
#define HIDEHUD_HEALTH (1<<3)
#define HIDEHUD_TIMER (1<<4)
#define HIDEHUD_MONEY (1<<5)
#define HIDEHUD_CROSSHAIR (1<<6)

#define MAX_AMMO_TYPES 32
#define MAX_AMMO_SLOTS 32

#define HUD_PRINTNOTIFY 1
#define HUD_PRINTCONSOLE 2
#define HUD_PRINTTALK 3
#define HUD_PRINTCENTER 4
#define HUD_PRINTRADIO 5


#define SCORE_STATUS_DEAD (1<<0)
#define SCORE_STATUS_BOMB (1<<1)
#define SCORE_STATUS_VIP (1<<2)

#define STATUSICON_HIDE 0
#define STATUSICON_SHOW 1
#define STATUSICON_FLASH 2

#define TEAM_UNASSIGNED 0
#define TEAM_TERRORIST 1
#define TEAM_CT 2
#define TEAM_SPECTATOR 3

#define CLASS_UNASSIGNED 0
#define CLASS_URBAN 1
#define CLASS_TERROR 2
#define CLASS_LEET 3
#define CLASS_ARCTIC 4
#define CLASS_GSG9 5
#define CLASS_GIGN 6
#define CLASS_SAS 7
#define CLASS_GUERILLA 8
#define CLASS_VIP 9
#define CLASS_MILITIA 10
#define CLASS_SPETSNAZ 11

#define MENU_KEY_1 (1<<0)
#define MENU_KEY_2 (1<<1)
#define MENU_KEY_3 (1<<2)
#define MENU_KEY_4 (1<<3)
#define MENU_KEY_5 (1<<4)
#define MENU_KEY_6 (1<<5)
#define MENU_KEY_7 (1<<6)
#define MENU_KEY_8 (1<<7)
#define MENU_KEY_9 (1<<8)
#define MENU_KEY_0 (1<<9)

#define MENU_TEAM 2
#define MENU_MAPBRIEFING 4
#define MENU_CLASS_T 26
#define MENU_CLASS_CT 27
#define MENU_BUY 28
#define MENU_BUY_PISTOL 29
#define MENU_BUY_SHOTGUN 30
#define MENU_BUY_RIFLE 31
#define MENU_BUY_SUBMACHINEGUN 32
#define MENU_BUY_MACHINEGUN 33
#define MENU_BUY_ITEM 34
// -- cs16client extension start -- //
#define MENU_RADIOA 35
#define MENU_RADIOB 36
#define MENU_RADIOC 37
#define MENU_RADIOSELECTOR 38
#define MENU_NUMERICAL_MENU -1
// -- cs16client extension end -- //


#define IUSER3_CANSHOOT (1<<0)
#define IUSER3_FREEZETIMEOVER (1<<1)
#define IUSER3_INBOMBZONE (1<<2)
#define IUSER3_HOLDINGSHIELD (1<<3)

#define ITEMSTATE_HASNIGHTVISION (1<<0)
#define ITEMSTATE_HASDEFUSER (1<<1)

#define PLAYER_DEAD (1<<0)
#define PLAYER_HAS_C4 (1<<1)
#define PLAYER_VIP (1<<2)

#define WEAPON_SUIT 31
#endif

```

`dlls/effects.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef EFFECTS_H
#define EFFECTS_H

#define SF_BEAM_STARTON 0x0001
#define SF_BEAM_TOGGLE 0x0002
#define SF_BEAM_RANDOM 0x0004
#define SF_BEAM_RING 0x0008
#define SF_BEAM_SPARKSTART 0x0010
#define SF_BEAM_SPARKEND 0x0020
#define SF_BEAM_DECALS 0x0040
#define SF_BEAM_SHADEIN 0x0080
#define SF_BEAM_SHADEOUT 0x0100
#define SF_BEAM_TEMPORARY 0x8000

#define SF_SPRITE_STARTON 0x0001
#define SF_SPRITE_ONCE 0x0002
#define SF_SPRITE_TEMPORARY 0x8000

class CSprite : public CPointEntity
{
public:
	void Spawn(void);
	void Restart(void);
	void Precache(void);

	int ObjectCaps(void)
	{
		int flags = 0;

		if (pev->spawnflags & SF_SPRITE_TEMPORARY)
			flags = FCAP_DONT_SAVE;

		return (CBaseEntity::ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | flags;
	}

	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	void Animate(float frames);
	void Expand(float scaleSpeed, float fadeSpeed);
	void SpriteInit(const char *pSpriteName, const Vector &origin);

	inline void SetAttachment(edict_t *pEntity, int attachment)
	{
		if (pEntity)
		{
			pev->skin = ENTINDEX(pEntity);
			pev->body = attachment;
			pev->aiment = pEntity;
			pev->movetype = MOVETYPE_FOLLOW;
		}
	}
	void TurnOff(void);
	void TurnOn(void);

public:
	inline float Frames(void){ return m_maxFrame; }

	inline void SetTransparency(int rendermode, int r, int g, int b, int a, int fx)
	{
		pev->rendermode = rendermode;
		pev->rendercolor.x = r;
		pev->rendercolor.y = g;
		pev->rendercolor.z = b;
		pev->renderamt = a;
		pev->renderfx = fx;
	}
	inline void SetTexture(int spriteIndex) { pev->modelindex = spriteIndex; }
	inline void SetScale(float scale) { pev->scale = scale; }
	inline void SetColor(int r, int g, int b) { pev->rendercolor.x = r; pev->rendercolor.y = g; pev->rendercolor.z = b; }
	inline void SetBrightness(int brightness){ pev->renderamt = brightness; }

	inline void AnimateAndDie(float framerate)
	{
		SetThink(&CSprite::AnimateUntilDead);
		pev->framerate = framerate;
		pev->dmgtime = gpGlobals->time + (m_maxFrame / framerate);
		pev->nextthink = gpGlobals->time;
	}

public:
	void EXPORT AnimateThink(void);
	void EXPORT ExpandThink(void);
	void EXPORT AnimateUntilDead(void);

	virtual int Save(CSave &save);
	virtual int Restore(CRestore &restore);
	static TYPEDESCRIPTION m_SaveData[];
	static CSprite *SpriteCreate(const char *pSpriteName, const Vector &origin, BOOL animate);

private:
	float m_lastTime;
	float m_maxFrame;
};

class CBeam : public CBaseEntity
{
public:
	void Spawn(void);
	void Precache(void);

	int ObjectCaps(void)
	{
		int flags = 0;

		if (pev->spawnflags & SF_BEAM_TEMPORARY)
			flags = FCAP_DONT_SAVE;

		return (CBaseEntity::ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | flags;
	}

public:
	inline void SetType(int type) { pev->rendermode = (pev->rendermode & 0xF0) | (type & 0x0F); }
	inline void SetFlags(int flags) { pev->rendermode = (pev->rendermode & 0x0F) | (flags & 0xF0); }
	inline void SetStartPos(const Vector &pos) { pev->origin = pos; }
	inline void SetEndPos(const Vector &pos){ pev->angles = pos; }

	void SetStartEntity(int entityIndex);
	void SetEndEntity(int entityIndex);

	inline void SetStartAttachment(int attachment) { pev->sequence = (pev->sequence & 0x0FFF) | ((attachment & 0xF) << 12); }
	inline void SetEndAttachment(int attachment) { pev->skin = (pev->skin & 0x0FFF) | ((attachment & 0xF) << 12); }
	inline void SetTexture(int spriteIndex) { pev->modelindex = spriteIndex; }
	inline void SetWidth(int width) { pev->scale = width; }
	inline void SetNoise(int amplitude) { pev->body = amplitude; }
	inline void SetColor(int r, int g, int b) { pev->rendercolor.x = r; pev->rendercolor.y = g; pev->rendercolor.z = b; }
	inline void SetBrightness(int brightness) { pev->renderamt = brightness; }
	inline void SetFrame(float frame) { pev->frame = frame; }
	inline void SetScrollRate(int speed){ pev->animtime = speed; }

public:
	inline int GetType(void) { return pev->rendermode & 0x0F; }
	inline int GetFlags(void) { return pev->rendermode & 0xF0; }
	inline int GetStartEntity(void) { return pev->sequence & 0xFFF; }
	inline int GetEndEntity(void) { return pev->skin & 0xFFF; }
	const Vector &GetStartPos(void);
	const Vector &GetEndPos(void);

public:
	Vector Center(void){ return (GetStartPos() + GetEndPos()) * 0.5; }

public:
	inline int GetTexture(void) { return pev->modelindex; }
	inline int GetWidth(void) { return (int)(pev->scale); }
	inline int GetNoise(void) { return pev->body; }
	inline int GetBrightness(void) { return (int)(pev->renderamt); }
	inline int GetFrame(void) { return (int)(pev->frame); }
	inline int GetScrollRate(void){ return (int)(pev->animtime); }

public:
	void EXPORT TriggerTouch(CBaseEntity *pOther);
	void RelinkBeam(void);
	void DoSparks(const Vector &start, const Vector &end);
	CBaseEntity *RandomTargetname(const char *szName);
	void BeamDamage(TraceResult *ptr);
	void BeamInit(const char *pSpriteName, int width);
	void PointsInit(const Vector &start, const Vector &end);
	void PointEntInit(const Vector &start, int endIndex);
	void EntsInit(int startIndex, int endIndex);
	void HoseInit(const Vector &start, const Vector &direction);

public:
	static CBeam *BeamCreate(const char *pSpriteName, int width);

public:
	inline void LiveForTime(float time){ SetThink(&CBaseEntity::SUB_Remove); pev->nextthink = gpGlobals->time + time; }

	inline void BeamDamageInstant(TraceResult *ptr, float damage)
	{
		pev->dmg = damage;
		pev->dmgtime = gpGlobals->time - 1;
		BeamDamage(ptr);
	}
};

#define SF_MESSAGE_ONCE 0x0001
#define SF_MESSAGE_ALL 0x0002

class CLaser : public CBeam
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData *pkvd);
	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	int Save(CSave &save);
	int Restore(CRestore &restore);

public:
	void TurnOn(void);
	void TurnOff(void);
	int IsOn(void);

public:
	void FireAtPoint(TraceResult &point);
	void EXPORT StrikeThink(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	CSprite *m_pSprite;
	int m_iszSpriteName;
	Vector m_firePosition;
};

#endif
```

`dlls/enginecallback.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef ENGINECALLBACK_H
#define ENGINECALLBACK_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#include "event_flags.h"

// Must be provided by user of this code
extern enginefuncs_t g_engfuncs;

// The actual engine callbacks
#define GETPLAYERUSERID (*g_engfuncs.pfnGetPlayerUserId)
#define PRECACHE_GENERIC	(*g_engfuncs.pfnPrecacheGeneric)
#ifdef CLIENT_DLL
inline int PRECACHE_MODEL( const char *s ) { return 0; }
inline int PRECACHE_SOUND( const char *s ) { return 0; }
#define SET_MODEL(x, y)
#else
#define PRECACHE_MODEL	(*g_engfuncs.pfnPrecacheModel)
#define PRECACHE_SOUND	(*g_engfuncs.pfnPrecacheSound)
#define SET_MODEL		(*g_engfuncs.pfnSetModel)
#endif
#define MODEL_INDEX		(*g_engfuncs.pfnModelIndex)
#define MODEL_FRAMES	(*g_engfuncs.pfnModelFrames)
#define SET_SIZE		(*g_engfuncs.pfnSetSize)
#define CHANGE_LEVEL	(*g_engfuncs.pfnChangeLevel)
#define GET_SPAWN_PARMS	(*g_engfuncs.pfnGetSpawnParms)
#define SAVE_SPAWN_PARMS (*g_engfuncs.pfnSaveSpawnParms)
#define VEC_TO_YAW		(*g_engfuncs.pfnVecToYaw)
#define VEC_TO_ANGLES	(*g_engfuncs.pfnVecToAngles)
#define MOVE_TO_ORIGIN  (*g_engfuncs.pfnMoveToOrigin)
#define oldCHANGE_YAW		(*g_engfuncs.pfnChangeYaw)
#define CHANGE_PITCH	(*g_engfuncs.pfnChangePitch)
#define MAKE_VECTORS	(*g_engfuncs.pfnMakeVectors)
#define CREATE_ENTITY	(*g_engfuncs.pfnCreateEntity)
#define REMOVE_ENTITY	(*g_engfuncs.pfnRemoveEntity)
#define CREATE_NAMED_ENTITY		(*g_engfuncs.pfnCreateNamedEntity)
#define MAKE_STATIC		(*g_engfuncs.pfnMakeStatic)
#define ENT_IS_ON_FLOOR	(*g_engfuncs.pfnEntIsOnFloor)
#define DROP_TO_FLOOR	(*g_engfuncs.pfnDropToFloor)
#define WALK_MOVE		(*g_engfuncs.pfnWalkMove)
#define SET_ORIGIN		(*g_engfuncs.pfnSetOrigin)
#define EMIT_SOUND_DYN2 (*g_engfuncs.pfnEmitSound)
#define BUILD_SOUND_MSG (*g_engfuncs.pfnBuildSoundMsg)
#define TRACE_LINE		(*g_engfuncs.pfnTraceLine)
#define TRACE_TOSS		(*g_engfuncs.pfnTraceToss)
#define TRACE_MONSTER_HULL		(*g_engfuncs.pfnTraceMonsterHull)
#define TRACE_HULL		(*g_engfuncs.pfnTraceHull)
#define GET_AIM_VECTOR	(*g_engfuncs.pfnGetAimVector)
#define SERVER_COMMAND	(*g_engfuncs.pfnServerCommand)
#define SERVER_EXECUTE2	(*g_engfuncs.pfnServerExecute)//SERVER_EXECUTE already present in windows winspool.h
#define CLIENT_COMMAND	(*g_engfuncs.pfnClientCommand)
#define PARTICLE_EFFECT	(*g_engfuncs.pfnParticleEffect)
#define LIGHT_STYLE		(*g_engfuncs.pfnLightStyle)
#define DECAL_INDEX		(*g_engfuncs.pfnDecalIndex)
#define POINT_CONTENTS	(*g_engfuncs.pfnPointContents)
#define CRC32_INIT           (*g_engfuncs.pfnCRC32_Init)
#define CRC32_PROCESS_BUFFER (*g_engfuncs.pfnCRC32_ProcessBuffer)
#define CRC32_PROCESS_BYTE   (*g_engfuncs.pfnCRC32_ProcessByte)
#define CRC32_FINAL          (*g_engfuncs.pfnCRC32_Final)
#define RANDOM_LONG		(*g_engfuncs.pfnRandomLong)
#define RANDOM_FLOAT	(*g_engfuncs.pfnRandomFloat)
#define GETPLAYERAUTHID	(*g_engfuncs.pfnGetPlayerAuthId)
#define GAME_TIME		(*g_engfuncs.pfnTime)

inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {
	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);
}
#define MESSAGE_END		(*g_engfuncs.pfnMessageEnd)
#define WRITE_BYTE		(*g_engfuncs.pfnWriteByte)
#define WRITE_CHAR		(*g_engfuncs.pfnWriteChar)
#define WRITE_SHORT		(*g_engfuncs.pfnWriteShort)
#define WRITE_LONG		(*g_engfuncs.pfnWriteLong)
#define WRITE_ANGLE		(*g_engfuncs.pfnWriteAngle)
#define WRITE_COORD		(*g_engfuncs.pfnWriteCoord)
#define WRITE_STRING	(*g_engfuncs.pfnWriteString)
#define WRITE_ENTITY	(*g_engfuncs.pfnWriteEntity)
#define CVAR_REGISTER	(*g_engfuncs.pfnCVarRegister)
#define CVAR_GET_FLOAT	(*g_engfuncs.pfnCVarGetFloat)
#define CVAR_GET_STRING	(*g_engfuncs.pfnCVarGetString)
#define CVAR_SET_FLOAT	(*g_engfuncs.pfnCVarSetFloat)
#define CVAR_SET_STRING	(*g_engfuncs.pfnCVarSetString)
#define CVAR_GET_POINTER (*g_engfuncs.pfnCVarGetPointer)
#define ALERT			(*g_engfuncs.pfnAlertMessage)
#define ENGINE_FPRINTF	(*g_engfuncs.pfnEngineFprintf)
#define ALLOC_PRIVATE	(*g_engfuncs.pfnPvAllocEntPrivateData)
inline void *GET_PRIVATE( edict_t *pent )
{
	if ( pent )
		return pent->pvPrivateData;
	return NULL;
}

#define FREE_PRIVATE	(*g_engfuncs.pfnFreeEntPrivateData)
//#define STRING			(*g_engfuncs.pfnSzFromIndex)
#define ALLOC_STRING	(*g_engfuncs.pfnAllocString)
#define FIND_ENTITY_BY_STRING	(*g_engfuncs.pfnFindEntityByString)
#define GETENTITYILLUM	(*g_engfuncs.pfnGetEntityIllum)
#define FIND_ENTITY_IN_SPHERE		(*g_engfuncs.pfnFindEntityInSphere)
#define FIND_CLIENT_IN_PVS			(*g_engfuncs.pfnFindClientInPVS)
#define EMIT_AMBIENT_SOUND			(*g_engfuncs.pfnEmitAmbientSound)
#define GET_MODEL_PTR				(*g_engfuncs.pfnGetModelPtr)
#define REG_USER_MSG				(*g_engfuncs.pfnRegUserMsg)
#define GET_BONE_POSITION			(*g_engfuncs.pfnGetBonePosition)
#define FUNCTION_FROM_NAME			(*g_engfuncs.pfnFunctionFromName)
#define NAME_FOR_FUNCTION			(*g_engfuncs.pfnNameForFunction)
#define TRACE_TEXTURE				(*g_engfuncs.pfnTraceTexture)
#define CLIENT_PRINTF				(*g_engfuncs.pfnClientPrintf)
#define CMD_ARGS					(*g_engfuncs.pfnCmd_Args)
#define CMD_ARGC					(*g_engfuncs.pfnCmd_Argc)
#define CMD_ARGV					(*g_engfuncs.pfnCmd_Argv)
#define GET_ATTACHMENT			(*g_engfuncs.pfnGetAttachment)
#define SET_VIEW				(*g_engfuncs.pfnSetView)
#define SET_CROSSHAIRANGLE		(*g_engfuncs.pfnCrosshairAngle)
#define LOAD_FILE_FOR_ME		(*g_engfuncs.pfnLoadFileForMe)
#define FREE_FILE				(*g_engfuncs.pfnFreeFile)
#define COMPARE_FILE_TIME		(*g_engfuncs.pfnCompareFileTime)
#define GET_GAME_DIR			(*g_engfuncs.pfnGetGameDir)
#define IS_MAP_VALID			(*g_engfuncs.pfnIsMapValid)
#define NUMBER_OF_ENTITIES		(*g_engfuncs.pfnNumberOfEntities)
#define IS_DEDICATED_SERVER		(*g_engfuncs.pfnIsDedicatedServer)

#define PRECACHE_EVENT			(*g_engfuncs.pfnPrecacheEvent)
#define PLAYBACK_EVENT_FULL		(*g_engfuncs.pfnPlaybackEvent)

#define ENGINE_SET_PVS			(*g_engfuncs.pfnSetFatPVS)
#define ENGINE_SET_PAS			(*g_engfuncs.pfnSetFatPAS)

#define ENGINE_CHECK_VISIBILITY (*g_engfuncs.pfnCheckVisibility)

#define DELTA_SET				( *g_engfuncs.pfnDeltaSetField )
#define DELTA_UNSET				( *g_engfuncs.pfnDeltaUnsetField )
#define DELTA_ADDENCODER		( *g_engfuncs.pfnDeltaAddEncoder )
#define ENGINE_CURRENT_PLAYER   ( *g_engfuncs.pfnGetCurrentPlayer )

#define	ENGINE_CANSKIP			( *g_engfuncs.pfnCanSkipPlayer )

#define DELTA_FINDFIELD			( *g_engfuncs.pfnDeltaFindField )
#define DELTA_SETBYINDEX		( *g_engfuncs.pfnDeltaSetFieldByIndex )
#define DELTA_UNSETBYINDEX		( *g_engfuncs.pfnDeltaUnsetFieldByIndex )

#define ENGINE_GETPHYSINFO		( *g_engfuncs.pfnGetPhysicsInfoString )

#define ENGINE_SETGROUPMASK		( *g_engfuncs.pfnSetGroupMask )

#define ENGINE_INSTANCE_BASELINE ( *g_engfuncs.pfnCreateInstancedBaseline )

#define ENGINE_FORCE_UNMODIFIED	( *g_engfuncs.pfnForceUnmodified )

#define PLAYER_CNX_STATS		( *g_engfuncs.pfnGetPlayerStats )
#define CREATE_FAKE_CLIENT  ( *g_engfuncs.pfnCreateFakeClient )
#define GET_USERINFO   ( *g_engfuncs.pfnGetInfoKeyBuffer )
#define SET_KEY_VALUE   ( *g_engfuncs.pfnSetKeyValue )
#define SET_CLIENT_KEY_VALUE ( *g_engfuncs.pfnSetClientKeyValue )
#define GET_INFO_BUFFER   (*g_engfuncs.pfnGetInfoKeyBuffer)
#define GET_KEY_VALUE   (*g_engfuncs.pfnInfoKeyValue)
#endif		//ENGINECALLBACK_H

```

`dlls/exportdef.h`:

```h
#ifndef EXPORTDEF_H
#define EXPORTDEF_H
#if defined _WIN32 || defined __CYGWIN__
	#ifdef __GNUC__
		#define EXPORT __attribute__ ((dllexport))
	#else
		#define EXPORT __declspec(dllexport) // Note: actually gcc seems to also supports this syntax.
	#endif
#else
  #if __GNUC__ >= 4
	#define EXPORT __attribute__ ((visibility ("default")))
   #else
	#define EXPORT
  #endif
#endif
#define DLLEXPORT EXPORT
#define _DLLEXPORT EXPORT
#endif // EXPORTDEF_H

```

`dlls/extdll.h`:

```h
/***
*
*	Copyright (c) 1996-2001, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef EXTDLL_H
#define EXTDLL_H

//
// Global header file for extension DLLs
//

// Allow "DEBUG" in addition to default "_DEBUG"
#ifdef _DEBUG
#define DEBUG 1
#endif

#ifdef MSC_VER
// Silence certain warnings
#pragma warning(disable : 4244)		// int or float down-conversion
#pragma warning(disable : 4305)		// int or float data truncation
#pragma warning(disable : 4201)		// nameless struct/union
#pragma warning(disable : 4514)		// unreferenced inline function removed
#pragma warning(disable : 4100)		// unreferenced formal parameter
#endif

#include "archtypes.h"     // DAL

// Prevent tons of unused windows definitions
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOWINRES
#define NOSERVICE
#define NOMCX
#define NOIME
#include "windows.h"
#else // _WIN32
typedef unsigned char BYTE;
typedef int BOOL;
#define MAX_PATH PATH_MAX
#include <limits.h>
#include <stdarg.h>
#include <string.h> // memset 

#define _vsnprintf(a,b,c,d) vsnprintf(a,b,c,d)
#endif //_WIN32

// Misc C-runtime library headers
#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#ifndef min
#define min(a,b)  (((a) < (b)) ? (a) : (b))
#endif
#ifndef max
#define max(a,b)  (((a) > (b)) ? (a) : (b))
#endif

// Header file containing definition of globalvars_t and entvars_t
//typedef unsigned int func_t;					//
//typedef unsigned int string_t;				// from engine's pr_comp.h;
typedef float vec_t;				// needed before including progdefs.h

// Vector class
#include "vector.h"

// Defining it as a (bogus) struct helps enforce type-checking
#define vec3_t Vector

// Shared engine/DLL constants
#include "const.h"
#include "progdefs.h"
#include "edict.h"

// Shared header describing protocol between engine and DLLs
#include "eiface.h"

// Shared header between the client DLL and the game DLLs
#include "cdll_dll.h"
#endif //EXTDLL_H

```

`dlls/gamerules.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

class CBasePlayerItem;
class CBasePlayer;
class CItem;
class CBasePlayerAmmo;

#define MAX_MOTD_CHUNK 60
#define MAX_MOTD_LENGTH 1536

#define STARTMONEY_MAX 32000
#define STARTMONEY_MIN 800
enum
{
	GR_NONE = 0,
	GR_WEAPON_RESPAWN_YES,
	GR_WEAPON_RESPAWN_NO,
	GR_AMMO_RESPAWN_YES,
	GR_AMMO_RESPAWN_NO,
	GR_ITEM_RESPAWN_YES,
	GR_ITEM_RESPAWN_NO,
	GR_PLR_DROP_GUN_ALL,
	GR_PLR_DROP_GUN_ACTIVE,
	GR_PLR_DROP_GUN_NO,
	GR_PLR_DROP_AMMO_ALL,
	GR_PLR_DROP_AMMO_ACTIVE,
	GR_PLR_DROP_AMMO_NO
};

enum
{
	GR_NOTTEAMMATE = 0,
	GR_TEAMMATE,
	GR_ENEMY,
	GR_ALLY,
	GR_NEUTRAL
};

class CGameRules
{
public:
	virtual void RefreshSkillData(void);
	virtual void Think(void) = 0;
	virtual BOOL IsAllowedToSpawn(CBaseEntity *pEntity) = 0;
	virtual BOOL FAllowFlashlight(void) = 0;
	virtual BOOL FShouldSwitchWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon) = 0;
	virtual BOOL GetNextBestWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon) = 0;
	virtual BOOL IsMultiplayer(void) = 0;
	virtual BOOL IsDeathmatch(void) = 0;
	virtual BOOL IsTeamplay(void) { return FALSE; }
	virtual BOOL IsCoOp(void) = 0;
	virtual const char *GetGameDescription(void) { return "Counter-Strike"; }
	virtual BOOL ClientConnected(edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[128]) = 0;
	virtual void InitHUD(CBasePlayer *pl) = 0;
	virtual void ClientDisconnected(edict_t *pClient) = 0;
	virtual void UpdateGameMode(CBasePlayer *pPlayer) {}
	virtual float FlPlayerFallDamage(CBasePlayer *pPlayer) = 0;
	virtual BOOL FPlayerCanTakeDamage(CBasePlayer *pPlayer, CBaseEntity *pAttacker) { return TRUE; }
	virtual BOOL ShouldAutoAim(CBasePlayer *pPlayer, edict_t *target) { return TRUE; }
	virtual void PlayerSpawn(CBasePlayer *pPlayer) = 0;
	virtual void PlayerThink(CBasePlayer *pPlayer) = 0;
	virtual BOOL FPlayerCanRespawn(CBasePlayer *pPlayer) = 0;
	virtual float FlPlayerSpawnTime(CBasePlayer *pPlayer) = 0;
	virtual edict_t *GetPlayerSpawnSpot(CBasePlayer *pPlayer);
	virtual BOOL AllowAutoTargetCrosshair(void) { return TRUE; }
	virtual BOOL ClientCommand_DeadOrAlive(CBasePlayer *pPlayer, const char *pcmd) { return FALSE; }
	virtual BOOL ClientCommand(CBasePlayer *pPlayer, const char *pcmd) { return FALSE; }
	virtual void ClientUserInfoChanged(CBasePlayer *pPlayer, char *infobuffer) {}
	virtual int IPointsForKill(CBasePlayer *pAttacker, CBasePlayer *pKilled) = 0;
	virtual void PlayerKilled(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor) = 0;
	virtual void DeathNotice(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor) = 0;
	virtual BOOL CanHavePlayerItem(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual void PlayerGotWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon) = 0;
	virtual int WeaponShouldRespawn(CBasePlayerItem *pWeapon) = 0;
	virtual float FlWeaponRespawnTime(CBasePlayerItem *pWeapon) = 0;
	virtual float FlWeaponTryRespawn(CBasePlayerItem *pWeapon) = 0;
	virtual Vector VecWeaponRespawnSpot(CBasePlayerItem *pWeapon) = 0;
	virtual BOOL CanHaveItem(CBasePlayer *pPlayer, CItem *pItem) = 0;
	virtual void PlayerGotItem(CBasePlayer *pPlayer, CItem *pItem) = 0;
	virtual int ItemShouldRespawn(CItem *pItem) = 0;
	virtual float FlItemRespawnTime(CItem *pItem) = 0;
	virtual Vector VecItemRespawnSpot(CItem *pItem) = 0;
	virtual BOOL CanHaveAmmo(CBasePlayer *pPlayer, const char *pszAmmoName, int iMaxCarry);
	virtual void PlayerGotAmmo(CBasePlayer *pPlayer, char *szName, int iCount) = 0;
	virtual int AmmoShouldRespawn(CBasePlayerAmmo *pAmmo) = 0;
	virtual float FlAmmoRespawnTime(CBasePlayerAmmo *pAmmo) = 0;
	virtual Vector VecAmmoRespawnSpot(CBasePlayerAmmo *pAmmo) = 0;
	virtual float FlHealthChargerRechargeTime(void) = 0;
	virtual float FlHEVChargerRechargeTime(void) { return 0; }
	virtual int DeadPlayerWeapons(CBasePlayer *pPlayer) = 0;
	virtual int DeadPlayerAmmo(CBasePlayer *pPlayer) = 0;
	virtual const char *GetTeamID(CBaseEntity *pEntity) = 0;
	virtual int PlayerRelationship(CBaseEntity *pPlayer, CBaseEntity *pTarget) = 0;
	virtual int GetTeamIndex(const char *pTeamName) { return -1; }
	virtual const char *GetIndexedTeamName(int teamIndex) { return ""; }
	virtual BOOL IsValidTeam(const char *pTeamName) { return TRUE; }
	virtual void ChangePlayerTeam(CBasePlayer *pPlayer, const char *pTeamName, BOOL bKill, BOOL bGib) {}
	virtual const char *SetDefaultPlayerTeam(CBasePlayer *pPlayer) { return ""; }
	virtual BOOL PlayTextureSounds(void) { return TRUE; }
	virtual BOOL FAllowMonsters(void) = 0;
	virtual void EndMultiplayerGame(void) {}
	virtual BOOL IsFreezePeriod(void) { return m_bFreezePeriod; }
	virtual void ServerDeactivate(void) {}
	virtual void CheckMapConditions(void) {}

public:
	BOOL m_bFreezePeriod;
	BOOL m_bBombDropped;
};

extern char *GetTeam(int teamNo);
extern void Broadcast(const char *sentence, int pitch = 100 );
extern CGameRules *InstallGameRules(void);

class CHalfLifeRules : public CGameRules
{
public:
	CHalfLifeRules(void);

public:
	virtual void Think(void);
	virtual BOOL IsAllowedToSpawn(CBaseEntity *pEntity);
	virtual BOOL FAllowFlashlight(void) { return TRUE; }
	virtual BOOL FShouldSwitchWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual BOOL GetNextBestWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon);
	virtual BOOL IsMultiplayer(void);
	virtual BOOL IsDeathmatch(void);
	virtual BOOL IsCoOp(void);
	virtual BOOL ClientConnected(edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[128]);
	virtual void InitHUD(CBasePlayer *pl);
	virtual void ClientDisconnected(edict_t *pClient);
	virtual float FlPlayerFallDamage(CBasePlayer *pPlayer);
	virtual void PlayerSpawn(CBasePlayer *pPlayer);
	virtual void PlayerThink(CBasePlayer *pPlayer);
	virtual BOOL FPlayerCanRespawn(CBasePlayer *pPlayer);
	virtual float FlPlayerSpawnTime(CBasePlayer *pPlayer);
	virtual edict_t *GetPlayerSpawnSpot(CBasePlayer *pPlayer);
	virtual BOOL AllowAutoTargetCrosshair(void);
	virtual int IPointsForKill(CBasePlayer *pAttacker, CBasePlayer *pKilled);
	virtual void PlayerKilled(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor);
	virtual void DeathNotice(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor);
	virtual void PlayerGotWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual int WeaponShouldRespawn(CBasePlayerItem *pWeapon);
	virtual float FlWeaponRespawnTime(CBasePlayerItem *pWeapon);
	virtual float FlWeaponTryRespawn(CBasePlayerItem *pWeapon);
	virtual Vector VecWeaponRespawnSpot(CBasePlayerItem *pWeapon);
	virtual BOOL CanHaveItem(CBasePlayer *pPlayer, CItem *pItem);
	virtual void PlayerGotItem(CBasePlayer *pPlayer, CItem *pItem);
	virtual int ItemShouldRespawn(CItem *pItem);
	virtual float FlItemRespawnTime(CItem *pItem);
	virtual Vector VecItemRespawnSpot(CItem *pItem);
	virtual void PlayerGotAmmo(CBasePlayer *pPlayer, char *szName, int iCount);
	virtual int AmmoShouldRespawn(CBasePlayerAmmo *pAmmo);
	virtual float FlAmmoRespawnTime(CBasePlayerAmmo *pAmmo);
	virtual Vector VecAmmoRespawnSpot(CBasePlayerAmmo *pAmmo);
	virtual float FlHealthChargerRechargeTime(void);
	virtual int DeadPlayerWeapons(CBasePlayer *pPlayer);
	virtual int DeadPlayerAmmo(CBasePlayer *pPlayer);
	virtual BOOL FAllowMonsters(void);
	virtual const char *GetTeamID(CBaseEntity *pEntity) { return ""; }
	virtual int PlayerRelationship(CBaseEntity *pPlayer, CBaseEntity *pTarget);
};

#define MAX_MAPS 100
#define MAX_VIPQUEUES 5

enum
{
	WINSTATUS_CT = 1,
	WINSTATUS_TERRORIST,
	WINSTATUS_DRAW
};

#define Target_Bombed 1
#define VIP_Escaped 2
#define VIP_Assassinated 3
#define Terrorists_Escaped 4
#define CTs_PreventEscape 5
#define Escaping_Terrorists_Neutralized 6
#define Bomb_Defused 7
#define CTs_Win 8
#define Terrorists_Win 9
#define Round_Draw 10
#define All_Hostages_Rescued 11
#define Target_Saved 12
#define Hostages_Not_Rescued 13
#define Terrorists_Not_Escaped 14
#define VIP_Not_Escaped 15
#define Game_Commencing 16

#include "voice_gamemgr.h"

class CHalfLifeMultiplay : public CGameRules
{
public:
	CHalfLifeMultiplay(void);

public:
	virtual void Think(void);
	virtual void RefreshSkillData(void);
	virtual BOOL IsAllowedToSpawn(CBaseEntity *pEntity);
	virtual BOOL FAllowFlashlight(void);
	virtual BOOL FShouldSwitchWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual BOOL GetNextBestWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon);
	virtual BOOL IsMultiplayer(void);
	virtual BOOL IsDeathmatch(void);
	virtual BOOL IsCoOp(void);
	virtual BOOL ClientConnected(edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[128]);
	virtual void InitHUD(CBasePlayer *pl);
	virtual void ClientDisconnected(edict_t *pClient);
	virtual void UpdateGameMode(CBasePlayer *pPlayer);
	virtual float FlPlayerFallDamage(CBasePlayer *pPlayer);
	virtual BOOL FPlayerCanTakeDamage(CBasePlayer *pPlayer, CBaseEntity *pAttacker);
	virtual void PlayerSpawn(CBasePlayer *pPlayer);
	virtual void PlayerThink(CBasePlayer *pPlayer);
	virtual BOOL FPlayerCanRespawn(CBasePlayer *pPlayer);
	virtual float FlPlayerSpawnTime(CBasePlayer *pPlayer);
	virtual edict_t *GetPlayerSpawnSpot(CBasePlayer *pPlayer);
	virtual BOOL AllowAutoTargetCrosshair(void);
	virtual BOOL ClientCommand_DeadOrAlive(CBasePlayer *pPlayer, const char *pcmd);
	virtual BOOL ClientCommand(CBasePlayer *pPlayer, const char *pcmd);
	virtual void ClientUserInfoChanged(CBasePlayer *pPlayer, char *infobuffer);
	virtual int IPointsForKill(CBasePlayer *pAttacker, CBasePlayer *pKilled);
	virtual void PlayerKilled(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor);
	virtual void DeathNotice(CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor);
	virtual BOOL CanHavePlayerItem(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual void PlayerGotWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pWeapon);
	virtual int WeaponShouldRespawn(CBasePlayerItem *pWeapon);
	virtual float FlWeaponRespawnTime(CBasePlayerItem *pWeapon);
	virtual float FlWeaponTryRespawn(CBasePlayerItem *pWeapon);
	virtual Vector VecWeaponRespawnSpot(CBasePlayerItem *pWeapon);
	virtual BOOL CanHaveItem(CBasePlayer *pPlayer, CItem *pItem);
	virtual void PlayerGotItem(CBasePlayer *pPlayer, CItem *pItem);
	virtual int ItemShouldRespawn(CItem *pItem);
	virtual float FlItemRespawnTime(CItem *pItem);
	virtual Vector VecItemRespawnSpot(CItem *pItem);
	virtual void PlayerGotAmmo(CBasePlayer *pPlayer, char *szName, int iCount);
	virtual int AmmoShouldRespawn(CBasePlayerAmmo *pAmmo);
	virtual float FlAmmoRespawnTime(CBasePlayerAmmo *pAmmo);
	virtual Vector VecAmmoRespawnSpot(CBasePlayerAmmo *pAmmo);
	virtual float FlHealthChargerRechargeTime(void);
	virtual float FlHEVChargerRechargeTime(void);
	virtual int DeadPlayerWeapons(CBasePlayer *pPlayer);
	virtual int DeadPlayerAmmo(CBasePlayer *pPlayer);
	virtual const char *GetTeamID(CBaseEntity *pEntity) { return ""; }
	virtual int PlayerRelationship(CBaseEntity *pPlayer, CBaseEntity *pTarget);
	virtual BOOL PlayTextureSounds(void) { return FALSE; }
	virtual BOOL FAllowMonsters(void);
	virtual void EndMultiplayerGame(void) { GoToIntermission(); }
	virtual void CheckMapConditions(void);
	virtual void ServerDeactivate(void);
	virtual void CleanUpMap(void);
	virtual void RestartRound(void);
	virtual void CheckWinConditions(void);
	virtual void RemoveGuns(void);
	virtual void GiveC4(void);
	virtual void ChangeLevel(void);
	virtual void GoToIntermission(void);
	virtual void SetRestartServerAtRoundEnd();
	virtual BOOL ShouldRestart();
public:
	void SendMOTDToClient(edict_t *client);
	void InitializePlayerCounts(int &NumAliveTerrorist, int &NumAliveCT, int &NumDeadTerrorist, int &NumDeadCT);
	BOOL NeededPlayersCheck(BOOL &bNeededPlayers);
	BOOL VIPRoundEndCheck(BOOL bNeededPlayers);
	BOOL PrisonRoundEndCheck(int NumAliveTerrorist, int NumAliveCT, int NumDeadTerrorist, int NumDeadCT, BOOL bNeededPlayers);
	BOOL BombRoundEndCheck(BOOL bNeededPlayers);
	BOOL TeamExterminationCheck(int NumAliveTerrorist, int NumAliveCT, int NumDeadTerrorist, int NumDeadCT, BOOL bNeededPlayers);
	BOOL HostageRescueRoundEndCheck(BOOL bNeededPlayers);
	void BalanceTeams(void);
	BOOL IsThereABomber(void);
	BOOL IsThereABomb(void);
	BOOL TeamFull(int team_id);
	BOOL TeamStacked(int newTeam_id, int curTeam_id);
	void StackVIPQueue(void);
	void CheckVIPQueue(void);
	BOOL IsVIPQueueEmpty(void);
	BOOL AddToVIPQueue(CBasePlayer *pPlayer);
	void ResetCurrentVIP(void);
	void PickNextVIP(void);
	void CheckFreezePeriodExpired(void);
	void CheckRoundTimeExpired(void);
	void CheckLevelInitialized(void);
	void CheckRestartRound(void);
	BOOL CheckTimeLimit(void);
	BOOL CheckMaxRounds(void);
	BOOL CheckGameOver(void);
	BOOL CheckWinLimit(void);
	void CheckAllowSpecator(void);
	void CheckGameCvar(void);
	void DisplayMaps(CBasePlayer *pPlayer, int mapId);
	void ResetAllMapVotes(void);
	void ProcessMapVote(CBasePlayer *pPlayer, int mapId);
	void UpdateTeamScores(void);
	void SwapAllPlayers(void);
	void TerminateRound(float tmDelay, int iWinStatus);
	void QueueCareerRoundEndMenu(float tmDelay, int iWinStatus);
	float TimeRemaining(void) { return m_iRoundTimeSecs - gpGlobals->time + m_fRoundCount; }
	BOOL HasRoundTimeExpired(void);
	BOOL IsBombPlanted(void);
	void MarkLivingPlayersOnTeamAsNotReceivingMoneyNextRound(int team);
	void CareerRestart(void);
	BOOL IsCareer(void) { return FALSE; }

public:
	CVoiceGameMgr m_VoiceGameMgr;
	float m_fTeamCount;
	float m_flCheckWinConditions;
	float m_fRoundCount;
	int m_iRoundTime;
	int m_iRoundTimeSecs;
	int m_iIntroRoundTime;
	float m_fIntroRoundCount;
	int m_iAccountTerrorist;
	int m_iAccountCT;
	int m_iNumTerrorist;
	int m_iNumCT;
	int m_iNumSpawnableTerrorist;
	int m_iNumSpawnableCT;
	int m_iSpawnPointCount_Terrorist;
	int m_iSpawnPointCount_CT;
	int m_iHostagesRescued;
	int m_iHostagesTouched;
	int m_iRoundWinStatus;
	short m_iNumCTWins;
	short m_iNumTerroristWins;
	bool m_bTargetBombed;
	bool m_bBombDefused;
	bool m_bMapHasBombTarget;
	bool m_bMapHasBombZone;
	bool m_bMapHasBuyZone;
	bool m_bMapHasRescueZone;
	bool m_bMapHasEscapeZone;
	int m_iMapHasVIPSafetyZone;
	int m_bMapHasCameras;
	int m_iC4Timer;
	int m_iC4Guy;
	int m_iLoserBonus;
	int m_iNumConsecutiveCTLoses;
	int m_iNumConsecutiveTerroristLoses;
	float m_fMaxIdlePeriod;
	int m_iLimitTeams;
	bool m_bLevelInitialized;
	bool m_bRoundTerminating;
	bool m_bCompleteReset;
	float m_flRequiredEscapeRatio;
	int m_iNumEscapers;
	int m_iHaveEscaped;
	bool m_bCTCantBuy;
	bool m_bTCantBuy;
	float m_flBombRadius;
	int m_iConsecutiveVIP;
	int m_iTotalGunCount;
	int m_iTotalGrenadeCount;
	int m_iTotalArmourCount;
	int m_iUnBalancedRounds;
	int m_iNumEscapeRounds;
	int m_iMapVotes[MAX_MAPS];
	int m_iLastPick;
	int m_iMaxMapTime;
	int m_iMaxRounds;
	int m_iTotalRoundsPlayed;
	int m_iMaxRoundsWon;
	int m_iStoredSpectValue;
	float m_flForceCameraValue;
	float m_flForceChaseCamValue;
	float m_flFadeToBlackValue;
	CBasePlayer *m_pVIP;
	CBasePlayer *VIPQueue[MAX_VIPQUEUES];
	float m_flIntermissionEndTime;
	float m_flIntermissionStartTime;
	int m_iEndIntermissionButtonHit;
	float m_tmNextPeriodicThink;
	bool m_bFirstConnected;
	bool m_bInCareerGame;
	float m_fCareerRoundMenuTime;
	int m_iCareerMatchWins;
	int m_iRoundWinDifference;
	float m_fCareerMatchMenuTime;
	bool m_bSkipSpawn;
	BOOL m_bShouldRestart;
};

extern DLL_GLOBAL CHalfLifeMultiplay *g_pGameRules;

```

`dlls/hintmessage.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include <tier1/UtlVector.h>

class CHintMessage
{
public:
	CHintMessage(const char *hintString, bool isHint, CUtlVector<const char *> *args, float duration);
	~CHintMessage(void);

public:
	float GetDuration(void) const { return m_duration; }
	void Send(CBaseEntity *client);
	bool IsEquivalent(const char *hintString, CUtlVector<const char *> *args) const;

private:
	const char *m_hintString;
	CUtlVector<char *> m_args;
	float m_duration;
	bool m_isHint;
};

class CHintMessageQueue
{
public:
	void Reset(void);
	void Update(CBaseEntity *player);
	bool AddMessage(const char *message, float duration, bool isHint, CUtlVector<const char *> *args);
	bool IsEmpty(void) { return m_messages.Count() == 0; }

private:
	float m_tmMessageEnd;
	CUtlVector<CHintMessage *> m_messages;
};

```

`dlls/monsterevent.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef MONSTEREVENT_H
#define MONSTEREVENT_H

typedef struct
{
	int event;
	char *options;
}
MonsterEvent_t;

#define EVENT_SPECIFIC 0
#define EVENT_SCRIPTED 1000
#define EVENT_SHARED 2000
#define EVENT_CLIENT 5000

#define MONSTER_EVENT_BODYDROP_LIGHT 2001
#define MONSTER_EVENT_BODYDROP_HEAVY 2002
#define MONSTER_EVENT_SWISHSOUND 2010

#endif
```

`dlls/monsters.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef MONSTERS_H
#include "skill.h"
#define MONSTERS_H

typedef enum
{
	HITGROUP_GENERIC,
	HITGROUP_HEAD,
	HITGROUP_CHEST,
	HITGROUP_STOMACH,
	HITGROUP_LEFTARM,
	HITGROUP_RIGHTARM,
	HITGROUP_LEFTLEG,
	HITGROUP_RIGHTLEG,
	HITGROUP_SHIELD,
	NUM_HITGROUPS
}
HitBoxGroup;

#define SF_MONSTER_WAIT_TILL_SEEN 1
#define SF_MONSTER_GAG 2
#define SF_MONSTER_HITMONSTERCLIP 4
#define SF_MONSTER_PRISONER 16
#define SF_MONSTER_WAIT_FOR_SCRIPT 128
#define SF_MONSTER_PREDISASTER 256
#define SF_MONSTER_FADECORPSE 512
#define SF_MONSTER_FALL_TO_GROUND 0x80000000
#define SF_MONSTER_TURRET_AUTOACTIVATE 32
#define SF_MONSTER_TURRET_STARTINACTIVE 64

extern void UTIL_MoveToOrigin(edict_t *pent, const Vector &vecGoal, float flDist, int iMoveType);
Vector VecCheckToss(entvars_t *pev, const Vector &vecSpot1, Vector vecSpot2, float flGravityAdj = 1);
Vector VecCheckThrow(entvars_t *pev, const Vector &vecSpot1, Vector vecSpot2, float flSpeed, float flGravityAdj = 1);

extern DLL_GLOBAL Vector g_vecAttackDir;
extern DLL_GLOBAL CONSTANT float g_flMeleeRange;
extern DLL_GLOBAL CONSTANT float g_flMediumRange;
extern DLL_GLOBAL CONSTANT float g_flLongRange;

extern void EjectBrass(const Vector &vecOrigin, const Vector &vecLeft, const Vector &vecVelocity, float rotation, int model, int soundtype, int entityIndex);
extern void EjectBrass2(const Vector &vecOrigin, const Vector &vecVelocity, float rotation, int model, int soundtype, entvars_t *pev);
extern void ExplodeModel(const Vector &vecOrigin, float speed, int model, int count);

BOOL FBoxVisible(entvars_t *pevLooker, entvars_t *pevTarget);
BOOL FBoxVisible(entvars_t *pevLooker, entvars_t *pevTarget, Vector &vecTargetOrigin, float flSize = 0);

#define R_AL -2
#define R_FR -1
#define R_NO 0
#define R_DL 1
#define R_HT 2
#define R_NM 3

#define bits_MEMORY_KILLED (1<<7)

class CGib : public CBaseEntity
{
public:
	void Spawn(const char *szGibModel);
	int ObjectCaps(void) { return (CBaseEntity::ObjectCaps() & ~FCAP_ACROSS_TRANSITION) | FCAP_DONT_SAVE; }

public:
	void EXPORT BounceGibTouch(CBaseEntity *pOther);
	void EXPORT StickyGibTouch(CBaseEntity *pOther);
	void EXPORT WaitTillLand(void);
	void LimitVelocity(void);

public:
	static void SpawnHeadGib(entvars_t *pevVictim);
	static void SpawnRandomGibs(entvars_t *pevVictim, int cGibs, int human);
	static void SpawnStickyGibs(entvars_t *pevVictim, Vector vecOrigin, int cGibs);

public:
	int m_bloodColor;
	int m_cBloodDecals;
	int m_material;
	float m_lifeTime;
};

#endif
```

`dlls/nodes.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef NODES_H
#define NODES_H

#define bits_NODE_GROUP_REALM 1

class CLink
{
public:
	entvars_t *m_pLinkEnt;
};

class CGraph
{
public:
	BOOL m_fGraphPresent;
	BOOL m_fGraphPointersSet;
	int m_cLinks;
	CLink *m_pLinkPool;

public:
	void InitGraph(void);
	int AllocNodes(void);
	int CheckNODFile(char *szMapName);
	int FLoadGraph(char *szMapName);
	int FSetGraphPointers(void);
	void ShowNodeConnections(int iNode);
	int FindNearestNode(const Vector &vecOrigin, CBaseEntity *pEntity);
	int FindNearestNode(const Vector &vecOrigin, int afNodeTypes);
};

extern CGraph WorldGraph;
#endif
```

`dlls/player.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PLAYER_H
#define PLAYER_H

#include "pm_materials.h"
#include "hintmessage.h"
#include "weapons.h"

#define MAX_PLAYER_NAME_LENGTH 32
#define MAX_AUTOBUY_LENGTH 256
#define MAX_REBUY_LENGTH 256
#define MAX_LACTION_LENGTH 32

#define PLAYER_FATAL_FALL_SPEED (float)1100
#define PLAYER_MAX_SAFE_FALL_SPEED (float)500
#define DAMAGE_FOR_FALL_SPEED (float)100.0 / (PLAYER_FATAL_FALL_SPEED - PLAYER_MAX_SAFE_FALL_SPEED)
#define PLAYER_MIN_BOUNCE_SPEED (float)350
#define PLAYER_FALL_PUNCH_THRESHOLD (float)250.0

#define PFLAG_ONLADDER (1<<0)
#define PFLAG_ONSWING (1<<0)
#define PFLAG_ONTRAIN (1<<1)
#define PFLAG_ONBARNACLE (1<<2)
#define PFLAG_DUCKING (1<<3)
#define PFLAG_USING (1<<4)
#define PFLAG_OBSERVER (1<<5)

#define TRAIN_ACTIVE 0x80
#define TRAIN_NEW 0xc0
#define TRAIN_OFF 0x00
#define TRAIN_NEUTRAL 0x01
#define TRAIN_SLOW 0x02
#define TRAIN_MEDIUM 0x03
#define TRAIN_FAST 0x04
#define TRAIN_BACK 0x05

#define DHF_ROUND_STARTED (1<<1)
#define DHF_HOSTAGE_SEEN_FAR (1<<2)
#define DHF_HOSTAGE_SEEN_NEAR (1<<3)
#define DHF_HOSTAGE_USED (1<<4)
#define DHF_HOSTAGE_INJURED (1<<5)
#define DHF_HOSTAGE_KILLED (1<<6)
#define DHF_FRIEND_SEEN (1<<7)
#define DHF_ENEMY_SEEN (1<<8)
#define DHF_FRIEND_INJURED (1<<9)
#define DHF_FRIEND_KILLED (1<<10)
#define DHF_ENEMY_KILLED (1<<11)
#define DHF_BOMB_RETRIEVED (1<<12)
#define DHF_AMMO_EXHAUSTED (1<<15)
#define DHF_IN_TARGET_ZONE (1<<16)
#define DHF_IN_RESCUE_ZONE (1<<17)
#define DHF_IN_ESCAPE_ZONE (1<<18)
#define DHF_IN_VIPSAFETY_ZONE (1<<19)
#define DHF_NIGHTVISION (1<<20)
#define DHF_HOSTAGE_CTMOVE (1<<21)
#define	DHF_SPEC_DUCK (1<<22)

#define DHM_ROUND_CLEAR (DHF_ROUND_STARTED | DHF_HOSTAGE_KILLED | DHF_FRIEND_KILLED | DHF_BOMB_RETRIEVED)
#define DHM_CONNECT_CLEAR (DHF_HOSTAGE_SEEN_FAR | DHF_HOSTAGE_SEEN_NEAR | DHF_HOSTAGE_USED | DHF_HOSTAGE_INJURED | DHF_FRIEND_SEEN | DHF_ENEMY_SEEN | DHF_FRIEND_INJURED | DHF_ENEMY_KILLED | DHF_AMMO_EXHAUSTED | DHF_IN_TARGET_ZONE | DHF_IN_RESCUE_ZONE | DHF_IN_ESCAPE_ZONE | DHF_IN_VIPSAFETY_ZONE | DHF_HOSTAGE_CTMOVE | DHF_SPEC_DUCK)

#define SIGNAL_BUY (1<<0)
#define SIGNAL_BOMB (1<<1)
#define SIGNAL_RESCUE (1<<2)
#define SIGNAL_ESCAPE (1<<3)
#define SIGNAL_VIPSAFETY (1<<4)

class CUnifiedSignals
{
public:
	CUnifiedSignals(void)
	{
		m_flSignal = 0;
		m_flState = 0;
	}

public:
	void Update(void)
	{
		m_flState = m_flSignal;
		m_flSignal = 0;
	}

	void Signal(int flags) { m_flSignal |= flags; }
	int GetSignal(void) { return m_flSignal; }
	int GetState(void) { return m_flState; }

private:
	int m_flSignal;
	int m_flState;
};

#define IGNOREMSG_NONE 0
#define IGNOREMSG_ENEMY 1
#define IGNOREMSG_TEAM 2

#define CSUITPLAYLIST 4

#define SUIT_GROUP TRUE
#define SUIT_SENTENCE FALSE

#define SUIT_REPEAT_OK 0
#define SUIT_NEXT_IN_30SEC 30
#define SUIT_NEXT_IN_1MIN 60
#define SUIT_NEXT_IN_5MIN 300
#define SUIT_NEXT_IN_10MIN 600
#define SUIT_NEXT_IN_30MIN 1800
#define SUIT_NEXT_IN_1HOUR 3600

#define CSUITNOREPEAT 32

#define SOUND_FLASHLIGHT_ON "items/flashlight1.wav"
#define SOUND_FLASHLIGHT_OFF "items/flashlight1.wav"

#define TEAM_NAME_LENGTH 16

typedef enum
{
	PLAYER_IDLE,
	PLAYER_WALK,
	PLAYER_JUMP,
	PLAYER_SUPERJUMP,
	PLAYER_DIE,
	PLAYER_ATTACK1,
	PLAYER_ATTACK2,
	PLAYER_FLINCH,
	PLAYER_LARGE_FLINCH,
	PLAYER_RELOAD,
	PLAYER_HOLDBOMB
}
PLAYER_ANIM;

typedef enum
{
	Menu_OFF,
	Menu_ChooseTeam,
	Menu_IGChooseTeam,
	Menu_ChooseAppearance,
	Menu_Buy,
	Menu_BuyPistol,
	Menu_BuyRifle,
	Menu_BuyMachineGun,
	Menu_BuyShotgun,
	Menu_BuySubMachineGun,
	Menu_BuyItem,
	Menu_Radio1,
	Menu_Radio2,
	Menu_Radio3,
	Menu_ClientBuy
}
Menu;

typedef enum
{
	MODEL_UNASSIGNED,
	MODEL_URBAN,
	MODEL_TERROR,
	MODEL_LEET,
	MODEL_ARCTIC,
	MODEL_GSG9,
	MODEL_GIGN,
	MODEL_SAS,
	MODEL_GUERILLA,
	MODEL_VIP,
	MODEL_MILITIA,
	MODEL_SPETSNAZ
}
ModelName;

typedef enum
{
	JOINED,
	SHOWLTEXT,
	READINGLTEXT,
	SHOWTEAMSELECT,
	PICKINGTEAM,
	GETINTOGAME
}
JoinState;

typedef struct
{
	int m_primaryWeapon;
	int m_primaryAmmo;
	int m_secondaryWeapon;
	int m_secondaryAmmo;
	int m_heGrenade;
	int m_flashbang;
	int m_smokeGrenade;
	BOOL m_defuser;
	BOOL m_nightVision;
	int m_armor;
}
RebuyStruct;

typedef enum
{
	THROW_NONE,
	THROW_FORWARD,
	THROW_BACKWARD,
	THROW_HITVEL,
	THROW_BOMB,
	THROW_GRENADE,
	THROW_HITVEL_MINUS_AIRVEL
}
ThrowDirection;

#define MAX_ID_RANGE 2048
#define MAX_SPECTATOR_ID_RANGE 8192
#define SBAR_STRING_SIZE 128

#define SBAR_TARGETTYPE_TEAMMATE 1
#define SBAR_TARGETTYPE_ENEMY 2
#define SBAR_TARGETTYPE_HOSTAGE 3

enum sbar_data
{
	SBAR_ID_TARGETTYPE = 1,
	SBAR_ID_TARGETNAME,
	SBAR_ID_TARGETHEALTH,
	SBAR_END
};

typedef enum
{
	SILENT,
	CALM,
	INTENSE
}
MusicState;

#define CHAT_INTERVAL 1.0

class CBasePlayer : public CBaseMonster
{
public:
	virtual void Spawn(void);
	virtual void Precache(void) { }
	virtual void Restart(void) { }
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual int ObjectCaps(void) { return CBaseMonster::ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }
	virtual int Classify(void) { return 0; }
	virtual void TraceAttack(entvars_t *pevAttacker, float flDamage, const Vector &vecDir, TraceResult *ptr, int bitsDamageType) { }
	virtual int TakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType) { return 0; }
	virtual int TakeHealth(float flHealth, int bitsDamageType) { return 0; }
	virtual void Killed(entvars_t *pevAttacker, int iGib);
	virtual void AddPoints(int score, BOOL bAllowNegativeScore) {}
	virtual void AddPointsToTeam(int score, BOOL bAllowNegativeScore) {}
	virtual BOOL AddPlayerItem(CBasePlayerItem *pItem) { return false; }
	virtual BOOL RemovePlayerItem(CBasePlayerItem *pItem) { return false; }
	virtual int GiveAmmo(int iAmount, char *szName, int iMax){ return 0; }
	virtual void StartSneaking(void) { m_tSneaking = gpGlobals->time - 1; }
	virtual void StopSneaking(void) { m_tSneaking = gpGlobals->time + 30; }
	virtual BOOL IsSneaking(void) { return m_tSneaking <= gpGlobals->time; }
	virtual BOOL IsAlive(void) { return pev->deadflag == DEAD_NO && pev->health > 0; }
	virtual BOOL IsPlayer(void) { return TRUE; }
	virtual BOOL IsNetClient(void) { return TRUE; }
	virtual const char *TeamID(void) { return NULL; }
	virtual BOOL FBecomeProne(void) { return TRUE; }
	virtual Vector BodyTarget(const Vector &posSrc) { return Center() + pev->view_ofs * RANDOM_FLOAT(0.5, 1.1); }
	virtual int Illumination(void) { return 0; }
	virtual BOOL ShouldFadeOnDeath(void) { return FALSE; }
	virtual void ResetMaxSpeed(void) {  }
	virtual void Jump(void) { }
	virtual void Duck(void) { }
	virtual void PreThink(void) { }
	virtual void PostThink(void) { }
	virtual Vector GetGunPosition(void);
	virtual BOOL IsBot(void) { return FALSE; }
	virtual void UpdateClientData(void) { }
	virtual void ImpulseCommands(void) { }
	virtual void RoundRespawn(void) { }
	virtual Vector GetAutoaimVector(float flDelta) { return g_vecZero; }
	virtual void Blind(float flUntilTime, float flHoldTime, float flFadeTime, int iAlpha) { }
	virtual void OnTouchingWeapon(CBasePlayerWeapon *pWeapon) {}

public:
	void Pain(int hitgroup, bool hitkevlar);
	void RenewItems(void);
	void PackDeadPlayerItems(void);
	void RemoveAllItems(BOOL removeSuit);
	void SwitchTeam(void);
	BOOL SwitchWeapon(CBasePlayerItem *pWeapon);
	BOOL IsOnLadder(void);
	BOOL FlashlightIsOn(void);
	void FlashlightTurnOn(void);
	void FlashlightTurnOff(void);
	void UpdatePlayerSound(void);
	void DeathSound(void);
	void SetAnimation(PLAYER_ANIM playerAnim);
	void SetWeaponAnimType(const char *szExtention);
	void CheatImpulseCommands(int iImpulse);
	void StartDeathCam(void);
	void StartObserver(const Vector &vecPosition, const Vector &vecViewAngle);
	CBaseEntity *Observer_IsValidTarget(int iTarget, bool bOnlyTeam);
	void Observer_FindNextPlayer(bool bReverse, char *name = NULL);
	void Observer_HandleButtons(void);
	void Observer_SetMode(int iMode);
	void Observer_CheckTarget(void);
	void Observer_CheckProperties(void);
	int IsObserver(void) { return pev->iuser1; }
	bool IsObservingPlayer(CBasePlayer *pTarget);
	void SetObserverAutoDirector(bool bState);
	BOOL CanSwitchObserverModes(void);
	void DropPlayerItem(const char *pszItemName);
	void ThrowPrimary(void);
	void ThrowWeapon(char *pszWeaponName);
	BOOL HasPlayerItem(CBasePlayerItem *pCheckItem);
	BOOL HasNamedPlayerItem(const char *pszItemName);
	BOOL HasWeapons(void);
	void SelectPrevItem(int iItem);
	void SelectNextItem(int iItem);
	void SelectLastItem(void);
	void SelectItem(const char *pstr);
	void ItemPreFrame(void);
	void ItemPostFrame(void);
	void GiveNamedItem(const char *szName);
	void EnableControl(BOOL fControl);
	void SendAmmoUpdate(void);
	void SendFOV(int iFOV);
	void SendHostagePos(void);
	void SendHostageIcons(void);
	void SendWeatherInfo(void);
	void WaterMove(void);
	void EXPORT PlayerDeathThink(void);
	void PlayerUse(void);
	void CheckSuitUpdate(void);
	void SetSuitUpdate(const char *name, int fgroup, int iNoRepeat);
	void UpdateGeigerCounter(void);
	void CheckTimeBasedDamage(void);
	void BarnacleVictimBitten(entvars_t *pevBarnacle);
	void BarnacleVictimReleased(void);
	static int GetAmmoIndex(const char *psz);
	int AmmoInventory(int iAmmoIndex);
	void ResetAutoaim(void);
	Vector AutoaimDeflection(Vector &vecSrc, float flDist, float flDelta);
	void ForceClientDllUpdate(void);
	void SetCustomDecalFrames(int nFrames);
	int GetCustomDecalFrames(void);
	void TabulateAmmo(void);
	void SetProgressBarTime(int iTime);
	void SetProgressBarTime2(int iTime, float flLastTime);
	void SetPlayerModel(BOOL HasC4);
	void SetNewPlayerModel(const char *model);
	void CheckPowerups(entvars_t *pev);
	void SmartRadio(void);
	void Radio(const char *msg_id, const char *msg_verbose, int pitch = 100, bool showIcon = true);
	void GiveDefaultItems(void);
	void SetBombIcon(BOOL bFlash);
	void SetScoreAttrib(CBasePlayer *dest);
	void SetScoreboardAttributes(CBasePlayer *pPlayer = NULL);
	BOOL IsBombGuy(void);
	BOOL ShouldDoLargeFlinch(int nHitGroup, int nGunType);
	BOOL IsArmored(int nHitGroup);
	bool HintMessage(const char *pMessage, BOOL bDisplayIfDead = FALSE, BOOL bOverrideClientSettings = FALSE);
	void AddAccount(int amount, bool bTrackChange = true);
	void SyncRoundTimer(void);
	void MenuPrint(const char *text);
	void ResetMenu(void);
	void MakeVIP(void);
	void JoiningThink(void);
	void ResetStamina(void);
	void Disappear(void);
	void RemoveLevelText(void);
	void MoveToNextIntroCamera(void);
	void SpawnClientSideCorpse(void);
	void SetPrefsFromUserinfo(char *infobuffer);
	void HostageUsed(void);
	bool CanPlayerBuy(bool display);
	void StudioEstimateGait(void);
	void CalculatePitchBlend(void);
	void CalculateYawBlend(void);
	void StudioProcessGait(void);
	void HandleSignals(void);
	void EnterEscapeZone(void);
	void LeaveEscapeZone(void);
	void EnterVIPSafetyZone(void);
	void LeaveVIPSafetyZone(void);
	void InitStatusBar(void);
	void UpdateStatusBar(void);
	bool IsHittingShield(const Vector &vecDirection, TraceResult *ptr);
	bool IsReloading(void);
	bool IsThrowingGrenade(void);
	void StopReload(void);
	void DrawnShiled(void);
	bool HasShield(void);
	void UpdateShieldCrosshair(bool bShieldDrawn);
	void DropShield(bool bDeploy);
	void GiveShield(bool bRetire);
	bool IsProtectedByShield(void);
	void RemoveShield(void);
	void UpdateLocation(bool bForceUpdate);
	void ClientCommand(const char *arg0, const char *arg1 = NULL, const char *arg2 = NULL, const char *arg3 = NULL);
	void ClearAutoBuyData(void);
	void AddAutoBuyData(const char *string);
	void InitRebuyData(const char *string);
	void AutoBuy(void);
	bool ShouldExecuteAutoBuyCommand(const AutoBuyInfoStruct *commandInfo, bool boughtPrimary, bool boughtSecondary);
	AutoBuyInfoStruct *GetAutoBuyCommandInfo(const char *command);
	void PrioritizeAutoBuyString(char *autobuyString, const char *priorityString);
	void ParseAutoBuyString(const char *string, bool &boughtPrimary, bool &boughtSecondary);
	void PostAutoBuyCommandProcessing(const AutoBuyInfoStruct *commandInfo, bool &boughtPrimary, bool &boughtSecondary);
	void BuildRebuyStruct(void);
	void Rebuy(void);
	void RebuyPrimaryWeapon(void);
	void RebuyPrimaryAmmo(void);
	void RebuySecondaryWeapon(void);
	void RebuySecondaryAmmo(void);
	void RebuyHEGrenade(void);
	void RebuyFlashbang(void);
	void RebuySmokeGrenade(void);
	void RebuyDefuser(void);
	void RebuyNightVision(void);
	void RebuyArmor(void);

public:
	static TYPEDESCRIPTION m_playerSaveData[];

public:
	int random_seed;
	unsigned short m_usPlayerBleed;
	EHANDLE m_hObserverTarget;
	float m_flNextObserverInput;
	int m_iObserverWeapon;
	int m_iObserverC4State;
	bool m_bObserverHasDefuser;
	int m_iObserverLastMode;
	float m_flFlinchTime;
	float m_flAnimTime;
	bool m_bHighDamage;
	float m_flVelocityModifier;
	int m_iLastZoom;
	bool m_bResumeZoom;
	float m_flEjectBrass;
	int m_iKevlar;
	bool m_bNotKilled;
	int m_iTeam;
	int m_iAccount;
	bool m_bHasPrimary;
	float m_flDeathThrowTime;
	int m_iThrowDirection;
	float m_flLastTalk;
	bool m_bJustConnected;
	bool m_bContextHelp;
	JoinState m_iJoiningState;
	CBaseEntity *m_pIntroCamera;
	float m_fIntroCamTime;
	float m_fLastMovement;
	bool m_bMissionBriefing;
	bool m_bTeamChanged;
	int m_iModelName;
	int m_iTeamKills;
	int m_iIgnoreGlobalChat;
	bool m_bHasNightVision;
	bool m_bNightVisionOn;
	Vector m_vRecentPath[20];
	float m_flIdleCheckTime;
	float m_flRadioTime;
	int m_iRadioMessages;
	bool m_bIgnoreRadio;
	bool m_bHasC4;
	bool m_bHasDefuser;
	bool m_bKilledByBomb;
	Vector m_vBlastVector;
	bool m_bKilledByGrenade;
	CHintMessageQueue m_hintMessageQueue;
	int m_flDisplayHistory;
	int m_iMenu;
	int m_iChaseTarget;
	CBaseEntity *m_pChaseTarget;
	BOOL m_fCamSwitch;
	bool m_bEscaped;
	bool m_bIsVIP;
	float m_tmNextRadarUpdate;
	Vector m_vLastOrigin;
	int m_iCurrentKickVote;
	float m_flNextVoteTime;
	bool m_bJustKilledTeammate;
	int m_iHostagesKilled;
	int m_iMapVote;
	bool m_bCanShoot;
	float m_flLastFired;
	float m_flLastAttackedTeammate;
	bool m_bHeadshotKilled;
	bool m_bPunishedForTK;
	bool m_bReceivesNoMoneyNextRound;
	int m_iTimeCheckAllowed;
	bool m_bHasChangedName;
	char m_szNewName[MAX_PLAYER_NAME_LENGTH];
	bool m_bIsDefusing;
	float m_tmHandleSignals;
	CUnifiedSignals m_signals;
	edict_t *m_pentCurBombTarget;
	int m_iPlayerSound;
	int m_iTargetVolume;
	int m_iWeaponVolume;
	int m_iExtraSoundTypes;
	int m_iWeaponFlash;
	float m_flStopExtraSoundTime;
	float m_flFlashLightTime;
	int m_iFlashBattery;
	int m_afButtonLast;
	int m_afButtonPressed;
	int m_afButtonReleased;
	edict_t *m_pentSndLast;
	float m_flSndRoomtype;
	float m_flSndRange;
	float m_flFallVelocity;
	int m_rgItems[MAX_ITEMS];
	int m_fNewAmmo;
	unsigned int m_afPhysicsFlags;
	float m_fNextSuicideTime;
	float m_flTimeStepSound;
	float m_flTimeWeaponIdle;
	float m_flSwimTime;
	float m_flDuckTime;
	float m_flWallJumpTime;
	float m_flSuitUpdate;
	int m_rgSuitPlayList[CSUITPLAYLIST];
	int m_iSuitPlayNext;
	int m_rgiSuitNoRepeat[CSUITNOREPEAT];
	float m_rgflSuitNoRepeatTime[CSUITNOREPEAT];
	int m_lastDamageAmount;
	float m_tbdPrev;
	float m_flgeigerRange;
	float m_flgeigerDelay;
	int m_igeigerRangePrev;
	int m_iStepLeft;
	char m_szTextureName[CBTEXTURENAMEMAX];
	char m_chTextureType;
	int m_idrowndmg;
	int m_idrownrestored;
	int m_bitsHUDDamage;
	BOOL m_fInitHUD;
	BOOL m_fGameHUDInitialized;
	int m_iTrain;
	BOOL m_fWeapon;
	EHANDLE m_pTank;
	float m_fDeadTime;
	BOOL m_fNoPlayerSound;
	BOOL m_fLongJump;
	float m_tSneaking;
	int m_iUpdateTime;
	int m_iClientHealth;
	int m_iClientBattery;
	int m_iHideHUD;
	int m_iClientHideHUD;
	int m_iFOV;
	int m_iClientFOV;
	int m_iNumSpawns;
	CBaseEntity *m_pObserver;
	CBasePlayerItem *m_rgpPlayerItems[MAX_ITEM_TYPES];
	CBasePlayerItem *m_pActiveItem;
	CBasePlayerItem *m_pClientActiveItem;
	CBasePlayerItem *m_pLastItem;
	int m_rgAmmo[MAX_AMMO_SLOTS];
	int m_rgAmmoLast[MAX_AMMO_SLOTS];
	Vector m_vecAutoAim;
	BOOL m_fOnTarget;
	int m_iDeaths;
	int m_izSBarState[SBAR_END];
	float m_flNextSBarUpdateTime;
	float m_flStatusBarDisappearDelay;
	char m_SbarString0[SBAR_STRING_SIZE];
	int m_lastx, m_lasty;
	int m_nCustomSprayFrames;
	float m_flNextDecalTime;
	char m_szTeamName[TEAM_NAME_LENGTH];
	int m_modelIndexPlayer;
	char m_szAnimExtention[32];
	int m_iGaitsequence;
	float m_flGaitframe;
	float m_flGaityaw;
	vec3_t m_prevgaitorigin;
	float m_flPitch;
	float m_flYaw;
	float m_flGaitMovement;
	int m_iAutoWepSwitch;
	bool m_bVGUIMenus;
	bool m_bShowHints;
	bool m_bShieldDrawn;
	bool m_bOwnsShield;
	bool m_bWasFollowing;
	float m_flNextFollowTime;
	float m_flYawModifier;
	float m_blindUntilTime;
	float m_blindStartTime;
	float m_blindHoldTime;
	float m_blindFadeTime;
	float m_blindAlpha;
	float m_allowAutoFollowTime;
	char m_autoBuyString[MAX_AUTOBUY_LENGTH];
	char *m_rebuyString;
	RebuyStruct m_rebuyStruct;
	bool m_bIsInRebuy;
	float m_flLastUpdateTime;
	char m_lastLocation[MAX_LACTION_LENGTH];
	int m_progressStart;
	int m_progressEnd;
	bool m_bObserverAutoDirector;
	bool m_canSwitchObserverModes;
	float m_heartBeatTime;
	int m_intenseTimestamp;
	int m_silentTimestamp;
	MusicState m_musicState;
	int m_flLastCommandTime[8];
};

#define AUTOAIM_2DEGREES 0.0348994967025
#define AUTOAIM_5DEGREES 0.08715574274766
#define AUTOAIM_8DEGREES 0.1391731009601
#define AUTOAIM_10DEGREES 0.1736481776669

extern int gmsgHudText;
extern int gmsgShowMenu;
extern int gmsgVGUIMenu;
extern int gmsgScenarioIcon;
extern int gmsgBombDrop;

extern BOOL gInitHUD;

void SendItemStatus(CBasePlayer *pPlayer);

extern bool UseBotArgs;
extern const char *BotArgs[4];

#endif

```

`dlls/saverestore.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef SAVERESTORE_H
#define SAVERESTORE_H

class CBaseEntity;

class CSaveRestoreBuffer
{
public:
	CSaveRestoreBuffer(void);
	CSaveRestoreBuffer(SAVERESTOREDATA *pdata);
	virtual ~CSaveRestoreBuffer(void);

public:
	int EntityIndex(entvars_t *pevLookup);
	int EntityIndex(edict_t *pentLookup);
	int EntityIndex(EOFFSET eoLookup);
	int EntityIndex(CBaseEntity *pEntity);
	int EntityFlags(int entityIndex, int flags) { return EntityFlagsSet(entityIndex, 0); }
	int EntityFlagsSet(int entityIndex, int flags);
	edict_t *EntityFromIndex(int entityIndex);
	unsigned short TokenHash(const char *pszToken);

protected:
	SAVERESTOREDATA *m_pdata;
	void BufferRewind(int size);
	unsigned int HashString(const char *pszToken);

private:
	void operator = (CSaveRestoreBuffer &);
	CSaveRestoreBuffer(const CSaveRestoreBuffer &);
};

class CSave : public CSaveRestoreBuffer
{
public:
	CSave(SAVERESTOREDATA *pdata): CSaveRestoreBuffer(pdata) {};

public:
	void WriteShort(const char *pname, const short *value, int count);
	void WriteInt(const char *pname, const int *value, int count);
	void WriteFloat(const char *pname, const float *value, int count);
	void WriteTime(const char *pname, const float *value, int count);
	void WriteData(const char *pname, int size, const char *pdata);
	void WriteString(const char *pname, const char *pstring);
	void WriteString(const char *pname, const int *stringId, int count);
	void WriteVector(const char *pname, const Vector &value);
	void WriteVector(const char *pname, const float *value, int count);
	void WritePositionVector(const char *pname, const Vector &value);
	void WritePositionVector(const char *pname, const float *value, int count);
	void WriteFunction(const char *pname, const int *value, int count);
	int WriteEntVars(const char *pname, entvars_t *pev);
	int WriteFields(const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount);

private:
	int DataEmpty(const char *pdata, int size);
	void BufferField(const char *pname, int size, const char *pdata);
	void BufferString(char *pdata, int len);
	void BufferData(const char *pdata, int size);
	void BufferHeader(const char *pname, int size);
};

typedef struct
{
	unsigned short size;
	unsigned short token;
	char *pData;
}
HEADER;

class CRestore : public CSaveRestoreBuffer
{
public:
	CRestore(SAVERESTOREDATA *pdata): CSaveRestoreBuffer(pdata), m_global(0), m_precache(TRUE) {}

public:
	int ReadEntVars(const char *pname, entvars_t *pev);
	int ReadFields(const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount);
	int ReadField(void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount, int startField, int size, char *pName, void *pData);
	int ReadInt(void);
	short ReadShort(void);
	int ReadNamedInt(const char *pName);
	char *ReadNamedString(const char *pName);
	int Empty(void) { return (!m_pdata) || ((m_pdata->pCurrentData - m_pdata->pBaseData) >= m_pdata->bufferSize); }
	inline void SetGlobalMode(int global) { m_global = global; }
	void PrecacheMode(BOOL mode){ m_precache = mode; }

private:
	char *BufferPointer(void);
	void BufferReadBytes(char *pOutput, int size);
	void BufferSkipBytes(int bytes);
	int BufferSkipZString(void);
	int BufferCheckZString(const char *string);
	void BufferReadHeader(HEADER *pheader);

private:
	int m_global;
	BOOL m_precache;
};

#define MAX_ENTITYARRAY 64

#define IMPLEMENT_SAVERESTORE(derivedClass,baseClass) \
	int derivedClass::Save(CSave &save)\
{\
	if (!baseClass::Save(save))\
	return 0;\
	return save.WriteFields(#derivedClass, this, m_SaveData, ARRAYSIZE(m_SaveData));\
}\
	int derivedClass::Restore(CRestore &restore)\
{\
	if (!baseClass::Restore(restore))\
	return 0;\
	return restore.ReadFields(#derivedClass, this, m_SaveData, ARRAYSIZE(m_SaveData));\
}

typedef enum { GLOBAL_OFF = 0, GLOBAL_ON = 1, GLOBAL_DEAD = 2 } GLOBALESTATE;
typedef struct globalentity_s globalentity_t;

struct globalentity_s
{
	char name[64];
	char levelName[32];
	GLOBALESTATE state;
	globalentity_t *pNext;
};

class CGlobalState
{
public:
	CGlobalState(void);

public:
	void Reset(void);
	void ClearStates(void);
	void EntityAdd(string_t globalname, string_t mapName, GLOBALESTATE state);
	void EntitySetState(string_t globalname, GLOBALESTATE state);
	void EntityUpdate(string_t globalname, string_t mapname);
	const globalentity_t *EntityFromTable(string_t globalname);
	GLOBALESTATE EntityGetState(string_t globalname);
	int EntityInTable(string_t globalname) { return (Find(globalname) != NULL) ? 1 : 0; }
	int Save(CSave &save);
	int Restore(CRestore &restore);
	void DumpGlobals(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

private:
	globalentity_t *Find(string_t globalname);
	globalentity_t *m_pList;
	int m_listCount;

private:
	void operator = (CGlobalState &);
	CGlobalState(const CGlobalState &);
};

extern CGlobalState gGlobalState;
#endif
```

`dlls/schedule.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef SCHEDULE_H
#define SCHEDULE_H

#define bits_COND_SEE_HATE (1<<1)
#define bits_COND_SEE_FEAR (1<<2)
#define bits_COND_SEE_DISLIKE (1<<3)
#define bits_COND_SEE_ENEMY (1<<4)
#define bits_COND_LIGHT_DAMAGE (1<<8)
#define bits_COND_HEAVY_DAMAGE (1<<9)
#define bits_COND_SEE_CLIENT (1<<21)
#define bits_COND_SEE_NEMESIS (1<<22)

#endif
```

`dlls/skill.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

struct skilldata_t
{
	int iSkillLevel;
	float agruntHealth;
	float agruntDmgPunch;
	float apacheHealth;
	float barneyHealth;
	float bigmommaHealthFactor;
	float bigmommaDmgSlash;
	float bigmommaDmgBlast;
	float bigmommaRadiusBlast;
	float bullsquidHealth;
	float bullsquidDmgBite;
	float bullsquidDmgWhip;
	float bullsquidDmgSpit;
	float gargantuaHealth;
	float gargantuaDmgSlash;
	float gargantuaDmgFire;
	float gargantuaDmgStomp;
	float hassassinHealth;
	float headcrabHealth;
	float headcrabDmgBite;
	float hgruntHealth;
	float hgruntDmgKick;
	float hgruntShotgunPellets;
	float hgruntGrenadeSpeed;
	float houndeyeHealth;
	float houndeyeDmgBlast;
	float slaveHealth;
	float slaveDmgClaw;
	float slaveDmgClawrake;
	float slaveDmgZap;
	float ichthyosaurHealth;
	float ichthyosaurDmgShake;
	float leechHealth;
	float leechDmgBite;
	float controllerHealth;
	float controllerDmgZap;
	float controllerSpeedBall;
	float controllerDmgBall;
	float nihilanthHealth;
	float nihilanthZap;
	float scientistHealth;
	float snarkHealth;
	float snarkDmgBite;
	float snarkDmgPop;
	float zombieHealth;
	float zombieDmgOneSlash;
	float zombieDmgBothSlash;
	float turretHealth;
	float miniturretHealth;
	float sentryHealth;
	float plrDmgCrowbar;
	float plrDmg9MM;
	float plrDmg357;
	float plrDmgMP5;
	float plrDmgM203Grenade;
	float plrDmgBuckshot;
	float plrDmgCrossbowClient;
	float plrDmgCrossbowMonster;
	float plrDmgRPG;
	float plrDmgGauss;
	float plrDmgEgonNarrow;
	float plrDmgEgonWide;
	float plrDmgHornet;
	float plrDmgHandGrenade;
	float plrDmgSatchel;
	float plrDmgTripmine;
	float monDmg9MM;
	float monDmgMP5;
	float monDmg12MM;
	float monDmgHornet;
	float suitchargerCapacity;
	float batteryCapacity;
	float healthchargerCapacity;
	float healthkitCapacity;
	float scientistHeal;
	float monHead;
	float monChest;
	float monStomach;
	float monLeg;
	float monArm;
	float plrHead;
	float plrChest;
	float plrStomach;
	float plrLeg;
	float plrArm;
};

extern DLL_GLOBAL skilldata_t gSkillData;
float GetSkillCvar(char *pName);
extern DLL_GLOBAL int g_iSkillLevel;

#define SKILL_EASY 1
#define SKILL_MEDIUM 2
#define SKILL_HARD 3
```

`dlls/soundent.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#define MAX_WORLD_SOUNDS 64

#define bits_SOUND_NONE 0
#define bits_SOUND_COMBAT (1<<0)
#define bits_SOUND_WORLD (1<<1)
#define bits_SOUND_PLAYER (1<< 2)
#define bits_SOUND_CARCASS (1<< 3)
#define bits_SOUND_MEAT (1<< 4)
#define bits_SOUND_DANGER (1<< 5)
#define bits_SOUND_GARBAGE (1<< 6)

#define bits_ALL_SOUNDS 0xFFFFFFFF

#define SOUNDLIST_EMPTY	-1

#define SOUNDLISTTYPE_FREE 1
#define SOUNDLISTTYPE_ACTIVE 2

#define SOUND_NEVER_EXPIRE -1

class CSound
{
public:
	void Clear(void);
	void Reset(void);

public:
	Vector m_vecOrigin;
	int m_iType;
	int m_iVolume;
	float m_flExpireTime;
	int m_iNext;
	int m_iNextAudible;

public:
	BOOL FIsSound(void);
	BOOL FIsScent(void);
};

class CSoundEnt : public CBaseEntity 
{
public:
	void Precache(void);
	void Spawn(void);
	void Think(void);
	void Initialize(void);
	int ObjectCaps(void) { return FCAP_DONT_SAVE; }

public:
	static void InsertSound(int iType, const Vector &vecOrigin, int iVolume, float flDuration);
	static void FreeSound(int iSound, int iPrevious);
	static int ActiveList(void);
	static int FreeList(void);
	static CSound *SoundPointerForIndex(int iIndex);
	static int ClientSoundIndex(edict_t *pClient);

public:
	BOOL IsEmpty(void) { return m_iActiveSound == SOUNDLIST_EMPTY; }
	int ISoundsInList(int iListType);
	int IAllocSound(void);

public:
	int m_iFreeSound;
	int m_iActiveSound;
	int m_cLastActiveSounds;
	BOOL m_fShowReport;

private:
	CSound m_SoundPool[MAX_WORLD_SOUNDS];
};
```

`dlls/stdafx.h`:

```h
#ifndef stdafx_h__
#define stdafx_h__

#include "port.h"
#include "extdll.h"
#include "util.h"

#endif // stdafx_h__

```

`dlls/util.h`:

```h
#ifndef util_h__
#define util_h__

/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "port.h"
#include <string.h>
#ifndef ACTIVITY_H
#include "activity.h"
#endif

#ifndef ENGINECALLBACK_H
#include "enginecallback.h"
#endif

#include <tier1/UtlVector.h>

inline void MESSAGE_BEGIN(int msg_dest, int msg_type, const float *pOrigin, entvars_t *ent);
extern globalvars_t *gpGlobals;
#define STRING(offset) reinterpret_cast<const char *>(gpGlobals->pStringBase + (uintp)offset)
#if !defined __aarch64__ || defined(CLIENT_DLL)
#define MAKE_STRING(str)	((int)(long int)str - (int)(long int)STRING(0))
#else
static inline int MAKE_STRING(const char *szValue)
{
	long long ptrdiff = szValue - STRING(0);
	if( ptrdiff > INT_MAX || ptrdiff < INT_MIN )
		return ALLOC_STRING( szValue );
	else
		return (int)ptrdiff;
}
#endif
inline edict_t *FIND_ENTITY_BY_CLASSNAME(edict_t *entStart, const char *pszName)
{
	return FIND_ENTITY_BY_STRING(entStart, "classname", pszName);
}

inline edict_t *FIND_ENTITY_BY_TARGETNAME(edict_t *entStart, const char *pszName)
{
	return FIND_ENTITY_BY_STRING(entStart, "targetname", pszName);
}

inline edict_t *FIND_ENTITY_BY_TARGET(edict_t *entStart, const char *pszName)
{
	return FIND_ENTITY_BY_STRING(entStart, "target", pszName);
}

#define WRITEKEY_INT(pf, szKeyName, iKeyValue) ENGINE_FPRINTF(pf, "\"%s\" \"%d\"\n", szKeyName, iKeyValue)
#define WRITEKEY_FLOAT(pf, szKeyName, flKeyValue) ENGINE_FPRINTF(pf, "\"%s\" \"%f\"\n", szKeyName, flKeyValue)
#define WRITEKEY_STRING(pf, szKeyName, szKeyValue) ENGINE_FPRINTF(pf, "\"%s\" \"%s\"\n", szKeyName, szKeyValue)
#define WRITEKEY_VECTOR(pf, szKeyName, flX, flY, flZ) ENGINE_FPRINTF(pf, "\"%s\" \"%f %f %f\"\n", szKeyName, flX, flY, flZ)

#define SetBits(flBitVector, bits) ((flBitVector) = (int)(flBitVector) | (bits))
#define ClearBits(flBitVector, bits) ((flBitVector) = (int)(flBitVector) & ~(bits))
#define FBitSet(flBitVector, bit) ((int)(flBitVector) & (bit))

#define FILE_GLOBAL static
#define DLL_GLOBAL
#define CONSTANT

typedef int EOFFSET;
typedef int BOOL;

#define M_PI 3.14159265358979323846

#define DECLARE_GLOBAL_METHOD(MethodName) extern void DLLEXPORT MethodName(void)
#define GLOBAL_METHOD(funcname) void DLLEXPORT funcname(void)

#ifdef CLIENT_DLL
#define LINK_ENTITY_TO_CLASS( x, y )
#elif defined(_WIN32)
#define LINK_ENTITY_TO_CLASS(mapClassName, DLLClassName) \
	extern "C" EXPORT void mapClassName(entvars_t *pev); \
	void mapClassName(entvars_t *pev) { GetClassPtr((DLLClassName *)pev); }
#else
#define LINK_ENTITY_TO_CLASS(mapClassName,DLLClassName) extern "C" void mapClassName(entvars_t *pev); void mapClassName(entvars_t *pev) { GetClassPtr((DLLClassName *)pev); }
#endif

#if defined(DEBUG) && !defined(CLIENT_DLL)
	extern edict_t *DBG_EntOfVars(const entvars_t *pev);
	inline edict_t *ENT(const entvars_t *pev) { return DBG_EntOfVars(pev); }
#else
	inline edict_t *ENT(const entvars_t *pev) { return pev->pContainingEntity; }
#endif
inline edict_t *ENT(edict_t *pent) { return pent; }
inline edict_t *ENT(EOFFSET eoffset) { return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }
inline EOFFSET OFFSET(EOFFSET eoffset) { return eoffset; }
inline EOFFSET OFFSET(const edict_t *pent)
{
#if _DEBUG
	if (!pent)
		ALERT(at_error, "Bad ent in OFFSET()\n");
#endif
	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent);
}

inline EOFFSET OFFSET(entvars_t *pev)
{
#if _DEBUG
	if (!pev)
		ALERT(at_error, "Bad pev in OFFSET()\n");
#endif
	return OFFSET(ENT(pev));
}
inline entvars_t *VARS(entvars_t *pev) { return pev; }

inline entvars_t *VARS(edict_t *pent)
{
	if (!pent)
		return NULL;

	return &pent->v;
}

inline entvars_t *VARS(EOFFSET eoffset) { return VARS(ENT(eoffset)); }
inline int ENTINDEX(edict_t *pEdict) { return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }
inline edict_t *INDEXENT(int iEdictNum) { return (*g_engfuncs.pfnPEntityOfEntIndex)(iEdictNum); }

inline void MESSAGE_BEGIN(int msg_dest, int msg_type, const float *pOrigin, entvars_t *ent) { (*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ENT(ent)); }

#define eoNullEntity 0
inline BOOL FNullEnt(EOFFSET eoffset) { return eoffset == 0; }
inline BOOL FNullEnt(const edict_t *pent) { return pent == NULL || FNullEnt(OFFSET(pent)); }
inline BOOL FNullEnt(entvars_t *pev) { return pev == NULL || FNullEnt(OFFSET(pev)); }

#define iStringNull 0
inline BOOL FStringNull(int iString) { return iString == iStringNull; }

#define cchMapNameMost 32

#define VIEW_FIELD_FULL (float)-1
#define VIEW_FIELD_WIDE (float)-0.7
#define VIEW_FIELD_NARROW (float)0.7
#define VIEW_FIELD_ULTRA_NARROW (float)0.9

#define DONT_BLEED -1
#define BLOOD_COLOR_RED (BYTE)247
#define BLOOD_COLOR_YELLOW (BYTE)195
#define BLOOD_COLOR_GREEN BLOOD_COLOR_YELLOW

typedef enum
{
	MONSTERSTATE_NONE = 0,
	MONSTERSTATE_IDLE,
	MONSTERSTATE_COMBAT,
	MONSTERSTATE_ALERT,
	MONSTERSTATE_HUNT,
	MONSTERSTATE_PRONE,
	MONSTERSTATE_SCRIPT,
	MONSTERSTATE_PLAYDEAD,
	MONSTERSTATE_DEAD
}
MONSTERSTATE;

typedef enum
{
	TS_AT_TOP,
	TS_AT_BOTTOM,
	TS_GOING_UP,
	TS_GOING_DOWN
}
TOGGLE_STATE;

inline BOOL FStrEq(const char *sz1, const char *sz2) { return (!strcmp(sz1, sz2)); }
inline BOOL FClassnameIs(edict_t *pent, const char *szClassname) { return FStrEq(STRING(VARS(pent)->classname), szClassname); }
inline BOOL FClassnameIs(entvars_t *pev, const char *szClassname) { return FStrEq(STRING(pev->classname), szClassname); }

class CBaseEntity;

extern void UTIL_SetSize(entvars_t *pev, const Vector &vecMin, const Vector &vecMax);
extern float UTIL_VecToYaw(const Vector &vec);
extern Vector UTIL_VecToAngles(const Vector &vec);
extern float UTIL_AngleMod(float a);
extern float UTIL_AngleDiff(float destAngle, float srcAngle);

extern CBaseEntity *UTIL_FindEntityInSphere(CBaseEntity *pStartEntity, const Vector &vecCenter, float flRadius);
extern CBaseEntity *UTIL_FindEntityByString_Old(CBaseEntity *pStartEntity, const char *szKeyword, const char *szValue);
extern CBaseEntity *UTIL_FindEntityByString(CBaseEntity *pStartEntity, const char *szKeyword, const char *szValue);
#ifndef CLIENT_DLL
extern CBaseEntity *UTIL_FindEntityByClassname(CBaseEntity *pStartEntity, const char *szName);
#else
inline CBaseEntity *UTIL_FindEntityByClassname(CBaseEntity *, const char* ) { return NULL; }
#endif
extern CBaseEntity *UTIL_FindEntityByTargetname(CBaseEntity *pStartEntity, const char *szName);
extern CBaseEntity *UTIL_FindEntityGeneric(const char *szName, Vector &vecSrc, float flRadius);
extern CBaseEntity *UTIL_PlayerByIndex(int playerIndex);

#define UTIL_EntitiesInPVS(pent) (*g_engfuncs.pfnEntitiesInPVS)(pent)

extern void UTIL_MakeVectors(const Vector &vecAngles);
extern int UTIL_MonstersInSphere(CBaseEntity **pList, int listMax, const Vector &center, float radius);
extern int UTIL_EntitiesInBox(CBaseEntity **pList, int listMax, const Vector &mins, const Vector &maxs, int flagMask);
inline void UTIL_MakeVectorsPrivate(const Vector &vecAngles, float *p_vForward, float *p_vRight, float *p_vUp) { g_engfuncs.pfnAngleVectors(vecAngles, p_vForward, p_vRight, p_vUp); }
extern void UTIL_MakeAimVectors(const Vector &vecAngles);
extern void UTIL_MakeInvVectors(const Vector &vec, globalvars_t *pgv);

extern void UTIL_SetOrigin(entvars_t *pev, const Vector &vecOrigin);
extern void UTIL_EmitAmbientSound(edict_t *entity, const Vector &vecOrigin, const char *samp, float vol, float attenuation, int fFlags, int pitch);
extern void UTIL_ParticleEffect(const Vector &vecOrigin, const Vector &vecDirection, ULONG ulColor, ULONG ulCount);
extern void UTIL_ScreenShake(const Vector &center, float amplitude, float frequency, float duration, float radius);
extern void UTIL_ScreenShakeAll(const Vector &center, float amplitude, float frequency, float duration);
extern void UTIL_ShowMessageArgs(const char *pString, CBaseEntity *pPlayer, CUtlVector<char *> *args, bool isHint);
extern void UTIL_ShowMessage(const char *pString, CBaseEntity *pPlayer);
extern void UTIL_ShowMessageAll(const char *pString);
extern void UTIL_ScreenFadeAll(const Vector &color, float fadeTime, float holdTime, int alpha, int flags);
extern void UTIL_ScreenFade(CBaseEntity *pEntity, const Vector &color, float fadeTime, float fadeHold, int alpha, int flags);

typedef enum { ignore_monsters = 1, dont_ignore_monsters = 0, missile = 2 } IGNORE_MONSTERS;
typedef enum { ignore_glass = 1, dont_ignore_glass = 0 } IGNORE_GLASS;
extern void UTIL_TraceLine(const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, edict_t *pentIgnore, TraceResult *ptr);
extern void UTIL_TraceLine(const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, IGNORE_GLASS ignoreGlass, edict_t *pentIgnore, TraceResult *ptr);
typedef enum { point_hull = 0, human_hull = 1, large_hull = 2, head_hull = 3 } HULL_TYPE;
#ifndef CLIENT_DLL
extern void UTIL_TraceHull(const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, int hullNumber, edict_t *pentIgnore, TraceResult *ptr);
#else
inline void UTIL_TraceHull(const Vector &vecStart, const Vector &vecEnd, IGNORE_MONSTERS igmon, int hullNumber, edict_t *pentIgnore, TraceResult *ptr) {}
#endif
extern TraceResult UTIL_GetGlobalTrace(void);
extern void UTIL_TraceModel(const Vector &vecStart, const Vector &vecEnd, int hullNumber, edict_t *pentModel, TraceResult *ptr);
extern Vector UTIL_GetAimVector(edict_t *pent, float flSpeed);
extern int UTIL_PointContents(const Vector &vec);

extern int UTIL_IsMasterTriggered(string_t sMaster, CBaseEntity *pActivator);
extern void UTIL_BloodStream(const Vector &origin, const Vector &direction, int color, int amount);
extern void UTIL_BloodDrips(const Vector &origin, const Vector &direction, int color, int amount);
extern Vector UTIL_RandomBloodVector(void);
extern BOOL UTIL_ShouldShowBlood(int bloodColor);
extern void UTIL_BloodDecalTrace(TraceResult *pTrace, int bloodColor);
extern void UTIL_DecalTrace(TraceResult *pTrace, int decalNumber);
extern void UTIL_PlayerDecalTrace(TraceResult *pTrace, int playernum, int decalNumber, BOOL bIsCustom);
extern void UTIL_GunshotDecalTrace(TraceResult *pTrace, int decalNumber);
extern void UTIL_Sparks(const Vector &position);
extern void UTIL_Ricochet(const Vector &position, float scale);
extern void UTIL_StringToVector(float *pVector, const char *pString);
extern void UTIL_StringToIntArray(int *pVector, int count, const char *pString);
extern Vector UTIL_ClampVectorToBox(const Vector &input, const Vector &clampSize);
extern float UTIL_Approach(float target, float value, float speed);
extern float UTIL_ApproachAngle(float target, float value, float speed);
extern float UTIL_AngleDistance(float next, float cur);
extern char *UTIL_VarArgs(char *format, ...);
extern void UTIL_Remove(CBaseEntity *pEntity);
extern BOOL UTIL_IsValidEntity(edict_t *pent);
extern BOOL UTIL_TeamsMatch(const char *pTeamName1, const char *pTeamName2);
extern float UTIL_SplineFraction(float value, float scale);
extern float UTIL_WaterLevel(const Vector &position, float minz, float maxz);
extern void UTIL_Bubbles(Vector mins, Vector maxs, int count);
extern void UTIL_BubbleTrail(Vector from, Vector to, int count);
extern void UTIL_PrecacheOther(const char *szClassname);
extern void UTIL_ClientPrintAll(int msg_dest, const char *msg_name, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL, const char *param4 = NULL);

inline void UTIL_CenterPrintAll(const char *msg_name, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL, const char *param4 = NULL)
{
	UTIL_ClientPrintAll(HUD_PRINTCENTER, msg_name, param1, param2, param3, param4);
}

class CBasePlayerItem;
class CBasePlayer;

extern BOOL UTIL_GetNextBestWeapon(CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon);
#ifndef CLIENT_DLL
extern void ClientPrint(entvars_t *client, int msg_dest, const char *msg_name, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL, const char *param4 = NULL);
#else
inline void ClientPrint(entvars_t *client, int msg_dest, const char *msg_name, const char *param1 = NULL, const char *param2 = NULL, const char *param3 = NULL, const char *param4 = NULL) { }
#endif
extern void UTIL_SayText(const char *pText, CBaseEntity *pEntity);
extern void UTIL_SayTextAll(const char *pText, CBaseEntity *pEntity);

typedef struct hudtextparms_s
{
	float x;
	float y;
	int effect;
	byte r1, g1, b1, a1;
	byte r2, g2, b2, a2;
	float fadeinTime;
	float fadeoutTime;
	float holdTime;
	float fxTime;
	int channel;
}
hudtextparms_t;

extern void UTIL_HudMessageAll(const hudtextparms_t &textparms, const char *pMessage);
extern void UTIL_HudMessage(CBaseEntity *pEntity, const hudtextparms_t &textparms, const char *pMessage);

extern char *UTIL_dtos1(int d);
extern char *UTIL_dtos2(int d);
extern char *UTIL_dtos3(int d);
extern char *UTIL_dtos4(int d);
extern void UTIL_LogPrintf(const char *fmt, ...);
extern float UTIL_DotPoints(const Vector &vecSrc, const Vector &vecCheck, const Vector &vecDir);
extern void UTIL_StripToken(const char *pKey, char *pDest);
extern char UTIL_TextureHit(TraceResult *ptrHit, Vector vecSrc, Vector vecEnd);
extern bool UTIL_IsGame(const char *gameName);
extern float UTIL_GetPlayerGaitYaw(int playerIndex);
extern int UTIL_HumansInGame(bool ignoreSpectators);

extern void SetMovedir(entvars_t *pev);
extern Vector VecBModelOrigin(entvars_t *pevBModel);
extern int BuildChangeList(LEVELLIST *pLevelList, int maxList);

#ifdef DEBUG
void DBG_AssertFunction(BOOL fExpr, const char *szExpr, const char *szFile, int szLine, const char *szMessage);
#define ASSERT(f) DBG_AssertFunction(f, #f, __FILE__, __LINE__, NULL)
#define ASSERTSZ(f, sz)	DBG_AssertFunction(f, #f, __FILE__, __LINE__, sz)
#else
#define ASSERT(f)
#define ASSERTSZ(f, sz)
#endif

extern DLL_GLOBAL const Vector g_vecZero;

#define LANGUAGE_ENGLISH 0
#define LANGUAGE_GERMAN 1
#define LANGUAGE_FRENCH 2
#define LANGUAGE_BRITISH 3

extern DLL_GLOBAL int g_Language;

#define AMBIENT_SOUND_STATIC 0
#define AMBIENT_SOUND_EVERYWHERE 1
#define AMBIENT_SOUND_SMALLRADIUS 2
#define AMBIENT_SOUND_MEDIUMRADIUS 4
#define AMBIENT_SOUND_LARGERADIUS 8
#define AMBIENT_SOUND_START_SILENT 16
#define AMBIENT_SOUND_NOT_LOOPING 32

#define SPEAKER_START_SILENT 1

#define SND_SPAWNING (1<<8)
#define SND_STOP (1<<5)
#define SND_CHANGE_VOL (1<<6)
#define SND_CHANGE_PITCH (1<<7)

#define LFO_SQUARE 1
#define LFO_TRIANGLE 2
#define LFO_RANDOM 3

#define SF_BRUSH_ROTATE_Y_AXIS 0
#define SF_BRUSH_ROTATE_INSTANT 1
#define SF_BRUSH_ROTATE_BACKWARDS 2
#define SF_BRUSH_ROTATE_Z_AXIS 4
#define SF_BRUSH_ROTATE_X_AXIS 8
#define SF_PENDULUM_AUTO_RETURN 16
#define SF_PENDULUM_PASSABLE 32

#define SF_BRUSH_ROTATE_SMALLRADIUS 128
#define SF_BRUSH_ROTATE_MEDIUMRADIUS 256
#define SF_BRUSH_ROTATE_LARGERADIUS 512

#define PUSH_BLOCK_ONLY_X 1
#define PUSH_BLOCK_ONLY_Y 2

#define VEC_HULL_MIN Vector(-16, -16, -36)
#define VEC_HULL_MAX Vector(16, 16, 36)
#define VEC_HUMAN_HULL_MIN Vector(-16, -16, 0)
#define VEC_HUMAN_HULL_MAX Vector(16, 16, 72)
#define VEC_HUMAN_HULL_DUCK Vector(16, 16, 36)

#define VEC_VIEW Vector(0, 0, 17)

#define VEC_DUCK_HULL_MIN Vector(-16, -16, -18)
#define VEC_DUCK_HULL_MAX Vector(16, 16, 32)
#define VEC_DUCK_VIEW Vector(0, 0, 12)

#define SVC_TEMPENTITY 23
#define SVC_INTERMISSION 30
#define SVC_CDTRACK 32
#define SVC_WEAPONANIM 35
#define SVC_ROOMTYPE 37
#define SVC_DIRECTOR 51

#define SF_TRIGGER_ALLOWMONSTERS 1
#define SF_TRIGGER_NOCLIENTS 2
#define SF_TRIGGER_PUSHABLES 4

#define SF_BREAK_TRIGGER_ONLY 1
#define SF_BREAK_TOUCH 2
#define SF_BREAK_PRESSURE 4
#define SF_BREAK_CROWBAR 256

#define SF_PUSH_BREAKABLE 128

#define SF_LIGHT_START_OFF 1

#define SPAWNFLAG_NOMESSAGE 1
#define SPAWNFLAG_NOTOUCH 1
#define SPAWNFLAG_DROIDONLY 4

#define SPAWNFLAG_USEONLY 1

#define TELE_PLAYER_ONLY 1
#define TELE_SILENT 2

#define SF_TRIG_PUSH_ONCE 1

#define CBSENTENCENAME_MAX 16
#define CVOXFILESENTENCEMAX 1536

extern char gszallsentencenames[CVOXFILESENTENCEMAX][CBSENTENCENAME_MAX];
extern int gcallsentences;

int USENTENCEG_Pick(int isentenceg, char *szfound);
int USENTENCEG_PickSequential(int isentenceg, char *szfound, int ipick, int freset);
void USENTENCEG_InitLRU(unsigned char *plru, int count);

void SENTENCEG_Init(void);
void SENTENCEG_Stop(edict_t *entity, int isentenceg, int ipick);
int SENTENCEG_PlayRndI(edict_t *entity, int isentenceg, float volume, float attenuation, int flags, int pitch);
int SENTENCEG_PlayRndSz(edict_t *entity, const char *szrootname, float volume, float attenuation, int flags, int pitch);
int SENTENCEG_PlaySequentialSz(edict_t *entity, const char *szrootname, float volume, float attenuation, int flags, int pitch, int ipick, int freset);
int SENTENCEG_GetIndex(const char *szrootname);
int SENTENCEG_Lookup(const char *sample, char *sentencenum);

void TEXTURETYPE_Init(void);
char TEXTURETYPE_Find(char *name);
float TEXTURETYPE_PlaySound(TraceResult *ptr, Vector vecSrc, Vector vecEnd, int iBulletType);

#ifndef CLIENT_WEAPONS
void EMIT_SOUND_DYN(edict_t *entity, int channel, const char *sample, float volume, float attenuation, int flags, int pitch);
#else
inline void EMIT_SOUND_DYN(edict_t *entity, int channel, const char *sample, float volume, float attenuation, int flags, int pitch) { }
#endif

inline void EMIT_SOUND(edict_t *entity, int channel, const char *sample, float volume, float attenuation)
{
	EMIT_SOUND_DYN(entity, channel, sample, volume, attenuation, 0, PITCH_NORM);
}

inline void STOP_SOUND(edict_t *entity, int channel, const char *sample)
{
	EMIT_SOUND_DYN(entity, channel, sample, 0, 0, SND_STOP, PITCH_NORM);
}

void EMIT_SOUND_SUIT(edict_t *entity, const char *sample);
void EMIT_GROUPID_SUIT(edict_t *entity, int isentenceg);
void EMIT_GROUPNAME_SUIT(edict_t *entity, const char *groupname);

#define PRECACHE_SOUND_ARRAY(a) \
{ for (int i = 0; i < (int)(ARRAYSIZE(a)); i++) PRECACHE_SOUND((char *) a [i]); }

#define EMIT_SOUND_ARRAY_DYN(chan, array) \
	EMIT_SOUND_DYN(ENT(pev), chan, array[RANDOM_LONG(0,A RRAYSIZE(array) - 1)], 1, ATTN_NORM, 0, RANDOM_LONG(95, 105));

#define RANDOM_SOUND_ARRAY(array) (array)[RANDOM_LONG(0, ARRAYSIZE((array)) - 1)]

#define PLAYBACK_EVENT(flags, who, index) PLAYBACK_EVENT_FULL(flags, who, index, 0, (float *)&g_vecZero, (float *)&g_vecZero, 0.0, 0.0, 0, 0, 0, 0);
#define PLAYBACK_EVENT_DELAY(flags, who, index, delay) PLAYBACK_EVENT_FULL(flags, who, index, delay, (float *)&g_vecZero, (float *)&g_vecZero, 0.0, 0.0, 0, 0, 0, 0);

#define GROUP_OP_AND 0
#define GROUP_OP_NAND 1

extern int g_groupmask;
extern int g_groupop;

class UTIL_GroupTrace
{
public:
	UTIL_GroupTrace(int groupmask, int op);
	~UTIL_GroupTrace(void);

private:
	int m_oldgroupmask, m_oldgroupop;
};

void UTIL_SetGroupTrace(int groupmask, int op);
void UTIL_UnsetGroupTrace(void);

int UTIL_SharedRandomLong(unsigned int seed, int low, int high);
float UTIL_SharedRandomFloat(unsigned int seed, float low, float high);

#ifndef CLIENT_WEAPONS
float UTIL_WeaponTimeBase(void);
#else
inline float UTIL_WeaponTimeBase( void ) { return 0; }
#endif
#endif // util_h__

```

`dlls/vector.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification ofthissource code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef VECTOR_H
#define VECTOR_H

//=========================================================
// 2DVector - used for many pathfinding and many other 
// operations that are treated as planar rather than 3d.
//=========================================================
class Vector2D
{
public:
	inline Vector2D(void): x(0.0), y(0.0)							{ }
	inline Vector2D(float X, float Y): x(0.0), y(0.0)				{ x = X; y = Y; }
	inline Vector2D operator+(const Vector2D& v)	const	{ return Vector2D(x+v.x, y+v.y);}
	inline Vector2D operator-(const Vector2D& v)	const	{ return Vector2D(x-v.x, y-v.y);}
	inline Vector2D operator*(float fl)				const	{ return Vector2D(x*fl, y*fl);}
	inline Vector2D operator/(float fl)				const	{ return Vector2D(x/fl, y/fl);}
	
	inline float Length(void)						const	{ return sqrt(x*x + y*y);	}

	inline Vector2D Normalize (void) const
	{

		float flLen = Length();
		if (flLen == 0)
		{
			return Vector2D( 0, 0);
		}
		else
		{
			flLen = 1 / flLen;
			return Vector2D( x * flLen, y * flLen );
		}
	}

	vec_t	x, y;
};

inline float DotProduct(const Vector2D& a, const Vector2D& b) { return( a.x*b.x + a.y*b.y); }
inline Vector2D operator*(float fl, const Vector2D& v)	{ return v * fl; }

//=========================================================
// 3D Vector
//=========================================================
class Vector // same data-layout as engine's vec3_t,
{							//		which is a vec_t[3]
public:
	// Construction/destruction
	inline Vector(void): x(0.0), y(0.0), z(0.0)					{ }
	inline Vector(float X, float Y, float Z): x(0.0), y(0.0), z(0.0)	{ x = X; y = Y; z = Z;			}
	//inline Vector(double X, double Y, double Z)		{ x = (float)X; y = (float)Y; z = (float)Z;}
	//inline Vector(int X, int Y, int Z)				{ x = (float)X; y = (float)Y; z = (float)Z;}
	inline Vector(const Vector& v): x(0.0), y(0.0), z(0.0)		{ x = v.x; y = v.y; z = v.z;			} 
	inline Vector(float rgfl[3]): x(0.0), y(0.0), z(0.0)		{ x = rgfl[0]; y = rgfl[1]; z = rgfl[2];}

	// Operators
	inline Vector operator-(void) const				{ return Vector(-x,-y,-z);			}
	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;}
	inline int operator!=(const Vector& v) const	{ return !(*this==v);				}
	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);}
	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);}
	inline Vector operator*(float fl) const			{ return Vector(x*fl, y*fl, z*fl);	}
	inline Vector operator/(float fl) const			{ return Vector(x/fl, y/fl, z/fl);	}
	
	// Methods
	inline void CopyToArray(float* rgfl) const		{ rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; }
	inline float Length(void) const					{ return sqrt(x*x + y*y + z*z); }
	operator float *()								{ return &x; } // Vectors will now automatically convert to float * when needed
	operator const float *() const					{ return &x; } // Vectors will now automatically convert to float * when needed
	inline Vector Normalize(void) const
	{
		float flLen = Length();
		if (flLen == 0) return Vector(0,0,1); // ????
		flLen = 1 / flLen;
		return Vector(x * flLen, y * flLen, z * flLen);
	}

	inline Vector2D Make2D (void) const
	{
		Vector2D	Vec2;

		Vec2.x = x;
		Vec2.y = y;

		return Vec2;
	}
	inline float Length2D(void) const					{ return sqrt(x*x + y*y); }

	// Members
	vec_t x, y, z;
};
inline Vector operator*(float fl, const Vector& v)	{ return v * fl; }
inline float DotProduct(const Vector& a, const Vector& b) { return(a.x*b.x+a.y*b.y+a.z*b.z); }
inline Vector CrossProduct(const Vector& a, const Vector& b) { return Vector(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }


#endif

```

`dlls/weapons.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef WEAPONS_H
#define WEAPONS_H

#include "effects.h"

class CBasePlayer;
extern int gmsgWeapPickup;
extern int gmsgReloadSound;

class CGrenade : public CBaseMonster
{
public:
	void Spawn(void);
	int Save(CSave &save);
	int Restore(CRestore &restore);
	virtual void BounceSound(void);
	int ObjectCaps(void) { return m_bIsC4 != false ? FCAP_CONTINUOUS_USE : 0; }
	int BloodColor(void) { return DONT_BLEED; }
	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	void Killed(entvars_t *pevAttacker, int iGib);

public:
	typedef enum { SATCHEL_DETONATE = 0, SATCHEL_RELEASE } SATCHELCODE;

public:
#ifndef CLIENT_DLL
	static CGrenade *ShootTimed(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time);
	static CGrenade *ShootTimed2(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time, int iTeam, unsigned short usEvent);
	static CGrenade *ShootContact(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity);
	static CGrenade *ShootSmokeGrenade(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time, unsigned short usEvent);
	static CGrenade *ShootSatchelCharge(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity);
#else
	static CGrenade *ShootTimed(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time) { return NULL; }
	static CGrenade *ShootTimed2(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time, int iTeam, unsigned short usEvent) { return NULL; }
	static CGrenade *ShootContact(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity) { return NULL; }
	static CGrenade *ShootSmokeGrenade(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time, unsigned short usEvent) { return NULL; }
	static CGrenade *ShootSatchelCharge(entvars_t *pevOwner, Vector vecStart, Vector vecVelocity) { return NULL; }
#endif
	static void UseSatchelCharges(entvars_t *pevOwner, SATCHELCODE code);

public:
	void Explode(Vector vecSrc, Vector vecAim);
	void Explode(TraceResult *pTrace, int bitsDamageType);
	void Explode2(TraceResult *pTrace, int bitsDamageType);
	void Explode3(TraceResult *pTrace, int bitsDamageType);
	void EXPORT Smoke(void);
	void EXPORT SG_Smoke(void);
	void EXPORT Smoke2(void);
	void EXPORT Smoke3_A(void);
	void EXPORT Smoke3_B(void);
	void EXPORT Smoke3_C(void);
	void EXPORT BounceTouch(CBaseEntity *pOther);
	void EXPORT SlideTouch(CBaseEntity *pOther);
	void EXPORT ExplodeTouch(CBaseEntity *pOther);
	void EXPORT DangerSoundThink(void);
	void EXPORT PreDetonate(void);
	void EXPORT Detonate(void);
	void EXPORT SG_Detonate(void);
	void EXPORT Detonate2(void);
	void EXPORT Detonate3(void);
	void EXPORT DetonateUse(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	void EXPORT TumbleThink(void);
	void EXPORT SG_TumbleThink(void);
	void EXPORT C4Think(void);
	void EXPORT C4Touch(CBaseEntity *pOther) {}

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	bool m_bStartDefuse;
	bool m_bIsC4;
	EHANDLE m_pBombDefuser;
	float m_flDefuseCountDown;
	float m_flC4Blow;
	float m_flNextFreqInterval;
	float m_flNextBeep;
	float m_flNextFreq;
	char *m_sBeepName;
	float m_fAttenu;
	float m_flNextBlink;
	float m_fNextDefuse;
	bool m_bJustBlew;
	int m_iTeam;
	int m_iCurWave;
	edict_t *m_pentCurBombTarget;
	int m_SGSmoke;
	int m_angle;
	unsigned short m_usEvent;
	bool m_bLightSmoke;
	bool m_bDetonated;
	Vector m_vSmokeDetonate;
	int m_iBounceCount;
	BOOL m_fRegisteredSound;
};

#define ITEM_HEALTHKIT 1
#define ITEM_ANTIDOTE 2
#define ITEM_SECURITY 3
#define ITEM_BATTERY 4

enum WeaponIdType
{
	WEAPON_NONE,
	WEAPON_P228,
	WEAPON_GLOCK,
	WEAPON_SCOUT,
	WEAPON_HEGRENADE,
	WEAPON_XM1014,
	WEAPON_C4,
	WEAPON_MAC10,
	WEAPON_AUG,
	WEAPON_SMOKEGRENADE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_UMP45,
	WEAPON_SG550,
	WEAPON_GALIL,
	WEAPON_FAMAS,
	WEAPON_USP,
	WEAPON_GLOCK18,
	WEAPON_AWP,
	WEAPON_MP5N,
	WEAPON_M249,
	WEAPON_M3,
	WEAPON_M4A1,
	WEAPON_TMP,
	WEAPON_G3SG1,
	WEAPON_FLASHBANG,
	WEAPON_DEAGLE,
	WEAPON_SG552,
	WEAPON_AK47,
	WEAPON_KNIFE,
	WEAPON_P90,
	WEAPON_SHIELDGUN = 99
};

#define WEAPON_ALLWEAPONS (~(1 << WEAPON_SUIT))
#define WEAPON_SUIT 31
#define MAX_WEAPONS 32

#define AK47_WEIGHT 25
#define AUG_WEIGHT 25
#define AWP_WEIGHT 30
#define C4_WEIGHT 3
#define DEAGLE_WEIGHT 7
#define ELITE_WEIGHT 5
#define FAMAS_WEIGHT 75
#define FIVESEVEN_WEIGHT 5
#define FLASHBANG_WEIGHT 1
#define G3SG1_WEIGHT 20
#define GALIL_WEIGHT 25
#define GLOCK18_WEIGHT 5
#define HEGRENADE_WEIGHT 2
#define KNIFE_WEIGHT 0
#define M249_WEIGHT 25
#define M3_WEIGHT 20
#define M4A1_WEIGHT 25
#define MAC10_WEIGHT 25
#define MP5NAVY_WEIGHT 25
#define P228_WEIGHT 5
#define P90_WEIGHT 26
#define SCOUT_WEIGHT 30
#define SG550_WEIGHT 20
#define SG552_WEIGHT 25
#define SMOKEGRENADE_WEIGHT 1
#define TMP_WEIGHT 25
#define UMP45_WEIGHT 25
#define USP_WEIGHT 5
#define XM1014_WEIGHT 20

#define MAX_NORMAL_BATTERY 100

#define WEAPON_NOCLIP -1

#define AK47_DEFAULT_GIVE 30
#define AUG_DEFAULT_GIVE 30
#define AWP_DEFAULT_GIVE 10
#define C4_DEFAULT_GIVE 1
#define DEAGLE_DEFAULT_GIVE 7
#define ELITE_DEFAULT_GIVE 30
#define FAMAS_DEFAULT_GIVE 25
#define FIVESEVEN_DEFAULT_GIVE 20
#define FLASHBANG_DEFAULT_GIVE 1
#define G3SG1_DEFAULT_GIVE 20
#define GALIL_DEFAULT_GIVE 35
#define GLOCK18_DEFAULT_GIVE 20
#define HEGRENADE_DEFAULT_GIVE 1
#define M249_DEFAULT_GIVE 100
#define M3_DEFAULT_GIVE 8
#define M4A1_DEFAULT_GIVE 30
#define MAC10_DEFAULT_GIVE 30
#define MP5NAVY_DEFAULT_GIVE 30
#define P228_DEFAULT_GIVE 13
#define P90_DEFAULT_GIVE 50
#define SCOUT_DEFAULT_GIVE 10
#define SG550_DEFAULT_GIVE 30
#define SG552_DEFAULT_GIVE 30
#define MAC10_DEFAULT_GIVE 30
#define SMOKEGRENADE_DEFAULT_GIVE 1
#define TMP_DEFAULT_GIVE 30
#define UMP45_DEFAULT_GIVE 25
#define USP_DEFAULT_GIVE 12
#define XM1014_DEFAULT_GIVE 7

#define AMMO_9MM_GIVE 30
#define AMMO_BUCKSHOT_GIVE 8
#define AMMO_556NATO_GIVE 30
#define AMMO_556NATOBOX_GIVE 30
#define AMMO_762NATO_GIVE 30
#define AMMO_45ACP_GIVE 12
#define AMMO_50AE_GIVE 7
#define AMMO_338MAGNUM_GIVE 10
#define AMMO_57MM_GIVE 50
#define AMMO_357SIG_GIVE 13

#define _9MM_MAX_CARRY MAX_AMMO_9MM
#define BUCKSHOT_MAX_CARRY MAX_AMMO_BUCKSHOT
#define _556NATO_MAX_CARRY MAX_AMMO_556NATO
#define _556NATOBOX_MAX_CARRY MAX_AMMO_556NATOBOX
#define _762NATO_MAX_CARRY MAX_AMMO_762NATO
#define _45ACP_MAX_CARRY MAX_AMMO_45ACP
#define _50AE_MAX_CARRY MAX_AMMO_50AE
#define _338MAGNUM_MAX_CARRY MAX_AMMO_338MAGNUM
#define _57MM_MAX_CARRY MAX_AMMO_57MM
#define _357SIG_MAX_CARRY MAX_AMMO_357SIG

#define HEGRENADE_MAX_CARRY 1
#define FLASHBANG_MAX_CARRY 2
#define SMOKEGRENADE_MAX_CARRY 1
#define C4_MAX_CARRY 1

enum AmmoCostType
{
	AMMO_338MAG_PRICE = 125,
	AMMO_357SIG_PRICE = 50,
	AMMO_45ACP_PRICE = 25,
	AMMO_50AE_PRICE = 40,
	AMMO_556NATO_PRICE = 60,
	AMMO_57MM_PRICE = 50,
	AMMO_762NATO_PRICE = 80,
	AMMO_9MM_PRICE = 20,
	AMMO_BUCKSHOT_PRICE = 65
};

enum WeaponCostType
{
	AK47_PRICE = 2500,
	AWP_PRICE = 4750,
	DEAGLE_PRICE = 650,
	G3SG1_PRICE = 5000,
	SG550_PRICE = 4200,
	GLOCK18_PRICE = 400,
	M249_PRICE = 5750,
	M3_PRICE = 1700,
	M4A1_PRICE = 3100,
	AUG_PRICE = 3500,
	MP5NAVY_PRICE = 1500,
	P228_PRICE = 600,
	P90_PRICE = 2350,
	UMP45_PRICE = 1700,
	MAC10_PRICE = 1400,
	SCOUT_PRICE = 2750,
	SG552_PRICE = 3500,
	TMP_PRICE = 1250,
	USP_PRICE = 500,
	ELITE_PRICE = 800,
	FIVESEVEN_PRICE = 750,
	XM1014_PRICE = 3000,
	GALIL_PRICE = 2000,
	FAMAS_PRICE = 2250,
	SHIELDGUN_PRICE = 2200
};

enum ItemCostType
{
	ASSAULTSUIT_PRICE = 1000,
	FLASHBANG_PRICE = 200,
	HEGRENADE_PRICE = 300,
	SMOKEGRENADE_PRICE = 300,
	KEVLAR_PRICE = 650,
	HELMET_PRICE = 350,
	NVG_PRICE = 1250,
	DEFUSEKIT_PRICE = 200
};

enum ClipSizeType
{
	P228_MAX_CLIP = 13,
	GLOCK18_MAX_CLIP = 20,
	SCOUT_MAX_CLIP = 10,
	XM1014_MAX_CLIP = 7,
	MAC10_MAX_CLIP = 30,
	AUG_MAX_CLIP = 30,
	ELITE_MAX_CLIP = 30,
	FIVESEVEN_MAX_CLIP = 20,
	UMP45_MAX_CLIP = 25,
	SG550_MAX_CLIP = 30,
	GALIL_MAX_CLIP = 35,
	FAMAS_MAX_CLIP = 25,
	USP_MAX_CLIP = 12,
	AWP_MAX_CLIP = 10,
	MP5N_MAX_CLIP = 30,
	M249_MAX_CLIP = 100,
	M3_MAX_CLIP = 8,
	M4A1_MAX_CLIP = 30,
	TMP_MAX_CLIP = 30,
	G3SG1_MAX_CLIP = 20,
	DEAGLE_MAX_CLIP = 7,
	SG552_MAX_CLIP = 30,
	AK47_MAX_CLIP = 30,
	P90_MAX_CLIP = 50
};

enum MaxAmmoType
{
	MAX_AMMO_BUCKSHOT = 32,
	MAX_AMMO_9MM = 120,
	MAX_AMMO_556NATO = 90,
	MAX_AMMO_556NATOBOX = 200,
	MAX_AMMO_762NATO = 90,
	MAX_AMMO_45ACP = 100,
	MAX_AMMO_50AE = 35,
	MAX_AMMO_338MAGNUM = 30,
	MAX_AMMO_57MM = 100,
	MAX_AMMO_357SIG = 52
};

enum AmmoType
{
	AMMO_BUCKSHOT,
	AMMO_9MM,
	AMMO_556NATO,
	AMMO_556NATOBOX,
	AMMO_762NATO,
	AMMO_45ACP,
	AMMO_50AE,
	AMMO_338MAGNUM,
	AMMO_57MM,
	AMMO_357SIG,
	AMMO_MAX_TYPES
};

typedef struct
{
	int id;
	int cost;
	int clipCost;
	int buyClipSize;
	int gunClipSize;
	int maxRounds;
	int ammoType;
	char *entityName;
}
WeaponInfoStruct;

enum WeaponClassType
{
	WEAPONCLASS_NONE,
	WEAPONCLASS_KNIFE,
	WEAPONCLASS_PISTOL,
	WEAPONCLASS_GRENADE,
	WEAPONCLASS_SUBMACHINEGUN,
	WEAPONCLASS_SHOTGUN,
	WEAPONCLASS_MACHINEGUN,
	WEAPONCLASS_RIFLE,
	WEAPONCLASS_SNIPERRIFLE,
	WEAPONCLASS_MAX
};

enum AutoBuyClassType
{
	AUTOBUYCLASS_PRIMARY = 1,
	AUTOBUYCLASS_SECONDARY = 2,
	AUTOBUYCLASS_AMMO = 4,
	AUTOBUYCLASS_ARMOR = 8,
	AUTOBUYCLASS_DEFUSER = 16,
	AUTOBUYCLASS_PISTOL = 32,
	AUTOBUYCLASS_SMG = 64,
	AUTOBUYCLASS_RIFLE = 128,
	AUTOBUYCLASS_SNIPERRIFLE = 256,
	AUTOBUYCLASS_SHOTGUN = 512,
	AUTOBUYCLASS_MACHINEGUN = 1024,
	AUTOBUYCLASS_GRENADE = 2048,
	AUTOBUYCLASS_NIGHTVISION = 4096,
	AUTOBUYCLASS_SHIELD = 8192
};

typedef struct
{
	int m_class;
	char *m_command;
	char *m_classname;
}
AutoBuyInfoStruct;

typedef struct
{
	char *alias;
	int id;
}
WeaponAliasInfo;

typedef struct
{
	char *alias;
	int id;
	char *failName;
}
WeaponBuyAliasInfo;

typedef struct
{
	char *alias;
	int id;
}
WeaponClassAliasInfo;

enum AmmoBuyAmount
{
	AMMO_338MAG_BUY = 10,
	AMMO_357SIG_BUY = 13,
	AMMO_45ACP_BUY = 12,
	AMMO_50AE_BUY = 7,
	AMMO_556NATO_BUY = 30,
	AMMO_556NATOBOX_BUY = 30,
	AMMO_57MM_BUY = 50,
	AMMO_762NATO_BUY = 30,
	AMMO_9MM_BUY = 30,
	AMMO_BUCKSHOT_BUY = 8
};

enum shieldgun_e
{
	SHIELDGUN_IDLE,
	SHIELDGUN_SHOOT1,
	SHIELDGUN_SHOOT2,
	SHIELDGUN_SHOOT_EMPTY,
	SHIELDGUN_RELOAD,
	SHIELDGUN_DRAW,
	SHIELDGUN_DRAWN_IDLE,
	SHIELDGUN_UP,
	SHIELDGUN_DOWN
};

enum shieldren_e
{
	SHIELDREN_IDLE = 4,
	SHIELDREN_UP,
	SHIELDREN_DOWN
};

typedef enum
{
	BULLET_NONE = 0,
	BULLET_PLAYER_9MM,
	BULLET_PLAYER_MP5,
	BULLET_PLAYER_357,
	BULLET_PLAYER_BUCKSHOT,
	BULLET_PLAYER_CROWBAR,

	BULLET_MONSTER_9MM,
	BULLET_MONSTER_MP5,
	BULLET_MONSTER_12MM,

	BULLET_PLAYER_45ACP,
	BULLET_PLAYER_338MAG,
	BULLET_PLAYER_762MM,
	BULLET_PLAYER_556MM,
	BULLET_PLAYER_50AE,
	BULLET_PLAYER_57MM,
	BULLET_PLAYER_357SIG
}
Bullet;

#define ITEM_FLAG_SELECTONEMPTY 1
#define ITEM_FLAG_NOAUTORELOAD 2
#define ITEM_FLAG_NOAUTOSWITCHEMPTY 4
#define ITEM_FLAG_LIMITINWORLD 8
#define ITEM_FLAG_EXHAUSTIBLE 16

#define WPNSLOT_PRIMARY 1
#define WPNSLOT_SECONDARY 2
#define WPNSLOT_KNIFE 3
#define WPNSLOT_GRENADE 4
#define WPNSLOT_C4 5

#define WPNSTATE_USP_SILENCED (1<<0)
#define WPNSTATE_GLOCK18_BURST_MODE (1<<1)
#define WPNSTATE_M4A1_SILENCED (1<<2)
#define WPNSTATE_ELITE_LEFT (1<<3)
#define WPNSTATE_FAMAS_BURST_MODE (1<<4)
#define WPNSTATE_SHIELD_DRAWN (1<<5)

#define WEAPON_IS_ONTARGET 0x40

typedef struct
{
	int iSlot;
	int iPosition;
	const char *pszAmmo1;
	int iMaxAmmo1;
	const char *pszAmmo2;
	int iMaxAmmo2;
	const char *pszName;
	int iMaxClip;
	int iId;
	int iFlags;
	int iWeight;
}
ItemInfo;

typedef struct
{
	const char *pszName;
	int iId;
}
AmmoInfo;

class CBasePlayerItem : public CBaseAnimating
{
public:
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual void SetObjectCollisionBox(void) { }
	virtual int AddToPlayer(CBasePlayer *pPlayer) { return false; }
	virtual int AddDuplicate(CBasePlayerItem *pItem) { return FALSE; }
	virtual int GetItemInfo(ItemInfo *p) { return 0; }
	virtual BOOL CanDeploy(void) { return TRUE; }
	virtual BOOL CanDrop(void) { return TRUE; }
	virtual BOOL Deploy(void) { return TRUE; }
	virtual BOOL IsWeapon(void) { return FALSE; }
	virtual BOOL CanHolster(void) { return TRUE; }
	virtual void Holster(int skiplocal = 0) {}
	virtual void UpdateItemInfo(void) {}
	virtual void ItemPreFrame(void) {}
	virtual void ItemPostFrame(void) {}
	virtual void Drop(void) {}
	virtual void Kill(void) {}
	virtual void AttachToPlayer(CBasePlayer *pPlayer) {}
	virtual int PrimaryAmmoIndex(void) { return -1; }
	virtual int SecondaryAmmoIndex(void) { return -1; }
	virtual int UpdateClientData(CBasePlayer *pPlayer) { return 0; }
	virtual CBasePlayerItem *GetWeaponPtr(void) { return NULL; }
	virtual float GetMaxSpeed(void) { return 260; }
	virtual int iItemSlot(void) { return 0; }

public:
	void EXPORT DestroyItem(void) {}
	void EXPORT DefaultTouch(CBaseEntity *pOther) {}
	void EXPORT FallThink(void) {}
	void EXPORT Materialize(void) {}
	void EXPORT AttemptToMaterialize(void) {}
	CBaseEntity *Respawn(void) { return this; }
	void FallInit(void) { }
	void CheckRespawn(void) {}

public:
	static TYPEDESCRIPTION m_SaveData[];
	static ItemInfo ItemInfoArray[MAX_WEAPONS];
	static AmmoInfo AmmoInfoArray[MAX_AMMO_SLOTS];

public:
	CBasePlayer *m_pPlayer;
	CBasePlayerItem *m_pNext;
	int m_iId;

public:
	int iItemPosition(void) { return ItemInfoArray[m_iId].iPosition; }
	const char *pszAmmo1(void) { return ItemInfoArray[m_iId].pszAmmo1; }
	int iMaxAmmo1(void) { return ItemInfoArray[m_iId].iMaxAmmo1; }
	const char *pszAmmo2(void) { return ItemInfoArray[m_iId].pszAmmo2; }
	int iMaxAmmo2(void) { return ItemInfoArray[m_iId].iMaxAmmo2; }
	const char *pszName(void) { return ItemInfoArray[m_iId].pszName; }
	int iMaxClip(void) { return ItemInfoArray[m_iId].iMaxClip; }
	int iWeight(void) { return ItemInfoArray[m_iId].iWeight; }
	int iFlags(void) { return ItemInfoArray[m_iId].iFlags; }
};

class CBasePlayerWeapon : public CBasePlayerItem
{
public:
	virtual int Save(CSave &save) { return 1; }
	virtual int Restore(CRestore &restore) { return 1; }
	virtual int AddToPlayer(CBasePlayer *pPlayer) { return 0; }
	virtual int AddDuplicate(CBasePlayerItem *pItem) { return 0; }
	virtual int ExtractAmmo(CBasePlayerWeapon *pWeapon) { return 0; }
	virtual int ExtractClipAmmo(CBasePlayerWeapon *pWeapon) { return 0; }
	virtual int AddWeapon(void) { ExtractAmmo(this); return TRUE; }
	virtual void UpdateItemInfo(void) {}
	virtual BOOL PlayEmptySound(void);
	virtual void ResetEmptySound(void);
	virtual void SendWeaponAnim(int iAnim, int skiplocal = 0);
	virtual BOOL CanDeploy(void);
	virtual BOOL IsWeapon(void) { return TRUE; }
	virtual BOOL IsUseable(void) { return true; }
	virtual void ItemPostFrame(void);
	virtual void PrimaryAttack(void) {}
	virtual void SecondaryAttack(void) {}
	virtual void Reload(void) {}
	virtual void WeaponIdle(void) {}
	virtual int UpdateClientData(CBasePlayer *pPlayer) { return 0; }
	virtual void RetireWeapon(void);
	virtual BOOL ShouldWeaponIdle(void) { return FALSE; }
	virtual void Holster(int skiplocal = 0);
	virtual BOOL UseDecrement(void) { return FALSE; }
	virtual CBasePlayerItem *GetWeaponPtr(void) { return (CBasePlayerItem *)this; }

public:
	BOOL DefaultDeploy(const char *szViewModel, const char *szWeaponModel, int iAnim, const char *szAnimExt, int skiplocal = 0);
	int DefaultReload(int iClipSize, int iAnim, float fDelay, int body = 0);
	void ReloadSound(void);
	BOOL AddPrimaryAmmo(int iCount, char *szName, int iMaxClip, int iMaxCarry) { return true; }
	BOOL AddSecondaryAmmo(int iCount, char *szName, int iMaxCarry) { return true; }
	int PrimaryAmmoIndex(void) { return -1; }
	int SecondaryAmmoIndex(void) { return -1; }
	void EjectBrassLate(void);
	void KickBack(float up_base, float lateral_base, float up_modifier, float lateral_modifier, float up_max, float lateral_max, int direction_change);
	void FireRemaining(int &shotsFired, float &shootTime, BOOL isGlock18);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);
	bool HasSecondaryAttack(void);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	int m_iPlayEmptySound;
	int m_fFireOnEmpty;
	float m_flNextPrimaryAttack;
	float m_flNextSecondaryAttack;
	float m_flTimeWeaponIdle;
	int m_iPrimaryAmmoType;
	int m_iSecondaryAmmoType;
	int m_iClip;
	int m_iClientClip;
	int m_iClientWeaponState;
	int m_fInReload;
	int m_fInSpecialReload;
	int m_iDefaultAmmo;
	int m_iShellId;
	int m_fMaxSpeed;
	bool m_bDelayFire;
	int m_iDirection;
	bool m_bSecondarySilencerOn;
	float m_flAccuracy;
	float m_flLastFire;
	int m_iShotsFired;
	Vector m_vVecAiming;
	string_t model_name;
	float m_flGlock18Shoot;
	int m_iGlock18ShotsFired;
	float m_flFamasShoot;
	int m_iFamasShotsFired;
	float m_fBurstSpread;
	int m_iWeaponState;
	float m_flNextReload;
	float m_flDecreaseShotsFired;
	unsigned short m_usFireGlock18;
	unsigned short m_usFireFamas;
};

class CBasePlayerAmmo : public CBaseEntity
{
public:
	virtual void Spawn(void){}
	virtual BOOL AddAmmo(CBaseEntity *pOther) { return TRUE; }

public:
	void EXPORT Materialize(void) { }
	void EXPORT DefaultTouch(CBaseEntity *pOther) { }
	CBaseEntity *Respawn(void) { return this; }
};

extern DLL_GLOBAL short g_sModelIndexLaser;
extern DLL_GLOBAL const char *g_pModelNameLaser;
extern DLL_GLOBAL short g_sModelIndexLaserDot;
extern DLL_GLOBAL short g_sModelIndexFireball;
extern DLL_GLOBAL short g_sModelIndexFireball2;
extern DLL_GLOBAL short g_sModelIndexFireball3;
extern DLL_GLOBAL short g_sModelIndexFireball4;
extern DLL_GLOBAL short g_sModelIndexSmoke;
extern DLL_GLOBAL short g_sModelIndexSmokePuff;
extern DLL_GLOBAL short g_sModelIndexWExplosion;
extern DLL_GLOBAL short g_sModelIndexBubbles;
extern DLL_GLOBAL short g_sModelIndexBloodDrop;
extern DLL_GLOBAL short g_sModelIndexBloodSpray;
extern DLL_GLOBAL short g_sModelIndexRadio;
extern DLL_GLOBAL short g_sModelIndexCTGhost;
extern DLL_GLOBAL short g_sModelIndexTGhost;
extern DLL_GLOBAL short g_sModelIndexC4Glow;

#ifndef CLIENT_WEAPONS
extern void ClearMultiDamage(void);
extern void ApplyMultiDamage(entvars_t *pevInflictor, entvars_t *pevAttacker);
extern void AddMultiDamage(entvars_t *pevInflictor, CBaseEntity *pEntity, float flDamage, int bitsDamageType);
extern void DecalGunshot(TraceResult *pTrace, int iBulletType, bool ClientOnly, entvars_t *pShooter, bool bHitMetal);
extern void SpawnBlood(Vector vecSpot, int bloodColor, float flDamage);
extern int DamageDecal(CBaseEntity *pEntity, int bitsDamageType);
extern void RadiusFlash(Vector vecSrc, entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage);
extern void RadiusDamage(Vector vecSrc, entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, float flRadius, int iClassIgnore, int bitsDamageType);
#else
inline void ClearMultiDamage(void) { }
inline void ApplyMultiDamage(entvars_t *pevInflictor, entvars_t *pevAttacker) { }
inline void DecalGunshot(TraceResult *pTrace, int iBulletType, bool ClientOnly, entvars_t *pShooter, bool bHitMetal) { }
#endif
typedef struct
{
	CBaseEntity *pEntity;
	float amount;
	int type;
}
MULTIDAMAGE;

extern MULTIDAMAGE gMultiDamage;

#define LOUD_GUN_VOLUME 1000
#define NORMAL_GUN_VOLUME 600
#define QUIET_GUN_VOLUME 200

#define BRIGHT_GUN_FLASH 512
#define NORMAL_GUN_FLASH 256
#define DIM_GUN_FLASH 128

#define BIG_EXPLOSION_VOLUME 2048
#define NORMAL_EXPLOSION_VOLUME 1024
#define SMALL_EXPLOSION_VOLUME 512

#define WEAPON_ACTIVITY_VOLUME 64

#define VECTOR_CONE_1DEGREES Vector(0.00873, 0.00873, 0.00873)
#define VECTOR_CONE_2DEGREES Vector(0.01745, 0.01745, 0.01745)
#define VECTOR_CONE_3DEGREES Vector(0.02618, 0.02618, 0.02618)
#define VECTOR_CONE_4DEGREES Vector(0.03490, 0.03490, 0.03490)
#define VECTOR_CONE_5DEGREES Vector(0.04362, 0.04362, 0.04362)
#define VECTOR_CONE_6DEGREES Vector(0.05234, 0.05234, 0.05234)
#define VECTOR_CONE_7DEGREES Vector(0.06105, 0.06105, 0.06105)
#define VECTOR_CONE_8DEGREES Vector(0.06976, 0.06976, 0.06976)
#define VECTOR_CONE_9DEGREES Vector(0.07846, 0.07846, 0.07846)
#define VECTOR_CONE_10DEGREES Vector(0.08716, 0.08716, 0.08716)
#define VECTOR_CONE_15DEGREES Vector(0.13053, 0.13053, 0.13053)
#define VECTOR_CONE_20DEGREES Vector(0.17365, 0.17365, 0.17365)

class CWeaponBox : public CBaseEntity
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData *pkvd);
	int Save(CSave &save);
	int Restore(CRestore &restore);
	void Touch(CBaseEntity *pOther);
	void SetObjectCollisionBox(void);

public:
	BOOL IsEmpty(void);
	int GiveAmmo(int iCount, char *szName, int iMax, int *pIndex = NULL);
	void EXPORT Kill(void);
	BOOL HasWeapon(CBasePlayerItem *pCheckItem);
	BOOL PackWeapon(CBasePlayerItem *pWeapon);
	BOOL PackAmmo(int iszName, int iCount);

public:
	static TYPEDESCRIPTION m_SaveData[];

public:
	CBasePlayerItem *m_rgpPlayerItems[MAX_ITEM_TYPES];
	int m_rgiszAmmo[MAX_AMMO_SLOTS];
	int m_rgAmmo[MAX_AMMO_SLOTS];
	int m_cAmmoTypes;
};

class CWShield : public CBaseEntity
{
public:
	void Spawn(void);
	void EXPORT Touch(CBaseEntity *pOther);
	void SetCantBePickedUpByUser(CBaseEntity *pEntity, float time);

public:
	EHANDLE m_hEntToIgnoreTouchesFrom;
	float m_flTimeToIgnoreTouches;
};

#ifdef PLAYER_H

class CAK47 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 221; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void AK47Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireAK47;
};

class CAUG : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 240; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	void AUGFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireAug;
};

class CAWP : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void AWPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireAWP;
};

class CC4 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	void KeyValue(KeyValueData *pkvd);
	void Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_C4; }
	void PrimaryAttack(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	bool m_bStartedArming;
	bool m_bBombPlacedAnimation;
	float m_fArmedTime;
	bool m_bHasShield;
};

class CDEAGLE : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void DEAGLEFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireDeagle;
};

class CELITE : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void ELITEFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireELITE_LEFT;
	unsigned short m_usFireELITE_RIGHT;
};

class CFamas : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 240; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void FamasFire(float flSpread, float flCycleTime, BOOL fUseAutoAim, BOOL bFireBurst);

private:
	int m_iShell;
	int iShellOn;
};

class CFiveSeven : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void FiveSevenFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireFiveSeven;
};

class CFlashbang : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL CanDeploy(void);
	BOOL CanDrop(void) { return FALSE; }
	BOOL Deploy(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_GRENADE; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void WeaponIdle(void);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}
};

class CG3SG1 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void G3SG1Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireG3SG1;
};

class CGalil : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 240; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void GalilFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireGalil;
};

class CGLOCK18 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void GLOCK18Fire(float flSpread, float flCycleTime, BOOL fUseBurstMode);

private:
	int m_iShell;
	bool m_bBurstFire;
};

class CHEGrenade : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL CanDeploy(void);
	BOOL CanDrop(void) { return FALSE; }
	BOOL Deploy(void);
	BOOL CanHolster(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_GRENADE; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void WeaponIdle(void);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	unsigned short m_usCreateExplosion;
};

class CKnife : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL CanDrop(void) { return FALSE; }
	BOOL Deploy(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_KNIFE; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	void WeaponAnimation(int iAnimation);
	void EXPORT SwingAgain(void);
	void EXPORT Smack(void);
	int Swing(int fFirst);
	int Stab(int fFirst);

private:
	//int m_iSwing; //Already exists in CBaseDelay
	TraceResult m_trHit;
	unsigned short m_usKnife;
};

class CM249 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 220; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void M249Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireM249;
};

class CM3 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 230; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	int m_iShell;
	float m_flPumpTime;
	unsigned short m_usFireM3;
};

class CM4A1 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 230; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void M4A1Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireM4A1;
};

class CMAC10 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void MAC10Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireMAC10;
};

class CMP5N : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void MP5NFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireMP5N;
};

class CP228 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void P228Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireP228;
};

class CP90 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 245; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void P90Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireP90;
};

class CSCOUT : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void SCOUTFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireScout;
};

class CSG550 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void SG550Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireSG550;
};

class CSG552 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void);
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	void SG552Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireSG552;
};

class CSmokeGrenade : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL CanDeploy(void);
	BOOL CanDrop(void) { return FALSE; }
	BOOL Deploy(void);
	void Holster(int skiplocal);
	float GetMaxSpeed(void) { return m_fMaxSpeed; }
	int iItemSlot(void) { return WPNSLOT_GRENADE; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void WeaponIdle(void);
	void SetPlayerShieldAnim(void);
	void ResetPlayerShieldAnim(void);
	bool ShieldSecondaryFire(int up_anim, int down_anim);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

public:
	unsigned short m_usCreateSmoke;
};

class CTMP : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void TMPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireTMP;
};

class CUMP45 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void UMP45Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	int iShellOn;
	unsigned short m_usFireUMP45;
};

class CUSP : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 250; }
	int iItemSlot(void) { return WPNSLOT_SECONDARY; }
	void PrimaryAttack(void);
	void SecondaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	void USPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim);

private:
	int m_iShell;
	unsigned short m_usFireUSP;
};

class CXM1014 : public CBasePlayerWeapon
{
public:
	void Spawn(void);
	void Precache(void);
	int GetItemInfo(ItemInfo *p);
	BOOL Deploy(void);
	float GetMaxSpeed(void) { return 240; }
	int iItemSlot(void) { return WPNSLOT_PRIMARY; }
	void PrimaryAttack(void);
	void Reload(void);
	void WeaponIdle(void);

	BOOL UseDecrement(void)
	{
#ifdef CLIENT_WEAPONS
		return TRUE;
#else
		return FALSE;
#endif
	}

private:
	int m_iShell;
	float m_flPumpTime;
	unsigned short m_usFireXM1014;
};

#endif

#define ARMOURY_MP5NAVY 0
#define ARMOURY_TMP 1
#define ARMOURY_P90 2
#define ARMOURY_MAC10 3
#define ARMOURY_AK47 4
#define ARMOURY_SG552 5
#define ARMOURY_M4A1 6
#define ARMOURY_AUG 7
#define ARMOURY_SCOUT 8
#define ARMOURY_G3SG1 9
#define ARMOURY_AWP 10
#define ARMOURY_M3 11
#define ARMOURY_XM1014 12
#define ARMOURY_M249 13
#define ARMOURY_FLASHBANG 14
#define ARMOURY_HEGRENADE 15
#define ARMOURY_KEVLAR 16
#define ARMOURY_ASSAULT 17
#define ARMOURY_SMOKEGRENADE 18

class CArmoury : public CBaseEntity
{
public:
	void Spawn(void);
	void Precache(void);
	void Restart(void);
	void KeyValue(KeyValueData *pkvd);

public:
	void EXPORT ArmouryTouch(CBaseEntity *pOther);

public:
	int m_iItem;
	int m_iCount;
	int m_iInitialCount;
	bool m_bAlreadyCounted;
};

#endif

```

`dlls/wpn_shared/wpn_ak47.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum ak47_e
{
	AK47_IDLE1,
	AK47_RELOAD,
	AK47_DRAW,
	AK47_SHOOT1,
	AK47_SHOOT2,
	AK47_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_ak47, CAK47)

void CAK47::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_ak47");

	Precache();
	m_iId = WEAPON_AK47;
	SET_MODEL(ENT(pev), "models/w_ak47.mdl");

	m_iDefaultAmmo = AK47_DEFAULT_GIVE;
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;

	FallInit();
}

void CAK47::Precache(void)
{
	PRECACHE_MODEL("models/v_ak47.mdl");
	PRECACHE_MODEL("models/w_ak47.mdl");

	PRECACHE_SOUND("weapons/ak47-1.wav");
	PRECACHE_SOUND("weapons/ak47-2.wav");
	PRECACHE_SOUND("weapons/ak47_clipout.wav");
	PRECACHE_SOUND("weapons/ak47_clipin.wav");
	PRECACHE_SOUND("weapons/ak47_boltpull.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireAK47 = PRECACHE_EVENT(1, "events/ak47.sc");
}

int CAK47::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "762Nato";
	p->iMaxAmmo1 = _762NATO_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = AK47_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 1;
	p->iId = m_iId = WEAPON_AK47;
	p->iFlags = 0;
	p->iWeight = AK47_WEIGHT;

	return 1;
}

BOOL CAK47::Deploy(void)
{
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_ak47.mdl", "models/p_ak47.mdl", AK47_DRAW, "ak47", UseDecrement() != FALSE);
}

void CAK47::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		AK47Fire(0.04 + (0.4) * m_flAccuracy, 0.0955, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
		AK47Fire(0.04 + (0.07) * m_flAccuracy, 0.0955, FALSE);
	else
		AK47Fire((0.0275), 0.0955, FALSE);
}

void CAK47::AK47Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 200.0) + 0.35;

	if (m_flAccuracy > 1.25)
		m_flAccuracy = 1.25;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);
	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 2, BULLET_PLAYER_762MM, 36, 0.98, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireAK47, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.9;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(1.5, 0.45, 0.225, 0.05, 6.5, 2.5, 7);
	else if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(2.0, 1.0, 0.5, 0.35, 9.0, 6.0, 5);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.9, 0.35, 0.15, 0.025, 5.5, 1.5, 9);
	else
		KickBack(1.0, 0.375, 0.175, 0.0375, 5.75, 1.75, 8);
}

void CAK47::Reload(void)
{
	if (m_pPlayer->ammo_762nato <= 0)
		return;

	if (DefaultReload(AK47_MAX_CLIP, AK47_RELOAD, 2.45))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CAK47::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(AK47_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_aug.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum aug_e
{
	AUG_IDLE1,
	AUG_RELOAD,
	AUG_DRAW,
	AUG_SHOOT1,
	AUG_SHOOT2,
	AUG_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_aug, CAUG)

void CAUG::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_aug");

	Precache();
	m_iId = WEAPON_AUG;
	SET_MODEL(ENT(pev), "models/w_aug.mdl");

	m_iDefaultAmmo = AUG_DEFAULT_GIVE;
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;

	FallInit();
}

void CAUG::Precache(void)
{
	PRECACHE_MODEL("models/v_aug.mdl");
	PRECACHE_MODEL("models/w_aug.mdl");

	PRECACHE_SOUND("weapons/aug-1.wav");
	PRECACHE_SOUND("weapons/aug_clipout.wav");
	PRECACHE_SOUND("weapons/aug_clipin.wav");
	PRECACHE_SOUND("weapons/aug_boltpull.wav");
	PRECACHE_SOUND("weapons/aug_boltslap.wav");
	PRECACHE_SOUND("weapons/aug_forearm.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireAug = PRECACHE_EVENT(1, "events/aug.sc");
}

int CAUG::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = _556NATO_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = AUG_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 14;
	p->iId = m_iId = WEAPON_AUG;
	p->iFlags = 0;
	p->iWeight = AUG_WEIGHT;

	return 1;
}

BOOL CAUG::Deploy(void)
{
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_aug.mdl", "models/p_aug.mdl", AUG_DRAW, "carbine", UseDecrement() != FALSE);
}

void CAUG::SecondaryAttack(void)
{
	if (m_pPlayer->m_iFOV != 90)
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 90;
	else
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 55;

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CAUG::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		AUGFire(0.035 + (0.4) * m_flAccuracy, 0.0825, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
		AUGFire(0.035 + (0.07) * m_flAccuracy, 0.0825, FALSE);
	else if (m_pPlayer->pev->fov == 90)
		AUGFire((0.02) * m_flAccuracy, 0.0825, FALSE);
	else
		AUGFire((0.02) * m_flAccuracy, 0.135, FALSE);
}

void CAUG::AUGFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 215.0) + 0.3;

	if (m_flAccuracy > 1)
		m_flAccuracy = 1;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);
	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 2, BULLET_PLAYER_556MM, 32, 0.96, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireAug, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.9;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(1.0, 0.45, 0.275, 0.05, 4.0, 2.5, 7);
	else if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(1.25, 0.45, 0.22, 0.18, 5.5, 4.0, 5);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.575, 0.325, 0.2, 0.011, 3.25, 2.0, 8);
	else
		KickBack(0.625, 0.375, 0.25, 0.0125, 3.5, 2.25, 8);
}

void CAUG::Reload(void)
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(AUG_MAX_CLIP, AUG_RELOAD, 3.3))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		if (m_pPlayer->m_iFOV != 90)
			SecondaryAttack();

		m_flAccuracy = 0;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CAUG::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(AUG_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_awp.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum awp_e
{
	AWP_IDLE,
	AWP_SHOOT1,
	AWP_SHOOT2,
	AWP_SHOOT3,
	AWP_RELOAD,
	AWP_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_awp, CAWP)

void CAWP::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_awp");

	Precache();
	m_iId = WEAPON_AWP;
	SET_MODEL(ENT(pev), "models/w_awp.mdl");

	m_iDefaultAmmo = AWP_DEFAULT_GIVE;
	FallInit();
}

void CAWP::Precache(void)
{
	PRECACHE_MODEL("models/v_awp.mdl");
	PRECACHE_MODEL("models/w_awp.mdl");

	PRECACHE_SOUND("weapons/awp1.wav");
	PRECACHE_SOUND("weapons/boltpull1.wav");
	PRECACHE_SOUND("weapons/boltup.wav");
	PRECACHE_SOUND("weapons/boltdown.wav");
	PRECACHE_SOUND("weapons/zoom.wav");
	PRECACHE_SOUND("weapons/awp_deploy.wav");
	PRECACHE_SOUND("weapons/awp_clipin.wav");
	PRECACHE_SOUND("weapons/awp_clipout.wav");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/rshell_big.mdl");
	m_usFireAWP = PRECACHE_EVENT(1, "events/awp.sc");
}

int CAWP::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "338Magnum";
	p->iMaxAmmo1 = _338MAGNUM_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = AWP_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 2;
	p->iId = m_iId = WEAPON_AWP;
	p->iFlags = 0;
	p->iWeight = AWP_WEIGHT;

	return 1;
}

BOOL CAWP::Deploy(void)
{
	if (DefaultDeploy("models/v_awp.mdl", "models/p_awp.mdl", AWP_DRAW, "rifle", UseDecrement() != FALSE))
	{
		m_flNextPrimaryAttack = m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 1.45;
		m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1;
		return TRUE;
	}

	return FALSE;
}

void CAWP::SecondaryAttack(void)
{
	switch (m_pPlayer->m_iFOV)
	{
		case 90: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 40; break;
		case 40: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 10; break;
		default: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 90; break;
	}

	m_pPlayer->ResetMaxSpeed();
	EMIT_SOUND(ENT(m_pPlayer->pev), CHAN_ITEM, "weapons/zoom.wav", 0.2, 2.4);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CAWP::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		AWPFire(0.85, 1.45, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
		AWPFire(0.25, 1.45, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 10)
		AWPFire(0.1, 1.45, FALSE);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		AWPFire(0.0, 1.45, FALSE);
	else
		AWPFire(0.001, 1.45, FALSE);
}

void CAWP::AWPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	if (m_pPlayer->pev->fov != 90)
	{
		m_pPlayer->m_bResumeZoom = true;
		m_pPlayer->m_iLastZoom = m_pPlayer->m_iFOV;
		m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 90;
	}
	else // not zoomed, so bullets diverts more
		flSpread += 0.08;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_flEjectBrass = gpGlobals->time + 0.55;
	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	Vector vecDir = FireBullets3(m_pPlayer->GetGunPosition(), gpGlobals->v_forward, flSpread, 8192, 3, BULLET_PLAYER_338MAG, 115, 0.99, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireAWP, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.x * 100), FALSE, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;
	m_pPlayer->pev->punchangle.x -= 2;
}

void CAWP::Reload(void)
{
	if (m_pPlayer->ammo_338mag <= 0)
		return;

	if (DefaultReload(AWP_MAX_CLIP, AWP_RELOAD, 2.5))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		if (m_pPlayer->pev->fov != 90)
		{
			m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 10;
			SecondaryAttack();
		}
	}
}

void CAWP::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60;
		SendWeaponAnim(AWP_IDLE, UseDecrement() != FALSE);
	}
}

float CAWP::GetMaxSpeed(void)
{
	if (m_pPlayer->m_iFOV == 90)
		return 210;

	return 150;
}

```

`dlls/wpn_shared/wpn_c4.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"
#include "hltv.h"
#include "gamerules.h"

//#define C4MADNESS
#ifdef CLIENT_WEAPONS
extern bool g_bInBombZone;
#endif

enum c4_e
{
	C4_IDLE1,
	C4_DRAW,
	C4_DROP,
	C4_ARM
};

LINK_ENTITY_TO_CLASS(weapon_c4, CC4)

void CC4::Spawn(void)
{
	SET_MODEL(ENT(pev), "models/w_backpack.mdl");

	pev->frame = 0;
	pev->body = 3;
	pev->sequence = 0;
	pev->framerate = 0;

	m_iId = WEAPON_C4;
	m_iDefaultAmmo = C4_DEFAULT_GIVE;
	m_bStartedArming = false;
	m_fArmedTime = 0;

	if (!FStringNull(pev->targetname))
	{
		pev->effects |= EF_NODRAW;
		DROP_TO_FLOOR(ENT(pev));
		return;
	}

	FallInit();
	SetThink(&CBasePlayerItem::FallThink);
	pev->nextthink = UTIL_WeaponTimeBase() + 0.1;
}

void CC4::Precache(void)
{
	PRECACHE_MODEL("models/v_c4.mdl");
	PRECACHE_MODEL("models/w_backpack.mdl");

	PRECACHE_SOUND("weapons/c4_click.wav");
}

int CC4::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "C4";
	p->iMaxAmmo1 = C4_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = WEAPON_NOCLIP;
	p->iSlot = 4;
	p->iPosition = 3;
	p->iId = m_iId = WEAPON_C4;
	p->iWeight = C4_WEIGHT;
	p->iFlags = ITEM_FLAG_LIMITINWORLD | ITEM_FLAG_EXHAUSTIBLE;

	return 1;
}

BOOL CC4::Deploy(void)
{
	pev->body = 0;
	m_bStartedArming = false;
	m_fArmedTime = 0;

	if (m_pPlayer->HasShield() != false)
	{
		m_bHasShield = true;
		m_pPlayer->pev->gamestate = 1;
	}

	return DefaultDeploy("models/v_c4.mdl", "models/p_c4.mdl", C4_DRAW, "c4", UseDecrement() != FALSE);
}

void CC4::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5;
	m_bStartedArming = false;

	if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		m_pPlayer->pev->weapons &= ~(1 << WEAPON_C4);
		DestroyItem();
	}

	if (m_bHasShield == true)
	{
		m_pPlayer->pev->gamestate = 0;
		m_bHasShield = false;
	}
}

void CC4::PrimaryAttack(void)
{
	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		return;

#ifndef CLIENT_WEAPONS
	BOOL onBombZone = m_pPlayer->m_signals.GetState() & SIGNAL_BOMB;
#else
	BOOL onBombZone = g_bInBombZone;
#endif
	BOOL onGround = m_pPlayer->pev->flags & FL_ONGROUND;

	if (!m_bStartedArming)
	{
#ifndef C4MADNESS
		if (!onBombZone)
		{
			ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#C4_Plant_At_Bomb_Spot");
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1;
			return;
		}

		if (!onGround)
		{
			ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#C4_Plant_Must_Be_On_Ground");
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1;
			return;
		}
#endif
		m_bStartedArming = true;
		m_bBombPlacedAnimation = false;
		m_fArmedTime = gpGlobals->time + 3;
		SendWeaponAnim(C4_ARM, UseDecrement() != FALSE);
#ifndef CLIENT_DLL
		g_engfuncs.pfnSetClientMaxspeed(ENT(m_pPlayer->pev), 1);
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
		m_pPlayer->SetProgressBarTime(3);
#endif
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.3;
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
	}
	else
	{
#ifndef C4MADNESS
		if (!onGround || !onBombZone)
		{
			if (onBombZone)
				ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#C4_Plant_Must_Be_On_Ground");
			else
				ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#C4_Arming_Cancelled");

			m_bStartedArming = false;
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1.5;
#ifndef CLIENT_DLL
			m_pPlayer->ResetMaxSpeed();
			m_pPlayer->SetProgressBarTime(0);
			m_pPlayer->SetAnimation(PLAYER_HOLDBOMB);
#endif
			if (m_bBombPlacedAnimation == true)
				SendWeaponAnim(C4_DRAW, UseDecrement() != FALSE);
			else
				SendWeaponAnim(C4_IDLE1, UseDecrement() != FALSE);

			return;
		}
#endif
		if (gpGlobals->time > m_fArmedTime)
		{
			if (m_bStartedArming == true)
			{
				m_bStartedArming = false;
				m_fArmedTime = 0;
				m_pPlayer->m_bHasC4 = false;

				Broadcast("BOMBPL");
#ifndef CLIENT_WEAPONS

				if (pev->speed != 0 && g_pGameRules)
					g_pGameRules->m_iC4Timer = (int)pev->speed;

				CGrenade *pGrenade = CGrenade::ShootSatchelCharge(m_pPlayer->pev, m_pPlayer->pev->origin, Vector(0, 0, 0));

				MESSAGE_BEGIN(MSG_SPEC, SVC_DIRECTOR);
				WRITE_BYTE(9);
				WRITE_BYTE(DRC_CMD_EVENT);
				WRITE_SHORT(ENTINDEX(m_pPlayer->edict()));
				WRITE_SHORT(0);
				WRITE_LONG(11 | DRC_FLAG_FACEPLAYER);
				MESSAGE_END();

				MESSAGE_BEGIN(MSG_ALL, gmsgBombDrop);
				WRITE_COORD(pGrenade->pev->origin.x);
				WRITE_COORD(pGrenade->pev->origin.y);
				WRITE_COORD(pGrenade->pev->origin.z);
				WRITE_BYTE(1);
				MESSAGE_END();
				UTIL_ClientPrintAll(HUD_PRINTCENTER, "#Bomb_Planted");

				UTIL_LogPrintf("\"%s<%i><%s><TERRORIST>\" triggered \"Planted_The_Bomb\"\n", STRING(m_pPlayer->pev->netname), GETPLAYERUSERID(m_pPlayer->edict()), GETPLAYERAUTHID(m_pPlayer->edict()));
				g_pGameRules->m_bBombDropped = false;
#endif		
				EMIT_SOUND(ENT(pev), CHAN_WEAPON, "weapons/c4_plant.wav", VOL_NORM, ATTN_NORM);

				m_pPlayer->pev->body = 0;
#ifndef CLIENT_DLL
				m_pPlayer->ResetMaxSpeed();				
				m_pPlayer->SetBombIcon(FALSE);
#endif
				m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]--;

				if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
				{
					RetireWeapon();
					return;
				}
			}
		}
		else
		{
			if (gpGlobals->time >= m_fArmedTime - 0.75)
			{
				if (m_bBombPlacedAnimation == false)
				{
					m_bBombPlacedAnimation = true;
					SendWeaponAnim(C4_DROP, UseDecrement() != FALSE);
#ifndef CLIENT_DLL
					m_pPlayer->SetAnimation(PLAYER_HOLDBOMB);
#endif
				}
			}
		}
	}

	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.3;
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
}

void CC4::WeaponIdle(void)
{
	if (m_bStartedArming == true)
	{
		m_bStartedArming = false;
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1;
#ifndef CLIENT_DLL
		m_pPlayer->ResetMaxSpeed();
		m_pPlayer->SetProgressBarTime(0);
#endif

		if (m_bBombPlacedAnimation == true)
			SendWeaponAnim(C4_DRAW, UseDecrement() != FALSE);
		else
			SendWeaponAnim(C4_IDLE1, UseDecrement() != FALSE);
	}

	if (m_flTimeWeaponIdle <= UTIL_WeaponTimeBase())
	{
		if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		{
			RetireWeapon();
			return;
		}

		SendWeaponAnim(C4_DRAW, UseDecrement() != FALSE);
		SendWeaponAnim(C4_IDLE1, UseDecrement() != FALSE);
	}
}

void CC4::KeyValue(KeyValueData *pkvd)
{
	if (FStrEq(pkvd->szKeyName, "detonatedelay"))
	{
		pev->speed = atof(pkvd->szValue);
		pkvd->fHandled = TRUE;
	}
	else if (FStrEq(pkvd->szKeyName, "detonatetarget"))
	{
		pev->noise1 = ALLOC_STRING(pkvd->szValue);
		pkvd->fHandled = TRUE;
	}
	else if (FStrEq(pkvd->szKeyName, "defusetarget"))
	{
		pev->target = ALLOC_STRING(pkvd->szValue);
		pkvd->fHandled = TRUE;
	}
	else
		CBaseEntity::KeyValue(pkvd);
}

void CC4::Use(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value)
{
	if (m_pPlayer)
		return;

	CBasePlayer *pPlayer = (CBasePlayer *)UTIL_PlayerByIndex(1);

	if (pPlayer)
	{
		edict_t *target = pPlayer->m_pentCurBombTarget;
		pPlayer->m_pentCurBombTarget = NULL;

#ifndef CLIENT_WEAPONS
		if (pev->speed != 0 && g_pGameRules)
			g_pGameRules->m_iC4Timer = (int)pev->speed;
#endif

		EMIT_SOUND(ENT(pev), CHAN_WEAPON, "weapons/c4_plant.wav", VOL_NORM, ATTN_NORM);
		CGrenade::ShootSatchelCharge(m_pPlayer->pev, m_pPlayer->pev->origin, Vector(0, 0, 0));
		CGrenade *pGrenade = NULL;

		while ((pGrenade = (CGrenade *)UTIL_FindEntityByClassname(pGrenade, "grenade")) != NULL)
		{
			if (pGrenade->m_bIsC4 && pGrenade->m_flNextFreq == gpGlobals->time)
			{
				pGrenade->pev->target = pev->target;
				pGrenade->pev->noise1 = pev->noise1;
				break;
			}
		}

		pPlayer->m_pentCurBombTarget = target;
		SUB_Remove();
	}
}

```

`dlls/wpn_shared/wpn_deagle.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum deagle_e
{
	DEAGLE_IDLE1,
	DEAGLE_SHOOT1,
	DEAGLE_SHOOT2,
	DEAGLE_SHOOT_EMPTY,
	DEAGLE_RELOAD,
	DEAGLE_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_deagle, CDEAGLE)

void CDEAGLE::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_deagle");

	Precache();
	m_iId = WEAPON_DEAGLE;
	SET_MODEL(ENT(pev), "models/w_deagle.mdl");

	m_iDefaultAmmo = DEAGLE_DEFAULT_GIVE;
	m_flAccuracy = 0.9;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_fMaxSpeed = 250;

	FallInit();
}

void CDEAGLE::Precache(void)
{
	PRECACHE_MODEL("models/v_deagle.mdl");
	PRECACHE_MODEL("models/shield/v_shield_deagle.mdl");
	PRECACHE_MODEL("models/w_deagle.mdl");

	PRECACHE_SOUND("weapons/deagle-1.wav");
	PRECACHE_SOUND("weapons/deagle-2.wav");
	PRECACHE_SOUND("weapons/de_clipout.wav");
	PRECACHE_SOUND("weapons/de_clipin.wav");
	PRECACHE_SOUND("weapons/de_deploy.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireDeagle = PRECACHE_EVENT(1, "events/deagle.sc");
}

int CDEAGLE::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "50AE";
	p->iMaxAmmo1 = _50AE_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = DEAGLE_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 1;
	p->iId = m_iId = WEAPON_DEAGLE;
	p->iFlags = 0;
	p->iWeight = DEAGLE_WEIGHT;

	return 1;
}

BOOL CDEAGLE::Deploy(void)
{
	m_flAccuracy = 0.9;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;
	m_fMaxSpeed = 250;

	if (m_pPlayer->HasShield() != false)
		return DefaultDeploy("models/shield/v_shield_deagle.mdl", "models/shield/p_shield_deagle.mdl", DEAGLE_DRAW, "shieldgun", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_deagle.mdl", "models/p_deagle.mdl", DEAGLE_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CDEAGLE::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		DEAGLEFire((1.5) * (1 - m_flAccuracy), 0.3, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		DEAGLEFire((0.25) * (1 - m_flAccuracy), 0.3, FALSE);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		DEAGLEFire((0.115) * (1 - m_flAccuracy), 0.3, FALSE);
	else
		DEAGLEFire((0.13) * (1 - m_flAccuracy), 0.3, FALSE);
}

void CDEAGLE::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_UP, SHIELDGUN_DOWN);
}

void CDEAGLE::DEAGLEFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	flCycleTime -= 0.075;
	m_iShotsFired++;

	if (m_iShotsFired > 1)
		return;

	if (m_flLastFire)
	{
		m_flAccuracy -= (0.4 - (gpGlobals->time - m_flLastFire)) * 0.35;

		if (m_flAccuracy > 0.9)
			m_flAccuracy = 0.9;
		else if (m_flAccuracy < 0.55)
			m_flAccuracy = 0.55;
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	SetPlayerShieldAnim();
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 4096, 2, BULLET_PLAYER_50AE, 54, 0.81, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireDeagle, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), m_iClip != 0, FALSE);

	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.8;
	m_pPlayer->pev->punchangle.x -= 2;
	ResetPlayerShieldAnim();
}

void CDEAGLE::Reload(void)
{
	if (m_pPlayer->ammo_50ae <= 0)
		return;

	if (DefaultReload(DEAGLE_MAX_CLIP, DEAGLE_RELOAD, 2.2))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.9;
	}
}

void CDEAGLE::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		SendWeaponAnim(SHIELDGUN_DRAWN_IDLE, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_elite.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum elite_e
{
	ELITE_IDLE,
	ELITE_IDLE_LEFTEMPTY,
	ELITE_SHOOTLEFT1,
	ELITE_SHOOTLEFT2,
	ELITE_SHOOTLEFT3,
	ELITE_SHOOTLEFT4,
	ELITE_SHOOTLEFT5,
	ELITE_SHOOTLEFTLAST,
	ELITE_SHOOTRIGHT1,
	ELITE_SHOOTRIGHT2,
	ELITE_SHOOTRIGHT3,
	ELITE_SHOOTRIGHT4,
	ELITE_SHOOTRIGHT5,
	ELITE_SHOOTRIGHTLAST,
	ELITE_RELOAD,
	ELITE_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_elite, CELITE)

void CELITE::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_elite");

	Precache();
	m_iId = WEAPON_ELITE;
	SET_MODEL(ENT(pev), "models/w_elite.mdl");

	m_iDefaultAmmo = ELITE_DEFAULT_GIVE;
	m_flAccuracy = 0.88;

	FallInit();
}

void CELITE::Precache(void)
{
	PRECACHE_MODEL("models/v_elite.mdl");
	PRECACHE_MODEL("models/w_elite.mdl");

	PRECACHE_SOUND("weapons/elite_fire.wav");
	PRECACHE_SOUND("weapons/elite_reloadstart.wav");
	PRECACHE_SOUND("weapons/elite_leftclipin.wav");
	PRECACHE_SOUND("weapons/elite_clipout.wav");
	PRECACHE_SOUND("weapons/elite_sliderelease.wav");
	PRECACHE_SOUND("weapons/elite_rightclipin.wav");
	PRECACHE_SOUND("weapons/elite_deploy.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireELITE_LEFT = PRECACHE_EVENT(1, "events/elite_left.sc");
	m_usFireELITE_RIGHT = PRECACHE_EVENT(1, "events/elite_right.sc");
}

int CELITE::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "9mm";
	p->iMaxAmmo1 = _9MM_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = ELITE_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 5;
	p->iId = m_iId = WEAPON_ELITE;
	p->iFlags = 0;
	p->iWeight = ELITE_WEIGHT;

	return 1;
}

BOOL CELITE::Deploy(void)
{
	m_flAccuracy = 0.88;

	if (!(m_iClip & 1))
		m_iWeaponState |= WPNSTATE_ELITE_LEFT;

	return DefaultDeploy("models/v_elite.mdl", "models/p_elite.mdl", ELITE_DRAW, "dualpistols", UseDecrement() != FALSE);
}

void CELITE::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		ELITEFire((1.3) * (1 - m_flAccuracy), 0.2, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		ELITEFire((0.175) * (1 - m_flAccuracy), 0.2, FALSE);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		ELITEFire((0.08) * (1 - m_flAccuracy), 0.2, FALSE);
	else
		ELITEFire((0.1) * (1 - m_flAccuracy), 0.2, FALSE);
}

void CELITE::ELITEFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	flCycleTime -= 0.125;
	m_iShotsFired++;

	if (m_iShotsFired > 1)
		return;

	if (m_flLastFire)
	{
		m_flAccuracy -= (0.325 - (gpGlobals->time - m_flLastFire)) * 0.275;

		if (m_flAccuracy > 0.88)
			m_flAccuracy = 0.88;
		else if (m_flAccuracy < 0.55)
			m_flAccuracy = 0.55;
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;

	Vector vecDir;
	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	if (m_iWeaponState & WPNSTATE_ELITE_LEFT)
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		m_iWeaponState &= ~WPNSTATE_ELITE_LEFT;

		vecDir = FireBullets3(m_pPlayer->GetGunPosition() - gpGlobals->v_right * 5, gpGlobals->v_forward, flSpread, 8192, BULLET_PLAYER_9MM, 1, 36, 0.75, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);
		PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireELITE_LEFT, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.y * 100), m_iClip, FALSE, FALSE);
	}
	else
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK2);
#endif
		m_iWeaponState |= WPNSTATE_ELITE_LEFT;

		vecDir = FireBullets3(m_pPlayer->GetGunPosition() - gpGlobals->v_right * 5, gpGlobals->v_forward, flSpread, 8192, BULLET_PLAYER_9MM, 1, 36, 0.75, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);
		PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireELITE_RIGHT, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.y * 100), m_iClip, FALSE, FALSE);
	}

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;
	m_pPlayer->pev->punchangle.x -= 2;
}

void CELITE::Reload(void)
{
	if (m_pPlayer->ammo_9mm <= 0)
		return;

	if (DefaultReload(ELITE_MAX_CLIP, ELITE_RELOAD, 4.5))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.88;
	}
}

void CELITE::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60;

		if (m_iClip == 1)
			SendWeaponAnim(ELITE_IDLE_LEFTEMPTY, UseDecrement() != FALSE);
		else
			SendWeaponAnim(ELITE_IDLE, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_famas.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum famas_e
{
	FAMAS_IDLE1,
	FAMAS_RELOAD,
	FAMAS_DRAW,
	FAMAS_SHOOT1,
	FAMAS_SHOOT2,
	FAMAS_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_famas, CFamas)

void CFamas::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_famas");

	Precache();
	m_iId = WEAPON_FAMAS;
	SET_MODEL(ENT(pev), "models/w_famas.mdl");

	m_iDefaultAmmo = FAMAS_DEFAULT_GIVE;
	m_iFamasShotsFired = 0;
	m_flFamasShoot = 0;

	FallInit();
}

void CFamas::Precache(void)
{
	PRECACHE_MODEL("models/v_famas.mdl");
	PRECACHE_MODEL("models/w_famas.mdl");

	PRECACHE_SOUND("weapons/famas-1.wav");
	PRECACHE_SOUND("weapons/famas-2.wav");
	PRECACHE_SOUND("weapons/famas_clipout.wav");
	PRECACHE_SOUND("weapons/famas_clipin.wav");
	PRECACHE_SOUND("weapons/famas_boltpull.wav");
	PRECACHE_SOUND("weapons/famas_boltslap.wav");
	PRECACHE_SOUND("weapons/famas_forearm.wav");
	PRECACHE_SOUND("weapons/famas-burst.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireFamas = PRECACHE_EVENT(1, "events/famas.sc");
}

int CFamas::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = _556NATO_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = FAMAS_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 18;
	p->iId = m_iId = WEAPON_FAMAS;
	p->iFlags = 0;
	p->iWeight = FAMAS_WEIGHT;

	return 1;
}

BOOL CFamas::Deploy(void)
{
	m_iShotsFired = 0;
	m_iFamasShotsFired = 0;
	m_flFamasShoot = 0;
	m_flAccuracy = 0.2;
	iShellOn = 1;

	return DefaultDeploy("models/v_famas.mdl", "models/p_famas.mdl", FAMAS_DRAW, "carbine", UseDecrement() != FALSE);
}

void CFamas::SecondaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_FAMAS_BURST_MODE)
	{
		ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#Switch_To_FullAuto");
		m_iWeaponState &= ~WPNSTATE_FAMAS_BURST_MODE;
	}
	else
	{
		ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#Switch_To_BurstFire");
		m_iWeaponState |= WPNSTATE_FAMAS_BURST_MODE;
	}

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CFamas::PrimaryAttack(void)
{
	if (m_pPlayer->pev->waterlevel == 3)
	{
		PlayEmptySound();
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.15;
		return;
	}

	BOOL bBurstMode = FBitSet(m_iWeaponState, WPNSTATE_FAMAS_BURST_MODE) ? TRUE : FALSE;

	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		FamasFire(0.030 + (0.3) * m_flAccuracy, 0.0825, FALSE, bBurstMode);
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
		FamasFire(0.030 + (0.07) * m_flAccuracy, 0.0825, FALSE, bBurstMode);
	else
		FamasFire((0.02) * m_flAccuracy, 0.0825, FALSE, bBurstMode);
}

void CFamas::FamasFire(float flSpread, float flCycleTime, BOOL fUseAutoAim, BOOL bFireBurst)
{
	if (bFireBurst != FALSE)
	{
		m_iFamasShotsFired = 0;
		flCycleTime = 0.55;
	}
	else
		flSpread += 0.01;

	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 215.0) + 0.3;

	if (m_flAccuracy > 1)
		m_flAccuracy = 1;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 2, BULLET_PLAYER_556MM, bFireBurst ? 34 : 30, 0.96, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireFamas, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 10000000), (int)(m_pPlayer->pev->punchangle.y * 10000000), m_iClip != 0, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.1;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(1, 0.45, 0.275, 0.05, 4, 2.5, 7);
	else if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(1.25, 0.45, 0.22, 0.18, 5.5, 4, 5);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.575, 0.325, 0.2, 0.011, 3.25, 2, 8);
	else
		KickBack(0.625, 0.375, 0.25, 0.0125, 3.5, 2.25, 8);

	if (bFireBurst != FALSE)
	{
		m_fBurstSpread = flSpread;
		m_iFamasShotsFired++;
		m_flFamasShoot = gpGlobals->time + 0.05;
	}
}

void CFamas::Reload(void)
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(FAMAS_MAX_CLIP, FAMAS_RELOAD, 3.3))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		if (m_pPlayer->m_iFOV != 90)
			SecondaryAttack();

		m_flAccuracy = 0;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CFamas::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(FAMAS_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_fiveseven.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum fiveseven_e
{
	FIVESEVEN_IDLE,
	FIVESEVEN_SHOOT1,
	FIVESEVEN_SHOOT2,
	FIVESEVEN_SHOOT_EMPTY,
	FIVESEVEN_RELOAD,
	FIVESEVEN_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_fiveseven, CFiveSeven)

void CFiveSeven::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_fiveseven");

	Precache();
	m_iId = WEAPON_FIVESEVEN;
	SET_MODEL(ENT(pev), "models/w_fiveseven.mdl");

	m_iDefaultAmmo = FIVESEVEN_DEFAULT_GIVE;
	m_flAccuracy = 0.92;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	FallInit();
}

void CFiveSeven::Precache(void)
{
	PRECACHE_MODEL("models/v_fiveseven.mdl");
	PRECACHE_MODEL("models/w_fiveseven.mdl");
	PRECACHE_MODEL("models/shield/v_shield_fiveseven.mdl");

	PRECACHE_SOUND("weapons/fiveseven-1.wav");
	PRECACHE_SOUND("weapons/fiveseven_clipout.wav");
	PRECACHE_SOUND("weapons/fiveseven_clipin.wav");
	PRECACHE_SOUND("weapons/fiveseven_sliderelease.wav");
	PRECACHE_SOUND("weapons/fiveseven_slidepull.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireFiveSeven = PRECACHE_EVENT(1, "events/fiveseven.sc");
}

int CFiveSeven::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "57mm";
	p->iMaxAmmo1 = _57MM_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = FIVESEVEN_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 6;
	p->iId = m_iId = WEAPON_FIVESEVEN;
	p->iFlags = 0;
	p->iWeight = FIVESEVEN_WEIGHT;

	return 1;
}

BOOL CFiveSeven::Deploy(void)
{
	m_flAccuracy = 0.92;
	m_fMaxSpeed = 250;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield() != false)
		return DefaultDeploy("models/shield/v_shield_fiveseven.mdl", "models/shield/p_shield_fiveseven.mdl", FIVESEVEN_DRAW, "shieldgun", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_fiveseven.mdl", "models/p_fiveseven.mdl", FIVESEVEN_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CFiveSeven::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		FiveSevenFire((1.5) * (1 - m_flAccuracy), 0.2, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		FiveSevenFire((0.255) * (1 - m_flAccuracy), 0.2, FALSE);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		FiveSevenFire((0.075) * (1 - m_flAccuracy), 0.2, FALSE);
	else
		FiveSevenFire((0.15) * (1 - m_flAccuracy), 0.2, FALSE);
}

void CFiveSeven::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_UP, SHIELDGUN_DOWN);
}

void CFiveSeven::FiveSevenFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	flCycleTime -= 0.05;
	m_iShotsFired++;

	if (m_iShotsFired > 1)
		return;

	if (m_flLastFire)
	{
		m_flAccuracy -= (0.275 - (gpGlobals->time - m_flLastFire)) * 0.25;

		if (m_flAccuracy > 0.92)
			m_flAccuracy = 0.92;
		else if (m_flAccuracy < 0.725)
			m_flAccuracy = 0.725;
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	SetPlayerShieldAnim();
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	Vector vecDir = FireBullets3(m_pPlayer->GetGunPosition(), gpGlobals->v_forward, flSpread, 4096, 1, BULLET_PLAYER_57MM, 20, 0.885, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireFiveSeven, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), m_iClip != 0, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;
	m_pPlayer->pev->punchangle.x -= 2;
	ResetPlayerShieldAnim();
}

void CFiveSeven::Reload(void)
{
	if (m_pPlayer->ammo_57mm <= 0)
		return;

	if (DefaultReload(FIVESEVEN_MAX_CLIP, FIVESEVEN_RELOAD, 2.7))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.92;
	}
}

void CFiveSeven::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_pPlayer->HasShield())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;

		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			SendWeaponAnim(SHIELDGUN_DRAWN_IDLE, UseDecrement() != FALSE);

		return;
	}

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3.0625;
		SendWeaponAnim(FIVESEVEN_IDLE, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_flashbang.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum flashbang_e
{
	FLASHBANG_IDLE,
	FLASHBANG_PULLPIN,
	FLASHBANG_THROW,
	FLASHBANG_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_flashbang, CFlashbang)

void CFlashbang::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_flashbang");

	Precache();
	m_iId = WEAPON_FLASHBANG;
	SET_MODEL(ENT(pev), "models/w_flashbang.mdl");

	pev->dmg = 4;
	m_iDefaultAmmo = FLASHBANG_DEFAULT_GIVE;
	m_flStartThrow = 0;
	m_flReleaseThrow = -1;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	FallInit();
}

void CFlashbang::Precache(void)
{
	PRECACHE_MODEL("models/v_flashbang.mdl");
	PRECACHE_MODEL("models/shield/v_shield_flashbang.mdl");

	PRECACHE_SOUND("weapons/flashbang-1.wav");
	PRECACHE_SOUND("weapons/flashbang-2.wav");
	PRECACHE_SOUND("weapons/pinpull.wav");
}

int CFlashbang::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "Flashbang";
	p->iMaxAmmo1 = FLASHBANG_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = WEAPON_NOCLIP;
	p->iSlot = 3;
	p->iPosition = 2;
	p->iId = m_iId = WEAPON_FLASHBANG;
	p->iWeight = FLASHBANG_WEIGHT;
	p->iFlags = ITEM_FLAG_LIMITINWORLD | ITEM_FLAG_EXHAUSTIBLE;

	return 1;
}

BOOL CFlashbang::Deploy(void)
{
	m_flReleaseThrow = -1;
	m_fMaxSpeed = 250;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield() != false)
		return DefaultDeploy("models/shield/v_shield_flashbang.mdl", "models/shield/p_shield_flashbang.mdl", FLASHBANG_DRAW, "shieldgren", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_flashbang.mdl", "models/p_flashbang.mdl", FLASHBANG_DRAW, "grenade", UseDecrement() != FALSE);
}

void CFlashbang::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5;

	if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		m_pPlayer->pev->weapons &= ~(1 << WEAPON_FLASHBANG);
		DestroyItem();
	}

	m_flStartThrow = 0;
	m_flReleaseThrow = -1;
}

void CFlashbang::PrimaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		return;

	if (!m_flStartThrow && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] > 0)
	{
		m_flStartThrow = gpGlobals->time;
		m_flReleaseThrow = 0;
		SendWeaponAnim(FLASHBANG_PULLPIN, UseDecrement() != FALSE);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.5;
	}
}

void CFlashbang::SetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strcpy(m_pPlayer->m_szAnimExtention, "shield");
		else
			strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
	}
}

void CFlashbang::ResetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
	}
}

bool CFlashbang::ShieldSecondaryFire(int up_anim, int down_anim)
{
	if (m_pPlayer->HasShield() == false)
		return false;

	if (m_flStartThrow > 0)
		return false;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(down_anim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
		m_fMaxSpeed = 250;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(up_anim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shielded");
		m_fMaxSpeed = 180;
		m_pPlayer->m_bShieldDrawn = true;
	}

#ifndef CLIENT_DLL
	m_pPlayer->UpdateShieldCrosshair((m_iWeaponState & WPNSTATE_SHIELD_DRAWN) == 0);
	m_pPlayer->ResetMaxSpeed();
#endif
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.6;
	return true;
}

void CFlashbang::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_DRAW, SHIELDGUN_DRAWN_IDLE);
}

void CFlashbang::WeaponIdle(void)
{
	if (!m_flReleaseThrow && m_flStartThrow)
		m_flReleaseThrow = gpGlobals->time;

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_flStartThrow)
	{
#ifndef CLIENT_DLL
		m_pPlayer->Radio("%!MRAD_FIREINHOLE", "#Fire_in_the_hole");
#endif
		Vector angThrow = m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle;

		if (angThrow.x < 0)
			angThrow.x = -10 + angThrow.x * ((90 - 10) / 90.0);
		else
			angThrow.x = -10 + angThrow.x * ((90 + 10) / 90.0);

		float flVel = (90 - angThrow.x) * 6;

		if (flVel > 750)
			flVel = 750;

		UTIL_MakeVectors(angThrow);
		Vector vecSrc = m_pPlayer->pev->origin + m_pPlayer->pev->view_ofs + gpGlobals->v_forward * 16;
		Vector vecThrow = gpGlobals->v_forward * flVel + m_pPlayer->pev->velocity;
		float time = 1.5;
		CGrenade::ShootTimed(m_pPlayer->pev, vecSrc, vecThrow, time);

		SendWeaponAnim(FLASHBANG_THROW, UseDecrement() != FALSE);
		SetPlayerShieldAnim();

#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		m_flStartThrow = 0;
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.5;
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.75;
		m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]--;

		if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
			m_flTimeWeaponIdle = m_flNextSecondaryAttack = m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.5;

		ResetPlayerShieldAnim();
		return;
	}
	else if (m_flReleaseThrow > 0)
	{
		m_flStartThrow = 0;
		RetireWeapon();
		return;
	}

	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		float flRand = RANDOM_FLOAT(0, 1);

		if (m_pPlayer->HasShield() != false)
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0;

			if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
				SendWeaponAnim(SHIELDREN_IDLE, UseDecrement() != FALSE);

			return;
		}

		if (flRand > 0.75)
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.5;
		else
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);

		SendWeaponAnim(FLASHBANG_IDLE, UseDecrement() != FALSE);
	}
}

BOOL CFlashbang::CanDeploy(void)
{
	return m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] != 0;
}

```

`dlls/wpn_shared/wpn_g3sg1.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum g3sg1_e
{
	G3SG1_IDLE,
	G3SG1_SHOOT,
	G3SG1_SHOOT2,
	G3SG1_RELOAD,
	G3SG1_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_g3sg1, CG3SG1)

void CG3SG1::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_g3sg1");

	Precache();
	m_iId = WEAPON_G3SG1;
	SET_MODEL(ENT(pev), "models/w_g3sg1.mdl");
	m_iDefaultAmmo = G3SG1_DEFAULT_GIVE;

	FallInit();
}

void CG3SG1::Precache(void)
{
	PRECACHE_MODEL("models/v_g3sg1.mdl");
	PRECACHE_MODEL("models/w_g3sg1.mdl");

	PRECACHE_SOUND("weapons/g3sg1-1.wav");
	PRECACHE_SOUND("weapons/g3sg1_slide.wav");
	PRECACHE_SOUND("weapons/g3sg1_clipin.wav");
	PRECACHE_SOUND("weapons/g3sg1_clipout.wav");
	PRECACHE_SOUND("weapons/zoom.wav");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireG3SG1 = PRECACHE_EVENT(1, "events/g3sg1.sc");
}

int CG3SG1::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "762Nato";
	p->iMaxAmmo1 = _762NATO_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = G3SG1_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 3;
	p->iId = m_iId = WEAPON_G3SG1;
	p->iFlags = 0;
	p->iWeight = WEAPON_G3SG1;

	return 1;
}

BOOL CG3SG1::Deploy(void)
{
	m_flAccuracy = 0.2;

	return DefaultDeploy("models/v_g3sg1.mdl", "models/p_g3sg1.mdl", G3SG1_DRAW, "mp5", UseDecrement() != FALSE);
}

void CG3SG1::SecondaryAttack(void)
{
	switch (m_pPlayer->m_iFOV)
	{
		case 90: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 40; break;
		case 40: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 15; break;
		default: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 90; break;
	}

	m_pPlayer->ResetMaxSpeed();
	EMIT_SOUND(ENT(pev), CHAN_ITEM, "weapons/zoom.wav", 0.2, 2.4);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CG3SG1::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		G3SG1Fire(0.45, 0.25, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		G3SG1Fire(0.15, 0.25, FALSE);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		G3SG1Fire(0.035, 0.25, FALSE);
	else
		G3SG1Fire(0.055, 0.25, FALSE);
}

void CG3SG1::G3SG1Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	if (m_pPlayer->pev->fov == 90)
		flCycleTime += 0.025;

	if (m_flLastFire)
	{
		m_flAccuracy = (gpGlobals->time - m_flLastFire) * 0.3 + 0.55;

		if (m_flAccuracy > 0.98)
			m_flAccuracy = 0.98;
	}
	else
		m_flAccuracy = 0.98;

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	Vector vecDir = FireBullets3(m_pPlayer->GetGunPosition(), gpGlobals->v_forward, flSpread, 8192, 3, BULLET_PLAYER_762MM, 80, 0.98, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireG3SG1, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), TRUE, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.8;

	m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomFloat(m_pPlayer->random_seed + 4, 2.75, 3.25) + m_pPlayer->pev->punchangle.x * 0.25;
	m_pPlayer->pev->punchangle.y += UTIL_SharedRandomFloat(m_pPlayer->random_seed + 5, -1.25, 1.5);
}

void CG3SG1::Reload(void)
{
	if (m_pPlayer->ammo_762nato <= 0)
		return;

	if (DefaultReload(G3SG1_MAX_CLIP, G3SG1_RELOAD, 3.5))
	{
		m_flAccuracy = 0.2;
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif

		if (m_pPlayer->pev->fov != 90)
		{
			m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 15;
			SecondaryAttack();
		}
	}
}

void CG3SG1::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60;
		SendWeaponAnim(G3SG1_IDLE, UseDecrement() != FALSE);
	}
}

float CG3SG1::GetMaxSpeed(void)
{
	if (m_pPlayer->m_iFOV == 90)
		return 210;

	return 150;
}

```

`dlls/wpn_shared/wpn_galil.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum galil_e
{
	GALIL_IDLE1,
	GALIL_RELOAD,
	GALIL_DRAW,
	GALIL_SHOOT1,
	GALIL_SHOOT2,
	GALIL_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_galil, CGalil)

void CGalil::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_galil");

	Precache();
	m_iId = WEAPON_GALIL;
	SET_MODEL(ENT(pev), "models/w_galil.mdl");

	m_iDefaultAmmo = GALIL_DEFAULT_GIVE;

	FallInit();
}

void CGalil::Precache(void)
{
	PRECACHE_MODEL("models/v_galil.mdl");
	PRECACHE_MODEL("models/w_galil.mdl");

	PRECACHE_SOUND("weapons/galil-1.wav");
	PRECACHE_SOUND("weapons/galil-2.wav");
	PRECACHE_SOUND("weapons/galil_clipout.wav");
	PRECACHE_SOUND("weapons/galil_clipin.wav");
	PRECACHE_SOUND("weapons/galil_boltpull.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireGalil = PRECACHE_EVENT(1, "events/galil.sc");
}

int CGalil::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = _556NATO_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = GALIL_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 17;
	p->iId = m_iId = WEAPON_GALIL;
	p->iFlags = 0;
	p->iWeight = GALIL_WEIGHT;

	return 1;
}

BOOL CGalil::Deploy(void)
{
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_galil.mdl", "models/p_galil.mdl", GALIL_DRAW, "ak47", UseDecrement() != FALSE);
}

void CGalil::PrimaryAttack(void)
{
	if (m_pPlayer->pev->waterlevel == 3)
	{
		PlayEmptySound();
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.15;
		return;
	}

	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		GalilFire(0.04 + (0.3) * m_flAccuracy, 0.0875, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
		GalilFire(0.04 + (0.07) * m_flAccuracy, 0.0875, FALSE);
	else
		GalilFire((0.0375) * m_flAccuracy, 0.0875, FALSE);
}

void CGalil::GalilFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 200.0) + 0.35;

	if (m_flAccuracy > 1.25)
		m_flAccuracy = 1.25;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);
	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 2, BULLET_PLAYER_556MM, 30, 0.98, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireGalil, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 10000000), (int)(m_pPlayer->pev->punchangle.y * 10000000), FALSE, FALSE);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.9;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(1.0, 0.45, 0.28, 0.045, 3.75, 3.0, 7);
	else if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(1.2, 0.5, 0.23, 0.15, 5.5, 3.5, 6);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.6, 0.3, 0.2, 0.0125, 3.25, 2.0, 7);
	else
		KickBack(0.65, 0.35, 0.25, 0.015, 3.5, 2.25, 7);
}

void CGalil::Reload(void)
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(GALIL_MAX_CLIP, GALIL_RELOAD, 2.45))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CGalil::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(GALIL_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_glock18.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

#ifdef CLIENT_WEAPONS
extern bool g_bGlockBurstMode;
#endif

enum glock18_e
{
	GLOCK18_IDLE1,
	GLOCK18_IDLE2,
	GLOCK18_IDLE3,
	GLOCK18_SHOOT,
	GLOCK18_SHOOT2,
	GLOCK18_SHOOT3,
	GLOCK18_SHOOT_EMPTY,
	GLOCK18_RELOAD,
	GLOCK18_DRAW,
	GLOCK18_HOLSTER,
	GLOCK18_ADD_SILENCER,
	GLOCK18_DRAW2,
	GLOCK18_RELOAD2
};

enum glock18_shield_e
{
	GLOCK18_SHIELD_IDLE1,
	GLOCK18_SHIELD_SHOOT,
	GLOCK18_SHIELD_SHOOT2,
	GLOCK18_SHIELD_SHOOT_EMPTY,
	GLOCK18_SHIELD_RELOAD,
	GLOCK18_SHIELD_DRAW,
	GLOCK18_SHIELD_IDLE,
	GLOCK18_SHIELD_UP,
	GLOCK18_SHIELD_DOWN
};

LINK_ENTITY_TO_CLASS(weapon_glock18, CGLOCK18)

void CGLOCK18::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_glock18");

	Precache();
	m_iId = WEAPON_GLOCK18;
	SET_MODEL(ENT(pev), "models/w_glock18.mdl");

	m_bBurstFire = 0;
	m_iGlock18ShotsFired = 0;
	m_flGlock18Shoot = 0;
	m_iDefaultAmmo = GLOCK18_DEFAULT_GIVE;
	m_flAccuracy = 0.9;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	FallInit();
}

void CGLOCK18::Precache(void)
{
	PRECACHE_MODEL("models/v_glock18.mdl");
	PRECACHE_MODEL("models/w_glock18.mdl");
	PRECACHE_MODEL("models/shield/v_shield_glock18.mdl");

	PRECACHE_SOUND("weapons/glock18-1.wav");
	PRECACHE_SOUND("weapons/glock18-2.wav");
	PRECACHE_SOUND("weapons/clipout1.wav");
	PRECACHE_SOUND("weapons/clipin1.wav");
	PRECACHE_SOUND("weapons/sliderelease1.wav");
	PRECACHE_SOUND("weapons/slideback1.wav");
	PRECACHE_SOUND("weapons/357_cock1.wav");
	PRECACHE_SOUND("weapons/de_clipin.wav");
	PRECACHE_SOUND("weapons/de_clipout.wav");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireGlock18 = PRECACHE_EVENT(1, "events/glock18.sc");
}

int CGLOCK18::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "9mm";
	p->iMaxAmmo1 = _9MM_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = GLOCK18_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 2;
	p->iId = m_iId = WEAPON_GLOCK18;
	p->iFlags = 0;
	p->iWeight = GLOCK18_WEIGHT;

	return 1;
}

BOOL CGLOCK18::Deploy(void)
{
	m_bBurstFire = 0;
	m_iGlock18ShotsFired = 0;
	m_flGlock18Shoot = 0;
	m_flAccuracy = 0.9;
	m_fMaxSpeed = 250;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield() != false)
		return DefaultDeploy("models/shield/v_shield_glock18.mdl", "models/shield/p_shield_glock18.mdl", GLOCK18_SHIELD_DRAW, "shieldgun", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_glock18.mdl", "models/p_glock18.mdl", RANDOM_LONG(0, 1) ? GLOCK18_DRAW : GLOCK18_DRAW2, "onehanded", UseDecrement() != FALSE);
}

void CGLOCK18::SecondaryAttack(void)
{
	if (ShieldSecondaryFire(GLOCK18_SHIELD_UP, GLOCK18_SHIELD_DOWN) == true)
		return;
	//return;

	if (m_iWeaponState & WPNSTATE_GLOCK18_BURST_MODE)
	{
		ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#Switch_To_SemiAuto");
		m_iWeaponState &= ~WPNSTATE_GLOCK18_BURST_MODE;
#ifdef CLIENT_WEAPONS
		g_bGlockBurstMode = false;
#endif
	}
	else
	{
		ClientPrint(m_pPlayer->pev, HUD_PRINTCENTER, "#Switch_To_BurstFire");
		m_iWeaponState |= WPNSTATE_GLOCK18_BURST_MODE;
#ifdef CLIENT_WEAPONS
		g_bGlockBurstMode = true;
#endif
	}

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CGLOCK18::PrimaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_GLOCK18_BURST_MODE)
	{
		if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
			GLOCK18Fire((1.2) * (1 - m_flAccuracy), 0.5, TRUE);
		else if (m_pPlayer->pev->velocity.Length2D() > 0)
			GLOCK18Fire((0.185) * (1 - m_flAccuracy), 0.5, TRUE);
		else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
			GLOCK18Fire((0.095) * (1 - m_flAccuracy), 0.5, TRUE);
		else
			GLOCK18Fire((0.3) * (1 - m_flAccuracy), 0.5, TRUE);
	}
	else
	{
		if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
			GLOCK18Fire((1.0) * (1 - m_flAccuracy), 0.2, FALSE);
		else if (m_pPlayer->pev->velocity.Length2D() > 0)
			GLOCK18Fire((0.165) * (1 - m_flAccuracy), 0.2, FALSE);
		else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
			GLOCK18Fire((0.075) * (1 - m_flAccuracy), 0.2, FALSE);
		else
			GLOCK18Fire((0.1) * (1 - m_flAccuracy), 0.2, FALSE);
	}
}

void CGLOCK18::GLOCK18Fire(float flSpread, float flCycleTime, BOOL fUseBurstMode)
{
	if (fUseBurstMode != FALSE)
	{
		m_iGlock18ShotsFired = 0;
	}
	else
	{
		m_iShotsFired++;
		flCycleTime -= 0.05;

		if (m_iShotsFired > 1)
			return;
	}

	if (m_flLastFire)
	{
		m_flAccuracy -= (0.325 - (gpGlobals->time - m_flLastFire)) * 0.275;

		if (m_flAccuracy > 0.9)
			m_flAccuracy = 0.9;
		else if (m_flAccuracy < 0.6)
			m_flAccuracy = 0.6;
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	SetPlayerShieldAnim();

#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 1, BULLET_PLAYER_9MM, 25, 0.75, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireGlock18, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), m_iClip != 0, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.5;

	if (fUseBurstMode != FALSE)
	{
		m_iGlock18ShotsFired++;
		m_flGlock18Shoot = gpGlobals->time + 0.1;
	}

	ResetPlayerShieldAnim();
}

void CGLOCK18::Reload(void)
{
	if (m_pPlayer->ammo_9mm <= 0)
		return;

	int iAnim;

	if (m_pPlayer->HasShield() != false)
		iAnim = GLOCK18_SHIELD_RELOAD;
	else if (RANDOM_LONG(0, 1))
		iAnim = GLOCK18_RELOAD;
	else
		iAnim = GLOCK18_RELOAD2;

	if (DefaultReload(GLOCK18_MAX_CLIP, iAnim, 2.2))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.9;
	}
}

void CGLOCK18::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_pPlayer->HasShield() != false)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;

		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			SendWeaponAnim(GLOCK18_SHIELD_IDLE, UseDecrement() != FALSE);

		return;
	}

	if (m_iClip)
	{
		float flRand = RANDOM_FLOAT(0, 1);

		if (flRand < 0.3)
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3.0625;
			SendWeaponAnim(GLOCK18_IDLE3, UseDecrement() != FALSE);
		}
		else if (flRand < 0.6)
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3.75;
			SendWeaponAnim(GLOCK18_IDLE1, UseDecrement() != FALSE);
		}
		else
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.5;
			SendWeaponAnim(GLOCK18_IDLE2, UseDecrement() != FALSE);
		}
	}
}

```

`dlls/wpn_shared/wpn_hegrenade.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum hegrenade_e
{
	HEGRENADE_IDLE,
	HEGRENADE_PULLPIN,
	HEGRENADE_THROW,
	HEGRENADE_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_hegrenade, CHEGrenade)

void CHEGrenade::Spawn(void)
{
	Precache();
	m_iId = WEAPON_HEGRENADE;
	SET_MODEL(ENT(pev), "models/w_hegrenade.mdl");

	pev->dmg = 4;
	m_iDefaultAmmo = HEGRENADE_DEFAULT_GIVE;
	m_flStartThrow = 0;
	m_flReleaseThrow = -1;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	FallInit();
}

void CHEGrenade::Precache(void)
{
	PRECACHE_MODEL("models/v_hegrenade.mdl");
	PRECACHE_MODEL("models/shield/v_shield_hegrenade.mdl");

	PRECACHE_SOUND("weapons/hegrenade-1.wav");
	PRECACHE_SOUND("weapons/hegrenade-2.wav");
	PRECACHE_SOUND("weapons/he_bounce-1.wav");
	PRECACHE_SOUND("weapons/pinpull.wav");

	m_usCreateExplosion = PRECACHE_EVENT(1, "events/createexplo.sc");
}

int CHEGrenade::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "HEGrenade";
	p->iMaxAmmo1 = HEGRENADE_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = WEAPON_NOCLIP;
	p->iSlot = 3;
	p->iPosition = 1;
	p->iId = m_iId = WEAPON_HEGRENADE;
	p->iWeight = HEGRENADE_WEIGHT;
	p->iFlags = ITEM_FLAG_LIMITINWORLD | ITEM_FLAG_EXHAUSTIBLE;

	return 1;
}

BOOL CHEGrenade::Deploy(void)
{
	m_flReleaseThrow = -1;
	m_fMaxSpeed = 250;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield() != false)
		return DefaultDeploy("models/shield/v_shield_hegrenade.mdl", "models/shield/p_shield_hegrenade.mdl", HEGRENADE_DRAW, "shieldgren", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_hegrenade.mdl", "models/p_hegrenade.mdl", HEGRENADE_DRAW, "grenade", UseDecrement() != FALSE);
}

BOOL CHEGrenade::CanHolster(void)
{
	return m_flStartThrow == 0;
}

void CHEGrenade::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5;

	if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		m_pPlayer->pev->weapons &= ~(1 << WEAPON_HEGRENADE);
		DestroyItem();
	}

	m_flStartThrow = 0;
	m_flReleaseThrow = -1;
}

void CHEGrenade::PrimaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		return;

	if (!m_flStartThrow && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] > 0)
	{
		m_flStartThrow = gpGlobals->time;
		m_flReleaseThrow = 0;
		SendWeaponAnim(HEGRENADE_PULLPIN, UseDecrement() != FALSE);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.5;
	}
}

void CHEGrenade::SetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strcpy(m_pPlayer->m_szAnimExtention, "shield");
		else
			strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
	}
}

void CHEGrenade::ResetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
	}
}

bool CHEGrenade::ShieldSecondaryFire(int up_anim, int down_anim)
{
	if (m_pPlayer->HasShield() == false)
		return false;

	if (m_flStartThrow > 0)
		return false;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(down_anim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
		m_fMaxSpeed = 250;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(up_anim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shielded");
		m_fMaxSpeed = 180;
		m_pPlayer->m_bShieldDrawn = true;
	}

#ifndef CLIENT_DLL
	m_pPlayer->UpdateShieldCrosshair((m_iWeaponState & WPNSTATE_SHIELD_DRAWN) == 0);
	m_pPlayer->ResetMaxSpeed();
#endif
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.6;
	return true;
}

void CHEGrenade::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_DRAW, SHIELDGUN_DRAWN_IDLE);
}

void CHEGrenade::WeaponIdle(void)
{
	if (!m_flReleaseThrow && m_flStartThrow)
		m_flReleaseThrow = gpGlobals->time;

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_flStartThrow)
	{
#ifndef CLIENT_DLL
		m_pPlayer->Radio("%!MRAD_FIREINHOLE", "#Fire_in_the_hole");
#endif
		Vector angThrow = m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle;

		if (angThrow.x < 0)
			angThrow.x = -10 + angThrow.x * ((90 - 10) / 90.0);
		else
			angThrow.x = -10 + angThrow.x * ((90 + 10) / 90.0);

		float flVel = (90 - angThrow.x) * 6;

		if (flVel > 750)
			flVel = 750;

		UTIL_MakeVectors(angThrow);
		Vector vecSrc = m_pPlayer->pev->origin + m_pPlayer->pev->view_ofs + gpGlobals->v_forward * 16;
		Vector vecThrow = gpGlobals->v_forward * flVel + m_pPlayer->pev->velocity;
		float time = 1.5;
		CGrenade::ShootTimed2(m_pPlayer->pev, vecSrc, vecThrow, time, m_pPlayer->m_iTeam, m_usCreateExplosion);

		SendWeaponAnim(HEGRENADE_THROW, UseDecrement() != FALSE);
		SetPlayerShieldAnim();

#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		m_flStartThrow = 0;
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.5;
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.75;
		m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]--;

		if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
			m_flTimeWeaponIdle = m_flNextSecondaryAttack = m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.5;

		ResetPlayerShieldAnim();
		return;
	}
	else if (m_flReleaseThrow > 0)
	{
		m_flStartThrow = 0;

		if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
		{
			SendWeaponAnim(HEGRENADE_DRAW, UseDecrement() != FALSE);
			m_flReleaseThrow = -1;
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
		}
		else
			RetireWeapon();

		return;
	}

	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		if (m_pPlayer->HasShield() != false)
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0;

			if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
				SendWeaponAnim(SHIELDREN_IDLE, UseDecrement() != FALSE);

			return;
		}

		SendWeaponAnim(HEGRENADE_IDLE, UseDecrement() != FALSE);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
	}
}

BOOL CHEGrenade::CanDeploy(void)
{
	return m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] != 0;
}

```

`dlls/wpn_shared/wpn_knife.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

#define KNIFE_BODYHIT_VOLUME 128
#define KNIFE_WALLHIT_VOLUME 512

LINK_ENTITY_TO_CLASS(weapon_knife, CKnife)

enum knife_e
{
	KNIFE_IDLE,
	KNIFE_ATTACK1HIT,
	KNIFE_ATTACK2HIT,
	KNIFE_DRAW,
	KNIFE_STABHIT,
	KNIFE_STABMISS,
	KNIFE_MIDATTACK1HIT,
	KNIFE_MIDATTACK2HIT
};

enum knife_shield_e
{
	KNIFE_SHIELD_IDLE,
	KNIFE_SHIELD_SLASH,
	KNIFE_SHIELD_ATTACKHIT,
	KNIFE_SHIELD_DRAW,
	KNIFE_SHIELD_UPIDLE,
	KNIFE_SHIELD_UP,
	KNIFE_SHIELD_DOWN
};

void CKnife::Spawn(void)
{
	Precache();
	m_iId = WEAPON_KNIFE;
	SET_MODEL(ENT(pev), "models/w_knife.mdl");

	m_iClip = WEAPON_NOCLIP;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	FallInit();
}

void CKnife::Precache(void)
{
	PRECACHE_MODEL("models/v_knife.mdl");
	PRECACHE_MODEL("models/shield/v_shield_knife.mdl");
	PRECACHE_MODEL("models/w_knife.mdl");

	PRECACHE_SOUND("weapons/knife_deploy1.wav");
	PRECACHE_SOUND("weapons/knife_hit1.wav");
	PRECACHE_SOUND("weapons/knife_hit2.wav");
	PRECACHE_SOUND("weapons/knife_hit3.wav");
	PRECACHE_SOUND("weapons/knife_hit4.wav");
	PRECACHE_SOUND("weapons/knife_slash1.wav");
	PRECACHE_SOUND("weapons/knife_slash2.wav");
	PRECACHE_SOUND("weapons/knife_stab.wav");
	PRECACHE_SOUND("weapons/knife_hitwall1.wav");

	m_usKnife = PRECACHE_EVENT(1, "events/knife.sc");
}

int CKnife::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = NULL;
	p->iMaxAmmo1 = -1;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = WEAPON_NOCLIP;
	p->iSlot = 2;
	p->iPosition = 1;
	p->iId = WEAPON_KNIFE;
	p->iFlags = 0;
	p->iWeight = KNIFE_WEIGHT;

	return 1;
}

BOOL CKnife::Deploy(void)
{
	EMIT_SOUND(ENT(m_pPlayer->pev), CHAN_ITEM, "weapons/knife_deploy1.wav", 0.3, 2.4);

	m_fMaxSpeed = 250;
	m_iSwing = 0;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield() != false)
		return DefaultDeploy("models/shield/v_shield_knife.mdl", "models/shield/p_shield_knife.mdl", KNIFE_SHIELD_DRAW, "shieldknife", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_knife.mdl", "models/p_knife.mdl", KNIFE_DRAW, "knife", UseDecrement() != FALSE);
}

void CKnife::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5;
}

void CKnife::WeaponAnimation(int iAnimation)
{
	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usKnife, 0, (float *)&g_vecZero, (float *)&g_vecZero, 0, 0, iAnimation, 2, 3, 4);
}

void FindHullIntersection(const Vector &vecSrc, TraceResult &tr, float *pflMins, float *pfkMaxs, edict_t *pEntity)
{
	TraceResult trTemp;
	float flDistance = 1000000;
	float *pflMinMaxs[2] = { pflMins, pfkMaxs };
	Vector vecHullEnd = tr.vecEndPos;

	vecHullEnd = vecSrc + ((vecHullEnd - vecSrc) * 2);
	TRACE_LINE(vecSrc, vecHullEnd, dont_ignore_monsters, pEntity, &trTemp);

	if (trTemp.flFraction < 1)
	{
		tr = trTemp;
		return;
	}

	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			for (int k = 0; k < 2; k++)
			{
				Vector vecEnd;
				vecEnd.x = vecHullEnd.x + pflMinMaxs[i][0];
				vecEnd.y = vecHullEnd.y + pflMinMaxs[j][1];
				vecEnd.z = vecHullEnd.z + pflMinMaxs[k][2];

				TRACE_LINE(vecSrc, vecEnd, dont_ignore_monsters, pEntity, &trTemp);

				if (trTemp.flFraction < 1)
				{
					float flThisDistance = (trTemp.vecEndPos - vecSrc).Length();

					if (flThisDistance < flDistance)
					{
						tr = trTemp;
						flDistance = flThisDistance;
					}
				}
			}
		}
	}
}

void CKnife::PrimaryAttack(void)
{
	Swing(TRUE);
}

void CKnife::SetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strcpy(m_pPlayer->m_szAnimExtention, "shield");
		else
			strcpy(m_pPlayer->m_szAnimExtention, "shieldknife");
	}
}

void CKnife::ResetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strcpy(m_pPlayer->m_szAnimExtention, "shieldknife");
	}
}

bool CKnife::ShieldSecondaryFire(int up_anim, int down_anim)
{
	if (m_pPlayer->HasShield() == false)
		return false;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(down_anim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shieldknife");
		m_fMaxSpeed = 250;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(up_anim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shielded");
		m_fMaxSpeed = 180;
		m_pPlayer->m_bShieldDrawn = true;
	}

#ifndef CLIENT_DLL
	m_pPlayer->UpdateShieldCrosshair((m_iWeaponState & WPNSTATE_SHIELD_DRAWN) == 0);
	m_pPlayer->ResetMaxSpeed();
#endif
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.6;
	return true;
}

void CKnife::SecondaryAttack(void)
{
	if (ShieldSecondaryFire(KNIFE_SHIELD_UP, KNIFE_SHIELD_DOWN) == true)
		return;

	Stab(TRUE);
	pev->nextthink = UTIL_WeaponTimeBase() + 0.35;
}

void CKnife::Smack(void)
{
	DecalGunshot(&m_trHit, BULLET_PLAYER_CROWBAR, false, m_pPlayer->pev, false);
}

void CKnife::SwingAgain(void)
{
	Swing(FALSE);
}

void CKnife::WeaponIdle(void)
{
	ResetEmptySound();
 	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_pPlayer->m_bShieldDrawn != true)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
		SendWeaponAnim(KNIFE_IDLE, UseDecrement() != FALSE);
	}
}

int CKnife::Swing(int fFirst)
{
	BOOL fDidHit = FALSE;
	UTIL_MakeVectors(m_pPlayer->pev->v_angle);
	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecEnd = vecSrc + gpGlobals->v_forward * 48;

	TraceResult tr;
	UTIL_TraceLine(vecSrc, vecEnd, dont_ignore_monsters, ENT(m_pPlayer->pev), &tr);

	if (tr.flFraction >= 1)
	{
		UTIL_TraceHull(vecSrc, vecEnd, dont_ignore_monsters, head_hull, ENT(m_pPlayer->pev), &tr);

		if (tr.flFraction < 1)
		{
			CBaseEntity *pHit = CBaseEntity::Instance(tr.pHit);

			if (!pHit || pHit->IsBSPModel())
				FindHullIntersection(vecSrc, tr, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX, ENT(m_pPlayer->pev));

			vecEnd = tr.vecEndPos;
		}
	}

	if (tr.flFraction >= 1)
	{
		if (fFirst)
		{
			if (m_pPlayer->HasShield() == false)
			{
				switch ((m_iSwing++) % 2)
				{
					case 0: SendWeaponAnim(KNIFE_MIDATTACK1HIT, UseDecrement() != FALSE); break;
					case 1: SendWeaponAnim(KNIFE_MIDATTACK2HIT, UseDecrement() != FALSE); break;
				}

				m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.35;
				m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.5;
			}
			else
			{
				SendWeaponAnim(KNIFE_SHIELD_ATTACKHIT, UseDecrement() != FALSE);

				m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1.0;
				m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.2;
			}

			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;

			if (RANDOM_LONG(0, 1))
				EMIT_SOUND_DYN(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/knife_slash1.wav", VOL_NORM, ATTN_NORM, 0, 94);
			else
				EMIT_SOUND_DYN(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/knife_slash2.wav", VOL_NORM, ATTN_NORM, 0, 94);

#ifndef CLIENT_DLL
			m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		}
	}
	else
	{
		fDidHit = TRUE;

		if (m_pPlayer->HasShield() == false)
		{
			switch ((m_iSwing++) % 2)
			{
				case 0: SendWeaponAnim(KNIFE_MIDATTACK1HIT, UseDecrement() != FALSE); break;
				case 1: SendWeaponAnim(KNIFE_MIDATTACK2HIT, UseDecrement() != FALSE); break;
			}

			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.4;
			m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.5;
		}
		else
		{
			SendWeaponAnim(KNIFE_SHIELD_ATTACKHIT, UseDecrement() != FALSE);

			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1.0;
			m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.2;
		}

		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;

		CBaseEntity *pEntity = CBaseEntity::Instance(tr.pHit);
		SetPlayerShieldAnim();

#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		ClearMultiDamage();
		if (pEntity)
		{
			if (m_flNextPrimaryAttack + 0.4 < UTIL_WeaponTimeBase())
				pEntity->TraceAttack(m_pPlayer->pev, 20, gpGlobals->v_forward, &tr, DMG_NEVERGIB | DMG_BULLET);
			else
				pEntity->TraceAttack(m_pPlayer->pev, 15, gpGlobals->v_forward, &tr, DMG_NEVERGIB | DMG_BULLET);
		}
		ApplyMultiDamage(m_pPlayer->pev, m_pPlayer->pev);

		float flVol = 1;
#ifndef CLIENT_DLL
		int fHitWorld = TRUE;
#endif
		if (pEntity)
		{
			if (pEntity->Classify() != CLASS_NONE && pEntity->Classify() != CLASS_MACHINE)
			{
				switch (RANDOM_LONG(0, 3))
				{
					case 0: EMIT_SOUND(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/knife_hit1.wav", VOL_NORM, ATTN_NORM); break;
					case 1: EMIT_SOUND(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/knife_hit2.wav", VOL_NORM, ATTN_NORM); break;
					case 2: EMIT_SOUND(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/knife_hit3.wav", VOL_NORM, ATTN_NORM); break;
					case 3: EMIT_SOUND(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/knife_hit4.wav", VOL_NORM, ATTN_NORM); break;
				}

				m_pPlayer->m_iWeaponVolume = KNIFE_BODYHIT_VOLUME;

				if (!pEntity->IsAlive())
					return TRUE;

				flVol = 0.1;
#ifndef CLIENT_DLL
				fHitWorld = FALSE;
#endif
			}
		}

#ifndef CLIENT_DLL
		if (fHitWorld)
		{
			TEXTURETYPE_PlaySound(&tr, vecSrc, vecSrc + (vecEnd - vecSrc) * 2, BULLET_PLAYER_CROWBAR);
			EMIT_SOUND_DYN(ENT(m_pPlayer->pev), CHAN_ITEM, "weapons/knife_hitwall1.wav", VOL_NORM, ATTN_NORM, 0, 98 + RANDOM_LONG(0, 3));
		}
#endif

		m_trHit = tr;
		m_pPlayer->m_iWeaponVolume = flVol * KNIFE_WALLHIT_VOLUME;

		SetThink(&CKnife::Smack);
		pev->nextthink = UTIL_WeaponTimeBase() + 0.2;
		SetPlayerShieldAnim();
	}

	return fDidHit;
}

int CKnife::Stab(int fFirst)
{
	BOOL fDidHit = FALSE;
	UTIL_MakeVectors(m_pPlayer->pev->v_angle);
	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecEnd = vecSrc + gpGlobals->v_forward * 32;

	TraceResult tr;
	UTIL_TraceLine(vecSrc, vecEnd, dont_ignore_monsters, ENT(m_pPlayer->pev), &tr);

	if (tr.flFraction >= 1)
	{
		UTIL_TraceHull(vecSrc, vecEnd, dont_ignore_monsters, head_hull, ENT(m_pPlayer->pev), &tr);

		if (tr.flFraction < 1)
		{
			CBaseEntity *pHit = CBaseEntity::Instance(tr.pHit);

			if (!pHit || pHit->IsBSPModel())
				FindHullIntersection(vecSrc, tr, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX, ENT(m_pPlayer->pev));

			vecEnd = tr.vecEndPos;
		}
	}

	if (tr.flFraction >= 1)
	{
		if (fFirst)
		{
			SendWeaponAnim(KNIFE_STABMISS, UseDecrement() != FALSE);

			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1;
			m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1;

			if (RANDOM_LONG(0, 1))
				EMIT_SOUND_DYN(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/knife_slash1.wav", VOL_NORM, ATTN_NORM, 0, 94);
			else
				EMIT_SOUND_DYN(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/knife_slash2.wav", VOL_NORM, ATTN_NORM, 0, 94);
#ifndef CLIENT_DLL
			m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		}
	}
	else
	{
		fDidHit = TRUE;

#ifndef CLIENT_DLL
		SendWeaponAnim(KNIFE_STABHIT, UseDecrement() != FALSE);
#endif
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1.1;
		m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1.1;

		CBaseEntity *pEntity = CBaseEntity::Instance(tr.pHit);

#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		float flDamage = 65.0;

		if (pEntity && pEntity->IsPlayer())
		{
			Vector2D vec2LOS;
			Vector vecForward = gpGlobals->v_forward;

			UTIL_MakeVectors(m_pPlayer->pev->angles);

			vec2LOS = vecForward.Make2D();
			vec2LOS = vec2LOS.Normalize();

			if (DotProduct(vec2LOS, gpGlobals->v_forward.Make2D()) > 0.8)
				flDamage *= 3.0;
		}

		UTIL_MakeVectors(m_pPlayer->pev->v_angle);
		ClearMultiDamage();
		if (pEntity)
			pEntity->TraceAttack(m_pPlayer->pev, flDamage, gpGlobals->v_forward, &tr, DMG_NEVERGIB | DMG_BULLET);
		ApplyMultiDamage(m_pPlayer->pev, m_pPlayer->pev);

		float flVol = 1;
#ifndef CLIENT_DLL
		int fHitWorld = TRUE;
#endif
		if (pEntity)
		{
			if (pEntity->Classify() != CLASS_NONE && pEntity->Classify() != CLASS_MACHINE)
			{
				EMIT_SOUND(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/knife_stab.wav", VOL_NORM, ATTN_NORM);
				m_pPlayer->m_iWeaponVolume = KNIFE_BODYHIT_VOLUME;

				if (!pEntity->IsAlive())
					return TRUE;

				flVol = 0.1;
#ifndef CLIENT_DLL
				fHitWorld = FALSE;
#endif
			}
		}

#ifndef CLIENT_DLL
		if (fHitWorld)
		{
			TEXTURETYPE_PlaySound(&tr, vecSrc, vecSrc + (vecEnd - vecSrc) * 2, BULLET_PLAYER_CROWBAR);
			EMIT_SOUND_DYN(ENT(m_pPlayer->pev), CHAN_ITEM, "weapons/knife_hitwall1.wav", VOL_NORM, ATTN_NORM, 0, 98 + RANDOM_LONG(0, 3));
		}
#endif

		m_trHit = tr;
		m_pPlayer->m_iWeaponVolume = flVol * KNIFE_WALLHIT_VOLUME;

		SetThink(&CKnife::Smack);
		pev->nextthink = UTIL_WeaponTimeBase() + 0.2;
	}

	return fDidHit;
}

```

`dlls/wpn_shared/wpn_m249.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum m249_e
{
	M249_IDLE1,
	M249_SHOOT1,
	M249_SHOOT2,
	M249_RELOAD,
	M249_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_m249, CM249)

void CM249::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_m249");

	Precache();
	m_iId = WEAPON_M249;
	SET_MODEL(ENT(pev), "models/w_m249.mdl");

	m_iDefaultAmmo = M249_DEFAULT_GIVE;
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;

	FallInit();
}

void CM249::Precache(void)
{
	PRECACHE_MODEL("models/v_m249.mdl");
	PRECACHE_MODEL("models/w_m249.mdl");

	PRECACHE_SOUND("weapons/m249-1.wav");
	PRECACHE_SOUND("weapons/m249-2.wav");
	PRECACHE_SOUND("weapons/m249_boxout.wav");
	PRECACHE_SOUND("weapons/m249_boxin.wav");
	PRECACHE_SOUND("weapons/m249_chain.wav");
	PRECACHE_SOUND("weapons/m249_coverup.wav");
	PRECACHE_SOUND("weapons/m249_coverdown.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireM249 = PRECACHE_EVENT(1, "events/m249.sc");
}

int CM249::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556NatoBox";
	p->iMaxAmmo1 = _556NATOBOX_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = M249_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 4;
	p->iId = m_iId = WEAPON_M249;
	p->iFlags = 0;
	p->iWeight = M249_WEIGHT;

	return 1;
}

BOOL CM249::Deploy(void)
{
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_m249.mdl", "models/p_m249.mdl", M249_DRAW, "m249", UseDecrement() != FALSE);
}

void CM249::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		M249Fire(0.045 + (0.5) * m_flAccuracy, 0.1, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
		M249Fire(0.045 + (0.095) * m_flAccuracy, 0.1, FALSE);
	else
		M249Fire((0.03) * m_flAccuracy, 0.1, FALSE);
}

void CM249::M249Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 175.0) + 0.4;

	if (m_flAccuracy > 0.9)
		m_flAccuracy = 0.9;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 2, BULLET_PLAYER_556MM, 32, 0.97, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireM249, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.6;

	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(1.8, 0.65, 0.45, 0.125, 5.0, 3.5, 8);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(1.1, 0.5, 0.3, 0.06, 4.0, 3.0, 8);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.75, 0.325, 0.25, 0.025, 3.5, 2.5, 9);
	else
		KickBack(0.8, 0.35, 0.3, 0.03, 3.75, 3.0, 9);
}

void CM249::Reload(void)
{
	if (m_pPlayer->ammo_556natobox <= 0)
		return;

	if (DefaultReload(M249_MAX_CLIP, M249_RELOAD, 4.7))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2;
		m_bDelayFire = false;
		m_iShotsFired = 0;
	}
}

void CM249::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(M249_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_m3.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum m3_e
{
	M3_IDLE,
	M3_FIRE1,
	M3_FIRE2,
	M3_RELOAD,
	M3_PUMP,
	M3_START_RELOAD,
	M3_DRAW,
	M3_HOLSTER
};

LINK_ENTITY_TO_CLASS(weapon_m3, CM3)

void CM3::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_m3");

	Precache();
	m_iId = WEAPON_M3;
	SET_MODEL(ENT(pev), "models/w_m3.mdl");
	m_iDefaultAmmo = M3_DEFAULT_GIVE;

	FallInit();
}

void CM3::Precache(void)
{
	PRECACHE_MODEL("models/v_m3.mdl");
	PRECACHE_MODEL("models/w_m3.mdl");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/shotgunshell.mdl");

	PRECACHE_SOUND("weapons/m3-1.wav");
	PRECACHE_SOUND("weapons/m3_insertshell.wav");
	PRECACHE_SOUND("weapons/m3_pump.wav");
	PRECACHE_SOUND("weapons/reload1.wav");
	PRECACHE_SOUND("weapons/reload3.wav");

	m_usFireM3 = PRECACHE_EVENT(1, "events/m3.sc");
}

int CM3::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "buckshot";
	p->iMaxAmmo1 = BUCKSHOT_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = M3_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 5;
	p->iId = m_iId = WEAPON_M3;
	p->iFlags = 0;
	p->iWeight = M3_WEIGHT;

	return 1;
}

BOOL CM3::Deploy(void)
{
	return DefaultDeploy("models/v_m3.mdl", "models/p_m3.mdl", M3_DRAW, "shotgun", UseDecrement() != FALSE);
}

void CM3::PrimaryAttack(void)
{
	if (m_pPlayer->pev->waterlevel == 3)
	{
		PlayEmptySound();
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.15;
		return;
	}

	if (m_iClip <= 0)
	{
		Reload();

		if (m_iClip == 0)
			PlayEmptySound();

		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1.0;
		return;
	}

	m_pPlayer->m_iWeaponVolume = LOUD_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);
#ifndef CLIENT_DLL
	m_pPlayer->FireBullets(9, m_pPlayer->GetGunPosition(), gpGlobals->v_forward, Vector(0.0675, 0.0675, 0), 3000, BULLET_PLAYER_BUCKSHOT, 0);
#endif

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireM3, 0, (float *)&g_vecZero, (float *)&g_vecZero, 0, 0, 0, 0, FALSE, FALSE);

	if (m_iClip)
		m_flPumpTime = UTIL_WeaponTimeBase() + 0.5;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	if (m_iClip)
		m_flPumpTime = UTIL_WeaponTimeBase() + 0.5;

	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.875;
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.875;

	if (m_iClip)
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.5;
	else
		m_flTimeWeaponIdle = 0.875;

	m_fInSpecialReload = 0;

	if (m_pPlayer->pev->flags & FL_ONGROUND)
		m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomLong(m_pPlayer->random_seed + 1, 4, 6);
	else
		m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomLong(m_pPlayer->random_seed + 1, 8, 11);

	m_pPlayer->m_flEjectBrass = gpGlobals->time + 0.45;
}

void CM3::Reload(void)
{
	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0 || m_iClip == M3_MAX_CLIP)
		return;

	if (m_flNextPrimaryAttack > UTIL_WeaponTimeBase())
		return;

	if (!m_fInSpecialReload)
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		SendWeaponAnim(M3_START_RELOAD, UseDecrement() != FALSE);

		m_fInSpecialReload = 1;
		m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.55;
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.55;
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.55;
		m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.55;
	}
	else if (m_fInSpecialReload == 1)
	{
		if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
			return;

		m_fInSpecialReload = 2;
		SendWeaponAnim(M3_RELOAD, UseDecrement() != FALSE);

		m_flNextReload = UTIL_WeaponTimeBase() + 0.45;
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.45;
	}
	else
	{
		m_iClip++;
		m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]--;
		m_fInSpecialReload = 1;
		m_pPlayer->ammo_buckshot--;
	}
}

void CM3::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_5DEGREES);

	if (m_flPumpTime && m_flPumpTime < UTIL_WeaponTimeBase())
		m_flPumpTime = 0;

	if (m_flTimeWeaponIdle < UTIL_WeaponTimeBase())
	{
		if (m_iClip == 0 && m_fInSpecialReload == 0 && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
		{
			Reload();
		}
		else if (m_fInSpecialReload != 0)
		{
			if (m_iClip != M3_MAX_CLIP && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
			{
				Reload();
			}
			else
			{
				SendWeaponAnim(M3_PUMP, UseDecrement() != FALSE);

				m_fInSpecialReload = 0;
				m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.5;
			}
		}
		else
			SendWeaponAnim(M3_IDLE, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_m4a1.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum m4a1_e
{
	M4A1_IDLE,
	M4A1_SHOOT1,
	M4A1_SHOOT2,
	M4A1_SHOOT3,
	M4A1_RELOAD,
	M4A1_DRAW,
	M4A1_ATTACH_SILENCER,
	M4A1_UNSIL_IDLE,
	M4A1_UNSIL_SHOOT1,
	M4A1_UNSIL_SHOOT2,
	M4A1_UNSIL_SHOOT3,
	M4A1_UNSIL_RELOAD,
	M4A1_UNSIL_DRAW,
	M4A1_DETACH_SILENCER
};

LINK_ENTITY_TO_CLASS(weapon_m4a1, CM4A1)

void CM4A1::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_m4a1");

	Precache();
	m_iId = WEAPON_M4A1;
	SET_MODEL(ENT(pev), "models/w_m4a1.mdl");

	m_iDefaultAmmo = M4A1_DEFAULT_GIVE;
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;
	m_bDelayFire = true;

	FallInit();
}

void CM4A1::Precache(void)
{
	PRECACHE_MODEL("models/v_m4a1.mdl");
	PRECACHE_MODEL("models/w_m4a1.mdl");

	PRECACHE_SOUND("weapons/m4a1-1.wav");
	PRECACHE_SOUND("weapons/m4a1_unsil-1.wav");
	PRECACHE_SOUND("weapons/m4a1_unsil-2.wav");
	PRECACHE_SOUND("weapons/m4a1_clipin.wav");
	PRECACHE_SOUND("weapons/m4a1_clipout.wav");
	PRECACHE_SOUND("weapons/m4a1_boltpull.wav");
	PRECACHE_SOUND("weapons/m4a1_deploy.wav");
	PRECACHE_SOUND("weapons/m4a1_silencer_on.wav");
	PRECACHE_SOUND("weapons/m4a1_silencer_off.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireM4A1 = PRECACHE_EVENT(1, "events/m4a1.sc");
}

int CM4A1::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = _556NATO_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = M4A1_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 6;
	p->iId = m_iId = WEAPON_M4A1;
	p->iFlags = 0;
	p->iWeight = M4A1_WEIGHT;

	return 1;
}

BOOL CM4A1::Deploy(void)
{
	m_bDelayFire = true;
	iShellOn = 1;
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;

	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
		return DefaultDeploy("models/v_m4a1.mdl", "models/p_m4a1.mdl", M4A1_DRAW, "rifle", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_m4a1.mdl", "models/p_m4a1.mdl", M4A1_UNSIL_DRAW, "rifle", UseDecrement() != FALSE);
}

void CM4A1::SecondaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
	{
		m_iWeaponState &= ~WPNSTATE_M4A1_SILENCED;
		SendWeaponAnim(M4A1_DETACH_SILENCER, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "rifle");
	}
	else
	{
		m_iWeaponState |= WPNSTATE_M4A1_SILENCED;
		SendWeaponAnim(M4A1_ATTACH_SILENCER, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "rifle");
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 2;
	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 2;
}

void CM4A1::PrimaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
	{
		if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
			M4A1Fire(0.035 + (0.4) * m_flAccuracy, 0.0875, FALSE);
		else if (m_pPlayer->pev->velocity.Length2D() > 140)
			M4A1Fire(0.035 + (0.07) * m_flAccuracy, 0.0875, FALSE);
		else
			M4A1Fire((0.025) * m_flAccuracy, 0.0875, FALSE);
	}
	else
	{
		if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
			M4A1Fire(0.035 + (0.4) * m_flAccuracy, 0.0875, FALSE);
		else if (m_pPlayer->pev->velocity.Length2D() > 140)
			M4A1Fire(0.035 + (0.07) * m_flAccuracy, 0.0875, FALSE);
		else
			M4A1Fire((0.02) * m_flAccuracy, 0.0875, FALSE);
	}
}

void CM4A1::M4A1Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 220) + 0.3;

	if (m_flAccuracy > 1)
		m_flAccuracy = 1;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir;

	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
	{
		vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 2, BULLET_PLAYER_556MM, 33, 0.95, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);
	}
	else
	{
		vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 2, BULLET_PLAYER_556MM, 32, 0.97, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);
		m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	}

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireM4A1, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), (m_iWeaponState & WPNSTATE_M4A1_SILENCED) ? true : false, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.5;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(1.0, 0.45, 0.28, 0.045, 3.75, 3.0, 7);
	else if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(1.2, 0.5, 0.23, 0.15, 5.5, 3.5, 6);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.6, 0.3, 0.2, 0.0125, 3.25, 2.0, 7);
	else
		KickBack(0.65, 0.35, 0.25, 0.015, 3.5, 2.25, 7);
}

void CM4A1::Reload(void)
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	int iAnim;

	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
		iAnim = M4A1_RELOAD;
	else
		iAnim = M4A1_UNSIL_RELOAD;

	if (DefaultReload(M4A1_MAX_CLIP, iAnim, 3.05))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CM4A1::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;

	if (m_iWeaponState & WPNSTATE_M4A1_SILENCED)
		SendWeaponAnim(M4A1_IDLE, UseDecrement() != FALSE);
	else
		SendWeaponAnim(M4A1_UNSIL_IDLE, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_mac10.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum mac10_e
{
	MAC10_IDLE1,
	MAC10_RELOAD,
	MAC10_DRAW,
	MAC10_SHOOT1,
	MAC10_SHOOT2,
	MAC10_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_mac10, CMAC10)

void CMAC10::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_mac10");

	Precache();
	m_iId = WEAPON_MAC10;
	SET_MODEL(ENT(pev), "models/w_mac10.mdl");

	m_iDefaultAmmo = MAC10_DEFAULT_GIVE;
	m_flAccuracy = 0.15;
	m_bDelayFire = false;

	FallInit();
}

void CMAC10::Precache(void)
{
	PRECACHE_MODEL("models/v_mac10.mdl");
	PRECACHE_MODEL("models/w_mac10.mdl");

	PRECACHE_SOUND("weapons/mac10-1.wav");
	PRECACHE_SOUND("weapons/mac10_clipout.wav");
	PRECACHE_SOUND("weapons/mac10_clipin.wav");
	PRECACHE_SOUND("weapons/mac10_boltpull.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireMAC10 = PRECACHE_EVENT(1, "events/mac10.sc");
}

int CMAC10::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "45acp";
	p->iMaxAmmo1 = _45ACP_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = MAC10_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 13;
	p->iId = m_iId = WEAPON_MAC10;
	p->iFlags = 0;
	p->iWeight = MAC10_WEIGHT;

	return 1;
}

BOOL CMAC10::Deploy(void)
{
	m_flAccuracy = 0.15;
	iShellOn = 1;
	m_bDelayFire = false;

	return DefaultDeploy("models/v_mac10.mdl", "models/p_mac10.mdl", MAC10_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CMAC10::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		MAC10Fire((0.375) * m_flAccuracy, 0.07, FALSE);
	else
		MAC10Fire((0.03) * m_flAccuracy, 0.07, FALSE);
}

void CMAC10::MAC10Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((m_iShotsFired * m_iShotsFired * m_iShotsFired) / 200.0) + 0.6;

	if (m_flAccuracy > 1.65)
		m_flAccuracy = 1.65;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 1, BULLET_PLAYER_45ACP, 29, 0.82, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireMAC10, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;

	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(1.3, 0.55, 0.4, 0.05, 4.75, 3.75, 5);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(0.9, 0.45, 0.25, 0.035, 3.5, 2.75, 7);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.75, 0.4, 0.175, 0.03, 2.75, 2.5, 10);
	else
		KickBack(0.775, 0.425, 0.2, 0.03, 3.0, 2.75, 9);
}

void CMAC10::Reload(void)
{
	if (m_pPlayer->ammo_45acp <= 0)
		return;

	if (DefaultReload(MAC10_MAX_CLIP, MAC10_RELOAD, 3.15))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0;
		m_iShotsFired = 0;
	}
}

void CMAC10::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(MAC10_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_mp5navy.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum mp5n_e
{
	MP5N_IDLE1,
	MP5N_RELOAD,
	MP5N_DRAW,
	MP5N_SHOOT1,
	MP5N_SHOOT2,
	MP5N_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_mp5navy, CMP5N)

void CMP5N::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_mp5navy");

	Precache();
	m_iId = WEAPON_MP5N;
	SET_MODEL(ENT(pev), "models/w_mp5.mdl");

	m_iDefaultAmmo = MP5NAVY_DEFAULT_GIVE;
	m_flAccuracy = 0;
	m_bDelayFire = false;

	FallInit();
}

void CMP5N::Precache(void)
{
	PRECACHE_MODEL("models/v_mp5.mdl");
	PRECACHE_MODEL("models/w_mp5.mdl");

	PRECACHE_SOUND("weapons/mp5-1.wav");
	PRECACHE_SOUND("weapons/mp5-2.wav");
	PRECACHE_SOUND("weapons/mp5_clipout.wav");
	PRECACHE_SOUND("weapons/mp5_clipin.wav");
	PRECACHE_SOUND("weapons/mp5_slideback.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireMP5N = PRECACHE_EVENT(1, "events/mp5n.sc");
}

int CMP5N::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "9mm";
	p->iMaxAmmo1 = _9MM_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = MP5N_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 7;
	p->iId = m_iId = WEAPON_MP5N;
	p->iFlags = 0;
	p->iWeight = MP5NAVY_WEIGHT;

	return 1;
}

BOOL CMP5N::Deploy(void)
{
	m_flAccuracy = 0;
	m_bDelayFire = false;
	iShellOn = 1;

	return DefaultDeploy("models/v_mp5.mdl", "models/p_mp5.mdl", MP5N_DRAW, "mp5", UseDecrement() != FALSE);
}

void CMP5N::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		MP5NFire((0.2) * m_flAccuracy, 0.075, FALSE);
	else
		MP5NFire((0.04) * m_flAccuracy, 0.075, FALSE);
}

void CMP5N::MP5NFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 220.0) + 0.45;

	if (m_flAccuracy > 0.75)
		m_flAccuracy = 0.75;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);
	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 1, BULLET_PLAYER_9MM, 26, 0.84, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireMP5N, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;

	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(0.9, 0.475, 0.35, 0.0425, 5.0, 3.0, 6);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(0.5, 0.275, 0.2, 0.03, 3.0, 2.0, 10);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.225, 0.15, 0.1, 0.015, 2.0, 1.0, 10);
	else
		KickBack(0.25, 0.175, 0.125, 0.02, 2.25, 1.25, 10);
}

void CMP5N::Reload(void)
{
	if (m_pPlayer->ammo_9mm <= 0)
		return;

	if (DefaultReload(MP5N_MAX_CLIP, MP5N_RELOAD, 2.63))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0;
		m_iShotsFired = 0;
	}
}

void CMP5N::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(MP5N_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_p228.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum p228_e
{
	P228_IDLE,
	P228_SHOOT1,
	P228_SHOOT2,
	P228_SHOOT3,
	P228_SHOOT_EMPTY,
	P228_RELOAD,
	P228_DRAW
};

enum p228_shield_e
{
	P228_SHIELD_IDLE,
	P228_SHIELD_SHOOT1,
	P228_SHIELD_SHOOT2,
	P228_SHIELD_SHOOT_EMPTY,
	P228_SHIELD_RELOAD,
	P228_SHIELD_DRAW,
	P228_SHIELD_IDLE_UP,
	P228_SHIELD_UP,
	P228_SHIELD_DOWN
};

LINK_ENTITY_TO_CLASS(weapon_p228, CP228)

void CP228::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_p228");

	Precache();
	m_iId = WEAPON_P228;
	SET_MODEL(ENT(pev), "models/w_p228.mdl");

	m_iDefaultAmmo = P228_DEFAULT_GIVE;
	m_flAccuracy = 0.9;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	FallInit();
}

void CP228::Precache(void)
{
	PRECACHE_MODEL("models/v_p228.mdl");
	PRECACHE_MODEL("models/w_p228.mdl");
	PRECACHE_MODEL("models/shield/v_shield_p228.mdl");

	PRECACHE_SOUND("weapons/p228-1.wav");
	PRECACHE_SOUND("weapons/p228_clipout.wav");
	PRECACHE_SOUND("weapons/p228_clipin.wav");
	PRECACHE_SOUND("weapons/p228_sliderelease.wav");
	PRECACHE_SOUND("weapons/p228_slidepull.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireP228 = PRECACHE_EVENT(1, "events/p228.sc");
}

int CP228::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "357SIG";
	p->iMaxAmmo1 = _357SIG_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = P228_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 3;
	p->iId = m_iId = WEAPON_P228;
	p->iFlags = 0;
	p->iWeight = P228_WEIGHT;

	return 1;
}

BOOL CP228::Deploy(void)
{
	m_flAccuracy = 0.9;
	m_fMaxSpeed = 250;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield())
		return DefaultDeploy("models/shield/v_shield_p228.mdl", "models/shield/p_shield_p228.mdl", P228_SHIELD_DRAW, "shieldgun", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_p228.mdl", "models/p_p228.mdl", P228_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CP228::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		P228Fire((1.5) * (1 - m_flAccuracy), 0.2, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		P228Fire((0.255) * (1 - m_flAccuracy), 0.2, FALSE);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		P228Fire((0.075) * (1 - m_flAccuracy), 0.2, FALSE);
	else
		P228Fire((0.15) * (1 - m_flAccuracy), 0.2, FALSE);
}

void CP228::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_UP, SHIELDGUN_DOWN);
}

void CP228::P228Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	flCycleTime -= 0.05;
	m_iShotsFired++;

	if (m_iShotsFired > 1)
		return;

	if (m_flLastFire)
	{
		m_flAccuracy -= (0.325 - (gpGlobals->time - m_flLastFire)) * 0.3;

		if (m_flAccuracy > 0.9)
			m_flAccuracy = 0.9;
		else if (m_flAccuracy < 0.6)
			m_flAccuracy = 0.6;
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
	SetPlayerShieldAnim();
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 4096, 1, BULLET_PLAYER_357SIG, 32, 0.8, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireP228, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), m_iClip != 0, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;
	ResetPlayerShieldAnim();
	m_pPlayer->pev->punchangle.x -= 2;
}

void CP228::Reload(void)
{
	if (m_pPlayer->ammo_357sig <= 0)
		return;

	int iAnim;

	if (m_pPlayer->HasShield() != false)
		iAnim = P228_SHIELD_RELOAD;
	else
		iAnim = P228_RELOAD;

	if (DefaultReload(P228_MAX_CLIP, iAnim, 2.7))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.9;
	}
}

void CP228::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_pPlayer->HasShield())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;

		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			SendWeaponAnim(P228_SHIELD_IDLE_UP, UseDecrement() != FALSE);

		return;
	}

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3.0625;
		SendWeaponAnim(P228_IDLE, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_p90.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum p90_e
{
	P90_IDLE1,
	P90_RELOAD,
	P90_DRAW,
	P90_SHOOT1,
	P90_SHOOT2,
	P90_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_p90, CP90)

void CP90::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_p90");

	Precache();
	m_iId = WEAPON_P90;
	SET_MODEL(ENT(pev), "models/w_p90.mdl");

	m_iDefaultAmmo = P90_DEFAULT_GIVE;
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;
	m_bDelayFire = false;

	FallInit();
}

void CP90::Precache(void)
{
	PRECACHE_MODEL("models/v_p90.mdl");
	PRECACHE_MODEL("models/w_p90.mdl");

	PRECACHE_SOUND("weapons/p90-1.wav");
	PRECACHE_SOUND("weapons/p90_clipout.wav");
	PRECACHE_SOUND("weapons/p90_clipin.wav");
	PRECACHE_SOUND("weapons/p90_boltpull.wav");
	PRECACHE_SOUND("weapons/p90_cliprelease.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireP90 = PRECACHE_EVENT(1, "events/p90.sc");
}

int CP90::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "57mm";
	p->iMaxAmmo1 = _57MM_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = P90_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 8;
	p->iId = m_iId = WEAPON_P90;
	p->iFlags = 0;
	p->iWeight = P90_WEIGHT;

	return 1;
}

BOOL CP90::Deploy(void)
{
	m_iShotsFired = 0;
	m_bDelayFire = false;
	m_flAccuracy = 0.2;

	return DefaultDeploy("models/v_p90.mdl", "models/p_p90.mdl", P90_DRAW, "carbine", UseDecrement() != FALSE);
}

void CP90::PrimaryAttack(void)
{
	if (!(m_pPlayer->pev->flags & FL_ONGROUND))
		P90Fire((0.3) * m_flAccuracy, 0.066, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 170)
		P90Fire((0.115) * m_flAccuracy, 0.066, FALSE);
	else
		P90Fire((0.045) * m_flAccuracy, 0.066, FALSE);
}

void CP90::P90Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 175) + 0.45;

	if (m_flAccuracy > 1)
		m_flAccuracy = 1;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 1, BULLET_PLAYER_57MM, 21, 0.885, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireP90, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), 5, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;

	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(0.9, 0.45, 0.35, 0.04, 5.25, 3.5, 4);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(0.45, 0.3, 0.2, 0.0275, 4.0, 2.25, 7);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.275, 0.2, 0.125, 0.02, 3.0, 1.0, 9);
	else
		KickBack(0.3, 0.225, 0.125, 0.02, 3.25, 1.25, 8);
}

void CP90::Reload(void)
{
	if (m_pPlayer->ammo_57mm <= 0)
		return;

	if (DefaultReload(P90_MAX_CLIP, P90_RELOAD, 3.4))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2;
		m_iShotsFired = 0;
	}
}

void CP90::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(P90_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_scout.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum scout_e
{
	SCOUT_IDLE,
	SCOUT_SHOOT,
	SCOUT_SHOOT2,
	SCOUT_RELOAD,
	SCOUT_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_scout, CSCOUT)

void CSCOUT::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_scout");

	Precache();
	m_iId = WEAPON_SCOUT;
	SET_MODEL(ENT(pev), "models/w_scout.mdl");

	m_iDefaultAmmo = SCOUT_DEFAULT_GIVE;
	FallInit();
}

void CSCOUT::Precache(void)
{
	PRECACHE_MODEL("models/v_scout.mdl");
	PRECACHE_MODEL("models/w_scout.mdl");

	PRECACHE_SOUND("weapons/scout_fire-1.wav");
	PRECACHE_SOUND("weapons/scout_bolt.wav");
	PRECACHE_SOUND("weapons/scout_clipin.wav");
	PRECACHE_SOUND("weapons/scout_clipout.wav");
	PRECACHE_SOUND("weapons/zoom.wav");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/rshell_big.mdl");
	m_usFireScout = PRECACHE_EVENT(1, "events/scout.sc");
}

int CSCOUT::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "762Nato";
	p->iMaxAmmo1 = _762NATO_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = SCOUT_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 9;
	p->iId = m_iId = WEAPON_SCOUT;
	p->iFlags = 0;
	p->iWeight = SCOUT_WEIGHT;

	return 1;
}

BOOL CSCOUT::Deploy(void)
{
	if (DefaultDeploy("models/v_scout.mdl", "models/p_scout.mdl", SCOUT_DRAW, "rifle", UseDecrement() != FALSE))
	{
		m_flNextPrimaryAttack = m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 1.25;
		m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 1;
		return TRUE;
	}

	return FALSE;
}

void CSCOUT::SecondaryAttack(void)
{
	if (m_pPlayer->m_iFOV == 90)
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 40;
	else if (m_pPlayer->m_iFOV == 40)
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 15;
	else
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 90;

	m_pPlayer->ResetMaxSpeed();
	EMIT_SOUND(ENT(m_pPlayer->pev), CHAN_ITEM, "weapons/zoom.wav", 0.2, 2.4);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CSCOUT::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		SCOUTFire(0.2, 1.25, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 170)
		SCOUTFire(0.075, 1.25, FALSE);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		SCOUTFire(0.0, 1.25, FALSE);
	else
		SCOUTFire(0.007, 1.25, FALSE);
}

void CSCOUT::SCOUTFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	if (m_pPlayer->pev->fov != 90)
	{
		m_pPlayer->m_bResumeZoom = true;
		m_pPlayer->m_iLastZoom = m_pPlayer->m_iFOV;
		m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 90;
	}
	else
		flSpread += 0.025;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_flEjectBrass = gpGlobals->time + 0.56;
	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	Vector vecDir = FireBullets3(m_pPlayer->GetGunPosition(), gpGlobals->v_forward, flSpread, 8192, 3, BULLET_PLAYER_762MM, 75, 0.98, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireScout, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x * 1000, vecDir.y * 1000, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.x * 100), FALSE, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.8;
	m_pPlayer->pev->punchangle.x -= 2;
}

void CSCOUT::Reload(void)
{
	if (m_pPlayer->ammo_762nato <= 0)
		return;

	if (DefaultReload(SCOUT_MAX_CLIP, SCOUT_RELOAD, 2))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif

		if (m_pPlayer->pev->fov != 90)
		{
			m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 15;
			SecondaryAttack();
		}
	}
}

void CSCOUT::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60;
		SendWeaponAnim(SCOUT_IDLE, UseDecrement() != FALSE);
	}
}

float CSCOUT::GetMaxSpeed(void)
{
	if (m_pPlayer->m_iFOV == 90)
		return 260;

	return 220;
}

```

`dlls/wpn_shared/wpn_sg550.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum sg550_e
{
	SG550_IDLE,
	SG550_SHOOT,
	SG550_SHOOT2,
	SG550_RELOAD,
	SG550_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_sg550, CSG550)

void CSG550::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_sg550");

	Precache();
	m_iId = WEAPON_SG550;
	SET_MODEL(ENT(pev), "models/w_sg550.mdl");
	m_iDefaultAmmo = SG550_DEFAULT_GIVE;

	FallInit();
}

void CSG550::Precache(void)
{
	PRECACHE_MODEL("models/v_sg550.mdl");
	PRECACHE_MODEL("models/w_sg550.mdl");

	PRECACHE_SOUND("weapons/sg550-1.wav");
	PRECACHE_SOUND("weapons/sg550_boltpull.wav");
	PRECACHE_SOUND("weapons/sg550_clipin.wav");
	PRECACHE_SOUND("weapons/sg550_clipout.wav");
	PRECACHE_SOUND("weapons/zoom.wav");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireSG550 = PRECACHE_EVENT(1, "events/sg550.sc");
}

int CSG550::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = _556NATO_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = SG550_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 16;
	p->iId = m_iId = WEAPON_SG550;
	p->iFlags = 0;
	p->iWeight = WEAPON_SG550;

	return 1;
}

BOOL CSG550::Deploy(void)
{
	m_flAccuracy = 0.2;

	return DefaultDeploy("models/v_sg550.mdl", "models/p_sg550.mdl", SG550_DRAW, "rifle", UseDecrement() != FALSE);
}

void CSG550::SecondaryAttack(void)
{
	switch (m_pPlayer->m_iFOV)
	{
		case 90: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 40; break;
		case 40: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 15; break;
		default: m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 90; break;
	}

	m_pPlayer->ResetMaxSpeed();
	EMIT_SOUND(ENT(pev), CHAN_ITEM, "weapons/zoom.wav", 0.2, 2.4);
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CSG550::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		SG550Fire((0.45) * (1 - m_flAccuracy), 0.25, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		SG550Fire(0.15, 0.25, FALSE);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		SG550Fire((0.04) * (1 - m_flAccuracy), 0.25, FALSE);
	else
		SG550Fire((0.05) * (1 - m_flAccuracy), 0.25, FALSE);
}

void CSG550::SG550Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	if (m_pPlayer->pev->fov == 90)
		flSpread += 0.025;

	if (m_flLastFire)
	{
		m_flAccuracy = (gpGlobals->time - m_flLastFire) * 0.35 + 0.65;

		if (m_flAccuracy > 0.98)
			m_flAccuracy = 0.98;
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = NORMAL_GUN_FLASH;

	Vector vecDir = FireBullets3(m_pPlayer->GetGunPosition(), gpGlobals->v_forward, flSpread, 8192, 2, BULLET_PLAYER_556MM, 70, 0.98, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireSG550, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), 5, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.8;

	m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomFloat(m_pPlayer->random_seed + 4, 1.5, 1.75) + m_pPlayer->pev->punchangle.x * 0.25;
	m_pPlayer->pev->punchangle.y += UTIL_SharedRandomFloat(m_pPlayer->random_seed + 5, -1.0, 1.0);
}

void CSG550::Reload(void)
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(SG550_MAX_CLIP, SG550_RELOAD, 3.35))
	{
		m_flAccuracy = 0.2;
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif

		if (m_pPlayer->pev->fov != 90)
		{
			m_pPlayer->m_iFOV = m_pPlayer->pev->fov = 15;
			SecondaryAttack();
		}
	}
}

void CSG550::WeaponIdle(void)
{
	ResetEmptySound();

	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60;
		SendWeaponAnim(SG550_IDLE, UseDecrement() != FALSE);
	}
}

float CSG550::GetMaxSpeed(void)
{
	if (m_pPlayer->m_iFOV == 90)
		return 210;

	return 150;
}

```

`dlls/wpn_shared/wpn_sg552.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum sg552_e
{
	SG552_IDLE1,
	SG552_RELOAD,
	SG552_DRAW,
	SG552_SHOOT1,
	SG552_SHOOT2,
	SG552_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_sg552, CSG552)

void CSG552::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_sg552");

	Precache();
	m_iId = WEAPON_SG552;
	SET_MODEL(ENT(pev), "models/w_sg552.mdl");

	m_iDefaultAmmo = SG552_DEFAULT_GIVE;
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;

	FallInit();
}

void CSG552::Precache(void)
{
	PRECACHE_MODEL("models/v_sg552.mdl");
	PRECACHE_MODEL("models/w_sg552.mdl");

	PRECACHE_SOUND("weapons/sg552-1.wav");
	PRECACHE_SOUND("weapons/sg552-2.wav");
	PRECACHE_SOUND("weapons/sg552_clipout.wav");
	PRECACHE_SOUND("weapons/sg552_clipin.wav");
	PRECACHE_SOUND("weapons/sg552_boltpull.wav");

	m_iShell = PRECACHE_MODEL("models/rshell.mdl");
	m_usFireSG552 = PRECACHE_EVENT(1, "events/sg552.sc");
}

int CSG552::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "556Nato";
	p->iMaxAmmo1 = _556NATO_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = SG552_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 10;
	p->iId = m_iId = WEAPON_SG552;
	p->iFlags = 0;
	p->iWeight = SG552_WEIGHT;

	return 1;
}

BOOL CSG552::Deploy(void)
{
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;
	iShellOn = 1;

	return DefaultDeploy("models/v_sg552.mdl", "models/p_sg552.mdl", SG552_DRAW, "mp5", UseDecrement() != FALSE);
}

void CSG552::SecondaryAttack(void)
{
	if (m_pPlayer->m_iFOV != 90)
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 90;
	else
		m_pPlayer->pev->fov = m_pPlayer->m_iFOV = 55;

	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.3;
}

void CSG552::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		SG552Fire(0.035 + (0.45) * m_flAccuracy, 0.0825, FALSE);
	else if (m_pPlayer->pev->velocity.Length2D() > 140)
		SG552Fire(0.035 + (0.075) * m_flAccuracy, 0.0825, FALSE);
	else if (m_pPlayer->pev->fov == 90)
		SG552Fire((0.02) * m_flAccuracy, 0.0825, FALSE);
	else
		SG552Fire((0.02) * m_flAccuracy, 0.135, FALSE);
}

void CSG552::SG552Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 220.0) + 0.3;

	if (m_flAccuracy > 1)
		m_flAccuracy = 1;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);
	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 2, BULLET_PLAYER_556MM, 33, 0.955, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireSG552, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), 5, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;

	if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(1.0, 0.45, 0.28, 0.04, 4.25, 2.5, 7);
	else if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(1.25, 0.45, 0.22, 0.18, 6.0, 4.0, 5);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.6, 0.35, 0.2, 0.0125, 3.7, 2.0, 10);
	else
		KickBack(0.625, 0.375, 0.25, 0.0125, 4.0, 2.25, 9);
}

void CSG552::Reload(void)
{
	if (m_pPlayer->ammo_556nato <= 0)
		return;

	if (DefaultReload(SG552_MAX_CLIP, SG552_RELOAD, 3))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif

		if (m_pPlayer->m_iFOV != 90)
			SecondaryAttack();

		m_flAccuracy = 0.2;
		m_iShotsFired = 0;
		m_bDelayFire = false;
	}
}

void CSG552::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(SG552_IDLE1, UseDecrement() != FALSE);
}

float CSG552::GetMaxSpeed(void)
{
	if (m_pPlayer->m_iFOV == 90)
		return 235;

	return 200;
}

```

`dlls/wpn_shared/wpn_smokegrenade.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum smokegrenade_e
{
	SMOKEGRENADE_IDLE,
	SMOKEGRENADE_PINPULL,
	SMOKEGRENADE_THROW,
	SMOKEGRENADE_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_smokegrenade, CSmokeGrenade)

void CSmokeGrenade::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_smokegrenade");

	Precache();
	m_iId = WEAPON_SMOKEGRENADE;
	SET_MODEL(ENT(pev), "models/w_smokegrenade.mdl");

	pev->dmg = 4;
	m_iDefaultAmmo = SMOKEGRENADE_DEFAULT_GIVE;
	m_flStartThrow = 0;
	m_flReleaseThrow = -1;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	FallInit();
}

void CSmokeGrenade::Precache(void)
{
	PRECACHE_MODEL("models/v_smokegrenade.mdl");
	PRECACHE_MODEL("models/shield/v_shield_smokegrenade.mdl");

	PRECACHE_SOUND("weapons/pinpull.wav");
	PRECACHE_SOUND("weapons/sg_explode.wav");

	m_usCreateSmoke = PRECACHE_EVENT(1, "events/createsmoke.sc");
}

int CSmokeGrenade::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "SmokeGrenade";
	p->iMaxAmmo1 = SMOKEGRENADE_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = WEAPON_NOCLIP;
	p->iSlot = 3;
	p->iPosition = 3;
	p->iId = m_iId = WEAPON_SMOKEGRENADE;
	p->iWeight = SMOKEGRENADE_WEIGHT;
	p->iFlags = ITEM_FLAG_LIMITINWORLD | ITEM_FLAG_EXHAUSTIBLE;

	return 1;
}

BOOL CSmokeGrenade::Deploy(void)
{
	m_flReleaseThrow = -1;
	m_fMaxSpeed = 250;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
	m_pPlayer->m_bShieldDrawn = false;

	if (m_pPlayer->HasShield() != false)
		return DefaultDeploy("models/shield/v_shield_smokegrenade.mdl", "models/shield/p_shield_smokegrenade.mdl", SMOKEGRENADE_DRAW, "shieldgren", UseDecrement() != FALSE);
	else
		return DefaultDeploy("models/v_smokegrenade.mdl", "models/p_smokegrenade.mdl", SMOKEGRENADE_DRAW, "grenade", UseDecrement() != FALSE);
}

void CSmokeGrenade::Holster(int skiplocal)
{
	m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.5;

	if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		m_pPlayer->pev->weapons &= ~(1 << WEAPON_SMOKEGRENADE);
		DestroyItem();
	}

	m_flStartThrow = 0;
	m_flReleaseThrow = -1;
}

void CSmokeGrenade::PrimaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
		return;

	if (!m_flStartThrow && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] > 0)
	{
		m_flStartThrow = gpGlobals->time;
		m_flReleaseThrow = 0;
		SendWeaponAnim(SMOKEGRENADE_PINPULL, UseDecrement() != FALSE);
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.5;
	}
}

void CSmokeGrenade::SetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strcpy(m_pPlayer->m_szAnimExtention, "shield");
		else
			strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
	}
}

void CSmokeGrenade::ResetPlayerShieldAnim(void)
{
	if (m_pPlayer->HasShield() == true)
	{
		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
	}
}

bool CSmokeGrenade::ShieldSecondaryFire(int up_anim, int down_anim)
{
	if (m_pPlayer->HasShield() == false)
		return false;

	if (m_flStartThrow > 0)
		return false;

	if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
	{
		m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(down_anim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shieldgren");
		m_fMaxSpeed = 250;
		m_pPlayer->m_bShieldDrawn = false;
	}
	else
	{
		m_iWeaponState |= WPNSTATE_SHIELD_DRAWN;
		SendWeaponAnim(up_anim, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "shielded");
		m_fMaxSpeed = 180;
		m_pPlayer->m_bShieldDrawn = true;
	}
#ifndef CLIENT_DLL
	m_pPlayer->UpdateShieldCrosshair((m_iWeaponState & WPNSTATE_SHIELD_DRAWN) == 0);
	m_pPlayer->ResetMaxSpeed();
#endif
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.4;
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.6;
	return true;
}

void CSmokeGrenade::SecondaryAttack(void)
{
	ShieldSecondaryFire(SHIELDGUN_DRAW, SHIELDGUN_DRAWN_IDLE);
}

void CSmokeGrenade::WeaponIdle(void)
{
	if (!m_flReleaseThrow && m_flStartThrow)
		m_flReleaseThrow = gpGlobals->time;

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_flStartThrow)
	{
#ifndef CLIENT_DLL
		m_pPlayer->Radio("%!MRAD_FIREINHOLE", "#Fire_in_the_hole");
#endif
		Vector angThrow = m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle;

		if (angThrow.x < 0)
			angThrow.x = -10 + angThrow.x * ((90 - 10) / 90.0);
		else
			angThrow.x = -10 + angThrow.x * ((90 + 10) / 90.0);

		float flVel = (90 - angThrow.x) * 6;

		if (flVel > 750)
			flVel = 750;

		UTIL_MakeVectors(angThrow);
		Vector vecSrc = m_pPlayer->pev->origin + m_pPlayer->pev->view_ofs + gpGlobals->v_forward * 16;
		Vector vecThrow = gpGlobals->v_forward * flVel + m_pPlayer->pev->velocity;
		float time = 1.5;
		CGrenade::ShootSmokeGrenade(m_pPlayer->pev, vecSrc, vecThrow, time, m_usCreateSmoke);

		SendWeaponAnim(SMOKEGRENADE_THROW, UseDecrement() != FALSE);
		SetPlayerShieldAnim();

#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif
		m_flStartThrow = 0;
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.5;
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.75;
		m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]--;

		if (!m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
			m_flTimeWeaponIdle = m_flNextSecondaryAttack = m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.5;

		ResetPlayerShieldAnim();
		return;
	}
	else if (m_flReleaseThrow > 0)
	{
		m_flStartThrow = 0;

		if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
		{
			SendWeaponAnim(SMOKEGRENADE_DRAW, UseDecrement() != FALSE);
			m_flReleaseThrow = -1;
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
		}
		else
			RetireWeapon();

		return;
	}

	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
	{
		if (m_pPlayer->HasShield() != false)
		{
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20.0;

			if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
				SendWeaponAnim(SHIELDREN_IDLE, UseDecrement() != FALSE);

			return;
		}

		int iAnim;
		float flRand = RANDOM_FLOAT(0, 1);

		if (flRand <= 0.75)
		{
			iAnim = SMOKEGRENADE_IDLE;
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + RANDOM_FLOAT(10, 15);
		}
		else
		{
			iAnim = SMOKEGRENADE_IDLE;
			m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 75.0 / 30.0;
		}

		SendWeaponAnim(iAnim, UseDecrement() != FALSE);
	}
}

BOOL CSmokeGrenade::CanDeploy(void)
{
	return m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] != 0;
}

```

`dlls/wpn_shared/wpn_tmp.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum tmp_e
{
	TMP_IDLE1,
	TMP_RELOAD,
	TMP_DRAW,
	TMP_SHOOT1,
	TMP_SHOOT2,
	TMP_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_tmp, CTMP)

void CTMP::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_tmp");

	Precache();
	m_iId = WEAPON_TMP;
	SET_MODEL(ENT(pev), "models/w_tmp.mdl");

	m_iDefaultAmmo = TMP_DEFAULT_GIVE;
	m_flAccuracy = 0.2;
	m_iShotsFired = 0;
	m_bDelayFire = false;

	FallInit();
}

void CTMP::Precache(void)
{
	PRECACHE_MODEL("models/v_tmp.mdl");
	PRECACHE_MODEL("models/w_tmp.mdl");

	PRECACHE_SOUND("weapons/tmp-1.wav");
	PRECACHE_SOUND("weapons/tmp-2.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireTMP = PRECACHE_EVENT(1, "events/tmp.sc");
}

int CTMP::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "9mm";
	p->iMaxAmmo1 = _9MM_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = TMP_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 11;
	p->iId = m_iId = WEAPON_TMP;
	p->iFlags = 0;
	p->iWeight = TMP_WEIGHT;

	return 1;
}

BOOL CTMP::Deploy(void)
{
	m_iShotsFired = 0;
	m_bDelayFire = false;
	m_flAccuracy = 0.2;
	iShellOn = 1;

	return DefaultDeploy("models/v_tmp.mdl", "models/p_tmp.mdl", TMP_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CTMP::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		TMPFire((0.25) * m_flAccuracy, 0.07, FALSE);
	else
		TMPFire((0.03) * m_flAccuracy, 0.07, FALSE);
}

void CTMP::TMPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 200) + 0.55;

	if (m_flAccuracy > 1.4)
		m_flAccuracy = 1.4;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);
	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 1, BULLET_PLAYER_9MM, 20, 0.85, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireTMP, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), 5, FALSE);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;

	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(1.1, 0.5, 0.35, 0.045, 4.5, 3.5, 6);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(0.8, 0.4, 0.2, 0.03, 3.0, 2.5, 7);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.7, 0.35, 0.125, 0.025, 2.5, 2.0, 10);
	else
		KickBack(0.725, 0.375, 0.15, 0.025, 2.75, 2.25, 9);
}

void CTMP::Reload(void)
{
	if (m_pPlayer->ammo_9mm <= 0)
		return;

	if (DefaultReload(TMP_MAX_CLIP, TMP_RELOAD, 2.12))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.2;
		m_iShotsFired = 0;
	}
}

void CTMP::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(TMP_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_ump45.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum ump45_e
{
	UMP45_IDLE1,
	UMP45_RELOAD,
	UMP45_DRAW,
	UMP45_SHOOT1,
	UMP45_SHOOT2,
	UMP45_SHOOT3
};

LINK_ENTITY_TO_CLASS(weapon_ump45, CUMP45)

void CUMP45::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_ump45");

	Precache();
	m_iId = WEAPON_UMP45;
	SET_MODEL(ENT(pev), "models/w_ump45.mdl");

	m_iDefaultAmmo = UMP45_DEFAULT_GIVE;
	m_flAccuracy = 0;
	m_bDelayFire = false;

	FallInit();
}

void CUMP45::Precache(void)
{
	PRECACHE_MODEL("models/v_ump45.mdl");
	PRECACHE_MODEL("models/w_ump45.mdl");

	PRECACHE_SOUND("weapons/ump45-1.wav");
	PRECACHE_SOUND("weapons/ump45_clipout.wav");
	PRECACHE_SOUND("weapons/ump45_clipin.wav");
	PRECACHE_SOUND("weapons/ump45_boltslap.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireUMP45 = PRECACHE_EVENT(1, "events/ump45.sc");
}

int CUMP45::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "45acp";
	p->iMaxAmmo1 = _45ACP_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = UMP45_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 15;
	p->iId = m_iId = WEAPON_UMP45;
	p->iFlags = 0;
	p->iWeight = UMP45_WEIGHT;

	return 1;
}

BOOL CUMP45::Deploy(void)
{
	m_flAccuracy = 0;
	m_bDelayFire = false;
	iShellOn = 1;

	return DefaultDeploy("models/v_ump45.mdl", "models/p_ump45.mdl", UMP45_DRAW, "carbine", UseDecrement() != FALSE);
}

void CUMP45::PrimaryAttack(void)
{
	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		UMP45Fire((0.24) * m_flAccuracy, 0.1, FALSE);
	else
		UMP45Fire((0.04) * m_flAccuracy, 0.1, FALSE);
}

void CUMP45::UMP45Fire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	m_bDelayFire = true;
	m_iShotsFired++;
	m_flAccuracy = ((float)(m_iShotsFired * m_iShotsFired * m_iShotsFired) / 210.0) + 0.5;

	if (m_flAccuracy > 1)
		m_flAccuracy = 1;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	Vector vecSrc = m_pPlayer->GetGunPosition();
	Vector vecDir = m_pPlayer->FireBullets3(vecSrc, gpGlobals->v_forward, flSpread, 8192, 1, BULLET_PLAYER_45ACP, 30, 0.82, m_pPlayer->pev, FALSE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, m_pPlayer->edict(), m_usFireUMP45, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), (int)(m_pPlayer->pev->punchangle.y * 100), FALSE, FALSE);

	m_pPlayer->m_iWeaponVolume = NORMAL_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;

	if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
		KickBack(0.125, 0.65, 0.55, 0.0475, 5.5, 4.0, 10);
	else if (m_pPlayer->pev->velocity.Length2D() > 0)
		KickBack(0.55, 0.3, 0.225, 0.03, 3.5, 2.5, 10);
	else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
		KickBack(0.25, 0.175, 0.125, 0.02, 2.25, 1.25, 10);
	else
		KickBack(0.275, 0.2, 0.15, 0.0225, 2.5, 1.5, 10);
}

void CUMP45::Reload(void)
{
	if (m_pPlayer->ammo_45acp <= 0)
		return;

	if (DefaultReload(UMP45_MAX_CLIP, UMP45_RELOAD, 3.5))
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0;
		m_iShotsFired = 0;
	}
}

void CUMP45::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;
	SendWeaponAnim(UMP45_IDLE1, UseDecrement() != FALSE);
}

```

`dlls/wpn_shared/wpn_usp.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum usp_e
{
	USP_IDLE,
	USP_SHOOT1,
	USP_SHOOT2,
	USP_SHOOT3,
	USP_SHOOT_EMPTY,
	USP_RELOAD,
	USP_DRAW,
	USP_ATTACH_SILENCER,
	USP_UNSIL_IDLE,
	USP_UNSIL_SHOOT1,
	USP_UNSIL_SHOOT2,
	USP_UNSIL_SHOOT3,
	USP_UNSIL_SHOOT_EMPTY,
	USP_UNSIL_RELOAD,
	USP_UNSIL_DRAW,
	USP_DETACH_SILENCER
};

enum usp_shield_e
{
	USP_SHIELD_IDLE,
	USP_SHIELD_SHOOT1,
	USP_SHIELD_SHOOT2,
	USP_SHIELD_SHOOT_EMPTY,
	USP_SHIELD_RELOAD,
	USP_SHIELD_DRAW,
	USP_SHIELD_UP_IDLE,
	USP_SHIELD_UP,
	USP_SHIELD_DOWN
};

LINK_ENTITY_TO_CLASS(weapon_usp, CUSP)

void CUSP::Spawn(void)
{
	pev->classname = MAKE_STRING("weapon_usp");

	Precache();
	m_iId = WEAPON_USP;
	SET_MODEL(ENT(pev), "models/w_usp.mdl");

	m_iDefaultAmmo = USP_DEFAULT_GIVE;
	m_flAccuracy = 0.92;
	m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;

	FallInit();
}

void CUSP::Precache(void)
{
	PRECACHE_MODEL("models/v_usp.mdl");
	PRECACHE_MODEL("models/w_usp.mdl");
	PRECACHE_MODEL("models/shield/v_shield_usp.mdl");

	PRECACHE_SOUND("weapons/usp1.wav");
	PRECACHE_SOUND("weapons/usp2.wav");
	PRECACHE_SOUND("weapons/usp_unsil-1.wav");
	PRECACHE_SOUND("weapons/usp_clipout.wav");
	PRECACHE_SOUND("weapons/usp_clipin.wav");
	PRECACHE_SOUND("weapons/usp_silencer_on.wav");
	PRECACHE_SOUND("weapons/usp_silencer_off.wav");
	PRECACHE_SOUND("weapons/usp_sliderelease.wav");
	PRECACHE_SOUND("weapons/usp_slideback.wav");

	m_iShell = PRECACHE_MODEL("models/pshell.mdl");
	m_usFireUSP = PRECACHE_EVENT(1, "events/usp.sc");
}

int CUSP::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "45acp";
	p->iMaxAmmo1 = _45ACP_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = USP_MAX_CLIP;
	p->iSlot = 1;
	p->iPosition = 4;
	p->iId = m_iId = WEAPON_USP;
	p->iFlags = 0;
	p->iWeight = USP_WEIGHT;

	return 1;
}

BOOL CUSP::Deploy(void)
{
   m_iWeaponState &= ~WPNSTATE_SHIELD_DRAWN;
   m_flAccuracy = 0.92f;
   m_fMaxSpeed = 250.0f;
   m_pPlayer->m_bShieldDrawn = false;

   if (m_pPlayer->HasShield())
   {
      m_iWeaponState &= ~WPNSTATE_USP_SILENCED;
      return DefaultDeploy("models/shield/v_shield_usp.mdl", "models/shield/p_shield_usp.mdl", USP_SHIELD_DRAW, "shieldgun", UseDecrement() != FALSE);
   }
   else if (m_iWeaponState & WPNSTATE_USP_SILENCED)
      return DefaultDeploy("models/v_usp.mdl", "models/p_usp.mdl", USP_DRAW, "onehanded", UseDecrement() != FALSE);
   return DefaultDeploy("models/v_usp.mdl", "models/p_usp.mdl", USP_UNSIL_DRAW, "onehanded", UseDecrement() != FALSE);
}

void CUSP::SecondaryAttack(void)
{
	if (ShieldSecondaryFire(USP_SHIELD_UP, USP_SHIELD_DOWN) == true)
		return;

	if (m_iWeaponState & WPNSTATE_USP_SILENCED)
	{
		m_iWeaponState &= ~WPNSTATE_USP_SILENCED;
		SendWeaponAnim(USP_DETACH_SILENCER, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "onehanded");
	}
	else
	{
		m_iWeaponState |= WPNSTATE_USP_SILENCED;
		SendWeaponAnim(USP_ATTACH_SILENCER, UseDecrement() != FALSE);
		strcpy(m_pPlayer->m_szAnimExtention, "onehanded");
	}

	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 3;
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 3;
	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 3;
}

void CUSP::PrimaryAttack(void)
{
	if (m_iWeaponState & WPNSTATE_USP_SILENCED)
	{
		if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
			USPFire((1.3) * (1 - m_flAccuracy), 0.225, FALSE);
		else if (m_pPlayer->pev->velocity.Length2D() > 0)
			USPFire((0.25) * (1 - m_flAccuracy), 0.225, FALSE);
		else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
			USPFire((0.125) * (1 - m_flAccuracy), 0.225, FALSE);
		else
			USPFire((0.15) * (1 - m_flAccuracy), 0.225, FALSE);
	}
	else
	{
		if (!FBitSet(m_pPlayer->pev->flags, FL_ONGROUND))
			USPFire((1.2) * (1 - m_flAccuracy), 0.225, FALSE);
		else if (m_pPlayer->pev->velocity.Length2D() > 0)
			USPFire((0.225) * (1 - m_flAccuracy), 0.225, FALSE);
		else if (FBitSet(m_pPlayer->pev->flags, FL_DUCKING))
			USPFire((0.08) * (1 - m_flAccuracy), 0.225, FALSE);
		else
			USPFire((0.1) * (1 - m_flAccuracy), 0.225, FALSE);
	}
}

void CUSP::USPFire(float flSpread, float flCycleTime, BOOL fUseAutoAim)
{
	flCycleTime -= 0.075;
	m_iShotsFired++;

	if (m_iShotsFired > 1)
		return;

	if (m_flLastFire)
	{
		m_flAccuracy -= (0.3 - (gpGlobals->time - m_flLastFire)) * 0.275;

		if (m_flAccuracy > 0.92)
			m_flAccuracy = 0.92;
		else if (m_flAccuracy < 0.6)
			m_flAccuracy = 0.6;
	}

	m_flLastFire = gpGlobals->time;

	if (m_iClip <= 0)
	{
		if (m_fFireOnEmpty)
		{
			PlayEmptySound();
			m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.2;
		}

		return;
	}

	m_iClip--;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	m_pPlayer->m_iWeaponVolume = BIG_EXPLOSION_VOLUME;
	m_pPlayer->m_iWeaponFlash = DIM_GUN_FLASH;

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);

	if (!(m_iWeaponState & WPNSTATE_USP_SILENCED))
		m_pPlayer->pev->effects |= EF_MUZZLEFLASH;

	int iDamage = (m_iWeaponState & WPNSTATE_USP_SILENCED) ? 30 : 34;
	Vector vecDir = FireBullets3(m_pPlayer->GetGunPosition(), gpGlobals->v_forward, flSpread, 4096, 1, BULLET_PLAYER_45ACP, iDamage, 0.79, m_pPlayer->pev, TRUE, m_pPlayer->random_seed);

	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireUSP, 0, (float *)&g_vecZero, (float *)&g_vecZero, vecDir.x, vecDir.y, (int)(m_pPlayer->pev->punchangle.x * 100), 0, m_iClip != 0, m_iWeaponState & WPNSTATE_USP_SILENCED);
	m_flNextPrimaryAttack = m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + flCycleTime;
#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2;
	m_pPlayer->pev->punchangle.x -= 2;
	ResetPlayerShieldAnim();
}

void CUSP::Reload(void)
{
	if (m_pPlayer->ammo_45acp <= 0)
		return;

	int iAnim;

	if (m_pPlayer->HasShield() != false)
		iAnim = USP_SHIELD_RELOAD;
	else if (m_iWeaponState & WPNSTATE_USP_SILENCED)
		iAnim = USP_RELOAD;
	else
		iAnim = USP_UNSIL_RELOAD;

	if (DefaultReload(USP_MAX_CLIP, iAnim, 2.7))
	{

#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		m_flAccuracy = 0.92;
	}
}

void CUSP::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_10DEGREES);

	if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
		return;

	if (m_pPlayer->HasShield())
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 20;

		if (m_iWeaponState & WPNSTATE_SHIELD_DRAWN)
			SendWeaponAnim(USP_DRAW, UseDecrement() != FALSE);

		return;
	}

	if (m_iClip)
	{
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 60;

		if (m_iWeaponState & WPNSTATE_USP_SILENCED)
			SendWeaponAnim(USP_IDLE, UseDecrement() != FALSE);
		else
			SendWeaponAnim(USP_UNSIL_IDLE, UseDecrement() != FALSE);
	}
}

```

`dlls/wpn_shared/wpn_xm1014.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

#include "stdafx.h"
#include "cbase.h"
#include "player.h"
#include "weapons.h"

enum xm1014_e
{
	XM1014_IDLE,
	XM1014_FIRE1,
	XM1014_FIRE2,
	XM1014_RELOAD,
	XM1014_PUMP,
	XM1014_START_RELOAD,
	XM1014_DRAW
};

LINK_ENTITY_TO_CLASS(weapon_xm1014, CXM1014)

void CXM1014::Spawn(void)
{
	Precache();
	m_iId = WEAPON_XM1014;
	SET_MODEL(ENT(pev), "models/w_xm1014.mdl");

	m_iDefaultAmmo = XM1014_DEFAULT_GIVE;

	FallInit();
}

void CXM1014::Precache(void)
{
	PRECACHE_MODEL("models/v_xm1014.mdl");
	PRECACHE_MODEL("models/w_xm1014.mdl");

	m_iShellId = m_iShell = PRECACHE_MODEL("models/shotgunshell.mdl");

	PRECACHE_SOUND("weapons/xm1014-1.wav");
	PRECACHE_SOUND("weapons/reload1.wav");
	PRECACHE_SOUND("weapons/reload3.wav");

	m_usFireXM1014 = PRECACHE_EVENT(1, "events/xm1014.sc");
}

int CXM1014::GetItemInfo(ItemInfo *p)
{
	p->pszName = STRING(pev->classname);
	p->pszAmmo1 = "buckshot";
	p->iMaxAmmo1 = BUCKSHOT_MAX_CARRY;
	p->pszAmmo2 = NULL;
	p->iMaxAmmo2 = -1;
	p->iMaxClip = XM1014_MAX_CLIP;
	p->iSlot = 0;
	p->iPosition = 12;
	p->iId = m_iId = WEAPON_XM1014;
	p->iFlags = 0;
	p->iWeight = XM1014_WEIGHT;

	return 1;
}

BOOL CXM1014::Deploy(void)
{
	return DefaultDeploy("models/v_xm1014.mdl", "models/p_xm1014.mdl", XM1014_DRAW, "m249", UseDecrement() != FALSE);
}

void CXM1014::PrimaryAttack(void)
{
	if (m_pPlayer->pev->waterlevel == 3)
	{
		PlayEmptySound();
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.15;
		return;
	}

	if (m_iClip <= 0)
	{
		Reload();

		if (m_iClip == 0)
			PlayEmptySound();

		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 1.0;
		return;
	}

	m_pPlayer->m_iWeaponVolume = LOUD_GUN_VOLUME;
	m_pPlayer->m_iWeaponFlash = BRIGHT_GUN_FLASH;

	m_iClip--;
	m_pPlayer->pev->effects |= EF_MUZZLEFLASH;
#ifndef CLIENT_DLL
	m_pPlayer->SetAnimation(PLAYER_ATTACK1);
#endif

	UTIL_MakeVectors(m_pPlayer->pev->v_angle + m_pPlayer->pev->punchangle);
#ifndef CLIENT_DLL
	m_pPlayer->FireBullets(6, m_pPlayer->GetGunPosition(), gpGlobals->v_forward, Vector(0.0725, 0.0725, 0.0), 3048, BULLET_PLAYER_BUCKSHOT, 0);
#endif
	int flags;
#ifdef CLIENT_WEAPONS
	flags = FEV_NOTHOST;
#else
	flags = 0;
#endif

	PLAYBACK_EVENT_FULL(flags, ENT(m_pPlayer->pev), m_usFireXM1014, 0, (float *)&g_vecZero, (float *)&g_vecZero, m_vVecAiming.x, m_vVecAiming.y, 7, m_vVecAiming.x * 100, m_iClip != 0, FALSE);

	if (m_iClip)
		m_flPumpTime = UTIL_WeaponTimeBase() + 0.125;

#ifndef CLIENT_DLL
	if (!m_iClip && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)
		m_pPlayer->SetSuitUpdate("!HEV_AMO0", FALSE, 0);
#endif
	if (m_iClip)
		m_flPumpTime = UTIL_WeaponTimeBase() + 0.125;

	m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.25;
	m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.25;

	if (m_iClip)
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 2.25;
	else
		m_flTimeWeaponIdle = 0.75;

	m_fInSpecialReload = 0;

	if (m_pPlayer->pev->flags & FL_ONGROUND)
		m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomLong(m_pPlayer->random_seed + 1, 3, 5);
	else
		m_pPlayer->pev->punchangle.x -= UTIL_SharedRandomLong(m_pPlayer->random_seed + 1, 7, 10);
}

void CXM1014::Reload(void)
{
	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0 || m_iClip == XM1014_MAX_CLIP)
		return;

	if (m_flNextPrimaryAttack > UTIL_WeaponTimeBase())
		return;

	if (!m_fInSpecialReload)
	{
#ifndef CLIENT_DLL
		m_pPlayer->SetAnimation(PLAYER_RELOAD);
#endif
		SendWeaponAnim(XM1014_START_RELOAD, UseDecrement() != FALSE);

		m_fInSpecialReload = 1;
		m_pPlayer->m_flNextAttack = UTIL_WeaponTimeBase() + 0.55;
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.55;
		m_flNextPrimaryAttack = UTIL_WeaponTimeBase() + 0.55;
		m_flNextSecondaryAttack = UTIL_WeaponTimeBase() + 0.55;
	}
	else if (m_fInSpecialReload == 1)
	{
		if (m_flTimeWeaponIdle > UTIL_WeaponTimeBase())
			return;

		m_fInSpecialReload = 2;

		if (RANDOM_LONG(0, 1))
			EMIT_SOUND_DYN(ENT(m_pPlayer->pev), CHAN_ITEM, "weapons/reload1.wav", VOL_NORM, ATTN_NORM, 0, 85 + RANDOM_LONG(0, 31));
		else
			EMIT_SOUND_DYN(ENT(m_pPlayer->pev), CHAN_ITEM, "weapons/reload3.wav", VOL_NORM, ATTN_NORM, 0, 85 + RANDOM_LONG(0, 31));

		SendWeaponAnim(XM1014_RELOAD, UseDecrement());

		m_flNextReload = UTIL_WeaponTimeBase() + 0.3;
		m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 0.3;
	}
	else
	{
		m_iClip++;
		m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]--;
		m_fInSpecialReload = 1;
		m_pPlayer->ammo_buckshot--;
	}
}

void CXM1014::WeaponIdle(void)
{
	ResetEmptySound();
	m_pPlayer->GetAutoaimVector(AUTOAIM_5DEGREES);

	if (m_flPumpTime && m_flPumpTime < UTIL_WeaponTimeBase())
		m_flPumpTime = 0;

	if (m_flTimeWeaponIdle < UTIL_WeaponTimeBase())
	{
		if (m_iClip == 0 && m_fInSpecialReload == 0 && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
		{
			Reload();
		}
		else if (m_fInSpecialReload != 0)
		{
			if (m_iClip != XM1014_MAX_CLIP && m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType])
			{
				Reload();
			}
			else
			{
				SendWeaponAnim(XM1014_PUMP, UseDecrement() != FALSE);

				m_fInSpecialReload = 0;
				m_flTimeWeaponIdle = UTIL_WeaponTimeBase() + 1.5;
			}
		}
		else
			SendWeaponAnim(XM1014_IDLE, UseDecrement() != FALSE);
	}
}

```

`engine/Sequence.h`:

```h
//---------------------------------------------------------------------------
// 
//		S c r i p t e d   S e q u e n c e s
// 
//---------------------------------------------------------------------------
#ifndef _INCLUDE_SEQUENCE_H_
#define _INCLUDE_SEQUENCE_H_


#ifndef _DEF_BYTE_
typedef unsigned char byte;
#endif

//---------------------------------------------------------------------------
// client_textmessage_t
//---------------------------------------------------------------------------

#define CLIENT_TEXTMESAGE_S
typedef struct client_textmessage_s
{
	int		effect;
	byte	r1, g1, b1, a1;		// 2 colors for effects
	byte	r2, g2, b2, a2;
	float	x;
	float	y;
	float	fadein;
	float	fadeout;
	float	holdtime;
	float	fxtime;
	const char *pName;
	const char *pMessage;
} client_textmessage_t;


//--------------------------------------------------------------------------
// sequenceDefaultBits_e
//	
// Enumerated list of possible modifiers for a command.  This enumeration
// is used in a bitarray controlling what modifiers are specified for a command.
//---------------------------------------------------------------------------
enum sequenceModifierBits
{
	SEQUENCE_MODIFIER_EFFECT_BIT		= (1 << 1),
	SEQUENCE_MODIFIER_POSITION_BIT		= (1 << 2),
	SEQUENCE_MODIFIER_COLOR_BIT			= (1 << 3),
	SEQUENCE_MODIFIER_COLOR2_BIT		= (1 << 4),
	SEQUENCE_MODIFIER_FADEIN_BIT		= (1 << 5),
	SEQUENCE_MODIFIER_FADEOUT_BIT		= (1 << 6),
	SEQUENCE_MODIFIER_HOLDTIME_BIT		= (1 << 7),
	SEQUENCE_MODIFIER_FXTIME_BIT		= (1 << 8),
	SEQUENCE_MODIFIER_SPEAKER_BIT		= (1 << 9),
	SEQUENCE_MODIFIER_LISTENER_BIT		= (1 << 10),
	SEQUENCE_MODIFIER_TEXTCHANNEL_BIT	= (1 << 11),
};
typedef enum sequenceModifierBits sequenceModifierBits_e ;


//---------------------------------------------------------------------------
// sequenceCommandEnum_e
// 
// Enumerated sequence command types.
//---------------------------------------------------------------------------
enum sequenceCommandEnum_
{
	SEQUENCE_COMMAND_ERROR = -1,
	SEQUENCE_COMMAND_PAUSE = 0,
	SEQUENCE_COMMAND_FIRETARGETS,
	SEQUENCE_COMMAND_KILLTARGETS,
	SEQUENCE_COMMAND_TEXT,
	SEQUENCE_COMMAND_SOUND,
	SEQUENCE_COMMAND_GOSUB,
	SEQUENCE_COMMAND_SENTENCE,
	SEQUENCE_COMMAND_REPEAT,
	SEQUENCE_COMMAND_SETDEFAULTS,
	SEQUENCE_COMMAND_MODIFIER,
	SEQUENCE_COMMAND_POSTMODIFIER,
	SEQUENCE_COMMAND_NOOP,

	SEQUENCE_MODIFIER_EFFECT,
	SEQUENCE_MODIFIER_POSITION,
	SEQUENCE_MODIFIER_COLOR,
	SEQUENCE_MODIFIER_COLOR2,
	SEQUENCE_MODIFIER_FADEIN,
	SEQUENCE_MODIFIER_FADEOUT,
	SEQUENCE_MODIFIER_HOLDTIME,
	SEQUENCE_MODIFIER_FXTIME,
	SEQUENCE_MODIFIER_SPEAKER,
	SEQUENCE_MODIFIER_LISTENER,
	SEQUENCE_MODIFIER_TEXTCHANNEL,
};
typedef enum sequenceCommandEnum_ sequenceCommandEnum_e;


//---------------------------------------------------------------------------
// sequenceCommandType_e
// 
// Typeerated sequence command types.
//---------------------------------------------------------------------------
enum sequenceCommandType_
{
	SEQUENCE_TYPE_COMMAND,
	SEQUENCE_TYPE_MODIFIER,
};
typedef enum sequenceCommandType_ sequenceCommandType_e;


//---------------------------------------------------------------------------
// sequenceCommandMapping_s
// 
// A mapping of a command enumerated-value to its name.
//---------------------------------------------------------------------------
typedef struct sequenceCommandMapping_ sequenceCommandMapping_s;
struct sequenceCommandMapping_
{
	sequenceCommandEnum_e	commandEnum;
	const char*				commandName;
	sequenceCommandType_e	commandType;
};


//---------------------------------------------------------------------------
// sequenceCommandLine_s
// 
// Structure representing a single command (usually 1 line) from a
//	.SEQ file entry.
//---------------------------------------------------------------------------
typedef struct sequenceCommandLine_ sequenceCommandLine_s;
struct sequenceCommandLine_
{
	int						commandType;		// Specifies the type of command
	client_textmessage_t	clientMessage;		// Text HUD message struct
	char*					speakerName;		// Targetname of speaking entity
	char*					listenerName;		// Targetname of entity being spoken to
	char*					soundFileName;		// Name of sound file to play
	char*					sentenceName;		// Name of sentences.txt to play
	char*					fireTargetNames;	// List of targetnames to fire
	char*					killTargetNames;	// List of targetnames to remove
	float					delay;				// Seconds 'till next command
	int						repeatCount;		// If nonzero, reset execution pointer to top of block (N times, -1 = infinite)
	int						textChannel;		// Display channel on which text message is sent
	int						modifierBitField;	// Bit field to specify what clientmessage fields are valid
	sequenceCommandLine_s*	nextCommandLine;	// Next command (linked list)
};


//---------------------------------------------------------------------------
// sequenceEntry_s
// 
// Structure representing a single command (usually 1 line) from a
//	.SEQ file entry.
//---------------------------------------------------------------------------
typedef struct sequenceEntry_ sequenceEntry_s;
struct sequenceEntry_
{
	char*					fileName;		// Name of sequence file without .SEQ extension
	char*					entryName;		// Name of entry label in file
	sequenceCommandLine_s*	firstCommand;	// Linked list of commands in entry
	sequenceEntry_s*		nextEntry;		// Next loaded entry
	qboolean				isGlobal;		// Is entry retained over level transitions?
};



//---------------------------------------------------------------------------
// sentenceEntry_s
// Structure representing a single sentence of a group from a .SEQ
// file entry.  Sentences are identical to entries in sentences.txt, but
// can be unique per level and are loaded/unloaded with the level.
//---------------------------------------------------------------------------
typedef struct sentenceEntry_ sentenceEntry_s;
struct sentenceEntry_
{
	char*					data;			// sentence data (ie "We have hostiles" )
	sentenceEntry_s*		nextEntry;		// Next loaded entry
	qboolean				isGlobal;		// Is entry retained over level transitions?
	unsigned int			index;			// this entry's position in the file.
};

//--------------------------------------------------------------------------
// sentenceGroupEntry_s
// Structure representing a group of sentences found in a .SEQ file.
// A sentence group is defined by all sentences with the same name, ignoring
// the number at the end of the sentence name.  Groups enable a sentence
// to be picked at random across a group.
//--------------------------------------------------------------------------
typedef struct sentenceGroupEntry_ sentenceGroupEntry_s;
struct sentenceGroupEntry_
{
	char*					groupName;		// name of the group (ie CT_ALERT )
	unsigned int			numSentences;	// number of sentences in group
	sentenceEntry_s*		firstSentence;	// head of linked list of sentences in group
	sentenceGroupEntry_s*	nextEntry;		// next loaded group
};

//---------------------------------------------------------------------------
// Function declarations
//---------------------------------------------------------------------------
sequenceEntry_s* SequenceGet( const char* fileName, const char* entryName );
void Sequence_ParseFile( const char* fileName, qboolean isGlobal );
void Sequence_OnLevelLoad( const char* mapName );
sentenceEntry_s* SequencePickSentence( const char *groupName, int pickMethod, int *picked );

#endif /* _INCLUDE_SEQUENCE_H_ */

```

`engine/anorms.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/

{-0.525731, 0.000000, 0.850651}, 
{-0.442863, 0.238856, 0.864188}, 
{-0.295242, 0.000000, 0.955423}, 
{-0.309017, 0.500000, 0.809017}, 
{-0.162460, 0.262866, 0.951056}, 
{0.000000, 0.000000, 1.000000}, 
{0.000000, 0.850651, 0.525731}, 
{-0.147621, 0.716567, 0.681718}, 
{0.147621, 0.716567, 0.681718}, 
{0.000000, 0.525731, 0.850651}, 
{0.309017, 0.500000, 0.809017}, 
{0.525731, 0.000000, 0.850651}, 
{0.295242, 0.000000, 0.955423}, 
{0.442863, 0.238856, 0.864188}, 
{0.162460, 0.262866, 0.951056}, 
{-0.681718, 0.147621, 0.716567}, 
{-0.809017, 0.309017, 0.500000}, 
{-0.587785, 0.425325, 0.688191}, 
{-0.850651, 0.525731, 0.000000}, 
{-0.864188, 0.442863, 0.238856}, 
{-0.716567, 0.681718, 0.147621}, 
{-0.688191, 0.587785, 0.425325}, 
{-0.500000, 0.809017, 0.309017}, 
{-0.238856, 0.864188, 0.442863}, 
{-0.425325, 0.688191, 0.587785}, 
{-0.716567, 0.681718, -0.147621}, 
{-0.500000, 0.809017, -0.309017}, 
{-0.525731, 0.850651, 0.000000}, 
{0.000000, 0.850651, -0.525731}, 
{-0.238856, 0.864188, -0.442863}, 
{0.000000, 0.955423, -0.295242}, 
{-0.262866, 0.951056, -0.162460}, 
{0.000000, 1.000000, 0.000000}, 
{0.000000, 0.955423, 0.295242}, 
{-0.262866, 0.951056, 0.162460}, 
{0.238856, 0.864188, 0.442863}, 
{0.262866, 0.951056, 0.162460}, 
{0.500000, 0.809017, 0.309017}, 
{0.238856, 0.864188, -0.442863}, 
{0.262866, 0.951056, -0.162460}, 
{0.500000, 0.809017, -0.309017}, 
{0.850651, 0.525731, 0.000000}, 
{0.716567, 0.681718, 0.147621}, 
{0.716567, 0.681718, -0.147621}, 
{0.525731, 0.850651, 0.000000}, 
{0.425325, 0.688191, 0.587785}, 
{0.864188, 0.442863, 0.238856}, 
{0.688191, 0.587785, 0.425325}, 
{0.809017, 0.309017, 0.500000}, 
{0.681718, 0.147621, 0.716567}, 
{0.587785, 0.425325, 0.688191}, 
{0.955423, 0.295242, 0.000000}, 
{1.000000, 0.000000, 0.000000}, 
{0.951056, 0.162460, 0.262866}, 
{0.850651, -0.525731, 0.000000}, 
{0.955423, -0.295242, 0.000000}, 
{0.864188, -0.442863, 0.238856}, 
{0.951056, -0.162460, 0.262866}, 
{0.809017, -0.309017, 0.500000}, 
{0.681718, -0.147621, 0.716567}, 
{0.850651, 0.000000, 0.525731}, 
{0.864188, 0.442863, -0.238856}, 
{0.809017, 0.309017, -0.500000}, 
{0.951056, 0.162460, -0.262866}, 
{0.525731, 0.000000, -0.850651}, 
{0.681718, 0.147621, -0.716567}, 
{0.681718, -0.147621, -0.716567}, 
{0.850651, 0.000000, -0.525731}, 
{0.809017, -0.309017, -0.500000}, 
{0.864188, -0.442863, -0.238856}, 
{0.951056, -0.162460, -0.262866}, 
{0.147621, 0.716567, -0.681718}, 
{0.309017, 0.500000, -0.809017}, 
{0.425325, 0.688191, -0.587785}, 
{0.442863, 0.238856, -0.864188}, 
{0.587785, 0.425325, -0.688191}, 
{0.688191, 0.587785, -0.425325}, 
{-0.147621, 0.716567, -0.681718}, 
{-0.309017, 0.500000, -0.809017}, 
{0.000000, 0.525731, -0.850651}, 
{-0.525731, 0.000000, -0.850651}, 
{-0.442863, 0.238856, -0.864188}, 
{-0.295242, 0.000000, -0.955423}, 
{-0.162460, 0.262866, -0.951056}, 
{0.000000, 0.000000, -1.000000}, 
{0.295242, 0.000000, -0.955423}, 
{0.162460, 0.262866, -0.951056}, 
{-0.442863, -0.238856, -0.864188}, 
{-0.309017, -0.500000, -0.809017}, 
{-0.162460, -0.262866, -0.951056}, 
{0.000000, -0.850651, -0.525731}, 
{-0.147621, -0.716567, -0.681718}, 
{0.147621, -0.716567, -0.681718}, 
{0.000000, -0.525731, -0.850651}, 
{0.309017, -0.500000, -0.809017}, 
{0.442863, -0.238856, -0.864188}, 
{0.162460, -0.262866, -0.951056}, 
{0.238856, -0.864188, -0.442863}, 
{0.500000, -0.809017, -0.309017}, 
{0.425325, -0.688191, -0.587785}, 
{0.716567, -0.681718, -0.147621}, 
{0.688191, -0.587785, -0.425325}, 
{0.587785, -0.425325, -0.688191}, 
{0.000000, -0.955423, -0.295242}, 
{0.000000, -1.000000, 0.000000}, 
{0.262866, -0.951056, -0.162460}, 
{0.000000, -0.850651, 0.525731}, 
{0.000000, -0.955423, 0.295242}, 
{0.238856, -0.864188, 0.442863}, 
{0.262866, -0.951056, 0.162460}, 
{0.500000, -0.809017, 0.309017}, 
{0.716567, -0.681718, 0.147621}, 
{0.525731, -0.850651, 0.000000}, 
{-0.238856, -0.864188, -0.442863}, 
{-0.500000, -0.809017, -0.309017}, 
{-0.262866, -0.951056, -0.162460}, 
{-0.850651, -0.525731, 0.000000}, 
{-0.716567, -0.681718, -0.147621}, 
{-0.716567, -0.681718, 0.147621}, 
{-0.525731, -0.850651, 0.000000}, 
{-0.500000, -0.809017, 0.309017}, 
{-0.238856, -0.864188, 0.442863}, 
{-0.262866, -0.951056, 0.162460}, 
{-0.864188, -0.442863, 0.238856}, 
{-0.809017, -0.309017, 0.500000}, 
{-0.688191, -0.587785, 0.425325}, 
{-0.681718, -0.147621, 0.716567}, 
{-0.442863, -0.238856, 0.864188}, 
{-0.587785, -0.425325, 0.688191}, 
{-0.309017, -0.500000, 0.809017}, 
{-0.147621, -0.716567, 0.681718}, 
{-0.425325, -0.688191, 0.587785}, 
{-0.162460, -0.262866, 0.951056}, 
{0.442863, -0.238856, 0.864188}, 
{0.162460, -0.262866, 0.951056}, 
{0.309017, -0.500000, 0.809017}, 
{0.147621, -0.716567, 0.681718}, 
{0.000000, -0.525731, 0.850651}, 
{0.425325, -0.688191, 0.587785}, 
{0.587785, -0.425325, 0.688191}, 
{0.688191, -0.587785, 0.425325}, 
{-0.955423, 0.295242, 0.000000}, 
{-0.951056, 0.162460, 0.262866}, 
{-1.000000, 0.000000, 0.000000}, 
{-0.850651, 0.000000, 0.525731}, 
{-0.955423, -0.295242, 0.000000}, 
{-0.951056, -0.162460, 0.262866}, 
{-0.864188, 0.442863, -0.238856}, 
{-0.951056, 0.162460, -0.262866}, 
{-0.809017, 0.309017, -0.500000}, 
{-0.864188, -0.442863, -0.238856}, 
{-0.951056, -0.162460, -0.262866}, 
{-0.809017, -0.309017, -0.500000}, 
{-0.681718, 0.147621, -0.716567}, 
{-0.681718, -0.147621, -0.716567}, 
{-0.850651, 0.000000, -0.525731}, 
{-0.688191, 0.587785, -0.425325}, 
{-0.587785, 0.425325, -0.688191}, 
{-0.425325, 0.688191, -0.587785}, 
{-0.425325, -0.688191, -0.587785}, 
{-0.587785, -0.425325, -0.688191}, 
{-0.688191, -0.587785, -0.425325}, 

```

`engine/archtypes.h`:

```h
//
// Word size dependent definitions
// DAL 1/03
//
#ifndef ARCHTYPES_H
#define ARCHTYPES_H

#ifdef __x86_64__
#define X64BITS
#endif

#if defined( _WIN32 ) && (! defined( __MINGW32__ ))

typedef __int16 int16;
typedef unsigned __int16 uint16;
typedef __int32 int32;
typedef unsigned __int32 uint32;
typedef __int64 int64;
typedef unsigned __int64 uint64;
typedef __int32 intp;				// intp is an integer that can accommodate a pointer
typedef unsigned __int32 uintp;		// (ie, sizeof(intp) >= sizeof(int) && sizeof(intp) >= sizeof(void *)

#else /* _WIN32 */

typedef short int16;
typedef unsigned short uint16;
typedef int int32;
typedef unsigned int uint32;
typedef long long int64;
typedef unsigned long long uint64;
#ifdef X64BITS
typedef long long intp;
typedef unsigned long long uintp;
#else
typedef int intp;
typedef unsigned int uintp;
#endif

#endif /* else _WIN32 */

#endif /* ARCHTYPES_H */

```

`engine/cdll_int.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_int.h
//
// 4-23-98  
// JOHN:  client dll interface declarations
//

#ifndef CDLL_INT_H
#define CDLL_INT_H

#ifdef __cplusplus
extern "C" {
#endif

#include "const.h"


// this file is included by both the engine and the client-dll,
// so make sure engine declarations aren't done twice

typedef int HSPRITE;	// handle to a graphic

#define SCRINFO_SCREENFLASH 1
#define SCRINFO_STRETCHED	2

typedef struct SCREENINFO_s
{
	int		iSize;
	int		iWidth;
	int		iHeight;
	int		iFlags;
	int		iCharHeight;
	short	charWidths[256];
} SCREENINFO;


typedef struct client_data_s
{
	// fields that cannot be modified  (ie. have no effect if changed)
	vec3_t origin;

	// fields that can be changed by the cldll
	vec3_t viewangles;
	int		iWeaponBits;
	float	fov;	// field of view
} client_data_t;

typedef struct client_sprite_s
{
	char szName[64];
	char szSprite[64];
	int hspr;
	int iRes;
	wrect_t rc;
} client_sprite_t;

#ifndef CLIENT_TEXTMESAGE_S
typedef struct client_textmessage_s
{
	int		effect;
	byte	r1, g1, b1, a1;		// 2 colors for effects
	byte	r2, g2, b2, a2;
	float	x;
	float	y;
	float	fadein;
	float	fadeout;
	float	holdtime;
	float	fxtime;
	const char *pName;
	const char *pMessage;
} client_textmessage_t;
#endif

typedef struct hud_player_info_s
{
	char *name;
	short ping;
	byte thisplayer;  // TRUE if this is the calling player

  // stuff that's unused at the moment,  but should be done
	byte spectator;
	byte packetloss;

	char *model;
	short topcolor;
	short bottomcolor;

} hud_player_info_t;


typedef struct cl_enginefuncs_s
{
	// sprite handlers
	HSPRITE						( *pfnSPR_Load )			( const char *szPicName );
	int							( *pfnSPR_Frames )			( HSPRITE hPic );
	int							( *pfnSPR_Height )			( HSPRITE hPic, int frame );
	int							( *pfnSPR_Width )			( HSPRITE hPic, int frame );
	void						( *pfnSPR_Set )				( HSPRITE hPic, int r, int g, int b );
	void						( *pfnSPR_Draw )			( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_DrawHoles )		( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_DrawAdditive )	( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_EnableScissor )	( int x, int y, int width, int height );
	void						( *pfnSPR_DisableScissor )	( void );
	client_sprite_t				*( *pfnSPR_GetList )			( const char *psz, int *piCount );

	// screen handlers
	void						( *pfnFillRGBA )			( int x, int y, int width, int height, int r, int g, int b, int a );
	int							( *pfnGetScreenInfo ) 		( SCREENINFO *pscrinfo );
	void						( *pfnSetCrosshair )		( HSPRITE hspr, wrect_t rc, int r, int g, int b );

	// cvar handlers
	struct cvar_s				*( *pfnRegisterVariable )	( const char *szName, const char *szValue, int flags );
	float						( *pfnGetCvarFloat )		( const char *szName );
	char*						( *pfnGetCvarString )		( const char *szName );

	// command handlers
	int							( *pfnAddCommand )			( const char *cmd_name, void (*function)(void) );
	int							( *pfnHookUserMsg )			( const char *szMsgName, pfnUserMsgHook pfn );
	int							( *pfnServerCmd )			( const char *szCmdString );
	int							( *pfnClientCmd )			( const char *szCmdString );

	void						( *pfnGetPlayerInfo )		( int ent_num, hud_player_info_t *pinfo );

	// sound handlers
	void						( *pfnPlaySoundByName )		( const char *szSound, float volume );
	void						( *pfnPlaySoundByIndex )	( int iSound, float volume );

	// vector helpers
	void						( *pfnAngleVectors )		( const float * vecAngles, float * forward, float * right, float * up );

	// text message system
	client_textmessage_t		*( *pfnTextMessageGet )		( const char *pName );
	int							( *pfnDrawCharacter )		( int x, int y, int number, int r, int g, int b );
	int							( *pfnDrawConsoleString )	( int x, int y, const char *string );
	void						( *pfnDrawSetTextColor )	( float r, float g, float b );
	void						( *pfnDrawConsoleStringLen )(  const char *string, int *length, int *height );

	void						( *pfnConsolePrint )		( const char *string );
	void						( *pfnCenterPrint )			( const char *string );


// Added for user input processing
	int							( *GetWindowCenterX )		( void );
	int							( *GetWindowCenterY )		( void );
	void						( *GetViewAngles )			( float * );
	void						( *SetViewAngles )			( float * );
	int							( *GetMaxClients )			( void );
	void						( *Cvar_SetValue )			( const char *cvar, float value );

	int       					(*Cmd_Argc)					(void);	
	char						*( *Cmd_Argv )				( int arg );
	void						( *Con_Printf )				( const char *fmt, ... );
	void						( *Con_DPrintf )			( const char *fmt, ... );
	void						( *Con_NPrintf )			( int pos, char *fmt, ... );
	void						( *Con_NXPrintf )			( struct con_nprint_s *info, const char *fmt, ... );

	const char					*( *PhysInfo_ValueForKey )	( const char *key );
	const char					*( *ServerInfo_ValueForKey )( const char *key );
	float						( *GetClientMaxspeed )		( void );
	int							( *CheckParm )				( const char *parm, char **ppnext );
	void						( *Key_Event )				( int key, int down );
	void						( *GetMousePosition )		( int *mx, int *my );
	int							( *IsNoClipping )			( void );

	struct cl_entity_s			*( *GetLocalPlayer )		( void );
	struct cl_entity_s			*( *GetViewModel )			( void );
	struct cl_entity_s			*( *GetEntityByIndex )		( int idx );

	float						( *GetClientTime )			( void );
	void						( *V_CalcShake )			( void );
	void						( *V_ApplyShake )			( float *origin, float *angles, float factor );

	int							( *PM_PointContents )		( float *point, int *truecontents );
	int							( *PM_WaterEntity )			( float *p );
	struct pmtrace_s			*( *PM_TraceLine )			( float *start, float *end, int flags, int usehull, int ignore_pe );

	struct model_s				*( *CL_LoadModel )			( const char *modelname, int *index );
	int							( *CL_CreateVisibleEntity )	( int type, struct cl_entity_s *ent );

	const struct model_s *		( *GetSpritePointer )		( HSPRITE hSprite );
	void						( *pfnPlaySoundByNameAtLocation )	( char *szSound, float volume, float *origin );

	unsigned short				( *pfnPrecacheEvent )		( int type, const char* psz );
	void						( *pfnPlaybackEvent )		( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	void						( *pfnWeaponAnim )			( int iAnim, int body );
	float						( *pfnRandomFloat )			( float flLow, float flHigh );
	long						( *pfnRandomLong )			( long lLow, long lHigh );
	void						( *pfnHookEvent )			( const char *name, void ( *pfnEvent )( struct event_args_s *args ) );
	int							(*Con_IsVisible)			();
	const char					*( *pfnGetGameDirectory )	( void );
	struct cvar_s				*( *pfnGetCvarPointer )		( const char *szName );
	const char					*( *Key_LookupBinding )		( const char *pBinding );
	const char					*( *pfnGetLevelName )		( void );
	void						( *pfnGetScreenFade )		( struct screenfade_s *fade );
	void						( *pfnSetScreenFade )		( struct screenfade_s *fade );
	void                        *( *VGui_GetPanel )         ( );
	void                         ( *VGui_ViewportPaintBackground ) (int extents[4]);

	byte*						(*COM_LoadFile)				( const char *path, int usehunk, int *pLength );
	char*						(*COM_ParseFile)			( char *data, char *token );
	void						(*COM_FreeFile)				( void *buffer );
		
	struct triangleapi_s		*pTriAPI;
	struct efx_api_s			*pEfxAPI;
	struct event_api_s			*pEventAPI;
	struct demo_api_s			*pDemoAPI;
	struct net_api_s			*pNetAPI;
	struct IVoiceTweak_s		*pVoiceTweak;

	// returns 1 if the client is a spectator only (connected to a proxy), 0 otherwise or 2 if in dev_overview mode
	int							( *IsSpectateOnly ) ( void );
	struct model_s				*( *LoadMapSprite )			( const char *filename );

	// file search functions
	void						( *COM_AddAppDirectoryToSearchPath ) ( const char *pszBaseDir, const char *appName );
	int							( *COM_ExpandFilename)				 ( const char *fileName, char *nameOutBuffer, int nameOutBufferSize );

	// User info
	// playerNum is in the range (1, MaxClients)
	// returns NULL if player doesn't exit
	// returns "" if no value is set
	const char					*( *PlayerInfo_ValueForKey )( int playerNum, const char *key );
	void						( *PlayerInfo_SetValueForKey )( const char *key, const char *value );

	// Gets a unique ID for the specified player. This is the same even if you see the player on a different server.
	// iPlayer is an entity index, so client 0 would use iPlayer=1.
	// Returns false if there is no player on the server in the specified slot.
	qboolean					(*GetPlayerUniqueID)(int iPlayer, char playerID[16]);

	// TrackerID access
	int							(*GetTrackerIDForPlayer)(int playerSlot);
	int							(*GetPlayerForTrackerID)(int trackerID);

	// Same as pfnServerCmd, but the message goes in the unreliable stream so it can't clog the net stream
	// (but it might not get there).
	int							( *pfnServerCmdUnreliable )( char *szCmdString );

	void						( *pfnGetMousePos )( struct tagPOINT *ppt );
	void						( *pfnSetMousePos )( int x, int y );
	void						( *pfnSetMouseEnable )( qboolean fEnable );


	// undocumented interface starts here
	struct cvar_s*	(*pfnGetFirstCvarPtr)( void );
	void*		(*pfnGetFirstCmdFunctionHandle)( void );
	void*		(*pfnGetNextCmdFunctionHandle)( void *cmdhandle );
	const char*	(*pfnGetCmdFunctionName)( void *cmdhandle );
	float		(*pfnGetClientOldTime)( void );
	float		(*pfnGetGravity)( void );
	struct model_s*	(*pfnGetModelByIndex)( int index );
	void		(*pfnSetFilterMode)( int mode ); // same as gl_texsort in original Quake
	void		(*pfnSetFilterColor)( float red, float green, float blue );
	void		(*pfnSetFilterBrightness)( float brightness );
	void		*(*pfnSequenceGet)( const char *fileName, const char *entryName );
	void		(*pfnSPR_DrawGeneric)( int frame, int x, int y, const wrect_t *prc, int blendsrc, int blenddst, int width, int height );
	void		*(*pfnSequencePickSentence)( const char *groupName, int pickMethod, int *entryPicked );
	int		(*pfnDrawString)( int x, int y, const char *str, int r, int g, int b );
	int		(*pfnDrawStringReverse)( int x, int y, const char *str, int r, int g, int b );
	const char	*(*LocalPlayerInfo_ValueForKey)( const char* key );
	int		(*pfnVGUI2DrawCharacter)( int x, int y, int ch, unsigned int font );
	int		(*pfnVGUI2DrawCharacterAdditive)( int x, int y, int ch, int r, int g, int b, unsigned int font );
	unsigned int	(*pfnGetApproxWavePlayLen)( const char *filename );
	void*		(*GetCareerGameUI)( void );	// g-cont. !!!! potential crash-point!
	void		(*Cvar_Set)( const char *name, const char *value );
	int		(*pfnIsPlayingCareerMatch)( void );
	void		(*pfnPlaySoundVoiceByName)( const char *szSound, float volume, int pitch );
	void		(*pfnPrimeMusicStream)( const char *filename, int looping );
	double		(*pfnSys_FloatTime)( void );

	// decay funcs
	void		(*pfnProcessTutorMessageDecayBuffer)( int *buffer, int buflen );
	void		(*pfnConstructTutorMessageDecayBuffer)( int *buffer, int buflen );
	void		(*pfnResetTutorMessageDecayData)( void );

	void		(*pfnPlaySoundByNameAtPitch)( char *szSound, float volume, int pitch );
	void		(*pfnFillRGBABlend)( int x, int y, int width, int height, int r, int g, int b, int a );
	int		(*pfnGetAppID)( void );
	void	*(*pfnGetAliases)( void );
	void		(*pfnVguiWrap2_GetMouseDelta)( int *x, int *y );
} cl_enginefunc_t;

#ifndef IN_BUTTONS_H
#include "in_buttons.h"
#endif

#define CLDLL_INTERFACE_VERSION		7

extern void ClientDLL_Init( void ); // from cdll_int.c
extern void ClientDLL_Shutdown( void );
extern void ClientDLL_HudInit( void );
extern void ClientDLL_HudVidInit( void );
extern void	ClientDLL_UpdateClientData( void );
extern void ClientDLL_Frame( double time );
extern void ClientDLL_HudRedraw( int intermission );
extern void ClientDLL_MoveClient( struct playermove_s *ppmove );
extern void ClientDLL_ClientMoveInit( struct playermove_s *ppmove );
extern char ClientDLL_ClientTextureType( char *name );

extern void ClientDLL_CreateMove( float frametime, struct usercmd_s *cmd, int active );
extern void ClientDLL_ActivateMouse( void );
extern void ClientDLL_DeactivateMouse( void );
extern void ClientDLL_MouseEvent( int mstate );
extern void ClientDLL_ClearStates( void );
extern int ClientDLL_IsThirdPerson( void );
extern void ClientDLL_GetCameraOffsets( float *ofs );
extern int ClientDLL_GraphKeyDown( void );
extern struct kbutton_s *ClientDLL_FindKey( const char *name );
extern void ClientDLL_CAM_Think( void );
extern void ClientDLL_IN_Accumulate( void );
extern void ClientDLL_CalcRefdef( struct ref_params_s *pparams );
extern int ClientDLL_AddEntity( int type, struct cl_entity_s *ent );
extern void ClientDLL_CreateEntities( void );

extern void ClientDLL_DrawNormalTriangles( void );
extern void ClientDLL_DrawTransparentTriangles( void );
extern void ClientDLL_StudioEvent( const struct mstudioevent_s *event, const struct cl_entity_s *entity );
extern void ClientDLL_PostRunCmd( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
extern void ClientDLL_TxferLocalOverrides( struct entity_state_s *state, const struct clientdata_s *client );
extern void ClientDLL_ProcessPlayerState( struct entity_state_s *dst, const struct entity_state_s *src );
extern void ClientDLL_TxferPredictionData ( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd );
extern void ClientDLL_ReadDemoBuffer( int size, unsigned char *buffer );
extern int ClientDLL_ConnectionlessPacket( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );
extern int ClientDLL_GetHullBounds( int hullnumber, float *mins, float *maxs );

extern void ClientDLL_VGui_ConsolePrint(const char* text);

extern int ClientDLL_Key_Event( int down, int keynum, const char *pszCurrentBinding );
extern void ClientDLL_TempEntUpdate( double ft, double ct, double grav, struct tempent_s **ppFreeTE, struct tempent_s **ppActiveTE, int ( *addTEntity )( struct cl_entity_s *pEntity ), void ( *playTESound )( struct tempent_s *pTemp, float damp ) );
extern struct cl_entity_s *ClientDLL_GetUserEntity( int index );
extern void ClientDLL_VoiceStatus(int entindex, qboolean bTalking);
extern void ClientDLL_DirectorMessage( int iSize, void *pbuf );


#ifdef __cplusplus
}
#endif

#endif // CDLL_INT_H

```

`engine/custom.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// Customization.h

#ifndef CUSTOM_H
#define CUSTOM_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

#include "const.h"

#define MAX_QPATH 64    // Must match value in quakedefs.h

/////////////////
// Customization
// passed to pfnPlayerCustomization
// For automatic downloading.
typedef enum
{
	t_sound = 0,
	t_skin,
	t_model,
	t_decal,
	t_generic,
	t_eventscript,
	t_world,		// Fake type for world, is really t_model
} resourcetype_t;


typedef struct
{
	int				size;
} _resourceinfo_t;

typedef struct resourceinfo_s
{
	_resourceinfo_t info[ 8 ];
} resourceinfo_t;

#define RES_FATALIFMISSING (1<<0)   // Disconnect if we can't get this file.
#define RES_WASMISSING     (1<<1)   // Do we have the file locally, did we get it ok?
#define RES_CUSTOM         (1<<2)   // Is this resource one that corresponds to another player's customization
								    //  or is it a server startup resource.
#define RES_REQUESTED	   (1<<3)	// Already requested a download of this one
#define RES_PRECACHED	   (1<<4)	// Already precached

#include "crc.h"

typedef struct resource_s
{
	char              szFileName[MAX_QPATH]; // File name to download/precache.
	resourcetype_t    type;                // t_sound, t_skin, t_model, t_decal.
	int               nIndex;              // For t_decals
	int               nDownloadSize;       // Size in Bytes if this must be downloaded.
	unsigned char     ucFlags;

// For handling client to client resource propagation
	unsigned char     rgucMD5_hash[16];    // To determine if we already have it.
	unsigned char     playernum;           // Which player index this resource is associated with, if it's a custom resource.

	unsigned char	  rguc_reserved[ 32 ]; // For future expansion
	struct resource_s *pNext;              // Next in chain.
	struct resource_s *pPrev;
} resource_t;

typedef struct customization_s
{
	qboolean bInUse;     // Is this customization in use;
	resource_t resource; // The resource_t for this customization
	qboolean bTranslated; // Has the raw data been translated into a useable format?  
						   //  (e.g., raw decal .wad make into texture_t *)
	int        nUserData1; // Customization specific data
	int        nUserData2; // Customization specific data
	void *pInfo;          // Buffer that holds the data structure that references the data (e.g., the cachewad_t)
	void *pBuffer;       // Buffer that holds the data for the customization (the raw .wad data)
	struct customization_s *pNext; // Next in chain
} customization_t;

#define FCUST_FROMHPAK		( 1<<0 )
#define FCUST_WIPEDATA		( 1<<1 )
#define FCUST_IGNOREINIT	( 1<<2 )

void		COM_ClearCustomizationList( struct customization_s *pHead, qboolean bCleanDecals);
qboolean	COM_CreateCustomization( struct customization_s *pListHead, struct resource_s *pResource, int playernumber, int flags, 
				struct customization_s **pCustomization, int *nLumps ); 
int			COM_SizeofResourceList ( struct resource_s *pList, struct resourceinfo_s *ri );

#endif // CUSTOM_H

```

`engine/customentity.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CUSTOMENTITY_H
#define CUSTOMENTITY_H

// Custom Entities

// Start/End Entity is encoded as 12 bits of entity index, and 4 bits of attachment (4:12)
#define BEAMENT_ENTITY(x)		((x)&0xFFF)
#define BEAMENT_ATTACHMENT(x)	(((x)>>12)&0xF)

// Beam types, encoded as a byte
enum 
{
	BEAM_POINTS = 0,
	BEAM_ENTPOINT,
	BEAM_ENTS,
	BEAM_HOSE,
};

#define BEAM_FSINE		0x10
#define BEAM_FSOLID		0x20
#define BEAM_FSHADEIN	0x40
#define BEAM_FSHADEOUT	0x80

#endif	//CUSTOMENTITY_H

```

`engine/edict.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined EDICT_H
#define EDICT_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif
#define	MAX_ENT_LEAFS	48

#include "progdefs.h"

struct edict_s
{
	qboolean	free;
	int			serialnumber;
	link_t		area;				// linked to a division node or leaf
	
	int			headnode;			// -1 to use normal leaf check
	int			num_leafs;
	short		leafnums[MAX_ENT_LEAFS];

	float		freetime;			// sv.time when the object was freed

	void*		pvPrivateData;		// Alloced and freed by engine, used by DLLs

	entvars_t	v;					// C exported fields from progs

	// other fields from progs come immediately after
};

#endif

```

`engine/eiface.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef EIFACE_H
#define EIFACE_H

#include "archtypes.h"     // DAL

#ifdef HLDEMO_BUILD
#define INTERFACE_VERSION       001
#else  // !HLDEMO_BUILD, i.e., regular version of HL
#define INTERFACE_VERSION		140
#endif // !HLDEMO_BUILD

#include <stdio.h>
#include "custom.h"
#include "cvardef.h"
#include "Sequence.h"
//
// Defines entity interface between engine and DLLs.
// This header file included by engine files and DLL files.
//
// Before including this header, DLLs must:
//		include progdefs.h
// This is conveniently done for them in extdll.h
//

typedef enum
	{
	at_notice,
	at_console,		// same as at_notice, but forces a ConPrintf, not a message box
	at_aiconsole,	// same as at_console, but only shown if developer level is 2!
	at_warning,
	at_error,
	at_logged		// Server print to console ( only in multiplayer games ).
	} ALERT_TYPE;

// 4-22-98  JOHN: added for use in pfnClientPrintf
typedef enum
	{
	print_console,
	print_center,
	print_chat,
	} PRINT_TYPE;

// For integrity checking of content on clients
typedef enum
{
	force_exactfile,					// File on client must exactly match server's file
	force_model_samebounds,				// For model files only, the geometry must fit in the same bbox
	force_model_specifybounds,			// For model files only, the geometry must fit in the specified bbox
	force_model_specifybounds_if_avail,	// For Steam model files only, the geometry must fit in the specified bbox (if the file is available)
} FORCE_TYPE;

// Returned by TraceLine
typedef struct
	{
	int		fAllSolid;			// if true, plane is not valid
	int		fStartSolid;		// if true, the initial point was in a solid area
	int		fInOpen;
	int		fInWater;
	float	flFraction;			// time completed, 1.0 = didn't hit anything
	vec3_t	vecEndPos;			// final position
	float	flPlaneDist;
	vec3_t	vecPlaneNormal;		// surface normal at impact
	edict_t	*pHit;				// entity the surface is on
	int		iHitgroup;			// 0 == generic, non zero is specific body part
	} TraceResult;

// CD audio status
typedef struct 
{
	int	fPlaying;// is sound playing right now?
	int	fWasPlaying;// if not, CD is paused if WasPlaying is true.
	int	fInitialized;
	int	fEnabled;
	int	fPlayLooping;
	float	cdvolume;
	//BYTE 	remap[100];
	int	fCDRom;
	int	fPlayTrack;
} CDStatus;

#include "../common/crc.h"


// Engine hands this to DLLs for functionality callbacks
typedef struct enginefuncs_s
{
	int			(*pfnPrecacheModel)			(const char* s);
	int			(*pfnPrecacheSound)			(const char* s);
	void		(*pfnSetModel)				(edict_t *e, const char *m);
	int			(*pfnModelIndex)			(const char *m);
	int			(*pfnModelFrames)			(int modelIndex);
	void		(*pfnSetSize)				(edict_t *e, const float *rgflMin, const float *rgflMax);
	void		(*pfnChangeLevel)			(char* s1, char* s2);
	void		(*pfnGetSpawnParms)			(edict_t *ent);
	void		(*pfnSaveSpawnParms)		(edict_t *ent);
	float		(*pfnVecToYaw)				(const float *rgflVector);
	void		(*pfnVecToAngles)			(const float *rgflVectorIn, float *rgflVectorOut);
	void		(*pfnMoveToOrigin)			(edict_t *ent, const float *pflGoal, float dist, int iMoveType);
	void		(*pfnChangeYaw)				(edict_t* ent);
	void		(*pfnChangePitch)			(edict_t* ent);
	edict_t*	(*pfnFindEntityByString)	(edict_t *pEdictStartSearchAfter, const char *pszField, const char *pszValue);
	int			(*pfnGetEntityIllum)		(edict_t* pEnt);
	edict_t*	(*pfnFindEntityInSphere)	(edict_t *pEdictStartSearchAfter, const float *org, float rad);
	edict_t*	(*pfnFindClientInPVS)		(edict_t *pEdict);
	edict_t* (*pfnEntitiesInPVS)			(edict_t *pplayer);
	void		(*pfnMakeVectors)			(const float *rgflVector);
	void		(*pfnAngleVectors)			(const float *rgflVector, float *forward, float *right, float *up);
	edict_t*	(*pfnCreateEntity)			(void);
	void		(*pfnRemoveEntity)			(edict_t* e);
	edict_t*	(*pfnCreateNamedEntity)		(int className);
	void		(*pfnMakeStatic)			(edict_t *ent);
	int			(*pfnEntIsOnFloor)			(edict_t *e);
	int			(*pfnDropToFloor)			(edict_t* e);
	int			(*pfnWalkMove)				(edict_t *ent, float yaw, float dist, int iMode);
	void		(*pfnSetOrigin)				(edict_t *e, const float *rgflOrigin);
	void		(*pfnEmitSound)				(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch);
	void		(*pfnEmitAmbientSound)		(edict_t *entity, float *pos, const char *samp, float vol, float attenuation, int fFlags, int pitch);
	void		(*pfnTraceLine)				(const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceToss)				(edict_t* pent, edict_t* pentToIgnore, TraceResult *ptr);
	int			(*pfnTraceMonsterHull)		(edict_t *pEdict, const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceHull)				(const float *v1, const float *v2, int fNoMonsters, int hullNumber, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceModel)			(const float *v1, const float *v2, int hullNumber, edict_t *pent, TraceResult *ptr);
	const char *(*pfnTraceTexture)			(edict_t *pTextureEntity, const float *v1, const float *v2 );
	void		(*pfnTraceSphere)			(const float *v1, const float *v2, int fNoMonsters, float radius, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnGetAimVector)			(edict_t* ent, float speed, float *rgflReturn);
	void		(*pfnServerCommand)			(char* str);
	void		(*pfnServerExecute)			(void);
	void		(*pfnClientCommand)			(edict_t* pEdict, char* szFmt, ...);
	void		(*pfnParticleEffect)		(const float *org, const float *dir, float color, float count);
	void		(*pfnLightStyle)			(int style, char* val);
	int			(*pfnDecalIndex)			(const char *name);
	int			(*pfnPointContents)			(const float *rgflVector);
	void		(*pfnMessageBegin)			(int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	void		(*pfnMessageEnd)			(void);
	void		(*pfnWriteByte)				(int iValue);
	void		(*pfnWriteChar)				(int iValue);
	void		(*pfnWriteShort)			(int iValue);
	void		(*pfnWriteLong)				(int iValue);
	void		(*pfnWriteAngle)			(float flValue);
	void		(*pfnWriteCoord)			(float flValue);
	void		(*pfnWriteString)			(const char *sz);
	void		(*pfnWriteEntity)			(int iValue);
	void		(*pfnCVarRegister)			(cvar_t *pCvar);
	float		(*pfnCVarGetFloat)			(const char *szVarName);
	const char*	(*pfnCVarGetString)			(const char *szVarName);
	void		(*pfnCVarSetFloat)			(const char *szVarName, float flValue);
	void		(*pfnCVarSetString)			(const char *szVarName, const char *szValue);
	void		(*pfnAlertMessage)			(ALERT_TYPE atype, const char *szFmt, ...);
	void		(*pfnEngineFprintf)			(void *pfile, const char *szFmt, ...);
	void*		(*pfnPvAllocEntPrivateData)	(edict_t *pEdict, int32 cb);
	void*		(*pfnPvEntPrivateData)		(edict_t *pEdict);
	void		(*pfnFreeEntPrivateData)	(edict_t *pEdict);
	const char*	(*pfnSzFromIndex)			(int iString);
	int			(*pfnAllocString)			(const char *szValue);
	struct entvars_s*	(*pfnGetVarsOfEnt)			(edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntOffset)	(int iEntOffset);
	int			(*pfnEntOffsetOfPEntity)	(const edict_t *pEdict);
	int			(*pfnIndexOfEdict)			(const edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntIndex)		(int iEntIndex);
	edict_t*	(*pfnFindEntityByVars)		(struct entvars_s* pvars);
	void*		(*pfnGetModelPtr)			(edict_t* pEdict);
	int			(*pfnRegUserMsg)			(const char *pszName, int iSize);
	void		(*pfnAnimationAutomove)		(const edict_t* pEdict, float flTime);
	void		(*pfnGetBonePosition)		(const edict_t* pEdict, int iBone, float *rgflOrigin, float *rgflAngles );
	uint32 (*pfnFunctionFromName)	( const char *pName );
	const char *(*pfnNameForFunction)		( uint32 function );
	void		(*pfnClientPrintf)			( edict_t* pEdict, PRINT_TYPE ptype, const char *szMsg ); // JOHN: engine callbacks so game DLL can print messages to individual clients
	void		(*pfnServerPrint)			( const char *szMsg );
	const char *(*pfnCmd_Args)				( void );		// these 3 added 
	const char *(*pfnCmd_Argv)				( int argc );	// so game DLL can easily 
	int			(*pfnCmd_Argc)				( void );		// access client 'cmd' strings
	void		(*pfnGetAttachment)			(const edict_t *pEdict, int iAttachment, float *rgflOrigin, float *rgflAngles );
	void		(*pfnCRC32_Init)			(CRC32_t *pulCRC);
	void        (*pfnCRC32_ProcessBuffer)   (CRC32_t *pulCRC, void *p, int len);
	void		(*pfnCRC32_ProcessByte)     (CRC32_t *pulCRC, unsigned char ch);
	CRC32_t		(*pfnCRC32_Final)			(CRC32_t pulCRC);
	int32		(*pfnRandomLong)			(int32  lLow,  int32  lHigh);
	float		(*pfnRandomFloat)			(float flLow, float flHigh);
	void		(*pfnSetView)				(const edict_t *pClient, const edict_t *pViewent );
	float		(*pfnTime)					( void );
	void		(*pfnCrosshairAngle)		(const edict_t *pClient, float pitch, float yaw);
	byte *      (*pfnLoadFileForMe)         (char *filename, int *pLength);
	void        (*pfnFreeFile)              (void *buffer);
	void        (*pfnEndSection)            (const char *pszSectionName); // trigger_endsection
	int 		(*pfnCompareFileTime)       (char *filename1, char *filename2, int *iCompare);
	void        (*pfnGetGameDir)            (char *szGetGameDir);
	void		(*pfnCvar_RegisterVariable) (cvar_t *variable);
	void        (*pfnFadeClientVolume)      (const edict_t *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds);
	void        (*pfnSetClientMaxspeed)     (const edict_t *pEdict, float fNewMaxspeed);
	edict_t *	(*pfnCreateFakeClient)		(const char *netname);	// returns NULL if fake client can't be created
	void		(*pfnRunPlayerMove)			(edict_t *fakeclient, const float *viewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, byte impulse, byte msec );
	int			(*pfnNumberOfEntities)		(void);
	char*		(*pfnGetInfoKeyBuffer)		(edict_t *e);	// passing in NULL gets the serverinfo
	char*		(*pfnInfoKeyValue)			(char *infobuffer, char *key);
	void		(*pfnSetKeyValue)			(char *infobuffer, char *key, char *value);
	void		(*pfnSetClientKeyValue)		(int clientIndex, char *infobuffer, char *key, char *value);
	int			(*pfnIsMapValid)			(char *filename);
	void		(*pfnStaticDecal)			( const float *origin, int decalIndex, int entityIndex, int modelIndex );
	int			(*pfnPrecacheGeneric)		(char* s);
	int			(*pfnGetPlayerUserId)		(edict_t *e ); // returns the server assigned userid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients
	void		(*pfnBuildSoundMsg)			(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch, int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	int			(*pfnIsDedicatedServer)		(void);// is this a dedicated server?
	cvar_t		*(*pfnCVarGetPointer)		(const char *szVarName);
	unsigned int (*pfnGetPlayerWONId)		(edict_t *e); // returns the server assigned WONid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients

	// YWB 8/1/99 TFF Physics additions
	void		(*pfnInfo_RemoveKey)		( char *s, const char *key );
	const char *(*pfnGetPhysicsKeyValue)	( const edict_t *pClient, const char *key );
	void		(*pfnSetPhysicsKeyValue)	( const edict_t *pClient, const char *key, const char *value );
	const char *(*pfnGetPhysicsInfoString)	( const edict_t *pClient );
	unsigned short (*pfnPrecacheEvent)		( int type, const char*psz );
	void		(*pfnPlaybackEvent)			( int flags, const edict_t *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );

	unsigned char *(*pfnSetFatPVS)			( float *org );
	unsigned char *(*pfnSetFatPAS)			( float *org );

	int			(*pfnCheckVisibility )		( const edict_t *entity, unsigned char *pset );

	void		(*pfnDeltaSetField)			( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaUnsetField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaAddEncoder)		( char *name, void (*conditionalencode)( struct delta_s *pFields, const unsigned char *from, const unsigned char *to ) );
	int			(*pfnGetCurrentPlayer)		( void );
	int			(*pfnCanSkipPlayer)			( const edict_t *player );
	int			(*pfnDeltaFindField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaSetFieldByIndex)	( struct delta_s *pFields, int fieldNumber );
	void		(*pfnDeltaUnsetFieldByIndex)( struct delta_s *pFields, int fieldNumber );

	void		(*pfnSetGroupMask)			( int mask, int op );

	int			(*pfnCreateInstancedBaseline) ( int classname, struct entity_state_s *baseline );
	void		(*pfnCvar_DirectSet)		( struct cvar_s *var, char *value );

	// Forces the client and server to be running with the same version of the specified file
	//  ( e.g., a player model ).
	// Calling this has no effect in single player
	void		(*pfnForceUnmodified)		( FORCE_TYPE type, float *mins, float *maxs, const char *filename );

	void		(*pfnGetPlayerStats)		( const edict_t *pClient, int *ping, int *packet_loss );

	void		(*pfnAddServerCommand)		( char *cmd_name, void (*function) (void) );

	// For voice communications, set which clients hear eachother.
	// NOTE: these functions take player entity indices (starting at 1).
	qboolean	(*pfnVoice_GetClientListening)(int iReceiver, int iSender);
	qboolean	(*pfnVoice_SetClientListening)(int iReceiver, int iSender, qboolean bListen);

	const char *(*pfnGetPlayerAuthId)		( edict_t *e );

	// PSV: Added for CZ training map
//	const char *(*pfnKeyNameForBinding)					( const char* pBinding );
	
	sequenceEntry_s*	(*pfnSequenceGet)				( const char* fileName, const char* entryName );
	sentenceEntry_s*	(*pfnSequencePickSentence)		( const char* groupName, int pickMethod, int *picked );

	// LH: Give access to filesize via filesystem
	int			(*pfnGetFileSize)						( char *filename );

	unsigned int (*pfnGetApproxWavePlayLen)				(const char *filepath);
	// MDC: Added for CZ career-mode
	int			(*pfnIsCareerMatch)						( void );

	// BGC: return the number of characters of the localized string referenced by using "label"
	int			(*pfnGetLocalizedStringLength)			(const char *label);

	// BGC: added to facilitate persistent storage of tutor message decay values for
	// different career game profiles.  Also needs to persist regardless of mp.dll being
	// destroyed and recreated.
	void		(*pfnRegisterTutorMessageShown)			(int mid);
	int			(*pfnGetTimesTutorMessageShown)			(int mid);
	void		(*pfnProcessTutorMessageDecayBuffer)	(int *buffer, int bufferLength);
	void		(*pfnConstructTutorMessageDecayBuffer)	(int *buffer, int bufferLength);
	void		(*pfnResetTutorMessageDecayData)		( void );
	void		(*pfnQueryClientCvarValue)				( const edict_t *player, const char *cvarName );
	void		(*pfnQueryClientCvarValue2)				( const edict_t *player, const char *cvarName, int requestID );
	int		(*pfnEngCheckParm)					( const char *pchCmdLineToken, char **pchNextVal );
} enginefuncs_t;


// ONLY ADD NEW FUNCTIONS TO THE END OF THIS STRUCT.  INTERFACE VERSION IS FROZEN AT 138

// Passed to pfnKeyValue
typedef struct KeyValueData_s
{
	char	*szClassName;	// in: entity classname
	char	*szKeyName;		// in: name of key
	char	*szValue;		// in: value of key
	int32	fHandled;		// out: DLL sets to true if key-value pair was understood
} KeyValueData;


typedef struct
{
	char		mapName[ 32 ];
	char		landmarkName[ 32 ];
	edict_t	*pentLandmark;
	vec3_t		vecLandmarkOrigin;
} LEVELLIST;
#define MAX_LEVEL_CONNECTIONS	16		// These are encoded in the lower 16bits of ENTITYTABLE->flags

typedef struct 
{
	int			id;				// Ordinal ID of this entity (used for entity <--> pointer conversions)
	edict_t	*pent;			// Pointer to the in-game entity

	int			location;		// Offset from the base data of this entity
	int			size;			// Byte size of this entity's data
	int			flags;			// This could be a short -- bit mask of transitions that this entity is in the PVS of
	string_t	classname;		// entity class name

} ENTITYTABLE;

#define FENTTABLE_PLAYER		0x80000000
#define FENTTABLE_REMOVED		0x40000000
#define FENTTABLE_MOVEABLE		0x20000000
#define FENTTABLE_GLOBAL		0x10000000

typedef struct saverestore_s SAVERESTOREDATA;

#ifdef _WIN32
typedef 
#endif
struct saverestore_s
{
	char		*pBaseData;		// Start of all entity save data
	char		*pCurrentData;	// Current buffer pointer for sequential access
	int			size;			// Current data size
	int			bufferSize;		// Total space for data
	int			tokenSize;		// Size of the linear list of tokens
	int			tokenCount;		// Number of elements in the pTokens table
	char		**pTokens;		// Hash table of entity strings (sparse)
	int			currentIndex;	// Holds a global entity table ID
	int			tableCount;		// Number of elements in the entity table
	int			connectionCount;// Number of elements in the levelList[]
	ENTITYTABLE	*pTable;		// Array of ENTITYTABLE elements (1 for each entity)
	LEVELLIST	levelList[ MAX_LEVEL_CONNECTIONS ];		// List of connections from this level

	// smooth transition
	int			fUseLandmark;
	char		szLandmarkName[20];// landmark we'll spawn near in next level
	vec3_t		vecLandmarkOffset;// for landmark transitions
	float		time;
	char		szCurrentMapName[32];	// To check global entities

} 
#ifdef _WIN32
SAVERESTOREDATA 
#endif
;

typedef enum _fieldtypes
{
	FIELD_FLOAT = 0,		// Any floating point value
	FIELD_STRING,			// A string ID (return from ALLOC_STRING)
	FIELD_ENTITY,			// An entity offset (EOFFSET)
	FIELD_CLASSPTR,			// CBaseEntity *
	FIELD_EHANDLE,			// Entity handle
	FIELD_EVARS,			// EVARS *
	FIELD_EDICT,			// edict_t *, or edict_t *  (same thing)
	FIELD_VECTOR,			// Any vector
	FIELD_POSITION_VECTOR,	// A world coordinate (these are fixed up across level transitions automagically)
	FIELD_POINTER,			// Arbitrary data pointer... to be removed, use an array of FIELD_CHARACTER
	FIELD_INTEGER,			// Any integer or enum
	FIELD_FUNCTION,			// A class function pointer (Think, Use, etc)
	FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
	FIELD_SHORT,			// 2 byte integer
	FIELD_CHARACTER,		// a byte
	FIELD_TIME,				// a floating point time (these are fixed up automatically too!)
	FIELD_MODELNAME,		// Engine string that is a model name (needs precache)
	FIELD_SOUNDNAME,		// Engine string that is a sound name (needs precache)

	FIELD_TYPECOUNT,		// MUST BE LAST
} FIELDTYPE;

#ifndef offsetof
#define offsetof(s,m)	(size_t)&(((s *)0)->m)
#endif

#define _FIELD(type,name,fieldtype,count,flags)		{ fieldtype, #name, offsetof(type, name), count, flags }
#define DEFINE_FIELD(type,name,fieldtype)			_FIELD(type, name, fieldtype, 1, 0)
#define DEFINE_ARRAY(type,name,fieldtype,count)		_FIELD(type, name, fieldtype, count, 0)
#define DEFINE_ENTITY_FIELD(name,fieldtype)			_FIELD(entvars_t, name, fieldtype, 1, 0 )
#define DEFINE_ENTITY_GLOBAL_FIELD(name,fieldtype)	_FIELD(entvars_t, name, fieldtype, 1, FTYPEDESC_GLOBAL )
#define DEFINE_GLOBAL_FIELD(type,name,fieldtype)	_FIELD(type, name, fieldtype, 1, FTYPEDESC_GLOBAL )


#define FTYPEDESC_GLOBAL			0x0001		// This field is masked for global entity save/restore

typedef struct 
{
	FIELDTYPE		fieldType;
	char			*fieldName;
	int				fieldOffset;
	short			fieldSize;
	short			flags;
} TYPEDESCRIPTION;

#ifndef ARRAYSIZE
#define ARRAYSIZE(p)		(sizeof(p)/sizeof(p[0]))
#endif

typedef struct 
{
	// Initialize/shutdown the game (one-time call after loading of game .dll )
	void			(*pfnGameInit)			( void );				
	int				(*pfnSpawn)				( edict_t *pent );
	void			(*pfnThink)				( edict_t *pent );
	void			(*pfnUse)				( edict_t *pentUsed, edict_t *pentOther );
	void			(*pfnTouch)				( edict_t *pentTouched, edict_t *pentOther );
	void			(*pfnBlocked)			( edict_t *pentBlocked, edict_t *pentOther );
	void			(*pfnKeyValue)			( edict_t *pentKeyvalue, KeyValueData *pkvd );
	void			(*pfnSave)				( edict_t *pent, SAVERESTOREDATA *pSaveData );
	int 			(*pfnRestore)			( edict_t *pent, SAVERESTOREDATA *pSaveData, int globalEntity );
	void			(*pfnSetAbsBox)			( edict_t *pent );

	void			(*pfnSaveWriteFields)	( SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int );
	void			(*pfnSaveReadFields)	( SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int );

	void			(*pfnSaveGlobalState)		( SAVERESTOREDATA * );
	void			(*pfnRestoreGlobalState)	( SAVERESTOREDATA * );
	void			(*pfnResetGlobalState)		( void );

	qboolean		(*pfnClientConnect)		( edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[ 128 ] );
	
	void			(*pfnClientDisconnect)	( edict_t *pEntity );
	void			(*pfnClientKill)		( edict_t *pEntity );
	void			(*pfnClientPutInServer)	( edict_t *pEntity );
	void			(*pfnClientCommand)		( edict_t *pEntity );
	void			(*pfnClientUserInfoChanged)( edict_t *pEntity, char *infobuffer );

	void			(*pfnServerActivate)	( edict_t *pEdictList, int edictCount, int clientMax );
	void			(*pfnServerDeactivate)	( void );

	void			(*pfnPlayerPreThink)	( edict_t *pEntity );
	void			(*pfnPlayerPostThink)	( edict_t *pEntity );

	void			(*pfnStartFrame)		( void );
	void			(*pfnParmsNewLevel)		( void );
	void			(*pfnParmsChangeLevel)	( void );

	 // Returns string describing current .dll.  E.g., TeamFotrress 2, Half-Life
	const char     *(*pfnGetGameDescription)( void );     

	// Notify dll about a player customization.
	void            (*pfnPlayerCustomization) ( edict_t *pEntity, customization_t *pCustom );  

	// Spectator funcs
	void			(*pfnSpectatorConnect)		( edict_t *pEntity );
	void			(*pfnSpectatorDisconnect)	( edict_t *pEntity );
	void			(*pfnSpectatorThink)		( edict_t *pEntity );

	// Notify game .dll that engine is going to shut down.  Allows mod authors to set a breakpoint.
	void			(*pfnSys_Error)			( const char *error_string );

	void			(*pfnPM_Move) ( struct playermove_s *ppmove, qboolean server );
	void			(*pfnPM_Init) ( struct playermove_s *ppmove );
	char			(*pfnPM_FindTextureType)( char *name );
	void			(*pfnSetupVisibility)( struct edict_s *pViewEntity, struct edict_s *pClient, unsigned char **pvs, unsigned char **pas );
	void			(*pfnUpdateClientData) ( const struct edict_s *ent, int sendweapons, struct clientdata_s *cd );
	int				(*pfnAddToFullPack)( struct entity_state_s *state, int e, edict_t *ent, edict_t *host, int hostflags, int player, unsigned char *pSet );
	void			(*pfnCreateBaseline) ( int player, int eindex, struct entity_state_s *baseline, struct edict_s *entity, int playermodelindex, vec3_t player_mins, vec3_t player_maxs );
	void			(*pfnRegisterEncoders)	( void );
	int				(*pfnGetWeaponData)		( struct edict_s *player, struct weapon_data_s *info );

	void			(*pfnCmdStart)			( const edict_t *player, const struct usercmd_s *cmd, unsigned int random_seed );
	void			(*pfnCmdEnd)			( const edict_t *player );

	// Return 1 if the packet is valid.  Set response_buffer_size if you want to send a response packet.  Incoming, it holds the max
	//  size of the response_buffer, so you must zero it out if you choose not to respond.
	int				(*pfnConnectionlessPacket )	( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );

	// Enumerates player hulls.  Returns 0 if the hull number doesn't exist, 1 otherwise
	int				(*pfnGetHullBounds)	( int hullnumber, float *mins, float *maxs );

	// Create baselines for certain "unplaced" items.
	void			(*pfnCreateInstancedBaselines) ( void );

	// One of the pfnForceUnmodified files failed the consistency check for the specified player
	// Return 0 to allow the client to continue, 1 to force immediate disconnection ( with an optional disconnect message of up to 256 characters )
	int				(*pfnInconsistentFile)( const struct edict_s *player, const char *filename, char *disconnect_message );

	// The game .dll should return 1 if lag compensation should be allowed ( could also just set
	//  the sv_unlag cvar.
	// Most games right now should return 0, until client-side weapon prediction code is written
	//  and tested for them.
	int				(*pfnAllowLagCompensation)( void );
} DLL_FUNCTIONS;

extern DLL_FUNCTIONS		gEntityInterface;

// Current version.
#define NEW_DLL_FUNCTIONS_VERSION	1

typedef struct
{
	// Called right before the object's memory is freed. 
	// Calls its destructor.
	void			(*pfnOnFreeEntPrivateData)(edict_t *pEnt);
	void			(*pfnGameShutdown)(void);
	int				(*pfnShouldCollide)( edict_t *pentTouched, edict_t *pentOther );
	void			(*pfnCvarValue)( const edict_t *pEnt, const char *value );
	void			(*pfnCvarValue2)( const edict_t *pEnt, int requestID, const char *cvarName, const char *value );
} NEW_DLL_FUNCTIONS;
typedef int	(*NEW_DLL_FUNCTIONS_FN)( NEW_DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion );

// Pointers will be null if the game DLL doesn't support this API.
extern NEW_DLL_FUNCTIONS	gNewDLLFunctions;

typedef int	(*APIFUNCTION)( DLL_FUNCTIONS *pFunctionTable, int interfaceVersion );
typedef int	(*APIFUNCTION2)( DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion );

#endif /* EIFACE_H */

```

`engine/keydefs.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// keydefs.h
#ifndef KEYDEFS_H
#define KEYDEFS_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

//
// these are the key numbers that should be passed to Key_Event
//
#define	K_TAB			9
#define	K_ENTER			13
#define	K_ESCAPE		27
#define	K_SPACE			32

// normal keys should be passed as lowercased ascii

#define	K_BACKSPACE		127
#define	K_UPARROW		128
#define	K_DOWNARROW		129
#define	K_LEFTARROW		130
#define	K_RIGHTARROW	131

#define	K_ALT			132
#define	K_CTRL			133
#define	K_SHIFT			134
#define	K_F1			135
#define	K_F2			136
#define	K_F3			137
#define	K_F4			138
#define	K_F5			139
#define	K_F6			140
#define	K_F7			141
#define	K_F8			142
#define	K_F9			143
#define	K_F10			144
#define	K_F11			145
#define	K_F12			146
#define	K_INS			147
#define	K_DEL			148
#define	K_PGDN			149
#define	K_PGUP			150
#define	K_HOME			151
#define	K_END			152

#define K_KP_HOME		160
#define K_KP_UPARROW	161
#define K_KP_PGUP		162
#define	K_KP_LEFTARROW	163
#define K_KP_5			164
#define K_KP_RIGHTARROW	165
#define K_KP_END		166
#define K_KP_DOWNARROW	167
#define K_KP_PGDN		168
#define	K_KP_ENTER		169
#define K_KP_INS   		170
#define	K_KP_DEL		171
#define K_KP_SLASH		172
#define K_KP_MINUS		173
#define K_KP_PLUS		174
#define K_CAPSLOCK		175


//
// joystick buttons
//
#define	K_JOY1			203
#define	K_JOY2			204
#define	K_JOY3			205
#define	K_JOY4			206

//
// aux keys are for multi-buttoned joysticks to generate so they can use
// the normal binding process
//
#define	K_AUX1			207
#define	K_AUX2			208
#define	K_AUX3			209
#define	K_AUX4			210
#define	K_AUX5			211
#define	K_AUX6			212
#define	K_AUX7			213
#define	K_AUX8			214
#define	K_AUX9			215
#define	K_AUX10			216
#define	K_AUX11			217
#define	K_AUX12			218
#define	K_AUX13			219
#define	K_AUX14			220
#define	K_AUX15			221
#define	K_AUX16			222
#define	K_AUX17			223
#define	K_AUX18			224
#define	K_AUX19			225
#define	K_AUX20			226
#define	K_AUX21			227
#define	K_AUX22			228
#define	K_AUX23			229
#define	K_AUX24			230
#define	K_AUX25			231
#define	K_AUX26			232
#define	K_AUX27			233
#define	K_AUX28			234
#define	K_AUX29			235
#define	K_AUX30			236
#define	K_AUX31			237
#define	K_AUX32			238
#define K_MWHEELDOWN	239
#define K_MWHEELUP		240

#define K_PAUSE			255

//
// mouse buttons generate virtual keys
//
#define	K_MOUSE1		241
#define	K_MOUSE2		242
#define	K_MOUSE3		243
#define K_MOUSE4		244
#define K_MOUSE5		245

#endif // KEYDEFS_H

```

`engine/menu_int.h`:

```h
/*
menu_int.h - interface between engine and menu
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef MENU_INT_H
#define MENU_INT_H

#include "cvardef.h"
#include "gameinfo.h"
#include "wrect.h"

typedef int		HIMAGE;		// handle to a graphic

// flags for PIC_Load
#define PIC_NEAREST		(1<<0)		// disable texfilter
#define PIC_KEEP_RGBDATA	(1<<1)		// some images keep source
#define PIC_NOFLIP_TGA	(1<<2)		// Steam background completely ignore tga attribute 0x20
#define PIC_KEEP_8BIT	(1<<3)		// keep original 8-bit image (if present)

typedef struct ui_globalvars_s
{	
	float		time;		// unclamped host.realtime
	float		frametime;

	int		scrWidth;		// actual values
	int		scrHeight;

	int		maxClients;
	int		developer;
	int		demoplayback;
	int		demorecording;
	char		demoname[64];	// name of currently playing demo
	char		maptitle[64];	// title of active map
} ui_globalvars_t;

typedef struct ui_enginefuncs_s
{
	// image handlers
	HIMAGE	(*pfnPIC_Load)( const char *szPicName, const byte *ucRawImage, long ulRawImageSize, long flags );
	void	(*pfnPIC_Free)( const char *szPicName );
	int	(*pfnPIC_Width)( HIMAGE hPic );
	int	(*pfnPIC_Height)( HIMAGE hPic );
	void	(*pfnPIC_Set)( HIMAGE hPic, int r, int g, int b, int a );
	void	(*pfnPIC_Draw)( int x, int y, int width, int height, const wrect_t *prc );
	void	(*pfnPIC_DrawHoles)( int x, int y, int width, int height, const wrect_t *prc );
	void	(*pfnPIC_DrawTrans)( int x, int y, int width, int height, const wrect_t *prc );
	void	(*pfnPIC_DrawAdditive)( int x, int y, int width, int height, const wrect_t *prc );
	void	(*pfnPIC_EnableScissor)( int x, int y, int width, int height );
	void	(*pfnPIC_DisableScissor)( void );

	// screen handlers
	void	(*pfnFillRGBA)( int x, int y, int width, int height, int r, int g, int b, int a );

	// cvar handlers
	cvar_t*	(*pfnRegisterVariable)( const char *szName, const char *szValue, int flags );
	float	(*pfnGetCvarFloat)( const char *szName );
	char*	(*pfnGetCvarString)( const char *szName );
	void	(*pfnCvarSetString)( const char *szName, const char *szValue );
	void	(*pfnCvarSetValue)( const char *szName, float flValue );

	// command handlers
	int	(*pfnAddCommand)( const char *cmd_name, void (*function)(void) );
	void	(*pfnClientCmd)( int execute_now, const char *szCmdString );
	void	(*pfnDelCommand)( const char *cmd_name );
	int       (*pfnCmdArgc)( void );	
	char*	(*pfnCmdArgv)( int argc );
	char*	(*pfnCmd_Args)( void );

	// debug messages (in-menu shows only notify)	
	void	(*Con_Printf)( const char *fmt, ... );
	void	(*Con_DPrintf)( const char *fmt, ... );
	void	(*Con_NPrintf)( int pos, const char *fmt, ... );
	void	(*Con_NXPrintf)( struct con_nprint_s *info, const char *fmt, ... );

	// sound handlers
	void	(*pfnPlayLocalSound)( const char *szSound );

	// cinematic handlers
	void	(*pfnDrawLogo)( const char *filename, float x, float y, float width, float height );
	int	(*pfnGetLogoWidth)( void );
	int	(*pfnGetLogoHeight)( void );
	float	(*pfnGetLogoLength)( void );	// cinematic duration in seconds

	// text message system
	void	(*pfnDrawCharacter)( int x, int y, int width, int height, int ch, int ulRGBA, HIMAGE hFont );
	int	(*pfnDrawConsoleString)( int x, int y, const char *string );
	void	(*pfnDrawSetTextColor)( int r, int g, int b, int alpha );
	void	(*pfnDrawConsoleStringLen)(  const char *string, int *length, int *height );
	void	(*pfnSetConsoleDefaultColor)( int r, int g, int b ); // color must came from colors.lst

	// custom rendering (for playermodel preview)
	struct cl_entity_s* (*pfnGetPlayerModel)( void );	// for drawing playermodel previews
	void	(*pfnSetModel)( struct cl_entity_s *ed, const char *path );
	void	(*pfnClearScene)( void );
	void	(*pfnRenderScene)( const struct ref_params_s *fd );
	int	(*CL_CreateVisibleEntity)( int type, struct cl_entity_s *ent );

	// misc handlers
	void	(*pfnHostError)( const char *szFmt, ... );
	int	(*pfnFileExists)( const char *filename, int gamedironly );
	void	(*pfnGetGameDir)( char *szGetGameDir );

	// gameinfo handlers
	int	(*pfnCreateMapsList)( int fRefresh );
	int	(*pfnClientInGame)( void );
	void	(*pfnClientJoin)( const struct netadr_s adr );
	
	// parse txt files
	byte*	(*COM_LoadFile)( const char *filename, int *pLength );
	char*	(*COM_ParseFile)( char *data, char *token );
	void	(*COM_FreeFile)( void *buffer );

	// keyfuncs
	void	(*pfnKeyClearStates)( void );				// call when menu open or close
	void	(*pfnSetKeyDest)( int dest );
	const char *(*pfnKeynumToString)( int keynum );
	const char *(*pfnKeyGetBinding)( int keynum );
	void	(*pfnKeySetBinding)( int keynum, const char *binding );
	int	(*pfnKeyIsDown)( int keynum );
	int	(*pfnKeyGetOverstrikeMode)( void );
	void	(*pfnKeySetOverstrikeMode)( int fActive );
	void	*(*pfnKeyGetState)( const char *name );			// for mlook, klook etc

	// engine memory manager
	void*	(*pfnMemAlloc)( size_t cb, const char *filename, const int fileline );
	void	(*pfnMemFree)( void *mem, const char *filename, const int fileline );

	// collect info from engine
	int	(*pfnGetGameInfo)( GAMEINFO *pgameinfo );
	GAMEINFO	**(*pfnGetGamesList)( int *numGames );			// collect info about all mods
	char 	**(*pfnGetFilesList)( const char *pattern, int *numFiles, int gamedironly );	// find in files
	int 	(*pfnGetSaveComment)( const char *savename, char *comment );
	int	(*pfnGetDemoComment)( const char *demoname, char *comment );
	int	(*pfnCheckGameDll)( void );				// returns false if hl.dll is missed or invalid
	char	*(*pfnGetClipboardData)( void );

	// engine launcher
	void	(*pfnShellExecute)( const char *name, const char *args, int closeEngine );
	void	(*pfnWriteServerConfig)( const char *name );
	void	(*pfnChangeInstance)( const char *newInstance, const char *szFinalMessage );
	void	(*pfnPlayBackgroundTrack)( const char *introName, const char *loopName );
	void	(*pfnHostEndGame)( const char *szFinalMessage );

	// menu interface is freezed at version 0.75
	// new functions starts here 
	float	(*pfnRandomFloat)( float flLow, float flHigh );	
	long	(*pfnRandomLong)( long lLow, long lHigh );

	void	(*pfnSetCursor)( void *hCursor );			// change cursor
	int	(*pfnIsMapValid)( char *filename );
	void	(*pfnProcessImage)( int texnum, float gamma, int topColor, int bottomColor );
	int	(*pfnCompareFileTime)( char *filename1, char *filename2, int *iCompare );
} ui_enginefuncs_t;

typedef struct ui_textfuncs_s {
	void (*pfnEnableTextInput)( int enable );
	int (*pfnUtfProcessChar) ( int ch );
	int (*pfnUtfMoveLeft) ( char *str, int pos );
	int (*pfnUtfMoveRight) ( char *str, int pos, int length );
} ui_textfuncs_t;

typedef struct
{
	int	(*pfnVidInit)( void );
	void	(*pfnInit)( void );
	void	(*pfnShutdown)( void );
	void	(*pfnRedraw)( float flTime );
	void	(*pfnKeyEvent)( int key, int down );
	void	(*pfnMouseMove)( int x, int y );
	void	(*pfnSetActiveMenu)( int active );
	void	(*pfnAddServerToList)( struct netadr_s adr, const char *info );
	void	(*pfnGetCursorPos)( int *pos_x, int *pos_y );
	void	(*pfnSetCursorPos)( int pos_x, int pos_y );
	void	(*pfnShowCursor)( int show );
	void	(*pfnCharEvent)( int key );
	int	(*pfnMouseInRect)( void );	// mouse entering\leave game window
	int	(*pfnIsVisible)( void );
	int	(*pfnCreditsActive)( void );	// unused
	void	(*pfnFinalCredits)( void );	// show credits + game end
} UI_FUNCTIONS;

typedef int (*MENUAPI)( UI_FUNCTIONS *pFunctionTable, ui_enginefuncs_t* engfuncs, ui_globalvars_t *pGlobals );

typedef int (*UITEXTAPI)( ui_textfuncs_t* engfuncs );
#endif//MENU_INT_H

```

`engine/mobility_int.h`:

```h
/*
mobility_int.h - interface between engine and client for mobile platforms
Copyright (C) 2015 a1batross

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#pragma once
#ifndef MOBILITY_INT_H
#define MOBILITY_INT_H
#ifdef __cplusplus
extern "C" {
#endif

#define MOBILITY_API_VERSION 2
#define MOBILITY_CLIENT_EXPORT "HUD_MobilityInterface"

#define VIBRATE_NORMAL (1U << 0) // just vibrate for given "life"

#define TOUCH_FL_HIDE			(1U << 0)
#define TOUCH_FL_NOEDIT			(1U << 1)
#define TOUCH_FL_CLIENT			(1U << 2)
#define TOUCH_FL_MP				(1U << 3)
#define TOUCH_FL_SP				(1U << 4)
#define TOUCH_FL_DEF_SHOW		(1U << 5)
#define TOUCH_FL_DEF_HIDE		(1U << 6)
#define TOUCH_FL_DRAW_ADDITIVE	(1U << 7)
#define TOUCH_FL_STROKE			(1U << 8)
#define TOUCH_FL_PRECISION		(1U << 9)

typedef struct mobile_engfuncs_s
{
	// indicates version of API. Should be equal to MOBILITY_API_VERSION
	// version changes when existing functions are changes
	int version;

	// vibration control
	// life -- time to vibrate in ms
	void (*pfnVibrate)( float life, char flags );

	// enable text input
	void (*pfnEnableTextInput)( int enable );

	// add temporaty button, edit will be disabled
	void (*pfnTouchAddClientButton)( const char *name, const char *texture, const char *command, float x1, float y1, float x2, float y2, unsigned char *color, int round, float aspect, int flags );

	// add button to defaults list. Will be loaded on config generation
	void (*pfnTouchAddDefaultButton)( const char *name, const char *texturefile, const char *command, float x1, float y1, float x2, float y2, unsigned char *color, int round, float aspect, int flags );

	// hide/show buttons by pattern
	void (*pfnTouchHideButtons)( const char *name, unsigned char hide );

	// remove button with given name
	void (*pfnTouchRemoveButton)( const char *name );

	// when enabled, only client buttons shown
	void (*pfnTouchSetClientOnly)( unsigned char state );

	// Clean defaults list
	void (*pfnTouchResetDefaultButtons)();

	// Draw scaled font for client
	int (*pfnDrawScaledCharacter)( int x, int y, int number, int r, int g, int b, float scale );

	// To be continued...
} mobile_engfuncs_t;

// function exported from client
// returns 0 on no error otherwise error
typedef int (*pfnMobilityInterface)( mobile_engfuncs_t *gMobileEngfuncs );

#ifdef __cplusplus
}
#endif
#endif

```

`engine/progdefs.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PROGDEFS_H
#define PROGDEFS_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif

typedef struct
{	
	float		time;
	float		frametime;
	float		force_retouch;
	string_t	mapname;
	string_t	startspot;
	float		deathmatch;
	float		coop;
	float		teamplay;
	float		serverflags;
	float		found_secrets;
	vec3_t		v_forward;
	vec3_t		v_up;
	vec3_t		v_right;
	float		trace_allsolid;
	float		trace_startsolid;
	float		trace_fraction;
	vec3_t		trace_endpos;
	vec3_t		trace_plane_normal;
	float		trace_plane_dist;
	edict_t		*trace_ent;
	float		trace_inopen;
	float		trace_inwater;
	int			trace_hitgroup;
	int			trace_flags;
	int			msg_entity;
	int			cdAudioTrack;
	int			maxClients;
	int			maxEntities;
	const char	*pStringBase;

	void		*pSaveData;
	vec3_t		vecLandmarkOffset;
} globalvars_t;


typedef struct entvars_s
{
	string_t	classname;
	string_t	globalname;

	vec3_t		origin;
	vec3_t		oldorigin;
	vec3_t		velocity;
	vec3_t		basevelocity;
	vec3_t      clbasevelocity;  // Base velocity that was passed in to server physics so 
							     //  client can predict conveyors correctly.  Server zeroes it, so we need to store here, too.
	vec3_t		movedir;

	vec3_t		angles;			// Model angles
	vec3_t		avelocity;		// angle velocity (degrees per second)
	vec3_t		punchangle;		// auto-decaying view angle adjustment
	vec3_t		v_angle;		// Viewing angle (player only)

	// For parametric entities
	vec3_t		endpos;
	vec3_t		startpos;
	float		impacttime;
	float		starttime;

	int			fixangle;		// 0:nothing, 1:force view angles, 2:add avelocity
	float		idealpitch;
	float		pitch_speed;
	float		ideal_yaw;
	float		yaw_speed;

	int			modelindex;
	string_t	model;

	int			viewmodel;		// player's viewmodel
	int			weaponmodel;	// what other players see
	
	vec3_t		absmin;		// BB max translated to world coord
	vec3_t		absmax;		// BB max translated to world coord
	vec3_t		mins;		// local BB min
	vec3_t		maxs;		// local BB max
	vec3_t		size;		// maxs - mins

	float		ltime;
	float		nextthink;

	int			movetype;
	int			solid;

	int			skin;			
	int			body;			// sub-model selection for studiomodels
	int 		effects;
	
	float		gravity;		// % of "normal" gravity
	float		friction;		// inverse elasticity of MOVETYPE_BOUNCE
	
	int			light_level;

	int			sequence;		// animation sequence
	int			gaitsequence;	// movement animation sequence for player (0 for none)
	float		frame;			// % playback position in animation sequences (0..255)
	float		animtime;		// world time when frame was set
	float		framerate;		// animation playback rate (-8x to 8x)
	byte		controller[4];	// bone controller setting (0..255)
	byte		blending[2];	// blending amount between sub-sequences (0..255)

	float		scale;			// sprite rendering scale (0..255)

	int			rendermode;
	float		renderamt;
	vec3_t		rendercolor;
	int			renderfx;

	float		health;
	float		frags;
	int			weapons;  // bit mask for available weapons
	float		takedamage;

	int			deadflag;
	vec3_t		view_ofs;	// eye position

	int			button;
	int			impulse;

	edict_t		*chain;			// Entity pointer when linked into a linked list
	edict_t		*dmg_inflictor;
	edict_t		*enemy;
	edict_t		*aiment;		// entity pointer when MOVETYPE_FOLLOW
	edict_t		*owner;
	edict_t		*groundentity;

	int			spawnflags;
	int			flags;
	
	int			colormap;		// lowbyte topcolor, highbyte bottomcolor
	int			team;

	float		max_health;
	float		teleport_time;
	float		armortype;
	float		armorvalue;
	int			waterlevel;
	int			watertype;
	
	string_t	target;
	string_t	targetname;
	string_t	netname;
	string_t	message;

	float		dmg_take;
	float		dmg_save;
	float		dmg;
	float		dmgtime;
	
	string_t	noise;
	string_t	noise1;
	string_t	noise2;
	string_t	noise3;
	
	float		speed;
	float		air_finished;
	float		pain_finished;
	float		radsuit_finished;
	
	edict_t		*pContainingEntity;

	int			playerclass;
	float		maxspeed;

	float		fov;
	int			weaponanim;

	int			pushmsec;

	int			bInDuck;
	int			flTimeStepSound;
	int			flSwimTime;
	int			flDuckTime;
	int			iStepLeft;
	float		flFallVelocity;

	int			gamestate;

	int			oldbuttons;

	int			groupinfo;

	// For mods
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
	edict_t		*euser1;
	edict_t		*euser2;
	edict_t		*euser3;
	edict_t		*euser4;
} entvars_t;


#endif // PROGDEFS_H

```

`engine/progs.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PROGS_H
#define PROGS_H

#include "progdefs.h"

// 16 simultaneous events, max
#define MAX_EVENT_QUEUE 64

#define DEFAULT_EVENT_RESENDS 1

#include "event_flags.h"

typedef struct event_info_s event_info_t;

#include "event_args.h"

struct event_info_s
{
	unsigned short index;			  // 0 implies not in use

	short packet_index;      // Use data from state info for entity in delta_packet .  -1 implies separate info based on event
	                         // parameter signature
	short entity_index;      // The edict this event is associated with

	float fire_time;        // if non-zero, the time when the event should be fired ( fixed up on the client )
	
	event_args_t args;

// CLIENT ONLY	
	int	  flags;			// Reliable or not, etc.

};

typedef struct event_state_s event_state_t;

struct event_state_s
{
	struct event_info_s ei[ MAX_EVENT_QUEUE ];
};

#if !defined( ENTITY_STATEH )
#include "entity_state.h"
#endif

#if !defined( EDICT_H )
#include "edict.h"
#endif

#define	STRUCT_FROM_LINK(l,t,m) ((t *)((byte *)l - (int)&(((t *)0)->m)))
#define	EDICT_FROM_AREA(l) STRUCT_FROM_LINK(l,edict_t,area)

//============================================================================

extern	char			*pr_strings;
extern	globalvars_t	gGlobalVariables;

//============================================================================

edict_t		*ED_Alloc (void);
void		ED_Free (edict_t *ed);
void		ED_LoadFromFile (char *data);

edict_t		*EDICT_NUM(int n);
int			NUM_FOR_EDICT(const edict_t *e);

#define PROG_TO_EDICT(e) ((edict_t *)((byte *)sv.edicts + e))

#endif // PROGS_H

```

`engine/shake.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef SHAKE_H
#define SHAKE_H

// Screen / View effects

// screen shake
extern int gmsgShake;

// This structure is sent over the net to describe a screen shake event
typedef struct
{
	unsigned short	amplitude;		// FIXED 4.12 amount of shake
	unsigned short 	duration;		// FIXED 4.12 seconds duration
	unsigned short	frequency;		// FIXED 8.8 noise frequency (low frequency is a jerk,high frequency is a rumble)
} ScreenShake;

extern void V_ApplyShake( float *origin, float *angles, float factor );
extern void V_CalcShake( void );
extern int V_ScreenShake( const char *pszName, int iSize, void *pbuf );
extern int V_ScreenFade( const char *pszName, int iSize, void *pbuf );


// Fade in/out
extern int gmsgFade;

#define FFADE_IN			0x0000		// Just here so we don't pass 0 into the function
#define FFADE_OUT			0x0001		// Fade out (not in)
#define FFADE_MODULATE		0x0002		// Modulate (don't blend)
#define FFADE_STAYOUT		0x0004		// ignores the duration, stays faded out until new ScreenFade message received

// This structure is sent over the net to describe a screen fade event
typedef struct
{
	unsigned short 	duration;		// FIXED 4.12 seconds duration
	unsigned short 	holdTime;		// FIXED 4.12 seconds duration until reset (fade & hold)
	short			fadeFlags;		// flags
	byte			r, g, b, a;		// fade to color ( max alpha )
} ScreenFade;

#endif		// SHAKE_H


```

`engine/studio.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/




#ifndef _STUDIO_H_
#define _STUDIO_H_

/*
==============================================================================

STUDIO MODELS

Studio models are position independent, so the cache manager can move them.
==============================================================================
*/


#define MAXSTUDIOTRIANGLES	20000	// TODO: tune this
#define MAXSTUDIOVERTS		2048	// TODO: tune this
#define MAXSTUDIOSEQUENCES	256		// total animation sequences
#define MAXSTUDIOSKINS		100		// total textures
#define MAXSTUDIOSRCBONES	512		// bones allowed at source movement
#define MAXSTUDIOBONES		128		// total bones actually used
#define MAXSTUDIOMODELS		32		// sub-models per model
#define MAXSTUDIOBODYPARTS	32
#define MAXSTUDIOGROUPS		16
#define MAXSTUDIOANIMATIONS	512		// per sequence
#define MAXSTUDIOMESHES		256
#define MAXSTUDIOEVENTS		1024
#define MAXSTUDIOPIVOTS		256
#define MAXSTUDIOCONTROLLERS 8

typedef struct 
{
	int					id;
	int					version;

	char				name[64];
	int					length;

	vec3_t				eyeposition;	// ideal eye position
	vec3_t				min;			// ideal movement hull size
	vec3_t				max;			

	vec3_t				bbmin;			// clipping bounding box
	vec3_t				bbmax;		

	int					flags;

	int					numbones;			// bones
	int					boneindex;

	int					numbonecontrollers;		// bone controllers
	int					bonecontrollerindex;

	int					numhitboxes;			// complex bounding boxes
	int					hitboxindex;			
	
	int					numseq;				// animation sequences
	int					seqindex;

	int					numseqgroups;		// demand loaded sequences
	int					seqgroupindex;

	int					numtextures;		// raw textures
	int					textureindex;
	int					texturedataindex;

	int					numskinref;			// replaceable textures
	int					numskinfamilies;
	int					skinindex;

	int					numbodyparts;		
	int					bodypartindex;

	int					numattachments;		// queryable attachable points
	int					attachmentindex;

	int					soundtable;
	int					soundindex;
	int					soundgroups;
	int					soundgroupindex;

	int					numtransitions;		// animation node to animation node transition graph
	int					transitionindex;
} studiohdr_t;

// header for demand loaded sequence group data
typedef struct 
{
	int					id;
	int					version;

	char				name[64];
	int					length;
} studioseqhdr_t;

// bones
typedef struct 
{
	char				name[32];	// bone name for symbolic links
	int		 			parent;		// parent bone
	int					flags;		// ??
	int					bonecontroller[6];	// bone controller index, -1 == none
	float				value[6];	// default DoF values
	float				scale[6];   // scale for delta DoF values
} mstudiobone_t;


// bone controllers
typedef struct 
{
	int					bone;	// -1 == 0
	int					type;	// X, Y, Z, XR, YR, ZR, M
	float				start;
	float				end;
	int					rest;	// byte index value at rest
	int					index;	// 0-3 user set controller, 4 mouth
} mstudiobonecontroller_t;

// intersection boxes
typedef struct
{
	int					bone;
	int					group;			// intersection group
	vec3_t				bbmin;		// bounding box
	vec3_t				bbmax;		
} mstudiobbox_t;

#if !defined( CACHE_USER ) && !defined( QUAKEDEF_H )
#define CACHE_USER
typedef struct cache_user_s
{
	void *data;
} cache_user_t;
#endif

// demand loaded sequence groups
typedef struct
{
	char				label[32];	// textual name
	char				name[64];	// file name
	cache_user_t		cache;		// cache index pointer
	int					data;		// hack for group 0
} mstudioseqgroup_t;

// sequence descriptions
typedef struct
{
	char				label[32];	// sequence label

	float				fps;		// frames per second	
	int					flags;		// looping/non-looping flags

	int					activity;
	int					actweight;

	int					numevents;
	int					eventindex;

	int					numframes;	// number of frames per sequence

	int					numpivots;	// number of foot pivots
	int					pivotindex;

	int					motiontype;	
	int					motionbone;
	vec3_t				linearmovement;
	int					automoveposindex;
	int					automoveangleindex;

	vec3_t				bbmin;		// per sequence bounding box
	vec3_t				bbmax;		

	int					numblends;
	int					animindex;		// mstudioanim_t pointer relative to start of sequence group data
										// [blend][bone][X, Y, Z, XR, YR, ZR]

	int					blendtype[2];	// X, Y, Z, XR, YR, ZR
	float				blendstart[2];	// starting value
	float				blendend[2];	// ending value
	int					blendparent;

	int					seqgroup;		// sequence group for demand loading

	int					entrynode;		// transition node at entry
	int					exitnode;		// transition node at exit
	int					nodeflags;		// transition rules
	
	int					nextseq;		// auto advancing sequences
} mstudioseqdesc_t;

// events
#include "studio_event.h"
/*
typedef struct 
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;
*/

// pivots
typedef struct 
{
	vec3_t				org;	// pivot point
	int					start;
	int					end;
} mstudiopivot_t;

// attachment
typedef struct 
{
	char				name[32];
	int					type;
	int					bone;
	vec3_t				org;	// attachment point
	vec3_t				vectors[3];
} mstudioattachment_t;

typedef struct
{
	unsigned short	offset[6];
} mstudioanim_t;

// animation frames
typedef union 
{
	struct {
		byte	valid;
		byte	total;
	} num;
	short		value;
} mstudioanimvalue_t;



// body part index
typedef struct
{
	char				name[64];
	int					nummodels;
	int					base;
	int					modelindex; // index into models array
} mstudiobodyparts_t;



// skin info
typedef struct
{
	char					name[64];
	int						flags;
	int						width;
	int						height;
	int						index;
} mstudiotexture_t;


// skin families
// short	index[skinfamilies][skinref]

// studio models
typedef struct
{
	char				name[64];

	int					type;

	float				boundingradius;

	int					nummesh;
	int					meshindex;

	int					numverts;		// number of unique vertices
	int					vertinfoindex;	// vertex bone info
	int					vertindex;		// vertex vec3_t
	int					numnorms;		// number of unique surface normals
	int					norminfoindex;	// normal bone info
	int					normindex;		// normal vec3_t

	int					numgroups;		// deformation groups
	int					groupindex;
} mstudiomodel_t;


// vec3_t	boundingbox[model][bone][2];	// complex intersection info


// meshes
typedef struct 
{
	int					numtris;
	int					triindex;
	int					skinref;
	int					numnorms;		// per mesh normals
	int					normindex;		// normal vec3_t
} mstudiomesh_t;

// triangles
#if 0
typedef struct 
{
	short				vertindex;		// index into vertex array
	short				normindex;		// index into normal array
	short				s,t;			// s,t position on skin
} mstudiotrivert_t;
#endif

// lighting options
#define STUDIO_NF_FLATSHADE		0x0001
#define STUDIO_NF_CHROME		0x0002
#define STUDIO_NF_FULLBRIGHT	0x0004

// motion flags
#define STUDIO_X		0x0001
#define STUDIO_Y		0x0002	
#define STUDIO_Z		0x0004
#define STUDIO_XR		0x0008
#define STUDIO_YR		0x0010
#define STUDIO_ZR		0x0020
#define STUDIO_LX		0x0040
#define STUDIO_LY		0x0080
#define STUDIO_LZ		0x0100
#define STUDIO_AX		0x0200
#define STUDIO_AY		0x0400
#define STUDIO_AZ		0x0800
#define STUDIO_AXR		0x1000
#define STUDIO_AYR		0x2000
#define STUDIO_AZR		0x4000
#define STUDIO_TYPES	0x7FFF
#define STUDIO_RLOOP	0x8000	// controller that wraps shortest distance

// sequence flags
#define STUDIO_LOOPING	0x0001

// bone flags
#define STUDIO_HAS_NORMALS	0x0001
#define STUDIO_HAS_VERTICES 0x0002
#define STUDIO_HAS_BBOX		0x0004
#define STUDIO_HAS_CHROME	0x0008	// if any of the textures have chrome on them

#define RAD_TO_STUDIO		(32768.0/M_PI)
#define STUDIO_TO_RAD		(M_PI/32768.0)

#endif

```

`game_shared/bitvec.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef BITVEC_H
#define BITVEC_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif


#include <assert.h>


class CBitVecAccessor
{
public:
				CBitVecAccessor(unsigned long *pDWords, int iBit);

	void		operator=(int val);
				operator unsigned long();

private:
	unsigned long	*m_pDWords;
	int				m_iBit;
};
	

// CBitVec allows you to store a list of bits and do operations on them like they were 
// an atomic type.
template<int NUM_BITS>
class CBitVec
{
public:
	
					CBitVec();

	// Set all values to the specified value (0 or 1..)
	void			Init(int val = 0);

	// Access the bits like an array.
	CBitVecAccessor	operator[](int i);

	// Operations on other bit vectors.
	CBitVec&		operator=(CBitVec<NUM_BITS> const &other);
	bool			operator==(CBitVec<NUM_BITS> const &other);
	bool			operator!=(CBitVec<NUM_BITS> const &other);

	// Get underlying dword representations of the bits.
	int				GetNumDWords();
	unsigned long	GetDWord(int i);
	void			SetDWord(int i, unsigned long val);

	int				GetNumBits();

private:

	enum {NUM_DWORDS = NUM_BITS/32 + !!(NUM_BITS & 31)};
	unsigned long	m_DWords[NUM_DWORDS];
};



// ------------------------------------------------------------------------ //
// CBitVecAccessor inlines.
// ------------------------------------------------------------------------ //

inline CBitVecAccessor::CBitVecAccessor(unsigned long *pDWords, int iBit)
{
	m_pDWords = pDWords;
	m_iBit = iBit;
}


inline void CBitVecAccessor::operator=(int val)
{
	if(val)
		m_pDWords[m_iBit >> 5] |= (1 << (m_iBit & 31));
	else
		m_pDWords[m_iBit >> 5] &= ~(unsigned long)(1 << (m_iBit & 31));
}

inline CBitVecAccessor::operator unsigned long()
{
	return m_pDWords[m_iBit >> 5] & (1 << (m_iBit & 31));
}



// ------------------------------------------------------------------------ //
// CBitVec inlines.
// ------------------------------------------------------------------------ //

template<int NUM_BITS>
inline int CBitVec<NUM_BITS>::GetNumBits()
{
	return NUM_BITS;
}


template<int NUM_BITS>
inline CBitVec<NUM_BITS>::CBitVec()
{
	for(int i=0; i < NUM_DWORDS; i++)
		m_DWords[i] = 0;
}


template<int NUM_BITS>
inline void CBitVec<NUM_BITS>::Init(int val)
{
	for(int i=0; i < GetNumBits(); i++)
	{
		(*this)[i] = val;
	}
}


template<int NUM_BITS>
inline CBitVec<NUM_BITS>& CBitVec<NUM_BITS>::operator=(CBitVec<NUM_BITS> const &other)
{
	memcpy(m_DWords, other.m_DWords, sizeof(m_DWords));
	return *this;
}


template<int NUM_BITS>
inline CBitVecAccessor CBitVec<NUM_BITS>::operator[](int i)	
{
	assert(i >= 0 && i < GetNumBits());
	return CBitVecAccessor(m_DWords, i);
}


template<int NUM_BITS>
inline bool CBitVec<NUM_BITS>::operator==(CBitVec<NUM_BITS> const &other)
{
	for(int i=0; i < NUM_DWORDS; i++)
		if(m_DWords[i] != other.m_DWords[i])
			return false;

	return true;
}


template<int NUM_BITS>
inline bool CBitVec<NUM_BITS>::operator!=(CBitVec<NUM_BITS> const &other)
{
	return !(*this == other);
}


template<int NUM_BITS>
inline int CBitVec<NUM_BITS>::GetNumDWords()
{
	return NUM_DWORDS;
}

template<int NUM_BITS>
inline unsigned long CBitVec<NUM_BITS>::GetDWord(int i)
{
	assert(i >= 0 && i < NUM_DWORDS);
	return m_DWords[i];
}


template<int NUM_BITS>
inline void CBitVec<NUM_BITS>::SetDWord(int i, unsigned long val)
{
	assert(i >= 0 && i < NUM_DWORDS);
	m_DWords[i] = val;
}


#endif // BITVEC_H


```

`game_shared/voice_banmgr.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include <string.h>
#include <stdio.h>
#include "voice_banmgr.h"


#define BANMGR_FILEVERSION	1
char const *g_pBanMgrFilename = "voice_ban.dt";



// Hash a player ID to a byte.
unsigned char HashPlayerID(char const playerID[16])
{
	unsigned char curHash = 0;

	for(int i=0; i < 16; i++)
		curHash += (unsigned char)playerID[i];

	return curHash;
}



CVoiceBanMgr::CVoiceBanMgr()
{
	Clear();
}


CVoiceBanMgr::~CVoiceBanMgr()
{
	Term();
}


bool CVoiceBanMgr::Init(char const *pGameDir)
{
	Term();

	char filename[512];
	_snprintf(filename, sizeof(filename), "%s/%s", pGameDir, g_pBanMgrFilename);

	// Load in the squelch file.
	FILE *fp = fopen(filename, "rb");
	if(fp)
	{
		int version;
		fread(&version, 1, sizeof(version), fp);
		if(version == BANMGR_FILEVERSION)
		{
			fseek(fp, 0, SEEK_END);
			int nIDs = (ftell(fp) - sizeof(version)) / 16;
			fseek(fp, sizeof(version), SEEK_SET);

			for(int i=0; i < nIDs; i++)
			{
				char playerID[16];
				fread(playerID, 1, 16, fp);
				AddBannedPlayer(playerID);
			}			
		}

		fclose(fp);
	}

	return true;
}


void CVoiceBanMgr::Term()
{
	// Free all the player structures.
	for(int i=0; i < 256; i++)
	{
		BannedPlayer *pListHead = &m_PlayerHash[i];
		BannedPlayer *pNext;
		for(BannedPlayer *pCur=pListHead->m_pNext; pCur != pListHead; pCur=pNext)
		{
			pNext = pCur->m_pNext;
			delete pCur;
		}
	}

	Clear();
}


void CVoiceBanMgr::SaveState(char const *pGameDir)
{
	// Save the file out.
	char filename[512];
	_snprintf(filename, sizeof(filename), "%s/%s", pGameDir, g_pBanMgrFilename);

	FILE *fp = fopen(filename, "wb");
	if(fp)
	{
		int version = BANMGR_FILEVERSION;
		fwrite(&version, 1, sizeof(version), fp);

		for(int i=0; i < 256; i++)
		{
			BannedPlayer *pListHead = &m_PlayerHash[i];
			for(BannedPlayer *pCur=pListHead->m_pNext; pCur != pListHead; pCur=pCur->m_pNext)
			{
				fwrite(pCur->m_PlayerID, 1, 16, fp);
			}
		}

		fclose(fp);
	}
}


bool CVoiceBanMgr::GetPlayerBan(char const playerID[16])
{
	return !!InternalFindPlayerSquelch(playerID);
}


void CVoiceBanMgr::SetPlayerBan(char const playerID[16], bool bSquelch)
{
	if(bSquelch)
	{
		// Is this guy already squelched?
		if(GetPlayerBan(playerID))
			return;
	
		AddBannedPlayer(playerID);
	}
	else
	{
		BannedPlayer *pPlayer = InternalFindPlayerSquelch(playerID);
		if(pPlayer)
		{
			pPlayer->m_pPrev->m_pNext = pPlayer->m_pNext;
			pPlayer->m_pNext->m_pPrev = pPlayer->m_pPrev;
			delete pPlayer;
		}
	}
}


void CVoiceBanMgr::ForEachBannedPlayer(void (*callback)(char id[16]))
{
	for(int i=0; i < 256; i++)
	{
		for(BannedPlayer *pCur=m_PlayerHash[i].m_pNext; pCur != &m_PlayerHash[i]; pCur=pCur->m_pNext)
		{
			callback(pCur->m_PlayerID);
		}
	}
}


void CVoiceBanMgr::Clear()
{
	// Tie off the hash table entries.
	for(int i=0; i < 256; i++)
		m_PlayerHash[i].m_pNext = m_PlayerHash[i].m_pPrev = &m_PlayerHash[i];
}


CVoiceBanMgr::BannedPlayer* CVoiceBanMgr::InternalFindPlayerSquelch(char const playerID[16])
{
	int index = HashPlayerID(playerID);
	BannedPlayer *pListHead = &m_PlayerHash[index];
	for(BannedPlayer *pCur=pListHead->m_pNext; pCur != pListHead; pCur=pCur->m_pNext)
	{
		if(memcmp(playerID, pCur->m_PlayerID, 16) == 0)
			return pCur;
	}

	return NULL;
}


CVoiceBanMgr::BannedPlayer* CVoiceBanMgr::AddBannedPlayer(char const playerID[16])
{
	BannedPlayer *pNew = new BannedPlayer;
	if(!pNew)
		return NULL;

	int index = HashPlayerID(playerID);
	memcpy(pNew->m_PlayerID, playerID, 16);
	pNew->m_pNext = &m_PlayerHash[index];
	pNew->m_pPrev = m_PlayerHash[index].m_pPrev;
	pNew->m_pPrev->m_pNext = pNew->m_pNext->m_pPrev = pNew;
	return pNew;
}


```

`game_shared/voice_banmgr.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VOICE_BANMGR_H
#define VOICE_BANMGR_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif


// This class manages the (persistent) list of squelched players.
class CVoiceBanMgr
{
public:

				CVoiceBanMgr();
				~CVoiceBanMgr();	

	// Init loads the list of squelched players from disk.
	bool		Init(char const *pGameDir);
	void		Term();

	// Saves the state into voice_squelch.dt.
	void		SaveState(char const *pGameDir);

	bool		GetPlayerBan(char const playerID[16]);
	void		SetPlayerBan(char const playerID[16], bool bSquelch);

	// Call your callback for each banned player.
	void		ForEachBannedPlayer(void (*callback)(char id[16]));


protected:

	class BannedPlayer
	{
	public:
		char			m_PlayerID[16];
		BannedPlayer	*m_pPrev, *m_pNext;
	};

	void				Clear();
	BannedPlayer*	InternalFindPlayerSquelch(char const playerID[16]);
	BannedPlayer*	AddBannedPlayer(char const playerID[16]);


protected:

	BannedPlayer	m_PlayerHash[256];
};


#endif // VOICE_BANMGR_H

```

`game_shared/voice_common.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VOICE_COMMON_H
#define VOICE_COMMON_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif


#include "bitvec.h"


#define VOICE_MAX_PLAYERS		32	// (todo: this should just be set to MAX_CLIENTS).
#define VOICE_MAX_PLAYERS_DW	((VOICE_MAX_PLAYERS / 32) + !!(VOICE_MAX_PLAYERS & 31))

typedef CBitVec<VOICE_MAX_PLAYERS> CPlayerBitVec;


#endif // VOICE_COMMON_H

```

`game_shared/voice_gamemgr.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#include "voice_gamemgr.h"
#include <string.h>
#include <assert.h>
#include "extdll.h"
#include "util.h"
#include "cbase.h"
#include "player.h"



#define UPDATE_INTERVAL	0.3


// These are stored off as CVoiceGameMgr is created and deleted.
CPlayerBitVec	g_PlayerModEnable;		// Set to 1 for each player if the player wants to use voice in this mod.
										// (If it's zero, then the server reports that the game rules are saying the
										// player can't hear anyone).

CPlayerBitVec	g_BanMasks[VOICE_MAX_PLAYERS];	// Tells which players don't want to hear each other.
												// These are indexed as clients and each bit represents a client
												// (so player entity is bit+1).

CPlayerBitVec	g_SentGameRulesMasks[VOICE_MAX_PLAYERS];	// These store the masks we last sent to each client so we can determine if
CPlayerBitVec	g_SentBanMasks[VOICE_MAX_PLAYERS];			// we need to resend them.
CPlayerBitVec	g_bWantModEnable;

cvar_t voice_serverdebug = {"voice_serverdebug", "0"};

// Set game rules to allow all clients to talk to each other.
// Muted players still can't talk to each other.
cvar_t sv_alltalk = {"sv_alltalk", "0"};

// ------------------------------------------------------------------------ //
// Static helpers.
// ------------------------------------------------------------------------ //

// Find a player with a case-insensitive name search.
static CBasePlayer* FindPlayerByName(const char *pTestName)
{
	for(int i=1; i <= gpGlobals->maxClients; i++)
	{
		edict_t *pEdict = g_engfuncs.pfnPEntityOfEntIndex(i);
		if(pEdict)
		{
			CBaseEntity *pEnt = CBaseEntity::Instance(pEdict);
			if(pEnt && pEnt->IsPlayer())
			{			
				const char *pNetName = STRING(pEnt->pev->netname);
				if(stricmp(pNetName, pTestName) == 0)
				{
					return (CBasePlayer*)pEnt;
				}
			}
		}
	}

	return NULL;
}

static void VoiceServerDebug( char const *pFmt, ... )
{
	char msg[4096];
	va_list marker;

	if( !voice_serverdebug.value )
		return;

	va_start( marker, pFmt );
	_vsnprintf( msg, sizeof(msg), pFmt, marker );
	va_end( marker );

	ALERT( at_console, "%s", msg );
}



// ------------------------------------------------------------------------ //
// CVoiceGameMgr.
// ------------------------------------------------------------------------ //

CVoiceGameMgr::CVoiceGameMgr()
{
	m_UpdateInterval = 0;
	m_nMaxPlayers = 0;
}


CVoiceGameMgr::~CVoiceGameMgr()
{
}


bool CVoiceGameMgr::Init(
	IVoiceGameMgrHelper *pHelper,
	int maxClients)
{		  
	m_pHelper = pHelper;
	m_nMaxPlayers = VOICE_MAX_PLAYERS < maxClients ? VOICE_MAX_PLAYERS : maxClients;
	g_engfuncs.pfnPrecacheModel("sprites/voiceicon.spr");

	m_msgPlayerVoiceMask = REG_USER_MSG( "VoiceMask", VOICE_MAX_PLAYERS_DW*4 * 2 );
	m_msgRequestState = REG_USER_MSG( "ReqState", 0 );
	
	// register voice_serverdebug if it hasn't been registered already
	if ( !CVAR_GET_POINTER( "voice_serverdebug" ) )
		CVAR_REGISTER( &voice_serverdebug );

	if( !CVAR_GET_POINTER( "sv_alltalk" ) )
		CVAR_REGISTER( &sv_alltalk );

	return true;
}


void CVoiceGameMgr::SetHelper(IVoiceGameMgrHelper *pHelper)
{
	m_pHelper = pHelper;
}


void CVoiceGameMgr::Update(double frametime)
{
	// Only update periodically.
	m_UpdateInterval += frametime;
	if(m_UpdateInterval < UPDATE_INTERVAL)
		return;

	UpdateMasks();
}


void CVoiceGameMgr::ClientConnected(edict_t *pEdict)
{
	int index = ENTINDEX(pEdict) - 1;
	
	// Clear out everything we use for deltas on this guy.
	g_bWantModEnable[index] = true;
	g_SentGameRulesMasks[index].Init(0);
	g_SentBanMasks[index].Init(0);
}

// Called to determine if the Receiver has muted (blocked) the Sender
// Returns true if the receiver has blocked the sender
bool CVoiceGameMgr::PlayerHasBlockedPlayer(CBasePlayer *pReceiver, CBasePlayer *pSender)
{
	int iReceiverIndex, iSenderIndex;

	if ( !pReceiver || !pSender )
		return false;

	iReceiverIndex = pReceiver->entindex() - 1;
	iSenderIndex   = pSender->entindex() - 1;

	if ( iReceiverIndex < 0 || iReceiverIndex >= m_nMaxPlayers || iSenderIndex < 0 || iSenderIndex >= m_nMaxPlayers )
		return false;

	return ( g_BanMasks[iReceiverIndex][iSenderIndex] ? true : false );
}

bool CVoiceGameMgr::ClientCommand(CBasePlayer *pPlayer, const char *cmd)
{
	int playerClientIndex = pPlayer->entindex() - 1;
	if(playerClientIndex < 0 || playerClientIndex >= m_nMaxPlayers)
	{
		VoiceServerDebug( "CVoiceGameMgr::ClientCommand: cmd %s from invalid client (%d)\n", cmd, playerClientIndex );
		return true;
	}

	bool bBan = stricmp(cmd, "vban") == 0;
	if(bBan && CMD_ARGC() >= 2)
	{
		for(int i=1; i < CMD_ARGC(); i++)
		{
			unsigned long mask = 0;
			sscanf(CMD_ARGV(i), "%x", &mask);

			if(i <= VOICE_MAX_PLAYERS_DW)
			{
				VoiceServerDebug( "CVoiceGameMgr::ClientCommand: vban (0x%x) from %d\n", mask, playerClientIndex );
				g_BanMasks[playerClientIndex].SetDWord(i-1, mask);
			}
			else
			{
				VoiceServerDebug( "CVoiceGameMgr::ClientCommand: invalid index (%d)\n", i );
			}
		}

		// Force it to update the masks now.
		//UpdateMasks();		
		return true;
	}
	else if(stricmp(cmd, "VModEnable") == 0 && CMD_ARGC() >= 2)
	{
		VoiceServerDebug( "CVoiceGameMgr::ClientCommand: VModEnable (%d)\n", !!atoi(CMD_ARGV(1)) );
		g_PlayerModEnable[playerClientIndex] = !!atoi(CMD_ARGV(1));
		g_bWantModEnable[playerClientIndex] = false;
		//UpdateMasks();		
		return true;
	}
	else
	{
		return false;
	}
}


void CVoiceGameMgr::UpdateMasks()
{
	m_UpdateInterval = 0;

	bool bAllTalk = !!g_engfuncs.pfnCVarGetFloat( "sv_alltalk" );

	for(int iClient=0; iClient < m_nMaxPlayers; iClient++)
	{
		CBaseEntity *pEnt = UTIL_PlayerByIndex(iClient+1);
		if(!pEnt || !pEnt->IsPlayer())
			continue;

		// Request the state of their "VModEnable" cvar.
		if(g_bWantModEnable[iClient])
		{
			MESSAGE_BEGIN(MSG_ONE, m_msgRequestState, NULL, pEnt->pev);
			MESSAGE_END();
		}

		CBasePlayer *pPlayer = (CBasePlayer*)pEnt;

		CPlayerBitVec gameRulesMask;
		if( g_PlayerModEnable[iClient] )
		{
			// Build a mask of who they can hear based on the game rules.
			for(int iOtherClient=0; iOtherClient < m_nMaxPlayers; iOtherClient++)
			{
				CBaseEntity *pEnt = UTIL_PlayerByIndex(iOtherClient+1);
				if(pEnt && pEnt->IsPlayer() && 
					(bAllTalk || m_pHelper->CanPlayerHearPlayer(pPlayer, (CBasePlayer*)pEnt)) )
				{
					gameRulesMask[iOtherClient] = true;
				}
			}
		}

		// If this is different from what the client has, send an update. 
		if(gameRulesMask != g_SentGameRulesMasks[iClient] || 
			g_BanMasks[iClient] != g_SentBanMasks[iClient])
		{
			g_SentGameRulesMasks[iClient] = gameRulesMask;
			g_SentBanMasks[iClient] = g_BanMasks[iClient];

			MESSAGE_BEGIN(MSG_ONE, m_msgPlayerVoiceMask, NULL, pPlayer->pev);
				int dw;
				for(dw=0; dw < VOICE_MAX_PLAYERS_DW; dw++)
				{
					WRITE_LONG(gameRulesMask.GetDWord(dw));
					WRITE_LONG(g_BanMasks[iClient].GetDWord(dw));
				}
			MESSAGE_END();
		}

		// Tell the engine.
		for(int iOtherClient=0; iOtherClient < m_nMaxPlayers; iOtherClient++)
		{
			bool bCanHear = gameRulesMask[iOtherClient] && !g_BanMasks[iClient][iOtherClient];
			g_engfuncs.pfnVoice_SetClientListening(iClient+1, iOtherClient+1, bCanHear);
		}
	}
}

```

`game_shared/voice_gamemgr.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VOICE_GAMEMGR_H
#define VOICE_GAMEMGR_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif


#include "voice_common.h"


class CGameRules;
class CBasePlayer;


class IVoiceGameMgrHelper
{
public:
	virtual				~IVoiceGameMgrHelper() {}

	// Called each frame to determine which players are allowed to hear each other.	This overrides
	// whatever squelch settings players have.
	virtual bool		CanPlayerHearPlayer(CBasePlayer *pListener, CBasePlayer *pTalker) = 0;
};


// CVoiceGameMgr manages which clients can hear which other clients.
class CVoiceGameMgr
{
public:
						CVoiceGameMgr();
	virtual				~CVoiceGameMgr();
	
	bool				Init(
		IVoiceGameMgrHelper *m_pHelper,
		int maxClients
		);

	void				SetHelper(IVoiceGameMgrHelper *pHelper);

	// Updates which players can hear which other players.
	// If gameplay mode is DM, then only players within the PVS can hear each other.
	// If gameplay mode is teamplay, then only players on the same team can hear each other.
	// Player masks are always applied.
	void				Update(double frametime);

	// Called when a new client connects (unsquelches its entity for everyone).
	void				ClientConnected(struct edict_s *pEdict);

	// Called on ClientCommand. Checks for the squelch and unsquelch commands.
	// Returns true if it handled the command.
	bool				ClientCommand(CBasePlayer *pPlayer, const char *cmd);

	// Called to determine if the Receiver has muted (blocked) the Sender
	// Returns true if the receiver has blocked the sender
	bool				PlayerHasBlockedPlayer(CBasePlayer *pReceiver, CBasePlayer *pSender);


private:

	// Force it to update the client masks.
	void				UpdateMasks();


private:
	int					m_msgPlayerVoiceMask;
	int					m_msgRequestState;

	IVoiceGameMgrHelper	*m_pHelper;
	int					m_nMaxPlayers;
	double				m_UpdateInterval;						// How long since the last update.
};


#endif // VOICE_GAMEMGR_H

```

`game_shared/voice_status.cpp`:

```cpp
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// There are hud.h's coming out of the woodwork so this ensures that we get the right one.
#if defined( DMC_BUILD )
	#include "../dmc/cl_dll/hud.h"
	#include "../dmc/cl_dll/cl_util.h"
#elif defined( RICOCHET_BUILD )
	#include "../ricochet/cl_dll/hud.h"
	#include "../ricochet/cl_dll/cl_util.h"
#else
	#include "../cl_dll/hud.h"
	#include "../cl_dll/cl_util.h"
#endif

#include <assert.h>
#include <string.h>
#include <stdio.h>

#if defined( DMC_BUILD )
	#include "../dmc/cl_dll/parsemsg.h"
	#include "../dmc/cl_dll/hud_servers.h"
	#include "../dmc/cl_dll/demo.h"
#elif defined( RICOCHET_BUILD )
	#include "../ricochet/cl_dll/parsemsg.h"
	#include "../ricochet/cl_dll/hud_servers.h"
	#include "../ricochet/cl_dll/demo.h"
#else
	#include "../cl_dll/parsemsg.h"
	#include "../cl_dll/hud_servers.h"
	#include "../cl_dll/demo.h"
#endif

#include "demo_api.h"
#include "voice_status.h"
#include "r_efx.h"
#include "entity_types.h"
#include "VGUI_ActionSignal.h"
#include "VGUI_Scheme.h"
#include "VGUI_TextImage.h"
#include "vgui_loadtga.h"
#include "vgui_helpers.h"
#include "vgui_mousecode.h"



using namespace vgui;


extern int cam_thirdperson;


#define VOICE_MODEL_INTERVAL		0.3
#define SCOREBOARD_BLINK_FREQUENCY	0.3	// How often to blink the scoreboard icons.
#define SQUELCHOSCILLATE_PER_SECOND	2.0f


extern BitmapTGA *LoadTGA( const char* pImageName );



// ---------------------------------------------------------------------- //
// The voice manager for the client.
// ---------------------------------------------------------------------- //
CVoiceStatus g_VoiceStatus;

CVoiceStatus* GetClientVoiceMgr()
{
	return &g_VoiceStatus;
}



// ---------------------------------------------------------------------- //
// CVoiceStatus.
// ---------------------------------------------------------------------- //

static CVoiceStatus *g_pInternalVoiceStatus = NULL;

int __MsgFunc_VoiceMask(const char *pszName, int iSize, void *pbuf)
{
	if(g_pInternalVoiceStatus)
		g_pInternalVoiceStatus->HandleVoiceMaskMsg(iSize, pbuf);

	return 1;
}

int __MsgFunc_ReqState(const char *pszName, int iSize, void *pbuf)
{
	if(g_pInternalVoiceStatus)
		g_pInternalVoiceStatus->HandleReqStateMsg(iSize, pbuf);

	return 1;
}


int g_BannedPlayerPrintCount;
void ForEachBannedPlayer(char id[16])
{
	char str[256];
	sprintf(str, "Ban %d: %2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x\n",
		g_BannedPlayerPrintCount++,
		id[0], id[1], id[2], id[3], 
		id[4], id[5], id[6], id[7], 
		id[8], id[9], id[10], id[11], 
		id[12], id[13], id[14], id[15]
		);
	strupr(str);
	gEngfuncs.pfnConsolePrint(str);
}


void ShowBannedCallback()
{
	if(g_pInternalVoiceStatus)
	{
		g_BannedPlayerPrintCount = 0;
		gEngfuncs.pfnConsolePrint("------- BANNED PLAYERS -------\n");
		g_pInternalVoiceStatus->m_BanMgr.ForEachBannedPlayer(ForEachBannedPlayer);
		gEngfuncs.pfnConsolePrint("------------------------------\n");
	}
}


// ---------------------------------------------------------------------- //
// CVoiceStatus.
// ---------------------------------------------------------------------- //

CVoiceStatus::CVoiceStatus()
{
	m_bBanMgrInitialized = false;
	m_LastUpdateServerState = 0;

	m_pSpeakerLabelIcon = NULL;
	m_pScoreboardNeverSpoken = NULL;
	m_pScoreboardNotSpeaking = NULL;
	m_pScoreboardSpeaking = NULL;
	m_pScoreboardSpeaking2 = NULL;
	m_pScoreboardSquelch = NULL;
	m_pScoreboardBanned = NULL;
	
	m_pLocalBitmap = NULL;
	m_pAckBitmap = NULL;

	m_bTalking = m_bServerAcked = false;

	memset(m_pBanButtons, 0, sizeof(m_pBanButtons));

	m_bServerModEnable = -1;

	m_pchGameDir = NULL;
}


CVoiceStatus::~CVoiceStatus()
{
	g_pInternalVoiceStatus = NULL;
	
	for(int i=0; i < MAX_VOICE_SPEAKERS; i++)
	{
		delete m_Labels[i].m_pLabel;
		m_Labels[i].m_pLabel = NULL;

		delete m_Labels[i].m_pIcon;
		m_Labels[i].m_pIcon = NULL;
		
		delete m_Labels[i].m_pBackground;
		m_Labels[i].m_pBackground = NULL;
	}				

	delete m_pLocalLabel;
	m_pLocalLabel = NULL;

	FreeBitmaps();

	if(m_pchGameDir)
	{
		if(m_bBanMgrInitialized)
		{
			m_BanMgr.SaveState(m_pchGameDir);
		}

		free(m_pchGameDir);
	}
}


int CVoiceStatus::Init(
	IVoiceStatusHelper *pHelper,
	Panel **pParentPanel)
{
	// Setup the voice_modenable cvar.
	gEngfuncs.pfnRegisterVariable("voice_modenable", "1", FCVAR_ARCHIVE);

	gEngfuncs.pfnRegisterVariable("voice_clientdebug", "0", 0);

	gEngfuncs.pfnAddCommand("voice_showbanned", ShowBannedCallback);

	if(gEngfuncs.pfnGetGameDirectory())
	{
		m_BanMgr.Init(gEngfuncs.pfnGetGameDirectory());
		m_bBanMgrInitialized = true;
	}

	assert(!g_pInternalVoiceStatus);
	g_pInternalVoiceStatus = this;

	m_BlinkTimer = 0;
	m_VoiceHeadModel = NULL;
	memset(m_Labels, 0, sizeof(m_Labels));
	
	for(int i=0; i < MAX_VOICE_SPEAKERS; i++)
	{
		CVoiceLabel *pLabel = &m_Labels[i];

		pLabel->m_pBackground = new Label("");

		if(pLabel->m_pLabel = new Label(""))
		{
			pLabel->m_pLabel->setVisible( true );
			pLabel->m_pLabel->setFont( Scheme::sf_primary2 );
			pLabel->m_pLabel->setTextAlignment( Label::a_east );
			pLabel->m_pLabel->setContentAlignment( Label::a_east );
			pLabel->m_pLabel->setParent( pLabel->m_pBackground );
		}

		if( pLabel->m_pIcon = new ImagePanel( NULL ) )
		{
			pLabel->m_pIcon->setVisible( true );
			pLabel->m_pIcon->setParent( pLabel->m_pBackground );
		}

		pLabel->m_clientindex = -1;
	}

	m_pLocalLabel = new ImagePanel(NULL);

	m_bInSquelchMode = false;

	m_pHelper = pHelper;
	m_pParentPanel = pParentPanel;
	gHUD.AddHudElem(this);
	m_iFlags = HUD_ACTIVE;
	HOOK_MESSAGE(VoiceMask);
	HOOK_MESSAGE(ReqState);

	// Cache the game directory for use when we shut down
	const char *pchGameDirT = gEngfuncs.pfnGetGameDirectory();
	m_pchGameDir = (char *)malloc(strlen(pchGameDirT) + 1);
	strcpy(m_pchGameDir, pchGameDirT);

	return 1;
}


int CVoiceStatus::VidInit()
{
	FreeBitmaps();


	if( m_pLocalBitmap = vgui_LoadTGA("gfx/vgui/icntlk_pl.tga") )
	{
		m_pLocalBitmap->setColor(Color(255,255,255,135));
	}

	if( m_pAckBitmap = vgui_LoadTGA("gfx/vgui/icntlk_sv.tga") )
	{
		m_pAckBitmap->setColor(Color(255,255,255,135));	// Give just a tiny bit of translucency so software draws correctly.
	}

	m_pLocalLabel->setImage( m_pLocalBitmap );
	m_pLocalLabel->setVisible( false );


	if( m_pSpeakerLabelIcon = vgui_LoadTGANoInvertAlpha("gfx/vgui/speaker4.tga" ) )
		m_pSpeakerLabelIcon->setColor( Color(255,255,255,1) );		// Give just a tiny bit of translucency so software draws correctly.

	if (m_pScoreboardNeverSpoken = vgui_LoadTGANoInvertAlpha("gfx/vgui/640_speaker1.tga"))
		m_pScoreboardNeverSpoken->setColor(Color(255,255,255,1));	// Give just a tiny bit of translucency so software draws correctly.

	if(m_pScoreboardNotSpeaking = vgui_LoadTGANoInvertAlpha("gfx/vgui/640_speaker2.tga"))
		m_pScoreboardNotSpeaking->setColor(Color(255,255,255,1));	// Give just a tiny bit of translucency so software draws correctly.
	
	if(m_pScoreboardSpeaking = vgui_LoadTGANoInvertAlpha("gfx/vgui/640_speaker3.tga"))
		m_pScoreboardSpeaking->setColor(Color(255,255,255,1));	// Give just a tiny bit of translucency so software draws correctly.
	
	if(m_pScoreboardSpeaking2 = vgui_LoadTGANoInvertAlpha("gfx/vgui/640_speaker4.tga"))
		m_pScoreboardSpeaking2->setColor(Color(255,255,255,1));	// Give just a tiny bit of translucency so software draws correctly.
	
	if(m_pScoreboardSquelch  = vgui_LoadTGA("gfx/vgui/icntlk_squelch.tga"))
		m_pScoreboardSquelch->setColor(Color(255,255,255,1));	// Give just a tiny bit of translucency so software draws correctly.

	if(m_pScoreboardBanned = vgui_LoadTGA("gfx/vgui/640_voiceblocked.tga"))
		m_pScoreboardBanned->setColor(Color(255,255,255,1));	// Give just a tiny bit of translucency so software draws correctly.

	// Figure out the voice head model height.
	m_VoiceHeadModelHeight = 45;
	char *pFile = (char *)gEngfuncs.COM_LoadFile("scripts/voicemodel.txt", 5, NULL);
	if(pFile)
	{
		char token[4096];
		gEngfuncs.COM_ParseFile(pFile, token);
		if(token[0] >= '0' && token[0] <= '9')
		{
			m_VoiceHeadModelHeight = (float)atof(token);
		}

		gEngfuncs.COM_FreeFile(pFile);
	}

	m_VoiceHeadModel = gEngfuncs.pfnSPR_Load("sprites/voiceicon.spr");
	return TRUE;
}


void CVoiceStatus::Frame(double frametime)
{
	// check server banned players once per second
	if(gEngfuncs.GetClientTime() - m_LastUpdateServerState > 1)
	{
		UpdateServerState(false);
	}

	m_BlinkTimer += frametime;

	// Update speaker labels.
	if( m_pHelper->CanShowSpeakerLabels() )
	{
		for( int i=0; i < MAX_VOICE_SPEAKERS; i++ )
			m_Labels[i].m_pBackground->setVisible( m_Labels[i].m_clientindex != -1 );
	}
	else
	{
		for( int i=0; i < MAX_VOICE_SPEAKERS; i++ )
			m_Labels[i].m_pBackground->setVisible( false );
	}

	for(int i=0; i < VOICE_MAX_PLAYERS; i++)
		UpdateBanButton(i);
}


void CVoiceStatus::CreateEntities()
{
	if(!m_VoiceHeadModel)
		return;

	cl_entity_t *localPlayer = gEngfuncs.GetLocalPlayer();

	int iOutModel = 0;
	for(int i=0; i < VOICE_MAX_PLAYERS; i++)
	{
		if(!m_VoicePlayers[i])
			continue;
		
		cl_entity_s *pClient = gEngfuncs.GetEntityByIndex(i+1);
		
		// Don't show an icon if the player is not in our PVS.
		if(!pClient || pClient->curstate.messagenum < localPlayer->curstate.messagenum)
			continue;

		// Don't show an icon for dead or spectating players (ie: invisible entities).
		if(pClient->curstate.effects & EF_NODRAW)
			continue;

		// Don't show an icon for the local player unless we're in thirdperson mode.
		if(pClient == localPlayer && !cam_thirdperson)
			continue;

		cl_entity_s *pEnt = &m_VoiceHeadModels[iOutModel];
		++iOutModel;

		memset(pEnt, 0, sizeof(*pEnt));

		pEnt->curstate.rendermode = kRenderTransAdd;
		pEnt->curstate.renderamt = 255;
		pEnt->baseline.renderamt = 255;
		pEnt->curstate.renderfx = kRenderFxNoDissipation;
		pEnt->curstate.framerate = 1;
		pEnt->curstate.frame = 0;
		pEnt->model = (struct model_s*)gEngfuncs.GetSpritePointer(m_VoiceHeadModel);
		pEnt->angles[0] = pEnt->angles[1] = pEnt->angles[2] = 0;
		pEnt->curstate.scale = 0.5f;
		
		pEnt->origin[0] = pEnt->origin[1] = 0;
		pEnt->origin[2] = 45;

		VectorAdd(pEnt->origin, pClient->origin, pEnt->origin);

		// Tell the engine.
		gEngfuncs.CL_CreateVisibleEntity(ET_NORMAL, pEnt);
	}
}


void CVoiceStatus::UpdateSpeakerStatus(int entindex, qboolean bTalking)
{
	if(!*m_pParentPanel)
		return;

	if( gEngfuncs.pfnGetCvarFloat("voice_clientdebug") )
	{
		char msg[256];
		_snprintf( msg, sizeof(msg), "CVoiceStatus::UpdateSpeakerStatus: ent %d talking = %d\n", entindex, bTalking );
		gEngfuncs.pfnConsolePrint( msg );
	}

	// Is it the local player talking?
	if( entindex == -1 )
	{
		m_bTalking = !!bTalking;
		if( bTalking )
		{
			// Enable voice for them automatically if they try to talk.
			gEngfuncs.pfnClientCmd( "voice_modenable 1" );
		}
	}
	else if( entindex == -2 )
	{
		m_bServerAcked = !!bTalking;
	}
	else if(entindex >= 0 && entindex <= VOICE_MAX_PLAYERS)
	{
		int iClient = entindex - 1;
		if(iClient < 0)
			return;

		CVoiceLabel *pLabel = FindVoiceLabel(iClient);
		if(bTalking)
		{
			m_VoicePlayers[iClient] = true;
			m_VoiceEnabledPlayers[iClient] = true;

			// If we don't have a label for this guy yet, then create one.
			if(!pLabel)
			{
				if(pLabel = GetFreeVoiceLabel())
				{
					// Get the name from the engine.
					hud_player_info_t info;
					memset(&info, 0, sizeof(info));
					GetPlayerInfo(entindex, &info);

					char paddedName[512];
					_snprintf(paddedName, sizeof(paddedName), "%s   ", info.name);

					int color[3];
					m_pHelper->GetPlayerTextColor( entindex, color );

					if( pLabel->m_pBackground )
					{
						pLabel->m_pBackground->setBgColor( color[0], color[1], color[2], 135 );
						pLabel->m_pBackground->setParent( *m_pParentPanel );
						pLabel->m_pBackground->setVisible( m_pHelper->CanShowSpeakerLabels() );
					}

					if( pLabel->m_pLabel )
					{
						pLabel->m_pLabel->setFgColor( 255, 255, 255, 0 );
						pLabel->m_pLabel->setBgColor( 0, 0, 0, 255 );
						pLabel->m_pLabel->setText( paddedName );
					}
					
					pLabel->m_clientindex = iClient;
				}
			}
		}
		else
		{
			m_VoicePlayers[iClient] = false;

			// If we have a label for this guy, kill it.
			if(pLabel)
			{
				pLabel->m_pBackground->setVisible(false);
				pLabel->m_clientindex = -1;
			}
		}
	}

	RepositionLabels();
}


void CVoiceStatus::UpdateServerState(bool bForce)
{
	// Can't do anything when we're not in a level.
	char const *pLevelName = gEngfuncs.pfnGetLevelName();
	if( pLevelName[0] == 0 )
	{
		if( gEngfuncs.pfnGetCvarFloat("voice_clientdebug") )
		{
			gEngfuncs.pfnConsolePrint( "CVoiceStatus::UpdateServerState: pLevelName[0]==0\n" );
		}

		return;
	}
	
	int bCVarModEnable = !!gEngfuncs.pfnGetCvarFloat("voice_modenable");
	if(bForce || m_bServerModEnable != bCVarModEnable)
	{
		m_bServerModEnable = bCVarModEnable;

		char str[256];
		_snprintf(str, sizeof(str), "VModEnable %d", m_bServerModEnable);
		ServerCmd(str);

		if(gEngfuncs.pfnGetCvarFloat("voice_clientdebug"))
		{
			char msg[256];
			sprintf(msg, "CVoiceStatus::UpdateServerState: Sending '%s'\n", str);
			gEngfuncs.pfnConsolePrint(msg);
		}
	}

	char str[2048];
	sprintf(str, "vban");
	bool bChange = false;

	for(unsigned long dw=0; dw < VOICE_MAX_PLAYERS_DW; dw++)
	{	
		unsigned long serverBanMask = 0;
		unsigned long banMask = 0;
		for(unsigned long i=0; i < 32; i++)
		{
			char playerID[16];
			if(!gEngfuncs.GetPlayerUniqueID(i+1, playerID))
				continue;

			if(m_BanMgr.GetPlayerBan(playerID))
				banMask |= 1 << i;

			if(m_ServerBannedPlayers[dw*32 + i])
				serverBanMask |= 1 << i;
		}

		if(serverBanMask != banMask)
			bChange = true;

		// Ok, the server needs to be updated.
		char numStr[512];
		sprintf(numStr, " %x", banMask);
		strcat(str, numStr);
	}

	if(bChange || bForce)
	{
		if(gEngfuncs.pfnGetCvarFloat("voice_clientdebug"))
		{
			char msg[256];
			sprintf(msg, "CVoiceStatus::UpdateServerState: Sending '%s'\n", str);
			gEngfuncs.pfnConsolePrint(msg);
		}

		gEngfuncs.pfnServerCmdUnreliable(str);	// Tell the server..
	}
	else
	{
		if (gEngfuncs.pfnGetCvarFloat("voice_clientdebug"))
		{
			gEngfuncs.pfnConsolePrint( "CVoiceStatus::UpdateServerState: no change\n" );
		}
	}
	
	m_LastUpdateServerState = gEngfuncs.GetClientTime();
}

void CVoiceStatus::UpdateSpeakerImage(Label *pLabel, int iPlayer)
{
	m_pBanButtons[iPlayer-1] = pLabel;
	UpdateBanButton(iPlayer-1);
}

void CVoiceStatus::UpdateBanButton(int iClient)
{
	Label *pPanel = m_pBanButtons[iClient];

	if (!pPanel)
		return;

	char playerID[16];
	extern bool HACK_GetPlayerUniqueID( int iPlayer, char playerID[16] );
	if(!HACK_GetPlayerUniqueID(iClient+1, playerID))
		return;

	// Figure out if it's blinking or not.
	bool bBlink   = fmod(m_BlinkTimer, SCOREBOARD_BLINK_FREQUENCY*2) < SCOREBOARD_BLINK_FREQUENCY;
	bool bTalking = !!m_VoicePlayers[iClient];
	bool bBanned  = m_BanMgr.GetPlayerBan(playerID);
	bool bNeverSpoken = !m_VoiceEnabledPlayers[iClient];

	// Get the appropriate image to display on the panel.
	if (bBanned)
	{
		pPanel->setImage(m_pScoreboardBanned);
	}
	else if (bTalking)
	{
		if (bBlink)
		{
			pPanel->setImage(m_pScoreboardSpeaking2);
		}
		else
		{
			pPanel->setImage(m_pScoreboardSpeaking);
		}
		pPanel->setFgColor(255, 170, 0, 1);
	}
	else if (bNeverSpoken)
	{
		pPanel->setImage(m_pScoreboardNeverSpoken);
		pPanel->setFgColor(100, 100, 100, 1);
	}
	else
	{
		pPanel->setImage(m_pScoreboardNotSpeaking);
	}
}


void CVoiceStatus::HandleVoiceMaskMsg(int iSize, void *pbuf)
{
	BEGIN_READ( pbuf, iSize );

	unsigned long dw;
	for(dw=0; dw < VOICE_MAX_PLAYERS_DW; dw++)
	{
		m_AudiblePlayers.SetDWord(dw, (unsigned long)READ_LONG());
		m_ServerBannedPlayers.SetDWord(dw, (unsigned long)READ_LONG());

		if(gEngfuncs.pfnGetCvarFloat("voice_clientdebug"))
		{
			char str[256];
			gEngfuncs.pfnConsolePrint("CVoiceStatus::HandleVoiceMaskMsg\n");
			
			sprintf(str, "    - m_AudiblePlayers[%d] = %lu\n", dw, m_AudiblePlayers.GetDWord(dw));
			gEngfuncs.pfnConsolePrint(str);
			
			sprintf(str, "    - m_ServerBannedPlayers[%d] = %lu\n", dw, m_ServerBannedPlayers.GetDWord(dw));
			gEngfuncs.pfnConsolePrint(str);
		}
	}

	m_bServerModEnable = READ_BYTE();
}

void CVoiceStatus::HandleReqStateMsg(int iSize, void *pbuf)
{
	if(gEngfuncs.pfnGetCvarFloat("voice_clientdebug"))
	{
		gEngfuncs.pfnConsolePrint("CVoiceStatus::HandleReqStateMsg\n");
	}

	UpdateServerState(true);	
}

void CVoiceStatus::StartSquelchMode()
{
	if(m_bInSquelchMode)
		return;

	m_bInSquelchMode = true;
	m_pHelper->UpdateCursorState();
}

void CVoiceStatus::StopSquelchMode()
{
	m_bInSquelchMode = false;
	m_pHelper->UpdateCursorState();
}

bool CVoiceStatus::IsInSquelchMode()
{
	return m_bInSquelchMode;
}

CVoiceLabel* CVoiceStatus::FindVoiceLabel(int clientindex)
{
	for(int i=0; i < MAX_VOICE_SPEAKERS; i++)
	{
		if(m_Labels[i].m_clientindex == clientindex)
			return &m_Labels[i];
	}

	return NULL;
}


CVoiceLabel* CVoiceStatus::GetFreeVoiceLabel()
{
	return FindVoiceLabel(-1);
}


void CVoiceStatus::RepositionLabels()
{
	// find starting position to draw from, along right-hand side of screen
	int y = ScreenHeight / 2;
	
	int iconWide = 8, iconTall = 8;
	if( m_pSpeakerLabelIcon )
	{
		m_pSpeakerLabelIcon->getSize( iconWide, iconTall );
	}
	
	// Reposition active labels.
	for(int i = 0; i < MAX_VOICE_SPEAKERS; i++)
	{
		CVoiceLabel *pLabel = &m_Labels[i];

		if( pLabel->m_clientindex == -1 || !pLabel->m_pLabel )
		{
			if( pLabel->m_pBackground )
				pLabel->m_pBackground->setVisible( false );

			continue;
		}

		int textWide, textTall;
		pLabel->m_pLabel->getContentSize( textWide, textTall );

		// Don't let it stretch too far across their screen.
		if( textWide > (ScreenWidth*2)/3 )
			textWide = (ScreenWidth*2)/3;

		// Setup the background label to fit everything in.
		int border = 2;
		int bgWide = textWide + iconWide + border*3;
		int bgTall = max( textTall, iconTall ) + border*2;
		pLabel->m_pBackground->setBounds( ScreenWidth - bgWide - 8, y, bgWide, bgTall );

		// Put the text at the left.
		pLabel->m_pLabel->setBounds( border, (bgTall - textTall) / 2, textWide, textTall );

		// Put the icon at the right.
		int iconLeft = border + textWide + border;
		int iconTop = (bgTall - iconTall) / 2;
		if( pLabel->m_pIcon )
		{
			pLabel->m_pIcon->setImage( m_pSpeakerLabelIcon );
			pLabel->m_pIcon->setBounds( iconLeft, iconTop, iconWide, iconTall );
		}

		y += bgTall + 2;
	}

	if( m_pLocalBitmap && m_pAckBitmap && m_pLocalLabel && (m_bTalking || m_bServerAcked) )
	{
		m_pLocalLabel->setParent(*m_pParentPanel);
		m_pLocalLabel->setVisible( true );

		if( m_bServerAcked && !!gEngfuncs.pfnGetCvarFloat("voice_clientdebug") )
			m_pLocalLabel->setImage( m_pAckBitmap );
		else
			m_pLocalLabel->setImage( m_pLocalBitmap );

		int sizeX, sizeY;
		m_pLocalBitmap->getSize(sizeX, sizeY);

		int local_xPos = ScreenWidth - sizeX - 10;
		int local_yPos = m_pHelper->GetAckIconHeight() - sizeY;
		
		m_pLocalLabel->setPos( local_xPos, local_yPos );
	}
	else
	{
		m_pLocalLabel->setVisible( false );
	}
}


void CVoiceStatus::FreeBitmaps()
{
	// Delete all the images we have loaded.
	delete m_pLocalBitmap;
	m_pLocalBitmap = NULL;

	delete m_pAckBitmap;
	m_pAckBitmap = NULL;

	delete m_pSpeakerLabelIcon;
	m_pSpeakerLabelIcon = NULL;

	delete m_pScoreboardNeverSpoken;
	m_pScoreboardNeverSpoken = NULL;

	delete m_pScoreboardNotSpeaking;
	m_pScoreboardNotSpeaking = NULL;

	delete m_pScoreboardSpeaking;
	m_pScoreboardSpeaking = NULL;

	delete m_pScoreboardSpeaking2;
	m_pScoreboardSpeaking2 = NULL;

	delete m_pScoreboardSquelch;
	m_pScoreboardSquelch = NULL;

	delete m_pScoreboardBanned;
	m_pScoreboardBanned = NULL;

	// Clear references to the images in panels.
	for(int i=0; i < VOICE_MAX_PLAYERS; i++)
	{
		if (m_pBanButtons[i])
		{
			m_pBanButtons[i]->setImage(NULL);
		}
	}

	if(m_pLocalLabel)
		m_pLocalLabel->setImage(NULL);
}

//-----------------------------------------------------------------------------
// Purpose: returns true if the target client has been banned
// Input  : playerID - 
// Output : Returns true on success, false on failure.
//-----------------------------------------------------------------------------
bool CVoiceStatus::IsPlayerBlocked(int iPlayer)
{
	char playerID[16];
	if (!gEngfuncs.GetPlayerUniqueID(iPlayer, playerID))
		return false;

	return m_BanMgr.GetPlayerBan(playerID);
}

//-----------------------------------------------------------------------------
// Purpose: returns true if the player can't hear the other client due to game rules (eg. the other team)
// Input  : playerID - 
// Output : Returns true on success, false on failure.
//-----------------------------------------------------------------------------
bool CVoiceStatus::IsPlayerAudible(int iPlayer)
{
	return !!m_AudiblePlayers[iPlayer-1];
}

//-----------------------------------------------------------------------------
// Purpose: blocks/unblocks the target client from being heard
// Input  : playerID - 
// Output : Returns true on success, false on failure.
//-----------------------------------------------------------------------------
void CVoiceStatus::SetPlayerBlockedState(int iPlayer, bool blocked)
{
	if (gEngfuncs.pfnGetCvarFloat("voice_clientdebug"))
	{
		gEngfuncs.pfnConsolePrint( "CVoiceStatus::SetPlayerBlockedState part 1\n" );
	}

	char playerID[16];
	if (!gEngfuncs.GetPlayerUniqueID(iPlayer, playerID))
		return;

	if (gEngfuncs.pfnGetCvarFloat("voice_clientdebug"))
	{
		gEngfuncs.pfnConsolePrint( "CVoiceStatus::SetPlayerBlockedState part 2\n" );
	}

	// Squelch or (try to) unsquelch this player.
	if (gEngfuncs.pfnGetCvarFloat("voice_clientdebug"))
	{
		char str[256];
		sprintf(str, "CVoiceStatus::SetPlayerBlockedState: setting player %d ban to %d\n", iPlayer, !m_BanMgr.GetPlayerBan(playerID));
		gEngfuncs.pfnConsolePrint(str);
	}

	m_BanMgr.SetPlayerBan( playerID, blocked );
	UpdateServerState(false);
}

```

`game_shared/voice_status.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#ifndef VOICE_STATUS_H
#define VOICE_STATUS_H
#ifdef _WIN32
#ifndef __MINGW32__
#pragma once
#endif /* not __MINGW32__ */
#endif


#include "VGUI_Label.h"
#include "VGUI_LineBorder.h"
#include "VGUI_ImagePanel.h"
#include "VGUI_BitmapTGA.h"
#include "VGUI_InputSignal.h"
#include "VGUI_Button.h"
#include "voice_common.h"
#include "cl_entity.h"
#include "voice_banmgr.h"
#include "vgui_checkbutton2.h"
#include "vgui_defaultinputsignal.h"


class CVoiceStatus;


class CVoiceLabel
{
public:
	vgui::Label			*m_pLabel;
	vgui::Label			*m_pBackground;
	vgui::ImagePanel	*m_pIcon;		// Voice icon next to player name.
	int					m_clientindex;	// Client index of the speaker. -1 if this label isn't being used.
};


// This is provided by each mod to access data that may not be the same across mods.
class IVoiceStatusHelper
{
public:
	virtual					~IVoiceStatusHelper()	{}

	// Get RGB color for voice status text about this player.
	virtual void			GetPlayerTextColor(int entindex, int color[3]) = 0;

	// Force it to update the cursor state.
	virtual void			UpdateCursorState() = 0;

	// Return the height above the bottom that the voice ack icons should be drawn at.
	virtual int				GetAckIconHeight() = 0;

	// Return true if the voice manager is allowed to show speaker labels
	// (mods usually return false when the scoreboard is up).
	virtual bool			CanShowSpeakerLabels() = 0;
};

//-----------------------------------------------------------------------------
// Purpose: Holds a color for the shared image
//-----------------------------------------------------------------------------
class VoiceImagePanel : public vgui::ImagePanel
{
	virtual void paintBackground()
	{
		if (_image!=null)
		{
			vgui::Color col;
			getFgColor(col);
			_image->setColor(col);
			_image->doPaint(this);
		}
	}
};


class CVoiceStatus : public CHudBase, public vgui::CDefaultInputSignal
{
public:
				CVoiceStatus();
	virtual		~CVoiceStatus();

// CHudBase overrides.
public:
	
	// Initialize the cl_dll's voice manager.
	virtual int Init(
		IVoiceStatusHelper *m_pHelper,
		vgui::Panel **pParentPanel);
	
	// ackPosition is the bottom position of where CVoiceStatus will draw the voice acknowledgement labels.
	virtual int VidInit();


public:
	
	// Call from HUD_Frame each frame.
	void	Frame(double frametime);

	// Called when a player starts or stops talking.
	// entindex is -1 to represent the local client talking (before the data comes back from the server). 
	// When the server acknowledges that the local client is talking, then entindex will be gEngfuncs.GetLocalPlayer().
	// entindex is -2 to represent the local client's voice being acked by the server.
	void	UpdateSpeakerStatus(int entindex, qboolean bTalking);

	// sets the correct image in the label for the player
	void	UpdateSpeakerImage(vgui::Label *pLabel, int iPlayer);

	// Call from the HUD_CreateEntities function so it can add sprites above player heads.
	void	CreateEntities();

	// Called when the server registers a change to who this client can hear.
	void	HandleVoiceMaskMsg(int iSize, void *pbuf);

	// The server sends this message initially to tell the client to send their state.
	void	HandleReqStateMsg(int iSize, void *pbuf);


// Squelch mode functions.
public:

	// When you enter squelch mode, pass in 
	void	StartSquelchMode();
	void	StopSquelchMode();
	bool	IsInSquelchMode();

	// returns true if the target client has been banned
	// playerIndex is of range 1..maxplayers
	bool	IsPlayerBlocked(int iPlayerIndex);

	// returns false if the player can't hear the other client due to game rules (eg. the other team)
	bool    IsPlayerAudible(int iPlayerIndex);

	// blocks the target client from being heard
	void	SetPlayerBlockedState(int iPlayerIndex, bool blocked);

public:

	CVoiceLabel*	FindVoiceLabel(int clientindex);	// Find a CVoiceLabel representing the specified speaker. 
													// Returns NULL if none.
													// entindex can be -1 if you want a currently-unused voice label.
	CVoiceLabel*	GetFreeVoiceLabel();			// Get an unused voice label. Returns NULL if none.

	void			RepositionLabels();

	void			FreeBitmaps();

	void			UpdateServerState(bool bForce);

	// Update the button artwork to reflect the client's current state.
	void			UpdateBanButton(int iClient);


public:

	enum			{MAX_VOICE_SPEAKERS=7};

	float			m_LastUpdateServerState;		// Last time we called this function.
	int				m_bServerModEnable;				// What we've sent to the server about our "voice_modenable" cvar.

	vgui::Panel		**m_pParentPanel;
	CPlayerBitVec	m_VoicePlayers;		// Who is currently talking. Indexed by client index.
	
	// This is the gamerules-defined list of players that you can hear. It is based on what teams people are on 
	// and is totally separate from the ban list. Indexed by client index.
	CPlayerBitVec	m_AudiblePlayers;

	// Players who have spoken at least once in the game so far
	CPlayerBitVec	m_VoiceEnabledPlayers;	

	// This is who the server THINKS we have banned (it can become incorrect when a new player arrives on the server).
	// It is checked periodically, and the server is told to squelch or unsquelch the appropriate players.
	CPlayerBitVec	m_ServerBannedPlayers;

	cl_entity_s		m_VoiceHeadModels[VOICE_MAX_PLAYERS];			// These aren't necessarily in the order of players. They are just
																	// a place for it to put data in during CreateEntities.

	IVoiceStatusHelper	*m_pHelper;		// Each mod provides an implementation of this.

	
	// Scoreboard icons.
	double			m_BlinkTimer;			// Blink scoreboard icons..
	vgui::BitmapTGA	*m_pScoreboardNeverSpoken;
	vgui::BitmapTGA	*m_pScoreboardNotSpeaking;
	vgui::BitmapTGA	*m_pScoreboardSpeaking;
	vgui::BitmapTGA	*m_pScoreboardSpeaking2;
	vgui::BitmapTGA	*m_pScoreboardSquelch;
	vgui::BitmapTGA	*m_pScoreboardBanned;
	
	vgui::Label		   *m_pBanButtons[VOICE_MAX_PLAYERS];		// scoreboard buttons.

	// Squelch mode stuff.
	bool				m_bInSquelchMode;
	
	HSPRITE				m_VoiceHeadModel;		// Voice head model (goes above players who are speaking).
	float				m_VoiceHeadModelHeight;	// Height above their head to place the model.

	vgui::Image			*m_pSpeakerLabelIcon;	// Icon next to speaker labels.

	// Lower-right icons telling when the local player is talking..
	vgui::BitmapTGA		*m_pLocalBitmap;		// Represents the local client talking.
	vgui::BitmapTGA		*m_pAckBitmap;			// Represents the server ack'ing the client talking.
	vgui::ImagePanel	*m_pLocalLabel;			// Represents the local client talking.

	bool				m_bTalking;				// Set to true when the client thinks it's talking.
	bool				m_bServerAcked;			// Set to true when the server knows the client is talking.

public:
	
	CVoiceBanMgr		m_BanMgr;				// Tracks which users we have squelched and don't want to hear.

public:

	bool				m_bBanMgrInitialized;

	// Labels telling who is speaking.
	CVoiceLabel			m_Labels[MAX_VOICE_SPEAKERS];

	// Cache the game directory for use when we shut down
	char *				m_pchGameDir;
};


// Get the (global) voice manager. 
CVoiceStatus* GetClientVoiceMgr();


#endif // VOICE_STATUS_H

```

`mainui/Android.mk`:

```mk

#Xash3d mainui port for android
#Copyright (c) nicknekit

LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

include $(XASH3D_CONFIG)

ifeq ($(TARGET_ARCH_ABI),armeabi-v7a-hard)
LOCAL_MODULE_FILENAME = libmenu_hardfp
endif



LOCAL_MODULE := menu

APP_PLATFORM := android-12

LOCAL_C_INCLUDES := $(SDL_PATH)/include \
		    $(LOCAL_PATH)/.			    \
		    $(LOCAL_PATH)/../common \
	            $(LOCAL_PATH)/../pm_shared \
	            $(LOCAL_PATH)/../engine \
		    $(LOCAL_PATH)/../engine/common \
		    $(LOCAL_PATH)/../utils/vgui/include \
		    $(HLSDK_PATH)/cl_dll/

LOCAL_SRC_FILES := basemenu.cpp \
           menu_advcontrols.cpp \
           menu_audio.cpp \
           menu_btns.cpp \
           menu_configuration.cpp \
           menu_controls.cpp \
           menu_creategame.cpp \
           menu_credits.cpp \
	   menu_filedialog.cpp \
           menu_gameoptions.cpp \
           menu_gamepad.cpp \
           menu_internetgames.cpp \
           menu_langame.cpp \
           menu_main.cpp \
           menu_multiplayer.cpp \
           menu_playersetup.cpp \
           menu_strings.cpp \
           menu_vidoptions.cpp \
	   menu_touchoptions.cpp \
	   menu_touch.cpp \
	   menu_touchedit.cpp \
	   menu_touchbuttons.cpp \
           udll_int.cpp \
           ui_title_anim.cpp \
	   utils.cpp \
	   legacy/menu_playrec.cpp \
	   legacy/menu_playdemo.cpp \
	   legacy/menu_recdemo.cpp 

#ifeq ($(XASH_SDL),1)
#LOCAL_SHARED_LIBRARIES += SDL2
#endif
include $(BUILD_SHARED_LIBRARY)

```

`mainui/CMakeLists.txt`:

```txt
#
# Copyright (c) 2015 Pavlo Lavrenenko
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

cmake_minimum_required(VERSION 2.6.0)
project (MAINUI)

# set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -pedantic")
set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -pedantic -m32")
set (CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g")
set (CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3")
set (CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL} -Os")
set (CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -g -O3")
set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -m32")

if(PANDORA)
	add_definitions(-DPANDORA)
endif()

set (MAINUI_LIBRARY xashmenu)

file (GLOB MAINUI_SOURCES *.cpp legacy/*.cpp)
include_directories (../common ../engine ../pm_shared ../mainui)
add_library (${MAINUI_LIBRARY} SHARED ${MAINUI_SOURCES})

set_target_properties (${MAINUI_SHARED} PROPERTIES
	VERSION ${XASH3D_VERSION} SOVERSION ${XASH3D_VERSION}
	POSITION_INDEPENDENT_CODE 1)

install( TARGETS ${MAINUI_LIBRARY} DESTINATION ${LIB_INSTALL_DIR}/xash3d 
        PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ)


```

`mainui/enginecallback.h`:

```h
/*
enginecallback.h - actual engine callbacks
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef ENGINECALLBACKS_H
#define ENGINECALLBACKS_H

// built-in memory manager
#define MALLOC( x )		(*g_engfuncs.pfnMemAlloc)( x, __FILE__, __LINE__ )
#define CALLOC( x, y )	(*g_engfuncs.pfnMemAlloc)((x) * (y), __FILE__, __LINE__ )
#define FREE( x )		(*g_engfuncs.pfnMemFree)( x, __FILE__, __LINE__ )

// screen handlers
#define PIC_Width		(*g_engfuncs.pfnPIC_Width)
#define PIC_Height		(*g_engfuncs.pfnPIC_Height)
#define PIC_EnableScissor	(*g_engfuncs.pfnPIC_EnableScissor)
#define PIC_DisableScissor	(*g_engfuncs.pfnPIC_DisableScissor)
#define FillRGBA		(*g_engfuncs.pfnFillRGBA)
#define GetScreenInfo	(*g_engfuncs.pfnGetScreenInfo)
#define GetGameInfo		(*g_engfuncs.pfnGetGameInfo)
#define CheckGameDll	(*g_engfuncs.pfnCheckGameDll)

#define PIC_SetGamma( x, y )	(*g_engfuncs.pfnProcessImage)( x, y, -1, -1 )
#define PIC_Remap( x, y, z )	(*g_engfuncs.pfnProcessImage)( x, -1.0f, y, z )

#define DRAW_LOGO		(*g_engfuncs.pfnDrawLogo)
#define PRECACHE_LOGO( x )	(*g_engfuncs.pfnDrawLogo)( x, 0, 0, 0, 0 )
#define GetLogoWidth	(*g_engfuncs.pfnGetLogoWidth)
#define GetLogoHeight	(*g_engfuncs.pfnGetLogoHeight)
#define GetLogoLength	(*g_engfuncs.pfnGetLogoLength)

inline HIMAGE PIC_Load( const char *szPicName, long flags = 0 )
{
	return g_engfuncs.pfnPIC_Load( szPicName, NULL, 0, flags );
}

inline HIMAGE PIC_Load( const char *szPicName, const byte *ucRawImage, long ulRawImageSize, long flags = 0 )
{
	return g_engfuncs.pfnPIC_Load( szPicName, ucRawImage, ulRawImageSize, flags );
}

#define PIC_Free		(*g_engfuncs.pfnPIC_Free)
#define PLAY_SOUND		(*g_engfuncs.pfnPlayLocalSound)
#define CVAR_REGISTER	(*g_engfuncs.pfnRegisterVariable)
#define CVAR_SET_FLOAT	(*g_engfuncs.pfnCvarSetValue)
#define CVAR_GET_FLOAT	(*g_engfuncs.pfnGetCvarFloat)
#define CVAR_GET_STRING	(*g_engfuncs.pfnGetCvarString)
#define CVAR_SET_STRING	(*g_engfuncs.pfnCvarSetString)
#define CLIENT_COMMAND	(*g_engfuncs.pfnClientCmd)
#define CLIENT_JOIN		(*g_engfuncs.pfnClientJoin)

#define GET_MENU_EDICT	(*g_engfuncs.pfnGetPlayerModel)
#define ENGINE_SET_MODEL	(*g_engfuncs.pfnSetModel)
#define R_ClearScene	(*g_engfuncs.pfnClearScene)
#define R_AddEntity		(*g_engfuncs.CL_CreateVisibleEntity)
#define R_RenderFrame	(*g_engfuncs.pfnRenderScene)

#define LOAD_FILE		(*g_engfuncs.COM_LoadFile)
#define FILE_EXISTS( file )	(*g_engfuncs.pfnFileExists)( file, FALSE )
#define FREE_FILE		(*g_engfuncs.COM_FreeFile)
#define GET_GAME_DIR	(*g_engfuncs.pfnGetGameDir)
#define HOST_ERROR		(*g_engfuncs.pfnHostError)
#define COM_ParseFile	(*g_engfuncs.COM_ParseFile)
#define KEY_SetDest		(*g_engfuncs.pfnSetKeyDest)
#define KEY_ClearStates	(*g_engfuncs.pfnKeyClearStates)
#define KEY_KeynumToString	(*g_engfuncs.pfnKeynumToString)
#define KEY_GetBinding	(*g_engfuncs.pfnKeyGetBinding)
#define KEY_SetBinding	(*g_engfuncs.pfnKeySetBinding)
#define KEY_IsDown		(*g_engfuncs.pfnKeyIsDown)
#define KEY_GetOverstrike	(*g_engfuncs.pfnKeyGetOverstrikeMode)
#define KEY_SetOverstrike	(*g_engfuncs.pfnKeySetOverstrikeMode)
#define Key_GetState	(*g_engfuncs.pfnKeyGetState)
#define SET_CURSOR		(*g_engfuncs.pfnSetCursor)
	
#define Cmd_AddCommand	(*g_engfuncs.pfnAddCommand)
#define Cmd_RemoveCommand	(*g_engfuncs.pfnDelCommand)
#define CMD_ARGC		(*g_engfuncs.pfnCmdArgc)
#define CMD_ARGV		(*g_engfuncs.pfnCmdArgv)
#define Con_Printf		(*g_engfuncs.Con_Printf)
#define Con_NPrintf		(*g_engfuncs.Con_NPrintf)

#define GET_GAMES_LIST	(*g_engfuncs.pfnGetGamesList)
#define BACKGROUND_TRACK	(*g_engfuncs.pfnPlayBackgroundTrack)
#define SHELL_EXECUTE	(*g_engfuncs.pfnShellExecute)
#define HOST_WRITECONFIG	(*g_engfuncs.pfnWriteServerConfig)
#define HOST_CHANGEGAME	(*g_engfuncs.pfnChangeInstance)
#define CHECK_MAP_LIST	(*g_engfuncs.pfnCreateMapsList)
#define HOST_ENDGAME	(*g_engfuncs.pfnHostEndGame)
#define GET_CLIPBOARD	(*g_engfuncs.pfnGetClipboardData)
#define FS_SEARCH		(*g_engfuncs.pfnGetFilesList)
#define MAP_IS_VALID	(*g_engfuncs.pfnIsMapValid)

#define GET_SAVE_COMMENT	(*g_engfuncs.pfnGetSaveComment)
#define GET_DEMO_COMMENT	(*g_engfuncs.pfnGetDemoComment)

#define CL_IsActive()	(g_engfuncs.pfnClientInGame() && !CVAR_GET_FLOAT( "cl_background" ))

inline void PIC_Set( HIMAGE hPic, int r, int g, int b )
{
	g_engfuncs.pfnPIC_Set( hPic, r, g, b, 255 );
}

inline void PIC_Set( HIMAGE hPic, int r, int g, int b, int a )
{
	g_engfuncs.pfnPIC_Set( hPic, r, g, b, a );
}

inline void PIC_Draw( int x, int y, const wrect_t *prc )
{
	g_engfuncs.pfnPIC_Draw( x, y, -1, -1, prc );
}

inline void PIC_Draw( int x, int y, int width, int height )
{
	g_engfuncs.pfnPIC_Draw( x, y, width, height, NULL );
}

inline void PIC_Draw( int x, int y, int width, int height, const wrect_t *prc )
{
	g_engfuncs.pfnPIC_Draw( x, y, width, height, prc );
}

inline void PIC_DrawTrans( int x, int y, const wrect_t *prc )
{
	g_engfuncs.pfnPIC_DrawTrans( x, y, -1, -1, prc );
}

inline void PIC_DrawTrans( int x, int y, int width, int height )
{
	g_engfuncs.pfnPIC_DrawTrans( x, y, width, height, NULL );
}

inline void PIC_DrawTrans( int x, int y, int width, int height, const wrect_t *prc )
{
	g_engfuncs.pfnPIC_DrawTrans( x, y, width, height, prc );
}

inline void PIC_DrawHoles( int x, int y, const wrect_t *prc )
{
	g_engfuncs.pfnPIC_DrawHoles( x, y, -1, -1, prc );
}

inline void PIC_DrawHoles( int x, int y, int width, int height )
{
	g_engfuncs.pfnPIC_DrawHoles( x, y, width, height, NULL );
}

inline void PIC_DrawHoles( int x, int y, int width, int height, const wrect_t *prc )
{
	g_engfuncs.pfnPIC_DrawHoles( x, y, width, height, prc );
}

inline void PIC_DrawAdditive( int x, int y, int width, int height )
{
	g_engfuncs.pfnPIC_DrawAdditive( x, y, width, height, NULL );
}

inline void PIC_DrawAdditive( int x, int y, const wrect_t *prc )
{
	g_engfuncs.pfnPIC_DrawAdditive( x, y, -1, -1, prc );
}

inline void PIC_DrawAdditive( int x, int y, int w, int h, const wrect_t *prc )
{
	g_engfuncs.pfnPIC_DrawAdditive( x, y, w, h, prc );
}

inline void TextMessageSetColor( int r, int g, int b, int alpha = 255 )
{
	g_engfuncs.pfnDrawSetTextColor( r, g, b, alpha );
}

#define TextMessageDrawChar	(*g_engfuncs.pfnDrawCharacter)
#define DrawConsoleString	(*g_engfuncs.pfnDrawConsoleString)
#define GetConsoleStringSize	(*g_engfuncs.pfnDrawConsoleStringLen)
#define ConsoleSetColor	(*g_engfuncs.pfnSetConsoleDefaultColor)

#define RANDOM_LONG		(*g_engfuncs.pfnRandomLong)
#define RANDOM_FLOAT	(*g_engfuncs.pfnRandomFloat)

#define COMPARE_FILE_TIME	(*g_engfuncs.pfnCompareFileTime)

//#define UtfProcessChar		(*g_textfuncs.pfnUtfProcessChar)
//#define UtfMoveLeft		(*g_textfuncs.pfnUtfMoveLeft)
//#define UtfMoveRight		(*g_textfuncs.pfnUtfMoveRight)
//#define EnableTextInput		(*g_textfuncs.pfnEnableTextInput)
inline void EnableTextInput( int enable )
{
	if( g_textfuncs.pfnEnableTextInput )
		g_textfuncs.pfnEnableTextInput( enable );
}
inline int UtfMoveRight( char *str, int pos, int length )
{
	if( g_textfuncs.pfnUtfMoveRight )
		return g_textfuncs.pfnUtfMoveRight( str, pos, length );
	return pos + 1;
}

inline int UtfMoveLeft( char *str, int pos )
{
	if( g_textfuncs.pfnUtfMoveLeft )
		return g_textfuncs.pfnUtfMoveLeft( str, pos );
	return pos - 1;
}
inline int UtfProcessChar( int in )
{
	if( g_textfuncs.pfnUtfProcessChar )
		return g_textfuncs.pfnUtfProcessChar( in );
	return in;
}

#endif//ENGINECALLBACKS_H

```

`mainui/extdll.h`:

```h
/*
extdll.h - must be included into the all ui files
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef EXTDLL_H
#define EXTDLL_H

// Misc C-runtime library headers
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>

#define bound( min, num, max )	((num) >= (min) ? ((num) < (max) ? (num) : (max)) : (min))
#define min( a, b )	(((a) < (b)) ? (a) : (b))

#ifndef FALSE
#define FALSE	0
#endif

#ifndef TRUE
#define TRUE	(!FALSE)
#endif

#ifndef _WIN32
#define stricmp	strcasecmp
#define strnicmp	strncasecmp
#else
#define strnicmp _strnicmp
#define stricmp _stricmp
#define snprintf _snprintf
#endif

typedef int (*cmpfunc)( const void *a, const void *b );
typedef int BOOL;
typedef unsigned char byte;

#include "menu_int.h"

#endif//EXTDLL_H

```

`mainui/legacy/menu_playdemo.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"

#define ART_BANNER	     	"gfx/shell/head_load"

#define ID_BACKGROUND	0
#define ID_BANNER		1
#define ID_PLAY		2
#define ID_DELETE		3
#define ID_CANCEL		4
#define ID_DEMOLIST		5
#define ID_TABLEHINT	6
#define ID_LEVELSHOT	7
#define ID_MSGBOX	 	8
#define ID_MSGTEXT	 	9
#define ID_YES	 	130
#define ID_NO	 	131

#define LEVELSHOT_X		72
#define LEVELSHOT_Y		400
#define LEVELSHOT_W		192
#define LEVELSHOT_H		160

#define TITLE_LENGTH	32
#define MAPNAME_LENGTH	24+TITLE_LENGTH
#define MAXCLIENTS_LENGTH	16+MAPNAME_LENGTH

typedef struct
{
	char		demoName[UI_MAXGAMES][CS_SIZE];
	char		delName[UI_MAXGAMES][CS_SIZE];
	char		demoDescription[UI_MAXGAMES][256];
	char		*demoDescriptionPtr[UI_MAXGAMES];

	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;
	menuAction_s	play;
	menuAction_s	remove;
	menuAction_s	cancel;

	menuScrollList_s	demosList;

	menuBitmap_s	levelShot;
	menuAction_s	hintMessage;
	char		hintText[MAX_HINT_TEXT];

	// prompt dialog
	menuAction_s	msgBox;
	menuAction_s	promptMessage;
	menuAction_s	yes;
	menuAction_s	no;
} uiPlayDemo_t;

static uiPlayDemo_t		uiPlayDemo;
static const char *uiEmptyString = "";

/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}

static void UI_DeleteDialog( void )
{
	// toggle main menu between active\inactive
	// show\hide remove dialog
	uiPlayDemo.play.generic.flags ^= QMF_INACTIVE; 
	uiPlayDemo.remove.generic.flags ^= QMF_INACTIVE;
	uiPlayDemo.cancel.generic.flags ^= QMF_INACTIVE;
	uiPlayDemo.demosList.generic.flags ^= QMF_INACTIVE;

	uiPlayDemo.msgBox.generic.flags ^= QMF_HIDDEN;
	uiPlayDemo.promptMessage.generic.flags ^= QMF_HIDDEN;
	uiPlayDemo.no.generic.flags ^= QMF_HIDDEN;
	uiPlayDemo.yes.generic.flags ^= QMF_HIDDEN;

}

/*
=================
UI_PlayDemo_KeyFunc
=================
*/
static const char *UI_PlayDemo_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE && uiPlayDemo.play.generic.flags & QMF_INACTIVE )
	{
		UI_DeleteDialog();
		return uiSoundNull;
	}
	return UI_DefaultKey( &uiPlayDemo.menu, key, down );
}

/*
=================
UI_PlayDemo_GetDemoList
=================
*/
static void UI_PlayDemo_GetDemoList( void )
{
	char	comment[256];
	char	**filenames;
	int	i, numFiles;

	filenames = FS_SEARCH( "demos/*.dem", &numFiles, TRUE );

	for( i = 0; i < numFiles; i++ )
	{
		if( i >= UI_MAXGAMES ) break;
		
		if( !GET_DEMO_COMMENT( filenames[i], comment ))
		{
			if( strlen( comment ))
			{
				// get name string even if not found - CL_GetComment can be mark demos
				// as <CORRUPTED> <OLD VERSION> etc
				StringConcat( uiPlayDemo.demoDescription[i], uiEmptyString, TITLE_LENGTH );
				StringConcat( uiPlayDemo.demoDescription[i], comment, MAPNAME_LENGTH );
				StringConcat( uiPlayDemo.demoDescription[i], uiEmptyString, MAXCLIENTS_LENGTH );
				uiPlayDemo.demoDescriptionPtr[i] = uiPlayDemo.demoDescription[i];
				COM_FileBase( filenames[i], uiPlayDemo.delName[i] );
			}
			else uiPlayDemo.demoDescriptionPtr[i] = NULL;
			continue;
		}

		// strip path, leave only filename (empty slots doesn't have savename)
		COM_FileBase( filenames[i], uiPlayDemo.demoName[i] );
		COM_FileBase( filenames[i], uiPlayDemo.delName[i] );

		// fill demo desc
		StringConcat( uiPlayDemo.demoDescription[i], comment + CS_SIZE, TITLE_LENGTH );
		StringConcat( uiPlayDemo.demoDescription[i], uiEmptyString, TITLE_LENGTH );
		StringConcat( uiPlayDemo.demoDescription[i], comment, MAPNAME_LENGTH );
		StringConcat( uiPlayDemo.demoDescription[i], uiEmptyString, MAPNAME_LENGTH ); // fill remaining entries
		StringConcat( uiPlayDemo.demoDescription[i], comment + CS_SIZE * 2, MAXCLIENTS_LENGTH );
		StringConcat( uiPlayDemo.demoDescription[i], uiEmptyString, MAXCLIENTS_LENGTH );
		uiPlayDemo.demoDescriptionPtr[i] = uiPlayDemo.demoDescription[i];
	}

	for ( ; i < UI_MAXGAMES; i++ )
		uiPlayDemo.demoDescriptionPtr[i] = NULL;
	uiPlayDemo.demosList.itemNames = (const char **)uiPlayDemo.demoDescriptionPtr;

	if( strlen( uiPlayDemo.demoName[0] ) == 0 )
		uiPlayDemo.play.generic.flags |= QMF_GRAYED;
	else uiPlayDemo.play.generic.flags &= ~QMF_GRAYED;

	if( strlen( uiPlayDemo.delName[0] ) == 0 || !stricmp( gpGlobals->demoname, uiPlayDemo.delName[uiPlayDemo.demosList.curItem] ))
		uiPlayDemo.remove.generic.flags |= QMF_GRAYED;
	else uiPlayDemo.remove.generic.flags &= ~QMF_GRAYED;
}

/*
=================
UI_PlayDemo_Callback
=================
*/
static void UI_PlayDemo_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( event == QM_CHANGED )
	{
		if( strlen( uiPlayDemo.demoName[uiPlayDemo.demosList.curItem] ) == 0 )
			uiPlayDemo.play.generic.flags |= QMF_GRAYED;
		else uiPlayDemo.play.generic.flags &= ~QMF_GRAYED;

		if( strlen( uiPlayDemo.delName[uiPlayDemo.demosList.curItem] ) == 0 || !stricmp( gpGlobals->demoname, uiPlayDemo.delName[uiPlayDemo.demosList.curItem] ))
			uiPlayDemo.remove.generic.flags |= QMF_GRAYED;
		else uiPlayDemo.remove.generic.flags &= ~QMF_GRAYED;
		return;
	}

	if( event != QM_ACTIVATED )
		return;
	
	switch( item->id )
	{
	case ID_CANCEL:
		UI_PopMenu();
		break;
	case ID_PLAY:
		if( gpGlobals->demoplayback || gpGlobals->demorecording )
		{
			CLIENT_COMMAND( FALSE, "stop" );
			uiPlayDemo.play.generic.name = "Play";
			uiPlayDemo.play.generic.statusText = "Play a demo";
			uiPlayDemo.remove.generic.flags &= ~QMF_GRAYED;
		}
		else if( strlen( uiPlayDemo.demoName[uiPlayDemo.demosList.curItem] ))
		{
			char	cmd[128];
			sprintf( cmd, "playdemo \"%s\"\n", uiPlayDemo.demoName[uiPlayDemo.demosList.curItem] );
			CLIENT_COMMAND( FALSE, cmd );
		}
		break;
	case ID_NO:
	case ID_DELETE:
		UI_DeleteDialog();
		break;
	case ID_YES:
		if( strlen( uiPlayDemo.delName[uiPlayDemo.demosList.curItem] ))
		{
			char	cmd[128];
			sprintf( cmd, "killdemo \"%s\"\n", uiPlayDemo.delName[uiPlayDemo.demosList.curItem] );

			CLIENT_COMMAND( TRUE, cmd );

			sprintf( cmd, "demos/%s.bmp", uiPlayDemo.delName[uiPlayDemo.demosList.curItem] );
			PIC_Free( cmd );

			// restarts the menu
			UI_PopMenu();
			UI_PlayDemo_Menu();
			return;
		}
		UI_DeleteDialog();
		break;
	}
}

/*
=================
UI_PlayDemo_Ownerdraw
=================
*/
static void UI_PlayDemo_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( item->type != QMTYPE_ACTION && item->id == ID_LEVELSHOT )
	{
		int	x, y, w, h;

		// draw the levelshot
		x = LEVELSHOT_X;
		y = LEVELSHOT_Y;
		w = LEVELSHOT_W;
		h = LEVELSHOT_H;
		
		UI_ScaleCoords( &x, &y, &w, &h );

		if( strlen( uiPlayDemo.demoName[uiPlayDemo.demosList.curItem] ))
		{
			char	demoshot[128];

			sprintf( demoshot, "demos/%s.bmp", uiPlayDemo.demoName[uiPlayDemo.demosList.curItem] );

			if( !FILE_EXISTS( demoshot ))
				UI_DrawPicAdditive( x, y, w, h, uiColorWhite, "{GRAF001" );
			else UI_DrawPic( x, y, w, h, uiColorWhite, demoshot );
		}
		else UI_DrawPicAdditive( x, y, w, h, uiColorWhite, "{GRAF001" );

		// draw the rectangle
		UI_DrawRectangle( item->x, item->y, item->width, item->height, uiInputFgColor );
	}
}

/*
=================
UI_PlayDemo_Init
=================
*/
static void UI_PlayDemo_Init( void )
{
	memset( &uiPlayDemo, 0, sizeof( uiPlayDemo_t ));

	uiPlayDemo.menu.vidInitFunc = UI_PlayDemo_Init;
	uiPlayDemo.menu.keyFunc = UI_PlayDemo_KeyFunc;

	StringConcat( uiPlayDemo.hintText, "Title", TITLE_LENGTH );
	StringConcat( uiPlayDemo.hintText, uiEmptyString, TITLE_LENGTH );
	StringConcat( uiPlayDemo.hintText, "Map", MAPNAME_LENGTH );
	StringConcat( uiPlayDemo.hintText, uiEmptyString, MAPNAME_LENGTH );
	StringConcat( uiPlayDemo.hintText, "Max Clients", MAXCLIENTS_LENGTH );
	StringConcat( uiPlayDemo.hintText, uiEmptyString, MAXCLIENTS_LENGTH );

	uiPlayDemo.background.generic.id = ID_BACKGROUND;
	uiPlayDemo.background.generic.type = QMTYPE_BITMAP;
	uiPlayDemo.background.generic.flags = QMF_INACTIVE;
	uiPlayDemo.background.generic.x = 0;
	uiPlayDemo.background.generic.y = 0;
	uiPlayDemo.background.generic.width = 1024;
	uiPlayDemo.background.generic.height = 768;
	uiPlayDemo.background.pic = ART_BACKGROUND;

	uiPlayDemo.banner.generic.id = ID_BANNER;
	uiPlayDemo.banner.generic.type = QMTYPE_BITMAP;
	uiPlayDemo.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiPlayDemo.banner.generic.x = UI_BANNER_POSX;
	uiPlayDemo.banner.generic.y = UI_BANNER_POSY;
	uiPlayDemo.banner.generic.width = UI_BANNER_WIDTH;
	uiPlayDemo.banner.generic.height = UI_BANNER_HEIGHT;
	uiPlayDemo.banner.pic = ART_BANNER;

	uiPlayDemo.play.generic.id = ID_PLAY;
	uiPlayDemo.play.generic.type = QMTYPE_ACTION;
	uiPlayDemo.play.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiPlayDemo.play.generic.x = 72;
	uiPlayDemo.play.generic.y = 230;

	if ( gpGlobals->demoplayback )
	{
		uiPlayDemo.play.generic.name = "Stop";
		uiPlayDemo.play.generic.statusText = "Stop a demo playing";
	}
	else if ( gpGlobals->demorecording )
	{
		uiPlayDemo.play.generic.name = "Stop";
		uiPlayDemo.play.generic.statusText = "Stop a demo recording";
	}
	else
	{
		uiPlayDemo.play.generic.name = "Play";
		uiPlayDemo.play.generic.statusText = "Play a demo";
	}
	uiPlayDemo.play.generic.callback = UI_PlayDemo_Callback;

	uiPlayDemo.remove.generic.id = ID_DELETE;
	uiPlayDemo.remove.generic.type = QMTYPE_ACTION;
	uiPlayDemo.remove.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiPlayDemo.remove.generic.x = 72;
	uiPlayDemo.remove.generic.y = 280;
	uiPlayDemo.remove.generic.name = "Delete";
	uiPlayDemo.remove.generic.statusText = "Delete a demo";
	uiPlayDemo.remove.generic.callback = UI_PlayDemo_Callback;

	uiPlayDemo.cancel.generic.id = ID_CANCEL;
	uiPlayDemo.cancel.generic.type = QMTYPE_ACTION;
	uiPlayDemo.cancel.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiPlayDemo.cancel.generic.x = 72;
	uiPlayDemo.cancel.generic.y = 330;
	uiPlayDemo.cancel.generic.name = "Cancel";
	uiPlayDemo.cancel.generic.statusText = "Return back to main menu";
	uiPlayDemo.cancel.generic.callback = UI_PlayDemo_Callback;

	uiPlayDemo.hintMessage.generic.id = ID_TABLEHINT;
	uiPlayDemo.hintMessage.generic.type = QMTYPE_ACTION;
	uiPlayDemo.hintMessage.generic.flags = QMF_INACTIVE|QMF_SMALLFONT;
	uiPlayDemo.hintMessage.generic.color = uiColorHelp;
	uiPlayDemo.hintMessage.generic.name = uiPlayDemo.hintText;
	uiPlayDemo.hintMessage.generic.x = 360;
	uiPlayDemo.hintMessage.generic.y = 225;

	uiPlayDemo.levelShot.generic.id = ID_LEVELSHOT;
	uiPlayDemo.levelShot.generic.type = QMTYPE_BITMAP;
	uiPlayDemo.levelShot.generic.flags = QMF_INACTIVE;
	uiPlayDemo.levelShot.generic.x = LEVELSHOT_X;
	uiPlayDemo.levelShot.generic.y = LEVELSHOT_Y;
	uiPlayDemo.levelShot.generic.width = LEVELSHOT_W;
	uiPlayDemo.levelShot.generic.height = LEVELSHOT_H;
	uiPlayDemo.levelShot.generic.ownerdraw = UI_PlayDemo_Ownerdraw;

	uiPlayDemo.demosList.generic.id = ID_DEMOLIST;
	uiPlayDemo.demosList.generic.type = QMTYPE_SCROLLLIST;
	uiPlayDemo.demosList.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_SMALLFONT;
	uiPlayDemo.demosList.generic.x = 360;
	uiPlayDemo.demosList.generic.y = 255;
	uiPlayDemo.demosList.generic.width = 640;
	uiPlayDemo.demosList.generic.height = 440;
	uiPlayDemo.demosList.generic.callback = UI_PlayDemo_Callback;

	uiPlayDemo.msgBox.generic.id = ID_MSGBOX;
	uiPlayDemo.msgBox.generic.type = QMTYPE_ACTION;
	uiPlayDemo.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiPlayDemo.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiPlayDemo.msgBox.generic.x = 192;
	uiPlayDemo.msgBox.generic.y = 256;
	uiPlayDemo.msgBox.generic.width = 640;
	uiPlayDemo.msgBox.generic.height = 256;

	uiPlayDemo.promptMessage.generic.id = ID_MSGBOX;
	uiPlayDemo.promptMessage.generic.type = QMTYPE_ACTION;
	uiPlayDemo.promptMessage.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN;
	uiPlayDemo.promptMessage.generic.name = "Delete selected demo?";
	uiPlayDemo.promptMessage.generic.x = 315;
	uiPlayDemo.promptMessage.generic.y = 280;

	uiPlayDemo.yes.generic.id = ID_YES;
	uiPlayDemo.yes.generic.type = QMTYPE_ACTION;
	uiPlayDemo.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiPlayDemo.yes.generic.name = "Ok";
	uiPlayDemo.yes.generic.x = 380;
	uiPlayDemo.yes.generic.y = 460;
	uiPlayDemo.yes.generic.callback = UI_PlayDemo_Callback;

	uiPlayDemo.no.generic.id = ID_NO;
	uiPlayDemo.no.generic.type = QMTYPE_ACTION;
	uiPlayDemo.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiPlayDemo.no.generic.name = "Cancel";
	uiPlayDemo.no.generic.x = 530;
	uiPlayDemo.no.generic.y = 460;
	uiPlayDemo.no.generic.callback = UI_PlayDemo_Callback;

	UI_PlayDemo_GetDemoList();

	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.background );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.banner );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.play );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.remove );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.cancel );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.hintMessage );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.levelShot );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.demosList );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.msgBox );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.promptMessage );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.no );
	UI_AddItem( &uiPlayDemo.menu, (void *)&uiPlayDemo.yes );
}

/*
=================
UI_PlayDemo_Precache
=================
*/
void UI_PlayDemo_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_PlayDemo_Menu
=================
*/
void UI_PlayDemo_Menu( void )
{
	UI_PlayDemo_Precache();
	UI_PlayDemo_Init();

	UI_PushMenu( &uiPlayDemo.menu );
}

```

`mainui/legacy/menu_playrec.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"

#include "menu_btnsbmp_table.h"

#define ART_BANNER		"gfx/shell/head_saveload"

#define ID_BACKGROUND	0
#define ID_BANNER		1

#define ID_PLAY	  	2
#define ID_RECORD	  	3
#define ID_DONE		4

#define ID_MSGHINT		5

typedef struct
{
	menuFramework_s	menu;
	menuFramework_s fake;

	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	record;
	menuPicButton_s	play;
	menuPicButton_s	done;

	menuAction_s	hintMessage;
	char		hintText[MAX_HINT_TEXT];
} uiPlayRec_t;

static uiPlayRec_t	uiPlayRec;
bool ignore = false;

/*
=================
UI_PlayRec_Callback
=================
*/
static void UI_PlayRec_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_PLAY:
		UI_PlayDemo_Menu();
		break;
	case ID_RECORD:
		UI_RecDemo_Menu();
		break;
	case ID_DONE:
		ignore = true;
		UI_PopMenu();
		break;
	}
}

/*
=================
UI_PlayRec_Init
=================
*/
static void UI_PlayRec_Init( void )
{
	memset( &uiPlayRec, 0, sizeof( uiPlayRec_t ));

	uiPlayRec.menu.vidInitFunc = UI_PlayRec_Init;

	strcat( uiPlayRec.hintText, "During play or record demo, you can quickly stop\n" );
	strcat( uiPlayRec.hintText, "playing/recording demo by pressing " );
	strcat( uiPlayRec.hintText, KEY_KeynumToString( KEY_GetKey( "stop" )));
	strcat( uiPlayRec.hintText, ".\n" );

	uiPlayRec.background.generic.id = ID_BACKGROUND;
	uiPlayRec.background.generic.type = QMTYPE_BITMAP;
	uiPlayRec.background.generic.flags = QMF_INACTIVE;
	uiPlayRec.background.generic.x = 0;
	uiPlayRec.background.generic.y = 0;
	uiPlayRec.background.generic.width = 1024;
	uiPlayRec.background.generic.height = 768;
	uiPlayRec.background.pic = ART_BACKGROUND;

	uiPlayRec.banner.generic.id = ID_BANNER;
	uiPlayRec.banner.generic.type = QMTYPE_BITMAP;
	uiPlayRec.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiPlayRec.banner.generic.x = UI_BANNER_POSX;
	uiPlayRec.banner.generic.y = UI_BANNER_POSY;
	uiPlayRec.banner.generic.width = UI_BANNER_WIDTH;
	uiPlayRec.banner.generic.height = UI_BANNER_HEIGHT;
	uiPlayRec.banner.pic = ART_BANNER;

	uiPlayRec.play.generic.id = ID_PLAY;
	uiPlayRec.play.generic.type = QMTYPE_ACTION;
	uiPlayRec.play.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiPlayRec.play.generic.name = "Play demo";
	uiPlayRec.play.generic.statusText = "Play a specified demo";
	uiPlayRec.play.generic.x = 72;
	uiPlayRec.play.generic.y = 230;
	uiPlayRec.play.generic.callback = UI_PlayRec_Callback;

	uiPlayRec.record.generic.id = ID_RECORD;
	uiPlayRec.record.generic.type = QMTYPE_ACTION;
	uiPlayRec.record.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiPlayRec.record.generic.name = "Record demo";
	uiPlayRec.record.generic.statusText = "Record demo at this time";
	uiPlayRec.record.generic.x = 72;
	uiPlayRec.record.generic.y = 280;
	uiPlayRec.record.generic.callback = UI_PlayRec_Callback;

	uiPlayRec.done.generic.id = ID_DONE;
	uiPlayRec.done.generic.type = QMTYPE_ACTION;
	uiPlayRec.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiPlayRec.done.generic.name = "Done";
	uiPlayRec.done.generic.statusText = "Go back to the Main Menu";
	uiPlayRec.done.generic.x = 72;
	uiPlayRec.done.generic.y = 330;
	uiPlayRec.done.generic.callback = UI_PlayRec_Callback;

	uiPlayRec.hintMessage.generic.id = ID_MSGHINT;
	uiPlayRec.hintMessage.generic.type = QMTYPE_ACTION;
	uiPlayRec.hintMessage.generic.flags = QMF_INACTIVE|QMF_SMALLFONT;
	uiPlayRec.hintMessage.generic.color = uiColorHelp;
	uiPlayRec.hintMessage.generic.name = uiPlayRec.hintText;
	uiPlayRec.hintMessage.generic.x = 360;
	uiPlayRec.hintMessage.generic.y = 480;

	UI_AddItem( &uiPlayRec.menu, (void *)&uiPlayRec.background );
	UI_AddItem( &uiPlayRec.menu, (void *)&uiPlayRec.banner );
	UI_AddItem( &uiPlayRec.menu, (void *)&uiPlayRec.play );
	UI_AddItem( &uiPlayRec.menu, (void *)&uiPlayRec.record );
	UI_AddItem( &uiPlayRec.menu, (void *)&uiPlayRec.done );
	UI_AddItem( &uiPlayRec.menu, (void *)&uiPlayRec.hintMessage );
}

/*
=================
UI_PlayRec_Precache
=================
*/
void UI_PlayRec_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_PlayRec_Menu
=================
*/
void UI_PlayRec_Menu( void )
{
	UI_PlayRec_Precache();
	UI_PlayRec_Init();

	UI_PushMenu( &uiPlayRec.menu );
}

```

`mainui/legacy/menu_recdemo.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"

#define ART_BANNER	     	"gfx/shell/head_save"

#define ID_BACKGROUND	0
#define ID_BANNER		1
#define ID_RECORD		2
#define ID_DELETE		3
#define ID_CANCEL		4
#define ID_DEMOLIST		5
#define ID_TABLEHINT	6
#define ID_LEVELSHOT	7
#define ID_MSGBOX	 	8
#define ID_MSGTEXT	 	9
#define ID_YES	 	130
#define ID_NO	 	131

#define LEVELSHOT_X		72
#define LEVELSHOT_Y		400
#define LEVELSHOT_W		192
#define LEVELSHOT_H		160

#define TITLE_LENGTH	32
#define MAPNAME_LENGTH	24+TITLE_LENGTH
#define MAXCLIENTS_LENGTH	16+MAPNAME_LENGTH

typedef struct
{
	char		demoName[UI_MAXGAMES][CS_SIZE];
	char		delName[UI_MAXGAMES][CS_SIZE];
	char		demoDescription[UI_MAXGAMES][256];
	char		*demoDescriptionPtr[UI_MAXGAMES];

	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;
	menuAction_s	record;
	menuAction_s	remove;
	menuAction_s	cancel;

	menuScrollList_s	demosList;

	menuBitmap_s	levelShot;
	menuAction_s	hintMessage;
	char		hintText[MAX_HINT_TEXT];

	// prompt dialog
	menuAction_s	msgBox;
	menuAction_s	promptMessage;
	menuAction_s	yes;
	menuAction_s	no;
} uiRecDemo_t;

static uiRecDemo_t		uiRecDemo;
static const char *uiEmptyString = "";

/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}

static void UI_DeleteDialog( void )
{
	// toggle main menu between active\inactive
	// show\hide remove dialog
	uiRecDemo.record.generic.flags ^= QMF_INACTIVE; 
	uiRecDemo.remove.generic.flags ^= QMF_INACTIVE;
	uiRecDemo.cancel.generic.flags ^= QMF_INACTIVE;
	uiRecDemo.demosList.generic.flags ^= QMF_INACTIVE;

	uiRecDemo.msgBox.generic.flags ^= QMF_HIDDEN;
	uiRecDemo.promptMessage.generic.flags ^= QMF_HIDDEN;
	uiRecDemo.no.generic.flags ^= QMF_HIDDEN;
	uiRecDemo.yes.generic.flags ^= QMF_HIDDEN;

}

/*
=================
UI_RecDemo_KeyFunc
=================
*/
static const char *UI_RecDemo_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE && uiRecDemo.record.generic.flags & QMF_INACTIVE )
	{
		UI_DeleteDialog();
		return uiSoundNull;
	}
	return UI_DefaultKey( &uiRecDemo.menu, key, down );
}

/*
=================
UI_RecDemo_GetDemoList
=================
*/
static void UI_RecDemo_GetDemoList( void )
{
	char	comment[256];
	char	**filenames;
	int	i = 0, j, numFiles;

	filenames = FS_SEARCH( "demos/*.dem", &numFiles, TRUE );

	if ( CL_IsActive () && !gpGlobals->demorecording && !gpGlobals->demoplayback )
	{
		char maxClients[32];
		sprintf( maxClients, "%i", gpGlobals->maxClients );

		// create new entry for current save game
		strncpy( uiRecDemo.demoName[i], "new", CS_SIZE );
		StringConcat( uiRecDemo.demoDescription[i], gpGlobals->maptitle, TITLE_LENGTH );
		StringConcat( uiRecDemo.demoDescription[i], uiEmptyString, TITLE_LENGTH ); // fill remaining entries
		StringConcat( uiRecDemo.demoDescription[i], "New Demo", MAPNAME_LENGTH );
		StringConcat( uiRecDemo.demoDescription[i], uiEmptyString, MAPNAME_LENGTH );
		StringConcat( uiRecDemo.demoDescription[i], maxClients, MAXCLIENTS_LENGTH );
		StringConcat( uiRecDemo.demoDescription[i], uiEmptyString, MAXCLIENTS_LENGTH );
		uiRecDemo.demoDescriptionPtr[i] = uiRecDemo.demoDescription[i];
		i++;
	}

	for( j = 0; j < numFiles; i++, j++ )
	{
		if( i >= UI_MAXGAMES ) break;
		
		if( !GET_DEMO_COMMENT( filenames[j], comment ))
		{
			if( strlen( comment ))
			{
				// get name string even if not found - C:_GetComment can be mark demos
				// as <CORRUPTED> <OLD VERSION> etc
				// get name string even if not found - SV_GetComment can be mark saves
				// as <CORRUPTED> <OLD VERSION> etc
				StringConcat( uiRecDemo.demoDescription[i], uiEmptyString, TITLE_LENGTH );
				StringConcat( uiRecDemo.demoDescription[i], comment, MAPNAME_LENGTH );
				StringConcat( uiRecDemo.demoDescription[i], uiEmptyString, MAXCLIENTS_LENGTH );
				uiRecDemo.demoDescriptionPtr[i] = uiRecDemo.demoDescription[i];
				COM_FileBase( filenames[j], uiRecDemo.demoName[i] );
				COM_FileBase( filenames[j], uiRecDemo.delName[i] );
			}
			else uiRecDemo.demoDescriptionPtr[i] = NULL;
			continue;
		}

		// strip path, leave only filename (empty slots doesn't have demoname)
		COM_FileBase( filenames[j], uiRecDemo.demoName[i] );
		COM_FileBase( filenames[j], uiRecDemo.delName[i] );

		// fill demo desc
		StringConcat( uiRecDemo.demoDescription[i], comment + CS_SIZE, TITLE_LENGTH );
		StringConcat( uiRecDemo.demoDescription[i], uiEmptyString, TITLE_LENGTH );
		StringConcat( uiRecDemo.demoDescription[i], comment, MAPNAME_LENGTH );
		StringConcat( uiRecDemo.demoDescription[i], uiEmptyString, MAPNAME_LENGTH ); // fill remaining entries
		StringConcat( uiRecDemo.demoDescription[i], comment + CS_SIZE * 2, MAXCLIENTS_LENGTH );
		StringConcat( uiRecDemo.demoDescription[i], uiEmptyString, MAXCLIENTS_LENGTH );
		uiRecDemo.demoDescriptionPtr[i] = uiRecDemo.demoDescription[i];
	}

	for ( ; i < UI_MAXGAMES; i++ )
		uiRecDemo.demoDescriptionPtr[i] = NULL;
	uiRecDemo.demosList.itemNames = (const char **)uiRecDemo.demoDescriptionPtr;

	if( strlen( uiRecDemo.demoName[0] ) == 0 || !CL_IsActive () || gpGlobals->demoplayback )
		uiRecDemo.record.generic.flags |= QMF_GRAYED;
	else uiRecDemo.record.generic.flags &= ~QMF_GRAYED;

	if( strlen( uiRecDemo.delName[0] ) == 0 || !stricmp( gpGlobals->demoname, uiRecDemo.delName[uiRecDemo.demosList.curItem] ))
		uiRecDemo.remove.generic.flags |= QMF_GRAYED;
	else uiRecDemo.remove.generic.flags &= ~QMF_GRAYED;
}

/*
=================
UI_RecDemo_Callback
=================
*/
static void UI_RecDemo_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( event == QM_CHANGED )
	{
		// never overwrite existing saves, because their names was never get collision
		if( strlen( uiRecDemo.demoName[uiRecDemo.demosList.curItem] ) == 0 || !CL_IsActive() || gpGlobals->demoplayback )
			uiRecDemo.record.generic.flags |= QMF_GRAYED;
		else uiRecDemo.record.generic.flags &= ~QMF_GRAYED;

		if( strlen( uiRecDemo.delName[uiRecDemo.demosList.curItem] ) == 0 || !stricmp( gpGlobals->demoname, uiRecDemo.delName[uiRecDemo.demosList.curItem] ))
			uiRecDemo.remove.generic.flags |= QMF_GRAYED;
		else uiRecDemo.remove.generic.flags &= ~QMF_GRAYED;
		return;
	}

	if( event != QM_ACTIVATED )
		return;
	
	switch( item->id )
	{
	case ID_CANCEL:
		UI_PopMenu();
		break;
	case ID_RECORD:
		if( gpGlobals->demorecording )
		{
			CLIENT_COMMAND( FALSE, "stop" );
			uiRecDemo.record.generic.name = "Record";
			uiRecDemo.record.generic.statusText = "Record a new demo";
			uiRecDemo.remove.generic.flags &= ~QMF_GRAYED;
		}
		else if( strlen( uiRecDemo.demoName[uiRecDemo.demosList.curItem] ))
		{
			char	cmd[128];

			sprintf( cmd, "demos/%s.bmp", uiRecDemo.demoName[uiRecDemo.demosList.curItem] );
			PIC_Free( cmd );

			sprintf( cmd, "record \"%s\"\n", uiRecDemo.demoName[uiRecDemo.demosList.curItem] );
			CLIENT_COMMAND( FALSE, cmd );
			UI_CloseMenu();
		}
		break;
	case ID_NO:
	case ID_DELETE:
		UI_DeleteDialog();
		break;
	case ID_YES:
		if( strlen( uiRecDemo.delName[uiRecDemo.demosList.curItem] ))
		{
			char	cmd[128];
			sprintf( cmd, "killdemo \"%s\"\n", uiRecDemo.delName[uiRecDemo.demosList.curItem] );

			CLIENT_COMMAND( TRUE, cmd );

			sprintf( cmd, "demos/%s.bmp", uiRecDemo.delName[uiRecDemo.demosList.curItem] );
			PIC_Free( cmd );

			// restarts the menu
			UI_PopMenu();
			UI_RecDemo_Menu();
			return;
		}
		UI_DeleteDialog();
		break;
	}
}

/*
=================
UI_RecDemo_Ownerdraw
=================
*/
static void UI_RecDemo_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( item->type != QMTYPE_ACTION && item->id == ID_LEVELSHOT )
	{
		int	x, y, w, h;

		// draw the levelshot
		x = LEVELSHOT_X;
		y = LEVELSHOT_Y;
		w = LEVELSHOT_W;
		h = LEVELSHOT_H;
		
		UI_ScaleCoords( &x, &y, &w, &h );

		if( strlen( uiRecDemo.demoName[uiRecDemo.demosList.curItem] ))
		{
			char	demoshot[128];

			sprintf( demoshot, "demos/%s.bmp", uiRecDemo.demoName[uiRecDemo.demosList.curItem] );

			if( !FILE_EXISTS( demoshot ))
				UI_DrawPicAdditive( x, y, w, h, uiColorWhite, "{GRAF001" );
			else UI_DrawPic( x, y, w, h, uiColorWhite, demoshot );
		}
		else UI_DrawPicAdditive( x, y, w, h, uiColorWhite, "{GRAF001" );

		// draw the rectangle
		UI_DrawRectangle( item->x, item->y, item->width, item->height, uiInputFgColor );
	}
}

/*
=================
UI_RecDemo_Init
=================
*/
static void UI_RecDemo_Init( void )
{
	memset( &uiRecDemo, 0, sizeof( uiRecDemo_t ));

	uiRecDemo.menu.vidInitFunc = UI_RecDemo_Init;
	uiRecDemo.menu.keyFunc = UI_RecDemo_KeyFunc;

	StringConcat( uiRecDemo.hintText, "Title", TITLE_LENGTH );
	StringConcat( uiRecDemo.hintText, uiEmptyString, TITLE_LENGTH );
	StringConcat( uiRecDemo.hintText, "Map", MAPNAME_LENGTH );
	StringConcat( uiRecDemo.hintText, uiEmptyString, MAPNAME_LENGTH );
	StringConcat( uiRecDemo.hintText, "Max Clients", MAXCLIENTS_LENGTH );
	StringConcat( uiRecDemo.hintText, uiEmptyString, MAXCLIENTS_LENGTH );

	uiRecDemo.background.generic.id = ID_BACKGROUND;
	uiRecDemo.background.generic.type = QMTYPE_BITMAP;
	uiRecDemo.background.generic.flags = QMF_INACTIVE;
	uiRecDemo.background.generic.x = 0;
	uiRecDemo.background.generic.y = 0;
	uiRecDemo.background.generic.width = 1024;
	uiRecDemo.background.generic.height = 768;
	uiRecDemo.background.pic = ART_BACKGROUND;

	uiRecDemo.banner.generic.id = ID_BANNER;
	uiRecDemo.banner.generic.type = QMTYPE_BITMAP;
	uiRecDemo.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiRecDemo.banner.generic.x = UI_BANNER_POSX;
	uiRecDemo.banner.generic.y = UI_BANNER_POSY;
	uiRecDemo.banner.generic.width = UI_BANNER_WIDTH;
	uiRecDemo.banner.generic.height = UI_BANNER_HEIGHT;
	uiRecDemo.banner.pic = ART_BANNER;

	uiRecDemo.record.generic.id = ID_RECORD;
	uiRecDemo.record.generic.type = QMTYPE_ACTION;
	uiRecDemo.record.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiRecDemo.record.generic.x = 72;
	uiRecDemo.record.generic.y = 230;

	if( gpGlobals->demorecording )
	{
		uiRecDemo.record.generic.name = "Stop";
		uiRecDemo.record.generic.statusText = "Stop a demo recording";
	}
	else
	{
		uiRecDemo.record.generic.name = "Record";
		uiRecDemo.record.generic.statusText = "Record a new demo";
	}
	uiRecDemo.record.generic.callback = UI_RecDemo_Callback;

	uiRecDemo.remove.generic.id = ID_DELETE;
	uiRecDemo.remove.generic.type = QMTYPE_ACTION;
	uiRecDemo.remove.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiRecDemo.remove.generic.x = 72;
	uiRecDemo.remove.generic.y = 280;
	uiRecDemo.remove.generic.name = "Delete";
	uiRecDemo.remove.generic.statusText = "Delete a demo";
	uiRecDemo.remove.generic.callback = UI_RecDemo_Callback;

	uiRecDemo.cancel.generic.id = ID_CANCEL;
	uiRecDemo.cancel.generic.type = QMTYPE_ACTION;
	uiRecDemo.cancel.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiRecDemo.cancel.generic.x = 72;
	uiRecDemo.cancel.generic.y = 330;
	uiRecDemo.cancel.generic.name = "Cancel";
	uiRecDemo.cancel.generic.statusText = "Return back to main menu";
	uiRecDemo.cancel.generic.callback = UI_RecDemo_Callback;

	uiRecDemo.hintMessage.generic.id = ID_TABLEHINT;
	uiRecDemo.hintMessage.generic.type = QMTYPE_ACTION;
	uiRecDemo.hintMessage.generic.flags = QMF_INACTIVE|QMF_SMALLFONT;
	uiRecDemo.hintMessage.generic.color = uiColorHelp;
	uiRecDemo.hintMessage.generic.name = uiRecDemo.hintText;
	uiRecDemo.hintMessage.generic.x = 360;
	uiRecDemo.hintMessage.generic.y = 225;

	uiRecDemo.levelShot.generic.id = ID_LEVELSHOT;
	uiRecDemo.levelShot.generic.type = QMTYPE_BITMAP;
	uiRecDemo.levelShot.generic.flags = QMF_INACTIVE;
	uiRecDemo.levelShot.generic.x = LEVELSHOT_X;
	uiRecDemo.levelShot.generic.y = LEVELSHOT_Y;
	uiRecDemo.levelShot.generic.width = LEVELSHOT_W;
	uiRecDemo.levelShot.generic.height = LEVELSHOT_H;
	uiRecDemo.levelShot.generic.ownerdraw = UI_RecDemo_Ownerdraw;

	uiRecDemo.demosList.generic.id = ID_DEMOLIST;
	uiRecDemo.demosList.generic.type = QMTYPE_SCROLLLIST;
	uiRecDemo.demosList.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_SMALLFONT;
	uiRecDemo.demosList.generic.x = 360;
	uiRecDemo.demosList.generic.y = 255;
	uiRecDemo.demosList.generic.width = 640;
	uiRecDemo.demosList.generic.height = 440;
	uiRecDemo.demosList.generic.callback = UI_RecDemo_Callback;

	uiRecDemo.msgBox.generic.id = ID_MSGBOX;
	uiRecDemo.msgBox.generic.type = QMTYPE_ACTION;
	uiRecDemo.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiRecDemo.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiRecDemo.msgBox.generic.x = 192;
	uiRecDemo.msgBox.generic.y = 256;
	uiRecDemo.msgBox.generic.width = 640;
	uiRecDemo.msgBox.generic.height = 256;

	uiRecDemo.promptMessage.generic.id = ID_MSGBOX;
	uiRecDemo.promptMessage.generic.type = QMTYPE_ACTION;
	uiRecDemo.promptMessage.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN;
	uiRecDemo.promptMessage.generic.name = "Delete selected demo?";
	uiRecDemo.promptMessage.generic.x = 315;
	uiRecDemo.promptMessage.generic.y = 280;

	uiRecDemo.yes.generic.id = ID_YES;
	uiRecDemo.yes.generic.type = QMTYPE_ACTION;
	uiRecDemo.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiRecDemo.yes.generic.name = "Ok";
	uiRecDemo.yes.generic.x = 380;
	uiRecDemo.yes.generic.y = 460;
	uiRecDemo.yes.generic.callback = UI_RecDemo_Callback;

	uiRecDemo.no.generic.id = ID_NO;
	uiRecDemo.no.generic.type = QMTYPE_ACTION;
	uiRecDemo.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiRecDemo.no.generic.name = "Cancel";
	uiRecDemo.no.generic.x = 530;
	uiRecDemo.no.generic.y = 460;
	uiRecDemo.no.generic.callback = UI_RecDemo_Callback;

	UI_RecDemo_GetDemoList();

	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.background );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.banner );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.record );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.remove );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.cancel );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.hintMessage );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.levelShot );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.demosList );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.msgBox );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.promptMessage );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.no );
	UI_AddItem( &uiRecDemo.menu, (void *)&uiRecDemo.yes );
}

/*
=================
UI_RecDemo_Precache
=================
*/
void UI_RecDemo_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_RecDemo_Menu
=================
*/
void UI_RecDemo_Menu( void )
{
	if( !CheckGameDll( )) return;

	UI_RecDemo_Precache();
	UI_RecDemo_Init();

	UI_PushMenu( &uiRecDemo.menu );
}

```

`mainui/menu_advcontrols.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "kbutton.h"
#include "menu_btnsbmp_table.h"
#include "menu_strings.h"

#define ART_BANNER			"gfx/shell/head_advanced"

#define ID_BACKGROUND		0
#define ID_BANNER			1

#define ID_DONE			2
#define ID_SENSITIVITY		3
#define ID_CROSSHAIR		4
#define ID_INVERTMOUSE		5
#define ID_MOUSELOOK		6
#define ID_LOOKSPRING		7
#define ID_LOOKSTRAFE		8
#define ID_MOUSEFILTER		9
#define ID_AUTOAIM			10

typedef struct
{
	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	done;

	menuCheckBox_s	crosshair;
	menuCheckBox_s	invertMouse;
	menuCheckBox_s	mouseLook;
	menuCheckBox_s	lookSpring;
	menuCheckBox_s	lookStrafe;
	menuCheckBox_s	mouseFilter;
	menuCheckBox_s	autoaim;
	menuSlider_s	sensitivity;
} uiAdvControls_t;

static uiAdvControls_t	uiAdvControls;

/*
=================
UI_AdvControls_UpdateConfig
=================
*/
static void UI_AdvControls_UpdateConfig( void )
{
	if( uiAdvControls.invertMouse.enabled && CVAR_GET_FLOAT( "m_pitch" ) > 0 )
		CVAR_SET_FLOAT( "m_pitch", -CVAR_GET_FLOAT( "m_pitch" ));
	else if( !uiAdvControls.invertMouse.enabled && CVAR_GET_FLOAT( "m_pitch" ) < 0 )
		CVAR_SET_FLOAT( "m_pitch", fabs( CVAR_GET_FLOAT( "m_pitch" )));

	CVAR_SET_FLOAT( "crosshair", uiAdvControls.crosshair.enabled );
	CVAR_SET_FLOAT( "lookspring", uiAdvControls.lookSpring.enabled );
	CVAR_SET_FLOAT( "lookstrafe", uiAdvControls.lookStrafe.enabled );
	CVAR_SET_FLOAT( "m_filter", uiAdvControls.mouseFilter.enabled );
	CVAR_SET_FLOAT( "sv_aim", uiAdvControls.autoaim.enabled );
	CVAR_SET_FLOAT( "sensitivity", (uiAdvControls.sensitivity.curValue * 20.0f) + 0.1f );

	if( uiAdvControls.mouseLook.enabled )
	{
		uiAdvControls.lookSpring.generic.flags |= QMF_GRAYED;
		uiAdvControls.lookStrafe.generic.flags |= QMF_GRAYED;
		CLIENT_COMMAND( TRUE, "+mlook" );
	}
	else
	{
		uiAdvControls.lookSpring.generic.flags &= ~QMF_GRAYED;
		uiAdvControls.lookStrafe.generic.flags &= ~QMF_GRAYED;
		CLIENT_COMMAND( TRUE, "-mlook" );
	}
}

/*
=================
UI_AdvControls_GetConfig
=================
*/
static void UI_AdvControls_GetConfig( void )
{
	kbutton_t	*mlook;

	if( CVAR_GET_FLOAT( "m_pitch" ) < 0 )
		uiAdvControls.invertMouse.enabled = true;

	if( CVAR_GET_FLOAT( "crosshair" ))
		uiAdvControls.crosshair.enabled = 1;

	mlook = (kbutton_s *)Key_GetState( "in_mlook" );
	if( mlook && mlook->state & 1 )
		uiAdvControls.mouseLook.enabled = 1;

	if( CVAR_GET_FLOAT( "lookspring" ))
		uiAdvControls.lookSpring.enabled = 1;

	if( CVAR_GET_FLOAT( "lookstrafe" ))
		uiAdvControls.lookStrafe.enabled = 1;

	if( CVAR_GET_FLOAT( "m_filter" ))
		uiAdvControls.mouseFilter.enabled = 1;

	if( CVAR_GET_FLOAT( "sv_aim" ))
		uiAdvControls.autoaim.enabled = 1;

	uiAdvControls.sensitivity.curValue = (CVAR_GET_FLOAT( "sensitivity" ) - 0.1f) / 20.0f;

	if( uiAdvControls.mouseLook.enabled )
	{
		uiAdvControls.lookSpring.generic.flags |= QMF_GRAYED;
		uiAdvControls.lookStrafe.generic.flags |= QMF_GRAYED;
	}
	else
	{
		uiAdvControls.lookSpring.generic.flags &= ~QMF_GRAYED;
		uiAdvControls.lookStrafe.generic.flags &= ~QMF_GRAYED;
	}
}

/*
=================
UI_AdvControls_Callback
=================
*/
static void UI_AdvControls_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	switch( item->id )
	{
	case ID_CROSSHAIR:
	case ID_INVERTMOUSE:
	case ID_MOUSELOOK:
	case ID_LOOKSPRING:
	case ID_LOOKSTRAFE:
	case ID_MOUSEFILTER:
	case ID_AUTOAIM:
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
		break;
	}

	if( event == QM_CHANGED )
	{
		UI_AdvControls_UpdateConfig();
		return;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		CLIENT_COMMAND( FALSE, "trysaveconfig\n" );
		UI_PopMenu();
		break;
	}
}

/*
=================
UI_AdvControls_Init
=================
*/
static void UI_AdvControls_Init( void )
{
	memset( &uiAdvControls, 0, sizeof( uiAdvControls_t ));

	uiAdvControls.menu.vidInitFunc = UI_AdvControls_Init;

	uiAdvControls.background.generic.id = ID_BACKGROUND;
	uiAdvControls.background.generic.type = QMTYPE_BITMAP;
	uiAdvControls.background.generic.flags = QMF_INACTIVE;
	uiAdvControls.background.generic.x = 0;
	uiAdvControls.background.generic.y = 0;
	uiAdvControls.background.generic.width = uiStatic.width;
	uiAdvControls.background.generic.height = 768;
	uiAdvControls.background.pic = ART_BACKGROUND;

	uiAdvControls.banner.generic.id = ID_BANNER;
	uiAdvControls.banner.generic.type = QMTYPE_BITMAP;
	uiAdvControls.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiAdvControls.banner.generic.x = UI_BANNER_POSX;
	uiAdvControls.banner.generic.y = UI_BANNER_POSY;
	uiAdvControls.banner.generic.width = UI_BANNER_WIDTH;
	uiAdvControls.banner.generic.height = UI_BANNER_HEIGHT;
	uiAdvControls.banner.pic = ART_BANNER;

	uiAdvControls.done.generic.id	= ID_DONE;
	uiAdvControls.done.generic.type = QMTYPE_BM_BUTTON;
	uiAdvControls.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW; 
	uiAdvControls.done.generic.x = 72;
	uiAdvControls.done.generic.y = 680;
	uiAdvControls.done.generic.name = "Done";
	uiAdvControls.done.generic.statusText = "Save changes and go back to the Customize Menu";
	uiAdvControls.done.generic.callback = UI_AdvControls_Callback;

	UI_UtilSetupPicButton( &uiAdvControls.done, PC_DONE );

	uiAdvControls.crosshair.generic.id = ID_CROSSHAIR;
	uiAdvControls.crosshair.generic.type = QMTYPE_CHECKBOX;
	uiAdvControls.crosshair.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_NOTIFY|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAdvControls.crosshair.generic.x = 72;
	uiAdvControls.crosshair.generic.y = 230;
	uiAdvControls.crosshair.generic.name = "Crosshair";
	uiAdvControls.crosshair.generic.callback = UI_AdvControls_Callback;
	uiAdvControls.crosshair.generic.statusText = "Enable the weapon aiming crosshair";

	uiAdvControls.invertMouse.generic.id = ID_INVERTMOUSE;
	uiAdvControls.invertMouse.generic.type = QMTYPE_CHECKBOX;
	uiAdvControls.invertMouse.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_NOTIFY|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAdvControls.invertMouse.generic.x = 72;
	uiAdvControls.invertMouse.generic.y = 280;
	uiAdvControls.invertMouse.generic.name = MenuStrings[HINT_REVERSE_MOUSE];
	uiAdvControls.invertMouse.generic.callback = UI_AdvControls_Callback;
	uiAdvControls.invertMouse.generic.statusText = "Reverse mouse up/down axis";

	uiAdvControls.mouseLook.generic.id = ID_MOUSELOOK;
	uiAdvControls.mouseLook.generic.type = QMTYPE_CHECKBOX;
	uiAdvControls.mouseLook.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_NOTIFY|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAdvControls.mouseLook.generic.x = 72;
	uiAdvControls.mouseLook.generic.y = 330;
	uiAdvControls.mouseLook.generic.name = "Mouse look";
	uiAdvControls.mouseLook.generic.callback = UI_AdvControls_Callback;
	uiAdvControls.mouseLook.generic.statusText = "Use the mouse to look around instead of using the mouse to move";

	uiAdvControls.lookSpring.generic.id = ID_LOOKSPRING;
	uiAdvControls.lookSpring.generic.type = QMTYPE_CHECKBOX;
	uiAdvControls.lookSpring.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_NOTIFY|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAdvControls.lookSpring.generic.x = 72;
	uiAdvControls.lookSpring.generic.y = 380;
	uiAdvControls.lookSpring.generic.name = "Look spring";
	uiAdvControls.lookSpring.generic.callback = UI_AdvControls_Callback;
	uiAdvControls.lookSpring.generic.statusText = "Causes the screen to 'spring' back to looking straight ahead when you\nmove forward";

	uiAdvControls.lookStrafe.generic.id = ID_LOOKSTRAFE;
	uiAdvControls.lookStrafe.generic.type = QMTYPE_CHECKBOX;
	uiAdvControls.lookStrafe.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_NOTIFY|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAdvControls.lookStrafe.generic.x = 72;
	uiAdvControls.lookStrafe.generic.y = 430;
	uiAdvControls.lookStrafe.generic.name = "Look strafe";
	uiAdvControls.lookStrafe.generic.callback = UI_AdvControls_Callback;
	uiAdvControls.lookStrafe.generic.statusText = "In combination with your mouse look modifier, causes left-right movements\nto strafe instead of turn";

	uiAdvControls.mouseFilter.generic.id = ID_MOUSEFILTER;
	uiAdvControls.mouseFilter.generic.type = QMTYPE_CHECKBOX;
	uiAdvControls.mouseFilter.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_NOTIFY|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAdvControls.mouseFilter.generic.x = 72;
	uiAdvControls.mouseFilter.generic.y = 480;
	uiAdvControls.mouseFilter.generic.name = "Mouse filter";
	uiAdvControls.mouseFilter.generic.callback = UI_AdvControls_Callback;
	uiAdvControls.mouseFilter.generic.statusText = "Average mouse inputs over the last two frames to smooth out movements";

	uiAdvControls.autoaim.generic.id = ID_AUTOAIM;
	uiAdvControls.autoaim.generic.type = QMTYPE_CHECKBOX;
	uiAdvControls.autoaim.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_NOTIFY|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAdvControls.autoaim.generic.x = 72;
	uiAdvControls.autoaim.generic.y = 530;
	uiAdvControls.autoaim.generic.name = "Autoaim";
	uiAdvControls.autoaim.generic.callback = UI_AdvControls_Callback;
	uiAdvControls.autoaim.generic.statusText = "Let game to help you aim at enemies";

	uiAdvControls.sensitivity.generic.id = ID_SENSITIVITY;
	uiAdvControls.sensitivity.generic.type = QMTYPE_SLIDER;
	uiAdvControls.sensitivity.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW|QMF_HIGHLIGHTIFFOCUS;
	uiAdvControls.sensitivity.generic.name = MenuStrings[HINT_MOUSE_SENSE];
	uiAdvControls.sensitivity.generic.x = 72;
	uiAdvControls.sensitivity.generic.y = 625;
	uiAdvControls.sensitivity.generic.callback = UI_AdvControls_Callback;
	uiAdvControls.sensitivity.generic.statusText = "Set in-game mouse sensitivity";
	uiAdvControls.sensitivity.minValue = 0.0;
	uiAdvControls.sensitivity.maxValue = 1.0;
	uiAdvControls.sensitivity.range = 0.05f;

	UI_AdvControls_GetConfig();

	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.background );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.banner );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.done );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.crosshair );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.invertMouse );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.mouseLook );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.lookSpring );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.lookStrafe );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.mouseFilter );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.autoaim );
	UI_AddItem( &uiAdvControls.menu, (void *)&uiAdvControls.sensitivity );
}

/*
=================
UI_AdvControls_Precache
=================
*/
void UI_AdvControls_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_AdvControls_Menu
=================
*/
void UI_AdvControls_Menu( void )
{
	UI_AdvControls_Precache();
	UI_AdvControls_Init();

	UI_AdvControls_UpdateConfig();
	UI_PushMenu( &uiAdvControls.menu );
}

```

`mainui/menu_audio.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER			"gfx/shell/head_audio"

#define ID_BACKGROUND		0
#define ID_BANNER			1
#define ID_DONE			2
#define ID_SUITVOLUME		3
#define ID_SOUNDVOLUME		4
#define ID_MUSICVOLUME		5
#define ID_INTERP			6
#define ID_NODSP			7
#define ID_MUTEFOCUSLOST	8
#define ID_MSGHINT			9
#define ID_VIBRATION		10
#define ID_VIBRATION_ENABLE	11
typedef struct
{
	float		soundVolume;
	float		musicVolume;
	float		suitVolume;
} uiAudioValues_t;

static uiAudioValues_t	uiAudioInitial;

typedef struct
{
	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	done;

	menuSlider_s	soundVolume;
	menuSlider_s	musicVolume;
	menuSlider_s	suitVolume;
	menuSlider_s	vibration;
	menuCheckBox_s	lerping;
	menuCheckBox_s	noDSP;
	menuCheckBox_s	muteFocusLost;
	menuCheckBox_s	vibrationEnable;
} uiAudio_t;

static uiAudio_t		uiAudio;

/*
=================
UI_Audio_GetConfig
=================
*/
static void UI_Audio_GetConfig( void )
{
	uiAudio.soundVolume.curValue = CVAR_GET_FLOAT( "volume" );
	uiAudio.musicVolume.curValue = CVAR_GET_FLOAT( "musicvolume" );
	uiAudio.suitVolume.curValue = CVAR_GET_FLOAT( "suitvolume" );
	uiAudio.vibration.curValue = ( CVAR_GET_FLOAT( "vibration_length" ) - 0.1 ) / 4.9;

	if( CVAR_GET_FLOAT( "s_lerping" ))
		uiAudio.lerping.enabled = 1;

	if( CVAR_GET_FLOAT( "dsp_off" ))
		uiAudio.noDSP.enabled = 1;

	if( CVAR_GET_FLOAT("snd_mute_losefocus" ))
		uiAudio.muteFocusLost.enabled = 1;

	if( CVAR_GET_FLOAT("vibration_enable" ))
		uiAudio.vibrationEnable.enabled = 1;

	// save initial values
	uiAudioInitial.soundVolume = uiAudio.soundVolume.curValue;
	uiAudioInitial.musicVolume = uiAudio.musicVolume.curValue;
	uiAudioInitial.suitVolume = uiAudio.suitVolume.curValue;
}

/*
=================
UI_Audio_SetConfig
=================
*/
static void UI_Audio_SetConfig( void )
{
	CVAR_SET_FLOAT( "volume", uiAudio.soundVolume.curValue );
	CVAR_SET_FLOAT( "musicvolume", uiAudio.musicVolume.curValue );
	CVAR_SET_FLOAT( "suitvolume", uiAudio.suitVolume.curValue );
	CVAR_SET_FLOAT( "vibration_length",  0.1 + uiAudio.vibration.curValue * 4.9 );
	CVAR_SET_FLOAT( "s_lerping", uiAudio.lerping.enabled );
	CVAR_SET_FLOAT( "dsp_off", uiAudio.noDSP.enabled );
	CVAR_SET_FLOAT( "snd_mute_losefocus", uiAudio.muteFocusLost.enabled );
	CVAR_SET_FLOAT( "vibration_enable", uiAudio.vibrationEnable.enabled );
}

/*
=================
UI_Audio_UpdateConfig
=================
*/
static void UI_Audio_UpdateConfig( void )
{
	UI_Audio_SetConfig();
}

/*
=================
UI_Audio_Callback
=================
*/
static void UI_Audio_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	switch( item->id )
	{
	case ID_INTERP:
	case ID_NODSP:
	case ID_MUTEFOCUSLOST:
	case ID_VIBRATION_ENABLE:
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
		break;
	case ID_VIBRATION:
		if( event == QM_CHANGED )
		{
			static float oldvalue = 0;
			if( uiAudio.vibration.curValue != oldvalue )
			{
				CLIENT_COMMAND( 1, "vibrate 10\n" );
				oldvalue = uiAudio.vibration.curValue;
			}
		}
	}

	if( event == QM_CHANGED )
	{
		UI_Audio_UpdateConfig();		
		return;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		CLIENT_COMMAND( FALSE, "trysaveconfig\n" );
		UI_PopMenu();
		break;
	}
}

/*
=================
UI_Audio_Init
=================
*/
static void UI_Audio_Init( void )
{
	memset( &uiAudio, 0, sizeof( uiAudio_t ));

	uiAudio.menu.vidInitFunc = UI_Audio_Init;
	
	uiAudio.background.generic.id	= ID_BACKGROUND;
	uiAudio.background.generic.type = QMTYPE_BITMAP;
	uiAudio.background.generic.flags = QMF_INACTIVE;
	uiAudio.background.generic.x = 0;
	uiAudio.background.generic.y = 0;
	uiAudio.background.generic.width = uiStatic.width;
	uiAudio.background.generic.height = 768;
	uiAudio.background.pic = ART_BACKGROUND;

	uiAudio.banner.generic.id = ID_BANNER;
	uiAudio.banner.generic.type = QMTYPE_BITMAP;
	uiAudio.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiAudio.banner.generic.x = UI_BANNER_POSX;
	uiAudio.banner.generic.y = UI_BANNER_POSY;
	uiAudio.banner.generic.width = UI_BANNER_WIDTH;
	uiAudio.banner.generic.height	= UI_BANNER_HEIGHT;
	uiAudio.banner.pic = ART_BANNER;

	uiAudio.done.generic.id = ID_DONE;
	uiAudio.done.generic.type = QMTYPE_BM_BUTTON;
	uiAudio.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiAudio.done.generic.x = 72;
	uiAudio.done.generic.y = 230;
	uiAudio.done.generic.name = "Done";
	uiAudio.done.generic.statusText = "Go back to the Configuration Menu";
	uiAudio.done.generic.callback = UI_Audio_Callback;

	UI_UtilSetupPicButton( &uiAudio.done, PC_DONE );

	uiAudio.soundVolume.generic.id = ID_SOUNDVOLUME;
	uiAudio.soundVolume.generic.type = QMTYPE_SLIDER;
	uiAudio.soundVolume.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW|QMF_HIGHLIGHTIFFOCUS;
	uiAudio.soundVolume.generic.name = "Game sound volume";
	uiAudio.soundVolume.generic.x = 320;
	uiAudio.soundVolume.generic.y = 280;
	uiAudio.soundVolume.generic.callback = UI_Audio_Callback;
	uiAudio.soundVolume.generic.statusText = "Set master volume level";
	uiAudio.soundVolume.minValue	= 0.0;
	uiAudio.soundVolume.maxValue	= 1.0;
	uiAudio.soundVolume.range = 0.05f;

	uiAudio.musicVolume.generic.id = ID_MUSICVOLUME;
	uiAudio.musicVolume.generic.type = QMTYPE_SLIDER;
	uiAudio.musicVolume.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW|QMF_HIGHLIGHTIFFOCUS;
	uiAudio.musicVolume.generic.name = "Game music volume";
	uiAudio.musicVolume.generic.x = 320;
	uiAudio.musicVolume.generic.y = 340;
	uiAudio.musicVolume.generic.callback = UI_Audio_Callback;
	uiAudio.musicVolume.generic.statusText = "Set background music volume level";
	uiAudio.musicVolume.minValue = 0.0;
	uiAudio.musicVolume.maxValue = 1.0;
	uiAudio.musicVolume.range = 0.05f;

	uiAudio.suitVolume.generic.id = ID_SUITVOLUME;
	uiAudio.suitVolume.generic.type = QMTYPE_SLIDER;
	uiAudio.suitVolume.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW|QMF_HIGHLIGHTIFFOCUS;
	uiAudio.suitVolume.generic.name = "Suit volume";
	uiAudio.suitVolume.generic.x = 320;
	uiAudio.suitVolume.generic.y = 400;
	uiAudio.suitVolume.generic.callback = UI_Audio_Callback;
	uiAudio.suitVolume.generic.statusText = "Singleplayer suit volume";
	uiAudio.suitVolume.minValue = 0.0;
	uiAudio.suitVolume.maxValue = 1.0;
	uiAudio.suitVolume.range = 0.05f;

	uiAudio.lerping.generic.id = ID_INTERP;
	uiAudio.lerping.generic.type = QMTYPE_CHECKBOX;
	uiAudio.lerping.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAudio.lerping.generic.name = "Enable sound interpolation";
	uiAudio.lerping.generic.x = 320;
	uiAudio.lerping.generic.y = 470;
	uiAudio.lerping.generic.callback = UI_Audio_Callback;
	uiAudio.lerping.generic.statusText = "enable/disable interpolation on sound output";

	uiAudio.noDSP.generic.id = ID_NODSP;
	uiAudio.noDSP.generic.type = QMTYPE_CHECKBOX;
	uiAudio.noDSP.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAudio.noDSP.generic.name = "Disable DSP effects";
	uiAudio.noDSP.generic.x = 320;
	uiAudio.noDSP.generic.y = 520;
	uiAudio.noDSP.generic.callback = UI_Audio_Callback;
	uiAudio.noDSP.generic.statusText = "this disables sound processing (like echo, flanger etc)";

	uiAudio.muteFocusLost.generic.id = ID_MUTEFOCUSLOST;
	uiAudio.muteFocusLost.generic.type = QMTYPE_CHECKBOX;
	uiAudio.muteFocusLost.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAudio.muteFocusLost.generic.name = "Mute when inactive";
	uiAudio.muteFocusLost.generic.x = 320;
	uiAudio.muteFocusLost.generic.y = 570;
	uiAudio.muteFocusLost.generic.callback = UI_Audio_Callback;
	uiAudio.muteFocusLost.generic.statusText = "silence the audio when game window loses focus";

	uiAudio.vibrationEnable.generic.id = ID_VIBRATION_ENABLE;
	uiAudio.vibrationEnable.generic.type = QMTYPE_CHECKBOX;
	uiAudio.vibrationEnable.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiAudio.vibrationEnable.generic.name = "Enable vibration";
	uiAudio.vibrationEnable.generic.x = 320;
	uiAudio.vibrationEnable.generic.y = 620;
	uiAudio.vibrationEnable.generic.callback = UI_Audio_Callback;
	uiAudio.vibrationEnable.generic.statusText = "enable vibration";

	uiAudio.vibration.generic.id = ID_VIBRATION;
	uiAudio.vibration.generic.type = QMTYPE_SLIDER;
	uiAudio.vibration.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW|QMF_HIGHLIGHTIFFOCUS;
	uiAudio.vibration.generic.name = "Vibration";
	uiAudio.vibration.generic.x = 320;
	uiAudio.vibration.generic.y = 720;
	uiAudio.vibration.generic.callback = UI_Audio_Callback;
	uiAudio.vibration.generic.statusText = "Vibration length";
	uiAudio.vibration.minValue = 0.0;
	uiAudio.vibration.maxValue = 1.0;
	uiAudio.vibration.range = 0.05f;

	UI_Audio_GetConfig();

	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.background );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.banner );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.done );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.soundVolume );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.musicVolume );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.suitVolume );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.lerping );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.noDSP );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.muteFocusLost );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.vibrationEnable );
	UI_AddItem( &uiAudio.menu, (void *)&uiAudio.vibration );
}

/*
=================
UI_Audio_Precache
=================
*/
void UI_Audio_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_Audio_Menu
=================
*/
void UI_Audio_Menu( void )
{
	UI_Audio_Precache();
	UI_Audio_Init();

	UI_Audio_UpdateConfig();
	UI_PushMenu( &uiAudio.menu );
}

```

`mainui/menu_btns.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "port.h"

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_btnsbmp_table.h"

#define ART_BUTTONS_MAIN		"gfx/shell/btns_main.bmp"	// we support bmp only

const char *MenuButtons[PC_BUTTONCOUNT] =
{
	"New game",
	"Resume Game",
	"Hazard Course",
	"Configuration",
	"Load game",
	"Save/load game",
	"View readme",
	"Quit",
	"Multiplayer",
	"Easy",
	"Medium",
	"Difficult",
	"Save game",
	"Load game",
	"Cancel",
	"Game options",
	"Video",
	"Audio",
	"Controls",
	"Done",
	"Quickstart",
	"Use defaults",
	"Ok",
	"Video options",
	"Video modes",
	"Adv controls",
	"Order Half-life",
	"Delete",
	"Internet games",
	"Chat rooms",
	"Lan games",
	"Customize",
	"Skip",
	"Exit",
	"Connect",
	"Refresh",
	"Filter",
	"Filter",
	"Create",
	"Create game",
	"Chat rooms",
	"List rooms",
	"Search",
	"Servers",
	"Join",
	"Find",
	"Create room",
	"Join game",
	"Search games",
	"Find game",
	"Start game",
	"View game info",
	"Update",
	"Add server",
	"Disconnect",
	"Console",
	"Content control",
	"Update",
	"Visit won",
	"Previews",
	"Adv options",
	"3D info site",
	"Custom Game",
	"Activate",
	"Install",
	"Visit web site",
	"Refresh list",
	"Deactivate",
	"Adv options",
	"Spectate game",
	"Spectate games"
};

typedef struct bmp_s
{
	//char magic[2];	//Useless.
	unsigned int	filesz;
	unsigned short	creator1;
	unsigned short	creator2;
	unsigned int	bmp_offset;
	unsigned int	biSize;
	unsigned int	biWidth;
	unsigned int	biHeight;
	unsigned short	biPlanes;
	unsigned short	biBitCount;
	unsigned int	biCompression;
	unsigned int	biSizeImage;
	unsigned int	biXPelsPerMeter;
	unsigned int	biYPelsPerMeter;
	unsigned int	biClrUsed;
	unsigned int	biClrImportant;
}bmp_t;

/*
=================
UI_LoadBmpButtons
=================
*/
void UI_LoadBmpButtons( void )
{
	memset( uiStatic.buttonsPics, 0, sizeof( uiStatic.buttonsPics ));

	int bmp_len_holder;
	byte *bmp_buffer = (byte*)LOAD_FILE( ART_BUTTONS_MAIN, &bmp_len_holder );

	if( !bmp_buffer || !bmp_len_holder )
	{
		Con_Printf( "UI_LoadBmpButtons: btns_main.bmp not found\n" );
		return;
	}

	bmp_t bhdr;
	memcpy( &bhdr, &bmp_buffer[sizeof( short )], sizeof( bmp_t ));
	
	int pallete_sz = bhdr.bmp_offset - sizeof( bmp_t ) - sizeof( short );

	uiStatic.buttons_height = ( bhdr.biBitCount == 4 ) ? 80 : 78; // bugstompers issues
	uiStatic.buttons_width = bhdr.biWidth - 3; // make some offset

	int stride = bhdr.biWidth * bhdr.biBitCount / 8;
	int cutted_img_sz = ((stride + 3 ) & ~3) * uiStatic.buttons_height;
	int CuttedBmpSize = sizeof( bmp_t ) + sizeof( short ) + pallete_sz + cutted_img_sz;
	byte *img_data = &bmp_buffer[bmp_len_holder-cutted_img_sz];

	if ( bhdr.biBitCount <= 8 )
	{
		byte* pallete=&bmp_buffer[sizeof( bmp_t ) + sizeof( short )];
		byte* firstpixel_col=&pallete[img_data[0]*4];
		firstpixel_col[0]=firstpixel_col[1]=firstpixel_col[2]=0;
	}

	// determine buttons count by image height...
	// int pic_count = ( pInfoHdr->biHeight == 5538 ) ? PC_BUTTONCOUNT
	int pic_count = ( bhdr.biHeight / 78 );

	bhdr.biHeight = 78;     //uiStatic.buttons_height;
	bhdr.filesz = CuttedBmpSize;
	bhdr.biSizeImage = CuttedBmpSize - bhdr.bmp_offset;

	char fname[256];
	byte *raw_img_buff = (byte *)MALLOC( sizeof( bmp_t ) + sizeof( short ) + pallete_sz + cutted_img_sz );

	for( int i = 0; i < pic_count; i++ )
	{
		int offset = sizeof( short );
		sprintf( fname, "#btns_%d.bmp", i );

		memcpy( raw_img_buff, bmp_buffer, offset);
		
		memcpy( &raw_img_buff[offset], &bhdr, sizeof( bmp_t ));
		offset += sizeof( bmp_t );

		if( bhdr.biBitCount <= 8 )
		{
			memcpy( &raw_img_buff[offset], &bmp_buffer[offset], pallete_sz );
			offset += pallete_sz;
		}

		memcpy( &raw_img_buff[offset], img_data, cutted_img_sz );

		// upload image into viedo memory
		uiStatic.buttonsPics[i] = PIC_Load( fname, raw_img_buff, CuttedBmpSize );

		img_data -= cutted_img_sz;
	}

	FREE( raw_img_buff );
	FREE_FILE( bmp_buffer );
}

```

`mainui/menu_btnsbmp_table.h`:

```h
/*
menu_btnsbmp_table.h - btns_main layout
Copyright (C) 2011 CrazyRussian

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef MENU_BTNSBMP_TABLE_H
#define MENU_BTNSBMP_TABLE_H
	
enum
{
	PC_NEW_GAME = 0,
	PC_RESUME_GAME,
	PC_HAZARD_COURSE,
	PC_CONFIG,
	PC_LOAD_GAME,
	PC_SAVE_LOAD_GAME,
	PC_VIEW_README,
	PC_QUIT,
	PC_MULTIPLAYER,
	PC_EASY,
	PC_MEDIUM,
	PC_DIFFICULT,
	PC_SAVE_GAME,
	PC_LOAD_GAME2,
	PC_CANCEL,
	PC_GAME_OPTIONS,
	PC_VIDEO,
	PC_AUDIO,
	PC_CONTROLS,
	PC_DONE,
	PC_QUICKSTART,
	PC_USE_DEFAULTS,
	PC_OK,
	PC_VID_OPT,
	PC_VID_MODES,
	PC_ADV_CONTROLS,
	PC_ORDER_HL,
	PC_DELETE,
	PC_INET_GAME,
	PC_CHAT_ROOMS,
	PC_LAN_GAME,
	PC_CUSTOMIZE,
	PC_SKIP,
	PC_EXIT,
	PC_CONNECT,
	PC_REFRESH,
	PC_FILTER,
	PC_FILTER2,
	PC_CREATE,
	PC_CREATE_GAME,
	PC_CHAT_ROOMS2,
	PC_LIST_ROOMS,
	PC_SEARCH,
	PC_SERVERS,
	PC_JOIN,
	PC_FIND,
	PC_CREATE_ROOM,
	PC_JOIN_GAME,
	PC_SEARCH_GAMES,
	PC_FIND_GAME,
	PC_START_GAME,
	PC_VIEW_GAME_INFO,
	PC_UPDATE,
	PC_ADD_SERVER,
	PC_DISCONNECT,
	PC_CONSOLE,
	PC_CONTENT_CONTROL,
	PC_UPDATE2,
	PC_VISIT_WON,
	PC_PREVIEWS,
	PC_ADV_OPT,
	PC_3DINFO_SITE,
	PC_CUSTOM_GAME,
	PC_ACTIVATE,
	PC_INSTALL,
	PC_VISIT_WEB_SITE,
	PC_REFRESH_LIST,
	PC_DEACTIVATE,
	PC_ADV_OPT2,
	PC_SPECTATE_GAME,
	PC_SPECTATE_GAMES,
	PC_BUTTONCOUNT		// must be last
};

#define BUTTON_NOFOCUS	0 
#define BUTTON_FOCUS	1
#define BUTTON_PRESSED	2

extern const char *MenuButtons[PC_BUTTONCOUNT];

inline int PicButtonWidth( int pic_id )
{
	if( pic_id < 0 || pic_id > PC_BUTTONCOUNT )
		return 0;
	
	return strlen( MenuButtons[pic_id] );
}

#endif//MENU_BTNSBMP_TABLE_H

```

`mainui/menu_configuration.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER	     	"gfx/shell/head_config"

#define ID_BACKGROUND    	0
#define ID_BANNER	     	1

#define ID_CONTROLS   2
#define ID_AUDIO      3
#define ID_VIDEO      4
#define ID_UPDATE     5
#define ID_DONE       6
#define ID_MSGBOX     7
#define ID_MSGTEXT    8
#define ID_TOUCH      9
#define ID_GAMEPAD    10
#define ID_YES        130
#define ID_NO         131

typedef struct
{
	menuFramework_s	menu;
	
	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	controls;
	menuPicButton_s	audio;
	menuPicButton_s	video;
	menuPicButton_s	touch;
	menuPicButton_s	update;
	menuPicButton_s gamepad;
	menuPicButton_s	done;

	// update dialog
	menuAction_s	msgBox;
	menuAction_s	updatePrompt;
	menuPicButton_s	yes;
	menuPicButton_s	no;
} uiOptions_t;

static uiOptions_t		uiOptions;

/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}

static void UI_CheckUpdatesDialog( void )
{
	// toggle configuration menu between active\inactive
	// show\hide CheckUpdates dialog
	uiOptions.controls.generic.flags ^= QMF_INACTIVE; 
	uiOptions.audio.generic.flags ^= QMF_INACTIVE;
	uiOptions.video.generic.flags ^= QMF_INACTIVE;
	uiOptions.touch.generic.flags ^= QMF_INACTIVE;
	uiOptions.update.generic.flags ^= QMF_INACTIVE;
	uiOptions.done.generic.flags ^= QMF_INACTIVE;

	uiOptions.msgBox.generic.flags ^= QMF_HIDDEN;
	uiOptions.updatePrompt.generic.flags ^= QMF_HIDDEN;
	uiOptions.no.generic.flags ^= QMF_HIDDEN;
	uiOptions.yes.generic.flags ^= QMF_HIDDEN;

}

/*
=================
UI_Options_KeyFunc
=================
*/
static const char *UI_Options_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE && uiOptions.done.generic.flags & QMF_INACTIVE )
	{
		UI_CheckUpdatesDialog ();	// cancel 'check updates' dialog
		return uiSoundNull;
	}
	return UI_DefaultKey( &uiOptions.menu, key, down );
}

/*
=================
UI_Options_Callback
=================
*/
static void UI_Options_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		UI_PopMenu();
		break;
	case ID_CONTROLS:
		UI_Controls_Menu();
		break;
	case ID_AUDIO:
		UI_Audio_Menu();
		break;
	case ID_VIDEO:
		UI_VidOptions_Menu();
		break;
	case ID_TOUCH:
		UI_Touch_Menu();
		break;
	case ID_GAMEPAD:
		UI_GamePad_Menu();
		break;
	case ID_UPDATE:
		UI_CheckUpdatesDialog();
		break;
	case ID_YES:
		SHELL_EXECUTE( gMenu.m_gameinfo.update_url, NULL, TRUE );
		break;
	case ID_NO:
		UI_CheckUpdatesDialog();
		break;
	}
}

/*
=================
UI_Options_Init
=================
*/
static void UI_Options_Init( void )
{
	memset( &uiOptions, 0, sizeof( uiOptions_t ));

	uiOptions.menu.vidInitFunc = UI_Options_Init;
	uiOptions.menu.keyFunc = UI_Options_KeyFunc;

	uiOptions.background.generic.id = ID_BACKGROUND;
	uiOptions.background.generic.type = QMTYPE_BITMAP;
	uiOptions.background.generic.flags = QMF_INACTIVE;
	uiOptions.background.generic.x = 0;
	uiOptions.background.generic.y = 0;
	uiOptions.background.generic.width = uiStatic.width;
	uiOptions.background.generic.height = 768;
	uiOptions.background.pic = ART_BACKGROUND;

	uiOptions.banner.generic.id = ID_BANNER;
	uiOptions.banner.generic.type = QMTYPE_BITMAP;
	uiOptions.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiOptions.banner.generic.x = UI_BANNER_POSX;
	uiOptions.banner.generic.y = UI_BANNER_POSY;
	uiOptions.banner.generic.width = UI_BANNER_WIDTH;
	uiOptions.banner.generic.height = UI_BANNER_HEIGHT;
	uiOptions.banner.pic = ART_BANNER;

	uiOptions.controls.generic.id	= ID_CONTROLS;
	uiOptions.controls.generic.type = QMTYPE_BM_BUTTON;
	uiOptions.controls.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiOptions.controls.generic.x = 72;
	uiOptions.controls.generic.y = 230;
	uiOptions.controls.generic.name = "Controls";
	uiOptions.controls.generic.statusText = "Change keyboard and mouse settings";
	uiOptions.controls.generic.callback = UI_Options_Callback;

	UI_UtilSetupPicButton( &uiOptions.controls, PC_CONTROLS );

	uiOptions.audio.generic.id = ID_AUDIO;
	uiOptions.audio.generic.type = QMTYPE_BM_BUTTON;
	uiOptions.audio.generic.flags	= QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiOptions.audio.generic.x = 72;
	uiOptions.audio.generic.y = 280;
	uiOptions.audio.generic.name = "Audio";
	uiOptions.audio.generic.statusText = "Change sound volume and quality";
	uiOptions.audio.generic.callback = UI_Options_Callback;

	UI_UtilSetupPicButton( &uiOptions.audio, PC_AUDIO );

	uiOptions.video.generic.id = ID_VIDEO;
	uiOptions.video.generic.type = QMTYPE_BM_BUTTON;
	uiOptions.video.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiOptions.video.generic.x = 72;
	uiOptions.video.generic.y = 330;
	uiOptions.video.generic.name = "Video";
	uiOptions.video.generic.statusText = "Change screen size, video mode and gamma";
	uiOptions.video.generic.callback = UI_Options_Callback;

	UI_UtilSetupPicButton( &uiOptions.video, PC_VIDEO );

	uiOptions.touch.generic.id = ID_TOUCH;
	uiOptions.touch.generic.type = QMTYPE_BM_BUTTON;
	uiOptions.touch.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY | QMF_ACT_ONRELEASE;
	uiOptions.touch.generic.x = 72;
	uiOptions.touch.generic.y = 380;
	uiOptions.touch.generic.name = "Touch";
	uiOptions.touch.generic.statusText = "Change touch settings and buttons";
	uiOptions.touch.generic.callback = UI_Options_Callback;
	uiOptions.touch.pic = PIC_Load("gfx/shell/btn_touch");

	//UI_UtilSetupPicButton( &uiOptions.video, PC_TOUCH );

	uiOptions.gamepad.generic.id = ID_GAMEPAD;
	uiOptions.gamepad.generic.type = QMTYPE_BM_BUTTON;
	uiOptions.gamepad.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY | QMF_ACT_ONRELEASE;
	uiOptions.gamepad.generic.x = 72;
	uiOptions.gamepad.generic.y = 430;
	uiOptions.gamepad.generic.name = "Gamepad";
	uiOptions.gamepad.generic.statusText = "Change gamepad axis and button settings";
	uiOptions.gamepad.generic.callback = UI_Options_Callback;
	uiOptions.gamepad.pic = PIC_Load("gfx/shell/btn_gamepad");

	//UI_UtilSetupPicButton( &uiOptions.video, PC_TOUCH );

	uiOptions.update.generic.id = ID_UPDATE;
	uiOptions.update.generic.type = QMTYPE_BM_BUTTON;
	uiOptions.update.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiOptions.update.generic.x = 72;
	uiOptions.update.generic.y = 480;
	uiOptions.update.generic.name = "Update";
	uiOptions.update.generic.statusText = "Donwload the latest version of the Xash3D engine";
	uiOptions.update.generic.callback = UI_Options_Callback;
	UI_UtilSetupPicButton(&uiOptions.update,PC_UPDATE);

	if( !strlen( gMenu.m_gameinfo.update_url ))
		uiOptions.update.generic.flags |= QMF_GRAYED;

	uiOptions.done.generic.id = ID_DONE;
	uiOptions.done.generic.type = QMTYPE_BM_BUTTON;
	uiOptions.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiOptions.done.generic.x = 72;
	uiOptions.done.generic.y = 530;
	uiOptions.done.generic.name = "Done";
	uiOptions.done.generic.statusText = "Go back to the Main Menu";
	uiOptions.done.generic.callback = UI_Options_Callback;

	UI_UtilSetupPicButton( &uiOptions.done, PC_DONE );

	uiOptions.msgBox.generic.id = ID_MSGBOX;
	uiOptions.msgBox.generic.type = QMTYPE_ACTION;
	uiOptions.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiOptions.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiOptions.msgBox.generic.x = DLG_X + 192;
	uiOptions.msgBox.generic.y = 256;
	uiOptions.msgBox.generic.width = 640;
	uiOptions.msgBox.generic.height = 256;

	uiOptions.updatePrompt.generic.id = ID_MSGBOX;
	uiOptions.updatePrompt.generic.type = QMTYPE_ACTION;
	uiOptions.updatePrompt.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN;
	uiOptions.updatePrompt.generic.name = "Check the Internet for updates?";
	uiOptions.updatePrompt.generic.x = DLG_X + 248;
	uiOptions.updatePrompt.generic.y = 280;

	uiOptions.yes.generic.id = ID_YES;
	uiOptions.yes.generic.type = QMTYPE_BM_BUTTON;
	uiOptions.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiOptions.yes.generic.name = "Ok";
	uiOptions.yes.generic.x = DLG_X + 380;
	uiOptions.yes.generic.y = 460;
	uiOptions.yes.generic.callback = UI_Options_Callback;

	UI_UtilSetupPicButton( &uiOptions.yes, PC_OK );

	uiOptions.no.generic.id = ID_NO;
	uiOptions.no.generic.type = QMTYPE_BM_BUTTON;
	uiOptions.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiOptions.no.generic.name = "Cancel";
	uiOptions.no.generic.x = DLG_X + 530;
	uiOptions.no.generic.y = 460;
	uiOptions.no.generic.callback = UI_Options_Callback;

	UI_UtilSetupPicButton( &uiOptions.no, PC_CANCEL );

	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.background );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.banner );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.done );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.controls );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.audio );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.video );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.touch );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.gamepad );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.update );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.msgBox );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.updatePrompt );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.no );
	UI_AddItem( &uiOptions.menu, (void *)&uiOptions.yes );
}

/*
=================
UI_Options_Precache
=================
*/
void UI_Options_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_Options_Menu
=================
*/
void UI_Options_Menu( void )
{
	UI_Options_Precache();
	UI_Options_Init();
	
	UI_PushMenu( &uiOptions.menu );
}

```

`mainui/menu_controls.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER		"gfx/shell/head_controls"

#define ID_BACKGROUND	0
#define ID_BANNER		1
#define ID_DEFAULTS		2
#define ID_ADVANCED		3
#define ID_DONE		4
#define ID_CANCEL		5
#define ID_KEYLIST		6
#define ID_TABLEHINT	7
#define ID_MSGBOX1	 	8
#define ID_MSGBOX2	 	9
#define ID_MSGTEXT	 	10
#define ID_PROMPT	 	11
#define ID_YES	 	130
#define ID_NO	 	131

#define MAX_KEYS		256
#define CMD_LENGTH		38
#define KEY1_LENGTH		20+CMD_LENGTH
#define KEY2_LENGTH		20+KEY1_LENGTH

typedef struct
{
	char		keysBind[MAX_KEYS][CMD_LENGTH];
	char		firstKey[MAX_KEYS][20];
	char		secondKey[MAX_KEYS][20];
	char		keysDescription[MAX_KEYS][256];
	char		*keysDescriptionPtr[MAX_KEYS];

	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;

	// state toggle by UI_ToggleMainControlsState
	menuPicButton_s	defaults;
	menuPicButton_s	advanced;
	menuPicButton_s	done;
	menuPicButton_s	cancel;
	menuScrollList_s keysList;

	// redefine key wait dialog
	menuAction_s	msgBox1;	// small msgbox
	menuAction_s	msgBox2;	// large msgbox
	menuAction_s	dlgMessage;
	menuAction_s	promptMessage;
	menuPicButton_s	yes;
	menuPicButton_s	no;

	menuAction_s	hintMessage;
	char			hintText[MAX_HINT_TEXT];
	int				bind_grab;	// waiting for key input
} uiControls_t;

static uiControls_t		uiControls;
extern bool		hold_button_stack;

static void UI_ToggleMainControlsState( void )
{
	// toggle main menu between active\inactive
	uiControls.defaults.generic.flags ^= QMF_INACTIVE;
	uiControls.advanced.generic.flags ^= QMF_INACTIVE;
	uiControls.done.generic.flags ^= QMF_INACTIVE;
	uiControls.cancel.generic.flags ^= QMF_INACTIVE;
	uiControls.keysList.generic.flags ^= QMF_INACTIVE;
}

static void UI_ResetToDefaultsDialog( void )
{
	// toggle main menu between active\inactive
	UI_ToggleMainControlsState();

	// show\hide reset to defaults dialog
	uiControls.msgBox2.generic.flags ^= QMF_HIDDEN;
	uiControls.promptMessage.generic.flags ^= QMF_HIDDEN;
	uiControls.yes.generic.flags ^= QMF_HIDDEN;
	uiControls.no.generic.flags ^= QMF_HIDDEN;
}

/*
=================
UI_Controls_GetKeyBindings
=================
*/
static void UI_Controls_GetKeyBindings( const char *command, int *twoKeys )
{
	int		i, count = 0;
	const char	*b;

	twoKeys[0] = twoKeys[1] = -1;

	for( i = 0; i < 256; i++ )
	{
		b = KEY_GetBinding( i );
		if( !b ) continue;

		if( !stricmp( command, b ))
		{
			twoKeys[count] = i;
			count++;

			if( count == 2 ) break;
		}
	}

	// swap keys if needed
	if( twoKeys[0] != -1 && twoKeys[1] != -1 )
	{
		int tempKey = twoKeys[1];
		twoKeys[1] = twoKeys[0];
		twoKeys[0] = tempKey;
	}
}

void UI_UnbindCommand( const char *command )
{
	int i, l;
	const char *b;

	l = strlen( command );

	for( i = 0; i < 256; i++ )
	{
		b = KEY_GetBinding( i );
		if( !b ) continue;

		if( !strncmp( b, command, l ))
			KEY_SetBinding( i, "" );
	}
}

static void UI_Controls_ParseKeysList( void )
{
	char *afile = (char *)LOAD_FILE( "gfx/shell/kb_act.lst", NULL );
	char *pfile = afile;
	char token[1024];
	int i = 0;

	if( !afile )
	{
		for( ; i < MAX_KEYS; i++ ) uiControls.keysDescriptionPtr[i] = NULL;
		uiControls.keysList.itemNames = (const char **)uiControls.keysDescriptionPtr;
	
		Con_Printf( "UI_Parse_KeysList: kb_act.lst not found\n" );
		return;
	}

	while(( pfile = COM_ParseFile( pfile, token )) != NULL )
	{
		char	str[128];

		if( !stricmp( token, "blank" ))
		{
			// seperator
			pfile = COM_ParseFile( pfile, token );
			if( !pfile ) break;	// technically an error

			snprintf( str, sizeof(str), "^6%s^7", token );	// enable uiPromptTextColor
			StringConcat( uiControls.keysDescription[i], str, strlen( str ) + 1 );
			AddSpaces( uiControls.keysDescription[i], 256 );	// empty
			uiControls.keysDescriptionPtr[i] = uiControls.keysDescription[i];
			strcpy( uiControls.keysBind[i], "" );
			strcpy( uiControls.firstKey[i], "" );
			strcpy( uiControls.secondKey[i], "" );
			i++;
		}
		else
		{
			// key definition
			int	keys[2];

			UI_Controls_GetKeyBindings( token, keys );
			strncpy( uiControls.keysBind[i], token, sizeof( uiControls.keysBind[i] ));

			pfile = COM_ParseFile( pfile, token );
			if( !pfile ) break; // technically an error

			snprintf( str, sizeof( str ), "^6%s^7", token );	// enable uiPromptTextColor

			if( keys[0] == -1 ) strcpy( uiControls.firstKey[i], "" );
			else strncpy( uiControls.firstKey[i], KEY_KeynumToString( keys[0] ), sizeof( uiControls.firstKey[i] ));

			if( keys[1] == -1 ) strcpy( uiControls.secondKey[i], "" ); 
			else strncpy( uiControls.secondKey[i], KEY_KeynumToString( keys[1] ), sizeof( uiControls.secondKey[i] ));

			StringConcat( uiControls.keysDescription[i], str, CMD_LENGTH );
			AddSpaces( uiControls.keysDescription[i], CMD_LENGTH );

			// HACKHACK this color should be get from kb_keys.lst
			if( !strnicmp( uiControls.firstKey[i], "MOUSE", 5 ))
				snprintf( str, sizeof( str ), "^5%s^7", uiControls.firstKey[i] );	// cyan
			else snprintf( str, sizeof( str ), "^3%s^7", uiControls.firstKey[i] );	// yellow
			StringConcat( uiControls.keysDescription[i], str, KEY1_LENGTH );
			AddSpaces( uiControls.keysDescription[i], KEY1_LENGTH );

			// HACKHACK this color should be get from kb_keys.lst
			if( !strnicmp( uiControls.secondKey[i], "MOUSE", 5 ))
				snprintf( str, sizeof( str ), "^5%s^7", uiControls.secondKey[i] );// cyan
			else snprintf( str, sizeof( str ), "^3%s^7", uiControls.secondKey[i] );	// yellow

			StringConcat( uiControls.keysDescription[i], str, KEY2_LENGTH );
			AddSpaces( uiControls.keysDescription[i],KEY2_LENGTH );
			uiControls.keysDescriptionPtr[i] = uiControls.keysDescription[i];
			i++;
		}
	}

	FREE_FILE( afile );

	for( ; i < MAX_KEYS; i++ ) uiControls.keysDescriptionPtr[i] = NULL;
	uiControls.keysList.itemNames = (const char **)uiControls.keysDescriptionPtr;
}

static void UI_PromptDialog( void )
{
	// toggle main menu between active\inactive
	UI_ToggleMainControlsState();

	// show\hide quit dialog
	uiControls.msgBox1.generic.flags ^= QMF_HIDDEN;
	uiControls.dlgMessage.generic.flags ^= QMF_HIDDEN;
}

static void UI_Controls_RestartMenu( void )
{
	int lastSelectedKey = uiControls.keysList.curItem;
	int lastTopItem = uiControls.keysList.topItem;
	int cursor = uiControls.menu.cursor;
	int cursorPrev = uiControls.menu.cursorPrev;

	// HACK to prevent mismatch anim stack
	hold_button_stack = true;

	// restarts the menu
	UI_PopMenu();
	UI_Controls_Menu();

	hold_button_stack = false;

	// restore last key and top item
	uiControls.menu.cursor = cursor;
	uiControls.menu.cursorPrev = cursorPrev;
	uiControls.keysList.curItem = lastSelectedKey;
	uiControls.keysList.topItem = lastTopItem;
}

static void UI_Controls_ResetKeysList( void )
{
	char *afile = (char *)LOAD_FILE( "gfx/shell/kb_def.lst", NULL );
	char *pfile = afile;
	char token[1024];

	if( !afile )
	{
		Con_Printf( "UI_Parse_KeysList: kb_act.lst not found\n" );
		return;
	}

	while(( pfile = COM_ParseFile( pfile, token )) != NULL )
	{
		char	key[32];

		strncpy( key, token, sizeof( key ));

		pfile = COM_ParseFile( pfile, token );
		if( !pfile ) break;	// technically an error

		char	cmd[128];

		if( key[0] == '\\' && key[1] == '\\' )
		{
			key[0] = '\\';
			key[1] = '\0';
		}

		UI_UnbindCommand( token );

		snprintf( cmd, sizeof( cmd ), "bind \"%s\" \"%s\"\n", key, token );
		CLIENT_COMMAND( TRUE, cmd );
	}

	FREE_FILE( afile );
	UI_Controls_RestartMenu ();
}

/*
=================
UI_Controls_KeyFunc
=================
*/
static const char *UI_Controls_KeyFunc( int key, int down )
{
	char	cmd[128];

	if( uiControls.msgBox1.generic.flags & QMF_HIDDEN )
	{
		if( down && key == K_ESCAPE && uiControls.defaults.generic.flags & QMF_INACTIVE )
		{
			UI_ResetToDefaultsDialog();
			return uiSoundNull;
		}
	}
	
	if( down )
	{
		if( uiControls.bind_grab )	// assume we are in grab-mode
		{
			// defining a key
			if( key == '`' || key == '~' )
			{
				return uiSoundBuzz;
			}
			else if( key != K_ESCAPE )
			{
				const char *bindName = uiControls.keysBind[uiControls.keysList.curItem];
				sprintf( cmd, "bind \"%s\" \"%s\"\n", KEY_KeynumToString( key ), bindName );
				CLIENT_COMMAND( TRUE, cmd );
			}

			uiControls.bind_grab = false;
			UI_Controls_RestartMenu();

			return uiSoundLaunch;
		}

		if( down
			&& ( key == K_ENTER || key == K_AUX1 || key == K_AUX31 || key == K_AUX32 )
			&& uiControls.dlgMessage.generic.flags & QMF_HIDDEN
			&& UI_IsCurrentSelected( &uiControls.keysList ) ) // ENTER, A or SELECT
		{
			if( !strlen( uiControls.keysBind[uiControls.keysList.curItem] ))
			{
				// probably it's a seperator
				return uiSoundBuzz;
			}

			// entering to grab-mode
			const char *bindName = uiControls.keysBind[uiControls.keysList.curItem];
			int keys[2];
	
			UI_Controls_GetKeyBindings( bindName, keys );
			if( keys[1] != -1 ) UI_UnbindCommand( bindName );
			uiControls.bind_grab = true;

			UI_PromptDialog();	// show prompt
			return uiSoundKey;
		}

		if(( key == K_BACKSPACE || key == K_DEL || key == K_AUX30 )
		   && uiControls.dlgMessage.generic.flags & QMF_HIDDEN
		   && UI_IsCurrentSelected( &uiControls.keysList ) )
		{
			// delete bindings

			if( !strlen( uiControls.keysBind[uiControls.keysList.curItem] ))
			{
				// probably it's a seperator
				return uiSoundNull;
			}

			const char *bindName = uiControls.keysBind[uiControls.keysList.curItem];
			UI_UnbindCommand( bindName );
			UI_StartSound( uiSoundRemoveKey );
			UI_Controls_RestartMenu();

			return uiSoundNull;
		}
	}
	return UI_DefaultKey( &uiControls.menu, key, down );
}

/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}

/*
=================
UI_Controls_Callback
=================
*/
static void UI_Controls_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		CLIENT_COMMAND( FALSE, "trysaveconfig\n" );
	case ID_CANCEL:
		UI_PopMenu();
		break;
	case ID_DEFAULTS:
	case ID_NO:
		UI_ResetToDefaultsDialog ();
		break;
	case ID_YES:
		UI_Controls_ResetKeysList ();
		break;
	case ID_ADVANCED:
		UI_AdvControls_Menu();
		break;
	}
}

/*
=================
UI_Controls_Init
=================
*/
static void UI_Controls_Init( void )
{
	memset( &uiControls, 0, sizeof( uiControls_t ));

	uiControls.menu.vidInitFunc = UI_Controls_Init;
	uiControls.menu.keyFunc = UI_Controls_KeyFunc;

	StringConcat( uiControls.hintText, "Action", CMD_LENGTH );
	AddSpaces( uiControls.hintText, CMD_LENGTH-4 );
	StringConcat( uiControls.hintText, "Key/Button", KEY1_LENGTH );
	AddSpaces( uiControls.hintText, KEY1_LENGTH-8 );
	StringConcat( uiControls.hintText, "Alternate", KEY2_LENGTH );
	AddSpaces( uiControls.hintText, KEY2_LENGTH );

	uiControls.background.generic.id = ID_BACKGROUND;
	uiControls.background.generic.type = QMTYPE_BITMAP;
	uiControls.background.generic.flags = QMF_INACTIVE;
	uiControls.background.generic.x = 0;
	uiControls.background.generic.y = 0;
	uiControls.background.generic.width = uiStatic.width;
	uiControls.background.generic.height = 768;
	uiControls.background.pic = ART_BACKGROUND;

	uiControls.banner.generic.id = ID_BANNER;
	uiControls.banner.generic.type = QMTYPE_BITMAP;
	uiControls.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiControls.banner.generic.x = UI_BANNER_POSX;
	uiControls.banner.generic.y = UI_BANNER_POSY;
	uiControls.banner.generic.width = UI_BANNER_WIDTH;
	uiControls.banner.generic.height = UI_BANNER_HEIGHT;
	uiControls.banner.pic = ART_BANNER;

	uiControls.defaults.generic.id = ID_DEFAULTS;
	uiControls.defaults.generic.type = QMTYPE_BM_BUTTON;
	uiControls.defaults.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiControls.defaults.generic.x = 72;
	uiControls.defaults.generic.y = 230;
	uiControls.defaults.generic.name = "Use defaults";
	uiControls.defaults.generic.statusText = "Reset all buttons binding to their default values";
	uiControls.defaults.generic.callback = UI_Controls_Callback;

	UI_UtilSetupPicButton( &uiControls.defaults, PC_USE_DEFAULTS );

	uiControls.advanced.generic.id = ID_ADVANCED;
	uiControls.advanced.generic.type = QMTYPE_BM_BUTTON;
	uiControls.advanced.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiControls.advanced.generic.x = 72;
	uiControls.advanced.generic.y = 280;
	uiControls.advanced.generic.name = "Adv controls";
	uiControls.advanced.generic.statusText = "Change mouse sensitivity, enable autoaim, mouselook and crosshair";
	uiControls.advanced.generic.callback = UI_Controls_Callback;

	UI_UtilSetupPicButton( &uiControls.advanced, PC_ADV_CONTROLS );

	uiControls.done.generic.id = ID_DONE;
	uiControls.done.generic.type = QMTYPE_BM_BUTTON;
	uiControls.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiControls.done.generic.x = 72;
	uiControls.done.generic.y = 330;
	uiControls.done.generic.name = "Ok";
	uiControls.done.generic.statusText = "Save changes and return to configuration menu";
	uiControls.done.generic.callback = UI_Controls_Callback;

	UI_UtilSetupPicButton( &uiControls.done, PC_DONE );

	uiControls.cancel.generic.id = ID_CANCEL;
	uiControls.cancel.generic.type = QMTYPE_BM_BUTTON;
	uiControls.cancel.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiControls.cancel.generic.x = 72;
	uiControls.cancel.generic.y = 380;
	uiControls.cancel.generic.name = "Cancel";
	uiControls.cancel.generic.statusText = "Discard changes and return to configuration menu";
	uiControls.cancel.generic.callback = UI_Controls_Callback;

	UI_UtilSetupPicButton( &uiControls.cancel, PC_CANCEL );

	uiControls.hintMessage.generic.id = ID_TABLEHINT;
	uiControls.hintMessage.generic.type = QMTYPE_ACTION;
	uiControls.hintMessage.generic.flags = QMF_INACTIVE|QMF_SMALLFONT;
	uiControls.hintMessage.generic.color = uiColorHelp;
	uiControls.hintMessage.generic.name = uiControls.hintText;
	uiControls.hintMessage.generic.x = 360;
	uiControls.hintMessage.generic.y = 225;

	uiControls.keysList.generic.id = ID_KEYLIST;
	uiControls.keysList.generic.type = QMTYPE_SCROLLLIST;
	uiControls.keysList.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_SMALLFONT;
	uiControls.keysList.generic.x = 360;
	uiControls.keysList.generic.y = 255;
	uiControls.keysList.generic.width = 640;
	uiControls.keysList.generic.height = 440;
	uiControls.keysList.generic.callback = UI_Controls_Callback;

	UI_Controls_ParseKeysList();

	uiControls.msgBox1.generic.id = ID_MSGBOX1;
	uiControls.msgBox1.generic.type = QMTYPE_ACTION;
	uiControls.msgBox1.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiControls.msgBox1.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiControls.msgBox1.generic.x = DLG_X + 192;
	uiControls.msgBox1.generic.y = 256;
	uiControls.msgBox1.generic.width = 640;
	uiControls.msgBox1.generic.height = 128;

	uiControls.msgBox2.generic.id = ID_MSGBOX2;
	uiControls.msgBox2.generic.type = QMTYPE_ACTION;
	uiControls.msgBox2.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiControls.msgBox2.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiControls.msgBox2.generic.x = DLG_X + 192;
	uiControls.msgBox2.generic.y = 256;
	uiControls.msgBox2.generic.width = 640;
	uiControls.msgBox2.generic.height = 256;

	uiControls.dlgMessage.generic.id = ID_MSGTEXT;
	uiControls.dlgMessage.generic.type = QMTYPE_ACTION;
	uiControls.dlgMessage.generic.flags = QMF_INACTIVE|QMF_HIDDEN|QMF_DROPSHADOW;
	uiControls.dlgMessage.generic.name = "Press a key or button";
	uiControls.dlgMessage.generic.x = DLG_X + 320;
	uiControls.dlgMessage.generic.y = 280;

	uiControls.promptMessage.generic.id = ID_PROMPT;
	uiControls.promptMessage.generic.type = QMTYPE_ACTION;
	uiControls.promptMessage.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN;
	uiControls.promptMessage.generic.name = "Reset buttons to default?";
	uiControls.promptMessage.generic.x = DLG_X + 290;
	uiControls.promptMessage.generic.y = 280;

	uiControls.yes.generic.id = ID_YES;
	uiControls.yes.generic.type = QMTYPE_BM_BUTTON;
	uiControls.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiControls.yes.generic.name = "Ok";
	uiControls.yes.generic.x = DLG_X + 380;
	uiControls.yes.generic.y = 460;
	uiControls.yes.generic.callback = UI_Controls_Callback;

	UI_UtilSetupPicButton( &uiControls.yes, PC_OK );

	uiControls.no.generic.id = ID_NO;
	uiControls.no.generic.type = QMTYPE_BM_BUTTON;
	uiControls.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiControls.no.generic.name = "Cancel";
	uiControls.no.generic.x = DLG_X + 530;
	uiControls.no.generic.y = 460;
	uiControls.no.generic.callback = UI_Controls_Callback;

	UI_UtilSetupPicButton( &uiControls.no, PC_CANCEL );

	UI_AddItem( &uiControls.menu, (void *)&uiControls.background );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.banner );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.defaults );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.advanced );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.done );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.cancel );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.hintMessage );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.keysList );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.msgBox1 );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.msgBox2 );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.dlgMessage );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.promptMessage );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.no );
	UI_AddItem( &uiControls.menu, (void *)&uiControls.yes );
}

/*
=================
UI_Controls_Precache
=================
*/
void UI_Controls_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_Controls_Menu
=================
*/
void UI_Controls_Menu( void )
{
	UI_Controls_Precache();
	UI_Controls_Init();

	UI_PushMenu( &uiControls.menu );
}

```

`mainui/menu_creategame.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER		"gfx/shell/head_creategame"

#define ID_BACKGROUND	0
#define ID_BANNER		1
#define ID_ADVOPTIONS	2
#define ID_DONE		3
#define ID_CANCEL		4
#define ID_MAPLIST		5
#define ID_TABLEHINT	6
#define ID_MAXCLIENTS	7
#define ID_HOSTNAME		8
#define ID_PASSWORD		9
#define ID_NAT		10
#define ID_DEDICATED	11

#define ID_MSGBOX	 	12
#define ID_MSGTEXT	 	13
#define ID_YES	 	130
#define ID_NO	 	131

#define MAPNAME_LENGTH	20
#define TITLE_LENGTH	20+MAPNAME_LENGTH

typedef struct
{
	char		mapName[UI_MAXGAMES][64];
	char		mapsDescription[UI_MAXGAMES][256];
	char		*mapsDescriptionPtr[UI_MAXGAMES];

	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;
	menuPicButton_s	advOptions;
	menuPicButton_s	done;
	menuPicButton_s	cancel;

	menuField_s	maxClients;
	menuField_s	hostName;
	menuField_s	password;
	menuCheckBox_s	nat;
	menuCheckBox_s	dedicatedServer;

	// newgame prompt dialog
	menuAction_s	msgBox;
	menuAction_s	dlgMessage1;
	menuAction_s	dlgMessage2;
	menuPicButton_s	yes;
	menuPicButton_s	no;

	menuScrollList_s	mapsList;
	menuAction_s	hintMessage;
	char		hintText[MAX_HINT_TEXT];
} uiCreateGame_t;

static uiCreateGame_t	uiCreateGame;

/*
=================
UI_CreateGame_Begin
=================
*/
static void UI_CreateGame_Begin( void )
{
	if( !MAP_IS_VALID( uiCreateGame.mapName[uiCreateGame.mapsList.curItem] ))
		return;	// bad map

	if( CVAR_GET_FLOAT( "host_serverstate" ) )
	{
		if(	CVAR_GET_FLOAT( "maxplayers" ) == 1 )
			HOST_ENDGAME( "end of the game" );
		else
			HOST_ENDGAME( "starting new server" );
	}

	CVAR_SET_FLOAT( "deathmatch", 1.0f );	// start deathmatch as default
	CVAR_SET_FLOAT( "maxplayers", atoi( uiCreateGame.maxClients.buffer ));
	CVAR_SET_STRING( "hostname", uiCreateGame.hostName.buffer );
	CVAR_SET_STRING( "defaultmap", uiCreateGame.mapName[uiCreateGame.mapsList.curItem] );
	CVAR_SET_FLOAT( "sv_nat", CVAR_GET_FLOAT("public")?uiCreateGame.nat.enabled:0 );

	BACKGROUND_TRACK( NULL, NULL );

	// all done, start server
	if( uiCreateGame.dedicatedServer.enabled )
	{
		HOST_WRITECONFIG ( CVAR_GET_STRING( "servercfgfile" ));

		char cmd[128];
		sprintf( cmd, "#%s", gMenu.m_gameinfo.gamefolder );

		// NOTE: dedicated server will be executed "defaultmap"
		// from engine after restarting
		HOST_CHANGEGAME( cmd, "Starting dedicated server...\n" );
	}
	else
	{
		HOST_WRITECONFIG ( CVAR_GET_STRING( "lservercfgfile" ));

		char cmd[128];
		sprintf( cmd, "exec %s\n", CVAR_GET_STRING( "lservercfgfile" ) );

		CLIENT_COMMAND( TRUE, cmd );

		// dirty listenserver config form old xash may rewrite maxplayers
		CVAR_SET_FLOAT( "maxplayers", atoi( uiCreateGame.maxClients.buffer ));

		// hack: wait three frames allowing server to completely shutdown, reapply maxplayers and start new map
		sprintf( cmd, "host_endgame;wait;wait;wait;maxplayers %i;latch;map %s\n", atoi( uiCreateGame.maxClients.buffer ), uiCreateGame.mapName[uiCreateGame.mapsList.curItem] );
		CLIENT_COMMAND( FALSE, cmd );

	}
}

static void UI_PromptDialog( void )
{
	if( !CVAR_GET_FLOAT( "host_serverstate" ) || CVAR_GET_FLOAT( "cl_background" ))
	{
		UI_CreateGame_Begin();
		return;
	}

	// toggle main menu between active\inactive
	// show\hide quit dialog
	uiCreateGame.advOptions.generic.flags ^= QMF_INACTIVE;
	uiCreateGame.done.generic.flags ^= QMF_INACTIVE;
	uiCreateGame.cancel.generic.flags ^= QMF_INACTIVE;
	uiCreateGame.maxClients.generic.flags ^= QMF_INACTIVE;
	uiCreateGame.hostName.generic.flags ^= QMF_INACTIVE;
	uiCreateGame.password.generic.flags ^= QMF_INACTIVE;
	uiCreateGame.dedicatedServer.generic.flags ^= QMF_INACTIVE;
	uiCreateGame.nat.generic.flags ^= QMF_INACTIVE;
	uiCreateGame.mapsList.generic.flags ^= QMF_INACTIVE;

	uiCreateGame.msgBox.generic.flags ^= QMF_HIDDEN;
	uiCreateGame.dlgMessage1.generic.flags ^= QMF_HIDDEN;
	uiCreateGame.dlgMessage2.generic.flags ^= QMF_HIDDEN;
	uiCreateGame.no.generic.flags ^= QMF_HIDDEN;
	uiCreateGame.yes.generic.flags ^= QMF_HIDDEN;

}

/*
=================
UI_CreateGame_KeyFunc
=================
*/
static const char *UI_CreateGame_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE && !( uiCreateGame.dlgMessage1.generic.flags & QMF_HIDDEN ))
	{
		UI_PromptDialog();
		return uiSoundNull;
	}
	return UI_DefaultKey( &uiCreateGame.menu, key, down );
}

/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}

/*
=================
UI_CreateGame_GetMapsList
=================
*/
static void UI_CreateGame_GetMapsList( void )
{
	char *afile;

	if( !CHECK_MAP_LIST( FALSE ) || (afile = (char *)LOAD_FILE( "maps.lst", NULL )) == NULL )
	{
		uiCreateGame.done.generic.flags |= QMF_GRAYED;
		uiCreateGame.mapsList.itemNames = (const char **)uiCreateGame.mapsDescriptionPtr;
		Con_Printf( "Cmd_GetMapsList: can't open maps.lst\n" );
		return;
	}

	char *pfile = afile;
	char token[1024];
	int numMaps = 0;

	while(( pfile = COM_ParseFile( pfile, token )) != NULL )
	{
		if( numMaps >= UI_MAXGAMES ) break;
		StringConcat( uiCreateGame.mapName[numMaps], token, sizeof( uiCreateGame.mapName[0] ));
		StringConcat( uiCreateGame.mapsDescription[numMaps], token, MAPNAME_LENGTH );
		AddSpaces( uiCreateGame.mapsDescription[numMaps], MAPNAME_LENGTH );
		if(( pfile = COM_ParseFile( pfile, token )) == NULL ) break; // unexpected end of file
		StringConcat( uiCreateGame.mapsDescription[numMaps], token, TITLE_LENGTH );
		AddSpaces( uiCreateGame.mapsDescription[numMaps], TITLE_LENGTH );
		uiCreateGame.mapsDescriptionPtr[numMaps] = uiCreateGame.mapsDescription[numMaps];
		numMaps++;
	}

	if( !numMaps ) uiCreateGame.done.generic.flags |= QMF_GRAYED;

	for( ; numMaps < UI_MAXGAMES; numMaps++ ) uiCreateGame.mapsDescriptionPtr[numMaps] = NULL;
	uiCreateGame.mapsList.itemNames = (const char **)uiCreateGame.mapsDescriptionPtr;
	FREE_FILE( afile );
}

/*
=================
UI_CreateGame_Callback
=================
*/
static void UI_CreateGame_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	switch( item->id )
	{
	case ID_NAT:
	case ID_DEDICATED:
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
		break;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_ADVOPTIONS:
		// UNDONE: not implemented
		break;
	case ID_DONE:
		UI_PromptDialog();
		break;
	case ID_CANCEL:
		UI_PopMenu();
		break;
	case ID_YES:
		UI_CreateGame_Begin();
		break;
	case ID_NO:
		UI_PromptDialog();
		break;
	}
}

/*
=================
UI_CreateGame_Init
=================
*/
static void UI_CreateGame_Init( void )
{
	memset( &uiCreateGame, 0, sizeof( uiCreateGame_t ));

	//uiCreateGame.menu.vidInitFunc = UI_CreateGame_Init;
	uiCreateGame.menu.keyFunc = UI_CreateGame_KeyFunc;

	StringConcat( uiCreateGame.hintText, "Map", MAPNAME_LENGTH );
	AddSpaces( uiCreateGame.hintText, MAPNAME_LENGTH );
	StringConcat( uiCreateGame.hintText, "Title", TITLE_LENGTH );
	AddSpaces( uiCreateGame.hintText, TITLE_LENGTH );

	uiCreateGame.background.generic.id = ID_BACKGROUND;
	uiCreateGame.background.generic.type = QMTYPE_BITMAP;
	uiCreateGame.background.generic.flags = QMF_INACTIVE;
	uiCreateGame.background.generic.x = 0;
	uiCreateGame.background.generic.y = 0;
	uiCreateGame.background.generic.width = uiStatic.width;
	uiCreateGame.background.generic.height = 768;
	uiCreateGame.background.pic = ART_BACKGROUND;

	uiCreateGame.banner.generic.id = ID_BANNER;
	uiCreateGame.banner.generic.type = QMTYPE_BITMAP;
	uiCreateGame.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiCreateGame.banner.generic.x = UI_BANNER_POSX;
	uiCreateGame.banner.generic.y = UI_BANNER_POSY;
	uiCreateGame.banner.generic.width = UI_BANNER_WIDTH;
	uiCreateGame.banner.generic.height = UI_BANNER_HEIGHT;
	uiCreateGame.banner.pic = ART_BANNER;

	uiCreateGame.advOptions.generic.id = ID_ADVOPTIONS;
	uiCreateGame.advOptions.generic.type = QMTYPE_BM_BUTTON;
	uiCreateGame.advOptions.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_GRAYED;
	uiCreateGame.advOptions.generic.x = 72;
	uiCreateGame.advOptions.generic.y = 230;
	uiCreateGame.advOptions.generic.name = "Adv. Options";
	uiCreateGame.advOptions.generic.statusText = "Open the LAN game advanced options menu";
	uiCreateGame.advOptions.generic.callback = UI_CreateGame_Callback;

	UI_UtilSetupPicButton( &uiCreateGame.advOptions, PC_ADV_OPT );

	uiCreateGame.done.generic.id = ID_DONE;
	uiCreateGame.done.generic.type = QMTYPE_BM_BUTTON;
	uiCreateGame.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiCreateGame.done.generic.x = 72;
	uiCreateGame.done.generic.y = 280;
	uiCreateGame.done.generic.name = "Ok";
	uiCreateGame.done.generic.statusText = "Start the multiplayer game";
	uiCreateGame.done.generic.callback = UI_CreateGame_Callback;

	UI_UtilSetupPicButton( &uiCreateGame.done, PC_OK );

	uiCreateGame.cancel.generic.id = ID_CANCEL;
	uiCreateGame.cancel.generic.type = QMTYPE_BM_BUTTON;
	uiCreateGame.cancel.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiCreateGame.cancel.generic.x = 72;
	uiCreateGame.cancel.generic.y = 330;
	uiCreateGame.cancel.generic.name = "Cancel";
	uiCreateGame.cancel.generic.statusText = "Return to LAN game menu";
	uiCreateGame.cancel.generic.callback = UI_CreateGame_Callback;

	UI_UtilSetupPicButton( &uiCreateGame.cancel, PC_CANCEL );

	uiCreateGame.dedicatedServer.generic.id = ID_DEDICATED;
	uiCreateGame.dedicatedServer.generic.type = QMTYPE_CHECKBOX;
	uiCreateGame.dedicatedServer.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiCreateGame.dedicatedServer.generic.name = "Dedicated server";
	uiCreateGame.dedicatedServer.generic.x = 72;
	uiCreateGame.dedicatedServer.generic.y = 685;
	uiCreateGame.dedicatedServer.generic.callback = UI_CreateGame_Callback;
	uiCreateGame.dedicatedServer.generic.statusText = "faster, but you can't join the server from this machine";

	uiCreateGame.nat.generic.id = ID_NAT;
	uiCreateGame.nat.generic.type = QMTYPE_CHECKBOX;
	uiCreateGame.nat.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiCreateGame.nat.generic.name = "NAT";
	uiCreateGame.nat.generic.x = 72;
	uiCreateGame.nat.generic.y = 635;
	uiCreateGame.nat.generic.callback = UI_CreateGame_Callback;
	uiCreateGame.nat.generic.statusText = "Use NAT Bypass instead of direct mode";
	uiCreateGame.nat.enabled = true;

	uiCreateGame.hintMessage.generic.id = ID_TABLEHINT;
	uiCreateGame.hintMessage.generic.type = QMTYPE_ACTION;
	uiCreateGame.hintMessage.generic.flags = QMF_INACTIVE|QMF_SMALLFONT;
	uiCreateGame.hintMessage.generic.color = uiColorHelp;
	uiCreateGame.hintMessage.generic.name = uiCreateGame.hintText;
	uiCreateGame.hintMessage.generic.x = 590;
	uiCreateGame.hintMessage.generic.y = 215;

	uiCreateGame.mapsList.generic.id = ID_MAPLIST;
	uiCreateGame.mapsList.generic.type = QMTYPE_SCROLLLIST;
	uiCreateGame.mapsList.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_SMALLFONT;
	uiCreateGame.mapsList.generic.x = 590;
	uiCreateGame.mapsList.generic.y = 245;
	uiCreateGame.mapsList.generic.width = 410;
	uiCreateGame.mapsList.generic.height = 440;
	uiCreateGame.mapsList.generic.callback = UI_CreateGame_Callback;

	uiCreateGame.hostName.generic.id = ID_HOSTNAME;
	uiCreateGame.hostName.generic.type = QMTYPE_FIELD;
	uiCreateGame.hostName.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiCreateGame.hostName.generic.name = "Server Name:";
	uiCreateGame.hostName.generic.x = 350;
	uiCreateGame.hostName.generic.y = 260;
	uiCreateGame.hostName.generic.width = 205;
	uiCreateGame.hostName.generic.height = 32;
	uiCreateGame.hostName.generic.callback = UI_CreateGame_Callback;
	uiCreateGame.hostName.maxLength = 16;
	strcpy( uiCreateGame.hostName.buffer, CVAR_GET_STRING( "hostname" ));

	uiCreateGame.maxClients.generic.id = ID_MAXCLIENTS;
	uiCreateGame.maxClients.generic.type = QMTYPE_FIELD;
	uiCreateGame.maxClients.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NUMBERSONLY;
	uiCreateGame.maxClients.generic.name = "Max Players:";
	uiCreateGame.maxClients.generic.x = 350;
	uiCreateGame.maxClients.generic.y = 360;
	uiCreateGame.maxClients.generic.width = 205;
	uiCreateGame.maxClients.generic.height = 32;
	uiCreateGame.maxClients.maxLength = 2;

	if( CVAR_GET_FLOAT( "maxplayers" ) <= 1 )
		strcpy( uiCreateGame.maxClients.buffer, "8" );
	else sprintf( uiCreateGame.maxClients.buffer, "%i", (int)CVAR_GET_FLOAT( "maxplayers" ));

	uiCreateGame.password.generic.id = ID_PASSWORD;
	uiCreateGame.password.generic.type = QMTYPE_FIELD;
	uiCreateGame.password.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDEINPUT;
	uiCreateGame.password.generic.name = "Password:";
	uiCreateGame.password.generic.x = 350;
	uiCreateGame.password.generic.y = 460;
	uiCreateGame.password.generic.width = 205;
	uiCreateGame.password.generic.height = 32;
	uiCreateGame.password.generic.callback = UI_CreateGame_Callback;
	uiCreateGame.password.maxLength = 16;

	uiCreateGame.msgBox.generic.id = ID_MSGBOX;
	uiCreateGame.msgBox.generic.type = QMTYPE_ACTION;
	uiCreateGame.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiCreateGame.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiCreateGame.msgBox.generic.x = DLG_X + 192;
	uiCreateGame.msgBox.generic.y = 256;
	uiCreateGame.msgBox.generic.width = 640;
	uiCreateGame.msgBox.generic.height = 256;

	uiCreateGame.dlgMessage1.generic.id = ID_MSGTEXT;
	uiCreateGame.dlgMessage1.generic.type = QMTYPE_ACTION;
	uiCreateGame.dlgMessage1.generic.flags = QMF_INACTIVE|QMF_HIDDEN|QMF_DROPSHADOW;
	uiCreateGame.dlgMessage1.generic.name = "Starting a new game will exit";
	uiCreateGame.dlgMessage1.generic.x = DLG_X + 248;
	uiCreateGame.dlgMessage1.generic.y = 280;

	uiCreateGame.dlgMessage2.generic.id = ID_MSGTEXT;
	uiCreateGame.dlgMessage2.generic.type = QMTYPE_ACTION;
	uiCreateGame.dlgMessage2.generic.flags = QMF_INACTIVE|QMF_HIDDEN|QMF_DROPSHADOW;
	uiCreateGame.dlgMessage2.generic.name = "any current game, OK to exit?";
	uiCreateGame.dlgMessage2.generic.x = DLG_X + 248;
	uiCreateGame.dlgMessage2.generic.y = 310;

	uiCreateGame.yes.generic.id = ID_YES;
	uiCreateGame.yes.generic.type = QMTYPE_BM_BUTTON;
	uiCreateGame.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_HIDDEN|QMF_DROPSHADOW;
	uiCreateGame.yes.generic.name = "Ok";
	uiCreateGame.yes.generic.x = DLG_X + 380;
	uiCreateGame.yes.generic.y = 460;
	uiCreateGame.yes.generic.callback = UI_CreateGame_Callback;

	UI_UtilSetupPicButton( &uiCreateGame.yes, PC_OK );

	uiCreateGame.no.generic.id = ID_NO;
	uiCreateGame.no.generic.type = QMTYPE_BM_BUTTON;
	uiCreateGame.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_HIDDEN|QMF_DROPSHADOW;
	uiCreateGame.no.generic.name = "Cancel";
	uiCreateGame.no.generic.x = DLG_X + 530;
	uiCreateGame.no.generic.y = 460;
	uiCreateGame.no.generic.callback = UI_CreateGame_Callback;

	UI_UtilSetupPicButton( &uiCreateGame.no, PC_CANCEL );

	UI_CreateGame_GetMapsList();

	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.background );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.banner );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.advOptions );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.done );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.cancel );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.maxClients );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.hostName );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.password );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.dedicatedServer );
	if( CVAR_GET_FLOAT("public") )
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.nat );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.hintMessage );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.mapsList );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.msgBox );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.dlgMessage1 );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.dlgMessage2 );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.no );
	UI_AddItem( &uiCreateGame.menu, (void *)&uiCreateGame.yes );
}

/*
=================
UI_CreateGame_Precache
=================
*/
void UI_CreateGame_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_CreateGame_Menu
=================
*/
void UI_CreateGame_Menu( void )
{
	if ( gMenu.m_gameinfo.gamemode == GAME_SINGLEPLAYER_ONLY )
		return;

	UI_CreateGame_Precache();
	UI_CreateGame_Init();

	UI_PushMenu( &uiCreateGame.menu );
}

```

`mainui/menu_credits.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"

static const char *uiCreditsDefault[] = 
{
	"CS16Client v1.32",
	"Build Date:" __DATE__ " " __TIME__ ,
	"",
	"Developers: ",
	"a1batross",
	"mittorn",
	"jeefo",
	"",
	"Touch & GFX: ",
	"SergioPoverony",
	"ahsim",
	"",
	"Beta-testers:",
	"1.kirill",
	"Romka_ZVO",
	"WolfReiser",
	"MakcuM56",
	"Mr.Lightning Bolt",
	"Kirpich",
	"MeL0maN",
	"LordAlfaruh",
	"Velaron",
	"KOBL1CK",
	"Rediska_Morkovka",
	"IcE",
	"CSPlayer",
	"Zu1iN~Mage",
	"lewa_j",
	"Cosmo",
	"Maks56873",
	"THE-Swank",
	"Namatrasnik",
	"picos",
	"BloodyLuxor",
	"AndroUser",
	"Bbltashit",
	"Athiend",
	"vlad[54rus]",
	"KinG",
	"erokhin",
	"Solexid",
	"",
	"Big thanks to Valve Corporation for Counter-Strike",
	"Uncle Mike for this powerful engine",
	"ONeiLL for inspiration",
	"Nagist and s1lentq for successful CS1.6 game researching",
	"Spirit of Half-Life developers for rain code",
	"hzqst for studio render code",
	"",
	"Copyright Flying With Gauss 2015-2016 (C)",
	"Flying With Gauss is not affiliated with Valve or any of their partners.",
	"All copyrights reserved to their respective owners.",
	"Thanks for playing!",
	NULL
};

typedef struct
{
	const char	**credits;
	int		startTime;
	int		showTime;
	int		fadeTime;
	int		numLines;
	int		active;
	int		finalCredits;

	menuFramework_s	menu;
} uiCredits_t;

static uiCredits_t		uiCredits;


/*
=================
UI_Credits_DrawFunc
=================
*/
static void UI_Credits_DrawFunc( void )
{
	int	i, y;
	float	speed = 32.0f * (768.0f / ScreenHeight);
	int	w = UI_SMALL_CHAR_WIDTH;
	int	h = UI_SMALL_CHAR_HEIGHT;
	int	color = 0x00FFA000;

	// draw the background first
	UI_FillRect( 0, 0, ScreenWidth, ScreenHeight, uiColorBlack );

	// now draw the credits
	UI_ScaleCoords( NULL, NULL, &w, &h );

	y = ScreenHeight - (((gpGlobals->time * 1000) - uiCredits.startTime ) / speed );

	// draw the credits
	for ( i = 0; i < uiCredits.numLines && uiCredits.credits[i]; i++, y += h )
	{
		// skip not visible lines, but always draw end line
		if( y <= -h && i != uiCredits.numLines - 1 ) continue;

		if(( y < ( ScreenHeight - h ) / 2 ) && i == uiCredits.numLines - 1 )
		{
			if( !uiCredits.fadeTime ) uiCredits.fadeTime = (gpGlobals->time * 1000);
			color = UI_FadeAlpha( uiCredits.fadeTime, uiCredits.showTime );
			if( UnpackAlpha( color ))
				UI_DrawString( 0, ( ScreenHeight - h ) / 2, ScreenWidth, h, uiCredits.credits[i], color, true, w, h, 1, true );
		}
		else UI_DrawString( 0, y, ScreenWidth, h, uiCredits.credits[i], uiColorWhite, false, w, h, 1, true );
	}

	if( y < 0 && UnpackAlpha( color ) == 0 )
	{
		uiCredits.active = false; // end of credits
	}

	if( !uiCredits.active )
		UI_PopMenu();
}

/*
=================
UI_Credits_KeyFunc
=================
*/
static const char *UI_Credits_KeyFunc( int key, int down )
{
	if( !down ) return uiSoundNull;

	// final credits can't be intterupted
	if( uiCredits.finalCredits )
		return uiSoundNull;

	uiCredits.active = false;
	return uiSoundNull;
}

/*
=================
UI_Credits_Init
=================
*/
static void UI_Credits_Init( void )
{
	uiCredits.menu.drawFunc = UI_Credits_DrawFunc;
	uiCredits.menu.keyFunc = UI_Credits_KeyFunc;

	// use built-in credits
	uiCredits.credits =  uiCreditsDefault;
	uiCredits.numLines = ( sizeof( uiCreditsDefault ) / sizeof( uiCreditsDefault[0] )) - 1; // skip term

	// run credits
	uiCredits.startTime = (gpGlobals->time * 1000) + 500; // make half-seconds delay
	uiCredits.showTime = bound( 1000, strlen( uiCredits.credits[uiCredits.numLines - 1]) * 1000, 10000 );
	uiCredits.fadeTime = 0; // will be determined later
	uiCredits.active = true;
}

void UI_DrawFinalCredits( void )
{
	if( uiCredits.finalCredits && uiCredits.active )
		UI_Credits_DrawFunc ();
}

int UI_CreditsActive( void )
{
	return uiCredits.active && uiCredits.finalCredits;
}

/*
=================
UI_Credits_Precache
=================
*/
void UI_Credits_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
}

/*
=================
UI_Credits_Menu
=================
*/
void UI_Credits_Menu( void )
{
	UI_Credits_Precache();
	UI_Credits_Init();

	UI_PushMenu( &uiCredits.menu );
}

void UI_FinalCredits( void )
{
	uiCredits.finalCredits = true;
	UI_Credits_Init();
}

```

`mainui/menu_filedialog.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER	  	"gfx/shell/head_touchoptions"
#define ART_GAMMA		"gfx/shell/gamma"

#define ID_BACKGROUND 	0
#define ID_BANNER	  	1
#define ID_DONE	  	2
#define ID_CANCEL 3
#define ID_PREVIEW 4
#define ID_FILELIST 5

uiFileDialogGlobal_t	uiFileDialogGlobal;

typedef struct
{
	menuFramework_s	menu;
	char		filePath[UI_MAXGAMES][95];
	char		*filePathPtr[UI_MAXGAMES];
	menuBitmap_s	background;
	//menuBitmap_s	banner;
	menuAction_s preview;
	HIMAGE image;

	menuPicButton_s	done;
	menuPicButton_s	cancel;

	menuScrollList_s fileList;
} uiFileDialog_t;

static uiFileDialog_t	uiFileDialog;

static void UI_Preview_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;
	UI_FillRect( item->x - 2, item->y - 2, item->width + 4, item->height + 4, 0xFFC0C0C0 );
	UI_FillRect( item->x, item->y, item->width, item->height, 0xFF808080 );
	PIC_Set( uiFileDialog.image, 255, 255, 255, 255 );
	PIC_DrawTrans( item->x, item->y, item->width, item->height );
}

static void UI_FileDialog_GetFileList( void )
{
	char	**filenames;
	int	i = 0, numFiles, j, k;


	for( k = 0; k < uiFileDialogGlobal.npatterns; k++)
	{
		filenames = FS_SEARCH( uiFileDialogGlobal.patterns[k], &numFiles, TRUE );
		for ( j = 0; j < numFiles; i++, j++ )
		{
			if( i >= UI_MAXGAMES ) break;
			strcpy( uiFileDialog.filePath[i],filenames[j] );
			uiFileDialog.filePathPtr[i] = uiFileDialog.filePath[i];
		}
	}
	uiFileDialog.fileList.numItems = i;

	if( uiFileDialog.fileList.generic.charHeight )
	{
		uiFileDialog.fileList.numRows = (uiFileDialog.fileList.generic.height2 / uiFileDialog.fileList.generic.charHeight) - 2;
		if( uiFileDialog.fileList.numRows > uiFileDialog.fileList.numItems )
			uiFileDialog.fileList.numRows = i;
	}

	for ( ; i < UI_MAXGAMES; i++ )
		uiFileDialog.filePathPtr[i] = NULL;


	uiFileDialog.fileList.itemNames = (const char **)uiFileDialog.filePathPtr;
	uiFileDialog.image = PIC_Load( uiFileDialog.filePath[ uiFileDialog.fileList.curItem ] );
}

/*
=================
UI_FileDialog_Callback
=================
*/
static void UI_FileDialog_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	switch( item->id )
	{/*
	   // checkboxes
	case ID_XXX
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
		break;*/
	}

	if( event == QM_CHANGED )
	{
		switch( item->id )
		{
		case ID_FILELIST:
			if( uiFileDialogGlobal.preview )
				uiFileDialog.image = PIC_Load( uiFileDialog.filePath[ uiFileDialog.fileList.curItem ] );
			break;
		}

		return;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		strcpy( uiFileDialogGlobal.result, uiFileDialog.filePath[uiFileDialog.fileList.curItem] );
		uiFileDialogGlobal.valid = false;
		UI_PopMenu();
		uiFileDialogGlobal.callback( true );
		break;
	case ID_CANCEL:
		strcpy( uiFileDialogGlobal.result, "" );
		uiFileDialogGlobal.valid = false;
		UI_PopMenu();
		uiFileDialogGlobal.callback( false );
		break;
	}
}

/*
=================
UI_FileDialog_Init
=================
*/
static void UI_FileDialog_Init( void )
{
	memset( &uiFileDialog, 0, sizeof( uiFileDialog_t ));

	//uiTouchOptions.hTestImage = PIC_Load( ART_GAMMA, PIC_KEEP_RGBDATA );

	uiFileDialog.menu.vidInitFunc = UI_FileDialog_Init;

	uiFileDialog.background.generic.id = ID_BACKGROUND;
	uiFileDialog.background.generic.type = QMTYPE_BITMAP;
	uiFileDialog.background.generic.flags = QMF_INACTIVE;
	uiFileDialog.background.generic.x = 0;
	uiFileDialog.background.generic.y = 0;
	uiFileDialog.background.generic.width = uiStatic.width;
	uiFileDialog.background.generic.height = 768;
	uiFileDialog.background.pic = ART_BACKGROUND;

	/*uiTouchOptions.banner.generic.id = ID_BANNER;
	uiTouchOptions.banner.generic.type = QMTYPE_BITMAP;
	uiTouchOptions.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiTouchOptions.banner.generic.x = UI_BANNER_POSX;
	uiTouchOptions.banner.generic.y = UI_BANNER_POSY;
	uiTouchOptions.banner.generic.width = UI_BANNER_WIDTH;
	uiTouchOptions.banner.generic.height = UI_BANNER_HEIGHT;
	uiTouchOptions.banner.pic = ART_BANNER;*/

	uiFileDialog.done.generic.id = ID_DONE;
	uiFileDialog.done.generic.type = QMTYPE_BM_BUTTON;
	uiFileDialog.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiFileDialog.done.generic.x = 72;
	uiFileDialog.done.generic.y = 150;
	uiFileDialog.done.generic.name = "Done";
	uiFileDialog.done.generic.statusText = "Use selected file";
	uiFileDialog.done.generic.callback = UI_FileDialog_Callback;

	UI_UtilSetupPicButton( &uiFileDialog.done, PC_DONE );

	uiFileDialog.cancel.generic.id = ID_CANCEL;
	uiFileDialog.cancel.generic.type = QMTYPE_BM_BUTTON;
	uiFileDialog.cancel.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiFileDialog.cancel.generic.x = 72;
	uiFileDialog.cancel.generic.y = 210;
	uiFileDialog.cancel.generic.name = "Cancel";
	uiFileDialog.cancel.generic.statusText = "Cancel file selection";
	uiFileDialog.cancel.generic.callback = UI_FileDialog_Callback;

	UI_UtilSetupPicButton( &uiFileDialog.cancel, PC_CANCEL );

	uiFileDialog.fileList.generic.id = ID_FILELIST;
	uiFileDialog.fileList.generic.type = QMTYPE_SCROLLLIST;
	uiFileDialog.fileList.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_SMALLFONT;
	uiFileDialog.fileList.generic.x = 340;
	uiFileDialog.fileList.generic.y = 150;
	uiFileDialog.fileList.generic.width = 600;
	uiFileDialog.fileList.generic.height = 500;
	uiFileDialog.fileList.generic.callback = UI_FileDialog_Callback;

	uiFileDialog.preview.generic.id = ID_PREVIEW;
	uiFileDialog.preview.generic.type = QMTYPE_ACTION;
	uiFileDialog.preview.generic.flags =  QMF_INACTIVE;
	uiFileDialog.preview.generic.x = 72;
	uiFileDialog.preview.generic.y = 300;
	uiFileDialog.preview.generic.width = 196;
	uiFileDialog.preview.generic.height = 196;
	uiFileDialog.preview.generic.ownerdraw = UI_Preview_Ownerdraw;

	UI_FileDialog_GetFileList();

	UI_AddItem( &uiFileDialog.menu, (void *)&uiFileDialog.background );
	//UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.banner );
	UI_AddItem( &uiFileDialog.menu, (void *)&uiFileDialog.done );
	UI_AddItem( &uiFileDialog.menu, (void *)&uiFileDialog.cancel );
	if( uiFileDialogGlobal.preview )
	UI_AddItem( &uiFileDialog.menu, (void *)&uiFileDialog.preview );
	UI_AddItem( &uiFileDialog.menu, (void *)&uiFileDialog.fileList );

}

/*
=================
UI_FileDialog_Precache
=================
*/
void UI_FileDialog_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	//PIC_Load( ART_BANNER );
}

/*
=================
UI_FileDialog_Menu
=================
*/
void UI_FileDialog_Menu( void )
{
	UI_FileDialog_Precache();
	UI_FileDialog_Init();


	UI_PushMenu( &uiFileDialog.menu );
	//if( !uiFileDialogGlobal.valid )
		//UI_PopMenu();
}

```

`mainui/menu_gameoptions.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER			"gfx/shell/head_advoptions"

#undef ID_BACKGROUND
#undef ID_BANNER

enum
{
	ID_BACKGROUND = 0,
	ID_BANNER,
	ID_DONE,
	ID_CANCEL,
	// cs16-client
	ID_CORSPESTAY,
	ID_DECALS,
	ID_MAXSHELLS,
	ID_MAXPUFFS,
	ID_SG_GREN_TYPE,
	ID_HAND,
	ID_OLDSTYLEMENU,
	ID_EXTENDEDMENU,
	ID_AUTOWEPSWITCH,
	ID_CENTERID,
	ID_AUTOHELP,
	ID_ENDGAME_SCREENSHOT,
	ID_OBSERVERCROSSHAIR,
	ID_TRANSPARENTRADAR,
	ID_MAXPACKET,
	ID_MAXPACKETMESSAGE
};

typedef struct
{
	float	cl_corpsestay;
	float	mp_decals;
	float   maxPacket;
	//float	max_sheels;
	//float	max_smoke_puffs;
	byte	fast_smoke_gas;
	byte	hand;
	byte	oldstylemenu;
	byte	extendedmenus;
	byte	cl_autowepswitch;
	byte	hud_centerid;
	byte	auto_help;
	byte	radar_type;
} uiGameValues_t;

typedef struct
{
	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	done;
	menuPicButton_s	cancel;

	menuSpinControl_s		cl_corpsestay;
	menuAction_s	cl_corpsestay_message;
	menuSpinControl_s		mp_decals;
	menuAction_s    mp_decals_message;

	menuCheckBox_s	fast_smoke_gas;
	menuCheckBox_s	hand;
	menuCheckBox_s	oldstylemenu;
	menuCheckBox_s  extendedmenus;
	menuCheckBox_s	cl_autowepswitch;
	menuCheckBox_s	hud_centerid;
	menuCheckBox_s	auto_help;
	//menuCheckBox_s	endgame_screenshot;
	//menuCheckBox_s	observer_crosshair;
	menuCheckBox_s	radar_type;

	menuSpinControl_s	maxPacket;
	menuAction_s	maxPacketmessage1;
	menuAction_s	maxPacketmessage2;
} uiGameOptions_t;

static uiGameOptions_t	uiGameOptions;
static uiGameValues_t	uiGameInitial;

/*
=================
UI_GameOptions_UpdateConfig
=================
*/
static void UI_GameOptions_UpdateConfig( void )
{
	static char	corpseStayText[8];
	static char	maxpacketText[8];
	static char decalsText[8];

	sprintf( corpseStayText, "%.f", uiGameOptions.cl_corpsestay.curValue );
	uiGameOptions.cl_corpsestay.generic.name = corpseStayText;

	sprintf( decalsText, "%.f", uiGameOptions.mp_decals.curValue );
	uiGameOptions.mp_decals.generic.name = decalsText;
	if( uiGameOptions.maxPacket.curValue >= 1500 )
	{
		sprintf( maxpacketText, "default" );

		// even do not send it to server
		CVAR_SET_FLOAT( "cl_maxpacket", 40000 );
	}
	else
	{
		sprintf( maxpacketText, "%.f", uiGameOptions.maxPacket.curValue );
		CVAR_SET_FLOAT( "cl_maxpacket", uiGameOptions.maxPacket.curValue );
	}

	uiGameOptions.maxPacket.generic.name = maxpacketText;

	CVAR_SET_FLOAT( "hand",          !uiGameOptions.hand.enabled );
	CVAR_SET_FLOAT( "cl_corpsestay", uiGameOptions.cl_corpsestay.curValue );
	CVAR_SET_FLOAT( "mp_decals",     uiGameOptions.mp_decals.curValue );
	//CVAR_SET_FLOAT( "") maxshells
	//CVAR_SET_FLOAT( "") max_smoke_puffs;
	CVAR_SET_FLOAT( "fastsprites",  uiGameOptions.fast_smoke_gas.enabled );
	CVAR_SET_FLOAT( "_vgui_menus",   !uiGameOptions.oldstylemenu.enabled );
	CVAR_SET_FLOAT( "_extended_menus", uiGameOptions.extendedmenus.enabled );
	CVAR_SET_FLOAT( "_cl_autowepswitch", uiGameOptions.cl_autowepswitch.enabled );
	CVAR_SET_FLOAT( "hud_centerid",  uiGameOptions.hud_centerid.enabled );
	CVAR_SET_FLOAT( "_ah",           uiGameOptions.auto_help.enabled );
	//CVAR_SET_FLOAT( "", uiGameOptions.endgame_screenshot.enabled );
	//CVAR_SET_FLOAT( "", uiGameOptions.observer_crosshair.enabled );
	CVAR_SET_FLOAT( "cl_radartype",  uiGameOptions.radar_type.enabled );

}

/*
=================
UI_GameOptions_DiscardChanges
=================
*/
static void UI_GameOptions_DiscardChanges( void )
{
	CVAR_SET_FLOAT( "hand",          !uiGameInitial.hand );
	CVAR_SET_FLOAT( "cl_corpsestay", uiGameInitial.cl_corpsestay );
	CVAR_SET_FLOAT( "mp_decals",     uiGameInitial.mp_decals );
	//CVAR_SET_FLOAT( "") maxshells
	//CVAR_SET_FLOAT( "") max_smoke_puffs;
	CVAR_SET_FLOAT( "fastsprites",  uiGameInitial.fast_smoke_gas );
	CVAR_SET_FLOAT( "_vgui_menus",   !uiGameInitial.oldstylemenu );
	CVAR_SET_FLOAT( "_extended_menus", uiGameInitial.extendedmenus );
	CVAR_SET_FLOAT( "_cl_autowepswitch", uiGameInitial.cl_autowepswitch );
	CVAR_SET_FLOAT( "hud_centerid",  uiGameInitial.hud_centerid );
	CVAR_SET_FLOAT( "_ah",           uiGameInitial.auto_help );
	//CVAR_SET_FLOAT( "_extended_menus", uiGameOptions.endgame_screenshot.enabled );
	//CVAR_SET_FLOAT( "", uiGameInitial.observer_crosshair );
	CVAR_SET_FLOAT( "cl_radartype",  uiGameInitial.radar_type );
	CVAR_SET_FLOAT( "cl_maxpacket", uiGameInitial.maxPacket );
}

/*
=================
UI_GameOptions_KeyFunc
=================
*/
static const char *UI_GameOptions_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE
#ifdef __ANDROID__
		|| key == 236 // ANDROID_K_MENU
#endif
		)
		UI_GameOptions_DiscardChanges ();
	return UI_DefaultKey( &uiGameOptions.menu, key, down );
}

/*
=================
UI_GameOptions_GetConfig
=================
*/
static void UI_GameOptions_GetConfig( void )
{
	uiGameOptions.cl_corpsestay.curValue = uiGameInitial.cl_corpsestay = CVAR_GET_FLOAT( "cl_corpsestay" );
	uiGameOptions.mp_decals.curValue = uiGameInitial.mp_decals = CVAR_GET_FLOAT( "mp_decals" );
	uiGameOptions.maxPacket.curValue = uiGameInitial.maxPacket = CVAR_GET_FLOAT( "cl_maxpacket" );

	uiGameInitial.hand = uiGameOptions.hand.enabled = !CVAR_GET_FLOAT( "hand" );
	uiGameInitial.oldstylemenu = uiGameOptions.oldstylemenu.enabled = !CVAR_GET_FLOAT( "_vgui_menus" );

	if( CVAR_GET_FLOAT( "fastsprites" ))
		uiGameInitial.fast_smoke_gas = uiGameOptions.fast_smoke_gas.enabled = true;
	if( CVAR_GET_FLOAT( "_extended_menus" ))
		uiGameInitial.extendedmenus = uiGameOptions.extendedmenus.enabled = true;
	if( CVAR_GET_FLOAT( "_cl_autowepswitch" ))
		uiGameInitial.cl_autowepswitch = uiGameOptions.cl_autowepswitch.enabled = true;
	if( CVAR_GET_FLOAT( "hud_centerid" ))
		uiGameInitial.hud_centerid = uiGameOptions.hud_centerid.enabled = true;
	if( CVAR_GET_FLOAT( "_ah" ))
		uiGameInitial.auto_help = uiGameOptions.auto_help.enabled = true;
	if( CVAR_GET_FLOAT( "cl_radartype" ))
		uiGameInitial.radar_type = uiGameOptions.radar_type.enabled = true;

	UI_GameOptions_UpdateConfig ();
}

/*
=================
UI_GameOptions_Callback
=================
*/
static void UI_GameOptions_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( item->id >= ID_HAND && item->id <= ID_TRANSPARENTRADAR )
	{
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
	}

	if( event == QM_CHANGED )
	{
		UI_GameOptions_UpdateConfig();
		return;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		CLIENT_COMMAND( FALSE, "trysaveconfig\n" );
		UI_PopMenu();
		break;
	case ID_CANCEL:
		UI_GameOptions_DiscardChanges();
		UI_PopMenu();
		break;
	}
}

/*
=================
UI_GenItemInit
=================
*/
inline void UI_GenItemInit( menuCommon_s &item, int id, menuType_t type, unsigned int flags,
	int x, int y, const char *name, const char *statusText )
{
	item.id = id;
	item.type = type;
	item.flags = flags;
	item.x = x;
	item.y = y;
	item.name = name;
	item.callback = UI_GameOptions_Callback;
	item.statusText = statusText;
}

/*
=================
UI_GameOptions_Init
=================
*/
static void UI_GameOptions_Init( void )
{
	static unsigned int iTypicalFlags = QMF_HIGHLIGHTIFFOCUS | QMF_ACT_ONRELEASE | QMF_DROPSHADOW;
	const int gap = 50;
	memset( &uiGameInitial, 0, sizeof( uiGameValues_t ));
	memset( &uiGameOptions, 0, sizeof( uiGameOptions_t ));

	uiGameOptions.menu.vidInitFunc = UI_GameOptions_Init;
	uiGameOptions.menu.keyFunc = UI_GameOptions_KeyFunc;

	uiGameOptions.background.generic.id = ID_BACKGROUND;
	uiGameOptions.background.generic.type = QMTYPE_BITMAP;
	uiGameOptions.background.generic.flags = QMF_INACTIVE;
	uiGameOptions.background.generic.x = 0;
	uiGameOptions.background.generic.y = 0;
	uiGameOptions.background.generic.width = uiStatic.width;
	uiGameOptions.background.generic.height = 768;
	uiGameOptions.background.pic = ART_BACKGROUND;

	uiGameOptions.banner.generic.id = ID_BANNER;
	uiGameOptions.banner.generic.type = QMTYPE_BITMAP;
	uiGameOptions.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiGameOptions.banner.generic.x = UI_BANNER_POSX;
	uiGameOptions.banner.generic.y = UI_BANNER_POSY;
	uiGameOptions.banner.generic.width = UI_BANNER_WIDTH;
	uiGameOptions.banner.generic.height = UI_BANNER_HEIGHT;
	uiGameOptions.banner.pic = ART_BANNER;

	int x = 72, y = 180;

	UI_GenItemInit( uiGameOptions.hand.generic, ID_HAND, QMTYPE_CHECKBOX, iTypicalFlags,
		x, y += gap, "Use left hand", "Draw gun at left side" );
	UI_GenItemInit( uiGameOptions.fast_smoke_gas.generic, ID_SG_GREN_TYPE, QMTYPE_CHECKBOX, iTypicalFlags,
		x, y += gap, "Low quality smoke", "Use low quality smoke, for slow devices" );
	UI_GenItemInit( uiGameOptions.oldstylemenu.generic,	ID_OLDSTYLEMENU, QMTYPE_CHECKBOX, iTypicalFlags,
		x, y += gap, "Old style menus", "Use old-styled numerical buy menu" );
	UI_GenItemInit( uiGameOptions.extendedmenus.generic, ID_EXTENDEDMENU, QMTYPE_CHECKBOX, iTypicalFlags,
		x, y += gap, "Extended touch menu", "Force touch menus for radio" );
	UI_GenItemInit( uiGameOptions.cl_autowepswitch.generic, ID_AUTOWEPSWITCH, QMTYPE_CHECKBOX, iTypicalFlags,
		x, y += gap, "Automatic weapon switch", "Enable automatic weapon switch" );
	UI_GenItemInit( uiGameOptions.hud_centerid.generic, ID_CENTERID, QMTYPE_CHECKBOX, iTypicalFlags,
		x, y += gap, "Center player names", "" );
	UI_GenItemInit( uiGameOptions.auto_help.generic, ID_AUTOHELP, QMTYPE_CHECKBOX, iTypicalFlags,
		x, y += gap, "Auto-help", "Do you need to know how to play Counter-Strike?" );
	UI_GenItemInit( uiGameOptions.radar_type.generic, ID_TRANSPARENTRADAR, QMTYPE_CHECKBOX, iTypicalFlags,
		x, y += gap, "Opaque radar", "Opaque or transparent radar. Useful for slow devices." );


	UI_GenItemInit( uiGameOptions.cl_corpsestay_message.generic, 10000, QMTYPE_ACTION, QMF_SMALLFONT| QMF_INACTIVE|QMF_DROPSHADOW,
		420, y = 240, "Time before dead bodies disappear:", NULL);
	uiGameOptions.cl_corpsestay_message.generic.color = uiColorHelp;

	UI_GenItemInit( uiGameOptions.cl_corpsestay.generic, ID_CORSPESTAY, QMTYPE_SPINCONTROL, QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW,
		450, y += gap, "600", NULL );
	uiGameOptions.cl_corpsestay.generic.height = 26;
	uiGameOptions.cl_corpsestay.generic.width = 168;
	uiGameOptions.cl_corpsestay.minValue = 0;
	uiGameOptions.cl_corpsestay.maxValue = 1000;
	uiGameOptions.cl_corpsestay.range	 = 50;

	UI_GenItemInit( uiGameOptions.mp_decals_message.generic, 10000, QMTYPE_ACTION, QMF_SMALLFONT|QMF_INACTIVE|QMF_DROPSHADOW,
		420, y += gap, "Multiplayer decal limit:", NULL);
	uiGameOptions.mp_decals_message.generic.color = uiColorHelp;

	UI_GenItemInit( uiGameOptions.mp_decals.generic, ID_DECALS, QMTYPE_SPINCONTROL, QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW,
		450, y += gap, "300", NULL );
	uiGameOptions.mp_decals.generic.height = 26;
	uiGameOptions.mp_decals.generic.width = 168;
	uiGameOptions.mp_decals.minValue = 0;
	uiGameOptions.mp_decals.maxValue = 1000;
	uiGameOptions.mp_decals.range	 = 50;

	uiGameOptions.maxPacketmessage1.generic.id = ID_MAXPACKETMESSAGE;
	uiGameOptions.maxPacketmessage1.generic.type = QMTYPE_ACTION;
	uiGameOptions.maxPacketmessage1.generic.flags = QMF_SMALLFONT|QMF_INACTIVE|QMF_DROPSHADOW;
	uiGameOptions.maxPacketmessage1.generic.x = 420;
	uiGameOptions.maxPacketmessage1.generic.y = (y += gap);
	uiGameOptions.maxPacketmessage1.generic.name = "Limit network packet size";
	uiGameOptions.maxPacketmessage1.generic.color = uiColorHelp;

	uiGameOptions.maxPacket.generic.id = ID_MAXPACKET;
	uiGameOptions.maxPacket.generic.type = QMTYPE_SPINCONTROL;
	uiGameOptions.maxPacket.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiGameOptions.maxPacket.generic.x = 450;
	uiGameOptions.maxPacket.generic.y = (y += gap);
	uiGameOptions.maxPacket.generic.width = 168;
	uiGameOptions.maxPacket.generic.height = 26;
	uiGameOptions.maxPacket.generic.callback = UI_GameOptions_Callback;
	uiGameOptions.maxPacket.generic.statusText = "Limit packet size durning connection";
	uiGameOptions.maxPacket.minValue = 200;
	uiGameOptions.maxPacket.maxValue = 1500;
	uiGameOptions.maxPacket.range = 50;

	uiGameOptions.maxPacketmessage2.generic.id = ID_MAXPACKETMESSAGE;
	uiGameOptions.maxPacketmessage2.generic.type = QMTYPE_ACTION;
	uiGameOptions.maxPacketmessage2.generic.flags = QMF_SMALLFONT|QMF_INACTIVE|QMF_DROPSHADOW;
	uiGameOptions.maxPacketmessage2.generic.x = 420;
	uiGameOptions.maxPacketmessage2.generic.y =  (y += gap);
	uiGameOptions.maxPacketmessage2.generic.name = "^3Use 700 or less if connection hangs\nafter \"^6Spooling demo header^3\" message";
	uiGameOptions.maxPacketmessage2.generic.color = uiColorWhite;

	UI_GenItemInit( uiGameOptions.done.generic, ID_DONE, QMTYPE_BM_BUTTON, QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW,
		450, y += gap, "Done", "Save changes and go back to the Customize Menu");
	UI_UtilSetupPicButton( &uiGameOptions.done, PC_DONE );

	UI_GenItemInit( uiGameOptions.cancel.generic, ID_CANCEL, QMTYPE_BM_BUTTON, QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW,
		450, y += gap, "Cancel", "Go back to the Customize Menu");
	UI_UtilSetupPicButton( &uiGameOptions.cancel, PC_CANCEL );

	UI_GameOptions_GetConfig();

	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.background );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.banner );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.hand );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.fast_smoke_gas );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.oldstylemenu );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.extendedmenus );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.cl_autowepswitch );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.hud_centerid );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.auto_help );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.radar_type );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.cl_corpsestay );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.cl_corpsestay_message );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.mp_decals );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.mp_decals_message );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.maxPacket );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.maxPacketmessage1 );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.maxPacketmessage2 );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.done );
	UI_AddItem( &uiGameOptions.menu, (void *)&uiGameOptions.cancel );
}

/*
=================
UI_GameOptions_Precache
=================
*/
void UI_GameOptions_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_GameOptions_Menu
=================
*/
void UI_GameOptions_Menu( void )
{
	UI_GameOptions_Precache();
	UI_GameOptions_Init();

	UI_GameOptions_UpdateConfig();
	UI_PushMenu( &uiGameOptions.menu );
}

```

`mainui/menu_gamepad.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER			"gfx/shell/head_gamepad"

#define ID_BACKGROUND 0
#define ID_BANNER 1

enum
{
	ID_DONE = 2,
	ID_RT_THRESHOLD,
	ID_LT_THRESHOLD,
	ID_SIDE,
	ID_FORWARD,
	ID_PITCH,
	ID_YAW,
	ID_INVERT_SIDE,
	ID_INVERT_FORWARD,
	ID_INVERT_PITCH,
	ID_INVERT_YAW,
	ID_AXIS_BIND1,
	ID_AXIS_BIND2,
	ID_AXIS_BIND3,
	ID_AXIS_BIND4,
	ID_AXIS_BIND5,
	ID_AXIS_BIND6,
	ID_JOY_ENABLE,
	ID_CONTROLS
};

enum engineAxis_t
{
	JOY_AXIS_SIDE = 0,
	JOY_AXIS_FWD,
	JOY_AXIS_PITCH,
	JOY_AXIS_YAW,
	JOY_AXIS_RT,
	JOY_AXIS_LT,
	JOY_AXIS_NULL
};

static const char *axisNames[7] =
{
	"Side Movement",
	"Forward Movement",
	"Camera Vertical Turn",
	"Camera Horizontal Turn",
	"Right Trigger",
	"Left Trigger",
	"NOT BOUND"
};

typedef struct
{
	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	done;
	menuPicButton_s controls;
	menuSlider_s side, forward, pitch, yaw;
	menuCheckBox_s invSide, invFwd, invPitch, invYaw;
	menuCheckBox_s joyEnable;

	menuSpinControl_s axisBind[6];

	menuAction_s axisBind_label;
} uiGamePad_t;

static uiGamePad_t		uiGamePad;

/*
=================
UI_GamePad_GetConfig
=================
*/
static void UI_GamePad_GetConfig( void )
{
	float side, forward, pitch, yaw;
	char binding[7] = { 0 };

	strncpy( binding, CVAR_GET_STRING( "joy_axis_binding"), sizeof( binding ));

	side = CVAR_GET_FLOAT( "joy_side" );
	forward = CVAR_GET_FLOAT( "joy_forward" );
	pitch = CVAR_GET_FLOAT( "joy_pitch" );
	yaw = CVAR_GET_FLOAT( "joy_yaw" );

	uiGamePad.side.curValue = fabs( side );
	uiGamePad.forward.curValue = fabs( forward );
	uiGamePad.pitch.curValue = fabs( pitch );
	uiGamePad.yaw.curValue = fabs( yaw );

	uiGamePad.invSide.enabled = side < 0.0f ? true: false;
	uiGamePad.invFwd.enabled = forward < 0.0f ? true: false;
	uiGamePad.invPitch.enabled = pitch < 0.0f ? true: false;
	uiGamePad.invYaw.enabled = yaw < 0.0f ? true: false;

	uiGamePad.joyEnable.enabled = (int)CVAR_GET_FLOAT( "joy_enable" );

	// I made a monster...
	for( unsigned int i = 0; i < sizeof( binding ) - 1; i++ )
	{
		switch( binding[i] )
		{
		case 's':
			uiGamePad.axisBind[i].generic.name = axisNames[JOY_AXIS_SIDE];
			uiGamePad.axisBind[i].curValue = JOY_AXIS_SIDE;
			break;
		case 'f':
			uiGamePad.axisBind[i].generic.name = axisNames[JOY_AXIS_FWD];
			uiGamePad.axisBind[i].curValue = JOY_AXIS_FWD;
			break;
		case 'p':
			uiGamePad.axisBind[i].generic.name = axisNames[JOY_AXIS_PITCH];
			uiGamePad.axisBind[i].curValue = JOY_AXIS_PITCH;
			break;
		case 'y':
			uiGamePad.axisBind[i].generic.name = axisNames[JOY_AXIS_YAW];
			uiGamePad.axisBind[i].curValue = JOY_AXIS_YAW;
			break;
		case 'r':
			uiGamePad.axisBind[i].generic.name = axisNames[JOY_AXIS_RT];
			uiGamePad.axisBind[i].curValue = JOY_AXIS_RT;
			break;
		case 'l':
			uiGamePad.axisBind[i].generic.name = axisNames[JOY_AXIS_LT];
			uiGamePad.axisBind[i].curValue = JOY_AXIS_LT;
			break;
		default:
			uiGamePad.axisBind[i].generic.name = axisNames[JOY_AXIS_NULL];
			uiGamePad.axisBind[i].curValue = JOY_AXIS_NULL;
		}
	}
}

/*
=================
UI_GamePad_SetConfig
=================
*/
static void UI_GamePad_SetConfig( void )
{
	float side, forward, pitch, yaw;
	char binding[7] = { 0 };

	side = uiGamePad.side.curValue;
	if( uiGamePad.invSide.enabled )
		side *= -1;

	forward = uiGamePad.forward.curValue;
	if( uiGamePad.invFwd.enabled )
		forward *= -1;

	pitch = uiGamePad.pitch.curValue;
	if( uiGamePad.invPitch.enabled )
		pitch *= -1;

	yaw = uiGamePad.yaw.curValue;
	if( uiGamePad.invYaw.enabled )
		yaw *= -1;

	for( int i = 0; i < 6; i++ )
	{
		switch( (int)uiGamePad.axisBind[i].curValue )
		{
		case JOY_AXIS_SIDE: binding[i]  = 's'; break;
		case JOY_AXIS_FWD: binding[i]   = 'f'; break;
		case JOY_AXIS_PITCH: binding[i] = 'p'; break;
		case JOY_AXIS_YAW: binding[i]   = 'y'; break;
		case JOY_AXIS_RT: binding[i]    = 'r'; break;
		case JOY_AXIS_LT: binding[i]    = 'l'; break;
		default: binding[i] = '0'; break;
		}
	}

	CVAR_SET_FLOAT( "joy_side", side );
	CVAR_SET_FLOAT( "joy_forward", forward );
	CVAR_SET_FLOAT( "joy_pitch", pitch );
	CVAR_SET_FLOAT( "joy_yaw", yaw );
	CVAR_SET_FLOAT( "joy_enable", uiGamePad.joyEnable.enabled );
	CVAR_SET_STRING( "joy_axis_binding", binding );
	CLIENT_COMMAND( FALSE, "trysaveconfig\n" );
}

/*
=================
UI_GamePad_UpdateConfig
=================
*/
static void UI_GamePad_UpdateConfig( void )
{
	UI_GamePad_SetConfig();
	UI_GamePad_GetConfig();
}

/*
=================
UI_GamePad_Callback
=================
*/
static void UI_GamePad_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	switch( item->id )
	{
	case ID_INVERT_SIDE:
	case ID_INVERT_FORWARD:
	case ID_INVERT_PITCH:
	case ID_INVERT_YAW:
	case ID_JOY_ENABLE:
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
		break;
	}

	if( event == QM_CHANGED )
	{
		UI_GamePad_UpdateConfig();
		return;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_CONTROLS:
		UI_Controls_Menu();
		break;
	case ID_DONE:
		CLIENT_COMMAND( FALSE, "trysaveconfig\n" );
		UI_PopMenu();
		break;
	}
}

/*
=================
UI_GamePad_Init
=================
*/
static void UI_GamePad_Init( void )
{
	memset( &uiGamePad, 0, sizeof( uiGamePad_t ));

	uiGamePad.menu.vidInitFunc = UI_GamePad_Init;

	uiGamePad.background.generic.id	= ID_BACKGROUND;
	uiGamePad.background.generic.type = QMTYPE_BITMAP;
	uiGamePad.background.generic.flags = QMF_INACTIVE;
	uiGamePad.background.generic.x = 0;
	uiGamePad.background.generic.y = 0;
	uiGamePad.background.generic.width = uiStatic.width;
	uiGamePad.background.generic.height = 768;
	uiGamePad.background.pic = ART_BACKGROUND;

	uiGamePad.banner.generic.id = ID_BANNER;
	uiGamePad.banner.generic.type = QMTYPE_BITMAP;
	uiGamePad.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiGamePad.banner.generic.x = UI_BANNER_POSX;
	uiGamePad.banner.generic.y = UI_BANNER_POSY;
	uiGamePad.banner.generic.width = UI_BANNER_WIDTH;
	uiGamePad.banner.generic.height	= UI_BANNER_HEIGHT;
	uiGamePad.banner.pic = ART_BANNER;

	uiGamePad.done.generic.id = ID_DONE;
	uiGamePad.done.generic.type = QMTYPE_BM_BUTTON;
	uiGamePad.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiGamePad.done.generic.x = 72;
	uiGamePad.done.generic.y = 630;
	uiGamePad.done.generic.name = "Done";
	uiGamePad.done.generic.statusText = "Go back to the Configuration Menu";
	uiGamePad.done.generic.callback = UI_GamePad_Callback;

	UI_UtilSetupPicButton( &uiGamePad.done, PC_DONE );

	uiGamePad.axisBind_label.generic.type = QMTYPE_ACTION;
	uiGamePad.axisBind_label.generic.flags = QMF_CENTER_JUSTIFY|QMF_INACTIVE|QMF_DROPSHADOW;
	uiGamePad.axisBind_label.generic.x = 72;
	uiGamePad.axisBind_label.generic.y = 180;
	uiGamePad.axisBind_label.generic.color = uiColorHelp;
	uiGamePad.axisBind_label.generic.height = 26;
	uiGamePad.axisBind_label.generic.width = 200;
	uiGamePad.axisBind_label.generic.charHeight = 30;
	uiGamePad.axisBind_label.generic.charWidth = 17;
	uiGamePad.axisBind_label.generic.callback = UI_GamePad_Callback;
	uiGamePad.axisBind_label.generic.name = "Axis binding map";


	for( int i = 0, y = 230; i < 6; i++, y += 50 )
	{
		uiGamePad.axisBind[i].generic.id = ID_AXIS_BIND1 + i;
		uiGamePad.axisBind[i].generic.type = QMTYPE_SPINCONTROL;
		uiGamePad.axisBind[i].generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
		uiGamePad.axisBind[i].generic.x = 104;
		uiGamePad.axisBind[i].generic.y = y;
		uiGamePad.axisBind[i].generic.height = 26;
		uiGamePad.axisBind[i].generic.width = 256;
		uiGamePad.axisBind[i].generic.charWidth = 11;
		uiGamePad.axisBind[i].generic.charHeight = 22;
		uiGamePad.axisBind[i].generic.callback = UI_GamePad_Callback;
		uiGamePad.axisBind[i].generic.statusText = "Set axis binding";
		uiGamePad.axisBind[i].minValue = JOY_AXIS_SIDE;
		uiGamePad.axisBind[i].maxValue = JOY_AXIS_NULL;
		uiGamePad.axisBind[i].range = 1;
	}

	uiGamePad.side.generic.id = ID_SIDE;
	uiGamePad.side.generic.type = QMTYPE_SLIDER;
	uiGamePad.side.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiGamePad.side.generic.x = 432;
	uiGamePad.side.generic.y = 250;
	uiGamePad.side.generic.callback = UI_GamePad_Callback;
	uiGamePad.side.generic.name = "Side";
	uiGamePad.side.generic.statusText = "Side movement sensitivity";
	uiGamePad.side.minValue = 0.0f;
	uiGamePad.side.maxValue = 2.0f;
	uiGamePad.side.range = 0.1f;

	uiGamePad.invSide.generic.id = ID_INVERT_SIDE;
	uiGamePad.invSide.generic.type = QMTYPE_CHECKBOX;
	uiGamePad.invSide.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiGamePad.invSide.generic.name = "Invert";
	uiGamePad.invSide.generic.x = 652;
	uiGamePad.invSide.generic.y = 230;
	uiGamePad.invSide.generic.callback = UI_GamePad_Callback;
	uiGamePad.invSide.generic.statusText = "Invert side movement axis";

	uiGamePad.forward.generic.id = ID_FORWARD;
	uiGamePad.forward.generic.type = QMTYPE_SLIDER;
	uiGamePad.forward.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiGamePad.forward.generic.x = 432;
	uiGamePad.forward.generic.y = 300;
	uiGamePad.forward.generic.callback = UI_GamePad_Callback;
	uiGamePad.forward.generic.name = "Forward";
	uiGamePad.forward.generic.statusText = "Forward movement sensitivity";
	uiGamePad.forward.minValue = 0.0f;
	uiGamePad.forward.maxValue = 2.0f;
	uiGamePad.forward.range = 0.1f;

	uiGamePad.invFwd.generic.id = ID_INVERT_FORWARD;
	uiGamePad.invFwd.generic.type = QMTYPE_CHECKBOX;
	uiGamePad.invFwd.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiGamePad.invFwd.generic.name = "Invert";
	uiGamePad.invFwd.generic.x = 652;
	uiGamePad.invFwd.generic.y = 280;
	uiGamePad.invFwd.generic.callback = UI_GamePad_Callback;
	uiGamePad.invFwd.generic.statusText = "Invert forward movement axis";

	uiGamePad.pitch.generic.id = ID_PITCH;
	uiGamePad.pitch.generic.type = QMTYPE_SLIDER;
	uiGamePad.pitch.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiGamePad.pitch.generic.x = 432;
	uiGamePad.pitch.generic.y = 350;
	uiGamePad.pitch.generic.callback = UI_GamePad_Callback;
	uiGamePad.pitch.generic.name = "Pitch";
	uiGamePad.pitch.generic.statusText = "Pitch rotating sensitivity";
	uiGamePad.pitch.minValue = 0.0f;
	uiGamePad.pitch.maxValue = 200.0f;
	uiGamePad.pitch.range = 1.0f;

	uiGamePad.invPitch.generic.id = ID_INVERT_PITCH;
	uiGamePad.invPitch.generic.type = QMTYPE_CHECKBOX;
	uiGamePad.invPitch.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiGamePad.invPitch.generic.name = "Invert";
	uiGamePad.invPitch.generic.x = 652;
	uiGamePad.invPitch.generic.y = 330;
	uiGamePad.invPitch.generic.callback = UI_GamePad_Callback;
	uiGamePad.invPitch.generic.statusText = "Invert pitch axis";

	uiGamePad.yaw.generic.id = ID_YAW;
	uiGamePad.yaw.generic.type = QMTYPE_SLIDER;
	uiGamePad.yaw.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiGamePad.yaw.generic.x = 432;
	uiGamePad.yaw.generic.y = 400;
	uiGamePad.yaw.generic.callback = UI_GamePad_Callback;
	uiGamePad.yaw.generic.name = "Yaw";
	uiGamePad.yaw.generic.statusText = "Yaw rotating sensitivity";
	uiGamePad.yaw.minValue = 0.0f;
	uiGamePad.yaw.maxValue = 200.0f;
	uiGamePad.yaw.range = 1.0f;

	uiGamePad.invYaw.generic.id = ID_INVERT_YAW;
	uiGamePad.invYaw.generic.type = QMTYPE_CHECKBOX;
	uiGamePad.invYaw.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiGamePad.invYaw.generic.name = "Invert";
	uiGamePad.invYaw.generic.x = 652;
	uiGamePad.invYaw.generic.y = 380;
	uiGamePad.invYaw.generic.callback = UI_GamePad_Callback;
	uiGamePad.invYaw.generic.statusText = "Invert yaw axis";

	uiGamePad.joyEnable.generic.id = ID_JOY_ENABLE;
	uiGamePad.joyEnable.generic.type = QMTYPE_CHECKBOX;
	uiGamePad.joyEnable.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiGamePad.joyEnable.generic.name = "Enable gamepad";
	uiGamePad.joyEnable.generic.x = 72;
	uiGamePad.joyEnable.generic.y = 530;
	uiGamePad.joyEnable.generic.callback = UI_GamePad_Callback;
	uiGamePad.joyEnable.generic.statusText = "Enable gamepad input in game";

	uiGamePad.controls.generic.id = ID_CONTROLS;
	uiGamePad.controls.generic.type = QMTYPE_BM_BUTTON;
	uiGamePad.controls.generic.flags= QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiGamePad.controls.generic.x = 72;
	uiGamePad.controls.generic.y = 580;
	uiGamePad.controls.generic.name = "Controls";
	uiGamePad.controls.generic.callback = UI_GamePad_Callback;
	uiGamePad.controls.generic.statusText = "Set gamepad key bindings";
	UI_UtilSetupPicButton( &uiGamePad.controls, PC_CONTROLS );

	UI_GamePad_GetConfig();

	UI_AddItem( &uiGamePad.menu, &uiGamePad.background );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.banner );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.done );
	for( int i = 0; i < 6; i++ )
	{
		UI_AddItem( &uiGamePad.menu, &uiGamePad.axisBind[i] );
	}
	UI_AddItem( &uiGamePad.menu, &uiGamePad.side );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.invSide );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.forward );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.invFwd );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.pitch );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.invPitch );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.yaw );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.invYaw );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.axisBind_label );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.joyEnable );
	UI_AddItem( &uiGamePad.menu, &uiGamePad.controls );
}

/*
=================
UI_GamePad_Precache
=================
*/
void UI_GamePad_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_GamePad_Menu
=================
*/
void UI_GamePad_Menu( void )
{
	UI_GamePad_Precache();
	UI_GamePad_Init();

	UI_GamePad_UpdateConfig();
	UI_PushMenu( &uiGamePad.menu );
}

```

`mainui/menu_internetgames.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER		"gfx/shell/head_inetgames"

#define ID_BACKGROUND	0
#define ID_BANNER		1
#define ID_JOINGAME		2
#define ID_CREATEGAME	3
#define ID_GAMEINFO		4
#define ID_REFRESH		5
#define ID_DONE		6
#define ID_SERVERSLIST	7
#define ID_TABLEHINT	8
#define ID_NAT			11
#define ID_DIRECT		12

#define ID_MSGBOX	 	9
#define ID_MSGTEXT	 	10
#define ID_YES	 	130
#define ID_NO	 	131

typedef struct
{
	char		gameDescription[UI_MAX_SERVERS][256];
	char		*gameDescriptionPtr[UI_MAX_SERVERS];

	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;
	menuPicButton_s	joinGame;
	menuPicButton_s	createGame;
	menuPicButton_s	gameInfo;
	menuPicButton_s	refresh;
	menuPicButton_s	done;
	menuPicButton_s	direct;
	menuPicButton_s	nat;

	// joingame prompt dialog
	menuAction_s	msgBox;
	menuAction_s	dlgMessage1;
	menuAction_s	dlgMessage2;
	menuPicButton_s	yes;
	menuPicButton_s	no;

	menuScrollList_s	gameList;
	menuAction_s	hintMessage;
	char		hintText[MAX_HINT_TEXT];
	int		refreshTime;
	int		refreshTime2;
} uiInternetGames_t;

static uiInternetGames_t	uiInternetGames;

static void UI_PromptDialog( void )
{
	// toggle main menu between active\inactive
	// show\hide quit dialog
	uiInternetGames.joinGame.generic.flags ^= QMF_INACTIVE;
	uiInternetGames.createGame.generic.flags ^= QMF_INACTIVE;
	uiInternetGames.gameInfo.generic.flags ^= QMF_INACTIVE;
	uiInternetGames.refresh.generic.flags ^= QMF_INACTIVE;
	uiInternetGames.done.generic.flags ^= QMF_INACTIVE;
	uiInternetGames.gameList.generic.flags ^= QMF_INACTIVE;
	uiInternetGames.nat.generic.flags ^= QMF_INACTIVE;
	uiInternetGames.direct.generic.flags ^= QMF_INACTIVE;

	uiInternetGames.msgBox.generic.flags ^= QMF_HIDDEN;
	uiInternetGames.dlgMessage1.generic.flags ^= QMF_HIDDEN;
	uiInternetGames.dlgMessage2.generic.flags ^= QMF_HIDDEN;
	uiInternetGames.no.generic.flags ^= QMF_HIDDEN;
	uiInternetGames.yes.generic.flags ^= QMF_HIDDEN;

}

/*
=================
UI_InternetGames_KeyFunc
=================
*/
static const char *UI_InternetGames_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE && !( uiInternetGames.dlgMessage1.generic.flags & QMF_HIDDEN ))
	{
		UI_PromptDialog();
		return uiSoundNull;
	}
	return UI_DefaultKey( &uiInternetGames.menu, key, down );
}

/*
=================
UI_InternetGames_GetGamesList
=================
*/
static void UI_InternetGames_GetGamesList( void )
{
	int		i;
	const char	*info;

	for( i = 0; i < uiStatic.numServers; i++ )
	{
		if( i >= UI_MAX_SERVERS )
			break;
		info = uiStatic.serverNames[i];

		uiInternetGames.gameDescription[i][0] = 0; // mark this string as empty

		StringConcat( uiInternetGames.gameDescription[i], Info_ValueForKey( info, "host" ), QMSB_GAME_LENGTH );
		AddSpaces( uiInternetGames.gameDescription[i], QMSB_GAME_LENGTH );

		StringConcat( uiInternetGames.gameDescription[i], Info_ValueForKey( info, "map" ), QMSB_MAPNAME_LENGTH );
		AddSpaces( uiInternetGames.gameDescription[i], QMSB_MAPNAME_LENGTH );

		StringConcat( uiInternetGames.gameDescription[i], Info_ValueForKey( info, "numcl" ), QMSB_MAXCL_LENGTH );
		StringConcat( uiInternetGames.gameDescription[i], "\\", QMSB_MAXCL_LENGTH );
		StringConcat( uiInternetGames.gameDescription[i], Info_ValueForKey( info, "maxcl" ), QMSB_MAXCL_LENGTH );
		AddSpaces( uiInternetGames.gameDescription[i], QMSB_MAXCL_LENGTH );

		char ping[10];
		snprintf( ping, 10, "%.f ms", uiStatic.serverPings[i] * 1000 );
		StringConcat( uiInternetGames.gameDescription[i], ping, QMSB_PING_LENGTH );
		AddSpaces( uiInternetGames.gameDescription[i], QMSB_PING_LENGTH );

		uiInternetGames.gameDescriptionPtr[i] = uiInternetGames.gameDescription[i];
	}

	for( ; i < UI_MAX_SERVERS; i++ )
		uiInternetGames.gameDescriptionPtr[i] = NULL;

	uiInternetGames.gameList.itemNames = (const char **)uiInternetGames.gameDescriptionPtr;
	uiInternetGames.gameList.numItems = 0; // reset it
	uiInternetGames.gameList.curItem = 0; // reset it

	if( !uiInternetGames.gameList.generic.charHeight )
		return; // to avoid divide integer by zero

	// count number of items
	while( uiInternetGames.gameList.itemNames[uiInternetGames.gameList.numItems] )
		uiInternetGames.gameList.numItems++;

	// calculate number of visible rows
	uiInternetGames.gameList.numRows = (uiInternetGames.gameList.generic.height2 / uiInternetGames.gameList.generic.charHeight) - 2;
	if( uiInternetGames.gameList.numRows > uiInternetGames.gameList.numItems ) uiInternetGames.gameList.numRows = uiInternetGames.gameList.numItems;

	if( uiStatic.numServers )
		uiInternetGames.joinGame.generic.flags &= ~QMF_GRAYED;
}

/*
=================
UI_InternetGames_JoinGame
=================
*/
static void UI_InternetGames_JoinGame( void )
{
	// close dialog
	if( !(uiInternetGames.yes.generic.flags & QMF_HIDDEN ) )
		UI_PromptDialog();

	if( !strlen( uiInternetGames.gameDescription[uiInternetGames.gameList.curItem] ))
		return;

	CLIENT_JOIN( uiStatic.serverAddresses[uiInternetGames.gameList.curItem] );
	// prevent refresh durning connect
	uiInternetGames.refreshTime = uiStatic.realTime + 999999;
}

#define REFRESH_LIST() \
if( uiStatic.realTime > uiInternetGames.refreshTime2 ) \
{ \
UI_RefreshInternetServerList(); \
uiInternetGames.refreshTime2 = uiStatic.realTime + (CVAR_GET_FLOAT("cl_nat")?4000:1000); \
uiInternetGames.refresh.generic.flags |= QMF_GRAYED; \
if( uiStatic.realTime + 20000 < uiInternetGames.refreshTime ) \
	uiInternetGames.refreshTime = uiStatic.realTime + 20000; \
}

/*
=================
UI_Background_Ownerdraw
=================
*/
static void UI_Background_Ownerdraw( void *self )
{
	if( !CVAR_GET_FLOAT( "cl_background" ))
		UI_DrawBackground_Callback( self );

	if( !CVAR_GET_FLOAT( "cl_nat" ) && uiStatic.realTime > uiInternetGames.refreshTime )
	{
		REFRESH_LIST();
		uiInternetGames.refreshTime = uiStatic.realTime + 20000;
	}
	if( uiStatic.realTime > uiInternetGames.refreshTime2 )
	{
		uiInternetGames.refresh.generic.flags &= ~QMF_GRAYED;
	}

	// serverinfo has been changed update display
	if( uiStatic.updateServers )
	{
		UI_InternetGames_GetGamesList ();
		uiStatic.updateServers = false;
	}
	UI_FillRect( 780 * uiStatic.scaleX, 184 * uiStatic.scaleY, (1000-780) * uiStatic.scaleX, 38 * uiStatic.scaleY, 0x80000000 );
	UI_FillRect( 777 * uiStatic.scaleX, 180 * uiStatic.scaleY, (1000-780+6) * uiStatic.scaleX, 4 * uiStatic.scaleY, 0xFF555555 );
	UI_FillRect( 777 * uiStatic.scaleX, 184 * uiStatic.scaleY, 4 * uiStatic.scaleX, 38 * uiStatic.scaleY, 0xFF555555 );
	if( !CVAR_GET_FLOAT( "cl_nat") )
	{
		uiInternetGames.nat.generic.flags &= ~QMF_GRAYED;
		uiInternetGames.direct.generic.flags |= QMF_GRAYED;
		UI_FillRect( 780 * uiStatic.scaleX, 184 * uiStatic.scaleY, 120 * uiStatic.scaleX, 38 * uiStatic.scaleY, 0xFF555555 );
	}
	else
	{
		uiInternetGames.direct.generic.flags &= ~QMF_GRAYED;
		uiInternetGames.nat.generic.flags |= QMF_GRAYED;
		UI_FillRect( 900 * uiStatic.scaleX, 184 * uiStatic.scaleY, 102 * uiStatic.scaleX, 38 * uiStatic.scaleY, 0xFF555555 );
	}

	UI_FillRect( 338 * uiStatic.scaleX, 223 * uiStatic.scaleY, 662 * uiStatic.scaleX, 34 * uiStatic.scaleY, 0x80000000 );
	UI_FillRect( 340 * uiStatic.scaleX, 221 * uiStatic.scaleY, 662 * uiStatic.scaleX, 4 * uiStatic.scaleY, 0xFF555555 );
	UI_FillRect( 336 * uiStatic.scaleX, 221 * uiStatic.scaleY, 4 * uiStatic.scaleX, 36 * uiStatic.scaleY, 0xFF555555);
	UI_FillRect( (339+660) * uiStatic.scaleX, 184 * uiStatic.scaleY, 4 * uiStatic.scaleX, 72 * uiStatic.scaleY, 0xFF555555);



	//UI_FillRect( 340, 225, 660, 30, 0x80404040 );

}

/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}

/*
=================
UI_InternetGames_Callback
=================
*/
static void UI_InternetGames_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_JOINGAME:
		if( CL_IsActive( ))
			UI_PromptDialog();
		else UI_InternetGames_JoinGame();
		break;
	case ID_CREATEGAME:
		CVAR_SET_FLOAT( "public", 1.0f );
		UI_CreateGame_Menu();
		break;
	case ID_GAMEINFO:
		// UNDONE: not implemented
		break;
	case ID_REFRESH:
		if( uiStatic.realTime > uiInternetGames.refreshTime2 )
		REFRESH_LIST();
		uiInternetGames.refresh.generic.flags |= QMF_GRAYED;
		break;
	case ID_DONE:
		CVAR_SET_FLOAT( "cl_nat", 0 );
		UI_PopMenu();
		break;
	case ID_YES:
		UI_InternetGames_JoinGame();
		break;
	case ID_NO:
		UI_PromptDialog();
		break;
	case ID_DIRECT:
		CVAR_SET_FLOAT( "cl_nat", 0 );
		uiInternetGames.nat.generic.flags &= ~QMF_GRAYED;
		uiInternetGames.direct.generic.flags |= QMF_GRAYED;
		UI_RefreshInternetServerList();
		uiInternetGames.refreshTime2 = uiStatic.realTime + 1000;
		uiStatic.numServers = 0;
		uiInternetGames.gameList.numItems = 0; // reset it
		uiInternetGames.gameList.curItem = 0; // reset it
		uiInternetGames.gameList.numRows = 0;
		for( int i = 0 ; i < UI_MAX_SERVERS; i++ )
			uiInternetGames.gameDescriptionPtr[i] = NULL;
		break;
	case ID_NAT:
		if( uiInternetGames.refreshTime2 > uiStatic.realTime )
			break;
		CVAR_SET_FLOAT( "cl_nat", 1 );
		uiInternetGames.direct.generic.flags &= ~QMF_GRAYED;
		uiInternetGames.nat.generic.flags |= QMF_GRAYED;
		UI_RefreshInternetServerList();
		uiInternetGames.refreshTime2 = uiStatic.realTime + 4000;
		uiStatic.numServers = 0;
		uiInternetGames.gameList.numItems = 0; // reset it
		uiInternetGames.gameList.curItem = 0; // reset it
		uiInternetGames.gameList.numRows = 0;
		for( int i = 0 ; i < UI_MAX_SERVERS; i++ )
			uiInternetGames.gameDescriptionPtr[i] = NULL;
		break;
	}
}

/*
=================
UI_InternetGames_Init
=================
*/
static void UI_InternetGames_Init( void )
{
	memset( &uiInternetGames, 0, sizeof( uiInternetGames_t ));

	uiInternetGames.menu.vidInitFunc = UI_InternetGames_Init;
	uiInternetGames.menu.keyFunc = UI_InternetGames_KeyFunc;

	StringConcat( uiInternetGames.hintText, "Name", QMSB_GAME_LENGTH );
	AddSpaces( uiInternetGames.hintText, QMSB_GAME_LENGTH );
	StringConcat( uiInternetGames.hintText, "Map", QMSB_MAPNAME_LENGTH );
	AddSpaces( uiInternetGames.hintText, QMSB_MAPNAME_LENGTH );
	StringConcat( uiInternetGames.hintText, "Players", QMSB_MAXCL_LENGTH );
	AddSpaces( uiInternetGames.hintText, QMSB_MAXCL_LENGTH );
	StringConcat( uiInternetGames.hintText, "Ping", QMSB_PING_LENGTH );
	AddSpaces( uiInternetGames.hintText, QMSB_PING_LENGTH );

	uiInternetGames.background.generic.id = ID_BACKGROUND;
	uiInternetGames.background.generic.type = QMTYPE_BITMAP;
	uiInternetGames.background.generic.flags = QMF_INACTIVE;
	uiInternetGames.background.generic.x = 0;
	uiInternetGames.background.generic.y = 0;
	uiInternetGames.background.generic.width = uiStatic.width;
	uiInternetGames.background.generic.height = 768;
	uiInternetGames.background.pic = ART_BACKGROUND;
	uiInternetGames.background.generic.ownerdraw = UI_Background_Ownerdraw;

	uiInternetGames.banner.generic.id = ID_BANNER;
	uiInternetGames.banner.generic.type = QMTYPE_BITMAP;
	uiInternetGames.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiInternetGames.banner.generic.x = UI_BANNER_POSX;
	uiInternetGames.banner.generic.y = UI_BANNER_POSY;
	uiInternetGames.banner.generic.width = UI_BANNER_WIDTH;
	uiInternetGames.banner.generic.height = UI_BANNER_HEIGHT;
	uiInternetGames.banner.pic = ART_BANNER;

	uiInternetGames.joinGame.generic.id = ID_JOINGAME;
	uiInternetGames.joinGame.generic.type = QMTYPE_BM_BUTTON;
	uiInternetGames.joinGame.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_GRAYED;
	uiInternetGames.joinGame.generic.x = 72;
	uiInternetGames.joinGame.generic.y = 230;
	uiInternetGames.joinGame.generic.name = "Join game";
	uiInternetGames.joinGame.generic.statusText = "Join to selected game";
	uiInternetGames.joinGame.generic.callback = UI_InternetGames_Callback;

	UI_UtilSetupPicButton( &uiInternetGames.joinGame, PC_JOIN_GAME );

	uiInternetGames.createGame.generic.id = ID_CREATEGAME;
	uiInternetGames.createGame.generic.type = QMTYPE_BM_BUTTON;
	uiInternetGames.createGame.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiInternetGames.createGame.generic.x = 72;
	uiInternetGames.createGame.generic.y = 280;
	uiInternetGames.createGame.generic.name = "Create game";
	uiInternetGames.createGame.generic.statusText = "Create new Internet game";
	uiInternetGames.createGame.generic.callback = UI_InternetGames_Callback;

	UI_UtilSetupPicButton( &uiInternetGames.createGame, PC_CREATE_GAME );

	uiInternetGames.gameInfo.generic.id = ID_GAMEINFO;
	uiInternetGames.gameInfo.generic.type = QMTYPE_BM_BUTTON;
	uiInternetGames.gameInfo.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_GRAYED;
	uiInternetGames.gameInfo.generic.x = 72;
	uiInternetGames.gameInfo.generic.y = 330;
	uiInternetGames.gameInfo.generic.name = "View game info";
	uiInternetGames.gameInfo.generic.statusText = "Get detail game info";
	uiInternetGames.gameInfo.generic.callback = UI_InternetGames_Callback;

	UI_UtilSetupPicButton( &uiInternetGames.gameInfo, PC_VIEW_GAME_INFO );

	uiInternetGames.refresh.generic.id = ID_REFRESH;
	uiInternetGames.refresh.generic.type = QMTYPE_BM_BUTTON;
	uiInternetGames.refresh.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiInternetGames.refresh.generic.x = 72;
	uiInternetGames.refresh.generic.y = 380;
	uiInternetGames.refresh.generic.name = "Refresh";
	uiInternetGames.refresh.generic.statusText = "Refresh servers list";
	uiInternetGames.refresh.generic.callback = UI_InternetGames_Callback;

	UI_UtilSetupPicButton( &uiInternetGames.refresh, PC_REFRESH );

	uiInternetGames.nat.generic.id = ID_NAT;
	uiInternetGames.nat.generic.type = QMTYPE_BM_BUTTON;
	uiInternetGames.nat.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiInternetGames.nat.generic.x = 920;
	uiInternetGames.nat.generic.y = 190;
	uiInternetGames.nat.generic.name = "NAT";
	uiInternetGames.nat.generic.statusText = "NAT-bypassed servers";
	uiInternetGames.nat.generic.callback = UI_InternetGames_Callback;

	uiInternetGames.direct.generic.id = ID_DIRECT;
	uiInternetGames.direct.generic.type = QMTYPE_BM_BUTTON;
	uiInternetGames.direct.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_GRAYED;
	uiInternetGames.direct.generic.x = 785;
	uiInternetGames.direct.generic.y = 190;
	uiInternetGames.direct.generic.name = "Direct";
	uiInternetGames.direct.generic.statusText = "Main servers";
	uiInternetGames.direct.generic.callback = UI_InternetGames_Callback;

	uiInternetGames.done.generic.id = ID_DONE;
	uiInternetGames.done.generic.type = QMTYPE_BM_BUTTON;
	uiInternetGames.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiInternetGames.done.generic.x = 72;
	uiInternetGames.done.generic.y = 430;
	uiInternetGames.done.generic.name = "Done";
	uiInternetGames.done.generic.statusText = "Return to main menu";
	uiInternetGames.done.generic.callback = UI_InternetGames_Callback;

	UI_UtilSetupPicButton( &uiInternetGames.done, PC_DONE );

	uiInternetGames.msgBox.generic.id = ID_MSGBOX;
	uiInternetGames.msgBox.generic.type = QMTYPE_ACTION;
	uiInternetGames.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiInternetGames.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiInternetGames.msgBox.generic.x = DLG_X + 192;
	uiInternetGames.msgBox.generic.y = 256;
	uiInternetGames.msgBox.generic.width = 640;
	uiInternetGames.msgBox.generic.height = 256;

	uiInternetGames.dlgMessage1.generic.id = ID_MSGTEXT;
	uiInternetGames.dlgMessage1.generic.type = QMTYPE_ACTION;
	uiInternetGames.dlgMessage1.generic.flags = QMF_INACTIVE|QMF_HIDDEN|QMF_DROPSHADOW;
	uiInternetGames.dlgMessage1.generic.name = "Join a network game will exit";
	uiInternetGames.dlgMessage1.generic.x = DLG_X + 248;
	uiInternetGames.dlgMessage1.generic.y = 280;

	uiInternetGames.dlgMessage2.generic.id = ID_MSGTEXT;
	uiInternetGames.dlgMessage2.generic.type = QMTYPE_ACTION;
	uiInternetGames.dlgMessage2.generic.flags = QMF_INACTIVE|QMF_HIDDEN|QMF_DROPSHADOW;
	uiInternetGames.dlgMessage2.generic.name = "any current game, OK to exit?";
	uiInternetGames.dlgMessage2.generic.x = DLG_X + 248;
	uiInternetGames.dlgMessage2.generic.y = 310;

	uiInternetGames.yes.generic.id = ID_YES;
	uiInternetGames.yes.generic.type = QMTYPE_BM_BUTTON;
	uiInternetGames.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_HIDDEN|QMF_DROPSHADOW;
	uiInternetGames.yes.generic.name = "Ok";
	uiInternetGames.yes.generic.x = DLG_X + 380;
	uiInternetGames.yes.generic.y = 460;
	uiInternetGames.yes.generic.callback = UI_InternetGames_Callback;

	UI_UtilSetupPicButton( &uiInternetGames.yes, PC_OK );

	uiInternetGames.no.generic.id = ID_NO;
	uiInternetGames.no.generic.type = QMTYPE_BM_BUTTON;
	uiInternetGames.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_HIDDEN|QMF_DROPSHADOW;
	uiInternetGames.no.generic.name = "Cancel";
	uiInternetGames.no.generic.x = DLG_X + 530;
	uiInternetGames.no.generic.y = 460;
	uiInternetGames.no.generic.callback = UI_InternetGames_Callback;

	UI_UtilSetupPicButton( &uiInternetGames.no, PC_CANCEL );

	uiInternetGames.hintMessage.generic.id = ID_TABLEHINT;
	uiInternetGames.hintMessage.generic.type = QMTYPE_ACTION;
	uiInternetGames.hintMessage.generic.flags = QMF_INACTIVE|QMF_SMALLFONT;
	uiInternetGames.hintMessage.generic.color = uiColorHelp;
	uiInternetGames.hintMessage.generic.name = uiInternetGames.hintText;
	uiInternetGames.hintMessage.generic.x = 340;
	uiInternetGames.hintMessage.generic.y = 225;

	uiInternetGames.gameList.generic.id = ID_SERVERSLIST;
	uiInternetGames.gameList.generic.type = QMTYPE_SCROLLLIST;
	uiInternetGames.gameList.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_SMALLFONT;
	uiInternetGames.gameList.generic.x = 340;
	uiInternetGames.gameList.generic.y = 255;
	uiInternetGames.gameList.generic.width = 660;
	uiInternetGames.gameList.generic.height = 440;
	uiInternetGames.gameList.generic.callback = UI_InternetGames_Callback;
	uiInternetGames.gameList.itemNames = (const char **)uiInternetGames.gameDescriptionPtr;

	// server.dll needs for reading savefiles or startup newgame
	if( !CheckGameDll( ))
		uiInternetGames.createGame.generic.flags |= QMF_GRAYED;	// server.dll is missed - remote servers only

	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.background );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.banner );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.joinGame );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.createGame );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.gameInfo );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.refresh );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.done );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.direct );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.nat );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.hintMessage );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.gameList );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.msgBox );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.dlgMessage1 );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.dlgMessage2 );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.no );
	UI_AddItem( &uiInternetGames.menu, (void *)&uiInternetGames.yes );

	uiInternetGames.refreshTime = uiStatic.realTime + 500; // delay before update 0.5 sec
}

/*
=================
UI_InternetGames_Precache
=================
*/
void UI_InternetGames_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_InternetGames_Menu
=================
*/
void UI_InternetGames_Menu( void )
{
	if ( gMenu.m_gameinfo.gamemode == GAME_SINGLEPLAYER_ONLY )
		return;

	// stop demos to allow network sockets to open
	if ( gpGlobals->demoplayback && CVAR_GET_FLOAT( "cl_background" ))
	{
		uiStatic.m_iOldMenuDepth = uiStatic.menuDepth;
		CLIENT_COMMAND( FALSE, "stop\n" );
		uiStatic.m_fDemosPlayed = true;
	}

	UI_InternetGames_Precache();
	UI_InternetGames_Init();

	UI_PushMenu( &uiInternetGames.menu );
}

```

`mainui/menu_langame.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER		"gfx/shell/head_lan"

#define ID_BACKGROUND	0
#define ID_BANNER		1
#define ID_JOINGAME		2
#define ID_CREATEGAME	3
#define ID_GAMEINFO		4
#define ID_REFRESH		5
#define ID_DONE		6
#define ID_SERVERSLIST	7
#define ID_TABLEHINT	8

#define ID_MSGBOX	 	9
#define ID_MSGTEXT	 	10
#define ID_YES	 	130
#define ID_NO	 	131

typedef struct
{
	char		gameDescription[UI_MAX_SERVERS][256];
	char		*gameDescriptionPtr[UI_MAX_SERVERS];

	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;
	menuPicButton_s	joinGame;
	menuPicButton_s	createGame;
	menuPicButton_s	gameInfo;
	menuPicButton_s	refresh;
	menuPicButton_s	done;

	// joingame prompt dialog
	menuAction_s	msgBox;
	menuAction_s	dlgMessage1;
	menuAction_s	dlgMessage2;
	menuPicButton_s	yes;
	menuPicButton_s	no;

	menuScrollList_s	gameList;
	menuAction_s	hintMessage;
	char		hintText[MAX_HINT_TEXT];
	int		refreshTime;
} uiLanGame_t;

static uiLanGame_t	uiLanGame;

static void UI_PromptDialog( void )
{
	// toggle main menu between active\inactive
	// show\hide quit dialog
	uiLanGame.joinGame.generic.flags ^= QMF_INACTIVE; 
	uiLanGame.createGame.generic.flags ^= QMF_INACTIVE;
	uiLanGame.gameInfo.generic.flags ^= QMF_INACTIVE;
	uiLanGame.refresh.generic.flags ^= QMF_INACTIVE;
	uiLanGame.done.generic.flags ^= QMF_INACTIVE;
	uiLanGame.gameList.generic.flags ^= QMF_INACTIVE;

	uiLanGame.msgBox.generic.flags ^= QMF_HIDDEN;
	uiLanGame.dlgMessage1.generic.flags ^= QMF_HIDDEN;
	uiLanGame.dlgMessage2.generic.flags ^= QMF_HIDDEN;
	uiLanGame.no.generic.flags ^= QMF_HIDDEN;
	uiLanGame.yes.generic.flags ^= QMF_HIDDEN;

}

/*
=================
UI_LanGame_KeyFunc
=================
*/
static const char *UI_LanGame_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE && !( uiLanGame.dlgMessage1.generic.flags & QMF_HIDDEN ))
	{
		UI_PromptDialog();
		return uiSoundNull;
	}
	return UI_DefaultKey( &uiLanGame.menu, key, down );
}

/*
=================
UI_LanGame_GetGamesList
=================
*/
static void UI_LanGame_GetGamesList( void )
{
	int		i;
	const char	*info;

	for( i = 0; i < uiStatic.numServers; i++ )
	{
		if( i >= UI_MAX_SERVERS ) break;
		info = uiStatic.serverNames[i];

		uiLanGame.gameDescription[i][0] = 0; // mark this string as empty

		StringConcat( uiLanGame.gameDescription[i], Info_ValueForKey( info, "host" ), QMSB_GAME_LENGTH );
		AddSpaces( uiLanGame.gameDescription[i], QMSB_GAME_LENGTH );

		StringConcat( uiLanGame.gameDescription[i], Info_ValueForKey( info, "map" ), QMSB_MAPNAME_LENGTH );
		AddSpaces( uiLanGame.gameDescription[i], QMSB_MAPNAME_LENGTH );

		StringConcat( uiLanGame.gameDescription[i], Info_ValueForKey( info, "numcl" ), QMSB_MAXCL_LENGTH );
		StringConcat( uiLanGame.gameDescription[i], "\\", QMSB_MAXCL_LENGTH );
		StringConcat( uiLanGame.gameDescription[i], Info_ValueForKey( info, "maxcl" ), QMSB_MAXCL_LENGTH );
		AddSpaces( uiLanGame.gameDescription[i], QMSB_MAXCL_LENGTH );

		char ping[10];
		snprintf( ping, 10, "%.f ms", uiStatic.serverPings[i] * 1000 );
		StringConcat( uiLanGame.gameDescription[i], ping, QMSB_PING_LENGTH );
		AddSpaces( uiLanGame.gameDescription[i], QMSB_PING_LENGTH );

		uiLanGame.gameDescriptionPtr[i] = uiLanGame.gameDescription[i];
	}

	for( ; i < UI_MAX_SERVERS; i++ )
		uiLanGame.gameDescriptionPtr[i] = NULL;

	uiLanGame.gameList.itemNames = (const char **)uiLanGame.gameDescriptionPtr;
	uiLanGame.gameList.numItems = 0; // reset it

	if( !uiLanGame.gameList.generic.charHeight )
		return; // to avoid divide integer by zero

	// count number of items
	while( uiLanGame.gameList.itemNames[uiLanGame.gameList.numItems] )
		uiLanGame.gameList.numItems++;

	// calculate number of visible rows
	uiLanGame.gameList.numRows = (uiLanGame.gameList.generic.height2 / uiLanGame.gameList.generic.charHeight) - 2;
	if( uiLanGame.gameList.numRows > uiLanGame.gameList.numItems ) uiLanGame.gameList.numRows = uiLanGame.gameList.numItems;

	if( uiStatic.numServers )
		uiLanGame.joinGame.generic.flags &= ~QMF_GRAYED;
}

/*
=================
UI_LanGame_JoinGame
=================
*/
static void UI_LanGame_JoinGame( void )
{
	if( !strlen( uiLanGame.gameDescription[uiLanGame.gameList.curItem] ))
		return;

	CLIENT_JOIN( uiStatic.serverAddresses[uiLanGame.gameList.curItem] );
}

/*
=================
UI_Background_Ownerdraw
=================
*/
static void UI_Background_Ownerdraw( void *self )
{
	if( !CVAR_GET_FLOAT( "cl_background" ))
		UI_DrawBackground_Callback( self );

	if( uiStatic.realTime > uiLanGame.refreshTime )
	{
		uiLanGame.refreshTime = uiStatic.realTime + 10000; // refresh every 10 secs
		UI_RefreshServerList();
	}

	// serverinfo has been changed update display
	if( uiStatic.updateServers )
	{
		UI_LanGame_GetGamesList ();
		uiStatic.updateServers = false;
	}
}

/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}

/*
=================
UI_LanGame_Callback
=================
*/
static void UI_LanGame_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_JOINGAME:
		if( CL_IsActive( ))
			UI_PromptDialog();
		else UI_LanGame_JoinGame();
		break;
	case ID_CREATEGAME:
		CVAR_SET_FLOAT( "public", 0.0f );
		UI_CreateGame_Menu();
		break;
	case ID_GAMEINFO:
		// UNDONE: not implemented
		break;
	case ID_REFRESH:
		UI_RefreshServerList();
		break;
	case ID_DONE:
		UI_PopMenu();
		break;
	case ID_YES:
		UI_LanGame_JoinGame();
		break;
	case ID_NO:
		UI_PromptDialog();
		break;
	}
}

/*
=================
UI_LanGame_Init
=================
*/
static void UI_LanGame_Init( void )
{
	memset( &uiLanGame, 0, sizeof( uiLanGame_t ));

	uiLanGame.menu.vidInitFunc = UI_LanGame_Init;
	uiLanGame.menu.keyFunc = UI_LanGame_KeyFunc;

	StringConcat( uiLanGame.hintText, "Name", QMSB_GAME_LENGTH );
	AddSpaces( uiLanGame.hintText, QMSB_GAME_LENGTH );
	StringConcat( uiLanGame.hintText, "Map", QMSB_MAPNAME_LENGTH );
	AddSpaces( uiLanGame.hintText, QMSB_MAPNAME_LENGTH );
	StringConcat( uiLanGame.hintText, "Players", QMSB_MAXCL_LENGTH );
	AddSpaces( uiLanGame.hintText, QMSB_MAXCL_LENGTH );
	StringConcat( uiLanGame.hintText, "Ping", QMSB_PING_LENGTH );
	AddSpaces( uiLanGame.hintText, QMSB_PING_LENGTH );

	uiLanGame.background.generic.id = ID_BACKGROUND;
	uiLanGame.background.generic.type = QMTYPE_BITMAP;
	uiLanGame.background.generic.flags = QMF_INACTIVE;
	uiLanGame.background.generic.x = 0;
	uiLanGame.background.generic.y = 0;
	uiLanGame.background.generic.width = uiStatic.width;
	uiLanGame.background.generic.height = 768;
	uiLanGame.background.pic = ART_BACKGROUND;
	uiLanGame.background.generic.ownerdraw = UI_Background_Ownerdraw;

	uiLanGame.banner.generic.id = ID_BANNER;
	uiLanGame.banner.generic.type = QMTYPE_BITMAP;
	uiLanGame.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiLanGame.banner.generic.x = UI_BANNER_POSX;
	uiLanGame.banner.generic.y = UI_BANNER_POSY;
	uiLanGame.banner.generic.width = UI_BANNER_WIDTH;
	uiLanGame.banner.generic.height = UI_BANNER_HEIGHT;
	uiLanGame.banner.pic = ART_BANNER;

	uiLanGame.joinGame.generic.id = ID_JOINGAME;
	uiLanGame.joinGame.generic.type = QMTYPE_BM_BUTTON;
	uiLanGame.joinGame.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_GRAYED;
	uiLanGame.joinGame.generic.x = 72;
	uiLanGame.joinGame.generic.y = 230;
	uiLanGame.joinGame.generic.name = "Join game";
	uiLanGame.joinGame.generic.statusText = "Join to selected game";
	uiLanGame.joinGame.generic.callback = UI_LanGame_Callback;

	UI_UtilSetupPicButton( &uiLanGame.joinGame, PC_JOIN_GAME );

	uiLanGame.createGame.generic.id = ID_CREATEGAME;
	uiLanGame.createGame.generic.type = QMTYPE_BM_BUTTON;
	uiLanGame.createGame.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiLanGame.createGame.generic.x = 72;
	uiLanGame.createGame.generic.y = 280;
	uiLanGame.createGame.generic.name = "Create game";
	uiLanGame.createGame.generic.statusText = "Create new LAN game";
	uiLanGame.createGame.generic.callback = UI_LanGame_Callback;

	UI_UtilSetupPicButton( &uiLanGame.createGame, PC_CREATE_GAME );

	uiLanGame.gameInfo.generic.id = ID_GAMEINFO;
	uiLanGame.gameInfo.generic.type = QMTYPE_BM_BUTTON;
	uiLanGame.gameInfo.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_GRAYED;
	uiLanGame.gameInfo.generic.x = 72;
	uiLanGame.gameInfo.generic.y = 330;
	uiLanGame.gameInfo.generic.name = "View game info";
	uiLanGame.gameInfo.generic.statusText = "Get detail game info";
	uiLanGame.gameInfo.generic.callback = UI_LanGame_Callback;

	UI_UtilSetupPicButton( &uiLanGame.gameInfo, PC_VIEW_GAME_INFO );

	uiLanGame.refresh.generic.id = ID_REFRESH;
	uiLanGame.refresh.generic.type = QMTYPE_BM_BUTTON;
	uiLanGame.refresh.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiLanGame.refresh.generic.x = 72;
	uiLanGame.refresh.generic.y = 380;
	uiLanGame.refresh.generic.name = "Refresh";
	uiLanGame.refresh.generic.statusText = "Refresh servers list";
	uiLanGame.refresh.generic.callback = UI_LanGame_Callback;

	UI_UtilSetupPicButton( &uiLanGame.refresh, PC_REFRESH );

	uiLanGame.done.generic.id = ID_DONE;
	uiLanGame.done.generic.type = QMTYPE_BM_BUTTON;
	uiLanGame.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiLanGame.done.generic.x = 72;
	uiLanGame.done.generic.y = 430;
	uiLanGame.done.generic.name = "Done";
	uiLanGame.done.generic.statusText = "Return to main menu";
	uiLanGame.done.generic.callback = UI_LanGame_Callback;

	UI_UtilSetupPicButton( &uiLanGame.done, PC_DONE );

	uiLanGame.msgBox.generic.id = ID_MSGBOX;
	uiLanGame.msgBox.generic.type = QMTYPE_ACTION;
	uiLanGame.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiLanGame.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiLanGame.msgBox.generic.x = DLG_X + 192;
	uiLanGame.msgBox.generic.y = 256;
	uiLanGame.msgBox.generic.width = 640;
	uiLanGame.msgBox.generic.height = 256;

	uiLanGame.dlgMessage1.generic.id = ID_MSGTEXT;
	uiLanGame.dlgMessage1.generic.type = QMTYPE_ACTION;
	uiLanGame.dlgMessage1.generic.flags = QMF_INACTIVE|QMF_HIDDEN|QMF_DROPSHADOW;
	uiLanGame.dlgMessage1.generic.name = "Join a network game will exit";
	uiLanGame.dlgMessage1.generic.x = DLG_X + 248;
	uiLanGame.dlgMessage1.generic.y = 280;

	uiLanGame.dlgMessage2.generic.id = ID_MSGTEXT;
	uiLanGame.dlgMessage2.generic.type = QMTYPE_ACTION;
	uiLanGame.dlgMessage2.generic.flags = QMF_INACTIVE|QMF_HIDDEN|QMF_DROPSHADOW;
	uiLanGame.dlgMessage2.generic.name = "any current game, OK to exit?";
	uiLanGame.dlgMessage2.generic.x = DLG_X + 248;
	uiLanGame.dlgMessage2.generic.y = 310;

	uiLanGame.yes.generic.id = ID_YES;
	uiLanGame.yes.generic.type = QMTYPE_BM_BUTTON;
	uiLanGame.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_HIDDEN|QMF_DROPSHADOW;
	uiLanGame.yes.generic.name = "Ok";
	uiLanGame.yes.generic.x = DLG_X + 380;
	uiLanGame.yes.generic.y = 460;
	uiLanGame.yes.generic.callback = UI_LanGame_Callback;

	UI_UtilSetupPicButton( &uiLanGame.yes, PC_OK );

	uiLanGame.no.generic.id = ID_NO;
	uiLanGame.no.generic.type = QMTYPE_BM_BUTTON;
	uiLanGame.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_HIDDEN|QMF_DROPSHADOW;
	uiLanGame.no.generic.name = "Cancel";
	uiLanGame.no.generic.x = DLG_X + 530;
	uiLanGame.no.generic.y = 460;
	uiLanGame.no.generic.callback = UI_LanGame_Callback;

	UI_UtilSetupPicButton( &uiLanGame.no, PC_CANCEL );

	uiLanGame.hintMessage.generic.id = ID_TABLEHINT;
	uiLanGame.hintMessage.generic.type = QMTYPE_ACTION;
	uiLanGame.hintMessage.generic.flags = QMF_INACTIVE|QMF_SMALLFONT;
	uiLanGame.hintMessage.generic.color = uiColorHelp;
	uiLanGame.hintMessage.generic.name = uiLanGame.hintText;
	uiLanGame.hintMessage.generic.x = 360;
	uiLanGame.hintMessage.generic.y = 225;

	uiLanGame.gameList.generic.id = ID_SERVERSLIST;
	uiLanGame.gameList.generic.type = QMTYPE_SCROLLLIST;
	uiLanGame.gameList.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_SMALLFONT;
	uiLanGame.gameList.generic.x = 340;
	uiLanGame.gameList.generic.y = 255;
	uiLanGame.gameList.generic.width = 660;
	uiLanGame.gameList.generic.height = 440;
	uiLanGame.gameList.generic.callback = UI_LanGame_Callback;
	uiLanGame.gameList.itemNames = (const char **)uiLanGame.gameDescriptionPtr;

	// server.dll needs for reading savefiles or startup newgame
	if( !CheckGameDll( ))
		uiLanGame.createGame.generic.flags |= QMF_GRAYED;	// server.dll is missed - remote servers only

	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.background );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.banner );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.joinGame );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.createGame );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.gameInfo );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.refresh );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.done );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.hintMessage );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.gameList );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.msgBox );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.dlgMessage1 );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.dlgMessage2 );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.no );
 	UI_AddItem( &uiLanGame.menu, (void *)&uiLanGame.yes );

	uiLanGame.refreshTime = uiStatic.realTime + 500; // delay before update 0.5 sec
}

/*
=================
UI_LanGame_Precache
=================
*/
void UI_LanGame_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_LanGame_Menu
=================
*/
void UI_LanGame_Menu( void )
{
	if ( gMenu.m_gameinfo.gamemode == GAME_SINGLEPLAYER_ONLY )
		return;

	// stop demos to allow network sockets to open
	if ( gpGlobals->demoplayback && CVAR_GET_FLOAT( "cl_background" ))
	{
		uiStatic.m_iOldMenuDepth = uiStatic.menuDepth;
		CLIENT_COMMAND( FALSE, "stop\n" );
		uiStatic.m_fDemosPlayed = true;
	}

	UI_LanGame_Precache();
	UI_LanGame_Init();

	uiLanGame.refreshTime = uiStatic.realTime + 10000; // refresh every 10 secs
	UI_RefreshServerList();

	UI_PushMenu( &uiLanGame.menu );
}

```

`mainui/menu_main.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"
#include "menu_btnsbmp_table.h"
#include "menu_strings.h"

#define ART_MINIMIZE_N	"gfx/shell/min_n"
#define ART_MINIMIZE_F	"gfx/shell/min_f"
#define ART_MINIMIZE_D	"gfx/shell/min_d"
#define ART_CLOSEBTN_N	"gfx/shell/cls_n"
#define ART_CLOSEBTN_F	"gfx/shell/cls_f"
#define ART_CLOSEBTN_D	"gfx/shell/cls_d"

#define ID_BACKGROUND	0
#define ID_CONSOLE		1
#define ID_RESUME		2
#define ID_NEWGAME		3
#define ID_CONFIGURATION 5
#define ID_MULTIPLAYER	7
#define ID_PREVIEWS		9
#define ID_QUIT		10
#define ID_QUIT_BUTTON	11
#define ID_MINIMIZE		12
#define ID_MSGBOX	 	13
#define ID_MSGTEXT	 	14
#define ID_DISCONNECT	15
#define ID_YES	 	130
#define ID_NO	 	131
#define ID_OK       132

typedef struct
{
	menuFramework_s	menu;

	menuBitmap_s	background;
	menuPicButton_s	console;
	menuPicButton_s	resumeGame;
	menuPicButton_s	disconnect;
	menuPicButton_s	newGame;
	menuPicButton_s	configuration;
	menuPicButton_s	multiPlayer;
	menuPicButton_s	credits;
	menuPicButton_s	quit;

	menuBitmap_s	minimizeBtn;
	menuBitmap_s	quitButton;

	// quit dialog
	menuAction_s	msgBox;
	menuAction_s	quitMessage;
	menuAction_s	dlgMessage1;
	menuPicButton_s	yes;
	menuPicButton_s	no;
	menuPicButton_s	ok;
	void ( *promptAction )( void );
	int promptAlert; // no cancel button
} uiMain_t;

static uiMain_t		uiMain;

/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}

/*
=================
UI_Background_Ownerdraw
=================
*/
static void UI_Background_Ownerdraw( void *self )
{
	// map has background
	if( CVAR_GET_FLOAT( "cl_background" ))
		return;

	UI_DrawBackground_Callback( self );

	if (uiStatic.m_fHaveSteamBackground || uiStatic.m_fDisableLogo)
		return; // no logos for steam background

	if( GetLogoLength() <= 0.05f || GetLogoWidth() <= 32 )
		return;	// don't draw stub logo (GoldSrc rules)

	float	logoWidth, logoHeight, logoPosY;
	float	scaleX, scaleY;

	scaleX = ScreenWidth / 640.0f;
	scaleY = ScreenHeight / 480.0f;

	logoWidth = GetLogoWidth() * scaleX;
	logoHeight = GetLogoHeight() * scaleY;
	logoPosY = 70 * scaleY;	// 70 it's empirically determined value (magic number)

	DRAW_LOGO( "logo.avi", 0, logoPosY, logoWidth, logoHeight );
}

static void UI_QuitDialog( void )
{
	// toggle main menu between active\inactive
	// show\hide quit dialog
	uiMain.console.generic.flags ^= QMF_INACTIVE;
	uiMain.resumeGame.generic.flags ^= QMF_INACTIVE;
	uiMain.disconnect.generic.flags ^= QMF_INACTIVE;
	uiMain.newGame.generic.flags ^= QMF_INACTIVE;
	uiMain.configuration.generic.flags ^= QMF_INACTIVE;
	uiMain.multiPlayer.generic.flags ^= QMF_INACTIVE;
	uiMain.credits.generic.flags ^= QMF_INACTIVE;
	uiMain.quit.generic.flags ^= QMF_INACTIVE;
	uiMain.minimizeBtn.generic.flags ^= QMF_INACTIVE;
	uiMain.quitButton.generic.flags ^= QMF_INACTIVE;

	uiMain.msgBox.generic.flags ^= QMF_HIDDEN;
	uiMain.quitMessage.generic.flags ^= QMF_HIDDEN;
	uiMain.no.generic.flags ^= QMF_HIDDEN;
	uiMain.yes.generic.flags ^= QMF_HIDDEN;

}

static void UI_PromptDialog( void )
{
	// toggle main menu between active\inactive
	// show\hide quit dialog
	uiMain.console.generic.flags ^= QMF_INACTIVE;
	uiMain.resumeGame.generic.flags ^= QMF_INACTIVE;
	uiMain.disconnect.generic.flags ^= QMF_INACTIVE;
	uiMain.newGame.generic.flags ^= QMF_INACTIVE;
	uiMain.configuration.generic.flags ^= QMF_INACTIVE;
	uiMain.multiPlayer.generic.flags ^= QMF_INACTIVE;
	uiMain.credits.generic.flags ^= QMF_INACTIVE;
	uiMain.quit.generic.flags ^= QMF_INACTIVE;
	uiMain.minimizeBtn.generic.flags ^= QMF_INACTIVE;
	uiMain.quitButton.generic.flags ^= QMF_INACTIVE;

	uiMain.msgBox.generic.flags ^= QMF_HIDDEN;
	uiMain.dlgMessage1.generic.flags ^= QMF_HIDDEN;
	if( uiMain.promptAlert )
		uiMain.ok.generic.flags ^= QMF_HIDDEN;
	else
	{
		uiMain.no.generic.flags ^= QMF_HIDDEN;
		uiMain.yes.generic.flags ^= QMF_HIDDEN;
	}
}

static void UI_ShowPrompt( void ( *action )( void ), const char *message )
{
	uiMain.promptAction = action;
	uiMain.dlgMessage1.generic.name = message;
	UI_PromptDialog();
}

void UI_ShowMessageBox( void )
{
	static char msg[1024];

	strncpy( msg, CMD_ARGV(1), 1023 );
	msg[1023] = 0;

	UI_SetActiveMenu( TRUE );

	UI_Main_Menu();
	uiMain.dlgMessage1.generic.name = msg;
	uiMain.promptAlert = 1;
	UI_PromptDialog();
}

/*
=================
UI_Main_KeyFunc
=================
*/
static const char *UI_Main_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE )
	{
		if ( CL_IsActive( ))
		{
			if(!( uiMain.dlgMessage1.generic.flags & QMF_HIDDEN ))
				UI_PromptDialog();
			else if(!( uiMain.quitMessage.generic.flags & QMF_HIDDEN ))
				UI_QuitDialog();
			else UI_CloseMenu();
		}
		else UI_QuitDialog();
		return uiSoundNull;
	}
	return UI_DefaultKey( &uiMain.menu, key, down );
}

/*
=================
UI_Main_ActivateFunc
=================
*/
static void UI_Main_ActivateFunc( void )
{
	if ( !CL_IsActive( ))
	{
		uiMain.resumeGame.generic.flags |= QMF_HIDDEN;
		uiMain.disconnect.generic.flags |= QMF_HIDDEN;
	}

	if( gpGlobals->developer )
	{
		uiMain.console.generic.y = CL_IsActive() ? 280 : 380;
		UI_ScaleCoords( NULL, &uiMain.console.generic.y, NULL, NULL );
	}
}

static void UI_Main_Disconnect( void )
{
	if( CVAR_GET_FLOAT( "host_serverstate" ) )
		CLIENT_COMMAND( TRUE, "endgame;wait;wait;wait;menu_options;menu_main\n");
	else
		CLIENT_COMMAND( TRUE, "cmd disconnect;wait;wait;wait;menu_options;menu_main\n");
	UI_Main_Menu();
}

/*
=================
UI_Main_Callback
=================
*/
static void UI_Main_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	switch( item->id )
	{
	case ID_QUIT_BUTTON:
		if( event == QM_PRESSED )
			((menuBitmap_s *)self)->focusPic = ART_CLOSEBTN_D;
		else ((menuBitmap_s *)self)->focusPic = ART_CLOSEBTN_F;
		break;
	case ID_MINIMIZE:
		if( event == QM_PRESSED )
			((menuBitmap_s *)self)->focusPic = ART_MINIMIZE_D;
		else ((menuBitmap_s *)self)->focusPic = ART_MINIMIZE_F;
		break;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_CONSOLE:
		UI_SetActiveMenu( FALSE );
		KEY_SetDest( KEY_CONSOLE );
		break;
	case ID_RESUME:
		UI_CloseMenu();
		break;
	case ID_DISCONNECT:
		UI_ShowPrompt( UI_Main_Disconnect, "Really disconnect?" );
		break;
	case ID_NEWGAME:
		CVAR_SET_FLOAT( "public", 0 );
		UI_CreateGame_Menu();
		break;
	case ID_MULTIPLAYER:
		UI_MultiPlayer_Menu();
		break;
	case ID_CONFIGURATION:
		UI_Options_Menu();
		break;
	case ID_PREVIEWS:
		UI_Credits_Menu();
		break;
	case ID_QUIT:
	case ID_QUIT_BUTTON:
		UI_QuitDialog();
		break;
	case ID_MINIMIZE:
		CLIENT_COMMAND( FALSE, "minimize\n" );
		break;
	case ID_YES:
		if( !( uiMain.quitMessage.generic.flags & QMF_HIDDEN ))
			CLIENT_COMMAND( FALSE, "quit\n" );
		else
			uiMain.promptAction();
		break;
	case ID_OK:
		UI_PromptDialog();
		uiMain.promptAlert = 0;
		break;
	case ID_NO:
		if( !( uiMain.quitMessage.generic.flags & QMF_HIDDEN ))
			UI_QuitDialog();
		else UI_PromptDialog();
		break;
	}
}

/*
=================
UI_Main_Init
=================
*/
static void UI_Main_Init( void )
{
	memset( &uiMain, 0, sizeof( uiMain_t ));

	// precache .avi file and get logo width and height
	PRECACHE_LOGO( "logo.avi" );

	uiMain.menu.vidInitFunc = UI_Main_Init;
	uiMain.menu.keyFunc = UI_Main_KeyFunc;
	uiMain.menu.activateFunc = UI_Main_ActivateFunc;

	uiMain.background.generic.id = ID_BACKGROUND;
	uiMain.background.generic.type = QMTYPE_BITMAP;
	uiMain.background.generic.flags = QMF_INACTIVE;
	uiMain.background.generic.x = 0;
	uiMain.background.generic.y = 0;
	uiMain.background.generic.width = uiStatic.width;
	uiMain.background.generic.height = 768;
	uiMain.background.pic = ART_BACKGROUND;
	uiMain.background.generic.ownerdraw = UI_Background_Ownerdraw;

	uiMain.console.generic.id = ID_CONSOLE;
	uiMain.console.generic.type = QMTYPE_BM_BUTTON;
	uiMain.console.generic.name = "Console";
	uiMain.console.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiMain.console.generic.x = 72;
	uiMain.console.generic.y = CL_IsActive() ? 280 : 380;
	uiMain.console.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.console, PC_CONSOLE );

	uiMain.resumeGame.generic.id = ID_RESUME;
	uiMain.resumeGame.generic.type = QMTYPE_BM_BUTTON;
	uiMain.resumeGame.generic.name = "Resume game";
	uiMain.resumeGame.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMain.resumeGame.generic.statusText = MenuStrings[HINT_RESUME_GAME];
	uiMain.resumeGame.generic.x = 72;
	uiMain.resumeGame.generic.y = 330;
	uiMain.resumeGame.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.resumeGame, PC_RESUME_GAME );

	uiMain.disconnect.generic.id = ID_DISCONNECT;
	uiMain.disconnect.generic.type = QMTYPE_BM_BUTTON;
	uiMain.disconnect.generic.name = "Disconnect";
	uiMain.disconnect.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMain.disconnect.generic.statusText = "Disconnect from server";
	uiMain.disconnect.generic.x = 72;
	uiMain.disconnect.generic.y = 380;
	uiMain.disconnect.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.disconnect, PC_DISCONNECT );

	uiMain.newGame.generic.id = ID_NEWGAME;
	uiMain.newGame.generic.type = QMTYPE_BM_BUTTON;
	uiMain.newGame.generic.name = "Create game";
	uiMain.newGame.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMain.newGame.generic.statusText = "Start a local game server";
	uiMain.newGame.generic.x = 72;
	uiMain.newGame.generic.y = 430;
	uiMain.newGame.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.newGame, PC_CREATE_GAME );

	// server.dll needs for reading savefiles or startup newgame
	if( !CheckGameDll( ))
	{
		uiMain.newGame.generic.flags |= QMF_GRAYED;
	}

	uiMain.configuration.generic.id = ID_CONFIGURATION;
	uiMain.configuration.generic.type = QMTYPE_BM_BUTTON;
	uiMain.configuration.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMain.configuration.generic.name = "Configuration";
	uiMain.configuration.generic.statusText = MenuStrings[HINT_CONFIGURATION];
	uiMain.configuration.generic.x = 72;
	uiMain.configuration.generic.y = 480;
	uiMain.configuration.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.configuration, PC_CONFIG );

	uiMain.multiPlayer.generic.id = ID_MULTIPLAYER;
	uiMain.multiPlayer.generic.type = QMTYPE_BM_BUTTON;
	uiMain.multiPlayer.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMain.multiPlayer.generic.name = "Multiplayer";
	uiMain.multiPlayer.generic.statusText = MenuStrings[HINT_MULTIPLAYER];
	uiMain.multiPlayer.generic.x = 72;
	uiMain.multiPlayer.generic.y = 530;
	uiMain.multiPlayer.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.multiPlayer, PC_MULTIPLAYER );

	uiMain.credits.generic.id = ID_PREVIEWS;
	uiMain.credits.generic.type = QMTYPE_BM_BUTTON;
	uiMain.credits.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMain.credits.generic.name = "Credits";
	uiMain.credits.generic.statusText = "Developer credits";
	uiMain.credits.generic.x = 72;
	uiMain.credits.generic.y = 580;
	uiMain.credits.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.credits, PC_VIEW_README );

	uiMain.quit.generic.id = ID_QUIT;
	uiMain.quit.generic.type = QMTYPE_BM_BUTTON;
	uiMain.quit.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMain.quit.generic.name = "Quit";
	uiMain.quit.generic.statusText = MenuStrings[HINT_QUIT_BUTTON];
	uiMain.quit.generic.x = 72;
	uiMain.quit.generic.y = 630;
	uiMain.quit.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.quit, PC_QUIT );

	uiMain.minimizeBtn.generic.id = ID_MINIMIZE;
	uiMain.minimizeBtn.generic.type = QMTYPE_BITMAP;
	uiMain.minimizeBtn.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_MOUSEONLY|QMF_ACT_ONRELEASE;
	uiMain.minimizeBtn.generic.x = uiStatic.width - 72;
	uiMain.minimizeBtn.generic.y = 13;
	uiMain.minimizeBtn.generic.width = 32;
	uiMain.minimizeBtn.generic.height = 32;
	uiMain.minimizeBtn.generic.callback = UI_Main_Callback;
	uiMain.minimizeBtn.pic = ART_MINIMIZE_N;
	uiMain.minimizeBtn.focusPic = ART_MINIMIZE_F;

	uiMain.quitButton.generic.id = ID_QUIT_BUTTON;
	uiMain.quitButton.generic.type = QMTYPE_BITMAP;
	uiMain.quitButton.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_MOUSEONLY|QMF_ACT_ONRELEASE;
	uiMain.quitButton.generic.x = uiStatic.width - 36;
	uiMain.quitButton.generic.y = 13;
	uiMain.quitButton.generic.width = 32;
	uiMain.quitButton.generic.height = 32;
	uiMain.quitButton.generic.callback = UI_Main_Callback;
	uiMain.quitButton.pic = ART_CLOSEBTN_N;
	uiMain.quitButton.focusPic = ART_CLOSEBTN_F;

	uiMain.msgBox.generic.id = ID_MSGBOX;
	uiMain.msgBox.generic.type = QMTYPE_ACTION;
	uiMain.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiMain.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiMain.msgBox.generic.x = DLG_X + 192;
	uiMain.msgBox.generic.y = 256;
	uiMain.msgBox.generic.width = 640;
	uiMain.msgBox.generic.height = 256;

	uiMain.quitMessage.generic.id = ID_MSGBOX;
	uiMain.quitMessage.generic.type = QMTYPE_ACTION;
	uiMain.quitMessage.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN|QMF_CENTER_JUSTIFY;
	uiMain.quitMessage.generic.name = (CL_IsActive( )) ? MenuStrings[HINT_QUIT_ACTIVE] : MenuStrings[HINT_QUIT];
	uiMain.quitMessage.generic.x = DLG_X + 192;
	uiMain.quitMessage.generic.y = 280;
	uiMain.quitMessage.generic.width = 640;
	uiMain.quitMessage.generic.height = 256;

	uiMain.dlgMessage1.generic.id = ID_MSGTEXT;
	uiMain.dlgMessage1.generic.type = QMTYPE_ACTION;
	uiMain.dlgMessage1.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN|QMF_CENTER_JUSTIFY;
	uiMain.dlgMessage1.generic.name = MenuStrings[HINT_RESTART_HZ];
	uiMain.dlgMessage1.generic.x = DLG_X + 192;
	uiMain.dlgMessage1.generic.y = 280;
	uiMain.dlgMessage1.generic.width = 640;
	uiMain.dlgMessage1.generic.height = 256;

	uiMain.yes.generic.id = ID_YES;
	uiMain.yes.generic.type = QMTYPE_BM_BUTTON;
	uiMain.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiMain.yes.generic.name = "Ok";
	uiMain.yes.generic.x = DLG_X + 380;
	uiMain.yes.generic.y = 460;
	uiMain.yes.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.yes, PC_OK );

	uiMain.ok.generic.id = ID_OK;
	uiMain.ok.generic.type = QMTYPE_BM_BUTTON;
	uiMain.ok.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiMain.ok.generic.name = "Ok";
	uiMain.ok.generic.x = DLG_X + 490;
	uiMain.ok.generic.y = 460;
	uiMain.ok.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.ok, PC_OK );

	uiMain.no.generic.id = ID_NO;
	uiMain.no.generic.type = QMTYPE_BM_BUTTON;
	uiMain.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiMain.no.generic.name = "Cancel";
	uiMain.no.generic.x = DLG_X + 530;
	uiMain.no.generic.y = 460;
	uiMain.no.generic.callback = UI_Main_Callback;

	UI_UtilSetupPicButton( &uiMain.no, PC_CANCEL );

	UI_AddItem( &uiMain.menu, (void *)&uiMain.background );

	if ( gpGlobals->developer )
		UI_AddItem( &uiMain.menu, (void *)&uiMain.console );

	UI_AddItem( &uiMain.menu, (void *)&uiMain.disconnect );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.resumeGame );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.newGame );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.configuration );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.multiPlayer );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.credits );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.quit );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.minimizeBtn );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.quitButton );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.msgBox );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.quitMessage );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.dlgMessage1 );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.no );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.yes );
	UI_AddItem( &uiMain.menu, (void *)&uiMain.ok );
}

/*
=================
UI_Main_Precache
=================
*/
void UI_Main_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_MINIMIZE_N );
	PIC_Load( ART_MINIMIZE_F );
	PIC_Load( ART_MINIMIZE_D );
	PIC_Load( ART_CLOSEBTN_N );
	PIC_Load( ART_CLOSEBTN_F );
	PIC_Load( ART_CLOSEBTN_D );

	// precache .avi file and get logo width and height
	PRECACHE_LOGO( "logo.avi" );
}

/*
=================
UI_Main_Menu
=================
*/
void UI_Main_Menu( void )
{
	UI_Main_Precache();
	UI_Main_Init();

	UI_PushMenu( &uiMain.menu );
}

```

`mainui/menu_multiplayer.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_btnsbmp_table.h"
#include "keydefs.h"

#define ART_BANNER			"gfx/shell/head_multi"

#define ID_BACKGROUND		0
#define ID_BANNER			1

#define ID_INTERNETGAMES		2
#define ID_SPECTATEGAMES		3
#define ID_LANGAME			4
#define ID_CUSTOMIZE		5
#define ID_CONTROLS			6
#define ID_DONE			7

#define ID_MSGBOX	 	8
#define ID_MSGTEXT	 	9
#define ID_YES		130
#define ID_NO	 	131

typedef struct
{
	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	internetGames;
	menuPicButton_s	spectateGames;
	menuPicButton_s	LANGame;
	menuPicButton_s	Customize;	// playersetup
	menuPicButton_s	Controls;
	menuPicButton_s	done;

	// prompt dialog
	menuAction_s	msgBox;
	menuAction_s	promptMessage;
	menuAction_s	promptMessage2;
	menuAction_s	promptMessage3;
	menuPicButton_s	yes;
	menuPicButton_s	no;
} uiMultiPlayer_t;

static uiMultiPlayer_t	uiMultiPlayer;

/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}

static void UI_PredictDialog( void )
{
	// toggle main menu between active\inactive
	// show\hide remove dialog
	uiMultiPlayer.internetGames.generic.flags ^= QMF_INACTIVE;
	uiMultiPlayer.spectateGames.generic.flags ^= QMF_INACTIVE;
	uiMultiPlayer.LANGame.generic.flags ^= QMF_INACTIVE;
	uiMultiPlayer.Customize.generic.flags ^= QMF_INACTIVE;
	uiMultiPlayer.Controls.generic.flags ^= QMF_INACTIVE;
	uiMultiPlayer.done.generic.flags ^= QMF_INACTIVE;

	uiMultiPlayer.msgBox.generic.flags ^= QMF_HIDDEN;
	uiMultiPlayer.promptMessage.generic.flags ^= QMF_HIDDEN;
	uiMultiPlayer.promptMessage2.generic.flags ^= QMF_HIDDEN;
	uiMultiPlayer.promptMessage3.generic.flags ^= QMF_HIDDEN;
	uiMultiPlayer.no.generic.flags ^= QMF_HIDDEN;
	uiMultiPlayer.yes.generic.flags ^= QMF_HIDDEN;
}


/*
=================
UI_Multiplayer_KeyFunc
=================
*/
static const char *UI_Multiplayer_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE && !( uiMultiPlayer.promptMessage.generic.flags & QMF_HIDDEN ))
	{
		UI_PredictDialog();
		return uiSoundNull;
	}
	return UI_DefaultKey( &uiMultiPlayer.menu, key, down );
}


/*
=================
UI_MultiPlayer_Callback
=================
*/
static void UI_MultiPlayer_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_INTERNETGAMES:
		UI_InternetGames_Menu();
		break;
	case ID_SPECTATEGAMES:
		// UNDONE: not implemented
		break;
	case ID_LANGAME:
		UI_LanGame_Menu();
		break;
	case ID_CUSTOMIZE:
		UI_PlayerSetup_Menu();
		break;
	case ID_CONTROLS:
		UI_Controls_Menu();
		break;
	case ID_DONE:
		UI_PopMenu();
		break;
	case ID_YES:
		CVAR_SET_FLOAT( "cl_predict", 1 );
	case ID_NO:
		CVAR_SET_FLOAT( "menu_mp_firsttime", 0 );
		UI_PredictDialog();
		break;
	}
}

/*
=================
UI_MultiPlayer_Init
=================
*/
static void UI_MultiPlayer_Init( void )
{
	memset( &uiMultiPlayer, 0, sizeof( uiMultiPlayer_t ));
	uiMultiPlayer.menu.keyFunc = UI_Multiplayer_KeyFunc;

	uiMultiPlayer.menu.vidInitFunc = UI_MultiPlayer_Init;

	uiMultiPlayer.background.generic.id = ID_BACKGROUND;
	uiMultiPlayer.background.generic.type = QMTYPE_BITMAP;
	uiMultiPlayer.background.generic.flags = QMF_INACTIVE;
	uiMultiPlayer.background.generic.x = 0;
	uiMultiPlayer.background.generic.y = 0;
	uiMultiPlayer.background.generic.width = uiStatic.width;
	uiMultiPlayer.background.generic.height = 768;
	uiMultiPlayer.background.pic = ART_BACKGROUND;

	uiMultiPlayer.banner.generic.id = ID_BANNER;
	uiMultiPlayer.banner.generic.type = QMTYPE_BITMAP;
	uiMultiPlayer.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiMultiPlayer.banner.generic.x = UI_BANNER_POSX;
	uiMultiPlayer.banner.generic.y = UI_BANNER_POSY;
	uiMultiPlayer.banner.generic.width = UI_BANNER_WIDTH;
	uiMultiPlayer.banner.generic.height = UI_BANNER_HEIGHT;
	uiMultiPlayer.banner.pic = ART_BANNER;

	uiMultiPlayer.internetGames.generic.id = ID_INTERNETGAMES;
	uiMultiPlayer.internetGames.generic.type = QMTYPE_BM_BUTTON;
	uiMultiPlayer.internetGames.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMultiPlayer.internetGames.generic.x = 72;
	uiMultiPlayer.internetGames.generic.y = 230;
	uiMultiPlayer.internetGames.generic.name = "Internet games";
	uiMultiPlayer.internetGames.generic.statusText = "View list of a game internet servers and join the one of your choise";
	uiMultiPlayer.internetGames.generic.callback = UI_MultiPlayer_Callback;

	UI_UtilSetupPicButton( &uiMultiPlayer.internetGames, PC_INET_GAME );

	uiMultiPlayer.spectateGames.generic.id = ID_SPECTATEGAMES;
	uiMultiPlayer.spectateGames.generic.type = QMTYPE_BM_BUTTON;
	uiMultiPlayer.spectateGames.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY|QMF_GRAYED;
	uiMultiPlayer.spectateGames.generic.x = 72;
	uiMultiPlayer.spectateGames.generic.y = 280;
	uiMultiPlayer.spectateGames.generic.name = "Spectate games";
	uiMultiPlayer.spectateGames.generic.statusText = "Spectate internet games";
	uiMultiPlayer.spectateGames.generic.callback = UI_MultiPlayer_Callback;

	UI_UtilSetupPicButton( &uiMultiPlayer.spectateGames, PC_SPECTATE_GAMES );

	uiMultiPlayer.LANGame.generic.id = ID_LANGAME;
	uiMultiPlayer.LANGame.generic.type = QMTYPE_BM_BUTTON;
	uiMultiPlayer.LANGame.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMultiPlayer.LANGame.generic.x = 72;
	uiMultiPlayer.LANGame.generic.y = 330;
	uiMultiPlayer.LANGame.generic.name = "LAN game";
	uiMultiPlayer.LANGame.generic.statusText = "Set up the game on the local area network";
	uiMultiPlayer.LANGame.generic.callback = UI_MultiPlayer_Callback;

	UI_UtilSetupPicButton( &uiMultiPlayer.LANGame, PC_LAN_GAME );

	uiMultiPlayer.Customize.generic.id = ID_CUSTOMIZE;
	uiMultiPlayer.Customize.generic.type = QMTYPE_BM_BUTTON;
	uiMultiPlayer.Customize.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMultiPlayer.Customize.generic.x = 72;
	uiMultiPlayer.Customize.generic.y = 380;
	uiMultiPlayer.Customize.generic.name = "Customize";
	uiMultiPlayer.Customize.generic.statusText = "Choose your player name, and select visual options for your character";
	uiMultiPlayer.Customize.generic.callback = UI_MultiPlayer_Callback;

	UI_UtilSetupPicButton( &uiMultiPlayer.Customize, PC_CUSTOMIZE );

	uiMultiPlayer.Controls.generic.id = ID_CONTROLS;
	uiMultiPlayer.Controls.generic.type = QMTYPE_BM_BUTTON;
	uiMultiPlayer.Controls.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMultiPlayer.Controls.generic.x = 72;
	uiMultiPlayer.Controls.generic.y = 430;
	uiMultiPlayer.Controls.generic.name = "Controls";
	uiMultiPlayer.Controls.generic.statusText = "Change keyboard and mouse settings";
	uiMultiPlayer.Controls.generic.callback = UI_MultiPlayer_Callback;

	UI_UtilSetupPicButton( &uiMultiPlayer.Controls, PC_CONTROLS );

	uiMultiPlayer.done.generic.id = ID_DONE;
	uiMultiPlayer.done.generic.type = QMTYPE_BM_BUTTON;
	uiMultiPlayer.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiMultiPlayer.done.generic.x = 72;
	uiMultiPlayer.done.generic.y = 480;
	uiMultiPlayer.done.generic.name = "Done";
	uiMultiPlayer.done.generic.statusText = "Go back to the Main Menu";
	uiMultiPlayer.done.generic.callback = UI_MultiPlayer_Callback;

	UI_UtilSetupPicButton( &uiMultiPlayer.done, PC_DONE );

	uiMultiPlayer.msgBox.generic.id = ID_MSGBOX;
	uiMultiPlayer.msgBox.generic.type = QMTYPE_ACTION;
	uiMultiPlayer.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiMultiPlayer.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiMultiPlayer.msgBox.generic.x = DLG_X + 192;
	uiMultiPlayer.msgBox.generic.y = 256;
	uiMultiPlayer.msgBox.generic.width = 640;
	uiMultiPlayer.msgBox.generic.height = 256;

	uiMultiPlayer.promptMessage.generic.id = ID_MSGBOX;
	uiMultiPlayer.promptMessage.generic.type = QMTYPE_ACTION;
	uiMultiPlayer.promptMessage.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN;
	uiMultiPlayer.promptMessage.generic.name = "It is recomended to enable\nclient movement prediction";
	uiMultiPlayer.promptMessage.generic.x = DLG_X + 270;
	uiMultiPlayer.promptMessage.generic.y = 280;

	uiMultiPlayer.promptMessage2.generic.id = ID_MSGBOX;
	uiMultiPlayer.promptMessage2.generic.type = QMTYPE_ACTION;
	uiMultiPlayer.promptMessage2.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN;
	uiMultiPlayer.promptMessage2.generic.name = " Or enable it later in\n^5(Multiplayer/Customize)";
	uiMultiPlayer.promptMessage2.generic.x = DLG_X + 310;
	uiMultiPlayer.promptMessage2.generic.y = 340;

	uiMultiPlayer.promptMessage3.generic.id = ID_MSGBOX;
	uiMultiPlayer.promptMessage3.generic.type = QMTYPE_ACTION;
	uiMultiPlayer.promptMessage3.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN;
	uiMultiPlayer.promptMessage3.generic.name = "Press OK to enable it now";
	uiMultiPlayer.promptMessage3.generic.x = DLG_X + 290;
	uiMultiPlayer.promptMessage3.generic.y = 400;

	uiMultiPlayer.yes.generic.id = ID_YES;
	uiMultiPlayer.yes.generic.type = QMTYPE_BM_BUTTON;
	uiMultiPlayer.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiMultiPlayer.yes.generic.name = "Ok";
	uiMultiPlayer.yes.generic.x = DLG_X + 380;
	uiMultiPlayer.yes.generic.y = 460;
	uiMultiPlayer.yes.generic.callback = UI_MultiPlayer_Callback;

	UI_UtilSetupPicButton( &uiMultiPlayer.yes, PC_OK );

	uiMultiPlayer.no.generic.id = ID_NO;
	uiMultiPlayer.no.generic.type = QMTYPE_BM_BUTTON;
	uiMultiPlayer.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiMultiPlayer.no.generic.name = "Cancel";
	uiMultiPlayer.no.generic.x = DLG_X + 530;
	uiMultiPlayer.no.generic.y = 460;
	uiMultiPlayer.no.generic.callback = UI_MultiPlayer_Callback;
	UI_UtilSetupPicButton( &uiMultiPlayer.no, PC_CANCEL );

	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.background );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.banner );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.internetGames );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.spectateGames );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.LANGame );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.Customize );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.Controls );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.done );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.msgBox );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.promptMessage );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.promptMessage2 );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.promptMessage3 );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.no );
	UI_AddItem( &uiMultiPlayer.menu, (void *)&uiMultiPlayer.yes );
}

/*
=================
UI_MultiPlayer_Precache
=================
*/
void UI_MultiPlayer_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_MultiPlayer_Menu
=================
*/
void UI_MultiPlayer_Menu( void )
{
	if ( gMenu.m_gameinfo.gamemode == GAME_SINGLEPLAYER_ONLY )
		return;

	UI_MultiPlayer_Precache();
	UI_MultiPlayer_Init();

	UI_PushMenu( &uiMultiPlayer.menu );
}

```

`mainui/menu_playersetup.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "mathlib.h"
#include "extdll.h"
#include "const.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"
#include "ref_params.h"
#include "cl_entity.h"
#include "entity_types.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER		"gfx/shell/head_customize"

#undef ID_BACKGROUND
#undef ID_BANNER
enum
{
	ID_BACKGROUND = 0,
	ID_BANNER,
	ID_DONE,
	ID_ADVOPTIONS,
	ID_NAME,
	ID_CROSSHAIRVIEW,
	ID_CROSSHAIRSIZE,
	ID_CROSSHAIRTRANSLUCENCY,
	ID_CROSSHAIRCOLOR,
	ID_SPRAYVIEW,
	ID_SPRAYDECAL,
	ID_SPRAYCOLOR
};

#define MAX_SPRAYDECALS	50

struct uiPlayerSetup_t
{
	menuFramework_s	menu;
	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuField_s	name;
	menuPicButton_s	done;
	menuPicButton_s	AdvOptions;

	menuBitmap_s	  crosshairView;
	menuSpinControl_s crosshairSize;
	menuSpinControl_s crosshairColor;
	menuCheckBox_s    crosshairTranslucent;

#if 0
	char	sprays[MAX_SPRAYDECALS][CS_SIZE];
	int		num_sprays;
	char	currentspray[CS_SIZE];

	menuBitmap_s	  sprayView;
	menuSpinControl_s sprayDecals;
	menuSpinControl_s sprayColor;
#endif

	HIMAGE uiWhite;
};

static uiPlayerSetup_t	uiPlayerSetup;

static char g_szCrosshairAvailColors[6][CS_SIZE] =
{
	"Green", "Red", "Blue", "Yellow", "Ltblue", ""
};
static byte g_iCrosshairAvailColors[6][3] =
{
	{ 50,  250, 50  },
	{ 250, 50,  50  },
	{ 50,  50,  250 },
	{ 250, 250, 50  },
	{ 50,  250, 250 },
	{ 0,   0,   0   }
};
static char g_szCrosshairAvailSizes[4][CS_SIZE] =
{
	"auto", "small", "medium", "large"
};

/*
=================
UI_PlayerSetup_FindSprayDecals
=================
*/
#if 0
static void UI_PlayerSetup_FindSprayDecals( void )
{
	char	**filenames;
	int	numFiles;

	uiPlayerSetup.num_sprays = 0;

	// Get file list
	filenames = FS_SEARCH( "logos/*.bmp", &numFiles, FALSE );

	// build the spray list
	for( int i = 0; i < numFiles; i++ )
	{
		if( !FILE_EXISTS( filenames[i] )) continue;

		strcpy( uiPlayerSetup.sprays[uiPlayerSetup.num_sprays], filenames[i] );
		uiPlayerSetup.num_sprays++;
	}
}
#endif
/*
=================
UI_PlayerSetup_GetConfig
=================
*/
static void UI_PlayerSetup_GetConfig( void )
{
	strncpy( uiPlayerSetup.name.buffer, CVAR_GET_STRING( "name" ), sizeof( uiPlayerSetup.name.buffer ));

	char curColor[CS_SIZE];
	int rgb[3];
	strncpy( curColor, CVAR_GET_STRING("cl_crosshair_color"), CS_SIZE);
	sscanf( curColor, "%d %d %d", rgb, rgb + 1, rgb + 2 );

	// check for custom colors
	int i;
	for( i = 0; i < 5; i++)
	{
		if( rgb[0] == g_iCrosshairAvailColors[i][0] &&
			rgb[1] == g_iCrosshairAvailColors[i][1] &&
			rgb[2] == g_iCrosshairAvailColors[i][2] )
		{
			break;
		}
	}

	if( i == 5 )
	{
		strcpy( g_szCrosshairAvailColors[i], curColor );
		g_iCrosshairAvailColors[i][0] = rgb[0];
		g_iCrosshairAvailColors[i][1] = rgb[1];
		g_iCrosshairAvailColors[i][2] = rgb[2];
		uiPlayerSetup.crosshairColor.maxValue = 5;
	}
	else
	{
		g_szCrosshairAvailColors[5][0] = '\0'; // mark that we're not used custom colors
		uiPlayerSetup.crosshairColor.maxValue = 4;
	}

	uiPlayerSetup.crosshairColor.generic.name = g_szCrosshairAvailColors[i];
	uiPlayerSetup.crosshairColor.curValue = i;

	static char crosshairSize[CS_SIZE];
	strncpy( crosshairSize, CVAR_GET_STRING( "cl_crosshair_size" ), CS_SIZE );
    for( i = 0; i < 4; i++ )
	{
		if( !stricmp( crosshairSize, g_szCrosshairAvailSizes[i] ) )
		{
			uiPlayerSetup.crosshairSize.generic.name = g_szCrosshairAvailSizes[i];
			break;
		}
	}
	// fix possible errors
	if( i == 4 )
	{
		uiPlayerSetup.crosshairSize.generic.name = g_szCrosshairAvailSizes[0];
		CVAR_SET_STRING( "cl_crosshair_size", "auto" );
	}
	if( CVAR_GET_FLOAT( "cl_crosshair_translucent") )
		uiPlayerSetup.crosshairTranslucent.enabled = 1;
}

/*
=================
UI_PlayerSetup_SetConfig
=================
*/
static void UI_PlayerSetup_SetConfig( void )
{
    CVAR_SET_STRING( "name", uiPlayerSetup.name.buffer );
	char curColor[CS_SIZE];
	int i = uiPlayerSetup.crosshairColor.curValue;
	snprintf( curColor, CS_SIZE, "%i %i %i",
			  g_iCrosshairAvailColors[i][0],
			  g_iCrosshairAvailColors[i][1],
			  g_iCrosshairAvailColors[i][2]
			);
	CVAR_SET_STRING( "cl_crosshair_color", curColor );
	CVAR_SET_STRING( "cl_crosshair_size", uiPlayerSetup.crosshairSize.generic.name );
	CVAR_SET_FLOAT( "cl_crosshair_translucent", uiPlayerSetup.crosshairTranslucent.enabled );
}

/*
=================
UI_PlayerSetup_UpdateConfig
=================
*/
static void UI_PlayerSetup_UpdateConfig( void )
{
    CVAR_SET_STRING( "name", uiPlayerSetup.name.buffer );
	char curColor[CS_SIZE];
	int i = uiPlayerSetup.crosshairColor.curValue;
	snprintf( curColor, CS_SIZE, "%i %i %i",
			  g_iCrosshairAvailColors[i][0],
			  g_iCrosshairAvailColors[i][1],
			  g_iCrosshairAvailColors[i][2]
			);
	CVAR_SET_STRING( "cl_crosshair_color", curColor );
	uiPlayerSetup.crosshairColor.generic.name = g_szCrosshairAvailColors[i];

	i = uiPlayerSetup.crosshairSize.curValue;
	uiPlayerSetup.crosshairSize.generic.name = g_szCrosshairAvailSizes[i];

	CVAR_SET_STRING( "cl_crosshair_size", uiPlayerSetup.crosshairSize.generic.name );
	CVAR_SET_FLOAT( "cl_crosshair_translucent", uiPlayerSetup.crosshairTranslucent.enabled );
}

/*
=================
UI_PlayerSetup_Callback
=================
*/
static void UI_PlayerSetup_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	/*if( item->id >= ID_DONE || item->id <= ID_SPRAYCOLOR )
	{
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
	}*/

	if( event == QM_CHANGED )
	{
		UI_PlayerSetup_UpdateConfig();
		return;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		UI_PlayerSetup_SetConfig();
		UI_PopMenu();
		break;
	case ID_ADVOPTIONS:
		UI_PlayerSetup_SetConfig();
		UI_GameOptions_Menu();
		break;
	}
}

/*
=================
UI_Crosshair_Ownerdraw
=================
*/
static void UI_Crosshair_Ownerdraw( void *self )
{
	menuBitmap_s *item = (menuBitmap_s*)self;

	UI_DrawPic(item->generic.x, item->generic.y, item->generic.width, item->generic.height, 0x00FFFFFF, "gfx/vgui/crosshair" );


	int l;
	switch( (int)uiPlayerSetup.crosshairSize.curValue )
	{
	case 1:
		l = 10;
		break;
	case 2:
		l = 20;
		break;
	case 3:
		l = 30;
		break;
	case 0:
		if( ScreenWidth < 640 )
			l = 30;
		else if( ScreenWidth < 1024 )
			l = 20;
		else l = 10;
	}

	l *= ScreenHeight / 768.0f;

	int x = item->generic.x, // xpos
		y = item->generic.y, // ypos
		w = item->generic.width, // width
		h = item->generic.height, // height
		// delta distance
		d = (item->generic.width / 2 - l) * 0.5,
		// alpha
		a = 180,
		// red
		r = g_iCrosshairAvailColors[(int)uiPlayerSetup.crosshairColor.curValue][0],
		// green
		g = g_iCrosshairAvailColors[(int)uiPlayerSetup.crosshairColor.curValue][1],
		// blue
		b = g_iCrosshairAvailColors[(int)uiPlayerSetup.crosshairColor.curValue][2];

	if( uiPlayerSetup.crosshairTranslucent.enabled )
	{
		// verical
		PIC_Set(uiPlayerSetup.uiWhite, r, g, b, a);
		PIC_DrawTrans(x + w / 2, y + d,         1, l );

		PIC_Set(uiPlayerSetup.uiWhite, r, g, b, a);
		PIC_DrawTrans(x + w / 2, y + h / 2 + d, 1, l );

		// horizontal
		PIC_Set(uiPlayerSetup.uiWhite, r, g, b, a);
		PIC_DrawTrans(x + d,         y + h / 2, l, 1 );

		PIC_Set(uiPlayerSetup.uiWhite, r, g, b, a);
		PIC_DrawTrans(x + w / 2 + d, y + h / 2, l, 1 );
	}
	else
	{
		// verical
		PIC_Set(uiPlayerSetup.uiWhite, r, g, b, a);
		PIC_DrawAdditive(x + w / 2, y + d,         1, l );

		PIC_Set(uiPlayerSetup.uiWhite, r, g, b, a);
		PIC_DrawAdditive(x + w / 2, y + h / 2 + d, 1, l );

		// horizontal
		PIC_Set(uiPlayerSetup.uiWhite, r, g, b, a);
		PIC_DrawAdditive(x + d,         y + h / 2, l, 1 );

		PIC_Set(uiPlayerSetup.uiWhite, r, g, b, a);
		PIC_DrawAdditive(x + w / 2 + d, y + h / 2, l, 1 );
	}

#if 0
	// verical
	FillRGBA(x + w / 2, y + d,         1, l, r, g, b, a);
	FillRGBA(x + w / 2, y + h / 2 + d, 1, l, r, g, b, a);

	// horizontal
	FillRGBA(x + d,         y + h / 2, l, 1, r, g, b, a);
	FillRGBA(x + w / 2 + d, y + h / 2, l, 1, r, g, b, a);
#endif
}

/*
=================
UI_PlayerSetup_Init
=================
*/
static void UI_PlayerSetup_Init( void )
{
	memset( &uiPlayerSetup, 0, sizeof( uiPlayerSetup_t ));

	uiPlayerSetup.menu.vidInitFunc = UI_PlayerSetup_Init;

	uiPlayerSetup.uiWhite = PIC_Load("*white");

	uiPlayerSetup.background.generic.id = ID_BACKGROUND;
	uiPlayerSetup.background.generic.type = QMTYPE_BITMAP;
	uiPlayerSetup.background.generic.flags = QMF_INACTIVE;
	uiPlayerSetup.background.generic.x = 0;
	uiPlayerSetup.background.generic.y = 0;
	uiPlayerSetup.background.generic.width = uiStatic.width;
	uiPlayerSetup.background.generic.height = 768;
	uiPlayerSetup.background.pic = ART_BACKGROUND;

	uiPlayerSetup.banner.generic.id = ID_BANNER;
	uiPlayerSetup.banner.generic.type = QMTYPE_BITMAP;
	uiPlayerSetup.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiPlayerSetup.banner.generic.x = UI_BANNER_POSX;
	uiPlayerSetup.banner.generic.y = UI_BANNER_POSY;
	uiPlayerSetup.banner.generic.width = UI_BANNER_WIDTH;
	uiPlayerSetup.banner.generic.height = UI_BANNER_HEIGHT;
	uiPlayerSetup.banner.pic = ART_BANNER;

	uiPlayerSetup.done.generic.id = ID_DONE;
	uiPlayerSetup.done.generic.type = QMTYPE_BM_BUTTON;
	uiPlayerSetup.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiPlayerSetup.done.generic.x = 72;
	uiPlayerSetup.done.generic.y = 230;
	uiPlayerSetup.done.generic.name = "Done";
	uiPlayerSetup.done.generic.statusText = "Go back to the Multiplayer Menu";
	uiPlayerSetup.done.generic.callback = UI_PlayerSetup_Callback;

	UI_UtilSetupPicButton( &uiPlayerSetup.done, PC_DONE );

	uiPlayerSetup.AdvOptions.generic.id = ID_ADVOPTIONS;
	uiPlayerSetup.AdvOptions.generic.type = QMTYPE_BM_BUTTON;
	uiPlayerSetup.AdvOptions.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiPlayerSetup.AdvOptions.generic.x = 72;
	uiPlayerSetup.AdvOptions.generic.y = 280;
	uiPlayerSetup.AdvOptions.generic.name = "Adv. Options";
	uiPlayerSetup.AdvOptions.generic.statusText = "Configure handness, fov and other advanced options";
	uiPlayerSetup.AdvOptions.generic.callback = UI_PlayerSetup_Callback;

	UI_UtilSetupPicButton( &uiPlayerSetup.AdvOptions, PC_ADV_OPT );

	uiPlayerSetup.name.generic.id = ID_NAME;
	uiPlayerSetup.name.generic.type = QMTYPE_FIELD;
	uiPlayerSetup.name.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiPlayerSetup.name.generic.x = 320;
	uiPlayerSetup.name.generic.y = 260;
	uiPlayerSetup.name.generic.width = 256;
	uiPlayerSetup.name.generic.height = 36;
	uiPlayerSetup.name.generic.callback = UI_PlayerSetup_Callback;
	uiPlayerSetup.name.generic.statusText = "Enter your multiplayer display name";
	uiPlayerSetup.name.maxLength = 32;

	uiPlayerSetup.crosshairView.generic.id = ID_CROSSHAIRVIEW;
	uiPlayerSetup.crosshairView.generic.type = QMTYPE_BITMAP;
	uiPlayerSetup.crosshairView.generic.flags = QMF_INACTIVE;
	uiPlayerSetup.crosshairView.generic.x = 320;
	uiPlayerSetup.crosshairView.generic.y = 310;
	uiPlayerSetup.crosshairView.generic.width = 96;
	uiPlayerSetup.crosshairView.generic.height = 96;
	uiPlayerSetup.crosshairView.generic.callback = UI_PlayerSetup_Callback;
	uiPlayerSetup.crosshairView.generic.ownerdraw = UI_Crosshair_Ownerdraw;
	uiPlayerSetup.crosshairView.generic.statusText = "Choose dynamic crosshair";
	uiPlayerSetup.crosshairView.pic = "gfx/vgui/crosshair";

	uiPlayerSetup.crosshairSize.generic.id = ID_CROSSHAIRSIZE;
	uiPlayerSetup.crosshairSize.generic.type = QMTYPE_SPINCONTROL;
	uiPlayerSetup.crosshairSize.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiPlayerSetup.crosshairSize.generic.x = 480;
	uiPlayerSetup.crosshairSize.generic.y = 315;
	uiPlayerSetup.crosshairSize.generic.height = 26;
	uiPlayerSetup.crosshairSize.generic.width = 256;
	uiPlayerSetup.crosshairSize.generic.callback = UI_PlayerSetup_Callback;
	uiPlayerSetup.crosshairSize.generic.statusText = "Set crosshair size";
	uiPlayerSetup.crosshairSize.minValue = 0;
	uiPlayerSetup.crosshairSize.maxValue = 3;
	uiPlayerSetup.crosshairSize.range	 = 1;

	uiPlayerSetup.crosshairColor.generic.id = ID_CROSSHAIRCOLOR;
	uiPlayerSetup.crosshairColor.generic.type = QMTYPE_SPINCONTROL;
	uiPlayerSetup.crosshairColor.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiPlayerSetup.crosshairColor.generic.x = 480;
	uiPlayerSetup.crosshairColor.generic.y = 375;
	uiPlayerSetup.crosshairColor.generic.height = 26;
	uiPlayerSetup.crosshairColor.generic.width = 256;
	uiPlayerSetup.crosshairColor.generic.callback = UI_PlayerSetup_Callback;
	uiPlayerSetup.crosshairColor.generic.statusText = "Set crosshair color";
	uiPlayerSetup.crosshairColor.minValue = 0;
	uiPlayerSetup.crosshairColor.maxValue = 4;
	uiPlayerSetup.crosshairColor.range	  = 1;

	uiPlayerSetup.crosshairTranslucent.generic.id = ID_CROSSHAIRCOLOR;
	uiPlayerSetup.crosshairTranslucent.generic.type = QMTYPE_CHECKBOX;
	uiPlayerSetup.crosshairTranslucent.generic.flags = QMF_HIGHLIGHTIFFOCUS | QMF_ACT_ONRELEASE | QMF_DROPSHADOW;
	uiPlayerSetup.crosshairTranslucent.generic.x = 320;
	uiPlayerSetup.crosshairTranslucent.generic.y = 420;
	uiPlayerSetup.crosshairTranslucent.generic.callback = UI_PlayerSetup_Callback;
	uiPlayerSetup.crosshairTranslucent.generic.name = "Translucent crosshair";
	uiPlayerSetup.crosshairTranslucent.generic.statusText = "Set additive render crosshair";

	UI_PlayerSetup_GetConfig();

	UI_AddItem( &uiPlayerSetup.menu, (void *)&uiPlayerSetup.background );
	UI_AddItem( &uiPlayerSetup.menu, (void *)&uiPlayerSetup.banner );
	UI_AddItem( &uiPlayerSetup.menu, (void *)&uiPlayerSetup.done );
	UI_AddItem( &uiPlayerSetup.menu, (void *)&uiPlayerSetup.AdvOptions );
	UI_AddItem( &uiPlayerSetup.menu, (void *)&uiPlayerSetup.name );
	UI_AddItem( &uiPlayerSetup.menu, (void *)&uiPlayerSetup.crosshairView );
	UI_AddItem( &uiPlayerSetup.menu, (void *)&uiPlayerSetup.crosshairSize );
	UI_AddItem( &uiPlayerSetup.menu, (void *)&uiPlayerSetup.crosshairTranslucent );
	UI_AddItem( &uiPlayerSetup.menu, (void *)&uiPlayerSetup.crosshairColor );

}

/*
=================
UI_PlayerSetup_Precache
=================
*/
void UI_PlayerSetup_Precache( void )
{
	PIC_Load( "gfx/vgui/crosshair" );
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_PlayerSetup_Menu
=================
*/
void UI_PlayerSetup_Menu( void )
{
	if ( gMenu.m_gameinfo.gamemode == GAME_SINGLEPLAYER_ONLY )
		return;

	UI_PlayerSetup_Precache();
	UI_PlayerSetup_Init();

	UI_PlayerSetup_UpdateConfig();
	UI_PushMenu( &uiPlayerSetup.menu );
}

```

`mainui/menu_strings.cpp`:

```cpp
/*
menu_strings.cpp - custom menu strings
Copyright (C) 2011 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_strings.h"

const char *MenuStrings[HINT_MAXSTRINGS] =
{
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 10
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 20
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 30
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 40
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 50
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 60
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 70
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 80
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 90
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 100
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 110
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 120
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 130
"",
"Display mode",
"",
"",
"",
"",
"",
"",
"",
"",	// 140
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 150
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 160
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 170
"Reverse mouse",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 180
"",
"",
"",
"Mouse sensitivity",
"",
"",
"",
"Return to game.",
"Start a new game.",
"",	// 190
"Load a previously saved game.",
"Load a saved game, save the current game.",
"Change game settings, configure controls",
"",
"",
"",
"",
"",
"",
"",	// 200
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 210
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 220
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 230
"",
"",
"",
"Starting a Hazard Course will exit\nany current game, OK to exit?",
"",	// filled in UI_LoadCustomStrings
"Are you sure you want to quit?",
"",
"",
"",
"Starting a new game will exit\nany current game, OK to exit?",	// 240
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 250
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 260
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 270
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 280
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 290
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 300
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 310
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 320
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 330
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 340
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 350
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 360
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 370
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 380
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 390
"",
"",
"",
"",
"",
"",
"",
"",
"",
"Find more about Valve's product lineup",	// 400
"",
"http://store.steampowered.com/app/70/",
"",
"",
"",
"",
"",
"",
"",
"",	// 410
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 420
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 430
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 440
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 450
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 460
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 470
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 480
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 490
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 500
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 510
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 520
"",
"",
"",
"",
"",
"",
"",
"",
"",
"Select a custom game",	// 530
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 540
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",	// 550
};

void UI_InitAliasStrings( void )
{
	char token[1024];

	// some strings needs to be initialized here
	sprintf( token, "Quit %s without\nsaving current game?", gMenu.m_gameinfo.title );
	MenuStrings[HINT_QUIT_ACTIVE] = StringCopy( token );

	sprintf( token, "Learn how to play %s", gMenu.m_gameinfo.title );
	MenuStrings[HINT_HAZARD_COURSE] = StringCopy( token );

	sprintf( token, "Play %s on the 'easy' skill setting", gMenu.m_gameinfo.title );
	MenuStrings[HINT_SKILL_EASY] = StringCopy( token );

	sprintf( token, "Play %s on the 'medium' skill setting", gMenu.m_gameinfo.title );
	MenuStrings[HINT_SKILL_NORMAL] = StringCopy( token );

	sprintf( token, "Play %s on the 'difficult' skill setting", gMenu.m_gameinfo.title );
	MenuStrings[HINT_SKILL_HARD] = StringCopy( token );

	sprintf( token, "Quit playing %s", gMenu.m_gameinfo.title );
	MenuStrings[HINT_QUIT_BUTTON] = StringCopy( token );

	sprintf( token, "Search for %s servers, configure character", gMenu.m_gameinfo.title );
	MenuStrings[HINT_MULTIPLAYER] = StringCopy( token );
}

void UI_LoadCustomStrings( void )
{
	char *afile = (char *)LOAD_FILE( "gfx/shell/strings.lst", NULL );
	char *pfile = afile;
	char token[1024];
	int string_num;

	UI_InitAliasStrings ();

	if( !afile )
		return;

	while(( pfile = COM_ParseFile( pfile, token )) != NULL )
	{
		if( isdigit( token[0] ))
		{
			string_num = atoi( token );

			// check for bad stiringnum
			if( string_num < 0 ) continue;
			if( string_num > ( HINT_MAXSTRINGS - 1 ))
				continue;
		}
		else continue; // invalid declaration ?

		// parse new string 
		pfile = COM_ParseFile( pfile, token );
		MenuStrings[string_num] = StringCopy( token ); // replace default string with custom
	}

	FREE_FILE( afile );
}

```

`mainui/menu_strings.h`:

```h
/*
menu_strings.h - custom menu strings
Copyright (C) 2011 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#define HINT_DISPLAYMODE	132
#define HINT_REVERSE_MOUSE	171
#define HINT_MOUSE_SENSE	184
#define HINT_RESUME_GAME	188
#define HINT_NEWGAME	189
#define HINT_HAZARD_COURSE	190
#define HINT_LOADGAME	191
#define HINT_SAVELOADGAME	192
#define HINT_CONFIGURATION	193
#define HINT_QUIT_BUTTON	196
#define HINT_MULTIPLAYER	198
#define HINT_SKILL_EASY	200
#define HINT_SKILL_NORMAL	201
#define HINT_SKILL_HARD	202
#define HINT_RESTART_HZ	234
#define HINT_QUIT_ACTIVE	235
#define HINT_QUIT		236
#define HINT_RESTART_GAME	240
#define HINT_PREVIEWS_TEXT	400
#define HINT_PREVIEWS_CMD	402	// this buton will execute program or open HTML-window
#define HINT_CUSTOM_GAME	530
#define HINT_MAXSTRINGS	551	// 550 strings allowed

extern const char *MenuStrings[HINT_MAXSTRINGS];

```

`mainui/menu_touch.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER		"gfx/shell/head_touch"

#define ID_BACKGROUND	0
#define ID_BANNER		1

#define ID_TOUCHOPTIONS  	2
#define ID_TOUCHBUTTONS	  	3
#define ID_DONE		4

typedef struct
{
	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	touchOptions;
	menuPicButton_s	touchButtons;
	menuPicButton_s	done;
} uiTouch_t;

static uiTouch_t	uiTouch;

/*
=================
UI_Touch_Callback
=================
*/
static void UI_Touch_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_TOUCHOPTIONS:
		UI_TouchOptions_Menu();
		break;
	case ID_TOUCHBUTTONS:
		UI_TouchButtons_Menu();
		break;
	case ID_DONE:
		UI_PopMenu();
		break;
	}
}

/*
=================
UI_Touch_Init
=================
*/
static void UI_Touch_Init( void )
{
	memset( &uiTouch, 0, sizeof( uiTouch_t ));

	uiTouch.menu.vidInitFunc = UI_Touch_Init;

	uiTouch.background.generic.id = ID_BACKGROUND;
	uiTouch.background.generic.type = QMTYPE_BITMAP;
	uiTouch.background.generic.flags = QMF_INACTIVE;
	uiTouch.background.generic.x = 0;
	uiTouch.background.generic.y = 0;
	uiTouch.background.generic.width = uiStatic.width;
	uiTouch.background.generic.height = 768;
	uiTouch.background.pic = ART_BACKGROUND;

	uiTouch.banner.generic.id = ID_BANNER;
	uiTouch.banner.generic.type = QMTYPE_BITMAP;
	uiTouch.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiTouch.banner.generic.x = UI_BANNER_POSX;
	uiTouch.banner.generic.y = UI_BANNER_POSY;
	uiTouch.banner.generic.width = UI_BANNER_WIDTH;
	uiTouch.banner.generic.height = UI_BANNER_HEIGHT;
	uiTouch.banner.pic = ART_BANNER;

	uiTouch.touchOptions.generic.id = ID_TOUCHOPTIONS;
	uiTouch.touchOptions.generic.type = QMTYPE_BM_BUTTON;
	uiTouch.touchOptions.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY | QMF_ACT_ONRELEASE;
	uiTouch.touchOptions.generic.name = "Touch options";
	uiTouch.touchOptions.generic.statusText = "Touch sensitivity and profile options";
	uiTouch.touchOptions.generic.x = 72;
	uiTouch.touchOptions.generic.y = 230;
	uiTouch.touchOptions.generic.callback = UI_Touch_Callback;
	uiTouch.touchOptions.pic = PIC_Load("gfx/shell/btn_touch_options");

	//UI_UtilSetupPicButton( &uiTouch.touchOptions, PC_TOUCH_OPT );

	uiTouch.touchButtons.generic.id = ID_TOUCHBUTTONS;
	uiTouch.touchButtons.generic.type = QMTYPE_BM_BUTTON;
	uiTouch.touchButtons.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY | QMF_ACT_ONRELEASE;
	uiTouch.touchButtons.generic.name = "Touch Buttons";
	uiTouch.touchButtons.generic.statusText = "Add, remove, edit touch buttons";
	uiTouch.touchButtons.generic.x = 72;
	uiTouch.touchButtons.generic.y = 280;
	uiTouch.touchButtons.generic.callback = UI_Touch_Callback;
	uiTouch.touchButtons.pic = PIC_Load("gfx/shell/btn_touch_buttons");

	//UI_UtilSetupPicButton( &uiTouch.touchButtons, PC_TOUCH_BUTTONS );

	uiTouch.done.generic.id = ID_DONE;
	uiTouch.done.generic.type = QMTYPE_BM_BUTTON;
	uiTouch.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_NOTIFY;
	uiTouch.done.generic.name = "Done";
	uiTouch.done.generic.statusText = "Go back to the previous menu";
	uiTouch.done.generic.x = 72;
	uiTouch.done.generic.y = 330;
	uiTouch.done.generic.callback = UI_Touch_Callback;

	UI_UtilSetupPicButton( &uiTouch.done, PC_DONE );

	UI_AddItem( &uiTouch.menu, (void *)&uiTouch.background );
	UI_AddItem( &uiTouch.menu, (void *)&uiTouch.banner );
	UI_AddItem( &uiTouch.menu, (void *)&uiTouch.touchOptions );
	UI_AddItem( &uiTouch.menu, (void *)&uiTouch.touchButtons );
	UI_AddItem( &uiTouch.menu, (void *)&uiTouch.done );
}

/*
=================
UI_Touch_Precache
=================
*/
void UI_Touch_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_Touch_Menu
=================
*/
void UI_Touch_Menu( void )
{
	UI_Touch_Precache();
	UI_Touch_Init();

	UI_PushMenu( &uiTouch.menu );
}

```

`mainui/menu_touchbuttons.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_btnsbmp_table.h"

#include "mobility_int.h"

#define ART_BANNER	  	"gfx/shell/head_touch_buttons"

#define ID_BACKGROUND 	0
#define ID_BANNER	  	1
#define ID_DONE	  	2
#define ID_RED	3
#define ID_GREEN		4
#define ID_BLUE	5
#define ID_ALPHA	6
#define ID_HIDE	7
#define ID_RESET	8
#define ID_BUTTONLIST	9
#define ID_SAVE 10
#define ID_DELETE 11
#define ID_MSGBOX	 	12
#define ID_MSGTEXT	 	13
#define ID_NAME	 	14
#define ID_COLOR	 	15
#define ID_PREVIEW	 	16
#define ID_TEXTURE	 	17
#define ID_COMMAND	 	18
#define ID_SELECT	 	19
#define ID_LOCK			21
#define ID_MP			22
#define ID_SP			23
#define ID_ADDITIVE		24
#define ID_EDITOR		25
#define ID_CANCEL	 	26
#define ID_PRECISION	 	27
#define ID_YES	 	130
#define ID_NO	 	131
typedef struct
{
	menuFramework_s	menu;
    char		bNames[UI_MAXGAMES][95];
    char		bTextures[UI_MAXGAMES][95];
    char		bCommands[UI_MAXGAMES][95];
    unsigned char		bColors[UI_MAXGAMES][4];
	int        bFlags[UI_MAXGAMES];
    bool        gettingList;
	HIMAGE textureid;
	char selectedName[256];
	int curflags;

    char		*bNamesPtr[UI_MAXGAMES];
	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	done;
    menuPicButton_s	cancel;

    menuSlider_s	red;
    menuSlider_s	green;
    menuSlider_s	blue;
    menuSlider_s	alpha;
    menuCheckBox_s	hide;
	menuCheckBox_s	sp;
	menuCheckBox_s	mp;
	menuCheckBox_s	lock;
	menuCheckBox_s	additive;
	menuCheckBox_s	precision;
	menuPicButton_s	reset;
	menuPicButton_s	remove;
	menuPicButton_s	save;
    menuPicButton_s	select;
	menuPicButton_s	editor;
    menuField_s	command;
    menuField_s	texture;
    menuField_s	name;
    menuAction_s color;
    menuAction_s preview;
    menuScrollList_s buttonList;

	// prompt dialog
	menuAction_s	msgBox;
	menuAction_s	promptMessage;
	menuPicButton_s	yes;
	menuPicButton_s	no;
	void ( *dialogAction ) ( void );
	char dialogText[256];
	bool initialized;
} uiTouchButtons_t;

static uiTouchButtons_t	uiTouchButtons;

static void UI_TouchButtons_UpdateFields( void );

void UI_TouchButtons_AddButtonToList( const char *name, const char *texture, const char *command, unsigned char *color, int flags )
{
	if( !uiTouchButtons.gettingList )
		return;
	int i = uiTouchButtons.buttonList.numItems++;
	strcpy(uiTouchButtons.bNames[i], name);
	uiTouchButtons.bNamesPtr[i] = uiTouchButtons.bNames[i];
	strcpy(uiTouchButtons.bTextures[i], texture);
	strcpy(uiTouchButtons.bCommands[i], command);
	uiTouchButtons.bColors[i][0] = color[0];
	uiTouchButtons.bColors[i][1] = color[1];
	uiTouchButtons.bColors[i][2] = color[2];
	uiTouchButtons.bColors[i][3] = color[3];
	uiTouchButtons.bFlags[i] = flags;
}

void UI_TouchButtons_GetButtonList()
{
	if( !uiTouchButtons.initialized )
		return;
	uiTouchButtons.buttonList.numItems = 0;
	CLIENT_COMMAND( 1, "" ); //perform Cbuf_Execute()
	uiTouchButtons.gettingList = true;
	CLIENT_COMMAND( 1, "touch_list\n" );
	uiTouchButtons.gettingList = false;
	int i = uiTouchButtons.buttonList.numItems;

	if( uiTouchButtons.buttonList.generic.charHeight )
	{
		uiTouchButtons.buttonList.numRows = (uiTouchButtons.buttonList.generic.height2 / uiTouchButtons.buttonList.generic.charHeight) - 2;
		if( uiTouchButtons.buttonList.numRows > uiTouchButtons.buttonList.numItems )
			uiTouchButtons.buttonList.numRows = i;
	}

	for ( ; i < UI_MAXGAMES; i++ )
		uiTouchButtons.bNamesPtr[i] = NULL;


	uiTouchButtons.buttonList.itemNames = (const char **)uiTouchButtons.bNamesPtr;
	UI_TouchButtons_UpdateFields();
}
/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}
#define CURCOLOR1(x) ( (unsigned int) ( uiTouchButtons.x.curValue * 255.0f ) )
static void UI_Preview_Ownerdraw( void *self )
{
    menuCommon_s	*item = (menuCommon_s *)self;
	UI_FillRect( item->x - 2, item->y - 2, item->width + 4, item->height + 4, 0xFFC0C0C0 );
	UI_FillRect( item->x, item->y, item->width, item->height, 0xFF808080 );
	PIC_Set( uiTouchButtons.textureid, CURCOLOR1(red), CURCOLOR1(green), CURCOLOR1(blue), CURCOLOR1(alpha));
	if( uiTouchButtons.additive.enabled )
		PIC_DrawAdditive( item->x, item->y, item->width, item->height );
	else
		PIC_DrawTrans( item->x, item->y, item->width, item->height );
}
#define CURCOLOR ( (unsigned int)(uiTouchButtons.blue.curValue * 255) | \
				 (unsigned int)(uiTouchButtons.green.curValue * 255) << 8 | \
				 (unsigned int)(uiTouchButtons.red.curValue * 255) << 16 | \
				 (unsigned int)(uiTouchButtons.alpha.curValue * 255) << 24 )
static void UI_Color_Ownerdraw( void *self )
{
    menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, CURCOLOR );
}

static void UI_DeleteButton()
{
	char command[256];
	snprintf(command, 256, "touch_removebutton \"%s\"\n", uiTouchButtons.selectedName );
	CLIENT_COMMAND(1, command);
	UI_TouchButtons_GetButtonList();
}

static void UI_ResetButtons()
{
	CLIENT_COMMAND( 0, "touch_removeall\n" );
	CLIENT_COMMAND( 1, "touch_loaddefaults\n" );
	UI_TouchButtons_GetButtonList();
}

static void UI_TouchButtons_UpdateFields()
{
	strcpy( uiTouchButtons.selectedName, uiTouchButtons.bNames[uiTouchButtons.buttonList.curItem]);
	strcpy( uiTouchButtons.texture.buffer, uiTouchButtons.bTextures[uiTouchButtons.buttonList.curItem]);
	strcpy( uiTouchButtons.command.buffer, uiTouchButtons.bCommands[uiTouchButtons.buttonList.curItem]);
	uiTouchButtons.red.curValue = (float) uiTouchButtons.bColors[uiTouchButtons.buttonList.curItem][0]/255;
	uiTouchButtons.green.curValue = (float) uiTouchButtons.bColors[uiTouchButtons.buttonList.curItem][1]/255;
	uiTouchButtons.blue.curValue = (float) uiTouchButtons.bColors[uiTouchButtons.buttonList.curItem][2]/255;
	uiTouchButtons.alpha.curValue = (float) uiTouchButtons.bColors[uiTouchButtons.buttonList.curItem][3]/255;
	uiTouchButtons.curflags = uiTouchButtons.bFlags[ uiTouchButtons.buttonList.curItem ];
	uiTouchButtons.mp.enabled = !!( uiTouchButtons.curflags & TOUCH_FL_MP );
	uiTouchButtons.sp.enabled = !!( uiTouchButtons.curflags & TOUCH_FL_SP );
	uiTouchButtons.lock.enabled = !!( uiTouchButtons.curflags & TOUCH_FL_NOEDIT );
	uiTouchButtons.hide.enabled = !!( uiTouchButtons.curflags & TOUCH_FL_HIDE );
	uiTouchButtons.additive.enabled = !!( uiTouchButtons.curflags & TOUCH_FL_DRAW_ADDITIVE );
	uiTouchButtons.precision.enabled = !!( uiTouchButtons.curflags & TOUCH_FL_PRECISION );
	if( uiTouchButtons.texture.buffer[0] && uiTouchButtons.texture.buffer[0] != '#' )
		uiTouchButtons.textureid = PIC_Load(uiTouchButtons.texture.buffer);
	else
		uiTouchButtons.textureid = 0;
	uiTouchButtons.name.buffer[0] = 0;
	uiTouchButtons.name.cursor = 0;
	uiTouchButtons.texture.cursor = strlen( uiTouchButtons.texture.buffer );
	if( uiTouchButtons.texture.cursor > uiTouchButtons.texture.widthInChars )
		uiTouchButtons.texture.scroll = uiTouchButtons.texture.cursor;
	else
		uiTouchButtons.texture.scroll = 0;
	uiTouchButtons.command.cursor = strlen( uiTouchButtons.command.buffer );
	if( uiTouchButtons.command.cursor > uiTouchButtons.command.widthInChars )
		uiTouchButtons.command.scroll = uiTouchButtons.command.cursor;
	else
		uiTouchButtons.command.scroll = 0;

}
static void UI_TouchButtons_DisableButtons()
{
	uiTouchButtons.remove.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.hide.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.buttonList.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.blue.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.alpha.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.red.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.green.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.reset.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.name.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.done.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.cancel.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.command.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.texture.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.sp.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.mp.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.lock.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.additive.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.precision.generic.flags |= QMF_INACTIVE;
	uiTouchButtons.editor.generic.flags |= QMF_INACTIVE;
}
static void UI_TouchButtons_EnableButtons()
{
	uiTouchButtons.remove.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.hide.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.buttonList.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.blue.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.alpha.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.red.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.green.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.reset.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.name.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.done.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.cancel.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.command.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.texture.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.sp.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.mp.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.lock.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.additive.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.precision.generic.flags &= ~QMF_INACTIVE;
	uiTouchButtons.editor.generic.flags &= ~QMF_INACTIVE;
}
static void UI_TouchButtons_FileDialogCallback( bool success )
{
	if( success )
	{
		strcpy( uiTouchButtons.texture.buffer, uiFileDialogGlobal.result );
		uiTouchButtons.textureid = PIC_Load(uiTouchButtons.texture.buffer);
	}
	UI_TouchButtons_EnableButtons();
}


/*
=================
UI_TouchButtons_Callback
=================
*/
static void UI_TouchButtons_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	switch( item->id )
	{
	case ID_SP:
		if( uiTouchButtons.sp.enabled )
			uiTouchButtons.mp.enabled = false;
	case ID_MP:
		if( uiTouchButtons.mp.enabled )
			uiTouchButtons.sp.enabled = false;
    case ID_HIDE:
	case ID_ADDITIVE:
	case ID_PRECISION:
	case ID_LOCK:
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
		// clean all flags that we may change
		uiTouchButtons.curflags &= ~ ( TOUCH_FL_HIDE | TOUCH_FL_NOEDIT | TOUCH_FL_MP | TOUCH_FL_SP | TOUCH_FL_DRAW_ADDITIVE | TOUCH_FL_PRECISION );
		if( uiTouchButtons.mp.enabled )
			uiTouchButtons.curflags |= TOUCH_FL_MP;
		if( uiTouchButtons.sp.enabled )
			uiTouchButtons.curflags |= TOUCH_FL_SP;
		if( uiTouchButtons.hide.enabled )
			uiTouchButtons.curflags |= TOUCH_FL_HIDE;
		if( uiTouchButtons.lock.enabled )
			uiTouchButtons.curflags |= TOUCH_FL_NOEDIT;
		if( uiTouchButtons.additive.enabled )
			uiTouchButtons.curflags |= TOUCH_FL_DRAW_ADDITIVE;
		if( uiTouchButtons.precision.enabled )
			uiTouchButtons.curflags |= TOUCH_FL_PRECISION;
		break;
	}

	if( event == QM_CHANGED )
	{
		switch( item->id )
		{
		case ID_TEXTURE:
			// update current texture
			if( uiTouchButtons.texture.buffer[0] && uiTouchButtons.texture.buffer[0] != '#' )
				uiTouchButtons.textureid = PIC_Load(uiTouchButtons.texture.buffer);
			else
				uiTouchButtons.textureid = 0;
			break;
		case ID_BUTTONLIST:
			UI_TouchButtons_UpdateFields();
			break;
		}
		return;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		CLIENT_COMMAND(0, "touch_writeconfig\n");
		UI_PopMenu();
		break;
	case ID_CANCEL:
		CLIENT_COMMAND(0, "touch_loadconfig\n");
		UI_PopMenu();
		break;
	case ID_RESET:
		UI_TouchButtons_DisableButtons();

        uiTouchButtons.msgBox.generic.flags &= ~QMF_HIDDEN;
        uiTouchButtons.promptMessage.generic.flags &= ~QMF_HIDDEN;
        uiTouchButtons.no.generic.flags &= ~QMF_HIDDEN;
        uiTouchButtons.yes.generic.flags &= ~QMF_HIDDEN;
        strcpy( uiTouchButtons.dialogText, "Reset all buttons?" );
        uiTouchButtons.dialogAction = UI_ResetButtons;
		break;
	case ID_DELETE:
		UI_TouchButtons_DisableButtons();


        uiTouchButtons.msgBox.generic.flags &= ~QMF_HIDDEN;
        uiTouchButtons.promptMessage.generic.flags &= ~QMF_HIDDEN;
        uiTouchButtons.no.generic.flags &= ~QMF_HIDDEN;
        uiTouchButtons.yes.generic.flags &= ~QMF_HIDDEN;
        strcpy( uiTouchButtons.dialogText, "Delete selected button?" );
        uiTouchButtons.dialogAction = UI_DeleteButton;
		break;
	case ID_YES:
		if( uiTouchButtons.dialogAction )
		{
			uiTouchButtons.dialogAction();
		}
	case ID_NO:
		UI_TouchButtons_EnableButtons();

        uiTouchButtons.msgBox.generic.flags |= QMF_HIDDEN;
        uiTouchButtons.promptMessage.generic.flags |= QMF_HIDDEN;
        uiTouchButtons.no.generic.flags |= QMF_HIDDEN;
        uiTouchButtons.yes.generic.flags |= QMF_HIDDEN;
		break;
	case ID_SAVE:
		if( strlen(uiTouchButtons.name.buffer) > 0)
		{
			char command[256];
			snprintf( command, 256, "touch_addbutton \"%s\" \"%s\" \"%s\"\n", uiTouchButtons.name.buffer,
					  uiTouchButtons.texture.buffer, uiTouchButtons.command.buffer );
			CLIENT_COMMAND(0, command);
			snprintf( command, 256, "touch_setflags \"%s\" %i\n", uiTouchButtons.name.buffer, uiTouchButtons.curflags );
			CLIENT_COMMAND(0, command);
			snprintf( command, 256, "touch_setcolor \"%s\" %d %d %d %d\n", uiTouchButtons.name.buffer, CURCOLOR1(red), CURCOLOR1(green), CURCOLOR1(blue),CURCOLOR1(alpha) );
			CLIENT_COMMAND(1, command);
			uiTouchButtons.name.buffer[0] = 0;
			uiTouchButtons.name.cursor = 0;
		}
		else
		{
			char command[256];
			snprintf( command, 256, "touch_settexture \"%s\" \"%s\"\n", uiTouchButtons.selectedName, uiTouchButtons.texture.buffer );
			CLIENT_COMMAND(0, command);
			snprintf( command, 256, "touch_setcommand \"%s\" \"%s\"\n", uiTouchButtons.selectedName, uiTouchButtons.command.buffer );
			CLIENT_COMMAND(0, command);
			snprintf( command, 256, "touch_setflags \"%s\" %i\n", uiTouchButtons.selectedName, uiTouchButtons.curflags );
			CLIENT_COMMAND(0, command);
			snprintf( command, 256, "touch_setcolor \"%s\" %d %d %d %d\n", uiTouchButtons.selectedName, CURCOLOR1(red), CURCOLOR1(green), CURCOLOR1(blue),CURCOLOR1(alpha) );
			CLIENT_COMMAND(1, command);
		}
		UI_TouchButtons_GetButtonList();
		break;
	case ID_EDITOR:
		UI_TouchEdit_Menu();
		break;
	case ID_SELECT:
		UI_TouchButtons_DisableButtons();
		uiFileDialogGlobal.npatterns = 7;
		strcpy( uiFileDialogGlobal.patterns[0], "touch/*.tga");
		strcpy( uiFileDialogGlobal.patterns[1], "touch_default/*.tga");
		strcpy( uiFileDialogGlobal.patterns[2], "gfx/touch/*");
		strcpy( uiFileDialogGlobal.patterns[3], "gfx/vgui/*");
		strcpy( uiFileDialogGlobal.patterns[4], "gfx/shell/*");
		strcpy( uiFileDialogGlobal.patterns[5], "*.tga");
		uiFileDialogGlobal.preview = true;
		uiFileDialogGlobal.valid = true;
		uiFileDialogGlobal.callback = UI_TouchButtons_FileDialogCallback;
		UI_FileDialog_Menu();
		break;
	}

}
/*
=================
UI_TouchButtons_Init
=================
*/
static void UI_TouchButtons_Init( void )
{
	memset( &uiTouchButtons, 0, sizeof( uiTouchButtons_t ));

	//uiTouchOptions.hTestImage = PIC_Load( ART_GAMMA, PIC_KEEP_RGBDATA );

	//uiTouchButtons.menu.vidInitFunc = UI_TouchButtons_Init;
	uiTouchButtons.initialized = true;

	uiTouchButtons.background.generic.id = ID_BACKGROUND;
	uiTouchButtons.background.generic.type = QMTYPE_BITMAP;
	uiTouchButtons.background.generic.flags = QMF_INACTIVE;
	uiTouchButtons.background.generic.x = 0;
	uiTouchButtons.background.generic.y = 0;
	uiTouchButtons.background.generic.width = uiStatic.width;
	uiTouchButtons.background.generic.height = 768;
	uiTouchButtons.background.pic = ART_BACKGROUND;

	uiTouchButtons.banner.generic.id = ID_BANNER;
	uiTouchButtons.banner.generic.type = QMTYPE_BITMAP;
	uiTouchButtons.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiTouchButtons.banner.generic.x = UI_BANNER_POSX;
	uiTouchButtons.banner.generic.y = UI_BANNER_POSY - 70;
	uiTouchButtons.banner.generic.width = UI_BANNER_WIDTH;
	uiTouchButtons.banner.generic.height = UI_BANNER_HEIGHT;
	uiTouchButtons.banner.pic = ART_BANNER;
/*
	uiTouchOptions.testImage.generic.id = ID_BANNER;
	uiTouchOptions.testImage.generic.type = QMTYPE_BITMAP;
	uiTouchOptions.testImage.generic.flags = QMF_INACTIVE;
	uiTouchOptions.testImage.generic.x = 390;
	uiTouchOptions.testImage.generic.y = 225;
	uiTouchOptions.testImage.generic.width = 480;
	uiTouchOptions.testImage.generic.height = 450;
	uiTouchOptions.testImage.pic = ART_GAMMA;
	uiTouchOptions.testImage.generic.ownerdraw = UI_TouchButtons_Ownerdraw;
*/
	uiTouchButtons.done.generic.id = ID_DONE;
	uiTouchButtons.done.generic.type = QMTYPE_BM_BUTTON;
	uiTouchButtons.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.done.generic.x = 72;
	uiTouchButtons.done.generic.y = 550;
	uiTouchButtons.done.generic.name = "Done";
	uiTouchButtons.done.generic.statusText = "Save changes and go back to the Touch Menu";
	uiTouchButtons.done.generic.callback = UI_TouchButtons_Callback;

	UI_UtilSetupPicButton( &uiTouchButtons.done, PC_DONE );

	uiTouchButtons.cancel.generic.id = ID_CANCEL;
	uiTouchButtons.cancel.generic.type = QMTYPE_BM_BUTTON;
	uiTouchButtons.cancel.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.cancel.generic.x = 72;
	uiTouchButtons.cancel.generic.y = 600;
	uiTouchButtons.cancel.generic.name = "Cancel";
	uiTouchButtons.cancel.generic.statusText = "Discard changes and go back to the Touch Menu";
	uiTouchButtons.cancel.generic.callback = UI_TouchButtons_Callback;

	UI_UtilSetupPicButton( &uiTouchButtons.cancel, PC_CANCEL );

	uiTouchButtons.red.generic.id = ID_RED;
	uiTouchButtons.red.generic.type = QMTYPE_SLIDER;
	uiTouchButtons.red.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.red.generic.name = "Red:";
	uiTouchButtons.red.generic.x = 680;
	uiTouchButtons.red.generic.y = 150;
	uiTouchButtons.red.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.red.generic.statusText = "Horizontal look sensitivity";
	uiTouchButtons.red.minValue = 0.0;
	uiTouchButtons.red.maxValue = 1.0;
	uiTouchButtons.red.range = 0.05f;

	uiTouchButtons.green.generic.id = ID_GREEN;
	uiTouchButtons.green.generic.type = QMTYPE_SLIDER;
	uiTouchButtons.green.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.green.generic.name = "Green:";
	uiTouchButtons.green.generic.x = 680;
	uiTouchButtons.green.generic.y = 210;
	uiTouchButtons.green.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.green.generic.statusText = "Vertical look sensitivity";
	uiTouchButtons.green.minValue = 0.0;
	uiTouchButtons.green.maxValue = 1.0;
	uiTouchButtons.green.range = 0.05f;

	uiTouchButtons.blue.generic.id = ID_BLUE;
	uiTouchButtons.blue.generic.type = QMTYPE_SLIDER;
	uiTouchButtons.blue.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.blue.generic.name = "Blue:";
	uiTouchButtons.blue.generic.x = 680;
	uiTouchButtons.blue.generic.y = 270;
	uiTouchButtons.blue.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.blue.generic.statusText = "Side move sensitivity";
	uiTouchButtons.blue.minValue = 0.0;
	uiTouchButtons.blue.maxValue = 1.0;
	uiTouchButtons.blue.range = 0.05f;

	uiTouchButtons.alpha.generic.id = ID_ALPHA;
	uiTouchButtons.alpha.generic.type = QMTYPE_SLIDER;
	uiTouchButtons.alpha.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.alpha.generic.name = "Alpha:";
	uiTouchButtons.alpha.generic.x = 680;
	uiTouchButtons.alpha.generic.y = 330;
	uiTouchButtons.alpha.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.alpha.generic.statusText = "Forward move sensitivity";
	uiTouchButtons.alpha.minValue = 0.0;
	uiTouchButtons.alpha.maxValue = 1.0;
	uiTouchButtons.alpha.range = 0.05f;

	uiTouchButtons.hide.generic.id = ID_HIDE;
	uiTouchButtons.hide.generic.type = QMTYPE_CHECKBOX;
	uiTouchButtons.hide.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_MOUSEONLY|QMF_DROPSHADOW;
	uiTouchButtons.hide.generic.name = "Hide";
	uiTouchButtons.hide.generic.x = 384 - 72 + 400;
	uiTouchButtons.hide.generic.y = 420;
	uiTouchButtons.hide.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.hide.generic.statusText = "show/hide button";

	uiTouchButtons.additive.generic.id = ID_ADDITIVE;
	uiTouchButtons.additive.generic.type = QMTYPE_CHECKBOX;
	uiTouchButtons.additive.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_MOUSEONLY|QMF_DROPSHADOW;
	uiTouchButtons.additive.generic.name = "Additive";
	uiTouchButtons.additive.generic.x = 650;
	uiTouchButtons.additive.generic.y = 470;
	uiTouchButtons.additive.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.additive.generic.statusText = "Set button additive draw mode";

	uiTouchButtons.mp.generic.id = ID_MP;
	uiTouchButtons.mp.generic.type = QMTYPE_CHECKBOX;
	uiTouchButtons.mp.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_MOUSEONLY|QMF_DROPSHADOW;
	uiTouchButtons.mp.generic.name = "MP";
	uiTouchButtons.mp.generic.x = 400;
	uiTouchButtons.mp.generic.y = 420;
	uiTouchButtons.mp.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.mp.generic.statusText = "Show button only in multiplayer";

	uiTouchButtons.sp.generic.id = ID_SP;
	uiTouchButtons.sp.generic.type = QMTYPE_CHECKBOX;
	uiTouchButtons.sp.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_MOUSEONLY|QMF_DROPSHADOW;
	uiTouchButtons.sp.generic.name = "SP";
	uiTouchButtons.sp.generic.x = 160 - 72 + 400;
	uiTouchButtons.sp.generic.y = 420;
	uiTouchButtons.sp.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.sp.generic.statusText = "Show button only in singleplayer";

	uiTouchButtons.lock.generic.id = ID_LOCK;
	uiTouchButtons.lock.generic.type = QMTYPE_CHECKBOX;
	uiTouchButtons.lock.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_MOUSEONLY|QMF_DROPSHADOW;
	uiTouchButtons.lock.generic.name = "Lock";
	uiTouchButtons.lock.generic.x = 256 - 72 + 400;
	uiTouchButtons.lock.generic.y = 420;
	uiTouchButtons.lock.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.lock.generic.statusText = "Lock button editing";

	uiTouchButtons.precision.generic.id = ID_PRECISION;
	uiTouchButtons.precision.generic.type = QMTYPE_CHECKBOX;
	uiTouchButtons.precision.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_MOUSEONLY|QMF_DROPSHADOW;
	uiTouchButtons.precision.generic.name = "Look precision";
	uiTouchButtons.precision.generic.x = 400;
	uiTouchButtons.precision.generic.y = 470;
	uiTouchButtons.precision.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.precision.generic.statusText = "Increase look precision";

	uiTouchButtons.buttonList.generic.id = ID_BUTTONLIST;
	uiTouchButtons.buttonList.generic.type = QMTYPE_SCROLLLIST;
	uiTouchButtons.buttonList.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_SMALLFONT;
	uiTouchButtons.buttonList.generic.x = 72;
	uiTouchButtons.buttonList.generic.y = 150;
	uiTouchButtons.buttonList.generic.width = 300;
	uiTouchButtons.buttonList.generic.height = 370;
	uiTouchButtons.buttonList.generic.callback = UI_TouchButtons_Callback;

	uiTouchButtons.save.generic.id = ID_SAVE;
	uiTouchButtons.save.generic.type = QMTYPE_BM_BUTTON;
	uiTouchButtons.save.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW | QMF_ACT_ONRELEASE;
	uiTouchButtons.save.generic.x = 384 - 72 + 320;
	uiTouchButtons.save.generic.y = 550;
	uiTouchButtons.save.generic.name = "Save";
	uiTouchButtons.save.generic.statusText = "Save as new button";
	uiTouchButtons.save.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.save.pic = PIC_Load("gfx/shell/btn_touch_save");

	uiTouchButtons.editor.generic.id = ID_EDITOR;
	uiTouchButtons.editor.generic.type = QMTYPE_BM_BUTTON;
	uiTouchButtons.editor.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW | QMF_ACT_ONRELEASE;
	uiTouchButtons.editor.generic.x = 384 - 72 + 320;
	uiTouchButtons.editor.generic.y = 600;
	uiTouchButtons.editor.generic.name = "Editor";
	uiTouchButtons.editor.generic.statusText = "Open interactive editor";
	uiTouchButtons.editor.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.editor.pic = PIC_Load("gfx/shell/btn_touch_editor");

	uiTouchButtons.select.generic.id = ID_SELECT;
	uiTouchButtons.select.generic.type = QMTYPE_BM_BUTTON;
	uiTouchButtons.select.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW | QMF_ACT_ONRELEASE;
	uiTouchButtons.select.generic.x = 500;
	uiTouchButtons.select.generic.y = 300;
	uiTouchButtons.select.generic.name = "Select";
	uiTouchButtons.select.generic.statusText = "Select texture from list";
	uiTouchButtons.select.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.select.pic = PIC_Load("gfx/shell/btn_touch_select");

	uiTouchButtons.name.generic.id = ID_NAME;
	uiTouchButtons.name.generic.type = QMTYPE_FIELD;
	uiTouchButtons.name.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.name.generic.name = "New Button:";
	uiTouchButtons.name.generic.x = 400;
	uiTouchButtons.name.generic.y = 550;
	uiTouchButtons.name.generic.width = 205;
	uiTouchButtons.name.generic.height = 32;
	uiTouchButtons.name.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.name.maxLength = 255;

	uiTouchButtons.command.generic.id = ID_COMMAND;
	uiTouchButtons.command.generic.type = QMTYPE_FIELD;
	uiTouchButtons.command.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.command.generic.name = "Command:";
	uiTouchButtons.command.generic.x = 400;
	uiTouchButtons.command.generic.y = 150;
	uiTouchButtons.command.generic.width = 205;
	uiTouchButtons.command.generic.height = 32;
	uiTouchButtons.command.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.command.maxLength = 255;

	uiTouchButtons.texture.generic.id = ID_TEXTURE;
	uiTouchButtons.texture.generic.type = QMTYPE_FIELD;
	uiTouchButtons.texture.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.texture.generic.name = "Texture:";
	uiTouchButtons.texture.generic.x = 400;
	uiTouchButtons.texture.generic.y = 250;
	uiTouchButtons.texture.generic.width = 205;
	uiTouchButtons.texture.generic.height = 32;
	uiTouchButtons.texture.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.texture.maxLength = 255;

	uiTouchButtons.msgBox.generic.id = ID_MSGBOX;
	uiTouchButtons.msgBox.generic.type = QMTYPE_ACTION;
	uiTouchButtons.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiTouchButtons.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiTouchButtons.msgBox.generic.x = DLG_X + 192;
	uiTouchButtons.msgBox.generic.y = 256;
	uiTouchButtons.msgBox.generic.width = 640;
	uiTouchButtons.msgBox.generic.height = 256;

	uiTouchButtons.color.generic.id = ID_COLOR;
	uiTouchButtons.color.generic.type = QMTYPE_ACTION;
	uiTouchButtons.color.generic.flags = QMF_INACTIVE;
	uiTouchButtons.color.generic.ownerdraw = UI_Color_Ownerdraw; // just a fill rectangle
	uiTouchButtons.color.generic.x = 800;
	uiTouchButtons.color.generic.y = 360;
	uiTouchButtons.color.generic.width = 70;
	uiTouchButtons.color.generic.height = 50;

	uiTouchButtons.preview.generic.id = ID_PREVIEW;
	uiTouchButtons.preview.generic.type = QMTYPE_ACTION;
	uiTouchButtons.preview.generic.flags = QMF_INACTIVE;
	uiTouchButtons.preview.generic.ownerdraw = UI_Preview_Ownerdraw; // just a fill rectangle
	uiTouchButtons.preview.generic.x = 400;
	uiTouchButtons.preview.generic.y = 300;
	uiTouchButtons.preview.generic.width = 70;
	uiTouchButtons.preview.generic.height = 70;

	uiTouchButtons.promptMessage.generic.id = ID_MSGBOX;
	uiTouchButtons.promptMessage.generic.type = QMTYPE_ACTION;
	uiTouchButtons.promptMessage.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN;
	uiTouchButtons.promptMessage.generic.name = uiTouchButtons.dialogText;
	uiTouchButtons.promptMessage.generic.x = DLG_X + 315;
	uiTouchButtons.promptMessage.generic.y = 280;

	uiTouchButtons.yes.generic.id = ID_YES;
	uiTouchButtons.yes.generic.type = QMTYPE_BM_BUTTON;
	uiTouchButtons.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiTouchButtons.yes.generic.name = "Ok";
	uiTouchButtons.yes.generic.x = DLG_X + 380;
	uiTouchButtons.yes.generic.y = 460;
	uiTouchButtons.yes.generic.callback = UI_TouchButtons_Callback;

	UI_UtilSetupPicButton( &uiTouchButtons.yes, PC_OK );

	uiTouchButtons.no.generic.id = ID_NO;
	uiTouchButtons.no.generic.type = QMTYPE_BM_BUTTON;
	uiTouchButtons.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiTouchButtons.no.generic.name = "Cancel";
	uiTouchButtons.no.generic.x = DLG_X + 530;
	uiTouchButtons.no.generic.y = 460;
	uiTouchButtons.no.generic.callback = UI_TouchButtons_Callback;

	UI_UtilSetupPicButton( &uiTouchButtons.no, PC_CANCEL );

	uiTouchButtons.reset.generic.id = ID_RESET;
	uiTouchButtons.reset.generic.type = QMTYPE_BM_BUTTON;
	uiTouchButtons.reset.generic.flags = QMF_HIGHLIGHTIFFOCUS | QMF_DROPSHADOW | QMF_ACT_ONRELEASE;
	uiTouchButtons.reset.generic.name = "Reset";
	uiTouchButtons.reset.generic.x = 384 - 72 + 480;
	uiTouchButtons.reset.generic.y = 600;
	uiTouchButtons.reset.generic.callback = UI_TouchButtons_Callback;
	uiTouchButtons.reset.generic.statusText = "Reset touch to default state";
	uiTouchButtons.reset.pic = PIC_Load("gfx/shell/btn_touch_reset");

	uiTouchButtons.remove.generic.id = ID_DELETE;
	uiTouchButtons.remove.generic.type = QMTYPE_BM_BUTTON;
	uiTouchButtons.remove.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchButtons.remove.generic.x = 384 - 72 + 480;
	uiTouchButtons.remove.generic.y = 550;
	uiTouchButtons.remove.generic.name = "Delete";
	uiTouchButtons.remove.generic.statusText = "Delete selected button";
	uiTouchButtons.remove.generic.callback = UI_TouchButtons_Callback;
	UI_UtilSetupPicButton( &uiTouchButtons.remove, PC_DELETE );

	uiTouchButtons.buttonList.itemNames = (const char **)uiTouchButtons.bNamesPtr;

	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.background );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.remove );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.reset );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.done );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.cancel );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.red );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.green );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.blue );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.alpha );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.hide );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.additive );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.precision );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.sp );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.mp );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.lock );

	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.buttonList );

	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.save );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.select );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.editor );

	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.banner );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.color );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.preview );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.command );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.texture );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.name );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.msgBox );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.promptMessage );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.no );
	UI_AddItem( &uiTouchButtons.menu, (void *)&uiTouchButtons.yes );

	UI_TouchButtons_GetButtonList();
}

/*
=================
UI_TouchButtons_Precache
=================
*/
void UI_TouchButtons_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
	uiTouchButtons.gettingList = false; // prevent filling list before init
}

/*
=================
UI_TouchButtons_Menu
=================
*/
void UI_TouchButtons_Menu( void )
{
    UI_TouchButtons_Precache();
    UI_TouchButtons_Init();

    UI_PushMenu( &uiTouchButtons.menu );
}

```

`mainui/menu_touchedit.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

/*
 * This is empty menu that allows engine to draw touch editor
 */

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"

typedef struct
{
	int		active;

	menuFramework_s	menu;
} uiTouchEdit_t;

static uiTouchEdit_t		uiTouchEdit;


/*
=================
UI_TouchEdit_DrawFunc
=================
*/
static void UI_TouchEdit_DrawFunc( void )
{
	if( !CVAR_GET_FLOAT("touch_in_menu") )
	{
		UI_PopMenu();
		UI_TouchButtons_GetButtonList();
	}
}

/*
=================
UI_TouchEdit_KeyFunc
=================
*/
static const char *UI_TouchEdit_KeyFunc( int key, int down )
{
	if( down && key == K_ESCAPE )
	{
		CVAR_SET_STRING("touch_in_menu", "0");
		CLIENT_COMMAND(0, "touch_disableedit");
		UI_PopMenu();
		return uiSoundOut;
	}
	return uiSoundNull;
}

/*
=================
UI_TouchEdit_Init
=================
*/
static void UI_TouchEdit_Init( void )
{
	uiTouchEdit.menu.drawFunc = UI_TouchEdit_DrawFunc;
	uiTouchEdit.menu.keyFunc = UI_TouchEdit_KeyFunc;
	CVAR_SET_STRING("touch_in_menu", "1");
	CLIENT_COMMAND(0, "touch_enableedit");
}

/*
=================
UI_TouchEdit_Precache
=================
*/
void UI_TouchEdit_Precache( void )
{

}

/*
=================
UI_TouchEdit_Menu
=================
*/
void UI_TouchEdit_Menu( void )
{
	UI_TouchEdit_Precache();
	UI_TouchEdit_Init();

	UI_PushMenu( &uiTouchEdit.menu );
}

```

`mainui/menu_touchoptions.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER	  	"gfx/shell/head_touch_options"

#define ID_BACKGROUND 	0
#define ID_BANNER	  	1
#define ID_DONE	  	2
#define ID_LOOKX	3
#define ID_LOOKY		4
#define ID_MOVEX	5 
#define ID_MOVEY	6
#define ID_ENABLE	7
#define ID_RESET	8
#define ID_PROFILELIST	9
#define ID_SAVE 10
#define ID_DELETE 11
#define ID_MSGBOX	 	12
#define ID_MSGTEXT	 	13
#define ID_PROFILENAME	 	14
#define ID_APPLY	15
#define ID_GRID		16
#define ID_GRID_SIZE	17
#define ID_IGNORE_MOUSE	18
#define ID_YES	 	130
#define ID_NO	 	131
typedef struct
{
	menuFramework_s	menu;
	char		profileDesc[UI_MAXGAMES][95];
	char		*profileDescPtr[UI_MAXGAMES];
	int			firstProfile;
	menuBitmap_s	background;
	menuBitmap_s	banner;

	menuPicButton_s	done;

	menuSlider_s	lookX;
	menuSlider_s	lookY;
	menuSlider_s	moveX;
	menuSlider_s	moveY;
	menuCheckBox_s	enable;
	menuCheckBox_s	grid;
	menuCheckBox_s	nomouse;
	menuPicButton_s	reset;
	menuPicButton_s	save;
	menuPicButton_s	remove;
	menuPicButton_s	apply;
	menuField_s	profilename;
	menuScrollList_s profiles;
	menuSpinControl_s gridsize;

	// prompt dialog
	menuAction_s	msgBox;
	menuAction_s	promptMessage;
	menuPicButton_s	yes;
	menuPicButton_s	no;
	void ( *dialogAction ) ( void );
	char dialogText[256];
} uiTouchOptions_t;

static uiTouchOptions_t	uiTouchOptions;



/*
=================
UI_MsgBox_Ownerdraw
=================
*/
static void UI_MsgBox_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	UI_FillRect( item->x, item->y, item->width, item->height, uiPromptBgColor );
}


static void UI_TouchOptions_GetProfileList( void )
{
	char	**filenames;
	int	i = 0, numFiles, j = 0;
	char *curprofile;

	strncpy( uiTouchOptions.profileDesc[i], "Presets:", CS_SIZE );
	uiTouchOptions.profileDescPtr[i] = uiTouchOptions.profileDesc[i];
	i++;

	filenames = FS_SEARCH( "touch_presets/*.cfg", &numFiles, TRUE );
	for ( ; j < numFiles; i++, j++ )
	{
		if( i >= UI_MAXGAMES ) break;

		// strip path, leave only filename (empty slots doesn't have savename)
		COM_FileBase( filenames[j], uiTouchOptions.profileDesc[i] );
		uiTouchOptions.profileDescPtr[i] = uiTouchOptions.profileDesc[i];
	}

	// Overwrite "Presets:" line if there is no presets
	if( i == 1 )
		i = 0;

	filenames = FS_SEARCH( "touch_profiles/*.cfg", &numFiles, TRUE );
	j = 0;
	curprofile = CVAR_GET_STRING("touch_config_file");

	strncpy( uiTouchOptions.profileDesc[i], "Profiles:", CS_SIZE );
	uiTouchOptions.profileDescPtr[i] = uiTouchOptions.profileDesc[i];
	i++;

	strncpy( uiTouchOptions.profileDesc[i], "default", CS_SIZE );
	uiTouchOptions.profileDescPtr[i] = uiTouchOptions.profileDesc[i];

	uiTouchOptions.profiles.highlight = i;

	uiTouchOptions.firstProfile = i;
	i++;

	for ( ; j < numFiles; i++, j++ )
	{
		if( i >= UI_MAXGAMES ) break;

		COM_FileBase( filenames[j], uiTouchOptions.profileDesc[i] );
		uiTouchOptions.profileDescPtr[i] = uiTouchOptions.profileDesc[i];
		if( !strcmp( filenames[j], curprofile ) )
			uiTouchOptions.profiles.highlight = i;
	}
	uiTouchOptions.profiles.numItems = i;

	uiTouchOptions.remove.generic.flags |= QMF_GRAYED;
	uiTouchOptions.apply.generic.flags |= QMF_GRAYED;

	if( uiTouchOptions.profiles.generic.charHeight )
	{
		uiTouchOptions.profiles.numRows = (uiTouchOptions.profiles.generic.height2 / uiTouchOptions.profiles.generic.charHeight) - 2;
		if( uiTouchOptions.profiles.numRows > uiTouchOptions.profiles.numItems )
			uiTouchOptions.profiles.numRows = i;
	}

	for ( ; i < UI_MAXGAMES; i++ )
		uiTouchOptions.profileDescPtr[i] = NULL;
	uiTouchOptions.profiles.curItem = uiTouchOptions.profiles.highlight;


	uiTouchOptions.profiles.itemNames = (const char **)uiTouchOptions.profileDescPtr;
}
static void UI_TouchOptions_SetConfig( void );
/*
=================
UI_TouchOptions_GetConfig
=================
*/
static void UI_TouchOptions_GetConfig( void )
{
	uiTouchOptions.lookX.curValue = RemapVal( CVAR_GET_FLOAT( "touch_yaw" ), 50.0f, 500.0f, 0.0f, 1.0f );
	uiTouchOptions.lookY.curValue = RemapVal( CVAR_GET_FLOAT( "touch_pitch" ), 50.0f, 500.0f, 0.0f, 1.0f );
	uiTouchOptions.moveX.curValue = ( 2.0f / CVAR_GET_FLOAT( "touch_sidezone" ) ) / 100;
	uiTouchOptions.moveY.curValue = ( 2.0f / CVAR_GET_FLOAT( "touch_forwardzone" ) ) / 100;


	uiTouchOptions.enable.enabled = CVAR_GET_FLOAT( "touch_enable" );
	uiTouchOptions.nomouse.enabled = CVAR_GET_FLOAT( "m_ignore" );
	uiTouchOptions.grid.enabled = CVAR_GET_FLOAT( "touch_grid_enable" );
	uiTouchOptions.gridsize.curValue = CVAR_GET_FLOAT( "touch_grid_count" );
	UI_TouchOptions_SetConfig( );
}

/*
=================
UI_TouchOptions_SetConfig
=================
*/

static void UI_TouchOptions_SetConfig( void )
{
	static char gridText[8];
	snprintf( gridText, 8, "%.f", uiTouchOptions.gridsize.curValue );

	uiTouchOptions.gridsize.generic.name = gridText;
	CVAR_SET_FLOAT( "touch_grid_enable", uiTouchOptions.grid.enabled );
	CVAR_SET_FLOAT( "touch_grid_count", uiTouchOptions.gridsize.curValue );
	CVAR_SET_FLOAT( "touch_yaw", RemapVal( uiTouchOptions.lookX.curValue, 0.0f, 1.0f, 50.0f, 500.0f ));
	CVAR_SET_FLOAT( "touch_pitch", RemapVal( uiTouchOptions.lookY.curValue, 0.0f, 1.0f, 50.0f, 500.0f ));
	CVAR_SET_FLOAT( "touch_sidezone", ( 2.0 / uiTouchOptions.moveX.curValue ) / 100 );
	CVAR_SET_FLOAT( "touch_forwardzone", ( 2.0 / uiTouchOptions.moveY.curValue ) / 100 );
	CVAR_SET_FLOAT( "touch_enable", uiTouchOptions.enable.enabled );
	CVAR_SET_FLOAT( "m_ignore", uiTouchOptions.nomouse.enabled );
}

static void UI_DeleteProfile()
{
	char command[256];

	if( uiTouchOptions.profiles.curItem <= uiTouchOptions.firstProfile )
		return;

	snprintf(command, 256, "touch_deleteprofile \"%s\"\n", uiTouchOptions.profileDesc[ uiTouchOptions.profiles.curItem ] );
	CLIENT_COMMAND(1, command);
	UI_TouchOptions_GetProfileList();
}

static void UI_ResetButtons()
{
	CLIENT_COMMAND( 0, "touch_pitch 90\n" );
	CLIENT_COMMAND( 0, "touch_yaw 120\n" );
	CLIENT_COMMAND( 0, "touch_forwardzone 0.06\n" );
	CLIENT_COMMAND( 0, "touch_sidezone 0.06\n" );
	CLIENT_COMMAND( 0, "touch_grid 1\n" );
	CLIENT_COMMAND( 1, "touch_grid_count 50\n" );
	UI_TouchOptions_GetConfig();
}

/*
=================
UI_TouchOptions_Callback
=================
*/
static void UI_TouchOptions_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	switch( item->id )
	{
	case ID_ENABLE:
	case ID_GRID:
	case ID_IGNORE_MOUSE:
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
		break;
	}

	if( event == QM_CHANGED )
	{
		// Update cvars based on controls
		UI_TouchOptions_SetConfig();

		if( item->id == ID_PROFILELIST )
		{
			char curprofile[256];
			int isCurrent;
			COM_FileBase( CVAR_GET_STRING( "touch_config_file" ), curprofile );
			isCurrent = !strcmp( curprofile, uiTouchOptions.profileDesc[ uiTouchOptions.profiles.curItem ]);

			// Scrolllist changed, update availiable options
			uiTouchOptions.remove.generic.flags |= QMF_GRAYED;
			if( ( uiTouchOptions.profiles.curItem > uiTouchOptions.firstProfile ) && !isCurrent )
				uiTouchOptions.remove.generic.flags &= ~QMF_GRAYED;

			uiTouchOptions.apply.generic.flags &= ~QMF_GRAYED;
			if( uiTouchOptions.profiles.curItem == 0 || uiTouchOptions.profiles.curItem == uiTouchOptions.firstProfile -1 )
				uiTouchOptions.profiles.curItem ++;
			if( isCurrent )
				uiTouchOptions.apply.generic.flags |= QMF_GRAYED;
		}
		return;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		UI_TouchOptions_SetConfig();
		UI_PopMenu();
		break;
	case ID_RESET:
		uiTouchOptions.save.generic.flags |= QMF_INACTIVE; 
		uiTouchOptions.remove.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.enable.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.profiles.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.moveX.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.moveY.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.lookX.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.lookY.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.reset.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.profilename.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.done.generic.flags |= QMF_INACTIVE;


		uiTouchOptions.msgBox.generic.flags &= ~QMF_HIDDEN;
		uiTouchOptions.promptMessage.generic.flags &= ~QMF_HIDDEN;
		uiTouchOptions.no.generic.flags &= ~QMF_HIDDEN;
		uiTouchOptions.yes.generic.flags &= ~QMF_HIDDEN;
		strcpy( uiTouchOptions.dialogText, "Reset all buttons?" );
		uiTouchOptions.dialogAction = UI_ResetButtons;
		break;
	case ID_DELETE:
		uiTouchOptions.save.generic.flags |= QMF_INACTIVE; 
		uiTouchOptions.remove.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.enable.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.profiles.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.moveX.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.moveY.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.lookX.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.lookY.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.reset.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.profilename.generic.flags |= QMF_INACTIVE;
		uiTouchOptions.done.generic.flags |= QMF_INACTIVE;


		uiTouchOptions.msgBox.generic.flags &= ~QMF_HIDDEN;
		uiTouchOptions.promptMessage.generic.flags &= ~QMF_HIDDEN;
		uiTouchOptions.no.generic.flags &= ~QMF_HIDDEN;
		uiTouchOptions.yes.generic.flags &= ~QMF_HIDDEN;
		strcpy( uiTouchOptions.dialogText, "Delete selected profile?" );
		uiTouchOptions.dialogAction = UI_DeleteProfile;
		break;
	case ID_YES:
	if( uiTouchOptions.dialogAction )
		uiTouchOptions.dialogAction();
	case ID_NO:
		uiTouchOptions.save.generic.flags &= ~QMF_INACTIVE; 
		uiTouchOptions.remove.generic.flags &= ~QMF_INACTIVE;
		uiTouchOptions.enable.generic.flags &= ~QMF_INACTIVE;
		uiTouchOptions.profiles.generic.flags &= ~QMF_INACTIVE;
		uiTouchOptions.moveX.generic.flags &= ~QMF_INACTIVE;
		uiTouchOptions.moveY.generic.flags &= ~QMF_INACTIVE;
		uiTouchOptions.lookX.generic.flags &= ~QMF_INACTIVE;
		uiTouchOptions.lookY.generic.flags &= ~QMF_INACTIVE;
		uiTouchOptions.reset.generic.flags &= ~QMF_INACTIVE;
		uiTouchOptions.profilename.generic.flags &= ~QMF_INACTIVE;
		uiTouchOptions.done.generic.flags &= ~QMF_INACTIVE;

		uiTouchOptions.msgBox.generic.flags |= QMF_HIDDEN;
		uiTouchOptions.promptMessage.generic.flags |= QMF_HIDDEN;
		uiTouchOptions.no.generic.flags |= QMF_HIDDEN;
		uiTouchOptions.yes.generic.flags |= QMF_HIDDEN;
		break;
	case ID_SAVE:
		{
			char name[256];
			if( uiTouchOptions.profilename.buffer[0] )
			{
				snprintf( name, 256, "touch_profiles/%s.cfg", uiTouchOptions.profilename.buffer );
				CVAR_SET_STRING("touch_config_file", name );
			}
			CLIENT_COMMAND( 1, "touch_writeconfig\n" );
		}
		UI_TouchOptions_GetProfileList();
		uiTouchOptions.profilename.buffer[0] = 0;
		uiTouchOptions.profilename.cursor = uiTouchOptions.profilename.scroll = 0;
		break;
	case ID_APPLY:
		{

			int i = uiTouchOptions.profiles.curItem;

			// preset selected
			if( i > 0 && i < uiTouchOptions.firstProfile - 1 )
			{
				char command[256];
				char *curconfig = CVAR_GET_STRING( "touch_config_file" );
				snprintf( command, 256, "exec \"touch_presets/%s\"\n", uiTouchOptions.profileDesc[ i ] );
				CLIENT_COMMAND( 1,  command );

				while( FILE_EXISTS( curconfig ) )
				{
					char copystring[256];
					char filebase[256];

					COM_FileBase( curconfig, filebase );

					if( snprintf( copystring, 256, "touch_profiles/%s (new).cfg", filebase ) > 255 )
						break;

					CVAR_SET_STRING( "touch_config_file", copystring );
					curconfig = CVAR_GET_STRING( "touch_config_file" );
				}
			}
			else if( i == uiTouchOptions.firstProfile )
				CLIENT_COMMAND( 1,"exec touch.cfg\n" );
			else if( i > uiTouchOptions.firstProfile )
			{
				char command[256];
				snprintf( command, 256, "exec \"touch_profiles/%s\"\n", uiTouchOptions.profileDesc[ i ] );
				CLIENT_COMMAND( 1,  command );
			}

			// try save config
			CLIENT_COMMAND( 1,  "touch_writeconfig\n" );

			// check if it failed ant reset profile to default if it is
			if( !FILE_EXISTS( CVAR_GET_STRING( "touch_config_file" ) ))
			{
				CVAR_SET_STRING( "touch_config_file", "touch.cfg" );
				uiTouchOptions.profiles.curItem = uiTouchOptions.firstProfile;
			}
			UI_TouchOptions_GetProfileList();
			UI_TouchOptions_GetConfig();
		}
	}
}

/*
=================
UI_TouchOptions_Init
=================
*/
static void UI_TouchOptions_Init( void )
{
	memset( &uiTouchOptions, 0, sizeof( uiTouchOptions_t ));

	//uiTouchOptions.hTestImage = PIC_Load( ART_GAMMA, PIC_KEEP_RGBDATA );

	//uiTouchOptions.menu.vidInitFunc = UI_TouchOptions_Init;

	uiTouchOptions.background.generic.id = ID_BACKGROUND;
	uiTouchOptions.background.generic.type = QMTYPE_BITMAP;
	uiTouchOptions.background.generic.flags = QMF_INACTIVE;
	uiTouchOptions.background.generic.x = 0;
	uiTouchOptions.background.generic.y = 0;
	uiTouchOptions.background.generic.width = uiStatic.width;
	uiTouchOptions.background.generic.height = 768;
	uiTouchOptions.background.pic = ART_BACKGROUND;

	uiTouchOptions.banner.generic.id = ID_BANNER;
	uiTouchOptions.banner.generic.type = QMTYPE_BITMAP;
	uiTouchOptions.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiTouchOptions.banner.generic.x = UI_BANNER_POSX;
	uiTouchOptions.banner.generic.y = UI_BANNER_POSY;
	uiTouchOptions.banner.generic.width = UI_BANNER_WIDTH;
	uiTouchOptions.banner.generic.height = UI_BANNER_HEIGHT;
	uiTouchOptions.banner.pic = ART_BANNER;
/*
	uiTouchOptions.testImage.generic.id = ID_BANNER;
	uiTouchOptions.testImage.generic.type = QMTYPE_BITMAP;
	uiTouchOptions.testImage.generic.flags = QMF_INACTIVE;
	uiTouchOptions.testImage.generic.x = 390;
	uiTouchOptions.testImage.generic.y = 225;
	uiTouchOptions.testImage.generic.width = 480;
	uiTouchOptions.testImage.generic.height = 450;
	uiTouchOptions.testImage.pic = ART_GAMMA;
	uiTouchOptions.testImage.generic.ownerdraw = UI_TouchOptions_Ownerdraw;
*/
	uiTouchOptions.done.generic.id = ID_DONE;
	uiTouchOptions.done.generic.type = QMTYPE_BM_BUTTON;
	uiTouchOptions.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchOptions.done.generic.x = 72;
	uiTouchOptions.done.generic.y = 700;
	uiTouchOptions.done.generic.name = "Done";
	uiTouchOptions.done.generic.statusText = "Go back to the Touch Menu";
	uiTouchOptions.done.generic.callback = UI_TouchOptions_Callback;

	UI_UtilSetupPicButton( &uiTouchOptions.done, PC_DONE );

	uiTouchOptions.lookX.generic.id = ID_LOOKX;
	uiTouchOptions.lookX.generic.type = QMTYPE_SLIDER;
	uiTouchOptions.lookX.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW;
	uiTouchOptions.lookX.generic.name = "Look X";
	uiTouchOptions.lookX.generic.x = 72;
	uiTouchOptions.lookX.generic.y = 280;
	uiTouchOptions.lookX.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.lookX.generic.statusText = "Horizontal look sensitivity";
	uiTouchOptions.lookX.minValue = 0.0;
	uiTouchOptions.lookX.maxValue = 1.0;
	uiTouchOptions.lookX.range = 0.05f;

	uiTouchOptions.lookY.generic.id = ID_LOOKY;
	uiTouchOptions.lookY.generic.type = QMTYPE_SLIDER;
	uiTouchOptions.lookY.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW;
	uiTouchOptions.lookY.generic.name = "Look Y";
	uiTouchOptions.lookY.generic.x = 72;
	uiTouchOptions.lookY.generic.y = 340;
	uiTouchOptions.lookY.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.lookY.generic.statusText = "Vertical look sensitivity";
	uiTouchOptions.lookY.minValue = 0.0;
	uiTouchOptions.lookY.maxValue = 1.0;
	uiTouchOptions.lookY.range = 0.05f;

	uiTouchOptions.moveX.generic.id = ID_MOVEX;
	uiTouchOptions.moveX.generic.type = QMTYPE_SLIDER;
	uiTouchOptions.moveX.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW;
	uiTouchOptions.moveX.generic.name = "Side";
	uiTouchOptions.moveX.generic.x = 72;
	uiTouchOptions.moveX.generic.y = 400;
	uiTouchOptions.moveX.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.moveX.generic.statusText = "Side move sensitivity";
	uiTouchOptions.moveX.minValue = 0.02;
	uiTouchOptions.moveX.maxValue = 1.0;
	uiTouchOptions.moveX.range = 0.05f;

	uiTouchOptions.moveY.generic.id = ID_MOVEY;
	uiTouchOptions.moveY.generic.type = QMTYPE_SLIDER;
	uiTouchOptions.moveY.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW;
	uiTouchOptions.moveY.generic.name = "Forward";
	uiTouchOptions.moveY.generic.x = 72;
	uiTouchOptions.moveY.generic.y = 460;
	uiTouchOptions.moveY.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.moveY.generic.statusText = "Forward move sensitivity";
	uiTouchOptions.moveY.minValue = 0.02;
	uiTouchOptions.moveY.maxValue = 1.0;
	uiTouchOptions.moveY.range = 0.05f;

	uiTouchOptions.gridsize.generic.id = ID_GRID_SIZE;
	uiTouchOptions.gridsize.generic.type = QMTYPE_SPINCONTROL;
	uiTouchOptions.gridsize.generic.flags = QMF_CENTER_JUSTIFY|QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchOptions.gridsize.generic.x = 72+30;
	uiTouchOptions.gridsize.generic.y = 580;
	uiTouchOptions.gridsize.generic.width = 150;
	uiTouchOptions.gridsize.generic.height = 30;
	uiTouchOptions.gridsize.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.gridsize.generic.statusText = "Set grid size";
	uiTouchOptions.gridsize.maxValue = 100;
	uiTouchOptions.gridsize.minValue = 25;
	uiTouchOptions.gridsize.range = 5;

	uiTouchOptions.grid.generic.id = ID_GRID;
	uiTouchOptions.grid.generic.type = QMTYPE_CHECKBOX;
	uiTouchOptions.grid.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_MOUSEONLY|QMF_DROPSHADOW;
	uiTouchOptions.grid.generic.name = "Grid";
	uiTouchOptions.grid.generic.x = 72;
	uiTouchOptions.grid.generic.y = 520;
	uiTouchOptions.grid.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.grid.generic.statusText = "Enable/disable grid";

	uiTouchOptions.enable.generic.id = ID_ENABLE;
	uiTouchOptions.enable.generic.type = QMTYPE_CHECKBOX;
	uiTouchOptions.enable.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_MOUSEONLY|QMF_DROPSHADOW;
	uiTouchOptions.enable.generic.name = "Enable";
	uiTouchOptions.enable.generic.x = 680;
	uiTouchOptions.enable.generic.y = 650;
	uiTouchOptions.enable.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.enable.generic.statusText = "enable/disable touch controls";

	uiTouchOptions.nomouse.generic.id = ID_IGNORE_MOUSE;
	uiTouchOptions.nomouse.generic.type = QMTYPE_CHECKBOX;
	uiTouchOptions.nomouse.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_MOUSEONLY|QMF_DROPSHADOW;
	uiTouchOptions.nomouse.generic.name = "Ignore Mouse";
	uiTouchOptions.nomouse.generic.x = 680;
	uiTouchOptions.nomouse.generic.y = 590;
	uiTouchOptions.nomouse.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.nomouse.generic.statusText = "Ignore mouse input";

	uiTouchOptions.profiles.generic.id = ID_PROFILELIST;
	uiTouchOptions.profiles.generic.type = QMTYPE_SCROLLLIST;
	uiTouchOptions.profiles.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_SMALLFONT;
	uiTouchOptions.profiles.generic.x = 360;
	uiTouchOptions.profiles.generic.y = 255;
	uiTouchOptions.profiles.generic.width = 300;
	uiTouchOptions.profiles.generic.height = 340;
	uiTouchOptions.profiles.generic.callback = UI_TouchOptions_Callback;

	uiTouchOptions.reset.generic.id = ID_RESET;
	uiTouchOptions.reset.generic.type = QMTYPE_BM_BUTTON;
	uiTouchOptions.reset.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW | QMF_ACT_ONRELEASE;
	uiTouchOptions.reset.generic.name = "Reset";
	uiTouchOptions.reset.generic.x = 72;
	uiTouchOptions.reset.generic.y = 640;
	uiTouchOptions.reset.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.reset.generic.statusText = "Reset touch to default state";
	uiTouchOptions.reset.pic = PIC_Load("gfx/shell/btn_touch_reset");
	
	uiTouchOptions.remove.generic.id = ID_DELETE;
	uiTouchOptions.remove.generic.type = QMTYPE_BM_BUTTON;
	uiTouchOptions.remove.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchOptions.remove.generic.x = 560;
	uiTouchOptions.remove.generic.y = 650;
	uiTouchOptions.remove.generic.name = "Delete";
	uiTouchOptions.remove.generic.statusText = "Delete saved game";
	uiTouchOptions.remove.generic.callback = UI_TouchOptions_Callback;
	UI_UtilSetupPicButton( &uiTouchOptions.remove, PC_DELETE );

	uiTouchOptions.apply.generic.id = ID_APPLY;
	uiTouchOptions.apply.generic.type = QMTYPE_BM_BUTTON;
	uiTouchOptions.apply.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchOptions.apply.generic.x = 360;
	uiTouchOptions.apply.generic.y = 650;
	uiTouchOptions.apply.generic.name = "Activate";
	uiTouchOptions.apply.generic.statusText = "Apply selected profile";
	uiTouchOptions.apply.generic.callback = UI_TouchOptions_Callback;
	UI_UtilSetupPicButton( &uiTouchOptions.apply, PC_ACTIVATE );

	uiTouchOptions.profilename.generic.id = ID_PROFILENAME;
	uiTouchOptions.profilename.generic.type = QMTYPE_FIELD;
	uiTouchOptions.profilename.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiTouchOptions.profilename.generic.name = "New Profile:";
	uiTouchOptions.profilename.generic.x = 680;
	uiTouchOptions.profilename.generic.y = 260;
	uiTouchOptions.profilename.generic.width = 205;
	uiTouchOptions.profilename.generic.height = 32;
	uiTouchOptions.profilename.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.profilename.maxLength = 16;

	uiTouchOptions.save.generic.id = ID_SAVE;
	uiTouchOptions.save.generic.type = QMTYPE_BM_BUTTON;
	uiTouchOptions.save.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW | QMF_ACT_ONRELEASE;
	uiTouchOptions.save.generic.x = 680;
	uiTouchOptions.save.generic.y = 330;
	uiTouchOptions.save.generic.name = "Save";
	uiTouchOptions.save.generic.statusText = "Save new profile";
	uiTouchOptions.save.generic.callback = UI_TouchOptions_Callback;
	uiTouchOptions.save.pic = PIC_Load("gfx/shell/btn_touch_save");
	
	uiTouchOptions.msgBox.generic.id = ID_MSGBOX;
	uiTouchOptions.msgBox.generic.type = QMTYPE_ACTION;
	uiTouchOptions.msgBox.generic.flags = QMF_INACTIVE|QMF_HIDDEN;
	uiTouchOptions.msgBox.generic.ownerdraw = UI_MsgBox_Ownerdraw; // just a fill rectangle
	uiTouchOptions.msgBox.generic.x = DLG_X + 192;
	uiTouchOptions.msgBox.generic.y = 256;
	uiTouchOptions.msgBox.generic.width = 640;
	uiTouchOptions.msgBox.generic.height = 256;

	uiTouchOptions.promptMessage.generic.id = ID_MSGBOX;
	uiTouchOptions.promptMessage.generic.type = QMTYPE_ACTION;
	uiTouchOptions.promptMessage.generic.flags = QMF_INACTIVE|QMF_DROPSHADOW|QMF_HIDDEN;
	uiTouchOptions.promptMessage.generic.name = uiTouchOptions.dialogText;
	uiTouchOptions.promptMessage.generic.x = DLG_X + 315;
	uiTouchOptions.promptMessage.generic.y = 280;

	uiTouchOptions.yes.generic.id = ID_YES;
	uiTouchOptions.yes.generic.type = QMTYPE_BM_BUTTON;
	uiTouchOptions.yes.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiTouchOptions.yes.generic.name = "Ok";
	uiTouchOptions.yes.generic.x = DLG_X + 380;
	uiTouchOptions.yes.generic.y = 460;
	uiTouchOptions.yes.generic.callback = UI_TouchOptions_Callback;

	UI_UtilSetupPicButton( &uiTouchOptions.yes, PC_OK );

	uiTouchOptions.no.generic.id = ID_NO;
	uiTouchOptions.no.generic.type = QMTYPE_BM_BUTTON;
	uiTouchOptions.no.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW|QMF_HIDDEN;
	uiTouchOptions.no.generic.name = "Cancel";
	uiTouchOptions.no.generic.x = DLG_X + 530;
	uiTouchOptions.no.generic.y = 460;
	uiTouchOptions.no.generic.callback = UI_TouchOptions_Callback;

	UI_UtilSetupPicButton( &uiTouchOptions.no, PC_CANCEL );
	UI_TouchOptions_GetConfig();
	UI_TouchOptions_GetProfileList();

	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.background );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.banner );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.done );
	uiTouchOptions.apply.generic.width = 80;
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.lookX );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.lookY );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.moveX );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.moveY );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.enable );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.nomouse );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.reset );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.profiles );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.save );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.profilename );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.remove );
	uiTouchOptions.remove.generic.width = 100;
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.apply );
	uiTouchOptions.apply.generic.width = 120;
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.grid );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.gridsize );

	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.msgBox );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.promptMessage );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.no );
	UI_AddItem( &uiTouchOptions.menu, (void *)&uiTouchOptions.yes );
	UI_TouchOptions_GetProfileList();

}

/*
=================
UI_TouchOptions_Precache
=================
*/
void UI_TouchOptions_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_TouchOptions_Menu
=================
*/
void UI_TouchOptions_Menu( void )
{
	UI_TouchOptions_Precache();
	UI_TouchOptions_Init();

	UI_PushMenu( &uiTouchOptions.menu );
}

```

`mainui/menu_vidoptions.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "menu_btnsbmp_table.h"

#define ART_BANNER		"gfx/shell/head_video"
#define ART_GAMMA		"gfx/shell/gamma"

#define ID_BACKGROUND 	0
#define ID_BANNER	  	1
#define ID_DONE	  	2
#define ID_SCREEN_SIZE	3
#define ID_GAMMA		4
#define ID_GLARE_REDUCTION	5 
#define ID_SIMPLE_SKY	6
#define ID_ALLOW_MATERIALS	7
#define ID_VERTICALSYNC	7

typedef struct
{
	int		outlineWidth;
	menuFramework_s	menu;

	menuBitmap_s	background;
	menuBitmap_s	banner;
	menuBitmap_s	testImage;

	menuPicButton_s	done;

	menuSlider_s	screenSize;
	menuSlider_s	gammaIntensity;
	menuSlider_s	glareReduction;
	menuCheckBox_s	fastSky;
	menuCheckBox_s	hiTextures;
	menuCheckBox_s	vsync;

	HIMAGE		hTestImage;
} uiVidOptions_t;

static uiVidOptions_t	uiVidOptions;


/*
=================
UI_VidOptions_GetConfig
=================
*/
static void UI_VidOptions_GetConfig( void )
{
	uiVidOptions.screenSize.curValue = RemapVal( CVAR_GET_FLOAT( "viewsize" ), 30.0f, 120.0f, 0.0f, 1.0f );
	uiVidOptions.glareReduction.curValue = (CVAR_GET_FLOAT( "r_flaresize" ) - 100.0f ) / 200.0f;

	if( CVAR_GET_FLOAT( "gl_ignorehwgamma" ))
	{
		uiVidOptions.gammaIntensity.curValue = RemapVal( CVAR_GET_FLOAT( "gamma" ), 1.8f, 7.0f, 0.0f, 1.0f );
		PIC_SetGamma( uiVidOptions.hTestImage, CVAR_GET_FLOAT( "gamma" ));
	}
	else uiVidOptions.gammaIntensity.curValue = RemapVal( CVAR_GET_FLOAT( "gamma" ), 0.5f, 2.3f, 0.0f, 1.0f );

	if( CVAR_GET_FLOAT( "r_fastsky" ))
		uiVidOptions.fastSky.enabled = 1;

	if( CVAR_GET_FLOAT( "host_allow_materials" ))
		uiVidOptions.hiTextures.enabled = 1;

	if( CVAR_GET_FLOAT( "gl_swapInterval" ))
		uiVidOptions.vsync.enabled = 1;

	uiVidOptions.outlineWidth = 2;
	UI_ScaleCoords( NULL, NULL, &uiVidOptions.outlineWidth, NULL );
}

/*
=================
UI_VidOptions_UpdateConfig
=================
*/
static void UI_VidOptions_UpdateConfig( void )
{
	CVAR_SET_FLOAT( "viewsize", RemapVal( uiVidOptions.screenSize.curValue, 0.0f, 1.0f, 30.0f, 120.0f ));
	CVAR_SET_FLOAT( "r_flaresize", (uiVidOptions.glareReduction.curValue * 200.0f ) + 100.0f );
	CVAR_SET_FLOAT( "r_fastsky", uiVidOptions.fastSky.enabled );
	CVAR_SET_FLOAT( "host_allow_materials", uiVidOptions.hiTextures.enabled );
	CVAR_SET_FLOAT( "gl_swapInterval", uiVidOptions.vsync.enabled );

	if( CVAR_GET_FLOAT( "gl_ignorehwgamma" ))
		PIC_SetGamma( uiVidOptions.hTestImage, RemapVal( uiVidOptions.gammaIntensity.curValue, 0.0f, 1.0f, 1.8f, 7.0f ));
	else CVAR_SET_FLOAT( "gamma", RemapVal( uiVidOptions.gammaIntensity.curValue, 0.0f, 1.0f, 0.5f, 2.3f ));
}

static void UI_VidOptions_SetConfig( void )
{
	CVAR_SET_FLOAT( "viewsize", RemapVal( uiVidOptions.screenSize.curValue, 0.0f, 1.0f, 30.0f, 120.0f ));
	CVAR_SET_FLOAT( "r_flaresize", (uiVidOptions.glareReduction.curValue * 200.0f ) + 100.0f );
	CVAR_SET_FLOAT( "r_fastsky", uiVidOptions.fastSky.enabled );
	CVAR_SET_FLOAT( "host_allow_materials", uiVidOptions.hiTextures.enabled );
	CVAR_SET_FLOAT( "gl_swapInterval", uiVidOptions.vsync.enabled );

	if( CVAR_GET_FLOAT( "gl_ignorehwgamma" ))
		CVAR_SET_FLOAT( "gamma", RemapVal( uiVidOptions.gammaIntensity.curValue, 0.0f, 1.0f, 1.8f, 7.0f ));
	else CVAR_SET_FLOAT( "gamma", RemapVal( uiVidOptions.gammaIntensity.curValue, 0.0f, 1.0f, 0.5f, 2.3f ));
}

/*
=================
UI_VidOptions_Ownerdraw
=================
*/
static void UI_VidOptions_Ownerdraw( void *self )
{
	menuCommon_s	*item = (menuCommon_s *)self;
	int		color = 0xFFFF0000; // 255, 0, 0, 255
	int		viewport[4];
	int		viewsize, size, sb_lines;

	viewsize = CVAR_GET_FLOAT( "viewsize" );

	if( viewsize >= 120 )
		sb_lines = 0;	// no status bar at all
	else if( viewsize >= 110 )
		sb_lines = 24;	// no inventory
	else sb_lines = 48;

	size = min( viewsize, 100 );

	viewport[2] = item->width * size / 100;
	viewport[3] = item->height * size / 100;

	if( viewport[3] > item->height - sb_lines )
		viewport[3] = item->height - sb_lines;
	if( viewport[3] > item->height )
		viewport[3] = item->height;

	viewport[2] &= ~7;
	viewport[3] &= ~1;

	viewport[0] = (item->width - viewport[2]) / 2;
	viewport[1] = (item->height - sb_lines - viewport[3]) / 2;

	UI_DrawPic( item->x + viewport[0], item->y + viewport[1], viewport[2], viewport[3], uiColorWhite, ((menuBitmap_s *)self)->pic );
	UI_DrawRectangleExt( item->x, item->y, item->width, item->height, color, uiVidOptions.outlineWidth );
}

/*
=================
UI_VidOptions_Callback
=================
*/
static void UI_VidOptions_Callback( void *self, int event )
{
	menuCommon_s	*item = (menuCommon_s *)self;

	switch( item->id )
	{
	case ID_SIMPLE_SKY:
	case ID_ALLOW_MATERIALS:
		if( event == QM_PRESSED )
			((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_PRESSED;
		else ((menuCheckBox_s *)self)->focusPic = UI_CHECKBOX_FOCUS;
		break;
	}

	if( event == QM_CHANGED )
	{
		UI_VidOptions_UpdateConfig();
		return;
	}

	if( event != QM_ACTIVATED )
		return;

	switch( item->id )
	{
	case ID_DONE:
		UI_VidOptions_SetConfig();
		UI_PopMenu();
		break;
	}
}

/*
=================
UI_VidOptions_Init
=================
*/
static void UI_VidOptions_Init( void )
{
	memset( &uiVidOptions, 0, sizeof( uiVidOptions_t ));

	uiVidOptions.hTestImage = PIC_Load( ART_GAMMA, PIC_KEEP_RGBDATA );

	uiVidOptions.menu.vidInitFunc = UI_VidOptions_Init;

	uiVidOptions.background.generic.id = ID_BACKGROUND;
	uiVidOptions.background.generic.type = QMTYPE_BITMAP;
	uiVidOptions.background.generic.flags = QMF_INACTIVE;
	uiVidOptions.background.generic.x = 0;
	uiVidOptions.background.generic.y = 0;
	uiVidOptions.background.generic.width = uiStatic.width;
	uiVidOptions.background.generic.height = 768;
	uiVidOptions.background.pic = ART_BACKGROUND;

	uiVidOptions.banner.generic.id = ID_BANNER;
	uiVidOptions.banner.generic.type = QMTYPE_BITMAP;
	uiVidOptions.banner.generic.flags = QMF_INACTIVE|QMF_DRAW_ADDITIVE;
	uiVidOptions.banner.generic.x = UI_BANNER_POSX;
	uiVidOptions.banner.generic.y = UI_BANNER_POSY;
	uiVidOptions.banner.generic.width = UI_BANNER_WIDTH;
	uiVidOptions.banner.generic.height = UI_BANNER_HEIGHT;
	uiVidOptions.banner.pic = ART_BANNER;

	uiVidOptions.testImage.generic.id = ID_BANNER;
	uiVidOptions.testImage.generic.type = QMTYPE_BITMAP;
	uiVidOptions.testImage.generic.flags = QMF_INACTIVE;
	uiVidOptions.testImage.generic.x = 390;
	uiVidOptions.testImage.generic.y = 225;
	uiVidOptions.testImage.generic.width = 480;
	uiVidOptions.testImage.generic.height = 450;
	uiVidOptions.testImage.pic = ART_GAMMA;
	uiVidOptions.testImage.generic.ownerdraw = UI_VidOptions_Ownerdraw;

	uiVidOptions.done.generic.id = ID_DONE;
	uiVidOptions.done.generic.type = QMTYPE_BM_BUTTON;
	uiVidOptions.done.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_DROPSHADOW;
	uiVidOptions.done.generic.x = 72;
	uiVidOptions.done.generic.y = 435;
	uiVidOptions.done.generic.name = "Done";
	uiVidOptions.done.generic.statusText = "Go back to the Video Menu";
	uiVidOptions.done.generic.callback = UI_VidOptions_Callback;

	UI_UtilSetupPicButton( &uiVidOptions.done, PC_DONE );

	uiVidOptions.screenSize.generic.id = ID_SCREEN_SIZE;
	uiVidOptions.screenSize.generic.type = QMTYPE_SLIDER;
	uiVidOptions.screenSize.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW|QMF_HIGHLIGHTIFFOCUS;
	uiVidOptions.screenSize.generic.name = "Screen size";
	uiVidOptions.screenSize.generic.x = 72;
	uiVidOptions.screenSize.generic.y = 280;
	uiVidOptions.screenSize.generic.callback = UI_VidOptions_Callback;
	uiVidOptions.screenSize.generic.statusText = "Set the screen size";
	uiVidOptions.screenSize.minValue = 0.0;
	uiVidOptions.screenSize.maxValue = 1.0;
	uiVidOptions.screenSize.range = 0.05f;

	uiVidOptions.gammaIntensity.generic.id = ID_GAMMA;
	uiVidOptions.gammaIntensity.generic.type = QMTYPE_SLIDER;
	uiVidOptions.gammaIntensity.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW|QMF_HIGHLIGHTIFFOCUS;
	uiVidOptions.gammaIntensity.generic.name = "Gamma";
	uiVidOptions.gammaIntensity.generic.x = 72;
	uiVidOptions.gammaIntensity.generic.y = 340;
	uiVidOptions.gammaIntensity.generic.callback = UI_VidOptions_Callback;
	uiVidOptions.gammaIntensity.generic.statusText = "Set gamma value (0.5 - 2.3)";
	uiVidOptions.gammaIntensity.minValue = 0.0;
	uiVidOptions.gammaIntensity.maxValue = 1.0;
	uiVidOptions.gammaIntensity.range = 0.05f;

	uiVidOptions.glareReduction.generic.id = ID_GLARE_REDUCTION;
	uiVidOptions.glareReduction.generic.type = QMTYPE_SLIDER;
	uiVidOptions.glareReduction.generic.flags = QMF_PULSEIFFOCUS|QMF_DROPSHADOW|QMF_HIGHLIGHTIFFOCUS;
	uiVidOptions.glareReduction.generic.name = "Glare reduction";
	uiVidOptions.glareReduction.generic.x = 72;
	uiVidOptions.glareReduction.generic.y = 400;
	uiVidOptions.glareReduction.generic.callback = UI_VidOptions_Callback;
	uiVidOptions.glareReduction.generic.statusText = "Set glare reduction level";
	uiVidOptions.glareReduction.minValue = 0.0;
	uiVidOptions.glareReduction.maxValue = 1.0;
	uiVidOptions.glareReduction.range = 0.05f;

	uiVidOptions.vsync.generic.id = ID_VERTICALSYNC;
	uiVidOptions.vsync.generic.type = QMTYPE_CHECKBOX;
	uiVidOptions.vsync.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiVidOptions.vsync.generic.name = "Vertical sync";
	uiVidOptions.vsync.generic.x = 72;
	uiVidOptions.vsync.generic.y = 565;
	uiVidOptions.vsync.generic.callback = UI_VidOptions_Callback;
	uiVidOptions.vsync.generic.statusText = "enable vertical synchronization";

	uiVidOptions.fastSky.generic.id = ID_SIMPLE_SKY;
	uiVidOptions.fastSky.generic.type = QMTYPE_CHECKBOX;
	uiVidOptions.fastSky.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiVidOptions.fastSky.generic.name = "Draw simple sky";
	uiVidOptions.fastSky.generic.x = 72;
	uiVidOptions.fastSky.generic.y = 615;
	uiVidOptions.fastSky.generic.callback = UI_VidOptions_Callback;
	uiVidOptions.fastSky.generic.statusText = "enable/disable fast sky rendering (for old computers)";

	uiVidOptions.hiTextures.generic.id = ID_ALLOW_MATERIALS;
	uiVidOptions.hiTextures.generic.type = QMTYPE_CHECKBOX;
	uiVidOptions.hiTextures.generic.flags = QMF_HIGHLIGHTIFFOCUS|QMF_ACT_ONRELEASE|QMF_DROPSHADOW;
	uiVidOptions.hiTextures.generic.name = "Allow materials";
	uiVidOptions.hiTextures.generic.x = 72;
	uiVidOptions.hiTextures.generic.y = 665;
	uiVidOptions.hiTextures.generic.callback = UI_VidOptions_Callback;
	uiVidOptions.hiTextures.generic.statusText = "let engine replace 8-bit textures with full color hi-res prototypes (if present)";

	UI_VidOptions_GetConfig();

	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.background );
	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.banner );
	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.done );
	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.screenSize );
	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.gammaIntensity );
	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.glareReduction );
	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.fastSky );
	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.hiTextures );
	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.testImage );
	UI_AddItem( &uiVidOptions.menu, (void *)&uiVidOptions.vsync );
}

/*
=================
UI_VidOptions_Precache
=================
*/
void UI_VidOptions_Precache( void )
{
	PIC_Load( ART_BACKGROUND );
	PIC_Load( ART_BANNER );
}

/*
=================
UI_VidOptions_Menu
=================
*/
void UI_VidOptions_Menu( void )
{
	UI_VidOptions_Precache();
	UI_VidOptions_Init();

	UI_PushMenu( &uiVidOptions.menu );
}

```

`mainui/menufont.h`:

```h
/*
menufont.h - built-in menu font 
Copyright (C) 2011 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef MENUFONT_H
#define MENUFONT_H

const byte menufont_bmp[] =
{
	0x42,0x4d,0x78,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x00,0x00,
	0x00,0x28,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,
	0x01,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x02,0x80,0x00,0x00,0x12,
	0x0b,0x00,0x00,0x12,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x11,0x11,0x00,0x22,0x22,0x22,
	0x00,0x33,0x33,0x33,0x00,0x44,0x44,0x44,0x00,0x55,0x55,0x55,0x00,
	0x66,0x66,0x66,0x00,0x77,0x77,0x77,0x00,0x88,0x88,0x88,0x00,0x99,
	0x99,0x99,0x00,0xaa,0xaa,0xaa,0x00,0xbb,0xbb,0xbb,0x00,0xcc,0xcc,
	0xcc,0x00,0xdd,0xdd,0xdd,0x00,0xee,0xee,0xee,0x00,0xff,0xff,0xff,
	0x00,0x21,0x1c,0xfb,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x00,
	0x00,0x11,0x11,0x11,0x11,0x11,0x11,0x10,0x01,0x11,0x11,0x11,0x11,
	0x11,0x9f,0xfb,0x41,0x11,0x11,0x11,0x11,0x10,0x01,0x6f,0xf3,0x00,
	0x01,0x11,0x11,0x10,0x00,0x11,0x11,0x00,0x01,0x11,0x11,0x10,0x00,
	0x00,0x00,0x38,0x51,0x11,0x11,0x11,0x11,0x11,0x10,0x00,0x11,0x11,
	0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x11,0x00,0x00,0x00,0x00,
	0x00,0x06,0x83,0x11,0x10,0x00,0x00,0x00,0x01,0x11,0x11,0x11,0x00,
	0x00,0x00,0x01,0x11,0x00,0x01,0x11,0x10,0x00,0x00,0x00,0x01,0x11,
	0x11,0x11,0x11,0x11,0x00,0x00,0x11,0x11,0x11,0x10,0x00,0x11,0x11,
	0x00,0x00,0x11,0x11,0x11,0x11,0x00,0x01,0x11,0x10,0x01,0x12,0x10,
	0x0c,0xfb,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x57,0x73,0x00,
	0x00,0x00,0x00,0x00,0x00,0x37,0x72,0x00,0x00,0x00,0x00,0x00,0x7a,
	0xef,0xd1,0x00,0x00,0x00,0x00,0x16,0x72,0x5f,0xf2,0x47,0x40,0x00,
	0x00,0x04,0x77,0x10,0x02,0x77,0x40,0x00,0x00,0x05,0x77,0x77,0x77,
	0xbf,0xa0,0x00,0x00,0x00,0x00,0x00,0x05,0x75,0x00,0x00,0x02,0x77,
	0x77,0x77,0x77,0x77,0x77,0x20,0x02,0x77,0x77,0x77,0x77,0x77,0x7e,
	0xf5,0x00,0x04,0x77,0x77,0x77,0x40,0x00,0x00,0x02,0x77,0x77,0x77,
	0x51,0x00,0x57,0x50,0x00,0x05,0x77,0x77,0x77,0x30,0x00,0x00,0x00,
	0x00,0x02,0x67,0x73,0x00,0x00,0x00,0x05,0x75,0x00,0x00,0x47,0x75,
	0x10,0x00,0x00,0x00,0x67,0x60,0x00,0x27,0x72,0x01,0x10,0x0c,0xfa,
	0x15,0x75,0x00,0x00,0x00,0x00,0x00,0x4d,0xff,0xff,0x91,0x00,0x00,
	0x00,0x00,0x00,0x6f,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xf6,
	0x00,0x00,0x00,0x01,0xcf,0xff,0xbf,0xfb,0xff,0xf8,0x00,0x00,0x04,
	0xff,0xa0,0x0a,0xff,0x40,0x00,0x00,0x0c,0xff,0xff,0xff,0xff,0xa0,
	0x00,0x00,0x00,0x00,0x00,0x0b,0xfc,0x00,0x00,0x05,0xff,0xff,0xff,
	0xff,0xff,0xff,0x50,0x05,0xff,0xff,0xff,0xff,0xff,0xff,0xf5,0x00,
	0x0a,0xff,0xff,0xff,0xfa,0x00,0x00,0x04,0xff,0xff,0xff,0xfd,0x30,
	0xcf,0xb0,0x00,0x0b,0xff,0xff,0xff,0xf9,0x00,0x00,0x00,0x00,0x6e,
	0xff,0xff,0x91,0x00,0x00,0x0b,0xfb,0x00,0x1b,0xff,0xff,0xd3,0x00,
	0x00,0x00,0x7f,0xf6,0x00,0x4f,0xf5,0x01,0x10,0x0c,0xfd,0xdf,0xff,
	0xc2,0x00,0x00,0x00,0x02,0xef,0xd7,0xaf,0xf7,0x00,0x00,0x00,0x00,
	0x00,0x6f,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x2f,0xfc,0x00,0x00,
	0x00,0x08,0xff,0x9a,0xff,0xff,0x8b,0xff,0x50,0x00,0x00,0x8f,0xf4,
	0x5f,0xf8,0x00,0x00,0x00,0x0c,0xfd,0x77,0x8e,0xfd,0x50,0x00,0x00,
	0x00,0x00,0x00,0x0a,0xfc,0x00,0x00,0x05,0xff,0x87,0x9f,0xf9,0x78,
	0xff,0x50,0x05,0xff,0x87,0x9f,0xf9,0x78,0xff,0xa2,0x00,0x09,0xfd,
	0x11,0x17,0xff,0x40,0x00,0x04,0xff,0x51,0x13,0xef,0xa0,0xbf,0xb0,
	0x00,0x0a,0xfc,0x11,0x18,0xff,0x30,0x00,0x00,0x03,0xff,0xd7,0xaf,
	0xf7,0x00,0x00,0x0b,0xfb,0x00,0x9f,0xf9,0x8e,0xfd,0x10,0x00,0x00,
	0x0b,0xfe,0x20,0x3f,0xf5,0x01,0x10,0x0c,0xff,0xc5,0x6e,0xfb,0x00,
	0x00,0x00,0x07,0xff,0x30,0x0c,0xfc,0x00,0x00,0x00,0x00,0x00,0x6f,
	0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x8f,0xff,0x40,0x00,0x00,0x1e,
	0xfa,0x00,0xbf,0xf8,0x01,0xdf,0xa0,0x00,0x00,0x1d,0xfd,0xef,0xd1,
	0x00,0x00,0x00,0x0c,0xfa,0x00,0x0b,0xfa,0x00,0x00,0x00,0x00,0x00,
	0x11,0x0a,0xfc,0x00,0x00,0x05,0xfe,0x00,0x3f,0xf3,0x01,0xff,0x50,
	0x05,0xff,0x10,0x3f,0xf3,0x00,0xef,0x40,0x00,0x09,0xfc,0x00,0x02,
	0xff,0x60,0x00,0x04,0xff,0x40,0x00,0xaf,0xc0,0xbf,0xb0,0x00,0x0a,
	0xfb,0x00,0x03,0xff,0x50,0x00,0x00,0x04,0xbd,0x30,0x0b,0xfd,0x10,
	0x00,0x0b,0xfa,0x01,0xff,0x80,0x04,0xff,0x60,0x00,0x00,0x03,0xef,
	0xa0,0x2f,0xf5,0x01,0x10,0x0c,0xfe,0x10,0x06,0xff,0x30,0x00,0x00,
	0x0a,0xfc,0x00,0x04,0x52,0x00,0x00,0x00,0x00,0x00,0x6f,0xf3,0x00,
	0x00,0x00,0x00,0x00,0x01,0xef,0xbf,0x90,0x00,0x00,0x3f,0xf5,0x00,
	0x6f,0xf3,0x00,0x9f,0xe1,0x00,0x00,0x04,0xff,0xff,0x40,0x00,0x00,
	0x00,0x0c,0xfa,0x00,0x0c,0xfa,0x00,0x00,0x00,0x00,0x2a,0xff,0xce,
	0xfc,0x00,0x00,0x05,0xff,0x10,0x3f,0xf3,0x02,0xff,0x50,0x05,0xff,
	0x20,0x3f,0xf3,0x01,0xff,0x50,0x00,0x09,0xfd,0x11,0x28,0xff,0x30,
	0x00,0x04,0xff,0x51,0x14,0xef,0x90,0xbf,0xb0,0x00,0x0a,0xfc,0x11,
	0x28,0xff,0x30,0x00,0x00,0x00,0x01,0x01,0x17,0xff,0x20,0x00,0x0b,
	0xfd,0x7a,0xff,0x40,0x01,0xdf,0x90,0x00,0x00,0x00,0x8f,0xfa,0x9f,
	0xf5,0x01,0x10,0x0c,0xfa,0x00,0x03,0xff,0x50,0x00,0x00,0x0b,0xfa,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6f,0xf3,0x00,0x00,0x00,
	0x00,0x00,0x06,0xfc,0x3f,0xf2,0x00,0x00,0x4f,0xf4,0x00,0x5f,0xf2,
	0x00,0x7f,0xf1,0x00,0x00,0x00,0xaf,0xf9,0x00,0x00,0x00,0x00,0x0c,
	0xfa,0x00,0x0c,0xfa,0x00,0x00,0x00,0x01,0xdf,0xe8,0x9e,0xfc,0x00,
	0x00,0x05,0xff,0x10,0x3f,0xf3,0x02,0xff,0x50,0x05,0xff,0x20,0x3f,
	0xf3,0x01,0xff,0x50,0x00,0x09,0xff,0xff,0xff,0xf9,0x00,0x00,0x04,
	0xff,0xff,0xff,0xfd,0x20,0xcf,0xb0,0x00,0x0a,0xff,0xff,0xff,0xf9,
	0x00,0x00,0x00,0x00,0x00,0x1f,0xff,0xff,0x30,0x00,0x0b,0xff,0xff,
	0xff,0x40,0x00,0xcf,0x90,0x00,0x00,0x07,0xff,0xff,0xff,0xf5,0x01,
	0x10,0x0c,0xfa,0x00,0x03,0xff,0x50,0x00,0x00,0x0a,0xfc,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x6f,0xf3,0x00,0x00,0x00,0x00,0x00,
	0x0c,0xf8,0x0b,0xf7,0x00,0x00,0x3f,0xf5,0x00,0x6f,0xf3,0x00,0x9f,
	0xd1,0x00,0x00,0x02,0xef,0xfc,0x10,0x00,0x00,0x00,0x0c,0xfa,0x00,
	0x0c,0xfa,0x00,0x00,0x00,0x05,0xff,0x40,0x0a,0xfc,0x00,0x00,0x05,
	0xff,0x10,0x3f,0xf3,0x02,0xff,0x50,0x05,0xff,0x20,0x3f,0xf3,0x01,
	0xff,0x50,0x00,0x09,0xfe,0x88,0x87,0x40,0x00,0x00,0x04,0xff,0xa8,
	0x88,0x61,0x00,0xcf,0xb0,0x00,0x0a,0xfe,0x88,0x87,0x40,0x00,0x00,
	0x00,0x00,0x00,0x07,0x8a,0xff,0x20,0x00,0x0b,0xfd,0x7a,0xff,0x40,
	0x01,0xdf,0x90,0x00,0x00,0x2f,0xf9,0x21,0x4f,0xf5,0x01,0x10,0x0c,
	0xfe,0x20,0x08,0xff,0x30,0x00,0x00,0x07,0xff,0x20,0x0b,0xb6,0x00,
	0x00,0x00,0x00,0x00,0x5f,0xf3,0x00,0x00,0x00,0x00,0x00,0x4f,0xf3,
	0x06,0xfd,0x10,0x00,0x1e,0xfa,0x00,0xbf,0xf8,0x01,0xdf,0xb0,0x00,
	0x00,0x0a,0xff,0xff,0x80,0x00,0x00,0x00,0x0c,0xfa,0x00,0x0c,0xfa,
	0x00,0x00,0x00,0x07,0xff,0x10,0x0a,0xfc,0x00,0x00,0x05,0xff,0x10,
	0x3f,0xf3,0x02,0xff,0x50,0x05,0xff,0x20,0x3f,0xf3,0x01,0xff,0x50,
	0x00,0x09,0xfc,0x00,0x00,0x00,0x00,0x00,0x04,0xff,0x40,0x00,0x00,
	0x00,0xcf,0xb0,0x00,0x0a,0xfb,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x36,0x20,0x08,0xfd,0x00,0x00,0x0b,0xfa,0x01,0xff,0x80,0x03,0xff,
	0x50,0x00,0x00,0x4f,0xf4,0x00,0x3f,0xf5,0x01,0x10,0x0c,0xff,0xd7,
	0x9f,0xfa,0x00,0x00,0x00,0x02,0xef,0xd7,0xbf,0xf7,0x00,0x00,0x00,
	0x02,0x77,0xaf,0xf9,0x77,0x10,0x00,0x00,0x00,0xaf,0xc0,0x02,0xff,
	0x50,0x00,0x07,0xff,0x9a,0xff,0xff,0x9b,0xff,0x50,0x00,0x00,0x6f,
	0xf7,0x8f,0xf3,0x00,0x00,0x00,0x0c,0xfa,0x00,0x0c,0xfa,0x00,0x00,
	0x00,0x08,0xff,0x10,0x0a,0xfc,0x00,0x00,0x05,0xff,0x10,0x3f,0xf3,
	0x02,0xff,0x50,0x05,0xff,0x20,0x3f,0xf3,0x01,0xff,0x50,0x04,0x7c,
	0xfd,0x00,0x00,0x00,0x00,0x00,0x04,0xff,0x50,0x00,0x00,0x00,0xcf,
	0xb0,0x00,0x0a,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xff,0xd7,
	0x9f,0xf7,0x00,0x00,0x0b,0xfb,0x00,0x9f,0xf9,0x8d,0xfd,0x10,0x00,
	0x00,0x2f,0xf9,0x11,0x4f,0xf5,0x01,0x10,0x0c,0xfc,0xcf,0xff,0xa1,
	0x00,0x00,0x00,0x00,0x4d,0xff,0xff,0x90,0x00,0x00,0x00,0x05,0xff,
	0xff,0xff,0xff,0x30,0x00,0x00,0x03,0xff,0x70,0x00,0xaf,0xc0,0x00,
	0x01,0xaf,0xff,0xbf,0xfb,0xff,0xf9,0x00,0x00,0x03,0xff,0xc0,0x1e,
	0xfd,0x10,0x00,0x00,0x0c,0xfb,0x00,0x0c,0xfb,0x00,0x00,0x00,0x08,
	0xff,0x10,0x0b,0xfc,0x00,0x00,0x05,0xff,0x10,0x4f,0xf4,0x02,0xff,
	0x50,0x05,0xff,0x20,0x4f,0xf4,0x01,0xff,0x50,0x09,0xff,0xfd,0x00,
	0x00,0x00,0x00,0x00,0x04,0xff,0x50,0x00,0x00,0x00,0xcf,0xb0,0x00,
	0x0b,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6f,0xff,0xff,0x90,
	0x00,0x00,0x0b,0xfb,0x00,0x1a,0xff,0xff,0xc2,0x00,0x00,0x00,0x09,
	0xff,0xff,0xff,0xf5,0x01,0x10,0x05,0x73,0x16,0x75,0x00,0x00,0x00,
	0x00,0x00,0x01,0x67,0x73,0x00,0x00,0x00,0x00,0x02,0x77,0x77,0x77,
	0x77,0x10,0x00,0x00,0x03,0x87,0x20,0x00,0x37,0x71,0x00,0x00,0x05,
	0x73,0x5f,0xe2,0x47,0x50,0x00,0x00,0x04,0x87,0x30,0x04,0x78,0x20,
	0x00,0x00,0x06,0x75,0x00,0x06,0x75,0x00,0x00,0x00,0x04,0x77,0x10,
	0x05,0x76,0x00,0x00,0x02,0x77,0x10,0x27,0x72,0x01,0x77,0x20,0x02,
	0x77,0x10,0x27,0x72,0x01,0x77,0x20,0x04,0x77,0x76,0x00,0x00,0x00,
	0x00,0x00,0x02,0x77,0x20,0x00,0x00,0x00,0x67,0x50,0x00,0x05,0x76,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x67,0x73,0x00,0x00,0x00,
	0x05,0x75,0x00,0x00,0x47,0x75,0x10,0x00,0x00,0x00,0x00,0x48,0x88,
	0x87,0x72,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x76,0x00,0x00,0x00,0x17,0x71,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x27,0x74,0x04,0x76,0x00,
	0x00,0x00,0x00,0x00,0x47,0x74,0x00,0x00,0x00,0x00,0x02,0x77,0x88,
	0x88,0x72,0x00,0x00,0x00,0x00,0x27,0x72,0x00,0x00,0x00,0x00,0x02,
	0xff,0x00,0x00,0x00,0x0f,0xf1,0x00,0x00,0x00,0x00,0x47,0x75,0x10,
	0x00,0x00,0x03,0x87,0x20,0x37,0x71,0x04,0x77,0x10,0x00,0x00,0x00,
	0x47,0x86,0x20,0x00,0x00,0x00,0x02,0x77,0x20,0x01,0x77,0x20,0x00,
	0x00,0x03,0x77,0x10,0x02,0x77,0x20,0x00,0x00,0x02,0x77,0x20,0x37,
	0x83,0x00,0x00,0x00,0x27,0x75,0x00,0x00,0x57,0x50,0x00,0x00,0x27,
	0x70,0x06,0x72,0x04,0x75,0x00,0x00,0x02,0x77,0x20,0x02,0x77,0x20,
	0x00,0x00,0x00,0x00,0x47,0x74,0x00,0x00,0x00,0x00,0x00,0x67,0x50,
	0x01,0x77,0x40,0x01,0x10,0x04,0xef,0xff,0xbc,0xf9,0x00,0x00,0x00,
	0x00,0x2c,0xff,0xff,0xc2,0x00,0x00,0x00,0x04,0xff,0xff,0xff,0xfe,
	0x40,0x00,0x00,0x00,0x5f,0xf4,0x00,0x00,0x00,0x00,0x02,0xfe,0x55,
	0x55,0x55,0x5f,0xf1,0x00,0x00,0x00,0x2c,0xff,0xff,0xd3,0x00,0x00,
	0x02,0xff,0x90,0x6f,0xf3,0x0d,0xfc,0x10,0x00,0x00,0x2b,0xff,0xff,
	0xf6,0x00,0x00,0x00,0x05,0xff,0xa0,0x02,0xff,0x50,0x00,0x00,0x07,
	0xff,0x90,0x04,0xff,0x40,0x00,0x00,0x05,0xff,0x40,0xaf,0xf2,0x00,
	0x00,0x00,0x5f,0xff,0x70,0x00,0xbf,0xb0,0x00,0x00,0x4f,0xf0,0x3f,
	0xf9,0x08,0xfa,0x00,0x00,0x05,0xff,0x40,0x05,0xff,0x40,0x00,0x00,
	0x00,0x3c,0xff,0xff,0xc2,0x00,0x00,0x00,0x00,0xcf,0xb0,0x02,0xff,
	0x80,0x01,0x10,0x0c,0xff,0x99,0xff,0xf6,0x00,0x00,0x00,0x01,0xcf,
	0xf9,0x8e,0xfd,0x10,0x00,0x00,0x03,0xff,0x51,0x13,0xdf,0xb0,0x00,
	0x00,0x00,0x5f,0xf3,0x00,0x00,0x00,0x00,0x02,0xff,0xff,0xff,0xff,
	0xff,0xf1,0x00,0x00,0x00,0xbf,0xf9,0x8f,0xfc,0x10,0x00,0x00,0x7f,
	0xf1,0x5f,0xf2,0x4f,0xf4,0x00,0x00,0x00,0x9f,0xf4,0x1a,0xff,0x20,
	0x00,0x00,0x05,0xff,0xf5,0x02,0xff,0x50,0x00,0x00,0x06,0xff,0xf3,
	0x03,0xff,0x30,0x00,0x00,0x05,0xff,0x31,0xef,0x60,0x00,0x00,0x00,
	0x27,0xdf,0xc0,0x00,0xbf,0xb0,0x00,0x00,0x3f,0xf0,0x7f,0xfe,0x07,
	0xf9,0x00,0x00,0x05,0xff,0x30,0x05,0xff,0x30,0x00,0x00,0x01,0xdf,
	0xf8,0x8e,0xfd,0x10,0x00,0x00,0x00,0xcf,0xa0,0x02,0xff,0x70,0x01,
	0x10,0x1e,0xf9,0x00,0x6f,0xf6,0x00,0x00,0x00,0x05,0xff,0x60,0x04,
	0xff,0x70,0x00,0x00,0x03,0xff,0x40,0x00,0xaf,0xc0,0x00,0x00,0x00,
	0x5f,0xf3,0x00,0x00,0x00,0x00,0x01,0x7e,0xfc,0x77,0x7b,0xff,0x70,
	0x00,0x00,0x03,0xff,0x70,0x04,0x52,0x00,0x00,0x00,0x1e,0xf7,0x4f,
	0xf2,0xaf,0xb0,0x00,0x00,0x00,0x25,0x40,0x03,0xff,0x40,0x00,0x00,
	0x05,0xff,0xfd,0x12,0xff,0x50,0x00,0x00,0x06,0xff,0xfb,0x03,0xff,
	0x30,0x00,0x00,0x05,0xff,0x25,0xfd,0x10,0x00,0x00,0x00,0x00,0x8f,
	0xd1,0x00,0xbf,0xb0,0x00,0x00,0x3f,0xf1,0xcf,0xef,0x37,0xf9,0x00,
	0x00,0x05,0xff,0x30,0x05,0xff,0x30,0x00,0x00,0x07,0xff,0x40,0x03,
	0xff,0x70,0x00,0x00,0x00,0xcf,0xa0,0x02,0xff,0x70,0x01,0x10,0x0a,
	0xfd,0x30,0x3f,0xf6,0x00,0x00,0x00,0x08,0xfd,0x00,0x00,0xbf,0xb0,
	0x00,0x00,0x03,0xff,0x51,0x14,0xdf,0x80,0x00,0x00,0x00,0x5f,0xf3,
	0x00,0x00,0x00,0x00,0x00,0x06,0xfd,0x00,0x06,0xfe,0x00,0x00,0x00,
	0x06,0xff,0x31,0x10,0x01,0x00,0x00,0x00,0x04,0xee,0xbf,0xfb,0xfd,
	0x20,0x00,0x00,0x00,0x00,0x00,0x19,0xfe,0x20,0x00,0x00,0x05,0xff,
	0xdf,0x71,0xff,0x50,0x00,0x00,0x06,0xff,0xdf,0x53,0xff,0x30,0x00,
	0x00,0x05,0xff,0x5c,0xf6,0x00,0x00,0x00,0x00,0x00,0x8f,0xe1,0x00,
	0xbf,0xb0,0x00,0x00,0x3f,0xe4,0xfc,0x7f,0x87,0xf9,0x00,0x00,0x05,
	0xff,0x41,0x15,0xff,0x30,0x00,0x00,0x0a,0xfc,0x00,0x00,0xbf,0xb0,
	0x00,0x00,0x00,0xcf,0xa0,0x02,0xff,0x70,0x01,0x10,0x02,0xbf,0xfd,
	0xbf,0xf6,0x00,0x00,0x00,0x0a,0xfb,0x00,0x00,0xaf,0xc0,0x00,0x00,
	0x03,0xff,0xff,0xff,0xf9,0x10,0x00,0x00,0x00,0x5f,0xf3,0x00,0x00,
	0x00,0x00,0x00,0x01,0xef,0x40,0x06,0xff,0x10,0x00,0x00,0x07,0xff,
	0xff,0xff,0xfe,0x40,0x00,0x00,0x00,0x8f,0xff,0xff,0xf5,0x00,0x00,
	0x00,0x00,0x00,0x03,0xff,0xc3,0x00,0x00,0x00,0x05,0xff,0x5e,0xe4,
	0xef,0x50,0x00,0x00,0x07,0xfe,0x5f,0xd4,0xff,0x30,0x00,0x00,0x05,
	0xff,0xff,0x90,0x00,0x00,0x00,0x00,0x00,0x8f,0xd1,0x00,0xbf,0xb0,
	0x00,0x00,0x3f,0xe8,0xf8,0x2f,0xd9,0xf9,0x00,0x00,0x05,0xff,0xff,
	0xff,0xff,0x30,0x00,0x00,0x0b,0xfa,0x00,0x00,0xaf,0xc0,0x00,0x00,
	0x00,0xcf,0xa0,0x02,0xff,0x70,0x01,0x10,0x00,0x02,0x69,0xef,0xf6,
	0x00,0x00,0x00,0x0a,0xfd,0x00,0x00,0xbf,0xb0,0x00,0x00,0x03,0xff,
	0xa8,0x8c,0xfc,0x20,0x00,0x00,0x00,0x5f,0xf3,0x00,0x00,0x00,0x00,
	0x00,0x00,0xcf,0x60,0x06,0xfe,0x10,0x00,0x00,0x06,0xff,0x98,0x89,
	0xff,0x40,0x00,0x00,0x02,0xfc,0x7f,0xf5,0xfc,0x00,0x00,0x00,0x00,
	0x00,0x02,0x8e,0xd4,0x00,0x00,0x00,0x05,0xff,0x27,0xfc,0xff,0x50,
	0x00,0x00,0x06,0xfe,0x09,0xfb,0xff,0x30,0x00,0x00,0x05,0xff,0xbf,
	0xb1,0x00,0x00,0x00,0x00,0x00,0x8f,0xd1,0x00,0xbf,0xb0,0x00,0x00,
	0x3f,0xfd,0xf4,0x0b,0xfd,0xf9,0x00,0x00,0x05,0xff,0xff,0xff,0xff,
	0x30,0x00,0x00,0x0a,0xfc,0x00,0x00,0xbf,0xb0,0x00,0x00,0x00,0xcf,
	0xa0,0x02,0xff,0x70,0x01,0x10,0x01,0x45,0x00,0x4f,0xf5,0x00,0x00,
	0x00,0x0a,0xff,0x60,0x04,0xff,0x70,0x00,0x00,0x03,0xff,0x40,0x01,
	0xff,0x70,0x00,0x00,0x00,0x5f,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,
	0xaf,0x80,0x06,0xff,0x10,0x00,0x00,0x03,0xff,0x50,0x06,0xfe,0x10,
	0x00,0x00,0x06,0xf6,0x4f,0xf2,0xaf,0x30,0x00,0x00,0x00,0x00,0x00,
	0x07,0xfc,0x00,0x00,0x00,0x05,0xff,0x21,0xdf,0xff,0x50,0x00,0x00,
	0x06,0xff,0x02,0xef,0xff,0x30,0x00,0x00,0x05,0xff,0x39,0xf4,0x00,
	0x00,0x00,0x00,0x00,0x8f,0xd0,0x00,0xaf,0xb0,0x00,0x00,0x3f,0xff,
	0xd1,0x07,0xff,0xf9,0x00,0x00,0x05,0xff,0x41,0x15,0xff,0x30,0x00,
	0x00,0x06,0xff,0x40,0x03,0xff,0x70,0x00,0x00,0x00,0xcf,0xa0,0x01,
	0xff,0x70,0x01,0x10,0x06,0xff,0x97,0xcf,0xf4,0x00,0x00,0x00,0x0a,
	0xfe,0xf9,0x8e,0xfd,0x10,0x00,0x00,0x03,0xff,0x51,0x15,0xff,0x70,
	0x00,0x00,0x00,0x5f,0xf9,0x77,0x71,0x00,0x00,0x00,0x00,0x9f,0xa4,
	0x49,0xfe,0x10,0x00,0x00,0x00,0xaf,0xe8,0x9f,0xf8,0x00,0x00,0x00,
	0x2c,0xf2,0x5f,0xf2,0x5f,0x91,0x00,0x00,0x00,0x2b,0xc3,0x1b,0xfb,
	0x00,0x00,0x00,0x05,0xff,0x30,0x5f,0xff,0x50,0x00,0x00,0x06,0xff,
	0x10,0x7f,0xff,0x30,0x00,0x00,0x05,0xff,0x33,0xfb,0x10,0x00,0x00,
	0x00,0x00,0x8f,0xe8,0x77,0xdf,0xb0,0x00,0x00,0x3f,0xff,0x90,0x02,
	0xff,0xf9,0x00,0x00,0x05,0xff,0x30,0x05,0xff,0x30,0x00,0x00,0x01,
	0xdf,0xf9,0x8e,0xfd,0x10,0x00,0x00,0x00,0xcf,0xd7,0x78,0xff,0x70,
	0x01,0x10,0x01,0xaf,0xff,0xff,0x90,0x00,0x00,0x00,0x08,0xf6,0xdf,
	0xff,0xc2,0x00,0x00,0x00,0x04,0xff,0xff,0xff,0xfd,0x20,0x00,0x00,
	0x00,0x5f,0xff,0xff,0xf1,0x00,0x00,0x00,0x00,0x9f,0xff,0xff,0xff,
	0x10,0x00,0x00,0x00,0x1b,0xff,0xff,0xa1,0x00,0x00,0x03,0xff,0xa0,
	0x6f,0xf3,0x1d,0xff,0x10,0x00,0x00,0x1b,0xff,0xff,0xe4,0x00,0x00,
	0x00,0x05,0xff,0x30,0x0b,0xff,0x50,0x00,0x00,0x07,0xff,0x10,0x0d,
	0xff,0x40,0x00,0x00,0x05,0xff,0x40,0xbf,0xf3,0x00,0x00,0x00,0x00,
	0x9f,0xff,0xff,0xff,0xb0,0x00,0x00,0x4f,0xff,0x40,0x00,0xcf,0xfa,
	0x00,0x00,0x05,0xff,0x40,0x05,0xff,0x40,0x00,0x00,0x00,0x2c,0xff,
	0xff,0xc2,0x00,0x00,0x00,0x00,0xcf,0xff,0xff,0xff,0x80,0x01,0x10,
	0x00,0x04,0x77,0x74,0x00,0x00,0x00,0x00,0x04,0xf8,0x15,0x64,0x00,
	0x00,0x00,0x00,0x02,0x77,0x88,0x88,0x61,0x00,0x00,0x00,0x00,0x27,
	0x77,0x77,0x71,0x00,0x00,0x00,0x00,0x47,0x77,0x77,0x77,0x10,0x00,
	0x00,0x00,0x00,0x57,0x74,0x00,0x00,0x00,0x02,0x86,0x10,0x37,0x71,
	0x02,0x77,0x10,0x00,0x00,0x00,0x37,0x86,0x20,0x00,0x00,0x00,0x02,
	0x77,0x10,0x02,0x77,0x20,0x00,0x00,0x03,0x77,0x38,0x53,0x77,0x20,
	0x00,0x00,0x02,0x77,0x20,0x17,0x81,0x00,0x00,0x00,0x00,0x47,0x77,
	0x77,0x77,0x50,0x00,0x00,0x27,0x77,0x10,0x00,0x47,0x75,0x00,0x00,
	0x02,0x77,0x20,0x02,0x77,0x20,0x00,0x00,0x00,0x00,0x47,0x74,0x00,
	0x00,0x00,0x00,0x00,0x67,0x77,0x77,0x77,0x40,0x01,0x10,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0xc7,0x67,0x73,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc9,0xd4,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x2c,0xff,0xff,0xff,0x30,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x50,0x34,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x37,0x77,0xaf,0x60,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x77,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x03,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x10,0x05,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0x77,
	0x51,0x00,0x00,0x00,0x00,0x00,0x37,0x71,0x00,0x00,0x00,0x00,0x00,
	0x57,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0x73,0x00,0x00,
	0x00,0x00,0x68,0x72,0x00,0x00,0x37,0x85,0x00,0x00,0x17,0x77,0x77,
	0x77,0x78,0xff,0x30,0x00,0x00,0x00,0x00,0x00,0x67,0x50,0x00,0x03,
	0x77,0x77,0x77,0x77,0x77,0x77,0x40,0x02,0x77,0x77,0x77,0x77,0x77,
	0x7b,0xf6,0x00,0x06,0x77,0x77,0x77,0x73,0x00,0x00,0x04,0x77,0x77,
	0x76,0x30,0x00,0x67,0x40,0x00,0x17,0x77,0x77,0x77,0x62,0x00,0x00,
	0x00,0x00,0x03,0x77,0x74,0x10,0x00,0x00,0x17,0x73,0x00,0x00,0x37,
	0x73,0x00,0x00,0x00,0x67,0x72,0x00,0x00,0x06,0x74,0x01,0x10,0x0b,
	0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0xff,0xff,0xfe,0x60,
	0x00,0x00,0x00,0x00,0x6f,0xf3,0x00,0x00,0x00,0x00,0x00,0xcf,0xfd,
	0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xf8,0x10,0x00,0x00,0x00,
	0x6f,0xfb,0x00,0x00,0xcf,0xf5,0x00,0x00,0x3f,0xff,0xff,0xff,0xff,
	0xff,0x30,0x00,0x00,0x00,0x00,0x00,0xcf,0xb0,0x00,0x05,0xff,0xff,
	0xff,0xff,0xff,0xff,0x80,0x05,0xff,0xff,0xff,0xff,0xff,0xff,0xf6,
	0x00,0x0d,0xff,0xff,0xff,0xff,0x80,0x00,0x09,0xff,0xff,0xff,0xf7,
	0x00,0xdf,0x80,0x00,0x2f,0xff,0xff,0xff,0xff,0x60,0x00,0x00,0x02,
	0xbf,0xff,0xff,0xc3,0x00,0x00,0x2f,0xf7,0x00,0x19,0xff,0xff,0xb2,
	0x00,0x00,0x7f,0xfb,0x00,0x00,0x1e,0xf9,0x01,0x10,0x0a,0xfc,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0xbf,0xfb,0x79,0xff,0xf5,0x00,0x00,
	0x00,0x00,0x6f,0xf3,0x00,0x00,0x00,0x00,0x00,0x57,0xdf,0xa0,0x00,
	0x00,0x00,0x00,0x04,0x9d,0xff,0xff,0xea,0x60,0x00,0x00,0x0a,0xff,
	0x60,0x07,0xff,0x90,0x00,0x00,0x3f,0xfa,0x77,0x77,0xbf,0xf8,0x10,
	0x00,0x00,0x00,0x00,0x00,0xcf,0xa0,0x00,0x05,0xfd,0x77,0x9f,0xf8,
	0x77,0xdf,0x60,0x05,0xfd,0x77,0x9f,0xf8,0x77,0xdf,0xb3,0x00,0x0c,
	0xfc,0x77,0x78,0xef,0xf5,0x00,0x08,0xfe,0x87,0x9f,0xff,0x30,0xdf,
	0x70,0x00,0x2f,0xfb,0x77,0x79,0xff,0xf3,0x00,0x00,0x2d,0xff,0xb7,
	0x9f,0xfe,0x30,0x00,0x2f,0xf6,0x00,0x9f,0xfb,0xaf,0xfd,0x10,0x00,
	0x0b,0xff,0x60,0x00,0x1d,0xf8,0x01,0x10,0x0a,0xfc,0x00,0x00,0x00,
	0x00,0x00,0x00,0x07,0xff,0x70,0x00,0x3f,0xfd,0x10,0x00,0x00,0x00,
	0x6f,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x2e,0xf3,0x00,0x00,0x00,
	0x00,0x6f,0xff,0xff,0xff,0xff,0xfb,0x10,0x00,0x02,0xef,0xe1,0x2f,
	0xfe,0x10,0x00,0x00,0x3f,0xf5,0x00,0x00,0x6f,0xf1,0x00,0x00,0x00,
	0x00,0x00,0x00,0xcf,0xa0,0x00,0x05,0xfb,0x00,0x2f,0xe1,0x00,0xaf,
	0x50,0x05,0xfb,0x00,0x2f,0xe1,0x00,0xaf,0x60,0x00,0x0d,0xf9,0x00,
	0x00,0x3f,0xfb,0x00,0x09,0xfd,0x00,0x05,0xff,0x80,0xcf,0x70,0x00,
	0x2f,0xf6,0x00,0x00,0x5f,0xf8,0x00,0x00,0x8f,0xf7,0x00,0x04,0xff,
	0xc0,0x00,0x2f,0xf7,0x04,0xff,0x80,0x06,0xff,0x80,0x00,0x03,0xff,
	0xe2,0x00,0x1d,0xf9,0x01,0x10,0x0a,0xfb,0x00,0x00,0x00,0x00,0x00,
	0x00,0x1d,0xfc,0x00,0x00,0x08,0xa4,0x00,0x00,0x00,0x00,0x6f,0xf3,
	0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0xf9,0x00,0x00,0x00,0x03,0xff,
	0xc3,0x3f,0xf7,0x28,0xff,0x70,0x00,0x00,0x6f,0xfa,0xaf,0xf5,0x00,
	0x00,0x00,0x3f,0xf6,0x00,0x00,0x6f,0xf2,0x00,0x00,0x00,0x00,0x11,
	0x00,0xbf,0xa0,0x00,0x05,0xfb,0x00,0x2f,0xe2,0x00,0xaf,0x60,0x05,
	0xfb,0x00,0x2f,0xe2,0x00,0xaf,0x60,0x00,0x0d,0xf9,0x00,0x00,0x0c,
	0xfc,0x00,0x08,0xfd,0x10,0x01,0xff,0x90,0xcf,0x70,0x00,0x2f,0xf7,
	0x00,0x00,0x1f,0xf9,0x00,0x00,0x27,0xb1,0x00,0x00,0x8f,0xf3,0x00,
	0x2f,0xf6,0x0a,0xfd,0x10,0x00,0xcf,0xd1,0x00,0x00,0x7f,0xfb,0x00,
	0x1d,0xf9,0x01,0x10,0x0a,0xfe,0x87,0x77,0x40,0x00,0x00,0x00,0x3f,
	0xf9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6f,0xf3,0x00,0x00,
	0x00,0x00,0x00,0x00,0x6f,0xfe,0x20,0x00,0x00,0x08,0xff,0x20,0x2f,
	0xf6,0x00,0xaf,0xd1,0x00,0x00,0x0b,0xff,0xff,0xa0,0x00,0x00,0x00,
	0x3f,0xf6,0x00,0x00,0x7f,0xf2,0x00,0x00,0x00,0x6b,0xff,0xd9,0xdf,
	0xa0,0x00,0x05,0xfb,0x00,0x2f,0xe2,0x00,0xaf,0x60,0x05,0xfb,0x00,
	0x2f,0xe2,0x00,0xaf,0x60,0x00,0x0d,0xf9,0x00,0x00,0x3f,0xfa,0x00,
	0x09,0xfd,0x00,0x05,0xff,0x80,0xdf,0x70,0x00,0x2f,0xf6,0x00,0x00,
	0x5f,0xf7,0x00,0x00,0x00,0x00,0x01,0x11,0x5f,0xf6,0x00,0x2f,0xf7,
	0x1d,0xf9,0x00,0x00,0x8f,0xf3,0x00,0x00,0x08,0xff,0x92,0x1e,0xf8,
	0x01,0x10,0x0a,0xff,0xff,0xff,0xfc,0x20,0x00,0x00,0x3f,0xf7,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6f,0xf3,0x00,0x00,0x00,0x00,
	0x00,0x01,0xdf,0xff,0x70,0x00,0x00,0x0b,0xfc,0x00,0x2f,0xf6,0x00,
	0x7f,0xf2,0x00,0x00,0x02,0xef,0xfe,0x20,0x00,0x00,0x00,0x3f,0xf6,
	0x00,0x00,0x7f,0xf2,0x00,0x00,0x09,0xff,0xff,0xff,0xff,0xa0,0x00,
	0x05,0xfb,0x00,0x2f,0xe2,0x00,0xaf,0x60,0x05,0xfb,0x00,0x2f,0xe2,
	0x00,0xaf,0x60,0x00,0x0c,0xfc,0x77,0x79,0xef,0xf5,0x00,0x08,0xff,
	0x87,0x9f,0xff,0x20,0xdf,0x70,0x00,0x2f,0xfb,0x77,0x79,0xff,0xf2,
	0x00,0x00,0x00,0x00,0x4f,0xff,0xff,0xf8,0x00,0x2f,0xff,0xff,0xf8,
	0x00,0x00,0x6f,0xf4,0x00,0x00,0x17,0xef,0xff,0xff,0xf9,0x01,0x10,
	0x0a,0xfe,0x87,0x7c,0xff,0xb0,0x00,0x00,0x3f,0xf7,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x6f,0xf3,0x00,0x00,0x00,0x00,0x00,0x07,
	0xfd,0x7f,0xe1,0x00,0x00,0x0b,0xfc,0x00,0x2f,0xf6,0x00,0x7f,0xf2,
	0x00,0x00,0x00,0xbf,0xfa,0x00,0x00,0x00,0x00,0x3f,0xf6,0x00,0x00,
	0x6f,0xf2,0x00,0x00,0x3f,0xfb,0x21,0x16,0xef,0xa0,0x00,0x05,0xfb,
	0x00,0x2f,0xe2,0x00,0xaf,0x60,0x05,0xfb,0x00,0x2f,0xe2,0x00,0xaf,
	0x60,0x00,0x0d,0xff,0xff,0xff,0xff,0x70,0x00,0x08,0xff,0xff,0xff,
	0xe5,0x00,0xdf,0x70,0x00,0x2f,0xff,0xff,0xff,0xfe,0x50,0x00,0x00,
	0x00,0x00,0x4f,0xff,0xff,0xf8,0x00,0x2f,0xff,0xff,0xf7,0x00,0x00,
	0x6f,0xf4,0x00,0x02,0xdf,0xff,0xef,0xff,0xf9,0x01,0x10,0x0a,0xfb,
	0x00,0x00,0xbf,0xf2,0x00,0x00,0x2f,0xf8,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x6f,0xf3,0x00,0x00,0x00,0x00,0x00,0x1e,0xf8,0x1e,
	0xf6,0x00,0x00,0x08,0xff,0x20,0x2f,0xf6,0x00,0xaf,0xd1,0x00,0x00,
	0x04,0xff,0xff,0x40,0x00,0x00,0x00,0x3f,0xf6,0x00,0x00,0x7f,0xf2,
	0x00,0x00,0x5f,0xf3,0x00,0x00,0xbf,0xa0,0x00,0x05,0xfb,0x00,0x2f,
	0xe2,0x00,0xaf,0x60,0x05,0xfb,0x00,0x2f,0xe2,0x00,0xaf,0x60,0x00,
	0x0c,0xfc,0x77,0x77,0x62,0x00,0x00,0x09,0xfe,0x87,0x75,0x20,0x00,
	0xdf,0x70,0x00,0x2f,0xfb,0x77,0x77,0x51,0x00,0x00,0x00,0x00,0x00,
	0x01,0x11,0x5f,0xf6,0x00,0x2f,0xf7,0x1d,0xf9,0x00,0x00,0x8f,0xf3,
	0x00,0x0a,0xff,0x61,0x11,0x2e,0xf8,0x01,0x10,0x0a,0xfc,0x00,0x00,
	0x7f,0xf4,0x00,0x00,0x0c,0xfc,0x00,0x00,0x04,0x52,0x00,0x00,0x00,
	0x00,0x6f,0xf3,0x00,0x00,0x00,0x00,0x00,0x7f,0xf2,0x08,0xfd,0x10,
	0x00,0x03,0xff,0xc3,0x3f,0xf7,0x28,0xff,0x70,0x00,0x00,0x1d,0xff,
	0xff,0xc1,0x00,0x00,0x00,0x3f,0xf6,0x00,0x00,0x6f,0xf2,0x00,0x00,
	0x6f,0xf3,0x00,0x00,0xcf,0xa0,0x00,0x05,0xfb,0x00,0x2f,0xe2,0x00,
	0xaf,0x60,0x05,0xfb,0x00,0x2f,0xe2,0x00,0xaf,0x60,0x00,0x0d,0xf9,
	0x00,0x00,0x00,0x00,0x00,0x08,0xfd,0x00,0x00,0x00,0x00,0xdf,0x70,
	0x00,0x2f,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x60,0x00,0x00,
	0x8f,0xf3,0x00,0x2f,0xf6,0x0a,0xfd,0x00,0x00,0xcf,0xd1,0x00,0x1d,
	0xfb,0x00,0x00,0x0d,0xf9,0x01,0x10,0x0a,0xfb,0x00,0x00,0xbf,0xf3,
	0x00,0x00,0x06,0xff,0x70,0x00,0x2e,0xfc,0x00,0x00,0x00,0x00,0x5f,
	0xf2,0x00,0x00,0x00,0x00,0x02,0xef,0x90,0x03,0xff,0x50,0x00,0x00,
	0x6f,0xff,0xff,0xff,0xff,0xfb,0x10,0x00,0x00,0x8f,0xf7,0x7f,0xf7,
	0x00,0x00,0x00,0x3f,0xf6,0x00,0x00,0x7f,0xf2,0x00,0x00,0x6f,0xf3,
	0x00,0x00,0xcf,0xa0,0x00,0x05,0xfb,0x00,0x2f,0xe2,0x00,0xaf,0x60,
	0x05,0xfb,0x00,0x2f,0xe2,0x00,0xaf,0x60,0x00,0x0c,0xf9,0x00,0x00,
	0x00,0x00,0x00,0x08,0xfd,0x10,0x00,0x00,0x00,0xcf,0x70,0x00,0x2f,
	0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xf7,0x00,0x04,0xff,0xb0,
	0x00,0x2f,0xf6,0x04,0xff,0x70,0x07,0xff,0x80,0x00,0x1d,0xfd,0x10,
	0x00,0x0d,0xf8,0x01,0x10,0x0a,0xfe,0x87,0x7b,0xff,0xc0,0x00,0x00,
	0x01,0xbf,0xfb,0x79,0xef,0xf5,0x00,0x00,0x27,0x77,0xaf,0xf9,0x77,
	0x60,0x00,0x00,0x08,0xff,0x30,0x00,0xbf,0xc0,0x00,0x00,0x03,0x9d,
	0xff,0xff,0xea,0x60,0x00,0x00,0x03,0xff,0xc0,0x1d,0xff,0x30,0x00,
	0x00,0x3f,0xf6,0x00,0x00,0x6f,0xf2,0x00,0x00,0x6f,0xf3,0x00,0x00,
	0xcf,0xa0,0x00,0x05,0xfb,0x00,0x2f,0xe2,0x00,0xaf,0x60,0x05,0xfb,
	0x00,0x2f,0xe2,0x00,0xaf,0x60,0x04,0x8e,0xf9,0x00,0x00,0x00,0x00,
	0x00,0x08,0xfd,0x10,0x00,0x00,0x00,0xcf,0x70,0x00,0x2f,0xf6,0x00,
	0x00,0x00,0x00,0x00,0x00,0x2d,0xff,0xa7,0x9f,0xfe,0x20,0x00,0x2f,
	0xf7,0x00,0x9f,0xfb,0xbf,0xfd,0x10,0x00,0x08,0xff,0xb7,0x77,0x8e,
	0xf8,0x01,0x10,0x0b,0xff,0xff,0xff,0xfd,0x20,0x00,0x00,0x00,0x19,
	0xff,0xff,0xfd,0x50,0x00,0x00,0x4f,0xff,0xff,0xff,0xff,0xf1,0x00,
	0x00,0x3f,0xfa,0x00,0x00,0x5f,0xf5,0x00,0x00,0x00,0x01,0x3f,0xf8,
	0x10,0x00,0x00,0x00,0x1d,0xff,0x30,0x04,0xff,0xd1,0x00,0x00,0x3f,
	0xf6,0x00,0x00,0x7f,0xf2,0x00,0x00,0x6f,0xf3,0x00,0x00,0xcf,0xb0,
	0x00,0x05,0xfc,0x00,0x3f,0xf2,0x00,0xbf,0x60,0x05,0xfc,0x00,0x3f,
	0xf2,0x00,0xbf,0x70,0x09,0xff,0xfa,0x00,0x00,0x00,0x00,0x00,0x09,
	0xff,0x10,0x00,0x00,0x00,0xdf,0x80,0x00,0x2f,0xf7,0x00,0x00,0x00,
	0x00,0x00,0x00,0x02,0xbf,0xff,0xff,0xc3,0x00,0x00,0x2f,0xf7,0x00,
	0x19,0xff,0xff,0xb2,0x00,0x00,0x01,0xbf,0xff,0xff,0xff,0xf9,0x01,
	0x10,0x05,0x77,0x77,0x77,0x51,0x00,0x00,0x00,0x00,0x00,0x26,0x77,
	0x51,0x00,0x00,0x00,0x27,0x77,0x77,0x77,0x77,0x60,0x00,0x00,0x38,
	0x72,0x00,0x00,0x17,0x74,0x00,0x00,0x00,0x00,0x17,0x73,0x00,0x00,
	0x00,0x00,0x28,0x75,0x00,0x00,0x57,0x82,0x00,0x00,0x17,0x73,0x00,
	0x00,0x37,0x71,0x00,0x00,0x37,0x71,0x00,0x00,0x67,0x50,0x00,0x03,
	0x75,0x00,0x17,0x71,0x00,0x57,0x30,0x03,0x75,0x00,0x17,0x71,0x00,
	0x57,0x30,0x04,0x77,0x75,0x00,0x00,0x00,0x00,0x00,0x04,0x76,0x00,
	0x00,0x00,0x00,0x67,0x40,0x00,0x17,0x73,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x03,0x77,0x74,0x00,0x00,0x00,0x17,0x73,0x00,0x00,0x37,
	0x73,0x00,0x00,0x00,0x00,0x04,0x77,0x77,0x77,0x74,0x01,0x10,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x04,0x74,0x00,0x00,0x00,0x02,0x76,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x13,0x87,0x20,0x00,0x00,0x04,
	0x78,0x20,0x00,0x17,0x77,0x77,0x77,0x62,0x00,0x00,0x00,0x27,0x77,
	0x77,0x77,0x62,0x00,0x00,0x00,0x01,0x77,0x40,0x00,0x00,0x00,0x00,
	0x09,0xf9,0x00,0x00,0x00,0x04,0xfe,0x00,0x00,0x05,0x77,0x77,0x77,
	0x77,0x71,0x00,0x28,0x74,0x00,0x27,0x71,0x00,0x67,0x70,0x00,0x00,
	0x03,0x77,0x75,0x20,0x00,0x00,0x00,0x27,0x74,0x00,0x00,0x37,0x71,
	0x00,0x00,0x27,0x73,0x00,0x00,0x37,0x71,0x00,0x00,0x01,0x77,0x30,
	0x00,0x67,0x82,0x00,0x00,0x57,0x73,0x00,0x00,0x27,0x72,0x00,0x02,
	0x77,0x10,0x27,0x72,0x01,0x77,0x30,0x00,0x05,0x76,0x00,0x00,0x17,
	0x74,0x00,0x00,0x00,0x02,0x67,0x76,0x20,0x00,0x00,0x00,0x17,0x73,
	0x00,0x00,0x37,0x71,0x01,0x03,0xff,0x70,0x00,0x00,0x0c,0xff,0x20,
	0x00,0x2f,0xff,0xff,0xff,0xff,0x60,0x00,0x00,0x4f,0xff,0xff,0xff,
	0xff,0x70,0x00,0x00,0x01,0xff,0x80,0x00,0x00,0x00,0x00,0x08,0xfc,
	0x77,0x77,0x77,0x7a,0xfd,0x00,0x00,0x0b,0xff,0xff,0xff,0xff,0xf3,
	0x00,0x1e,0xfd,0x10,0x5f,0xf2,0x03,0xff,0xa0,0x00,0x02,0xbf,0xff,
	0xff,0xf7,0x00,0x00,0x00,0x4f,0xff,0x20,0x00,0x6f,0xf3,0x00,0x00,
	0x4f,0xfd,0x10,0x00,0x7f,0xf1,0x00,0x00,0x02,0xff,0x60,0x03,0xff,
	0xd1,0x00,0x00,0xcf,0xff,0x40,0x00,0x5f,0xf4,0x00,0x05,0xff,0x30,
	0x6f,0xf7,0x02,0xff,0x60,0x00,0x0b,0xfc,0x00,0x00,0x1f,0xf8,0x00,
	0x00,0x01,0x9f,0xff,0xff,0xf9,0x10,0x00,0x00,0x3f,0xf6,0x00,0x00,
	0x7f,0xf2,0x01,0x10,0xcf,0xc0,0x00,0x00,0x2f,0xf9,0x00,0x00,0x2f,
	0xfb,0x77,0x79,0xff,0xf3,0x00,0x00,0x3f,0xfa,0x77,0x78,0xef,0xf4,
	0x00,0x00,0x01,0xef,0x70,0x00,0x00,0x00,0x00,0x09,0xff,0xff,0xff,
	0xff,0xff,0xfd,0x00,0x00,0x0a,0xfe,0x87,0x77,0x77,0x71,0x00,0x06,
	0xff,0x50,0x4f,0xe2,0x09,0xff,0x30,0x00,0x0a,0xff,0xb7,0x8e,0xff,
	0x50,0x00,0x00,0x3f,0xff,0xa0,0x00,0x6f,0xf3,0x00,0x00,0x4f,0xff,
	0x80,0x00,0x7f,0xf1,0x00,0x00,0x02,0xff,0x60,0x09,0xff,0x50,0x00,
	0x00,0x58,0xff,0x90,0x00,0x5f,0xf4,0x00,0x05,0xff,0x30,0xaf,0xfa,
	0x02,0xff,0x60,0x00,0x0a,0xfc,0x00,0x00,0x1e,0xf7,0x00,0x00,0x1b,
	0xff,0xc8,0x7c,0xff,0xb1,0x00,0x00,0x3f,0xf6,0x00,0x00,0x7f,0xf2,
	0x01,0x10,0x6f,0xf8,0x77,0x77,0xbf,0xf4,0x00,0x00,0x2f,0xf6,0x00,
	0x00,0x5f,0xf8,0x00,0x00,0x3f,0xf4,0x00,0x00,0x3f,0xf9,0x00,0x00,
	0x01,0xef,0x70,0x00,0x00,0x00,0x00,0x04,0xaf,0xfa,0x77,0x77,0xdf,
	0xd6,0x00,0x00,0x0a,0xfb,0x00,0x00,0x00,0x00,0x00,0x01,0xdf,0xc0,
	0x4f,0xe1,0x1e,0xfa,0x00,0x00,0x1b,0xfa,0x00,0x03,0xef,0xa0,0x00,
	0x00,0x3f,0xff,0xf4,0x00,0x6f,0xf3,0x00,0x00,0x4f,0xff,0xf3,0x00,
	0x6f,0xe1,0x00,0x00,0x02,0xff,0x60,0x2f,0xfc,0x00,0x00,0x00,0x00,
	0xbf,0xa0,0x00,0x5f,0xf4,0x00,0x05,0xff,0x30,0xdf,0xfe,0x12,0xff,
	0x60,0x00,0x0a,0xfc,0x00,0x00,0x1e,0xf7,0x00,0x00,0x7f,0xf9,0x10,
	0x00,0x9f,0xf6,0x00,0x00,0x3f,0xf6,0x00,0x00,0x7f,0xf2,0x01,0x10,
	0x2f,0xff,0xff,0xff,0xff,0xd1,0x00,0x00,0x2f,0xf6,0x00,0x00,0x2f,
	0xf9,0x00,0x00,0x3f,0xf5,0x00,0x00,0x0e,0xfa,0x00,0x00,0x01,0xef,
	0x70,0x00,0x00,0x00,0x00,0x00,0x1f,0xf8,0x00,0x00,0xaf,0xa0,0x00,
	0x00,0x0a,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xf3,0x3f,0xe1,
	0x8f,0xf4,0x00,0x00,0x00,0x32,0x00,0x00,0xdf,0xb0,0x00,0x00,0x3f,
	0xff,0xfd,0x10,0x6f,0xf3,0x00,0x00,0x4f,0xff,0xfb,0x00,0x6f,0xe1,
	0x00,0x00,0x02,0xff,0x50,0xaf,0xf5,0x00,0x00,0x00,0x00,0xbf,0xb0,
	0x00,0x5f,0xf4,0x00,0x05,0xff,0x32,0xff,0xff,0x32,0xff,0x60,0x00,
	0x0a,0xfc,0x00,0x00,0x1e,0xf7,0x00,0x00,0xdf,0xd1,0x00,0x00,0x1d,
	0xfd,0x00,0x00,0x3f,0xf6,0x00,0x00,0x6f,0xf2,0x01,0x10,0x0a,0xfe,
	0x87,0x79,0xff,0x90,0x00,0x00,0x2f,0xf6,0x00,0x00,0x5f,0xf8,0x00,
	0x00,0x3f,0xf4,0x00,0x00,0x4f,0xf8,0x00,0x00,0x01,0xef,0x70,0x00,
	0x00,0x00,0x00,0x00,0x0b,0xfb,0x00,0x00,0xbf,0xb0,0x00,0x00,0x0a,
	0xfb,0x00,0x00,0x00,0x00,0x00,0x00,0x1d,0xfb,0x6f,0xe5,0xef,0xa0,
	0x00,0x00,0x00,0x00,0x01,0x28,0xff,0x80,0x00,0x00,0x3f,0xfa,0xff,
	0x70,0x6f,0xf3,0x00,0x00,0x4f,0xfa,0xff,0x60,0x6f,0xe1,0x00,0x00,
	0x02,0xff,0x65,0xff,0xb0,0x00,0x00,0x00,0x00,0xbf,0xb0,0x00,0x5f,
	0xf4,0x00,0x05,0xff,0x35,0xfc,0xbf,0x72,0xff,0x60,0x00,0x0a,0xfb,
	0x00,0x00,0x0e,0xf7,0x00,0x02,0xff,0x90,0x00,0x00,0x09,0xff,0x20,
	0x00,0x3f,0xf6,0x00,0x00,0x7f,0xf2,0x01,0x10,0x05,0xff,0x20,0x06,
	0xff,0x40,0x00,0x00,0x2f,0xfb,0x77,0x79,0xff,0xf2,0x00,0x00,0x3f,
	0xfa,0x77,0x79,0xef,0xd2,0x00,0x00,0x01,0xef,0x70,0x00,0x00,0x00,
	0x00,0x00,0x08,0xfe,0x10,0x00,0xbf,0xb0,0x00,0x00,0x0a,0xfe,0x87,
	0x77,0x77,0x30,0x00,0x00,0x04,0xef,0xff,0xff,0xfc,0x20,0x00,0x00,
	0x00,0x00,0x1e,0xff,0xfb,0x10,0x00,0x00,0x3f,0xf4,0xaf,0xf2,0x5f,
	0xf3,0x00,0x00,0x4f,0xf4,0xcf,0xe1,0x6f,0xe1,0x00,0x00,0x02,0xff,
	0xff,0xfc,0x20,0x00,0x00,0x00,0x00,0xbf,0xb0,0x00,0x5f,0xf4,0x00,
	0x05,0xff,0x38,0xf7,0x6f,0xa3,0xff,0x60,0x00,0x0a,0xfe,0x87,0x77,
	0x8f,0xf7,0x00,0x04,0xff,0x70,0x00,0x00,0x07,0xff,0x40,0x00,0x3f,
	0xf6,0x00,0x00,0x6f,0xf2,0x01,0x10,0x01,0xef,0x70,0x0c,0xfd,0x00,
	0x00,0x00,0x2f,0xff,0xff,0xff,0xfe,0x50,0x00,0x00,0x3f,0xff,0xff,
	0xff,0xfc,0x20,0x00,0x00,0x01,0xff,0x70,0x00,0x00,0x00,0x00,0x00,
	0x06,0xff,0x20,0x00,0xbf,0xb0,0x00,0x00,0x0a,0xff,0xff,0xff,0xff,
	0x60,0x00,0x00,0x01,0xbf,0xff,0xff,0xf7,0x00,0x00,0x00,0x00,0x00,
	0x1e,0xff,0xb0,0x00,0x00,0x00,0x3f,0xf4,0x2f,0xfa,0x5f,0xf3,0x00,
	0x00,0x4f,0xf3,0x3f,0xf8,0x6f,0xf1,0x00,0x00,0x02,0xff,0xff,0xf7,
	0x00,0x00,0x00,0x00,0x00,0xbf,0xb0,0x00,0x5f,0xf4,0x00,0x05,0xff,
	0x5b,0xf3,0x2f,0xd4,0xff,0x60,0x00,0x0a,0xff,0xff,0xff,0xff,0xf7,
	0x00,0x04,0xff,0x70,0x00,0x00,0x07,0xff,0x30,0x00,0x3f,0xf6,0x00,
	0x00,0x6f,0xf2,0x01,0x10,0x00,0x9f,0xc0,0x3f,0xf8,0x00,0x00,0x00,
	0x2f,0xfb,0x77,0x77,0x62,0x00,0x00,0x00,0x3f,0xfa,0x77,0x79,0xfe,
	0x60,0x00,0x00,0x01,0xef,0x70,0x00,0x00,0x00,0x00,0x00,0x05,0xff,
	0x40,0x00,0xbf,0xb0,0x00,0x00,0x0a,0xfe,0x87,0x77,0x77,0x30,0x00,
	0x00,0x06,0xfc,0x6f,0xe5,0xef,0x30,0x00,0x00,0x00,0x00,0x01,0x3c,
	0xf8,0x00,0x00,0x00,0x3f,0xf5,0x08,0xff,0xbf,0xf3,0x00,0x00,0x4f,
	0xf3,0x09,0xfe,0xbf,0xf1,0x00,0x00,0x02,0xff,0x66,0xff,0x30,0x00,
	0x00,0x00,0x00,0xbf,0xb0,0x00,0x5f,0xf4,0x00,0x05,0xff,0x7f,0xe1,
	0x0d,0xf7,0xff,0x60,0x00,0x0a,0xfe,0x87,0x77,0x8f,0xf7,0x00,0x02,
	0xff,0x90,0x00,0x00,0x09,0xff,0x20,0x00,0x3f,0xf6,0x00,0x00,0x6f,
	0xf2,0x01,0x10,0x00,0x4f,0xf2,0x7f,0xf3,0x00,0x00,0x00,0x2f,0xf6,
	0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xf4,0x00,0x00,0x8f,0xe1,0x00,
	0x00,0x01,0xff,0x70,0x00,0x00,0x00,0x00,0x00,0x04,0xff,0x40,0x00,
	0xbf,0xb0,0x00,0x00,0x0a,0xfb,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,
	0xf4,0x3f,0xe1,0x9f,0x80,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0x30,
	0x00,0x00,0x3f,0xf5,0x01,0xdf,0xff,0xf3,0x00,0x00,0x4f,0xf3,0x02,
	0xef,0xff,0xe1,0x00,0x00,0x02,0xff,0x50,0xcf,0x80,0x00,0x00,0x00,
	0x00,0xbf,0xb0,0x00,0x5f,0xf4,0x00,0x05,0xff,0xbf,0xa0,0x09,0xfa,
	0xff,0x60,0x00,0x0a,0xfb,0x00,0x00,0x0e,0xf7,0x00,0x00,0xdf,0xd1,
	0x00,0x00,0x1d,0xfc,0x00,0x00,0x3f,0xf6,0x00,0x00,0x7f,0xf2,0x01,
	0x10,0x00,0x0d,0xf8,0xbf,0xc0,0x00,0x00,0x00,0x2f,0xf6,0x00,0x00,
	0x00,0x00,0x00,0x00,0x3f,0xf4,0x00,0x00,0x7f,0xf2,0x00,0x00,0x01,
	0xff,0x70,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0x40,0x00,0xaf,0xb0,
	0x00,0x00,0x0a,0xfb,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xe1,0x4f,
	0xe1,0x3f,0xd1,0x00,0x00,0x07,0xcb,0x10,0x06,0xff,0x50,0x00,0x00,
	0x3f,0xf5,0x00,0x5f,0xff,0xf3,0x00,0x00,0x4f,0xf3,0x00,0x6f,0xff,
	0xe1,0x00,0x00,0x02,0xff,0x60,0x6f,0xe1,0x00,0x00,0x00,0x00,0xbf,
	0xa0,0x00,0x4f,0xf4,0x00,0x05,0xff,0xff,0x60,0x05,0xfe,0xff,0x60,
	0x00,0x0a,0xfc,0x00,0x00,0x1e,0xf7,0x00,0x00,0x6f,0xf9,0x00,0x00,
	0x8f,0xf6,0x00,0x00,0x3f,0xf5,0x00,0x00,0x6f,0xf2,0x01,0x10,0x00,
	0x08,0xfe,0xff,0x70,0x00,0x00,0x00,0x2f,0xfb,0x77,0x77,0x77,0x40,
	0x00,0x00,0x3f,0xfa,0x77,0x79,0xff,0xc1,0x00,0x00,0x01,0xff,0xb7,
	0x77,0x77,0x50,0x00,0x00,0x03,0xff,0xa7,0x77,0xdf,0xb0,0x00,0x00,
	0x0a,0xfe,0x87,0x77,0x77,0x60,0x00,0x28,0xdf,0x80,0x4f,0xe1,0x0c,
	0xfb,0x60,0x00,0x08,0xff,0xc7,0x9f,0xfe,0x10,0x00,0x00,0x3f,0xf5,
	0x00,0x0a,0xff,0xf3,0x00,0x00,0x4f,0xf3,0x00,0x0c,0xff,0xf1,0x00,
	0x00,0x02,0xff,0x60,0x1e,0xfc,0x72,0x00,0x00,0x00,0xbf,0xd7,0x77,
	0xaf,0xf4,0x00,0x05,0xff,0xff,0x30,0x02,0xff,0xff,0x60,0x00,0x0a,
	0xfc,0x00,0x00,0x1f,0xf7,0x00,0x00,0x1b,0xff,0xc7,0x7c,0xff,0xb1,
	0x00,0x00,0x3f,0xfa,0x77,0x77,0xbf,0xf2,0x01,0x10,0x00,0x03,0xff,
	0xff,0x20,0x00,0x00,0x00,0x2f,0xff,0xff,0xff,0xff,0x90,0x00,0x00,
	0x4f,0xff,0xff,0xff,0xfd,0x30,0x00,0x00,0x01,0xff,0xff,0xff,0xff,
	0xc0,0x00,0x00,0x04,0xff,0xff,0xff,0xff,0xb0,0x00,0x00,0x0b,0xff,
	0xff,0xff,0xff,0xe1,0x00,0x4f,0xfd,0x20,0x5f,0xf2,0x04,0xef,0xf1,
	0x00,0x01,0x9f,0xff,0xff,0xd4,0x00,0x00,0x00,0x4f,0xf5,0x00,0x02,
	0xff,0xf3,0x00,0x00,0x4f,0xf3,0x01,0x13,0xff,0xf1,0x00,0x00,0x02,
	0xff,0x60,0x05,0xff,0xf4,0x00,0x00,0x00,0xbf,0xff,0xff,0xff,0xf4,
	0x00,0x05,0xff,0xfd,0x00,0x00,0xcf,0xff,0x60,0x00,0x0b,0xfc,0x00,
	0x00,0x1f,0xf8,0x00,0x00,0x01,0x9f,0xff,0xff,0xf8,0x10,0x00,0x00,
	0x3f,0xff,0xff,0xff,0xff,0xf2,0x01,0x10,0x00,0x00,0x67,0x76,0x00,
	0x00,0x00,0x00,0x17,0x77,0x77,0x77,0x77,0x40,0x00,0x00,0x27,0x77,
	0x77,0x77,0x51,0x00,0x00,0x00,0x01,0x77,0x77,0x77,0x77,0x50,0x00,
	0x00,0x02,0x77,0x77,0x77,0x77,0x50,0x00,0x00,0x05,0x77,0x77,0x77,
	0x77,0x60,0x00,0x27,0x61,0x00,0x27,0x71,0x00,0x27,0x70,0x00,0x00,
	0x03,0x67,0x75,0x10,0x00,0x00,0x00,0x27,0x72,0x00,0x00,0x57,0x71,
	0x00,0x00,0x27,0x73,0xae,0xd4,0x57,0x71,0x00,0x00,0x01,0x77,0x30,
	0x00,0x36,0x72,0x00,0x00,0x00,0x57,0x77,0x77,0x77,0x72,0x00,0x02,
	0x77,0x75,0x00,0x00,0x47,0x77,0x30,0x00,0x05,0x76,0x00,0x00,0x17,
	0x74,0x00,0x00,0x00,0x02,0x67,0x76,0x20,0x00,0x00,0x00,0x17,0x77,
	0x77,0x77,0x77,0x71,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x06,0xc1,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x04,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x10,0x00,0x00,0x16,0x76,0x10,0x00,0x00,0x00,0x00,0x00,0x03,
	0x77,0x10,0x00,0x00,0x00,0x04,0x77,0x77,0x77,0x77,0x10,0x00,0x00,
	0x00,0x00,0x37,0x76,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x71,
	0x00,0x00,0x00,0x00,0x00,0x47,0x74,0x00,0x00,0x00,0x00,0x00,0x01,
	0x57,0x73,0x00,0x00,0x00,0x00,0x00,0x17,0x73,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x47,0x75,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x73,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0a,0xd2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0x71,0x00,0x00,0x01,0x10,
	0x00,0x03,0xdf,0xff,0xd2,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x20,
	0x00,0x00,0x00,0x06,0xff,0xff,0xff,0xff,0x30,0x00,0x00,0x00,0x07,
	0xff,0xff,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xf2,0x00,0x00,
	0x00,0x00,0x1b,0xff,0xff,0xc2,0x00,0x00,0x00,0x00,0x2c,0xff,0xff,
	0x80,0x00,0x00,0x00,0x00,0x1f,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,
	0x2c,0xff,0xff,0xc2,0x00,0x00,0x00,0x00,0x09,0xff,0xff,0xa1,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xd8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x3f,0xf3,0x00,0x00,0x01,0x10,0x00,0x1d,
	0xfd,0x7d,0xfb,0x00,0x00,0x00,0x00,0x00,0x06,0xff,0x20,0x00,0x00,
	0x00,0x01,0xdf,0xfe,0xee,0xee,0x20,0x00,0x00,0x00,0x6f,0xfc,0x7d,
	0xff,0x30,0x00,0x00,0x01,0x11,0x11,0x7f,0xf3,0x10,0x00,0x00,0x00,
	0x9f,0xf9,0x8f,0xfb,0x00,0x00,0x00,0x00,0xcf,0xf8,0xaf,0xf6,0x00,
	0x00,0x00,0x00,0x0c,0xf8,0x00,0x00,0x00,0x00,0x00,0x01,0xcf,0xf9,
	0x9f,0xfb,0x00,0x00,0x00,0x00,0x6f,0xfa,0x8f,0xfa,0x00,0x00,0x00,
	0x00,0x00,0x27,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0xda,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4a,0x30,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xa4,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x2e,0xe2,0x00,0x00,0x01,0x10,0x00,0x5f,0xf3,0x04,
	0xff,0x30,0x00,0x00,0x00,0x00,0x07,0xff,0x20,0x00,0x00,0x00,0x00,
	0x5f,0xf7,0x11,0x11,0x00,0x00,0x00,0x00,0xcf,0xe1,0x02,0xef,0x90,
	0x00,0x00,0x09,0xef,0xff,0xff,0xff,0x70,0x00,0x00,0x02,0xff,0xa0,
	0x06,0xff,0x40,0x00,0x00,0x04,0xff,0x60,0x0c,0xfb,0x00,0x00,0x00,
	0x00,0x0a,0xfa,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0x70,0x08,0xff,
	0x20,0x00,0x00,0x00,0x6c,0xc0,0x06,0xff,0x30,0x00,0x00,0x00,0x00,
	0x4f,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x0d,0xfa,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x5c,0xff,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x03,0xff,0xc5,0x10,0x00,0x00,0x00,0x00,0x00,
	0x00,0x02,0x20,0x00,0x00,0x01,0x10,0x00,0x8f,0xd0,0x01,0xef,0x60,
	0x00,0x00,0x00,0x00,0x06,0xff,0x20,0x00,0x00,0x00,0x00,0x07,0xff,
	0x60,0x00,0x00,0x00,0x00,0x00,0x36,0x50,0x00,0xcf,0xb0,0x00,0x00,
	0x0a,0xff,0xff,0xff,0xff,0x70,0x00,0x00,0x01,0x47,0x20,0x02,0xff,
	0x60,0x00,0x00,0x08,0xff,0x20,0x09,0xfd,0x10,0x00,0x00,0x00,0x06,
	0xfe,0x10,0x00,0x00,0x00,0x00,0x04,0xff,0x30,0x04,0xff,0x40,0x00,
	0x00,0x00,0x00,0x11,0x11,0xff,0x70,0x00,0x00,0x00,0x00,0x4e,0xf4,
	0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0xfa,0x00,0x00,0x00,0x00,0x00,
	0x02,0x7d,0xff,0xc5,0x00,0x00,0x00,0x02,0x77,0x77,0x77,0x77,0x50,
	0x00,0x00,0x00,0x5c,0xff,0xd7,0x20,0x00,0x00,0x00,0x00,0x00,0x2e,
	0xe2,0x00,0x00,0x01,0x10,0x00,0xaf,0xb0,0x00,0xdf,0x80,0x00,0x00,
	0x00,0x00,0x06,0xff,0x20,0x00,0x00,0x00,0x00,0x00,0x8f,0xf8,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xef,0x90,0x00,0x00,0x05,0xfe,
	0x21,0x7f,0xf3,0x10,0x00,0x00,0x00,0x00,0x00,0x02,0xff,0x60,0x00,
	0x00,0x0a,0xff,0x20,0x0a,0xfd,0x00,0x00,0x00,0x00,0x02,0xff,0x40,
	0x00,0x00,0x00,0x00,0x02,0xff,0x70,0x08,0xff,0x20,0x00,0x00,0x00,
	0x03,0xbf,0xd7,0xef,0x90,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x11,0x00,0x00,0x00,0x00,0x03,0x9e,0xff,
	0xc5,0x00,0x00,0x00,0x00,0x04,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,
	0x00,0x00,0x5c,0xff,0xe9,0x30,0x00,0x00,0x00,0x00,0x1f,0xf7,0x00,
	0x00,0x01,0x10,0x00,0xaf,0xb0,0x00,0xcf,0x90,0x00,0x00,0x00,0x00,
	0x06,0xff,0x20,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x90,0x00,0x00,
	0x00,0x00,0x00,0x05,0x7c,0xfd,0x20,0x00,0x00,0x00,0x9f,0x90,0x6f,
	0xf2,0x00,0x00,0x00,0x00,0x9e,0x92,0x2a,0xff,0x30,0x00,0x00,0x0b,
	0xff,0x91,0x4e,0xfa,0x00,0x00,0x00,0x00,0x00,0xaf,0x90,0x00,0x00,
	0x00,0x00,0x00,0x7f,0xf8,0x9f,0xf7,0x00,0x00,0x00,0x00,0x3e,0xff,
	0xff,0xff,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xff,0xc4,0x00,0x00,
	0x00,0x00,0x00,0x02,0x77,0x77,0x77,0x77,0x50,0x00,0x00,0x00,0x00,
	0x00,0x4b,0xff,0xa0,0x00,0x00,0x00,0x00,0x09,0xff,0x70,0x00,0x01,
	0x10,0x00,0xaf,0xb0,0x00,0xcf,0x90,0x00,0x00,0x00,0x00,0x07,0xff,
	0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xf6,0x00,0x00,0x00,0x00,
	0x00,0x08,0xff,0xc1,0x00,0x00,0x00,0x00,0x2e,0xf3,0x6f,0xf2,0x00,
	0x00,0x00,0x00,0xbf,0xff,0xff,0xf8,0x00,0x00,0x00,0x0b,0xff,0xff,
	0xff,0xe2,0x00,0x00,0x00,0x00,0x00,0x4f,0xf2,0x00,0x00,0x00,0x00,
	0x00,0x09,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0xaf,0xe3,0x1a,0xff,
	0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xff,0xb3,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3b,
	0xff,0xa0,0x00,0x00,0x00,0x00,0x01,0xaf,0xf8,0x00,0x01,0x10,0x00,
	0xaf,0xb0,0x01,0xdf,0x80,0x00,0x00,0x00,0x8a,0x26,0xff,0x20,0x00,
	0x00,0x00,0x00,0x00,0x00,0x0b,0xfd,0x00,0x00,0x00,0x00,0x00,0x03,
	0x9f,0xf7,0x00,0x00,0x00,0x00,0x06,0xfc,0x7f,0xf2,0x00,0x00,0x00,
	0x00,0x8f,0xed,0xfd,0x70,0x00,0x00,0x00,0x0a,0xfd,0x7e,0xfa,0x30,
	0x00,0x00,0x00,0x00,0x00,0x0b,0xf8,0x00,0x00,0x00,0x00,0x00,0x6e,
	0xe8,0x9f,0xe4,0x00,0x00,0x00,0x01,0xef,0x90,0x03,0xff,0x90,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x03,0x9e,0xff,0xb4,0x00,0x00,0x00,0x00,0x04,
	0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x00,0x00,0x4b,0xff,0xf9,0x30,
	0x00,0x00,0x00,0x00,0x00,0x08,0xff,0x60,0x01,0x10,0x00,0x8f,0xd0,
	0x01,0xef,0x60,0x00,0x00,0x00,0x8f,0xec,0xff,0x20,0x00,0x00,0x00,
	0x01,0x47,0x20,0x05,0xff,0x20,0x00,0x00,0x00,0x00,0x10,0x08,0xff,
	0x20,0x00,0x00,0x00,0x00,0xbf,0xef,0xf2,0x00,0x00,0x00,0x00,0x5f,
	0xd1,0x10,0x00,0x00,0x00,0x00,0x08,0xfe,0x11,0x11,0x00,0x00,0x00,
	0x00,0x00,0x00,0x03,0xff,0x30,0x00,0x00,0x00,0x01,0xdf,0x70,0x09,
	0xfb,0x00,0x00,0x00,0x01,0xef,0x80,0x02,0xff,0x70,0x00,0x00,0x00,
	0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x11,0x00,0x00,
	0x00,0x00,0x00,0x02,0x7d,0xff,0xc5,0x00,0x00,0x00,0x04,0xff,0xff,
	0xff,0xff,0xa0,0x00,0x00,0x00,0x5c,0xff,0xd7,0x20,0x00,0x00,0x00,
	0x04,0x75,0x00,0x00,0xcf,0xb0,0x01,0x10,0x00,0x4f,0xf3,0x04,0xff,
	0x30,0x00,0x00,0x00,0x18,0xff,0xff,0x20,0x00,0x00,0x00,0x02,0xff,
	0x70,0x07,0xff,0x20,0x00,0x00,0x00,0x6c,0xc0,0x07,0xff,0x30,0x00,
	0x00,0x00,0x00,0x2e,0xff,0xf2,0x00,0x00,0x00,0x00,0x3f,0xf3,0x11,
	0x11,0x00,0x00,0x00,0x04,0xff,0x60,0x1d,0xc6,0x00,0x00,0x00,0x01,
	0x11,0x11,0x8f,0xc1,0x00,0x00,0x00,0x01,0xff,0x70,0x09,0xfc,0x00,
	0x00,0x00,0x00,0xcf,0xb0,0x07,0xff,0x30,0x00,0x00,0x00,0x00,0x4e,
	0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0xea,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x5c,0xff,0x30,0x00,0x00,0x00,0x11,0x11,0x11,0x11,
	0x10,0x00,0x00,0x03,0xff,0xc5,0x10,0x00,0x00,0x00,0x00,0x07,0xff,
	0x30,0x01,0xdf,0xa0,0x01,0x10,0x00,0x1d,0xfd,0x7d,0xfb,0x00,0x00,
	0x00,0x00,0x00,0x5f,0xff,0x20,0x00,0x00,0x00,0x00,0xbf,0xf8,0x9f,
	0xfb,0x00,0x00,0x00,0x00,0x4f,0xfb,0x8e,0xfc,0x10,0x00,0x00,0x00,
	0x00,0x06,0xff,0xf2,0x00,0x00,0x00,0x00,0x1e,0xff,0xee,0xfc,0x00,
	0x00,0x00,0x00,0xbf,0xe8,0xbf,0xf4,0x00,0x00,0x00,0x0a,0xff,0xee,
	0xef,0xf8,0x00,0x00,0x00,0x00,0xbf,0xe8,0x9f,0xf8,0x00,0x00,0x00,
	0x00,0x6f,0xf9,0x8f,0xfb,0x00,0x00,0x00,0x00,0x00,0x4f,0xf4,0x00,
	0x00,0x00,0x00,0x00,0x00,0x0d,0xfb,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x4a,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x03,0xa4,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xdf,0xe8,0x7d,
	0xff,0x40,0x01,0x10,0x00,0x03,0xef,0xff,0xd2,0x00,0x00,0x00,0x00,
	0x00,0x06,0xff,0x20,0x00,0x00,0x00,0x00,0x2c,0xff,0xff,0xc2,0x00,
	0x00,0x00,0x00,0x07,0xff,0xff,0xd3,0x00,0x00,0x00,0x00,0x00,0x00,
	0xcf,0xf2,0x00,0x00,0x00,0x00,0x0c,0xff,0xff,0xfe,0x10,0x00,0x00,
	0x00,0x1b,0xff,0xff,0x80,0x00,0x00,0x00,0x0c,0xff,0xff,0xff,0xfb,
	0x00,0x00,0x00,0x00,0x2c,0xff,0xff,0xb1,0x00,0x00,0x00,0x00,0x08,
	0xff,0xff,0xb2,0x00,0x00,0x00,0x00,0x00,0x27,0x72,0x00,0x00,0x00,
	0x00,0x00,0x00,0x06,0x75,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2c,0xff,0xff,0xe6,0x00,
	0x01,0x10,0x00,0x00,0x26,0x76,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
	0x77,0x10,0x00,0x00,0x00,0x00,0x00,0x47,0x75,0x10,0x00,0x00,0x00,
	0x00,0x00,0x37,0x75,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x27,0x71,
	0x00,0x00,0x00,0x00,0x05,0x77,0x77,0x76,0x00,0x00,0x00,0x00,0x00,
	0x47,0x74,0x00,0x00,0x00,0x00,0x05,0x77,0x77,0x77,0x75,0x00,0x00,
	0x00,0x00,0x01,0x57,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x75,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x75,0x10,0x00,0x01,0x10,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x40,0x00,0x00,0x00,0x00,0x01,
	0x10,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x75,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x85,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x27,0x72,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x75,0x03,0x74,0x00,0x00,
	0x00,0x00,0x00,0x01,0x5e,0xd4,0x00,0x00,0x00,0x00,0x02,0xeb,0x00,
	0x00,0x6d,0xfb,0x20,0x00,0x00,0x26,0x77,0x51,0x00,0x51,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xf5,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0xdf,0x30,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x4f,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x27,0x72,0x00,0x00,0x00,0x00,0x00,
	0x04,0x73,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x5f,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x03,0xfe,0x04,0xfc,0x00,0x00,0x00,0x00,
	0x00,0x3d,0xff,0xff,0xb1,0x00,0x00,0x00,0x00,0x9f,0x50,0x03,0xfd,
	0x9f,0xb0,0x00,0x07,0xef,0xff,0xfd,0x6b,0xf9,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4f,0xc0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x5f,0xb0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x04,0xf2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x4f,0xf4,0x00,0x00,0x00,0x00,0x00,0x05,0xf9,
	0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x4e,0xe3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xdf,0x10,0xee,0x00,0x00,0x00,0x00,0x01,0xdf,
	0xee,0xcc,0xfa,0x00,0x00,0x00,0x00,0x2f,0xc0,0x07,0xf7,0x0d,0xf2,
	0x00,0x5f,0xfc,0x79,0xef,0xff,0xfa,0x10,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xaf,0x80,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x1e,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x06,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x28,
	0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3f,0xf4,0x00,0x00,0x00,0x00,0x00,0x02,0xfc,0x00,0x00,
	0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x06,0xdf,0xa7,0xef,0x97,0x50,0x00,0x00,0x03,0xff,0x5a,0x81,
	0xff,0x20,0x00,0x00,0x00,0x09,0xf5,0x08,0xf6,0x0c,0xf3,0x00,0xaf,
	0xd1,0x00,0x5f,0xff,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x02,0xff,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0b,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0e,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x4f,0xf4,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0x20,0x00,0x00,0x01,
	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0xa0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,
	0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x35,0x0b,0x81,0xff,0x30,
	0x00,0x00,0x00,0x02,0xfc,0x07,0xf7,0x0d,0xf2,0x00,0xaf,0xc0,0x01,
	0xcf,0xff,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x05,0xff,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xfc,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0c,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x4f,0xf3,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x9f,0x50,0x00,0x00,0x01,0x10,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0d,0xc0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x9f,0xd7,
	0xaf,0xd7,0x50,0x00,0x00,0x00,0x00,0x0b,0xba,0xff,0x20,0x00,0x00,
	0x00,0x00,0x9f,0x42,0xfd,0x9f,0xb0,0x00,0x6f,0xf6,0x1b,0xff,0xaf,
	0xf2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,
	0xfd,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0xfe,0x10,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x1d,0xf6,
	0x11,0x10,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,
	0x01,0x11,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x5f,0x90,0x00,0x00,0x01,0x10,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0xe1,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xe0,0x2f,0xc0,
	0x00,0x00,0x00,0x00,0x02,0x9e,0xff,0xf8,0x00,0x00,0x00,0x58,0x61,
	0x2f,0xc0,0x6d,0xfb,0x20,0x00,0x0a,0xff,0xdf,0xf7,0x17,0x51,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xfc,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0xff,0x20,0x00,0x00,0x00,
	0x05,0xb1,0x4b,0x20,0x00,0x00,0x00,0x04,0xff,0xff,0xff,0xff,0xa0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,
	0xff,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x2f,0xc0,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x2f,0xf1,0x00,0x00,0x00,0x00,0x00,0x00,
	0x11,0x10,0x11,0x10,0x00,0x00,0x01,0x1d,0xf3,0x1e,0xf3,0x10,0x00,
	0x00,0x00,0x3e,0xff,0xfc,0x60,0x00,0x00,0x08,0xff,0xfb,0x07,0xf5,
	0x01,0x10,0x00,0x00,0x00,0x6f,0xff,0xe2,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x08,0xfd,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x06,0xff,0x10,0x00,0x00,0x00,0x02,0xea,
	0xcc,0x10,0x00,0x00,0x00,0x04,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0xff,0x50,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0d,0xf2,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x3f,0xf2,0x00,0x00,0x00,0x00,0x00,0x00,0xce,0x90,
	0xae,0xa0,0x00,0x00,0x0c,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x00,
	0xcf,0xee,0x90,0x00,0x00,0x00,0x1f,0xe2,0xbf,0x41,0xec,0x00,0x00,
	0x00,0x00,0x00,0x4f,0xff,0xfd,0x20,0x00,0x00,0x00,0x00,0x00,0x3e,
	0xe4,0x00,0x00,0x00,0x00,0x00,0x06,0xfe,0x10,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x08,0xfd,0x00,0x00,0x00,0x00,0x03,0x8f,0xf7,0x20,
	0x00,0x00,0x00,0x00,0x11,0x1d,0xf6,0x11,0x10,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x11,0x11,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xf4,
	0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x4f,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0xdf,0xa0,0xbf,0xc0,
	0x00,0x00,0x0c,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x01,0xff,0x4a,
	0x90,0x00,0x00,0x00,0x4f,0xa0,0x7f,0x60,0x8f,0x50,0x00,0x00,0x00,
	0x00,0xcf,0xc3,0x9f,0xc0,0x00,0x00,0x00,0x00,0x00,0x3f,0xf5,0x00,
	0x00,0x00,0x00,0x00,0x02,0xff,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0a,0xf9,0x00,0x00,0x00,0x00,0x2f,0xee,0xde,0xd1,0x00,0x00,
	0x00,0x00,0x00,0x0c,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0xf8,0x00,0x00,
	0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5f,
	0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0xcb,0x40,0xbc,0x50,0x00,0x00,
	0x01,0x14,0xfc,0x15,0xfb,0x10,0x00,0x00,0x01,0xff,0x4a,0x87,0xc7,
	0x00,0x00,0x4f,0xa0,0x7f,0x60,0x1e,0xc0,0x00,0x00,0x00,0x02,0xff,
	0x60,0x3f,0xf2,0x00,0x00,0x00,0x00,0x00,0x3f,0x92,0x00,0x00,0x00,
	0x00,0x00,0x00,0xbf,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,
	0xf4,0x00,0x00,0x00,0x00,0x04,0x2c,0x92,0x40,0x00,0x00,0x00,0x00,
	0x00,0x0e,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xfc,0x00,0x00,0x01,0x10,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6f,0xf5,0x00,
	0x00,0x00,0x00,0x00,0x00,0xba,0x00,0x9c,0x00,0x00,0x00,0x00,0x01,
	0xff,0x12,0xfd,0x00,0x00,0x00,0x00,0xbf,0xdd,0xde,0xf9,0x00,0x00,
	0x2f,0xd2,0xbf,0x40,0x08,0xf5,0x00,0x00,0x00,0x01,0xef,0xd7,0xcf,
	0xd1,0x00,0x00,0x00,0x00,0x00,0x1f,0x50,0x00,0x00,0x00,0x00,0x00,
	0x00,0x4f,0xd0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5f,0xb0,0x00,
	0x00,0x00,0x00,0x00,0x0d,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x06,
	0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xdf,0x10,0x00,0x01,0x10,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6f,0xf5,0x00,0x00,0x00,
	0x00,0x00,0x00,0x3e,0x80,0x2d,0xa0,0x00,0x00,0x00,0x00,0xcf,0x40,
	0xef,0x30,0x00,0x00,0x00,0x2c,0xff,0xff,0xb1,0x00,0x00,0x08,0xff,
	0xfb,0x10,0x01,0xfe,0x10,0x00,0x00,0x00,0x6f,0xff,0xfe,0x40,0x00,
	0x00,0x00,0x00,0x00,0x07,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,
	0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xdf,0x30,0x00,0x00,0x00,
	0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xaf,0x50,0x00,0x01,0x10,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x72,0x00,0x00,0x00,0x00,0x00,
	0x00,0x03,0x40,0x02,0x50,0x00,0x00,0x00,0x00,0x57,0x30,0x57,0x20,
	0x00,0x00,0x00,0x01,0x5e,0xd5,0x00,0x00,0x00,0x00,0x58,0x61,0x00,
	0x00,0x58,0x20,0x00,0x00,0x00,0x02,0x77,0x62,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x75,0x00,
	0x00,0x00,0x00,0x00,0x00,0x02,0x85,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x37,0x30,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x05,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0d,0xdd,0x20,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0c,0xdd,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x10,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xef,
	0xfc,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0d,0xd0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0f,0xff,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0e,0xff,0x40,0x00,0x00,0x00,0x0d,0xdd,0x20,0x00,0x00,0x00,0x00,
	0x01,0x9e,0xff,0xfc,0x50,0x00,0x00,0x00,0x00,0x03,0xdf,0xfe,0x20,
	0x00,0x00,0x00,0x02,0xcf,0xfa,0x4d,0xda,0x00,0x00,0x00,0x00,0x00,
	0x9d,0xd7,0x00,0x00,0x00,0x00,0x00,0x6d,0xd3,0x02,0xdd,0x60,0x00,
	0x00,0x2d,0xdd,0x40,0x0b,0xdd,0xa0,0x00,0x00,0x05,0xbb,0xff,0xf2,
	0x00,0x00,0x00,0x00,0x00,0x9d,0xdd,0xdd,0xdd,0x70,0x00,0x00,0x00,
	0x00,0x00,0x4c,0xff,0x50,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,
	0x00,0x00,0x00,0x5f,0xfc,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0f,0xff,0x33,0x54,0x10,0x00,0x00,0x00,0x00,0x03,0x54,0x1e,0xff,
	0x40,0x00,0x00,0x00,0x0f,0xff,0x30,0x00,0x00,0x00,0x00,0x0b,0xff,
	0xeb,0xef,0xf4,0x00,0x00,0x00,0x00,0x0b,0xff,0xff,0x10,0x00,0x00,
	0x00,0x0c,0xff,0xff,0xef,0xfb,0x00,0x00,0x00,0x00,0x01,0xff,0xfe,
	0x00,0x00,0x00,0x00,0x00,0xbf,0xf7,0x06,0xff,0xc0,0x00,0x00,0x06,
	0xff,0xe1,0x6f,0xff,0x20,0x00,0x00,0x00,0x00,0xaf,0xfa,0x00,0x00,
	0x00,0x00,0x00,0xaf,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,
	0xdf,0xff,0x50,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,
	0x00,0x5f,0xff,0xd0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x00,0x00,0x00,0x00,0x0f,0xff,
	0xdf,0xff,0xd2,0x00,0x00,0x00,0x01,0xbf,0xff,0xdf,0xff,0x40,0x00,
	0x00,0x00,0x0f,0xff,0x30,0x00,0x00,0x00,0x00,0x07,0x9a,0x30,0x5f,
	0xfa,0x00,0x00,0x00,0x00,0x0d,0xff,0x84,0x00,0x00,0x00,0x00,0x1f,
	0xff,0xb7,0xff,0xfb,0x00,0x00,0x00,0x00,0x07,0xff,0xff,0x50,0x00,
	0x00,0x00,0x01,0xff,0xfb,0x0c,0xff,0xf2,0x00,0x00,0x00,0xbf,0xfa,
	0xef,0xf6,0x00,0x00,0x00,0x00,0x00,0xdf,0xff,0x20,0x00,0x00,0x00,
	0x00,0x5f,0xff,0x94,0x44,0x20,0x00,0x00,0x00,0x00,0x00,0xff,0xf5,
	0x10,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x15,
	0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x5c,0xf7,0x00,0x00,0x00,0x00,0x0f,0xff,0xe9,0xef,
	0xfc,0x00,0x00,0x00,0x08,0xff,0xfa,0xdf,0xff,0x40,0x00,0x00,0x00,
	0x0f,0xff,0x30,0x00,0x00,0x00,0x00,0x00,0x15,0x9c,0xff,0xf8,0x00,
	0x00,0x00,0x00,0x0d,0xff,0x50,0x00,0x00,0x00,0x00,0x1f,0xff,0x20,
	0x8f,0xfb,0x00,0x00,0x00,0x00,0x0d,0xfd,0xef,0xc0,0x00,0x00,0x00,
	0x05,0xfd,0xff,0x2f,0xfd,0xf6,0x00,0x00,0x00,0x1e,0xff,0xff,0xb0,
	0x00,0x00,0x00,0x00,0x06,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x05,
	0xff,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,
	0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0xef,0xf0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x5c,0xff,0xf8,0x00,0x00,0x00,0x00,0x0f,0xff,0x50,0x3f,0xff,0x10,
	0x00,0x00,0x0d,0xff,0x60,0x1f,0xff,0x40,0x00,0x00,0x00,0x0f,0xff,
	0x40,0x00,0x00,0x00,0x00,0x03,0xef,0xff,0xff,0xc1,0x00,0x00,0x00,
	0x00,0x0d,0xff,0x50,0x00,0x00,0x00,0x00,0x1f,0xff,0x20,0x6f,0xfb,
	0x00,0x00,0x00,0x00,0x4f,0xf8,0x9f,0xf3,0x00,0x00,0x00,0x0b,0xf8,
	0xdf,0xaf,0xd8,0xfb,0x00,0x00,0x00,0x08,0xff,0xff,0x30,0x00,0x00,
	0x00,0x00,0x1e,0xfd,0xbf,0xf1,0x00,0x00,0x00,0x00,0x00,0x6f,0xff,
	0x40,0x00,0x00,0x00,0x00,0x00,0x02,0xff,0xd0,0x00,0x00,0x00,0x00,
	0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0xdf,0xf2,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4c,0xff,0xff,
	0xff,0xee,0xe8,0x00,0x00,0x0f,0xff,0x30,0x1f,0xff,0x20,0x00,0x00,
	0x0d,0xff,0x50,0x0f,0xff,0x40,0x00,0x00,0x00,0x0f,0xff,0xa0,0x00,
	0x00,0x00,0x00,0x0a,0xff,0xc8,0x63,0x00,0x00,0x00,0x00,0x00,0x0d,
	0xff,0x50,0x00,0x00,0x00,0x00,0x1f,0xff,0x20,0x6f,0xfb,0x00,0x00,
	0x00,0x00,0xbf,0xf4,0x4f,0xf9,0x00,0x00,0x00,0x1f,0xf5,0x8f,0xff,
	0x84,0xff,0x10,0x00,0x00,0x2f,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,
	0x7f,0xf7,0x5f,0xf7,0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xf4,0x00,
	0x00,0x00,0x00,0x00,0x5e,0xff,0x90,0x00,0x00,0x00,0x00,0x00,0x0f,
	0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x9f,0xfe,0x50,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3a,0xff,0xff,0xfc,0x88,
	0x85,0x00,0x00,0x0f,0xff,0x91,0x7f,0xfe,0x00,0x00,0x00,0x0a,0xff,
	0xa1,0x5f,0xff,0x40,0x00,0x00,0x00,0x0f,0xff,0xfe,0xc0,0x00,0x00,
	0x00,0x0a,0xff,0x53,0xbc,0xb3,0x00,0x00,0x00,0x01,0xdf,0xff,0xed,
	0x10,0x00,0x00,0x00,0x1f,0xff,0x20,0x6f,0xfb,0x00,0x00,0x00,0x02,
	0xff,0xe0,0x0f,0xff,0x10,0x00,0x00,0x5f,0xf2,0x4f,0xff,0x41,0xff,
	0x50,0x00,0x00,0xcf,0xfa,0xdf,0xf7,0x00,0x00,0x00,0x01,0xef,0xf2,
	0x1f,0xfe,0x00,0x00,0x00,0x00,0x4a,0xaa,0xef,0xff,0x20,0x00,0x00,
	0x00,0x00,0x7f,0xfd,0x10,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,
	0x00,0x00,0x00,0x00,0x00,0x1d,0xff,0x70,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3a,0xff,0xf7,0x00,0x00,0x00,
	0x00,0x0f,0xff,0xff,0xff,0xf6,0x00,0x00,0x00,0x03,0xff,0xff,0xff,
	0xff,0x40,0x00,0x00,0x00,0x0f,0xff,0xcf,0xf3,0x00,0x00,0x00,0x03,
	0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x01,0xff,0xff,0xff,0x10,0x00,
	0x00,0x00,0x1f,0xff,0x20,0x6f,0xfb,0x00,0x00,0x00,0x08,0xff,0xa0,
	0x0a,0xff,0x70,0x00,0x00,0x9f,0xe0,0x1f,0xfe,0x10,0xdf,0xa0,0x00,
	0x08,0xff,0xf2,0x4f,0xff,0x30,0x00,0x00,0x08,0xff,0xb0,0x0a,0xff,
	0x60,0x00,0x00,0x00,0x5f,0xff,0xff,0xff,0x50,0x00,0x00,0x00,0x00,
	0x4d,0xff,0x90,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x9f,0xfd,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x3a,0xf7,0x00,0x00,0x00,0x00,0x0b,
	0xba,0x3a,0xdc,0x60,0x00,0x00,0x00,0x00,0x3b,0xdb,0x57,0xbb,0x30,
	0x00,0x00,0x00,0x06,0x66,0x18,0x82,0x00,0x00,0x00,0x00,0x27,0x99,
	0x85,0x00,0x00,0x00,0x00,0x00,0x6e,0xff,0x96,0x00,0x00,0x00,0x00,
	0x06,0x66,0x10,0x36,0x65,0x00,0x00,0x00,0x05,0x66,0x30,0x03,0x66,
	0x50,0x00,0x00,0x56,0x50,0x05,0x65,0x00,0x46,0x60,0x00,0x06,0x66,
	0x40,0x05,0x66,0x50,0x00,0x00,0x06,0x66,0x30,0x02,0x66,0x50,0x00,
	0x00,0x00,0x26,0x66,0x66,0x66,0x20,0x00,0x00,0x00,0x00,0x02,0xff,
	0xc0,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,
	0x00,0xcf,0xf2,0x00,0x00,0x00,0x00,0x01,0x55,0x10,0x55,0x10,0x00,
	0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0d,0xff,0x50,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xd0,0x00,
	0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0xdf,
	0xf0,0x00,0x00,0x00,0x00,0x04,0xff,0x43,0xff,0x50,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x02,0xaf,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xf5,0x10,0x00,0x00,
	0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x15,0xff,0xf0,0x00,
	0x00,0x00,0x00,0x08,0xff,0x76,0xff,0x90,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x02,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0xff,0x50,0x00,0x00,0x00,0x00,
	0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x5f,0xff,0xc0,0x00,0x00,0x00,
	0x00,0x09,0xff,0x87,0xff,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x3c,0xff,0x50,0x00,0x00,0x00,0x00,0x0c,0xc0,
	0x00,0x00,0x00,0x00,0x00,0x5f,0xfc,0x30,0x00,0x00,0x00,0x00,0x08,
	0xcc,0x76,0xcc,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x8d,0xff,0xfd,0x91,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x7f,0xfb,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x06,0xbc,0xb5,0x29,0x97,0x00,0x00,0x00,
	0x99,0x91,0x9c,0xa3,0x00,0x00,0x00,0x00,0x06,0xac,0xca,0x60,0x00,
	0x00,0x00,0x00,0x8f,0xfd,0x3d,0xdc,0x00,0x00,0x00,0x00,0x07,0xbc,
	0xca,0x60,0x00,0x00,0x00,0x00,0x09,0xdd,0x60,0x00,0x00,0x00,0x00,
	0x07,0xff,0xea,0xcf,0xfc,0x00,0x00,0x00,0x0b,0xdd,0x50,0x2d,0xdd,
	0x00,0x00,0x00,0x00,0x00,0xcd,0xd3,0x00,0x00,0x00,0x00,0x00,0x7f,
	0xff,0x90,0x00,0x00,0x00,0x00,0x01,0xdd,0xd2,0x02,0xdd,0xd6,0x00,
	0x00,0x00,0x00,0x0d,0xdd,0x30,0x00,0x00,0x00,0xdd,0xc0,0x1d,0xdc,
	0x01,0xdd,0xb0,0x00,0x01,0xdd,0xd2,0x06,0xdd,0xa0,0x00,0x00,0x00,
	0x05,0xac,0xc9,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x6f,0xff,0xff,0xef,0xf8,0x00,0x00,0x00,0xff,0xfd,
	0xff,0xff,0x40,0x00,0x00,0x01,0xcf,0xff,0xff,0xfb,0x00,0x00,0x00,
	0x07,0xff,0xff,0xef,0xfe,0x00,0x00,0x00,0x01,0xcf,0xff,0xff,0xfb,
	0x00,0x00,0x00,0x00,0x0a,0xff,0x70,0x00,0x00,0x00,0x00,0x06,0x86,
	0x30,0x1f,0xff,0x30,0x00,0x00,0x0c,0xff,0x50,0x3f,0xff,0x00,0x00,
	0x00,0x00,0x00,0xef,0xf4,0x00,0x00,0x00,0x00,0x00,0x1a,0xff,0xb0,
	0x00,0x00,0x00,0x00,0x01,0xff,0xf3,0x09,0xff,0xd0,0x00,0x00,0x00,
	0x00,0x0e,0xff,0x40,0x00,0x00,0x00,0xff,0xe0,0x1f,0xfd,0x01,0xff,
	0xd0,0x00,0x01,0xff,0xf2,0x06,0xff,0xb0,0x00,0x00,0x00,0xaf,0xff,
	0xff,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xaf,0xf9,0x03,0xef,0xf7,0x00,0x00,0x00,0xff,0xfe,0x8d,0xff,
	0xc0,0x00,0x00,0x08,0xff,0xe6,0x6e,0xff,0x60,0x00,0x00,0x0e,0xff,
	0xa4,0xcf,0xfe,0x00,0x00,0x00,0x07,0xff,0xc2,0x3b,0xb9,0x30,0x00,
	0x00,0x00,0x0a,0xff,0x70,0x00,0x00,0x00,0x00,0x00,0x5c,0xed,0x6e,
	0xff,0x40,0x00,0x00,0x0c,0xff,0x50,0x3f,0xff,0x00,0x00,0x00,0x00,
	0x00,0xef,0xf4,0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xb0,0x00,0x00,
	0x00,0x00,0x01,0xff,0xf6,0x2f,0xff,0x40,0x00,0x00,0x00,0x00,0x0e,
	0xff,0x40,0x00,0x00,0x00,0xff,0xe0,0x1f,0xfd,0x01,0xff,0xd0,0x00,
	0x01,0xff,0xf2,0x06,0xff,0xb0,0x00,0x00,0x07,0xff,0xe6,0x7f,0xff,
	0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,
	0xfd,0x40,0xaf,0xf7,0x00,0x00,0x00,0xff,0xf5,0x03,0xff,0xf1,0x00,
	0x00,0x0d,0xff,0x60,0x04,0x86,0x30,0x00,0x00,0x2f,0xff,0x10,0x5f,
	0xfe,0x00,0x00,0x00,0x0d,0xff,0x84,0x44,0x44,0x20,0x00,0x00,0x00,
	0x0a,0xff,0x70,0x00,0x00,0x00,0x00,0x05,0xff,0xfd,0xff,0xff,0x40,
	0x00,0x00,0x0c,0xff,0x50,0x3f,0xff,0x00,0x00,0x00,0x00,0x00,0xef,
	0xf4,0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xb0,0x00,0x00,0x00,0x00,
	0x01,0xff,0xff,0xdf,0xfb,0x00,0x00,0x00,0x00,0x00,0x0e,0xff,0x40,
	0x00,0x00,0x00,0xff,0xe0,0x1f,0xfd,0x01,0xff,0xd0,0x00,0x01,0xff,
	0xf2,0x06,0xff,0xb0,0x00,0x00,0x0c,0xff,0x60,0x0b,0xff,0x70,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0xef,0xff,
	0xef,0xf7,0x00,0x00,0x00,0xff,0xf3,0x01,0xff,0xf2,0x00,0x00,0x0e,
	0xff,0x40,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x00,0x4f,0xfe,0x00,
	0x00,0x00,0x0e,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x00,0x0a,0xff,
	0x70,0x00,0x00,0x00,0x00,0x0c,0xff,0x70,0x2f,0xff,0x40,0x00,0x00,
	0x0c,0xff,0x60,0x3f,0xff,0x00,0x00,0x00,0x00,0x00,0xef,0xf4,0x00,
	0x00,0x00,0x00,0x00,0x06,0xff,0xb0,0x00,0x00,0x00,0x00,0x01,0xff,
	0xff,0xff,0xf2,0x00,0x00,0x00,0x00,0x00,0x0e,0xff,0x40,0x00,0x00,
	0x00,0xff,0xe0,0x1f,0xfd,0x01,0xff,0xd0,0x00,0x01,0xff,0xf2,0x06,
	0xff,0xb0,0x00,0x00,0x0e,0xff,0x40,0x08,0xff,0x90,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x6a,0xff,0xf7,
	0x00,0x00,0x00,0xff,0xf5,0x03,0xff,0xf1,0x00,0x00,0x0d,0xff,0x60,
	0x03,0x31,0x00,0x00,0x00,0x1f,0xff,0x40,0x7f,0xfe,0x00,0x00,0x00,
	0x0d,0xff,0x95,0x5c,0xff,0x80,0x00,0x00,0x00,0x0a,0xff,0x70,0x00,
	0x00,0x00,0x00,0x0e,0xff,0x40,0x0f,0xff,0x40,0x00,0x00,0x0c,0xff,
	0xa0,0x5f,0xff,0x00,0x00,0x00,0x00,0x00,0xef,0xf4,0x00,0x00,0x00,
	0x00,0x00,0x06,0xff,0xb0,0x00,0x00,0x00,0x00,0x01,0xff,0xff,0xff,
	0xa0,0x00,0x00,0x00,0x00,0x00,0x0e,0xff,0x40,0x00,0x00,0x00,0xff,
	0xf3,0x2f,0xff,0x23,0xff,0xd0,0x00,0x01,0xff,0xf6,0x09,0xff,0xb0,
	0x00,0x00,0x0d,0xff,0x60,0x0a,0xff,0x80,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x4c,0xed,0x21,0xbf,0xf6,0x00,0x00,
	0x00,0xff,0xfe,0x8d,0xff,0xd0,0x00,0x00,0x08,0xff,0xe5,0x5e,0xff,
	0x50,0x00,0x00,0x0c,0xff,0xfc,0xff,0xfe,0x00,0x00,0x00,0x08,0xff,
	0xb1,0x2e,0xff,0x40,0x00,0x00,0x00,0xcf,0xff,0xed,0x00,0x00,0x00,
	0x00,0x0d,0xff,0x91,0x6f,0xff,0x40,0x00,0x00,0x0c,0xff,0xfe,0xff,
	0xfe,0x00,0x00,0x00,0x00,0x00,0xef,0xf4,0x00,0x00,0x00,0x00,0x00,
	0x06,0xff,0xb0,0x00,0x00,0x00,0x00,0x01,0xff,0xf5,0xef,0xf8,0x00,
	0x00,0x00,0x00,0x00,0x0e,0xff,0x40,0x00,0x00,0x00,0xff,0xff,0xff,
	0xff,0xff,0xff,0xb0,0x00,0x01,0xff,0xff,0xef,0xff,0xa0,0x00,0x00,
	0x07,0xff,0xe5,0x6f,0xff,0x30,0x00,0x00,0x00,0x03,0x54,0x00,0x00,
	0x00,0x00,0x00,0x00,0x1e,0xff,0xff,0xff,0xe1,0x00,0x00,0x00,0xff,
	0xff,0xff,0xff,0x50,0x00,0x00,0x01,0xcf,0xff,0xff,0xfb,0x00,0x00,
	0x00,0x03,0xff,0xff,0xef,0xfe,0x00,0x00,0x00,0x01,0xcf,0xff,0xff,
	0xf9,0x00,0x00,0x00,0x00,0xdf,0xff,0xff,0x00,0x00,0x00,0x00,0x06,
	0xff,0xff,0xff,0xff,0x40,0x00,0x00,0x0c,0xff,0xcf,0xff,0xf7,0x00,
	0x00,0x00,0x00,0x00,0xef,0xf4,0x00,0x00,0x00,0x00,0x00,0x06,0xff,
	0xb0,0x00,0x00,0x00,0x00,0x01,0xff,0xf3,0x4f,0xff,0x80,0x00,0x00,
	0x00,0x00,0x0e,0xff,0x40,0x00,0x00,0x00,0xff,0xde,0xff,0xf9,0xef,
	0xff,0x50,0x00,0x01,0xff,0xea,0xff,0xff,0x40,0x00,0x00,0x00,0xbf,
	0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x0b,0xfc,0x00,0x00,0x00,0x00,
	0x00,0x00,0x02,0x8c,0xdd,0xc9,0x20,0x00,0x00,0x00,0xff,0xf5,0xad,
	0xb4,0x00,0x00,0x00,0x00,0x17,0xbd,0xdb,0x60,0x00,0x00,0x00,0x00,
	0x28,0x96,0x4f,0xfe,0x00,0x00,0x00,0x00,0x17,0xbd,0xdb,0x50,0x00,
	0x00,0x00,0x00,0x6d,0xff,0xb6,0x00,0x00,0x00,0x00,0x00,0x5b,0xdb,
	0x57,0xbb,0x20,0x00,0x00,0x0c,0xff,0x53,0x89,0x50,0x00,0x00,0x00,
	0x00,0x00,0x66,0x62,0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xb0,0x00,
	0x00,0x00,0x00,0x01,0xff,0xf3,0x04,0x66,0x62,0x00,0x00,0x00,0x00,
	0x0e,0xff,0x40,0x00,0x00,0x00,0x66,0x51,0x89,0x60,0x28,0x95,0x00,
	0x00,0x00,0x66,0x60,0x59,0x93,0x00,0x00,0x00,0x00,0x06,0xbd,0xda,
	0x40,0x00,0x00,0x00,0x00,0x0f,0xff,0x10,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xf3,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x4f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x09,0xff,0xb4,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x0c,0xff,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x88,0x82,0x00,0x00,0x00,0x00,0x00,0x01,0x33,0x20,0x00,0x00,0x00,
	0x00,0x01,0xff,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xff,
	0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x1f,0xff,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xf3,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4f,0xfe,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,
	0xff,0xff,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0c,0xff,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xef,0xf4,
	0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xb0,0x00,0x00,0x00,0x00,0x01,
	0xff,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xff,0x40,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x1c,0xcc,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xcc,0xc2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x88,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6b,0xba,
	0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,
	0x88,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x82,0x00,0x00,
	0x00,0x00,0x00,0x05,0xcc,0x90,0x00,0x00,0x00,0x00,0x01,0x88,0x81,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x88,0x20,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0d,0xdd,0xda,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xad,0xdd,0xd0,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xbd,0xda,0x00,0x00,0x00,0x00,0x00,0x00,0x17,
	0xac,0xca,0x6d,0xfe,0x10,0x00,0x3d,0xdd,0x40,0x03,0xdd,0xda,0x00,
	0x00,0x00,0x04,0x9c,0xcc,0x94,0x00,0x00,0x00,0x00,0x0a,0xdd,0xb0,
	0x00,0x00,0x00,0x00,0x00,0x19,0xef,0xff,0xd8,0x00,0x00,0x00,0x00,
	0x00,0xad,0xdd,0x50,0x00,0x00,0x00,0x01,0xdd,0xc0,0x01,0xdd,0xc0,
	0x00,0x01,0xcd,0xdc,0x10,0x01,0xdd,0xdb,0x00,0x00,0x00,0x00,0x6d,
	0xdd,0x10,0x00,0x00,0x00,0x0d,0xdd,0xdd,0xdd,0xdd,0xdc,0x00,0x00,
	0x00,0x00,0x0f,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x9a,0x00,
	0x00,0x00,0x00,0x00,0xcf,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x00,0x00,0xcf,0xfb,0x00,0x00,0x00,0x00,0x00,0x03,0xef,0xff,0xff,
	0xff,0xf6,0x00,0x00,0x4f,0xff,0x40,0x0b,0xff,0xf4,0x00,0x00,0x00,
	0x9f,0xff,0xff,0xff,0x90,0x00,0x00,0x00,0x0b,0xff,0xc0,0x00,0x00,
	0x00,0x00,0x01,0xdf,0xff,0xff,0xff,0xb0,0x00,0x00,0x00,0x02,0xff,
	0xff,0xb0,0x00,0x00,0x00,0x03,0xff,0xf2,0x04,0xff,0xf1,0x00,0x00,
	0x5f,0xff,0x80,0x0a,0xff,0xf4,0x00,0x00,0x00,0x00,0x7f,0xff,0x10,
	0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xfd,0x00,0x00,0x00,0x00,
	0x0f,0xff,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0xf9,0x00,0x00,0x00,
	0x00,0x00,0x67,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,
	0xcf,0xfb,0x00,0x00,0x00,0x00,0x00,0x2e,0xff,0xfd,0xef,0xff,0xd1,
	0x00,0x00,0x4f,0xff,0x50,0x4f,0xff,0xc0,0x00,0x00,0x03,0xff,0xfc,
	0x79,0xff,0xf4,0x00,0x00,0x00,0x0b,0xff,0xc0,0x00,0x00,0x00,0x00,
	0x09,0xff,0xfd,0xae,0xff,0xf6,0x00,0x00,0x00,0x08,0xff,0xff,0xf2,
	0x00,0x00,0x00,0x05,0xff,0xf6,0x07,0xff,0xf4,0x00,0x00,0x0a,0xff,
	0xf3,0x4f,0xff,0x90,0x00,0x00,0x00,0x00,0x7f,0xff,0x10,0x00,0x00,
	0x00,0x0d,0xff,0xfb,0x88,0x88,0x87,0x00,0x00,0x00,0x00,0x0f,0xfe,
	0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xf5,0x00,0x00,0x00,0x00,0x00,
	0x00,0xef,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0xfb,
	0x00,0x00,0x00,0x00,0x00,0x8f,0xff,0x55,0xef,0xff,0xf6,0x00,0x00,
	0x4f,0xff,0x50,0xcf,0xff,0x30,0x00,0x00,0x09,0xff,0xe1,0x00,0xcf,
	0xf9,0x00,0x00,0x00,0x0b,0xff,0xc0,0x00,0x00,0x00,0x00,0x0e,0xff,
	0xc0,0x01,0xef,0xfb,0x00,0x00,0x00,0x0d,0xff,0xdf,0xf7,0x00,0x00,
	0x00,0x08,0xff,0xf9,0x0a,0xff,0xf7,0x00,0x00,0x01,0xef,0xfc,0xdf,
	0xfe,0x10,0x00,0x00,0x00,0x00,0x7f,0xff,0x10,0x00,0x00,0x00,0x02,
	0xef,0xfe,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xfe,0x00,0x00,
	0x00,0x00,0x00,0x00,0x07,0xf2,0x00,0x00,0x00,0x00,0x00,0x00,0xef,
	0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0xfe,0x99,0x96,
	0x10,0x00,0x00,0xdf,0xfc,0x06,0xb2,0xef,0xfa,0x00,0x00,0x4f,0xff,
	0x79,0xff,0xf6,0x00,0x00,0x00,0x02,0x34,0x40,0x16,0xff,0xfa,0x00,
	0x00,0x00,0x0b,0xff,0xc0,0x00,0x00,0x00,0x00,0x1f,0xff,0x80,0x00,
	0xaf,0xfd,0x00,0x00,0x00,0x4f,0xff,0x5f,0xfd,0x00,0x00,0x00,0x0a,
	0xff,0xfc,0x0e,0xff,0xf9,0x00,0x00,0x00,0x5f,0xff,0xff,0xf4,0x00,
	0x00,0x00,0x00,0x00,0x7f,0xff,0x10,0x00,0x00,0x00,0x00,0x2e,0xff,
	0xe2,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xfe,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0b,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0xef,0xf0,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0xff,0xff,0xff,0xd1,0x00,
	0x00,0xff,0xf9,0x00,0x00,0xcf,0xfc,0x00,0x00,0x4f,0xff,0xff,0xff,
	0xd6,0x00,0x00,0x00,0x00,0x01,0x7c,0xff,0xff,0xf5,0x00,0x00,0x00,
	0x0b,0xff,0xc0,0x00,0x00,0x00,0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,
	0x00,0x00,0x00,0xaf,0xfa,0x1f,0xff,0x30,0x00,0x00,0x0e,0xfd,0xff,
	0x3f,0xfd,0xfc,0x00,0x00,0x00,0x0a,0xff,0xff,0xa0,0x00,0x00,0x00,
	0x00,0x01,0xdf,0xff,0x70,0x00,0x00,0x00,0x00,0x03,0xef,0xfe,0x20,
	0x00,0x00,0x00,0x00,0x00,0x0f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0f,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0xef,0xf0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0xcf,0xfe,0xac,0xff,0xf9,0x00,0x00,0xff,
	0xf8,0x00,0x00,0xcf,0xfc,0x00,0x00,0x4f,0xff,0xfe,0xff,0xff,0x70,
	0x00,0x00,0x00,0x5f,0xff,0xff,0xff,0x90,0x00,0x00,0x00,0x0b,0xff,
	0xc0,0x00,0x00,0x00,0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,0x00,0x00,
	0x01,0xff,0xf5,0x0a,0xff,0x90,0x00,0x00,0x1f,0xf8,0xff,0xaf,0xe8,
	0xff,0x00,0x00,0x00,0x08,0xff,0xff,0x90,0x00,0x00,0x00,0x00,0x08,
	0xff,0xff,0xf2,0x00,0x00,0x00,0x00,0x00,0x3e,0xff,0xd1,0x00,0x00,
	0x00,0x00,0x00,0x0f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x60,
	0x00,0x00,0x00,0x00,0x00,0x00,0xef,0xf0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xcf,0xfb,0x00,0xbf,0xfd,0x00,0x00,0xef,0xfb,0x00,
	0x00,0xef,0xfa,0x00,0x00,0x4f,0xff,0x50,0x1b,0xff,0xf0,0x00,0x00,
	0x01,0xff,0xff,0xfd,0x83,0x00,0x00,0x00,0x00,0x0b,0xff,0xc0,0x00,
	0x00,0x00,0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,0x00,0x00,0x06,0xff,
	0xf1,0x05,0xff,0xf1,0x00,0x00,0x4f,0xf5,0xcf,0xff,0xa6,0xff,0x20,
	0x00,0x00,0x3f,0xff,0xff,0xf4,0x00,0x00,0x00,0x00,0x3f,0xff,0xff,
	0xfc,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0xfd,0x10,0x00,0x00,0x00,
	0x00,0x0f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x20,0x00,0x00,
	0x00,0x00,0x00,0x00,0xef,0xf0,0x00,0x00,0x00,0x00,0x01,0xde,0xa0,
	0x0a,0xec,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xcf,0xfb,0x00,0xbf,0xfd,0x00,0x00,0x9f,0xff,0x30,0x05,0xff,
	0xf7,0x00,0x00,0x4f,0xff,0x50,0x09,0xff,0xf1,0x00,0x00,0x03,0xff,
	0xf6,0x11,0x98,0x72,0x00,0x01,0x44,0x4c,0xff,0xd4,0x44,0x20,0x00,
	0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,0x00,0x00,0x0c,0xff,0xb0,0x01,
	0xff,0xf5,0x00,0x00,0x6f,0xf3,0x8f,0xff,0x74,0xff,0x50,0x00,0x01,
	0xdf,0xfc,0xbf,0xfd,0x10,0x00,0x00,0x01,0xdf,0xfd,0x4f,0xff,0x70,
	0x00,0x00,0x00,0x00,0x00,0x4f,0xff,0xc1,0x00,0x00,0x00,0x00,0x0f,
	0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0xbe,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xef,0xf0,0x00,0x00,0x00,0x00,0x00,0x6f,0xf3,0x3f,0xf5,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,
	0xfe,0xbd,0xff,0xfa,0x00,0x00,0x3f,0xff,0xfb,0xcf,0xff,0xe1,0x00,
	0x00,0x4f,0xff,0xdb,0xcf,0xff,0xe0,0x00,0x00,0x02,0xff,0xf5,0x29,
	0xff,0xf2,0x00,0x05,0xff,0xff,0xff,0xff,0xff,0x60,0x00,0x00,0x1f,
	0xff,0x70,0x00,0xaf,0xfd,0x00,0x00,0x2f,0xff,0x60,0x00,0xbf,0xfb,
	0x00,0x00,0x9f,0xf0,0x5f,0xff,0x42,0xff,0x80,0x00,0x08,0xff,0xf3,
	0x2f,0xff,0x80,0x00,0x00,0x08,0xff,0xf4,0x0a,0xff,0xf2,0x00,0x00,
	0x05,0xdd,0xdd,0xdf,0xff,0xf9,0x00,0x00,0x00,0x00,0x0f,0xfe,0x00,
	0x00,0x00,0x00,0x00,0x00,0xea,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xef,0xf0,0x00,0x00,0x00,0x00,0x00,0x0b,0xfb,0xbf,0xa0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0xff,0xff,
	0xff,0xe2,0x00,0x00,0x06,0xff,0xff,0xff,0xff,0x40,0x00,0x00,0x4f,
	0xff,0xff,0xff,0xff,0x50,0x00,0x00,0x00,0x9f,0xff,0xff,0xff,0x90,
	0x00,0x05,0xff,0xff,0xff,0xff,0xff,0x60,0x00,0x00,0x1f,0xff,0x70,
	0x00,0xaf,0xfd,0x00,0x00,0x8f,0xff,0x10,0x00,0x6f,0xff,0x20,0x00,
	0xcf,0xd0,0x2f,0xff,0x00,0xff,0xa0,0x00,0x3f,0xff,0x90,0x08,0xff,
	0xf3,0x00,0x00,0x3f,0xff,0x90,0x02,0xff,0xfc,0x00,0x00,0x05,0xff,
	0xff,0xff,0xff,0xf9,0x00,0x00,0x00,0x00,0x0f,0xff,0x86,0x00,0x00,
	0x00,0x00,0x03,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0xff,0xf0,
	0x00,0x00,0x00,0x00,0x00,0x02,0xff,0xfe,0x10,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x88,0x88,0x86,0x10,
	0x00,0x00,0x00,0x39,0xef,0xfd,0x92,0x00,0x00,0x00,0x28,0x88,0x88,
	0x88,0x62,0x00,0x00,0x00,0x00,0x06,0xcf,0xff,0xc6,0x00,0x00,0x03,
	0x88,0x88,0x88,0x88,0x88,0x40,0x00,0x00,0x18,0x88,0x40,0x00,0x68,
	0x87,0x00,0x00,0x78,0x87,0x00,0x00,0x18,0x88,0x30,0x00,0x88,0x60,
	0x08,0x87,0x00,0x78,0x70,0x00,0x68,0x88,0x10,0x01,0x88,0x86,0x00,
	0x00,0x68,0x88,0x10,0x00,0x58,0x88,0x30,0x00,0x03,0x88,0x88,0x88,
	0x88,0x85,0x00,0x00,0x00,0x00,0x0f,0xff,0xfc,0x00,0x00,0x00,0x00,
	0x06,0xf2,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0xff,0xf0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x6f,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0c,0xcc,0xca,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xac,0xcc,0xc0,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x5a,0xbb,0x83,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3d,0xd8,
	0x67,0xbf,0xb1,0x00,0x00,0x8d,0xdd,0x10,0x00,0x1d,0xdd,0x80,0x00,
	0x0b,0xdd,0xdd,0xdd,0xc9,0x20,0x00,0x00,0x00,0x17,0xbc,0xca,0x50,
	0x00,0x00,0x00,0x0d,0xdd,0xdd,0xdb,0x71,0x00,0x00,0x00,0x4d,0xdd,
	0xdd,0xdd,0xdd,0x30,0x00,0x00,0x00,0xbd,0xda,0x00,0x00,0x00,0x00,
	0x00,0x00,0x17,0xac,0xcb,0x83,0x00,0x00,0x00,0x1d,0xdd,0x60,0x00,
	0x9d,0xdc,0x00,0x00,0x00,0x0d,0xdd,0x80,0x00,0x00,0x00,0x00,0x00,
	0x17,0xbc,0xc8,0x20,0x00,0x00,0x00,0x4d,0xdd,0x30,0x00,0xad,0xdd,
	0x70,0x00,0x01,0xdd,0xdd,0xdd,0xdd,0xd0,0x00,0x02,0xdd,0xa0,0x1d,
	0xda,0x01,0xdd,0xb0,0x00,0x0b,0xdd,0x60,0x00,0x6d,0xdd,0x20,0x00,
	0x00,0x17,0xac,0xca,0x61,0x00,0x00,0x00,0x02,0xe8,0x00,0x00,0x02,
	0xbc,0x10,0x00,0x3f,0xff,0x40,0x00,0x5f,0xff,0x30,0x00,0x0c,0xff,
	0xff,0xff,0xff,0xf2,0x00,0x00,0x04,0xef,0xff,0xff,0xfa,0x00,0x00,
	0x00,0x0f,0xff,0xff,0xff,0xfe,0x20,0x00,0x00,0x5f,0xff,0xff,0xff,
	0xff,0x40,0x00,0x00,0x00,0xcf,0xfb,0x00,0x00,0x00,0x00,0x00,0x03,
	0xef,0xff,0xff,0xff,0xa2,0x00,0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,
	0x00,0x00,0x00,0x0e,0xff,0x90,0x00,0x00,0x00,0x00,0x01,0xef,0xff,
	0xff,0xf3,0x00,0x00,0x00,0x5f,0xff,0x40,0x04,0xff,0xfe,0x10,0x00,
	0x01,0xff,0xff,0xff,0xff,0xf0,0x00,0x02,0xff,0xb0,0x5f,0xff,0x11,
	0xff,0xc0,0x00,0x0c,0xff,0x70,0x02,0xff,0xff,0x20,0x00,0x03,0xef,
	0xff,0xff,0xfd,0x20,0x00,0x00,0x0b,0x83,0xdf,0x89,0xfb,0x20,0x00,
	0x00,0x0d,0xff,0xff,0xff,0xff,0xfd,0x00,0x00,0x0c,0xff,0xe8,0x8b,
	0xff,0xf9,0x00,0x00,0x2e,0xff,0xfe,0xff,0xff,0x70,0x00,0x00,0x0f,
	0xff,0xeb,0xdf,0xff,0xc0,0x00,0x00,0x5f,0xff,0xcb,0xbb,0xbb,0x30,
	0x00,0x00,0x00,0xcf,0xfb,0x00,0x00,0x00,0x00,0x00,0x1e,0xff,0xfc,
	0xbe,0xff,0xf9,0x00,0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,0x00,0x00,
	0x00,0x0e,0xff,0x90,0x00,0x00,0x00,0x00,0x09,0xff,0xfe,0xff,0xfd,
	0x00,0x00,0x00,0x5f,0xff,0x40,0x0b,0xff,0xf5,0x00,0x00,0x01,0xff,
	0xff,0xee,0xee,0xe0,0x00,0x02,0xff,0xb0,0x9f,0xff,0x41,0xff,0xc0,
	0x00,0x0c,0xff,0x70,0x0c,0xff,0xff,0x20,0x00,0x2e,0xff,0xfd,0xef,
	0xff,0xd1,0x00,0x00,0x3f,0x2e,0xc3,0xbf,0xb8,0xe3,0x00,0x00,0x07,
	0xff,0xff,0xff,0xff,0xf7,0x00,0x00,0x0c,0xff,0xb0,0x00,0xdf,0xfb,
	0x00,0x00,0x8f,0xff,0x40,0x1b,0xff,0xe0,0x00,0x00,0x0f,0xff,0x80,
	0x08,0xff,0xf3,0x00,0x00,0x5f,0xff,0x40,0x00,0x00,0x00,0x00,0x00,
	0x00,0xcf,0xfb,0x00,0x00,0x00,0x00,0x00,0x8f,0xff,0x40,0x00,0xaf,
	0xf9,0x00,0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,0x00,0x00,0x00,0x0e,
	0xff,0x90,0x00,0x00,0x00,0x00,0x0e,0xff,0x90,0x8f,0xff,0x20,0x00,
	0x00,0x5f,0xff,0xc1,0x4f,0xff,0xc0,0x00,0x00,0x01,0xff,0xf7,0x00,
	0x00,0x00,0x00,0x02,0xff,0xb0,0xdf,0xff,0x81,0xff,0xc0,0x00,0x0c,
	0xff,0x70,0x7f,0xff,0xff,0x20,0x00,0x8f,0xff,0x50,0x07,0xff,0xf6,
	0x00,0x00,0x6b,0x4f,0x50,0x2f,0xa0,0x8c,0x00,0x00,0x02,0xff,0xfa,
	0x7a,0xff,0xf2,0x00,0x00,0x0c,0xff,0xc2,0x24,0xff,0xf8,0x00,0x00,
	0xdf,0xfb,0x00,0x02,0xe9,0x50,0x00,0x00,0x0f,0xff,0x80,0x02,0xff,
	0xf6,0x00,0x00,0x5f,0xff,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0xcf,
	0xfc,0x33,0x33,0x10,0x00,0x00,0xdf,0xfc,0x00,0x67,0xbf,0xf9,0x00,
	0x00,0x1f,0xff,0x94,0x44,0xcf,0xfd,0x00,0x00,0x00,0x0e,0xff,0x90,
	0x00,0x00,0x00,0x00,0x05,0x79,0x40,0x5f,0xff,0x30,0x00,0x00,0x5f,
	0xff,0xfc,0xcf,0xff,0x20,0x00,0x00,0x01,0xff,0xf7,0x00,0x00,0x00,
	0x00,0x02,0xff,0xb2,0xff,0xff,0xc1,0xff,0xc0,0x00,0x0c,0xff,0x73,
	0xff,0xff,0xff,0x20,0x00,0xdf,0xfb,0x00,0x00,0xef,0xfa,0x00,0x00,
	0x7a,0x5f,0x50,0x0d,0xd0,0x1f,0x20,0x00,0x00,0xbf,0xf8,0x09,0xff,
	0xb0,0x00,0x00,0x0c,0xff,0xff,0xff,0xff,0xb1,0x00,0x00,0xff,0xf9,
	0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0x80,0x01,0xff,0xf7,0x00,
	0x00,0x5f,0xff,0xff,0xff,0xfa,0x00,0x00,0x00,0x00,0xcf,0xff,0xff,
	0xff,0x30,0x00,0x00,0xff,0xf9,0x00,0xcf,0xff,0xf9,0x00,0x00,0x1f,
	0xff,0xff,0xff,0xff,0xfd,0x00,0x00,0x00,0x0e,0xff,0x90,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x5f,0xff,0x40,0x00,0x00,0x5f,0xff,0xff,
	0xff,0xf8,0x00,0x00,0x00,0x01,0xff,0xf7,0x00,0x00,0x00,0x00,0x02,
	0xff,0xb5,0xff,0x8f,0xf2,0xff,0xc0,0x00,0x0c,0xff,0x8d,0xff,0xcf,
	0xff,0x20,0x00,0xff,0xf9,0x00,0x00,0xcf,0xfc,0x00,0x00,0x7a,0x3f,
	0x70,0x0a,0xf0,0x0d,0x50,0x00,0x00,0x5f,0xfc,0x0e,0xff,0x50,0x00,
	0x00,0x0c,0xff,0xff,0xff,0xfd,0x30,0x00,0x00,0xff,0xf8,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0f,0xff,0x80,0x01,0xff,0xf7,0x00,0x00,0x5f,
	0xff,0xff,0xff,0xfa,0x00,0x00,0x00,0x00,0xcf,0xff,0xff,0xff,0x30,
	0x00,0x00,0xff,0xf9,0x00,0xbd,0xdd,0xd8,0x00,0x00,0x1f,0xff,0xff,
	0xff,0xff,0xfd,0x00,0x00,0x00,0x0e,0xff,0x90,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x5f,0xff,0x40,0x00,0x00,0x5f,0xff,0xff,0xff,0xe1,
	0x00,0x00,0x00,0x01,0xff,0xf7,0x00,0x00,0x00,0x00,0x02,0xff,0xb9,
	0xfd,0x2f,0xf6,0xff,0xc0,0x00,0x0c,0xff,0xef,0xfd,0x4f,0xff,0x20,
	0x00,0xff,0xf9,0x00,0x00,0xcf,0xfc,0x00,0x00,0x6c,0x0e,0xb0,0x09,
	0xf2,0x0d,0x50,0x00,0x00,0x1f,0xff,0x5f,0xff,0x10,0x00,0x00,0x0c,
	0xff,0xc1,0x18,0xff,0xe1,0x00,0x00,0xef,0xfa,0x00,0x01,0x20,0x00,
	0x00,0x00,0x0f,0xff,0x80,0x04,0xff,0xf5,0x00,0x00,0x5f,0xff,0x75,
	0x55,0x53,0x00,0x00,0x00,0x00,0xcf,0xfc,0x22,0x22,0x00,0x00,0x00,
	0xdf,0xfb,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,0xc8,0x88,0xdf,
	0xfd,0x00,0x00,0x00,0x0e,0xff,0x90,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x5f,0xff,0x40,0x00,0x00,0x5f,0xff,0xcf,0xff,0xb0,0x00,0x00,
	0x00,0x01,0xff,0xf7,0x00,0x00,0x00,0x00,0x02,0xff,0xbe,0xf9,0x0e,
	0xfa,0xff,0xc0,0x00,0x0c,0xff,0xff,0xf4,0x3f,0xff,0x20,0x00,0xef,
	0xfb,0x00,0x00,0xef,0xfb,0x00,0x00,0x2f,0x28,0xf3,0x0c,0xf4,0x0f,
	0x30,0x00,0x00,0x09,0xff,0xef,0xf9,0x00,0x00,0x00,0x0c,0xff,0xb0,
	0x05,0xff,0xf3,0x00,0x00,0xaf,0xff,0x20,0x07,0xfe,0x90,0x00,0x00,
	0x0f,0xff,0x91,0x3c,0xff,0xf1,0x00,0x00,0x5f,0xff,0x40,0x00,0x00,
	0x00,0x00,0x00,0x00,0xcf,0xfb,0x00,0x00,0x00,0x00,0x00,0x9f,0xff,
	0x20,0x02,0xc9,0x62,0x00,0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,0x00,
	0x00,0x00,0x0e,0xff,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5f,
	0xff,0x40,0x00,0x00,0x5f,0xff,0x4a,0xff,0xfa,0x00,0x00,0x00,0x01,
	0xff,0xf7,0x00,0x00,0x00,0x00,0x02,0xff,0xef,0xf5,0x09,0xfe,0xff,
	0xc0,0x00,0x0c,0xff,0xff,0x80,0x3f,0xff,0x20,0x00,0x9f,0xff,0x30,
	0x06,0xff,0xf7,0x00,0x00,0x0a,0xa0,0xbf,0xea,0xf6,0x5e,0x10,0x00,
	0x00,0x03,0xff,0xff,0xf4,0x00,0x00,0x00,0x0c,0xff,0xeb,0xcf,0xff,
	0xf2,0x00,0x00,0x3f,0xff,0xfa,0xbf,0xff,0x80,0x00,0x00,0x0f,0xff,
	0xff,0xff,0xff,0x90,0x00,0x00,0x5f,0xff,0xed,0xdd,0xdd,0x20,0x00,
	0x00,0x00,0xcf,0xff,0xdd,0xdd,0xd0,0x00,0x00,0x2f,0xff,0xe9,0x8e,
	0xff,0xf3,0x00,0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,0x00,0x00,0x00,
	0x0e,0xff,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5f,0xff,0x40,
	0x00,0x00,0x5f,0xff,0x41,0xcf,0xff,0x90,0x00,0x00,0x01,0xff,0xf7,
	0x00,0x00,0x00,0x00,0x02,0xff,0xff,0xf1,0x05,0xff,0xff,0xc0,0x00,
	0x0c,0xff,0xfd,0x10,0x3f,0xff,0x20,0x00,0x3f,0xff,0xfb,0xcf,0xff,
	0xe1,0x00,0x00,0x02,0xe9,0x13,0x30,0x14,0xe6,0x00,0x00,0x00,0x00,
	0xdf,0xff,0xe0,0x00,0x00,0x00,0x0c,0xff,0xff,0xff,0xff,0x90,0x00,
	0x00,0x06,0xff,0xff,0xff,0xfc,0x10,0x00,0x00,0x0f,0xff,0xff,0xff,
	0xfa,0x10,0x00,0x00,0x5f,0xff,0xff,0xff,0xff,0x20,0x00,0x00,0x00,
	0xcf,0xff,0xff,0xff,0xe0,0x00,0x00,0x05,0xff,0xff,0xff,0xff,0x90,
	0x00,0x00,0x1f,0xff,0x70,0x00,0xaf,0xfd,0x00,0x00,0x00,0x0e,0xff,
	0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5f,0xff,0x40,0x00,0x00,
	0x5f,0xff,0x40,0x1e,0xff,0xf9,0x00,0x00,0x01,0xff,0xf7,0x00,0x00,
	0x00,0x00,0x02,0xff,0xff,0xc0,0x01,0xff,0xff,0xc0,0x00,0x0c,0xff,
	0xf3,0x00,0x3f,0xff,0x20,0x00,0x06,0xff,0xff,0xff,0xff,0x40,0x00,
	0x00,0x00,0x3d,0xe9,0x77,0xbf,0x70,0x00,0x00,0x00,0x00,0x58,0x88,
	0x50,0x00,0x00,0x00,0x07,0x88,0x88,0x88,0x84,0x00,0x00,0x00,0x00,
	0x3a,0xef,0xfc,0x71,0x00,0x00,0x00,0x08,0x88,0x88,0x87,0x30,0x00,
	0x00,0x00,0x38,0x88,0x88,0x88,0x88,0x10,0x00,0x00,0x00,0x78,0x88,
	0x88,0x88,0x80,0x00,0x00,0x00,0x29,0xdf,0xff,0xc6,0x00,0x00,0x00,
	0x18,0x88,0x40,0x00,0x68,0x87,0x00,0x00,0x00,0x08,0x88,0x50,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x4c,0xcc,0x30,0x00,0x00,0x38,0x88,
	0x20,0x03,0x88,0x88,0x30,0x00,0x01,0x88,0x84,0x00,0x00,0x00,0x00,
	0x01,0x88,0x88,0x50,0x00,0x78,0x88,0x70,0x00,0x07,0x88,0x50,0x00,
	0x28,0x88,0x10,0x00,0x00,0x39,0xef,0xfd,0x92,0x00,0x00,0x00,0x00,
	0x00,0x5a,0xbb,0x82,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x18,0xcc,0xb7,0x10,0x00,0x00,0x00,0x00,
	0x00,0x08,0xdd,0x80,0x00,0x00,0x00,0x0a,0xdd,0xdd,0xdd,0xdd,0xa0,
	0x00,0x00,0x00,0x2b,0xff,0xfe,0x81,0x00,0x00,0x00,0x00,0x00,0x02,
	0xdd,0x80,0x00,0x00,0x00,0x00,0x3b,0xff,0xfd,0x70,0x00,0x00,0x00,
	0x00,0x07,0xdf,0xfe,0x91,0x00,0x00,0x00,0x00,0x07,0xdd,0x80,0x00,
	0x00,0x00,0x00,0x00,0x39,0xbc,0xc9,0x40,0x00,0x00,0x00,0x00,0x18,
	0xbc,0xb7,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xbf,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x69,0x95,0x00,0x00,
	0x00,0x00,0x02,0xef,0xff,0xff,0xc1,0x00,0x00,0x00,0x00,0x00,0x09,
	0xff,0x90,0x00,0x00,0x00,0x07,0xff,0xff,0xff,0xff,0xb0,0x00,0x00,
	0x02,0xef,0xfe,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x02,0xff,0x90,
	0x00,0x00,0x00,0x03,0xff,0xfe,0xff,0xfa,0x00,0x00,0x00,0x00,0x9f,
	0xff,0xff,0xfd,0x00,0x00,0x00,0x00,0x06,0xff,0xb0,0x00,0x00,0x00,
	0x00,0x04,0xff,0xff,0xff,0xf7,0x00,0x00,0x00,0x01,0xdf,0xff,0xff,
	0xe2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0b,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x71,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaf,0xf7,0x00,0x00,0x00,0x00,
	0x0a,0xff,0xc6,0xef,0xf7,0x00,0x00,0x00,0x00,0x00,0x09,0xff,0x90,
	0x00,0x00,0x00,0x01,0xef,0xff,0xbb,0xbb,0x80,0x00,0x00,0x0b,0xff,
	0xa0,0x1e,0xff,0x50,0x00,0x00,0xbb,0xbb,0xbc,0xff,0xeb,0x10,0x00,
	0x00,0x0c,0xff,0xa0,0x1e,0xff,0x30,0x00,0x00,0x03,0xff,0xe2,0x1b,
	0xff,0x60,0x00,0x00,0x00,0x03,0xff,0xe0,0x00,0x00,0x00,0x00,0x0d,
	0xff,0xb2,0x8f,0xff,0x10,0x00,0x00,0x08,0xff,0xd2,0x8f,0xfc,0x00,
	0x00,0x00,0x00,0x29,0x99,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x9c,
	0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0xef,0x00,0x00,0x00,0x00,
	0x01,0x11,0x11,0x11,0x11,0x00,0x00,0x00,0x00,0x00,0xfe,0x60,0x00,
	0x00,0x00,0x00,0x00,0x00,0xaf,0xf7,0x00,0x00,0x00,0x00,0x1f,0xff,
	0x20,0x6f,0xfc,0x00,0x00,0x00,0x00,0x00,0x09,0xff,0x90,0x00,0x00,
	0x00,0x00,0x4f,0xff,0x90,0x00,0x00,0x00,0x00,0x03,0x57,0x30,0x0a,
	0xff,0x80,0x00,0x00,0xef,0xff,0xff,0xff,0xff,0x10,0x00,0x00,0x02,
	0x45,0x20,0x0a,0xff,0x80,0x00,0x00,0x08,0xff,0x90,0x06,0xff,0x90,
	0x00,0x00,0x00,0x00,0xef,0xf2,0x00,0x00,0x00,0x00,0x1f,0xff,0x20,
	0x0e,0xff,0x40,0x00,0x00,0x00,0x13,0x20,0x1f,0xff,0x20,0x00,0x00,
	0x00,0x4f,0xff,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xf5,0x00,
	0x00,0x00,0x00,0x00,0x06,0xdf,0xff,0x00,0x00,0x00,0x00,0x0b,0xff,
	0xff,0xff,0xfb,0x00,0x00,0x00,0x00,0x00,0xff,0xfd,0x60,0x00,0x00,
	0x00,0x00,0x00,0x23,0x31,0x00,0x00,0x00,0x00,0x3f,0xff,0x00,0x3f,
	0xff,0x00,0x00,0x00,0x00,0x00,0x09,0xff,0x90,0x00,0x00,0x00,0x00,
	0x04,0xff,0xfd,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x0d,0xff,0x70,
	0x00,0x00,0xef,0xfb,0xbc,0xff,0xeb,0x10,0x00,0x00,0x00,0x00,0x00,
	0x0b,0xff,0x80,0x00,0x00,0x0b,0xff,0x90,0x07,0xff,0x90,0x00,0x00,
	0x00,0x00,0x8f,0xf7,0x00,0x00,0x00,0x00,0x0f,0xff,0x40,0x1f,0xff,
	0x30,0x00,0x00,0x00,0x29,0xcb,0x4d,0xff,0x60,0x00,0x00,0x00,0x4f,
	0xff,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xf5,0x00,0x00,0x00,
	0x00,0x05,0xdf,0xff,0xb4,0x00,0x00,0x00,0x00,0x0b,0xff,0xff,0xff,
	0xfb,0x00,0x00,0x00,0x00,0x00,0x4c,0xff,0xfd,0x50,0x00,0x00,0x00,
	0x00,0x8f,0xf7,0x00,0x00,0x00,0x00,0x4f,0xfd,0x00,0x2f,0xff,0x10,
	0x00,0x00,0x00,0x00,0x09,0xff,0x90,0x00,0x00,0x00,0x00,0x00,0x2d,
	0xff,0xf4,0x00,0x00,0x00,0x00,0x00,0x2c,0xef,0xfe,0x10,0x00,0x00,
	0x6f,0xf7,0x02,0xff,0x90,0x00,0x00,0x00,0x05,0xcf,0xb4,0x6f,0xff,
	0x40,0x00,0x00,0x0c,0xff,0xf6,0x5e,0xff,0x50,0x00,0x00,0x00,0x00,
	0x2f,0xfd,0x00,0x00,0x00,0x00,0x08,0xff,0xd7,0xcf,0xfb,0x00,0x00,
	0x00,0x02,0xef,0xff,0xfe,0xff,0x70,0x00,0x00,0x00,0x28,0x88,0x10,
	0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x83,0x00,0x00,0x00,0x00,0x0e,
	0xff,0xb4,0x00,0x00,0x00,0x00,0x00,0x05,0x66,0x66,0x66,0x65,0x00,
	0x00,0x00,0x00,0x00,0x00,0x4b,0xff,0xe0,0x00,0x00,0x00,0x00,0x6f,
	0xfe,0x20,0x00,0x00,0x00,0x5f,0xfd,0x00,0x2f,0xff,0x10,0x00,0x00,
	0x00,0xb6,0x09,0xff,0x90,0x00,0x00,0x00,0x00,0x00,0x01,0xaf,0xff,
	0x20,0x00,0x00,0x00,0x00,0x1f,0xff,0xc1,0x00,0x00,0x00,0x08,0xff,
	0x42,0xff,0x90,0x00,0x00,0x00,0x05,0xff,0xff,0xff,0xfa,0x00,0x00,
	0x00,0x0c,0xff,0xef,0xff,0xfa,0x00,0x00,0x00,0x00,0x00,0x08,0xff,
	0x60,0x00,0x00,0x00,0x00,0x9f,0xff,0xff,0xd1,0x00,0x00,0x00,0x0a,
	0xff,0xa3,0x8f,0xff,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0xff,0x82,
	0x00,0x00,0x00,0x00,0x00,0x03,0x44,0x44,0x44,0x43,0x00,0x00,0x00,
	0x00,0x00,0x00,0x28,0xff,0xe0,0x00,0x00,0x00,0x00,0x0b,0xff,0xe4,
	0x00,0x00,0x00,0x4f,0xfe,0x00,0x2f,0xff,0x00,0x00,0x00,0x00,0xef,
	0xdc,0xff,0x90,0x00,0x00,0x00,0x00,0x01,0x10,0x0c,0xff,0x80,0x00,
	0x00,0x00,0x00,0x05,0xbf,0xf8,0x00,0x00,0x00,0x00,0xbf,0xf5,0xff,
	0x90,0x00,0x00,0x00,0x03,0xff,0xc9,0xba,0x60,0x00,0x00,0x00,0x0a,
	0xff,0x86,0xbb,0x60,0x00,0x00,0x00,0x00,0x00,0x01,0xdf,0xe2,0x00,
	0x00,0x00,0x04,0xff,0xd7,0xcf,0xf7,0x00,0x00,0x00,0x0e,0xff,0x20,
	0x0e,0xff,0x60,0x00,0x00,0x00,0x27,0x77,0x10,0x00,0x00,0x00,0x00,
	0x00,0x00,0x77,0x73,0x00,0x00,0x00,0x00,0x07,0xef,0xff,0x92,0x00,
	0x00,0x00,0x00,0x0b,0xff,0xff,0xff,0xfb,0x00,0x00,0x00,0x00,0x00,
	0x29,0xff,0xfe,0x70,0x00,0x00,0x00,0x00,0x00,0x9f,0xff,0x20,0x00,
	0x00,0x2f,0xff,0x10,0x5f,0xfc,0x00,0x00,0x00,0x00,0xcf,0xff,0xff,
	0x90,0x00,0x00,0x00,0x07,0xff,0xc0,0x08,0xff,0xa0,0x00,0x00,0x03,
	0x69,0x40,0x2f,0xff,0x00,0x00,0x00,0x00,0x1c,0xff,0xff,0x90,0x00,
	0x00,0x00,0x01,0xff,0xc1,0x11,0x11,0x00,0x00,0x00,0x07,0xff,0xb0,
	0x04,0x31,0x00,0x00,0x00,0x01,0x22,0x22,0x5f,0xfc,0x10,0x00,0x00,
	0x0a,0xff,0x50,0x2f,0xfe,0x00,0x00,0x00,0x0e,0xff,0x10,0x0e,0xff,
	0x30,0x00,0x00,0x00,0x4f,0xff,0x20,0x00,0x00,0x00,0x00,0x00,0x00,
	0xff,0xf5,0x00,0x00,0x00,0x00,0x00,0x18,0xff,0xff,0x00,0x00,0x00,
	0x00,0x0b,0xff,0xff,0xff,0xfb,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
	0x81,0x00,0x00,0x00,0x01,0xce,0xf1,0x0d,0xff,0x60,0x00,0x00,0x0d,
	0xff,0x82,0xcf,0xf8,0x00,0x00,0x00,0x00,0x04,0xdf,0xff,0x90,0x00,
	0x00,0x00,0x03,0xff,0xf9,0x8f,0xff,0x70,0x00,0x00,0x07,0xff,0xc4,
	0x9f,0xfe,0x00,0x00,0x00,0x00,0x02,0xef,0xff,0x90,0x00,0x00,0x00,
	0x00,0xef,0xff,0xff,0xff,0x00,0x00,0x00,0x01,0xff,0xf5,0x5f,0xff,
	0x30,0x00,0x00,0x08,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x09,0xff,
	0x80,0x6f,0xfd,0x00,0x00,0x00,0x0a,0xff,0x80,0x6f,0xfd,0x00,0x00,
	0x00,0x00,0x4f,0xff,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xf5,
	0x00,0x00,0x00,0x00,0x00,0x00,0x29,0xff,0x00,0x00,0x00,0x00,0x03,
	0x44,0x44,0x44,0x43,0x00,0x00,0x00,0x00,0x00,0xff,0x92,0x00,0x00,
	0x00,0x00,0x00,0xef,0xfb,0x7f,0xff,0x50,0x00,0x00,0x04,0xff,0xff,
	0xff,0xe1,0x00,0x00,0x00,0x00,0x00,0x1c,0xff,0x90,0x00,0x00,0x00,
	0x00,0x9f,0xff,0xff,0xfc,0x10,0x00,0x00,0x01,0xcf,0xff,0xff,0xf5,
	0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x90,0x00,0x00,0x00,0x00,0xbf,
	0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x5f,0xff,0xff,0xf8,0x00,0x00,
	0x00,0x08,0xff,0xff,0xff,0xff,0xb0,0x00,0x00,0x03,0xff,0xff,0xff,
	0xf6,0x00,0x00,0x00,0x02,0xff,0xff,0xff,0xf4,0x00,0x00,0x00,0x00,
	0x2a,0xaa,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0xa4,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa2,0x00,0x00,0x00,0x00,0x00,
	0x00,0x6f,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x4b,0xef,0xea,0x20,
	0x00,0x00,0x00,0x00,0x00,0x03,0xbb,0x70,0x00,0x00,0x00,0x00,0x05,
	0x9b,0xba,0x61,0x00,0x00,0x00,0x00,0x06,0xab,0xb9,0x30,0x00,0x00,
	0x00,0x00,0x00,0x05,0xbb,0x70,0x00,0x00,0x00,0x00,0x58,0x88,0x88,
	0x88,0x00,0x00,0x00,0x00,0x02,0x8b,0xba,0x50,0x00,0x00,0x00,0x05,
	0x88,0x88,0x88,0x88,0x60,0x00,0x00,0x00,0x3a,0xef,0xec,0x50,0x00,
	0x00,0x00,0x00,0x2a,0xef,0xeb,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,
	0xcf,0xfd,0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x07,0xf9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xf7,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x95,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x22,0x20,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xdd,0xd3,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xcc,0x13,0xcc,
	0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x80,0x00,0x00,0x00,0x00,0x00,
	0x9e,0x10,0x00,0x6d,0xec,0x40,0x00,0x01,0x7b,0xcc,0xa6,0x11,0x83,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2f,0xf2,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0xff,0x20,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0xef,0x60,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xff,0xf2,0x00,0x00,0x00,
	0x00,0x00,0x08,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xef,0xf4,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x31,0xff,0x20,0x00,
	0x00,0x00,0x00,0x02,0x5b,0xc6,0x20,0x00,0x00,0x00,0x00,0x2f,0x80,
	0x04,0xfe,0x6f,0xf2,0x00,0x2e,0xff,0xff,0xff,0xee,0xfe,0x20,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xbf,0xc0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xcf,0xb0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0x62,0x00,0x00,0x00,
	0x00,0x00,0x00,0x1e,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x04,0xff,0xf2,0x00,0x00,0x00,0x00,0x00,
	0x06,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xde,0xe3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0xcf,0x71,0xef,0x61,0x10,0x00,0x00,
	0x00,0x8f,0xff,0xff,0xf9,0x00,0x00,0x00,0x00,0x08,0xf2,0x09,0xf8,
	0x0b,0xf7,0x00,0xaf,0xfe,0x54,0x9f,0xff,0xfd,0x30,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0x70,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x7f,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x4f,0xf4,0x00,0x00,0x00,0x00,0x00,
	0x02,0x9d,0xf2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x04,0xff,0xf2,0x00,0x00,0x00,0x00,0x00,0x03,0xf6,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x24,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x0b,0xff,0xff,0xff,0xff,0xb0,0x00,0x00,0x06,0xff,
	0xfc,0xcc,0xff,0x70,0x00,0x00,0x00,0x01,0xea,0x0a,0xf8,0x0b,0xf7,
	0x00,0xcf,0xf5,0x01,0xaf,0xff,0xf1,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x08,0xff,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3f,0xf8,0x00,0x00,0x00,0x00,0x04,0x90,0xa2,0x00,0x00,
	0x00,0x00,0x00,0x00,0x4f,0xf4,0x00,0x00,0x00,0x00,0x00,0x04,0xff,
	0xf2,0x00,0x00,0x00,0x00,0x00,0x01,0x33,0x33,0x10,0x00,0x00,0x00,
	0x00,0x00,0x11,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0xea,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x8f,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0b,0xff,0xff,0xff,0xff,0xb0,0x00,0x00,0x08,0xce,0x87,0x92,
	0xff,0xd0,0x00,0x00,0x00,0x00,0x7f,0x36,0xfc,0x4e,0xf3,0x00,0x9f,
	0xfa,0x1c,0xff,0xff,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0b,0xff,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x1f,0xfb,0x00,0x00,0x00,0x00,0x09,0xf8,0xf6,0x00,0x00,0x00,0x00,
	0x02,0x66,0x9f,0xf9,0x66,0x20,0x00,0x00,0x00,0x04,0xff,0xf2,0x00,
	0x00,0x00,0x00,0x00,0x05,0xff,0xff,0x40,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xae,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9f,0xe0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x4f,0xf2,0x5f,0xf2,0x10,0x00,0x00,0x00,0x00,0x08,0xba,0xff,0xc0,
	0x00,0x00,0x00,0x00,0x0d,0xb0,0x8f,0xff,0x60,0x00,0x1d,0xff,0xff,
	0xfe,0x3c,0xa5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0d,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xfd,
	0x00,0x00,0x00,0x00,0x14,0xdf,0xc4,0x10,0x00,0x00,0x00,0x04,0xff,
	0xff,0xff,0xff,0x40,0x00,0x00,0x00,0x02,0x88,0x81,0x00,0x00,0x00,
	0x00,0x00,0x05,0xff,0xff,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x20,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xbf,0xf1,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf3,
	0x1f,0xf2,0x00,0x00,0x00,0x00,0x06,0xbf,0xff,0xff,0x60,0x00,0x00,
	0x6b,0xb7,0x15,0xf4,0x01,0x20,0x00,0x00,0x01,0x9f,0xff,0xf6,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0d,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xfd,0x00,0x00,
	0x00,0x00,0x5f,0xef,0xdf,0x40,0x00,0x00,0x00,0x04,0xff,0xff,0xff,
	0xff,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x02,0x55,0x55,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x3f,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xdf,0xf3,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0xff,0xff,0xff,0xff,
	0xb0,0x00,0x00,0x00,0xbf,0xff,0xff,0xc5,0x00,0x00,0x07,0xfd,0xbf,
	0xa0,0xcd,0x00,0x00,0x00,0x00,0x00,0x8f,0xff,0xff,0x70,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0xff,0x10,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xfb,0x00,0x00,0x00,0x00,
	0x15,0x4f,0x25,0x10,0x00,0x00,0x00,0x00,0x11,0x4f,0xf4,0x11,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0f,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0xff,0xf5,0x00,0x00,0x00,0x00,0x00,0x15,
	0x51,0x05,0x51,0x00,0x00,0x00,0x0b,0xff,0xff,0xff,0xff,0xb0,0x00,
	0x00,0x04,0xff,0xfd,0xb2,0x00,0x00,0x00,0x0e,0xf4,0x1f,0xf2,0x4f,
	0x60,0x00,0x00,0x00,0x01,0xff,0xe2,0x9f,0xf3,0x00,0x00,0x00,0x00,
	0x00,0x35,0x40,0x00,0x00,0x00,0x00,0x08,0xff,0x40,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x4f,0xf8,0x00,0x00,0x00,0x00,0x00,0x4b,
	0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x4f,0xf4,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0b,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0xff,0xf5,0x00,0x00,0x00,0x00,0x00,0x4f,0xf4,0x3f,
	0xf5,0x00,0x00,0x00,0x02,0x37,0xfd,0x38,0xfc,0x20,0x00,0x00,0x05,
	0xff,0xa7,0x95,0x75,0x20,0x00,0x0f,0xf3,0x0f,0xf2,0x0b,0xe1,0x00,
	0x00,0x00,0x01,0xff,0xc0,0x3f,0xf6,0x00,0x00,0x00,0x00,0x00,0xbf,
	0xc0,0x00,0x00,0x00,0x00,0x03,0xff,0x70,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x7f,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x4f,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xf2,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0xff,0xf5,0x00,0x00,0x00,0x00,0x00,0x8f,0xf7,0x6f,0xf9,0x00,
	0x00,0x00,0x00,0x03,0xff,0x14,0xfe,0x00,0x00,0x00,0x01,0xff,0xfc,
	0xdf,0xff,0x40,0x00,0x0b,0xf7,0x4f,0xe1,0x02,0xf7,0x00,0x00,0x00,
	0x00,0xcf,0xfc,0xef,0xf2,0x00,0x00,0x00,0x00,0x00,0xff,0xf1,0x00,
	0x00,0x00,0x00,0x00,0xbf,0xd0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xcf,0xb0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xf6,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x88,
	0x83,0x00,0x00,0x00,0x00,0x00,0x9f,0xf8,0x7f,0xfa,0x00,0x00,0x00,
	0x00,0x00,0xff,0x31,0xff,0x20,0x00,0x00,0x00,0x4d,0xff,0xff,0xe6,
	0x00,0x00,0x02,0xdf,0xfe,0x40,0x00,0x9e,0x10,0x00,0x00,0x00,0x19,
	0xef,0xfb,0x40,0x00,0x00,0x00,0x00,0x01,0xff,0xf2,0x00,0x00,0x00,
	0x00,0x00,0x3f,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xff,
	0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf9,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x8c,0xc7,0x6c,0xc8,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3a,0xb3,0x10,0x00,0x00,
	0x00,0x03,0x31,0x00,0x00,0x14,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0xcc,0xc1,0x00,0x00,0x00,0x00,0x00,
	0x07,0xfa,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0xf7,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xff,0xff,0xf0,0x00,0x07,0xbf,0xff,0xff,0xff,0xff,0xf0,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,
	0xfb,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0x00,0x00,
	0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xff,0xff,0xf0,0x00,0xbf,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xfb,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
	0xf0,0x07,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0x70,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,
	0xff,0x00,0x00,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
	0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0b,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xb0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xaf,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xfa,0x00,0x00,0x00,0x00,
	0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,
	0x00,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,
	0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,
	0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaf,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xfa,0x00,0x00,0x00,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x0f,
	0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0xb0,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0b,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x0a,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,
	0xff,0xff,0xff,0xff,0xff,0xff,0xa2,0x00,0x00,0xff,0xff,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,
	0xff,0xff,0xff,0xff,0xf2,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,
	0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xff,0xff,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf2,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0xb0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0b,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
	0x00,0x00,0x00,0x0a,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xa2,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,
	0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xaf,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xfa,0x00,0x00,
	0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
	0x00,0x00,0x0b,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,
	0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xb0,
	0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,
	0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xaf,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xfa,0x00,0x00,0x00,0x00,0xff,
	0xff,0xff,0xff,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0x00,0x00,
	0x07,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0x70,0x0f,0xff,
	0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,
	0xff,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xbf,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xfb,0x00,0x0f,0xff,0xff,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xbf,0xff,
	0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,
	0xff,0xff,0xff,0xff,0xfb,0x70,0x00,0x0f,0xff,0xff,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x00,0x00,0x7b,0xff,0xff,0xff,0xff,0xf0,0x0f,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xfb,
	0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0f,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x00,0x0b,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,
	0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xfb,0x00,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0xff,0xff,0xff,0xff,
	0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,
	0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x00,0x7f,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0x70,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0xff,0xff,0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xa0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x22,0xbf,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xb0,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xa0,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x22,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x22,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,
	0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x00,
	0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,
	0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,
	0xff,0xff,0xff,0xff,0xf0,0x22,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,
	0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x00,0xff,
	0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,
	0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,
	0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf0,0x22,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,
	0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,
	0xff,0xff,0xff,0xff,0xff,0xa0,0x00,0x00,0x00,0x00,0xff,0xff,0x00,
	0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
	0xff,0xff,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x22,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,
	0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,
	0xff,0xff,0xa0,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,
	0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x22,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xa0,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x0b,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xb0,0x0f,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x22,0xff,0xff,
	0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xa0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,
	0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0x70,0x0f,0xff,0xff,
	0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x22,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0f,0xff,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xbf,0xff,
	0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
	0x0f,0xff,0xff,0xff,0xff,0xff,0xfb,0x00,0x0f,0xff,0xff,0xff,0xff,
	0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,
	0xff,0xff,0xff,0xff,0xff,0xf0,0x22,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0f,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xbf,0xff,0xff,
	0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x0f,0xff,
	0xff,0xff,0xff,0xfb,0x70,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,
	0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xf0,0x22,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x11,
	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,
	0xff,0xf0,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

#endif//MENUFONT_H
```

`mainui/udll_int.cpp`:

```cpp
/*
dll_int.cpp - dll entry point
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"

ui_enginefuncs_t	g_engfuncs;
ui_textfuncs_t	g_textfuncs;
ui_globalvars_t	*gpGlobals;
CMenu gMenu;

static UI_FUNCTIONS gFunctionTable = 
{
	UI_VidInit,
	UI_Init,
	UI_Shutdown,
	UI_UpdateMenu,
	UI_KeyEvent,
	UI_MouseMove,
	UI_SetActiveMenu,
	UI_AddServerToList,
	UI_GetCursorPos,
	UI_SetCursorPos,
	UI_ShowCursor,
	UI_CharEvent,
	UI_MouseInRect,
	UI_IsVisible,
	UI_CreditsActive,
	UI_FinalCredits
};

#ifdef _WIN32
#define EXPORT __declspec(dllexport)
#else
#define EXPORT
#endif

//=======================================================================
//			GetApi
//=======================================================================
extern "C" EXPORT int GetMenuAPI(UI_FUNCTIONS *pFunctionTable, ui_enginefuncs_t* pEngfuncsFromEngine, ui_globalvars_t *pGlobals)
{
	if( !pFunctionTable || !pEngfuncsFromEngine )
	{
		return FALSE;
	}

	// copy HUD_FUNCTIONS table to engine, copy engfuncs table from engine
	memcpy( pFunctionTable, &gFunctionTable, sizeof( UI_FUNCTIONS ));
	memcpy( &g_engfuncs, pEngfuncsFromEngine, sizeof( ui_enginefuncs_t ));
	memset( &g_textfuncs, 0, sizeof( ui_textfuncs_t ));

	gpGlobals = pGlobals;

	return TRUE;
}

extern "C" EXPORT int GiveTextAPI( ui_textfuncs_t* pTextfuncsFromEngine )
{
	if( !pTextfuncsFromEngine )
	{
		return FALSE;
	}

	// copy HUD_FUNCTIONS table to engine, copy engfuncs table from engine
	memcpy( &g_textfuncs, pTextfuncsFromEngine, sizeof( ui_textfuncs_t ));

	return TRUE;
}

extern "C" EXPORT void AddTouchButtonToList( const char *name, const char *texture, const char *command, unsigned char *color, int flags )
{
	UI_TouchButtons_AddButtonToList( name, texture, command, color, flags );
}


```

`mainui/ui_title_anim.cpp`:

```cpp
#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "ui_title_anim.h"

#define BANNER_X_FIX	-16
#define BANNER_Y_FIX	-20

// Title Transition Time period
#define TTT_PERIOD		200.0f

ui_quad_t TitleLerpQuads[2];
int transition_initial_time;
int transition_state;
HIMAGE TransPic = 0;
int PreClickDepth;
bool hold_button_stack = false;

void UI_TACheckMenuDepth( void )
{
	PreClickDepth = uiStatic.menuDepth;
}

menuPicButton_s *ButtonStack[UI_MAX_MENUDEPTH];
int ButtonStackDepth;

void UI_PopPButtonStack()
{
	if( hold_button_stack ) return;

	if ( ButtonStack[ButtonStackDepth] ) UI_SetTitleAnim( AS_TO_BUTTON, ButtonStack[ButtonStackDepth] );
	if ( ButtonStackDepth ) ButtonStackDepth--;
}

void UI_PushPButtonStack( menuPicButton_s *button )
{
	if( ButtonStack[ButtonStackDepth] == button )
		return;

	ButtonStackDepth++;
	ButtonStack[ButtonStackDepth] = button;
}

float UI_GetTitleTransFraction( void )
{
	float fraction = (float)(uiStatic.realTime - transition_initial_time ) / TTT_PERIOD;

	if( fraction > 1.0f )
		fraction = 1.0f;

	return fraction;
}

void LerpQuad( ui_quad_t a, ui_quad_t b, float frac, ui_quad_t *c )
{
	c->x = a.x + (b.x - a.x) * frac;
	c->y = a.y + (b.y - a.y) * frac;
	c->lx = a.lx + (b.lx - a.lx) * frac;
	c->ly = a.ly + (b.ly - a.ly) * frac;
}

void UI_SetupTitleQuad()
{
	TitleLerpQuads[1].x  = UI_BANNER_POSX * ScreenHeight / 768;
	TitleLerpQuads[1].y  = UI_BANNER_POSY * ScreenHeight / 768;
	TitleLerpQuads[1].lx = UI_BANNER_WIDTH * ScreenHeight / 768;
	TitleLerpQuads[1].ly = UI_BANNER_HEIGHT * ScreenHeight / 768;
}

void UI_DrawTitleAnim()
{
	UI_SetupTitleQuad();

	if( !TransPic ) return;

	wrect_t r = { 0, uiStatic.buttons_width, 26, 51 };

	float frac = UI_GetTitleTransFraction();/*(sin(gpGlobals->time*4)+1)/2*/;

#ifdef TA_ALT_MODE
	if( frac == 1 && transition_state == AS_TO_BUTTON )
		return;
#else
	if( frac == 1 ) return;
#endif

	ui_quad_t c;
	
	int f_idx = (transition_state == AS_TO_TITLE) ? 0 : 1;
	int s_idx = (transition_state == AS_TO_TITLE) ? 1 : 0;

	LerpQuad( TitleLerpQuads[f_idx], TitleLerpQuads[s_idx], frac, &c );

	PIC_Set( TransPic, 255, 255, 255, 255 );
	PIC_DrawAdditive( c.x, c.y, c.lx, c.ly, &r );
}

void UI_SetTitleAnim( int anim_state, menuPicButton_s *button )
{
	// skip buttons which don't call new menu
	if( !button || ( PreClickDepth == uiStatic.menuDepth && anim_state == AS_TO_TITLE ) )
		return;

	// replace cancel\done button with button which called this menu 
	if( PreClickDepth > uiStatic.menuDepth && anim_state == AS_TO_TITLE ) 
	{
		anim_state = AS_TO_BUTTON;

		// HACK HACK HACK
		if ( ButtonStack[ButtonStackDepth + 1] )
			button = ButtonStack[ButtonStackDepth+1];
	}	

	// don't reset anim if dialog buttons pressed
	if( button->generic.id == ID_YES || button->generic.id == ID_NO )
		return;

	if( anim_state == AS_TO_TITLE )
		UI_PushPButtonStack( button );

	transition_state = anim_state;

	TitleLerpQuads[0].x = button->generic.x;
	TitleLerpQuads[0].y = button->generic.y;
	TitleLerpQuads[0].lx = button->generic.width;
	TitleLerpQuads[0].ly = button->generic.height;
	
	transition_initial_time = uiStatic.realTime;
	TransPic = button->pic;
}

void UI_InitTitleAnim()
{
	memset( TitleLerpQuads, 0, sizeof( ui_quad_t ) * 2 );

	UI_SetupTitleQuad();

	ButtonStackDepth = 0;
	memset( ButtonStack, 0, sizeof( ButtonStack ));
}

void UI_ClearButtonStack( void )
{
	ButtonStackDepth = 0;
	memset( ButtonStack, 0, sizeof( ButtonStack ));
}

```

`mainui/ui_title_anim.h`:

```h
#define AS_TO_TITLE		1
#define AS_TO_BUTTON	2

void UI_SetTitleAnim( int anim_state, menuPicButton_s *picid );
void UI_DrawTitleAnim( void );
void UI_InitTitleAnim( void );
void UI_TACheckMenuDepth( void );
float UI_GetTitleTransFraction( void );

typedef struct  
{
	int x, y, lx, ly;
} ui_quad_t;

void UI_PopPButtonStack( void );
void UI_ClearButtonStack( void );

// использовать кусок из btns_main.bmp заместо head_%s.bmp
//#define TA_ALT_MODE 1

```

`mainui/utils.cpp`:

```cpp
/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/


// ui_qmenu.c -- Quake menu framework

#include "extdll.h"
#include "basemenu.h"
#include "utils.h"
#include "keydefs.h"
#include "menu_btnsbmp_table.h"
//CR
#include "ui_title_anim.h"

#ifdef _DEBUG
void DBG_AssertFunction( BOOL fExpr, const char* szExpr, const char* szFile, int szLine, const char* szMessage )
{
	if( fExpr ) return;

	char szOut[512];
	if( szMessage != NULL )
		sprintf( szOut, "ASSERT FAILED:\n %s \n(%s@%d)\n%s", szExpr, szFile, szLine, szMessage );
	else sprintf( szOut, "ASSERT FAILED:\n %s \n(%s@%d)", szExpr, szFile, szLine );
	HOST_ERROR( szOut );
}
#endif	// DEBUG

void AddSpaces(char *s, int size)
{
	int len = strlen(s);

	size += len - ColorStrlen(s);

	while( len < size - 1 )
	{	
		s[len] = ' ';
		len++;
	}
	s[len] = '\0';
}

int ColorStrlen( const char *str )
{
	const char *p;

	if( !str )
		return 0;

	int len = 0;
	p = str;
	UtfProcessChar( 0 );
	while( *p )
	{
		if( IsColorString( p ))
		{
			p += 2;
			continue;
		}

		p++;
		if( UtfProcessChar( (unsigned char) *p ) )
			len++;
	}
	len++;

	return len;
}

void StringConcat( char *dst, const char *src, size_t size )
{
	register char *d = dst;
	register const char *s = src;
	register size_t n = size;
	size_t dlen;

	if( !dst || !src || !size )
		return;

#if 0
	// find the end of dst and adjust bytes left but don't go past end
	while(n-- != 0 && *d != '\0') d++;
	dlen = d - dst;
#else
	// VERY UNSAFE. SURE THAT DST IS BIG
	dlen = ColorStrlen( dst );
	d += strlen( dst );
#endif

	n = size - dlen;

	if ( n == 0 ) return;
	while ( *s != '\0' )
	{
		if ( n != 1 )
		{
			*d++ = *s;
			n--;
		}
		s++;
	}

	*d = '\0';
	return;
}

char *StringCopy( const char *input )
{
	if( !input ) return NULL;

	char *out = (char *)MALLOC( strlen( input ) + 1 );
	strcpy( out, input );

	return out;
}

/*
============
COM_CompareSaves
============
*/
int COM_CompareSaves( const void **a, const void **b )
{
	char *file1, *file2;

	file1 = (char *)*a;
	file2 = (char *)*b;

	int bResult;

	COMPARE_FILE_TIME( file2, file1, &bResult );

	return bResult;
}

/*
============
COM_FileBase
============
*/
// Extracts the base name of a file (no path, no extension, assumes '/' as path separator)
void COM_FileBase ( const char *in, char *out )
{
	int len, start, end;

	len = strlen( in );
	
	// scan backward for '.'
	end = len - 1;
	while ( end && in[end] != '.' && in[end] != '/' && in[end] != '\\' )
		end--;
	
	if ( in[end] != '.' )		// no '.', copy to end
		end = len-1;
	else 
		end--;			// Found ',', copy to left of '.'


	// Scan backward for '/'
	start = len-1;
	while ( start >= 0 && in[start] != '/' && in[start] != '\\' )
		start--;

	if ( in[start] != '/' && in[start] != '\\' )
		start = 0;
	else 
		start++;

	// Length of new sting
	len = end - start + 1;

	// Copy partial string
	strncpy( out, &in[start], len );
	// Terminate it
	out[len] = 0;
}

/*
===============
Info_ValueForKey

Searches the string for the given
key and returns the associated value, or an empty string.
===============
*/
char *Info_ValueForKey( const char *s, const char *key )
{
	char	pkey[MAX_INFO_STRING];
	static	char value[2][MAX_INFO_STRING]; // use two buffers so compares work without stomping on each other
	static	int valueindex;
	char	*o;
	
	valueindex ^= 1;
	if( *s == '\\' ) s++;
	printf("I_VFK '%s' '%s'\n", s, key );

	while( 1 )
	{
		o = pkey;
		while( *s != '\\' && *s != '\n' )
		{
			if( !*s ) return "";
			*o++ = *s++;
		}

		*o = 0;
		s++;

		o = value[valueindex];

		while( *s != '\\' && *s != '\n' && *s )
		{
			if( !*s ) return "";
			*o++ = *s++;
		}
		*o = 0;

		if( !strcmp( key, pkey ))
			return value[valueindex];
		if( !*s ) return "";
		s++;
	}
}


/* 
===================
Key_GetKey
===================
*/
int KEY_GetKey( const char *binding )
{
	const char *b;

	if ( !binding )
		return -1;

	for ( int i = 0; i < 256; i++ )
	{
		b = KEY_GetBinding( i );
		if( !b ) continue;

		if( !stricmp( binding, b ))
			return i;
	}
	return -1;
}

/*
================
UI_FadeAlpha
================
*/
int UI_FadeAlpha( int starttime, int endtime )
{
	int	time, fade_time;

	if( starttime == 0 )
	{
		return 0xFFFFFFFF;
	}

	time = ( gpGlobals->time * 1000 ) - starttime;

	if( time >= endtime )
	{
		return 0x00FFFFFF;
	}

	// fade time is 1/4 of endtime
	fade_time = endtime / 4;
	fade_time = bound( 300, fade_time, 10000 );

	int alpha;

	// fade out
	if(( endtime - time ) < fade_time )
		alpha = bound( 0, (( endtime - time ) * 1.0f / fade_time ) * 255, 255 );
	else alpha = 255;

	return PackRGBA( 255, 255, 255, alpha );
}

void UI_UtilSetupPicButton( menuPicButton_s *pic, int ID )
{
	if( ID < 0 || ID > PC_BUTTONCOUNT )
		return; // bad id

#if 0	// too different results on various games. disabled
	pic->generic.width = PicButtonWidth( ID ) * UI_BUTTON_CHARWIDTH;
#else
	pic->generic.width = UI_BUTTONS_WIDTH;
#endif
	pic->generic.height = UI_BUTTONS_HEIGHT;

	pic->pic = uiStatic.buttonsPics[ID];
	pic->button_id = ID;

	if( pic->pic ) // text buttons not use it
		pic->generic.flags|= QMF_ACT_ONRELEASE;
}

/*
=================
UI_ScrollList_Init
=================
*/
void UI_ScrollList_Init( menuScrollList_s *sl )
{
	if( !sl->generic.name ) sl->generic.name = "";

	sl->generic.charWidth = 1;
	sl->generic.charHeight = 1;
	if( sl->generic.flags & QMF_BIGFONT )
	{
		sl->generic.charWidth = UI_BIG_CHAR_WIDTH;
		sl->generic.charHeight = UI_BIG_CHAR_HEIGHT;
	}
	else if( sl->generic.flags & QMF_SMALLFONT )
	{
		sl->generic.charWidth = UI_SMALL_CHAR_WIDTH;
		sl->generic.charHeight = UI_SMALL_CHAR_HEIGHT;
	}
	else
	{
		if( sl->generic.charWidth < 1 ) sl->generic.charWidth = UI_MED_CHAR_WIDTH;
		if( sl->generic.charHeight < 1 ) sl->generic.charHeight = UI_MED_CHAR_HEIGHT;
	}

	UI_ScaleCoords( NULL, NULL, &sl->generic.charWidth, &sl->generic.charHeight );

	if( sl->generic.charWidth < 1 ) sl->generic.charWidth = 1;
	if( sl->generic.charHeight < 1 ) sl->generic.charHeight = 1;

	if(!(sl->generic.flags & (QMF_LEFT_JUSTIFY|QMF_CENTER_JUSTIFY|QMF_RIGHT_JUSTIFY)))
		sl->generic.flags |= QMF_LEFT_JUSTIFY;

	if( !sl->generic.color ) sl->generic.color = uiPromptTextColor;
	if( !sl->generic.focusColor ) sl->generic.focusColor = uiPromptFocusColor;
	if( !sl->upArrow ) sl->upArrow = UI_UPARROW;
	if( !sl->upArrowFocus ) sl->upArrowFocus = UI_UPARROWFOCUS;
	if( !sl->downArrow ) sl->downArrow = UI_DOWNARROW;
	if( !sl->downArrowFocus ) sl->downArrowFocus = UI_DOWNARROWFOCUS;

//	sl->curItem = 0;
	sl->topItem = 0;
	sl->numItems = 0;
	sl->highlight = -1;

	// count number of items
	while( sl->itemNames[sl->numItems] )
		sl->numItems++;

	// scale the center box
	sl->generic.x2 = sl->generic.x;
	sl->generic.y2 = sl->generic.y;
	sl->generic.width2 = sl->generic.width;
	sl->generic.height2 = sl->generic.height;
	UI_ScaleCoords( &sl->generic.x2, &sl->generic.y2, &sl->generic.width2, &sl->generic.height2 );

	// calculate number of visible rows
	sl->numRows = (sl->generic.height2 / sl->generic.charHeight) - 2;
	if( sl->numRows > sl->numItems ) sl->numRows = sl->numItems;

	// extend the height so it has room for the arrows
	sl->generic.height += (sl->generic.width / 4);

	// calculate new Y for the control
	sl->generic.y -= (sl->generic.width / 8);

	UI_ScaleCoords( &sl->generic.x, &sl->generic.y, &sl->generic.width, &sl->generic.height );
}
/*
=================
UI_ScrollList_Key
=================
*/
const char *UI_ScrollList_Key( menuScrollList_s *sl, int key, int down )
{
	const char	*sound = 0;
	int		arrowWidth, arrowHeight, upX, upY, downX, downY;
	int		i, y;
	bool noscroll = false;

	if( !down )
	{
		sl->scrollBarSliding = false;
		return uiSoundNull;
	}

	switch( key )
	{
	case K_MOUSE1:
		noscroll = true; // don't scroll to current when mouse used
		if(!( sl->generic.flags & QMF_HASMOUSEFOCUS ))
			break;

		// use fixed size for arrows
		arrowWidth = 24;
		arrowHeight = 24;

		UI_ScaleCoords( NULL, NULL, &arrowWidth, &arrowHeight );

		// glue with right top and right bottom corners
		upX = sl->generic.x2 + sl->generic.width2 - arrowWidth;
		upY = sl->generic.y2 + UI_OUTLINE_WIDTH;
		downX = sl->generic.x2 + sl->generic.width2 - arrowWidth;
		downY = sl->generic.y2 + (sl->generic.height2 - arrowHeight) - UI_OUTLINE_WIDTH;

		// ADAMIX
		if( UI_CursorInRect( upX, upY + arrowHeight, arrowWidth, sl->scrollBarY - upY - arrowHeight ) ||
			  UI_CursorInRect( upX, sl->scrollBarY + sl->scrollBarHeight , arrowWidth, downY - ( sl->scrollBarY + sl->scrollBarHeight ) ) )
		{
			sl->scrollBarSliding = true;
			//break;
		}
		// ADAMIX END

		// Now see if either up or down has focus
		if( UI_CursorInRect( upX, upY, arrowWidth, arrowHeight ))
		{
			if( sl->topItem > 5 )
			{
				sl->topItem-=5;
				sound = uiSoundMove;
			}
			else
			{
				sl->topItem = 0;
				sound = uiSoundBuzz;
			}
			break;
		}
		else if( UI_CursorInRect( downX, downY, arrowWidth, arrowHeight ))
		{
			if( sl->topItem < sl->numItems - sl->numRows - 5 )
			{
				sl->topItem+=5;
				sound = uiSoundMove;
			}
			else
			{
				sl->topItem = sl->numItems - sl->numRows;
				sound = uiSoundBuzz;
			}
			break;
		}

		// see if an item has been selected
		y = sl->generic.y2 + sl->generic.charHeight;
		for( i = sl->topItem; i < sl->topItem + sl->numRows; i++, y += sl->generic.charHeight )
		{
			if( !sl->itemNames[i] )
				break; // done

			if( UI_CursorInRect( sl->generic.x, y, sl->generic.width - arrowWidth, sl->generic.charHeight ))
			{
				sl->curItem = i;
				sound = uiSoundNull;
				break;
			}
		}
		break;
	case K_HOME:
	case K_KP_HOME:
		if( sl->curItem != 0 )
		{
			sl->curItem = 0;
			sound = uiSoundMove;
		}
		else sound = uiSoundBuzz;
		break;
	case K_END:
	case K_KP_END:
		if( sl->curItem != sl->numItems - 1 )
		{
			sl->curItem = sl->numItems - 1;
			sound = uiSoundMove;
		}
		else sound = uiSoundBuzz;
		break;
	case K_PGUP:
	case K_KP_PGUP:
		if( sl->curItem != 0 )
		{
			sl->curItem -= 2;
			if( sl->curItem < 0 )
				sl->curItem = 0;
			sound = uiSoundMove;
		}
		else sound = uiSoundBuzz;
		break;
	case K_PGDN:
	case K_KP_PGDN:
		if( sl->curItem != sl->numItems - 1 )
		{
			sl->curItem += 2;
			if( sl->curItem > sl->numItems - 1 )
				sl->curItem = sl->numItems - 1;
			sound = uiSoundMove;
		}
		else sound = uiSoundBuzz;
		break;
	case K_UPARROW:
	case K_KP_UPARROW:
	case K_MWHEELUP:
		if( sl->curItem != 0 )
		{
			sl->curItem--;
			sound = uiSoundMove;
		}
		else sound = uiSoundBuzz;
		break;
	case K_DOWNARROW:
	case K_MWHEELDOWN:
		if( sl->numItems > 0 && sl->curItem != sl->numItems - 1 )
		{
			sl->curItem++;
			sound = uiSoundMove;
		}
		else sound = uiSoundBuzz;
		break;
	}
	if( !noscroll )
	{
		if( sl->curItem < sl->topItem )
			sl->topItem = sl->curItem;
		if( sl->curItem > sl->topItem + sl->numRows - 1 )
			sl->topItem = sl->curItem - sl->numRows + 1;
		if( sl->topItem < 0 ) sl->topItem = 0;
		if( sl->topItem > sl->numItems - sl->numRows )
			sl->topItem = sl->numItems - sl->numRows;
	}

	if( sound && ( sl->generic.flags & QMF_SILENT ))
		sound = uiSoundNull;

	if( sound && sl->generic.callback )
	{
		if( sound != uiSoundBuzz )
			sl->generic.callback( sl, QM_CHANGED );
	}
	return sound;
}

/*
=================
UI_ScrollList_Draw
=================
*/
void UI_ScrollList_Draw( menuScrollList_s *sl )
{
	int	justify = 0;
	int	shadow;
	int	i, x, y, w, h;
	int	selColor = 0xFF503818; // Red 80, Green 56, Blue 24, Alpha 255
	int	arrowWidth, arrowHeight, upX, upY, downX, downY;
	int	upFocus, downFocus, scrollbarFocus;

	if( sl->generic.flags & QMF_LEFT_JUSTIFY )
		justify = 0;
	else if( sl->generic.flags & QMF_CENTER_JUSTIFY )
		justify = 1;
	else if( sl->generic.flags & QMF_RIGHT_JUSTIFY )
		justify = 2;

	shadow = (sl->generic.flags & QMF_DROPSHADOW);

	// use fixed size for arrows
	arrowWidth = 24;
	arrowHeight = 24;

	UI_ScaleCoords( NULL, NULL, &arrowWidth, &arrowHeight );

	x = sl->generic.x2;
	y = sl->generic.y2;
	w = sl->generic.width2;
	h = sl->generic.height2;

	if( !sl->background )
	{
		// draw the opaque outlinebox first
		UI_FillRect( x, y, w, h, uiColorBlack );
	}

	// hightlight the selected item
	if( !( sl->generic.flags & QMF_GRAYED ))
	{
		y = sl->generic.y2 + sl->generic.charHeight;
		for( i = sl->topItem; i < sl->topItem + sl->numRows; i++, y += sl->generic.charHeight )
		{
			if( !sl->itemNames[i] )
				break;		// Done
			// hightlighted item
			if( i == sl->highlight )
			{
				UI_FillRect( sl->generic.x, y, sl->generic.width - arrowWidth, sl->generic.charHeight, 0xFF383838 );
			}

			if( i == sl->curItem )
			{
				UI_FillRect( sl->generic.x, y, sl->generic.width - arrowWidth, sl->generic.charHeight, selColor );
			}
		}
	}

	if( sl->background )
	{
		// get size and position for the center box
		UI_DrawPic( x, y, w, h, uiColorWhite, sl->background );
	}
	else
	{

		int color;

		if( sl->generic.flags & QMF_HIGHLIGHTIFFOCUS && sl->generic.flags & QMF_HASKEYBOARDFOCUS )
			color = uiInputTextColor;
		else
			color = uiInputFgColor;

		x = sl->generic.x2 - UI_OUTLINE_WIDTH;
		y = sl->generic.y2;
		w = UI_OUTLINE_WIDTH;
		h = sl->generic.height2;

		// draw left
		UI_FillRect( x, y, w, h, color );

		x = sl->generic.x2 + sl->generic.width2;
		y = sl->generic.y2;
		w = UI_OUTLINE_WIDTH;
		h = sl->generic.height2;

		// draw right
		UI_FillRect( x, y, w, h, color );

		x = sl->generic.x2;
		y = sl->generic.y2;
		w = sl->generic.width2 + UI_OUTLINE_WIDTH;
		h = UI_OUTLINE_WIDTH;

		// draw top
		UI_FillRect( x, y, w, h, color );

		// draw bottom
		x = sl->generic.x2;
		y = sl->generic.y2 + sl->generic.height2 - UI_OUTLINE_WIDTH;
		w = sl->generic.width2 + UI_OUTLINE_WIDTH;
		h = UI_OUTLINE_WIDTH;

		UI_FillRect( x, y, w, h, color );
	}

	// glue with right top and right bottom corners
	upX = sl->generic.x2 + sl->generic.width2 - arrowWidth;
	upY = sl->generic.y2 + UI_OUTLINE_WIDTH;
	downX = sl->generic.x2 + sl->generic.width2 - arrowWidth;
	downY = sl->generic.y2 + (sl->generic.height2 - arrowHeight) - UI_OUTLINE_WIDTH;

	float step = (sl->numItems <= 1 ) ? 1 : (downY - upY - arrowHeight) / (float)(sl->numItems - 1);

	if( cursorDown && !sl->scrollBarSliding )
	{
		if( UI_CursorInRect( sl->generic.x2, sl->generic.y2, sl->generic.width2 - arrowWidth, sl->generic.height2 ))
		{
			static float ac_y = 0;
			ac_y += cursorDY;
			cursorDY = 0;
			if( ac_y > sl->generic.charHeight / 2.0f )
			{
				sl->topItem -= ac_y/ sl->generic.charHeight - 0.5;
				if( sl->topItem < 0 )
					sl->topItem = 0;
				ac_y = 0;
			}
			if( ac_y < -sl->generic.charHeight / 2.0f )
			{
				sl->topItem -= ac_y/ sl->generic.charHeight - 0.5 ;
				if( sl->topItem > sl->numItems - sl->numRows )
					sl->topItem = sl->numItems - sl->numRows;
				ac_y = 0;
			}
		}
		else if( UI_CursorInRect( sl->scrollBarX, sl->scrollBarY, sl->scrollBarWidth, sl->scrollBarHeight ))
		{
			static float ac_y = 0;
			ac_y += cursorDY;
			cursorDY = 0;
			if( ac_y < -step )
			{
				sl->topItem += ac_y / step + 0.5;
				if( sl->topItem < 0 )
					sl->topItem = 0;
				ac_y = 0;
			}
			if( ac_y > step )
			{
				sl->topItem += ac_y / step + 0.5;
				if( sl->topItem > sl->numItems - sl->numRows )
					sl->topItem = sl->numItems - sl->numRows;
				ac_y = 0;
			}
		}

	}

	// draw the arrows base
	UI_FillRect( upX, upY + arrowHeight, arrowWidth, downY - upY - arrowHeight, uiInputFgColor );


	// ADAMIX
	sl->scrollBarX = upX + sl->generic.charHeight/4;
	sl->scrollBarWidth = arrowWidth - sl->generic.charHeight/4;

	if(((downY - upY - arrowHeight) - (((sl->numItems-1)*sl->generic.charHeight)/2)) < 2)
	{
		sl->scrollBarHeight = (downY - upY - arrowHeight) - (step * (sl->numItems - sl->numRows));
		sl->scrollBarY = upY + arrowHeight + (step*sl->topItem);
	}
	else
	{
		sl->scrollBarHeight = downY - upY - arrowHeight - (((sl->numItems- sl->numRows) * sl->generic.charHeight) / 2);
		sl->scrollBarY = upY + arrowHeight + (((sl->topItem) * sl->generic.charHeight)/2);
	}

	if( sl->scrollBarSliding )
	{
		int dist = uiStatic.cursorY - sl->scrollBarY - (sl->scrollBarHeight>>1);

		if((((dist / 2) > (sl->generic.charHeight / 2)) || ((dist / 2) < (sl->generic.charHeight / 2))) && sl->topItem <= (sl->numItems - sl->numRows ) && sl->topItem >= 0)
		{
			//if(sl->generic.callback)
				//sl->generic.callback( sl, QM_CHANGED );

			if((dist / 2) > ( sl->generic.charHeight / 2 ) && sl->topItem < ( sl->numItems - sl->numRows - 1 ))
			{
				sl->topItem++;
			}

			if((dist / 2) < -(sl->generic.charHeight / 2) && sl->topItem > 0 )
			{
				sl->topItem--;
			}
		}

		//sl->topItem = sl->curItem - sl->numRows + 1;
		if( sl->topItem < 0 ) sl->topItem = 0;
		if( sl->topItem > ( sl->numItems - sl->numRows - 1 ))
			sl->topItem = sl->numItems - sl->numRows - 1;
	}

	if( sl->scrollBarSliding )
	{
		// Draw scrollbar background
		UI_FillRect ( sl->scrollBarX, upY + arrowHeight, sl->scrollBarWidth, downY - upY - arrowHeight, uiColorBlack);
	}

	// ADAMIX END
	// draw the arrows
	if( sl->generic.flags & QMF_GRAYED )
	{
		UI_DrawPic( upX, upY, arrowWidth, arrowHeight, uiColorDkGrey, sl->upArrow );
		UI_DrawPic( downX, downY, arrowWidth, arrowHeight, uiColorDkGrey, sl->downArrow );
	}
	else
	{
		scrollbarFocus = UI_CursorInRect( sl->scrollBarX, sl->scrollBarY, sl->scrollBarWidth, sl->scrollBarHeight );

		// special case if we sliding but lost focus
		if( sl->scrollBarSliding ) scrollbarFocus = true;

		// Draw scrollbar itself
		UI_FillRect( sl->scrollBarX, sl->scrollBarY, sl->scrollBarWidth, sl->scrollBarHeight, scrollbarFocus ? uiInputTextColor : uiColorBlack );

		if((menuCommon_s *)sl != (menuCommon_s *)UI_ItemAtCursor(sl->generic.parent))
		{
			UI_DrawPic( upX, upY, arrowWidth, arrowHeight, uiColorWhite, sl->upArrow );
			UI_DrawPic( downX, downY, arrowWidth, arrowHeight, uiColorWhite, sl->downArrow );
		}
		else
		{
			// see which arrow has the mouse focus
			upFocus = UI_CursorInRect( upX, upY, arrowWidth, arrowHeight );
			downFocus = UI_CursorInRect( downX, downY, arrowWidth, arrowHeight );

			if(!( sl->generic.flags & QMF_FOCUSBEHIND ))
			{
				UI_DrawPic( upX, upY, arrowWidth, arrowHeight, uiColorWhite, sl->upArrow );
				UI_DrawPic( downX, downY, arrowWidth, arrowHeight, uiColorWhite, sl->downArrow );
			}

			if( sl->generic.flags & QMF_HIGHLIGHTIFFOCUS )
			{
				UI_DrawPic( upX, upY, arrowWidth, arrowHeight, uiColorWhite, (upFocus) ? sl->upArrowFocus : sl->upArrow );
				UI_DrawPic( downX, downY, arrowWidth, arrowHeight, uiColorWhite, (downFocus) ? sl->downArrowFocus : sl->downArrow );
			}
			else if( sl->generic.flags & QMF_PULSEIFFOCUS )
			{
				int	color;

				color = PackAlpha( sl->generic.color, 255 * (0.5 + 0.5 * sin( (float)uiStatic.realTime / UI_PULSE_DIVISOR )));

				UI_DrawPic( upX, upY, arrowWidth, arrowHeight, (upFocus) ? color : sl->generic.color, (upFocus) ? sl->upArrowFocus : sl->upArrow );
				UI_DrawPic( downX, downY, arrowWidth, arrowHeight, (downFocus) ? color : sl->generic.color, (downFocus) ? sl->downArrowFocus : sl->downArrow );
			}

			if( sl->generic.flags & QMF_FOCUSBEHIND )
			{
				UI_DrawPic( upX, upY, arrowWidth, arrowHeight, sl->generic.color, sl->upArrow );
				UI_DrawPic( downX, downY, arrowWidth, arrowHeight, sl->generic.color, sl->downArrow );
			}
		}
	}

	// Draw the list
	x = sl->generic.x2;
	w = sl->generic.width2;
	h = sl->generic.charHeight;
	y = sl->generic.y2 + sl->generic.charHeight;

	// prevent the columns out of rectangle bounds
	PIC_EnableScissor( x, y, sl->generic.width - arrowWidth - uiStatic.outlineWidth, sl->generic.height );

	for( i = sl->topItem; i < sl->topItem + sl->numRows; i++, y += sl->generic.charHeight )
	{
		if( !sl->itemNames[i] )
			break;	// done

		if( sl->generic.flags & QMF_GRAYED )
		{
			UI_DrawString( x, y, w, h, sl->itemNames[i], uiColorDkGrey, true, sl->generic.charWidth, sl->generic.charHeight, justify, shadow );
			continue;	// grayed
		}

		if( i != sl->curItem )
		{
			UI_DrawString( x, y, w, h, sl->itemNames[i], sl->generic.color, false, sl->generic.charWidth, sl->generic.charHeight, justify, shadow );
			continue;	// no focus
		}

		if(!( sl->generic.flags & QMF_FOCUSBEHIND ))
			UI_DrawString( x, y, w, h, sl->itemNames[i], sl->generic.color, false, sl->generic.charWidth, sl->generic.charHeight, justify, shadow );

		if( sl->generic.flags & QMF_HIGHLIGHTIFFOCUS )
			UI_DrawString( x, y, w, h, sl->itemNames[i], sl->generic.focusColor, false, sl->generic.charWidth, sl->generic.charHeight, justify, shadow );
		else if( sl->generic.flags & QMF_PULSEIFFOCUS )
		{
			int	color;

			color = PackAlpha( sl->generic.color, 255 * (0.5 + 0.5 * sin( (float)uiStatic.realTime / UI_PULSE_DIVISOR )));

			UI_DrawString( x, y, w, h, sl->itemNames[i], color, false, sl->generic.charWidth, sl->generic.charHeight, justify, shadow );
		}

		if( sl->generic.flags & QMF_FOCUSBEHIND )
			UI_DrawString( x, y, w, h, sl->itemNames[i], sl->generic.color, false, sl->generic.charWidth, sl->generic.charHeight, justify, shadow );
	}

	PIC_DisableScissor();
}

/*
=================
UI_SpinControl_Init
=================
*/
void UI_SpinControl_Init( menuSpinControl_s *sc )
{
	if( !sc->generic.name ) sc->generic.name = "";	// this is also the text displayed

	if( sc->generic.flags & QMF_BIGFONT )
	{
		sc->generic.charWidth = UI_BIG_CHAR_WIDTH;
		sc->generic.charHeight = UI_BIG_CHAR_HEIGHT;
	}
	else if( sc->generic.flags & QMF_SMALLFONT )
	{
		sc->generic.charWidth = UI_SMALL_CHAR_WIDTH;
		sc->generic.charHeight = UI_SMALL_CHAR_HEIGHT;
	}
	else
	{
		if( sc->generic.charWidth < 1 ) sc->generic.charWidth = UI_MED_CHAR_WIDTH;
		if( sc->generic.charHeight < 1 ) sc->generic.charHeight = UI_MED_CHAR_HEIGHT;
	}

	UI_ScaleCoords( NULL, NULL, &sc->generic.charWidth, &sc->generic.charHeight );

	if(!( sc->generic.flags & (QMF_LEFT_JUSTIFY|QMF_CENTER_JUSTIFY|QMF_RIGHT_JUSTIFY)))
		sc->generic.flags |= QMF_LEFT_JUSTIFY;

	if( !sc->generic.color ) sc->generic.color = uiColorHelp;
	if( !sc->generic.focusColor ) sc->generic.focusColor = uiPromptTextColor;
	if( !sc->leftArrow ) sc->leftArrow = UI_LEFTARROW;
	if( !sc->leftArrowFocus ) sc->leftArrowFocus = UI_LEFTARROWFOCUS;
	if( !sc->rightArrow ) sc->rightArrow = UI_RIGHTARROW;
	if( !sc->rightArrowFocus ) sc->rightArrowFocus = UI_RIGHTARROWFOCUS;

	// scale the center box
	sc->generic.x2 = sc->generic.x;
	sc->generic.y2 = sc->generic.y;
	sc->generic.width2 = sc->generic.width;
	sc->generic.height2 = sc->generic.height;
	UI_ScaleCoords( &sc->generic.x2, &sc->generic.y2, &sc->generic.width2, &sc->generic.height2 );

	// extend the width so it has room for the arrows
	sc->generic.width += (sc->generic.height * 3);

	// calculate new X for the control
	sc->generic.x -= (sc->generic.height + (sc->generic.height/2));

	UI_ScaleCoords( &sc->generic.x, &sc->generic.y, &sc->generic.width, &sc->generic.height );
}

/*
=================
UI_SpinControl_Key
=================
*/
const char *UI_SpinControl_Key( menuSpinControl_s *sc, int key, int down )
{
	const char	*sound = 0;
	int		arrowWidth, arrowHeight, leftX, leftY, rightX, rightY;

	if( !down ) return uiSoundNull;

	switch( key )
	{
	case K_MOUSE1:
	case K_MOUSE2:
		if( !( sc->generic.flags & QMF_HASMOUSEFOCUS ))
			break;

		// calculate size and position for the arrows
		arrowWidth = sc->generic.height + (UI_OUTLINE_WIDTH * 2);
		arrowHeight = sc->generic.height + (UI_OUTLINE_WIDTH * 2);

		leftX = sc->generic.x + UI_OUTLINE_WIDTH;
		leftY = sc->generic.y - UI_OUTLINE_WIDTH;
		rightX = sc->generic.x + (sc->generic.width - arrowWidth) - UI_OUTLINE_WIDTH;
		rightY = sc->generic.y - UI_OUTLINE_WIDTH;

		// now see if either left or right arrow has focus
		if( UI_CursorInRect( leftX, leftY, arrowWidth, arrowHeight ))
		{
			if( sc->curValue > sc->minValue )
			{
				sc->curValue -= sc->range;
				if( sc->curValue < sc->minValue )
					sc->curValue = sc->minValue;
				sound = uiSoundMove;
			}
			else sound = uiSoundBuzz;
		}
		else if( UI_CursorInRect( rightX, rightY, arrowWidth, arrowHeight ))
		{
			if( sc->curValue < sc->maxValue )
			{
				sc->curValue += sc->range;
				if( sc->curValue > sc->maxValue )
					sc->curValue = sc->maxValue;
				sound = uiSoundMove;
			}
			else sound = uiSoundBuzz;
		}
		break;
	case K_LEFTARROW:
	case K_KP_LEFTARROW:
		if( sc->generic.flags & QMF_MOUSEONLY )
			break;
		if( sc->curValue > sc->minValue )
		{
			sc->curValue -= sc->range;
			if( sc->curValue < sc->minValue )
				sc->curValue = sc->minValue;
			sound = uiSoundMove;
		}
		else sound = uiSoundBuzz;
		break;
	case K_RIGHTARROW:
	case K_KP_RIGHTARROW:
		if( sc->generic.flags & QMF_MOUSEONLY )
			break;

		if( sc->curValue < sc->maxValue )
		{
			sc->curValue += sc->range;
			if( sc->curValue > sc->maxValue )
				sc->curValue = sc->maxValue;
			sound = uiSoundMove;
		}
		else sound = uiSoundBuzz;
		break;
	}

	if( sound && ( sc->generic.flags & QMF_SILENT ))
		sound = uiSoundNull;

	if( sound && sc->generic.callback )
	{
		if( sound != uiSoundBuzz )
			sc->generic.callback( sc, QM_CHANGED );
	}
	return sound;
}

/*
=================
UI_SpinControl_Draw
=================
*/
void UI_SpinControl_Draw( menuSpinControl_s *sc )
{
	int	justify = 0;
	int	shadow;
	int	x, y, w, h;
	int	arrowWidth, arrowHeight, leftX, leftY, rightX, rightY;
	int	leftFocus, rightFocus;
	
	if( sc->generic.flags & QMF_LEFT_JUSTIFY )
		justify = 0;
	else if( sc->generic.flags & QMF_CENTER_JUSTIFY )
		justify = 1;
	else if( sc->generic.flags & QMF_RIGHT_JUSTIFY )
		justify = 2;

	shadow = (sc->generic.flags & QMF_DROPSHADOW);

	// calculate size and position for the arrows
	arrowWidth = sc->generic.height + (UI_OUTLINE_WIDTH * 2);
	arrowHeight = sc->generic.height + (UI_OUTLINE_WIDTH * 2);

	leftX = sc->generic.x + UI_OUTLINE_WIDTH;
	leftY = sc->generic.y - UI_OUTLINE_WIDTH;
	rightX = sc->generic.x + (sc->generic.width - arrowWidth) - UI_OUTLINE_WIDTH;
	rightY = sc->generic.y - UI_OUTLINE_WIDTH;

	// get size and position for the center box
	w = sc->generic.width2;
	h = sc->generic.height2;
	x = sc->generic.x2;
	y = sc->generic.y2;

	if( sc->background )
	{
		UI_DrawPic( x, y, w, h, uiColorWhite, sc->background );
	}
	else
	{
		// draw the background
		UI_FillRect( x, y, w, h, uiColorBlack );

		// draw the rectangle
		UI_DrawRectangle( x, y, w, h, uiInputFgColor );
	}

	if( sc->generic.flags & QMF_GRAYED )
	{
		UI_DrawString( x, y, w, h, sc->generic.name, uiColorDkGrey, true, sc->generic.charWidth, sc->generic.charHeight, justify, shadow );
		UI_DrawPic( leftX, leftY, arrowWidth, arrowHeight, uiColorDkGrey, sc->leftArrow );
		UI_DrawPic( rightX, rightY, arrowWidth, arrowHeight, uiColorDkGrey, sc->rightArrow );
		return; // grayed
	}

	if((menuCommon_s *)sc != (menuCommon_s *)UI_ItemAtCursor(sc->generic.parent ))
	{
		UI_DrawString(x, y, w, h, sc->generic.name, sc->generic.color, false, sc->generic.charWidth, sc->generic.charHeight, justify, shadow );
		UI_DrawPic(leftX, leftY, arrowWidth, arrowHeight, sc->generic.color, sc->leftArrow);
		UI_DrawPic(rightX, rightY, arrowWidth, arrowHeight, sc->generic.color, sc->rightArrow);
		return;		// No focus
	}

	// see which arrow has the mouse focus
	leftFocus = UI_CursorInRect( leftX, leftY, arrowWidth, arrowHeight );
	rightFocus = UI_CursorInRect( rightX, rightY, arrowWidth, arrowHeight );

	if( !( sc->generic.flags & QMF_FOCUSBEHIND ))
	{
		UI_DrawString( x, y, w, h, sc->generic.name, sc->generic.color, false, sc->generic.charWidth, sc->generic.charHeight, justify, shadow );
		UI_DrawPic( leftX, leftY, arrowWidth, arrowHeight, sc->generic.color, sc->leftArrow );
		UI_DrawPic( rightX, rightY, arrowWidth, arrowHeight, sc->generic.color, sc->rightArrow );
	}

	if( sc->generic.flags & QMF_HIGHLIGHTIFFOCUS )
	{
		UI_DrawString( x, y, w, h, sc->generic.name, sc->generic.focusColor, false, sc->generic.charWidth, sc->generic.charHeight, justify, shadow );
		UI_DrawPic( leftX, leftY, arrowWidth, arrowHeight, (leftFocus) ? sc->generic.color : sc->generic.color, (leftFocus) ? sc->leftArrowFocus : sc->leftArrow );
		UI_DrawPic( rightX, rightY, arrowWidth, arrowHeight, (rightFocus) ? sc->generic.color : sc->generic.color, (rightFocus) ? sc->rightArrowFocus : sc->rightArrow );
	}
	else if( sc->generic.flags & QMF_PULSEIFFOCUS )
	{
		int	color;

		color = PackAlpha( sc->generic.color, 255 * (0.5 + 0.5 * sin( (float)uiStatic.realTime / UI_PULSE_DIVISOR )));

		UI_DrawString( x, y, w, h, sc->generic.name, color, false, sc->generic.charWidth, sc->generic.charHeight, justify, shadow );
		UI_DrawPic( leftX, leftY, arrowWidth, arrowHeight, (leftFocus) ? color : sc->generic.color, (leftFocus) ? sc->leftArrowFocus : sc->leftArrow );
		UI_DrawPic( rightX, rightY, arrowWidth, arrowHeight, (rightFocus) ? color : sc->generic.color, (rightFocus) ? sc->rightArrowFocus : sc->rightArrow );
	}

	if( sc->generic.flags & QMF_FOCUSBEHIND )
	{
		UI_DrawString( x, y, w, h, sc->generic.name, sc->generic.color, false, sc->generic.charWidth, sc->generic.charHeight, justify, shadow );
		UI_DrawPic( leftX, leftY, arrowWidth, arrowHeight, sc->generic.color, sc->leftArrow );
		UI_DrawPic( rightX, rightY, arrowWidth, arrowHeight, sc->generic.color, sc->rightArrow );
	}
}

/*
=================
UI_Slider_Init
=================
*/
void UI_Slider_Init( menuSlider_s *sl )
{
	if( !sl->generic.name ) sl->generic.name = "";	// this is also the text displayed

	if( !sl->generic.width ) sl->generic.width = 200;
	if( !sl->generic.height) sl->generic.height = 4;
	if( !sl->generic.color ) sl->generic.color = uiColorWhite;
	if( !sl->generic.focusColor ) sl->generic.focusColor = uiColorWhite;
	if( !sl->range ) sl->range = 1.0f;
	if( sl->range < 0.05f ) sl->range = 0.05f;

	if( sl->generic.flags & QMF_BIGFONT )
	{
		sl->generic.charWidth = UI_BIG_CHAR_WIDTH;
		sl->generic.charHeight = UI_BIG_CHAR_HEIGHT;
	}
	else if( sl->generic.flags & QMF_SMALLFONT )
	{
		sl->generic.charWidth = UI_SMALL_CHAR_WIDTH;
		sl->generic.charHeight = UI_SMALL_CHAR_HEIGHT;
	}
	else
	{
		if( sl->generic.charWidth < 1 ) sl->generic.charWidth = 12;
		if( sl->generic.charHeight < 1 ) sl->generic.charHeight = 24;
	}

	UI_ScaleCoords( NULL, NULL, &sl->generic.charWidth, &sl->generic.charHeight );

	if(!(sl->generic.flags & (QMF_LEFT_JUSTIFY|QMF_CENTER_JUSTIFY|QMF_RIGHT_JUSTIFY)))
		sl->generic.flags |= QMF_LEFT_JUSTIFY;

	// scale the center box
	sl->generic.x2 = sl->generic.x;
	sl->generic.y2 = sl->generic.y;
	sl->generic.width2 = sl->generic.width / 5.0f;
	sl->generic.height2 = 4;

	UI_ScaleCoords( &sl->generic.x2, &sl->generic.y2, &sl->generic.width2, &sl->generic.height2 );
	UI_ScaleCoords( &sl->generic.x, &sl->generic.y, &sl->generic.width, &sl->generic.height );

	sl->generic.y -= uiStatic.sliderWidth;
	sl->generic.height += uiStatic.sliderWidth * 2;
	sl->generic.y2 -= uiStatic.sliderWidth;

	sl->numSteps = (sl->maxValue - sl->minValue) / sl->range + 1;
	sl->drawStep = (float)(sl->generic.width - sl->generic.width2) / (float)sl->numSteps;
}

/*
=================
UI_Slider_Key
=================
*/
const char *UI_Slider_Key( menuSlider_s *sl, int key, int down )
{
	int	sliderX;

	if( !down )
	{
		if( sl->keepSlider )
		{
			// tell menu about changes
			if( sl->generic.callback )
				sl->generic.callback( sl, QM_CHANGED );
			sl->keepSlider = false; // button released
		}
		return uiSoundNull;
	}

	switch( key )
	{
	case K_MOUSE1:
		sl->keepSlider = false;
		if( !UI_CursorInRect( sl->generic.x, sl->generic.y - 20, sl->generic.width, sl->generic.height + 40 ) )
			return uiSoundNull;

		// find the current slider position
		sliderX = sl->generic.x2 + (sl->drawStep * (sl->curValue / sl->range));
		sl->keepSlider = true;
		int	dist, numSteps;
		
		// immediately move slider into specified place
		dist = uiStatic.cursorX - sl->generic.x2 - (sl->generic.width2>>2);
		numSteps = round(dist / sl->drawStep);
		sl->curValue = bound( sl->minValue, numSteps * sl->range, sl->maxValue );
		
		// tell menu about changes
		if( sl->generic.callback )
			sl->generic.callback( sl, QM_CHANGED );

		return uiSoundNull;
		break;
	case K_LEFTARROW:
		sl->curValue -= sl->range;

		if( sl->curValue < sl->minValue )
		{
			sl->curValue = sl->minValue;
			return uiSoundBuzz;
		}

		// tell menu about changes
		if( sl->generic.callback )
			sl->generic.callback( sl, QM_CHANGED );

		return uiSoundKey;
		break;
	case K_RIGHTARROW:
		sl->curValue += sl->range;

		if( sl->curValue > sl->maxValue )
		{
			sl->curValue = sl->maxValue;
			return uiSoundBuzz;
		}

		// tell menu about changes
		if( sl->generic.callback )
			sl->generic.callback( sl, QM_CHANGED );

		return uiSoundKey;
		break;
	}

	return 0;
}

/*
=================
UI_Slider_Draw
=================
*/
void UI_Slider_Draw( menuSlider_s *sl )
{
	int	justify = 0;
	int	shadow;
	int	textHeight, sliderX;

	if( sl->generic.flags & QMF_LEFT_JUSTIFY )
		justify = 0;
	else if( sl->generic.flags & QMF_CENTER_JUSTIFY )
		justify = 1;
	else if( sl->generic.flags & QMF_RIGHT_JUSTIFY )
		justify = 2;

	shadow = (sl->generic.flags & QMF_DROPSHADOW);

	if( sl->keepSlider )
	{
		if( !UI_CursorInRect( sl->generic.x, sl->generic.y - 40, sl->generic.width, sl->generic.height + 80 ) )
			sl->keepSlider = false;
		else
		{
			int	dist, numSteps;

			// move slider follow the holded mouse button
			dist = uiStatic.cursorX - sl->generic.x2 - (sl->generic.width2>>2);
			numSteps = round(dist / sl->drawStep);
			sl->curValue = bound( sl->minValue, numSteps * sl->range, sl->maxValue );
			
			// tell menu about changes
			if( sl->generic.callback ) sl->generic.callback( sl, QM_CHANGED );
		}
	}

	// keep value in range
	sl->curValue = bound( sl->minValue, sl->curValue, sl->maxValue );

	// calc slider position
	sliderX = sl->generic.x2 + (sl->drawStep * (sl->curValue / sl->range)); // TODO: fix behaviour when values goes negative
	//sliderX = bound( sl->generic.x2, sliderX, sl->generic.x2 + sl->generic.width - uiStatic.sliderWidth);

	UI_DrawRectangleExt( sl->generic.x, sl->generic.y + uiStatic.sliderWidth, sl->generic.width, sl->generic.height2, uiInputBgColor, uiStatic.sliderWidth );
	if( sl->generic.flags & QMF_HIGHLIGHTIFFOCUS && sl == UI_ItemAtCursor( sl->generic.parent ))
		UI_DrawPic( sliderX, sl->generic.y2, sl->generic.width2, sl->generic.height, uiColorHelp, UI_SLIDER_MAIN );
	else
		UI_DrawPic( sliderX, sl->generic.y2, sl->generic.width2, sl->generic.height, uiColorWhite, UI_SLIDER_MAIN );


	textHeight = sl->generic.y - (sl->generic.charHeight * 1.5f);
	UI_DrawString( sl->generic.x, textHeight, sl->generic.width, sl->generic.charHeight, sl->generic.name, uiColorHelp, true, sl->generic.charWidth, sl->generic.charHeight, justify, shadow );
}

/*
=================
UI_CheckBox_Init
=================
*/
void UI_CheckBox_Init( menuCheckBox_s *cb )
{
	if( !cb->generic.name ) cb->generic.name = "";

	if( cb->generic.flags & QMF_BIGFONT )
	{
		cb->generic.charWidth = UI_BIG_CHAR_WIDTH;
		cb->generic.charHeight = UI_BIG_CHAR_HEIGHT;
	}
	else if( cb->generic.flags & QMF_SMALLFONT )
	{
		cb->generic.charWidth = UI_SMALL_CHAR_WIDTH;
		cb->generic.charHeight = UI_SMALL_CHAR_HEIGHT;
	}
	else
	{
		if( cb->generic.charWidth < 1 ) cb->generic.charWidth = 12;
		if( cb->generic.charHeight < 1 ) cb->generic.charHeight = 24;
	}

	UI_ScaleCoords( NULL, NULL, &cb->generic.charWidth, &cb->generic.charHeight );

	if(!(cb->generic.flags & (QMF_LEFT_JUSTIFY|QMF_CENTER_JUSTIFY|QMF_RIGHT_JUSTIFY)))
		cb->generic.flags |= QMF_LEFT_JUSTIFY;

	if( !cb->emptyPic ) cb->emptyPic = UI_CHECKBOX_EMPTY;
	if( !cb->focusPic ) cb->focusPic = UI_CHECKBOX_FOCUS;
	if( !cb->checkPic ) cb->checkPic = UI_CHECKBOX_ENABLED;
	if( !cb->grayedPic ) cb->grayedPic = UI_CHECKBOX_GRAYED;
	if( !cb->generic.color ) cb->generic.color = uiColorWhite;
	if( !cb->generic.focusColor ) cb->generic.focusColor = uiColorWhite;

	if( !cb->generic.width ) cb->generic.width = 32;
	if( !cb->generic.height ) cb->generic.height = 32;

	UI_ScaleCoords( &cb->generic.x, &cb->generic.y, &cb->generic.width, &cb->generic.height );
}

/*
=================
UI_CheckBox_Key
=================
*/
const char *UI_CheckBox_Key( menuCheckBox_s *cb, int key, int down )
{
	const char	*sound = 0;

	switch( key )
	{
	case K_MOUSE1:
		if(!( cb->generic.flags & QMF_HASMOUSEFOCUS ))
			break;
		sound = uiSoundGlow;
		break;
	case K_ENTER:
	case K_KP_ENTER:
	case K_AUX1:
		//if( !down ) return sound;
		if( cb->generic.flags & QMF_MOUSEONLY )
			break;
		sound = uiSoundGlow;
		break;
	}
	if( sound && ( cb->generic.flags & QMF_SILENT ))
		sound = uiSoundNull;

	if( cb->generic.flags & QMF_ACT_ONRELEASE )
	{
		if( sound && cb->generic.callback )
		{
			int	event;

			if( down )
			{
				event = QM_PRESSED;
				cb->generic.bPressed = true;
			}
			else event = QM_CHANGED;
			if( !down ) cb->enabled = !cb->enabled;	// apply on release
			cb->generic.callback( cb, event );
		}
	}
	else if( down )
	{
		if( sound && cb->generic.callback )
		{
			cb->enabled = !cb->enabled;
			cb->generic.callback( cb, QM_CHANGED );
		}
	}
	return sound;
}

/*
=================
UI_CheckBox_Draw
=================
*/
void UI_CheckBox_Draw( menuCheckBox_s *cb )
{
	int	justify;
	int	shadow;
	int	textOffset, y;

	if( cb->generic.flags & QMF_LEFT_JUSTIFY )
		justify = 0;
	else if( cb->generic.flags & QMF_CENTER_JUSTIFY )
		justify = 1;
	else if( cb->generic.flags & QMF_RIGHT_JUSTIFY )
		justify = 2;

	shadow = (cb->generic.flags & QMF_DROPSHADOW);

	y = cb->generic.y + (cb->generic.height>>2);
	textOffset = cb->generic.x + (cb->generic.width * 1.7f);
	UI_DrawString( textOffset, y, strlen( cb->generic.name ) * cb->generic.charWidth, cb->generic.charHeight, cb->generic.name, uiColorHelp, true, cb->generic.charWidth, cb->generic.charHeight, justify, shadow );

	if( cb->generic.statusText && cb->generic.flags & QMF_NOTIFY )
	{
		int	charW, charH;
		int	x, w;

		charW = UI_SMALL_CHAR_WIDTH;
		charH = UI_SMALL_CHAR_HEIGHT;

		UI_ScaleCoords( NULL, NULL, &charW, &charH );

		x = 250;
		w = UI_SMALL_CHAR_WIDTH * strlen( cb->generic.statusText );
		UI_ScaleCoords( &x, NULL, &w, NULL );
		x += cb->generic.x;

		int	r, g, b;

		UnpackRGB( r, g, b, uiColorHelp );
		TextMessageSetColor( r, g, b );
		DrawConsoleString( x, cb->generic.y, cb->generic.statusText );
	}

	if( cb->generic.flags & QMF_GRAYED )
	{
		UI_DrawPic( cb->generic.x, cb->generic.y, cb->generic.width, cb->generic.height, uiColorWhite, cb->grayedPic );
		return; // grayed
	}

	if(( cb->generic.flags & QMF_MOUSEONLY ) && !( cb->generic.flags & QMF_HASMOUSEFOCUS )
	   || ( (menuCommon_s *)cb != (menuCommon_s *)UI_ItemAtCursor( cb->generic.parent ) ) )
	{
		if( !cb->enabled )
			UI_DrawPic( cb->generic.x, cb->generic.y, cb->generic.width, cb->generic.height, cb->generic.color, cb->emptyPic );
		else UI_DrawPic( cb->generic.x, cb->generic.y, cb->generic.width, cb->generic.height, cb->generic.color, cb->checkPic );
		return; // no focus
	}

	if( cb->generic.flags & QMF_HIGHLIGHTIFFOCUS && !cb->enabled )
	{
		UI_DrawPic( cb->generic.x, cb->generic.y, cb->generic.width, cb->generic.height, cb->generic.focusColor, cb->focusPic );
	}
	else if( !cb->enabled )
	{
		UI_DrawPic( cb->generic.x, cb->generic.y, cb->generic.width, cb->generic.height, cb->generic.color, cb->emptyPic );
	}
	else if( cb->generic.flags & QMF_HIGHLIGHTIFFOCUS )
	{
		// use two textures for it. Second is just focus texture, slightly orange. Looks pretty.
		UI_DrawPic( cb->generic.x, cb->generic.y, cb->generic.width, cb->generic.height, cb->generic.color, UI_CHECKBOX_PRESSED );
		UI_DrawPicAdditive( cb->generic.x, cb->generic.y, cb->generic.width, cb->generic.height, uiInputTextColor, cb->focusPic );
	}
	else
	{
		UI_DrawPic( cb->generic.x, cb->generic.y, cb->generic.width, cb->generic.height, cb->generic.color, cb->checkPic );
	}
}

/*
=================
UI_Field_Init
=================
*/
void UI_Field_Init( menuField_s *f )
{
	if( !f->generic.name ) f->generic.name = "";

	if( f->generic.flags & QMF_BIGFONT )
	{
		f->generic.charWidth = UI_BIG_CHAR_WIDTH;
		f->generic.charHeight = UI_BIG_CHAR_HEIGHT;
	}
	else if( f->generic.flags & QMF_SMALLFONT )
	{
		f->generic.charWidth = UI_SMALL_CHAR_WIDTH;
		f->generic.charHeight = UI_SMALL_CHAR_HEIGHT;
	}
	else
	{
		if( f->generic.charWidth < 1 ) f->generic.charWidth = UI_MED_CHAR_WIDTH;
		if( f->generic.charHeight < 1 ) f->generic.charHeight = UI_MED_CHAR_HEIGHT;
	}

	UI_ScaleCoords( NULL, NULL, &f->generic.charWidth, &f->generic.charHeight );

	if( !(f->generic.flags & (QMF_LEFT_JUSTIFY|QMF_CENTER_JUSTIFY|QMF_RIGHT_JUSTIFY)))
		f->generic.flags |= QMF_LEFT_JUSTIFY;

	if( !f->generic.color ) f->generic.color = uiInputTextColor;
	if( !f->generic.focusColor ) f->generic.focusColor = uiInputTextColor;

	f->maxLength++;
	if( f->maxLength <= 1 || f->maxLength >= UI_MAX_FIELD_LINE )
		f->maxLength = UI_MAX_FIELD_LINE - 1;

	UI_ScaleCoords( &f->generic.x, &f->generic.y, &f->generic.width, &f->generic.height );

	// calculate number of visible characters
	f->widthInChars = (f->generic.width / f->generic.charWidth);

	f->cursor = strlen( f->buffer );
}

/*
================
UI_Field_Paste
================
*/
void UI_Field_Paste( void )
{
	char	*str;
	int	pasteLen, i;

	str = GET_CLIPBOARD ();
	if( !str ) return;

	// send as if typed, so insert / overstrike works properly
	pasteLen = strlen( str );
	for( i = 0; i < pasteLen; i++ )
		UI_CharEvent( str[i] );
	FREE( str );
}

/*
================
UI_Field_Clear
================
*/
void UI_Field_Clear( menuField_s *f )
{
	memset( f->buffer, 0, UI_MAX_FIELD_LINE );
	f->cursor = 0;
	f->scroll = 0;
}


/*
=================
UI_Field_Key
=================
*/
const char *UI_Field_Key( menuField_s *f, int key, int down )
{
	int	len;

	if( !down ) return 0;

	// clipboard paste
	if((( key == K_INS ) || ( key == K_KP_INS )) && KEY_IsDown( K_SHIFT ))
	{
		UI_Field_Paste();
		return 0;
	}

	len = strlen( f->buffer );

	if( key == K_INS )
	{
		// toggle overstrike mode
		KEY_SetOverstrike( !KEY_GetOverstrike( ));
		return uiSoundNull; // handled
	}

	// previous character
	if( key == K_LEFTARROW )
	{
		if( f->cursor > 0 ) f->cursor = UtfMoveLeft( f->buffer, f->cursor );
		if( f->cursor < f->scroll ) f->scroll--;
		return uiSoundNull;
	}

	// next character
	if( key == K_RIGHTARROW )
	{
		if( f->cursor < len ) f->cursor = UtfMoveRight( f->buffer, f->cursor, len );
		if( f->cursor >= f->scroll + f->widthInChars && f->cursor <= len )
			f->scroll++;
		return uiSoundNull;
	}

	// first character
	if( key == K_HOME )
	{
		f->cursor = 0;
		return uiSoundNull;
	}

	// last character
	if( key == K_END )
	{
		f->cursor = len;
		return uiSoundNull;
	}

	if( key == K_BACKSPACE )
	{
		if( f->cursor > 0 )
		{
			int pos = UtfMoveLeft( f->buffer, f->cursor );
			memmove( f->buffer + pos, f->buffer + f->cursor, len - f->cursor + 1 );
			f->cursor = pos;
			if( f->scroll ) f->scroll--;
		}
	}
	if( key == K_DEL )
	{	
		if( f->cursor < len )
			memmove( f->buffer + f->cursor, f->buffer + f->cursor + 1, len - f->cursor );
	}

	if( key == K_MOUSE1 )
	{
		float y = f->generic.y;

		if( y > ScreenHeight - f->generic.height - 40 )
			y = ScreenHeight - f->generic.height - 15;

		if( UI_CursorInRect( f->generic.x, y, f->generic.width, f->generic.height ) )
		{
			int charpos = (uiStatic.cursorX - f->generic.x) / f->generic.charWidth;
			f->cursor = f->scroll + charpos;
			if( charpos == 0 && f->scroll )
				f->scroll--;
			if( charpos == f->widthInChars && f->scroll < len - 1 )
				f->scroll++;
			if( f->scroll > len )
				f->scroll = len;
			if( f->cursor > len )
				f->cursor = len;
		}
	}

	if( f->generic.callback )
		f->generic.callback( f, QM_CHANGED );
	return 0;
}

/*
=================
UI_Field_Char
=================
*/
void UI_Field_Char( menuField_s *f, int key )
{
	int	len;

	if( key == 'v' - 'a' + 1 )
	{
		// ctrl-v is paste
		UI_Field_Paste();
		return;
	}

	if( key == 'c' - 'a' + 1 )
	{
		// ctrl-c clears the field
		UI_Field_Clear( f );
		return;
	}

	len = strlen( f->buffer );

	if( key == 'a' - 'a' + 1 )
	{
		// ctrl-a is home
		f->cursor = 0;
		f->scroll = 0;
		return;
	}

	if( key == 'e' - 'a' + 1 )
	{
		// ctrl-e is end
		f->cursor = len;
		f->scroll = f->cursor - f->widthInChars;
		return;
	}

	// ignore any other non printable chars
	//if( key < 32 ) return;

	if( key == '^' && !( f->generic.flags & QMF_ALLOW_COLORSTRINGS ))
	{
		// ignore color key-symbol
		return;
	}

	if( f->generic.flags & QMF_NUMBERSONLY )
	{
		if( key < '0' || key > '9' )
			return;
	}

	if( f->generic.flags & QMF_LOWERCASE )
		key = tolower( key );
	else if( f->generic.flags & QMF_UPPERCASE )
		key = toupper( key );

	if( KEY_GetOverstrike( ))
	{	
		if( f->cursor == f->maxLength - 1 ) return;
		f->buffer[f->cursor] = key;
		f->cursor++;
	}
	else
	{
		// insert mode
		if( len == f->maxLength - 1 ) return; // all full
		memmove( f->buffer + f->cursor + 1, f->buffer + f->cursor, len + 1 - f->cursor );
		f->buffer[f->cursor] = key;
		f->cursor++;
	}

	if( f->cursor >= f->widthInChars ) f->scroll++;
	if( f->cursor == len + 1 ) f->buffer[f->cursor] = 0;

	if( f->generic.callback )
		f->generic.callback( f, QM_CHANGED );
}

/*
=================
UI_Field_Draw
=================
*/
void UI_Field_Draw( menuField_s *f )
{
	int	justify = 0;
	int	shadow;
	char	text[UI_MAX_FIELD_LINE];
	int	len, drawLen, prestep;
	int	cursor, x, textHeight;
	char	cursor_char[3];
	float y = f->generic.y;

	if( y > ScreenHeight - f->generic.height - 40 )
	{
		if((menuCommon_s *)f == (menuCommon_s *)UI_ItemAtCursor( f->generic.parent ))
			y = ScreenHeight - f->generic.height - 15;
		else
			return;
	}

	if( f->generic.flags & QMF_LEFT_JUSTIFY )
		justify = 0;
	else if( f->generic.flags & QMF_CENTER_JUSTIFY )
		justify = 1;
	else if( f->generic.flags & QMF_RIGHT_JUSTIFY )
		justify = 2;

	shadow = (f->generic.flags & QMF_DROPSHADOW);

	cursor_char[1] = '\0';
	if( KEY_GetOverstrike( ))
		cursor_char[0] = 11;
	else cursor_char[0] = 95;

	drawLen = f->widthInChars;
	len = strlen( f->buffer ) + 1;

	// guarantee that cursor will be visible
	if( len <= drawLen )
	{
		prestep = 0;
	}
	else
	{
		if( f->scroll + drawLen > len )
		{
			f->scroll = len - drawLen;
			if( f->scroll < 0 ) f->scroll = 0;
		}
		prestep = f->scroll;
	}

	if( prestep + drawLen > len )
		drawLen = len - prestep;

	// extract <drawLen> characters from the field at <prestep>
	if( drawLen >= UI_MAX_FIELD_LINE )
		HOST_ERROR( "UI_Field_Draw: drawLen >= UI_MAX_FIELD_LINE\n" );

	memcpy( text, f->buffer + prestep, drawLen );
	text[drawLen] = 0;

	if( f->generic.flags & QMF_HIDEINPUT )
	{
		for( int i = 0; i < drawLen; i++ )
			if( text[i] ) text[i] = '*';
	}

	// find cursor position
	x = drawLen - (ColorStrlen( text ) + 1 );
	if( x < 0 ) x = 0;
	cursor = ( f->cursor - prestep - x );
	if( cursor < 0 ) cursor = 0;

	if( justify == 0 ) x = f->generic.x;
	else if( justify == 1 )
		x = f->generic.x + ((f->generic.width - (ColorStrlen( text ) * f->generic.charWidth )) / 2 );
	else if( justify == 2 )
		x = f->generic.x + (f->generic.width - (ColorStrlen( text ) * f->generic.charWidth ));

	if( f->background )
	{
		UI_DrawPic( f->generic.x, y, f->generic.width, f->generic.height, uiColorWhite, f->background );
	}
	else
	{
		// draw the background
		UI_FillRect( f->generic.x, y, f->generic.width, f->generic.height, uiInputBgColor );

		// draw the rectangle
		UI_DrawRectangle( f->generic.x, y, f->generic.width, f->generic.height, uiInputFgColor );
	}

	textHeight = y - (f->generic.charHeight * 1.5f);
	UI_DrawString( f->generic.x, textHeight, f->generic.width, f->generic.charHeight, f->generic.name, uiColorHelp, true, f->generic.charWidth, f->generic.charHeight, 0, shadow );

	if( f->generic.flags & QMF_GRAYED )
	{
		UI_DrawString( f->generic.x, y, f->generic.width, f->generic.height, text, uiColorDkGrey, true, f->generic.charWidth, f->generic.charHeight, justify, shadow );
		return; // grayed
	}

	if((menuCommon_s *)f != (menuCommon_s *)UI_ItemAtCursor( f->generic.parent ))
	{
		UI_DrawString( f->generic.x, y, f->generic.width, f->generic.height, text, f->generic.color, false, f->generic.charWidth, f->generic.charHeight, justify, shadow );
		return; // no focus
	}

	if( !( f->generic.flags & QMF_FOCUSBEHIND ))
	{
		UI_DrawString( f->generic.x, y, f->generic.width, f->generic.height, text, f->generic.color, false, f->generic.charWidth, f->generic.charHeight, justify, shadow );

		if(( uiStatic.realTime & 499 ) < 250 )
			UI_DrawString( x + (cursor * f->generic.charWidth), y, f->generic.charWidth, f->generic.height, cursor_char, f->generic.color, true, f->generic.charWidth, f->generic.charHeight, 0, shadow );
	}

	if( f->generic.flags & QMF_HIGHLIGHTIFFOCUS )
	{
		UI_DrawString( f->generic.x, y, f->generic.width, f->generic.height, text, f->generic.focusColor, false, f->generic.charWidth, f->generic.charHeight, justify, shadow );

		if(( uiStatic.realTime & 499 ) < 250 )
			UI_DrawString( x + (cursor * f->generic.charWidth), y, f->generic.charWidth, f->generic.height, cursor_char, f->generic.focusColor, true, f->generic.charWidth, f->generic.charHeight, 0, shadow );
	}
	else if( f->generic.flags & QMF_PULSEIFFOCUS )
	{
		int	color;

		color = PackAlpha( f->generic.color, 255 * (0.5 + 0.5 * sin( (float)uiStatic.realTime / UI_PULSE_DIVISOR )));
		UI_DrawString( f->generic.x, y, f->generic.width, f->generic.height, text, color, false, f->generic.charWidth, f->generic.charHeight, justify, shadow );

		if(( uiStatic.realTime & 499 ) < 250 )
			UI_DrawString( x + (cursor * f->generic.charWidth), y, f->generic.charWidth, f->generic.height, cursor_char, color, true, f->generic.charWidth, f->generic.charHeight, 0, shadow );
	}

	if( f->generic.flags & QMF_FOCUSBEHIND )
	{
		UI_DrawString( f->generic.x, y, f->generic.width, f->generic.height, text, f->generic.color, false, f->generic.charWidth, f->generic.charHeight, justify, shadow );

		if(( uiStatic.realTime & 499 ) < 250 )
			UI_DrawString( x + (cursor * f->generic.charWidth), y, f->generic.charWidth, f->generic.height, cursor_char, f->generic.color, true, f->generic.charWidth, f->generic.charHeight, 0, shadow );
	}
}

/*
=================
UI_Action_Init
=================
*/
void UI_Action_Init( menuAction_s *a )
{
	if( !a->generic.name ) a->generic.name = ""; // this is also the text displayed

	if( a->generic.flags & QMF_BIGFONT )
	{
		a->generic.charWidth = UI_BIG_CHAR_WIDTH;
		a->generic.charHeight = UI_BIG_CHAR_HEIGHT;
	}
	else if( a->generic.flags & QMF_SMALLFONT )
	{
		a->generic.charWidth = UI_SMALL_CHAR_WIDTH;
		a->generic.charHeight = UI_SMALL_CHAR_HEIGHT;
	}
	else
	{
		if( a->generic.charWidth < 1 ) a->generic.charWidth = UI_MED_CHAR_WIDTH;
		if( a->generic.charHeight < 1 ) a->generic.charHeight = UI_MED_CHAR_HEIGHT;
	}

	if(!( a->generic.flags & ( QMF_LEFT_JUSTIFY|QMF_CENTER_JUSTIFY|QMF_RIGHT_JUSTIFY )))
		a->generic.flags |= QMF_LEFT_JUSTIFY;

	if( !a->generic.color ) a->generic.color = uiPromptTextColor;
	if( !a->generic.focusColor ) a->generic.focusColor = uiPromptFocusColor;

	if( a->generic.width < 1 || a->generic.height < 1 )
	{
		if( a->background )
		{
			HIMAGE handle = PIC_Load( a->background );
			a->generic.width = PIC_Width( handle );
			a->generic.height = PIC_Height( handle );
		}
		else
		{
			if( a->generic.width < 1 )
				a->generic.width = a->generic.charWidth * strlen( a->generic.name );

			if( a->generic.height < 1 )
				a->generic.height = a->generic.charHeight * 1.5;
		}
	}

	UI_ScaleCoords( NULL, NULL, &a->generic.charWidth, &a->generic.charHeight );
	UI_ScaleCoords( &a->generic.x, &a->generic.y, &a->generic.width, &a->generic.height );
}

/*
=================
UI_Action_Key
=================
*/
const char *UI_Action_Key( menuAction_s *a, int key, int down )
{
	const char	*sound = 0;

	switch( key )
	{
	case K_MOUSE1:
		if(!( a->generic.flags & QMF_HASMOUSEFOCUS ))
			break;
		sound = uiSoundLaunch;
		break;
	case K_ENTER:
	case K_KP_ENTER:
	case K_AUX1:
		//if( !down ) return sound;
		if( a->generic.flags & QMF_MOUSEONLY )
			break;
		sound = uiSoundLaunch;
		break;
	}

	if( sound && ( a->generic.flags & QMF_SILENT ))
		sound = uiSoundNull;

	if( a->generic.flags & QMF_ACT_ONRELEASE )
	{
		if( sound && a->generic.callback )
		{
			int	event;

			if( down )
			{
				event = QM_PRESSED;
				a->generic.bPressed = true;
			}
			else event = QM_ACTIVATED;
			a->generic.callback( a, event );
		}
	}
	else if( down )
	{
		if( sound && a->generic.callback )
			a->generic.callback( a, QM_ACTIVATED );
	}

	return sound;
}

/*
=================
UI_Action_Draw
=================
*/
void UI_Action_Draw( menuAction_s *a )
{
	int	justify = 0;
	int	shadow;

	if( a->generic.flags & QMF_LEFT_JUSTIFY )
		justify = 0;
	else if( a->generic.flags & QMF_CENTER_JUSTIFY )
		justify = 1;
	else if( a->generic.flags & QMF_RIGHT_JUSTIFY )
		justify = 2;

	shadow = (a->generic.flags & QMF_DROPSHADOW);

	if( a->background )
		UI_DrawPic( a->generic.x, a->generic.y, a->generic.width, a->generic.height, uiColorWhite, a->background );

	if( a->generic.statusText && a->generic.flags & QMF_NOTIFY )
	{
		int	charW, charH;
		int	x, w;

		charW = UI_SMALL_CHAR_WIDTH;
		charH = UI_SMALL_CHAR_HEIGHT;

		UI_ScaleCoords( NULL, NULL, &charW, &charH );

		x = 290;
		w = UI_SMALL_CHAR_WIDTH * strlen( a->generic.statusText );
		UI_ScaleCoords( &x, NULL, &w, NULL );
		x += a->generic.x;

		int	r, g, b;

		UnpackRGB( r, g, b, uiColorHelp );
		TextMessageSetColor( r, g, b );
		DrawConsoleString( x, a->generic.y, a->generic.statusText );
	}

	if( a->generic.flags & QMF_GRAYED )
	{
		UI_DrawString( a->generic.x, a->generic.y, a->generic.width, a->generic.height, a->generic.name, uiColorDkGrey, true, a->generic.charWidth, a->generic.charHeight, justify, shadow );
		return; // grayed
	}

	if((menuCommon_s *)a != (menuCommon_s *)UI_ItemAtCursor( a->generic.parent ))
	{
		UI_DrawString( a->generic.x, a->generic.y, a->generic.width, a->generic.height, a->generic.name, a->generic.color, false, a->generic.charWidth, a->generic.charHeight, justify, shadow );
		return; // no focus
	}

	if(!( a->generic.flags & QMF_FOCUSBEHIND ))
		UI_DrawString( a->generic.x, a->generic.y, a->generic.width, a->generic.height, a->generic.name, a->generic.color, false, a->generic.charWidth, a->generic.charHeight, justify, shadow );

	if( a->generic.flags & QMF_HIGHLIGHTIFFOCUS )
		UI_DrawString( a->generic.x, a->generic.y, a->generic.width, a->generic.height, a->generic.name, a->generic.focusColor, false, a->generic.charWidth, a->generic.charHeight, justify, shadow );
	else if( a->generic.flags & QMF_PULSEIFFOCUS )
	{
		int	color;

		color = PackAlpha( a->generic.color, 255 * (0.5 + 0.5 * sin( (float)uiStatic.realTime / UI_PULSE_DIVISOR )));

		UI_DrawString( a->generic.x, a->generic.y, a->generic.width, a->generic.height, a->generic.name, color, false, a->generic.charWidth, a->generic.charHeight, justify, shadow );
	}

	if( a->generic.flags & QMF_FOCUSBEHIND )
		UI_DrawString( a->generic.x, a->generic.y, a->generic.width, a->generic.height, a->generic.name, a->generic.color, false, a->generic.charWidth, a->generic.charHeight, justify, shadow );
}

/*
=================
UI_Bitmap_Init
=================
*/
void UI_Bitmap_Init( menuBitmap_s *b )
{
	if( !b->generic.name ) b->generic.name = "";
	if( !b->focusPic ) b->focusPic = b->pic;
	if( !b->generic.color ) b->generic.color = uiColorWhite;

	UI_ScaleCoords( &b->generic.x, &b->generic.y, &b->generic.width, &b->generic.height );
}

/*
=================
UI_Bitmap_Key
=================
*/
const char *UI_Bitmap_Key( menuBitmap_s *b, int key, int down )
{
	const char	*sound = 0;

	switch( key )
	{
	case K_MOUSE1:
		if(!( b->generic.flags & QMF_HASMOUSEFOCUS ))
			break;
		sound = uiSoundLaunch;
		break;
	case K_ENTER:
	case K_KP_ENTER:
	case K_AUX1:
		//if( !down ) return sound;
		if( b->generic.flags & QMF_MOUSEONLY )
			break;
		sound = uiSoundLaunch;
		break;
	}
	if( sound && ( b->generic.flags & QMF_SILENT ))
		sound = uiSoundNull;

	if( b->generic.flags & QMF_ACT_ONRELEASE )
	{
		if( sound && b->generic.callback )
		{
			int	event;

			if( down )
			{
				event = QM_PRESSED;
				b->generic.bPressed = true;
			}
			else event = QM_ACTIVATED;
			b->generic.callback( b, event );
		}
	}
	else if( down )
	{
		if( sound && b->generic.callback )
			b->generic.callback( b, QM_ACTIVATED );
          }

	return sound;
}

/*
=================
UI_Bitmap_Draw
=================
*/
void UI_Bitmap_Draw( menuBitmap_s *b )
{
	if( b->generic.id == ID_BACKGROUND )	// background is always 0!
	{
		if( CVAR_GET_FLOAT( "cl_background" ))
			return;	// has background map disable images

		// UGLY HACK for replace all backgrounds
		UI_DrawBackground_Callback( b );
		return;
	}

	//CR
	if( b->generic.id == ID_BANNER )
	{
		// don't draw banners until transition is done
#ifdef TA_ALT_MODE
		if( UI_GetTitleTransFraction() != 10 ) return;
#else
		if( UI_GetTitleTransFraction() < 1.0f ) return;
#endif
	}

	if( b->generic.flags & QMF_GRAYED )
	{
		UI_DrawPic( b->generic.x, b->generic.y, b->generic.width, b->generic.height, uiColorDkGrey, b->pic );
		return; // grayed
	}

	if(( b->generic.flags & QMF_MOUSEONLY ) && !( b->generic.flags & QMF_HASMOUSEFOCUS ))
	{
		UI_DrawPic( b->generic.x, b->generic.y, b->generic.width, b->generic.height, b->generic.color, b->pic );
		return; // no focus
	}
	
	if((menuCommon_s *)b != (menuCommon_s *)UI_ItemAtCursor( b->generic.parent ))
	{
		// UNDONE: only inactive bitmaps supported
		if( b->generic.flags & QMF_DRAW_ADDITIVE )
			UI_DrawPicAdditive( b->generic.x, b->generic.y, b->generic.width, b->generic.height, b->generic.color, b->pic );
		else UI_DrawPic( b->generic.x, b->generic.y, b->generic.width, b->generic.height, b->generic.color, b->pic );
		return; // no focus
	}

	if(!( b->generic.flags & QMF_FOCUSBEHIND ))
		UI_DrawPic( b->generic.x, b->generic.y, b->generic.width, b->generic.height, b->generic.color, b->pic );
	if( b->generic.flags & QMF_HIGHLIGHTIFFOCUS )
		UI_DrawPic( b->generic.x, b->generic.y, b->generic.width, b->generic.height, b->generic.color, b->focusPic );
	else if( b->generic.flags & QMF_PULSEIFFOCUS )
	{
		int	color;

		color = PackAlpha( b->generic.color, 255 * (0.5 + 0.5 * sin( (float)uiStatic.realTime / UI_PULSE_DIVISOR )));
		UI_DrawPic( b->generic.x, b->generic.y, b->generic.width, b->generic.height, color, b->focusPic );
	}

	if( b->generic.flags & QMF_FOCUSBEHIND )
		UI_DrawPic( b->generic.x, b->generic.y, b->generic.width, b->generic.height, b->generic.color, b->pic );
}

/*
=================
UI_PicButton_Init
=================
*/
void UI_PicButton_Init( menuPicButton_s *pb )
{
	if( !pb->generic.name ) pb->generic.name = "";

	if( pb->generic.flags & QMF_BIGFONT )
	{
		pb->generic.charWidth = UI_BIG_CHAR_WIDTH;
		pb->generic.charHeight = UI_BIG_CHAR_HEIGHT;
	}
	else if( pb->generic.flags & QMF_SMALLFONT )
	{
		pb->generic.charWidth = UI_SMALL_CHAR_WIDTH;
		pb->generic.charHeight = UI_SMALL_CHAR_HEIGHT;
	}
	else
	{
		if( pb->generic.charWidth < 1 ) pb->generic.charWidth = UI_MED_CHAR_WIDTH;
		if( pb->generic.charHeight < 1 ) pb->generic.charHeight = UI_MED_CHAR_HEIGHT;
	}

	if(!( pb->generic.flags & ( QMF_LEFT_JUSTIFY|QMF_CENTER_JUSTIFY|QMF_RIGHT_JUSTIFY )))
		pb->generic.flags |= QMF_LEFT_JUSTIFY;

	if( !pb->generic.color ) pb->generic.color = uiPromptTextColor;
	if( !pb->generic.focusColor ) pb->generic.focusColor = uiPromptFocusColor;

	if( pb->generic.width < 1 || pb->generic.height < 1 )
	{
		if( pb->generic.width < 1 )
			pb->generic.width = pb->generic.charWidth * strlen( pb->generic.name );

		if( pb->generic.height < 1 )
			pb->generic.height = pb->generic.charHeight * 1.5;
	}

	UI_ScaleCoords( &pb->generic.x, &pb->generic.y, &pb->generic.width, &pb->generic.height );
	UI_ScaleCoords( NULL, NULL, &pb->generic.charWidth, &pb->generic.charHeight );
}

/*
=================
UI_PicButton_Key
=================
*/
const char *UI_PicButton_Key( menuPicButton_s *b, int key, int down )
{
	const char	*sound = 0;

	switch( key )
	{
	case K_MOUSE1:
		if(!( b->generic.flags & QMF_HASMOUSEFOCUS ))
			break;
		sound = uiSoundLaunch;
		break;
	case K_ENTER:
	case K_KP_ENTER:
	case K_AUX1:
		if( b->generic.flags & QMF_MOUSEONLY )
			break;
		sound = uiSoundLaunch;
	}
	if( sound && ( b->generic.flags & QMF_SILENT ))
		sound = uiSoundNull;

	if( sound && b->generic.callback )
	{
		if( b->generic.flags & QMF_ACT_ONRELEASE )
		{
			int event;
			if( down )
			{
				event = QM_PRESSED;
				b->generic.bPressed = true;
			}
			else
				event = QM_ACTIVATED;

			UI_TACheckMenuDepth();
			b->generic.callback( b, event );
			UI_SetTitleAnim( AS_TO_TITLE, b );
		}
		else if( down )
		{
			b->generic.callback( b, QM_ACTIVATED );
		}
	}

	return sound;
}

/*
=================
UI_PicButton_Draw
=================
*/
void UI_PicButton_Draw( menuPicButton_s *item )
{
	int state = BUTTON_NOFOCUS;

	if( item->generic.flags & (QMF_HASMOUSEFOCUS|QMF_HASKEYBOARDFOCUS))
		state = BUTTON_FOCUS;

	// make sure what cursor in rect
	if( item->generic.bPressed && cursorDown )
 		state = BUTTON_PRESSED;
	else item->generic.bPressed = false;

	if( item->generic.statusText && item->generic.flags & QMF_NOTIFY )
	{
		int	charW, charH;
		int	x, w;
		
		charW = UI_SMALL_CHAR_WIDTH;
		charH = UI_SMALL_CHAR_HEIGHT;
		
		UI_ScaleCoords( NULL, NULL, &charW, &charH );
		
		x = 290;
		w = UI_SMALL_CHAR_WIDTH * strlen( item->generic.statusText );
		UI_ScaleCoords( &x, NULL, &w, NULL );
		x += item->generic.x;
		
		int	r, g, b;
		
		UnpackRGB( r, g, b, uiColorHelp );
		TextMessageSetColor( r, g, b );
		DrawConsoleString( x, item->generic.y, item->generic.statusText );
	}

	if( item->pic )
	{
		int r, g, b, a;

		UnpackRGB( r, g, b, item->generic.flags & QMF_GRAYED ? uiColorDkGrey : uiColorWhite );

		wrect_t rects[]=
		{
		{ 0, uiStatic.buttons_width, 0, 26 },
		{ 0, uiStatic.buttons_width, 26, 52 },
		{ 0, uiStatic.buttons_width, 52, 78 }
		};

		PIC_Set( item->pic, r, g, b, 255 );
		PIC_DrawAdditive( item->generic.x, item->generic.y, uiStatic.buttons_draw_width, uiStatic.buttons_draw_height, &rects[state] );

		a = (512 - (uiStatic.realTime - item->generic.lastFocusTime)) >> 1;

		if( state == BUTTON_NOFOCUS && a > 0 )
		{
			PIC_Set( item->pic, r, g, b, a );
			PIC_DrawAdditive( item->generic.x, item->generic.y, uiStatic.buttons_draw_width, uiStatic.buttons_draw_height, &rects[BUTTON_FOCUS] );
		}
	}
	else
	{
		int	justify = 0;
		int	shadow;
		
		if( item->generic.flags & QMF_LEFT_JUSTIFY )
			justify = 0;
		else if( item->generic.flags & QMF_CENTER_JUSTIFY )
			justify = 1;
		else if( item->generic.flags & QMF_RIGHT_JUSTIFY )
			justify = 2;
		
		shadow = (item->generic.flags & QMF_DROPSHADOW);

		if( item->generic.flags & QMF_GRAYED )
		{
			UI_DrawString( item->generic.x, item->generic.y, item->generic.width, item->generic.height, item->generic.name, uiColorDkGrey, true, item->generic.charWidth, item->generic.charHeight, justify, shadow );
			return; // grayed
		}
		
		if((menuCommon_s *)item != (menuCommon_s *)UI_ItemAtCursor( item->generic.parent ))
		{
			UI_DrawString( item->generic.x, item->generic.y, item->generic.width, item->generic.height, item->generic.name, item->generic.color, false, item->generic.charWidth, item->generic.charHeight, justify, shadow );
			return; // no focus
		}
		
		if(!( item->generic.flags & QMF_FOCUSBEHIND ))
			UI_DrawString( item->generic.x, item->generic.y, item->generic.width, item->generic.height, item->generic.name, item->generic.color, false, item->generic.charWidth, item->generic.charHeight, justify, shadow );
		
		if( item->generic.flags & QMF_HIGHLIGHTIFFOCUS )
			UI_DrawString( item->generic.x, item->generic.y, item->generic.width, item->generic.height, item->generic.name, item->generic.focusColor, false, item->generic.charWidth, item->generic.charHeight, justify, shadow );
		else if( item->generic.flags & QMF_PULSEIFFOCUS )
		{
			int	color;
			
			color = PackAlpha( item->generic.color, 255 * (0.5 + 0.5 * sin( (float)uiStatic.realTime / UI_PULSE_DIVISOR )));
			
			UI_DrawString( item->generic.x, item->generic.y, item->generic.width, item->generic.height, item->generic.name, color, false, item->generic.charWidth, item->generic.charHeight, justify, shadow );
		}
		
		if( item->generic.flags & QMF_FOCUSBEHIND )
			UI_DrawString( item->generic.x, item->generic.y, item->generic.width, item->generic.height, item->generic.name, item->generic.color, false, item->generic.charWidth, item->generic.charHeight, justify, shadow );
	}
}

```

`mainui/utils.h`:

```h
/*
utils.h - draw helper
Copyright (C) 2010 Uncle Mike

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
*/

#ifndef UTILS_H
#define UTILS_H

extern ui_enginefuncs_t g_engfuncs;
extern ui_textfuncs_t g_textfuncs;

#include "enginecallback.h"
#include "gameinfo.h"

#define FILE_GLOBAL	static
#define DLL_GLOBAL

#define MAX_INFO_STRING	256	// engine limit

#define RAD2DEG( x )	((float)(x) * (float)(180.f / M_PI))
#define DEG2RAD( x )	((float)(x) * (float)(M_PI / 180.f))

//
// How did I ever live without ASSERT?
//
#ifdef _DEBUG
void DBG_AssertFunction( BOOL fExpr, const char* szExpr, const char* szFile, int szLine, const char* szMessage );
#define ASSERT( f )		DBG_AssertFunction( f, #f, __FILE__, __LINE__, NULL )
#define ASSERTSZ( f, sz )	DBG_AssertFunction( f, #f, __FILE__, __LINE__, sz )
#else
#define ASSERT( f )
#define ASSERTSZ( f, sz )
#endif

extern ui_globalvars_t		*gpGlobals;

// exports
extern int UI_VidInit( void );
extern void UI_Init( void );
extern void UI_Shutdown( void );
extern void UI_UpdateMenu( float flTime );
extern void UI_KeyEvent( int key, int down );
extern void UI_MouseMove( int x, int y );
extern void UI_SetActiveMenu( int fActive );
extern void UI_AddServerToList( netadr_t adr, const char *info );
extern void UI_GetCursorPos( int *pos_x, int *pos_y );
extern void UI_SetCursorPos( int pos_x, int pos_y );
extern void UI_ShowCursor( int show );
extern void UI_CharEvent( int key );
extern int UI_MouseInRect( void );
extern int UI_IsVisible( void );
extern int UI_CreditsActive( void );
extern void UI_FinalCredits( void );

#include "cvardef.h"

// ScreenHeight returns the height of the screen, in pixels
#define ScreenHeight	(gpGlobals->scrHeight)
// ScreenWidth returns the width of the screen, in pixels
#define ScreenWidth		(gpGlobals->scrWidth)

inline unsigned int PackRGB( int r, int g, int b )
{
	return ((0xFF)<<24|(r)<<16|(g)<<8|(b));
}

inline unsigned int PackRGBA( int r, int g, int b, int a )
{
	return ((a)<<24|(r)<<16|(g)<<8|(b));
}

inline void UnpackRGB( int &r, int &g, int &b, unsigned int ulRGB )
{
	r = (ulRGB & 0xFF0000) >> 16;
	g = (ulRGB & 0xFF00) >> 8;
	b = (ulRGB & 0xFF) >> 0;
}

inline void UnpackRGBA( int &r, int &g, int &b, int &a, unsigned int ulRGBA )
{
	a = (ulRGBA & 0xFF000000) >> 24;
	r = (ulRGBA & 0xFF0000) >> 16;
	g = (ulRGBA & 0xFF00) >> 8;
	b = (ulRGBA & 0xFF) >> 0;
}

inline int PackAlpha( unsigned int ulRGB, unsigned int ulAlpha )
{
	return (ulRGB)|(ulAlpha<<24);
}

inline int UnpackAlpha( unsigned int ulRGBA )
{
	return ((ulRGBA & 0xFF000000) >> 24);	
}

inline float RemapVal( float val, float A, float B, float C, float D)
{
	return C + (D - C) * (val - A) / (B - A);
}

extern void AddSpaces( char *s, int size );
extern int ColorStrlen( const char *str );	// returns string length without color symbols
extern const unsigned int g_iColorTable[8];
extern void COM_FileBase( const char *in, char *out );		// ripped out from hlsdk 2.3
extern int UI_FadeAlpha( int starttime, int endtime );
extern void StringConcat( char *dst, const char *src, size_t size );	// strncat safe prototype
extern char *Info_ValueForKey( const char *s, const char *key );
extern int KEY_GetKey( const char *binding );			// ripped out from engine
extern char *StringCopy( const char *input );			// copy string into new memory
extern int COM_CompareSaves( const void **a, const void **b );

extern void UI_LoadCustomStrings( void );

#endif//UTILS_H

```

`network/delta.lst`:

```lst
// structure name
// none == no conditional encode routine
// gamedll routine_name : before transmitting data, invoke the named function from the game .dll to reset fields as needed
// clientdll routine_name : same as above, except the routine is called via the client.dll

clientdata_t none                    
{
	DEFINE_DELTA( flTimeStepSound, DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( origin[0], DT_SIGNED | DT_FLOAT, 21, 128.0 ),
	DEFINE_DELTA( origin[1], DT_SIGNED | DT_FLOAT, 21, 128.0 ),
	DEFINE_DELTA( velocity[0], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( velocity[1], DT_SIGNED | DT_FLOAT, 16, 8.0 ),

	DEFINE_DELTA( m_flNextAttack, DT_FLOAT | DT_SIGNED, 22, 1000.0 ),

	DEFINE_DELTA( origin[2], DT_SIGNED | DT_FLOAT, 21, 128.0 ),
	DEFINE_DELTA( velocity[2], DT_SIGNED | DT_FLOAT, 16, 8.0 ),

	DEFINE_DELTA( ammo_nails, DT_SIGNED | DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( ammo_shells, DT_SIGNED | DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( ammo_cells, DT_SIGNED | DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( ammo_rockets, DT_SIGNED | DT_INTEGER, 10, 1.0 ),

	DEFINE_DELTA( m_iId, DT_INTEGER, 5, 1.0 ),

	DEFINE_DELTA( punchangle[2], DT_SIGNED | DT_FLOAT, 21, 8.0 ),
	DEFINE_DELTA( flags, DT_INTEGER, 32, 1.0 ), // Cut to 3 bits?
	DEFINE_DELTA( weaponanim, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( health, DT_SIGNED | DT_FLOAT, 10, 1.0 ), // Cut # of bits?
	DEFINE_DELTA( maxspeed, DT_FLOAT, 16, 10.0 ),
	DEFINE_DELTA( flDuckTime, DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( view_ofs[2], DT_SIGNED | DT_FLOAT, 10, 4.0 ),
	DEFINE_DELTA( punchangle[0], DT_SIGNED | DT_FLOAT, 26, 8192.0 ),
	DEFINE_DELTA( punchangle[1], DT_SIGNED | DT_FLOAT, 26, 8192.0 ),
	DEFINE_DELTA( viewmodel, DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( weapons, DT_INTEGER, 32, 1.0 ),

	DEFINE_DELTA( pushmsec, DT_INTEGER, 11, 1.0 ),
	DEFINE_DELTA( deadflag, DT_INTEGER, 3, 1.0 ),
	DEFINE_DELTA( fov, DT_FLOAT, 8, 1.0 ),
	DEFINE_DELTA( physinfo, DT_STRING, 1, 1.0 ),
	DEFINE_DELTA( bInDuck, DT_INTEGER, 1, 1.0 ),
	DEFINE_DELTA( flSwimTime, DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( waterjumptime, DT_INTEGER, 15, 1.0 ),
	DEFINE_DELTA( waterlevel, DT_INTEGER, 2, 1.0 ),

	DEFINE_DELTA( iuser1, DT_INTEGER, 3, 1.0 ),
	DEFINE_DELTA( iuser2, DT_INTEGER, 6, 1.0 ),
	DEFINE_DELTA( iuser3, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( iuser4, DT_INTEGER, 2, 1.0 ),

	DEFINE_DELTA( vuser2[0], DT_FLOAT, 9, 1.0 ),
	DEFINE_DELTA( vuser2[1], DT_FLOAT, 9, 1.0 ),
	DEFINE_DELTA( vuser2[2], DT_FLOAT, 9, 1.0 ),

	DEFINE_DELTA( vuser3[0], DT_FLOAT, 9, 1.0 ),
	DEFINE_DELTA( vuser3[1], DT_FLOAT, 9, 1.0 ),
	DEFINE_DELTA( vuser3[2], DT_FLOAT, 9, 1.0 ),

	DEFINE_DELTA( vuser4[0], DT_FLOAT, 9, 1.0 ),
	DEFINE_DELTA( vuser4[1], DT_FLOAT, 9, 1.0 ),

	DEFINE_DELTA( fuser1, DT_FLOAT, 9, 1.0 ),
	DEFINE_DELTA( fuser2, DT_FLOAT, 14, 1.0 ),
	DEFINE_DELTA( fuser3, DT_FLOAT, 10, 1.0 )
}

entity_state_t gamedll Entity_Encode
{
	DEFINE_DELTA( animtime, DT_TIMEWINDOW_8, 8, 1.0 ),
	DEFINE_DELTA( frame, DT_FLOAT, 8, 1.0 ),
	DEFINE_DELTA( origin[0], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( angles[0], DT_ANGLE, 16, 1.0 ),
	DEFINE_DELTA( angles[1], DT_ANGLE, 16, 1.0 ),
	DEFINE_DELTA( origin[1], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( origin[2], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( sequence, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( modelindex, DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( movetype, DT_INTEGER, 4, 1.0 ),
	DEFINE_DELTA( solid, DT_SHORT, 3, 1.0 ),
	DEFINE_DELTA( mins[0], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( mins[1], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( mins[2], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( maxs[0], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( maxs[1], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( maxs[2], DT_SIGNED | DT_FLOAT, 16, 8.0 ),

	DEFINE_DELTA( endpos[0], DT_SIGNED | DT_FLOAT, 13, 1.0 ),
	DEFINE_DELTA( endpos[1], DT_SIGNED | DT_FLOAT, 13, 1.0 ),
	DEFINE_DELTA( endpos[2], DT_SIGNED | DT_FLOAT, 13, 1.0 ),
	DEFINE_DELTA( startpos[0], DT_SIGNED | DT_FLOAT, 13, 1.0 ),
	DEFINE_DELTA( startpos[1], DT_SIGNED | DT_FLOAT, 13, 1.0 ),
	DEFINE_DELTA( startpos[2], DT_SIGNED | DT_FLOAT, 13, 1.0 ),
	DEFINE_DELTA( impacttime, DT_TIMEWINDOW_BIG, 13, 100.0 ),
	DEFINE_DELTA( starttime, DT_TIMEWINDOW_BIG, 13, 100.0 ),
	
	DEFINE_DELTA( weaponmodel, DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( owner, DT_INTEGER, 5, 1.0 ),
	DEFINE_DELTA( effects, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( eflags, DT_INTEGER, 1, 1.0 ),
	DEFINE_DELTA( angles[2], DT_ANGLE, 16, 1.0 ),
	DEFINE_DELTA( colormap, DT_INTEGER, 16, 1.0 ),
	DEFINE_DELTA( framerate, DT_SIGNED | DT_FLOAT, 8, 16.0 ),
	DEFINE_DELTA( skin, DT_SHORT | DT_SIGNED, 9, 1.0 ),
	DEFINE_DELTA( controller[0], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( controller[1], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( controller[2], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( controller[3], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( blending[0], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( blending[1], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( body, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( rendermode, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( renderamt, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( renderfx, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( scale, DT_FLOAT, 16, 256.0 ),
	DEFINE_DELTA( rendercolor.r, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( rendercolor.g, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( rendercolor.b, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( aiment, DT_INTEGER, 11, 1.0 ),
	DEFINE_DELTA( basevelocity[0], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( basevelocity[1], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( basevelocity[2], DT_SIGNED | DT_FLOAT, 16, 8.0 ),

	DEFINE_DELTA( iuser4, DT_INTEGER, 2, 1.0 )
}

entity_state_player_t gamedll Player_Encode
{
	DEFINE_DELTA( animtime, DT_TIMEWINDOW_8, 8, 1.0 ),
	DEFINE_DELTA( frame, DT_FLOAT, 8, 1.0 ),
	DEFINE_DELTA( origin[0], DT_SIGNED | DT_FLOAT, 18, 32.0 ),
	DEFINE_DELTA( angles[0], DT_ANGLE, 16, 1.0 ),
	DEFINE_DELTA( angles[1], DT_ANGLE, 16, 1.0 ),
	DEFINE_DELTA( origin[1], DT_SIGNED | DT_FLOAT, 18, 32.0 ),
	DEFINE_DELTA( origin[2], DT_SIGNED | DT_FLOAT, 18, 32.0 ),
	DEFINE_DELTA( gaitsequence, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( sequence, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( modelindex, DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( movetype, DT_INTEGER, 4, 1.0 ),
	DEFINE_DELTA( solid, DT_SHORT, 3, 1.0 ),
	DEFINE_DELTA( mins[0], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( mins[1], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( mins[2], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( maxs[0], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( maxs[1], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( maxs[2], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( weaponmodel, DT_INTEGER, 10, 1.0 ),
	// DEFINE_DELTA( team, DT_INTEGER, 4, 1.0 )
	// DEFINE_DELTA( playerclass, DT_INTEGER, 4, 1.0 )
	DEFINE_DELTA( owner, DT_INTEGER, 5, 1.0 ),
	DEFINE_DELTA( effects, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( angles[2], DT_ANGLE, 16, 1.0 ),
	DEFINE_DELTA( colormap, DT_INTEGER, 16, 1.0 ),
	DEFINE_DELTA( framerate, DT_SIGNED | DT_FLOAT, 8, 16.0 ),
	DEFINE_DELTA( skin, DT_SHORT | DT_SIGNED, 9, 1.0 ),
	DEFINE_DELTA( controller[0], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( controller[1], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( controller[2], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( controller[3], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( blending[0], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( blending[1], DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( body, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( rendermode, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( renderamt, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( renderfx, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( scale, DT_FLOAT, 16, 256.0 ),
	DEFINE_DELTA( rendercolor.r, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( rendercolor.g, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( rendercolor.b, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( friction, DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( usehull, DT_INTEGER, 1, 1.0 ),
	DEFINE_DELTA( gravity, DT_SIGNED | DT_FLOAT, 16, 32.0 ),
	DEFINE_DELTA( aiment, DT_INTEGER, 11, 1.0 ),
	DEFINE_DELTA( basevelocity[0], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( basevelocity[1], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( basevelocity[2], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( spectator, DT_INTEGER, 1, 1.0 )

	DEFINE_DELTA( iuser4, DT_INTEGER, 2, 1.0 )
}

custom_entity_state_t gamedll Custom_Encode
{
	DEFINE_DELTA( rendermode, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( origin[0], DT_SIGNED | DT_FLOAT, 17, 8.0 ),
	DEFINE_DELTA( origin[1], DT_SIGNED | DT_FLOAT, 17, 8.0 ),
	DEFINE_DELTA( origin[2], DT_SIGNED | DT_FLOAT, 17, 8.0 ),
	DEFINE_DELTA( angles[0], DT_SIGNED | DT_FLOAT, 17, 8.0 ),
	DEFINE_DELTA( angles[1], DT_SIGNED | DT_FLOAT, 17, 8.0 ),
	DEFINE_DELTA( angles[2], DT_SIGNED | DT_FLOAT, 17, 8.0 ),
	DEFINE_DELTA( sequence, DT_INTEGER, 16, 1.0 ),
	DEFINE_DELTA( skin, DT_INTEGER, 16, 1.0 ),
	DEFINE_DELTA( modelindex, DT_INTEGER, 16, 1.0 ),
	DEFINE_DELTA_POST( scale, DT_FLOAT, 8, 1.0, 0.1 ),
	DEFINE_DELTA( body, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( rendercolor.r, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( rendercolor.g, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( rendercolor.b, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( renderfx, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( renderamt, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( frame, DT_FLOAT, 8, 1.0 ),
	DEFINE_DELTA_POST( animtime, DT_FLOAT, 8, 1.0, 0.1 )
}

usercmd_t none
{
	DEFINE_DELTA( lerp_msec, DT_SHORT, 9, 1.0 ),
	DEFINE_DELTA( msec, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( viewangles[1], DT_ANGLE, 16, 1.0 ),
	DEFINE_DELTA( viewangles[0], DT_ANGLE, 16, 1.0 ),
	DEFINE_DELTA( buttons, DT_SHORT, 16, 1.0 ),
	DEFINE_DELTA( forwardmove, DT_SIGNED | DT_FLOAT, 12, 1.0 ),
	DEFINE_DELTA( lightlevel, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( sidemove, DT_SIGNED | DT_FLOAT, 12, 1.0 ),
	DEFINE_DELTA( upmove, DT_SIGNED | DT_FLOAT, 12, 1.0 ),
	DEFINE_DELTA( impulse, DT_BYTE, 8, 1.0 ),
	DEFINE_DELTA( viewangles[2], DT_ANGLE, 16, 1.0 ),
	DEFINE_DELTA( impact_index, DT_INTEGER, 6, 1.0 ),
	DEFINE_DELTA( impact_position[0], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( impact_position[1], DT_SIGNED | DT_FLOAT, 16, 8.0 ),
	DEFINE_DELTA( impact_position[2], DT_SIGNED | DT_FLOAT, 16, 8.0 )
}

weapon_data_t none
{
	DEFINE_DELTA( m_flTimeWeaponIdle, DT_FLOAT | DT_SIGNED, 22, 1000.0 ),
	DEFINE_DELTA( m_flNextPrimaryAttack, DT_FLOAT | DT_SIGNED, 22, 1000.0 ),
	DEFINE_DELTA( m_flNextReload, DT_FLOAT | DT_SIGNED, 22, 1000.0 ),
	DEFINE_DELTA( m_fNextAimBonus, DT_FLOAT | DT_SIGNED, 22, 1000.0 ),
	DEFINE_DELTA( m_flNextSecondaryAttack, DT_FLOAT | DT_SIGNED, 22, 1000.0 ),
	DEFINE_DELTA( m_iClip, DT_SIGNED | DT_INTEGER, 10, 1.0 ),
	DEFINE_DELTA( m_flPumpTime, DT_FLOAT | DT_SIGNED, 22, 1000.0 ),
	DEFINE_DELTA( m_fInSpecialReload, DT_INTEGER, 2, 1.0 ),
	DEFINE_DELTA( m_fReloadTime, DT_FLOAT, 16, 100.0 ),
	DEFINE_DELTA( m_fInReload, DT_INTEGER, 1, 1.0 ),
	DEFINE_DELTA( m_fAimedDamage, DT_FLOAT, 22, 1000.0 ),
	DEFINE_DELTA( m_fInZoom, DT_INTEGER, 8, 1.0 ),
	DEFINE_DELTA( m_iWeaponState, DT_INTEGER, 7, 1.0 )
	DEFINE_DELTA( m_iId, DT_INTEGER, 5, 1.0 )
	DEFINE_DELTA( fuser1, DT_SIGNED | DT_FLOAT, 22, 1000.0 ),
	DEFINE_DELTA( fuser2, DT_SIGNED | DT_FLOAT, 22, 128.0  ),
	DEFINE_DELTA( fuser3, DT_SIGNED | DT_FLOAT, 22, 128.0  ),
	DEFINE_DELTA( iuser1, DT_SIGNED | DT_INTEGER, 16, 128.0 )
}

event_t none
{
	DEFINE_DELTA( entindex, DT_INTEGER, 11, 1.0 ),
	DEFINE_DELTA( bparam1, DT_INTEGER, 1, 1.0 ),
	DEFINE_DELTA( bparam2, DT_INTEGER, 1, 1.0 ),
	DEFINE_DELTA( origin[0], DT_SIGNED | DT_FLOAT, 26, 8192.0 ),
	DEFINE_DELTA( origin[1], DT_SIGNED | DT_FLOAT, 26, 8192.0 ),
	DEFINE_DELTA( origin[2], DT_SIGNED | DT_FLOAT, 26, 8192.0 ),
	DEFINE_DELTA( fparam1, DT_FLOAT | DT_SIGNED, 20, 100.0 ),
	DEFINE_DELTA( fparam2, DT_FLOAT | DT_SIGNED, 20, 100.0 ),
	DEFINE_DELTA( iparam1, DT_INTEGER | DT_SIGNED, 18, 1.0 ),
	DEFINE_DELTA( iparam2, DT_INTEGER | DT_SIGNED, 18, 1.0 ),
	DEFINE_DELTA( angles[0], DT_SIGNED | DT_FLOAT, 26, 8192.0 ),
	DEFINE_DELTA( angles[1], DT_SIGNED | DT_FLOAT, 26, 8192.0 ),
	DEFINE_DELTA( angles[2], DT_SIGNED | DT_FLOAT, 26, 8192.0 ),
	DEFINE_DELTA( ducking, DT_INTEGER, 1, 1.0 )
}

```

`pm_shared/pm_debug.cpp`:

```cpp
#include "mathlib.h"
#include "const.h"
#include "usercmd.h"
#include "pm_defs.h"
#include "pm_shared.h"
#include "pm_movevars.h"
#include "pm_debug.h"

#include <string.h>
#undef vec3_t

// Expand debugging BBOX particle hulls by this many units.
#define BOX_GAP 0.0f

int PM_boxpnt[6][4] =
{
	{ 0, 4, 6, 2 }, // +X
	{ 0, 1, 5, 4 }, // +Y
	{ 0, 2, 3, 1 }, // +Z
	{ 7, 5, 1, 3 }, // -X
	{ 7, 3, 2, 6 }, // -Y
	{ 7, 6, 4, 5 }, // -Z
};

void PM_ShowClipBox()
{
#ifdef _DEBUG
	if (!pmove->runfuncs)
		return;

	// More debugging, draw the particle bbox for player and for the entity we are looking directly at.
	// aslo prints entity info to the console overlay.
	if (!pmove->server)
		return;

	// Draw entity in center of view
	// Also draws the normal to the clip plane that intersects our movement ray. Leaves a particle
	// trail at the intersection point.
	PM_ViewEntity();

	// Show our BBOX in particles.
 	//PM_DrawBBox(pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], pmove->origin, 132, 0.1);
/*
	{
		int i;
		for (i = 0; i < pmove->numphysent; i++)
		{
			if (pmove->physents[ i ].info >= 1 && pmove->physents[ i ].info <= 4)
			{
			 	PM_DrawBBox(pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], pmove->physents[i].origin, 132, 0.1);
			}
		}
	}
*/
#endif // _DEBUG
}

void PM_ParticleLine(vec3_t start, vec3_t end, int pcolor, float life, float vert)
{
	float linestep = 2.0f;
	float curdist;
	float len;
	vec3_t curpos;
	vec3_t diff;
	int i;
	// Determine distance;

	VectorSubtract(end, start, diff);

	len = VectorNormalize(diff);

	curdist = 0;
	while (curdist <= len)
	{
		for (i = 0; i < 3; ++i)
			curpos[i] = start[i] + curdist * diff[i];

		pmove->PM_Particle(curpos, pcolor, life, 0, vert);
		curdist += linestep;
	}
}

void PM_DrawRectangle(vec3_t tl, vec3_t bl, vec3_t tr, vec3_t br, int pcolor, float life)
{
	PM_ParticleLine(tl, bl, pcolor, life, 0);
	PM_ParticleLine(bl, br, pcolor, life, 0);
	PM_ParticleLine(br, tr, pcolor, life, 0);
	PM_ParticleLine(tr, tl, pcolor, life, 0);
}

void PM_DrawPhysEntBBox(int num, int pcolor, float life)
{
	physent_t *pe;
	vec3_t org;
	int j;
	vec3_t tmp;
	vec3_t p[8];
	float gap = BOX_GAP;
	vec3_t modelmins, modelmaxs;

	if (num >= pmove->numphysent || num <= 0)
		return;

	pe = &pmove->physents[num];

	if (pe->model)
	{
		VectorCopy(pe->origin, org);

		pmove->PM_GetModelBounds(pe->model, modelmins, modelmaxs);
		for (j = 0; j < 8; ++j)
		{
			tmp[0] = (j & 1) ? modelmins[0] - gap : modelmaxs[0] + gap;
			tmp[1] = (j & 2) ? modelmins[1] - gap : modelmaxs[1] + gap;
			tmp[2] = (j & 4) ? modelmins[2] - gap : modelmaxs[2] + gap;

			VectorCopy(tmp, p[j]);
		}

		// If the bbox should be rotated, do that
		if (pe->angles[0] || pe->angles[1] || pe->angles[2])
		{
			vec3_t forward, right, up;

			AngleVectorsTranspose(pe->angles, forward, right, up);
			for (j = 0; j < 8; ++j)
			{
				VectorCopy(p[j], tmp);
				p[j][0] = DotProduct(tmp, forward);
				p[j][1] = DotProduct(tmp, right);
				p[j][2] = DotProduct(tmp, up);
			}
		}

		// Offset by entity origin, if any.
		for (j = 0; j < 8; ++j)
			VectorAdd(p[j], org, p[j]);

		for (j = 0; j < 6; ++j)
		{
			PM_DrawRectangle(
				p[PM_boxpnt[j][1]],
				p[PM_boxpnt[j][0]],
				p[PM_boxpnt[j][2]],
				p[PM_boxpnt[j][3]],
				pcolor, life);
		}
	}
	else
	{
		for (j = 0; j < 8; ++j)
		{
			tmp[0] = (j & 1) ? pe->mins[0] : pe->maxs[0];
			tmp[1] = (j & 2) ? pe->mins[1] : pe->maxs[1];
			tmp[2] = (j & 4) ? pe->mins[2] : pe->maxs[2];

			VectorAdd(tmp, pe->origin, tmp);
			VectorCopy(tmp, p[j]);
		}

		for (j = 0; j < 6; ++j)
		{
			PM_DrawRectangle(
				p[PM_boxpnt[j][1]],
				p[PM_boxpnt[j][0]],
				p[PM_boxpnt[j][2]],
				p[PM_boxpnt[j][3]],
				pcolor, life);
		}
	}
}

void PM_DrawBBox(vec3_t mins, vec3_t maxs, vec3_t origin, int pcolor, float life)
{
	int j;

	vec3_t tmp;
	vec3_t p[8];
	float gap = BOX_GAP;

	for (j = 0; j < 8; ++j)
	{
		tmp[0] = (j & 1) ? mins[0] - gap : maxs[0] + gap;
		tmp[1] = (j & 2) ? mins[1] - gap : maxs[1] + gap;
		tmp[2] = (j & 4) ? mins[2] - gap : maxs[2] + gap;

		VectorAdd(tmp, origin, tmp);
		VectorCopy(tmp, p[j]);
	}

	for (j = 0; j < 6; ++j)
	{
		PM_DrawRectangle(
			p[PM_boxpnt[j][1]],
			p[PM_boxpnt[j][0]],
			p[PM_boxpnt[j][2]],
			p[PM_boxpnt[j][3]],
			pcolor, life);
	}
}

// Shows a particle trail from player to entity in crosshair.
// Shows particles at that entities bbox
// Tries to shoot a ray out by about 128 units.

void PM_ViewEntity()
{
	vec3_t forward, right, up;
	float raydist = 256.0f;
	vec3_t origin;
	vec3_t end;
	int i;
	pmtrace_t trace;
	int pcolor = 77;
	float fup;

#if 0
	if (!pm_showclip.value)
		return;
#endif

	// Determine movement angles
	AngleVectors(pmove->angles, forward, right, up);

	VectorCopy(pmove->origin, origin);

	fup = 0.5 * (pmove->_player_mins[pmove->usehull][2] + pmove->_player_maxs[pmove->usehull][2]);
	fup += pmove->view_ofs[2];
	fup -= 4;

	for (i = 0; i < 3; i++)
	{
		end[i] = origin[i] + raydist * forward[i];
	}

	trace = pmove->PM_PlayerTrace(origin, end, PM_STUDIO_BOX, -1);

	// Not the world
	if (trace.ent > 0)
	{
		pcolor = 111;
	}

	// Draw the hull or bbox.
	if (trace.ent > 0)
	{
		PM_DrawPhysEntBBox(trace.ent, pcolor, 0.3f);
	}
}

```

`pm_shared/pm_debug.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_DEBUG_H
#define PM_DEBUG_H
#ifdef _WIN32
#pragma once
#endif

void PM_ShowClipBox();
void PM_ParticleLine(vec3_t start, vec3_t end, int pcolor, float life, float vert);
void PM_DrawRectangle(vec3_t tl, vec3_t bl, vec3_t tr, vec3_t br, int pcolor, float life);
void PM_DrawPhysEntBBox(int num, int pcolor, float life);
void PM_DrawBBox(vec3_t mins, vec3_t maxs, vec3_t origin, int pcolor, float life);
void PM_ViewEntity();

#endif // PM_DEBUG_H

```

`pm_shared/pm_defs.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_DEFS_H
#define PM_DEFS_H
#ifdef _WIN32
#pragma once
#endif

#define MAX_PHYSENTS 600 		  		// Must have room for all entities in the world.
#define MAX_MOVEENTS 64
#define MAX_CLIP_PLANES	5

#define PM_NORMAL			0x00000000
#define PM_STUDIO_IGNORE		0x00000001	// Skip studio models
#define PM_STUDIO_BOX			0x00000002	// Use boxes for non-complex studio models (even in traceline)
#define PM_GLASS_IGNORE			0x00000004	// Ignore entities with non-normal rendermode
#define PM_WORLD_ONLY			0x00000008	// Only trace against the world

#define PM_TRACELINE_PHYSENTSONLY	0
#define PM_TRACELINE_ANYVISIBLE		1

#include "pm_info.h"
#include "pmtrace.h"

#ifndef USERCMD_H
#include "usercmd.h"
#endif

#include "const.h"

typedef struct physent_s
{
	char name[32];					// Name of model, or "player" or "world".
	int player;
	vec3_t origin;					// Model's origin in world coordinates.
	struct model_s *model;				// only for bsp models
	struct model_s *studiomodel;			// SOLID_BBOX, but studio clip intersections.
	vec3_t mins, maxs;				// only for non-bsp models
	int info;					// For client or server to use to identify (index into edicts or cl_entities)
	vec3_t angles;					// rotated entities need this info for hull testing to work.

	int solid;					// Triggers and func_door type WATER brushes are SOLID_NOT
	int skin;					// BSP Contents for such things like fun_door water brushes.
	int rendermode;					// So we can ignore glass

	float frame;
	int sequence;
	byte controller[4];
	byte blending[2];

	int movetype;
	int takedamage;
	int blooddecal;
	int team;
	int classnumber;

	int iuser1;
	int iuser2;
	int iuser3;
	int iuser4;
	float fuser1;
	float fuser2;
	float fuser3;
	float fuser4;
	vec3_t vuser1;
	vec3_t vuser2;
	vec3_t vuser3;
	vec3_t vuser4;

} physent_t;

typedef struct playermove_s
{
	int player_index;				// So we don't try to run the PM_CheckStuck nudging too quickly.
	qboolean server;				// For debugging, are we running physics code on server side?
	qboolean multiplayer;				// 1 == multiplayer server
	float time;					// realtime on host, for reckoning duck timing
	float frametime;				// Duration of this frame
	vec3_t forward, right, up;			// Vectors for angles
	vec3_t origin;					// Movement origin.
	vec3_t angles;					// Movement view angles.
	vec3_t oldangles;				// Angles before movement view angles were looked at.
	vec3_t velocity;				// Current movement direction.
	vec3_t movedir;					// For waterjumping, a forced forward velocity so we can fly over lip of ledge.
	vec3_t basevelocity;				// Velocity of the conveyor we are standing, e.g.
	vec3_t view_ofs;				// For ducking/dead
							// Our eye position.
	float flDuckTime;				// Time we started duck
	qboolean bInDuck;				// In process of ducking or ducked already?
	int flTimeStepSound;				// For walking/falling
							// Next time we can play a step sound
	int iStepLeft;
	float flFallVelocity;
	vec3_t punchangle;
	float flSwimTime;
	float flNextPrimaryAttack;
	int effects;					// MUZZLE FLASH, e.g.
	int flags;					// FL_ONGROUND, FL_DUCKING, etc.
	int usehull;					// 0 = regular player hull, 1 = ducked player hull, 2 = point hull
	float gravity;					// Our current gravity and friction.
	float friction;
	int oldbuttons;					// Buttons last usercmd
	float waterjumptime;				// Amount of time left in jumping out of water cycle.
	qboolean dead;					// Are we a dead player?
	int deadflag;
	int spectator;					// Should we use spectator physics model?
	int movetype;					// Our movement type, NOCLIP, WALK, FLY
	int onground;					// -1 = in air, else pmove entity number
	int waterlevel;
	int watertype;
	int oldwaterlevel;
	char sztexturename[256];
	char chtexturetype;
	float maxspeed;
	float clientmaxspeed;
	int iuser1;
	int iuser2;
	int iuser3;
	int iuser4;
	float fuser1;
	float fuser2;
	float fuser3;
	float fuser4;
	vec3_t vuser1;
	vec3_t vuser2;
	vec3_t vuser3;
	vec3_t vuser4;
	int numphysent;					// world state
							// Number of entities to clip against.
	physent_t physents[MAX_PHYSENTS];
	int nummoveent;					// Number of momvement entities (ladders)
	physent_t moveents[MAX_MOVEENTS];		// just a list of ladders
	int numvisent;					// All things being rendered, for tracing against things you don't actually collide with
	physent_t visents[MAX_PHYSENTS];
	usercmd_t cmd;					// input to run through physics.
	int numtouch;					// Trace results for objects we collided with.
	pmtrace_t touchindex[MAX_PHYSENTS];
	char physinfo[MAX_PHYSINFO_STRING];		// Physics info string
	struct movevars_s *movevars;
	vec_t _player_mins[4][3];
	vec_t _player_maxs[4][3];

	const char *(*PM_Info_ValueForKey)(const char *s, const char *key);
	void (*PM_Particle)(float *origin, int color, float life, int zpos, int zvel);
	int (*PM_TestPlayerPosition)(float *pos, pmtrace_t *ptrace);
	void (*Con_NPrintf)(int idx, const char *fmt, ...);
	void (*Con_DPrintf)(const char *fmt, ...);
	void (*Con_Printf)(const char *fmt, ...);
	double (*Sys_FloatTime)();
	void (*PM_StuckTouch)(int hitent, pmtrace_t *ptraceresult);
	int (*PM_PointContents)(float *p, int *truecontents);
	int (*PM_TruePointContents)(float *p);
	int (*PM_HullPointContents)(struct hull_s *hull, int num, float *p);
	pmtrace_t (*PM_PlayerTrace)(float *start, float *end, int traceFlags, int ignore_pe);
	struct pmtrace_s *(*PM_TraceLine)(float *start, float *end, int flags, int usehulll, int ignore_pe);
	int (*RandomLong)(int lLow, int lHigh);
	float (*RandomFloat)(float flLow, float flHigh);
	int (*PM_GetModelType)(struct model_s *mod);
	void (*PM_GetModelBounds)(struct model_s *mod, float *mins, float *maxs);
	void *(*PM_HullForBsp)(physent_t *pe, float *offset);
	float (*PM_TraceModel)(physent_t *pEnt, float *start, float *end, trace_t *trace);
	int (*COM_FileSize)(char *filename);
	byte *(*COM_LoadFile)(char *path, int usehunk, int *pLength);
	void (*COM_FreeFile)(void *buffer);
	char *(*memfgets)(byte *pMemFile, int fileSize, int *pFilePos, char *pBuffer, int bufferSize);
	qboolean runfuncs;
	void (*PM_PlaySound)(int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch);
	const char *(*PM_TraceTexture)(int ground, float *vstart, float *vend);
	void (*PM_PlaybackEventFull)(int flags, int clientindex, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2);

} playermove_t;

#endif // PM_DEFS_H

```

`pm_shared/pm_info.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_INFO_H
#define PM_INFO_H
#ifdef _WIN32
#pragma once
#endif

#define MAX_PHYSINFO_STRING 256

#endif // PM_INFO_H

```

`pm_shared/pm_materials.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_MATERIALS_H
#define PM_MATERIALS_H
#ifdef _WIN32
#pragma once
#endif

#define CTEXTURESMAX		1024	// max number of textures loaded
#define CBTEXTURENAMEMAX	17	// only load first n chars of name

#define CHAR_TEX_CONCRETE	'C'	// texture types
#define CHAR_TEX_METAL		'M'
#define CHAR_TEX_DIRT		'D'
#define CHAR_TEX_VENT		'V'
#define CHAR_TEX_GRATE		'G'
#define CHAR_TEX_TILE		'T'
#define CHAR_TEX_SLOSH		'S'
#define CHAR_TEX_WOOD		'W'
#define CHAR_TEX_COMPUTER	'P'
#define CHAR_TEX_GRASS		'X'
#define CHAR_TEX_GLASS		'Y'
#define CHAR_TEX_FLESH		'F'
#define CHAR_TEX_SNOW		'N'

#endif // PM_MATERIALS_H

```

`pm_shared/pm_math.cpp`:

```cpp
#include "mathlib.h"
#include "const.h"
#include <math.h>
/*
* Globals initialization
*/
vec3_t vec3_origin = {0, 0, 0};
int nanmask = 255<<23;

float anglemod(float a)
{
	a = (360.0 / 65536) * ((int)(a  *(65536 / 360.0)) & 65535);
	return a;
}

void AngleVectors(const vec_t *angles, vec_t *forward, vec_t *right, vec_t *up)
{
	float sr, sp, sy, cr, cp;

	float cy;
	float angle;

	angle = (float)(angles[YAW] * (M_PI * 2 / 360));
	sy = sin(angle);
	cy = cos(angle);

	angle = (float)(angles[PITCH] * (M_PI * 2 / 360));
	sp = sin(angle);
	cp = cos(angle);

	angle = (float)(angles[ROLL] * (M_PI * 2 / 360));
	sr = sin(angle);
	cr = cos(angle);

	if (forward)
	{
		forward[0] = cp * cy;
		forward[1] = cp * sy;
		forward[2] = -sp;
	}
	if (right)
	{
		right[0] = (-1 * sr * sp * cy + -1 * cr * -sy);
		right[1] = (-1 * sr * sp * sy + -1 * cr * cy);
		right[2] = -1 * sr * cp;
	}
	if (up)
	{
		up[0] = (cr * sp * cy + -sr * -sy);
		up[1] = (cr * sp * sy + -sr * cy);
		up[2] = cr * cp;
	}
}

void AngleVectorsTranspose(const vec_t *angles, vec_t *forward, vec_t *right, vec_t *up)
{
	float angle;
	float sr, sp, sy, cr, cp, cy;

	angle = angles[YAW] * (M_PI * 2 / 360);
	sy = sin(angle);
	cy = cos(angle);
	angle = angles[PITCH] * (M_PI * 2 / 360);
	sp = sin(angle);
	cp = cos(angle);
	angle = angles[ROLL] * (M_PI * 2 / 360);
	sr = sin(angle);
	cr = cos(angle);

	if (forward)
	{
		forward[0] = cp * cy;
		forward[1] = (sr * sp * cy + cr * -sy);
		forward[2] = (cr * sp * cy + -sr * -sy);
	}
	if (right)
	{
		right[0] = cp * sy;
		right[1] = (sr * sp * sy + cr * cy);
		right[2] = (cr * sp * sy + -sr * cy);
	}
	if (up)
	{
		up[0] = -sp;
		up[1] = sr * cp;
		up[2] = cr * cp;
	}
}

void AngleMatrix(const vec_t *angles, float (*matrix)[4])
{
	float angle;
	float  sr, sp, sy, cr, cp, cy;

	angle = (float)(angles[ROLL] * (M_PI * 2 / 360));
	sy = sin(angle);
	cy = cos(angle);

	angle = (float)(angles[YAW] * (M_PI * 2 / 360));
	sp = sin(angle);
	cp = cos(angle);

	angle = (float)(angles[PITCH] * (M_PI * 2 / 360));
	sr = sin(angle);
	cr = cos(angle);

	matrix[0][0] = cr * cp;
	matrix[1][0] = cr * sp;
	matrix[2][0] = -sr;

	matrix[0][1] = (sy * sr) * cp - cy * sp;
	matrix[1][1] = (sy * sr) * sp + cy * cp;
	matrix[2][1] = sy * cr;

	matrix[0][2] = (cy * sr) * cp + sy * sp;
	matrix[1][2] = (cy * sr) * sp - sy * cp;
	matrix[2][2] = cy * cr;

	matrix[0][3] = 0.0f;
	matrix[1][3] = 0.0f;
	matrix[2][3] = 0.0f;
}

void AngleIMatrix(const vec_t *angles, float (*matrix)[4])
{
	float angle;
	float sr, sp, sy, cr, cp, cy;

	angle = angles[YAW] * (M_PI * 2 / 360);
	sy = sin(angle);
	cy = cos(angle);
	angle = angles[PITCH] * (M_PI * 2 / 360);
	sp = sin(angle);
	cp = cos(angle);
	angle = angles[ROLL] * (M_PI * 2 / 360);
	sr = sin(angle);
	cr = cos(angle);

	// matrix = (YAW * PITCH) * ROLL
	matrix[0][0] = cp * cy;
	matrix[0][1] = cp * sy;
	matrix[0][2] = -sp;
	matrix[1][0] = sr * sp * cy + cr * -sy;
	matrix[1][1] = sr * sp * sy + cr * cy;
	matrix[1][2] = sr * cp;
	matrix[2][0] = (cr * sp * cy + -sr * -sy);
	matrix[2][1] = (cr * sp * sy + -sr * cy);
	matrix[2][2] = cr * cp;
	matrix[0][3] = 0.0;
	matrix[1][3] = 0.0;
	matrix[2][3] = 0.0;
}

void NormalizeAngles(float *angles)
{
	int i;
	// Normalize angles
	for (i = 0; i < 3; ++i)
	{
		if (angles[i] > 180.0)
		{
			angles[i] -= 360.0;
		}
		else if (angles[i] < -180.0)
		{
			angles[i] += 360.0;
		}
	}
}

// Interpolate Euler angles.
// FIXME:  Use Quaternions to avoid discontinuities
// Frac is 0.0 to 1.0 (i.e., should probably be clamped, but doesn't have to be)

void InterpolateAngles(float *start, float *end, float *output, float frac)
{
	int i;
	float ang1, ang2;
	float d;

	NormalizeAngles(start);
	NormalizeAngles(end);

	for (i = 0; i < 3; ++i)
	{
		ang1 = start[i];
		ang2 = end[i];

		d = ang2 - ang1;
		if (d > 180)
		{
			d -= 360;
		}
		else if (d < -180)
		{
			d += 360;
		}

		output[i] = ang1 + d * frac;
	}

	NormalizeAngles(output);
}

float AngleBetweenVectors(const vec_t *v1, const vec_t *v2)
{
	float angle;
	float l1 = Length(v1);
	float l2 = Length(v2);

	if (!l1 || !l2)
		return 0.0f;

	angle = acos(DotProduct(v1, v2)) / (l1 * l2);
	angle = (angle * 180.0f) / M_PI;

	return angle;
}

void VectorTransform(const vec_t *in1, float (*in2)[4], vec_t *out)
{
	out[0] = DotProduct(in1, in2[0]) + in2[0][3];
	out[1] = DotProduct(in1, in2[1]) + in2[1][3];
	out[2] = DotProduct(in1, in2[2]) + in2[2][3];
}

int VectorCompare(const vec_t *v1, const vec_t *v2)
{
	int i;
	for (i = 0; i < 3; ++i)
	{
		if (v1[i] != v2[i])
			return 0;
	}

	return 1;
}

void VectorMA(const vec_t *veca, float scale, const vec_t *vecb, vec_t *vecc)
{
	vecc[0] = veca[0] + scale * vecb[0];
	vecc[1] = veca[1] + scale * vecb[1];
	vecc[2] = veca[2] + scale * vecb[2];
}

float _DotProduct(const vec_t *v1, const vec_t *v2)
{
	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
}

void _VectorSubtract(vec_t *veca, vec_t *vecb, vec_t *out)
{
	out[0] = veca[0] - vecb[0];
	out[1] = veca[1] - vecb[1];
	out[2] = veca[2] - vecb[2];
}

void _VectorAdd(vec_t *veca, vec_t *vecb, vec_t *out)
{
	out[0] = veca[0] + vecb[0];
	out[1] = veca[1] + vecb[1];
	out[2] = veca[2] + vecb[2];
}

void _VectorCopy(vec_t *in, vec_t *out)
{
	out[0] = in[0];
	out[1] = in[1];
	out[2] = in[2];
}

void _CrossProduct(const vec_t *v1, const vec_t *v2, vec_t *cross)
{
	cross[0] = v1[1] * v2[2] - v1[2] * v2[1];
	cross[1] = v1[2] * v2[0] - v1[0] * v2[2];
	cross[2] = v1[0] * v2[1] - v1[1] * v2[0];
}

float Length(const vec_t *v)
{
	int i;
	float length = 0.0f;

	for (i = 0; i < 3; ++i)
		length += v[i] * v[i];

	return sqrt(length);
}

float Distance(const vec_t *v1, const vec_t *v2)
{
	vec_t d[3];
	VectorSubtract(v2, v1, d);
	return Length(d);
}

float VectorNormalize(vec_t *v)
{
	float length;
	float ilength;

	length = sqrt((float)(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]));

	if (length)
	{
		ilength = 1.0 / length;

		v[0] *= ilength;
		v[1] *= ilength;
		v[2] *= ilength;
	}

	return length;
}

void VectorInverse(vec_t *v)
{
	v[0] = -v[0];
	v[1] = -v[1];
	v[2] = -v[2];
}

void VectorScale(const vec_t *in, vec_t scale, vec_t *out)
{
	out[0] = scale * in[0];
	out[1] = scale * in[1];
	out[2] = scale * in[2];
}

int Q_log2(int val)
{
	int answer = 0;
	while (val >>= 1)
		++answer;

	return answer;
}

void VectorMatrix(vec_t *forward, vec_t *right, vec_t *up)
{
	vec_t tmp[3];

	if (forward[0] == 0 && forward[1] == 0)
	{
		right[0] = 1;
		right[1] = 0;
		right[2] = 0;

		up[0] = -forward[2];
		up[1] = 0;
		up[2] = 0;
		return;
	}

	tmp[0] = 0;
	tmp[1] = 0;
	tmp[2] = 1.0f;

	_CrossProduct(forward, tmp, right);
	VectorNormalize(right);
	_CrossProduct(right, forward, up);
	VectorNormalize(up);
}

void VectorAngles(const vec_t *forward, vec_t *angles)
{
	float tmp, yaw, pitch;

	if (forward[1] == 0 && forward[0] == 0)
	{
		yaw = 0;
		if (forward[2] > 0)
			pitch = 90;
		else
			pitch = 270;
	}
	else
	{
		yaw = (atan2(forward[1], forward[0]) * 180 / M_PI);
		if (yaw < 0)
			yaw += 360;

		tmp = sqrt (forward[0] * forward[0] + forward[1] * forward[1]);
		pitch = (atan2(forward[2], tmp) * 180 / M_PI);
		if (pitch < 0)
			pitch += 360;
	}

	angles[0] = pitch;
	angles[1] = yaw;
	angles[2] = 0;
}

```

`pm_shared/pm_math.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_MATH_H
#define PM_MATH_H
#ifdef _WIN32
#pragma once
#endif

#define PITCH	0	// up/down
#define YAW	1	// left/right
#define ROLL	2	// fall over

extern vec3_t vec3_origin;
extern int nanmask;

#define IS_NAN(x)	((*reinterpret_cast<int *>(&(x)) & nanmask) == nanmask)

float anglemod(float a);
void  AngleVectors(const vec_t *angles, vec_t *forward, vec_t *right, vec_t *up);
void  AngleVectorsTranspose(const vec_t *angles, vec_t *forward, vec_t *right, vec_t *up);
void  AngleMatrix(const vec_t *angles, float (*matrix)[4]);
void  AngleIMatrix(const vec_t *angles, float (*matrix)[4]);
void  NormalizeAngles(float *angles);
void  InterpolateAngles(float *start, float *end, float *output, float frac);
float AngleBetweenVectors(const vec_t *v1, const vec_t *v2);
void VectorTransform(const vec_t *in1, float (*in2)[4], vec_t *out);
int   VectorCompare(const vec_t *v1, const vec_t *v2);
void  VectorMA(const vec_t *veca, float scale, const vec_t *vecb, vec_t *vecc);

float _DotProduct(const vec_t *v1, const vec_t *v2);
void  _VectorSubtract(vec_t *veca, vec_t *vecb, vec_t *out);
void  _VectorAdd(vec_t *veca, vec_t *vecb, vec_t *out);
void  _VectorCopy(vec_t *in, vec_t *out);
void  _CrossProduct(const vec_t *v1, const vec_t *v2, vec_t *cross);

float Length(const vec_t *v);
float Distance(const vec_t *v1, const vec_t *v2);
float VectorNormalize(vec_t *v);

void  VectorInverse(vec_t *v);
void  VectorScale(const vec_t *in, vec_t scale, vec_t *out);
int   Q_log2(int val);
void  VectorMatrix(vec_t *forward, vec_t *right, vec_t *up);
void  VectorAngles(const vec_t *forward, vec_t *angles);

#endif // PM_MATH_H

```

`pm_shared/pm_movevars.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_MOVEVARS_H
#define PM_MOVEVARS_H
#ifdef _WIN32
#pragma once
#endif

typedef struct movevars_s
{
	float gravity;			// Gravity for map
	float stopspeed;		// Deceleration when not moving
	float maxspeed;			// Max allowed speed
	float spectatormaxspeed;
	float accelerate;		// Acceleration factor
	float airaccelerate;		// Same for when in open air
	float wateraccelerate;		// Same for when in water
	float friction;
	float edgefriction;		// Extra friction near dropofs
	float waterfriction;		// Less in water
	float entgravity;		// 1.0
	float bounce;			// Wall bounce value. 1.0
	float stepsize;			// sv_stepsize;
	float maxvelocity;		// maximum server velocity.
	float zmax;			// Max z-buffer range (for GL)
	float waveHeight;		// Water wave height (for GL)
	qboolean footsteps;		// Play footstep sounds
	char skyName[32];		// Name of the sky map
	float rollangle;
	float rollspeed;
	float skycolor_r;		// Sky color
	float skycolor_g;
	float skycolor_b;
	float skyvec_x;			// Sky vector
	float skyvec_y;
	float skyvec_z;

} movevars_t;

#endif // PM_MOVEVARS_H

```

`pm_shared/pm_shared.cpp`:

```cpp
#include <assert.h>
#include "mathlib.h"
#include "const.h"
#include "usercmd.h"
#include "pm_defs.h"
#include "pm_shared.h"
#include "pm_movevars.h"
#include "pm_materials.h"
#include "pm_debug.h"
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "com_model.h"

#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif

#ifndef max
#define max(a, b) ((a) > (b) ? (a) : (b))
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 1
#endif


#ifdef CLIENT_DLL
	int iJumpSpectator;
	float vJumpOrigin[3];
	float vJumpAngles[3];
#endif

/*
* Globals initialization
*/
int pm_shared_initialized = 0;

vec3_t rgv3tStuckTable[54];
int rgStuckLast[MAX_CLIENTS][2];

int pm_gcTextures = 0;
char pm_grgszTextureName[1024][17];
char pm_grgchTextureType[1024];

playermove_t *pmove = NULL;
int g_onladder = 0;

void PM_SwapTextures(int i, int j)
{
	char chTemp;
	char szTemp[CBTEXTURENAMEMAX];

	strcpy(szTemp, pm_grgszTextureName[i]);
	chTemp = pm_grgchTextureType[i];

	strcpy(pm_grgszTextureName[i], pm_grgszTextureName[j]);
	pm_grgchTextureType[i] = pm_grgchTextureType[j];

	strcpy(pm_grgszTextureName[j], szTemp);
	pm_grgchTextureType[j] = chTemp;
}

int PM_IsThereGrassTexture()
{
	int i;

	for (i = 0; i < pm_gcTextures; ++i)
	{
		if (pm_grgchTextureType[i] == CHAR_TEX_GRASS)
			return 1;
	}

	return 0;
}

void PM_SortTextures()
{
	// Bubble sort, yuck, but this only occurs at startup and it's only 512 elements...
	int i, j;

	for (i = 0; i < pm_gcTextures; ++i)
	{
		for (j = i + 1; j < pm_gcTextures; j++)
		{
			if (stricmp(pm_grgszTextureName[i], pm_grgszTextureName[j]) > 0)
			{
				// Swap
				PM_SwapTextures(i, j);
			}
		}
	}
}

void PM_InitTextureTypes()
{
	char buffer[512];
	int i, j;
	byte *pMemFile;
	int fileSize, filePos;
	static qboolean bTextureTypeInit = false;

	if (bTextureTypeInit)
		return;

	memset(&(pm_grgszTextureName[0][0]), 0, sizeof(pm_grgszTextureName));
	memset(pm_grgchTextureType, 0, sizeof(pm_grgchTextureType));

	pm_gcTextures = 0;
	memset(buffer, 0, sizeof(buffer));

	fileSize = pmove->COM_FileSize((char*)"sound/materials.txt");
	pMemFile = pmove->COM_LoadFile((char*)"sound/materials.txt", 5, NULL);

	if (!pMemFile)
		return;

	filePos = 0;
	fileSize = 0;

	// for each line in the file...
	while (pmove->memfgets(pMemFile, fileSize, &filePos, buffer, sizeof(buffer) - 1) != NULL && (pm_gcTextures < CTEXTURESMAX))
	{
		// skip whitespace
		i = 0;
		while (buffer[i] && isspace(buffer[i]))
			++i;

		if (!buffer[i])
			continue;

		// skip comment lines
		if (buffer[i] == '/' || !isalpha(buffer[i]))
			continue;

		// get texture type
		pm_grgchTextureType[pm_gcTextures] = toupper(buffer[i++]);

		// skip whitespace
		while (buffer[i] && isspace(buffer[i]))
			++i;

		if (!buffer[i])
			continue;

		// get sentence name
		j = i;
		while (buffer[j] && !isspace(buffer[j]))
			j++;

		if (!buffer[j])
			continue;

		// null-terminate name and save in sentences array
		j = min(j, CBTEXTURENAMEMAX - 1 + i);
		buffer[j] = '\0';

		strcpy(&(pm_grgszTextureName[pm_gcTextures++][0]), &(buffer[i]));
	}

	// Must use engine to free since we are in a .dll
	pmove->COM_FreeFile(pMemFile);

	PM_SortTextures();
	bTextureTypeInit = true;
}

char PM_FindTextureType(char *name)
{
	int left, right, pivot;
	int val;

	assert(pm_shared_initialized);

	left = 0;
	right = pm_gcTextures - 1;

	while (left <= right)
	{
		pivot = (left + right) / 2;

		val = strnicmp(name, pm_grgszTextureName[pivot], CBTEXTURENAMEMAX - 1);

		if (val == 0)
		{
			return pm_grgchTextureType[pivot];
		}
		else if (val > 0)
		{
			left = pivot + 1;
		}
		else if (val < 0)
		{
			right = pivot - 1;
		}
	}

	return CHAR_TEX_CONCRETE;
}

void PM_PlayStepSound(int step, float fvol)
{
	static int iSkipStep = 0;
	int irand;

	pmove->iStepLeft = !pmove->iStepLeft;

	if (!pmove->runfuncs)
	{
		return;
	}

	irand = pmove->RandomLong(0, 1) + (pmove->iStepLeft * 2);

	// FIXME mp_footsteps needs to be a movevar
	if (pmove->multiplayer && !pmove->movevars->footsteps)
		return;

	// irand - 0,1 for right foot, 2,3 for left foot
	// used to alternate left and right foot
	// FIXME, move to player state
	switch (step)
	{
	default:
	case STEP_CONCRETE:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_step1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_step3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_step2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_step4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_METAL:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_metal1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_metal3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_metal2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_metal4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_DIRT:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_dirt1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_dirt3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_dirt2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_dirt4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_VENT:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_duct1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_duct3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_duct2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_duct4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_GRATE:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_grate1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_grate3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_grate2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_grate4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_TILE:
		if (!pmove->RandomLong(0, 4))
			irand = 4;

		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 4: pmove->PM_PlaySound(CHAN_BODY, "player/pl_tile5.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_SLOSH:
		switch (irand)
		{
			// right foot
			case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_slosh1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
			case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_slosh3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
			// left foot
			case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_slosh2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
			case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_slosh4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_WADE:
		if (iSkipStep == 0)
		{
			iSkipStep++;
			break;
		}

		if (iSkipStep++ == 3)
		{
			iSkipStep = 0;
		}

		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}

		break;
	case STEP_LADDER:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_ladder1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_ladder3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_ladder2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_ladder4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	case STEP_SNOW:
		switch (irand)
		{
		// right foot
		case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_snow1.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_snow3.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		// left foot
		case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_snow2.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_snow4.wav", fvol, ATTN_NORM, 0, PITCH_NORM); break;
		}
		break;
	}
}

int PM_MapTextureTypeStepType(char chTextureType)
{
	switch (chTextureType)
	{
	default:
	case CHAR_TEX_CONCRETE: return STEP_CONCRETE;
	case CHAR_TEX_METAL: return STEP_METAL;
	case CHAR_TEX_DIRT: return STEP_DIRT;
	case CHAR_TEX_VENT: return STEP_VENT;
	case CHAR_TEX_GRATE: return STEP_GRATE;
	case CHAR_TEX_TILE: return STEP_TILE;
	case CHAR_TEX_SLOSH: return STEP_SLOSH;
	case CHAR_TEX_SNOW: return STEP_SNOW;
	}
}

void PM_CatagorizeTextureType()
{
	vec3_t start, end;
	const char *pTextureName;

	VectorCopy(pmove->origin, start);
	VectorCopy(pmove->origin, end);

	// Straight down
	end[2] -= 64.0f;

	// Fill in default values, just in case.
	pmove->sztexturename[0] = '\0';
	pmove->chtexturetype = CHAR_TEX_CONCRETE;

	pTextureName = pmove->PM_TraceTexture(pmove->onground, start, end);

	if (!pTextureName)
		return;

	// strip leading '-0' or '+0~' or '{' or '!'
	if (*pTextureName == '-' || *pTextureName == '+')
		pTextureName += 2;

	if (*pTextureName == '{' || *pTextureName == '!' || *pTextureName == '~' || *pTextureName == ' ')
		pTextureName++;

	strcpy(pmove->sztexturename, pTextureName);
	pmove->sztexturename[CBTEXTURENAMEMAX - 1] = 0;

	// get texture type
	pmove->chtexturetype = PM_FindTextureType(pmove->sztexturename);
}

void PM_UpdateStepSound()
{
	float fvol;
	vec3_t knee;
	vec3_t feet;
	//vec3_t center;
	float height;
	float speed;
	int fLadder;
	int step;
	int onground;

	if (pmove->flTimeStepSound > 0)
		return;

	if (pmove->flags & FL_FROZEN)
		return;

	speed = Length(pmove->velocity);

	if (speed <= 150.0)
	{
		pmove->flTimeStepSound = 400;
		return;
	}

	// determine if we are on a ladder
	fLadder = (pmove->movetype == MOVETYPE_FLY);

	// determine if we are not in air
	onground = (pmove->onground != -1);

	// If we're on a ladder or on the ground play step sound.
	if (fLadder || onground)
	{
		PM_CatagorizeTextureType();

		//VectorCopy(pmove->origin, center);
		VectorCopy(pmove->origin, knee);
		VectorCopy(pmove->origin, feet);

		height = pmove->_player_maxs[pmove->usehull][2] - pmove->_player_mins[pmove->usehull][2];

		knee[2] = pmove->origin[2] - 0.3 * height;
		feet[2] = pmove->origin[2] - 0.5 * height;

		// find out what we're stepping in or on...
		if (fLadder)
		{
			step = STEP_LADDER;
			fvol = 0.35;
			pmove->flTimeStepSound = 350;
		}
		else if (pmove->PM_PointContents(knee, NULL) == CONTENTS_WATER)
		{
			step = STEP_WADE;
			fvol = 0.65;
			pmove->flTimeStepSound = 600;
		}
		else if (pmove->PM_PointContents(feet, NULL) == CONTENTS_WATER)
		{
			step = STEP_SLOSH;
			fvol = 0.5;
			pmove->flTimeStepSound = 300;
		}
		else
		{
			// find texture under player, if different from current texture,
			// get material type
			step = PM_MapTextureTypeStepType(pmove->chtexturetype);

			switch (pmove->chtexturetype)
			{
			default:
			case CHAR_TEX_CONCRETE:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;

			case CHAR_TEX_METAL:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;

			case CHAR_TEX_DIRT:
				fvol = 0.55;
				pmove->flTimeStepSound = 300;
				break;

			case CHAR_TEX_VENT:
				fvol = 0.7;
				pmove->flTimeStepSound = 300;
				break;

			case CHAR_TEX_GRATE:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;

			case CHAR_TEX_TILE:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;

			case CHAR_TEX_SLOSH:
				fvol = 0.5;
				pmove->flTimeStepSound = 300;
				break;
			}
		}

		if ((pmove->flags & FL_DUCKING) || fLadder)
		{
			pmove->flTimeStepSound += 100; // slower step time if ducking

			// play the sound
			// 35% volume if ducking
			if ((pmove->flags & FL_DUCKING) && pmove->flDuckTime < 950.0)
			{
				fvol *= 0.35;
			}
		}

		PM_PlayStepSound(step, fvol);
	}
}

// Add's the trace result to touch list, if contact is not already in list.

qboolean PM_AddToTouched(pmtrace_t tr, vec_t *impactvelocity)
{
	int i;
	for (i = 0; i < pmove->numtouch; ++i)
	{
		if (pmove->touchindex[i].ent == tr.ent)
			break;
	}

	// Already in list.
	if (i != pmove->numtouch)
	{
		return false;
	}

	VectorCopy(impactvelocity, tr.deltavelocity);

	if (pmove->numtouch >= MAX_PHYSENTS)
	{
		pmove->Con_DPrintf("Too many entities were touched!\n");
	}

	pmove->touchindex[pmove->numtouch++] = tr;
	return true;
}

void PM_CheckVelocity()
{
	int i;

	// bound velocity
	for (i = 0; i < 3; ++i)
	{
		// See if it's bogus.
		if (IS_NAN(pmove->velocity[i]))
		{
			pmove->Con_Printf("PM  Got a NaN velocity %i\n", i);
			pmove->velocity[i] = 0;
		}

		if (IS_NAN(pmove->origin[i]))
		{
			pmove->Con_Printf("PM  Got a NaN origin on %i\n", i);
			pmove->origin[i] = 0;
		}

		// Bound it.
		if (pmove->velocity[i] > pmove->movevars->maxvelocity)
		{
			pmove->Con_DPrintf("PM  Got a velocity too high on %i\n", i);
			pmove->velocity[i] = pmove->movevars->maxvelocity;
		}
		else if (pmove->velocity[i] < -pmove->movevars->maxvelocity)
		{
			pmove->Con_DPrintf("PM  Got a velocity too low on %i\n", i);
			pmove->velocity[i] = -pmove->movevars->maxvelocity;
		}
	}
}

// Slide off of the impacting object
// returns the blocked flags:
// 0x01 == floor
// 0x02 == step / wall

int PM_ClipVelocity(vec_t *in, vec_t *normal, vec_t *out, float overbounce)
{
	float change;
	float angle;
	float backoff;
	int i, blocked;

	angle = normal[2];

	// Assume unblocked.
	blocked = 0x00;

	// If the plane that is blocking us has a positive z component, then assume it's a floor.
	if (angle > 0)
	{
		blocked |= 0x01;
	}

	// If the plane has no Z, it is vertical (wall/step)
	if (!angle)
	{
		blocked |= 0x02;
	}

	// Determine how far along plane to slide based on incoming direction.
	// Scale by overbounce factor.
	backoff = DotProduct(in, normal) * overbounce;

	for (i = 0; i < 3; ++i)
	{
		change = in[i] - normal[i] * backoff;
		out[i] = change;

		// If out velocity is too small, zero it out.
		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
		{
			out[i] = 0;
		}
	}

	// Return blocking flags.
	return blocked;
}

void PM_AddCorrectGravity()
{
	float ent_gravity;

	if (pmove->waterjumptime)
		return;

	if (pmove->gravity != 0.0f)
		ent_gravity = pmove->gravity;
	else
		ent_gravity = 1.0f;

	// Add gravity so they'll be in the correct position during movement
	// yes, this 0.5 looks wrong, but it's not.
	pmove->velocity[2] -= (ent_gravity * pmove->movevars->gravity * 0.5f * pmove->frametime);
	pmove->velocity[2] += pmove->basevelocity[2] * pmove->frametime;

	pmove->basevelocity[2] = 0;

	PM_CheckVelocity();
}

void PM_FixupGravityVelocity()
{
	float ent_gravity;

	if (pmove->waterjumptime)
		return;

	if (pmove->gravity != 0.0)
		ent_gravity = pmove->gravity;
	else
		ent_gravity = 1.0;

	// Get the correct velocity for the end of the dt
	pmove->velocity[2] -= (pmove->movevars->gravity * pmove->frametime * ent_gravity * 0.5);
	PM_CheckVelocity();
}

int PM_FlyMove()
{
	int bumpcount, numbumps;
	vec3_t dir;
	float d;
	int numplanes;
	vec3_t planes[MAX_CLIP_PLANES];
	vec3_t primal_velocity, original_velocity;
	vec3_t new_velocity;
	int i, j;
	pmtrace_t trace;
	vec3_t end;
	float time_left, allFraction;
	int blocked;

	numbumps = 4;	// Bump up to four times
	blocked = 0x00;	// Assume not blocked
	numplanes = 0;	//  and not sliding along any planes

	VectorCopy(pmove->velocity, original_velocity);		// Store original velocity
	VectorCopy(pmove->velocity, primal_velocity);

	allFraction = 0;
	time_left = pmove->frametime;				// Total time for this movement operation.

	for (bumpcount = 0; bumpcount < numbumps; bumpcount++)
	{
		if (!pmove->velocity[0] && !pmove->velocity[1] && !pmove->velocity[2])
			break;

		// Assume we can move all the way from the current origin to the
		// end point.
		for (i = 0; i < 3; ++i)
		{
			float flScale = time_left * pmove->velocity[i];

			end[i] = pmove->origin[i] + flScale;
		}

		// See if we can make it from origin to end point.
		trace = pmove->PM_PlayerTrace(pmove->origin, end, PM_NORMAL, -1);

		allFraction += trace.fraction;

		// If we started in a solid object, or we were in solid space
		// the whole way, zero out our velocity and return that we
		// are blocked by floor and wall.
		if (trace.allsolid)
		{
			// entity is trapped in another solid
			VectorCopy(vec3_origin, pmove->velocity);
			return 4;
		}

		// If we moved some portion of the total distance, then
		// copy the end position into the pmove->origin and
		// zero the plane counter.
		if (trace.fraction > 0.0f)
		{
			// actually covered some distance
			VectorCopy(trace.endpos, pmove->origin);
			VectorCopy(pmove->velocity, original_velocity);

			numplanes = 0;
		}

		// If we covered the entire distance, we are done
		// and can return.
		if (trace.fraction == 1.0f)
		{
			// moved the entire distance
			break;
		}

		// Save entity that blocked us (since fraction was < 1.0)
		// for contact
		// Add it if it's not already in the list
		PM_AddToTouched(trace, pmove->velocity);

		// If the plane we hit has a high z component in the normal, then
		// it's probably a floor
		if (trace.plane.normal[2] > 0.7f)
		{
			// floor
			blocked |= 0x01;
		}

		// If the plane has a zero z component in the normal, then it's a
		// step or wall
		if (!trace.plane.normal[2])
		{
			// step / wall
			blocked |= 0x02;
		}

		// Reduce amount of pmove->frametime left by total time left * fraction
		// that we covered.
		time_left -= time_left * trace.fraction;

		// Did we run out of planes to clip against?
		if (numplanes >= MAX_CLIP_PLANES)
		{
			// this shouldn't really happen
			// Stop our movement if so.
			VectorCopy(vec3_origin, pmove->velocity);
			break;
		}

		// Set up next clipping plane
		VectorCopy(trace.plane.normal, planes[numplanes]);
		numplanes++;

		// modify original_velocity so it parallels all of the clip planes
		// relfect player velocity
		if (numplanes == 1 && pmove->movetype == MOVETYPE_WALK && (pmove->onground == -1 || pmove->friction != 1))
		{
			for (i = 0; i < numplanes; ++i)
			{
				if (planes[i][2] > 0.7f)
				{
					// floor or slope
					PM_ClipVelocity(original_velocity, planes[i], new_velocity, 1);
					VectorCopy(new_velocity, original_velocity);
				}
				else
					PM_ClipVelocity(original_velocity, planes[i], new_velocity, 1.0 + pmove->movevars->bounce * (1.0 - pmove->friction));
			}

			VectorCopy(new_velocity, pmove->velocity);
			VectorCopy(new_velocity, original_velocity);
		}
		else
		{
			for (i = 0; i < numplanes; ++i)
			{
				PM_ClipVelocity(original_velocity, planes[i], pmove->velocity, 1);

				for (j = 0; j < numplanes; j++)
				{
					if (j != i && DotProduct(pmove->velocity, planes[j]) < 0)
					{
						break;
					}
				}

				if (j == numplanes)
					break;
			}

			if (i == numplanes)
			{
				if (numplanes != 2)
				{
					VectorCopy(vec3_origin, pmove->velocity);
					break;
				}

				CrossProduct(planes[0], planes[1], dir);
				d = DotProduct(dir, pmove->velocity);
				VectorScale(dir, d, pmove->velocity);
			}

			if (DotProduct(pmove->velocity, primal_velocity) <= 0)
			{
				VectorCopy(vec3_origin, pmove->velocity);
				break;
			}
		}
	}

	if (allFraction == 0.0f)
	{
		VectorCopy(vec3_origin, pmove->velocity);
	}

	return blocked;
}

void PM_Accelerate(vec_t *wishdir, float wishspeed, float accel)
{
	int i;
	float addspeed;

	float currentspeed;
	float accelspeed;

	// Dead player's don't accelerate
	if (pmove->dead)
		return;

	// If waterjumping, don't accelerate
	if (pmove->waterjumptime)
		return;

	// See if we are changing direction a bit
	currentspeed = DotProduct(pmove->velocity, wishdir);

	// Reduce wishspeed by the amount of veer.
	addspeed = wishspeed - currentspeed;

	// If not going to add any speed, done.
	if (addspeed <= 0)
		return;

	// Determine amount of accleration.
	accelspeed = accel * pmove->frametime * wishspeed * pmove->friction;

	// Cap at addspeed
	if (accelspeed > addspeed)
		accelspeed = addspeed;

	// Adjust velocity.
	for (i = 0; i < 3; ++i)
	{
		pmove->velocity[i] += accelspeed * wishdir[i];
	}
}

// Only used by players.  Moves along the ground when player is a MOVETYPE_WALK.

void PM_WalkMove()
{
	//int clip;
	int oldonground;
	int i;

	vec3_t wishvel;
	float spd;
	float fmove, smove;
	vec3_t wishdir;
	float wishspeed;

	//vec3_t start;	// TODO: unused
	vec3_t dest;
	vec3_t original, originalvel;
	vec3_t down, downvel;
	float downdist, updist;

	pmtrace_t trace;

	if (pmove->fuser2 > 0.0)
	{
		float flRatio = (100 - pmove->fuser2 * 0.001 * 19) * 0.01;

		pmove->velocity[0] *= flRatio;
		pmove->velocity[1] *= flRatio;
	}

	// Copy movement amounts
	fmove = pmove->cmd.forwardmove;
	smove = pmove->cmd.sidemove;

	// Zero out z components of movement vectors
	pmove->forward[2] = 0;
	pmove->right[2] = 0;

	// Normalize remainder of vectors.
	VectorNormalize(pmove->forward);
	VectorNormalize(pmove->right);

	// Determine x and y parts of velocity
	for (i = 0; i < 2; ++i)
	{
		wishvel[i] = pmove->forward[i] * fmove + pmove->right[i] * smove;
	}

	// Zero out z part of velocity
	wishvel[2] = 0;

	// Determine maginitude of speed of move
	VectorCopy(wishvel, wishdir);
	wishspeed = VectorNormalize(wishdir);

	// Clamp to server defined max speed
	if (wishspeed > pmove->maxspeed)
	{
		VectorScale(wishvel, pmove->maxspeed / wishspeed, wishvel);
		wishspeed = pmove->maxspeed;
	}

	// Set pmove velocity
	pmove->velocity[2] = 0;
	PM_Accelerate(wishdir, wishspeed, pmove->movevars->accelerate);
	pmove->velocity[2] = 0;

	// Add in any base velocity to the current velocity.
	VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);

	spd = Length(pmove->velocity);

	if (spd < 1.0)
	{
		VectorClear(pmove->velocity);
		return;
	}

	// If we are not moving, do nothing
	//if (!pmove->velocity[0] && !pmove->velocity[1] && !pmove->velocity[2])
	//	return;

	oldonground = pmove->onground;

	// first try just moving to the destination
	dest[0] = pmove->origin[0] + pmove->velocity[0] * pmove->frametime;
	dest[1] = pmove->origin[1] + pmove->velocity[1] * pmove->frametime;
	dest[2] = pmove->origin[2];

	// first try moving directly to the next spot
	// VectorCopy(dest, start);

	trace = pmove->PM_PlayerTrace(pmove->origin, dest, PM_NORMAL, -1);

	// If we made it all the way, then copy trace end
	// as new player position.
	if (trace.fraction == 1.0f)
	{
		VectorCopy(trace.endpos, pmove->origin);
		return;
	}

	// Don't walk up stairs if not on ground.
	if (oldonground == -1 && pmove->waterlevel == 0)
	{
		return;
	}

	// If we are jumping out of water, don't do anything more.
	if (pmove->waterjumptime)
		return;

	// Try sliding forward both on ground and up 16 pixels
	// take the move that goes farthest

	// Save out original pos &
	VectorCopy(pmove->origin, original);

	// velocity.
	VectorCopy(pmove->velocity, originalvel);

	// Slide move
	/*clip = */PM_FlyMove();

	// Copy the results out
	VectorCopy(pmove->origin, down);
	VectorCopy(pmove->velocity, downvel);

	// Reset original values.
	VectorCopy(original, pmove->origin);
	VectorCopy(originalvel, pmove->velocity);

	// Start out up one stair height
	VectorCopy(pmove->origin, dest);

	dest[2] += pmove->movevars->stepsize;

	trace = pmove->PM_PlayerTrace(pmove->origin, dest, PM_NORMAL, -1);

	// If we started okay and made it part of the way at least,
	// copy the results to the movement start position and then
	// run another move try.
	if (!trace.startsolid && !trace.allsolid)
	{
		VectorCopy(trace.endpos, pmove->origin);
	}

	// slide move the rest of the way.
	/*clip = */PM_FlyMove();

	// Now try going back down from the end point
	//  press down the stepheight
	VectorCopy(pmove->origin, dest);
	dest[2] -= pmove->movevars->stepsize;

	trace = pmove->PM_PlayerTrace(pmove->origin, dest, PM_NORMAL, -1);

	// If we are not on the ground any more then
	// use the original movement attempt
	if (trace.plane.normal[2] < 0.7f)
		goto usedown;

	// If the trace ended up in empty space, copy the end
	// over to the origin.
	if (!trace.startsolid && !trace.allsolid)
	{
		VectorCopy(trace.endpos, pmove->origin);
	}

	// Copy this origion to up.
	VectorCopy(pmove->origin, pmove->up);

	// decide which one went farther
	downdist = (down[0] - original[0]) * (down[0] - original[0]) + (down[1] - original[1]) * (down[1] - original[1]);
	updist = (pmove->up[0] - original[0]) * (pmove->up[0] - original[0]) + (pmove->up[1] - original[1]) * (pmove->up[1] - original[1]);

	if (downdist > updist)
	{
usedown:
		VectorCopy(down, pmove->origin);
		VectorCopy(downvel, pmove->velocity);
	}
	else
	{
		// copy z value from slide move
		pmove->velocity[2] = downvel[2];
	}
}

// Handles both ground friction and water friction

void PM_Friction()
{
	float *vel;
	float speed;
	float newspeed, control, friction, drop;
	vec3_t newvel;

	// If we are in water jump cycle, don't apply friction
	if (pmove->waterjumptime)
		return;

	// Get velocity
	vel = pmove->velocity;

	// Calculate speed
	speed = sqrt((float)(vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2]));

	// If too slow, return
	if (speed < 0.1f)
	{
		return;
	}

	drop = 0;

	// apply ground friction
	// On an entity that is the ground
	if (pmove->onground != -1)
	{
		vec3_t start, stop;
		pmtrace_t trace;

		start[0] = stop[0] = pmove->origin[0] + vel[0] / speed * 16;
		start[1] = stop[1] = pmove->origin[1] + vel[1] / speed * 16;
		start[2] = pmove->origin[2] + pmove->_player_mins[pmove->usehull][2];
		stop[2] = start[2] - 34;

		trace = pmove->PM_PlayerTrace(start, stop, PM_NORMAL, -1);

		if (trace.fraction == 1.0f)
			friction = pmove->movevars->friction * pmove->movevars->edgefriction;
		else
			friction = pmove->movevars->friction;

		// Grab friction value.
		//friction = pmove->movevars->friction;

		// player friction?
		friction *= pmove->friction;

		// Bleed off some speed, but if we have less than the bleed
		// threshhold, bleed the theshold amount.
		control = (speed < pmove->movevars->stopspeed) ? pmove->movevars->stopspeed : speed;

		// Add the amount to t'he drop amount.
		drop += friction * (control * pmove->frametime);
	}

	// apply water friction
	//if (pmove->waterlevel)
	//{
	//	drop += speed * pmove->movevars->waterfriction * waterlevel * pmove->frametime;
	//}

	// scale the velocity
	newspeed = speed - drop;

	if (newspeed < 0)
	{
		newspeed = 0;
	}

	// Determine proportion of old speed we are using.
	newspeed /= speed;

	// Adjust velocity according to proportion.
	newvel[0] = vel[0] * newspeed;
	newvel[1] = vel[1] * (float)newspeed;
	newvel[2] = vel[2] * (float)newspeed;

	VectorCopy(newvel, pmove->velocity);
}

void PM_AirAccelerate(vec_t *wishdir, float wishspeed, float accel)
{
	int i;
	float addspeed;
	float wishspd = wishspeed;

	float currentspeed;
	float accelspeed;

	if (pmove->dead || pmove->waterjumptime)
		return;

	// Cap speed
	if (wishspd > 30)
		wishspd = 30;

	// Determine veer amount
	currentspeed = DotProduct(pmove->velocity, wishdir);

	// See how much to add
	addspeed = wishspd - currentspeed;

	// If not adding any, done.
	if (addspeed <= 0)
		return;

	// Determine acceleration speed after acceleration
	accelspeed = accel * wishspeed * pmove->frametime * pmove->friction;

	// Cap it
	if (accelspeed > addspeed)
		accelspeed = addspeed;

	// Adjust pmove vel.
	for (i = 0; i < 3; ++i)
	{
		pmove->velocity[i] += accelspeed * wishdir[i];
	}
}

void PM_WaterMove()
{
	int i;
	vec3_t wishvel;
	vec3_t wishdir;
	vec3_t start, dest;
	vec3_t temp;
	pmtrace_t trace;

	float speed, accelspeed, wishspeed;
	float newspeed, addspeed;

	// user intentions
	for (i = 0; i < 3; ++i)
	{
		wishvel[i] = (pmove->forward[i] * pmove->cmd.forwardmove) + (pmove->cmd.sidemove * pmove->right[i]);
	}

	// Sinking after no other movement occurs
	if (!pmove->cmd.forwardmove && !pmove->cmd.sidemove && !pmove->cmd.upmove)
	{
		// drift towards bottom
		wishvel[2] -= 60.0f;
	}
	else
	{
		// Go straight up by upmove amount.
		wishvel[2] += pmove->cmd.upmove;
	}

	// Copy it over and determine speed
	VectorCopy(wishvel, wishdir);
	wishspeed = VectorNormalize(wishdir);

	// Cap speed.
	if (wishspeed > pmove->maxspeed)
	{
		VectorScale(wishvel, pmove->maxspeed / wishspeed, wishvel);
		wishspeed = pmove->maxspeed;
	}

	// Slow us down a bit.
	wishspeed *= 0.8;
	VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);

	// Water friction
	VectorCopy(pmove->velocity, temp);
	speed = VectorNormalize(temp);

	if (speed)
	{
		newspeed = speed - pmove->movevars->friction * pmove->friction * pmove->frametime * speed;

		if (newspeed < 0.0f)
		{
			newspeed = 0.0f;
		}

		VectorScale(pmove->velocity, newspeed / speed, pmove->velocity);
	}
	else
		newspeed = 0;

	// water acceleration
	if ((float)wishspeed < 0.1f)
	{
		return;
	}

	addspeed = (float)wishspeed - newspeed;

	if (addspeed > 0.0f)
	{
		VectorNormalize(wishvel);
		accelspeed = pmove->movevars->accelerate * pmove->friction * pmove->frametime * (float)wishspeed;

		if (accelspeed > addspeed)
		{
			accelspeed = addspeed;
		}

		for (i = 0; i < 3; ++i)
		{
			pmove->velocity[i] += accelspeed * wishvel[i];
		}
	}

	// Now move
	// assume it is a stair or a slope, so press down from stepheight above
	VectorMA(pmove->origin, pmove->frametime, pmove->velocity, dest);
	VectorCopy(dest, start);

	start[2] += pmove->movevars->stepsize + 1;
	trace = pmove->PM_PlayerTrace(start, dest, PM_NORMAL, -1);

	// FIXME: check steep slope?
	if (!trace.startsolid && !trace.allsolid)
	{
		// walked up the step, so just keep result and exit
		VectorCopy(trace.endpos, pmove->origin);
		return;
	}

	// Try moving straight along out normal path.
	PM_FlyMove();
}

void PM_AirMove()
{
	int i;
	vec3_t wishvel;
	float fmove, smove;
	vec3_t wishdir;
	float wishspeed;

	// Copy movement amounts
	fmove = pmove->cmd.forwardmove;
	smove = pmove->cmd.sidemove;

	// Zero out z components of movement vectors
	pmove->forward[2] = 0;
	pmove->right[2] = 0;

	// Renormalize
	VectorNormalize(pmove->forward);
	VectorNormalize(pmove->right);

	// Determine x and y parts of velocity
	for (i = 0; i < 2; ++i)
	{
		wishvel[i] = pmove->forward[i] * fmove + pmove->right[i] * smove;
	}

	// Zero out z part of velocity
	wishvel[2] = 0;

	 // Determine maginitude of speed of move
	VectorCopy(wishvel, wishdir);
	wishspeed = VectorNormalize(wishdir);

	// Clamp to server defined max speed
	if (wishspeed > pmove->maxspeed)
	{
		VectorScale(wishvel, pmove->maxspeed/wishspeed, wishvel);
		wishspeed = pmove->maxspeed;
	}

	PM_AirAccelerate(wishdir, wishspeed, pmove->movevars->airaccelerate);

	// Add in any base velocity to the current velocity.
	VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);

	PM_FlyMove();
}

qboolean PM_InWater()
{
	return (pmove->waterlevel > 1);
}

// Sets pmove->waterlevel and pmove->watertype values.

qboolean PM_CheckWater()
{
	vec3_t point;
	int cont;
	int truecont;
	float height;
	float heightover2;

	// Pick a spot just above the players feet.
	point[0] = pmove->origin[0] + (pmove->_player_mins[pmove->usehull][0] + pmove->_player_maxs[pmove->usehull][0]) * 0.5;
	point[1] = pmove->origin[1] + (pmove->_player_mins[pmove->usehull][1] + pmove->_player_maxs[pmove->usehull][1]) * 0.5;
	point[2] = pmove->origin[2] + pmove->_player_mins[pmove->usehull][2] + 1;

	// Assume that we are not in water at all.
	pmove->waterlevel = 0;
	pmove->watertype = CONTENTS_EMPTY;

	// Grab point contents.
	cont = pmove->PM_PointContents(point, &truecont);

	// Are we under water? (not solid and not empty?)
	if (cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT)
	{
		// Set water type
		pmove->watertype = cont;

		// We are at least at level one
		pmove->waterlevel = 1;

		height = (pmove->_player_mins[pmove->usehull][2] + pmove->_player_maxs[pmove->usehull][2]);
		heightover2 = height * 0.5;

		// Now check a point that is at the player hull midpoint.
		point[2] = pmove->origin[2] + heightover2;
		cont = pmove->PM_PointContents(point, NULL);

		// If that point is also under water...
		if (cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT)
		{
			// Set a higher water level.
			pmove->waterlevel = 2;

			// Now check the eye position.  (view_ofs is relative to the origin)
			point[2] = pmove->origin[2] + pmove->view_ofs[2];

			cont = pmove->PM_PointContents(point, NULL);
			if (cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT)
			{
				// In over our eyes
				pmove->waterlevel = 3;
			}
		}

		// Adjust velocity based on water current, if any.
		if ((truecont <= CONTENTS_CURRENT_0) && (truecont >= CONTENTS_CURRENT_DOWN))
		{
			// The deeper we are, the stronger the current.
			static vec_t current_table[][3] =
			{
				{1, 0, 0}, {0, 1, 0}, {-1, 0, 0},
				{0, -1, 0}, {0, 0, 1}, {0, 0, -1}
			};

			VectorMA(pmove->basevelocity, 50.0 * pmove->waterlevel, current_table[CONTENTS_CURRENT_0 - truecont], pmove->basevelocity);
		}
	}

	return pmove->waterlevel > 1;
}

void PM_CatagorizePosition()
{
	vec3_t point;
	pmtrace_t tr;

	// if the player hull point one unit down is solid, the player
	// is on ground

	// see if standing on something solid

	// Doing this before we move may introduce a potential latency in water detection, but
	// doing it after can get us stuck on the bottom in water if the amount we move up
	// is less than the 1 pixel 'threshold' we're about to snap to.	Also, we'll call
	// this several times per frame, so we really need to avoid sticking to the bottom of
	// water on each call, and the converse case will correct itself if called twice.
	PM_CheckWater();

	point[0] = pmove->origin[0];
	point[1] = pmove->origin[1];
	point[2] = pmove->origin[2] - 2;

	// Shooting up really fast.  Definitely not on ground.
	if (pmove->velocity[2] > 180)
	{
		pmove->onground = -1;
	}
	else
	{
		// Try and move down.
		tr = pmove->PM_PlayerTrace(pmove->origin, point, PM_NORMAL, -1);

		// If we hit a steep plane, we are not on ground
		if (tr.plane.normal[2] < 0.7f)
		{
			// too steep
			pmove->onground = -1;
		}
		else
		{
			// Otherwise, point to index of ent under us.
			pmove->onground = tr.ent;
		}

		// If we are on something...
		if (pmove->onground != -1)
		{
			// Then we are not in water jump sequence
			pmove->waterjumptime = 0;

			// If we could make the move, drop us down that 1 pixel
			if (pmove->waterlevel < 2 && !tr.startsolid && !tr.allsolid)
			{
				VectorCopy(tr.endpos, pmove->origin);
			}
		}

		// Standing on an entity other than the world
		// So signal that we are touching something.
		if (tr.ent > 0)
		{
			PM_AddToTouched(tr, pmove->velocity);
		}
	}
}

// When a player is stuck, it's costly to try and unstick them
// Grab a test offset for the player based on a passed in index

int PM_GetRandomStuckOffsets(int nIndex, int server, vec_t *offset)
{
	// Last time we did a full
	int idx;
	idx = rgStuckLast[nIndex][server]++;

	VectorCopy(rgv3tStuckTable[idx % 54], offset);

	return (idx % 54);
}

void PM_ResetStuckOffsets(int nIndex, int server)
{
	rgStuckLast[nIndex][server] = 0;
}

// If pmove->origin is in a solid position,
// try nudging slightly on all axis to
// allow for the cut precision of the net coordinates

int PM_CheckStuck()
{
	vec3_t base;
	vec3_t offset;
	vec3_t test;
	int hitent;
	int idx;
	float fTime;
	int i;
	pmtrace_t traceresult;

	// Last time we did a full
	static float rgStuckCheckTime[MAX_CLIENTS][2];

	// If position is okay, exit
	hitent = pmove->PM_TestPlayerPosition(pmove->origin, &traceresult);
	if (hitent == -1)
	{
		PM_ResetStuckOffsets(pmove->player_index, pmove->server);
		return 0;
	}

	VectorCopy(pmove->origin, base);

	// Deal with precision error in network.
	if (!pmove->server)
	{
		// World or BSP model
		if (hitent == 0 || pmove->physents[hitent].model != NULL)
		{
			int nReps = 0;
			PM_ResetStuckOffsets(pmove->player_index, pmove->server);
			do
			{
				i = PM_GetRandomStuckOffsets(pmove->player_index, pmove->server, offset);

				VectorAdd(base, offset, test);
				if (pmove->PM_TestPlayerPosition(test, &traceresult) == -1)
				{
					PM_ResetStuckOffsets(pmove->player_index, pmove->server);
					VectorCopy(test, pmove->origin);
					return 0;
				}

				nReps++;
			}
			while (nReps < 54);
		}
	}

	// Only an issue on the client.

	if (pmove->server)
		idx = 0;
	else
		idx = 1;

	fTime = pmove->Sys_FloatTime();

	// Too soon?
	if (rgStuckCheckTime[pmove->player_index][idx] >= (fTime - PM_CHECKSTUCK_MINTIME))
	{
		return 1;
	}

	rgStuckCheckTime[pmove->player_index][idx] = fTime;

	pmove->PM_StuckTouch(hitent, &traceresult);

	i = PM_GetRandomStuckOffsets(pmove->player_index, pmove->server, offset);

	VectorAdd(base, offset, test);
	if ((hitent = pmove->PM_TestPlayerPosition(test, NULL)) == -1)
	{
		PM_ResetStuckOffsets(pmove->player_index, pmove->server);

		if (i >= 27)
		{
			VectorCopy(test, pmove->origin);
		}

		return 0;
	}

	// If player is flailing while stuck in another player (should never happen), then see
	//  if we can't "unstick" them forceably.
	if ((pmove->cmd.buttons & (IN_JUMP | IN_DUCK | IN_ATTACK)) && pmove->physents[hitent].player != 0)
	{
		float x, y, z;
		float xystep = 8.0;
		float zstep = 18.0;
		float xyminmax = xystep;
		float zminmax = 4 * zstep;

		for (z = 0; z <= zminmax; z += zstep)
		{
			for (x = -xyminmax; x <= xyminmax; x += xystep)
			{
				for (y = -xyminmax; y <= xyminmax; y += xystep)
				{
					VectorCopy(base, test);

					test[0] += x;
					test[1] += y;
					test[2] += z;

					if (pmove->PM_TestPlayerPosition(test, NULL) == -1)
					{
						VectorCopy(test, pmove->origin);
						return 0;
					}
				}
			}
		}
	}

	return 1;
}

void PM_SpectatorMove()
{
	float speed, drop, friction;
	float control, newspeed;
	float currentspeed, addspeed;
	float accelspeed;
	int i;
	vec3_t wishvel;
	float fmove, smove;
	vec3_t wishdir;
	float wishspeed;

	// this routine keeps track of the spectators psoition
	// there a two different main move types : track player or moce freely (OBS_ROAMING)
	// doesn't need excate track position, only to generate PVS, so just copy
	// targets position and real view position is calculated on client (saves server CPU)
	if (pmove->iuser1 == OBS_ROAMING)
	{
#ifdef CLIENT_DLL
		if (iJumpSpectator)
		{
			VectorCopy(vJumpOrigin, pmove->origin);
			VectorCopy(vJumpAngles, pmove->angles);
			VectorCopy(vec3_origin, pmove->velocity);
			iJumpSpectator = 0;
			return;
		}
#endif

		// Move around in normal spectator method
		speed = Length (pmove->velocity);

		if (speed >= 1.0)
		{
			drop = 0;

			// extra friction
			friction = pmove->movevars->friction * 1.5;
			control = speed < pmove->movevars->stopspeed ? pmove->movevars->stopspeed : speed;
			drop += friction * (control * pmove->frametime);

			// scale the velocity
			newspeed = speed - drop;

			if (newspeed < 0)
			{
				newspeed = 0;
			}
			newspeed /= speed;

			VectorScale(pmove->velocity, newspeed, pmove->velocity);
		}
		else
		{
			VectorCopy(vec3_origin, pmove->velocity)
		}

		// accelerate
		fmove = pmove->cmd.forwardmove;
		smove = pmove->cmd.sidemove;

		VectorNormalize(pmove->forward);
		VectorNormalize(pmove->right);

		for (i = 0; i < 3; ++i)
		{
			wishvel[i] = pmove->forward[i] * fmove + pmove->right[i] * smove;
		}

		wishvel[2] += pmove->cmd.upmove;

		VectorCopy(wishvel, wishdir);
		wishspeed = VectorNormalize(wishdir);

		// clamp to server defined max speed
		if (wishspeed > pmove->movevars->spectatormaxspeed)
		{
			VectorScale(wishvel, pmove->movevars->spectatormaxspeed / wishspeed, wishvel);
			wishspeed = pmove->movevars->spectatormaxspeed;
		}

		currentspeed = DotProduct(pmove->velocity, wishdir);

		addspeed = wishspeed - currentspeed;
		if (addspeed <= 0)
		{
			return;
		}

		accelspeed = pmove->movevars->accelerate * pmove->frametime * wishspeed;
		if (accelspeed > addspeed)
		{
			accelspeed = addspeed;
		}

		for (i = 0; i < 3; ++i)
		{
			pmove->velocity[i] += accelspeed * wishdir[i];
		}

		// move
		VectorMA(pmove->origin, pmove->frametime, pmove->velocity, pmove->origin);
	}
	else
	{
		// all other modes just track some kind of target, so spectator PVS = target PVS
		int target;

		// no valid target ?
		if (pmove->iuser2 <= 0)
			return;

		// Find the client this player's targeting
		for (target = 0; target < pmove->numphysent; target++)
		{
			if (pmove->physents[target].info == pmove->iuser2)
				break;
		}

		if (target == pmove->numphysent)
			return;

		// use targets position as own origin for PVS
		VectorCopy(pmove->physents[target].angles, pmove->angles);
		VectorCopy(pmove->physents[target].origin, pmove->origin);

		// no velocity
		VectorCopy(vec3_origin, pmove->velocity);
	}
}

// Use for ease-in, ease-out style interpolation (accel/decel)
// Used by ducking code.

float PM_SplineFraction(float value, float scale)
{
	float valueSquared;

	value = scale * value;
	valueSquared = value * value;

	// Nice little ease-in, ease-out spline-like curve
	return 3 * valueSquared - 2 * valueSquared * value;
}

float PM_SimpleSpline(float value)
{
	float valueSquared;

	valueSquared = value * value;

	return 3 * valueSquared - 2 * valueSquared * value;
}

void PM_FixPlayerCrouchStuck(int direction)
{
	int hitent;
	int i;
	vec3_t test;

	hitent = pmove->PM_TestPlayerPosition (pmove->origin, NULL);

	if (hitent == -1)
	{
		return;
	}

	VectorCopy(pmove->origin, test);

	for (i = 0; i < 36; ++i)
	{
		pmove->origin[2] += direction;
		hitent = pmove->PM_TestPlayerPosition(pmove->origin, NULL);

		if (hitent == -1)
		{
			return;
		}
	}

	// Failed
	VectorCopy(test, pmove->origin);
}

void PM_Duck()
{
	float duckFraction;

	int buttonsChanged = (pmove->oldbuttons ^ pmove->cmd.buttons);	// These buttons have changed this frame
	int nButtonPressed =  buttonsChanged & pmove->cmd.buttons;	// The changed ones still down are "pressed"

	/*int duckchange = buttonsChanged & IN_DUCK ? 1 : 0;
	int duckpressed = nButtonPressed & IN_DUCK ? 1 : 0;*/

	if (pmove->cmd.buttons & IN_DUCK)
	{
		pmove->oldbuttons |= IN_DUCK;
	}
	else
	{
		pmove->oldbuttons &= ~IN_DUCK;
	}

	if (pmove->dead || (!(pmove->cmd.buttons & IN_DUCK) && !pmove->bInDuck && !(pmove->flags & FL_DUCKING)))
	{
		return;
	}

	pmove->cmd.forwardmove *= PLAYER_DUCKING_MULTIPLIER;
	pmove->cmd.sidemove *= PLAYER_DUCKING_MULTIPLIER;
	pmove->cmd.upmove *= PLAYER_DUCKING_MULTIPLIER;

	if (pmove->cmd.buttons & IN_DUCK)
	{
		if ((nButtonPressed & IN_DUCK) && !(pmove->flags & FL_DUCKING))
		{
			// Use 1 second so super long jump will work
			pmove->flDuckTime = 1000;
			pmove->bInDuck = true;
		}

		float time = max(0.0, (1.0 - pmove->flDuckTime / 1000.0));

		if (pmove->bInDuck)
		{
			// Finish ducking immediately if duck time is over or not on ground
			if (((pmove->flDuckTime / 1000.0) <= (1.0 - TIME_TO_DUCK)) || pmove->onground == -1)
			{
				pmove->usehull = 1;
				pmove->view_ofs[2] = PM_VEC_DUCK_VIEW;
				pmove->flags |= FL_DUCKING;
				pmove->bInDuck = FALSE;

				// HACKHACK - Fudge for collision bug - no time to fix this properly
				if (pmove->onground != -1)
				{
					pmove->origin[2] = pmove->origin[2] - 18.0;

					// See if we are stuck?
					PM_FixPlayerCrouchStuck(STUCK_MOVEUP);

					// Recatagorize position since ducking can change origin
					PM_CatagorizePosition();
				}
			}
			else
			{
				float fMore = (PM_VEC_DUCK_HULL_MIN - PM_VEC_HULL_MIN);

				// Calc parametric time
				duckFraction = PM_SplineFraction(time, (1.0 / TIME_TO_DUCK));
				pmove->view_ofs[2] = ((PM_VEC_DUCK_VIEW - fMore) * duckFraction) + (PM_VEC_VIEW * (1 - duckFraction));
			}
		}

	}
	else // Try to unduck
	{
		pmtrace_t trace;
		vec3_t newOrigin;

		VectorCopy(pmove->origin, newOrigin);

		if (pmove->onground != -1)
		{
			newOrigin[2] += 18.0;
		}

		trace = pmove->PM_PlayerTrace(newOrigin, newOrigin, PM_NORMAL, -1);

		if (!trace.startsolid)
		{
			pmove->usehull = 0;

			// Oh, no, changing hulls stuck us into something, try unsticking downward first.
			trace = pmove->PM_PlayerTrace(newOrigin, newOrigin, PM_NORMAL, -1);

			if (trace.startsolid)
			{
				// See if we are stuck?  If so, stay ducked with the duck hull until we have a clear spot
				// Con_Printf("unstick got stuck\n");
				pmove->usehull = 1;
				return;
			}

			pmove->flags &= ~FL_DUCKING;
			pmove->bInDuck = FALSE;
			pmove->view_ofs[2] = PM_VEC_VIEW;
			pmove->flDuckTime = 0;

			pmove->flTimeStepSound -= 100;

			if (pmove->flTimeStepSound < 0)
			{
				pmove->flTimeStepSound = 0;
			}

			VectorCopy(newOrigin, pmove->origin);

			// Recatagorize position since ducking can change origin
			PM_CatagorizePosition();
		}
	}
}

void PM_LadderMove(physent_t *pLadder)
{
	vec3_t ladderCenter;
	trace_t trace;
	qboolean onFloor;
	vec3_t floor;
	vec3_t modelmins, modelmaxs;

	if (pmove->movetype == MOVETYPE_NOCLIP)
		return;

	pmove->PM_GetModelBounds(pLadder->model, modelmins, modelmaxs);

	VectorAdd(modelmins, modelmaxs, ladderCenter);
	VectorScale(ladderCenter, 0.5, ladderCenter);

	pmove->movetype = MOVETYPE_FLY;

	// On ladder, convert movement to be relative to the ladder
	VectorCopy(pmove->origin, floor);
	floor[2] += pmove->_player_mins[pmove->usehull][2] - 1;

	if (pmove->PM_PointContents(floor, NULL) == CONTENTS_SOLID)
		onFloor = true;
	else
		onFloor = false;

	pmove->gravity = 0;
	pmove->PM_TraceModel(pLadder, pmove->origin, ladderCenter, &trace);

	if (trace.fraction != 1.0f)
	{
		float forward = 0, right = 0;
		vec3_t vpn, v_right;
		float flSpeed = MAX_CLIMB_SPEED;

		// they shouldn't be able to move faster than their maxspeed
		if (flSpeed > pmove->maxspeed)
		{
			flSpeed = pmove->maxspeed;
		}

		AngleVectors(pmove->angles, vpn, v_right, NULL);

		if (pmove->flags & FL_DUCKING)
		{
			flSpeed *= PLAYER_DUCKING_MULTIPLIER;
		}

		if (pmove->cmd.buttons & IN_BACK)
		{
			forward -= flSpeed;
		}
		if (pmove->cmd.buttons & IN_FORWARD)
		{
			forward += flSpeed;
		}
		if (pmove->cmd.buttons & IN_MOVELEFT)
		{
			right -= flSpeed;
		}
		if (pmove->cmd.buttons & IN_MOVERIGHT)
		{
			right += flSpeed;
		}

		if (pmove->cmd.buttons & IN_JUMP)
		{
			pmove->movetype = MOVETYPE_WALK;
			VectorScale(trace.plane.normal, 270, pmove->velocity);
		}
		else
		{
			if (forward != 0 || right != 0)
			{
				vec3_t velocity, perp, cross, lateral, tmp;
				float normal;

				VectorScale(vpn, forward, velocity);
				VectorMA(velocity, right, v_right, velocity);

				VectorClear(tmp);
				tmp[2] = 1;

				CrossProduct(tmp, trace.plane.normal, perp);
				VectorNormalize(perp);

				// decompose velocity into ladder plane
				normal = DotProduct(velocity, trace.plane.normal);
				// This is the velocity into the face of the ladder
				VectorScale(trace.plane.normal, normal, cross);

				// This is the player's additional velocity
				VectorSubtract(velocity, cross, lateral);

				// This turns the velocity into the face of the ladder into velocity that
				// is roughly vertically perpendicular to the face of the ladder.
				// NOTE: It IS possible to face up and move down or face down and move up
				// because the velocity is a sum of the directional velocity and the converted
				// velocity through the face of the ladder -- by design.
				CrossProduct(trace.plane.normal, perp, tmp);
				VectorMA(lateral, -normal, tmp, pmove->velocity);

				// On ground moving away from the ladder
				if (onFloor && normal > 0)
				{
					VectorMA(pmove->velocity, MAX_CLIMB_SPEED, trace.plane.normal, pmove->velocity);
				}
			}
			else
			{
				VectorClear(pmove->velocity);
			}
		}
	}
}

physent_t *PM_Ladder()
{
	int i;
	physent_t *pe;
	hull_t *hull;
	int num;
	vec3_t test;

	for (i = 0; i < pmove->nummoveent; ++i)
	{
		pe = &pmove->moveents[i];

		if (pe->model && (modtype_t)pmove->PM_GetModelType(pe->model) == mod_brush && pe->skin == CONTENTS_LADDER)
		{
			hull = (hull_t *)pmove->PM_HullForBsp(pe, test);
			num = hull->firstclipnode;

			// Offset the test point appropriately for this hull.
			VectorSubtract(pmove->origin, test, test);

			// Test the player's hull for intersection with this model
			if (pmove->PM_HullPointContents(hull, num, test) == CONTENTS_EMPTY)
			{
				continue;
			}

			return pe;
		}
	}

	return NULL;
}

void PM_WaterJump()
{
	if (pmove->waterjumptime > 10000)
	{
		pmove->waterjumptime = 10000;
	}

	if (!pmove->waterjumptime)
	{
		return;
	}

	pmove->waterjumptime -= pmove->cmd.msec;

	if (pmove->waterjumptime < 0 || !pmove->waterlevel)
	{
		pmove->waterjumptime = 0;
		pmove->flags &= ~FL_WATERJUMP;
	}

	pmove->velocity[0] = pmove->movedir[0];
	pmove->velocity[1] = pmove->movedir[1];
}

void PM_AddGravity()
{
	float ent_gravity;

	if (pmove->gravity != 0.0f)
		ent_gravity = pmove->gravity;
	else
		ent_gravity = 1.0f;

	pmove->velocity[2] -= (ent_gravity * pmove->movevars->gravity * pmove->frametime);
	pmove->velocity[2] += pmove->basevelocity[2] * pmove->frametime;

	pmove->basevelocity[2] = 0;
	PM_CheckVelocity();
}

// Does not change the entities velocity at all

pmtrace_t PM_PushEntity(vec_t *push)
{
	pmtrace_t trace;
	vec3_t end;

	VectorAdd(pmove->origin, push, end);

	trace = pmove->PM_PlayerTrace(pmove->origin, end, PM_NORMAL, -1);

	VectorCopy(trace.endpos, pmove->origin);

	// So we can run impact function afterwards.
	if (trace.fraction < 1.0f && !trace.allsolid)
	{
		PM_AddToTouched(trace, pmove->velocity);
	}

	return trace;
}

void PM_Physics_Toss()
{
	pmtrace_t trace;
	vec3_t move;
	float backoff;

	PM_CheckWater();

	if (pmove->velocity[2] > 0)
	{
		pmove->onground = -1;
	}

	// If on ground and not moving, return.
	if (pmove->onground != -1)
	{
		if (VectorCompare(pmove->basevelocity, vec3_origin) && VectorCompare(pmove->velocity, vec3_origin))
		{
			return;
		}
	}

	PM_CheckVelocity();

	// add gravity
	if (pmove->movetype != MOVETYPE_FLY && pmove->movetype != MOVETYPE_BOUNCEMISSILE && pmove->movetype != MOVETYPE_FLYMISSILE)
	{
		PM_AddGravity();
	}

	// move origin
	// Base velocity is not properly accounted for since this entity will move again after the bounce without
	// taking it into account
	VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);

	PM_CheckVelocity();
	VectorScale(pmove->velocity, pmove->frametime, move);
	VectorSubtract(pmove->velocity, pmove->basevelocity, pmove->velocity);

	// Should this clear basevelocity
	trace = PM_PushEntity(move);

	PM_CheckVelocity();

	if (trace.allsolid)
	{
		// entity is trapped in another solid
		pmove->onground = trace.ent;
		VectorCopy(vec3_origin, pmove->velocity);
		return;
	}

	if (trace.fraction == 1.0f)
	{
		PM_CheckWater();
		return;
	}

	if (pmove->movetype == MOVETYPE_BOUNCE)
	{
		backoff = 2.0f - pmove->friction;
	}
	else if (pmove->movetype == MOVETYPE_BOUNCEMISSILE)
	{
		backoff = 2.0f;
	}
	else
		backoff = 1.0f;

	PM_ClipVelocity(pmove->velocity, trace.plane.normal, pmove->velocity, backoff);

	// stop if on ground
	if (trace.plane.normal[2] > 0.7f)
	{
		float vel;
		vec3_t base;

		VectorClear(base);
		if (pmove->velocity[2] < pmove->movevars->gravity * pmove->frametime)
		{
			// we're rolling on the ground, add static friction.
			pmove->onground = trace.ent;
			pmove->velocity[2] = 0;
		}

		vel = DotProduct(pmove->velocity, pmove->velocity);

		if (vel < (30 * 30) || (pmove->movetype != MOVETYPE_BOUNCE && pmove->movetype != MOVETYPE_BOUNCEMISSILE))
		{
			pmove->onground = trace.ent;
			VectorCopy(vec3_origin, pmove->velocity);
		}
		else
		{
			VectorScale(pmove->velocity, (1.0f - trace.fraction) * pmove->frametime * 0.9f, move);
			trace = PM_PushEntity(move);
		}

		VectorSubtract(pmove->velocity, base, pmove->velocity)
	}

	// check for in water
	PM_CheckWater();
}

void PM_NoClip()
{
	int i;
	vec3_t wishvel;
	float fmove, smove;

	// Copy movement amounts
	fmove = pmove->cmd.forwardmove;
	smove = pmove->cmd.sidemove;

	VectorNormalize(pmove->forward);
	VectorNormalize(pmove->right);

	// Determine x and y parts of velocity
	for (i = 0; i < 3; ++i)
	{
		wishvel[i] = pmove->forward[i] * fmove + pmove->right[i] * smove;
	}

	wishvel[2] += pmove->cmd.upmove;

	VectorMA(pmove->origin, pmove->frametime, wishvel, pmove->origin);

	// Zero out the velocity so that we don't accumulate a huge downward velocity from
	//  gravity, etc.
	VectorClear(pmove->velocity);
}

// Purpose: Corrects bunny jumping (where player initiates a bunny jump before other
//  movement logic runs, thus making onground == -1 thus making PM_Friction get skipped and
//  running PM_AirMove, which doesn't crop velocity to maxspeed like the ground / other
//  movement logic does.

void PM_PreventMegaBunnyJumping()
{
	// Current player speed
	float spd;
	// If we have to crop, apply this cropping fraction to velocity
	float fraction;
	// Speed at which bunny jumping is limited
	float maxscaledspeed;

	maxscaledspeed = BUNNYJUMP_MAX_SPEED_FACTOR * pmove->maxspeed;

	// Don't divide by zero
	if (maxscaledspeed <= 0.0f)
		return;

	spd = Length(pmove->velocity);

	if (spd <= maxscaledspeed)
		return;

	// Returns the modifier for the velocity
	fraction = (maxscaledspeed / spd) * 0.8;

	// Crop it down!.
	VectorScale(pmove->velocity, fraction, pmove->velocity);
}

void PM_Jump()
{
	if (pmove->dead)
	{
		// don't jump again until released
		pmove->oldbuttons |= IN_JUMP;
		return;
	}

	// See if we are waterjumping.  If so, decrement count and return.
	if (pmove->waterjumptime != 0.0f)
	{
		pmove->waterjumptime -= pmove->cmd.msec;

		if (pmove->waterjumptime < 0)
		{
			pmove->waterjumptime = 0;
		}

		return;
	}

	// If we are in the water most of the way...
	if (pmove->waterlevel >= 2)
	{
		// swimming, not jumping
		pmove->onground = -1;

		// We move up a certain amount
		if (pmove->watertype == CONTENTS_WATER)
		{
			pmove->velocity[2] = 100;
		}
		else if (pmove->watertype == CONTENTS_SLIME)
		{
			pmove->velocity[2] = 80;
		}
		else // LAVA
			pmove->velocity[2] = 50;

		// play swiming sound
		if (pmove->flSwimTime <= 0)
		{
			// Don't play sound again for 1 second
			pmove->flSwimTime = 1000.0f;

			switch (pmove->RandomLong(0, 3))
			{
			case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade1.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
			case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade2.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
			case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade3.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
			case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade4.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
			}
		}

		return;
	}

	// No more effect
	// in air, so no effect
 	if (pmove->onground == -1)
	{
		// Flag that we jumped.
		// don't jump again until released
		pmove->oldbuttons |= IN_JUMP;
		return;
	}

	// don't pogo stick
	if (pmove->oldbuttons & IN_JUMP)
	{
		return;
	}

	if (pmove->bInDuck && (pmove->flags & FL_DUCKING))
	{
		return;
	}

	PM_CatagorizeTextureType();

	// In the air now.
	pmove->onground = -1;

	PM_PreventMegaBunnyJumping();

	float fvel = Length(pmove->velocity);
	float fvol = 1.0f;

	if (fvel >= 150.0f)
	{
		PM_PlayStepSound(PM_MapTextureTypeStepType(pmove->chtexturetype), fvol);
	}

	// See if user can super long jump?
	bool cansuperjump = (pmove->PM_Info_ValueForKey(pmove->physinfo, "slj")[0] == '1');

	// Acclerate upward
	// If we are ducking...
	if (pmove->bInDuck || (pmove->flags & FL_DUCKING))
	{
		// Adjust for super long jump module
		// UNDONE -- note this should be based on forward angles, not current velocity.
		if (cansuperjump && (pmove->cmd.buttons & IN_DUCK) && pmove->flDuckTime > 0 && Length(pmove->velocity) > 50)
		{
			pmove->punchangle[0] = -5.0f;

			for (int i  = 0; i < 2; ++i)
			{
				pmove->velocity[i] = pmove->forward[i] * PLAYER_LONGJUMP_SPEED * 1.6f;
			}

			pmove->velocity[2] = sqrt(2 * 800 * 56.0f);
		}
		else
		{
			pmove->velocity[2] = sqrt(2 * 800 * 45.0f);
		}
	}
	else
	{
		// NOTE: don't do it in .f (float)
		pmove->velocity[2] = sqrt(2.0 * 800.0f * 45.0f);
	}

	if (pmove->fuser2 > 0.0f)
	{
		// NOTE: don't do it in .f (float)
		float flRatio = (100.0 - pmove->fuser2 * 0.001 * 19.0) * 0.01;
		pmove->velocity[2] *= flRatio;
	}

	pmove->fuser2 = 1315.789429;

	// Decay it for simulation
	PM_FixupGravityVelocity();

	// Flag that we jumped.
	// don't jump again until released
	pmove->oldbuttons |= IN_JUMP;
}

void PM_CheckWaterJump()
{
	vec3_t vecStart, vecEnd;
	vec3_t flatforward;
	vec3_t flatvelocity;
	float curspeed;
	pmtrace_t tr;
	int savehull;

	// Already water jumping.
	if (pmove->waterjumptime)
		return;

	// Don't hop out if we just jumped in
	if (pmove->velocity[2] < -180)
	{
		// only hop out if we are moving up
		return;
	}

	// See if we are backing up
	flatvelocity[0] = pmove->velocity[0];
	flatvelocity[1] = pmove->velocity[1];
	flatvelocity[2] = 0;

	// Must be moving
	curspeed = VectorNormalize(flatvelocity);

	// see if near an edge
	flatforward[0] = pmove->forward[0];
	flatforward[1] = pmove->forward[1];
	flatforward[2] = 0;
	VectorNormalize(flatforward);

	// Are we backing into water from steps or something?  If so, don't pop forward
	if (curspeed != 0.0 && (DotProduct(flatvelocity, flatforward) < 0.0))
	{
		return;
	}

	VectorCopy(pmove->origin, vecStart);
	vecStart[2] += WJ_HEIGHT;

	VectorMA(vecStart, 24, flatforward, vecEnd);

	// Trace, this trace should use the point sized collision hull
	savehull = pmove->usehull;
	pmove->usehull = 2;

	tr = pmove->PM_PlayerTrace(vecStart, vecEnd, PM_NORMAL, -1);

	// Facing a near vertical wall?
	if (tr.fraction < 1.0 && fabs((float)(tr.plane.normal[2])) < 0.1f)
	{
		vecStart[2] += pmove->_player_maxs[savehull][2] - WJ_HEIGHT;

		VectorMA(vecStart, 24, flatforward, vecEnd);
		VectorMA(vec3_origin, -50, tr.plane.normal, pmove->movedir);

		tr = pmove->PM_PlayerTrace(vecStart, vecEnd, PM_NORMAL, -1);

		if (tr.fraction == 1.0f)
		{
			pmove->waterjumptime = 2000.0f;
			pmove->velocity[2] = 225.0f;

			pmove->oldbuttons |= IN_JUMP;
			pmove->flags |= FL_WATERJUMP;
		}
	}

	// Reset the collision hull
	pmove->usehull = savehull;
}

void PM_CheckFalling()
{
	if (pmove->onground != -1 && !pmove->dead && pmove->flFallVelocity >= PM_PLAYER_FALL_PUNCH_THRESHHOLD)
	{
		float fvol = 0.5f;

		if (pmove->waterlevel <= 0)
		{
			if (pmove->flFallVelocity > PM_PLAYER_MAX_SAFE_FALL_SPEED)
			{
				fvol = 1.0f;
			}
			else if (pmove->flFallVelocity > PM_PLAYER_MAX_SAFE_FALL_SPEED / 2)
			{
				fvol = 0.85f;
			}
			else if (pmove->flFallVelocity < PM_PLAYER_MIN_BOUNCE_SPEED)
			{
				fvol = 0.0f;
			}
		}

		if (fvol > 0.0f)
		{
			PM_CatagorizeTextureType();

			// play step sound for current texture
			PM_PlayStepSound(PM_MapTextureTypeStepType(pmove->chtexturetype), fvol);

			pmove->flTimeStepSound = 300;

			// Knock the screen around a little bit, temporary effect
			// punch z axis
			pmove->punchangle[2] = pmove->flFallVelocity * 0.013;

			if (pmove->punchangle[0] > 8.0f)
			{
				pmove->punchangle[0] = 8.0f;
			}
		}
	}

	if (pmove->onground != -1)
	{
		pmove->flFallVelocity = 0;
	}
}

void PM_PlayWaterSounds()
{
	// Did we enter or leave water?
	if (pmove->oldwaterlevel != 0)
	{
		if (pmove->waterlevel != 0)
			return;
	}
	else
	{
		if (pmove->waterlevel == 0)
			return;
	}

	switch (pmove->RandomLong(0, 3))
	{
	case 0: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade1.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
	case 1: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade2.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
	case 2: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade3.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
	case 3: pmove->PM_PlaySound(CHAN_BODY, "player/pl_wade4.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM); break;
	}
}

float PM_CalcRoll(vec_t *angles, vec_t *velocity, float rollangle, float rollspeed)
{
	float sign;
	float side;
	float value;
	vec3_t forward, right, up;

	AngleVectors(angles, forward, right, up);

	side = DotProduct(velocity, right);

	sign = side < 0 ? -1 : 1;

	side = fabs(side);

	value = rollangle;

	if (side < rollspeed)
	{
		side = side * value / rollspeed;
	}
	else
	{
		side = value;
	}

	return side * sign;
}

void PM_DropPunchAngle(vec_t *punchangle)
{
	float len;

	len = VectorNormalize(punchangle);
	len -= (10.0 + len * 0.5) * pmove->frametime;
	len = max(len, 0.0f);

	VectorScale(punchangle, len, punchangle);
}

void PM_CheckParamters()
{
	float spd;
	float maxspeed;
	vec3_t v_angle;

	spd = sqrt((float)(pmove->cmd.sidemove * pmove->cmd.sidemove + pmove->cmd.forwardmove * pmove->cmd.forwardmove + pmove->cmd.upmove * pmove->cmd.upmove));

	maxspeed = pmove->clientmaxspeed;

	if (maxspeed != 0.0f)
	{
		pmove->maxspeed = min(maxspeed, (float)pmove->maxspeed);
	}

	if (spd != 0.0f && spd > (float)pmove->maxspeed)
	{
		float fRatio = pmove->maxspeed / spd;

		pmove->cmd.forwardmove *= fRatio;
		pmove->cmd.sidemove *= fRatio;
		pmove->cmd.upmove *= fRatio;
	}

	if ((pmove->flags & (FL_FROZEN | FL_ONTRAIN)) || pmove->dead)
	{
		pmove->cmd.forwardmove = 0;
		pmove->cmd.sidemove = 0;
		pmove->cmd.upmove = 0;
	}

	PM_DropPunchAngle(pmove->punchangle);

	// Take angles from command.
	if (!pmove->dead)
	{
		VectorCopy(pmove->cmd.viewangles, v_angle);
		VectorAdd(v_angle, pmove->punchangle, v_angle);

		// Set up view angles.
		pmove->angles[ROLL] = PM_CalcRoll(v_angle, pmove->velocity, pmove->movevars->rollangle, pmove->movevars->rollspeed) * 4;
		pmove->angles[PITCH] = v_angle[PITCH];
		pmove->angles[YAW] = v_angle[YAW];
	}
	else
	{
		VectorCopy(pmove->oldangles, pmove->angles);
	}

	// Set dead player view_offset
	if (pmove->dead)
	{
		pmove->view_ofs[2] = PM_DEAD_VIEWHEIGHT;
	}

	// Adjust client view angles to match values used on server.
	if (pmove->angles[YAW] > 180.0f)
	{
		pmove->angles[YAW] -= 360.0f;
	}
}

void PM_ReduceTimers()
{
	if (pmove->flTimeStepSound > 0)
	{
		pmove->flTimeStepSound -= pmove->cmd.msec;

		if (pmove->flTimeStepSound < 0)
		{
			pmove->flTimeStepSound = 0;
		}
	}

	if (pmove->flDuckTime > 0)
	{
		pmove->flDuckTime -= pmove->cmd.msec;

		if (pmove->flDuckTime < 0)
		{
			pmove->flDuckTime = 0;
		}
	}

	if (pmove->flSwimTime > 0)
	{
		pmove->flSwimTime -= pmove->cmd.msec;

		if (pmove->flSwimTime < 0)
		{
			pmove->flSwimTime = 0;
		}
	}

	if (pmove->fuser2 > 0.0)
	{
		pmove->fuser2 -= pmove->cmd.msec;

		if (pmove->fuser2 < 0.0)
		{
			pmove->fuser2 = 0;
		}
	}
}

qboolean PM_ShouldDoSpectMode()
{
	return (pmove->iuser3 <= 0 || pmove->deadflag == DEAD_DEAD);
}

// Returns with origin, angles, and velocity modified in place.
// Numtouch and touchindex[] will be set if any of the physents
// were contacted during the move.

void PM_PlayerMove(qboolean server)
{
	physent_t *pLadder = NULL;

	// Are we running server code?
	pmove->server = server;

	// Adjust speeds etc.
	PM_CheckParamters();

	// Assume we don't touch anything
	pmove->numtouch = 0;

	// # of msec to apply movement

	//double v2 = (double)pmove->cmd.msec * 0.001;
	pmove->frametime = pmove->cmd.msec * 0.001;

	PM_ReduceTimers();

	// Convert view angles to vectors
	AngleVectors(pmove->angles, pmove->forward, pmove->right, pmove->up);

	//PM_ShowClipBox();

	// Special handling for spectator and observers. (iuser1 is set if the player's in observer mode)
	if ((pmove->spectator || pmove->iuser1 > 0) && PM_ShouldDoSpectMode())
	{
		PM_SpectatorMove();
		PM_CatagorizePosition();
		return;
	}

	// Always try and unstick us unless we are in NOCLIP mode
	if (pmove->movetype != MOVETYPE_NOCLIP && pmove->movetype != MOVETYPE_NONE)
	{
		if (PM_CheckStuck())
		{
			// Can't move, we're stuck
			return;
		}
	}

	// Now that we are "unstuck", see where we are (waterlevel and type, pmove->onground).
	PM_CatagorizePosition();

	// Store off the starting water level
	pmove->oldwaterlevel = pmove->waterlevel;

	// If we are not on ground, store off how fast we are moving down
	if (pmove->onground == -1)
	{
		pmove->flFallVelocity = -pmove->velocity[2];
	}

	g_onladder = 0;

	// Don't run ladder code if dead or on a train
	if (!pmove->dead && !(pmove->flags & FL_ONTRAIN))
	{
		pLadder = PM_Ladder();

		if (pLadder != NULL)
		{
			g_onladder = 1;
		}
	}

	PM_Duck();
	PM_UpdateStepSound();

	// Don't run ladder code if dead or on a train
	if (!pmove->dead && !(pmove->flags & FL_ONTRAIN))
	{
		if (pLadder != NULL)
		{
			PM_LadderMove(pLadder);
		}
		else if (pmove->movetype != MOVETYPE_WALK && pmove->movetype != MOVETYPE_NOCLIP)
		{
			// Clear ladder stuff unless player is noclipping
			// it will be set immediately again next frame if necessary
			pmove->movetype = MOVETYPE_WALK;
		}
	}

	// Handle movement
	switch (pmove->movetype)
	{
	default:
		pmove->Con_DPrintf("Bogus pmove player movetype %i on (%i) 0=cl 1=sv\n", pmove->movetype, pmove->server);
		break;

	case MOVETYPE_NONE:
		break;

	case MOVETYPE_NOCLIP:
		PM_NoClip();
		break;

	case MOVETYPE_TOSS:
	case MOVETYPE_BOUNCE:
		PM_Physics_Toss();
		break;

	case MOVETYPE_FLY:
		PM_CheckWater();

		// Was jump button pressed?
		// If so, set velocity to 270 away from ladder.  This is currently wrong.
		// Also, set MOVE_TYPE to walk, too.
		if (pmove->cmd.buttons & IN_JUMP)
		{
			if (!pLadder)
			{
				PM_Jump();
			}
		}
		else
		{
			pmove->oldbuttons &= ~IN_JUMP;
		}

		// Perform the move accounting for any base velocity.
		VectorAdd(pmove->velocity, pmove->basevelocity, pmove->velocity);
		PM_FlyMove();
		VectorSubtract(pmove->velocity, pmove->basevelocity, pmove->velocity);
		break;

	case MOVETYPE_WALK:
		if (!PM_InWater())
		{
			PM_AddCorrectGravity();
		}

		// If we are leaping out of the water, just update the counters.
		if (pmove->waterjumptime != 0.0f)
		{
			PM_WaterJump();
			PM_FlyMove();

			// Make sure waterlevel is set correctly
			PM_CheckWater();
			return;
		}

		// If we are swimming in the water, see if we are nudging against a place we can jump up out
		//  of, and, if so, start out jump.  Otherwise, if we are not moving up, then reset jump timer to 0
		if (pmove->waterlevel >= 2)
		{
			if (pmove->waterlevel == 2)
			{
				PM_CheckWaterJump();
			}

			// If we are falling again, then we must not trying to jump out of water any more.
			if (pmove->velocity[2] < 0 && pmove->waterjumptime)
			{
				pmove->waterjumptime = 0;
			}

			// Was jump button pressed?
			if (pmove->cmd.buttons & IN_JUMP)
			{
				PM_Jump();
			}
			else
			{
				pmove->oldbuttons &= ~IN_JUMP;
			}

			// Perform regular water movement
			PM_WaterMove();

			VectorSubtract(pmove->velocity, pmove->basevelocity, pmove->velocity);

			// Get a final position
			PM_CatagorizePosition();
		}
		// Not underwater
		else
		{
			// Was jump button pressed?
			if (pmove->cmd.buttons & IN_JUMP)
			{
				if (!pLadder)
				{
					PM_Jump();
				}
			}
			else
			{
				pmove->oldbuttons &= ~IN_JUMP;
			}

			// Fricion is handled before we add in any base velocity. That way, if we are on a conveyor,
			// we don't slow when standing still, relative to the conveyor.
			if (pmove->onground != -1)
			{
				pmove->velocity[2] = 0;
				PM_Friction();
			}

			// Make sure velocity is valid.
			PM_CheckVelocity();

			// Are we on ground now
			if (pmove->onground != -1)
			{
				PM_WalkMove();
			}
			else
			{
				// Take into account movement when in air.
				PM_AirMove();
			}

			// Set final flags.
			PM_CatagorizePosition();

			// Now pull the base velocity back out.
			// Base velocity is set if you are on a moving object, like
			// a conveyor (or maybe another monster?)
			VectorSubtract(pmove->velocity, pmove->basevelocity, pmove->velocity);

			// Make sure velocity is valid.
			PM_CheckVelocity();

			// Add any remaining gravitational component.
			if (!PM_InWater())
			{
				PM_FixupGravityVelocity();
			}

			// If we are on ground, no downward velocity.
			if (pmove->onground != -1)
			{
				pmove->velocity[2] = 0;
			}

			// See if we landed on the ground with enough force to play
			// a landing sound.
			PM_CheckFalling();
		}

		// Did we enter or leave the water?
		PM_PlayWaterSounds();
		break;
	}
}

void PM_CreateStuckTable()
{
	float x, y, z;

	int idx;
	int i;
	float zi[3];

	memset(rgv3tStuckTable, 0, sizeof(rgv3tStuckTable));

	idx = 0;

	// Little Moves.
	x = 0;
	y = 0;

	// Z moves
	for (z = -0.125; z <= 0.125; z += 0.125)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	x = 0;
	z = 0;
	// Y moves
	for (y = -0.125; y <= 0.125; y += 0.125)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	y = 0;
	z = 0;
	// X moves
	for (x = -0.125; x <= 0.125; x += 0.125)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	// Remaining multi axis nudges.
	for (x = -0.125; x <= 0.125; x += 0.250)
	{
		for (y = -0.125; y <= 0.125; y += 0.250)
		{
			for (z = -0.125; z <= 0.125; z += 0.250)
			{
				rgv3tStuckTable[idx][0] = x;
				rgv3tStuckTable[idx][1] = y;
				rgv3tStuckTable[idx][2] = z;

				idx++;
			}
		}
	}

	// Big Moves.
	x = 0;
	y = 0;

	zi[0] = 0.0f;
	zi[1] = 1.0f;
	zi[2] = 6.0f;

	for (i = 0; i < 3; ++i)
	{
		// Z moves
		z = zi[i];

		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	x = 0;
	z = 0;

	// Y moves
	for (y = -2.0f; y <= 2.0f; y += 2.0)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	y = 0;
	z = 0;

	// X moves
	for (x = -2.0f; x <= 2.0f; x += 2.0f)
	{
		rgv3tStuckTable[idx][0] = x;
		rgv3tStuckTable[idx][1] = y;
		rgv3tStuckTable[idx][2] = z;

		idx++;
	}

	// Remaining multi axis nudges.
	for (i = 0; i < 3; ++i)
	{
		z = zi[i];

		for (x = -2.0f; x <= 2.0f; x += 2.0f)
		{
			for (y = -2.0f; y <= 2.0f; y += 2.0)
			{
				rgv3tStuckTable[idx][0] = x;
				rgv3tStuckTable[idx][1] = y;
				rgv3tStuckTable[idx][2] = z;

				idx++;
			}
		}
	}
}

// This module implements the shared player physics code between any particular game and
// the engine. The same PM_Move routine is built into the game .dll and the client .dll and is
// invoked by each side as appropriate. There should be no distinction, internally, between server
// and client. This will ensure that prediction behaves appropriately.

void PM_Move(struct playermove_s *ppmove, int server)
{
	assert(pm_shared_initialized);

	pmove = ppmove;

	PM_PlayerMove((server != 0) ? TRUE : FALSE);

	if (pmove->onground != -1)
		pmove->flags |= FL_ONGROUND;
	else
		pmove->flags &= ~FL_ONGROUND;

	if (!pmove->multiplayer && pmove->movetype == MOVETYPE_WALK)
	{
		pmove->friction = 1.0f;
	}
}

int PM_GetVisEntInfo(int ent)
{
	if (ent >= 0 && ent <= pmove->numvisent)
	{
		return pmove->visents[ent].info;
	}

	return -1;
}

int PM_GetPhysEntInfo(int ent)
{
	if (ent >= 0 && ent <= pmove->numphysent)
	{
		return pmove->physents[ent].info;
	}

	return -1;
}

void PM_Init(struct playermove_s *ppmove)
{
	assert(!pm_shared_initialized);

	pmove = ppmove;

	PM_CreateStuckTable();
	PM_InitTextureTypes();

	pm_shared_initialized = 1;
}

```

`pm_shared/pm_shared.h`:

```h
/*
*
*   This program is free software; you can redistribute it and/or modify it
*   under the terms of the GNU General Public License as published by the
*   Free Software Foundation; either version 2 of the License, or (at
*   your option) any later version.
*
*   This program is distributed in the hope that it will be useful, but
*   WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program; if not, write to the Free Software Foundation,
*   Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*   In addition, as a special exception, the author gives permission to
*   link the code of this program with the Half-Life Game Engine ("HL
*   Engine") and Modified Game Libraries ("MODs") developed by Valve,
*   L.L.C ("Valve").  You must obey the GNU General Public License in all
*   respects for all of the code used other than the HL Engine and MODs
*   from Valve.  If you modify this file, you may extend this exception
*   to your version of the file, but you are not obligated to do so.  If
*   you do not wish to do so, delete this exception statement from your
*   version.
*
*/

#ifndef PM_SHARED_H
#define PM_SHARED_H
#ifdef _WIN32
#pragma once
#endif

#include "pmtrace.h"
#include "pm_defs.h"

#define MAX_CLIENTS			32

#define PM_DEAD_VIEWHEIGHT		-8

#define OBS_NONE			0
#define OBS_CHASE_LOCKED		1
#define OBS_CHASE_FREE			2
#define OBS_ROAMING			3
#define OBS_IN_EYE			4
#define OBS_MAP_FREE			5
#define OBS_MAP_CHASE			6

#define STEP_CONCRETE			0
#define STEP_METAL			1
#define STEP_DIRT			2
#define STEP_VENT			3
#define STEP_GRATE			4
#define STEP_TILE			5
#define STEP_SLOSH			6
#define STEP_WADE			7
#define STEP_LADDER			8
#define STEP_SNOW			9

#define WJ_HEIGHT				8
#define	STOP_EPSILON				0.1
#define MAX_CLIMB_SPEED				200
#define PLAYER_DUCKING_MULTIPLIER		0.333
#define PM_CHECKSTUCK_MINTIME			0.05	// Don't check again too quickly.

#define PLAYER_LONGJUMP_SPEED			350.0f	// how fast we longjump

// Ducking time
#define TIME_TO_DUCK				0.4
#define STUCK_MOVEUP				1

#define PM_VEC_DUCK_HULL_MIN			-18
#define PM_VEC_HULL_MIN				-36
#define PM_VEC_DUCK_VIEW			12
#define PM_VEC_VIEW				17

#define PM_PLAYER_MAX_SAFE_FALL_SPEED		580	// approx 20 feet
#define PM_PLAYER_MIN_BOUNCE_SPEED		350
#define PM_PLAYER_FALL_PUNCH_THRESHHOLD		250	// won't punch player's screen/make scrape noise unless player falling at least this fast.

// Only allow bunny jumping up to 1.2x server / player maxspeed setting
#define BUNNYJUMP_MAX_SPEED_FACTOR		1.2f

void PM_SwapTextures(int i, int j);
int PM_IsThereGrassTexture();
void PM_SortTextures();
void PM_InitTextureTypes();
char PM_FindTextureType(char *name);
void PM_PlayStepSound(int step, float fvol);
int PM_MapTextureTypeStepType(char chTextureType);
void PM_CatagorizeTextureType();
void PM_UpdateStepSound();
qboolean PM_AddToTouched(pmtrace_t tr, vec_t *impactvelocity);
void PM_CheckVelocity();
int PM_ClipVelocity(vec_t *in, vec_t *normal, vec_t *out, float overbounce);
void PM_AddCorrectGravity();
void PM_FixupGravityVelocity();
int PM_FlyMove();
void PM_Accelerate(vec_t *wishdir, float wishspeed, float accel);
void PM_WalkMove();
void PM_Friction();
void PM_AirAccelerate(vec_t *wishdir, float wishspeed, float accel);
void PM_WaterMove();
void PM_AirMove();
qboolean PM_InWater();
qboolean PM_CheckWater();
void PM_CatagorizePosition();
int PM_GetRandomStuckOffsets(int nIndex, int server, vec_t *offset);
void PM_ResetStuckOffsets(int nIndex, int server);
int PM_CheckStuck();
void PM_SpectatorMove();
float PM_SplineFraction(float value, float scale);
float PM_SimpleSpline(float value);
void PM_FixPlayerCrouchStuck(int direction);
void PM_Duck();
void PM_LadderMove(physent_t *pLadder);
physent_t *PM_Ladder();
void PM_WaterJump();
void PM_AddGravity();
pmtrace_t PM_PushEntity(vec_t *push);
void PM_Physics_Toss();
void PM_NoClip();
void PM_PreventMegaBunnyJumping();
void PM_Jump();
void PM_CheckWaterJump();
void PM_CheckFalling();
void PM_PlayWaterSounds();
float PM_CalcRoll(vec_t *angles, vec_t *velocity, float rollangle, float rollspeed);
void PM_DropPunchAngle(vec_t *punchangle);
void PM_CheckParamters();
void PM_ReduceTimers();
qboolean PM_ShouldDoSpectMode();
void PM_PlayerMove(qboolean server);
void PM_CreateStuckTable();
void PM_Move(struct playermove_s *ppmove, int server);
int PM_GetVisEntInfo(int ent);
int PM_GetPhysEntInfo(int ent);
void PM_Init(struct playermove_s *ppmove);

extern playermove_t *pmove;

#endif // PM_SHARED_H

```

`projects/client.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "client", "client.vcxproj", "{DC1DD765-CFEB-47DA-A2EA-9F1E20A24272}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DC1DD765-CFEB-47DA-A2EA-9F1E20A24272}.Debug|x86.ActiveCfg = Debug|Win32
		{DC1DD765-CFEB-47DA-A2EA-9F1E20A24272}.Debug|x86.Build.0 = Debug|Win32
		{DC1DD765-CFEB-47DA-A2EA-9F1E20A24272}.Release|x86.ActiveCfg = Release|Win32
		{DC1DD765-CFEB-47DA-A2EA-9F1E20A24272}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`projects/client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\cl_dll\cdll_int.cpp" />
    <ClCompile Include="..\cl_dll\cs_wpn\com_weapons.cpp" />
    <ClCompile Include="..\cl_dll\cs_wpn\cs_baseentity.cpp" />
    <ClCompile Include="..\cl_dll\cs_wpn\cs_objects.cpp" />
    <ClCompile Include="..\cl_dll\cs_wpn\cs_weapons.cpp" />
    <ClCompile Include="..\cl_dll\demo.cpp" />
    <ClCompile Include="..\cl_dll\entity.cpp" />
    <ClCompile Include="..\cl_dll\events.cpp" />
    <ClCompile Include="..\cl_dll\events\event_ak47.cpp" />
    <ClCompile Include="..\cl_dll\events\event_aug.cpp" />
    <ClCompile Include="..\cl_dll\events\event_awp.cpp" />
    <ClCompile Include="..\cl_dll\events\event_createexplo.cpp" />
    <ClCompile Include="..\cl_dll\events\event_createsmoke.cpp" />
    <ClCompile Include="..\cl_dll\events\event_deagle.cpp" />
    <ClCompile Include="..\cl_dll\events\event_decal_reset.cpp" />
    <ClCompile Include="..\cl_dll\events\event_elite_left.cpp" />
    <ClCompile Include="..\cl_dll\events\event_elite_right.cpp" />
    <ClCompile Include="..\cl_dll\events\event_famas.cpp" />
    <ClCompile Include="..\cl_dll\events\event_fiveseven.cpp" />
    <ClCompile Include="..\cl_dll\events\event_g3sg1.cpp" />
    <ClCompile Include="..\cl_dll\events\event_galil.cpp" />
    <ClCompile Include="..\cl_dll\events\event_glock18.cpp" />
    <ClCompile Include="..\cl_dll\events\event_knife.cpp" />
    <ClCompile Include="..\cl_dll\events\event_m249.cpp" />
    <ClCompile Include="..\cl_dll\events\event_m3.cpp" />
    <ClCompile Include="..\cl_dll\events\event_m4a1.cpp" />
    <ClCompile Include="..\cl_dll\events\event_mac10.cpp" />
    <ClCompile Include="..\cl_dll\events\event_mp5n.cpp" />
    <ClCompile Include="..\cl_dll\events\event_p228.cpp" />
    <ClCompile Include="..\cl_dll\events\event_p90.cpp" />
    <ClCompile Include="..\cl_dll\events\event_scout.cpp" />
    <ClCompile Include="..\cl_dll\events\event_sg550.cpp" />
    <ClCompile Include="..\cl_dll\events\event_sg552.cpp" />
    <ClCompile Include="..\cl_dll\events\event_tmp.cpp" />
    <ClCompile Include="..\cl_dll\events\event_ump45.cpp" />
    <ClCompile Include="..\cl_dll\events\event_usp.cpp" />
    <ClCompile Include="..\cl_dll\events\event_vehicle.cpp" />
    <ClCompile Include="..\cl_dll\events\event_xm1014.cpp" />
    <ClCompile Include="..\cl_dll\events\ev_cs16.cpp" />
    <ClCompile Include="..\cl_dll\events\hl_events.cpp" />
    <ClCompile Include="..\cl_dll\ev_common.cpp" />
    <ClCompile Include="..\cl_dll\hud\ammo.cpp" />
    <ClCompile Include="..\cl_dll\hud\ammohistory.cpp" />
    <ClCompile Include="..\cl_dll\hud\ammo_secondary.cpp" />
    <ClCompile Include="..\cl_dll\hud\battery.cpp" />
    <ClCompile Include="..\cl_dll\hud\death.cpp" />
    <ClCompile Include="..\cl_dll\hud\flashlight.cpp" />
    <ClCompile Include="..\cl_dll\hud\geiger.cpp" />
    <ClCompile Include="..\cl_dll\hud\health.cpp" />
    <ClCompile Include="..\cl_dll\hud\hud.cpp" />
    <ClCompile Include="..\cl_dll\hud\hud_msg.cpp" />
    <ClCompile Include="..\cl_dll\hud\hud_redraw.cpp" />
    <ClCompile Include="..\cl_dll\hud\hud_spectator.cpp" />
    <ClCompile Include="..\cl_dll\hud\hud_update.cpp" />
    <ClCompile Include="..\cl_dll\hud\menu.cpp" />
    <ClCompile Include="..\cl_dll\hud\message.cpp" />
    <ClCompile Include="..\cl_dll\hud\money.cpp" />
    <ClCompile Include="..\cl_dll\hud\MOTD.cpp" />
    <ClCompile Include="..\cl_dll\hud\nvg.cpp" />
    <ClCompile Include="..\cl_dll\hud\radar.cpp" />
    <ClCompile Include="..\cl_dll\hud\radio.cpp" />
    <ClCompile Include="..\cl_dll\hud\saytext.cpp" />
    <ClCompile Include="..\cl_dll\hud\scoreboard.cpp" />
    <ClCompile Include="..\cl_dll\hud\sniperscope.cpp" />
    <ClCompile Include="..\cl_dll\hud\statusbar.cpp" />
    <ClCompile Include="..\cl_dll\hud\status_icons.cpp" />
    <ClCompile Include="..\cl_dll\hud\text_message.cpp" />
    <ClCompile Include="..\cl_dll\hud\timer.cpp" />
    <ClCompile Include="..\cl_dll\hud\train.cpp" />
    <ClCompile Include="..\cl_dll\input.cpp" />
    <ClCompile Include="..\cl_dll\inputw32.cpp" />
    <ClCompile Include="..\cl_dll\in_camera.cpp" />
    <ClCompile Include="..\cl_dll\overview.cpp" />
    <ClCompile Include="..\cl_dll\parsemsg.cpp" />
    <ClCompile Include="..\cl_dll\rain.cpp" />
    <ClCompile Include="..\cl_dll\studio\GameStudioModelRenderer.cpp" />
    <ClCompile Include="..\cl_dll\studio\StudioModelRenderer.cpp" />
    <ClCompile Include="..\cl_dll\studio\studio_util.cpp" />
    <ClCompile Include="..\cl_dll\tri.cpp" />
    <ClCompile Include="..\cl_dll\unicode_strtools.cpp" />
    <ClCompile Include="..\cl_dll\util.cpp" />
    <ClCompile Include="..\cl_dll\vgui_parser.cpp" />
    <ClCompile Include="..\cl_dll\view.cpp" />
    <ClCompile Include="..\common\interface.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_ak47.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_aug.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_awp.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_c4.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_deagle.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_elite.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_famas.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_fiveseven.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_flashbang.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_g3sg1.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_galil.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_glock18.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_hegrenade.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_knife.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_m249.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_m3.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_m4a1.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_mac10.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_mp5navy.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_p228.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_p90.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_scout.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_sg550.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_sg552.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_smokegrenade.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_tmp.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_ump45.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_usp.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_xm1014.cpp" />
    <ClCompile Include="..\pm_shared\pm_debug.c" />
    <ClCompile Include="..\pm_shared\pm_math.c" />
    <ClCompile Include="..\pm_shared\pm_shared.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\cl_dll\include\camera.h" />
    <ClInclude Include="..\cl_dll\include\cl_dll.h" />
    <ClInclude Include="..\cl_dll\include\cl_util.h" />
    <ClInclude Include="..\cl_dll\include\com_weapons.h" />
    <ClInclude Include="..\cl_dll\include\demo.h" />
    <ClInclude Include="..\cl_dll\include\events.h" />
    <ClInclude Include="..\cl_dll\include\eventscripts.h" />
    <ClInclude Include="..\cl_dll\include\ev_hldm.h" />
    <ClInclude Include="..\cl_dll\include\hud\ammo.h" />
    <ClInclude Include="..\cl_dll\include\hud\ammohistory.h" />
    <ClInclude Include="..\cl_dll\include\hud\health.h" />
    <ClInclude Include="..\cl_dll\include\hud\hud.h" />
    <ClInclude Include="..\cl_dll\include\hud\hud_iface.h" />
    <ClInclude Include="..\cl_dll\include\hud\hud_spectator.h" />
    <ClInclude Include="..\cl_dll\include\hud\radar.h" />
    <ClInclude Include="..\cl_dll\include\in_defs.h" />
    <ClInclude Include="..\cl_dll\include\kbutton.h" />
    <ClInclude Include="..\cl_dll\include\overview.h" />
    <ClInclude Include="..\cl_dll\include\parsemsg.h" />
    <ClInclude Include="..\cl_dll\include\rain.h" />
    <ClInclude Include="..\cl_dll\include\studio\GameStudioModelRenderer.h" />
    <ClInclude Include="..\cl_dll\include\studio\StudioModelRenderer.h" />
    <ClInclude Include="..\cl_dll\include\studio\studio_util.h" />
    <ClInclude Include="..\cl_dll\include\tf_defs.h" />
    <ClInclude Include="..\cl_dll\include\unicode_strtools.h" />
    <ClInclude Include="..\cl_dll\include\util_vector.h" />
    <ClInclude Include="..\cl_dll\include\vgui_parser.h" />
    <ClInclude Include="..\cl_dll\include\view.h" />
    <ClInclude Include="..\cl_dll\include\wrect.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{DC1DD765-CFEB-47DA-A2EA-9F1E20A24272}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>hl_cdll</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(Configuration)\$(ProjectName)\</OutDir>
    <TargetName>client</TargetName>
    <IntDir>$(Configuration)\$(ProjectName)\int\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(Configuration)\$(ProjectName)\</OutDir>
    <TargetName>client</TargetName>
    <IntDir>$(Configuration)\$(ProjectName)\int\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;CLIENT_DLL;CLIENT_WEAPONS;HL_DLL;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>..\dlls;..\cl_dll\include\studio;..\cl_dll\include\hud;..\cl_dll\include;..\cl_dll;..\public;..\common;..\pm_shared;..\engine;..\utils\vgui\include;..\game_shared;..\external;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>wsock32.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <BaseAddress>
      </BaseAddress>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>
      </Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;CLIENT_DLL;CLIENT_WEAPONS;HL_DLL;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>..\dlls;..\cl_dll\include\studio;..\cl_dll\include\hud;..\cl_dll\include;..\cl_dll;..\public;..\common;..\pm_shared;..\engine;..\utils\vgui\include;..\game_shared;..\external;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>wsock32.lib;winmm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <BaseAddress>
      </BaseAddress>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>
      </Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`projects/client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{3427cc6b-55ed-45f0-8e57-29a32ec766fc}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\weapons">
      <UniqueIdentifier>{bf8c2f92-98f5-45fb-95c5-5f4261d4bdff}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\gs">
      <UniqueIdentifier>{6e197b5b-a841-469a-b725-3594b0b0bd20}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\pm">
      <UniqueIdentifier>{bf0db874-9883-43e7-8194-300d58086c08}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\events">
      <UniqueIdentifier>{f9759b8f-eb75-4cd4-bf55-f4e5782770a4}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\studio">
      <UniqueIdentifier>{dee46702-17d9-474e-aff7-313fe6316093}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\cs">
      <UniqueIdentifier>{1152c56f-ba6f-4902-bb09-36e4513fefdd}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\hud">
      <UniqueIdentifier>{d3fa3982-08dd-4792-ae64-41f2c3da12ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="inc">
      <UniqueIdentifier>{c28aba62-ad19-4d1d-9df7-79d8069ebb9a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\pm_shared\pm_debug.c">
      <Filter>src\pm</Filter>
    </ClCompile>
    <ClCompile Include="..\pm_shared\pm_math.c">
      <Filter>src\pm</Filter>
    </ClCompile>
    <ClCompile Include="..\pm_shared\pm_shared.c">
      <Filter>src\pm</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\ev_cs16.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_ak47.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_aug.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_awp.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_createexplo.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_createsmoke.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_deagle.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_decal_reset.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_elite_left.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_elite_right.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_famas.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_fiveseven.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_g3sg1.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_galil.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_glock18.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_knife.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_m3.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_m4a1.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_m249.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_mac10.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_mp5n.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_p90.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_p228.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_scout.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_sg550.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_sg552.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_tmp.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_ump45.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_usp.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_vehicle.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\event_xm1014.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events\hl_events.cpp">
      <Filter>src\events</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\studio\GameStudioModelRenderer.cpp">
      <Filter>src\studio</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\studio\studio_util.cpp">
      <Filter>src\studio</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\studio\StudioModelRenderer.cpp">
      <Filter>src\studio</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\cs_wpn\com_weapons.cpp">
      <Filter>src\cs</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\cs_wpn\cs_baseentity.cpp">
      <Filter>src\cs</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\cs_wpn\cs_objects.cpp">
      <Filter>src\cs</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\cs_wpn\cs_weapons.cpp">
      <Filter>src\cs</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_ak47.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_aug.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_awp.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_c4.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_deagle.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_elite.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_famas.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_fiveseven.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_flashbang.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_g3sg1.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_galil.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_glock18.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_hegrenade.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_knife.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_m3.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_m4a1.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_m249.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_mac10.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_mp5navy.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_p90.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_p228.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_scout.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_sg550.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_sg552.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_smokegrenade.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_tmp.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_ump45.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_usp.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_xm1014.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\common\interface.cpp">
      <Filter>src\gs</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\ammo.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\ammo_secondary.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\ammohistory.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\battery.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\death.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\flashlight.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\geiger.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\health.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\hud.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\hud_msg.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\hud_redraw.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\hud_spectator.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\hud_update.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\menu.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\message.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\money.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\MOTD.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\nvg.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\radar.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\radio.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\saytext.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\scoreboard.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\sniperscope.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\status_icons.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\statusbar.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\text_message.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\timer.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\hud\train.cpp">
      <Filter>src\hud</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\cdll_int.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\demo.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\entity.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\ev_common.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\events.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\in_camera.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\input.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\inputw32.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\overview.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\parsemsg.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\rain.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\tri.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\unicode_strtools.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\util.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\vgui_parser.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\cl_dll\view.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\cl_dll\include\camera.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\cl_dll.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\cl_util.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\com_weapons.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\demo.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\ev_hldm.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\events.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\eventscripts.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\in_defs.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\kbutton.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\overview.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\parsemsg.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\rain.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\tf_defs.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\unicode_strtools.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\util_vector.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\vgui_parser.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\view.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\wrect.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\studio\GameStudioModelRenderer.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\studio\studio_util.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\studio\StudioModelRenderer.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\hud\ammo.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\hud\ammohistory.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\hud\health.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\hud\hud.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\hud\hud_iface.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\hud\hud_spectator.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\cl_dll\include\hud\radar.h">
      <Filter>inc</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`projects/mainui.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mainui", "mainui.vcxproj", "{90F48F37-D9F8-4F36-B04F-1FC8CC834424}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{90F48F37-D9F8-4F36-B04F-1FC8CC834424}.Debug|x86.ActiveCfg = Debug|Win32
		{90F48F37-D9F8-4F36-B04F-1FC8CC834424}.Debug|x86.Build.0 = Debug|Win32
		{90F48F37-D9F8-4F36-B04F-1FC8CC834424}.Release|x86.ActiveCfg = Release|Win32
		{90F48F37-D9F8-4F36-B04F-1FC8CC834424}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`projects/mainui.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\mainui\basemenu.h" />
    <ClInclude Include="..\mainui\enginecallback.h" />
    <ClInclude Include="..\mainui\extdll.h" />
    <ClInclude Include="..\mainui\menufont.h" />
    <ClInclude Include="..\mainui\menu_btnsbmp_table.h" />
    <ClInclude Include="..\mainui\menu_strings.h" />
    <ClInclude Include="..\mainui\ui_title_anim.h" />
    <ClInclude Include="..\mainui\utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\mainui\basemenu.cpp" />
    <ClCompile Include="..\mainui\menu_advcontrols.cpp" />
    <ClCompile Include="..\mainui\menu_audio.cpp" />
    <ClCompile Include="..\mainui\menu_btns.cpp" />
    <ClCompile Include="..\mainui\menu_configuration.cpp" />
    <ClCompile Include="..\mainui\menu_controls.cpp" />
    <ClCompile Include="..\mainui\menu_creategame.cpp" />
    <ClCompile Include="..\mainui\menu_credits.cpp" />
    <ClCompile Include="..\mainui\menu_filedialog.cpp" />
    <ClCompile Include="..\mainui\menu_gameoptions.cpp" />
    <ClCompile Include="..\mainui\menu_internetgames.cpp" />
    <ClCompile Include="..\mainui\menu_langame.cpp" />
    <ClCompile Include="..\mainui\menu_main.cpp" />
    <ClCompile Include="..\mainui\menu_multiplayer.cpp" />
    <ClCompile Include="..\mainui\menu_playersetup.cpp" />
    <ClCompile Include="..\mainui\menu_strings.cpp" />
    <ClCompile Include="..\mainui\menu_touch.cpp" />
    <ClCompile Include="..\mainui\menu_touchbuttons.cpp" />
    <ClCompile Include="..\mainui\menu_touchedit.cpp" />
    <ClCompile Include="..\mainui\menu_touchoptions.cpp" />
    <ClCompile Include="..\mainui\menu_video.cpp" />
    <ClCompile Include="..\mainui\menu_vidmodes.cpp" />
    <ClCompile Include="..\mainui\menu_vidoptions.cpp" />
    <ClCompile Include="..\mainui\udll_int.cpp" />
    <ClCompile Include="..\mainui\ui_title_anim.cpp" />
    <ClCompile Include="..\mainui\utils.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{90F48F37-D9F8-4F36-B04F-1FC8CC834424}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>mainui</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140_xp</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);../engine;../common;../pm_shared</IncludePath>
    <TargetName>menu</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);../engine;../common;../pm_shared</IncludePath>
    <TargetName>menu</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>XASH_VGUI;XASH_SDL;WIN32;MAINUI_EXPORTS;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>XASH_VGUI;WIN32;MAINUI_EXPORTS;%(PreprocessorDefinitions);_CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`projects/mainui.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\mainui\basemenu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\mainui\enginecallback.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\mainui\extdll.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\mainui\menu_btnsbmp_table.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\mainui\menu_strings.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\mainui\menufont.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\mainui\ui_title_anim.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\mainui\utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\mainui\basemenu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_advcontrols.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_audio.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_btns.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_configuration.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_controls.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_creategame.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_credits.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_filedialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_gameoptions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_internetgames.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_langame.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_multiplayer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_playersetup.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_strings.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_touch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_touchbuttons.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_touchedit.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_touchoptions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_video.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_vidmodes.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\menu_vidoptions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\udll_int.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\ui_title_anim.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mainui\utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`projects/server.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "server", "server.vcxproj", "{69DDADC0-97F4-419E-86EB-C91781A0D2E0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{69DDADC0-97F4-419E-86EB-C91781A0D2E0}.Debug|x86.ActiveCfg = Debug|Win32
		{69DDADC0-97F4-419E-86EB-C91781A0D2E0}.Debug|x86.Build.0 = Debug|Win32
		{69DDADC0-97F4-419E-86EB-C91781A0D2E0}.Release|x86.ActiveCfg = Release|Win32
		{69DDADC0-97F4-419E-86EB-C91781A0D2E0}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`projects/server.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\dlls\airtank.cpp" />
    <ClCompile Include="..\dlls\ammo.cpp" />
    <ClCompile Include="..\dlls\animating.cpp" />
    <ClCompile Include="..\dlls\animation.cpp" />
    <ClCompile Include="..\dlls\bmodels.cpp" />
    <ClCompile Include="..\dlls\buttons.cpp" />
    <ClCompile Include="..\dlls\cbase.cpp" />
    <ClCompile Include="..\dlls\client.cpp" />
    <ClCompile Include="..\dlls\combat.cpp" />
    <ClCompile Include="..\dlls\doors.cpp" />
    <ClCompile Include="..\dlls\effects.cpp" />
    <ClCompile Include="..\dlls\explode.cpp" />
    <ClCompile Include="..\dlls\func_break.cpp" />
    <ClCompile Include="..\dlls\func_tank.cpp" />
    <ClCompile Include="..\dlls\game.cpp" />
    <ClCompile Include="..\dlls\gamerules.cpp" />
    <ClCompile Include="..\dlls\ggrenade.cpp" />
    <ClCompile Include="..\dlls\globals.cpp" />
    <ClCompile Include="..\dlls\healthkit.cpp" />
    <ClCompile Include="..\dlls\hintmessage.cpp" />
    <ClCompile Include="..\dlls\hostage.cpp" />
    <ClCompile Include="..\dlls\hostage_localnav.cpp" />
    <ClCompile Include="..\dlls\h_ai.cpp" />
    <ClCompile Include="..\dlls\h_battery.cpp" />
    <ClCompile Include="..\dlls\h_cycler.cpp" />
    <ClCompile Include="..\dlls\h_export.cpp" />
    <ClCompile Include="..\dlls\items.cpp" />
    <ClCompile Include="..\dlls\lights.cpp" />
    <ClCompile Include="..\dlls\mapinfo.cpp" />
    <ClCompile Include="..\dlls\maprules.cpp" />
    <ClCompile Include="..\dlls\MemPool.cpp" />
    <ClCompile Include="..\dlls\mortar.cpp" />
    <ClCompile Include="..\dlls\mpstubb.cpp" />
    <ClCompile Include="..\dlls\multiplay_gamerules.cpp" />
    <ClCompile Include="..\dlls\observer.cpp" />
    <ClCompile Include="..\dlls\pathcorner.cpp" />
    <ClCompile Include="..\dlls\perf_counter.cpp" />
    <ClCompile Include="..\dlls\plane.cpp" />
    <ClCompile Include="..\dlls\plats.cpp" />
    <ClCompile Include="..\dlls\player.cpp" />
    <ClCompile Include="..\dlls\singleplay_gamerules.cpp" />
    <ClCompile Include="..\dlls\skill.cpp" />
    <ClCompile Include="..\dlls\sound.cpp" />
    <ClCompile Include="..\dlls\soundent.cpp" />
    <ClCompile Include="..\dlls\spectator.cpp" />
    <ClCompile Include="..\dlls\stdafx.cpp" />
    <ClCompile Include="..\dlls\subs.cpp" />
    <ClCompile Include="..\dlls\training_gamerules.cpp" />
    <ClCompile Include="..\dlls\triggers.cpp" />
    <ClCompile Include="..\dlls\util.cpp" />
    <ClCompile Include="..\dlls\vehicle.cpp" />
    <ClCompile Include="..\dlls\weapons.cpp" />
    <ClCompile Include="..\dlls\world.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_ak47.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_aug.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_awp.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_c4.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_deagle.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_elite.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_famas.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_fiveseven.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_flashbang.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_g3sg1.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_galil.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_glock18.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_hegrenade.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_knife.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_m249.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_m3.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_m4a1.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_mac10.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_mp5navy.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_p228.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_p90.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_scout.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_sg550.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_sg552.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_smokegrenade.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_tmp.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_ump45.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_usp.cpp" />
    <ClCompile Include="..\dlls\wpn_shared\wpn_xm1014.cpp" />
    <ClCompile Include="..\game_shared\voice_banmgr.cpp" />
    <ClCompile Include="..\game_shared\voice_gamemgr.cpp" />
    <ClCompile Include="..\pm_shared\pm_debug.c" />
    <ClCompile Include="..\pm_shared\pm_math.c" />
    <ClCompile Include="..\pm_shared\pm_shared.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\dlls\activity.h" />
    <ClInclude Include="..\dlls\activitymap.h" />
    <ClInclude Include="..\dlls\animation.h" />
    <ClInclude Include="..\dlls\basemonster.h" />
    <ClInclude Include="..\dlls\cbase.h" />
    <ClInclude Include="..\dlls\cdll_dll.h" />
    <ClInclude Include="..\dlls\client.h" />
    <ClInclude Include="..\dlls\decals.h" />
    <ClInclude Include="..\dlls\doors.h" />
    <ClInclude Include="..\dlls\effects.h" />
    <ClInclude Include="..\dlls\enginecallback.h" />
    <ClInclude Include="..\dlls\explode.h" />
    <ClInclude Include="..\dlls\extdll.h" />
    <ClInclude Include="..\dlls\func_break.h" />
    <ClInclude Include="..\dlls\game.h" />
    <ClInclude Include="..\dlls\gamerules.h" />
    <ClInclude Include="..\dlls\hintmessage.h" />
    <ClInclude Include="..\dlls\hostage.h" />
    <ClInclude Include="..\dlls\items.h" />
    <ClInclude Include="..\dlls\mapinfo.h" />
    <ClInclude Include="..\dlls\maprules.h" />
    <ClInclude Include="..\dlls\MemPool.h" />
    <ClInclude Include="..\dlls\monsterevent.h" />
    <ClInclude Include="..\dlls\monsters.h" />
    <ClInclude Include="..\dlls\nodes.h" />
    <ClInclude Include="..\dlls\perf_counter.h" />
    <ClInclude Include="..\dlls\plane.h" />
    <ClInclude Include="..\dlls\player.h" />
    <ClInclude Include="..\dlls\saverestore.h" />
    <ClInclude Include="..\dlls\schedule.h" />
    <ClInclude Include="..\dlls\scriptevent.h" />
    <ClInclude Include="..\dlls\skill.h" />
    <ClInclude Include="..\dlls\soundent.h" />
    <ClInclude Include="..\dlls\spectator.h" />
    <ClInclude Include="..\dlls\stdafx.h" />
    <ClInclude Include="..\dlls\talkmonster.h" />
    <ClInclude Include="..\dlls\training_gamerules.h" />
    <ClInclude Include="..\dlls\trains.h" />
    <ClInclude Include="..\dlls\util.h" />
    <ClInclude Include="..\dlls\vector.h" />
    <ClInclude Include="..\dlls\vehicle.h" />
    <ClInclude Include="..\dlls\weapons.h" />
    <ClInclude Include="..\game_shared\bitvec.h" />
    <ClInclude Include="..\game_shared\voice_banmgr.h" />
    <ClInclude Include="..\game_shared\voice_common.h" />
    <ClInclude Include="..\game_shared\voice_gamemgr.h" />
    <ClInclude Include="..\game_shared\voice_status.h" />
    <ClInclude Include="..\pm_shared\pm_debug.h" />
    <ClInclude Include="..\pm_shared\pm_defs.h" />
    <ClInclude Include="..\pm_shared\pm_info.h" />
    <ClInclude Include="..\pm_shared\pm_materials.h" />
    <ClInclude Include="..\pm_shared\pm_movevars.h" />
    <ClInclude Include="..\pm_shared\pm_shared.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{69DDADC0-97F4-419E-86EB-C91781A0D2E0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>hldll</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(Configuration)\$(ProjectName)\</OutDir>
    <IntDir>$(Configuration)\$(ProjectName)\int\</IntDir>
    <TargetName>mp</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(Configuration)\$(ProjectName)\</OutDir>
    <IntDir>$(Configuration)\$(ProjectName)\int\</IntDir>
    <TargetName>mp</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;QUIVER;VOXEL;QUAKE2;VALVE_DLL;CLIENT_WEAPONS;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
      <AdditionalIncludeDirectories>..\dlls;..\engine;..\common;..\pm_shared;..\game_shared;..\public;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>
      </Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;QUIVER;VOXEL;QUAKE2;VALVE_DLL;CLIENT_WEAPONS;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>..\dlls;..\engine;..\common;..\pm_shared;..\game_shared;..\public;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <RuntimeTypeInfo>true</RuntimeTypeInfo>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>
      </Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`projects/server.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{54a91ea5-da7e-4bfc-bff1-49b6849cae68}</UniqueIdentifier>
    </Filter>
    <Filter Include="inc">
      <UniqueIdentifier>{4f1623b5-c7d7-4a17-ac83-6b45430a1941}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\weapons">
      <UniqueIdentifier>{e1c83c08-214c-4a1a-ae54-7290070c18f4}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\pm">
      <UniqueIdentifier>{d770b270-f8f0-488b-9081-2e6e7b8b2d9f}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\gs">
      <UniqueIdentifier>{29cd80f8-8344-4833-942a-8c3882a760de}</UniqueIdentifier>
    </Filter>
    <Filter Include="inc\pm">
      <UniqueIdentifier>{39a0bd90-8784-40c3-af23-3b2ea4f8b789}</UniqueIdentifier>
    </Filter>
    <Filter Include="inc\gs">
      <UniqueIdentifier>{c6847509-22cf-4107-b200-87c1ec5f7665}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\dlls\airtank.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\ammo.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\animating.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\animation.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\bmodels.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\buttons.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\cbase.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\client.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\combat.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\doors.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\effects.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\explode.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\func_break.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\func_tank.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\game.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\gamerules.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\ggrenade.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\globals.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\h_ai.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\h_battery.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\h_cycler.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\h_export.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\healthkit.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\hintmessage.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\hostage.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\hostage_localnav.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\items.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\lights.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\mapinfo.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\maprules.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\MemPool.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\mortar.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\mpstubb.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\multiplay_gamerules.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\observer.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\pathcorner.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\perf_counter.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\plane.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\plats.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\player.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\singleplay_gamerules.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\skill.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\sound.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\soundent.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\spectator.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\stdafx.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\subs.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\training_gamerules.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\triggers.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\util.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\vehicle.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\weapons.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\world.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_ak47.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_aug.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_awp.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_c4.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_deagle.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_elite.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_famas.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_fiveseven.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_flashbang.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_g3sg1.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_galil.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_glock18.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_hegrenade.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_knife.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_m3.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_m4a1.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_m249.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_mac10.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_mp5navy.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_p90.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_p228.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_scout.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_sg550.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_sg552.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_smokegrenade.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_tmp.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_ump45.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_usp.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\dlls\wpn_shared\wpn_xm1014.cpp">
      <Filter>src\weapons</Filter>
    </ClCompile>
    <ClCompile Include="..\pm_shared\pm_debug.c">
      <Filter>src\pm</Filter>
    </ClCompile>
    <ClCompile Include="..\pm_shared\pm_math.c">
      <Filter>src\pm</Filter>
    </ClCompile>
    <ClCompile Include="..\pm_shared\pm_shared.c">
      <Filter>src\pm</Filter>
    </ClCompile>
    <ClCompile Include="..\game_shared\voice_banmgr.cpp">
      <Filter>src\gs</Filter>
    </ClCompile>
    <ClCompile Include="..\game_shared\voice_gamemgr.cpp">
      <Filter>src\gs</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\dlls\activity.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\activitymap.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\animation.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\basemonster.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\cbase.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\cdll_dll.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\client.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\decals.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\doors.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\effects.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\enginecallback.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\explode.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\extdll.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\func_break.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\game.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\gamerules.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\hintmessage.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\hostage.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\items.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\mapinfo.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\maprules.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\MemPool.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\monsterevent.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\monsters.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\nodes.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\perf_counter.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\plane.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\player.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\saverestore.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\schedule.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\scriptevent.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\skill.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\soundent.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\spectator.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\stdafx.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\talkmonster.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\training_gamerules.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\trains.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\util.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\vector.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\vehicle.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\dlls\weapons.h">
      <Filter>inc</Filter>
    </ClInclude>
    <ClInclude Include="..\game_shared\bitvec.h">
      <Filter>inc\gs</Filter>
    </ClInclude>
    <ClInclude Include="..\game_shared\voice_banmgr.h">
      <Filter>inc\gs</Filter>
    </ClInclude>
    <ClInclude Include="..\game_shared\voice_common.h">
      <Filter>inc\gs</Filter>
    </ClInclude>
    <ClInclude Include="..\game_shared\voice_gamemgr.h">
      <Filter>inc\gs</Filter>
    </ClInclude>
    <ClInclude Include="..\game_shared\voice_status.h">
      <Filter>inc\gs</Filter>
    </ClInclude>
    <ClInclude Include="..\pm_shared\pm_debug.h">
      <Filter>inc\pm</Filter>
    </ClInclude>
    <ClInclude Include="..\pm_shared\pm_defs.h">
      <Filter>inc\pm</Filter>
    </ClInclude>
    <ClInclude Include="..\pm_shared\pm_info.h">
      <Filter>inc\pm</Filter>
    </ClInclude>
    <ClInclude Include="..\pm_shared\pm_materials.h">
      <Filter>inc\pm</Filter>
    </ClInclude>
    <ClInclude Include="..\pm_shared\pm_movevars.h">
      <Filter>inc\pm</Filter>
    </ClInclude>
    <ClInclude Include="..\pm_shared\pm_shared.h">
      <Filter>inc\pm</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`public/tier1/UtlMemory.h`:

```h
//=========== (C) Copyright 1999 Valve, L.L.C. All rights reserved. ===========
//
// The copyright to the contents herein is the property of Valve, L.L.C.
// The contents may be used and/or copied only with the written permission of
// Valve, L.L.C., or in accordance with the terms and conditions stipulated in
// the agreement/contract under which the contents have been supplied.
//
// $Header: $
// $NoKeywords: $
//
// A growable memory class.
//=============================================================================
#pragma once
#ifndef UTLMEMORY_H
#define UTLMEMORY_H

#include <string.h>
#include <new>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>

#ifdef MSC_VER
#pragma warning (disable:4100)
#pragma warning (disable:4514)
#endif

//-----------------------------------------------------------------------------
// Methods to invoke the constructor, copy constructor, and destructor
//-----------------------------------------------------------------------------

template <class T> 
inline void Construct( T* pMemory )
{
	::new( pMemory ) T;
}

template <class T> 
inline void CopyConstruct( T* pMemory, T const& src )
{
	::new( pMemory ) T(src);
}

template <class T> 
inline void Destruct( T* pMemory )
{
	pMemory->~T();

#ifdef _DEBUG
	memset( pMemory, 0xDD, sizeof(T) );
#endif
}


















//-----------------------------------------------------------------------------
// The CUtlMemory class:
// A growable memory class which doubles in size by default.
//-----------------------------------------------------------------------------
template< class T >
class CUtlMemory
{
public:
	// constructor, destructor
	CUtlMemory( int nGrowSize = 0, int nInitSize = 0 );
	CUtlMemory( T* pMemory, int numElements );
	CUtlMemory( const T* pMemory, int numElements );
	~CUtlMemory();

	// element access
	T& operator[]( int i );
	T const& operator[]( int i ) const;
	T& Element( int i );
	T const& Element( int i ) const;

	// Can we use this index?
	bool IsIdxValid( int i ) const;

	// Gets the base address (can change when adding elements!)
	T* Base();
	T const* Base() const;

	// Attaches the buffer to external memory....
	void SetExternalBuffer( T* pMemory, int numElements );

	// Size
	int NumAllocated() const;
	int Count() const;

	// Grows the memory, so that at least allocated + num elements are allocated
	void Grow( int num = 1 );

	// Makes sure we've got at least this much memory
	void EnsureCapacity( int num );

	// Memory deallocation
	void Purge();

	// is the memory externally allocated?
	bool IsExternallyAllocated() const;

	// is the memory read only?
	bool IsReadOnly() const;

	// Set the size by which the memory grows
	void SetGrowSize( int size );

private:
	enum
	{
		EXTERNAL_BUFFER_MARKER = -1,
		EXTERNAL_CONST_BUFFER_MARKER = 2,
	};

	T* m_pMemory;
	int m_nAllocationCount;
	int m_nGrowSize;
};


//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
template< class T >
CUtlMemory<T>::CUtlMemory( int nGrowSize, int nInitAllocationCount ) : m_pMemory(0), 
	m_nAllocationCount( nInitAllocationCount ), m_nGrowSize( nGrowSize )
{
	assert( (nGrowSize >= 0) && (nGrowSize != EXTERNAL_BUFFER_MARKER) );
	if (m_nAllocationCount)
	{
		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
	}
}

template< class T >
CUtlMemory<T>::CUtlMemory( T* pMemory, int numElements ) : m_pMemory(pMemory),
	m_nAllocationCount( numElements )
{
	// Special marker indicating externally supplied memory
	m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template< class T >
CUtlMemory<T>::CUtlMemory( const T* pMemory, int numElements ) : m_pMemory( (T*)pMemory ),
	m_nAllocationCount( numElements )
{
	// Special marker indicating externally supplied modifyable memory
	m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template< class T >
CUtlMemory<T>::~CUtlMemory()
{
	Purge();
}


//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template< class T >
void CUtlMemory<T>::SetExternalBuffer( T* pMemory, int numElements )
{
	// Blow away any existing allocated memory
	Purge();

	m_pMemory = pMemory;
	m_nAllocationCount = numElements;

	// Indicate that we don't own the memory
	m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}


//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template< class T >
inline T& CUtlMemory<T>::operator[]( int i )
{
	assert( IsIdxValid(i) );
	return m_pMemory[i];
}

template< class T >
inline T const& CUtlMemory<T>::operator[]( int i ) const
{
	assert( IsIdxValid(i) );
	return m_pMemory[i];
}

template< class T >
inline T& CUtlMemory<T>::Element( int i )
{
	assert( IsIdxValid(i) );
	return m_pMemory[i];
}

template< class T >
inline T const& CUtlMemory<T>::Element( int i ) const
{
	assert( IsIdxValid(i) );
	return m_pMemory[i];
}


//-----------------------------------------------------------------------------
// is the memory externally allocated?
//-----------------------------------------------------------------------------
template< class T >
bool CUtlMemory<T>::IsExternallyAllocated() const
{
	return m_nGrowSize == EXTERNAL_BUFFER_MARKER;
}

//-----------------------------------------------------------------------------
// is the memory read only?
//-----------------------------------------------------------------------------
template< class T >
bool CUtlMemory<T>::IsReadOnly() const
{
	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);
}

template< class T >
void CUtlMemory<T>::SetGrowSize( int nSize )
{
	assert( (nSize >= 0) && (nSize != EXTERNAL_BUFFER_MARKER) );
	m_nGrowSize = nSize;
}


//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------
template< class T >
inline T* CUtlMemory<T>::Base()
{
	return m_pMemory;
}

template< class T >
inline T const* CUtlMemory<T>::Base() const
{
	return m_pMemory;
}


//-----------------------------------------------------------------------------
// Size
//-----------------------------------------------------------------------------
template< class T >
inline int CUtlMemory<T>::NumAllocated() const
{
	return m_nAllocationCount;
}

template< class T >
inline int CUtlMemory<T>::Count() const
{
	return m_nAllocationCount;
}


//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template< class T >
inline bool CUtlMemory<T>::IsIdxValid( int i ) const
{
	return (i >= 0) && (i < m_nAllocationCount);
}
 

//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
template< class T >
void CUtlMemory<T>::Grow( int num )
{
	assert( num > 0 );

	if (IsExternallyAllocated())
	{
		// Can't grow a buffer whose memory was externally allocated 
		assert(0);
		return;
	}

	// Make sure we have at least numallocated + num allocations.
	// Use the grow rules specified for this memory (in m_nGrowSize)
	int nAllocationRequested = m_nAllocationCount + num;
	while (m_nAllocationCount < nAllocationRequested)
	{
		if ( m_nAllocationCount != 0 )
		{
			if (m_nGrowSize)
			{
				m_nAllocationCount += m_nGrowSize;
			}
			else
			{
				m_nAllocationCount += m_nAllocationCount;
			}
		}
		else
		{
			// Compute an allocation which is at least as big as a cache line...
			m_nAllocationCount = (31 + sizeof(T)) / sizeof(T);
			assert(m_nAllocationCount != 0);
		}
	}

	if (m_pMemory)
	{
		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );
	}
	else
	{
		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
	}
}


//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template< class T >
inline void CUtlMemory<T>::EnsureCapacity( int num )
{
	if (m_nAllocationCount >= num)
		return;

	if (IsExternallyAllocated())
	{
		// Can't grow a buffer whose memory was externally allocated 
		assert(0);
		return;
	}

	m_nAllocationCount = num;
	if (m_pMemory)
	{
		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );
	}
	else
	{
		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );
	}
}


//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template< class T >
void CUtlMemory<T>::Purge()
{
	if (!IsExternallyAllocated())
	{
		if (m_pMemory)
		{
			free( (void*)m_pMemory );
			m_pMemory = 0;
		}
		m_nAllocationCount = 0;
	}
}


#endif // UTLSTORAGE_H

```

`public/tier1/UtlVector.h`:

```h
//=========== (C) Copyright 1999 Valve, L.L.C. All rights reserved. ===========
//
// The copyright to the contents herein is the property of Valve, L.L.C.
// The contents may be used and/or copied only with the written permission of
// Valve, L.L.C., or in accordance with the terms and conditions stipulated in
// the agreement/contract under which the contents have been supplied.
//
// $Header: $
// $NoKeywords: $
//
// A growable array class that maintains a free list and keeps elements
// in the same location
//=============================================================================

#ifndef UTLVECTOR_H
#define UTLVECTOR_H

#ifdef _WIN32
#pragma once
#endif

#include "UtlMemory.h"

//-----------------------------------------------------------------------------
// The CUtlVector class:
// A growable array class which doubles in size by default.
// It will always keep all elements consecutive in memory, and may move the
// elements around in memory (via a realloc) when elements are inserted or
// removed. Clients should therefore refer to the elements of the vector
// by index (they should *never* maintain pointers to elements in the vector).
//-----------------------------------------------------------------------------

template< class T >
class CUtlVector
{
public:
	typedef T ElemType_t;

	// constructor, destructor
	CUtlVector( int growSize = 0, int initSize = 0 );
	CUtlVector( T* pMemory, int numElements );
	~CUtlVector();
	
	// Copy the array.
	CUtlVector<T>& operator=( const CUtlVector<T> &other );

	// element access
	T& operator[]( int i );
	T const& operator[]( int i ) const;
	T& Element( int i );
	T const& Element( int i ) const;

	// Gets the base address (can change when adding elements!)
	T* Base();
	T const* Base() const;

	// Returns the number of elements in the vector
	// SIZE IS DEPRECATED!
	int Count() const;
	int Size() const;	// don't use me!

	// Is element index valid?
	bool IsValidIndex( int i ) const;
	static int InvalidIndex( void );

	// Adds an element, uses default constructor
	int AddToHead();
	int AddToTail();
	int InsertBefore( int elem );
	int InsertAfter( int elem );

	// Adds an element, uses copy constructor
	int AddToHead( T const& src );
	int AddToTail( T const& src );
	int InsertBefore( int elem, T const& src );
	int InsertAfter( int elem, T const& src );

	// Adds multiple elements, uses default constructor
	int AddMultipleToHead( int num );
	int AddMultipleToTail( int num, const T *pToCopy=NULL );	   
	int InsertMultipleBefore( int elem, int num, const T *pToCopy=NULL );	// If pToCopy is set, then it's an array of length 'num' and
	int InsertMultipleAfter( int elem, int num );

	// Calls RemoveAll() then AddMultipleToTail.
	void SetSize( int size );
	void SetCount( int count );
	
	// Calls SetSize and copies each element.
	void CopyArray( T const *pArray, int size );
	
	// Add the specified array to the tail.
	int AddVectorToTail( CUtlVector<T> const &src );

	// Finds an element (element needs operator== defined)
	int Find( T const& src ) const;

	bool HasElement( T const& src );

	// Makes sure we have enough memory allocated to store a requested # of elements
	void EnsureCapacity( int num );

	// Makes sure we have at least this many elements
	void EnsureCount( int num );

	// Element removal
	void FastRemove( int elem );	// doesn't preserve order
	void Remove( int elem );		// preserves order, shifts elements
	void FindAndRemove( T const& src );	// removes first occurrence of src, preserves order, shifts elements
	void RemoveMultiple( int elem, int num );	// preserves order, shifts elements
	void RemoveAll();				// doesn't deallocate memory

	// Memory deallocation
	void Purge();

	// Purges the list and calls delete on each element in it.
	void PurgeAndDeleteElements();

	// Set the size by which it grows when it needs to allocate more memory.
	void SetGrowSize( int size );

protected:
	// Can't copy this unless we explicitly do it!
	CUtlVector( CUtlVector const& vec ) { assert(0); 
	}

	// Grows the vector
	void GrowVector( int num = 1 );

	// Shifts elements....
	void ShiftElementsRight( int elem, int num = 1 );
	void ShiftElementsLeft( int elem, int num = 1 );

	// For easier access to the elements through the debugger
	void ResetDbgInfo();

	CUtlMemory<T> m_Memory;
	int m_Size;

	// For easier access to the elements through the debugger
	// it's in release builds so this can be used in libraries correctly
	T *m_pElements;
};


//-----------------------------------------------------------------------------
// For easier access to the elements through the debugger
//-----------------------------------------------------------------------------

template< class T >
inline void CUtlVector<T>::ResetDbgInfo()
{
	m_pElements = m_Memory.Base();
}

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------

template< class T >
inline CUtlVector<T>::CUtlVector( int growSize, int initSize )	: 
	m_Memory(growSize, initSize), m_Size(0)
{
	ResetDbgInfo();
}

template< class T >
inline CUtlVector<T>::CUtlVector( T* pMemory, int numElements )	: 
	m_Memory(pMemory, numElements), m_Size(0)
{
	ResetDbgInfo();
}

template< class T >
inline CUtlVector<T>::~CUtlVector()
{
	Purge();
}

template<class T>
inline CUtlVector<T>& CUtlVector<T>::operator=( const CUtlVector<T> &other )
{
	CopyArray( other.Base(), other.Count() );
	return *this;
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------

template< class T >
inline T& CUtlVector<T>::operator[]( int i )
{
	assert( IsValidIndex(i) );
	return m_Memory[i];
}

template< class T >
inline T const& CUtlVector<T>::operator[]( int i ) const
{
	assert( IsValidIndex(i) );
	return m_Memory[i];
}

template< class T >
inline T& CUtlVector<T>::Element( int i )
{
	assert( IsValidIndex(i) );
	return m_Memory[i];
}

template< class T >
inline T const& CUtlVector<T>::Element( int i ) const
{
	assert( IsValidIndex(i) );
	return m_Memory[i];
}


//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------

template< class T >
inline T* CUtlVector<T>::Base()
{
	return m_Memory.Base();
}

template< class T >
inline T const* CUtlVector<T>::Base() const
{
	return m_Memory.Base();
}

//-----------------------------------------------------------------------------
// Count
//-----------------------------------------------------------------------------

template< class T >
inline int CUtlVector<T>::Size() const
{
	return m_Size;
}

template< class T >
inline int CUtlVector<T>::Count() const
{
	return m_Size;
}


//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------

template< class T >
inline bool CUtlVector<T>::IsValidIndex( int i ) const
{
	return (i >= 0) && (i < m_Size);
}
 

//-----------------------------------------------------------------------------
// Returns in invalid index
//-----------------------------------------------------------------------------
template< class T >
inline int CUtlVector<T>::InvalidIndex( void )
{
	return -1;
}


//-----------------------------------------------------------------------------
// Grows the vector
//-----------------------------------------------------------------------------
template< class T >
void CUtlVector<T>::GrowVector( int num )
{
	if (m_Size + num - 1 >= m_Memory.NumAllocated())
	{
		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );
	}

	m_Size += num;
	ResetDbgInfo();
}


//-----------------------------------------------------------------------------
// Makes sure we have enough memory allocated to store a requested # of elements
//-----------------------------------------------------------------------------
template< class T >
void CUtlVector<T>::EnsureCapacity( int num )
{
	m_Memory.EnsureCapacity(num);
	ResetDbgInfo();
}


//-----------------------------------------------------------------------------
// Makes sure we have at least this many elements
//-----------------------------------------------------------------------------
template< class T >
void CUtlVector<T>::EnsureCount( int num )
{
	if (Count() < num)
		AddMultipleToTail( num - Count() );
}


//-----------------------------------------------------------------------------
// Shifts elements
//-----------------------------------------------------------------------------
template< class T >
void CUtlVector<T>::ShiftElementsRight( int elem, int num )
{
	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));
	int numToMove = m_Size - elem - num;
	if ((numToMove > 0) && (num > 0))
		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );
}

template< class T >
void CUtlVector<T>::ShiftElementsLeft( int elem, int num )
{
	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));
	int numToMove = m_Size - elem - num;
	if ((numToMove > 0) && (num > 0))
	{
		memmove( &Element(elem), &Element(elem+num), numToMove * sizeof(T) );

#ifdef _DEBUG
		memset( &Element(m_Size-num), 0xDD, num * sizeof(T) );
#endif
	}
}

//-----------------------------------------------------------------------------
// Adds an element, uses default constructor
//-----------------------------------------------------------------------------

template< class T >
inline int CUtlVector<T>::AddToHead()
{
	return InsertBefore(0);
}

template< class T >
inline int CUtlVector<T>::AddToTail()
{
	return InsertBefore( m_Size );
}

template< class T >
inline int CUtlVector<T>::InsertAfter( int elem )
{
	return InsertBefore( elem + 1 );
}

template< class T >
int CUtlVector<T>::InsertBefore( int elem )
{
	// Can insert at the end
	assert( (elem == Count()) || IsValidIndex(elem) );

	GrowVector();
	ShiftElementsRight(elem);
	Construct( &Element(elem) );
	return elem;
}


//-----------------------------------------------------------------------------
// Adds an element, uses copy constructor
//-----------------------------------------------------------------------------

template< class T >
inline int CUtlVector<T>::AddToHead( T const& src )
{
	return InsertBefore( 0, src );
}

template< class T >
inline int CUtlVector<T>::AddToTail( T const& src )
{
	return InsertBefore( m_Size, src );
}

template< class T >
inline int CUtlVector<T>::InsertAfter( int elem, T const& src )
{
	return InsertBefore( elem + 1, src );
}

template< class T >
int CUtlVector<T>::InsertBefore( int elem, T const& src )
{
	// Can insert at the end
	assert( (elem == Count()) || IsValidIndex(elem) );

	GrowVector();
	ShiftElementsRight(elem);
	CopyConstruct( &Element(elem), src );
	return elem;
}


//-----------------------------------------------------------------------------
// Adds multiple elements, uses default constructor
//-----------------------------------------------------------------------------

template< class T >
inline int CUtlVector<T>::AddMultipleToHead( int num )
{
	return InsertMultipleBefore( 0, num );
}

template< class T >
inline int CUtlVector<T>::AddMultipleToTail( int num, const T *pToCopy )
{
	return InsertMultipleBefore( m_Size, num, pToCopy );
}

template< class T >
int CUtlVector<T>::InsertMultipleAfter( int elem, int num )
{
	return InsertMultipleBefore( elem + 1, num );
}


template< class T >
void CUtlVector<T>::SetCount( int count )
{
	RemoveAll();
	AddMultipleToTail( count );
}

template< class T >
inline void CUtlVector<T>::SetSize( int size )
{
	SetCount( size );
}

template< class T >
void CUtlVector<T>::CopyArray( T const *pArray, int size )
{
	SetSize( size );
	for( int i=0; i < size; i++ )
		(*this)[i] = pArray[i];
}

template< class T >
int CUtlVector<T>::AddVectorToTail( CUtlVector const &src )
{
	int base = Count();
	
	// Make space.
	AddMultipleToTail( src.Count() );

	// Copy the elements.	
	for ( int i=0; i < src.Count(); i++ )
		(*this)[base + i] = src[i];

	return base;
}

template< class T >
inline int CUtlVector<T>::InsertMultipleBefore( int elem, int num, const T *pToInsert )
{
	if( num == 0 )
		return elem;
	
	// Can insert at the end
	assert( (elem == Count()) || IsValidIndex(elem) );

	GrowVector(num);
	ShiftElementsRight(elem, num);

	// Invoke default constructors
	for (int i = 0; i < num; ++i)
		Construct( &Element(elem+i) );

	// Copy stuff in?
	if ( pToInsert )
	{
		for ( int i=0; i < num; i++ )
		{
			Element( elem+i ) = pToInsert[i];
		}
	}

	return elem;
}

//-----------------------------------------------------------------------------
// Finds an element (element needs operator== defined)
//-----------------------------------------------------------------------------
template< class T >
int CUtlVector<T>::Find( T const& src ) const
{
	for ( int i = 0; i < Count(); ++i )
	{
		if (Element(i) == src)
			return i;
	}
	return -1;
}

template< class T >
bool CUtlVector<T>::HasElement( T const& src )
{
	return ( Find(src) >= 0 );
}

//-----------------------------------------------------------------------------
// Element removal
//-----------------------------------------------------------------------------

template< class T >
void CUtlVector<T>::FastRemove( int elem )
{
	assert( IsValidIndex(elem) );

	Destruct( &Element(elem) );
	if (m_Size > 0)
	{
		memcpy( &Element(elem), &Element(m_Size-1), sizeof(T) );
		--m_Size;
	}
}

template< class T >
void CUtlVector<T>::Remove( int elem )
{
	Destruct( &Element(elem) );
	ShiftElementsLeft(elem);
	--m_Size;
}

template< class T >
void CUtlVector<T>::FindAndRemove( T const& src )
{
	int elem = Find( src );
	if ( elem != -1 )
	{
		Remove( elem );
	}
}

template< class T >
void CUtlVector<T>::RemoveMultiple( int elem, int num )
{
	assert( IsValidIndex(elem) );
	assert( elem + num <= Count() );

	for (int i = elem + num; --i >= elem; )
		Destruct(&Element(i));

	ShiftElementsLeft(elem, num);
	m_Size -= num;
}

template< class T >
void CUtlVector<T>::RemoveAll()
{
	for (int i = m_Size; --i >= 0; )
		Destruct(&Element(i));

	m_Size = 0;
}


//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------

template< class T >
void CUtlVector<T>::Purge()
{
	RemoveAll();
	m_Memory.Purge( );
	ResetDbgInfo();
}


template<class T>
inline void CUtlVector<T>::PurgeAndDeleteElements()
{
	for( int i=0; i < m_Size; i++ )
		delete Element(i);

	Purge();
}


template< class T >
void CUtlVector<T>::SetGrowSize( int size )
{
	m_Memory.SetGrowSize( size );
}


#endif // CCVECTOR_H

```