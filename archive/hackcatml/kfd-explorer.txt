Project Path: arc_hackcatml_kfd-explorer_j4yxncts

Source Tree:

```txt
arc_hackcatml_kfd-explorer_j4yxncts
├── LICENSE
├── README.md
├── code.py
├── disasm.py
├── disasm.ui
├── globvar.py
├── hexviewer.py
├── history.py
├── history.ui
├── icon
│   ├── greenlight.png
│   ├── kfd-explorer.png
│   └── redlight.png
├── kfd-explorer.sh
├── kfund-gadget.ipa
├── kfundfiles
│   ├── ContentView.swift
│   ├── frida-gadget-16.1.11.config
│   └── frida-gadget-16.1.11.dylib
├── main.py
├── requirements.txt
├── scripts
│   └── default.js
├── ui.py
├── ui.ui
└── utilviewer.py

```

`LICENSE`:

```
GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.
```

`README.md`:

```md
# kfd-explorer
Kernel memory explorer utilizing [kfund](https://github.com/wh1te4ever/kfund) project with frida-gadget

## Supported Device
iOS/iPadOS 16.0-16.6.1

## Usage
1.&nbsp;Install kfund-gadget.ipa using trollstroe or sideloadly<br>

2.&nbsp;Launch kfd app and kopen

3.&nbsp;Run kfd-explorer
```
# Git clone
git clone https://github.com/hackcatml/kfd-explorer
cd kfd-explorer

# Run
./kfd-explorer.sh
```

4.&nbsp;Attach<br>
If it cannot attach, try running Xcode briefly.

## Screenshots
![image](https://github.com/hackcatml/kfd-explorer/assets/75507443/403e617f-b252-4829-ae55-cb324829e696)
![image](https://github.com/hackcatml/kfd-explorer/assets/75507443/6cf60086-bd89-41f0-a7d1-4af699db3441)
![image](https://github.com/hackcatml/kfd-explorer/assets/75507443/011b1d7d-ed99-4051-ba83-72dc86145d1b)

## Build kfund-gadget.ipa
```
# Git clone kfund
git clone https://github.com/wh1te4ever/kfund

# Replace ContentView.swift
Replace the ContentView.swift in kfund with the one in the kfundfiles directory

# Include frida-gadget
Put frida-gadget-16.1.11.dylib, frida-gadget-16.1.11.config in the kfund project

# Build
Open kfund > Build Phases > Copy Bundle Resources > add frida-gadget-16.1.11.dylib, frida-gadget-16.1.11.config.
Build
```

## Credits
[kfund](https://github.com/wh1te4ever/kfund)<br>

```

`code.py`:

```py
import platform

import frida
from PySide6 import QtCore
from PySide6.QtCore import QObject

MESSAGE = ""
ERRMESSAGE = ""


def clean_message():
    global MESSAGE
    MESSAGE = ''


class Instrument(QObject):
    attachsig = QtCore.Signal(int)

    def __init__(self, script_text, target):
        super().__init__()
        self.name = None
        self.sessions = []
        self.script = None
        self.script_text = script_text
        self.device = None
        self.device = frida.get_usb_device(1)
        self.attachtarget = target

    def __del__(self):
        for session in self.sessions:
            session.detach()

    def is_attached(self, attached: bool):
        self.attachsig.emit(1) if attached is True else self.attachsig.emit(0)

    def on_destroyed(self):
        self.attachsig.emit(0)

    # frida script에서 send 함수로 보내는 메시지는 on_message에서 처리됨
    def on_message(self, message, data):
        # print(message)
        global MESSAGE
        if 'payload' in message and message['payload'] is not None:
            MESSAGE = message['payload']
        if message['type'] == 'error':
            ERRMESSAGE = message['description']
            ERRMESSAGE += message['stack']
            print("[hackcatml] errmessage: ", ERRMESSAGE)

    def read_frida_js_source(self):
        # on Windows should open frida script with encoding option('cp949 issue')
        with open(self.script_text, 'r', encoding="UTF8") if platform.system() == 'Windows' \
                else open(self.script_text, "r") as f:
            return f.read()

    def instrument(self, caller):
        session = self.device.attach(self.attachtarget)
        self.name = self.attachtarget
        session.on('detached', self.is_attached)    # register is_attached callback func for a session's on detach event
        self.sessions.append(session)
        self.script = session.create_script(self.read_frida_js_source())
        self.script.on('message', self.on_message)
        self.script.on('destroyed', self.on_destroyed)
        self.script.load()
        self.is_attached(True)

    def get_agent(self):
        return self.script.exports_sync

    # just dummy func for checking script is destroyed or not
    def dummy_script(self):
        self.script.exports.dummy()
        return MESSAGE

    def arch(self):
        self.script.exports.arch()
        return MESSAGE

    def platform(self):
        self.script.exports.platform()
        return MESSAGE

    def list_modules(self):
        self.script.exports.listmodules()
        return MESSAGE

    def mem_enumerate_ranges(self, prot):
        enumranges = self.script.exports.enumerateranges(prot)
        return enumranges

    def get_kernel_slide(self):
        return self.script.exports.get_kernel_slide()

    def get_vm_kernel_link_addr(self):
        return self.script.exports.get_vm_kernel_link_addr()

    def get_kernel_base(self):
        return int(self.get_vm_kernel_link_addr()) + int(self.get_kernel_slide())

    def get_kern_version(self):
        return self.script.exports.get_kern_version()

    def get_offsets(self):
        clean_message()
        self.script.exports.get_offsets()
        return MESSAGE

    def get_kfd(self):
        clean_message()
        self.script.exports.get_kfd()
        return MESSAGE

    def get_all_proc(self, pid):
        return self.script.exports.get_all_proc(pid)

    def get_vnode_at_path(self, filePath):
        clean_message()
        self.script.exports.get_vnode_at_path(filePath)
        return MESSAGE

    def unsign_kptr(self, pac_kaddr):
        return self.script.exports.unsign_kptr(pac_kaddr)

    def read_kmem_offset(self, offset):
        if offset == "0x0":
            kaddr = self.get_kernel_base()
            self.script.exports.k_hex_dump(kaddr, None)
        else:
            kaddr = str(int(self.get_kernel_base()) + int(offset, 16))
            self.script.exports.k_hex_dump(kaddr, None)
        return MESSAGE

    def read_kmem_addr(self, kaddr, size):
        clean_message()
        self.script.exports.k_hex_dump(kaddr, size)
        return MESSAGE

    def write_kmem_addr(self, arg):
        for target in arg:
            targetAddr = target[0]
            targetPatchCode = target[1]
            self.script.exports.write_kmem_addr(targetAddr, targetPatchCode)

    def read_mem_addr(self, addr, size):
        clean_message()
        self.script.exports.hexdumpaddr(addr, size)
        return MESSAGE

    def write_mem_addr(self, arg):
        for target in arg:
            targetAddr = target[0]
            targetPatchCode = target[1]
            targetProt = target[3]
            self.script.exports.writememaddr(targetAddr, targetPatchCode, targetProt)



```

`disasm.py`:

```py
import re
import platform

from PySide6.QtCore import QObject, Qt, Slot
from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtWidgets import QWidget
from capstone import *


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(550, 300)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.disasmBrowser = QtWidgets.QTextEdit(Form)
        self.disasmBrowser.setReadOnly(True)
        font = QtGui.QFont()
        font.setFamily("Courier New")
        fontsize = 13 if platform.system() == 'Darwin' else 10
        font.setPointSize(fontsize)
        self.disasmBrowser.setFont(font)
        self.disasmBrowser.setObjectName("disasmBrowser")
        self.gridLayout.addWidget(self.disasmBrowser, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Disassemble"))


class EscapableWidget(QWidget):
    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape:
            self.close()
        else:
            super().keyPressEvent(event)


class DisassembleWorker(QObject):
    def __init__(self):
        super().__init__()
        self.disasm_window = EscapableWidget()
        self.disasm_window.setWindowFlags(Qt.WindowType.WindowStaysOnTopHint)
        self.disasmui = Ui_Form()
        self.disasmui.setupUi(self.disasm_window)

        self.hexviewer = None

        self.disasm_result = None

    def disassemble(self, arch: str, addr: str, hex_dump_result: str):
        hex_dump_result = hex_dump_result.replace('\u2029', '\n')
        lines = hex_dump_result.strip().split('\n')

        hex_data = []
        for line in lines:
            # Calculate hex start and end positions
            hex_start = len(line) - 65
            hex_end = len(line) - 16

            # Extract hex part
            hex_part = line[hex_start:hex_end]

            # Extract two-digit hex numbers from the part
            matches = re.findall(r'\b[0-9a-fA-F]{2}\b', hex_part)
            hex_data.append(' '.join(matches))

        hex_string = ' '.join(hex_data).split()
        disasm_target = b''.join(bytes([int(hex_value, 16)]) for hex_value in hex_string)

        md = Cs(CS_ARCH_ARM64, CS_MODE_ARM) if arch == "arm64" else Cs(CS_ARCH_ARM, CS_MODE_ARM)
        disasm_lines = []
        for (address, size, mnemonic, op_str) in md.disasm_lite(disasm_target, int(addr, 16)):
            # print("0x%x\t%s\t%s" % (address, mnemonic, op_str))
            disasm_lines.append("%x \t%s\t%s" % (address, mnemonic, op_str))

        self.disasm_result = '\n'.join(disasm_lines)
        self.disasmui.disasmBrowser.setText(self.disasm_result)

    @Slot(str)
    def hexviewer_wheelsig_func(self, wheelsig: str):
        if not re.search(r"0x[0-9a-f]+", wheelsig) or re.search(r"\d+\. 0x[0-9a-f]+, module:", wheelsig):
            return

        tc = self.disasmui.disasmBrowser.textCursor()
        if not re.search(r"[0-9a-f]+", tc.block().text().split('\t')[0]):
            return

        # calculate scrollbar position
        wheel_gap = int(wheelsig, 16) - int(tc.block().text().split('\t')[0], 16)
        if wheel_gap < 0:
            return
        wheel_count = round(wheel_gap / 64)
        gap = (wheel_gap + 16 * wheel_count) * 3
        scrollbar = self.disasmui.disasmBrowser.verticalScrollBar()
        scrollbar.setValue(gap)

    @Slot(int)
    def hexviewer_scrollsig_func(self, scrollsig: int):
        # sync the scrollbar position with hexviewer's one approximately
        scrollbar = self.disasmui.disasmBrowser.verticalScrollBar()
        scrollbar.setValue(4 * scrollsig - 5)

```

`disasm.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>524</width>
    <height>294</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Disassemble</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTextEdit" name="disasmBrowser">
     <property name="font">
      <font>
       <family>Courier New</family>
       <pointsize>13</pointsize>
      </font>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`globvar.py`:

```py
errorType1 = "script has been destroyed"

fridaInstrument = None
enumerateRanges = []
isFridaAttached = False
offsets = []
arch = None

isHexEditMode = False
hexEdited = []

currentFrameBlockNumber = 0
currentFrameStartAddress = ''

visitedAddress = []

```

`hexviewer.py`:

```py
import inspect
import re

from PySide6 import QtGui, QtCore
from PySide6.QtCore import Qt
from PySide6.QtGui import QTextCursor, QAction, QCursor
from PySide6.QtWidgets import QTextEdit, QApplication, QWidget, QVBoxLayout

import globvar


class HexViewerClass(QTextEdit):
    wheelupsig = QtCore.Signal(str)
    wheelsig = QtCore.Signal(str)
    scrollsig = QtCore.Signal(int)
    movesig = QtCore.Signal(int)
    refreshsig = QtCore.Signal(int)

    def __init__(self, args):
        super(HexViewerClass, self).__init__(args)
        self.hitcount = 0
        self.verticalScrollBar().sliderMoved.connect(self.setScrollBarPos)
        self.statusBar = None
        self.result_widget = ResultWidget()
        # hexviewer text changed event
        self.textChanged.connect(self.text_changed_event)

    def setScrollBarPos(self, value):
        # print("[hackcatml] slidermoved: ", value)
        self.scrollsig.emit(value)
        globvar.currentFrameBlockNumber = round(value / 15)

    # wheelevent https://spec.tistory.com/449
    def wheelEvent(self, e: QtGui.QWheelEvent) -> None:
        delta = e.angleDelta().y()
        # wheel down
        if delta < 0:
            globvar.currentFrameBlockNumber += -1 * delta / 120 * 4
        # wheel up
        elif delta > 0 and globvar.currentFrameBlockNumber > 0:
            globvar.currentFrameBlockNumber -= delta / 120 * 4

        tc = self.textCursor()
        tc.movePosition(QTextCursor.MoveOperation.Start, QTextCursor.MoveMode.MoveAnchor, 1)
        tc.movePosition(QTextCursor.MoveOperation.Down, QTextCursor.MoveMode.MoveAnchor, int(globvar.currentFrameBlockNumber))
        globvar.currentFrameStartAddress = "".join(("0x", tc.block().text()[:tc.block().text().find(' ')]))

        if tc.blockNumber() == 0 and re.search(r"\d+\. 0x[0-9a-f]+, module:", tc.block().text()) is None:
            self.hitcount += 1
            if self.hitcount > 0 and delta > 0:
                self.wheelupsig.emit(globvar.currentFrameStartAddress)
                self.hitcount = 0
        elif re.search(r"\d+\. 0x[0-9a-f]+, module:", tc.block().text()) is None:
            self.wheelsig.emit(globvar.currentFrameStartAddress)
        # print("[hackcatml] globvar.currentFrameBlockNumber: ", globvar.currentFrameBlockNumber)
        # print("[hackcatml] tc.blockNumber(): ", tc.blockNumber())
        # print("[hackcatml] tc.block().text(): ", tc.block().text())
        # print("[hackcatml] globvar.currentFrameStartAddress: ", globvar.currentFrameStartAddress)

        return super(HexViewerClass, self).wheelEvent(e)

    def keyReleaseEvent(self, e: QtGui.QKeyEvent) -> None:
        # if key is hexedit shortcut key then just return. if not hexeditor behavior is weird
        if e.key() == Qt.Key.Key_F2:
            return

        tc = self.textCursor()
        tcx = tc.positionInBlock()
        # print("keyrelease pos: ", tcx)
        indices = [i for i, x in enumerate(tc.block().text()) if x == " "]
        if len(indices) == 0:
            return
        if tcx in range(indices[1]):
            return

        # change color on edited hex as black -> red
        if self.isReadOnly() is False:
            self.moveCursor(QTextCursor.MoveOperation.Left, QTextCursor.MoveMode.KeepAnchor)
            self.setTextColor(QtGui.QColor("Red"))
            self.moveCursor(QTextCursor.MoveOperation.Right)

        if tcx in range(indices[2], indices[len(indices) - 2] + 3, 3) and e.key() != Qt.Key.Key_Left:
            if tcx == indices[len(indices) - 2]:
                self.moveCursor(QTextCursor.MoveOperation.Down)
                self.moveCursor(QTextCursor.MoveOperation.StartOfLine)
                self.moveCursor(QTextCursor.MoveOperation.NextWord)
                return
            self.moveCursor(QTextCursor.MoveOperation.Right)
            return

    def keyPressEvent(self, e: QtGui.QKeyEvent) -> None:
        tc = self.textCursor()
        tcx = tc.positionInBlock()
        tcy = tc.anchor()
        # print("keypress pos: ", tcx, tcy)

        # backspace, delete, enter, left key and space is not allowed
        if e.key() in (
                QtCore.Qt.Key.Key_Backspace, QtCore.Qt.Key.Key_Delete, QtCore.Qt.Key.Key_Return, Qt.Key.Key_Left, Qt.Key.Key_Space
        ): return

        # hexedit 모드에서 ctrl + a, cmd + a (select all), ctrl + v, cmd + v (paste) is not allowed
        # if self.isReadOnly() is False:
        if (e.keyCombination().keyboardModifiers() == QtCore.Qt.KeyboardModifier.MetaModifier or e.keyCombination().keyboardModifiers() == QtCore.Qt.KeyboardModifier.ControlModifier) and e.key() == QtCore.Qt.Key.Key_A:
            # print("ctrl + a, cmd + a is not allowed")
            return
        if (e.keyCombination().keyboardModifiers() == QtCore.Qt.KeyboardModifier.MetaModifier or e.keyCombination().keyboardModifiers() == QtCore.Qt.KeyboardModifier.ControlModifier) and e.key() == QtCore.Qt.Key.Key_V:
            # print("ctrl + v, cmd + v is not allowed")
            return

        # cmd, ctrl, alt, shift + up, right, left, down selection not allowed
        # print(str(e.keyCombination().keyboardModifiers()))
        if str(e.keyCombination().keyboardModifiers()) in ["KeyboardModifier.KeypadModifier|ShiftModifier", "KeyboardModifier.AltModifier", "KeyboardModifier.KeypadModifier|ControlModifier|ShiftModifier", "KeyboardModifier.KeypadModifier|MetaModifier|ShiftModifier","KeyboardModifier.KeypadModifier|AltModifier|ShiftModifier", "KeyboardModifier.KeypadModifier|ControlModifier"]: return

        # editable only hex area. indices => [9, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58, 59]
        indices = [i for i, x in enumerate(tc.block().text()) if x == " "]
        if (len(indices) > 0) is False:
            return
        if tcx in range(indices[1]) or tcx in range(indices[1] + 3, indices[len(indices) - 2] + 3, 3):
            return

        super(HexViewerClass, self).keyPressEvent(e)

    def mousePressEvent(self, e: QtGui.QMouseEvent) -> None:
        super(HexViewerClass, self).mousePressEvent(e)
        pos = e.pos()
        tc = self.cursorForPosition(pos)
        tcx = tc.positionInBlock()
        line = tc.block().text()
        # print(tc.block().text())
        # print("mousepress pos: ", tcx, tcy)

        indices = [i for i, x in enumerate(line) if x == " "]
        # memory pattern search 한 결과창에서 마우스 클릭한 경우
        if len(indices) == 0:
            if e.buttons() == QtCore.Qt.MouseButton.XButton1 or e.buttons() == QtCore.Qt.MouseButton.XButton2: return
            for i in range(2): self.moveCursor(QTextCursor.MoveOperation.Up)
            self.moveCursor(QTextCursor.MoveOperation.NextWord)
            return
        # elif line.find(', module:') != -1:
        elif re.search(r"\d+\. 0x[a-f0-9]+, module:", line):
            if e.buttons() == QtCore.Qt.MouseButton.XButton1 or e.buttons() == QtCore.Qt.MouseButton.XButton2: return
            self.moveCursor(QTextCursor.MoveOperation.Down)
            self.moveCursor(QTextCursor.MoveOperation.StartOfBlock)
            self.moveCursor(QTextCursor.MoveOperation.NextWord)
            return

        if e.buttons() == QtCore.Qt.MouseButton.XButton1:
            self.movesig.emit(0)
        elif e.buttons() == QtCore.Qt.MouseButton.XButton2:
            self.movesig.emit(1)

        # mouse left click on non hex editable region at normal hexviewer
        if e.buttons() == QtCore.Qt.MouseButton.LeftButton and len(indices) > 0:
            # ADDRESS region
            if tcx in range(indices[1] + 1):
                self.moveCursor(QTextCursor.MoveOperation.NextWord)
                return
            # ASCII String Region
            if tcx in range(len(line) - 16, len(line) + 1):
                self.moveCursor(QTextCursor.MoveOperation.StartOfLine)
                for i in range(16):
                    self.moveCursor(QTextCursor.MoveOperation.NextWord)
                return
            # if (tcx - 9) % 3 == 0 or (tcx - 9) % 3 == 1:
            if tcx in indices or (tcx + 1) in indices:
                self.moveCursor(QTextCursor.MoveOperation.PreviousWord)
                return

    def contextMenuEvent(self, e: QtGui.QContextMenuEvent) -> None:
        # If in hexedit mode, don't create a context menu on right click
        if not self.isReadOnly():
            return

        tc = self.cursorForPosition(e.pos())
        tcx = tc.positionInBlock()

        menu = super(HexViewerClass, self).createStandardContextMenu()  # Get the default context menu
        select_all_action = next((action for action in menu.actions() if "Select All" in action.text()), None)

        if select_all_action:
            # Check if the selected text matches the hex_regex
            hex_regex = re.compile(r'(\b0x[a-fA-F0-9]+\b|\b[a-fA-F0-9]{6,}\b)')
            match = hex_regex.match(self.textCursor().selectedText())
            is_selected = bool(self.textCursor().selectedText())

            def create_action(text, enabled, func):
                action = QAction(text, self)
                action.setEnabled(enabled)
                action.triggered.connect(func)
                return action

            # Create and insert the actions
            copy_hex_action = create_action("Copy Hex", is_selected and match is None, self.copy_hex)
            disassemble_action = create_action("Hex to Arm", is_selected and match is None, self.request_armconverter)

            copy_pointer_action = None
            unsign_kptr_action = None
            if globvar.fridaInstrument is None:
                self.statusBar.showMessage(f"Attach first", 3000)
                return
            addr_match = hex_regex.match(tc.block().text())
            if addr_match is not None:
                addr_length = len(addr_match[0])
                hex_start = addr_length + 2
                cursor_len_4bytes = 12  # '00 00 00 00 '
                cursor_len_8bytes = 2 * 12
                if globvar.arch == "arm64" and (tcx in [hex_start, hex_start + 1, hex_start + 2] or tcx in [hex_start + cursor_len_8bytes, hex_start + cursor_len_8bytes + 1, hex_start + cursor_len_8bytes + 2]):
                    make_copy_pointer_action = True
                elif globvar.arch == "arm" and (tcx in [hex_start, hex_start + 1, hex_start + 2] or tcx in [hex_start + cursor_len_4bytes, hex_start + cursor_len_4bytes + 1, hex_start + cursor_len_4bytes + 2] or tcx in [hex_start + cursor_len_8bytes, hex_start + cursor_len_8bytes + 1, hex_start + cursor_len_8bytes + 2] or tcx in [hex_start + 3 * cursor_len_4bytes, hex_start + 3 * cursor_len_4bytes + 1, hex_start + 3 * cursor_len_4bytes + 2]):
                    make_copy_pointer_action = True
                else:
                    make_copy_pointer_action = False

                if make_copy_pointer_action:
                    copy_pointer_action = create_action("Copy Pointer", match is None,
                                                        lambda: self.copy_pointer(tc, hex_start))
                    unsign_kptr_action = create_action("Unsign kptr", match is None,
                                                       lambda: self.unsign_kptr(tc, hex_start))

            menu.insertAction(select_all_action, copy_hex_action)
            menu.insertAction(select_all_action, disassemble_action)
            if copy_pointer_action is not None:
                menu.insertAction(select_all_action, copy_pointer_action)
                menu.insertAction(select_all_action, unsign_kptr_action)

        menu.exec(e.globalPos())

    def text_changed_event(self):
        tc = self.textCursor()
        tcx = tc.positionInBlock()
        line = tc.block().text()
        # print("[hackcatml] text changed: " + tc.block().text())

        # if tc.block().text() == "", index out of error occurs
        if line == "": return

        # if changed text is not hex, then refresh the hex viewer
        # print(f"text: {line[len(line) - 66:len(line) - 16]}")
        if re.search(r"[^0-9a-f\s]+", line[len(line) - 66:len(line) - 16]) and not re.search(r"\d+\. 0x[0-9a-f]+, module:", line):
            self.refreshsig.emit(1) if globvar.isFridaAttached else None
            return

        indices = [i for i, x in enumerate(line) if x == " "]
        try:
            hexstart = indices[1] + 1
        except Exception as e:
            print(f"{inspect.currentframe().f_code.co_name}: {e}")
            self.clear()
            return

        # print("[hackcatml] (tcx - hexstart) // 3 = ", (tcx - hexstart) // 3)
        if (tcx - hexstart) // 3 < 0 or (tcx - hexstart) // 3 > 15: return

        addr = hex(int(line[:line.find(" ")], 16) + (tcx - hexstart) // 3)
        # print("[hackcatml] text changed addr: ", addr)

        changed = line[3 * ((tcx - hexstart) // 3) + hexstart: 3 * ((tcx - hexstart) // 3) + hexstart + 2]
        changed = "".join(("0x", changed))
        # print("[hackcatml] changed hex: ", changed)

        pos = tc.position()

        try:
            orig = globvar.fridaInstrument.read_kmem_addr(addr, 1)
            index = orig.find("\n")
            index = index + orig[index:].find(' ') + 2
            orig = orig[index: index + 2]
            orig = "".join(("0x", orig))
            if changed == orig or len(changed.replace('0x', '').strip()) == 1 or re.search(r"(?![0-9a-fA-F]).",
                                                                                           changed.replace('0x', '')):
                return
        except Exception as e:
            if str(e) == globvar.errorType1:
                globvar.fridaInstrument.sessions.clear()
            return

        prot = '---'
        for i in range(len(globvar.enumerateRanges)):
            if int(globvar.enumerateRanges[i][0], 16) <= int(addr, 16) <= int(globvar.enumerateRanges[i][1], 16):
                prot = globvar.enumerateRanges[i][2]

        for i in range(len(globvar.hexEdited)):
            if addr in globvar.hexEdited[i]:
                globvar.hexEdited[i][1] = changed
                globvar.hexEdited[i][2] = orig
                globvar.hexEdited[i][3] = prot
                globvar.hexEdited[i][4] = pos
                return

        globvar.hexEdited.append([addr, changed, orig, prot, pos])
        # print(f"text changed pos: {tcx}")

    def selected_text(self, request_to_armconverter: bool) -> str:
        selected_text = self.textCursor().selectedText()  # gets the currently selected text
        selected_text = selected_text.replace('\u2029', '\n')
        lines = selected_text.strip().split('\n')
        if len(lines) <= 2:
            hex_data = []
            for line in lines:
                matches = re.findall(r'\b[0-9a-fA-F]{2}\b', line)
                hex_data.append(' '.join(matches))
            if request_to_armconverter is False:
                hex_string = '\n'.join(hex_data)
            else:
                hex_string = ''.join(hex_data)
            return hex_string
        elif len(lines) > 2:
            # Determine the length of the second line
            second_line_length = len(lines[1])
            # If the first line is shorter, pad it with spaces at the beginning
            if len(lines[0]) < second_line_length:
                difference = second_line_length - len(lines[0])
                lines[0] = ' ' * difference + lines[0]
            # If the last line is shorter, pad it with spaces at the end
            if len(lines[-1]) < second_line_length:
                difference = second_line_length - len(lines[-1])
                lines[-1] += ' ' * difference
            hex_data = []
            for line in lines:
                # Calculate hex start and end positions
                hex_start = len(line) - 65
                hex_end = len(line) - 16

                # Extract hex part
                hex_part = line[hex_start:hex_end]

                # Extract two-digit hex numbers from the part
                matches = re.findall(r'\b[0-9a-fA-F]{2}\b', hex_part)
                hex_data.append(' '.join(matches))
            # Join hex data into a single string
            if request_to_armconverter is False:
                hex_string = '\n'.join(hex_data)
            else:
                hex_string = ''.join(hex_data)
            return hex_string

    def copy_hex(self):
        hex_string = self.selected_text(False)
        QApplication.clipboard().setText(hex_string)  # copies the hex text to the clipboard

    def request_armconverter(self):
        import requests

        url = 'https://armconverter.com/api/convert'
        hex_string = self.selected_text(True)

        payload = {"hex": hex_string, "offset": "", "arch": [globvar.arch]}
        response = requests.post(url, json=payload)
        data = response.json()

        if data['asm'][globvar.arch][0] is True:
            hex_to_arm_result = data['asm'][globvar.arch][1]
            # Show the copied text in a new widget
            self.new_hex_to_arm_widget = NewHexToArmWidget(hex_to_arm_result)
            cursor_pos = QCursor.pos()
            # Move the widget to the cursor position
            self.new_hex_to_arm_widget.move(cursor_pos)
            self.new_hex_to_arm_widget.show()
        else:
            print("Fail to hex to arm convert")

    def hex_code_at_pos(self, tc, hex_start):
        tcx = tc.positionInBlock()
        cursor_len_4bytes = 12
        cursor_len_8bytes = 12 * 2
        hex_code = None

        if tcx in [hex_start, hex_start + 1, hex_start + 2]:
            hex_code = tc.block().text()[
                       hex_start:hex_start + cursor_len_8bytes - 1] if globvar.arch == "arm64" else tc.block().text()[
                                                                                                    hex_start:hex_start + cursor_len_4bytes - 1]
        elif tcx in [hex_start + cursor_len_4bytes, hex_start + cursor_len_4bytes + 1,
                     hex_start + cursor_len_4bytes + 2]:
            hex_code = tc.block().text()[hex_start + cursor_len_4bytes:hex_start + cursor_len_8bytes - 1]
        elif tcx in [hex_start + cursor_len_8bytes, hex_start + cursor_len_8bytes + 1,
                     hex_start + cursor_len_8bytes + 2]:
            hex_code = tc.block().text()[
                       hex_start + cursor_len_8bytes:hex_start + 2 * cursor_len_8bytes - 1] if globvar.arch == "arm64" else tc.block().text()[
                                                                                                                            hex_start + cursor_len_8bytes:hex_start + 3 * cursor_len_4bytes - 1]
        elif tcx in [hex_start + 3 * cursor_len_4bytes, hex_start + 3 * cursor_len_4bytes + 1,
                     hex_start + 3 * cursor_len_4bytes + 2]:
            hex_code = tc.block().text()[hex_start + 3 * cursor_len_4bytes:hex_start + 4 * cursor_len_4bytes - 1]

        return hex_code

    def copy_pointer(self, tc: QTextCursor, hex_start):
        hex_code = self.hex_code_at_pos(tc, hex_start)
        pointer = hex(int(''.join(reversed(hex_code.split(' '))), 16))
        QApplication.clipboard().setText(pointer)

    def unsign_kptr(self, tc: QTextCursor, hex_start):
        hex_code = self.hex_code_at_pos(tc, hex_start)
        pointer = hex(int(''.join(reversed(hex_code.split(' '))), 16))
        result = globvar.fridaInstrument.unsign_kptr(pointer)

        self.result_widget.text_edit.append(hex(int(result)))
        cursorPOS = QCursor.pos()
        self.result_widget.move(cursorPOS)
        self.result_widget.show()


class ResultWidget(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Unsign kptr")
        self.setWindowFlags(Qt.WindowType.WindowStaysOnTopHint)
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)  # Make the text edit read-only
        self.layout = QVBoxLayout()
        self.layout.addWidget(self.text_edit)
        self.setLayout(self.layout)
        self.resize(250, 100)

    def closeEvent(self, e: QtGui.QCloseEvent) -> None:
        self.text_edit.clear()
        self.text_edit.closeEvent(e)
        super().closeEvent(e)

    def keyPressEvent(self, event: QtGui.QKeyEvent) -> None:
        if event.key() == Qt.Key_Escape:
            self.close()
        else:
            super().keyPressEvent(event)


class NewHexToArmWidget(QWidget):
    def __init__(self, text):
        super().__init__()
        self.setWindowTitle("HEX to ARM")
        self.text_edit = QTextEdit()
        self.text_edit.setPlainText(text)
        self.text_edit.setReadOnly(True)  # Make the text edit read-only
        self.layout = QVBoxLayout()
        self.layout.addWidget(self.text_edit)
        self.setLayout(self.layout)





```

`history.py`:

```py
import platform

from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtCore import Qt, QObject
from PySide6.QtWidgets import QTableWidgetItem, QWidget


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(480, 170)
        font = QtGui.QFont()
        font.setFamily("Courier New")
        font_size = 13 if platform.system() == "Darwin" else 9
        font.setPointSize(font_size)
        Form.setFont(font)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.historyTableWidget = QtWidgets.QTableWidget(Form)
        font = QtGui.QFont()
        font.setFamily("Courier New")
        self.historyTableWidget.setFont(font)
        self.historyTableWidget.setColumnCount(2)
        self.historyTableWidget.setColumnWidth(0, 170)
        self.historyTableWidget.setColumnWidth(1, 250)
        self.historyTableWidget.setHorizontalHeaderLabels(['Address', 'Description'])
        self.historyTableWidget.setObjectName("historyTableWidget")
        self.gridLayout.addWidget(self.historyTableWidget, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "History"))


class EscapableWidget(QWidget):
    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape:
            self.close()
        else:
            super().keyPressEvent(event)


class HistoryViewClass(QObject):
    historyaddrsig = QtCore.Signal(str)

    def __init__(self):
        super().__init__()
        self.history_window = EscapableWidget()
        self.history_ui = Ui_Form()
        self.history_ui.setupUi(self.history_window)

        self.history_ui.historyTableWidget.itemClicked.connect(self.addr_clicked)

    def add_row(self, addr):
        for row in range(self.history_ui.historyTableWidget.rowCount()):
            item = self.history_ui.historyTableWidget.item(row, 0)
            if item is not None and item.text() == addr:
                return

        row_position = self.history_ui.historyTableWidget.rowCount()
        self.history_ui.historyTableWidget.insertRow(row_position)

        # Address column (non-editable)
        address_item = QTableWidgetItem(f"{addr}")
        address_item.setFlags(address_item.flags() & ~Qt.ItemFlag.ItemIsEditable)  # Make it non-editable
        self.history_ui.historyTableWidget.setItem(row_position, 0, address_item)

        # Description column (editable)
        description_item = QTableWidgetItem("Description")
        self.history_ui.historyTableWidget.setItem(row_position, 1, description_item)

    def addr_clicked(self, item):
        if item.column() == 0:
            self.historyaddrsig.emit(item.text())

    def clear_table(self):
        self.history_ui.historyTableWidget.clearContents()
        while self.history_ui.historyTableWidget.rowCount() > 0:
            self.history_ui.historyTableWidget.removeRow(0)

```

`history.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>428</width>
    <height>174</height>
   </rect>
  </property>
  <property name="font">
   <font>
    <family>Courier New</family>
   </font>
  </property>
  <property name="windowTitle">
   <string>History</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTableWidget" name="historyTableWidget">
     <property name="font">
      <font>
       <family>Courier New</family>
      </font>
     </property>
     <property name="rowCount">
      <number>1</number>
     </property>
     <property name="columnCount">
      <number>2</number>
     </property>
     <row/>
     <column/>
     <column/>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`kfd-explorer.sh`:

```sh
#!/bin/bash

# Use python3 if python is not available
if command -v python &> /dev/null; then
    PYTHON_CMD=python
elif command -v python3 &> /dev/null; then
    PYTHON_CMD=python3
else
    echo "Need to install python >= 3.8.0 to run kfd-explorer."
    exit 1
fi

# Check if installed python version is 3.8.0+
if [ "$(${PYTHON_CMD} -c 'import sys; print(sys.version_info >= (3, 8))')" != "True" ]; then
    echo "Python 3.8.0+ is required."
    exit 1
fi

# Check if the virtual environment already exists
if [ ! -d "venv" ]; then
    # Create python virtual environment
    ${PYTHON_CMD} -m venv ./venv

    # Activate venv
    source venv/bin/activate

    # Install requirements
    pip install -r requirements.txt

    # Install capstone based on architecture
    ARCH=$(uname -m)
    if [ "$ARCH" = "arm64" ]; then
        pip install --pre --no-binary capstone capstone
    else
        pip install capstone
    fi
else
    # Activate venv
    source venv/bin/activate
fi

# Run
${PYTHON_CMD} main.py
```

`kfundfiles/ContentView.swift`:

```swift
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

import SwiftUI
import os

struct ContentView: View {
    init() {
    }
    
    @State private var kfd: UInt64 = 0
    @State private var isGadgetLoaded: Bool = false

    private var puaf_pages_options = [16, 32, 64, 128, 256, 512, 1024, 2048]
    @State private var puaf_pages_index = 7
    @State private var puaf_pages = 0

    private var puaf_method_options = ["physpuppet", "smith", "landa"]
    @State private var puaf_method = 2

    private var kread_method_options = ["kqueue_workloop_ctl", "sem_open"]
    @State private var kread_method = 1

    private var kwrite_method_options = ["dup", "sem_open"]
    @State private var kwrite_method = 1

    var body: some View {
        NavigationView {
            Form {
                Section {
                    Picker(selection: $puaf_pages_index, label: Text("puaf pages:")) {
                        ForEach(0 ..< puaf_pages_options.count, id: \.self) {
                            Text(String(self.puaf_pages_options[$0]))
                        }
                    }.disabled(kfd != 0)
                }
                Section {
                    Picker(selection: $puaf_method, label: Text("puaf method:")) {
                        ForEach(0 ..< puaf_method_options.count, id: \.self) {
                            Text(self.puaf_method_options[$0])
                        }
                    }.disabled(kfd != 0)
                }
                Section {
                    Picker(selection: $kread_method, label: Text("kread method:")) {
                        ForEach(0 ..< kread_method_options.count, id: \.self) {
                            Text(self.kread_method_options[$0])
                        }
                    }.disabled(kfd != 0)
                }
                Section {
                    Picker(selection: $kwrite_method, label: Text("kwrite method:")) {
                        ForEach(0 ..< kwrite_method_options.count, id: \.self) {
                            Text(self.kwrite_method_options[$0])
                        }
                    }.disabled(kfd != 0)
                }
                Section {
                    HStack {
                        Button("kopen") {
                            puaf_pages = puaf_pages_options[puaf_pages_index]
                            
                            kfd = do_kopen(UInt64(puaf_pages), UInt64(puaf_method), UInt64(kread_method), UInt64(kwrite_method))
                            do_fun()
                        }.disabled(kfd != 0).frame(minWidth: 0, maxWidth: .infinity)
                        Button("kclose") {
                            do_kclose()
                            puaf_pages = 0
                            kfd = 0
                            isGadgetLoaded = false
                        }.disabled(kfd == 0).frame(minWidth: 0, maxWidth: .infinity)
                    }.buttonStyle(.bordered)
                }.listRowBackground(Color.clear)
                if kfd != 0 {
                    Section {
                        VStack {
                            Text("Success!").foregroundColor(.green)
                            Text("Look at output in Xcode")
                        }.frame(minWidth: 0, maxWidth: .infinity)
                    }.listRowBackground(Color.clear)
                }
                if isGadgetLoaded {
                    Section {
                        VStack {
                            Text("frida-gadget loaded!").foregroundColor(.red)
                        }.frame(minWidth: 0, maxWidth: .infinity)
                    }.listRowBackground(Color.clear)
                }
            }
            .navigationBarTitle(Text("kfd"), displayMode: .inline)
            .onChange(of: kfd) { kfd in
                if kfd != 0 {
                    let resourceUrl = Bundle.main.resourceURL
                    let fridaGadgetURL = resourceUrl!.appendingPathComponent("frida-gadget-16.1.11.dylib")
                    if access(fridaGadgetURL.path.cString(using: .utf8), F_OK) == 0 {
                        var thread = Thread(block: {
                            fridaGadgetThread()
                        })
                        thread.start()
                    }
                }
            }
        }
    }
    
    func fridaGadgetThread() -> Void {
        let resourceUrl = Bundle.main.resourceURL
        let fridaGadgetURL = resourceUrl!.appendingPathComponent("frida-gadget-16.1.11.dylib")
        let handle: UnsafeMutableRawPointer? = dlopen(fridaGadgetURL.path, RTLD_LAZY)
        if handle != nil {
            os_log("[hackcatml] frida-gadget loaded")
            isGadgetLoaded = true
        } else {
            os_log("[hackcatml] fail to load frida-gadget")
        }
    }
}

//struct ContentView_Previews: PreviewProvider {
//    static var previews: some View {
//        ContentView()
//    }
//}

```

`kfundfiles/frida-gadget-16.1.11.config`:

```config
{
  "code_signing":"required",
  "interaction": {
    "type": "listen",
    "address": "127.0.0.1",
    "port": 27042,
    "on_port_conflict": "fail",
    "on_load": "resume"
  }
}
```

`main.py`:

```py
import collections
import inspect
import platform
import re

from PySide6 import QtGui
from PySide6.QtCore import QThread, Slot, Qt, QEvent, QPoint
from PySide6.QtGui import QPixmap, QTextCursor, QShortcut, QKeySequence, QIcon, QPalette
from PySide6.QtWidgets import QLabel, QMainWindow, QMessageBox, QApplication

import code
import globvar
import ui
from disasm import DisassembleWorker
from history import HistoryViewClass


def set_mem_range(prot):
    try:
        result = globvar.fridaInstrument.mem_enumerate_ranges(prot)
        # print("[hackcatml] mem_enumerate_ranges result: ", result)
    except Exception as e:
        print(e)
        return
    # enumerateRanges --> [(base, base + size - 1, prot, size), ... ]
    globvar.enumerateRanges.clear()
    for i in range(len(result)):
        globvar.enumerateRanges.append(
            (result[i]['base'], hex(int(result[i]['base'], 16) + result[i]['size'] - 1), result[i]['protection'],
             result[i]['size']))
    # print("[hackcatml] globvar.enumerateRanges: ", globvar.enumerateRanges)


def hex_calculator(s):
    """ https://leetcode.com/problems/basic-calculator-ii/solutions/658480/Python-Basic-Calculator-I-II-III-easy
    -solution-detailed-explanation/comments/881191/"""

    def twos_complement(input_value: int, num_bits: int) -> int:
        mask = 2 ** num_bits - 1
        return ((input_value ^ mask) + 1) & mask

    def replace(match):
        num = int(match.group(0), 16)
        return "- " + hex(twos_complement(num, 64))

    # multiply, divide op are not supported
    if re.search(r"[*/]", s):
        return False

    # find negative hex value which starts with ffffffff and replace it with "- 2's complement"
    pattern = re.compile(r'[fF]{8}\w*')
    s = pattern.sub(replace, s)
    s = s.replace('0x', '')

    num, op, arr, stack = '', "+", collections.deque(s + "+"), []
    while sym := arr.popleft() if arr else None:
        if str.isdigit(sym):
            num += sym
        elif re.search(r"[a-zA-F]", sym):
            num += sym
        elif sym in ('+', '-'):
            if num == '':
                num = '0'
            stack += int(op + num, 16),
            op, num = sym, ''

    return hex(sum(stack))


def process_read_kmem_result(result: str) -> str:
    remove_target = '0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF\n'
    result = result.replace(result[result.find('\n') + 1:result.find(remove_target)], '')
    result = result.replace(remove_target, '')
    # remove any residual whitespace
    result = result.strip()
    return result


class WindowClass(QMainWindow, ui.Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.statusBar()
        self.statusLight = QLabel()
        self.set_status_light()

        self.hexEditShortcut = QShortcut(QKeySequence(Qt.Key.Key_F2), self)

        self.hexViewer.wheelupsig.connect(self.wheelupsig_func)
        self.hexViewer.movesig.connect(self.movesig_func)
        self.hexViewer.refreshsig.connect(self.refreshsig_func)
        self.hexViewer.statusBar = self.statusBar()
        self.defaultcolor = QLabel().palette().color(QPalette.ColorRole.WindowText)

        self.attachtargetname = None    # name to attach. need to provide on the AppList widget
        self.attachedname = None    # main module name after frida attached successfully
        self.refreshCurrentAddressShortcut = QShortcut(QKeySequence(Qt.Key.Key_F3), self)
        self.refreshCurrentAddressShortcut.activated.connect(self.refresh_curr_addr)

        self.attachBtn.clicked.connect(lambda: self.attach_frida("attachBtnClicked"))
        self.detachBtn.clicked.connect(self.detach_frida)
        self.offsetInput.returnPressed.connect(lambda: self.offset_ok_btn_pressed_func("returnPressed"))
        self.offsetOkbtn.pressed.connect(lambda: self.offset_ok_btn_pressed_func("pressed"))
        self.offsetOkbtn.clicked.connect(self.offset_ok_btn_func)

        self.addrInput.returnPressed.connect(lambda: self.addr_btn_pressed_func("returnPressed"))
        self.addrBtn.pressed.connect(lambda: self.addr_btn_pressed_func("pressed"))
        self.addrBtn.clicked.connect(self.addr_btn_func)
        self.tabWidget2.tabBarClicked.connect(self.status_tab_bar_click_func)

        self.hexEditBtn.clicked.connect(self.hex_edit)
        self.hexEditDoneBtn.clicked.connect(self.hex_edit)
        self.hexEditShortcut.activated.connect(self.hex_edit)

        self.refreshBtn.clicked.connect(self.refresh_curr_addr)
        self.moveBackwardBtn.clicked.connect(self.move_backward)
        self.moveForwardBtn.clicked.connect(self.move_forward)

        self.offsetFilter.textChanged.connect(lambda: self.search_offset("offsetFilter"))

        self.disasm_thread = QThread()
        self.disasm_worker = DisassembleWorker()
        self.disasm_worker.hexviewer = self.hexViewer
        self.disasm_worker.hexviewer.wheelsig.connect(self.disasm_worker.hexviewer_wheelsig_func)
        self.disasm_worker.hexviewer.scrollsig.connect(self.disasm_worker.hexviewer_scrollsig_func)
        self.disasm_worker.moveToThread(self.disasm_thread)
        self.disasm_thread.start()
        self.disassemBtnClickedCount = 0
        self.disassemBtn.clicked.connect(self.show_disassemble_result)

        self.history_view = HistoryViewClass()
        self.history_view.historyaddrsig.connect(self.history_addr_sig_func)
        self.historyBtn.clicked.connect(self.show_history)
        self.historyBtnClickedCount = 0

        self.kslide = None
        self.kbase = None
        self.kernversion = None

        self.utilViewer.get_kfd_btn = self.getKfdBtn
        self.utilViewer.get_kfd_btn.clicked.connect(self.utilViewer.get_kfd)

        self.utilViewer.get_pid_list_btn = self.getPidListBtn
        self.utilViewer.get_pid_list_btn.clicked.connect(self.utilViewer.get_pid_list)

        self.utilViewer.get_all_proc_btn = self.getAllProcBtn
        self.utilViewer.get_all_proc_btn.clicked.connect(self.utilViewer.get_all_proc)

        self.utilViewer.get_vnode_at_path_btn = self.getVnodeAtPathBtn
        self.utilViewer.get_vnode_at_path_input = self.getVnodeAtPathInput
        self.utilViewer.get_vnode_at_path_input.returnPressed.connect(self.utilViewer.get_vnode_at_path)
        self.utilViewer.get_vnode_at_path_btn.clicked.connect(self.utilViewer.get_vnode_at_path)

        self.utilViewer.util_viewer_filter = self.utilViewerFilter
        self.utilViewer.util_viewer_filter.textChanged.connect(self.utilViewer.util_viewer_filter_func)

        # install event filter to use tab and move to some input fields
        self.interested_widgets = []
        QApplication.instance().installEventFilter(self)

    @Slot(str)
    def wheelupsig_func(self, wheelupsig: str):
        # print(wheelupsig)
        if self.status_kernel_base.toPlainText() == hex_calculator(f"{wheelupsig}"):
            return
        addr = hex_calculator(f"{wheelupsig} - 10")
        # print(addr)
        self.addrInput.setText(addr)
        self.addr_btn_func()

    @Slot(int)
    def movesig_func(self, movesig: int):
        self.move_backward() if movesig == 0 else self.move_forward()

    @Slot(int)
    def refreshsig_func(self, refreshsig: int):
        if refreshsig:
            self.refresh_curr_addr()

    @Slot(int)
    def fridaattachsig_func(self, attach_sig: int):
        if attach_sig:
            globvar.isFridaAttached = True
        else:
            globvar.isFridaAttached = False
            self.detach_frida()
        self.set_status_light()

    @Slot(str)
    def history_addr_sig_func(self, addr: str):
        self.addrInput.setText(addr)
        self.addr_btn_func()

    def adjust_label_pos(self):
        tc = self.hexViewer.textCursor()
        text_length = len(tc.block().text())
        current_height = self.height()
        self.resize(text_length * 13, current_height)
        if text_length >= 77:
            self.label_3.setIndent(28 + (text_length - 77) * 8)
        else:
            self.label_3.setIndent(28 - (77 - text_length) * 7)

    def attach_frida(self, caller: str):
        if globvar.isFridaAttached is True:
            try:
                # check if script is still alive. if not exception will occur
                globvar.fridaInstrument.dummy_script()
                QMessageBox.information(self, "info", "Already attached")
            except Exception as e:
                self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 3000)
                globvar.fridaInstrument.sessions.clear()
            return

        try:
            self.attachtargetname = "Gadget"
            globvar.fridaInstrument = code.Instrument("scripts/default.js",
                                                      self.attachtargetname)
            # connect frida attach signal function
            globvar.fridaInstrument.attachsig.connect(self.fridaattachsig_func)
            msg = globvar.fridaInstrument.instrument(caller)
        except Exception as e:
            self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 3000)
            return

        if msg is not None:
            QMessageBox.information(self, "info", msg)
            self.offsetInput.clear()
            return

        set_mem_range('r--')

        try:
            self.platform = globvar.fridaInstrument.platform()
            self.utilViewer.platform = self.platform
            globvar.arch = globvar.fridaInstrument.arch()
            name = globvar.fridaInstrument.list_modules()[0]['name']
            self.attachedname = name
            self.set_status()
        except Exception as e:
            print(e)
            return

    def detach_frida(self):
        if globvar.fridaInstrument is None:
            pass
        else:
            try:
                for session in globvar.fridaInstrument.sessions:
                    session.detach()
                globvar.fridaInstrument.sessions.clear()
                globvar.enumerateRanges.clear()
                globvar.hexEdited.clear()
                globvar.offsets.clear()
                globvar.arch = None
                globvar.isFridaAttached = False
                globvar.fridaInstrument = None
                globvar.visitedAddress.clear()
                if self.history_view is not None:
                    self.history_view.history_window.close()
                    self.history_view.clear_table()
                self.statusBar().showMessage("")
            except Exception as e:
                self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 5000)

    def offset_ok_btn_pressed_func(self, caller):
        if caller == "returnPressed":
            self.offset_ok_btn_func()

    def offset_ok_btn_func(self):
        if globvar.isFridaAttached is False:
            QMessageBox.information(self, "info", "Attach first")
            self.offsetInput.clear()
            return

        offset = self.offsetInput.text()
        try:
            offset = hex_calculator(offset)
        except Exception as e:
            self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 3000)
            return

        if offset is False:
            self.statusBar().showMessage("can't operate *, /", 3000)
            return

        self.offsetInput.setText(offset)

        try:
            result = globvar.fridaInstrument.read_kmem_offset(offset)
        except Exception as e:
            self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 3000)
            if str(e) == globvar.errorType1:
                globvar.fridaInstrument.sessions.clear()
            return

        self.show_mem_result_on_viewer(None, result)

    def addr_btn_pressed_func(self, caller):
        if caller == "returnPressed":
            self.addr_btn_func()

    def addr_btn_func(self):
        if globvar.isFridaAttached is False:
            QMessageBox.information(self, "info", "Attach first")
            self.addrInput.clear()
            return

        addr = self.addrInput.text()
        if addr.strip() == '':
            return
        hex_regex = re.compile(r'(\b0x[a-fA-F0-9]+\b|\b[a-fA-F0-9]{6,}\b)')
        match = hex_regex.match(addr)
        # in case it's not a hex expression on addrInput field. for example "fopen", "sysctl", ...
        if match is None:
            self.statusBar().showMessage(f"Cannot find address for {addr}", 3000)
            return

        try:
            addr = hex_calculator(addr)
        except Exception as e:
            self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 3000)
            return

        if addr is False:
            self.statusBar().showMessage("Can't operate *, /")
            return

        self.addrInput.setText(addr)
        # print(f"addr_btn_func: {int(addr, 16)}")
        # return

        try:
            if re.search(r"0x0*[fF]{6,}", addr):
                result = globvar.fridaInstrument.read_kmem_addr(addr, None)
            else:
                result = globvar.fridaInstrument.read_mem_addr(addr, 0x640)
        except Exception as e:
            self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 3000)
            if str(e) == globvar.errorType1:
                globvar.fridaInstrument.sessions.clear()
            return

        self.show_mem_result_on_viewer(addr, result)

    def show_mem_result_on_viewer(self, addr, result):
        # empty changed hex list before refresh hexviewer
        globvar.hexEdited.clear()
        # show hex dump result
        hex_dump_result = result[result.find('\n') + 1:]
        self.hexViewer.setPlainText(hex_dump_result)
        # adjust label pos
        self.adjust_label_pos()

        if inspect.currentframe().f_back.f_code.co_name != "offset_ok_btn_func":
            self.set_status()
            # reset address input area
            self.addrInput.clear()
        else:
            self.set_status()
            # reset offset input area
            self.offsetInput.clear()

        # move cursor
        if self.hexViewer.textCursor().positionInBlock() == 0:
            self.hexViewer.moveCursor(QTextCursor.MoveOperation.NextWord)
        # set initial currentFrameStartAddress
        globvar.currentFrameBlockNumber = 0
        globvar.currentFrameStartAddress = "".join(
            ("0x", self.hexViewer.textCursor().block().text()[:self.hexViewer.textCursor().block().text().find(' ')]))
        # print("[hackcatml] currentFrameBlockNumber: ", globvar.currentFrameBlockNumber)
        # print("[hackcatml] currentFrameStartAddress: ", globvar.currentFrameStartAddress)
        self.visited_addr()

        self.disasm_worker.disassemble(globvar.arch, globvar.currentFrameStartAddress, hex_dump_result)

    # remember visited address
    def visited_addr(self):
        if len(inspect.stack()) > 3 and inspect.stack()[3].function == 'wheelupsig_func':
            return

        kaddr = self.status_current_kaddr.toPlainText()
        addr = self.status_current_addr.toPlainText()
        curr_addr = ""
        if kaddr != "" and addr == "":
            curr_addr = kaddr
        elif kaddr == "" and addr != "":
            curr_addr = addr
        match = re.search(r'\(0x[a-fA-F0-9]+\)', curr_addr)
        visited_addr = curr_addr[:match.start()] if match is not None else curr_addr
        if visited_addr != '':
            if len(globvar.visitedAddress) == 0:
                globvar.visitedAddress.append(['last', visited_addr])
            else:
                last_visit_index = None
                for item in globvar.visitedAddress:
                    if item[0] == 'last':
                        last_visit_index = globvar.visitedAddress.index(item)
                if not any(sublist[1] == visited_addr for sublist in globvar.visitedAddress):
                    globvar.visitedAddress.append(['last', visited_addr])
                    if last_visit_index is not None:
                        globvar.visitedAddress[last_visit_index][0] = 'notlast'
                else:
                    revisit_index = None
                    # Find the index of the sublist to modify
                    for idx, sublist in enumerate(globvar.visitedAddress):
                        if sublist[1] == visited_addr and sublist[0] == 'notlast':
                            revisit_index = idx
                            break
                    # Modify the sublist if we found a matching index
                    if revisit_index is not None and (inspect.stack()[3].function != 'move_forward' and inspect.stack()[3].function != 'move_backward'):
                        revisit_addr_mark = globvar.visitedAddress[revisit_index][0]
                        revisit_addr = globvar.visitedAddress[revisit_index][1]
                        globvar.visitedAddress.remove([revisit_addr_mark, revisit_addr])
                        globvar.visitedAddress.append(['last', revisit_addr])
                        for idx, sublist in enumerate(globvar.visitedAddress):
                            if sublist[1] != revisit_addr and sublist[0] == 'last':
                                globvar.visitedAddress[idx][0] = 'notlast'
                                break
                    elif revisit_index is not None and (inspect.stack()[3].function == 'move_forward' or inspect.stack()[3].function == 'move_backward'):
                        globvar.visitedAddress[revisit_index][0] = 'last'
                        if revisit_index != last_visit_index:
                            globvar.visitedAddress[last_visit_index][0] = 'notlast'
            # add visted_addr to the history table
            self.history_view.add_row(visited_addr)

    def show_disassemble_result(self):
        self.disassemBtnClickedCount += 1
        self.disasm_worker.disasm_window.show()
        if self.disassemBtnClickedCount == 1:
            curr_pos = self.disasm_worker.disasm_window.pos()
            new_pos = curr_pos + QPoint(-270, 150)
            self.disasm_worker.disasm_window.move(new_pos)

    def show_history(self):
        self.historyBtnClickedCount += 1
        self.history_view.history_window.show()
        if self.historyBtnClickedCount == 1:
            curr_pos = self.history_view.history_window.pos()
            new_pos = (curr_pos + QPoint(480, -350)) if platform.system() == "Darwin" else (curr_pos + QPoint(490, -360))
            self.history_view.history_window.move(new_pos)

    def status_tab_bar_click_func(self, index):
        # status tab
        if index == 0:
            try:
                if globvar.fridaInstrument is not None:
                    globvar.fridaInstrument.dummy_script()
            except Exception as e:
                if str(e) == globvar.errorType1:
                    globvar.fridaInstrument.sessions.clear()
                self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 3000)
                return
        # offsets tab
        elif index == 1:
            text = ""
            result = []
            self.offsetFilter.setText('')
            if globvar.fridaInstrument is not None:
                try:
                    result = globvar.fridaInstrument.get_offsets()
                    globvar.offsets = result
                except Exception as e:
                    if str(e) == globvar.errorType1:
                        globvar.fridaInstrument.sessions.clear()
                    self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 3000)
                    return
            if len(result) > 0:
                for key in result:
                    text += f"{key}\t{hex(int(result[key]))}\n"
            self.offsetsViewer.setTextColor(self.defaultcolor)
            self.offsetsViewer.setPlainText(text)

    def hex_edit(self):
        if self.tabWidget.tabText(self.tabWidget.currentIndex()) == "Util":
            return
        # print(self.sender().__class__.__name__)
        if self.sender().__class__.__name__ == "QShortcut" or \
                (self.sender().__class__.__name__ != "QShortcut" and self.sender().text() == "Done"):
            if globvar.isHexEditMode is True:
                self.hexViewer.setReadOnly(True)
                if len(globvar.hexEdited) == 0:
                    globvar.isHexEditMode = False
                    return
                elif len(globvar.hexEdited) >= 1:
                    try:
                        globvar.fridaInstrument.write_kmem_addr(globvar.hexEdited)
                    except Exception as e:
                        if str(e) == globvar.errorType1:
                            globvar.fridaInstrument.sessions.clear()
                            globvar.hexEdited.clear()
                        self.statusBar().showMessage(f"{inspect.currentframe().f_code.co_name}: {e}", 3000)
                        return
                print("[hackcatml] hex edited: ", globvar.hexEdited)

                # refresh hex viewer after patching
                tc = self.hexViewer.textCursor()
                finalposlist = []
                for arr in globvar.hexEdited:
                    origpos = arr[4]
                    tc.setPosition(origpos, QTextCursor.MoveMode.MoveAnchor)
                    tc.movePosition(QTextCursor.MoveOperation.StartOfBlock, QTextCursor.MoveMode.MoveAnchor)
                    if tc.position() not in finalposlist:
                        finalposlist.append(tc.position())

                for finalpos in finalposlist:
                    tc.setPosition(finalpos, QTextCursor.MoveMode.MoveAnchor)
                    # read mem addr after patching
                    result = globvar.fridaInstrument.read_kmem_addr(
                        "".join(("0x", tc.block().text()[:tc.block().text().find(' ')])), 16)
                    # process read mem result
                    result = process_read_kmem_result(result)
                    # replace text
                    tc.movePosition(QTextCursor.MoveOperation.EndOfBlock, QTextCursor.MoveMode.KeepAnchor)
                    tc.insertText(result)

                self.hexViewer.moveCursor(QTextCursor.MoveOperation.StartOfBlock, QTextCursor.MoveMode.MoveAnchor)
                self.hexViewer.moveCursor(QTextCursor.MoveOperation.NextWord, QTextCursor.MoveMode.MoveAnchor)
                globvar.isHexEditMode = False
                # empty changed hex list
                globvar.hexEdited.clear()
                # reset current frame block number
                # globvar.currentFrameBlockNumber = 0
                return

        if self.sender().__class__.__name__ == "QShortcut" or (
                self.sender().__class__.__name__ != "QShortcut" and self.sender().text() == "kwrite"):
            if globvar.isHexEditMode is False:
                self.hexViewer.setReadOnly(False)
                self.hexViewer.setTextInteractionFlags(
                    ~Qt.TextInteractionFlag.TextSelectableByKeyboard & ~Qt.TextInteractionFlag.TextSelectableByMouse)
                globvar.isHexEditMode = True

    def refresh_curr_addr(self):
        kaddr = self.status_current_kaddr.toPlainText()
        addr = self.status_current_addr.toPlainText()
        curr_addr = kaddr if kaddr != '' else addr
        if curr_addr == '':
            return
        else:
            match = re.search(r'\(0x[a-fA-F0-9]+\)', curr_addr)
            curr_addr = curr_addr[:match.start()] if match is not None else curr_addr
            self.addrInput.setText(curr_addr)
            self.addr_btn_func()

    def move_backward(self):
        tc = self.hexViewer.textCursor()
        indices = [i for i, x in enumerate(tc.block().text()) if x == " "]
        if len(indices) == 0:
            return
        elif re.search(r"\d+\. 0x[a-f0-9]+, module:", tc.block().text()):
            return

        if len(globvar.visitedAddress) > 0:
            for idx, sublist in enumerate(globvar.visitedAddress):
                if sublist[0] == 'last' and idx > 0:
                    addr_to_visit = globvar.visitedAddress[idx - 1][1]
                    self.addrInput.setText(addr_to_visit)
                    self.addr_btn_func()
                    break

    def move_forward(self):
        tc = self.hexViewer.textCursor()
        indices = [i for i, x in enumerate(tc.block().text()) if x == " "]
        if len(indices) == 0:
            return
        elif re.search(r"\d+\. 0x[a-f0-9]+, module:", tc.block().text()):
            return

        if len(globvar.visitedAddress) > 0:
            for idx, sublist in enumerate(globvar.visitedAddress):
                if sublist[0] == 'last' and idx < len(globvar.visitedAddress) - 1:
                    addr_to_visit = globvar.visitedAddress[idx + 1][1]
                    self.addrInput.setText(addr_to_visit)
                    self.addr_btn_func()
                    break

    def search_offset(self, caller):
        # print(self.offsetFilter.text())
        text_to_find = ''
        viewer = None
        if caller == "offsetFilter":
            text_to_find = self.offsetFilter.text().lower()
            viewer = self.offsetsViewer

        matched = ''
        if len(globvar.offsets) > 0:
            for offset in globvar.offsets:
                if offset.lower().find(text_to_find) != -1:
                    matched += f"{offset}\t{hex(int(globvar.offsets[offset]))}\n"
        viewer.setText(matched)

    def set_status(self):
        # print(inspect.currentframe().f_back.f_code.co_name)
        # print(inspect.stack()[0][3] + ':', name)
        if self.kernversion is None:
            self.kernversion = globvar.fridaInstrument.get_kern_version()
        if self.kslide is None:
            self.kslide = globvar.fridaInstrument.get_kernel_slide()
        if self.kbase is None:
            self.kbase = globvar.fridaInstrument.get_kernel_base()

        self.status_kernel_version.setPlainText(self.kernversion)
        self.status_kernel_base.setPlainText(hex(int(self.kbase)))
        self.status_kernel_slide.setPlainText(hex(int(self.kslide)))

        input = self.offsetInput.text()
        if inspect.stack()[2].function == "addr_btn_func":
            input = self.addrInput.text()

        if input.startswith('0x') is False:
            input = "".join(("0x0", input))

        try:
            if inspect.stack()[2].function == "offset_ok_btn_func":
                addr = hex(int(self.kbase) + int(input, 16))
                current_addr = addr + f"({input})"
                self.status_current_kaddr.setPlainText(current_addr)
                self.status_current_addr.setPlainText("")
            elif inspect.stack()[2].function == "addr_btn_func" and re.search(r"0x0*[fF]{6,}", input):
                addr = input
                if int(addr, 16) >= int(self.kbase):
                    current_addr = addr + f"({hex(int(input, 16) - int(self.kbase))})"
                else:
                    current_addr = addr
                self.status_current_kaddr.setPlainText(current_addr)
                self.status_current_addr.setPlainText("")
            elif inspect.stack()[2].function == "addr_btn_func" and not re.search(r"0x0*[fF]{6,}", input):
                current_addr = input
                self.status_current_kaddr.setPlainText("")
                self.status_current_addr.setPlainText(current_addr)
            # caller function 찾기. https://stackoverflow.com/questions/900392/getting-the-caller-function-name-inside-another-function-in-python
            elif inspect.currentframe().f_back.f_code.co_name == "attach_frida":
                self.offsetInput.clear()
                self.addrInput.clear()
        except Exception as e:
            print(e)
            pass

    def set_status_light(self):
        onicon = QPixmap("icon/greenlight.png").scaledToHeight(13)
        officon = QPixmap("icon/redlight.png").scaledToHeight(13)

        self.statusLight.setPixmap(officon)
        if globvar.isFridaAttached is True:
            self.statusLight.setPixmap(onicon)

        self.statusBar().removeWidget(self.statusLight)
        self.statusBar().addPermanentWidget(self.statusLight)
        self.statusLight.show()

    def eventFilter(self, obj, event):
        self.interested_widgets = [self.offsetInput, self.addrInput]
        if event.type() == QEvent.Type.KeyPress and event.key() == Qt.Key.Key_Tab:
            try:
                if self.tabWidget.tabText(self.tabWidget.currentIndex()) == "Util":
                    self.interested_widgets = [self.getVnodeAtPathInput, self.utilViewerFilter]
                # Get the index of the currently focused widget in our list
                index = self.interested_widgets.index(self.focusWidget())

                # Try to focus the next widget in the list
                self.interested_widgets[(index + 1) % len(self.interested_widgets)].setFocus()
            except ValueError:
                # The currently focused widget is not in our list, so we focus the first one
                self.interested_widgets[0].setFocus()

            # We've handled the event ourselves, so we don't pass it on
            return True

        # For other events, we let them be handled normally
        return super().eventFilter(obj, event)

    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        if self.disasm_worker is not None:
            self.disasm_worker.disasm_window.close()
            self.disasm_worker.thread().quit()


if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)
    app.setWindowIcon(QIcon('icon/kfd-explorer.png'))
    myWindow = WindowClass()
    myWindow.show()
    sys.exit(app.exec())

```

`requirements.txt`:

```txt
attrs==22.2.0
certifi==2023.5.7
charset-normalizer==2.1.1
colorama==0.4.6
frida==16.1.7
frida-tools==12.3.0
frozenlist==1.3.3
idna==3.4
multidict==6.0.4
Pygments==2.17.2
PySide6==6.6.1
PySide6-Addons==6.6.1
PySide6-Essentials==6.6.1
requests==2.31.0
shiboken6==6.6.1
timer==0.2.2
typing_extensions==4.9.0
urllib3==2.0.3
wcwidth==0.2.13
yarl==1.8.2

```

`scripts/default.js`:

```js
var module_name = "kfd"
var kreadbuf = new NativeFunction(Module.findExportByName(module_name, "kreadbuf"), 'void', ['uint64', 'pointer', 'int']);
var get_kslide = new NativeFunction(Module.findExportByName(module_name, "get_kslide"), 'uint64', []);
var get_vm_kernel_link_addr = new NativeFunction(Module.findExportByName(module_name, "get_vm_kernel_link_addr"), 'uint64', []);
var get_kernversion = new NativeFunction(Module.findExportByName(module_name, "get_kernversion"), 'pointer', []);
var getProc = new NativeFunction(Module.findExportByName(module_name, "getProc"), 'uint64', ['int']);
var getVnodeAtPath = new NativeFunction(Module.findExportByName(module_name, "getVnodeAtPath"), 'uint64', ['pointer']);
var unsign_kptr = new NativeFunction(Module.findExportByName(module_name, "unsign_kptr"), 'uint64', ['uint64']);
var kread8 = new NativeFunction(Module.findExportByName(module_name, "kread8"), 'uint8', ['uint64']);
var kread16 = new NativeFunction(Module.findExportByName(module_name, "kread16"), 'uint32', ['uint64']);
var kread32 = new NativeFunction(Module.findExportByName(module_name, "kread32"), 'uint32', ['uint64']);
var kread64 = new NativeFunction(Module.findExportByName(module_name, "kread64"), 'uint64', ['uint64']);
var kwrite8 = new NativeFunction(Module.findExportByName(module_name, "kwrite8"), 'void', ['uint64', 'uint64']);
var kwrite16 = new NativeFunction(Module.findExportByName(module_name, "kwrite16"), 'void', ['uint64', 'uint64']);
var kwrite32 = new NativeFunction(Module.findExportByName(module_name, "kwrite32"), 'void', ['uint64', 'uint64']);
var kwrite64 = new NativeFunction(Module.findExportByName(module_name, "kwrite64"), 'void', ['uint64', 'uint64']);

// offsets
var offsets = {
    "off_p_list_le_prev": getOffset('off_p_list_le_prev'),
    "off_p_proc_ro": getOffset('off_p_proc_ro'),
    "off_p_ppid": getOffset('off_p_ppid'),
    "off_p_original_ppid": getOffset('off_p_original_ppid'),
    "off_p_pgrpid": getOffset('off_p_pgrpid'),
    "off_p_uid": getOffset('off_p_uid'),
    "off_p_gid": getOffset('off_p_gid'),
    "off_p_ruid": getOffset('off_p_ruid'),
    "off_p_rgid": getOffset('off_p_rgid'),
    "off_p_svuid": getOffset('off_p_svuid'),
    "off_p_svgid": getOffset('off_p_svgid'),
    "off_p_sessionid": getOffset('off_p_sessionid'),
    "off_p_puniqueid": getOffset('off_p_puniqueid'),
    "off_p_pid": getOffset('off_p_pid'),
    "off_p_pfd": getOffset('off_p_pfd'),
    "off_p_textvp": getOffset('off_p_textvp'),
    "off_p_name": getOffset('off_p_name'),
    "off_p_ro_p_csflags": getOffset('off_p_ro_p_csflags'),
    "off_p_ro_p_ucred": getOffset('off_p_ro_p_ucred'),
    "off_p_ro_pr_proc": getOffset('off_p_ro_pr_proc'),
    "off_p_ro_pr_task": getOffset('off_p_ro_pr_task'),
    "off_p_ro_t_flags_ro": getOffset('off_p_ro_t_flags_ro'),
    "off_u_cr_label": getOffset('off_u_cr_label'),
    "off_u_cr_posix": getOffset('off_u_cr_posix'),
    "off_cr_uid": getOffset('off_cr_uid'),
    "off_cr_ruid": getOffset('off_cr_ruid'),
    "off_cr_svuid": getOffset('off_cr_svuid'),
    "off_cr_ngroups": getOffset('off_cr_ngroups'),
    "off_cr_groups": getOffset('off_cr_groups'),
    "off_cr_rgid": getOffset('off_cr_rgid'),
    "off_cr_svgid": getOffset('off_cr_svgid'),
    "off_cr_gmuid": getOffset('off_cr_gmuid'),
    "off_cr_flags": getOffset('off_cr_flags'),
    "off_task_t_flags": getOffset('off_task_t_flags'),
    "off_task_itk_space": getOffset('off_task_itk_space'),
    "off_fd_ofiles": getOffset('off_fd_ofiles'),
    "off_fd_cdir": getOffset('off_fd_cdir'),
    "off_fp_glob": getOffset('off_fp_glob'),
    "off_fg_data": getOffset('off_fg_data'),
    "off_fg_flag": getOffset('off_fg_flag'),
    "off_vnode_v_ncchildren_tqh_first": getOffset('off_vnode_v_ncchildren_tqh_first'),
    "off_vnode_v_ncchildren_tqh_last": getOffset('off_vnode_v_ncchildren_tqh_last'),
    "off_vnode_v_nclinks_lh_first": getOffset('off_vnode_v_nclinks_lh_first'),
    "off_vnode_v_iocount": getOffset('off_vnode_v_iocount'),
    "off_vnode_v_usecount": getOffset('off_vnode_v_usecount'),
    "off_vnode_v_flag": getOffset('off_vnode_v_flag'),
    "off_vnode_v_name": getOffset('off_vnode_v_name'),
    "off_vnode_v_mount": getOffset('off_vnode_v_mount'),
    "off_vnode_v_data": getOffset('off_vnode_v_data'),
    "off_vnode_v_kusecount": getOffset('off_vnode_v_kusecount'),
    "off_vnode_v_references": getOffset('off_vnode_v_references'),
    "off_vnode_v_lflag": getOffset('off_vnode_v_lflag'),
    "off_vnode_v_owner": getOffset('off_vnode_v_owner'),
    "off_vnode_v_parent": getOffset('off_vnode_v_parent'),
    "off_vnode_v_label": getOffset('off_vnode_v_label'),
    "off_vnode_v_cred": getOffset('off_vnode_v_cred'),
    "off_vnode_v_writecount": getOffset('off_vnode_v_writecount'),
    "off_vnode_v_type": getOffset('off_vnode_v_type'),
    "off_vnode_v_id": getOffset('off_vnode_v_id'),
    "off_vnode_vu_ubcinfo": getOffset('off_vnode_vu_ubcinfo'),
    "off_mount_mnt_data": getOffset('off_mount_mnt_data'),
    "off_mount_mnt_fsowner": getOffset('off_mount_mnt_fsowner'),
    "off_mount_mnt_fsgroup": getOffset('off_mount_mnt_fsgroup'),
    "off_mount_mnt_devvp": getOffset('off_mount_mnt_devvp'),
    "off_mount_mnt_flag": getOffset('off_mount_mnt_flag'),
    "off_specinfo_si_flags": getOffset('off_specinfo_si_flags'),
    "off_namecache_nc_dvp": getOffset('off_namecache_nc_dvp'),
    "off_namecache_nc_vp": getOffset('off_namecache_nc_vp'),
    "off_namecache_nc_hashval": getOffset('off_namecache_nc_hashval'),
    "off_namecache_nc_name": getOffset('off_namecache_nc_name'),
    "off_namecache_nc_child_tqe_prev": getOffset('off_namecache_nc_child_tqe_prev'),
    "off_ipc_space_is_table": getOffset('off_ipc_space_is_table'),
    "off_ubc_info_cs_blobs": getOffset('off_ubc_info_cs_blobs'),
    "off_ubc_info_cs_add_gen": getOffset('off_ubc_info_cs_add_gen'),
    "off_cs_blob_csb_pmap_cs_entry": getOffset('off_cs_blob_csb_pmap_cs_entry'),
    "off_cs_blob_csb_cdhash": getOffset('off_cs_blob_csb_cdhash'),
    "off_cs_blob_csb_flags": getOffset('off_cs_blob_csb_flags'),
    "off_cs_blob_csb_teamid": getOffset('off_cs_blob_csb_teamid'),
    "off_cs_blob_csb_validation_category": getOffset('off_cs_blob_csb_validation_category'),
    "off_pmap_cs_code_directory_ce_ctx": getOffset('off_pmap_cs_code_directory_ce_ctx'),
    "off_pmap_cs_code_directory_der_entitlements_size": getOffset('off_pmap_cs_code_directory_der_entitlements_size'),
    "off_pmap_cs_code_directory_trust": getOffset('off_pmap_cs_code_directory_trust'),
    "off_ipc_entry_ie_object": getOffset('off_ipc_entry_ie_object'),
    "off_ipc_object_io_bits": getOffset('off_ipc_object_io_bits'),
    "off_ipc_object_io_references": getOffset('off_ipc_object_io_references'),
    "off_ipc_port_ip_kobject": getOffset('off_ipc_port_ip_kobject'),

    "off_cdevsw": getOffset('off_cdevsw'),
    "off_gPhysBase": getOffset('off_gPhysBase'),
    "off_gPhysSize": getOffset('off_gPhysSize'),
    "off_gVirtBase": getOffset('off_gVirtBase'),
    "off_perfmon_dev_open": getOffset('off_perfmon_dev_open'),
    "off_perfmon_devices": getOffset('off_perfmon_devices'),
    "off_ptov_table": getOffset('off_ptov_table'),
    "off_vn_kqfilter": getOffset('off_vn_kqfilter'),
    "off_proc_object_size": getOffset('off_proc_object_size')
}

function getOffset(name) {
    var exportList = Module.enumerateExportsSync(module_name);
    var found = exportList.find(function(m) { return m.type == 'variable' && m.name == name; });
    if (found) {
        if (name == "off_cdevsw" || name == "off_gPhysBase" || name == "off_gPhysSize" || name == "off_gVirtBase" || name == "off_perfmon_dev_open" || name == "off_perfmon_devices" || name == "off_ptov_table" || name == "off_vn_kqfilter" || name == "off_proc_object_size") {
            return ptr(found.address).readU64();
        }
        return ptr(found.address).readU32();
    }
    return null;
}

rpc.exports = {
    // just dummy function for checking script is alive
    dummy: () => {
        // console.log("muffin")
        send("")
    },
    arch: () => {
        send(Process.arch)
    },
    platform: () => {
        send(Process.platform)
    },
    enumerateranges: (prot) => {
        // send(Process.enumerateRangesSync(prot))
        return Process.enumerateRangesSync(prot)
    },
    listmodules: () => {
        send(Process.enumerateModulesSync())
    },
    getKernelSlide: () => {
        return get_kslide();
    },
    getVmKernelLinkAddr: () => {
        return get_vm_kernel_link_addr();
    },
    getKernVersion: () => {
        return get_kernversion().readUtf8String();
    },
    getOffsets: () => {
        send(offsets);
    },
    getKfd: () => {
        var symbolsList = Module.enumerateSymbolsSync(module_name)
        var found = symbolsList.find(function(m) { return m.name === "_kfd" && m.address != "0x0"; })
        if (found) {
            var _kfd = ptr(found.address)
            var _kfd_struct = _kfd.readPointer()
            var kfd = {
                "kfd": _kfd,
                "kfd->info.env.pid": _kfd_struct.add(0x18).readU32(),
                "kfd->info.env.tid": _kfd_struct.add(0x18).add(0x8).readU64(),
                "kfd->info.env.vid": _kfd_struct.add(0x18).add(0x10).readU64(),
                "kfd->info.env.maxfilesperproc": _kfd_struct.add(0x18).add(0x18).readU64(),
                "kfd->info.kaddr.current_map": _kfd_struct.add(0x38).readPointer(),
                "kfd->info.kaddr.current_pmap": _kfd_struct.add(0x38).add(0x8).readPointer(),
                "kfd->info.kaddr.current_proc": _kfd_struct.add(0x38).add(0x10).readPointer(),
                "kfd->info.kaddr.current_task": _kfd_struct.add(0x38).add(0x18).readPointer(),
                "kfd->info.kaddr.kernel_map": _kfd_struct.add(0x38).add(0x20).readPointer(),
                "kfd->info.kaddr.kernel_pmap": _kfd_struct.add(0x38).add(0x28).readPointer(),
                "kfd->info.kaddr.kernel_proc": _kfd_struct.add(0x38).add(0x30).readPointer(),
                "kfd->info.kaddr.kernel_task": _kfd_struct.add(0x38).add(0x38).readPointer(),
                "kfd->perf.kernel_slide": _kfd_struct.add(0x78).readPointer(),
                "kfd->perf.gVirtBase": _kfd_struct.add(0x78).add(0x8).readPointer(),
                "kfd->perf.gPhysBase": _kfd_struct.add(0x78).add(0x10).readPointer(),
                "kfd->perf.gPhysSize": _kfd_struct.add(0x78).add(0x18).readPointer(),
            }
            send(kfd)
        }
    },
    getAllProc: (pid) => {
        return getProc(pid);
    },
    getVnodeAtPath: (file_path) => {
        var path = Memory.allocUtf8String(file_path);
        var vnode = getVnodeAtPath(path);
        if (ptr(vnode) != '0xffffffffffffffff') {
            var vnode_info = {
                "vnode": vnode,
                "usecount": kread32(vnode.add(0x60)),
                "iocount": kread32(vnode.add(0x64)),
                "flag": kread32(vnode.add(0x54))
            }
            send(vnode_info)
        }
    },
    unsignKptr: (pac_kaddr) => {
        return unsign_kptr(uint64(pac_kaddr));
    },
    kHexDump: (kaddr, size) => {
        // console.log(uint64(kaddr))
        var kdump_size;
        size == null ? kdump_size = 0x640 : kdump_size = size;
        var data = Memory.alloc(kdump_size);
        kreadbuf(uint64(kaddr), data, kdump_size);
        send(hexdump(data, {address: uint64(kaddr), length: kdump_size}));
    },
    writeKmemAddr: (kaddr, code) => {
        kwrite8(uint64(kaddr), uint64(code));
    },
    hexdumpaddr: (addr, size) => {
        send(hexdump(ptr(addr), {offset:0, length:size}))
    },
    writememaddr: (addr, code, prot) => {
        // console.log("mem prot: " + prot)
        var newprot = prot
        if(prot == "r--" || prot == "r-x" || prot == "---") {
            newprot = "rw-"
        }
        Memory.protect(ptr(addr), 4, newprot)
        Memory.writeByteArray(ptr(addr), [code])
        if(prot == "---") return    // if mem protection '---' then remain else back to orig prot
        Memory.protect(ptr(addr), 4, prot)
    },
}

```

`ui.py`:

```py
# -*- coding: utf-8 -*-

################################################################################
## Form generated from reading UI file 'ui_test.ui'
##
## Created by: Qt User Interface Compiler version 6.5.1
##
## WARNING! All changes made in this file will be lost when recompiling UI file!
################################################################################

from PySide6.QtCore import (QCoreApplication, QLocale,
                            QMetaObject, QSize, Qt)
from PySide6.QtGui import (QFont)
from PySide6.QtWidgets import (QFormLayout, QGridLayout, QHBoxLayout,
                               QLabel, QLayout, QLineEdit, QPushButton, QSizePolicy, QSpacerItem, QTabWidget,
                               QTextBrowser, QWidget)

import hexviewer
import utilviewer


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        if not MainWindow.objectName():
            MainWindow.setObjectName(u"MainWindow")
        MainWindow.resize(1070, 670)
        MainWindow.setMinimumSize(QSize(1070, 670))
        font = QFont()
        font.setFamilies([u"Courier New"])
        MainWindow.setFont(font)
        self.centralwidget = QWidget(MainWindow)
        self.centralwidget.setObjectName(u"centralwidget")
        self.gridLayout = QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName(u"gridLayout")
        self.tabWidget = QTabWidget(self.centralwidget)
        self.tabWidget.setObjectName(u"tabWidget")
        self.tabWidget.setMinimumSize(QSize(0, 0))
        self.tab = QWidget()
        self.tab.setObjectName(u"tab")
        self.gridLayout_2 = QGridLayout(self.tab)
        self.gridLayout_2.setObjectName(u"gridLayout_2")
        self.horizontalLayout_4 = QHBoxLayout()
        self.horizontalLayout_4.setSpacing(7)
        self.horizontalLayout_4.setObjectName(u"horizontalLayout_4")
        self.horizontalLayout_4.setContentsMargins(-1, 0, -1, 0)
        self.hexEditBtn = QPushButton(self.tab)
        self.hexEditBtn.setObjectName(u"hexEditBtn")
        sizePolicy = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.hexEditBtn.sizePolicy().hasHeightForWidth())
        self.hexEditBtn.setSizePolicy(sizePolicy)
        self.hexEditBtn.setMinimumSize(QSize(0, 0))
        self.hexEditBtn.setMaximumSize(QSize(65, 16777215))

        self.horizontalLayout_4.addWidget(self.hexEditBtn)

        self.hexEditDoneBtn = QPushButton(self.tab)
        self.hexEditDoneBtn.setObjectName(u"hexEditDoneBtn")
        sizePolicy.setHeightForWidth(self.hexEditDoneBtn.sizePolicy().hasHeightForWidth())
        self.hexEditDoneBtn.setSizePolicy(sizePolicy)
        self.hexEditDoneBtn.setMinimumSize(QSize(65, 0))
        self.hexEditDoneBtn.setMaximumSize(QSize(65, 16777215))

        self.horizontalLayout_4.addWidget(self.hexEditDoneBtn)

        self.refreshBtn = QPushButton(self.tab)
        self.refreshBtn.setObjectName(u"refreshBtn")
        self.refreshBtn.setMaximumSize(QSize(30, 30))
        font1 = QFont()
        font1.setFamilies([u"Courier New"])
        font1.setPointSize(25)
        font1.setKerning(False)
        self.refreshBtn.setFont(font1)
        self.refreshBtn.setStyleSheet(u"")

        self.horizontalLayout_4.addWidget(self.refreshBtn)

        self.moveBackwardBtn = QPushButton(self.tab)
        self.moveBackwardBtn.setObjectName(u"moveBackwardBtn")
        self.moveBackwardBtn.setMaximumSize(QSize(30, 16777215))

        self.horizontalLayout_4.addWidget(self.moveBackwardBtn)

        self.moveForwardBtn = QPushButton(self.tab)
        self.moveForwardBtn.setObjectName(u"moveForwardBtn")
        self.moveForwardBtn.setEnabled(True)
        sizePolicy.setHeightForWidth(self.moveForwardBtn.sizePolicy().hasHeightForWidth())
        self.moveForwardBtn.setSizePolicy(sizePolicy)
        self.moveForwardBtn.setMaximumSize(QSize(30, 16777215))

        self.horizontalLayout_4.addWidget(self.moveForwardBtn)

        self.disassemBtn = QPushButton(self.tab)
        self.disassemBtn.setObjectName(u"disassemBtn")
        sizePolicy.setHeightForWidth(self.disassemBtn.sizePolicy().hasHeightForWidth())
        self.disassemBtn.setSizePolicy(sizePolicy)
        self.disassemBtn.setMinimumSize(QSize(65, 0))
        self.disassemBtn.setMaximumSize(QSize(65, 16777215))

        self.horizontalLayout_4.addWidget(self.disassemBtn)

        self.historyBtn = QPushButton(self.tab)
        self.historyBtn.setObjectName(u"historyBtn")
        sizePolicy.setHeightForWidth(self.historyBtn.sizePolicy().hasHeightForWidth())
        self.historyBtn.setSizePolicy(sizePolicy)
        self.historyBtn.setMinimumSize(QSize(65, 0))
        self.historyBtn.setMaximumSize(QSize(65, 16777215))

        self.horizontalLayout_4.addWidget(self.historyBtn)

        self.horizontalSpacer_3 = QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)

        self.horizontalLayout_4.addItem(self.horizontalSpacer_3)

        self.horizontalSpacer_2 = QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)

        self.horizontalLayout_4.addItem(self.horizontalSpacer_2)

        self.horizontalSpacer = QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)

        self.horizontalLayout_4.addItem(self.horizontalSpacer)


        self.gridLayout_2.addLayout(self.horizontalLayout_4, 0, 0, 1, 2)

        self.horizontalLayout_2 = QHBoxLayout()
        self.horizontalLayout_2.setObjectName(u"horizontalLayout_2")
        self.horizontalLayout_2.setSizeConstraint(QLayout.SetMaximumSize)
        self.horizontalLayout_2.setContentsMargins(-1, -1, -1, 0)
        self.addrInput = QLineEdit(self.tab)
        self.addrInput.setObjectName(u"addrInput")
        sizePolicy.setHeightForWidth(self.addrInput.sizePolicy().hasHeightForWidth())
        self.addrInput.setSizePolicy(sizePolicy)
        self.addrInput.setMinimumSize(QSize(0, 25))
        self.addrInput.setMaximumSize(QSize(16777215, 16777215))

        self.horizontalLayout_2.addWidget(self.addrInput)

        self.addrBtn = QPushButton(self.tab)
        self.addrBtn.setObjectName(u"addrBtn")
        self.addrBtn.setMinimumSize(QSize(0, 31))
        self.addrBtn.setMaximumSize(QSize(50, 16777215))

        self.horizontalLayout_2.addWidget(self.addrBtn)


        self.gridLayout_2.addLayout(self.horizontalLayout_2, 8, 2, 1, 2)

        self.label_2 = QLabel(self.tab)
        self.label_2.setObjectName(u"label_2")
        sizePolicy1 = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        sizePolicy1.setHorizontalStretch(0)
        sizePolicy1.setVerticalStretch(0)
        sizePolicy1.setHeightForWidth(self.label_2.sizePolicy().hasHeightForWidth())
        self.label_2.setSizePolicy(sizePolicy1)
        self.label_2.setMaximumSize(QSize(16777215, 10))

        self.gridLayout_2.addWidget(self.label_2, 7, 2, 1, 1)

        self.horizontalLayout_3 = QHBoxLayout()
        self.horizontalLayout_3.setObjectName(u"horizontalLayout_3")
        self.attachBtn = QPushButton(self.tab)
        self.attachBtn.setObjectName(u"attachBtn")
        sizePolicy2 = QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        sizePolicy2.setHorizontalStretch(0)
        sizePolicy2.setVerticalStretch(0)
        sizePolicy2.setHeightForWidth(self.attachBtn.sizePolicy().hasHeightForWidth())
        self.attachBtn.setSizePolicy(sizePolicy2)
        self.attachBtn.setMinimumSize(QSize(110, 0))
        self.attachBtn.setFocusPolicy(Qt.TabFocus)

        self.horizontalLayout_3.addWidget(self.attachBtn)

        self.detachBtn = QPushButton(self.tab)
        self.detachBtn.setObjectName(u"detachBtn")
        sizePolicy2.setHeightForWidth(self.detachBtn.sizePolicy().hasHeightForWidth())
        self.detachBtn.setSizePolicy(sizePolicy2)
        self.detachBtn.setMinimumSize(QSize(110, 0))

        self.horizontalLayout_3.addWidget(self.detachBtn)


        self.gridLayout_2.addLayout(self.horizontalLayout_3, 4, 2, 1, 1)

        self.horizontalLayout = QHBoxLayout()
#ifndef Q_OS_MAC
        self.horizontalLayout.setSpacing(-1)
#endif
        self.horizontalLayout.setObjectName(u"horizontalLayout")
        self.horizontalLayout.setContentsMargins(-1, -1, -1, 0)
        self.offsetInput = QLineEdit(self.tab)
        self.offsetInput.setObjectName(u"offsetInput")
        sizePolicy.setHeightForWidth(self.offsetInput.sizePolicy().hasHeightForWidth())
        self.offsetInput.setSizePolicy(sizePolicy)
        self.offsetInput.setMinimumSize(QSize(0, 25))
        self.offsetInput.setMaximumSize(QSize(16777215, 16777215))
        self.offsetInput.setLocale(QLocale(QLocale.English, QLocale.UnitedStates))

        self.horizontalLayout.addWidget(self.offsetInput)

        self.offsetOkbtn = QPushButton(self.tab)
        self.offsetOkbtn.setObjectName(u"offsetOkbtn")
        self.offsetOkbtn.setMinimumSize(QSize(0, 31))
        self.offsetOkbtn.setMaximumSize(QSize(50, 16777215))

        self.horizontalLayout.addWidget(self.offsetOkbtn)


        self.gridLayout_2.addLayout(self.horizontalLayout, 6, 2, 1, 2)

        # self.hexViewer = QTextEdit(self.tab)
        self.hexViewer = hexviewer.HexViewerClass(self.tab)
        self.hexViewer.setObjectName(u"hexViewer")
        sizePolicy3 = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        sizePolicy3.setHorizontalStretch(2)
        sizePolicy3.setVerticalStretch(0)
        sizePolicy3.setHeightForWidth(self.hexViewer.sizePolicy().hasHeightForWidth())
        self.hexViewer.setSizePolicy(sizePolicy3)
        self.hexViewer.setMinimumSize(QSize(685, 0))
        self.hexViewer.setMaximumSize(QSize(16777215, 16777215))
        self.hexViewer.setLocale(QLocale(QLocale.English, QLocale.UnitedStates))
        self.hexViewer.setInputMethodHints(Qt.ImhMultiLine)
        self.hexViewer.setReadOnly(True)
        self.hexViewer.setOverwriteMode(True)
        self.hexViewer.setAcceptRichText(True)
        # self.hexViewer.setTextInteractionFlags(Qt.NoTextInteraction)

        self.gridLayout_2.addWidget(self.hexViewer, 4, 0, 16, 2)

        self.label_3 = QLabel(self.tab)
        self.label_3.setObjectName(u"label_3")
        sizePolicy4 = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        sizePolicy4.setHorizontalStretch(0)
        sizePolicy4.setVerticalStretch(0)
        sizePolicy4.setHeightForWidth(self.label_3.sizePolicy().hasHeightForWidth())
        self.label_3.setSizePolicy(sizePolicy4)
        self.label_3.setScaledContents(False)
        self.label_3.setWordWrap(False)
        self.label_3.setMargin(0)
        self.label_3.setIndent(21)

        self.gridLayout_2.addWidget(self.label_3, 2, 0, 1, 2)

        self.label = QLabel(self.tab)
        self.label.setObjectName(u"label")
        sizePolicy1.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy1)
        self.label.setMaximumSize(QSize(16777215, 10))

        self.gridLayout_2.addWidget(self.label, 5, 2, 1, 1)

        self.tabWidget2 = QTabWidget(self.tab)
        self.tabWidget2.setObjectName(u"tabWidget2")
        sizePolicy5 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        sizePolicy5.setHorizontalStretch(1)
        sizePolicy5.setVerticalStretch(0)
        sizePolicy5.setHeightForWidth(self.tabWidget2.sizePolicy().hasHeightForWidth())
        self.tabWidget2.setSizePolicy(sizePolicy5)
        self.tabWidget2.setMinimumSize(QSize(295, 0))
        self.tabWidget2.setMaximumSize(QSize(16777215, 16777215))
        self.tabWidget2.setFocusPolicy(Qt.NoFocus)
        self.tabWidget2.setLayoutDirection(Qt.LeftToRight)
        self.tab_3 = QWidget()
        self.tab_3.setObjectName(u"tab_3")
        self.formLayout = QFormLayout(self.tab_3)
        self.formLayout.setObjectName(u"formLayout")
        self.label_8 = QLabel(self.tab_3)
        self.label_8.setObjectName(u"label_8")
        self.label_8.setMinimumSize(QSize(55, 0))

        self.formLayout.setWidget(1, QFormLayout.LabelRole, self.label_8)

        self.status_kernel_slide = QTextBrowser(self.tab_3)
        self.status_kernel_slide.setObjectName(u"status_kernel_slide")
        self.status_kernel_slide.setMaximumSize(QSize(16777215, 25))

        self.formLayout.setWidget(1, QFormLayout.FieldRole, self.status_kernel_slide)

        self.label_7 = QLabel(self.tab_3)
        self.label_7.setObjectName(u"label_7")
        self.label_7.setMinimumSize(QSize(55, 0))

        self.formLayout.setWidget(2, QFormLayout.LabelRole, self.label_7)

        self.status_kernel_base = QTextBrowser(self.tab_3)
        self.status_kernel_base.setObjectName(u"status_kernel_base")
        self.status_kernel_base.setMaximumSize(QSize(16777215, 25))

        self.formLayout.setWidget(2, QFormLayout.FieldRole, self.status_kernel_base)

        self.label_6 = QLabel(self.tab_3)
        self.label_6.setObjectName(u"label_6")

        self.formLayout.setWidget(3, QFormLayout.LabelRole, self.label_6)

        self.status_current_kaddr = QTextBrowser(self.tab_3)
        self.status_current_kaddr.setObjectName(u"status_current_kaddr")
        self.status_current_kaddr.setMinimumSize(QSize(0, 0))
        self.status_current_kaddr.setMaximumSize(QSize(16777215, 25))

        self.formLayout.setWidget(3, QFormLayout.FieldRole, self.status_current_kaddr)

        self.label_9 = QLabel(self.tab_3)
        self.label_9.setObjectName(u"label_9")

        self.formLayout.setWidget(4, QFormLayout.LabelRole, self.label_9)

        self.status_current_addr = QTextBrowser(self.tab_3)
        self.status_current_addr.setObjectName(u"status_current_addr")
        self.status_current_addr.setMinimumSize(QSize(0, 0))
        self.status_current_addr.setMaximumSize(QSize(16777215, 25))

        self.formLayout.setWidget(4, QFormLayout.FieldRole, self.status_current_addr)

        self.verticalSpacer_2 = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)

        self.formLayout.setItem(5, QFormLayout.FieldRole, self.verticalSpacer_2)

        self.status_kernel_version = QTextBrowser(self.tab_3)
        self.status_kernel_version.setObjectName(u"status_kernel_version")
        self.status_kernel_version.setMinimumSize(QSize(0, 50))
        self.status_kernel_version.setMaximumSize(QSize(16777215, 25))

        self.formLayout.setWidget(0, QFormLayout.FieldRole, self.status_kernel_version)

        self.label_10 = QLabel(self.tab_3)
        self.label_10.setObjectName(u"label_10")
        self.label_10.setMinimumSize(QSize(55, 0))

        self.formLayout.setWidget(0, QFormLayout.LabelRole, self.label_10)

        self.tabWidget2.addTab(self.tab_3, "")
        self.tab_4 = QWidget()
        self.tab_4.setObjectName(u"tab_4")
        self.gridLayout_4 = QGridLayout(self.tab_4)
        self.gridLayout_4.setObjectName(u"gridLayout_4")
        self.offsetsViewer = QTextBrowser(self.tab_4)
        self.offsetsViewer.setObjectName(u"offsetsViewer")
        self.offsetsViewer.setMinimumSize(QSize(0, 0))

        self.gridLayout_4.addWidget(self.offsetsViewer, 0, 0, 1, 2)

        self.offsetFilter = QLineEdit(self.tab_4)
        self.offsetFilter.setObjectName(u"offsetFilter")

        self.gridLayout_4.addWidget(self.offsetFilter, 1, 0, 1, 2)

        self.tabWidget2.addTab(self.tab_4, "")

        self.gridLayout_2.addWidget(self.tabWidget2, 9, 2, 11, 2)

        self.tabWidget.addTab(self.tab, "")
        self.label.raise_()
        self.tabWidget2.raise_()
        self.label_2.raise_()
        self.label_3.raise_()
        self.hexViewer.raise_()
        self.tab_2 = QWidget()
        self.tab_2.setObjectName(u"tab_2")
        self.gridLayout_7 = QGridLayout(self.tab_2)
        self.gridLayout_7.setObjectName(u"gridLayout_7")
        self.utilTabWidget = QTabWidget(self.tab_2)
        self.utilTabWidget.setObjectName(u"utilTabWidget")
        sizePolicy5.setHeightForWidth(self.utilTabWidget.sizePolicy().hasHeightForWidth())
        self.utilTabWidget.setSizePolicy(sizePolicy5)
        self.utilTabWidget.setMinimumSize(QSize(295, 0))
        self.utilTabWidget.setMaximumSize(QSize(16777215, 16777215))
        self.utilTabWidget.setFocusPolicy(Qt.NoFocus)
        self.utilTabWidget.setLayoutDirection(Qt.LeftToRight)
        self.tab_6 = QWidget()
        self.tab_6.setObjectName(u"tab_6")
        self.gridLayout_8 = QGridLayout(self.tab_6)
        self.gridLayout_8.setObjectName(u"gridLayout_8")
        self.getVnodeAtPathBtn = QPushButton(self.tab_6)
        self.getVnodeAtPathBtn.setObjectName(u"getVnodeAtPathBtn")

        self.gridLayout_8.addWidget(self.getVnodeAtPathBtn, 8, 1, 1, 1)

        self.utilViewerFilter = QLineEdit(self.tab_6)
        self.utilViewerFilter.setObjectName(u"utilViewerFilter")

        self.gridLayout_8.addWidget(self.utilViewerFilter, 11, 0, 1, 2)

        self.verticalSpacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)

        self.gridLayout_8.addItem(self.verticalSpacer, 10, 0, 1, 1)

        self.getAllProcLabel = QLabel(self.tab_6)
        self.getAllProcLabel.setObjectName(u"getAllProcLabel")
        self.getAllProcLabel.setMaximumSize(QSize(16777215, 15))

        self.gridLayout_8.addWidget(self.getAllProcLabel, 3, 0, 1, 1)

        self.getAllProcBtn = QPushButton(self.tab_6)
        self.getAllProcBtn.setObjectName(u"getAllProcBtn")

        self.gridLayout_8.addWidget(self.getAllProcBtn, 3, 1, 1, 1)

        self.getVnodeAtPathInput = QLineEdit(self.tab_6)
        self.getVnodeAtPathInput.setObjectName(u"getVnodeAtPathInput")

        self.gridLayout_8.addWidget(self.getVnodeAtPathInput, 8, 0, 1, 1)

        self.getPidListBtn = QPushButton(self.tab_6)
        self.getPidListBtn.setObjectName(u"getPidListBtn")

        self.gridLayout_8.addWidget(self.getPidListBtn, 1, 1, 1, 1)

        self.getVnodeAtPathLabel = QLabel(self.tab_6)
        self.getVnodeAtPathLabel.setObjectName(u"getVnodeAtPathLabel")
        self.getVnodeAtPathLabel.setMaximumSize(QSize(16777215, 40))

        self.gridLayout_8.addWidget(self.getVnodeAtPathLabel, 6, 0, 1, 1)

        self.getKfdBtn = QPushButton(self.tab_6)
        self.getKfdBtn.setObjectName(u"getKfdBtn")

        self.gridLayout_8.addWidget(self.getKfdBtn, 0, 1, 1, 1)

        self.getPidListLabel = QLabel(self.tab_6)
        self.getPidListLabel.setObjectName(u"getPidListLabel")
        self.getPidListLabel.setMaximumSize(QSize(16777215, 15))

        self.gridLayout_8.addWidget(self.getPidListLabel, 1, 0, 1, 1)

        self.getKfdLabel = QLabel(self.tab_6)
        self.getKfdLabel.setObjectName(u"getKfdLabel")
        self.getKfdLabel.setMaximumSize(QSize(16777215, 15))

        self.gridLayout_8.addWidget(self.getKfdLabel, 0, 0, 1, 1)

        self.utilTabWidget.addTab(self.tab_6, "")

        self.gridLayout_7.addWidget(self.utilTabWidget, 0, 1, 1, 1)

        # self.utilViewer = QTextEdit(self.tab_2)
        self.utilViewer = utilviewer.UtilViewerClass(self.tab_2)
        self.utilViewer.setObjectName(u"utilViewer")
        sizePolicy3.setHeightForWidth(self.utilViewer.sizePolicy().hasHeightForWidth())
        self.utilViewer.setSizePolicy(sizePolicy3)
        self.utilViewer.setMinimumSize(QSize(630, 0))
        self.utilViewer.setMaximumSize(QSize(16777215, 16777215))
        self.utilViewer.setLocale(QLocale(QLocale.English, QLocale.UnitedStates))
        self.utilViewer.setInputMethodHints(Qt.ImhMultiLine)
        self.utilViewer.setReadOnly(True)
        self.utilViewer.setOverwriteMode(True)
        self.utilViewer.setAcceptRichText(True)
        # self.utilViewer.setTextInteractionFlags(Qt.NoTextInteraction)

        self.gridLayout_7.addWidget(self.utilViewer, 0, 0, 1, 1)

        self.tabWidget.addTab(self.tab_2, "")

        self.gridLayout.addWidget(self.tabWidget, 0, 0, 1, 1)

        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)

        self.tabWidget.setCurrentIndex(0)
        self.tabWidget2.setCurrentIndex(0)
        self.utilTabWidget.setCurrentIndex(0)


        QMetaObject.connectSlotsByName(MainWindow)
    # setupUi

    def retranslateUi(self, MainWindow):
        MainWindow.setWindowTitle(QCoreApplication.translate("MainWindow", u"kfd-explorer", None))
        self.hexEditBtn.setText(QCoreApplication.translate("MainWindow", u"kwrite", None))
        self.hexEditDoneBtn.setText(QCoreApplication.translate("MainWindow", u"Done", None))
#if QT_CONFIG(whatsthis)
        self.refreshBtn.setWhatsThis(QCoreApplication.translate("MainWindow", u"<html><head/><body><p><br/></p></body></html>", None))
#endif // QT_CONFIG(whatsthis)
        self.refreshBtn.setText(QCoreApplication.translate("MainWindow", u"\u21bb", None))
#if QT_CONFIG(whatsthis)
        self.moveBackwardBtn.setWhatsThis(QCoreApplication.translate("MainWindow", u"<html><head/><body><p><br/></p></body></html>", None))
#endif // QT_CONFIG(whatsthis)
        self.moveBackwardBtn.setText(QCoreApplication.translate("MainWindow", u"\u25c0", None))
        self.moveForwardBtn.setText(QCoreApplication.translate("MainWindow", u"\u25b6", None))
        self.disassemBtn.setText(QCoreApplication.translate("MainWindow", u"Disasm", None))
        self.historyBtn.setText(QCoreApplication.translate("MainWindow", u"History", None))
        self.addrBtn.setText(QCoreApplication.translate("MainWindow", u"GO", None))
        self.label_2.setText(QCoreApplication.translate("MainWindow", u"Address", None))
        self.attachBtn.setText(QCoreApplication.translate("MainWindow", u"Attach", None))
        self.detachBtn.setText(QCoreApplication.translate("MainWindow", u"Detach", None))
        self.offsetOkbtn.setText(QCoreApplication.translate("MainWindow", u"GO", None))
        self.hexViewer.setHtml(QCoreApplication.translate("MainWindow", u"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><meta charset=\"utf-8\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"hr { height: 1px; border-width: 0; }\n"
"li.unchecked::marker { content: \"\\2610\"; }\n"
"li.checked::marker { content: \"\\2612\"; }\n"
"</style></head><body style=\" font-family:'Courier New'; font-size:13pt; font-weight:400; font-style:normal;\">\n"
"<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p></body></html>", None))
        self.label_3.setText(QCoreApplication.translate("MainWindow", u"ADDRESS   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF", None))
        self.label.setText(QCoreApplication.translate("MainWindow", u"Offset", None))
        self.label_8.setText(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>kslide</p></body></html>", None))
        self.label_7.setText(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Kernel   <br/>Base</p></body></html>", None))
        self.label_6.setText(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Current<br/>kaddr</p></body></html>", None))
        self.label_9.setText(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Current<br/>addr</p></body></html>", None))
        self.label_10.setText(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Kern<br/>version</p></body></html>", None))
        self.tabWidget2.setTabText(self.tabWidget2.indexOf(self.tab_3), QCoreApplication.translate("MainWindow", u"Status", None))
        self.offsetFilter.setPlaceholderText(QCoreApplication.translate("MainWindow", u"filter", None))
        self.tabWidget2.setTabText(self.tabWidget2.indexOf(self.tab_4), QCoreApplication.translate("MainWindow", u"Offsets", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), QCoreApplication.translate("MainWindow", u"Viewer", None))
        self.getVnodeAtPathBtn.setText(QCoreApplication.translate("MainWindow", u"Get", None))
        self.utilViewerFilter.setPlaceholderText(QCoreApplication.translate("MainWindow", u"filter", None))
        self.getAllProcLabel.setText(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Get all proc</p></body></html>", None))
        self.getAllProcBtn.setText(QCoreApplication.translate("MainWindow", u"Get", None))
        self.getVnodeAtPathInput.setPlaceholderText(QCoreApplication.translate("MainWindow", u"full file path", None))
        self.getPidListBtn.setText(QCoreApplication.translate("MainWindow", u"Get", None))
        self.getVnodeAtPathLabel.setText(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Get vnode at path</p></body></html>", None))
        self.getKfdBtn.setText(QCoreApplication.translate("MainWindow", u"Get", None))
        self.getPidListLabel.setText(QCoreApplication.translate("MainWindow", u"Get pid list", None))
        self.getKfdLabel.setText(QCoreApplication.translate("MainWindow", u"Get kfd", None))
        self.getKfdBtn.setText(QCoreApplication.translate("MainWindow", u"Get", None))
        self.utilTabWidget.setTabText(self.utilTabWidget.indexOf(self.tab_6), QCoreApplication.translate("MainWindow", u"Info", None))
        self.utilViewer.setHtml(QCoreApplication.translate("MainWindow", u"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><meta charset=\"utf-8\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"hr { height: 1px; border-width: 0; }\n"
"li.unchecked::marker { content: \"\\2610\"; }\n"
"li.checked::marker { content: \"\\2612\"; }\n"
"</style></head><body style=\" font-family:'Courier New'; font-size:13pt; font-weight:400; font-style:normal;\">\n"
"<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p></body></html>", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), QCoreApplication.translate("MainWindow", u"Util", None))
    # retranslateUi


```

`ui.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1007</width>
    <height>670</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>1007</width>
    <height>670</height>
   </size>
  </property>
  <property name="font">
   <font>
    <family>Courier New</family>
   </font>
  </property>
  <property name="windowTitle">
   <string>MLViewer</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QTabWidget" name="tabWidget">
      <property name="currentIndex">
       <number>0</number>
      </property>
      <widget class="QWidget" name="tab">
       <attribute name="title">
        <string>Viewer</string>
       </attribute>
       <layout class="QGridLayout" name="gridLayout_2">
        <item row="9" column="2" rowspan="11" colspan="2">
         <widget class="QTabWidget" name="tabWidget2">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
            <horstretch>1</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="minimumSize">
           <size>
            <width>295</width>
            <height>0</height>
           </size>
          </property>
          <property name="maximumSize">
           <size>
            <width>16777215</width>
            <height>16777215</height>
           </size>
          </property>
          <property name="focusPolicy">
           <enum>Qt::NoFocus</enum>
          </property>
          <property name="layoutDirection">
           <enum>Qt::LeftToRight</enum>
          </property>
          <property name="currentIndex">
           <number>0</number>
          </property>
          <widget class="QWidget" name="tab_3">
           <attribute name="title">
            <string>Status</string>
           </attribute>
           <layout class="QGridLayout" name="gridLayout_3">
            <item row="0" column="1">
             <widget class="QLineEdit" name="status_img_name">
              <property name="minimumSize">
               <size>
                <width>0</width>
                <height>25</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="5" column="0">
             <widget class="QLabel" name="label_8">
              <property name="text">
               <string>Size</string>
              </property>
             </widget>
            </item>
            <item row="1" column="0">
             <widget class="QLabel" name="label_5">
              <property name="text">
               <string>Base</string>
              </property>
             </widget>
            </item>
            <item row="0" column="0">
             <widget class="QLabel" name="label_4">
              <property name="text">
               <string>Name</string>
              </property>
             </widget>
            </item>
            <item row="4" column="0">
             <widget class="QLabel" name="label_7">
              <property name="text">
               <string>End</string>
              </property>
             </widget>
            </item>
            <item row="2" column="0">
             <widget class="QLabel" name="label_6">
              <property name="text">
               <string>Current</string>
              </property>
             </widget>
            </item>
            <item row="1" column="1">
             <widget class="QTextBrowser" name="status_kernel_base">
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>25</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="2" column="1">
             <widget class="QTextBrowser" name="status_current">
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>25</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="4" column="1">
             <widget class="QTextBrowser" name="status_end">
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>25</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="5" column="1">
             <widget class="QTextBrowser" name="status_size">
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>25</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="6" column="0">
             <widget class="QLabel" name="label_9">
              <property name="text">
               <string>Path</string>
              </property>
             </widget>
            </item>
            <item row="6" column="1">
             <widget class="QTextBrowser" name="status_path"/>
            </item>
           </layout>
          </widget>
          <widget class="QWidget" name="tab_4">
           <attribute name="title">
            <string>List IMG</string>
           </attribute>
           <layout class="QGridLayout" name="gridLayout_4">
            <item row="2" column="1">
             <widget class="QPushButton" name="memDumpBtn">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="minimumSize">
               <size>
                <width>60</width>
                <height>0</height>
               </size>
              </property>
              <property name="maximumSize">
               <size>
                <width>70</width>
                <height>16777215</height>
               </size>
              </property>
              <property name="focusPolicy">
               <enum>Qt::NoFocus</enum>
              </property>
              <property name="text">
               <string>Dump</string>
              </property>
             </widget>
            </item>
            <item row="0" column="0" colspan="2">
             <widget class="QTextBrowser" name="offsetsViewer">
              <property name="minimumSize">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="2" column="0">
             <widget class="QLineEdit" name="offsetFilter"/>
            </item>
            <item row="1" column="0">
             <widget class="QLabel" name="label_12">
              <property name="minimumSize">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
              <property name="maximumSize">
               <size>
                <width>200</width>
                <height>16777215</height>
               </size>
              </property>
              <property name="font">
               <font>
                <family>Courier New</family>
                <bold>false</bold>
               </font>
              </property>
              <property name="text">
               <string>Unity? Check &amp; Dump</string>
              </property>
              <property name="alignment">
               <set>Qt::AlignCenter</set>
              </property>
             </widget>
            </item>
            <item row="1" column="1">
             <widget class="QCheckBox" name="unityCheckBox">
              <property name="maximumSize">
               <size>
                <width>60</width>
                <height>16777215</height>
               </size>
              </property>
              <property name="text">
               <string>Unity</string>
              </property>
             </widget>
            </item>
           </layout>
          </widget>
          <widget class="QWidget" name="tab_5">
           <attribute name="title">
            <string>Search</string>
           </attribute>
           <layout class="QGridLayout" name="gridLayout_5">
            <item row="1" column="4">
             <widget class="QCheckBox" name="memSearchReplaceCheckBox">
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>15</height>
               </size>
              </property>
              <property name="text">
               <string>Rep</string>
              </property>
             </widget>
            </item>
            <item row="5" column="0" colspan="5">
             <widget class="QProgressBar" name="progressBar">
              <property name="minimumSize">
               <size>
                <width>190</width>
                <height>0</height>
               </size>
              </property>
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>15</height>
               </size>
              </property>
              <property name="value">
               <number>0</number>
              </property>
              <property name="invertedAppearance">
               <bool>false</bool>
              </property>
             </widget>
            </item>
            <item row="2" column="4">
             <widget class="QPushButton" name="memSearchBtn">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="minimumSize">
               <size>
                <width>50</width>
                <height>31</height>
               </size>
              </property>
              <property name="maximumSize">
               <size>
                <width>50</width>
                <height>16777215</height>
               </size>
              </property>
              <property name="text">
               <string>GO</string>
              </property>
             </widget>
            </item>
            <item row="7" column="0" rowspan="2" colspan="5">
             <widget class="QTextBrowser" name="memSearchResult">
              <property name="minimumSize">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="3" column="0" colspan="4">
             <widget class="QTextEdit" name="memReplacePattern">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
                <horstretch>0</horstretch>
                <verstretch>1</verstretch>
               </sizepolicy>
              </property>
              <property name="minimumSize">
               <size>
                <width>190</width>
                <height>25</height>
               </size>
              </property>
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>25</height>
               </size>
              </property>
              <property name="focusPolicy">
               <enum>Qt::StrongFocus</enum>
              </property>
              <property name="tabChangesFocus">
               <bool>true</bool>
              </property>
              <property name="acceptRichText">
               <bool>false</bool>
              </property>
             </widget>
            </item>
            <item row="1" column="2">
             <spacer name="horizontalSpacer_5">
              <property name="orientation">
               <enum>Qt::Horizontal</enum>
              </property>
              <property name="sizeHint" stdset="0">
               <size>
                <width>50</width>
                <height>10</height>
               </size>
              </property>
             </spacer>
            </item>
            <item row="6" column="2" colspan="3">
             <widget class="QLabel" name="memSearchFoundCount">
              <property name="minimumSize">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>10</height>
               </size>
              </property>
              <property name="text">
               <string/>
              </property>
              <property name="alignment">
               <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
              </property>
             </widget>
            </item>
            <item row="1" column="0" colspan="2">
             <widget class="QLabel" name="label_10">
              <property name="text">
               <string>Pattern</string>
              </property>
             </widget>
            </item>
            <item row="9" column="0" colspan="5">
             <widget class="QLineEdit" name="searchMemSearchResult">
              <property name="text">
               <string/>
              </property>
             </widget>
            </item>
            <item row="3" column="4">
             <widget class="QPushButton" name="memReplaceBtn">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="minimumSize">
               <size>
                <width>50</width>
                <height>31</height>
               </size>
              </property>
              <property name="maximumSize">
               <size>
                <width>50</width>
                <height>16777215</height>
               </size>
              </property>
              <property name="text">
               <string>REP</string>
              </property>
             </widget>
            </item>
            <item row="6" column="0" colspan="2">
             <widget class="QLabel" name="label_11">
              <property name="minimumSize">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>10</height>
               </size>
              </property>
              <property name="text">
               <string>Result</string>
              </property>
             </widget>
            </item>
            <item row="1" column="3">
             <widget class="QCheckBox" name="memScanPatternTypeCheckBox">
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>15</height>
               </size>
              </property>
              <property name="focusPolicy">
               <enum>Qt::NoFocus</enum>
              </property>
              <property name="text">
               <string>Str</string>
              </property>
             </widget>
            </item>
            <item row="2" column="0" colspan="4">
             <widget class="QTextEdit" name="memSearchPattern">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
                <horstretch>0</horstretch>
                <verstretch>1</verstretch>
               </sizepolicy>
              </property>
              <property name="minimumSize">
               <size>
                <width>190</width>
                <height>25</height>
               </size>
              </property>
              <property name="focusPolicy">
               <enum>Qt::StrongFocus</enum>
              </property>
              <property name="tabChangesFocus">
               <bool>true</bool>
              </property>
              <property name="acceptRichText">
               <bool>false</bool>
              </property>
             </widget>
            </item>
            <item row="0" column="4">
             <widget class="QCheckBox" name="memSearchTargetImgCheckBox">
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>15</height>
               </size>
              </property>
              <property name="text">
               <string>Img</string>
              </property>
             </widget>
            </item>
            <item row="0" column="0" colspan="4">
             <widget class="QLineEdit" name="memSearchTargetImgInput">
              <property name="enabled">
               <bool>false</bool>
              </property>
              <property name="minimumSize">
               <size>
                <width>190</width>
                <height>25</height>
               </size>
              </property>
             </widget>
            </item>
           </layout>
          </widget>
         </widget>
        </item>
        <item row="4" column="0" rowspan="16" colspan="2">
         <widget class="QTextEdit" name="hexViewer">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
            <horstretch>1</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="minimumSize">
           <size>
            <width>630</width>
            <height>0</height>
           </size>
          </property>
          <property name="maximumSize">
           <size>
            <width>16777215</width>
            <height>16777215</height>
           </size>
          </property>
          <property name="locale">
           <locale language="English" country="UnitedStates"/>
          </property>
          <property name="inputMethodHints">
           <set>Qt::ImhMultiLine</set>
          </property>
          <property name="readOnly">
           <bool>true</bool>
          </property>
          <property name="html">
           <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
hr { height: 1px; border-width: 0; }
li.unchecked::marker { content: &quot;\2610&quot;; }
li.checked::marker { content: &quot;\2612&quot;; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Courier New'; font-size:13pt; font-weight:400; font-style:normal;&quot;&gt;
&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
          </property>
          <property name="overwriteMode">
           <bool>true</bool>
          </property>
          <property name="acceptRichText">
           <bool>true</bool>
          </property>
          <property name="textInteractionFlags">
           <set>Qt::NoTextInteraction</set>
          </property>
         </widget>
        </item>
        <item row="6" column="2" colspan="2">
         <layout class="QHBoxLayout" name="horizontalLayout" stretch="0,0">
          <property name="spacing">
           <number>-1</number>
          </property>
          <property name="bottomMargin">
           <number>0</number>
          </property>
          <item>
           <widget class="QLineEdit" name="offsetInput">
            <property name="sizePolicy">
             <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
            <property name="minimumSize">
             <size>
              <width>0</width>
              <height>25</height>
             </size>
            </property>
            <property name="maximumSize">
             <size>
              <width>16777215</width>
              <height>16777215</height>
             </size>
            </property>
            <property name="locale">
             <locale language="English" country="UnitedStates"/>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="offsetOkbtn">
            <property name="minimumSize">
             <size>
              <width>0</width>
              <height>31</height>
             </size>
            </property>
            <property name="maximumSize">
             <size>
              <width>50</width>
              <height>16777215</height>
             </size>
            </property>
            <property name="text">
             <string>GO</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item row="4" column="2">
         <layout class="QHBoxLayout" name="horizontalLayout_3">
          <item>
           <widget class="QPushButton" name="attachBtn">
            <property name="sizePolicy">
             <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
            <property name="minimumSize">
             <size>
              <width>110</width>
              <height>0</height>
             </size>
            </property>
            <property name="focusPolicy">
             <enum>Qt::TabFocus</enum>
            </property>
            <property name="text">
             <string>Attach</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="detachBtn">
            <property name="sizePolicy">
             <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
            <property name="minimumSize">
             <size>
              <width>110</width>
              <height>0</height>
             </size>
            </property>
            <property name="text">
             <string>Detach</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item row="8" column="2" colspan="2">
         <layout class="QHBoxLayout" name="horizontalLayout_2" stretch="0,0">
          <property name="sizeConstraint">
           <enum>QLayout::SetMaximumSize</enum>
          </property>
          <property name="bottomMargin">
           <number>0</number>
          </property>
          <item>
           <widget class="QLineEdit" name="addrInput">
            <property name="sizePolicy">
             <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
            <property name="minimumSize">
             <size>
              <width>0</width>
              <height>25</height>
             </size>
            </property>
            <property name="maximumSize">
             <size>
              <width>16777215</width>
              <height>16777215</height>
             </size>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="addrBtn">
            <property name="minimumSize">
             <size>
              <width>0</width>
              <height>31</height>
             </size>
            </property>
            <property name="maximumSize">
             <size>
              <width>50</width>
              <height>16777215</height>
             </size>
            </property>
            <property name="text">
             <string>GO</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item row="5" column="2">
         <widget class="QLabel" name="label">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="maximumSize">
           <size>
            <width>16777215</width>
            <height>10</height>
           </size>
          </property>
          <property name="text">
           <string>Offset</string>
          </property>
         </widget>
        </item>
        <item row="7" column="2">
         <widget class="QLabel" name="label_2">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="maximumSize">
           <size>
            <width>16777215</width>
            <height>10</height>
           </size>
          </property>
          <property name="text">
           <string>Address</string>
          </property>
         </widget>
        </item>
        <item row="2" column="0" colspan="2">
         <widget class="QLabel" name="label_3">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="text">
           <string>ADDRESS   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF</string>
          </property>
          <property name="scaledContents">
           <bool>false</bool>
          </property>
          <property name="wordWrap">
           <bool>false</bool>
          </property>
          <property name="margin">
           <number>0</number>
          </property>
          <property name="indent">
           <number>21</number>
          </property>
         </widget>
        </item>
        <item row="2" column="2">
         <layout class="QHBoxLayout" name="horizontalLayout_6">
          <property name="leftMargin">
           <number>5</number>
          </property>
          <item>
           <widget class="QCheckBox" name="listPIDCheckBox">
            <property name="maximumSize">
             <size>
              <width>110</width>
              <height>16777215</height>
             </size>
            </property>
            <property name="text">
             <string>ListPID</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QCheckBox" name="attachTypeCheckBox">
            <property name="maximumSize">
             <size>
              <width>110</width>
              <height>16777215</height>
             </size>
            </property>
            <property name="text">
             <string>Remote</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QCheckBox" name="spawnModeCheckBox">
            <property name="sizePolicy">
             <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
            <property name="minimumSize">
             <size>
              <width>0</width>
              <height>0</height>
             </size>
            </property>
            <property name="maximumSize">
             <size>
              <width>110</width>
              <height>16777215</height>
             </size>
            </property>
            <property name="text">
             <string>Spawn</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item row="0" column="0" colspan="2">
         <layout class="QHBoxLayout" name="horizontalLayout_4">
          <item>
           <widget class="QPushButton" name="hexEditBtn">
            <property name="sizePolicy">
             <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
            <property name="minimumSize">
             <size>
              <width>70</width>
              <height>0</height>
             </size>
            </property>
            <property name="text">
             <string>HexEdit</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="hexEditDoneBtn">
            <property name="sizePolicy">
             <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
              <horstretch>0</horstretch>
              <verstretch>0</verstretch>
             </sizepolicy>
            </property>
            <property name="minimumSize">
             <size>
              <width>70</width>
              <height>0</height>
             </size>
            </property>
            <property name="text">
             <string>Done</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QCheckBox" name="watchMemoryCheckBox">
            <property name="minimumSize">
             <size>
              <width>0</width>
              <height>0</height>
             </size>
            </property>
            <property name="baseSize">
             <size>
              <width>0</width>
              <height>0</height>
             </size>
            </property>
            <property name="text">
             <string>Watch</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QDoubleSpinBox" name="watchMemorySpinBox">
            <property name="maximumSize">
             <size>
              <width>45</width>
              <height>16777215</height>
             </size>
            </property>
            <property name="decimals">
             <number>1</number>
            </property>
            <property name="singleStep">
             <double>0.100000000000000</double>
            </property>
           </widget>
          </item>
          <item>
           <spacer name="horizontalSpacer_4">
            <property name="orientation">
             <enum>Qt::Horizontal</enum>
            </property>
            <property name="sizeHint" stdset="0">
             <size>
              <width>40</width>
              <height>20</height>
             </size>
            </property>
           </spacer>
          </item>
          <item>
           <spacer name="horizontalSpacer_3">
            <property name="orientation">
             <enum>Qt::Horizontal</enum>
            </property>
            <property name="sizeHint" stdset="0">
             <size>
              <width>40</width>
              <height>20</height>
             </size>
            </property>
           </spacer>
          </item>
          <item>
           <spacer name="horizontalSpacer_2">
            <property name="orientation">
             <enum>Qt::Horizontal</enum>
            </property>
            <property name="sizeHint" stdset="0">
             <size>
              <width>40</width>
              <height>20</height>
             </size>
            </property>
           </spacer>
          </item>
          <item>
           <spacer name="horizontalSpacer">
            <property name="orientation">
             <enum>Qt::Horizontal</enum>
            </property>
            <property name="sizeHint" stdset="0">
             <size>
              <width>40</width>
              <height>20</height>
             </size>
            </property>
           </spacer>
          </item>
         </layout>
        </item>
       </layout>
       <zorder>label</zorder>
       <zorder>tabWidget2</zorder>
       <zorder>label_2</zorder>
       <zorder>label_3</zorder>
       <zorder>hexViewer</zorder>
       <zorder></zorder>
      </widget>
      <widget class="QWidget" name="tab_2">
       <attribute name="title">
        <string>Util</string>
       </attribute>
       <layout class="QGridLayout" name="gridLayout_7">
        <item row="0" column="0">
         <widget class="QTextEdit" name="utilViewer">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
            <horstretch>1</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="minimumSize">
           <size>
            <width>630</width>
            <height>0</height>
           </size>
          </property>
          <property name="maximumSize">
           <size>
            <width>16777215</width>
            <height>16777215</height>
           </size>
          </property>
          <property name="locale">
           <locale language="English" country="UnitedStates"/>
          </property>
          <property name="inputMethodHints">
           <set>Qt::ImhMultiLine</set>
          </property>
          <property name="readOnly">
           <bool>true</bool>
          </property>
          <property name="html">
           <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
hr { height: 1px; border-width: 0; }
li.unchecked::marker { content: &quot;\2610&quot;; }
li.checked::marker { content: &quot;\2612&quot;; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Courier New'; font-size:13pt; font-weight:400; font-style:normal;&quot;&gt;
&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
          </property>
          <property name="overwriteMode">
           <bool>true</bool>
          </property>
          <property name="acceptRichText">
           <bool>true</bool>
          </property>
          <property name="textInteractionFlags">
           <set>Qt::NoTextInteraction</set>
          </property>
         </widget>
        </item>
        <item row="0" column="1">
         <widget class="QTabWidget" name="utilTabWidget">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
            <horstretch>1</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="minimumSize">
           <size>
            <width>295</width>
            <height>0</height>
           </size>
          </property>
          <property name="maximumSize">
           <size>
            <width>500</width>
            <height>16777215</height>
           </size>
          </property>
          <property name="focusPolicy">
           <enum>Qt::NoFocus</enum>
          </property>
          <property name="layoutDirection">
           <enum>Qt::LeftToRight</enum>
          </property>
          <property name="currentIndex">
           <number>0</number>
          </property>
          <widget class="QWidget" name="tab_7">
           <attribute name="title">
            <string>Parse IMG</string>
           </attribute>
           <layout class="QGridLayout" name="gridLayout_6">
            <item row="0" column="0">
             <widget class="QLabel" name="parseImgNameLabel">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Fixed" vsizetype="Preferred">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="text">
               <string>Name</string>
              </property>
             </widget>
            </item>
            <item row="1" column="0">
             <widget class="QLabel" name="parseImgBaseLabel">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Fixed" vsizetype="Preferred">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="text">
               <string>Base</string>
              </property>
             </widget>
            </item>
            <item row="1" column="1" colspan="3">
             <widget class="QTextBrowser" name="parse_img_base">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>25</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="3" column="0" colspan="4">
             <widget class="QTextBrowser" name="parseImgListImgViewer">
              <property name="minimumSize">
               <size>
                <width>0</width>
                <height>0</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="4" column="0" colspan="3">
             <widget class="QLineEdit" name="parseImgName"/>
            </item>
            <item row="4" column="3">
             <widget class="QPushButton" name="parseBtn">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="minimumSize">
               <size>
                <width>60</width>
                <height>0</height>
               </size>
              </property>
              <property name="maximumSize">
               <size>
                <width>70</width>
                <height>16777215</height>
               </size>
              </property>
              <property name="focusPolicy">
               <enum>Qt::NoFocus</enum>
              </property>
              <property name="text">
               <string>Parse</string>
              </property>
             </widget>
            </item>
            <item row="0" column="1" colspan="3">
             <widget class="QLineEdit" name="parse_img_name">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="minimumSize">
               <size>
                <width>0</width>
                <height>25</height>
               </size>
              </property>
             </widget>
            </item>
            <item row="2" column="0">
             <widget class="QLabel" name="parseImgPathLabel">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Fixed" vsizetype="Preferred">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="text">
               <string>Path</string>
              </property>
             </widget>
            </item>
            <item row="2" column="1" colspan="3">
             <widget class="QTextBrowser" name="parse_img_path">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="maximumSize">
               <size>
                <width>16777215</width>
                <height>100</height>
               </size>
              </property>
             </widget>
            </item>
           </layout>
          </widget>
         </widget>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`utilviewer.py`:

```py
import re

import frida
from PySide6 import QtGui
from PySide6.QtGui import QAction
from PySide6.QtWidgets import QTextBrowser, QTextEdit, QLineEdit, QPushButton, QCheckBox

import globvar


class UtilViewerClass(QTextEdit):
    def __init__(self, args):
        super(UtilViewerClass, self).__init__(args)

        self.platform = None
        self.statusBar = None
        self.pid_list = None
        self.proc_list = None

        self.get_kfd_btn = QPushButton(None)
        self.get_pid_list_btn = QPushButton(None)
        self.get_all_proc_btn = QPushButton(None)
        self.get_vnode_at_path_input = QLineEdit(None)
        self.get_vnode_at_path_btn = QPushButton(None)

        self.util_viewer_filter = QLineEdit(None)

    def get_kfd(self):
        try:
            if globvar.fridaInstrument is None:
                return
            kfd = globvar.fridaInstrument.get_kfd()
            if kfd is not None:
                # Find the maximum key length for alignment
                max_key_length = max(len(key) for key in kfd) + 1  # +1 for extra space before value
                kfd_text = ""
                for key in kfd:
                    # Right-align the value with calculated padding
                    padding = max_key_length - len(key)
                    kfd_text += f"{key}{' ' * padding}\t\t{kfd[key]}\n"
                self.setText(f"{kfd_text}")
        except Exception as e:
            print(e)
            return

    def get_pid_list(self):
        self.setPlainText('')
        try:
            device = frida.get_usb_device(1)
            enumeration_function = device.enumerate_processes
        except Exception as e:
            print(e)
            return

        self.pid_list = [app for app in enumeration_function()]
        pid_list_text = ''
        for app in self.pid_list:
            pid_list_text += f"{str(app.pid)}\t{app.name}\n"

        self.setText(pid_list_text)

    def get_all_proc(self):
        try:
            if globvar.fridaInstrument is None:
                return
            device = frida.get_usb_device(1)
            enumeration_function = device.enumerate_processes
        except Exception as e:
            print(e)
            return

        self.pid_list = [app for app in enumeration_function()]
        self.proc_list = [[app.pid, app.name, globvar.fridaInstrument.get_all_proc(app.pid)] for app in self.pid_list]
        proc_list_text = ''
        for proc in self.proc_list:
            proc_list_text += f"pid: {proc[0]}\tname: {proc[1]}\tproc: {hex(int(proc[2]))}\n"

        self.setPlainText('')
        self.setText(proc_list_text)

    def get_vnode_at_path(self):
        try:
            if globvar.fridaInstrument is None:
                return
            if (path := self.get_vnode_at_path_input.text()) != '':
                vnode = globvar.fridaInstrument.get_vnode_at_path(path)
                if vnode != '':
                    vnode_text = f"path: {path}\n" \
                                 f"vnode: {hex(int(vnode['vnode']))}\n" \
                                 f"usecount: {vnode['usecount']}, iocount: {vnode['iocount']}\n" \
                                 f"flag: {hex(int(vnode['flag']))}"
                    self.setPlainText('')
                    self.setText(vnode_text)
            else:
                self.get_vnode_at_path_input.setFocus()
        except Exception as e:
            print(e)
            return

    def util_viewer_filter_func(self):
        text_to_find = self.util_viewer_filter.text().lower()

        matched = ''
        if self.pid_list is not None and len(self.pid_list) > 0 and re.search(r"^\d+\t.*", self.toPlainText()):
            for app in self.pid_list:
                pid_list_text = f"{str(app.pid)}\t{app.name}\n"
                if pid_list_text.lower().find(text_to_find) != -1:
                    matched += pid_list_text
        elif self.proc_list is not None and len(self.proc_list) > 0 and re.search(r"^pid: \d+\tname: .*\tproc: .*", self.toPlainText()):
            for proc in self.proc_list:
                proc_list_text = f"pid: {proc[0]}\tname: {proc[1]}\tproc: {hex(int(proc[2]))}\n"
                if proc_list_text.lower().find(text_to_find) != -1:
                    matched += proc_list_text

        if matched != '':
            self.setText(matched)

    # def contextMenuEvent(self, e: QtGui.QContextMenuEvent) -> None:
    #     menu = super(UtilViewerClass, self).createStandardContextMenu()  # Get the default context menu
    #     select_all_action = next((action for action in menu.actions() if "Select All" in action.text()), None)
    #
    #     if select_all_action:
    #         # parse more on __got, __la_symbol_ptr tables
    #         selected_text = self.textCursor().selectedText()
    #         if self.platform == 'linux':
    #             detail_section = ['.dynsym', '.rela.plt', '.got.plt', '.symtab']
    #             for item in detail_section:
    #                 if item in self.textCursor().block().text():
    #                     selected_text = item
    #         regex = re.compile(r'(\b__got\b|\b__la_symbol_ptr\b|\.dynsym|\.rela.plt|\.got\.plt|\.symtab)')
    #         match = regex.match(selected_text)
    #         is_selected = bool(selected_text)
    #
    #         def create_action(text, enabled, func):
    #             action = QAction(text, self)
    #             action.setEnabled(enabled)
    #             action.triggered.connect(func)
    #             return action
    #
    #         if match and is_selected:
    #             detail_action = create_action(f"Parse {selected_text}", True, lambda: self.detail(selected_text))
    #             menu.insertAction(select_all_action, detail_action)
    #
    #     menu.exec(e.globalPos())





```