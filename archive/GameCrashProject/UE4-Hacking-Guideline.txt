Project Path: arc_GameCrashProject_UE4-Hacking-Guideline_vuw_gwf7

Source Tree:

```txt
arc_GameCrashProject_UE4-Hacking-Guideline_vuw_gwf7
├── 1_Introduction
│   ├── 1_UnrealEngine.md
│   ├── 2_Attack_Vectors.md
│   └── 3_Tools.md
├── 2_Methodology
│   ├── 1_Build.md
│   └── 2_Analysis
│       ├── 2.1_Introduction.md
│       ├── 2.2_UE4_Features.md
│       ├── 2.3_Resource_Analysis.md
│       ├── 2.4_Network_Analysis.md
│       ├── 2.5_Harness.md
│       ├── 2.6_ETC.md
│       ├── 2.7_Reference.md
│       └── README.md
├── 3_Conclusion
│   └── 1_Conclusion.md
└── README.md

```

`1_Introduction/1_UnrealEngine.md`:

```md
### 목차
- [1. 개요](#1-개요)
  - [1.1. 게임 엔진을 선택한 이유](#11-게임-엔진을-선택한-이유)
- [2. 왜 Unreal Engine 4 인가](#2-왜-unreal-engine-4-인가)
  - [2.1. UE4 설명](#21-ue4-설명)
  - [2.2. 오픈 소스](#22-오픈-소스)
  - [3. 참고 문헌](#3-참고-문헌)

---
# 1. 개요
게임 산업은 지속적으로 성장하고 있다. 한국콘텐츠진흥원에서 발간한 2020 대한민국 게임백서에 따르면 2020년 국내 게임 시장의 규모는 2019년 대비 9.2% 정도 상승한 약 17조 93억 원에 달하며 2022년에는 약 20조 원에 달할 것으로 전망된다.<sup id="head1">[1](#foot1)</sup> 게임과 관련된 국내 게임 시장뿐만 아니라 세계 게임 시장의 규모 또한 큰 폭으로 성정하고 있다. 시장조사기관인 뉴주(Newzoo)에 따르면 2021년에는 1758억 달러(약 200조 원)에 달하며 2024년에는 2187억 달러(약 259조 원)에 달할 것으로 전망된다.<sup id="head2">[2](#foot2)</sup>

## 1.1. 게임 엔진을 선택한 이유
게임은 표준 라이브러리와 DirectX, OpenGL, Vulkan와 같은 그래픽 라이브러리만 가지고 개발하기에는 복잡하며 생산성이 떨어진다. 그렇기 때문에 대다수의 게임 개발자는 게임을 개발하는데 반드시 필요한 기능인 그래픽 엔진, 물리 엔진, 오디오 엔진, UI 시스템, 각종 프레임워크, 네트워크 통신등을 지원하는 게임 엔진을 사용하여 게임을 개발한다.

같은 게임 엔진을 사용하여 개발된 게임들은 모두 같은 코드베이스를 공유한다고 볼 수 있다. 게임 엔진의 취약점은 해당 게임 엔진을 사용하는 모든 게임에 적용될 수 있으며 특정 게임에만 국한되는 특정 게임에만 국한되는 게임핵에 비해 파급력이 크다고 볼 수 있다. 또한, 게임 엔진을 업데이트하기 어려운 게임의 특성상 게임 엔진의 취약점은 각각의 게임에 치명적일 수 있다.

이렇듯 게임 엔진의 보안은 매우 중요하지만, 현재 게임 엔진에 대한 취약점 제보는 비교적 매우 적은 상황이다. 아래와 같이 CVE에 특정 키워드로 검색을 해본 결과 구글 크롬과 웹킷은 2600여개와 1200여개의 CVE가 검색되었지만, 언리얼 엔진의 경우 17개의 CVE만 검색되었다. 시장 가치로는 3.2배 밖에 차이 나지 않지만 등록된 CVE의 경우 14배이상 차이가 난다. 이는 시장 가치에 비해 게임 엔진에 대한 보안 연구가 관심이 없거나 진행이 되지 않았다고 볼 수 있다.

그러므로 우리는 매크로나 게임핵과 같은 보안 위협에만 중점을 두고 있는 게임 업계에 게임 엔진 취약점에 대한 경각심을 유발하고, 이를 통해 게임 엔진 보안성을 향상시키고자 프로젝트 주제로 게임 엔진을 선택했다.

# 2. 왜 Unreal Engine 4 인가
우리는 다양한 게임 엔진 중에서 Epic Games(에픽 게임즈)사의 상용 게임 엔진인 Unreal Engine 4(언리얼 엔진 4, 이하 UE4)는 선정하여 취약점 분석을 진행하였다.

## 2.1. UE4 설명
UE4는 미국의 에픽 게임즈사에서 개발한 3차원 게임 엔진이다. 지속적인 업데이트와 다양한 기술 지원, 뛰어난 개발 도구 지원 등의 이유로 많은 게임 개발사들이 채용해서 사용하고 있다. 국내에서는 PUBG사의 PlayerUnknown's Battlegrounds(배틀그라운드)와 NC소프트의 블레이드 & 소울가 UE4를 기반으로 개발이 되었으며 해외에서는 반다이 남코의 철권7과 에픽 게임즈사의 포트나이트가 UE4를 기반으로 개발이 되었다.

시장 점유율 역시 유니티 게임 엔진과 함께 상용 게임 엔진 시장을 양분하고 있을 정도로 높은 수준이다.

## 2.2. 오픈 소스
높은 시장 점유율도 큰 메리트로 다가왔지만 프로젝트에 있어 UE4의 가장 큰 메리트는 오픈 소스라는 점이었다. 경쟁사의 게임 엔진인 유니티 게임 엔진은 부분적으로 소스 코드를 공개하고 소스 코드 공개에 있어 협상과 매우 큰 비용이 필요하다고 알려져 있다. 

하지만 UE4의 경우 간단한 인증 절차와 계정 연동을 통해 코드 베이스를 받아 볼 수 있으며 이는 취약점 분석 작업에 있어 매우 용이하다. 그렇기 때문에 여러 게임 엔진 중에서 UE4이 프로젝트에 가장 적합하다고 판단했고 이를 바탕으로 프로젝트를 진행했다.

## 3. 참고 문헌
<b id="foot1">[[1](#head1)]</b> [2020 대한민국 게임백서](https://www.kocca.kr/cop/bbs/view/B0000146/1843527.do?menuNo=201826) <br />
<b id="foot2">[[2](#head2)]</b> [Newzoo Global Games Market Report 2021 | Free Version](https://newzoo.com/insights/trend-reports/newzoo-global-games-market-report-2021-free-version/)

```

`1_Introduction/2_Attack_Vectors.md`:

```md
### 목차 
- [1. 개요](#1-개요)
- [2. 리소스](#2-리소스)
  - [2.1. 리소스 파일](#21-리소스-파일)
- [3. 네트워크](#3-네트워크)
  - [3.1. RPC](#31-rpc)
  - [3.2. Pixel Streaming](#32-pixel-streaming)
  
---

# 1. 개요
UE4의 공격 벡터를 선정하고 분석한다.

공격 벡터를 리소스와 네트워크로 구분하고 분석을 진행하였다.

# 2. 리소스
Unreal Engine을 통해 만든 프로젝트는 패키징 과정을 거친다. 패키징을 하게 되면 게임의 기본 설정, 모델링, 오디오와 같은 리소스 파일, 게임의 로직을 표현하는데 사용되는 블루프린트 등은 Cook이라는 과정을 거치며, 이를 통해 게임에서 사용되는 파일인 Ini와 uasset, umap등의 파일로 변환된다. 

UE4을 통해 만든 프로젝트는 자체적인 파일 포맷으로 리소스를 관리하며 게임을 배포할 시 쿠킹과 패키징 과정을 거쳐 최적화된 리소스 파일을 사용한다. 쿠킹과 패키징의 대상은 텍스쳐, 모델, 오디오와 같은 일반적인 리소스 파일부터, 게임 실행시 필요한 기본 설정, 게임의 로직을 표현하는데 사용되는 블루프린트등 여러가지 리소스 파일이 존재한다.

쿠킹과 패키징 과정에서 압축과 암호화가 이루어지며 이 과정에서 파일 크기, 이름, 오프셋등 다양한 정보가 직렬화 되어 저장되며 게임을 실행할 경우 해당 과정을 역순으로 진행하여 최종적으로 플레이어가 경험할 수 있는 리소스 파일로 메모리에 적재된다.

우리는 리소스 파일을 로딩하는 과정에서 취약점이 존재할 것으로 보고 여러 리소스 파일을 대상으로 공격 벡터를 선정하였다.

## 2.1. 리소스 파일
리소스 파일은 크게 에디터에서 사용하는 리소스 파일과 게임에서 사용하는 리소스 파일이 존재한다. 에디터에서는 크게 uasset과 umap이 존재한다. umap은 UE4에서 자체적으로 사용하는 파일로 모델과 액터의 위치와 각 모델과 액터에 대한 블루프린트등 정보가 저장된다. uasset은 에셋이 저장되는 파일로 에디터에서 텍스쳐, 모델, 임포트, 폰트등 임포트할때 추가적인 메타데이터를 포함하여 저장된다.

에디터에서 사용하는 파일의 경우 메타데이터와 원본데이터가 저장되어있기 때문에 게임에서 사용하기에는 크기가 크다. 그렇기 때문에 게임에서 사용하기 위해서는 처리를 거쳐야 되며 이 처리를 쿠킹과 패키징이라고 한다.

쿠킹과 패키징 과정에서 압축과 암호화가 이루어진다. 쿠킹과 패키징된 리소스 파일은 게임 배포시 배포되며 모드등으로 유저간에 공유가 용이하기에 취약점 발생시 파급력이 크며 퍼징 테스트에도 용이하기에 공격 벡터로 선택하였다.

우리가 선정한 공격 벡터는 다음과 같다.
- 텍스쳐, 모델, 오디오 등 원본 데이터 파일
- uasset
- umap
- pak


# 3. 네트워크
UE4에서는 자체적으로 네트워크와 관련된 다양한 기능을 제공하며 그 중, 공격 벡터로 이용할 수 있는 부분을 정리하였다.

## 3.1. RPC
RPC는 Remote Procedure Call(원격 프로시저 호출)의 약자로 프로세스의 내부가 아닌 외부 프로세스나 다른 네트워크에 존재하는 프로세스의 함수(메소드)를 호출하기 위한 인터페이스로 UE4에서는 온라인 게임을 구현하기 위해 사용된다. 크게 클라이언트끼리 통신하는 P2P(Pear to Pear) 방식과 일반적인 클라이언트-서버 구조를 가진 데디케이트 서버 방식이 존재한다.

UE4는 RPC를 호출하기 위해, 다양한 검증과 인증 과정을 거치며 해당 과정에서 취약점이 발생하면 사용자 권한 문제와 임의 결제등 게임의 운영과 직결된 치명적인 문제가 발생할 것으로 보여 공격 벡터로 선정하였다.

## 3.2. Pixel Streaming
Pixel Streaming(픽셀 스트리밍)은 UE4 4.27에서 추가된 기능으로 웹 프로토콜을 이용하여 게임을 제공하는 기능이다. 사용자 입력을 웹 브라우저로 입력받고, 연산과 렌더링등 부하가 큰 작업은 서버를 사용하는 방식이다. UE4에서는 플러그인 형식으로 제공하며 클라우드와 접목하여 사용자는 클라우드를 통해 제공되는 게임을 하거나 스트리밍을 할 수 있다.

우리는 최신 기능이며 픽셀 스트리밍이 이루어지는 과정에서 통신이 발생하고 패킷을 처리하는 과정에서 취약점이 발생할 수 있을 것으로 보고 공격 벡터로 선정하였다.
```

`1_Introduction/3_Tools.md`:

```md
### 목차
- [1. 개요](#1-개요)
- [2. Fuzzing](#2-fuzzing)
  - [2.1 AFL++](#21-afl)
  - [2.2 peach](#22-peach)
  - [2.3 WinAFL](#23-winafl)
- [3. Analyzing](#3-analyzing)
  - [3.1 Static Code Analysis Tools](#31-static-code-analysis-tools)
  - [3.2 Debugging Tools](#32-debugging-tools)
    - [3.2 Dynamic Analysis Tools](#32-dynamic-analysis-tools)
  
---

# 1. 개요
UE4 취약점 분석 시에 사용한 도구를 정리하였다.

# 2. Fuzzing

## 2.1 AFL++
리소스 파일 퍼징을 위해 사용한 도구로, 코드 커버리지 기반 퍼저 중 널리 알려진 퍼저이며 화이트 박스 퍼징과 블랙 박스 퍼징을 모두 지원하기에 사용한 도구다. 하지만 화이트 박스 퍼징을 위하여 계측 삽입을 위한 빌드가 필요하며 언리얼 엔진의 빌드 시스템을 분석하여 계측을 삽입한 후 퍼징을 진행하였다.

## 2.2 peach
오디오 파일 퍼징을 위해 선정한 스마트 퍼저로 공개된 Wav의 구조를 기반으로 Wav 파일을 뮤테이션하여 에디터에서 임포트 하는 방식으로 퍼징을 진행하였다.

## 2.3 WinAFL
네트워크 퍼징을 위해 네트워크와 관련한 다양한 기능을 제공하는 WinAFL을 사용하였다. 서버와 클라이언트의 인증을 위한 시간 딜레이를 주는 기능도 가능하며 추가적으로 빌드가 필요하다. 하지만 현재 타임아웃과 관련한 오류로 제대로 동작하지 않는 문제가 발생하였다.

# 3. Analyzing 
## 3.1 Static Code Analysis Tools
UE4는 오픈 소스이기에 소스 코드에 대한 직접적인 분석이 가능하나 코드 베이스만 350MB 이상으로 소스코드만 읽는 방식으로 분석이 불가능하기 때문에 IDE와 서드파티 코드 분석 플러그인을 사용하여 정적 코드 분석을 진행하였다.

- Microsoft Visual Studio
- JetBrains ReSharper C++

## 3.2 Debugging Tools
정적 코드 분석만으로는 전체적인 구조나 취약점 분석하기가 쉽지 않기 떄문에 디버거를 사용하여 동작 방식과 취약점 분석을 진행하였으며, 퍼징 결과를 분석할때도 사용하였다.

- Microsoft Visual Studio 내장 디버거
- Microsoft Windbg
- GDB (Pwndbg)

### 3.2 Dynamic Analysis Tools
네트워크 패킷이나 함수의 인자를 분석하기 위해 사용한 도구로 사용하였다. 

- Wireshark
- frida
```

`2_Methodology/1_Build.md`:

```md
### Contents <!-- omit in toc -->
- [1. Unreal Engine 빌드](#1-unreal-engine-빌드)
	- [1.1 소스코드 다운로드](#11-소스코드-다운로드)
	- [1.1 Windows 빌드](#11-windows-빌드)
	- [1.2. Linux 빌드](#12-linux-빌드)
	- [1.2. 빌드 시스템 분석](#12-빌드-시스템-분석)
- [2. AFL++ 빌드](#2-afl-빌드)
	- [2.1 전체 모듈 계측삽입](#21-전체-모듈-계측삽입)
		- [2.1.1 UnrealBuildTool 수정](#211-unrealbuildtool-수정)
		- [2.1.2 빌드 환경 설정](#212-빌드-환경-설정)
		- [2.1.3 빌드를 위한 소스코드 수정](#213-빌드를-위한-소스코드-수정)
		- [2.1.4 빌드](#214-빌드)
	- [2.2 부분 계측 삽입](#22-부분-계측-삽입)
		- [2.2.1 리스폰스 파일 수정 및 컴파일](#221-리스폰스-파일-수정-및-컴파일)
		- [2.2.2 링킹](#222-링킹)
	- [2.3 검증](#23-검증)
	- [3. WinAFL 빌드](#3-winafl-빌드)

---

# 1. Unreal Engine 빌드
언리얼 엔진의 소스코드를 다운로드 받기위해서는 깃허브 계정과 에픽 게임즈 계정을 연동해야된다. 상세한 방법은 다음 문서를 참조하라.

[계정연동](https://www.unrealengine.com/en-US/ue4-on-github)

## 1.1 소스코드 다운로드
계정 연동을 끝맞췄다면 git을 통해 소스코드를 다운로드 받을 수 있다. 해당 깃허브 저장소이기 때문에 미리 토큰을 발급받거나 SSH 공개키를 깃허브에 등록 하는 것이 좋다.

토큰으로 소스코드를 clone하고자 한다면 다음의 명령어를 실행하면 된다.

```sh
git clone https://github.com/EpicGames/UnrealEngine.git
```

SSH 공개키를 깃허브에 등록하였다면 다음의 명령어로 저장소를 clone할 수 있다.

```sh
git clone git@github.com:EpicGames/UnrealEngine.git
```

기본적으로 `release` 브랜치로 다운로드 되며 해당 브랜치는 최신 언리얼 엔진 버진이다. 에픽 게임즈측에서는 버전별로 태그를 달아놓았으며 구 버전을 다운로드 받아야 될 경우 `git checkout`으로 소스코드의 버전을 변경할 수 있다. 예를 들어서 4.26 버전으로 바꾸기 위해서는 `git checkout 4.26.0-release`를 실행함으로 다운그레이드 할 수 있다.

## 1.1 Windows 빌드
Windows의 경우 빌드를 하기 위해서는 Visual Studio 2017이상이 설치되어 있어야 된다. 상세한 빌드 방법에 대해서는 다음 레퍼런스를 참조하라.

[Unreal Engine 빌드하기](https://docs.unrealengine.com/4.27/ko/ProductionPipelines/DevelopmentSetup/BuildingUnrealEngine/)


## 1.2. Linux 빌드
Linux의 경우 먼저 다음과 같은 명령어로 프로젝트를 초기화 시켜야 된다.

```sh
$ ./Setup.sh
$ ./GenerateProjectFiles.sh
```
모든 작업이 완료되었다면 `make`를 통해 빌드를 할 수 있으며 에디터의 경우 `make UE4Editor`로 빌드를 할 수 있으며 게임의 경우 `make UE4Game`으로 빌드를 할 수 있다.

기본적으로 모든 빌드 구성은 `Development`이며 릴리즈 버전의 경우 `make UE4Game-Linux-Shipping`으로 빌드할 수 있다. 

## 1.2. 빌드 시스템 분석
UE4에서는 UnrealBuildTool(언리얼 빌드 툴, 이하 UBT)를 사용하여 빌드가 진행된다. 빌드할때 사용하는 컴파일러와 링커는 플랫폼마다 다르며 상세한 정보는 `Engine/Source/Programs/UnrealBuildTool/Platform`에서 각 소스코드를 분석해야된다. 해당 문서에서는 Linux에서의 빌드 과정을 다룬다.

`make`를 실행하게되면 `make`에서는 UBT를 실행한다. 해당 UBT에서는 정의된 정보에 따라서 각 모듈의 종속성과 상태를 결정하며 빌드할 모듈의 범위를 정한다. 그리고 나서 UnrealHeaderTool(UHT)를 사용하여 각 모듈에서 사용될 헤더 파일(.h)을 생성한다.

헤더 파일이 생성되면 컴파일을 위한 리스폰스 파일(.rsp)과 링킹과 심볼 분리를 위한 쉘 스크립트를 생성하며 컴파일러와 쉘 스크립트를 실행하면서 빌드가 진행된다.

# 2. AFL++ 빌드
퍼즈 테스트를 효율적으로 하기 위해서는 계측을 삽입해야 된다. 계측을 삽입하기 위해서는 각 퍼저에서 커스텀한 컴파일러를 사용해야된다. 우리는 전체 모듈에 대한 계측을 삽입하는 방법과 특정 모듈에만 계측을 삽입하는 방법에 대해서 연구를 하였다.

## 2.1 전체 모듈 계측삽입
### 2.1.1 UnrealBuildTool 수정
UnrealBuildTool(이하 UBT)에서 AFL++에서 사용하는 컴파일러인 `afl-clang-lto++`를 사용하도록 수정해야 된다. 해당 유틸리티의 소스코드는 Github의 저장소에서 `Source/Programs/UnrealBuildTool`에서 확인할 수 있다.

해당 유틸리티는 C#으로 작성이 되었으며 빌드는 Microsoft Visual Studio에서 해야된다. 해당 프로젝트에서는 `Platform/Linux` 디렉토리에 Linux 빌드와 관련된 소스코드를 확인할 수 있다.

`LinuxCommon.cs+47`의 소스코드를 다음과 같이 수정한다.

```diff
				return Path.Combine(InternalSDKPath, "bin", "clang++");
			}

-			string[] ClangNames = { "clang++", "clang++-7.0", "clang++-6.0" };
+			string[] ClangNames = { "afl-clang++-lto", "clang++", "clang++-7.0", "clang++-6.0" };
			string ClangPath;
```

`afl-clang-lto++`의 경우 `-x` 옵션을 지원하지 않는다. 하지만 UBT에서 기본적으로 해당 옵션을 삽입하며 해당 옵션을 사용하지 않도록 수정을 해야된다. 해당 옵션을 삽입하는 함수는 `LinuxToolChain.cs`에서 확인할 수 있으며 C++같은 경우 `GetCompileArguments_CPP`함수에서 해당 옵션을 삽입하며 C언어 같은 경우 `GetCompileArguments_C`함수에서 해당 옵션을 삽입한다.

두 함수의 소스코드를 다음과 같이 수정한다.

```diff
		static string GetCompileArguments_CPP(CppCompileEnvironment CompileEnvironment)
		{
			string Result = "";
-			Result += " -x c++";
			Result += GetCompilerStandardVersion_CPP(CompileEnvironment);
			return Result;
		}

		static string GetCompileArguments_C()
		{
			string Result = "";
-			Result += " -x c";
			return Result;
		}
``` 

또한 사용하는 툴체인을 변경해줘야 된다. 해당 부분 같은 경우 `LinuxToolChain.cs+119`부터 다음과 같이 수정을 하면 된다.

```diff
			if (bForceUseSystemCompiler)
			{
				// Validate the system toolchain.
				BaseLinuxPath = "";
				MultiArchRoot = "";

				ToolchainInfo = "system toolchain";

				// use native linux toolchain
				ClangPath = LinuxCommon.WhichClang();
				GCCPath = LinuxCommon.WhichGcc();
				ArPath = LinuxCommon.Which("ar");
				LlvmArPath = LinuxCommon.Which("llvm-ar");
-				RanlibPath = LinuxCommon.Which("ranlib");
-				StripPath = LinuxCommon.Which("strip");
-				ObjcopyPath = LinuxCommon.Which("objcopy");
+				RanlibPath = LinuxCommon.Which("llvm-ranlib);
+				StripPath = LinuxCommon.Which("llvm-strip);
+				ObjcopyPath = LinuxCommon.Which("llvm-objcopy);

				// if clang is available, zero out gcc (@todo: support runtime switching?)
				if (!String.IsNullOrEmpty(ClangPath))
				{
					GCCPath = null;
				}
```

AFL++의 경우 별도의 ld를 사용하므로 해당 ld를 사용하도록 변경을 해줘야 된다. `LinuxToolChain.cs+119`를 다음과 같이 수정하면 된다.

```diff
protected virtual string GetLinkArguments(LinkEnvironment LinkEnvironment)
		{
			string Result = "";

			if (UsingLld(LinkEnvironment.Architecture) && (!LinkEnvironment.bIsBuildingDLL || (CompilerVersionMajor >= 9)))
			{
-				Result += (BuildHostPlatform.Current.Platform == UnrealTargetPlatform.Win64) ? " -fuse-ld=lld.exe" : " -fuse-ld=lld";
+				Result += (BuildHostPlatform.Current.Platform == UnrealTargetPlatform.Win64) ? " -fuse-ld=lld.exe" : " -fuse-ld=-fuse-ld=afl-ld-lto";
			}
```

기본적으로 UBT에서는 내장된 표준 라이브러리를 가지고 빌드를 하나 계측을 하기 위해서는 LLVM의 라이브러리를 사용해야 된다. `LinuxToolChain.cs+561`과 `LinuxToolChain.cs+562`를 다음과 같이 수정한다.

```diff
			if (ShouldUseLibcxx(CompileEnvironment.Architecture))
			{
				Result += " -nostdinc++";
-				Result += " -I" + "ThirdParty/Linux/LibCxx/include/";
-				Result += " -I" + "ThirdParty/Linux/LibCxx/include/c++/v1";
+				Result += " -I" + "/usr/lib/llvm-11/include/c++/";
+				Result += " -I" + "/usr/lib/llvm-11/include/c++/v1";
			}
```

또한 `LinuxToolChain.cs+1911`부터 다음과 같이 수정한다.

```diff
			if (ShouldUseLibcxx(LinkEnvironment.Architecture))
			{
				// libc++ and its abi lib
				LinkCommandString += " -nodefaultlibs";
-				LinkCommandString += " -L" + "ThirdParty/Linux/LibCxx/lib/Linux/" + LinkEnvironment.Architecture + "/";
-				LinkCommandString += " " + "ThirdParty/Linux/LibCxx/lib/Linux/" + LinkEnvironment.Architecture + "/libc++.a";
-				LinkCommandString += " " + "ThirdParty/Linux/LibCxx/lib/Linux/" + LinkEnvironment.Architecture + "/libc++abi.a";
+				auto LLVMLibPath = "/usr/lib/llvm-11/lib/";
+				LinkCommandString += " -L" + LLVMLibPath;
+				LinkCommandString += " " + LLVMLibPath + "/libc++.so";
+				LinkCommandString += " " + LLVMLibPath + "/libc++abi.so"; 
				LinkCommandString += " -lm";
				LinkCommandString += " -lc";
				LinkCommandString += " -lpthread"; // pthread_mutex_trylock is missing from libc stubs
				LinkCommandString += " -lgcc_s";
				LinkCommandString += " -lgcc";
			}
```

정상적으로 계측을 하기 위해서는 AFL++ 전용 라이브러리가 추가적으로 포함되어야 된다. `LinuxtoolChain.cs+1705`에 다음과 같은 코드를 추가하면 된다.

```diff
				ResponseLines.Add(string.Format("\"{0}\"", InputFile.AbsolutePath.Replace("\\", "/")));
				LinkAction.PrerequisiteItems.Add(InputFile);
			}
+		ResponseLines.Add("/usr/local/lib/afl/afl-compiler-rt.o");
+		ResponesLines.Add(""/usr/local/lib/afl/afl-llvm-rt-lto.o");
```

UE4Game을 대상으로 하는 경우 엔진 기능에 대한 공유 라이브러리를 사용하지 않기 때문에 상관이 없지만 UE4Editor나 다른 유틸리티의 경우 공유 라이브러리를 사용하기 때문에 링크 스크립트를 수정해줘야 된다. AFL++를 확인하면 공유 라이브러리에 대한 계측을 하는 방법에 대해서 나와 있으며 해당 방법을 토대로 링크 스크립트를 수정한다.

간단히 공유 라이브러리에 계측을 하는 방법에 대해서 설명을 하자면 공유 라이브러리를 링킹할 때는 `AFL_LLVM_LTO_DONTWRITEID`가 1로 설정 되어야 되며 `AFL_LLVM_LTO_STARTID`를 0에서부터 증가 시켜줘야 된다. `AFL_LLVM_LTO_STARTID`는 다음 공유 라이브러리를 빌드하기 전에 수치를 증가시켜 줘야 되며 AFL++에서 링킹 결과를 기반으로 증가시켜야 된다. 마지막으로 실행파일을 빌드할때는 `AFL_LLVM_LTO_DONTWRITEID`가 설정되어 있으면 안된다.

수정할 코드의 위치는 `LinuxToolChain.cs+1978` 부터이며 다음과 같이 수정을 하였다.
```diff
				else
				{
					LinkWriter.NewLine = "\n";
					LinkWriter.WriteLine("#!/bin/sh");
					LinkWriter.WriteLine("# Automatically generated by UnrealBuildTool");
					LinkWriter.WriteLine("# *DO NOT EDIT*");
					LinkWriter.WriteLine();
					LinkWriter.WriteLine("set -o errexit");

+					if (LinkEnvironment.bIsBuildingDLL)
+						{
+							LinkWriter.WriteLine("AFL_LLVM_LTO_DONTWRITEID=1");
+							LinkWriter.WriteLine("AFL_LLVM_LTO_STARTID=`cat /tmp/AFL_LLVM_LTO_STARTID`");
+							LinkWriter.WriteLine("if [ -z $AFL_LLVM_LTO_STARTID ]; then");
+							LinkWriter.WriteLine("touch /tmp/AFL_LLVM_LTO_STARTID");
+							LinkWriter.WriteLine("\tAFL_LLVM_LTO_STARTID=0");
+							LinkWriter.WriteLine("fi");
+						}
+						else
+						{
+							LinkWriter.WriteLine("unset AFL_LLVM_LTO_DONTWRITEID");
+							LinkWriter.WriteLine("AFL_LLVM_LTO_STARTID=`cat /tmp/AFL_LLVM_LTO_STARTID`");
+						}
+						LinkWriter.WriteLine();
+						LinkWriter.WriteLine("echo \"Linking Start! - AFL_LLBM_LTO_STARTID:\" $AFL_LLVM_LTO_STARTID")
+						LinkWriter.Write("temp=`");
+						LinkWriter.Write(LinkCommandString);
+						LinkWriter.WriteLine("`");
+						if (LinkEnvironment.bIsBuildingDLL)
+						{
+							LinkWriter.WriteLine("temp=`echo $temp | sed 's/.*Instrumented //' | sed 's/ locations.*//' | grep --color=never -o '[0-9]\\+'`");
+							LinkWriter.WriteLine("AFL_LLVM_LTO_STARTID=$((AFL_LLVM_LTO_STARTID+temp))");
+							LinkWriter.WriteLine("echo $AFL_LLVM_LTO_STARTID > /tmp/AFL_LLVM_LTO_STARTID");
+						}
+						else 
+						{
+							LinkWriter.WriteLine("echo 0 > /tmp/AFL_LLVM_LTO_STARTID");
+							LinkWriter.WriteLine("echo \"Linking End! - AFL_LLBM_LTO_STARTID:\" `cat /tmp/AFL_LLVM_LTO_STARTID`");
+						}
+					LinkWriter.WriteLine(GetDumpEncodeDebugCommand(LinkEnvironment, OutputFile));
+				}
```

그냥 실행시킬 경우 동기화 문제가 발생한다. 동기화를 방지하기 위해서 리눅스의 기본 유틸리티 중 하나인 `flock`을 사용하도록 코드를 수정한다. `LocalExecutor.cs+70`의 `ThreadFunc`를 수정하면 된다.

```diff
			ActionStartInfo.RedirectStandardOutput = false;
			ActionStartInfo.RedirectStandardError = false;

			// Log command-line used to execute task if debug info printing is enabled.
			Log.TraceVerbose("Executing: {0} {1}", ActionStartInfo.FileName, ActionStartInfo.Arguments);
+			if (processStartInfo.FileName == "/bin/sh")
+			{
+				ActionStartInfo.UseShellExecute = true;
+				ActionStartInfo.FileName = "/usr/bin/flock";
+				ActionStartInfo.Arguments = "/tmp/AFL_LLVM_LTO_STARTID -c \"sh " + ActionStartInfo.Arguments.Replace('"', ' ') + "\"";
+			} 
```

### 2.1.2 빌드 환경 설정
먼저 아래의 명령어를 통해 수정한 UnrealBuildTool에서 사용하는 파일을 생성한다.
```shell
echo 0 > /tmp/AFL_LLVM_LTO_STARTID
```

그리고 아래와 같이 Build.sh 파일을 수정해준다. 다음 명령어를 통해 수정한 UBT와 시스템에 설치된 컴파일러를 가지고 빌드할 수 있다.

```shell
sed -i '13,18s/^/#/' Engine/Build/BatchFiles/Linux/Build.sh
sed -i '21s/ / -ForceUseSystemCompiler /2' Engine/Build/BatchFiles/Linux/Build.sh
```

AFL++에서 커스텀한 컴파일러의 경우 PCH를 제대로 지원하지 않으며 UHT에 계측이 삽입되는 경우 오류가 발생하니 다음과 같이 `BuildConfiguation.xml`를 수정해야 된다.
```shell
echo -e "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n" \
	"<Configuration xmlns=\"https://www.unrealengine.com/BuildConfiguration\">\n" \
	"\t<BuildConfiguration>\n" \
	"\t\t<bUsePCHFiles>false</bUsePCHFiles>\n" \
	"\t</BuildConfiguration>\n" \
	"\t<UEBuildConfiguration>\n" \
	"\t\t<bDoNotBuildUHT>true</bDoNotBuildUHT>\n" \
	"\t<\<UEBuildConfiguration>\n" \
	"</Configuration>" | sed 's/^ //' > Engine/Saved/UnrealBuildTool/BuildConfiguration.xml
```

UBT는 `Engine/Binaries/DotNET`에 위치해 있으며 해당 UBT를 수정해서 빌드한 UBT로 변경한다.

### 2.1.3 빌드를 위한 소스코드 수정
PCH가 활성화 되어있을 경우 오류가 발생하지 않으나 PCH가 비활성화 되어 있을 경우 컴파일 에러가 발생하며 소스코드를 수정해야 된다.

`Engine/Plugins/Developer/RiderSourceCodeAccess/Source/RiderSourceCodeAccess/Private/RiderPathLocator/Linux/RiderPathLocatorLinux.cpp`를 다음과 같이 수정해야된다.

먼저 12번째에 변경할 함수를 사용할 수 있게 헤더파일을 추가해줘야 된다.
```diff
#if PLATFORM_LINUX
+ #include "Unix/UnixPlatformProcess.h"
```

그리고 나서 79번째 라인의 `FPlatfomProcess`를 `FUnixPlatfromProcess`로 수정하면 된다.

```diff
- FPlatfomProcess::ExecProcess(TEXT("/usr/bin/mdfind"), TEXT("\"kMDItemKind == Application\""), &ReturnCode, &OutResults, &OutErrors);
+ FUnixPlatformProcess::ExecProcess(TEXT("/usr/bin/mdfind"), TEXT("\"kMDItemKind == Application\""), &ReturnCode, &OutResults, &OutErrors);
```

`Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Public/Widgets/SItemSelector.h`의 경우 다음 헤더파일을 추가하면 된다.

```c
#include "Framework/Application/SlateApplication.h"
```

`Engine/Source/Runtime/Core/Public/Templates/TypeHash.h`에는 다음 코드를 상단에 추가하면 된다.

```c
#include <stdint.h>
```

`Engine/Plugins/Media/ImgMedia/Source/ImgMedia/Private/Assets/ImgMediaMipMapInfo.cpp`와 `Engine/Source/Runtime/MovieScene/Private/MovieSceneCommonHelpers.cpp`에는 다음 코드를 상단에 추가하면 된다. 
```c
#include "Engine/Engine.h"
```

### 2.1.4 빌드
`make`를 통해 빌드를 하게 되면 빌드가 된다. 하지만 링킹하는 과정에서 64기가 이상의 메모리를 요구하며 속도도 매우 느린 문제가 발생하였기에 특정 모듈에 계측을 할 수 있는 방법을 연구하였다.

## 2.2 부분 계측 삽입
해당 방법의 경우 UBT 수정 없이 빌드가 가능하며 리스폰스 파일과 쉘 스크립트를 빌드하고 나서 지우지 않는 것을 이용한 방법이다. 

만약 전쳬계측을 위해 패치가 되어 있다면 UBT와 `Engine/Build/BatchFiles/Linux/Build.sh`를 원상태로 복구해야 된다. 간단히 `Engine/Build/BatchFiles/Linux/Build.sh`의 주석을 친 부분을 제거하면 최초 실행시 UBT를 기본 UBT로 변경한다. `Engine/Saved/UnrealBuildTool/BuildConfiguration.xml`의 경우 를 전체 계측과 동일하게 수정한다.

이후 UBT와 UE4Game을 이용하여 빌드한다.
```shell
make UnrealBuildTool 
make UE4Game
```

이제 개별 소스코드에 대해서 AFL++를 적용한다.

### 2.2.1 리스폰스 파일 수정 및 컴파일
`Engine/Intermediate/Build/Linux/B4D820EA/UE4/Development`에서 AFL++를 적용할 모듈을 선정하고 리스폰스 파일을 수정한다. 해당 예제에서는 `PakFile`을 사용하였다.

```sh
$ cd Engine/Intermediate/Build/Linux/B4D820EA/UE4/Development/PakFile
$ sed -i 's/-x c++//' Module.PakFile.cpp.o.rsp
$ export RSP_PATH="`pwd`/Module.PakFile.cpp.o.rsp"
$ cd Engine/Source
$ afl-clang-lto++ @"$RSP_PATH"
```

### 2.2.2 링킹
컴파일이 정상적으로 되었다면 다음과 같은 명령어로 쉘 스크립트 파일을 수정하고 링킹을 하면 계측을 삽입할 수 있다.

```shell
$ export UNREALENGINE_LIB_PATH="$(pwd)/Engine/Source/ThirdParty"
$ export UNREALENGINE_LIB_PATH=$(echo $UNREALENGINE_LIB_PATH | sed -e 's/\//\\\//g')
$ cd Engine/Intermediate/Build/Linux/B4D820EA/UE4/Development
$ sed -i 's/.*clang++"/afl-clang-lto++/' Link-UE4Game-ASan.link.sh
$ sed -i 's/-LThirdParty/-L'"$UNREALENGINE_LIB_PATH"'/' Link-UE4Game-ASan.link.sh
$ sed -i 's/ ThirdParty/ '"$UNREALENGINE_LIB_PATH"'/' Link-UE4Game-ASan.link.sh
$ sed -i 's/ ThirdParty/ '"$UNREALENGINE_LIB_PATH"'/' Link-UE4Game-ASan.link.sh
$ sh Link-UE4Game-ASan.link.sh
```

## 2.3 검증
AFL++의 계측이 정상적으로 삽입되었는지 확인하기 위해 `readelf`와 `gdb`로 확인을 할 수 있다.

```shell
$ cd Engine/Binaries/Linux
$ readelf -Ws UE4Game-ASan | grep afl # 결과에 afl 관련 함수나 오브젝트가 보이면 적용이 된것.
$ gdb UE4Game-ASan
(gdb) disassemble 함수명 # 디스어셈블링된 코드 중에
						# 0x1dca682(%rip),%rax # 0x18f934a0 <__afl_area_ptr> <- 이런식으로 나오면 적용이 된것.
```

리눅스에서 게임을 실행시키기 위해서는 빌드한 UE4Game을 패키지 디렉토리에 옮기고 실행시키면 된다.


## 3. WinAFL 빌드
WinAFL은 Windows에서 데이케이트 서버에 대한 퍼즈 테스트를 위해 사용한 퍼저로 Visual Stduio 버전과 DynamoRio 위치는 각 환경에 맞추어주면 된다.

```batch
> git clone --recurse-submodules https://github.com/googleprojectzero/winafl.git
> cd winafl
> mkdir build64
> cd build64
> cmake -G "Visual Studio 16 2019" -A x64 .. -DDynamoRIO_DIR="C:\Users\kunsh\Desktop\DynamoRIO\cmake"
> cmake --build . --config Release
```

아래의 명령어로 퍼저를 실행시킨다.
```batch
> .\afl-fuzz.exe -debug -i "D:\Fuzzing\results\input\" -o "D:\Fuzzing\results\output\" -D "D:\Fuzzing\DynamoRIO-Windows-8.0.0-1\bin64" -t 5000 -- -covtype edge -coverage_module "D:\Unreal\Package\WindowsServer\Dedicated\Binaries\Win64\DedicatedServer.exe" -target_module "D:\Unreal\Package\WindowsServer\Dedicated\Binaries\Win64\DedicatedServer.exe" -target_offset 0x2632b50 -persistence_mode in_app -- "D:\Unreal\Package\WindowsServer\Dedicated\Binaries\Win64\DedicatedServer.exe"
```
```

`2_Methodology/2_Analysis/2.1_Introduction.md`:

```md
### 목차
- [1. 개요](#1-개요)

## 1. 개요
프로젝트를 통해 분석한 내용들 중에서 주요 내용 정리하고자 한다. 프로젝트 진행 중 연구한 내용을 전부 담으려고 노력을 하였지만 일부 내용의 경우 버그 바운티 정책상 공개가 불가능한 점 양해바란다.
```

`2_Methodology/2_Analysis/2.2_UE4_Features.md`:

```md
### 목차
- [2. UE4 기능 분석](#2-ue4-기능-분석)
	- [2.1. UE4 실행 과정](#21-ue4-실행-과정)
	- [2.2. UE4 패키징 옵션](#22-ue4-패키징-옵션)
	- [2.3. UE4 스레드 모델](#23-ue4-스레드-모델)

# 2. UE4 기능 분석
## 2.1. UE4 실행 과정
프로그램을 실행하게 되면 프로그램 진입함수는 `GuardedMain`을 호출하며 해당 함수는 `FEngineLoop::PreInit`가 호출된다.
```cpp
// LanchEngineLoop.cpp
int32 GuardedMain(const TCHAR* CMdLine)
{
	int32 ErrorLevel = GEnginLoop.PreInit(CmdLine);
```

`FEngineLoop::PreInit`에서는 필요한 모든 엔진, 프로젝트 및 플러그인 모듈을 로드하고 해당 모듈에서 클래스를 등록(COD)하고 제자리에 있어야하는 모든 하위 수준 시스템을 초기화한다. 해당 단계에서는 게임 개발자가 관여하지 않는다. 또한 개발한지 20년이 넘었지만 잘 작동되므로 큰 수정 없이 현재까지 사용되고 있다.

해당 함수를 호출하게 되면 다음 모듈들을 로드한다.
- LoadCoreModule
	- CoreUObject
- LoadPreInitModules
	- Engine
	- Rendere
	- AnimGraphRuntime
	- Rendering APIs (e.g. D3D12RHI)
	- SlateRHIRendere
	- Landscapde
	- RenderCore
- LoadStartupCoreModules
	- Core
	- Networking
	- HeadMountedDisplay
	- XAudio2
	- Messaging
	- MRMesh
	- SlateCore
	- Slate
	- UMG
	- Overlay
	- MediaAssets
	- ClothingSystemRuntimeNv
	- PacketHandler
	- NetworkReplayStreaming
- Project & Plugin : 프로젝트와 플러그인의 경우 활성화 되어 있을때만 호출된다.
	- EarliestPossibe
	- PostConfigInit
	- PostSplashScreen
	- PreEarlyLoadingScreen
	- PreLoadingScreen
	- PreDefault
	- Default
	- PostDefault

그다음 `GEngineLoop.Init()`에서는 Engine 구성파일을 확인하여 어떤 GameEngine 클래스를 사용해야 하는지 파악한다.(`UEitorEngine`, `UGameEngine`) 그리고 해당 클래스의 인스턴스를 만들고 Engine/Engine.h 에 선언된 전역 변수인 GEngine을 통해, 액세스 할 수 있는 전역 UEngine 인스턴스로 보관한다. 

그리고 `GEngine->Init(this)`에서, 지도가 로드되기 전에 자체적으로 초기화되고 GameInstance, GameViewportClient, LocalPlayer와 같은 몇가지 중요한 객체를 생성하고 초기화한다.
- GameInstance : 이전에 UEngine에서 처리되었던 프로젝트별 기능 중 일부를 처리하기 위해 분리된다.
- ViewportClinet : 화면으로 렌더링, 오디오 및 입력 시스템을 위한 상위 수준 인터페이스, 사용자와 엔진간의 인터페이스를 처리한다.
- LoadPlayer : 현재 게임을 하는 플레이어를 처리한다.

그후 `GEngine->Start()`에서 LoadMap 초기 호출을 담당한다. LoadMap(`UEngine::Loadmap`)이 성공적으로 실행되면 맵에 저장된 모든 액터가 포함된 UWorld와 GameFramework의 핵심을 형성하는 액터(게임모드, 게임상태, 플레이어 컨트롤러 등)가 생성된다.

`UEngine::Loadmap`은 게임 실행중 반복적으로 실행될 수 있다. 맵이 생성되는 것을 알리고, 이미 로드되어 있으면 로딩된 맵을 삭제한다. 그리고 .umap 파일로 직렬화된 UWorld, ULevel들을 메모리에 로딩한다. 로드된 UWorld로 GWorld를 초기화한다. WorldContext에 초기화되고 루트 세트에 추가되어 Garbage Collection을 방지한다. 그후 `InitWorld()`로 물리, 오디오 등의 시스템을 설정하고 `SetGameMode()`로 게임 모드가 액터를 생성하도록 요청한다. 만일 여기서 게임 모드가 존재하면 맵을 완전히 로드한다. 끝으로 `InitialieActorsForPlay`로 액터와 구성요소를 등록하고 InitGame 함수를 호출한다. 

추가로 `Gameframework Actor`는 `SpawnPlayActor` 함수를 호출하고 로그인 인증이 완료되면 PostLogin이 호출되며 플레이어가 합류하는데 필요한 모든 설정을 진행한다.

`BeginPlay`는 Engine → World → GameMode → WorldSettings로 모든 액터에 대해 루프를 알려준다. 모든 액터에서는 BeginPlay함수가 있으며 BeginPlay 이벤트를 블루프린트에서 시작한다. 즉 개발자가 정의한 코드를 실행한다고 볼 수 있다.

상세한 내용에 대해서는 다음 동영상을 참조하라.<br>
[The Unreal Engine Game Framework: From int main() to BeginPlay](https://www.youtube.com/watch?v=IaU2Hue-ApI)

## 2.2. UE4 패키징 옵션
UE4에서 게임을 패키징할 때 다양한 옵션을 설정할 수 있다. 이 중 분석에 필요한 일부 내용에 대해서 대략적으로 정리했다.

- Crypto (패키지 암호화와 관련한 옵션)
	- Encryption Key - 암호화에 사용되는 키이며 패키징시 하드 코딩되어 게임 실행파일에 저장된다.
	- Secondary Encrypion Keys - 보조 키
	- Encrypt Pak Ini Files
	- Encrypt Pak Index
	- Encrypt UAsset Files
	- Encrypt All Asset Files

- Packaging (패키징과 관련한 옵션)
	- Use Pak File - 체크시 모든 리소스를 Pak으로 압축해서 패키징을 한다.
	- Use Io Store
	- Make Binary Config
	- Generate Chunks
	- Generate No Chunks
	- Chunk Hard References Only
	- Build Http Cunk Install Data
	- Share Material Shader Code
	- Deterministric Shader Code Order
	- Shared Material Native Libraries

## 2.3. UE4 스레드 모델
Unreal Engine은 4.19버전 이후로 사용자의 환경에 맞추어 스레드를 생성할 수 있다. 스레드의 종류에는 크게 Game Thread(게임 스레드)와 Render Thread(랜더 스레드), Audio Thread(오디오 스레드)가 존재한다.

먼저 게임 스레드는 UE4Game의 메인 스레드로 다음과 같은 작업을 처리한다.
- 게임플레이
- 애니메이션
- 물리
- 네트워킹
- Thick : 한번의 프레임당 처리되는 이벤트

다음 랜더 스레드는 그래픽 렌더링과 관련된 스레드로 GPU와 통신하며 다음과 같은 작업을 처리한다.
- Depth prepass
- Base pass
- Translucency
- Velocity

마지막으로 오디오 스레드는 오디오 처리와 관련된 스레드로 랜더 스레드와유사하며 다음과 같은 작업을 수행하기 위해 로우 레벨 믹싱의 인터페이스 역할을 한다. 또한 오디오 스레드는 별도의 블루 프린트와 게임 플레이와 관련된 API와 상호작용한다.
- 디코딩 : 압축된 오디오 파일을 블록별로 디코딩하며 이중 버퍼링을 사용해 오디오를 재생하는 동안 디코딩을 진행한다.
- Soruce Worker : 샘플링 속도 변환, 공간화(HRTF), 효과 등 소스에 대한 처리를 수행하며 INI파일에서 해당 스레드의 갯수를 설정할 수 있다.
- Evaluating sound queue graph
- Building wave instances
- Handling attenuation, and so on

오디오 하드웨어 스레드는 플랫폼에 의존하는 서드 파티 영역의 단일 스레드로, 하드웨어에서 오디오를 랜더링을 하여 출력하는 스레드이다.

자세한 내용 같은 경우 다음 문서를 참조하라.<br>
[https://software.intel.com/content/www/us/en/develop/articles/intel-software-engineers-assist-with-unreal-engine-419-optimizations.html](https://software.intel.com/content/www/us/en/develop/articles/intel-software-engineers-assist-with-unreal-engine-419-optimizations.html)
[https://ikrima.dev/ue4guide/engine-programming/threading-model/](https://ikrima.dev/ue4guide/engine-programming/threading-model/)
```

`2_Methodology/2_Analysis/2.3_Resource_Analysis.md`:

```md
### 목차

- [3. 리소스 분석](#3-리소스-분석)
	- [3.1. Umap Fuzzing](#31-umap-fuzzing)
	- [3.2. Audio Fuzzing](#32-audio-fuzzing)
	- [3.4. AssetRegistry.bin Fuzzing](#34-assetregistrybin-fuzzing)
	- [UnrealInsights Fuzzing](#unrealinsights-fuzzing)
	- [Niagara Fuzzing](#niagara-fuzzing)

# 3. 리소스 분석
## 3.1. Umap Fuzzing
AFL++으로 퍼징하였으며 상세한 파일분석 없이 전체 파일을 뮤테이션 하는 방법으로 퍼징을 하였다. 기본적으로 Shipping 구성으로 빌드를 하였으며 효율적인 퍼징을 위해 간단한 게임을 제작하였다.

타겟으로 한 게임은 예제로 제공되는 게임 프로젝트를 선택하였으며 블루프린트를 사용하도록 생성하였다. 

AFL++의 경우 종료 코드를 기반으로 해당 실행 파일이 정상적으로 종료되었는지 크래시로 인해 종료되었는지를 파악하며 지정된 시간이 지나면 타임아웃으로 처리하기 때문에 게임 레벨 블루프린트에서 게임이 시작되지마자 종료되게 설정했다.

![image](https://user-images.githubusercontent.com/86822726/143765515-9b7cb887-a231-4ea9-bcaf-b87413e23b4c.png)

그리고 게임 패키징 시에 특정 맵을 불러오도록 설정한다. `패키지 세팅->맵&모드`에서 설정이 가능하며 퍼징시에 이 맵파일을 퍼징했다.

![image](https://user-images.githubusercontent.com/86822726/143766286-85ed3cec-11b3-4a78-a8d0-cdc35bff5bfc.png)

아래의 옵션으로 AFL++를 실행시켰다. mutate된 값을 -f 옵션을 통해 Fuzz02/Content/Untitled.umap으로 저장했다.
```shell
./afl-fuzz -i /PATH/OF/INPUT/ \
-o /PATH/OF/OUTOUT \
-t 10000 \
-f /PATH/OF/MUTATED/FILE \
-- /PATH/OF/TARGET/UE4Game-Linux-Shipping \"/RELATIVE/PATH/OF/UPROJECT\" # /RELATIVE/PATH/OF/UPROJECT의 경우 UE4Game-Linux-Shipping을 기준으로 상대경로를 입력해야 된다. 자세한 것은 빌드된 프로젝트 디렉토리의 쉘 스크립트 파일을 참조하라.
```

아래는 실행 화면이다. 30분 이후부터 Path와 Crash를 발견하기 시작했다.
![image](https://user-images.githubusercontent.com/86822726/143766361-7b552fda-236e-4b3f-b4fa-24a57f6bb115.png)

결과적으로 Stack Buffer Overflow, Heap Buffer Overflow, Use After Free의 크래시들을 찾을 수 있었으며 유효한 익스플로잇을 찾을 수 있었으나 상세한 루트 커즈는 버그바운티 정책상 공개가 불가능하다는 점 양해바란다.

## 3.2. Audio Fuzzing
게임을 개발할때 사용되는 UE4Editor(이하 에디터)에서는 WAV파일을 임포트할 수 있다. 잘못된 파일을 업로드할 시에 오류가 발생하며 이에 대한 검증은 `Engine\Source\Runtime\Engine\Private\Audio.cpp`에서 수행한다.

에디터에서의 검증 조건에는 다음과 같다.
- RIFF의 Format은 "WAVE", FMT의 Chunk ID는 "fmt ", DATA의 Chunk ID는 "data" 여야한다.
- DATA Chunk 는 (FMT offset + FMT Chunk Size)의 위치에 존재해야한다.
- FMT Audio Format은 0x1, 0x2, 0x11 셋 중 하나의 값을 가져야한다.

WAV 파일을 퍼징하기 위해서 Peach Fuzzer를 이용하였으며 다음과 같은 XML 파일을 작성하였다.

```xml
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach /peach/peach.xsd">
	
	<!-- Defines the common wave chunk -->
	<DataModel name="Chunk">
		<String name="ID" length="4" padCharacter=" " />
		<Number name="Size" size="32" >
			<Relation type="size" of="Data" />
		</Number>
		<Blob name="Data" />
		<Padding alignment="16" />
	</DataModel>

	<DataModel name="ChunkData" ref="Chunk">
		<String name="ID" value="data" token="true"/>
	</DataModel>

	<DataModel name="ChunkFact" ref="Chunk">
		<String name="ID" value="fact" token="true"/>
		<Block name="Data">
			<Number size="32" />
			<Blob/>
		</Block>
	</DataModel>
...후략
```

또한 추가로 아래와 같이 DataModel을 수정하면 원하는 포맷 및 영역만 뮤테이션이 가능하다.

뮤테이션의 경우 Peach Fuzzer를 이용하였으며 실행의 경우 자체적인 덤 퍼저를 작성하여 사용하였다. 

```python
from threading import Timer
from datetime import datetime, timedelta
from glob import glob
from hashlib import md5

import subprocess
import time
import os
import shutil


count = 0

class Fuzzer():
	def __init__(self):
		self.peach_path = os.getcwd()+r"\peach-3.0.202-win-x64-debug\peach-3.0.202-win-x64-debug"
		self.target = r"C:\Soundseed\test.wav"
		timeout = 5	
		path = r"..\SoundFuzzGame\WindowsNoEditor\DebugTest05.exe"
		crashes_path = r"..\SoundFuzzGame\WindowsNoEditor\DebugTest05\Saved\Crashes"
		self.proc = subprocess.Popen(path)
		try:
			self.proc.wait(timeout=timeout)
		except subprocess.TimeoutExpired:
			subprocess.Popen("TASKKILL /F /PID {pid} /T".format(pid=self.proc.pid))
			time.sleep(1)
			self.mutator()

		crashes = glob(crashes_path + "*")
		if crashes != []:
			print("crash!")
			dest = md5(datetime.now().strftime("%Y%m%d%H%M%S%f").encode()).hexdigest()
			print(dest)
			os.mkdir(r'./SoundCrashLogs/{0}'.format(dest))
			try:
				shutil.move(crashes[0], r'./SoundCrashLogs/{0}/'.format(dest))
				shutil.move(self.target, r'./SoundCrashLogs/{0}/'.format(dest))
				#shutil.rmtree(crashes_path)
			except PermissionError:
				print("PermissionError")
				pass
	
	def mutator(self):
		global count
		count += 1
		print(count)
		proc = subprocess.Popen([self.peach_path+"/peach", "--range", "1,1", self.peach_path+"/2.xml"])
		proc.wait()
		

while True:
	fuzzer = Fuzzer()
```

## 3.4. AssetRegistry.bin Fuzzing
[Umap Fuzzing](#31-umap-fuzzing)과 비슷하게 AFL++을 사용하여 퍼징을 진행하였으며 유효한 크래시를 찾을 수 있었다. 상세한 크래시 분석을 위해 간단히 AssetRegistry.bin에 대한 분석을 진행하였다.

대략적인 파일의 구조는 아래와 같다.
```
0x00~0x0F : Hash값으로 추정
0x10~0x13 : AssetRegistryNumberedNameBit (0x8)로 고정됨  (uint32)
0x14~0x17 : Num (uint32)
0x18~0x1B : NumStringBytes (uint32)
0x1C~0x23 : HashVersion (uint64)
0x24 ~ + (8 * Num) : SavedHashes
	 ~ + (sizeof(FSerializedNameHeader) * Num) : Headers
	 ~ + NumStringBytes : Strings
	 ~ EOL : Data
```

## UnrealInsights Fuzzing
UnrealInsights는 UE4에서 데이터를 수집하고, 이것을 분석하고 시각화 해주는 프로 파일링 시스템이며 계측 삽입에 어려움이 있어 AFL++의 덤 퍼징 기능을 사용하여 퍼징을 하였다. 사전 녹화된 세션인 .utrace에 대해서 퍼징을 수행하였지만 Integer Underflow 단순 버그만 찾고 유효한 크래시를 발견하지 못하였다.

## Niagara Fuzzing 
UE4 내부에서 비주얼 이펙트(VFX)를 생성하고 조정할 수 있는 툴인 Niagara VFX System에 대해서 퍼징을 수행하였지만 별다른 유효한 크래시를 발견하지 못하였다.

```

`2_Methodology/2_Analysis/2.4_Network_Analysis.md`:

```md
### 목차
- [4. 네트워크 분석](#4-네트워크-분석)
	- [4.1. Pixel Streaming](#41-pixel-streaming)
	- [4.2. RPC](#42-rpc)
		- [4.2.1 개요](#421-개요)
		- [4.2.2. 패킷 구조 분석](#422-패킷-구조-분석)
			- [4.2.2.1. 메시지 전송](#4221-메시지-전송)
			- [4.2.2.2 메세지 수신](#4222-메세지-수신)

# 4. 네트워크 분석
## 4.1. Pixel Streaming
먼저 Pixel Streaming은 원격지에 있는 게임을 브라우저를 통해 플레이하거나 시청할 수 있는 기능으로 UE4 4.27에 추가된 신기능이다. 기본적으로 다수의 사용자가 한 게임에 접속할 경우 Input을 공유해 함께 컨트롤하게 된다.

Pixel Streaming은 총 3개의 서버를 요구한다.
-Signaling 서버 (STUN,TURN,ICE)
-Web 서버 (브라우저에서 접속했을 때 보여질 페이지)
-WebRTC 프록시 서버

시그널링 서버를 통해서 P2P 연결을 수립한다. 기본적으로 다 NAT를 사용하고, 사용자들은 대부분 사설 IP를 할당받은 상태이기 때문에 NAT Traversal 기술을 이용해야 한다.

STUN 서버 : 익히 알려진 UDP 홀펀칭의 개념이다. NAT 의 존재 유무를 판단하여 NAT 뒤에 있는 사용자와 P2P 연결을 해준다.
TURN 서버 : NAT 자체가 표준이 확실하게 정해지지 않았다. 그러므로 STUN 서버에서 연결을 할 수 없으면 패킷을 릴레이 해준다.
ICE 프레임워크 : STUN+TURN 해서 NAT Traversal 을 해준다.

아래는 데모 소스코드를 통한 분석 결과이다.

`app.js` , `webRTCPlayer.js` 는 클라이언트에서 실행되는 자바스크립트 코드이다. `cirrus.js` 는 서버측에서 실행되는 node.js 코드로 백엔드와 시그널링 서버역할을 담당한다. WebRTC 프록시 서버는 따로 언리얼 측에서 만들어서 실행하면 된다. 

비디오의 경우 WebRTC의 Media Stream API를 이용하여 Stream 형식으로 전달된다. 사용자의 Input과 사용자가 서버에 전송하는 메세지들은 WebRTC의 Data Channel을 이용하여 전달되며 서버측에서 클라이언트로 보내는 메세지도 Data Channel을 이용하여 전달된다. 

그리고 프록시에서 언리얼 엔진으로 값이 전달될 때는 Data Channel 인터페이스를 통해서 전달되었는데 이는 Chromium에서 사용하는 WebRTC 코드와 동일하기 때문에 이곳에서 취약점을 찾는 것은 프로젝트 취지에 맞지 않아 보인다.

이용자가 접속했을 때에는 `FPlayerSession` 클래스를 이용하여 플레이어의 세션이 만들어지며 각 세션마다 DataChannel이 제공된다. 각 플레이어는 `PlayerID`를 통해서 구분되는데 데모에서는 0에서 차례대로 1씩 증가하며 부여되는 것으로 확인된다. `PlayerID` 는 `cirrus.js` 코드에서 처리된다. 언리얼 엔진단에서는 플레이어가 접속할 경우 `FPlayerSession::OnOffer` 에서 영상을 보낼 때 필요한 인코딩 방식, 비트레이트 등을 설정해준다.

`Data Channel` 에 메세지가 전달되면 `webrtc::DataChannelObserver` 를 상속받은 `FPlayerSession::OnMessage` 콜백에서 메세지를 처리한다. 이때 처리되는 메세지 타입은 4가지로 `RequestQualityControl` , `LatencyTest` , `RequestInitialSettings` , `Input` 이다. 마지막 `Input`의 경우에는, 사용자가 보낸 입력을 파싱한다. 

코드 오디팅으로 파싱하는 과정에서 취약점이 발생할 것으로 파악하고 해당 내용에 대해서 버그 바운티를 제보하였으며 유효한 취약점으로 인정받을 수 있었다. 상세한 루트커즈의 경우 공개가 불가능하다는 점 양해바란다.

## 4.2. RPC
### 4.2.1 개요
RPC는 Remote Procedure Call의 약자로 다른 프로세서나 다른 네트워크로 분리된 프로세스에서 특정한 코드를 실행시키는 통신 방식이다.

UE4에서 서버에서 함수를 호출해 클라이언트에서 실행되는 RPC의 선언은 다음과 같다.
```cpp
UFUNCTION( Client )
void ClientRPCFunction();
```

클라이언트에서 함수를 호출해 서버에서 실행되는 RPC의 선언은 다음과 같다.
```cpp
UFUNCTION( Server )
void ServerRPCFunction();
```

서버에서 호출해 등록된 모든 클라이언트에서 실행되도록 하는 Multicast RPC는 다음과 같이 선언할 수 있다.
```cpp
UFUNCTION( NetMulticast )
void MulticastRPCFunction();
```

RPC는 서버에서 RPC를 수행해도 액터를 실제로 '소유'하고 있는 클라이언트에서만 함수가 실행되며 기본적으로 RPC는 보안에 취약하기 때문에 비신뢰성이다. 그래서 UE4에서 패치로 통해 RPC에 인증 함수를 추가하는 기능을 추가하였다. 아래와 같이 WithValidation 키워드를 추가하는 것으로 인증 함수를 사용할 수 있으며 실행 함수 주변에 Validate 함수를 추가해 주는 것으로 기능을 사용할 수 있다.
```cpp
UFUNCTION( Server, WithValidation )
void SomeRPCFunction( int32 AddHealth );
```

```cpp
bool SomeRPCFunction_Validate( int32 AddHealth )
{
if ( AddHealth > MAX_ADD_HEALTH )
    {
        return false;                       // This will disconnect the caller
    }
    return true;                              // This will allow the RPC to be called
}

void SomeRPCFunction_Implementation( int32 AddHealth )
{
    Health += AddHealth;
}
```

RPC는 다음과 같이 처리된다.
```
RPC 처리 과정 (클라이언트 → 서버)

1. 클라이언트에서 RPC를 호출
- NetDriver 및 NetConnection을 통해 RPC를 호출하는 액터 채널로 전달
- 액터 채널은 RPC '식별자와 매개변수, 액터 채널의 ID'를 bunch로 직렬화
- 액터 채널은 NetConnection에 bunch를 보내도록 요청
- NetConnection은 데이터를 패킷으로 결합해 서버로 전송
- 서버의 NetDriver가 패킷을 수신
- 서버에서 패킷의 주소를 확인하고 패킷을 NetConnection으로 전달
- NetConnection은 패킷을 bunch로 분해
- NetConnection은 bunch의 채널 ID를 확인해서 해당 액터 채널로 라우팅
- 액터 채널은 bunch를 디코딩해서 해당 함수를 호출
```

`NetDriver`는 `UNetConnections`과 이들 사이에서 공유할 수 있는 데이터를 관리하는 역할을 한다.

- Game NetDrvier : 표준 게임 네트워크 트래픽을 담당
- Demo NetDriver : 이전에 녹화된 게임 데이터 재생
- Beacon NetDriver : 표준 네트워크 트래픽에 속하지 않는 트래픽을 담당

`NetConnections`은 `NetDriver`에 연결된 단일 클라이언 를 나타낸다. 각 `NetConnection`에는 고유한 채널 집합이 있으며 데이터를 알맞는 채널로 라우팅한다. 

채널의 종류는 다음과 같다.
- ControlChannel : 연결상태(연결 종료 여부 등)에 대한 정보를 송수신한다.
- VoiceChannel : 클라이언트와 서버간에 음성 데이터를 송수신한다.
- ActorChannel_N : 서버에서 클라이언트로 복사된 액터들은 고유한 채널이 있다. 대부분의 UE4의 동기화 기능은 액터 채널을 중심으로 이루어진다.

일반적인 상황에선 클라이언트와 서버 각각 하나의 NetDriver만 사용한다. 서버 NetDriver는 액터의 데이터 복사를 담당한다. 

UE4에서는 기본 네트워크 프로토콜은 신뢰성을 보장할 수 없다고 가정한다. 따라서, 패킷과 bunch는 신뢰성을 위해 각각 일련 번호를 설정한다. 패킷을 전송할 때 동일한 패킷 번호로 다시 패킷을 전송하지 않으며, bunch의 일련 번호는 각 채널마다 부여되며 전송될때마다 증가한다. UE4에서는 일련 번호를 가지고 드랍된 패킷을 감지한다.

분석했을 때 아래의 코드에서 최종적으로 RPC 패킷을 전송하는 것으로 확인했다. 또한 패킷을 받을 때에도 해당 코드 위치에 있는 `RecvFrom()` 함수를 이용하는 것으로 확인했다. 이때 패킷의 마지막 바이트가 Null인 경우 MalformedPacket으로 판단한다.
```cpp
// Engine/Source/Runtime/Sockets/Private/BSDSockets/SocketsBSD.cpp
bool FSocketBSD::SendTo(const uint8* Data, int32 Count, int32& BytesSent, const FInternetAddr& Destination)
{
	// TODO: Consider converting IPv4 addresses to v6 when needed
	if (Destination.GetProtocolType() != GetProtocol())
	{
		UE_LOG(LogSockets, Warning, TEXT("Destination protocol of '%s' does not match protocol: '%s' for address: '%s'"),
			*Destination.GetProtocolType().ToString(), *GetProtocol().ToString(), *Destination.ToString(true));
		return false;
	}

	const FInternetAddrBSD& BSDAddr = static_cast<const FInternetAddrBSD&>(Destination);
	// Write the data and see how much was written
	BytesSent = sendto(Socket, (const char*)Data, Count, 0, (const sockaddr*)&(BSDAddr.Addr), BSDAddr.GetStorageSize());

//	NETWORK_PROFILER(FSocket::SendTo(Data,Count,BytesSent,Destination));

	bool Result = BytesSent >= 0;
	if (Result)
	{
		LastActivityTime = FPlatformTime::Seconds();
	}
	return Result;
}
```

데디케이티드 서버와 관련여  UE4에서 사용하는 포트는 다음과 같다. UE4Editor에선 17777을 사용한다.
- Server Port Start : 7777
- Beacon Porat Start : 15000
- UE4Editor : 17777


아래부턴 리슨 서버 에서 RPC 패킷을 분석한 내용이다. 먼저, 아래 그림은 와이어샤크를 통해 특정 포트 필터링 없이 루프백 패킷을 캡쳐했을 때 이다. 데이터에 UE4, Rpc란 키워드가 있는걸로 보아 이 패킷 또한 UE4네트워크 관련 패킷이라고 추측한다. RPC 패킷은 서버인 17777포트에서 통신되기 때문에 이 부분에 대한 분석은 제외한다.

![image](https://user-images.githubusercontent.com/77185602/145812288-bf722248-49a2-4bc0-8db3-60c13fda9ef0.png)

### 4.2.2. 패킷 구조 분석

- TSequenceHistory

수신된 일련번호를 관리하기 위해 사용되며 일반적으로 패킷을 받으면 `Ack` 또는 `Nak`이 생성된다. `Ack`은 1, `Nak`은 0이며 순서대로 `Storage`에 기록된다. `Storage`는 uint32 배열로 최대 256비트까지 저장할 수 있고 `MaxSequenceHistoryLength`를 초과하면 `FlushNet`을 통해 즉시 전송된다.

- FNetPacketNotify

NetPacketNotify는 시퀀스 번호의 전송, 확인과 패킷 헤더 데이터, `Ack` 수신 등 관련 처리를 포함해 시퀀스 데이터의 신뢰성을 실현하는 데 사용된다.

- FNotificationHeader

네트워크 데이터의 패킷 헤더 구조이며 각 데이터 패킷은 현재 일련 번호 정보를 전달한다. `OutSeq`는 `FlushNet`이 패킷을 보낼 때 자동으로 증가하는 송신 시퀀스 번호이며, `InAckSeq`는 수신 시퀀스 번호, 패킷을 받으면 `Ack`이든 `Nak`이든 자동으로 증가하게 된다. `WrittenHistoryWordCount`는 과거 시퀀스 번호의 수를 나타낸다. 패킷 헤더가 직렬화되면 uint32 타입으로, 14비트 `Seq`와 14비트 `AckedSeq` 및 4비트 `HistoryWordCount`로 압축된다.

![image](https://user-images.githubusercontent.com/86822726/144710453-c453be5a-917b-4a2d-943e-88e4c3c38b97.png)

#### 4.2.2.1. 메시지 전송
메시지 전송은 `UChannel`을 통해 처리되고 `UChannel::SendBunch`를 호출해서 통합처리 된다. 전송된 Bunch는 `FOutBunch` 형식이고 `bReliable`이 `True`이면 신뢰할 수 있음을 의미한다.

**1. Judging the upper limit**

`SendBunch`에서 현재 Bunch의 크기가 제한을 초과하는지 판단한다. `IsBunchTooLarge`는 64K를 초과여부를 판단한다.

**2. Consider merging**

경우에 따라 데이터를 병합할 수 있고, 동일한 채널은 동일한 신뢰성을 가진다. 병합 후 단일 Bunch의 제한을 초과하지 않으면 Bunch로 병합될 수 있다. `Actor`가 초기화될 때 `NetGUID` 관련 정보를 동기화해야 하는 경우에는 병합되지 않아야 한다.

**3. Consider splitting**

Bunch의 사이즈가 제한을 초과하면 더 작은 Bunch들로 쪼개지며 분할된 Bunch의 `bPartial`의 값은 1이된다. `bPartialInitial = 1`은 분할된 Bunch의 첫번째를 의미하고 `bPartialFinal = 1`은 마지막을 의미한다. `bOpen`과 `bClose`는 각각 첫 번째 및 마지막 Bunch와 관련이 있다.
```cpp
// DataChannel.cpp::1067
// MAX_SINGLE_BUNCH_SIZE_BITS = 7625
// MAX_PARTIAL_BUNCH_SIZE_BITS = 7624

if( Bunch->GetNumBits() > MAX_SINGLE_BUNCH_SIZE_BITS )
```

**4. Judgment overflow**

Bunch의 limit인 `GCVarNetPartialBunchReliableThreshold`가 설정되어 있을 때 만일 분할 목록의 `OutgoingBunches` 수가 임계값을 초과하고, 신뢰할 수 있는 리스트가 버퍼 크기를 초과하지 않는다면 신뢰할 수 있는 것으로 표시되고 모든 `Ack`이 수신될 때까지 복제가 일시 중단된다. 여기서 신뢰할 수 있는 리스트가 오버플로우되면 연결이 닫히게 된다. 이때 `NumOutRec`는 현재 신뢰할 수 있는 Bunches의 수이므로 신뢰할 수 있는 Bunches의 수는 최대 256개이다.
```cpp
// DataChannel.cpp::1110
// RELIABLE_BUFFER = 256

const bool bOverflowsReliable = (NumOutRec + OutgoingBunches.Num() >= RELIABLE_BUFFER + Bunch->bClose);
```

**5. Reliable Bunch preprocessing**

`SendRawBunch`를 호출하기 전, 전처리 단계가 존재한다. 전처리 단계에서 Bunch가 `reliable`할 때 `PrepBunch`를 실행한다.
- `OutReliable`은 각 채널의 신뢰할 수 있는 Bunch 수량을 저장하고, Bunch의 채널 일련 번호인 `ChSequence`를 초기화한다. 이때 각 채널의 신뢰할 수 있는 Bunch의 일련 번호가 증가
- 신뢰할 수 있는 데이터 패킷 수(NumOutRec)를 조정
- 재전송을 위해 `OutRec`에 추가 (이때 신뢰할 수 있는 Bunch만 저장)
```cpp
DataChannel.cpp::1237
Bunch->Next	= NULL;
Bunch->ChSequence = ++Connection->OutReliable[ChIndex];
NumOutRec++;
OutBunch = new FOutBunch(*Bunch);
FOutBunch** OutLink = &OutRec;
while(*OutLink) // This was rewritten from a single-line for loop due to compiler complaining about empty body for loops (-Wempty-body)
{
	OutLink=&(*OutLink)->Next;
}
*OutLink = OutBunch;
```

**6. SendRawBunch**

> `UChannel::SendRawBunch`

`Ack` 확인 플래그인 `ReceivedAck`은 0으로 재설정된다. 채널 상태는 `bClose` 플래그에 따라 설정되며, 현재 채널의 `OutBunch`는 `UNetConnection`으로 전달된다.

**7. SendRawBunch**

> `UNetConnection::SendRawBunch`

 `TimeSensitive` 플래그를 1로 설정하고, 현재 `OutBunch`를 `SendBuffer`에 기록한다. 이때 버퍼가 가득 차면 `FlushNet`이 즉시 호출되어 전송된다. 현재 버퍼에 쓰기 전에 `PrepareWriteBitsToSendBuffer` 함수를 호출하여 현재 Bunch가 버퍼에 쓰여진 후 오버플로우 여부를 결정하게 된다. 만일 오버플로우 상태이면 `FlushNet`을 호출하여 즉시 전송하고 `SendBuffer`를 초기화한다.

**8. Timing of sending**

일반적으로 `UNetConnection::Tick`이 호출되면, `sensitive mark` 또는 `timeout`이 있는지 확인한다. `TimeSensitive`를 보고 즉시 보낼지에 대한 여부를 결정한다. 예를 들면, `SendRawBunch`를 호출하거나 `DirtyAcks`로 패킷을 수신한다. 
```cpp
// NetConnection.cpp::3638
// KeepAliveTime = 0.2
// Flush.
	if ( TimeSensitive || (Driver->GetElapsedTime() - LastSendTime) > Driver->KeepAliveTime)
	{
		bool bHandlerHandshakeComplete = !Handler.IsValid() || Handler->IsFullyInitialized();

		// Delay any packet sends on the server, until we've verified that a packet has been received from the client.
		if (bHandlerHandshakeComplete && HasReceivedClientPacket())
		{
			FlushNet();
		}
	}
```

**9. send**

`FlushNet`이 호출되면 `TimeSensitive`가 리셋되고 Sending Buffer에 데이터가 있는지, ack 패킷인지, 하트비트 패킷인지를 보내기 전에 판단한다. 
```cpp
// NetConnection.cpp::1427
TimeSensitive = 0;

	// If there is any pending data to send, send it.
	if (SendBuffer.GetNumBits() || HasDirtyAcks || ( Driver->GetElapsedTime() - LastSendTime > Driver->KeepAliveTime && !IsInternalAck() && State != USOCK_Closed))
	{
		// Due to the PacketHandler handshake code, servers must never send the client data,
		// before first receiving a client control packet (which is taken as an indication of a complete handshake).
		if (!HasReceivedClientPacket() && CVarRandomizeSequence.GetValueOnAnyThread() != 0)
		{
			UE_LOG(LogNet, Log, TEXT("Attempting to send data before handshake is complete. %s"), *Describe());
			Close();
			InitSendBuffer();
			return;
		}
```
 
이후 실제로 패킷을 보내는 최하위 부분인 `FSocketBSD::SendTo`로 도달한다. 패킷을 전송한 후 `InitSendBuffer()`를 호출해서 sending buffer를 초기화 한다. 

`SendTo`에서 Destination구조는 아래와 같다. 이때 빨간색 부분이 포트, 노란색 부분이 주소이다.

![image](https://user-images.githubusercontent.com/86822726/144711196-89536586-43c3-4818-933d-3236e0e499a8.png)

아래는 `SendTo`의 콜스택이다.

![image](https://user-images.githubusercontent.com/86822726/144711242-1be30afc-9f15-4cdb-aec8-fdf2c2cd8c0d.png)

패킷을 캡쳐하는 과정에서 UdpMessage에서 6666포트로 핑하는게 잡힌다. 이는 Transport관련 기능으로 해당옵션을 [프로젝트 세팅->플러그인 - UDP메시징-> 트랜스포트 비활성화] 함으로써 분석을 보다 깔끔하게 할 수 있다.

#### 4.2.2.2 메세지 수신

아래는 직접 만든 RPC함수인 `MyServerFunc()`의 콜스택이다.

![image](https://user-images.githubusercontent.com/77185602/145812182-5748093c-2058-4e86-8d6c-556a81fbd688.png)

**1. TickDispatch**

> `UIpNetDriver::TickDispatch`

패킷을 수신한 다음 해당 `NetConnection`에 배포하는 역할을 한다. 수신된 모든 패킷은 패킷 반복자 `FPacketIterator`를 통해 구현되며, 각 반복은 `AdvanceCurrentPacket`을 호출하여 패킷을 가져오고 하위 계층도 `FSocketBSD::RecvFrom`을 호출하여 수신한다. 이 과정에선 패킷 처리를 위한 ReceivedRawPacket 함수가 있으며 빈 패킷과 같은 DDoS 탐지 기능도 수행한다.

![image](https://user-images.githubusercontent.com/86822726/144711509-1dd57893-9a0b-4c4a-a08b-a5ccd428a958.png)

또한 `IpNetDriver`에서 패킷을 수신하고 있다.

![image](https://user-images.githubusercontent.com/86822726/144711537-891e7ab0-176e-4a8e-a48c-30d65943d007.png)

**2. ReceivedRawPacket**

> `UNetConnection::ReceivedRawPacket`

이름대로 raw packet을 수신해 역직렬화하고 이를 `ReceivedPacket`에 전달한다. 이 과정에선 수신 또는 송신 패킷의 핸드셰이크, 확인, 암호화, 압축 등과 같은 동작이 `PacketHandler`에서 처리된다.

![image](https://user-images.githubusercontent.com/86822726/144711602-89f457db-c581-4779-a9fb-7c57608aa9ef.png)

이때 패킷 데이터의 마지막 바이트는 Null이면 안된다. `PacketHandler.cpp`에서 아래의 `Incoming`함수 내부의 `ReplaceIncomingPacket()`에서 패킷이 역직렬화하는 것을 확인할 수 있었다.

![image](https://user-images.githubusercontent.com/86822726/144711643-4ea841a5-be8c-4906-b9ec-f9119cd942fc.png)

![image](https://user-images.githubusercontent.com/86822726/144711663-c617a8fe-c129-4f7a-99fe-9e71acd6b09e.png)

또한 비트들을 역직렬화 하면서 `BitReader.h:42`에서 `SerializeBits()`를 호출한다. Unreal에선 직렬화와 역직렬화 코드가 동일하다.

![image](https://user-images.githubusercontent.com/86822726/144711692-94e196e4-01db-4b37-bb82-1cc798aca651.png)

![image](https://user-images.githubusercontent.com/86822726/144711704-1794bc5e-81e8-4ff3-8a3e-4e9343996db7.png)

`SerializeBits()`함수 안에서 `appBitsCpy()`를 통해서 아래 전달된 패킷을 다음과 같이 역직렬화한다.

![image](https://user-images.githubusercontent.com/86822726/144711826-0cc8b9fa-81ef-4c76-9577-2086edf6aa2d.png)

![image](https://user-images.githubusercontent.com/86822726/144711831-58711c98-1728-4e39-9b28-bfc50d4deda7.png)

이후 `UnProcessedPacket` 객체의 `Data` 변수에 역직렬화된 패킷 데이터가 들어간다. CountBits를 보면 0x217로 `f9 20 7c` 까지만 패킷 데이터에 해당한다. 이는 UE4가 패킷 중 플래그를 비트단위로도 처리하기 때문에 MSB(Most Significant Bit)까지만 계산해서 `CountBits`에 할당한다. 

![image](https://user-images.githubusercontent.com/86822726/144711843-9327a54f-6cad-4bff-afc5-3d7724b34d77.png)

그리고 다시 한번 더 마지막 바이트인 0x7c가 Null인지 확인한다. 만일 마지막 바이트가 Null이면 `MalformedPacket`으로 판단한다. 이때 0x80(1000 0000)과 and 연산으로 MSB를 계산한다.

![image](https://user-images.githubusercontent.com/86822726/144711935-70bb2075-93ea-48fa-8a97-20672ec260fa.png)

**3. ReceivedPacket**

> `UNetConnection::ReceivedPacket`

- 패킷 손실을 감지한다.
- 패킷의 헤더 정보를 읽고, 헤더에 포함된 일련 번호 정보와 마지막으로 성공적으로 수신된 일련 번호에 따라 일련 번호의 증가를 판단하게 된다.
- 일련 번호의 차이가 1보다 크면 패킷의 손실이 발생했음을 의마하며 이때는 패킷을 즉시 처리하지 않고 현재 패킷을 `PacketOrderCache`큐에 추가한다. 만일 1보다 작으면 수신된 패킷의 순서가 어긋난 경우이므로 이 경우 유효하지 않은 패킷으로 판단해 무시한다. 또한 패킷은 순서대로 수신되며, 고유한 일련 번호는 재사용되지 않는다.

- `TickDispatch`로 현재 프레임의 모든 데이터 패킷을 수신한 후 `PostTickDispatch`를 호출한다. 여기서  `FlushPacketOrderCache` 함수가 다시 호출되어 이전에 캐시된 데이터 패킷을 처리한다. 여기서 `DeltaTime`은 현재 `Tick`의 시간 차이이다.
```cpp
void UPendingNetGame::Tick( float DeltaTime )
{
	check(NetDriver && NetDriver->ServerConnection);

	// Handle timed out or failed connection.
	if (NetDriver->ServerConnection->State == USOCK_Closed && ConnectionError == TEXT(""))
	{
		ConnectionError = NSLOCTEXT("Engine", "ConnectionFailed", "Your connection to the host has been lost.").ToString();
		return;
	}
	NetDriver->TickDispatch(DeltaTime);
	if (NetDriver) {
		NetDriver->PostTickDispatch();
	}
	if (NetDriver) {
		NetDriver->TickFlush(DeltaTime);
	}
	if (NetDriver) {
		NetDriver->PostTickFlush();
	}
}
```

![image](https://user-images.githubusercontent.com/86822726/144712135-8e4c8c1b-f864-4965-ac81-b6a0cf885ac4.png)

`GetBitsLeft()`는 Reader의 `Num - pos`로 남은 비트 수를 계산한다.

**4. Parse the data packet header**

들어오는 각 데이터 패킷은 `PacketNotify`의 시퀀스 번호 정보를 업데이트해야 한다. 그리고 패킷 헤더에 실린 일련번호 데이터에 따라 현재 확인된 일련번호의 개수를 계산한 후 `AckRecord`에 따라 `InAckSeqAck`를 업데이트한다. 만일 `SequenceHistoryT::Size = 256`을 초과하면 `Nak`을 받은 것으로 간주한다. 이후 일련번호 이력(History Storage)에서 `Ack`인지 `Nak`인지를 판단해 해당 처리 함수를 호출한다.

아래는 패킷이 들어와서 역직렬화된 값이다. `0x0f2b3590`은 `Header`의 `Seq`와 `AckedSeq`에 사용되고 `0xffffffff`은 `History`에 저장된다. NetPacketNotify.cpp에서 아래의 연산을 통해 계산한다.

`Seq = Packed >> SeqShift(0x12) & SeqMask(0x3fff)`

`AckedSeq = Packed >> SeqShift(0x04) & SeqMask(0x3ffff)`

![image](https://user-images.githubusercontent.com/86822726/144712305-556a9e0d-3a89-43bb-a57c-2a2a8111ada0.png)

![image](https://user-images.githubusercontent.com/86822726/144712338-0dc7443e-39d7-4401-b686-f8efdc064ea2.png)


**5. Receive Ack**

`Engine\Source\Runtime\Engine\Private\NetConnection.cpp:1728`

 Ack이 수신되면, 현재 확인된 동일한 패키지 id를 가진 bunch에 대한 플래그 비트(ReceivedAck)가 수정된다. 확인된 메시지 bunch는 `OutRec` 리스트에서 삭제된다.

**6. Receive Nak**

`Engine\Source\Runtime\Engine\Private\NetConnection.cpp:1767`

`reliable Bunch`를 보내게 되면, 수신된 `unconfirmed reliable messages` 리스트인 `OutRec`에 추가된다. 만일 `Nak`을 수신하면, `unconfirmed reliable data`의 패킷 id가 `NakPacketId`인 각 채널에 `unconfirmed reliable data`를 재전송한다. 

만약 패킷 손실이 발생하면, Bunch에 따라서만 재전송되게 된다. 이때 bunch의 `sequence number`는 여전히 원래 채널의 `sequence number`이다. 또한 이전 패킷은 재사용되지 않고 항상 새로운 패킷이 생성되며 최신 PacketId가 생성된다. 즉 이전에 전송된 데이터 패킷은 재전송되지 않고, 데이터 패킷 `sequence number`를 재사용하지 않는다.  데이터 패킷을 전송할때마다, 새로 생성된 데이터 패킷과 증가한 `sequence number`이게 된다.

**7. Distribute bundles**

데이터를 분석하고 Bunch를 전달한다. 채널 인덱스(ChIndex)를 통해 해당 채널을 찾고 `UChannel::ReceivedRawBunch` 함수를 호출한다.

![image](https://user-images.githubusercontent.com/86822726/144717146-2cc48b01-3dcd-4503-9ab4-0c91a4e4bf15.png)

여기서부터 패킷을 bunch로 파싱한다. 이때의 `this`에는 아래와 같은 값이 들어있다. ReceivedPacket()에서 Reader객체의 값이 최적화 기능 때문에 정확하지 않아서 이전 콜스택인 ReceivedRawPacket()에서 참고한다.

![image](https://user-images.githubusercontent.com/86822726/144717190-2c4ac038-a92c-4c4a-b25b-2f5616ca5234.png)

Buffer의 9번째 인덱스에서 `bControl`, `bIsReplicationPaused`, `bReliable` 값들을 파싱한다. 이는 sequence의 크기가 14비트를 넘어감에 따라 위치가 변할 수도 있다. 따라서, UE4에선 패킷의 특정 인덱스가 어떤 플래그에 해당된다고 말하기 어렵다.

아래의 코드에서 `voice`, `control`, `actor_N`의  채널들 중 원하는 채널 인덱스를 파싱한다.
![image](https://user-images.githubusercontent.com/86822726/144717247-62e9b991-7ba3-4661-9c23-c478d14010a4.png)

BitReader.cpp

![image](https://user-images.githubusercontent.com/86822726/144717276-2f85a1ac-e883-4174-8ef6-7b7a8ddbb5df.png)

`Buffer.GetData()`로 직렬화된 패킷 데이터를 가져오고 `(Pos >> 3U)`로 9바이트를 더해준다. 9, 10 인덱스로 전달될 타겟 채널의 인덱스 값을 파싱한다. 이곳에서는 ChIndex로 값이 3이며, 이 값을 Bunch의 ChIndex에 저장한다.

![image](https://user-images.githubusercontent.com/86822726/144717328-38b17fff-28a4-4e35-98a9-ffe2e86858da.png)

10번째 인덱스에서 `bHasPackageMapExports`, 11번째 인덱스에서 `Bunch.bHasMustBeMappedGUIDs`, `Bunch.bPartial`를 파싱한다.

그리고 아래의 코드에서 채널명을 파싱한다.

![image](https://user-images.githubusercontent.com/86822726/144717349-9b17f96c-ed0b-432a-96af-caa8ea215a80.png)

Engine\Source\Runtime\Core\Public\UObject\UnrealNames.ini 에서 단어에 해당하는 정수값들이 저장되어 있다. Actor는 102에 해당한다.

이렇게 Bunch에 값들을 파싱해준 뒤 `ReceivedRawBunch`를 호출한다.

**8. ReceivedRawBunch**

> `UChannel::ReceivedRawBunch`

신뢰할 수 있는 메시지이지만, 채널 시퀀스 번호가 순서가 아닌 경우, 해당 값을 `receiving reliable message list InRec`에 넣고 채널 시퀀스 번호(ChSequence) 순서로 저장한다. 이때 앞과 마찬가지로 수신된 신뢰할 수 있는 메시지 목록의 수 `NumInRec`는 버퍼 크기 256(RELIABLE_BUFFER)을 초과할 수 없다. 그리고` ReceivedNextBunch`를 호출하여 이전에 캐시된 신뢰할 수 있는 메시지 목록 `InRec`을 순서대로 처리한다.

**9. ReceivedNextBunch**

> `UChannel::ReceivedNextBunch`

수신한 값이 신뢰할 수 있는 메시지인 경우 일련 번호(serial number)를 재설정한다. 이때의 값이 `PartialBunch`인 경우 `bPartialInitial`이 처음 초기화될 때 `InPartialBunch`가 생성되고 나중에 만나서 모든 `PartialBunch`가 `InPartialBunch`로 병합된다. 병합된 `InPartialBunch`는 `IsBunchTooLarge`에서 크기를 확인하고 64K를 초과하면 처리되지 않는다.

**10. ReceivedSequencedBunch**

> `UChannel::ReceivedSequencedBunch`

순서가 정렬된 Bunch를 확인한 후, 해당 채널의 수신 로직을 처리하기 위해 `ReceivedBunch` 기능을 실행해 Bunch를 인자로 전달한다.  `bClose`의 Bunch가 표시되면 해당 채널을 닫는다.

**11. ReceivedBunch**

> `UActorChannel::ReceivedBunch`

guid를 확인한다. 이때 Server와 Client일때 코드가 서로 상이하다.

**12. ProcessBunch**

> `UActorChannel::ProcessBunch`

Actor 청크를 읽어 플레이어가 소유한 Actor인지 확인한다.

**13. ReceivedBunch**

> `FObjectReplicator::ReceivedBunch`

`Field` 헤더와 페이로드를 읽는 부분에서 `FieldCache`를 설정한다. 그후 저 안에서 `RepIndex`를 읽는다. 이 플래그는 나중에 RPC 관련 필드를 찾는데 사용된다.
```cpp
// Read fields from stream
const FFieldNetCache * FieldCache = nullptr;
. . .

while (true)
	{
		UE_NET_TRACE_NAMED_DYNAMIC_NAME_SCOPE(FieldHeaderAndPayloadScope, FName(), Bunch, OwningChannel->Connection->GetInTraceCollector(), ENetTraceVerbosity::Trace);

		if (!OwningChannel->ReadFieldHeaderAndPayload(Object, ClassCache, NetFieldExportGroup, Bunch, &FieldCache, Reader))
		{
			break;
		}
```

각 필드마다 `FieldsBase`값을 가지고 있는데 아래와 같이 연산해서 `ClassCache`에서 해당하는 부분을 찾아서 `FieldCache(==OutField)`를 설정한다.
```cpp
const FFieldNetCache* GetFromIndex( const int32 Index ) const
	{
		for ( const FClassNetCache* C = this; C; C = C->Super )
		{
			if ( Index >= C->FieldsBase && Index < C->FieldsBase + C->Fields.Num() )
			{
				return &C->Fields[Index-C->FieldsBase];
			}
		}
		return NULL;
	}
```

![image](https://user-images.githubusercontent.com/86822726/144717786-2cb08c04-318f-42be-8daf-5fbf2b6bf433.png)

![image](https://user-images.githubusercontent.com/86822726/144717800-4fafa3c1-f282-4217-9718-fc87df8f66f0.png)

Class Name들을 보면 아래와 같이 구성되어 있으며 각각의 클래스들 마다 `Fields`에 배열로 함수이름, 메타데이터들이 저장되어 있다.
	Object
	ㄴ Actor
		ㄴ Pawn
			ㄴ Character
				ㄴ RPC_ProjectCharacter
					ㄴ ThirdPersonCharacter_C


![image](https://user-images.githubusercontent.com/86822726/144717823-d42a510c-d3b8-415b-8c25-83dcf024b7af.png)

**14. ReceivedRPC**

> `FObjectReplicator::ReceivedRPC`
3번째 인자로 `FieldCache`가 들어온다.

![image](https://user-images.githubusercontent.com/86822726/144717848-5222f3ab-5f01-40b0-8dc9-ab5ef80b719b.png)

**15. ProcessEvent**

> `AAcotr::ProcessEvent`

> `UObject::ProcessEvent`

여기서부터 RPC 함수 실행 루틴으로 들어간다.

**16. RPC**

> UFunction::Invoke

> ARPC_ProjectCharacter::execMyServerFunc

> ARPC_ProjectCharacter::MyServerFunc_Implementation()

---

전체적으로 살펴본 내용을 바탕으로 WinAFL을 이용해 RPC Fuzzing을 시도했다.

타겟으로는 아래의 `IpNetDriver.cpp`코드 부분에서, `TickDispatch`가 수신한 패킷을 해당 `Connection` 의 `ReceivedRawPacket` 으로 보내게 된다. 여기서 `ReceivedRawPacket` 함수에 대한 퍼징을 진행하기로 결정했다. 

![image](https://user-images.githubusercontent.com/86822726/144718123-cb36e98c-9b00-4bb7-92db-2af1ad055330.png)

IDA를 이용해 `UNetConnection::ReceivedRawPacket` 의 위치가 `BaseAddr + 0x2632B50` 임을 파악했다.

앞선 RPC 분석 결과로, UE4 Server는 7777 포트 부터 사용을 시작해 1씩 늘어나게 됨을 확인했다. 아래와 같이 환경변수 설정을 통해서 `afl_custom_net` 에서 사용할 포트와 ip 그리고 유저와 서버간의 인증을 위해 delay 를 주었다.
```shell
set AFL_CUSTOM_DLL_ARGS="-U -p 7777 -a 127.0.0.1 -w 3000"
```

추가로 실제 Unreal Engine에서 패킷의 소유자를 찾을 때는 ip, port 를 둘다 사용하기 때문에 AFL 에서 Dedicated Server로 보내는 포트를 명시해줄 필요가 있다.

- `IpNetDriver.cpp`
```cpp
const TSharedRef<const FInternetAddr> FromAddr = ReceivedPacket.Address.ToSharedRef();
...
if (Connection == nullptr)
		{
			UNetConnection** Result = MappedClientConnections.Find(FromAddr);
```

`MappedClientConnections` 는 `std::unordered_map` 을 상속받는 `TMap` 객체이다. 

- `IPAddress.h:136`
```cpp
virtual bool operator==(const FInternetAddr& Other) const
	{
		TArray<uint8> ThisIP = GetRawIp();
		TArray<uint8> OtherIP = Other.GetRawIp();
		return ThisIP == OtherIP && GetPort() == Other.GetPort();
	}
```

위 코드처럼 `FInternetAddr` 에 대해 ip, port 를 모두 검사한다. 하지만 다른 프로세스에서 같은 포트를 사용하는 것은, OS 레벨에서 블록되기 때문에 소켓 바인딩이 불가능하다. 따라서 위의 소스코드 부분을 수정해 특정 대역 포트는 모두 같은 클라이언트로 인식하게 했다.

- `IPAddress.h:136`
```cpp
virtual bool operator==(const FInternetAddr& Other) const
	{
		TArray<uint8> ThisIP = GetRawIp();
		TArray<uint8> OtherIP = Other.GetRawIp();
    //10000 이상의 포트가 들어오면 같은 클라이언트로 인식
	*	return ThisIP == OtherIP && Other.GetPort() >= 10000; 
	}
```

- `IPAddressBSD.cpp:486`
```cpp
bool FInternetAddrBSD::operator==(const FInternetAddr& Other) const
{
	const FInternetAddrBSD& OtherBSD = static_cast<const FInternetAddrBSD&>(Other);
	FName CurrentFamily = GetProtocolType();

	// Check if the addr families match
	if (OtherBSD.GetProtocolType() != CurrentFamily)
	{
		return false;
	}

	// 여기도 바꿔주자.
*	if (OtherBSD.GetPort() <= 10000)
	{
		return false;
	}

#if PLATFORM_HAS_BSD_IPV6_SOCKETS
	if (CurrentFamily == FNetworkProtocolTypes::IPv6)
	{
		const sockaddr_in6* OtherBSDAddr = (sockaddr_in6*)&(OtherBSD.Addr);
		const sockaddr_in6* ThisBSDAddr = ((sockaddr_in6*)&Addr);
		return memcmp(&(ThisBSDAddr->sin6_addr), &(OtherBSDAddr->sin6_addr), sizeof(in6_addr)) == 0;
	}
#endif

	if (CurrentFamily == FNetworkProtocolTypes::IPv4)
	{
		const sockaddr_in* OtherBSDAddr = (sockaddr_in*)&(OtherBSD.Addr);
		const sockaddr_in* ThisBSDAddr = ((sockaddr_in*)&Addr);
		return ThisBSDAddr->sin_addr.s_addr == OtherBSDAddr->sin_addr.s_addr;
	}

	return false;
}
```

위의 코드들을 수정해 주었다.

이후 아래의 옵션을 통해 WinAFL을 실행시켜 주었다.
```shell
.\afl-fuzz.exe -debug -i "/PATH/OF/INPUT" -o "/PATH/OF/OUTPUT" -D "/PATH/OF/DynamoRIO/bin64" -t 5000 -- -covtype edge -coverage_module "/PATH/OF/TARGET/DedicatedServer-Win64-Shipping.exe" -target_module "/PATH/OF/TARGET/DedicatedServer-Win64-Shipping.exe" -target_offset 0x2632b50 -fuzz_interations 5000 -persistence_mode in_app -- "/PATH/OF/TARGET/DedicatedServer-Win64-Shipping.exe"
```

하지만 타임아웃 오류가 발생해 실행할 수 없거나 서버가 꺼져버리는 등 복잡한 인증 과정으로 인해 WinAFL을 적용시키는데 여러가지 문제가 발생했고, 결국 RPC에 퍼저를 적용시키는데 실패했다.
```

`2_Methodology/2_Analysis/2.5_Harness.md`:

```md
### 목차
- [5. 하네스 제작](#5-하네스-제작)
  - [5.1. Ue4 하네스](#51-ue4-하네스)

# 5. 하네스 제작
## 5.1. Ue4 하네스

UE4에 대한 퍼징 효율 향상을 위해 아래의 문서를 참조해 하네스를 제작했다. 

[https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/BuildTools/UnrealBuildTool/ModuleFiles/](https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/BuildTools/UnrealBuildTool/ModuleFiles/)

아래는 전체적인 제작 과정을 정리한 내용이다.

**1. 프로젝트 생성**

`Engine/Source/Programes`에 자신이 만들고 싶은 Harness의 디렉토리를 생성하고 다음과 같은 파일과 디렉토리를 생성한다. (여기서는 HelloWorld)
- HelloWorld.Build.cs
- HelloWorld.Target.cs
- Private
- Public
- Resources

**1-1 HelloWorld.Build.cs**

UE_LOG를 사용하여 Hello, World!를 출력하는 프로젝트의 Build.cs는 다음과 같다.
```cs
using UnrealBuildTool;

public class HelloWorld : ModuleRules
{
        public HelloWorld(ReadOnlyTargetRules Target) : base(Target)
        {
                PublicIncludePaths.Add("Runtime/Launch/Public");
                PrivateIncludePaths.Add("Runtime/Launch/Private");

                PrivateDependencyModuleNames.Add("Core");
                PrivateDependencyModuleNames.Add("Projects");
        }
}
```

**1-2 HelloWorld.Target.cs**

UE_LOG를 사용하여 Hello, World!를 출력하는 프로젝트의 Target.cs는 다음과 같다.
```cs
using UnrealBuildTool;
using System.Collections.Generic;

[SupportedPlatforms(UnrealPlatformClass.Desktop)]
public class HelloWorld : TargetRules
{
        public HelloWorld(TargetInfo Target) : base(Target)
        {
                Type = TargetType.Program;
                LinkType = TargetLinkType.Monolithic;
                LaunchModuleName = "HelloWorld";

                bBuildDeveloperTools = false;
                bUseMallocProfiler = false;

                bBuildWithEditorOnlyData = true;
                bCompileAgainstEngine = false;
                bCompileAgainstCoreUObject = false;
                bCompileAgainstApplicationCore = false;

                bIsBuildingConsoleApplication = true;
        }
}
```

**2. 소스 코드 작성**

Private나 Public 디렉토리 아래에 소스코드를 작성하면 되며 예제 소스는 다음과 같다.
```c
//HelloWorld.h
#pragma once

#include "CoreMinimal.h"
```

```cpp
//HelloWorld.cpp
#include "HelloWorld.h"

#include "RequiredProgramMainCPPInclude.h"

DEFINE_LOG_CATEGORY_STATIC(LogHelloWorld, Log, All);

IMPLEMENT_APPLICATION(HelloWorld, "HelloWorld");

INT32_MAIN_INT32_ARGC_TCHAR_ARGV()
{
        GEngineLoop.PreInit(ArgC, ArgV);
        UE_LOG(LogHelloWorld, Display, TEXT("Hello, World!"));
        FEngineLoop::AppExit();
        return 0;
}
```

**3. 빌드 시스템 등록**

루트 디렉토리의 Makefile 아래에 다음과 같이 추가하면 make 명령어로 빌드가 가능하다.
```
HelloWorld:
        $(BUILD) HelloWorld Linux Development $(ARGS)
```

하지만 Unreal Engine 소스 코드 기반으로 제작한 경우 기본적으로 실행속도가 (1 \~ 2exec/s) 정도로 매우 느렸다. 분석을 해본 결과 `GEngineLoop`와 `FEngineLoop`에서 실행속도를 상당히 잡아먹을 것으로 판단했고 해당 부분을 삭제하고 컴파일을 했고, 문제 없이 제대로 실행되었다. 또한 AFL++로 테스틀 해본 결과 속도가 600 \~ 1400배 가량 향상되었다(1200 \~ 1400exec/sec) 하지만 해당 함수를 제거함으로 발생하는 오류에 대해서는 충분한 테스트를 거치지 못하였다.

**4. 적용 방법**

```cpp
//HelloWorld.cpp
#include "HelloWorld.h"

#include "RequiredProgramMainCPPInclude.h"
#include <iostream>
//DEFINE_LOG_CATEGORY_STATIC(LogHelloWorld, Log, All);

IMPLEMENT_APPLICATION(HelloWorld, "HelloWorld");

int main(void)
{
//        GEngineLoop.PreInit(ArgC, ArgV);
//        UE_LOG(LogHelloWorld, Display, TEXT("Hello, World!"));
					std::cout << "Hello, World!" << std::endl;
//        FEngineLoop::AppExit();
//        return 0;
}
```
```

`2_Methodology/2_Analysis/2.6_ETC.md`:

```md
### 목차
- [6. 기타](#6-기타)
	- [6.1. Debugger Attach](#61-debugger-attach)
	- [6.2 UE4 패스워드 복호화](#62-ue4-패스워드-복호화)

# 6. 기타
## 6.1. Debugger Attach

언리얼 엔진 또는 언리얼 엔진 에디터를 리눅스에서 GDB로 분석하기 위해서는 실행중인 프로세스에 디버거를 붙일 필요가 있다.
이를 위한 파이썬 스크립트이다. 디버거가 정상적으로 붙지 않으면 `time.sleep()` 의 인자를 조절할 수 있다.

```python
from pwn import*
import time
while True:
        p = process(['ps','-ef'])
        a = p.readall().decode()
        p.close()
        lines = a.split('\n')
        for line in lines:
                if 'UE4' in line:
                        line = line.split(' ')
                        while '' in line :
                                line.remove('')
                        print(line)
                        g = process(['gdb','-p',str(line[1])])
                        g.interactive()
                        exit()
        time.sleep(0.5)
```

## 6.2 UE4 패스워드 복호화
UE4 패키징 기능에서 패스워드로 패키징 파일을 암호화 하는 기능이 존재한다. 이에 대해서 패스워드 복호화 방법을 분석해 보았다.

먼저 아래는 Decrypt와 관련한 콜스택이다.
```
1. `WinMain`
2. `int LaunchWindowsStartup(struct HINSTANCE__ * **ptr64,struct HINSTANCE** * __ptr64,char * __ptr64,int,wchar_t const * __ptr64)`
3. `int GuardedMainWrapper(wchar_t const * __ptr64)`
4. `int GuardedMain(wchar_t const * __ptr64)`
5. `int FEngineLoop::PreInitPreStartupScreen(wchar_t const * __ptr64)`
6. `bool LaunchCheckForFileOverride(wchar_t const * __ptr64,bool & __ptr64)`
7. `virtual bool FPakPlatformFile::Initialize(class IPlatformFile * __ptr64,wchar_t const * __ptr64)`
8. `int FPakPlatformFile::MountAllPakFiles(class TArray<class FString,class TSizedDefaultAllocator<32> > const & __ptr64,class FString const & __ptr64)`
9. `bool FPakPlatformFile::Mount(wchar_t const * __ptr64,unsigned int,wchar_t const * __ptr64,bool)`
10. `FPakFile::FPakFile(class IPlatformFile * __ptr64,wchar_t const * __ptr64,bool,bool)`
11. `void FPakFile::Initialize(class FArchive * __ptr64,bool)`
12. `bool FPakFile::LoadIndexInternal(class FArchive * __ptr64)`
13. `void DecryptData(unsigned char * __ptr64,unsigned int,struct FGuid)`
14. `static void FAES::DecryptData(unsigned char * __ptr64,unsigned int,struct FAES::FAESKey const & __ptr64)`
```

키를 파악하고자 할 때에 직접 빌드한 경우에는 PDB 파일이 있기 때문에 주소를 정확히 특정 지을 수 있다. 하지만 라이브 서비스 중인 게임이나 패키지 게임 등 배포된 경우 PDB 파일이 존재하지 않기 때문에 정확한 주소를 찾기 힘들며 디버거를 사용해 반복 작업을 통해 키를 파악할 필요가 있다.


`LoadIndexInternal`의 경우 `PakFile_HashPrimaryIndex`을 검색해 바로 찾을 수 있다. 나머지의 경우 따로 찾을 수 있는 패턴이 없기 때문에 어셈블리어의 패턴을 파악해서 원하는 함수가 어떤 함수에 위치하는지 파악했다.

-`DecryptData`
```
push rsi
push rdi
push r14
push r15
sub rsp, ??
mov rax, qword ptr ds:[<__security_cookie>]
xor rax, rsp
mov qword ptr ss:[rsp+60], rax
mov rsi, r8
mov r15d, edx
...
mov edx, r15d
mov rcx, r14
call ... // FAES::DecryptData
```

-`FAES::DecryptData`
```
mov r9d, 20
jmp ...
int3
...
mov qword ptr ss:[rsp+10], rbx 
```

`call FAES::DecryptData` 에 BP를 걸고 R8의 값을 확인하면 키를 파악할 수 있다. 해당 값을 Hex to Base64로 변환하면 키를 확인할 수 있다.
![image](https://user-images.githubusercontent.com/86822726/144545589-77ebdae8-931c-4875-a581-4e99d937a22c.png)

아래는 해당 방법이 실제로 사용 가능한지 확인을 해보기 위해 ShooterGame을 대상으로 테스트한 내용이다.

1. 먼저 `PakFile_HashPrimaryIndex`를 찾아 근처의 call을 확인한다.
![image](https://user-images.githubusercontent.com/86822726/144545651-bb1fbd06-0924-4bf8-ab52-e9860e576a84.png)

2. 확인해본 결과 `7FF6D33104C0` 에 위치에 함수가 패턴과 동일한 것으로 파악되었다. 해당 함수로 진입해 내리다 보면 `FAES::DecryptData` 를 호출하는 패턴을 가진 어셈블리어 패턴을 확인할 수 있다.
![image](https://user-images.githubusercontent.com/86822726/144545680-1a5ba484-3ab0-4e74-a842-ee4cc6662dca.png)

3. 해당 위치에 BP를 걸고 확인을 R8 레지스터를 확인하면 키를 확인할 수 있다.
![image](https://user-images.githubusercontent.com/86822726/144545814-fe75ae3d-28b6-4591-aeec-bfefe5ca9c3c.png)

4. 실제 키 값과 비교했을 때 `J9+627U3OIrN4np8Xz68NyGvCuCnYC0tf4oWVI8305Q=`로 동일한 것을 확인할 수 있다.
![image](https://user-images.githubusercontent.com/86822726/144545874-707b4ce0-db7e-4c95-8548-f0cbec8b6b8a.png)
```

`2_Methodology/2_Analysis/2.7_Reference.md`:

```md
# 참고문헌
- [The Unreal Engine Game Framework: From int main() to BeginPlay](https://www.youtube.com/watch?v=IaU2Hue-ApI)
- [https://software.intel.com/content/www/us/en/develop/articles/intel-software-engineers-assist-with-unreal-engine-419-optimizations.html](https://software.intel.com/content/www/us/en/develop/articles/intel-software-engineers-assist-with-unreal-engine-419-optimizations.html)
- [https://ikrima.dev/ue4guide/engine-programming/threading-model/](https://ikrima.dev/ue4guide/engine-programming/threading-model/)
- [https://github.com/panzi/u4pak](https://github.com/panzi/u4pak)
- [https://docs.microsoft.com/ko-kr/windows/mixed-reality/develop/unreal/unreal-insights](https://docs.microsoft.com/ko-kr/windows/mixed-reality/develop/unreal/unreal-insights)
- [https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Niagara/](https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/Niagara/)
- [https://www.796t.com/article.php?id=40904](https://www.796t.com/article.php?id=40904)
- [https://zepeh.tistory.com/577](https://zepeh.tistory.com/577)
- [https://www.youtube.com/watch?v=OA4JUSwH98Q](https://www.youtube.com/watch?v=OA4JUSwH98Q)
- [https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/BuildTools/UnrealBuildTool/ModuleFiles/](https://docs.unrealengine.com/4.27/en-US/ProductionPipelines/BuildTools/UnrealBuildTool/ModuleFiles/)
- [https://zhuanlan.zhihu.com/p/372375535](https://zhuanlan.zhihu.com/p/372375535)
- [https://zhuanlan.zhihu.com/p/414683958](https://zhuanlan.zhihu.com/p/414683958)

```

`2_Methodology/2_Analysis/README.md`:

```md
# 2. Anaysis

- [2.1 개요](2.1_Introduction.md)
- [2.2 UE4 기능](2.2_UE4_Features.md)
- [2.3 리소스 분석 및 퍼징](2.3_Resource_Analysis.md)
- [2.4 네트워크 분석](2.4_Network_Analysis.md)
- [2.5 하네스 제작](2.5_Harness.md)
- [2.6 기타](2.6_ETC.md)
- [2.7 참고문헌](2.7_Reference.md)
```

`3_Conclusion/1_Conclusion.md`:

```md
# 결론
BoB 프로젝트를 통해 약 4개월 간 게임 취약점에 대한 경각심 제고와 게임 엔진 보안성 향상을 목적으로  UE4의 보안 취약점을 분석했다. 공격 벡터를 크게 리소스 파일과 네트워크 기능으로 분류했고, 각각에 대해 퍼징 과 코드 오디팅을 수행했다. 리소스 파일의 경우 코드 분석을 통해 세부적으로  UE4에서 uasset, umap과 같은 자체적으로 개발한 포맷들과 BMP와 같은 자체적으로 구현한 파서가 존재하는 포맷을 분석 대상으로 선정했다. 네트워크의 경우 세부적으로 RPC 기능과 픽셀 스트리밍 기능을 선정하고 이에 대해 퍼징과 코드 오디팅을 수행했다.

프로젝트에 WinAFL, AFL++, Dumb Fuzzer등 다양한 퍼저를 사용했고 이를 통해 Stack Buffer Overflow, Out Of Bounds Read, Use After Free, Integer Underflow등의 버그를 찾을 수 있었다. 이중 리소스 파일에서 파일 로딩시 발생한 Stack Buffer Overflow 취약점을 이용해 익스플로잇까지 성공시켰다. 이는 헤더 부분에서 길이을 파싱하고 그 길이 만큼 바디를 스택에 복사하는 과정에서 헤더의 길이에 대한 검증이 없어 발생했다. 두 취약점 모두 리눅스 환경에서 스택 프로텍터도 삽입되어 있지 않고 PIE 보호 기법도 걸려있지 않아 쉽게 Exploit을 수행할 수 있었다. 또한 umap 파일에서 발생하는 취약점은 윈도우에서도 스택 프로텍터가 삽입되어있지 않았고, ASLR이 걸리지 않은 모듈이 존재하였기 때문에 익스플로잇이 가능했다. 간단한 코드 한 줄로도 해당 취약점을 방지할 수 있던 것으로 볼 때에 추후 더욱더 게임 엔진 취약점에 대한 경각심이 필요함을 느꼈다.

네트워크의 경우 픽셀 스트리밍 기능에서 악성 패킷을 전송해 OOB Read 취약점이 트리거되며 서버가 다운되는 Dos 취약점을 발견했다. 하지만 RPC의 경우 패킷을 파싱하는 부분을 대상으로 퍼징을 시도했으나 검증 과정이 너무나 복잡하고 이를 우회하는데 실패해 RPC 함수 퍼징 을 적용하지 못했다. 추가로 전체적으로 UE4의 경우 게임을 실행할 때에 복잡한 과정을 거쳐 게임을 초기화하고 실행시키기 때문에 퍼징을 위해 상당한 컴퓨터 사양이 요구되었고 퍼징  진행 속도가 다른 프로그램에 비해 현저히 느려 크래시 발생에 시간이 너무 오래 걸리는 한계점이 존재한다.

본 팀은 기간 내에 프로젝트 목표 달성을 위해 수행하며 적절한 성과를 거둘 수 있었다. 하지만 여러가지 한계점들도 존재했고 이로 인해 아쉬운 부분도 많았다고 느낀다. 프로젝트의 전체 진행 과정을 공유하며 이후 UE4를 비롯한 게임엔진을 분석하는 사람들에게 조금이나마 도움이 되었으면 한다.

```

`README.md`:

```md
# UE4-Hacking-Guideline

> [BoB(Best of the Best)](https://www.kitribob.kr/) 프로젝트의 일환으로 게임 엔진에 대한 취약점 분석 방법론에 대해 개발한다.
> 다양한 게임 엔진이 존재하나 다양한 이유로 우리는 상용 게임 엔진 중 Epic Games사의 Unreal Engine 4를 주 타겟으로 취약점 분석 방법론을 제시한다.

현재 게임 업계는 직접적인 운영과 관련된 매크로나 게임핵(Game Hack)과 같은 보안 위협을 방어하는데 중점을 두고 있으며 직접적인 운영과 관련되지 않은, 취약점에 대해서는 크게 관심을 두고 있지 않다. 마찬가지로 게임의 기반이 되는 게임 엔진에 대한 보안 위협 또한 다른 소프트웨어에 비해 관심이 낮다. 그래서 우리는 다양한 게임 엔진 중 대표적인 게임엔진인 Unreal Engine을 가지고 게임 엔진에 대한 취약점 분석을 진행한다.

4개월간 진행된 프로젝트로 후속 연구를 위한 가이드 라인을 제시하고자 한다.

# Author
> Best of the Best 10기 취약점분석 트랙 GameCrashProject(이하 GCP) 팀
- 심영진 멘토<sup id="head1">[M](#foot1)</sup>, 박천성 멘토<sup id="head1">[M](#foot1)</sup>
- 이도현 PL<sup id="head2">[9](#foot2)</sup>
- 김영민 PM<sup id="head3">[10](#foot3)</sup>, 구성민<sup id="head3">[10](#foot3)</sup>, 김훈민<sup id="head3">[10](#foot3)</sup>, 정다훈<sup id="head3">[10](#foot3)</sup>, 정원홍<sup id="head3">[10](#foot3)</sup>, 황시준<sup id="head3">[10](#foot3)</sup>

# Contents
## 서론
[1. UnrealEngine](1_Introduction/1_UnrealEngine.md)<br>
[2. Attack Vectors](1_Introduction/2_Attack_Vectors.md)<br>
[3. Tools](1_Introduction/3_Tools.md)<br>

## 프로젝트 접근 방법론
[1. Build](2_Methodology/1_Build.md)<br>
[2. Analysis](2_Methodology/2_Analysis/README.md)<br>

## 결론
[1. Conclusion](3_Conclusion/1_Conclusion.md)<br>

---
<b id="foot1">[[M](#head1)]</b> KITRI 차세대 보안 리더 양성 프로그램 취약점 분석 트랙 멘토 <br>
<b id="foot2">[[9](#head2)]</b> KITRI 차세대 보안 리더 양성 프로그램 취약점 분석 트랙 9기 수료생<br>
<b id="foot3">[[10](#head3)]</b> KITRI 차세대 보안 리더 양성 프로그램 취약점 분석 트랙 10기 수료생<br>

```