Project Path: arc_lstaroth_AntiXorstr__r3bthjq

Source Tree:

```txt
arc_lstaroth_AntiXorstr__r3bthjq
├── ADVobfuscator.gif
├── ADVobfuscator.png
├── README-CN.md
├── README.md
├── antixorstr
│   ├── AnalyzeDialog.ui
│   ├── analyze_ui.py
│   ├── antixorstr_core.py
│   ├── antixorstr_gui.py
│   ├── antixorstr_utils.py
│   └── model.py
├── antixorstr_proxy.py
├── new.gif
├── requirements.txt
└── xorstr.png

```

`README-CN.md`:

```md
<h1 align="center">
<span>AntiXorstr</span>
</h1>
<p align="center">
    <a href="./README.md">English</a> | 中文介绍
</p>
<p align="center">
    <em>枚举和自动解密那些使用c++模板技巧实现的加密字符串，无需关注加密字符串的算法实现</em>
</p>

### 原理

利用C++模板技巧实现字符串的编译期加密存在难以绕过的固有模式，可以被特定规则捕捉，本插件利用这一特点首先对该特征进行识别，筛选出可疑特征后利用unicorn模拟执行，使用其原本的解密代码进行加密字符串还原，因此无需关心其加密算法设计。

### 安装

AntiXorstr支持x86和x64二进制文件，并且可以在任何IDA版本 >= 7.0上运行。安装插件只需将最新版本的代码复制到您的IDA安装目录下的`plugins\`文件夹中即可，记得安装python 3.9(测试过)，以及`requirements`中指定的库

### 例子

```c++
void SampleEncryped()
{
    std::cout << OBFUSCATED("starry") << std::endl;
    std::cout << OBFUSCATED("Softrib") << std::endl;
    std::cout << OBFUSCATED("arlboro") << std::endl;
    std::cout << OBFUSCATED("Angus") << std::endl;
    std::cout << OBFUSCATED("Estrus") << std::endl;
    std::cout << OBFUSCATED("Overbearing") << std::endl;
    std::cout << OBFUSCATED("Monologue") << std::endl;
    std::cout << OBFUSCATED("hushnoo") << std::endl;
    std::cout << OBFUSCATED("Transparent") << std::endl;
    std::cout << OBFUSCATED("Grind") << std::endl;
}
```

1. 使用来自[andrivet/ADVobfuscator](https://github.com/andrivet/ADVobfuscator)的字符串编译期加密

   ![](ADVobfuscator.png)

2. 使用来自[JustasMasiulis/xorstr](https://github.com/JustasMasiulis/xorstr)的字符串编译期加密

   ![](xorstr.png)

### 注意

本插件无法对如VMP保护过后的程序进行识别，请确认需要分析的函数未被混淆

### 待办(未排序)

- 支持Shellcode
- 识别能力增强
- 支持更多架构
- 代码优化

### 感谢

[erocarrera/pefile](https://github.com/erocarrera/pefile)

[unicorn-engine/unicorn](https://github.com/unicorn-engine/unicorn)

[andrivet/ADVobfuscator](https://github.com/andrivet/ADVobfuscator)

[JustasMasiulis/xorstr](https://github.com/JustasMasiulis/xorstr)

```

`README.md`:

```md
<h1 align="center">
<span>AntiXorstr</span>
</h1>
<p align="center">
    English | <a href="./README-CN.md">中文介绍</a>
</p>
<p align="center">
    <em>Enumerate and automatically decrypt encrypted strings implemented using C++ template techniques</em><br>
    <em>without concerning about the algorithmic implementation of the encrypted strings.</em>
</p>


**!!预计近期准备更新支持加密字符串到代码特征的映射!!**
![](new.gif)

### Principle

The compile-time encryption of strings using C++ template techniques has inherent patterns that are difficult to bypass and can be captured by specific rules. This plugin first identifies this feature, filters out suspicious features, and then uses Unicorn to simulate execution. The original decryption code is used to restore the encrypted string, so there is no need to worry about the design of the encryption algorithm.

### Installation

AntiXorstr supports x86 and x64 binary files and can run on any version of IDA >= 7.0. To install the plugin, simply copy the latest version of the code into the `plugins\` folder of your IDA installation directory. Remember to install Python 3.9 (tested) and the libraries specified in the `requirements` file.

### Examples

```c++
void SampleEncryped()
{
    std::cout << OBFUSCATED("starry") << std::endl;
    std::cout << OBFUSCATED("Softrib") << std::endl;
    std::cout << OBFUSCATED("arlboro") << std::endl;
    std::cout << OBFUSCATED("Angus") << std::endl;
    std::cout << OBFUSCATED("Estrus") << std::endl;
    std::cout << OBFUSCATED("Overbearing") << std::endl;
    std::cout << OBFUSCATED("Monologue") << std::endl;
    std::cout << OBFUSCATED("hushnoo") << std::endl;
    std::cout << OBFUSCATED("Transparent") << std::endl;
    std::cout << OBFUSCATED("Grind") << std::endl;
}
```

1. Using compile-time string encryption from [andrivet/ADVobfuscator](https://github.com/andrivet/ADVobfuscator)

   ![](ADVobfuscator.png)

2. Using compile-time string encryption from [JustasMasiulis/xorstr](https://github.com/JustasMasiulis/xorstr)

   ![](xorstr.png)

### Note

This plugin is unable to recognize programs that have been protected by techniques like VMP. Please ensure that the functions you wish to analyze have not been obfuscated.

### Todo (Unsorted)

- Shellcode support
- Improved recognition capabilities
- Support for more architectures
- Code optimization

### Thanks

[erocarrera/pefile](https://github.com/erocarrera/pefile)

[unicorn-engine/unicorn](https://github.com/unicorn-engine/unicorn)

[andrivet/ADVobfuscator](https://github.com/andrivet/ADVobfuscator)

[JustasMasiulis/xorstr](https://github.com/JustasMasiulis/xorstr)

```

`antixorstr/AnalyzeDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>AntiXorstr</class>
 <widget class="QDialog" name="AntiXorstr">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1115</width>
    <height>915</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Anti Xorstring v1.0</string>
  </property>
  <layout class="QHBoxLayout" name="horizontalLayout">
   <item>
    <widget class="QSplitter" name="splitter">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QTableView" name="function_tableview">
      <property name="sizePolicy">
       <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
        <horstretch>0</horstretch>
        <verstretch>0</verstretch>
       </sizepolicy>
      </property>
      <property name="minimumSize">
       <size>
        <width>0</width>
        <height>0</height>
       </size>
      </property>
     </widget>
     <widget class="QWidget" name="verticalLayoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout_1" stretch="50,3,0,3,1">
       <item>
        <widget class="QTableView" name="result_tableview"/>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_3" stretch="1,0,2">
         <item>
          <widget class="QLineEdit" name="load_lineedit">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
           <property name="text">
            <string/>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="bit_checkbox">
           <property name="text">
            <string>x64</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="load_button">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Minimum" vsizetype="Expanding">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
           <property name="text">
            <string>Load File</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLabel" name="label">
           <property name="text">
            <string>Function Range</string>
           </property>
           <property name="textFormat">
            <enum>Qt::PlainText</enum>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="start_lineedit"/>
         </item>
         <item>
          <widget class="QLineEdit" name="end_lineedit"/>
         </item>
        </layout>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_1" stretch="1,2,4">
         <item>
          <widget class="QCheckBox" name="debuginfo_checkbox">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Preferred" vsizetype="Minimum">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
           <property name="text">
            <string>DebugInfo</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="this_button">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
           <property name="text">
            <string>Analyze This</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="all_button">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
             <horstretch>0</horstretch>
             <verstretch>0</verstretch>
            </sizepolicy>
           </property>
           <property name="text">
            <string>Analyze All Function</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QLabel" name="url_lable">
         <property name="text">
          <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;From &lt;a href=&quot;https://github.com/lstaroth/AntiXorstr&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;AntiXorstr&lt;/span&gt;&lt;/a&gt; By Istaroth&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
         </property>
         <property name="alignment">
          <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`antixorstr/analyze_ui.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '.\AnalyzeDialog.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_AntiXorstr(object):
    def setupUi(self, AntiXorstr):
        AntiXorstr.setObjectName("AntiXorstr")
        AntiXorstr.resize(1115, 915)
        self.horizontalLayout = QtWidgets.QHBoxLayout(AntiXorstr)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.splitter = QtWidgets.QSplitter(AntiXorstr)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.splitter.sizePolicy().hasHeightForWidth())
        self.splitter.setSizePolicy(sizePolicy)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.function_tableview = QtWidgets.QTableView(self.splitter)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.function_tableview.sizePolicy().hasHeightForWidth())
        self.function_tableview.setSizePolicy(sizePolicy)
        self.function_tableview.setMinimumSize(QtCore.QSize(0, 0))
        self.function_tableview.setObjectName("function_tableview")
        self.verticalLayoutWidget = QtWidgets.QWidget(self.splitter)
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.verticalLayout_1 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout_1.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_1.setObjectName("verticalLayout_1")
        self.result_tableview = QtWidgets.QTableView(self.verticalLayoutWidget)
        self.result_tableview.setObjectName("result_tableview")
        self.verticalLayout_1.addWidget(self.result_tableview)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.load_lineedit = QtWidgets.QLineEdit(self.verticalLayoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.load_lineedit.sizePolicy().hasHeightForWidth())
        self.load_lineedit.setSizePolicy(sizePolicy)
        self.load_lineedit.setText("")
        self.load_lineedit.setAlignment(QtCore.Qt.AlignCenter)
        self.load_lineedit.setObjectName("load_lineedit")
        self.horizontalLayout_3.addWidget(self.load_lineedit)
        self.bit_checkbox = QtWidgets.QCheckBox(self.verticalLayoutWidget)
        self.bit_checkbox.setObjectName("bit_checkbox")
        self.horizontalLayout_3.addWidget(self.bit_checkbox)
        self.load_button = QtWidgets.QPushButton(self.verticalLayoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.load_button.sizePolicy().hasHeightForWidth())
        self.load_button.setSizePolicy(sizePolicy)
        self.load_button.setObjectName("load_button")
        self.horizontalLayout_3.addWidget(self.load_button)
        self.horizontalLayout_3.setStretch(0, 1)
        self.horizontalLayout_3.setStretch(2, 2)
        self.verticalLayout_1.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.label.setTextFormat(QtCore.Qt.PlainText)
        self.label.setObjectName("label")
        self.horizontalLayout_2.addWidget(self.label)
        self.start_lineedit = QtWidgets.QLineEdit(self.verticalLayoutWidget)
        self.start_lineedit.setObjectName("start_lineedit")
        self.horizontalLayout_2.addWidget(self.start_lineedit)
        self.end_lineedit = QtWidgets.QLineEdit(self.verticalLayoutWidget)
        self.end_lineedit.setObjectName("end_lineedit")
        self.horizontalLayout_2.addWidget(self.end_lineedit)
        self.verticalLayout_1.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_1 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_1.setObjectName("horizontalLayout_1")
        self.debuginfo_checkbox = QtWidgets.QCheckBox(self.verticalLayoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.debuginfo_checkbox.sizePolicy().hasHeightForWidth())
        self.debuginfo_checkbox.setSizePolicy(sizePolicy)
        self.debuginfo_checkbox.setObjectName("debuginfo_checkbox")
        self.horizontalLayout_1.addWidget(self.debuginfo_checkbox)
        self.this_button = QtWidgets.QPushButton(self.verticalLayoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.this_button.sizePolicy().hasHeightForWidth())
        self.this_button.setSizePolicy(sizePolicy)
        self.this_button.setObjectName("this_button")
        self.horizontalLayout_1.addWidget(self.this_button)
        self.all_button = QtWidgets.QPushButton(self.verticalLayoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.all_button.sizePolicy().hasHeightForWidth())
        self.all_button.setSizePolicy(sizePolicy)
        self.all_button.setObjectName("all_button")
        self.horizontalLayout_1.addWidget(self.all_button)
        self.horizontalLayout_1.setStretch(0, 1)
        self.horizontalLayout_1.setStretch(1, 2)
        self.horizontalLayout_1.setStretch(2, 4)
        self.verticalLayout_1.addLayout(self.horizontalLayout_1)
        self.url_lable = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.url_lable.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.url_lable.setObjectName("url_lable")
        self.verticalLayout_1.addWidget(self.url_lable)
        self.verticalLayout_1.setStretch(0, 50)
        self.verticalLayout_1.setStretch(1, 3)
        self.verticalLayout_1.setStretch(3, 3)
        self.verticalLayout_1.setStretch(4, 1)
        self.horizontalLayout.addWidget(self.splitter)

        self.retranslateUi(AntiXorstr)
        QtCore.QMetaObject.connectSlotsByName(AntiXorstr)

    def retranslateUi(self, AntiXorstr):
        _translate = QtCore.QCoreApplication.translate
        AntiXorstr.setWindowTitle(_translate("AntiXorstr", "Anti Xorstring v1.0"))
        self.bit_checkbox.setText(_translate("AntiXorstr", "x64"))
        self.load_button.setText(_translate("AntiXorstr", "Load File"))
        self.label.setText(_translate("AntiXorstr", "Function Range"))
        self.debuginfo_checkbox.setText(_translate("AntiXorstr", "DebugInfo"))
        self.this_button.setText(_translate("AntiXorstr", "Analyze This"))
        self.all_button.setText(_translate("AntiXorstr", "Analyze All Function"))
        self.url_lable.setText(_translate("AntiXorstr", "<html><head/><body><p>From <a href=\"https://github.com/lstaroth/AntiXorstr\"><span style=\" text-decoration: underline; color:#0000ff;\">AntiXorstr</span></a> By Istaroth</p></body></html>"))

```

`antixorstr/antixorstr_core.py`:

```py
import os
import math
import pefile
import idc, idaapi
from unicorn import *
from unicorn.x86_const import *
from antixorstr.antixorstr_utils import *

global mu
global target_32bit
global init_context
global function_basesp
global function_basespd
emu_start = 0
emu_end = 0
keypoint_ea = 0
code_hook_sleep = False
target_len = {0: 1, 1 : 2, 2 : 4, 7 : 8, 8 : 16}

def InitAntixorstrCore(map_addr, target_64bit):
    global mu
    global init_context
    global target_32bit
    if map_addr == 0:
        dst_pe = pefile.PE(idc.get_input_file_path())
        target_32bit = dst_pe.NT_HEADERS.FILE_HEADER.Machine == 0x014c
        mu = Uc(UC_ARCH_X86, UC_MODE_32 if target_32bit else UC_MODE_64)
        codesecs = GetPefileCodesecInfo(dst_pe)
        for sec in codesecs:
            mu.mem_map(dst_pe.OPTIONAL_HEADER.ImageBase + sec[0], sec[1])
            mu.mem_write(dst_pe.OPTIONAL_HEADER.ImageBase + sec[0], dst_pe.get_data(sec[0], sec[2]))
    else:
        target_32bit = not target_64bit
        mu = Uc(UC_ARCH_X86, UC_MODE_32 if target_32bit else UC_MODE_64)
        mu.mem_map(map_addr, os.path.getsize(idc.get_input_file_path()))
        mu.mem_write(map_addr, open(idc.get_input_file_path(), 'rb').read())

    CodeCallbackSleep()
    init_context = mu.context_save()
    mu.hook_add(UC_HOOK_CODE, CodeCallback)

def CodeCallbackSleep():
    global code_hook_sleep
    code_hook_sleep = True

def CodeCallbackWork():
    global code_hook_sleep
    code_hook_sleep = False

def SetEmuScope(start_ea, end_ea):
    global emu_start
    global emu_end
    emu_start = start_ea
    emu_end = end_ea

def StartEmuCode(start_ea, end_ea, limit_count = 100):
    SetEmuScope(start_ea, end_ea)
    try:
        mu.emu_start(emu_start, emu_end, count = limit_count)
    except:
        pass

def CodeCallback(mu, address, size, user_data):
    if code_hook_sleep:
        return True
    if address < emu_start or address >= emu_end:
        mu.emu_stop()
        return False
    insn, opname = DecodeInsnOpname(address)
    if "call" in opname and address > keypoint_ea:
        mu.emu_stop()
        return False
    if "push" in opname or "pop" in opname or ("call" in opname and address < keypoint_ea) or (insn.Op1.type == idaapi.o_reg and insn.Op1.reg == 4 and WillChangeFirst(insn)):
        mu.reg_write(UC_X86_REG_EIP if target_32bit else UC_X86_REG_RIP, address + size)
        return True

    mu.reg_write(UC_X86_REG_ESP if target_32bit else UC_X86_REG_RSP , function_basesp + idc.get_spd(address) - function_basespd)

def MemwriteCallback(uc, access, address, size, value, user_data):
    print(">>> Memory is being WRITE at 0x%x, data size = %u" %(address, size))

def CleanVolatileReg():
    mu.reg_write(UC_X86_REG_EAX if target_32bit else UC_X86_REG_RAX , 0)
    mu.reg_write(UC_X86_REG_ECX if target_32bit else UC_X86_REG_RCX , 0)
    mu.reg_write(UC_X86_REG_EDX if target_32bit else UC_X86_REG_RDX , 0)
    if not target_32bit:
        mu.reg_write(UC_X86_REG_R8, 0)
        mu.reg_write(UC_X86_REG_R9, 0)
        mu.reg_write(UC_X86_REG_R10, 0)
        mu.reg_write(UC_X86_REG_R11, 0)

def DecodeDecryptStr(offset, size):
    try:
        membytes = mu.mem_read(offset + 0x1000, size)
        if len(membytes.split(b'\0')[0]) == 1:
            if membytes.find(b'\x00\x00') == -1:
                return membytes.decode("utf-16")
            return membytes[:membytes.find(b'\x00\x00') + 1].decode("utf-16")
        else:
            return membytes.split(b'\0')[0].decode("utf-8")
    except:
        pass
    return ""

class Analyzer:
    def __init__(self, start, end):
        self.function_blocks = None
        self.stack_dye_list = []
        self.imm_reg = dict()
        self.real_str = []
        self.pointer_offsets = []
        self.sp_delta = 0
        self.stack_space = 0
        self.stack_last_ea = 0
        self.start_ea = start
        self.end_ea = end
        global keypoint_ea
        keypoint_ea = 0
        CodeCallbackSleep()

        mu.context_restore(init_context)
        self.Scan()

    def GetStackLastea(self):
        global function_basespd
        if target_32bit:
            base_spd = 0
            current_ea = self.start_ea
            while current_ea < self.end_ea and current_ea != idc.BADADDR:
                if idc.get_sp_delta(current_ea) > 0:
                    base_spd = idc.get_spd(current_ea)
                    break
                current_ea = idc.next_head(current_ea)
            function_basespd = base_spd
        else:
            base_spd = []
            current_ea = self.start_ea
            while current_ea < self.end_ea and current_ea != idc.BADADDR:
                current_spd = idc.get_spd(current_ea)
                if current_spd is not None and current_spd not in base_spd:
                    base_spd.append(current_spd)
                current_ea = idc.next_head(current_ea)
            base_spd.sort()
            function_basespd = base_spd[0]

        current_ea = self.start_ea
        while current_ea < self.end_ea and current_ea != idc.BADADDR:
            if idc.get_spd(current_ea) == function_basespd:
                break
            current_ea = idc.next_head(current_ea)
        self.stack_last_ea = current_ea

        #bugfix ida7.7 bug for analuze _alloca_probe spd error
        insn, _ = DecodeInsnOpname(current_ea)
        if (not target_32bit) and insn.Op1.type == idaapi.o_reg and insn.Op1.reg == 4 and WillChangeFirst(insn):
            self.stack_last_ea = idc.next_head(self.stack_last_ea)

        if self.stack_last_ea >= self.end_ea:
            return False
        return True

    def GetFunctionInfo(self):
        if not self.GetStackLastea():
            return False

        mu.mem_map(0, 0x10000)
        mu.reg_write(UC_X86_REG_ESP if target_32bit else UC_X86_REG_RSP , 0x5000)
        mu.reg_write(UC_X86_REG_EBP if target_32bit else UC_X86_REG_RBP , 0x5000)
        try:
            StartEmuCode(self.start_ea, self.stack_last_ea, 1000)
        except:
            mu.mem_unmap(0, 0x10000)
            return False

        mu.mem_unmap(0, 0x10000)
        self.stack_space = 0x5000 - mu.reg_read(UC_X86_REG_ESP if target_32bit else UC_X86_REG_RSP)
        self.sp_delta = mu.reg_read(UC_X86_REG_EBP if target_32bit else UC_X86_REG_RBP) - mu.reg_read(UC_X86_REG_ESP if target_32bit else UC_X86_REG_RSP)
        return True

    def SearchArrayPointer(self):
        current_ea = self.start_ea
        while current_ea < self.end_ea and current_ea != idc.BADADDR:
            insn, opname = DecodeInsnOpname(current_ea)
            if "lea" in opname and insn.Op2.type == idaapi.o_displ and (insn.Op2.reg == 5 or insn.Op2.reg == 4) and insn.Op1.type == idaapi.o_reg: # and (insn.Op1.reg in [1,2,8,9])
                status, offset = GetStkvarOffset(insn, 1, current_ea, self.sp_delta, self.stack_last_ea)
                if status:
                    self.pointer_offsets.append((offset, current_ea))
            current_ea = idc.next_head(current_ea)

    def DeyStackSpace(self):
        imm_reg = dict()
        current_ea = self.start_ea
        while current_ea < self.end_ea and current_ea != idc.BADADDR:
            insn, opname = DecodeInsnOpname(current_ea)
            if not WillChangeFirst(insn):
                current_ea = idc.next_head(current_ea)
                continue
            if insn.Op1.type == idaapi.o_reg:
                if insn.Op2.type == idaapi.o_phrase or insn.Op2.type == idaapi.o_displ:
                    imm_reg[insn.Op1.reg] = 0
                    if "mov" in opname and (insn.Op2.reg == 5 or insn.Op2.reg == 4):
                        status, offset = GetStkvarOffset(insn, 1, current_ea, self.sp_delta, self.stack_last_ea)
                        if status and JudgeMemInList(offset, offset + target_len[insn.Op2.dtype], self.stack_dye_list):
                            imm_reg[insn.Op1.reg] = 1
                elif insn.Op2.type == idaapi.o_reg:
                    if "xor" in opname and insn.Op1.reg == insn.Op2.reg:
                        imm_reg[insn.Op1.reg] = 0
                    elif "mov" in opname and JudgeRegNotzeroimm(imm_reg, insn.Op2.reg):
                        imm_reg[insn.Op1.reg] = 1
                elif insn.Op2.type == idaapi.o_mem or (insn.Op2.type == idaapi.o_imm and insn.Op2.value != 0):
                    if "mov" in opname:
                        imm_reg[insn.Op1.reg] = 1
                    elif imm_reg.get(insn.Op1.reg) is None:
                        imm_reg[insn.Op1.reg] = 1
            elif insn.Op1.reg == 5 or insn.Op1.reg == 4:
                if "mov" not in opname:
                    current_ea = idc.next_head(current_ea)
                    continue
                status, offset = GetStkvarOffset(insn, 0, current_ea, self.sp_delta, self.stack_last_ea)
                if status and insn.Op2.type == idaapi.o_mem or (insn.Op2.type == idaapi.o_imm and insn.Op2.value != 0):
                    InsterStackOffsets(self.stack_dye_list, offset, offset + target_len[insn.Op2.dtype])
                elif insn.Op2.type == idaapi.o_reg and JudgeRegNotzeroimm(imm_reg, insn.Op2.reg):
                    InsterStackOffsets(self.stack_dye_list, offset, offset + target_len[insn.Op2.dtype])
                elif insn.Op2.type == idaapi.o_displ and (insn.Op2.reg == 5 or insn.Op2.reg == 4):
                    status, offset = GetStkvarOffset(insn, 1, current_ea, self.sp_delta, self.stack_last_ea)
                    if status and JudgeMemInList(offset, offset + target_len[insn.Op2.dtype], self.stack_dye_list):
                        InsterStackOffsets(self.stack_dye_list, offset, offset + target_len[insn.Op2.dtype])
            current_ea = idc.next_head(current_ea)

    def SplitStackdyeList(self):
        for spliter, _ in self.pointer_offsets:
            for index in range(0, len(self.stack_dye_list)):
                if self.stack_dye_list[index][0] < spliter < self.stack_dye_list[index][1]:
                    prev_end = self.stack_dye_list[index][1]
                    self.stack_dye_list[index] = (self.stack_dye_list[index][0], spliter)
                    self.stack_dye_list.insert(index + 1, (spliter, prev_end))

    def SimulateInitdecBlock(self):
        global function_basesp
        function_basesp = idc.get_frame_regs_size(self.start_ea) + 0x1000

        CleanVolatileReg()
        mu.reg_write(UC_X86_REG_ESP if target_32bit else UC_X86_REG_RSP, idc.get_frame_regs_size(self.start_ea) + 0x1000)
        mu.reg_write(UC_X86_REG_EBP if target_32bit else UC_X86_REG_RBP, self.sp_delta + idc.get_frame_regs_size(self.start_ea) + 0x1000)

        global keypoint_ea
        first_index = FindBlockIndex(self.function_blocks, keypoint_ea)
        for index in range(first_index, self.function_blocks.size):
            block = self.function_blocks[index]
            current_ea = block.start_ea
            if block.start_ea <= keypoint_ea < block.end_ea:
                current_ea = idc.next_head(keypoint_ea)    #go on
            while current_ea < block.end_ea and current_ea != idc.BADADDR:
                keypoint_ea = current_ea
                insn, opname = DecodeInsnOpname(current_ea)
                if not WillChangeFirst(insn):
                    current_ea = idc.next_head(current_ea)
                    continue
                if insn.Op1.type == idaapi.o_reg:
                    if insn.Op2.type == idaapi.o_phrase or insn.Op2.type == idaapi.o_displ:
                        self.imm_reg[insn.Op1.reg] = 0
                        if "mov" in opname and (insn.Op2.reg == 5 or insn.Op2.reg == 4):
                            status, offset = GetStkvarOffset(insn, 1, current_ea, self.sp_delta, self.stack_last_ea)
                            if status and JudgeMemInList(offset, offset + target_len[insn.Op2.dtype], self.stack_dye_list):
                                self.imm_reg[insn.Op1.reg] = 1
                    elif insn.Op2.type == idaapi.o_reg:
                        if "xor" in opname and insn.Op1.reg == insn.Op2.reg:
                            self.imm_reg[insn.Op1.reg] = 0
                        elif "mov" in opname and JudgeRegNotzeroimm(self.imm_reg, insn.Op2.reg):
                            self.imm_reg[insn.Op1.reg] = 1
                    elif insn.Op2.type == idaapi.o_mem or (insn.Op2.type == idaapi.o_imm and insn.Op2.value != 0):
                        if "mov" in opname:
                            self.imm_reg[insn.Op1.reg] = 1
                        elif self.imm_reg.get(insn.Op1.reg) is None:
                            self.imm_reg[insn.Op1.reg] = 1
                elif insn.Op1.reg == 5 or insn.Op1.reg == 4:
                    ready_for_init = False
                    if "mov" not in opname:
                        current_ea = idc.next_head(current_ea)
                        continue
                    status, offset = GetStkvarOffset(insn, 0, current_ea, self.sp_delta, self.stack_last_ea)
                    if status and insn.Op2.type == idaapi.o_mem or (insn.Op2.type == idaapi.o_imm and insn.Op2.value != 0):
                        ready_for_init = True
                        InsterStackOffsets(self.stack_dye_list, offset, offset + target_len[insn.Op2.dtype])
                    elif insn.Op2.type == idaapi.o_reg and JudgeRegNotzeroimm(self.imm_reg, insn.Op2.reg):
                        ready_for_init = True
                        InsterStackOffsets(self.stack_dye_list, offset, offset + target_len[insn.Op2.dtype])
                    elif insn.Op2.type == idaapi.o_displ and (insn.Op2.reg == 5 or insn.Op2.reg == 4):
                        status, offset = GetStkvarOffset(insn, 1, current_ea, self.sp_delta, self.stack_last_ea)
                        if status and JudgeMemInList(offset, offset + target_len[insn.Op2.dtype], self.stack_dye_list):
                            ready_for_init = True
                            InsterStackOffsets(self.stack_dye_list, offset, offset + target_len[insn.Op2.dtype])
                    if ready_for_init:
                        status, offset = RecommendOffset(current_ea, offset, target_len[insn.Op2.dtype], self.pointer_offsets)
                        if status:
                            for reg_index in [3,7,6,12,13,14,15]:
                                self.EmuCodeWithNonvolatile(reg_index, current_ea)
                            StartEmuCode(block.start_ea if block.start_ea > self.stack_last_ea else self.stack_last_ea, self.function_blocks[self.function_blocks.size - 1].end_ea, 1000)
                            return True, offset
                current_ea = idc.next_head(current_ea)
        return False, 0

    def EmuCodeWithNonvolatile(self, reg_index, end_ea):
        block_index = FindBlockIndex(self.function_blocks, end_ea)
        preds = list(filter(lambda x:x.start_ea < self.function_blocks[block_index].start_ea, self.function_blocks[block_index].preds()))
        while True:
            if not len(preds):
                break
            current_ea = idc.prev_head(preds[0].end_ea)
            while current_ea >= preds[0].start_ea and current_ea != idc.BADADDR:
                insn, opname = DecodeInsnOpname(current_ea)
                if insn.Op1.type == idaapi.o_reg and insn.Op1.reg == reg_index and WillChangeFirst(insn) and "pop" not in opname:
                    if "lea" in opname or (insn.Op2.type != idaapi.o_phrase and insn.Op2.type != idaapi.o_displ):
                        StartEmuCode(current_ea, idc.next_head(current_ea), 1)
                        return
                current_ea = idc.prev_head(current_ea)
            preds = list(filter(lambda x:x.start_ea < preds[0].start_ea, preds[0].preds()))

    def FliterSortPointers(self):
        for index in range(0, len(self.pointer_offsets)):
            self.pointer_offsets[index] = (self.pointer_offsets[index][0], GetArraySize(self.stack_dye_list, self.pointer_offsets[index][0]), self.pointer_offsets[index][1])
        self.pointer_offsets = list(filter(lambda x: x[1] > 4, self.pointer_offsets))
        self.pointer_offsets.sort(key = lambda x:x[2])
        if len(self.pointer_offsets) == 0:
            return False

    def Scan(self):
        if (not self.GetFunctionInfo()) or self.stack_space <= 0x30:
            return False
        self.SearchArrayPointer()
        self.DeyStackSpace()
        self.FliterSortPointers()
        global keypoint_ea
        keypoint_ea = self.stack_last_ea
        mu.mem_map(0, math.ceil(self.stack_space / 0x1000) * 0x1000 + 0x2000)
        self.function_blocks = idaapi.FlowChart(None, (self.start_ea, self.end_ea))
        CodeCallbackWork()
        while True:
            try:
                status, offset = self.SimulateInitdecBlock()
            except:
                break

            if not status:
                break

            for pack in self.pointer_offsets:
                if pack[0] == offset:
                    decrypted_str = DecodeDecryptStr(offset, pack[1])
                    if len(decrypted_str) >= 3:
                        self.real_str.append(decrypted_str)
                    break

        mu.mem_unmap(0, math.ceil(self.stack_space / 0x1000) * 0x1000 + 0x2000)

def SearchFunction(start, end):
    try:
        function_analyzer = Analyzer(start, end)
        return 1, function_analyzer.real_str
    except Exception as e:
        print(f"function crash: {hex(start)}")
        print(e)
        return 1, []
```

`antixorstr/antixorstr_gui.py`:

```py

import idc
import idaapi
import idautils
import ida_bytes
import ida_ua

from antixorstr.model import FunctionModel
from antixorstr.model import ResultModelView
from antixorstr.analyze_ui import Ui_AntiXorstr
from antixorstr.antixorstr_core import SearchFunction
from antixorstr.antixorstr_core import InitAntixorstrCore
from antixorstr.antixorstr_utils import SetDebuginfo

from PyQt5 import QtWidgets, QtCore, QtGui
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QApplication, QMessageBox, QVBoxLayout, QMenu
from PyQt5.QtGui import QCursor, QKeySequence

PLUGIN_NAME = "AntiXorstr (x86/x64)"
PLUGIN_HOTKEY = 'ctrl+alt+a'
VERSION = 'V2.1'
WINDOWTITLE = f'{PLUGIN_NAME} {VERSION}'

class AntixorstrGui(idaapi.plugin_t):
    """
    Main Plugin Class
    """
    flags = idaapi.PLUGIN_KEEP
    comment = "Analyze all XorStr with plugin"
    help = f"Edit->Plugin->antixorstr"
    wanted_name = PLUGIN_NAME
    wanted_hotkey = PLUGIN_HOTKEY
    windows = None
    
    def __init__(self):
        super(AntixorstrGui, self).__init__()
        pass
    
    def init(self):#相当于构造函数
        return idaapi.PLUGIN_OK
 
    def term(self):#相当于析构函数
        return idaapi.PLUGIN_OK

    def run(self, arg):
        OpenForm()
        pass

def OpenForm():
    """
    open the same form, no matter how the plugin is launched
    """
    global function_form
    try:
        function_form
    except:
        function_form = FunctionsListForm()
    function_form.Show()

class FunctionsListForm(idaapi.PluginForm):
    def OnCreate(self, form):
        if form is None:
                return None
        self.parent = self.FormToPyQtWidget(form)
        self.mtw = AnalyzeWidget()
        self.mtw.setWindowTitle(WINDOWTITLE)
        
        layout = QVBoxLayout()
        layout.addWidget(self.mtw)
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)
        
        self.parent.setLayout(layout)

    def OnClose(self, form):
        pass

    def Show(self):
        return idaapi.PluginForm.Show(self, WINDOWTITLE, options=idaapi.PluginForm.WOPN_PERSIST)

class AnalyzeWidget(QtWidgets.QWidget, Ui_AntiXorstr):
    def __init__(self):
        super(AnalyzeWidget,self).__init__()
        self.setupUi(self)
        self.retranslateUi(self)

        self.function_model = FunctionModel()
        self.result_model = ResultModelView()
        self.result_tableview.setModel(self.result_model)
        self.function_tableview.setModel(self.function_model)

        self.function_tableview.resizeColumnsToContents()
        self.function_tableview.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.function_tableview.setSelectionMode(QtWidgets.QTableView.SingleSelection)
        self.function_tableview.setEditTriggers(QtWidgets.QTableView.NoEditTriggers)
        self.function_tableview.setContextMenuPolicy(Qt.CustomContextMenu)
        self.function_tableview.horizontalHeader().setStretchLastSection(True)
        self.function_tableview.setAlternatingRowColors(True)
        self.result_tableview.horizontalHeader().setVisible(False)
        self.result_tableview.horizontalHeader().setStretchLastSection(True)

        self.load_button.clicked.connect(self.LoadButtonClick)
        self.function_tableview.clicked.connect(self.FunctionTableviewClick)
        self.function_tableview.doubleClicked.connect(self.FunctionTableviewDoubleClick)
        self.this_button.clicked.connect(self.ThisButtonClick)
        self.all_button.clicked.connect(self.AllButtonClick)

    def LoadButtonClick(self):
        self.function_model.loadFile()
        if "0x" not in self.load_lineedit.text():
            InitAntixorstrCore(0, 0)
        else:
            InitAntixorstrCore(int(self.load_lineedit.text(), 16), self.bit_checkbox.isChecked())

    def FunctionTableviewClick(self, index):
        item_data = self.function_model.getItemData(index.row())
        self.start_lineedit.setText(hex(item_data.va))
        self.end_lineedit.setText(hex(item_data.va + item_data.size))

    def FunctionTableviewDoubleClick(self, index):
        if not index.isValid():
            return None
        idaapi.jumpto(self.function_model.getItemData(index.row()).va)
        return None

    def ThisButtonClick(self):
        if "0x" not in self.start_lineedit.text() or "0x" not in self.end_lineedit.text():
            QMessageBox.information(self, "Tips","please set function range first", QMessageBox.Yes|QMessageBox.No, QMessageBox.Yes)
            return

        SetDebuginfo(self.debuginfo_checkbox.isChecked())
        start_ea = int(self.start_lineedit.text(), 16)
        end_ea = int(self.end_lineedit.text(), 16)

        status, real_str = SearchFunction(start_ea, end_ea)

        self.function_model.setStatus(start_ea, end_ea - start_ea, status)
        self.function_model.clearResult(start_ea, end_ea - start_ea)
        self.function_model.addResults(start_ea, end_ea - start_ea, real_str)

        self.result_model.clear()
        self.result_model.addItems(start_ea, real_str)

    def AllButtonClick(self):
        if self.debuginfo_checkbox.isChecked():
            QMessageBox.information(self, "Tips","debuginfo output do not support all function", QMessageBox.Yes|QMessageBox.No, QMessageBox.Yes)
            self.debuginfo_checkbox.setChecked(False)

        SetDebuginfo(False)
        self.result_model.clear()

        for va in self.function_model.mydata.keys():
            if self.function_model.mydata[va].status == 0:
                status, real_str = SearchFunction(va, self.function_model.mydata[va].va + self.function_model.mydata[va].size)
                self.function_model.mydata[va].status = status
                self.function_model.addResults(va, self.function_model.mydata[va].size, real_str)
            self.result_model.addItems(va, self.function_model.mydata[va].result)
```

`antixorstr/antixorstr_utils.py`:

```py
import idc, idaapi, ida_ua
import ctypes

#debug info print
detail = False
def SetDebuginfo(debuginfo):
    global detail
    detail = debuginfo

def PrintDbginfo(info ="", end ='\n'):
    if detail:
        print(info, end = end)

#Trigger exception for catch in vsc use idacode: https://github.com/ioncodes/idacode
def CatchDebug():
    try:
        raise ArithmeticError
    except (ValueError, ArithmeticError):
        print("now in debug")

#get reg index from name
def GetRegConst(reg_name):
    ri = idaapi.reg_info_t()
    idaapi.parse_reg_name(ri, reg_name)
    return ri.reg

#mov rax,[rbp + reg * index + offset], function return (index, offset)
def GetOp2DisplReg(insn):
    if insn.Op2.type == idaapi.o_reg or insn.Op2.type == idaapi.o_displ or insn.Op2.type == idaapi.o_phrase:
        if insn.Op2.specflag1:
            return insn.Op2.specflag2 & 7, (insn.Op2.specflag2 >> 3) & 7
        else:
            return insn.Op2.reg, None
    else:
        return None, None

#Recommended read size for the specified offset, may not be appropriate when reuse occurs
def GetArraySize(stack_dye_ist, offset):
    for start,end in stack_dye_ist:
        if offset >= start and offset < end:
            return end - offset
    return 0

def getAlignedSize(input_size, align_size):
    fixed_size = int(input_size / align_size) * align_size
    fixed_size += align_size if input_size % align_size else 0
    return fixed_size

#return item list,ltem type eg: [sec.rva, sec.a_virtualsize, sec.a_rawsize]
def GetPefileCodesecInfo(dst_pe):
    codesec_Info = []
    for sec in dst_pe.sections:
        codesec_Info.append([sec.VirtualAddress, getAlignedSize(sec.Misc_VirtualSize, dst_pe.OPTIONAL_HEADER.SectionAlignment), getAlignedSize(sec.SizeOfRawData, dst_pe.OPTIONAL_HEADER.FileAlignment)])
    return codesec_Info

#imm dye stack space
def InsterStackOffsets(stack_dye_list, start_offset, end_offset):
    if end_offset < start_offset:
        return

    if len(stack_dye_list) == 0:
        stack_dye_list.append((start_offset, end_offset))
        return

    repair_index = -1
    for index in range(0, len(stack_dye_list)):
        obj_start, obj_end = stack_dye_list[index]
        if start_offset > obj_end:
            if index == len(stack_dye_list) - 1:
                stack_dye_list.append((start_offset, end_offset))
            continue
        if end_offset < obj_start:
            stack_dye_list.insert(index, (start_offset, end_offset))
            break
        obj_start = obj_start if obj_start < start_offset else start_offset
        obj_end = obj_end if obj_end > end_offset else end_offset
        stack_dye_list[index] = (obj_start, obj_end)
        repair_index = index
        break

    if repair_index != -1 and repair_index != len(stack_dye_list) - 1:
        remove_cnt = 0
        for index in range(repair_index + 1, len(stack_dye_list)):
            start_offset, end_offset = stack_dye_list[repair_index]
            obj_start, obj_end = stack_dye_list[index]
            if end_offset >= obj_start:
                stack_dye_list[repair_index] = (start_offset, obj_end if obj_end > end_offset else end_offset)
                remove_cnt += 1
                continue
            break

        for i in range(0, remove_cnt):
            stack_dye_list.pop(repair_index + 1)

#return insn, opname
def DecodeInsnOpname(current_ea):
    insn = ida_ua.insn_t()
    ida_ua.decode_insn(insn, current_ea)
    opname = idc.print_insn_mnem(current_ea)
    return insn, opname

#Judge whether the specified insn will modify the first parameter
def WillChangeFirst(insn):
    feature = insn.get_canon_feature()
    return True if feature & idaapi.CF_CHG1 else False

#judge whether the specific offset is in array pointers
def JudgeInOffsets(offset, pointer_offsets):
    for off, ea in pointer_offsets:
        if off == offset:
            return True
    return False

def JudgeRegNotzeroimm(imm_reg, obj_name):
    if imm_reg.get(obj_name) != None and imm_reg[obj_name] == 1:
        return True
    return False

def JudgeMemInList(obj_start, obj_end, stack_dye_list):
    for item in stack_dye_list:
        if obj_start < item[0]:
            break
        if obj_start >= item[0] and obj_end <= item[1]:
            return True
    return False

def GetStkvarOffset(insn, op_index, current_ea, sp_delta, stack_last_ea):
    if insn.ops[op_index].type != idaapi.o_displ:
        return False, 0
    if insn.ops[op_index].reg == 5:
        return True, sp_delta + idc.get_frame_regs_size(current_ea) + ctypes.c_int(insn.ops[op_index].addr).value
    elif insn.ops[op_index].reg == 4:
        return True, idc.get_frame_regs_size(current_ea) - (idc.get_spd(stack_last_ea) - idc.get_spd(current_ea)) + ctypes.c_int(insn.ops[op_index].addr).value

def FindBlockIndex(blocks, last_ea):
    for index in range(0, blocks.size):
        if last_ea >= blocks[index].start_ea:
            continue
        return index - 1
    return blocks.size - 1

#Recommend offset through cover status and start distance
def RecommendOffset(current_ea, offset, size, filter_offsets):
    recommend_offsets = []
    for pointer_offset in filter_offsets:
        if offset <= pointer_offset[0] and (offset + size) > pointer_offset[0]:
            recommend_offsets.append(pointer_offset)
    if not len(recommend_offsets):
        return False, 0
    recommend_offsets.sort(key = lambda x:abs(x[2]-current_ea))
    return True, recommend_offsets[0][0]
```

`antixorstr/model.py`:

```py

import idc
import idaapi
import idautils
import ida_bytes
import ida_ua
import ida_pro

from PyQt5 import QtWidgets, QtCore, QtGui
from PyQt5.QtCore import Qt
from typing import List

class FunctionModel(QtCore.QAbstractTableModel):
    col_va = 0
    col_size = 1
    col_status = 2
    col_name = 3
    
    class FunctionItem:
        def __init__(self, va, size, name):
            self.va = va
            self.size = size
            self.name = name
            self.status = 0
            self.result = []

    def __init__(self):
        QtCore.QAbstractTableModel.__init__(self)
        self.headerdata = ["VA", "Size", "status", "name"]
        self.mydata = dict()

    def loadFile(self):
        self.va = 0
        self.size = 0
        self.name = ""
        self.status = 0
        self.clear()
        for item in idautils.Functions():
            thisfunc = idaapi.get_func(item)
            flag = idc.get_func_flags(thisfunc.start_ea)
            if (flag & idaapi.FUNC_THUNK) != 0 or (flag & idaapi.FUNC_LIB) != 0:
                continue
            self.addItem(FunctionModel.FunctionItem(thisfunc.start_ea, thisfunc.end_ea - thisfunc.start_ea, idc.get_func_name(thisfunc.start_ea)))
    
    def columnCount(self, index=QtCore.QModelIndex()):
        return len(self.headerdata)

    def rowCount(self, index=QtCore.QModelIndex()):
        return len(self.mydata)

    def headerData(self, section: int, orientation: Qt.Orientation, role: int = ...):
        if role == Qt.DisplayRole:
            if orientation == Qt.Horizontal:
                return self.headerdata[section]
        return None

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        col = index.column()
        if role == Qt.DisplayRole:
            d = list(self.mydata.values())[index.row()]
            if col == self.col_va:
                return hex(d.va)
            if col == self.col_size:
                return d.size
            if col == self.col_status:
                return d.status
            if col == self.col_name:
                return d.name

    def addItem(self, item: FunctionItem):
        self.mydata[item.va] = item
        self.layoutChanged.emit()

    def setItems(self, items: dict):
        self.mydata = items
        self.layoutChanged.emit()

    def clear(self):
        self.mydata = dict()
        self.layoutChanged.emit()

    def clearResult(self, va, size):
        if self.mydata.get(va) == None or self.mydata[va].size != size:
            return
        self.mydata[va].result.clear()

    def addResult(self, va, size, str):
        if self.mydata.get(va) == None or self.mydata[va].size != size:
            return
        self.mydata[va].result.append(str)

    def addResults(self, va, size, strs):
        if self.mydata.get(va) == None or self.mydata[va].size != size:
            return
        for str in strs:
            self.mydata[va].result.append(str)

    def getItemData(self, index):
        return list(self.mydata.values())[index]

    def setStatus(self, va, size, status):
        if self.mydata.get(va) == None or self.mydata[va].size != size:
            return
        self.mydata[va].status = status
        self.layoutChanged.emit()

class ResultModelView(QtCore.QAbstractTableModel):
    def __init__(self):
        QtCore.QAbstractTableModel.__init__(self)
        self.showList = []

    def columnCount(self, index=QtCore.QModelIndex()):
        return 1

    def rowCount(self, index=QtCore.QModelIndex()):
        return len(self.showList)

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.DisplayRole:
            return self.showList[index.row()]

    def addItem(self, va, str):
        self.showList.append(va)
        self.layoutChanged.emit()

    def addItem(self, va, str):
        self.showList.append(f"{hex(va)}: {str}")
        self.layoutChanged.emit()

    def addItems(self, va, strs):
        for str in strs:
            self.showList.append(f"{hex(va)}: {str}")
        self.layoutChanged.emit()

    def clear(self):
        self.showList = []
        self.layoutChanged.emit()
```

`antixorstr_proxy.py`:

```py
import sys
from antixorstr.antixorstr_gui import AntixorstrGui
    
__AUTHOR__ = 'https://github.com/lstaroth'
 
# register IDA plugin
def PLUGIN_ENTRY():
    return AntixorstrGui()
    
```

`requirements.txt`:

```txt
pefile
unicorn

```