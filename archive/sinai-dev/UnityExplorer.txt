Project Path: arc_sinai-dev_UnityExplorer_1j5fx65b

Source Tree:

```txt
arc_sinai-dev_UnityExplorer_1j5fx65b
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ THIRDPARTY_LICENSES.md
â”œâ”€â”€ UnityEditorPackage
â”‚   â”œâ”€â”€ LICENSE.md
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ Runtime
â”‚   â”‚   â”œâ”€â”€ 0Harmony.dll
â”‚   â”‚   â”œâ”€â”€ Mono.Cecil.Mdb.dll
â”‚   â”‚   â”œâ”€â”€ Mono.Cecil.Pdb.dll
â”‚   â”‚   â”œâ”€â”€ Mono.Cecil.Rocks.dll
â”‚   â”‚   â”œâ”€â”€ Mono.Cecil.dll
â”‚   â”‚   â”œâ”€â”€ MonoMod.RuntimeDetour.dll
â”‚   â”‚   â”œâ”€â”€ MonoMod.Utils.dll
â”‚   â”‚   â”œâ”€â”€ Tomlet.dll
â”‚   â”‚   â”œâ”€â”€ UnityExplorer.STANDALONE.Mono.dll
â”‚   â”‚   â”œâ”€â”€ UnityExplorer.prefab
â”‚   â”‚   â”œâ”€â”€ UniverseLib.Mono.dll
â”‚   â”‚   â””â”€â”€ mcs.dll
â”‚   â”œâ”€â”€ Third Party Notices.md
â”‚   â””â”€â”€ package.json
â”œâ”€â”€ build.ps1
â”œâ”€â”€ img
â”‚   â”œâ”€â”€ icon.png
â”‚   â””â”€â”€ preview.png
â”œâ”€â”€ lib
â”‚   â”œâ”€â”€ ILRepack.exe
â”‚   â”œâ”€â”€ interop
â”‚   â”‚   â”œâ”€â”€ Il2CppSystem.Core.dll
â”‚   â”‚   â”œâ”€â”€ Il2Cppmscorlib.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.AssetBundleModule.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.AudioModule.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.CoreModule.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.IMGUIModule.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.PhysicsModule.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.TextRenderingModule.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.UI.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.UIModule.dll
â”‚   â”‚   â””â”€â”€ UnityEngine.dll
â”‚   â”œâ”€â”€ net35
â”‚   â”‚   â”œâ”€â”€ BepInEx.Core.dll
â”‚   â”‚   â”œâ”€â”€ BepInEx.Unity.dll
â”‚   â”‚   â”œâ”€â”€ BepInEx.dll
â”‚   â”‚   â”œâ”€â”€ MelonLoader.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.UI.dll
â”‚   â”‚   â”œâ”€â”€ UnityEngine.dll
â”‚   â”‚   â””â”€â”€ mcs.dll
â”‚   â”œâ”€â”€ net472
â”‚   â”‚   â”œâ”€â”€ BepInEx.Core.dll
â”‚   â”‚   â””â”€â”€ BepInEx.IL2CPP.dll
â”‚   â”œâ”€â”€ net6
â”‚   â”‚   â”œâ”€â”€ MelonLoader.dll
â”‚   â”‚   â”œâ”€â”€ System.Runtime.dll
â”‚   â”‚   â””â”€â”€ mcs.dll
â”‚   â””â”€â”€ unhollowed
â”‚       â”œâ”€â”€ Il2CppSystem.Core.dll
â”‚       â”œâ”€â”€ Il2Cppmscorlib.dll
â”‚       â”œâ”€â”€ UnityEngine.AssetBundleModule.dll
â”‚       â”œâ”€â”€ UnityEngine.AudioModule.dll
â”‚       â”œâ”€â”€ UnityEngine.CoreModule.dll
â”‚       â”œâ”€â”€ UnityEngine.IMGUIModule.dll
â”‚       â”œâ”€â”€ UnityEngine.PhysicsModule.dll
â”‚       â”œâ”€â”€ UnityEngine.TextRenderingModule.dll
â”‚       â”œâ”€â”€ UnityEngine.UI.dll
â”‚       â”œâ”€â”€ UnityEngine.UIModule.dll
â”‚       â””â”€â”€ UnityEngine.dll
â””â”€â”€ src
    â”œâ”€â”€ CSConsole
    â”‚   â”œâ”€â”€ CSAutoCompleter.cs
    â”‚   â”œâ”€â”€ ConsoleController.cs
    â”‚   â”œâ”€â”€ LexerBuilder.cs
    â”‚   â”œâ”€â”€ Lexers
    â”‚   â”‚   â”œâ”€â”€ CommentLexer.cs
    â”‚   â”‚   â”œâ”€â”€ KeywordLexer.cs
    â”‚   â”‚   â”œâ”€â”€ Lexer.cs
    â”‚   â”‚   â”œâ”€â”€ NumberLexer.cs
    â”‚   â”‚   â”œâ”€â”€ StringLexer.cs
    â”‚   â”‚   â””â”€â”€ SymbolLexer.cs
    â”‚   â”œâ”€â”€ ScriptEvaluator.cs
    â”‚   â””â”€â”€ ScriptInteraction.cs
    â”œâ”€â”€ CacheObject
    â”‚   â”œâ”€â”€ CacheConfigEntry.cs
    â”‚   â”œâ”€â”€ CacheConstructor.cs
    â”‚   â”œâ”€â”€ CacheField.cs
    â”‚   â”œâ”€â”€ CacheKeyValuePair.cs
    â”‚   â”œâ”€â”€ CacheListEntry.cs
    â”‚   â”œâ”€â”€ CacheMember.cs
    â”‚   â”œâ”€â”€ CacheMemberFactory.cs
    â”‚   â”œâ”€â”€ CacheMethod.cs
    â”‚   â”œâ”€â”€ CacheObjectBase.cs
    â”‚   â”œâ”€â”€ CacheProperty.cs
    â”‚   â”œâ”€â”€ ICacheObjectController.cs
    â”‚   â”œâ”€â”€ IValues
    â”‚   â”‚   â”œâ”€â”€ InteractiveColor.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveDictionary.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveEnum.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveList.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveString.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveValue.cs
    â”‚   â”‚   â””â”€â”€ InteractiveValueStruct.cs
    â”‚   â””â”€â”€ Views
    â”‚       â”œâ”€â”€ CacheConfigCell.cs
    â”‚       â”œâ”€â”€ CacheKeyValuePairCell.cs
    â”‚       â”œâ”€â”€ CacheListEntryCell.cs
    â”‚       â”œâ”€â”€ CacheMemberCell.cs
    â”‚       â””â”€â”€ CacheObjectCell.cs
    â”œâ”€â”€ Config
    â”‚   â”œâ”€â”€ ConfigElement.cs
    â”‚   â”œâ”€â”€ ConfigHandler.cs
    â”‚   â”œâ”€â”€ ConfigManager.cs
    â”‚   â”œâ”€â”€ IConfigElement.cs
    â”‚   â””â”€â”€ InternalConfigHandler.cs
    â”œâ”€â”€ ExplorerBehaviour.cs
    â”œâ”€â”€ ExplorerCore.cs
    â”œâ”€â”€ Hooks
    â”‚   â”œâ”€â”€ AddHookCell.cs
    â”‚   â”œâ”€â”€ HookCell.cs
    â”‚   â”œâ”€â”€ HookCreator.cs
    â”‚   â”œâ”€â”€ HookInstance.cs
    â”‚   â””â”€â”€ HookList.cs
    â”œâ”€â”€ Inspectors
    â”‚   â”œâ”€â”€ GameObjectInspector.cs
    â”‚   â”œâ”€â”€ InspectorBase.cs
    â”‚   â”œâ”€â”€ InspectorManager.cs
    â”‚   â”œâ”€â”€ InspectorTab.cs
    â”‚   â”œâ”€â”€ MouseInspector.cs
    â”‚   â”œâ”€â”€ MouseInspectors
    â”‚   â”‚   â”œâ”€â”€ MouseInspectorBase.cs
    â”‚   â”‚   â”œâ”€â”€ UiInspector.cs
    â”‚   â”‚   â””â”€â”€ WorldInspector.cs
    â”‚   â””â”€â”€ ReflectionInspector.cs
    â”œâ”€â”€ Loader
    â”‚   â”œâ”€â”€ BepInEx
    â”‚   â”‚   â”œâ”€â”€ BepInExConfigHandler.cs
    â”‚   â”‚   â””â”€â”€ ExplorerBepInPlugin.cs
    â”‚   â”œâ”€â”€ IExplorerLoader.cs
    â”‚   â”œâ”€â”€ MelonLoader
    â”‚   â”‚   â”œâ”€â”€ ExplorerMelonMod.cs
    â”‚   â”‚   â””â”€â”€ MelonLoaderConfigHandler.cs
    â”‚   â””â”€â”€ Standalone
    â”‚       â”œâ”€â”€ Editor
    â”‚       â”‚   â”œâ”€â”€ ExplorerEditorBehaviour.cs
    â”‚       â”‚   â””â”€â”€ ExplorerEditorLoader.cs
    â”‚       â”œâ”€â”€ ExplorerStandalone.cs
    â”‚       â””â”€â”€ StandaloneConfigHandler.cs
    â”œâ”€â”€ ObjectExplorer
    â”‚   â”œâ”€â”€ ObjectSearch.cs
    â”‚   â”œâ”€â”€ SceneExplorer.cs
    â”‚   â”œâ”€â”€ SceneHandler.cs
    â”‚   â””â”€â”€ SearchProvider.cs
    â”œâ”€â”€ Properties
    â”‚   â””â”€â”€ AssemblyInfo.cs
    â”œâ”€â”€ Runtime
    â”‚   â”œâ”€â”€ Il2CppHelper.cs
    â”‚   â”œâ”€â”€ MonoHelper.cs
    â”‚   â”œâ”€â”€ UERuntimeHelper.cs
    â”‚   â””â”€â”€ UnityCrashPrevention.cs
    â”œâ”€â”€ Tests
    â”‚   â””â”€â”€ TestClass.cs
    â”œâ”€â”€ UI
    â”‚   â”œâ”€â”€ DisplayManager.cs
    â”‚   â”œâ”€â”€ ExplorerUIBase.cs
    â”‚   â”œâ”€â”€ Notification.cs
    â”‚   â”œâ”€â”€ Panels
    â”‚   â”‚   â”œâ”€â”€ AutoCompleteModal.cs
    â”‚   â”‚   â”œâ”€â”€ CSConsolePanel.cs
    â”‚   â”‚   â”œâ”€â”€ ClipboardPanel.cs
    â”‚   â”‚   â”œâ”€â”€ FreeCamPanel.cs
    â”‚   â”‚   â”œâ”€â”€ HookManagerPanel.cs
    â”‚   â”‚   â”œâ”€â”€ InspectorPanel.cs
    â”‚   â”‚   â”œâ”€â”€ LogPanel.cs
    â”‚   â”‚   â”œâ”€â”€ MouseInspectorResultsPanel.cs
    â”‚   â”‚   â”œâ”€â”€ ObjectExplorerPanel.cs
    â”‚   â”‚   â”œâ”€â”€ OptionsPanel.cs
    â”‚   â”‚   â”œâ”€â”€ UEPanel.cs
    â”‚   â”‚   â””â”€â”€ UEPanelDragger.cs
    â”‚   â”œâ”€â”€ UEPanelManager.cs
    â”‚   â”œâ”€â”€ UIManager.cs
    â”‚   â””â”€â”€ Widgets
    â”‚       â”œâ”€â”€ AutoComplete
    â”‚       â”‚   â”œâ”€â”€ EnumCompleter.cs
    â”‚       â”‚   â”œâ”€â”€ ISuggestionProvider.cs
    â”‚       â”‚   â”œâ”€â”€ Suggestion.cs
    â”‚       â”‚   â””â”€â”€ TypeCompleter.cs
    â”‚       â”œâ”€â”€ EvaluateWidget
    â”‚       â”‚   â”œâ”€â”€ BaseArgumentHandler.cs
    â”‚       â”‚   â”œâ”€â”€ EvaluateWidget.cs
    â”‚       â”‚   â”œâ”€â”€ GenericArgumentHandler.cs
    â”‚       â”‚   â”œâ”€â”€ GenericConstructorWidget.cs
    â”‚       â”‚   â””â”€â”€ ParameterHandler.cs
    â”‚       â”œâ”€â”€ GameObjects
    â”‚       â”‚   â”œâ”€â”€ AxisControl.cs
    â”‚       â”‚   â”œâ”€â”€ ComponentCell.cs
    â”‚       â”‚   â”œâ”€â”€ ComponentList.cs
    â”‚       â”‚   â”œâ”€â”€ GameObjectControls.cs
    â”‚       â”‚   â”œâ”€â”€ GameObjectInfoPanel.cs
    â”‚       â”‚   â”œâ”€â”€ TransformControls.cs
    â”‚       â”‚   â”œâ”€â”€ TransformType.cs
    â”‚       â”‚   â””â”€â”€ Vector3Control.cs
    â”‚       â”œâ”€â”€ TimeScaleWidget.cs
    â”‚       â””â”€â”€ UnityObjects
    â”‚           â”œâ”€â”€ AudioClipWidget.cs
    â”‚           â”œâ”€â”€ MaterialWidget.cs
    â”‚           â”œâ”€â”€ Texture2DWidget.cs
    â”‚           â””â”€â”€ UnityObjectWidget.cs
    â”œâ”€â”€ UnityExplorer.csproj
    â”œâ”€â”€ UnityExplorer.sln
    â””â”€â”€ nuget.config

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
<p align="center">
  <img align="center" src="img/icon.png">
</p>

<p align="center">
  ğŸ” An in-game UI for exploring, debugging and modifying Unity games.
</p>
<p align="center">
  âœ”ï¸ Supports most Unity versions from 5.2 to 2021+ (IL2CPP and Mono).
</p>
<p align="center">
  âœ¨ Powered by <a href="https://github.com/sinai-dev/UniverseLib">UniverseLib</a>
</p>

# Releases  [![](https://img.shields.io/github/downloads/sinai-dev/UnityExplorer/total.svg)](../../releases)

[![](https://img.shields.io/github/release/sinai-dev/UnityExplorer.svg?label=version)](../../releases/latest) [![](https://img.shields.io/github/workflow/status/sinai-dev/UnityExplorer/Build%20UnityExplorer)](https://github.com/sinai-dev/UnityExplorer/actions) [![](https://img.shields.io/github/downloads/sinai-dev/UnityExplorer/latest/total.svg)](../../releases/latest)

âš¡ Thunderstore releases: [BepInEx Mono](https://thunderstore.io/package/sinai-dev/UnityExplorer) | [BepInEx IL2CPP](https://gtfo.thunderstore.io/package/sinai-dev/UnityExplorer_IL2CPP) | [MelonLoader IL2CPP](https://boneworks.thunderstore.io/package/sinai-dev/UnityExplorer_IL2CPP_ML)

## Release schedule

Releases will be posted at most once per week, generally on weekends. 

Nightly builds can be found [here](https://github.com/sinai-dev/UnityExplorer/actions).

## BepInEx

| Release | IL2CPP | Mono |
| ------- | ------ | ---- |
| BIE 6.X | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.BepInEx.IL2CPP.zip) | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.BepInEx6.Mono.zip) |
| BIE 6.X (CoreCLR) | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.BepInEx.IL2CPP.CoreCLR.zip) | âœ– |
| BIE 5.X | âœ–ï¸ n/a | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.BepInEx5.Mono.zip) |

1. Unzip the release file into a folder
2. Take the `plugins/sinai-dev-UnityExplorer` folder and place it in `BepInEx/plugins/`

<i>Note: BepInEx 6 is obtainable via [builds.bepinex.dev](https://builds.bepinex.dev/projects/bepinex_be)</i>

## MelonLoader

| Release | IL2CPP | Mono |
| ------- | ------ | ---- |
| ML 0.5  | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.MelonLoader.IL2CPP.zip) | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.MelonLoader.Mono.zip) | 
| ML 0.6  | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.MelonLoader.IL2CPP.net6preview.zip) | âœ–ï¸ |

1. Unzip the release file into a folder
2. Copy the DLL inside the `Mods` folder into your MelonLoader `Mods` folder
3. Copy all of the DLLs inside the `UserLibs` folder into your MelonLoader `UserLibs` folder

## Standalone

| IL2CPP | Mono |
| ------ | ---- |
| âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.Standalone.IL2CPP.zip) | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.Standalone.Mono.zip) | 

The standalone release can be used with any injector or loader of your choice, but it requires you to load the dependencies manually.

1. Ensure the required libs are loaded - UniverseLib, HarmonyX and MonoMod. Take them from the [`UnityExplorer.Editor`](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.Editor.zip) release if you need them.
2. For IL2CPP, load Il2CppAssemblyUnhollower and start an [Il2CppAssemblyUnhollower runtime](https://github.com/knah/Il2CppAssemblyUnhollower#required-external-setup)
2. Load the UnityExplorer DLL
3. Create an instance of Unity Explorer with `UnityExplorer.ExplorerStandalone.CreateInstance();`
4. Optionally subscribe to the `ExplorerStandalone.OnLog` event to handle logging if you wish

## Unity Editor

1. Download the [`UnityExplorer.Editor`](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.Editor.zip) release.
2. Install the package, either by using the Package Manager and importing the `package.json` file, or by manually dragging the folder into your `Assets` folder.
3. Drag the `Runtime/UnityExplorer` prefab into your scene, or create a GameObject and add the `Explorer Editor Behaviour` script to it.

# Common issues and solutions

Although UnityExplorer should work out of the box for most Unity games, in some cases you may need to tweak the settings for it to work properly.

To adjust the settings, open the config file:
* BepInEx: `BepInEx\config\com.sinai.unityexplorer.cfg`
* MelonLoader: `UserData\MelonPreferences.cfg`
* Standalone: `sinai-dev-UnityExplorer\config.cfg`

Try adjusting the following settings and see if it fixes your issues:
* `Startup_Delay_Time` - increase to 5-10 seconds (or more as needed), can fix issues with UnityExplorer being destroyed or corrupted during startup.
* `Disable_EventSystem_Override` - if input is not working properly, try setting this to `true`.

If these fixes do not work, please create an issue in this repo and I'll do my best to look into it.

# Features

<p align="center">
  <a href="https://raw.githubusercontent.com/sinai-dev/UnityExplorer/master/img/preview.png">
    <img src="img/preview.png" />
  </a>
</p>

### Inspector API

If you want to inspect an object or Type from outside the C# console, use the `InspectorManager` class:

**To inspect an object:**
```csharp
UnityExplorer.InspectorManager.Inspect(theObject);
```

**To inspect a Type:**
```cs
UnityExplorer.InspectorManager.Inspect(typeof(SomeClass));
```

### Object Explorer

* Use the <b>Scene Explorer</b> tab to traverse the active scenes, as well as the DontDestroyOnLoad and HideAndDontSave objects.
  * The "HideAndDontSave" scene contains objects with that flag, as well as Assets and Resources which are not in any scene but behave the same way.
  * You can use the Scene Loader to easily load any of the scenes in the build (may not work for Unity 5.X games)
* Use the <b>Object Search</b> tab to search for Unity objects (including GameObjects, Components, etc), C# Singletons or Static Classes.
  * Use the UnityObject search to look for any objects which derive from `UnityEngine.Object`, with optional filters
  * The singleton search will look for any classes with a typical "Instance" field, and check it for a current value. This may cause unexpected behaviour in some IL2CPP games as we cannot distinguish between true properties and field-properties, so some property accessors will be invoked.

### Inspector

The inspector is used to see detailed information on objects of any type and manipulate their values, as well as to inspect C# Classes with static reflection.

* The <b>GameObject Inspector</b> (tab prefix `[G]`) is used to inspect a `GameObject`, and to see and manipulate its Transform and Components.
  * You can edit any of the input fields in the inspector (excluding readonly fields) and press <b>Enter</b> to apply your changes. You can also do this to the GameObject path as a way to change the GameObject's parent. Press the <b>Escape</b> key to cancel your edits.
  * <i>note: When inspecting a GameObject with a Canvas, the transform controls may be overridden by the RectTransform anchors.</i>
* The <b>Reflection Inspectors</b> (tab prefix `[R]` and `[S]`) are used for everything else
  * Automatic updating is not enabled by default, and you must press Apply for any changes you make to take effect.
  * Press the `â–¼` button to expand certain values such as strings, enums, lists, dictionaries, some structs, etc
  * Use the filters at the top to quickly find the members you are looking for
  * For `Texture2D`, `Image`, `Sprite` and `Material` objects, there is a `View Texture` button at the top of the inspector which lets you view the Texture(s) and save them as a PNG file. 
  * For `AudioClip` objects there is a `Show Player` button which opens an audio player widget. For clips which are loaded as `DecompressOnLoad`, there is also a button to save them to a `.wav` file. 

### C# Console

* The C# Console uses the `Mono.CSharp.Evaluator` to define temporary classes or run immediate REPL code.
* You can execute a script automatically on startup by naming it `startup.cs` and placing it in the `sinai-dev-UnityExplorer\Scripts\` folder (this folder will be created where you placed the DLL file).
* See the "Help" dropdown in the C# console menu for more detailed information.

### Hook Manager

* The Hooks panel allows you to hook methods at the click of a button for debugging purposes.
  * Simply enter any class and hook the methods you want from the menu. 
  * You can edit the source code of the generated hook with the "Edit Hook Source" button. Accepted method names are `Prefix` (which can return `bool` or `void`), `Postfix`, `Finalizer` (which can return `Exception` or `void`), and `Transpiler` (which must return `IEnumerable<HarmonyLib.CodeInstruction>`). You can define multiple patches if you wish.

### Mouse-Inspect

* The "Mouse Inspect" dropdown in the "Inspector" panel allows you to inspect objects under the mouse.
  * <b>World</b>: uses Physics.Raycast to look for Colliders
  * <b>UI</b>: uses GraphicRaycasters to find UI objects

### Freecam

* UnityExplorer provides a basic Free Camera which you can control with your keyboard and mouse.
* Unlike all other features of UnityExplorer, you can still use Freecam while UnityExplorer's menu is hidden.
* Supports using the game's main Camera or a separate custom Camera.
* See the Freecam panel for further instructions and details.

### Clipboard

* The "Clipboard" panel allows you to see your current paste value, or clear it (resets it to `null`)
  * Can copy the value from any member in a Reflection Inspector, Enumerable or Dictionary, and from the target of any Inspector tab
  * Can paste values onto any member in a Reflection Inspector
  * Non-parsable arguments in Method/Property Evaluators allow pasting values
  * The C# Console has helper methods `Copy(obj)` and `Paste()` for accessing the Clipboard

### Settings

* You can change the settings via the "Options" tab of the menu, or directly from the config file.
  * BepInEx: `BepInEx\config\com.sinai.unityexplorer.cfg`
  * MelonLoader: `UserData\MelonPreferences.cfg`
  * Standalone `{DLL_location}\sinai-dev-UnityExplorer\config.cfg`

# Building

1. Run the `build.ps1` powershell script to build UnityExplorer. Releases are found in the `Release` folder.

Building individual configurations from your IDE is fine, though note that the intial build process builds into `Release/<version>/...` instead of the subfolders that the powershell script uses. Batch building is not currently supported with the project.

# Acknowledgments

* [ManlyMarco](https://github.com/ManlyMarco) for [Runtime Unity Editor](https://github.com/ManlyMarco/RuntimeUnityEditor) \[[license](THIRDPARTY_LICENSES.md#runtimeunityeditor-license)\], the ScriptEvaluator from RUE's REPL console was used as the base for UnityExplorer's C# console.
* [Geoffrey Horsington](https://github.com/ghorsington) for [mcs-unity](https://github.com/sinai-dev/mcs-unity) \[no license\], used as the `Mono.CSharp` reference for the C# Console.

### Disclaimer

UnityExplorer is in no way associated with Unity Technologies. "Unity", Unity logos, and other Unity trademarks are trademarks or registered trademarks of Unity Technologies or its affiliates in the U.S. and elsewhere.

```

`THIRDPARTY_LICENSES.md`:

```md
* [RuntimeUnityEditor License](#runtimeunityeditor-license)
* [MelonLoader License](#melonloader-license)

## RuntimeUnityEditor License

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.


## MelonLoader License

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2020 - 2021 Lava Gang

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


```

`UnityEditorPackage/LICENSE.md`:

```md
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`UnityEditorPackage/README.md`:

```md
# UnityExplorer

ğŸ” An in-game UI for exploring, debugging and modifying Unity games.
âœ”ï¸ Supports most Unity versions from 5.2 to 2021+ (IL2CPP and Mono).
âœ¨ Powered by [UniverseLib](https://github.com/sinai-dev/UniverseLib)

# Setup

* Install this package, either by using the Package Manager and importing the `package.json` file, or by manually dragging this folder into your Assets folder.
* Drag the `Runtime/UnityExplorer` prefab into your scene, or create a GameObject and add the `Explorer Editor Behaviour` script to it.

# Features

### Object Explorer

* Use the <b>Scene Explorer</b> tab to traverse the active scenes, as well as the DontDestroyOnLoad and HideAndDontSave objects.
  * The "HideAndDontSave" scene contains objects with that flag, as well as Assets and Resources which are not in any scene but behave the same way.
  * You can use the Scene Loader to easily load any of the scenes in the build (may not work for Unity 5.X games)
* Use the <b>Object Search</b> tab to search for Unity objects (including GameObjects, Components, etc), C# Singletons or Static Classes.
  * Use the UnityObject search to look for any objects which derive from `UnityEngine.Object`, with optional filters
  * The singleton search will look for any classes with a typical "Instance" field, and check it for a current value. This may cause unexpected behaviour in some IL2CPP games as we cannot distinguish between true properties and field-properties, so some property accessors will be invoked.

### Inspector

The inspector is used to see detailed information on objects of any type and manipulate their values, as well as to inspect C# Classes with static reflection.

* The <b>GameObject Inspector</b> (tab prefix `[G]`) is used to inspect a `GameObject`, and to see and manipulate its Transform and Components.
  * You can edit any of the input fields in the inspector (excluding readonly fields) and press <b>Enter</b> to apply your changes. You can also do this to the GameObject path as a way to change the GameObject's parent. Press the <b>Escape</b> key to cancel your edits.
  * <i>note: When inspecting a GameObject with a Canvas, the transform controls may be overridden by the RectTransform anchors.</i>
* The <b>Reflection Inspectors</b> (tab prefix `[R]` and `[S]`) are used for everything else
  * Automatic updating is not enabled by default, and you must press Apply for any changes you make to take effect.
  * Press the `â–¼` button to expand certain values such as strings, enums, lists, dictionaries, some structs, etc
  * Use the filters at the top to quickly find the members you are looking for
  * For `Texture2D` objects, there is a `View Texture` button at the top of the inspector which lets you view it and save it as a PNG file. Currently there are no other similar helpers yet, but I may add more at some point for Mesh, Sprite, Material, etc

### C# Console

* The C# Console uses the `Mono.CSharp.Evaluator` to define temporary classes or run immediate REPL code.
* You can execute a script automatically on startup by naming it `startup.cs` and placing it in the `UnityExplorer\Scripts\` folder (this folder will be created where you placed the DLL file).
* See the "Help" dropdown in the C# console menu for more detailed information.

### Hook Manager

* The Hooks panel allows you to hook methods at the click of a button for debugging purposes.
  * Simply enter any class (generic types not yet supported) and hook the methods you want from the menu. 
  * You can edit the source code of the generated hook with the "Edit Hook Source" button. Accepted method names are `Prefix` (which can return `bool` or `void`), `Postfix`, `Finalizer` (which can return `Exception` or `void`), and `Transpiler` (which must return `IEnumerable<HarmonyLib.CodeInstruction>`). You can define multiple patches if you wish.

### Mouse-Inspect

* The "Mouse Inspect" dropdown in the "Inspector" panel allows you to inspect objects under the mouse.
  * <b>World</b>: uses Physics.Raycast to look for Colliders
  * <b>UI</b>: uses GraphicRaycasters to find UI objects

### Clipboard

* The "Clipboard" panel allows you to see your current paste value, or clear it (resets it to `null`)
  * Can copy the value from any member in a Reflection Inspector, Enumerable or Dictionary, and from the target of any Inspector tab
  * Can paste values onto any member in a Reflection Inspector
  * Non-parsable arguments in Method/Property Evaluators allow pasting values
  * The C# Console has helper methods `Copy(obj)` and `Paste()` for accessing the Clipboard

### Settings

* You can change the settings via the "Options" tab of the menu, or directly from the config file.
  * <AssetsFolder>/sinai-dev-UnityExplorer~/config.cfg

# Acknowledgments

* [ManlyMarco](https://github.com/ManlyMarco) for [Runtime Unity Editor](https://github.com/ManlyMarco/RuntimeUnityEditor) \[[license](THIRDPARTY_LICENSES.md#runtimeunityeditor-license)\], the ScriptEvaluator from RUE's REPL console was used as the base for UnityExplorer's C# console.
* [Geoffrey Horsington](https://github.com/ghorsington) for [mcs-unity](https://github.com/sinai-dev/mcs-unity) \[no license\], used as the `Mono.CSharp` reference for the C# Console.

### Disclaimer

UnityExplorer is in no way associated with Unity Technologies. "Unity", Unity logos, and other Unity trademarks are trademarks or registered trademarks of Unity Technologies or its affiliates in the U.S. and elsewhere.

```

`UnityEditorPackage/Runtime/UnityExplorer.prefab`:

```prefab
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &2342243352467007562
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2342243352467007560}
  - component: {fileID: 2342243352467007563}
  m_Layer: 0
  m_Name: UnityExplorer
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &2342243352467007560
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2342243352467007562}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!114 &2342243352467007563
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2342243352467007562}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 255528132, guid: 7e940c577136f52428020c8e128f06f3, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 

```

`UnityEditorPackage/Third Party Notices.md`:

```md
* [RuntimeUnityEditor License](#runtimeunityeditor-license)
* [MelonLoader License](#melonloader-license)

## RuntimeUnityEditor License

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.


## MelonLoader License

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2020 - 2021 Lava Gang

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


```

`UnityEditorPackage/package.json`:

```json
{
  "name": "com.sinai-dev.unityexplorer",
  "version": "4.7.12",
  "displayName": "UnityExplorer",
  "description": "An in-game UI for exploring, debugging and modifying Unity games.",
  "unity": "2017.1",
  "documentationUrl": "https://github.com/sinai-dev/UnityExplorer",
  "changelogUrl": "https://github.com/sinai-dev/UnityExplorer/releases",
  "licensesUrl": "https://github.com/sinai-dev/UnityExplorer/blob/master/LICENSE",
  "keywords": [
    "inspector",
    "debug",
    "runtime"
  ],
  "author": {
    "name": "Sinai",
    "url": "https://github.com/sinai-dev"
  }
}
```

`build.ps1`:

```ps1
# ----------- MelonLoader IL2CPP (net6) -----------
dotnet build src/UnityExplorer.sln -c Release_ML_Cpp_net6
$Path = "Release\UnityExplorer.MelonLoader.IL2CPP.net6preview"
# ILRepack
lib/ILRepack.exe /target:library /lib:lib/net6 /lib:lib/unhollowed /lib:$Path /internalize /out:$Path/UnityExplorer.ML.IL2CPP.net6preview.dll $Path/UnityExplorer.ML.IL2CPP.net6preview.dll $Path/mcs.dll 
# (cleanup and move files)
Remove-Item $Path/UnityExplorer.ML.IL2CPP.net6preview.deps.json
Remove-Item $Path/Tomlet.dll
Remove-Item $Path/mcs.dll
Remove-Item $Path/Iced.dll
Remove-Item $Path/UnhollowerBaseLib.dll
New-Item -Path "$Path" -Name "Mods" -ItemType "directory" -Force
Move-Item -Path $Path/UnityExplorer.ML.IL2CPP.net6preview.dll -Destination $Path/Mods -Force
New-Item -Path "$Path" -Name "UserLibs" -ItemType "directory" -Force
Move-Item -Path $Path/UniverseLib.IL2CPP.Unhollower.dll -Destination $Path/UserLibs -Force
# (create zip archive)
Remove-Item $Path/../UnityExplorer.MelonLoader.IL2CPP.net6preview.zip -ErrorAction SilentlyContinue
7z a $Path/../UnityExplorer.MelonLoader.IL2CPP.net6preview.zip .\$Path\*

# ----------- MelonLoader IL2CPP (net472) -----------
dotnet build src/UnityExplorer.sln -c Release_ML_Cpp_net472
$Path = "Release/UnityExplorer.MelonLoader.IL2CPP"
# ILRepack
lib/ILRepack.exe /target:library /lib:lib/net472 /lib:lib/net35 /lib:lib/unhollowed /lib:$Path /internalize /out:$Path/UnityExplorer.ML.IL2CPP.dll $Path/UnityExplorer.ML.IL2CPP.dll $Path/mcs.dll 
# (cleanup and move files)
Remove-Item $Path/Tomlet.dll
Remove-Item $Path/mcs.dll
Remove-Item $Path/Iced.dll
Remove-Item $Path/UnhollowerBaseLib.dll
New-Item -Path "$Path" -Name "Mods" -ItemType "directory" -Force
Move-Item -Path $Path/UnityExplorer.ML.IL2CPP.dll -Destination $Path/Mods -Force
New-Item -Path "$Path" -Name "UserLibs" -ItemType "directory" -Force
Move-Item -Path $Path/UniverseLib.IL2CPP.Unhollower.dll -Destination $Path/UserLibs -Force
# (create zip archive)
Remove-Item $Path/../UnityExplorer.MelonLoader.IL2CPP.zip -ErrorAction SilentlyContinue
7z a $Path/../UnityExplorer.MelonLoader.IL2CPP.zip .\$Path\*

# ----------- MelonLoader Mono -----------
dotnet build src/UnityExplorer.sln -c Release_ML_Mono
$Path = "Release/UnityExplorer.MelonLoader.Mono"
# ILRepack
lib/ILRepack.exe /target:library /lib:lib/net35 /lib:$Path /internalize /out:$Path/UnityExplorer.ML.Mono.dll $Path/UnityExplorer.ML.Mono.dll $Path/mcs.dll 
# (cleanup and move files)
Remove-Item $Path/Tomlet.dll
Remove-Item $Path/mcs.dll
New-Item -Path "$Path" -Name "Mods" -ItemType "directory" -Force
Move-Item -Path $Path/UnityExplorer.ML.Mono.dll -Destination $Path/Mods -Force
New-Item -Path "$Path" -Name "UserLibs" -ItemType "directory" -Force
Move-Item -Path $Path/UniverseLib.Mono.dll -Destination $Path/UserLibs -Force
# (create zip archive)
Remove-Item $Path/../UnityExplorer.MelonLoader.Mono.zip -ErrorAction SilentlyContinue
7z a $Path/../UnityExplorer.MelonLoader.Mono.zip .\$Path\*

# ----------- BepInEx IL2CPP -----------
dotnet build src/UnityExplorer.sln -c Release_BIE_Cpp
$Path = "Release/UnityExplorer.BepInEx.IL2CPP"
# ILRepack
lib/ILRepack.exe /target:library /lib:lib/net472 /lib:lib/unhollowed /lib:$Path /internalize /out:$Path/UnityExplorer.BIE.IL2CPP.dll $Path/UnityExplorer.BIE.IL2CPP.dll $Path/mcs.dll $Path/Tomlet.dll
# (cleanup and move files)
Remove-Item $Path/Tomlet.dll
Remove-Item $Path/mcs.dll
Remove-Item $Path/Iced.dll
Remove-Item $Path/UnhollowerBaseLib.dll
New-Item -Path "$Path" -Name "plugins" -ItemType "directory" -Force
New-Item -Path "$Path" -Name "plugins/sinai-dev-UnityExplorer" -ItemType "directory" -Force
Move-Item -Path $Path/UnityExplorer.BIE.IL2CPP.dll -Destination $Path/plugins/sinai-dev-UnityExplorer -Force
Move-Item -Path $Path/UniverseLib.IL2CPP.Unhollower.dll -Destination $Path/plugins/sinai-dev-UnityExplorer -Force
# (create zip archive)
Remove-Item $Path/../UnityExplorer.BepInEx.IL2CPP.zip -ErrorAction SilentlyContinue
7z a $Path/../UnityExplorer.BepInEx.IL2CPP.zip .\$Path\*

# ----------- BepInEx IL2CPP CoreCLR -----------
dotnet build src/UnityExplorer.sln -c Release_BIE_CoreCLR
$Path = "Release/UnityExplorer.BepInEx.IL2CPP.CoreCLR"
# ILRepack
lib/ILRepack.exe /target:library /lib:lib/net472 /lib:lib/net6/ /lib:lib/interop/ /lib:$Path /internalize /out:$Path/UnityExplorer.BIE.IL2CPP.CoreCLR.dll $Path/UnityExplorer.BIE.IL2CPP.CoreCLR.dll $Path/mcs.dll $Path/Tomlet.dll
# (cleanup and move files)
Remove-Item $Path/Tomlet.dll
Remove-Item $Path/mcs.dll
Remove-Item $Path/Iced.dll
Remove-Item $Path/Il2CppInterop.Common.dll
Remove-Item $Path/Il2CppInterop.Runtime.dll
Remove-Item $Path/Microsoft.Extensions.Logging.Abstractions.dll
Remove-Item $Path/UnityExplorer.BIE.IL2CPP.CoreCLR.deps.json
New-Item -Path "$Path" -Name "plugins" -ItemType "directory" -Force
New-Item -Path "$Path" -Name "plugins/sinai-dev-UnityExplorer" -ItemType "directory" -Force
Move-Item -Path $Path/UnityExplorer.BIE.IL2CPP.CoreCLR.dll -Destination $Path/plugins/sinai-dev-UnityExplorer -Force
Move-Item -Path $Path/UniverseLib.IL2CPP.Interop.dll -Destination $Path/plugins/sinai-dev-UnityExplorer -Force
# (create zip archive)
Remove-Item $Path/../UnityExplorer.BepInEx.IL2CPP.CoreCLR.zip -ErrorAction SilentlyContinue
7z a $Path/../UnityExplorer.BepInEx.IL2CPP.CoreCLR.zip .\$Path\*

# ----------- BepInEx 5 Mono -----------
dotnet build src/UnityExplorer.sln -c Release_BIE5_Mono
$Path = "Release/UnityExplorer.BepInEx5.Mono"
# ILRepack
lib/ILRepack.exe /target:library /lib:lib/net35 /lib:$Path /internalize /out:$Path/UnityExplorer.BIE5.Mono.dll $Path/UnityExplorer.BIE5.Mono.dll $Path/mcs.dll $Path/Tomlet.dll
# (cleanup and move files)
Remove-Item $Path/Tomlet.dll
Remove-Item $Path/mcs.dll
New-Item -Path "$Path" -Name "plugins" -ItemType "directory" -Force
New-Item -Path "$Path" -Name "plugins/sinai-dev-UnityExplorer" -ItemType "directory" -Force
Move-Item -Path $Path/UnityExplorer.BIE5.Mono.dll -Destination $Path/plugins/sinai-dev-UnityExplorer -Force
Move-Item -Path $Path/UniverseLib.Mono.dll -Destination $Path/plugins/sinai-dev-UnityExplorer -Force
# (create zip archive)
Remove-Item $Path/../UnityExplorer.BepInEx5.Mono.zip -ErrorAction SilentlyContinue
7z a $Path/../UnityExplorer.BepInEx5.Mono.zip .\$Path\*

# ----------- BepInEx 6 Mono -----------
dotnet build src/UnityExplorer.sln -c Release_BIE6_Mono
$Path = "Release/UnityExplorer.BepInEx6.Mono"
# ILRepack
lib/ILRepack.exe /target:library /lib:lib/net35 /lib:$Path /internalize /out:$Path/UnityExplorer.BIE6.Mono.dll $Path/UnityExplorer.BIE6.Mono.dll $Path/mcs.dll $Path/Tomlet.dll
# (cleanup and move files)
Remove-Item $Path/Tomlet.dll
Remove-Item $Path/mcs.dll
New-Item -Path "$Path" -Name "plugins" -ItemType "directory" -Force
New-Item -Path "$Path" -Name "plugins/sinai-dev-UnityExplorer" -ItemType "directory" -Force
Move-Item -Path $Path/UnityExplorer.BIE6.Mono.dll -Destination $Path/plugins/sinai-dev-UnityExplorer -Force
Move-Item -Path $Path/UniverseLib.Mono.dll -Destination $Path/plugins/sinai-dev-UnityExplorer -Force
# (create zip archive)
Remove-Item $Path/../UnityExplorer.BepInEx6.Mono.zip -ErrorAction SilentlyContinue
7z a $Path/../UnityExplorer.BepInEx6.Mono.zip .\$Path\*

# ----------- Standalone Mono -----------
dotnet build src/UnityExplorer.sln -c Release_STANDALONE_Mono
$Path = "Release/UnityExplorer.Standalone.Mono"
# ILRepack
lib/ILRepack.exe /target:library /lib:lib/net35 /lib:$Path /internalize /out:$Path/UnityExplorer.Standalone.Mono.dll $Path/UnityExplorer.Standalone.Mono.dll $Path/mcs.dll $Path/Tomlet.dll
# (cleanup and move files)
Remove-Item $Path/Tomlet.dll
Remove-Item $Path/mcs.dll
Remove-Item $Path/../UnityExplorer.Standalone.Mono.zip -ErrorAction SilentlyContinue
7z a $Path/../UnityExplorer.Standalone.Mono.zip .\$Path\*

# ----------- Standalone IL2CPP -----------
dotnet build src/UnityExplorer.sln -c Release_STANDALONE_Cpp
$Path = "Release/UnityExplorer.Standalone.IL2CPP"
# ILRepack
lib/ILRepack.exe /target:library /lib:lib/net472 /lib:lib/unhollowed /lib:$Path /internalize /out:$Path/UnityExplorer.Standalone.IL2CPP.dll $Path/UnityExplorer.Standalone.IL2CPP.dll $Path/mcs.dll $Path/Tomlet.dll
# (cleanup and move files)
Remove-Item $Path/Tomlet.dll
Remove-Item $Path/mcs.dll
Remove-Item $Path/Iced.dll
Remove-Item $Path/UnhollowerBaseLib.dll
Remove-Item $Path/../UnityExplorer.Standalone.IL2CPP.zip -ErrorAction SilentlyContinue
7z a $Path/../UnityExplorer.Standalone.IL2CPP.zip .\$Path\*

# ----------- Editor (mono) -----------
$Path1 = "Release/UnityExplorer.Standalone.Mono"
$Path2 = "UnityEditorPackage/Runtime"
Copy-Item $Path1/UnityExplorer.STANDALONE.Mono.dll -Destination $Path2
Copy-Item $Path1/UniverseLib.Mono.dll -Destination $Path2
Remove-Item Release/UnityExplorer.Editor.zip -ErrorAction SilentlyContinue
7z a Release/UnityExplorer.Editor.zip .\UnityEditorPackage\*
```

`src/CSConsole/CSAutoCompleter.cs`:

```cs
using System.Text;
using UnityExplorer.CSConsole.Lexers;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI.Models;

namespace UnityExplorer.CSConsole
{
    public class CSAutoCompleter : ISuggestionProvider
    {
        public InputFieldRef InputField => ConsoleController.Input;

        public bool AnchorToCaretPosition => true;

        bool ISuggestionProvider.AllowNavigation => true;

        public void OnSuggestionClicked(Suggestion suggestion)
        {
            ConsoleController.InsertSuggestionAtCaret(suggestion.UnderlyingValue);
            AutoCompleteModal.Instance.ReleaseOwnership(this);
        }

        private readonly HashSet<char> delimiters = new()
        {
            '{',
            '}',
            ',',
            ';',
            '<',
            '>',
            '(',
            ')',
            '[',
            ']',
            '=',
            '|',
            '&',
            '?'
        };

        private readonly List<Suggestion> suggestions = new();

        public void CheckAutocompletes()
        {
            if (string.IsNullOrEmpty(InputField.Text))
            {
                AutoCompleteModal.Instance.ReleaseOwnership(this);
                return;
            }

            suggestions.Clear();

            int caret = Math.Max(0, Math.Min(InputField.Text.Length - 1, InputField.Component.caretPosition - 1));
            int startIdx = caret;

            // If the character at the caret index is whitespace or delimiter,
            // or if the next character (if it exists) is not whitespace,
            // then we don't want to provide suggestions.
            if (char.IsWhiteSpace(InputField.Text[caret])
                || delimiters.Contains(InputField.Text[caret])
                || (InputField.Text.Length > caret + 1 && !char.IsWhiteSpace(InputField.Text[caret + 1])))
            {
                AutoCompleteModal.Instance.ReleaseOwnership(this);
                return;
            }

            // get the current composition string (from caret back to last delimiter)
            while (startIdx > 0)
            {
                startIdx--;
                char c = InputField.Text[startIdx];
                if (delimiters.Contains(c) || char.IsWhiteSpace(c))
                {
                    startIdx++;
                    break;
                }
            }
            string input = InputField.Text.Substring(startIdx, caret - startIdx + 1);

            // Get MCS completions

            string[] evaluatorCompletions = ConsoleController.Evaluator.GetCompletions(input, out string prefix);

            if (evaluatorCompletions != null && evaluatorCompletions.Any())
            {
                suggestions.AddRange(from completion in evaluatorCompletions
                                     select new Suggestion(GetHighlightString(prefix, completion), completion));
            }

            // Get manual namespace completions

            foreach (string ns in ReflectionUtility.AllNamespaces)
            {
                if (ns.StartsWith(input))
                {
                    if (!namespaceHighlights.ContainsKey(ns))
                        namespaceHighlights.Add(ns, $"<color=#CCCCCC>{ns}</color>");

                    string completion = ns.Substring(input.Length, ns.Length - input.Length);
                    suggestions.Add(new Suggestion(namespaceHighlights[ns], completion));
                }
            }

            // Get manual keyword completions

            foreach (string kw in KeywordLexer.keywords)
            {
                if (kw.StartsWith(input))// && kw.Length > input.Length)
                {
                    if (!keywordHighlights.ContainsKey(kw))
                        keywordHighlights.Add(kw, $"<color=#{SignatureHighlighter.keywordBlueHex}>{kw}</color>");

                    string completion = kw.Substring(input.Length, kw.Length - input.Length);
                    suggestions.Add(new Suggestion(keywordHighlights[kw], completion));
                }
            }

            if (suggestions.Any())
            {
                AutoCompleteModal.TakeOwnership(this);
                AutoCompleteModal.Instance.SetSuggestions(suggestions);
            }
            else
            {
                AutoCompleteModal.Instance.ReleaseOwnership(this);
            }
        }


        private readonly Dictionary<string, string> namespaceHighlights = new();

        private readonly Dictionary<string, string> keywordHighlights = new();

        private readonly StringBuilder highlightBuilder = new();
        private const string OPEN_HIGHLIGHT = "<color=cyan>";

        private string GetHighlightString(string prefix, string completion)
        {
            highlightBuilder.Clear();
            highlightBuilder.Append(OPEN_HIGHLIGHT);
            highlightBuilder.Append(prefix);
            highlightBuilder.Append(SignatureHighlighter.CLOSE_COLOR);
            highlightBuilder.Append(completion);
            return highlightBuilder.ToString();
        }
    }
}

```

`src/CSConsole/ConsoleController.cs`:

```cs
using Mono.CSharp;
using System.Collections;
using System.Text;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UniverseLib.Input;
using UniverseLib.UI.Models;

namespace UnityExplorer.CSConsole
{
    public static class ConsoleController
    {
        public static ScriptEvaluator Evaluator { get; private set; }
        public static LexerBuilder Lexer { get; private set; }
        public static CSAutoCompleter Completer { get; private set; }

        public static bool SRENotSupported { get; private set; }
        public static int LastCaretPosition { get; private set; }
        public static float DefaultInputFieldAlpha { get; set; }

        public static bool EnableCtrlRShortcut { get; private set; } = true;
        public static bool EnableAutoIndent { get; private set; } = true;
        public static bool EnableSuggestions { get; private set; } = true;

        public static CSConsolePanel Panel => UIManager.GetPanel<CSConsolePanel>(UIManager.Panels.CSConsole);
        public static InputFieldRef Input => Panel.Input;

        public static string ScriptsFolder => Path.Combine(ExplorerCore.ExplorerFolder, "Scripts");

        static HashSet<string> usingDirectives;
        static StringBuilder evaluatorOutput;
        static StringWriter evaluatorStringWriter;
        static float timeOfLastCtrlR;

        static bool settingCaretCoroutine;
        static string previousInput;
        static int previousContentLength = 0;

        static readonly string[] DefaultUsing = new string[]
        {
            "System",
            "System.Linq",
            "System.Text",
            "System.Collections",
            "System.Collections.Generic",
            "System.Reflection",
            "UnityEngine",
            "UniverseLib",
#if CPP
            "UnhollowerBaseLib",
            "UnhollowerRuntimeLib",
#endif
        };

        const int CSCONSOLE_LINEHEIGHT = 18;

        public static void Init()
        {
            try
            {
                ResetConsole(false);
                // ensure the compiler is supported (if this fails then SRE is probably stripped)
                Evaluator.Compile("0 == 0");
            }
            catch (Exception ex)
            {
                DisableConsole(ex);
                return;
            }

            // Setup console
            Lexer = new LexerBuilder();
            Completer = new CSAutoCompleter();

            SetupHelpInteraction();

            Panel.OnInputChanged += OnInputChanged;
            Panel.InputScroller.OnScroll += OnInputScrolled;
            Panel.OnCompileClicked += Evaluate;
            Panel.OnResetClicked += ResetConsole;
            Panel.OnHelpDropdownChanged += HelpSelected;
            Panel.OnAutoIndentToggled += OnToggleAutoIndent;
            Panel.OnCtrlRToggled += OnToggleCtrlRShortcut;
            Panel.OnSuggestionsToggled += OnToggleSuggestions;
            Panel.OnPanelResized += OnInputScrolled;

            // Run startup script
            try
            {
                if (!Directory.Exists(ScriptsFolder))
                    Directory.CreateDirectory(ScriptsFolder);

                string startupPath = Path.Combine(ScriptsFolder, "startup.cs");
                if (File.Exists(startupPath))
                {
                    ExplorerCore.Log($"Executing startup script from '{startupPath}'...");
                    string text = File.ReadAllText(startupPath);
                    Input.Text = text;
                    Evaluate();
                }
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception executing startup script: {ex}");
            }
        }


        #region Evaluating

        static void GenerateTextWriter()
        {
            evaluatorOutput = new StringBuilder();
            evaluatorStringWriter = new StringWriter(evaluatorOutput);
        }

        public static void ResetConsole() => ResetConsole(true);

        public static void ResetConsole(bool logSuccess = true)
        {
            if (SRENotSupported)
                return;

            if (Evaluator != null)
                Evaluator.Dispose();

            GenerateTextWriter();
            Evaluator = new ScriptEvaluator(evaluatorStringWriter)
            {
                InteractiveBaseClass = typeof(ScriptInteraction)
            };

            usingDirectives = new HashSet<string>();
            foreach (string use in DefaultUsing)
                AddUsing(use);

            if (logSuccess)
                ExplorerCore.Log($"C# Console reset");//. Using directives:\r\n{Evaluator.GetUsing()}");
        }

        public static void AddUsing(string assemblyName)
        {
            if (!usingDirectives.Contains(assemblyName))
            {
                Evaluate($"using {assemblyName};", true);
                usingDirectives.Add(assemblyName);
            }
        }

        public static void Evaluate()
        {
            if (SRENotSupported)
                return;

            Evaluate(Input.Text);
        }

        public static void Evaluate(string input, bool supressLog = false)
        {
            if (SRENotSupported)
                return;

            if (evaluatorStringWriter == null || evaluatorOutput == null)
            {
                GenerateTextWriter();
                Evaluator._textWriter = evaluatorStringWriter;
            }

            try
            {
                // Compile the code. If it returned a CompiledMethod, it is REPL.
                CompiledMethod repl = Evaluator.Compile(input);

                if (repl != null)
                {
                    // Valid REPL, we have a delegate to the evaluation.
                    try
                    {
                        object ret = null;
                        repl.Invoke(ref ret);
                        string result = ret?.ToString();
                        if (!string.IsNullOrEmpty(result))
                            ExplorerCore.Log($"Invoked REPL, result: {ret}");
                        else
                            ExplorerCore.Log($"Invoked REPL (no return value)");
                    }
                    catch (Exception ex)
                    {
                        ExplorerCore.LogWarning($"Exception invoking REPL: {ex}");
                    }
                }
                else
                {
                    // The compiled code was not REPL, so it was a using directive or it defined classes.

                    string output = Evaluator._textWriter.ToString();
                    string[] outputSplit = output.Split('\n');
                    if (outputSplit.Length >= 2)
                        output = outputSplit[outputSplit.Length - 2];
                    evaluatorOutput.Clear();

                    if (ScriptEvaluator._reportPrinter.ErrorsCount > 0)
                        throw new FormatException($"Unable to compile the code. Evaluator's last output was:\r\n{output}");
                    else if (!supressLog)
                        ExplorerCore.Log($"Code compiled without errors.");
                }
            }
            catch (FormatException fex)
            {
                if (!supressLog)
                    ExplorerCore.LogWarning(fex.Message);
            }
            catch (Exception ex)
            {
                if (!supressLog)
                    ExplorerCore.LogWarning(ex);
            }
        }

        #endregion


        #region Update loop and event listeners

        public static void Update()
        {
            if (SRENotSupported)
                return;

            if (!InputManager.GetKey(KeyCode.LeftControl) && !InputManager.GetKey(KeyCode.RightControl))
            {
                if (InputManager.GetKeyDown(KeyCode.Home))
                    JumpToStartOrEndOfLine(true);
                else if (InputManager.GetKeyDown(KeyCode.End))
                    JumpToStartOrEndOfLine(false);
            }

            UpdateCaret(out bool caretMoved);

            if (!settingCaretCoroutine && EnableSuggestions)
            {
                if (AutoCompleteModal.CheckEscape(Completer))
                {
                    OnAutocompleteEscaped();
                    return;
                }

                if (caretMoved)
                    AutoCompleteModal.Instance.ReleaseOwnership(Completer);
            }

            if (EnableCtrlRShortcut
                && (InputManager.GetKey(KeyCode.LeftControl) || InputManager.GetKey(KeyCode.RightControl))
                && InputManager.GetKeyDown(KeyCode.R)
                && timeOfLastCtrlR.OccuredEarlierThanDefault())
            {
                timeOfLastCtrlR = Time.realtimeSinceStartup;
                Evaluate(Panel.Input.Text);
            }
        }

        static void OnInputScrolled() => HighlightVisibleInput(out _);

        static void OnInputChanged(string value)
        {
            if (SRENotSupported)
                return;

            // prevent escape wiping input
            if (InputManager.GetKeyDown(KeyCode.Escape))
            {
                Input.Text = previousInput;

                if (EnableSuggestions && AutoCompleteModal.CheckEscape(Completer))
                    OnAutocompleteEscaped();

                return;
            }

            previousInput = value;

            if (EnableSuggestions && AutoCompleteModal.CheckEnter(Completer))
                OnAutocompleteEnter();

            if (!settingCaretCoroutine)
            {
                if (EnableAutoIndent)
                    DoAutoIndent();
            }

            HighlightVisibleInput(out bool inStringOrComment);

            if (!settingCaretCoroutine)
            {
                if (EnableSuggestions)
                {
                    if (inStringOrComment)
                        AutoCompleteModal.Instance.ReleaseOwnership(Completer);
                    else
                        Completer.CheckAutocompletes();
                }
            }

            UpdateCaret(out _);
        }

        static void OnToggleAutoIndent(bool value)
        {
            EnableAutoIndent = value;
        }

        static void OnToggleCtrlRShortcut(bool value)
        {
            EnableCtrlRShortcut = value;
        }

        static void OnToggleSuggestions(bool value)
        {
            EnableSuggestions = value;
        }

        #endregion


        #region Caret position

        static void UpdateCaret(out bool caretMoved)
        {
            int prevCaret = LastCaretPosition;
            caretMoved = false;

            // Override up/down arrow movement when autocompleting
            if (EnableSuggestions && AutoCompleteModal.CheckNavigation(Completer))
            {
                Input.Component.caretPosition = LastCaretPosition;
                return;
            }

            if (Input.Component.isFocused)
            {
                LastCaretPosition = Input.Component.caretPosition;
                caretMoved = LastCaretPosition != prevCaret;
            }

            if (Input.Text.Length == 0)
                return;

            // If caret moved, ensure caret is visible in the viewport
            if (caretMoved)
            {
                UICharInfo charInfo = Input.TextGenerator.characters[LastCaretPosition];
                float charTop = charInfo.cursorPos.y;
                float charBot = charTop - CSCONSOLE_LINEHEIGHT;

                float viewportMin = Input.Transform.rect.height - Input.Transform.anchoredPosition.y - (Input.Transform.rect.height * 0.5f);
                float viewportMax = viewportMin - Panel.InputScroller.ViewportRect.rect.height;

                float diff = 0f;
                if (charTop > viewportMin)
                    diff = charTop - viewportMin;
                else if (charBot < viewportMax)
                    diff = charBot - viewportMax;

                if (Math.Abs(diff) > 1)
                {
                    RectTransform rect = Input.Transform;
                    rect.anchoredPosition = new Vector2(rect.anchoredPosition.x, rect.anchoredPosition.y - diff);
                }
            }
        }

        public static void SetCaretPosition(int caretPosition)
        {
            Input.Component.caretPosition = caretPosition;

            // Fix to make sure we always really set the caret position.
            // Yields a frame and fixes text-selection issues.
            settingCaretCoroutine = true;
            Input.Component.readOnly = true;
            RuntimeHelper.StartCoroutine(DoSetCaretCoroutine(caretPosition));
        }

        static IEnumerator DoSetCaretCoroutine(int caretPosition)
        {
            Color color = Input.Component.selectionColor;
            color.a = 0f;
            Input.Component.selectionColor = color;

            EventSystemHelper.SetSelectionGuard(false);
            Input.Component.Select();

            yield return null; // ~~~~~~~ YIELD FRAME ~~~~~~~~~

            Input.Component.caretPosition = caretPosition;
            Input.Component.selectionFocusPosition = caretPosition;
            LastCaretPosition = Input.Component.caretPosition;

            color.a = DefaultInputFieldAlpha;
            Input.Component.selectionColor = color;

            Input.Component.readOnly = false;
            settingCaretCoroutine = false;
        }

        // For Home and End keys
        static void JumpToStartOrEndOfLine(bool toStart)
        {
            // Determine the current and next line
            UILineInfo thisline = default;
            UILineInfo? nextLine = null;
            for (int i = 0; i < Input.Component.cachedInputTextGenerator.lineCount; i++)
            {
                UILineInfo line = Input.Component.cachedInputTextGenerator.lines[i];

                if (line.startCharIdx > LastCaretPosition)
                {
                    nextLine = line;
                    break;
                }
                thisline = line;
            }

            if (toStart)
            {
                // Determine where the indented text begins
                int endOfLine = nextLine == null ? Input.Text.Length : nextLine.Value.startCharIdx;
                int indentedStart = thisline.startCharIdx;
                while (indentedStart < endOfLine - 1 && char.IsWhiteSpace(Input.Text[indentedStart]))
                    indentedStart++;

                // Jump to either the true start or the non-whitespace position,
                // depending on which one we are not at.
                if (LastCaretPosition == indentedStart)
                    SetCaretPosition(thisline.startCharIdx);
                else 
                    SetCaretPosition(indentedStart);
            }
            else
            {
                // If there is no next line, jump to the end of this line (+1, to the invisible next character position)
                if (nextLine == null)
                    SetCaretPosition(Input.Text.Length);
                else // jump to the next line start index - 1, ie. end of this line
                    SetCaretPosition(nextLine.Value.startCharIdx - 1);
            }
        }

        #endregion


        #region Lexer Highlighting

        private static void HighlightVisibleInput(out bool inStringOrComment)
        {
            inStringOrComment = false;
            if (string.IsNullOrEmpty(Input.Text))
            {
                Panel.HighlightText.text = "";
                Panel.LineNumberText.text = "1";
                return;
            }

            // Calculate the visible lines

            int topLine = -1;
            int bottomLine = -1;

            // the top and bottom position of the viewport in relation to the text height
            // they need the half-height adjustment to normalize against the 'line.topY' value.
            float viewportMin = Input.Transform.rect.height - Input.Transform.anchoredPosition.y - (Input.Transform.rect.height * 0.5f);
            float viewportMax = viewportMin - Panel.InputScroller.ViewportRect.rect.height;

            for (int i = 0; i < Input.TextGenerator.lineCount; i++)
            {
                UILineInfo line = Input.TextGenerator.lines[i];
                // if not set the top line yet, and top of line is below the viewport top
                if (topLine == -1 && line.topY <= viewportMin)
                    topLine = i;
                // if bottom of line is below the viewport bottom
                if ((line.topY - line.height) >= viewportMax)
                    bottomLine = i;
            }

            topLine = Math.Max(0, topLine - 1);
            bottomLine = Math.Min(Input.TextGenerator.lineCount - 1, bottomLine + 1);

            int startIdx = Input.TextGenerator.lines[topLine].startCharIdx;
            int endIdx = (bottomLine >= Input.TextGenerator.lineCount - 1)
                ? Input.Text.Length - 1
                : (Input.TextGenerator.lines[bottomLine + 1].startCharIdx - 1);


            // Highlight the visible text with the LexerBuilder

            Panel.HighlightText.text = Lexer.BuildHighlightedString(Input.Text, startIdx, endIdx, topLine, LastCaretPosition, out inStringOrComment);

            // Set the line numbers

            // determine true starting line number (not the same as the cached TextGenerator line numbers)
            int realStartLine = 0;
            for (int i = 0; i < startIdx; i++)
            {
                if (LexerBuilder.IsNewLine(Input.Text[i]))
                    realStartLine++;
            }
            realStartLine++;
            char lastPrev = '\n';

            StringBuilder sb = new();

            // append leading new lines for spacing (no point rendering line numbers we cant see)
            for (int i = 0; i < topLine; i++)
                sb.Append('\n');

            // append the displayed line numbers
            for (int i = topLine; i <= bottomLine; i++)
            {
                if (i > 0)
                    lastPrev = Input.Text[Input.TextGenerator.lines[i].startCharIdx - 1];

                // previous line ended with a newline character, this is an actual new line.
                if (LexerBuilder.IsNewLine(lastPrev))
                {
                    sb.Append(realStartLine.ToString());
                    realStartLine++;
                }

                sb.Append('\n');
            }

            Panel.LineNumberText.text = sb.ToString();

            return;
        }

        #endregion


        #region Autocompletes

        public static void InsertSuggestionAtCaret(string suggestion)
        {
            settingCaretCoroutine = true;
            Input.Text = Input.Text.Insert(LastCaretPosition, suggestion);

            SetCaretPosition(LastCaretPosition + suggestion.Length);
            LastCaretPosition = Input.Component.caretPosition;
        }

        private static void OnAutocompleteEnter()
        {
            // Remove the new line
            int lastIdx = Input.Component.caretPosition - 1;
            Input.Text = Input.Text.Remove(lastIdx, 1);

            // Use the selected suggestion
            Input.Component.caretPosition = LastCaretPosition;
            Completer.OnSuggestionClicked(AutoCompleteModal.SelectedSuggestion);
        }

        private static void OnAutocompleteEscaped()
        {
            AutoCompleteModal.Instance.ReleaseOwnership(Completer);
            SetCaretPosition(LastCaretPosition);
        }


        #endregion


        #region Auto indenting

        private static void DoAutoIndent()
        {
            if (Input.Text.Length > previousContentLength)
            {
                int inc = Input.Text.Length - previousContentLength;

                if (inc == 1)
                {
                    int caret = Input.Component.caretPosition;
                    Input.Text = Lexer.IndentCharacter(Input.Text, ref caret);
                    Input.Component.caretPosition = caret;
                    LastCaretPosition = caret;
                }
                else
                {
                    // todo indenting for copy+pasted content

                    //ExplorerCore.Log("Content increased by " + inc);
                    //var comp = Input.Text.Substring(PreviousCaretPosition, inc);
                    //ExplorerCore.Log("composition string: " + comp);
                }
            }

            previousContentLength = Input.Text.Length;
        }

        #endregion


        #region "Help" interaction

        private static void DisableConsole(Exception ex)
        {
            SRENotSupported = true;
            Input.Component.readOnly = true;
            Input.Component.textComponent.color = "5d8556".ToColor();

            if (ex is NotSupportedException)
            {
                Input.Text = $@"The C# Console has been disabled because System.Reflection.Emit threw a NotSupportedException.

Easy, dirty fix: (will likely break on game updates)
    * Download the corlibs for the game's Unity version from here: https://unity.bepinex.dev/corlibs/
    * Unzip and copy mscorlib.dll (and System.Reflection.Emit DLLs, if present) from the folder
    * Paste and overwrite the files into <Game>_Data/Managed/

With UnityDoorstop: (BepInEx only, or if you use UnityDoorstop + Standalone release):
    * Download the corlibs for the game's Unity version from here: https://unity.bepinex.dev/corlibs/
    * Unzip and copy mscorlib.dll (and System.Reflection.Emit DLLs, if present) from the folder
    * Find the folder which contains doorstop_config.ini (the game folder, or your r2modman/ThunderstoreModManager profile folder)
    * Make a subfolder called 'corlibs' inside this folder.
    * Paste the DLLs inside the corlibs folder.
    * In doorstop_config.ini, set 'dllSearchPathOverride=corlibs'.

Doorstop example:
- <Game>\
    - <Game>_Data\...
    - BepInEx\...
    - corlibs\
        - mscorlib.dll
    - doorstop_config.ini (with dllSearchPathOverride=corlibs)
    - <Game>.exe
    - winhttp.dll";
            }
            else
            {
                Input.Text = $"The C# Console has been disabled. {ex}";
            }
        }

        private static readonly Dictionary<string, string> helpDict = new();

        public static void SetupHelpInteraction()
        {
            Dropdown drop = Panel.HelpDropdown;

            helpDict.Add("Help", "");
            helpDict.Add("Usings", HELP_USINGS);
            helpDict.Add("REPL", HELP_REPL);
            helpDict.Add("Classes", HELP_CLASSES);
            helpDict.Add("Coroutines", HELP_COROUTINES);

            foreach (KeyValuePair<string, string> opt in helpDict)
                drop.options.Add(new Dropdown.OptionData(opt.Key));
        }

        public static void HelpSelected(int index)
        {
            if (index == 0)
                return;

            KeyValuePair<string, string> helpText = helpDict.ElementAt(index);

            Input.Text = helpText.Value;

            Panel.HelpDropdown.value = 0;
        }


        internal const string STARTUP_TEXT = @"<color=#5d8556>// Welcome to the UnityExplorer C# Console!

// It is recommended to use the Log panel (or a console log window) while using this tool.
// Use the Help dropdown to see detailed examples of how to use the console.

// To execute a script automatically on startup, put the script at 'sinai-dev-UnityExplorer\Scripts\startup.cs'</color>";

        internal const string HELP_USINGS = @"// You can add a using directive to any namespace, but you must compile for it to take effect.
// It will remain in effect until you Reset the console.
using UnityEngine.UI;

// To see your current usings, use the ""GetUsing();"" helper.
// Note: You cannot add usings and evaluate REPL at the same time.";

        internal const string HELP_REPL = @"/* REPL (Read-Evaluate-Print-Loop) is a way to execute code immediately.
 * REPL code cannot contain any using directives or classes.
 * The return value of the last line of your REPL will be printed to the log.
 * Variables defined in REPL will exist until you Reset the console.
*/

// eg: This code would print 'Hello, World!', and then print 6 as the return value.
Log(""Hello, world!"");
var x = 5;
++x;

/* The following helpers are available in REPL mode:
 * CurrentTarget;     - System.Object, the target of the active Inspector tab
 * AllTargets;        - System.Object[], the targets of all Inspector tabs
 * Log(obj);          - prints a message to the console log
 * Inspect(obj);      - inspect the object with the Inspector
 * Inspect(someType); - inspect a Type with static reflection
 * Start(enumerator); - Coroutine, starts the IEnumerator as a Coroutine, and returns the Coroutine.
 * Stop(coroutine);   - stop the Coroutine ONLY if it was started with Start(ienumerator).
 * Copy(obj);         - copies the object to the UnityExplorer Clipboard
 * Paste();           - System.Object, the contents of the Clipboard.
 * GetUsing();        - prints the current using directives to the console log
 * GetVars();         - prints the names and values of the REPL variables you have defined
 * GetClasses();      - prints the names and members of the classes you have defined
 * help;              - the default REPL help command, contains additional helpers.
*/";

        internal const string HELP_CLASSES = @"// Classes you compile will exist until the application closes.
// You can soft-overwrite a class by compiling it again with the same name. The old class will still technically exist in memory.

// Compiled classes can be accessed from both inside and outside this console.
// Note: in IL2CPP, you must declare a Namespace to inject these classes with ClassInjector or it will crash the game.

public class HelloWorld
{
    public static void Main()
    {
        UnityExplorer.ExplorerCore.Log(""Hello, world!"");
    }
}

// In REPL, you could call the example method above with ""HelloWorld.Main();""
// Note: The compiler does not allow you to run REPL code and define classes at the same time.

// In REPL, use the ""GetClasses();"" helper to see the classes you have defined since the last Reset.";

        internal const string HELP_COROUTINES = @"// To start a Coroutine directly, use ""Start(SomeCoroutine());"" in REPL mode.

// To declare a coroutine, you will need to compile it separately. For example:
public class MyCoro
{
    public static IEnumerator Main()
    {
        yield return null;
        UnityExplorer.ExplorerCore.Log(""Hello, world after one frame!"");
    }
}
// To run this Coroutine in REPL, it would look like ""Start(MyCoro.Main());""";

        #endregion
    }
}

```

`src/CSConsole/LexerBuilder.cs`:

```cs
using System.Text;
using UnityExplorer.CSConsole.Lexers;

namespace UnityExplorer.CSConsole
{
    public struct MatchInfo
    {
        public int startIndex;
        public int endIndex;
        public bool isStringOrComment;
        public bool matchToEndOfLine;
        public string htmlColorTag;
    }

    public class LexerBuilder
    {
        public const char WHITESPACE = ' ';
        public readonly HashSet<char> IndentOpenChars = new() { '{', '(' };
        public readonly HashSet<char> IndentCloseChars = new() { '}', ')' };

        private readonly Lexer[] lexers;
        private readonly HashSet<char> delimiters = new();

        private readonly StringLexer stringLexer = new();
        private readonly CommentLexer commentLexer = new();

        public LexerBuilder()
        {
            lexers = new Lexer[]
            {
                commentLexer,
                stringLexer,
                new SymbolLexer(),
                new NumberLexer(),
                new KeywordLexer(),
            };

            foreach (Lexer matcher in lexers)
            {
                foreach (char c in matcher.Delimiters)
                {
                    if (!delimiters.Contains(c))
                        delimiters.Add(c);
                }
            }
        }

        /// <summary>The last committed index for a match or no-match. Starts at -1 for a new parse.</summary>
        public int CommittedIndex { get; private set; }
        /// <summary>The index of the character we are currently parsing, at minimum it will be CommittedIndex + 1.</summary>
        public int CurrentIndex { get; private set; }

        /// <summary>The current character we are parsing, determined by CurrentIndex.</summary>
        public char Current => !EndOfInput ? currentInput[CurrentIndex] : WHITESPACE;
        /// <summary>The previous character (CurrentIndex - 1), or whitespace if no previous character.</summary>
        public char Previous => CurrentIndex >= 1 ? currentInput[CurrentIndex - 1] : WHITESPACE;

        /// <summary>Returns true if CurrentIndex is >= the current input length.</summary>
        public bool EndOfInput => CurrentIndex > currentEndIdx;
        /// <summary>Returns true if EndOfInput or current character is a new line.</summary>
        public bool EndOrNewLine => EndOfInput || IsNewLine(Current);

        public static bool IsNewLine(char c) => c == '\n' || c == '\r';

        private string currentInput;
        private int currentStartIdx;
        private int currentEndIdx;

        /// <summary>
        /// Parse the range of the string with the Lexer and build a RichText-highlighted representation of it.
        /// </summary>
        /// <param name="input">The entire input string which you want to parse a section (or all) of</param>
        /// <param name="startIdx">The first character you want to highlight</param>
        /// <param name="endIdx">The last character you want to highlight</param>
        /// <param name="leadingLines">The amount of leading empty lines you want before the first character in the return string.</param>
        /// <returns>A string which contains the amount of leading lines specified, as well as the rich-text highlighted section.</returns>
        public string BuildHighlightedString(string input, int startIdx, int endIdx, int leadingLines, int caretIdx, out bool caretInStringOrComment)
        {
            caretInStringOrComment = false;

            if (string.IsNullOrEmpty(input) || endIdx <= startIdx)
                return input;

            currentInput = input;
            currentStartIdx = startIdx;
            currentEndIdx = endIdx;

            StringBuilder sb = new();

            for (int i = 0; i < leadingLines; i++)
                sb.Append('\n');

            int lastUnhighlighted = startIdx;
            foreach (MatchInfo match in GetMatches())
            {
                // append non-highlighted text between last match and this
                for (int i = lastUnhighlighted; i < match.startIndex; i++)
                    sb.Append(input[i]);

                // append the highlighted match
                sb.Append(match.htmlColorTag);
                for (int i = match.startIndex; i <= match.endIndex && i <= currentEndIdx; i++)
                    sb.Append(input[i]);
                sb.Append(SignatureHighlighter.CLOSE_COLOR);

                // update the last unhighlighted start index
                lastUnhighlighted = match.endIndex + 1;

                int matchEndIdx = match.endIndex;
                if (match.matchToEndOfLine)
                {
                    while (input.Length - 1 >= matchEndIdx)
                    {
                        matchEndIdx++;
                        if (IsNewLine(input[matchEndIdx]))
                            break;
                    }
                }

                // check caretIdx to determine inStringOrComment state
                if (caretIdx >= match.startIndex && (caretIdx <= (matchEndIdx + 1) || (caretIdx >= input.Length && matchEndIdx >= input.Length - 1)))
                    caretInStringOrComment = match.isStringOrComment;
            }

            // Append trailing unhighlighted input
            while (lastUnhighlighted <= endIdx)
            {
                sb.Append(input[lastUnhighlighted]);
                lastUnhighlighted++;
            }

            return sb.ToString();
        }


        // Match builder, iterates through each Lexer and returns all matches found.

        public IEnumerable<MatchInfo> GetMatches()
        {
            CommittedIndex = currentStartIdx - 1;
            Rollback();

            while (!EndOfInput)
            {
                SkipWhitespace();
                bool anyMatch = false;
                int startIndex = CommittedIndex + 1;

                foreach (Lexer lexer in lexers)
                {
                    if (lexer.TryMatchCurrent(this))
                    {
                        anyMatch = true;

                        yield return new MatchInfo
                        {
                            startIndex = startIndex,
                            endIndex = CommittedIndex,
                            htmlColorTag = lexer.ColorTag,
                            isStringOrComment = lexer is StringLexer || lexer is CommentLexer,
                        };
                        break;
                    }
                    else
                        Rollback();
                }

                if (!anyMatch)
                {
                    CurrentIndex = CommittedIndex + 1;
                    Commit();
                }
            }
        }

        // Methods used by the Lexers for interfacing with the current parse process

        public char PeekNext(int amount = 1)
        {
            CurrentIndex += amount;
            return Current;
        }

        public void Commit()
        {
            CommittedIndex = Math.Min(currentEndIdx, CurrentIndex);
        }

        public void Rollback()
        {
            CurrentIndex = CommittedIndex + 1;
        }

        public void RollbackBy(int amount)
        {
            CurrentIndex = Math.Max(CommittedIndex + 1, CurrentIndex - amount);
        }

        public bool IsDelimiter(char character, bool orWhitespace = false, bool orLetterOrDigit = false)
        {
            return delimiters.Contains(character)
                || (orWhitespace && char.IsWhiteSpace(character))
                || (orLetterOrDigit && char.IsLetterOrDigit(character));
        }

        private void SkipWhitespace()
        {
            // peek and commit as long as there is whitespace
            while (!EndOfInput && char.IsWhiteSpace(Current))
            {
                Commit();
                PeekNext();
            }

            if (!char.IsWhiteSpace(Current))
                Rollback();
        }

        #region Auto Indenting

        // Using the Lexer for indenting as it already has what we need to tokenize strings and comments.
        // At the moment this only handles when a single newline or close-delimiter is composed.
        // Does not handle copy+paste or any other characters yet.

        public string IndentCharacter(string input, ref int caretIndex)
        {
            int lastCharIndex = caretIndex - 1;
            char c = input[lastCharIndex];

            // we only want to indent for new lines and close indents
            if (!IsNewLine(c) && !IndentCloseChars.Contains(c))
                return input;

            // perform a light parse up to the caret to determine indent level
            currentInput = input;
            currentStartIdx = 0;
            currentEndIdx = lastCharIndex;
            CommittedIndex = -1;
            Rollback();

            int indent = 0;

            while (!EndOfInput)
            {
                if (CurrentIndex >= lastCharIndex)
                {
                    // reached the caret index
                    if (indent <= 0)
                        break;

                    if (IsNewLine(c))
                        input = IndentNewLine(input, indent, ref caretIndex);
                    else // closing indent
                        input = IndentCloseDelimiter(input, indent, lastCharIndex, ref caretIndex);

                    break;
                }

                // Try match strings and comments (Lexer will commit to the end of the match)
                if (stringLexer.TryMatchCurrent(this) || commentLexer.TryMatchCurrent(this))
                {
                    PeekNext();
                    continue;
                }

                // Still parsing, check indent

                if (IndentOpenChars.Contains(Current))
                    indent++;
                else if (IndentCloseChars.Contains(Current))
                    indent--;

                Commit();
                PeekNext();
            }

            return input;
        }

        private string IndentNewLine(string input, int indent, ref int caretIndex)
        {
            // continue until the end of line or next non-whitespace character.
            // if there's a close-indent on this line, reduce the indent level.
            while (CurrentIndex < input.Length - 1)
            {
                CurrentIndex++;
                char next = input[CurrentIndex];
                if (IsNewLine(next))
                    break;
                if (char.IsWhiteSpace(next))
                    continue;
                else if (IndentCloseChars.Contains(next))
                    indent--;

                break;
            }

            if (indent > 0)
            {
                input = input.Insert(caretIndex, new string('\t', indent));
                caretIndex += indent;
            }

            return input;
        }

        private string IndentCloseDelimiter(string input, int indent, int lastCharIndex, ref int caretIndex)
        {
            if (CurrentIndex > lastCharIndex)
            {
                return input;
            }

            // lower the indent level by one as we would not have accounted for this closing symbol
            indent--;

            // go back from the caret to the start of the line, calculate how much indent we need to adjust.
            while (CurrentIndex > 0)
            {
                CurrentIndex--;
                char prev = input[CurrentIndex];
                if (IsNewLine(prev))
                    break;
                if (!char.IsWhiteSpace(prev))
                {
                    // the line containing the closing bracket has non-whitespace characters before it. do not indent.
                    indent = 0;
                    break;
                }
                else if (prev == '\t')
                    indent--;
            }

            if (indent > 0)
            {
                input = input.Insert(caretIndex, new string('\t', indent));
                caretIndex += indent;
            }
            else if (indent < 0)
            {
                // line is overly indented
                input = input.Remove(lastCharIndex - 1, -indent);
                caretIndex += indent;
            }

            return input;
        }

        #endregion
    }
}

```

`src/CSConsole/Lexers/CommentLexer.cs`:

```cs
namespace UnityExplorer.CSConsole.Lexers
{
    public class CommentLexer : Lexer
    {
        private enum CommentType
        {
            Line,
            Block
        }

        // forest green
        protected override Color HighlightColor => new(0.34f, 0.65f, 0.29f, 1.0f);

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            if (lexer.Current == '/')
            {
                lexer.PeekNext();
                if (lexer.Current == '/')
                {
                    // line comment. read to end of line or file.
                    do
                    {
                        lexer.Commit();
                        lexer.PeekNext();
                    }
                    while (!lexer.EndOrNewLine);

                    return true;
                }
                else if (lexer.Current == '*')
                {
                    // block comment, read until end of file or closing '*/'
                    lexer.PeekNext();
                    do
                    {
                        lexer.PeekNext();
                        lexer.Commit();
                    }
                    while (!lexer.EndOfInput && !(lexer.Current == '/' && lexer.Previous == '*'));

                    return true;
                }
            }

            return false;
        }
    }
}

```

`src/CSConsole/Lexers/KeywordLexer.cs`:

```cs
using System.Text;

namespace UnityExplorer.CSConsole.Lexers
{
    public class KeywordLexer : Lexer
    {
        // system blue
        protected override Color HighlightColor => new(0.33f, 0.61f, 0.83f, 1.0f);

        public static readonly HashSet<string> keywords = new()
        {
// reserved keywords
"abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue",
"decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally",
"fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
"long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public",
"readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch",
"this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void",
"volatile", "while",
// contextual keywords
"add", "and", "alias", "ascending", "async", "await", "by", "descending", "dynamic", "equals", "from", "get",
"global", "group", "init", "into", "join", "let", "managed", "nameof",  "not", "notnull", "on",
"or", "orderby", "partial", "record", "remove", "select", "set", "unmanaged", "value", "var", "when", "where",
"where", "with", "yield", "nint", "nuint"
        };

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            char prev = lexer.Previous;
            char first = lexer.Current;

            // check for keywords
            if (lexer.IsDelimiter(prev, true) && char.IsLetter(first))
            {
                // can be a keyword...

                StringBuilder sb = new();
                sb.Append(lexer.Current);
                while (!lexer.EndOfInput && char.IsLetter(lexer.PeekNext()))
                    sb.Append(lexer.Current);

                // next must be whitespace or delimiter
                if (!lexer.EndOfInput && !(char.IsWhiteSpace(lexer.Current) || lexer.IsDelimiter(lexer.Current)))
                    return false;

                if (keywords.Contains(sb.ToString()))
                {
                    if (!lexer.EndOfInput)
                        lexer.RollbackBy(1);
                    lexer.Commit();
                    return true;
                }

                return false;

            }
            else
                return false;
        }
    }
}

```

`src/CSConsole/Lexers/Lexer.cs`:

```cs
namespace UnityExplorer.CSConsole.Lexers
{
    public abstract class Lexer
    {
        public virtual IEnumerable<char> Delimiters => Enumerable.Empty<char>();

        protected abstract Color HighlightColor { get; }

        public string ColorTag => colorTag ?? (colorTag = "<color=#" + HighlightColor.ToHex() + ">");
        private string colorTag;

        public abstract bool TryMatchCurrent(LexerBuilder lexer);
    }
}

```

`src/CSConsole/Lexers/NumberLexer.cs`:

```cs
namespace UnityExplorer.CSConsole.Lexers
{
    public class NumberLexer : Lexer
    {
        // Maroon
        protected override Color HighlightColor => new(0.58f, 0.33f, 0.33f, 1.0f);

        private bool IsNumeric(char c) => char.IsNumber(c) || c == '.';

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            // previous character must be whitespace or delimiter
            if (!lexer.IsDelimiter(lexer.Previous, true))
                return false;

            if (!IsNumeric(lexer.Current))
                return false;

            while (!lexer.EndOfInput)
            {
                lexer.Commit();
                if (!IsNumeric(lexer.PeekNext()))
                    break;
            }

            return true;
        }
    }

}

```

`src/CSConsole/Lexers/StringLexer.cs`:

```cs
namespace UnityExplorer.CSConsole.Lexers
{
    public class StringLexer : Lexer
    {
        public override IEnumerable<char> Delimiters => new[] { '"', '\'', };

        // orange
        protected override Color HighlightColor => new(0.79f, 0.52f, 0.32f, 1.0f);

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            if (lexer.Current == '"')
            {
                if (lexer.Previous == '@')
                {
                    // verbatim string, continue until un-escaped quote.
                    while (!lexer.EndOfInput)
                    {
                        lexer.Commit();
                        if (lexer.PeekNext() == '"')
                        {
                            lexer.Commit();
                            // possibly the end, check for escaped quotes.
                            // commit the character and flip the escape bool for each quote.
                            bool escaped = false;
                            while (lexer.PeekNext() == '"')
                            {
                                lexer.Commit();
                                escaped = !escaped;
                            }
                            // if the last quote wasnt escaped, that was the end of the string.
                            if (!escaped)
                                break;
                        }
                    }
                }
                else
                {
                    // normal string
                    // continue until a quote which is not escaped, or end of input

                    while (!lexer.EndOfInput)
                    {
                        lexer.Commit();
                        lexer.PeekNext();
                        if ((lexer.Current == '"') && lexer.Previous != '\\')
                        {
                            lexer.Commit();
                            break;
                        }
                    }
                }

                return true;
            }
            else if (lexer.Current == '\'')
            {
                // char

                while (!lexer.EndOfInput)
                {
                    lexer.Commit();
                    lexer.PeekNext();
                    if ((lexer.Current == '\'') && lexer.Previous != '\\')
                    {
                        lexer.Commit();
                        break;
                    }
                }

                return true;
            }
            else
                return false;
        }
    }
}

```

`src/CSConsole/Lexers/SymbolLexer.cs`:

```cs
namespace UnityExplorer.CSConsole.Lexers
{
    public class SymbolLexer : Lexer
    {
        // silver
        protected override Color HighlightColor => new(0.6f, 0.6f, 0.6f);

        // all symbols are delimiters
        public override IEnumerable<char> Delimiters => symbols.Where(it => it != '.'); // '.' is not a delimiter, only a separator.

        public static bool IsSymbol(char c) => symbols.Contains(c);

        public static readonly HashSet<char> symbols = new()
        {
            '[', '{', '(',                  // open
            ']', '}', ')',                  // close
            '.', ',', ';', ':', '?', '@',   // special

            // operators
            '+', '-', '*', '/', '%', '&', '|', '^', '~', '=', '<', '>', '!',
        };

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            // previous character must be delimiter, whitespace, or alphanumeric.
            if (!lexer.IsDelimiter(lexer.Previous, true, true))
                return false;

            if (IsSymbol(lexer.Current))
            {
                lexer.Commit();
                return true;
            }

            return false;
        }
    }
}

```

`src/CSConsole/ScriptEvaluator.cs`:

```cs
using Mono.CSharp;
using UnityExplorer.Config;

// Thanks to ManlyMarco for this

namespace UnityExplorer.CSConsole
{
    public class ScriptEvaluator : Evaluator, IDisposable
    {
        internal TextWriter _textWriter;
        internal static StreamReportPrinter _reportPrinter;

        private static readonly HashSet<string> StdLib = new(StringComparer.InvariantCultureIgnoreCase)
        {
            "mscorlib",
            "System.Core",
            "System",
            "System.Xml"
        };

        public ScriptEvaluator(TextWriter tw) : base(BuildContext(tw))
        {
            _textWriter = tw;

            ImportAppdomainAssemblies();
            AppDomain.CurrentDomain.AssemblyLoad += OnAssemblyLoad;
        }

        public void Dispose()
        {
            AppDomain.CurrentDomain.AssemblyLoad -= OnAssemblyLoad;
            _textWriter.Dispose();
        }

        private void OnAssemblyLoad(object sender, AssemblyLoadEventArgs args)
        {
            string name = args.LoadedAssembly.GetName().Name;

            if (StdLib.Contains(name))
                return;

            Reference(args.LoadedAssembly);
        }

        private void Reference(Assembly asm)
        {
            string name = asm.GetName().Name;

            if (name == "completions") // ignore assemblies generated by mcs' autocomplete.
                return;

            foreach (string blacklisted in ConfigManager.CSConsole_Assembly_Blacklist.Value.Split(';'))
            {
                string bl = blacklisted;
                if (bl.EndsWith(".dll", StringComparison.OrdinalIgnoreCase))
                    bl = blacklisted.Substring(0, bl.Length - 4);
                if (string.Equals(bl, name, StringComparison.OrdinalIgnoreCase))
                    return;
            }

            ReferenceAssembly(asm);
        }

        private static CompilerContext BuildContext(TextWriter tw)
        {
            _reportPrinter = new StreamReportPrinter(tw);

            CompilerSettings settings = new()
            {
                Version = LanguageVersion.Experimental,
                GenerateDebugInfo = false,
                StdLib = true,
                Target = Target.Library,
                WarningLevel = 0,
                EnhancedWarnings = false
            };

            return new CompilerContext(settings, _reportPrinter);
        }

        private void ImportAppdomainAssemblies()
        {
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                string name = assembly.GetName().Name;
                if (StdLib.Contains(name))
                    continue;

                try
                {
                    Reference(assembly);
                }
                catch // (Exception ex)
                {
                    //ExplorerCore.LogWarning($"Excepting referencing '{name}': {ex.GetType()}.{ex.Message}");
                }
            }
        }
    }
}

```

`src/CSConsole/ScriptInteraction.cs`:

```cs
using HarmonyLib;
using Mono.CSharp;
using System.Collections;
using System.Text;
using UnityExplorer.UI.Panels;

namespace UnityExplorer.CSConsole
{
    public class ScriptInteraction : InteractiveBase
    {
        public static object CurrentTarget
            => InspectorManager.ActiveInspector?.Target;

        public static object[] AllTargets
            => InspectorManager.Inspectors.Select(it => it.Target).ToArray();

        public static void Log(object message)
            => ExplorerCore.Log(message);

        public static void Inspect(object obj)
            => InspectorManager.Inspect(obj);

        public static void Inspect(Type type)
            => InspectorManager.Inspect(type);

        public static Coroutine Start(IEnumerator ienumerator)
            => RuntimeHelper.StartCoroutine(ienumerator);

        public static void Stop(Coroutine coro)
            => RuntimeHelper.StopCoroutine(coro);

        public static void Copy(object obj)
            => ClipboardPanel.Copy(obj);

        public static object Paste()
            => ClipboardPanel.Current;

        public static void GetUsing()
            => Log(Evaluator.GetUsing());

        public static void GetVars()
        {
            string vars = Evaluator.GetVars()?.Trim();
            if (string.IsNullOrEmpty(vars))
                ExplorerCore.LogWarning("No variables seem to be defined!");
            else
                Log(vars);
        }

        public static void GetClasses()
        {
            if (AccessTools.Field(typeof(Evaluator), "source_file")
                    .GetValue(Evaluator) is CompilationSourceFile sourceFile
                && sourceFile.Containers.Any())
            {
                StringBuilder sb = new();
                sb.Append($"There are {sourceFile.Containers.Count} defined classes:");
                foreach (TypeDefinition type in sourceFile.Containers.Where(it => it is TypeDefinition))
                {
                    sb.Append($"\n\n{type.MemberName.Name}:");
                    foreach (MemberCore member in type.Members)
                        sb.Append($"\n\t- {member.AttributeTargets}: \"{member.MemberName.Name}\" ({member.ModFlags})");
                }
                Log(sb.ToString());
            }
            else
                ExplorerCore.LogWarning("No classes seem to be defined.");

        }
    }
}

```

`src/CacheObject/CacheConfigEntry.cs`:

```cs
using UnityExplorer.CacheObject.Views;
using UnityExplorer.Config;

namespace UnityExplorer.CacheObject
{
    public class CacheConfigEntry : CacheObjectBase
    {
        public CacheConfigEntry(IConfigElement configElement)
        {
            this.RefConfigElement = configElement;
            this.FallbackType = configElement.ElementType;

            this.NameLabelText = $"<color=cyan>{configElement.Name}</color>" +
                $"\r\n<color=grey><i>{configElement.Description}</i></color>";
            this.NameLabelTextRaw = string.Empty;

            configElement.OnValueChangedNotify += UpdateValueFromSource;
        }

        public IConfigElement RefConfigElement;

        public override bool ShouldAutoEvaluate => true;
        public override bool HasArguments => false;
        public override bool CanWrite => true;

        public void UpdateValueFromSource()
        {
            //if (RefConfigElement.BoxedValue.Equals(this.Value))
            //    return;

            SetValueFromSource(RefConfigElement.BoxedValue);

            if (this.CellView != null)
                this.SetDataToCell(CellView);
        }

        public override void TrySetUserValue(object value)
        {
            this.Value = value;
            RefConfigElement.BoxedValue = value;
        }

        protected override bool TryAutoEvaluateIfUnitialized(CacheObjectCell cell) => true;
    }
}

```

`src/CacheObject/CacheConstructor.cs`:

```cs
using UnityExplorer.Inspectors;

namespace UnityExplorer.CacheObject
{
    public class CacheConstructor : CacheMember
    {
        public ConstructorInfo CtorInfo { get; }
        readonly Type typeForStructConstructor;

        public override Type DeclaringType => typeForStructConstructor ?? CtorInfo.DeclaringType;
        public override bool IsStatic => true;
        public override bool ShouldAutoEvaluate => false;
        public override bool CanWrite => false;

        public CacheConstructor(ConstructorInfo ci)
        {
            this.CtorInfo = ci;
        }

        public CacheConstructor(Type typeForStructConstructor)
        {
            this.typeForStructConstructor = typeForStructConstructor;
        }

        public override void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            Type ctorReturnType;
            // if is parameterless struct ctor
            if (typeForStructConstructor != null)
            {
                ctorReturnType = typeForStructConstructor;
                this.Owner = inspector;

                // eg. Vector3.Vector3()
                this.NameLabelText = SignatureHighlighter.Parse(typeForStructConstructor, false);
                NameLabelText += $".{NameLabelText}()";

                this.NameForFiltering = SignatureHighlighter.RemoveHighlighting(NameLabelText);
                this.NameLabelTextRaw = NameForFiltering;
                return;
            }
            else
            {
                base.SetInspectorOwner(inspector, member);

                Arguments = CtorInfo.GetParameters();
                ctorReturnType = CtorInfo.DeclaringType;
            }

            if (ctorReturnType.IsGenericTypeDefinition)
                GenericArguments = ctorReturnType.GetGenericArguments();
        }

        protected override object TryEvaluate()
        {
            try
            {
                Type returnType = DeclaringType;

                if (returnType.IsGenericTypeDefinition)
                    returnType = DeclaringType.MakeGenericType(Evaluator.TryParseGenericArguments());

                object ret;
                if (HasArguments)
                    ret = Activator.CreateInstance(returnType, Evaluator.TryParseArguments());
                else
                    ret = Activator.CreateInstance(returnType, ArgumentUtility.EmptyArgs);

                LastException = null;
                return ret;
            }
            catch (Exception ex)
            {
                LastException = ex;
                return null;
            }
        }

        protected override void TrySetValue(object value) => throw new NotImplementedException("You can't set a constructor");
    }
}

```

`src/CacheObject/CacheField.cs`:

```cs
using UnityExplorer.Inspectors;

namespace UnityExplorer.CacheObject
{
    public class CacheField : CacheMember
    {
        public FieldInfo FieldInfo { get; internal set; }
        public override Type DeclaringType => FieldInfo.DeclaringType;
        public override bool IsStatic => FieldInfo.IsStatic;
        public override bool CanWrite => m_canWrite ?? (bool)(m_canWrite = !(FieldInfo.IsLiteral && !FieldInfo.IsInitOnly));
        private bool? m_canWrite;

        public override bool ShouldAutoEvaluate => true;

        public CacheField(FieldInfo fi)
        {
            this.FieldInfo = fi;
        }

        public override void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            base.SetInspectorOwner(inspector, member);
        }

        protected override object TryEvaluate()
        {
            try
            {
                object ret = FieldInfo.GetValue(DeclaringInstance);
                LastException = null;
                return ret;
            }
            catch (Exception ex)
            {
                LastException = ex;
                return null;
            }
        }

        protected override void TrySetValue(object value)
        {
            try
            {
                FieldInfo.SetValue(DeclaringInstance, value);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning(ex);
            }
        }
    }
}

```

`src/CacheObject/CacheKeyValuePair.cs`:

```cs
using UnityExplorer.CacheObject.IValues;
using UnityExplorer.CacheObject.Views;

namespace UnityExplorer.CacheObject
{
    public class CacheKeyValuePair : CacheObjectBase
    {
        //public InteractiveList CurrentList { get; set; }

        public int DictIndex;
        public object DictKey;
        public object DisplayedKey;

        public bool KeyInputWanted;
        public bool InspectWanted;
        public string KeyLabelText;
        public string KeyInputText;
        public string KeyInputTypeText;

        public float DesiredKeyWidth;
        public float DesiredValueWidth;

        public override bool ShouldAutoEvaluate => true;
        public override bool HasArguments => false;
        public override bool CanWrite => Owner.CanWrite;

        public void SetDictOwner(InteractiveDictionary dict, int index)
        {
            this.Owner = dict;
            this.DictIndex = index;
        }

        public void SetKey(object key)
        {
            this.DictKey = key;
            this.DisplayedKey = key.TryCast();

            Type type = DisplayedKey.GetType();
            if (ParseUtility.CanParse(type))
            {
                KeyInputWanted = true;
                KeyInputText = ParseUtility.ToStringForInput(DisplayedKey, type);
                KeyInputTypeText = SignatureHighlighter.Parse(type, false);
            }
            else
            {
                KeyInputWanted = false;
                InspectWanted = type != typeof(bool) && !type.IsEnum;
                KeyLabelText = ToStringUtility.ToStringWithType(DisplayedKey, type, true);
            }
        }

        public override void SetDataToCell(CacheObjectCell cell)
        {
            base.SetDataToCell(cell);

            CacheKeyValuePairCell kvpCell = cell as CacheKeyValuePairCell;

            kvpCell.NameLabel.text = $"{DictIndex}:";
            kvpCell.HiddenNameLabel.Text = "";
            kvpCell.Image.color = DictIndex % 2 == 0 ? CacheListEntryCell.EvenColor : CacheListEntryCell.OddColor;

            if (KeyInputWanted)
            {
                kvpCell.KeyInputField.UIRoot.SetActive(true);
                kvpCell.KeyInputTypeLabel.gameObject.SetActive(true);
                kvpCell.KeyLabel.gameObject.SetActive(false);
                kvpCell.KeyInspectButton.Component.gameObject.SetActive(false);

                kvpCell.KeyInputField.Text = KeyInputText;
                kvpCell.KeyInputTypeLabel.text = KeyInputTypeText;
            }
            else
            {
                kvpCell.KeyInputField.UIRoot.SetActive(false);
                kvpCell.KeyInputTypeLabel.gameObject.SetActive(false);
                kvpCell.KeyLabel.gameObject.SetActive(true);
                kvpCell.KeyInspectButton.Component.gameObject.SetActive(InspectWanted);

                kvpCell.KeyLabel.text = KeyLabelText;
            }
        }

        public override void TrySetUserValue(object value)
        {
            (Owner as InteractiveDictionary).TrySetValueToKey(DictKey, value, DictIndex);
        }


        protected override bool TryAutoEvaluateIfUnitialized(CacheObjectCell cell) => true;
    }
}

```

`src/CacheObject/CacheListEntry.cs`:

```cs
using UnityExplorer.CacheObject.IValues;
using UnityExplorer.CacheObject.Views;

namespace UnityExplorer.CacheObject
{
    public class CacheListEntry : CacheObjectBase
    {
        public int ListIndex;

        public override bool ShouldAutoEvaluate => true;
        public override bool HasArguments => false;
        public override bool CanWrite => Owner?.CanWrite ?? false;

        public void SetListOwner(InteractiveList list, int listIndex)
        {
            this.Owner = list;
            this.ListIndex = listIndex;
        }

        public override void SetDataToCell(CacheObjectCell cell)
        {
            base.SetDataToCell(cell);

            CacheListEntryCell listCell = cell as CacheListEntryCell;

            listCell.NameLabel.text = $"{ListIndex}:";
            listCell.HiddenNameLabel.Text = "";
            listCell.Image.color = ListIndex % 2 == 0 ? CacheListEntryCell.EvenColor : CacheListEntryCell.OddColor;
        }

        public override void TrySetUserValue(object value)
        {
            (Owner as InteractiveList).TrySetValueToIndex(value, this.ListIndex);
        }

        protected override bool TryAutoEvaluateIfUnitialized(CacheObjectCell cell) => true;
    }
}

```

`src/CacheObject/CacheMember.cs`:

```cs
using UnityExplorer.CacheObject.Views;
using UnityExplorer.Inspectors;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.CacheObject
{
    public abstract class CacheMember : CacheObjectBase
    {
        public abstract Type DeclaringType { get; }
        public string NameForFiltering { get; protected set; }
        public object DeclaringInstance => IsStatic ? null : (m_declaringInstance ??= Owner.Target.TryCast(DeclaringType));
        private object m_declaringInstance;

        public abstract bool IsStatic { get; }
        public override bool HasArguments => Arguments?.Length > 0 || GenericArguments.Length > 0;
        public ParameterInfo[] Arguments { get; protected set; } = new ParameterInfo[0];
        public Type[] GenericArguments { get; protected set; } = ArgumentUtility.EmptyTypes;
        public EvaluateWidget Evaluator { get; protected set; }
        public bool Evaluating => Evaluator != null && Evaluator.UIRoot.activeSelf;

        public virtual void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            this.Owner = inspector;
            this.NameLabelText = this switch
            {
                CacheMethod => SignatureHighlighter.ParseMethod(member as MethodInfo),
                CacheConstructor => SignatureHighlighter.ParseConstructor(member as ConstructorInfo),
                _ => SignatureHighlighter.Parse(member.DeclaringType, false, member),
            };

            this.NameForFiltering = SignatureHighlighter.RemoveHighlighting(NameLabelText);
            this.NameLabelTextRaw = NameForFiltering;
        }

        public override void ReleasePooledObjects()
        {
            base.ReleasePooledObjects();

            if (this.Evaluator != null)
            {
                this.Evaluator.OnReturnToPool();
                Pool<EvaluateWidget>.Return(this.Evaluator);
                this.Evaluator = null;
            }
        }

        public override void UnlinkFromView()
        {
            if (this.Evaluator != null)
                this.Evaluator.UIRoot.transform.SetParent(Pool<EvaluateWidget>.Instance.InactiveHolder.transform, false);

            base.UnlinkFromView();
        }

        protected abstract object TryEvaluate();

        protected abstract void TrySetValue(object value);

        /// <summary>
        /// Evaluate is called when first shown (if ShouldAutoEvaluate), or else when Evaluate button is clicked, or auto-updated.
        /// </summary>
        public void Evaluate()
        {
            SetValueFromSource(TryEvaluate());
        }

        /// <summary>
        /// Called when user presses the Evaluate button.
        /// </summary>
        public void EvaluateAndSetCell()
        {
            Evaluate();
            if (CellView != null)
                SetDataToCell(CellView);
        }

        public override void TrySetUserValue(object value)
        {
            TrySetValue(value);
            Evaluate();
        }

        protected override void SetValueState(CacheObjectCell cell, ValueStateArgs args)
        {
            base.SetValueState(cell, args);
        }

        private static readonly Color evalEnabledColor = new(0.15f, 0.25f, 0.15f);
        private static readonly Color evalDisabledColor = new(0.15f, 0.15f, 0.15f);

        protected override bool TryAutoEvaluateIfUnitialized(CacheObjectCell objectcell)
        {
            CacheMemberCell cell = objectcell as CacheMemberCell;

            cell.EvaluateHolder.SetActive(!ShouldAutoEvaluate);
            if (!ShouldAutoEvaluate)
            {
                cell.EvaluateButton.Component.gameObject.SetActive(true);
                if (HasArguments)
                {
                    if (!Evaluating)
                        cell.EvaluateButton.ButtonText.text = $"Evaluate ({Arguments.Length + GenericArguments.Length})";
                    else
                    {
                        cell.EvaluateButton.ButtonText.text = "Hide";
                        Evaluator.UIRoot.transform.SetParent(cell.EvaluateHolder.transform, false);
                        RuntimeHelper.SetColorBlock(cell.EvaluateButton.Component, evalEnabledColor, evalEnabledColor * 1.3f);
                    }
                }
                else
                    cell.EvaluateButton.ButtonText.text = "Evaluate";

                if (!Evaluating)
                    RuntimeHelper.SetColorBlock(cell.EvaluateButton.Component, evalDisabledColor, evalDisabledColor * 1.3f);
            }

            if (State == ValueState.NotEvaluated && !ShouldAutoEvaluate)
            {
                SetValueState(cell, ValueStateArgs.Default);
                cell.RefreshSubcontentButton();

                return false;
            }

            if (State == ValueState.NotEvaluated)
                Evaluate();

            return true;
        }

        public void OnEvaluateClicked()
        {
            if (!HasArguments)
            {
                EvaluateAndSetCell();
            }
            else
            {
                if (Evaluator == null)
                {
                    this.Evaluator = Pool<EvaluateWidget>.Borrow();
                    Evaluator.OnBorrowedFromPool(this);
                    Evaluator.UIRoot.transform.SetParent((CellView as CacheMemberCell).EvaluateHolder.transform, false);
                    TryAutoEvaluateIfUnitialized(CellView);
                }
                else
                {
                    if (Evaluator.UIRoot.activeSelf)
                        Evaluator.UIRoot.SetActive(false);
                    else
                        Evaluator.UIRoot.SetActive(true);

                    TryAutoEvaluateIfUnitialized(CellView);
                }
            }
        }
    }
}

```

`src/CacheObject/CacheMemberFactory.cs`:

```cs
using HarmonyLib;
using UnityExplorer.Inspectors;
using UnityExplorer.Runtime;

namespace UnityExplorer.CacheObject
{
    public static class CacheMemberFactory
    {
        public static List<CacheMember> GetCacheMembers(Type type, ReflectionInspector inspector)
        {
            //var list = new List<CacheMember>();
            HashSet<string> cachedSigs = new();
            List<CacheMember> props = new();
            List<CacheMember> fields = new();
            List<CacheMember> ctors = new();
            List<CacheMember> methods = new();

            Type[] types = ReflectionUtility.GetAllBaseTypes(type);

            BindingFlags flags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static;
            if (!inspector.StaticOnly)
                flags |= BindingFlags.Instance;

            if (!type.IsAbstract)
            {
                // Get non-static constructors of the main type.
                // There's no reason to get the static cctor, it will be invoked when we inspect the class.
                // Also no point getting ctors on inherited types.
                foreach (ConstructorInfo ctor in type.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
                    TryCacheMember(ctor, ctors, cachedSigs, type, inspector);

                // structs always have a parameterless constructor
                if (type.IsValueType)
                {
                    CacheConstructor cached = new(type);
                    cached.SetFallbackType(type);
                    cached.SetInspectorOwner(inspector, null);
                    ctors.Add(cached);
                }
            }

            foreach (Type declaringType in types)
            {
                foreach (PropertyInfo prop in declaringType.GetProperties(flags))
                    if (prop.DeclaringType == declaringType)
                        TryCacheMember(prop, props, cachedSigs, declaringType, inspector);

                foreach (FieldInfo field in declaringType.GetFields(flags))
                    if (field.DeclaringType == declaringType)
                        TryCacheMember(field, fields, cachedSigs, declaringType, inspector);

                foreach (MethodInfo method in declaringType.GetMethods(flags))
                    if (method.DeclaringType == declaringType)
                        TryCacheMember(method, methods, cachedSigs, declaringType, inspector);

            }

            List<CacheMember> sorted = new();
            sorted.AddRange(props.OrderBy(it => Array.IndexOf(types, it.DeclaringType))
                                 .ThenBy(it => it.NameForFiltering));
            sorted.AddRange(fields.OrderBy(it => Array.IndexOf(types, it.DeclaringType))
                                 .ThenBy(it => it.NameForFiltering));
            sorted.AddRange(ctors.OrderBy(it => Array.IndexOf(types, it.DeclaringType))
                                 .ThenBy(it => it.NameForFiltering));
            sorted.AddRange(methods.OrderBy(it => Array.IndexOf(types, it.DeclaringType))
                                 .ThenBy(it => it.NameForFiltering));
            return sorted;
        }

        static void TryCacheMember<T>(MemberInfo member, List<T> list, HashSet<string> cachedSigs,
            Type declaringType, ReflectionInspector inspector, bool ignorePropertyMethodInfos = true)
            where T : CacheMember
        {
            try
            {
                if (UERuntimeHelper.IsBlacklisted(member))
                    return;

                string sig = member switch
                {
                    MethodBase mb => mb.FullDescription(), // (method or constructor)
                    PropertyInfo or FieldInfo => $"{member.DeclaringType.FullDescription()}.{member.Name}",
                    _ => throw new NotImplementedException(),
                };

                if (cachedSigs.Contains(sig))
                    return;

                // ExplorerCore.Log($"Trying to cache member {sig}... ({member.MemberType})");

                CacheMember cached;
                Type returnType;

                switch (member.MemberType)
                {
                    case MemberTypes.Constructor:
                        {
                            ConstructorInfo ci = member as ConstructorInfo;
                            cached = new CacheConstructor(ci);
                            returnType = ci.DeclaringType;
                        }
                        break;

                    case MemberTypes.Method:
                        {
                            MethodInfo mi = member as MethodInfo;
                            if (ignorePropertyMethodInfos
                                && (mi.Name.StartsWith("get_") || mi.Name.StartsWith("set_")))
                                return;

                            cached = new CacheMethod(mi);
                            returnType = mi.ReturnType;
                            break;
                        }

                    case MemberTypes.Property:
                        {
                            PropertyInfo pi = member as PropertyInfo;

                            if (!pi.CanRead && pi.CanWrite)
                            {
                                // write-only property, cache the set method instead.
                                MethodInfo setMethod = pi.GetSetMethod(true);
                                if (setMethod != null)
                                    TryCacheMember(setMethod, list, cachedSigs, declaringType, inspector, false);
                                return;
                            }

                            cached = new CacheProperty(pi);
                            returnType = pi.PropertyType;
                            break;
                        }

                    case MemberTypes.Field:
                        {
                            FieldInfo fi = member as FieldInfo;
                            cached = new CacheField(fi);
                            returnType = fi.FieldType;
                            break;
                        }

                    default:
                        throw new NotImplementedException();
                }

                cachedSigs.Add(sig);

                cached.SetFallbackType(returnType);
                cached.SetInspectorOwner(inspector, member);

                list.Add((T)cached);
            }
            catch (Exception e)
            {
                ExplorerCore.LogWarning($"Exception caching member {member.DeclaringType.FullName}.{member.Name}!");
                ExplorerCore.Log(e);
            }
        }
    }
}

```

`src/CacheObject/CacheMethod.cs`:

```cs
using UnityExplorer.Inspectors;

namespace UnityExplorer.CacheObject
{
    public class CacheMethod : CacheMember
    {
        public MethodInfo MethodInfo { get; }
        public override Type DeclaringType => MethodInfo.DeclaringType;
        public override bool CanWrite => false;
        public override bool IsStatic => MethodInfo.IsStatic;

        public override bool ShouldAutoEvaluate => false;

        public CacheMethod(MethodInfo mi)
        {
            this.MethodInfo = mi;
        }

        public override void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            base.SetInspectorOwner(inspector, member);

            Arguments = MethodInfo.GetParameters();
            if (MethodInfo.IsGenericMethod)
                GenericArguments = MethodInfo.GetGenericArguments();
        }

        protected override object TryEvaluate()
        {
            try
            {
                MethodInfo methodInfo = MethodInfo;
                if (methodInfo.IsGenericMethod)
                    methodInfo = MethodInfo.MakeGenericMethod(Evaluator.TryParseGenericArguments());

                object ret;
                if (HasArguments)
                    ret = methodInfo.Invoke(DeclaringInstance, Evaluator.TryParseArguments());
                else
                    ret = methodInfo.Invoke(DeclaringInstance, ArgumentUtility.EmptyArgs);
                LastException = null;
                return ret;
            }
            catch (Exception ex)
            {
                LastException = ex;
                return null;
            }
        }

        protected override void TrySetValue(object value) => throw new NotImplementedException("You can't set a method");
    }
}

```

`src/CacheObject/CacheObjectBase.cs`:

```cs
using System.Collections;
using UnityExplorer.CacheObject.IValues;
using UnityExplorer.CacheObject.Views;
using UniverseLib.UI;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.CacheObject
{
    public enum ValueState
    {
        NotEvaluated,
        Exception,
        Boolean,
        Number,
        String,
        Enum,
        Collection,
        Dictionary,
        ValueStruct,
        Color,
        Unsupported
    }

    public abstract class CacheObjectBase
    {
        public ICacheObjectController Owner { get; set; }
        public CacheObjectCell CellView { get; internal set; }

        public object Value { get; protected set; }
        public Type FallbackType { get; protected set; }
        public ValueState State { get; set; }
        public Exception LastException { get; protected set; }
        bool valueIsNull;
        Type currentValueType;

        // InteractiveValues
        public InteractiveValue IValue { get; private set; }
        public Type CurrentIValueType { get; private set; }
        public bool SubContentShowWanted { get; private set; }

        // UI
        public string NameLabelText { get; protected set; }
        public string NameLabelTextRaw { get; protected set; }
        public string ValueLabelText { get; protected set; }

        // Abstract
        public abstract bool ShouldAutoEvaluate { get; }
        public abstract bool HasArguments { get; }
        public abstract bool CanWrite { get; }

        protected const string NOT_YET_EVAL = "<color=grey>Not yet evaluated</color>";

        public virtual void SetFallbackType(Type fallbackType)
        {
            this.FallbackType = fallbackType;
            this.ValueLabelText = GetValueLabel();
        }

        public virtual void SetView(CacheObjectCell cellView)
        {
            this.CellView = cellView;
            cellView.Occupant = this;
        }

        public virtual void UnlinkFromView()
        {
            if (this.CellView == null)
                return;

            this.CellView.Occupant = null;
            this.CellView = null;

            if (this.IValue != null)
                this.IValue.UIRoot.transform.SetParent(InactiveIValueHolder.transform, false);
        }

        public virtual void ReleasePooledObjects()
        {
            if (this.IValue != null)
                ReleaseIValue();

            if (this.CellView != null)
                UnlinkFromView();
        }

        // Updating and applying values

        // The only method which sets the CacheObjectBase.Value
        public virtual void SetValueFromSource(object value)
        {
            this.Value = value;

            if (!Value.IsNullOrDestroyed())
                Value = Value.TryCast();

            ProcessOnEvaluate();

            if (this.IValue != null)
            {
                if (SubContentShowWanted)
                    this.IValue.SetValue(Value);
                else
                    IValue.PendingValueWanted = true;
            }
        }

        public void SetUserValue(object value)
        {
            value = value.TryCast(FallbackType);

            TrySetUserValue(value);

            if (CellView != null)
                SetDataToCell(CellView);

            // If the owner's ParentCacheObject is set, we are setting the value of an inspected struct.
            // Set the inspector target as the value back to that parent.
            if (Owner.ParentCacheObject != null)
                Owner.ParentCacheObject.SetUserValue(Owner.Target);
        }

        public abstract void TrySetUserValue(object value);

        protected virtual void ProcessOnEvaluate()
        {
            ValueState prevState = State;

            if (LastException != null)
            {
                valueIsNull = true;
                currentValueType = FallbackType;
                State = ValueState.Exception;
            }
            else if (Value.IsNullOrDestroyed())
            {
                valueIsNull = true;
                State = GetStateForType(FallbackType);
            }
            else
            {
                valueIsNull = false;
                State = GetStateForType(Value.GetActualType());
            }

            if (IValue != null)
            {
                // If we changed states (always needs IValue change)
                // or if the value is null, and the fallback type isnt string (we always want to edit strings).
                if (State != prevState || (State != ValueState.String && State != ValueState.Exception && Value.IsNullOrDestroyed()))
                {
                    // need to return IValue
                    ReleaseIValue();
                    SubContentShowWanted = false;
                }
            }

            // Set label text
            this.ValueLabelText = GetValueLabel();
        }

        public ValueState GetStateForType(Type type)
        {
            if (currentValueType == type && (State != ValueState.Exception || LastException != null))
                return State;

            currentValueType = type;
            if (type == typeof(bool))
                return ValueState.Boolean;
            else if (type.IsPrimitive || type == typeof(decimal))
                return ValueState.Number;
            else if (type == typeof(string))
                return ValueState.String;
            else if (type.IsEnum)
                return ValueState.Enum;
            else if (type == typeof(Color) || type == typeof(Color32))
                return ValueState.Color;
            else if (InteractiveValueStruct.SupportsType(type))
                return ValueState.ValueStruct;
            else if (ReflectionUtility.IsDictionary(type))
                return ValueState.Dictionary;
            else if (!typeof(Transform).IsAssignableFrom(type) && ReflectionUtility.IsEnumerable(type))
                return ValueState.Collection;
            else
                return ValueState.Unsupported;
        }

        protected string GetValueLabel()
        {
            string label = string.Empty;

            switch (State)
            {
                case ValueState.NotEvaluated:
                    return $"<i>{NOT_YET_EVAL} ({SignatureHighlighter.Parse(FallbackType, true)})</i>";

                case ValueState.Exception:
                    return $"<i><color=#eb4034>{LastException.ReflectionExToString()}</color></i>";

                // bool and number dont want the label for the value at all
                case ValueState.Boolean:
                case ValueState.Number:
                    return null;

                // and valuestruct also doesnt want it if we can parse it
                case ValueState.ValueStruct:
                    if (ParseUtility.CanParse(currentValueType))
                        return null;
                    break;

                // string wants it trimmed to max 200 chars
                case ValueState.String:
                    if (!valueIsNull)
                        return $"\"{ToStringUtility.PruneString(Value as string, 200, 5)}\"";
                    break;

                // try to prefix the count of the collection for lists and dicts
                case ValueState.Collection:
                    if (!valueIsNull)
                    {
                        if (Value is IList iList)
                            label = $"[{iList.Count}] ";
                        else if (Value is ICollection iCol)
                            label = $"[{iCol.Count}] ";
                        else
                            label = "[?] ";
                    }
                    break;

                case ValueState.Dictionary:
                    if (!valueIsNull)
                    {
                        if (Value is IDictionary iDict)
                            label = $"[{iDict.Count}] ";
                        else
                            label = "[?] ";
                    }
                    break;
            }

            // Cases which dont return will append to ToStringWithType

            return label += ToStringUtility.ToStringWithType(Value, FallbackType, true);
        }

        // Setting cell state from our model

        /// <summary>Return false if SetCell should abort, true if it should continue.</summary>
        protected abstract bool TryAutoEvaluateIfUnitialized(CacheObjectCell cell);

        public virtual void SetDataToCell(CacheObjectCell cell)
        {
            cell.NameLabel.text = NameLabelText;
            if (cell.HiddenNameLabel != null)
                cell.HiddenNameLabel.Text = NameLabelTextRaw ?? string.Empty;
            cell.ValueLabel.gameObject.SetActive(true);

            cell.SubContentHolder.gameObject.SetActive(SubContentShowWanted);
            if (IValue != null)
            {
                IValue.UIRoot.transform.SetParent(cell.SubContentHolder.transform, false);
                IValue.SetLayout();
            }

            bool evaluated = TryAutoEvaluateIfUnitialized(cell);

            if (cell.CopyButton != null)
            {
                bool canCopy = State != ValueState.NotEvaluated && State != ValueState.Exception;
                cell.CopyButton.Component.gameObject.SetActive(canCopy);
                cell.PasteButton.Component.gameObject.SetActive(canCopy && this.CanWrite);
            }

            if (!evaluated)
                return;

            // The following only executes if the object has evaluated.
            // For members and properties with args, they will return by default now.

            switch (State)
            {
                case ValueState.Exception:
                    SetValueState(cell, new(true, subContentButtonActive: true));
                    break;
                case ValueState.Boolean:
                    SetValueState(cell, new(false, toggleActive: true, applyActive: CanWrite));
                    break;
                case ValueState.Number:
                    SetValueState(cell, new(false, typeLabelActive: true, inputActive: true, applyActive: CanWrite));
                    break;
                case ValueState.String:
                    if (valueIsNull)
                        SetValueState(cell, new(true, subContentButtonActive: true));
                    else
                        SetValueState(cell, new(true, false, SignatureHighlighter.StringOrange, subContentButtonActive: true));
                    break;
                case ValueState.Enum:
                    SetValueState(cell, new(true, subContentButtonActive: CanWrite));
                    break;
                case ValueState.Color:
                case ValueState.ValueStruct:
                    if (ParseUtility.CanParse(currentValueType))
                        SetValueState(cell, new(false, false, null, true, false, true, CanWrite, true, true));
                    else
                        SetValueState(cell, new(true, inspectActive: true, subContentButtonActive: true));
                    break;
                case ValueState.Collection:
                case ValueState.Dictionary:
                    SetValueState(cell, new(true, inspectActive: !valueIsNull, subContentButtonActive: !valueIsNull));
                    break;
                case ValueState.Unsupported:
                    SetValueState(cell, new(true, inspectActive: !valueIsNull));
                    break;
            }

            cell.RefreshSubcontentButton();
        }

        protected virtual void SetValueState(CacheObjectCell cell, ValueStateArgs args)
        {
            // main value label
            if (args.valueActive)
            {
                cell.ValueLabel.text = ValueLabelText;
                cell.ValueLabel.supportRichText = args.valueRichText;
                cell.ValueLabel.color = args.valueColor;
            }
            else
                cell.ValueLabel.text = "";

            // Type label (for primitives)
            cell.TypeLabel.gameObject.SetActive(args.typeLabelActive);
            if (args.typeLabelActive)
                cell.TypeLabel.text = SignatureHighlighter.Parse(currentValueType, false);

            // toggle for bools
            cell.Toggle.gameObject.SetActive(args.toggleActive);
            if (args.toggleActive)
            {
                cell.Toggle.interactable = CanWrite;
                cell.Toggle.isOn = (bool)Value;
                cell.ToggleText.text = Value.ToString();
            }

            // inputfield for numbers
            cell.InputField.UIRoot.SetActive(args.inputActive);
            if (args.inputActive)
            {
                cell.InputField.Text = ParseUtility.ToStringForInput(Value, currentValueType);
                cell.InputField.Component.readOnly = !CanWrite;
            }

            // apply for bool and numbers
            cell.ApplyButton.Component.gameObject.SetActive(args.applyActive);

            // Inspect button only if last value not null.
            if (cell.InspectButton != null)
                cell.InspectButton.Component.gameObject.SetActive(args.inspectActive && !valueIsNull);

            // set subcontent button if needed, and for null strings and exceptions
            cell.SubContentButton.Component.gameObject.SetActive(
                args.subContentButtonActive
                && (!valueIsNull || State == ValueState.String || State == ValueState.Exception));
        }

        // CacheObjectCell Apply

        public virtual void OnCellApplyClicked()
        {
            if (State == ValueState.Boolean)
                SetUserValue(this.CellView.Toggle.isOn);
            else
            {
                if (ParseUtility.TryParse(CellView.InputField.Text, currentValueType, out object value, out Exception ex))
                {
                    SetUserValue(value);
                }
                else
                {
                    ExplorerCore.LogWarning("Unable to parse input!");
                    if (ex != null)
                        ExplorerCore.Log(ex.ReflectionExToString());
                }
            }

            SetDataToCell(this.CellView);
        }

        // IValues

        public virtual void OnCellSubContentToggle()
        {
            if (this.IValue == null)
            {
                Type ivalueType = InteractiveValue.GetIValueTypeForState(State);

                if (ivalueType == null)
                    return;

                IValue = (InteractiveValue)Pool.Borrow(ivalueType);
                CurrentIValueType = ivalueType;

                IValue.OnBorrowed(this);
                IValue.SetValue(this.Value);
                IValue.UIRoot.transform.SetParent(CellView.SubContentHolder.transform, false);
                CellView.SubContentHolder.SetActive(true);
                SubContentShowWanted = true;

                // update our cell after creating the ivalue (the value may have updated, make sure its consistent)
                this.ProcessOnEvaluate();
                this.SetDataToCell(this.CellView);
            }
            else
            {
                SubContentShowWanted = !SubContentShowWanted;
                CellView.SubContentHolder.SetActive(SubContentShowWanted);

                if (SubContentShowWanted && IValue.PendingValueWanted)
                {
                    IValue.PendingValueWanted = false;
                    this.ProcessOnEvaluate();
                    this.SetDataToCell(this.CellView);
                    IValue.SetValue(this.Value);
                }
            }

            CellView.RefreshSubcontentButton();
        }

        public virtual void ReleaseIValue()
        {
            if (IValue == null)
                return;

            IValue.ReleaseFromOwner();
            Pool.Return(CurrentIValueType, IValue);

            IValue = null;
        }

        internal static GameObject InactiveIValueHolder
        {
            get
            {
                if (!inactiveIValueHolder)
                {
                    inactiveIValueHolder = new GameObject("Temp_IValue_Holder");
                    GameObject.DontDestroyOnLoad(inactiveIValueHolder);
                    inactiveIValueHolder.hideFlags = HideFlags.HideAndDontSave;
                    inactiveIValueHolder.transform.parent = UniversalUI.PoolHolder.transform;
                    inactiveIValueHolder.SetActive(false);
                }
                return inactiveIValueHolder;
            }
        }
        private static GameObject inactiveIValueHolder;

        // Value state args helper

        public struct ValueStateArgs
        {
            public static ValueStateArgs Default { get; } = new(true);

            public Color valueColor;
            public bool valueActive, valueRichText, typeLabelActive, toggleActive, inputActive, applyActive, inspectActive, subContentButtonActive;

            public ValueStateArgs(bool valueActive = true,
                bool valueRichText = true,
                Color? valueColor = null,
                bool typeLabelActive = false,
                bool toggleActive = false,
                bool inputActive = false,
                bool applyActive = false,
                bool inspectActive = false,
                bool subContentButtonActive = false)
            {
                this.valueActive = valueActive;
                this.valueRichText = valueRichText;
                this.valueColor = valueColor == null ? Color.white : (Color)valueColor;
                this.typeLabelActive = typeLabelActive;
                this.toggleActive = toggleActive;
                this.inputActive = inputActive;
                this.applyActive = applyActive;
                this.inspectActive = inspectActive;
                this.subContentButtonActive = subContentButtonActive;
            }
        }
    }
}

```

`src/CacheObject/CacheProperty.cs`:

```cs
using UnityExplorer.Inspectors;

namespace UnityExplorer.CacheObject
{
    public class CacheProperty : CacheMember
    {
        public PropertyInfo PropertyInfo { get; internal set; }
        public override Type DeclaringType => PropertyInfo.DeclaringType;
        public override bool CanWrite => PropertyInfo.CanWrite;
        public override bool IsStatic => m_isStatic ?? (bool)(m_isStatic = PropertyInfo.GetAccessors(true)[0].IsStatic);
        private bool? m_isStatic;

        public override bool ShouldAutoEvaluate => !HasArguments;

        public CacheProperty(PropertyInfo pi)
        {
            this.PropertyInfo = pi;
        }

        public override void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            base.SetInspectorOwner(inspector, member);

            Arguments = PropertyInfo.GetIndexParameters();
        }

        protected override object TryEvaluate()
        {
            try
            {
                object ret;
                if (HasArguments)
                    ret = PropertyInfo.GetValue(DeclaringInstance, this.Evaluator.TryParseArguments());
                else
                    ret = PropertyInfo.GetValue(DeclaringInstance, null);
                LastException = null;
                return ret;
            }
            catch (Exception ex)
            {
                LastException = ex;
                return null;
            }
        }

        protected override void TrySetValue(object value)
        {
            if (!CanWrite)
                return;

            try
            {
                bool _static = PropertyInfo.GetAccessors(true)[0].IsStatic;

                if (HasArguments)
                    PropertyInfo.SetValue(DeclaringInstance, value, Evaluator.TryParseArguments());
                else
                    PropertyInfo.SetValue(DeclaringInstance, value, null);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning(ex);
            }
        }
    }
}

```

`src/CacheObject/ICacheObjectController.cs`:

```cs
using System.Collections;
using UnityExplorer.CacheObject.Views;

namespace UnityExplorer.CacheObject
{
    public interface ICacheObjectController
    {
        CacheObjectBase ParentCacheObject { get; }

        object Target { get; }
        Type TargetType { get; }

        bool CanWrite { get; }
    }

    public static class CacheObjectControllerHelper
    {
        // Helper so that this doesn't need to be copy+pasted between each implementation of the interface

        public static void SetCell(CacheObjectCell cell, int index, IList cachedEntries, Action<CacheObjectCell> onDataSetToCell)
        {
            if (index < 0 || index >= cachedEntries.Count)
            {
                if (cell.Occupant != null)
                    cell.Occupant.UnlinkFromView();

                cell.Disable();
                return;
            }

            CacheObjectBase entry = (CacheObjectBase)cachedEntries[index];

            if (entry.CellView != null && entry.CellView != cell)
                entry.UnlinkFromView();

            if (cell.Occupant != null && cell.Occupant != entry)
                cell.Occupant.UnlinkFromView();

            if (entry.CellView != cell)
                entry.SetView(cell);

            entry.SetDataToCell(cell);

            onDataSetToCell?.Invoke(cell);
        }
    }
}

```

`src/CacheObject/IValues/InteractiveColor.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveColor : InteractiveValue
    {
        public bool IsValueColor32;

        public Color EditedColor;

        private Image colorImage;
        private readonly InputFieldRef[] inputs = new InputFieldRef[4];
        private readonly Slider[] sliders = new Slider[4];

        private ButtonRef applyButton;

        private static readonly string[] fieldNames = new[] { "R", "G", "B", "A" };

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            applyButton.Component.gameObject.SetActive(owner.CanWrite);

            foreach (Slider slider in sliders)
                slider.interactable = owner.CanWrite;
            foreach (InputFieldRef input in inputs)
                input.Component.readOnly = !owner.CanWrite;
        }

        // owner setting value to this
        public override void SetValue(object value)
        {
            OnOwnerSetValue(value);
        }

        private void OnOwnerSetValue(object value)
        {
            if (value is Color32 c32)
            {
                IsValueColor32 = true;
                EditedColor = c32;
                inputs[0].Text = c32.r.ToString();
                inputs[1].Text = c32.g.ToString();
                inputs[2].Text = c32.b.ToString();
                inputs[3].Text = c32.a.ToString();
                foreach (Slider slider in sliders)
                    slider.maxValue = 255;
            }
            else
            {
                IsValueColor32 = false;
                EditedColor = (Color)value;
                inputs[0].Text = EditedColor.r.ToString();
                inputs[1].Text = EditedColor.g.ToString();
                inputs[2].Text = EditedColor.b.ToString();
                inputs[3].Text = EditedColor.a.ToString();
                foreach (Slider slider in sliders)
                    slider.maxValue = 1;
            }

            if (colorImage)
                colorImage.color = EditedColor;
        }

        // setting value to owner

        public void SetValueToOwner()
        {
            if (IsValueColor32)
                CurrentOwner.SetUserValue((Color32)EditedColor);
            else
                CurrentOwner.SetUserValue(EditedColor);
        }

        private void SetColorField(float val, int fieldIndex)
        {
            switch (fieldIndex)
            {
                case 0: EditedColor.r = val; break;
                case 1: EditedColor.g = val; break;
                case 2: EditedColor.b = val; break;
                case 3: EditedColor.a = val; break;
            }

            if (colorImage)
                colorImage.color = EditedColor;
        }

        private void OnInputChanged(string val, int fieldIndex)
        {
            try
            {
                float f;
                if (IsValueColor32)
                {
                    byte value = byte.Parse(val);
                    sliders[fieldIndex].value = value;
                    f = (float)((decimal)value / 255);
                }
                else
                {
                    f = float.Parse(val);
                    sliders[fieldIndex].value = f;
                }

                SetColorField(f, fieldIndex);
            }
            catch (ArgumentException) { } // ignore bad user input
            catch (FormatException) { }
            catch (OverflowException) { }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("InteractiveColor OnInput: " + ex.ToString());
            }
        }

        private void OnSliderValueChanged(float val, int fieldIndex)
        {
            try
            {
                if (IsValueColor32)
                {
                    inputs[fieldIndex].Text = ((byte)val).ToString();
                    val /= 255f;
                }
                else
                {
                    inputs[fieldIndex].Text = val.ToString();
                }

                SetColorField(val, fieldIndex);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("InteractiveColor OnSlider: " + ex.ToString());
            }
        }

        // UI Construction

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveColor", false, false, true, true, 3, new Vector4(4, 4, 4, 4),
                new Color(0.06f, 0.06f, 0.06f));

            // hori group

            GameObject horiGroup = UIFactory.CreateHorizontalGroup(UIRoot, "ColorEditor", false, false, true, true, 5,
                default, new Color(1, 1, 1, 0), TextAnchor.MiddleLeft);

            // sliders / inputs

            GameObject grid = UIFactory.CreateGridGroup(horiGroup, "Grid", new Vector2(140, 25), new Vector2(2, 2), new Color(1, 1, 1, 0));
            UIFactory.SetLayoutElement(grid, minWidth: 580, minHeight: 25, flexibleWidth: 0);

            for (int i = 0; i < 4; i++)
                AddEditorRow(i, grid);

            // apply button

            applyButton = UIFactory.CreateButton(horiGroup, "ApplyButton", "Apply", new Color(0.2f, 0.26f, 0.2f));
            UIFactory.SetLayoutElement(applyButton.Component.gameObject, minHeight: 25, minWidth: 90);
            applyButton.OnClick += SetValueToOwner;

            // image of color

            GameObject imgObj = UIFactory.CreateUIObject("ColorImageHelper", horiGroup);
            UIFactory.SetLayoutElement(imgObj, minHeight: 25, minWidth: 50, flexibleWidth: 50);
            colorImage = imgObj.AddComponent<Image>();

            return UIRoot;
        }

        internal void AddEditorRow(int index, GameObject groupObj)
        {
            GameObject row = UIFactory.CreateHorizontalGroup(groupObj, "EditorRow_" + fieldNames[index],
                false, true, true, true, 5, default, new Color(1, 1, 1, 0));

            Text label = UIFactory.CreateLabel(row, "RowLabel", $"{fieldNames[index]}:", TextAnchor.MiddleRight, Color.cyan);
            UIFactory.SetLayoutElement(label.gameObject, minWidth: 17, flexibleWidth: 0, minHeight: 25);

            InputFieldRef input = UIFactory.CreateInputField(row, "Input", "...");
            UIFactory.SetLayoutElement(input.UIRoot, minWidth: 40, minHeight: 25, flexibleHeight: 0);
            inputs[index] = input;
            input.OnValueChanged += (string val) => { OnInputChanged(val, index); };

            GameObject sliderObj = UIFactory.CreateSlider(row, "Slider", out Slider slider);
            sliders[index] = slider;
            UIFactory.SetLayoutElement(sliderObj, minHeight: 25, minWidth: 70, flexibleWidth: 999, flexibleHeight: 0);
            slider.minValue = 0;
            slider.maxValue = 1;
            slider.onValueChanged.AddListener((float val) => { OnSliderValueChanged(val, index); });
        }
    }
}

```

`src/CacheObject/IValues/InteractiveDictionary.cs`:

```cs
using System.Collections;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.UI.Panels;
using UniverseLib.UI;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveDictionary : InteractiveValue, ICellPoolDataSource<CacheKeyValuePairCell>, ICacheObjectController
    {
        CacheObjectBase ICacheObjectController.ParentCacheObject => this.CurrentOwner;
        object ICacheObjectController.Target => this.CurrentOwner.Value;
        public Type TargetType { get; private set; }

        public override bool CanWrite => base.CanWrite && RefIDictionary != null && !RefIDictionary.IsReadOnly;

        public Type KeysType;
        public Type ValuesType;
        public IDictionary RefIDictionary;

        public int ItemCount => cachedEntries.Count;
        private readonly List<CacheKeyValuePair> cachedEntries = new();

        public ScrollPool<CacheKeyValuePairCell> DictScrollPool { get; private set; }

        private Text NotSupportedLabel;

        public Text TopLabel;

        public LayoutElement KeyTitleLayout;
        public LayoutElement ValueTitleLayout;

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            DictScrollPool.Refresh(true, true);
        }

        public override void ReleaseFromOwner()
        {
            base.ReleaseFromOwner();

            ClearAndRelease();
        }

        private void ClearAndRelease()
        {
            RefIDictionary = null;

            foreach (CacheKeyValuePair entry in cachedEntries)
            {
                entry.UnlinkFromView();
                entry.ReleasePooledObjects();
            }

            cachedEntries.Clear();
        }

        public override void SetValue(object value)
        {
            if (value == null)
            {
                // should never be null
                ClearAndRelease();
                return;
            }
            else
            {
                Type type = value.GetActualType();
                ReflectionUtility.TryGetEntryTypes(type, out KeysType, out ValuesType);

                CacheEntries(value);

                TopLabel.text = $"[{cachedEntries.Count}] {SignatureHighlighter.Parse(type, false)}";
            }

            this.DictScrollPool.Refresh(true, false);
        }

        private void CacheEntries(object value)
        {
            RefIDictionary = value as IDictionary;

            if (ReflectionUtility.TryGetDictEnumerator(value, out IEnumerator<DictionaryEntry> dictEnumerator))
            {
                NotSupportedLabel.gameObject.SetActive(false);

                int idx = 0;
                while (dictEnumerator.MoveNext())
                {
                    CacheKeyValuePair cache;
                    if (idx >= cachedEntries.Count)
                    {
                        cache = new CacheKeyValuePair();
                        cache.SetDictOwner(this, idx);
                        cachedEntries.Add(cache);
                    }
                    else
                        cache = cachedEntries[idx];

                    cache.SetFallbackType(ValuesType);
                    cache.SetKey(dictEnumerator.Current.Key);
                    cache.SetValueFromSource(dictEnumerator.Current.Value);

                    idx++;
                }

                // Remove excess cached entries if dict count decreased
                if (cachedEntries.Count > idx)
                {
                    for (int i = cachedEntries.Count - 1; i >= idx; i--)
                    {
                        CacheKeyValuePair cache = cachedEntries[i];
                        if (cache.CellView != null)
                            cache.UnlinkFromView();

                        cache.ReleasePooledObjects();
                        cachedEntries.RemoveAt(i);
                    }
                }
            }
            else
            {
                NotSupportedLabel.gameObject.SetActive(true);
            }
        }

        // Setting value to dictionary

        public void TrySetValueToKey(object key, object value, int keyIndex)
        {
            try
            {
                if (!RefIDictionary.Contains(key))
                {
                    ExplorerCore.LogWarning("Unable to set key! Key may have been boxed to/from Il2Cpp Object.");
                    return;
                }

                RefIDictionary[key] = value;

                CacheKeyValuePair entry = cachedEntries[keyIndex];
                entry.SetValueFromSource(value);
                if (entry.CellView != null)
                    entry.SetDataToCell(entry.CellView);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting IDictionary key! {ex}");
            }
        }

        // KVP entry scroll pool

        public void OnCellBorrowed(CacheKeyValuePairCell cell) { }

        public void SetCell(CacheKeyValuePairCell cell, int index)
        {
            CacheObjectControllerHelper.SetCell(cell, index, cachedEntries, SetCellLayout);
        }

        public int AdjustedWidth => (int)UIRect.rect.width - 80;

        public override void SetLayout()
        {
            float minHeight = 5f;

            KeyTitleLayout.minWidth = AdjustedWidth * 0.44f;
            ValueTitleLayout.minWidth = AdjustedWidth * 0.55f;

            foreach (CacheKeyValuePairCell cell in DictScrollPool.CellPool)
            {
                SetCellLayout(cell);
                if (cell.Enabled)
                    minHeight += cell.Rect.rect.height;
            }

            this.scrollLayout.minHeight = Math.Min(InspectorPanel.CurrentPanelHeight - 400f, minHeight);
        }

        private void SetCellLayout(CacheObjectCell objcell)
        {
            CacheKeyValuePairCell cell = objcell as CacheKeyValuePairCell;
            cell.KeyGroupLayout.minWidth = cell.AdjustedWidth * 0.44f;
            cell.RightGroupLayout.minWidth = cell.AdjustedWidth * 0.55f;

            if (cell.Occupant?.IValue != null)
                cell.Occupant.IValue.SetLayout();
        }

        private LayoutElement scrollLayout;
        private RectTransform UIRect;

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveDict", true, true, true, true, 6, new Vector4(10, 3, 15, 4),
                new Color(0.05f, 0.05f, 0.05f));
            UIFactory.SetLayoutElement(UIRoot, flexibleWidth: 9999, minHeight: 25, flexibleHeight: 475);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            UIRect = UIRoot.GetComponent<RectTransform>();

            // Entries label

            TopLabel = UIFactory.CreateLabel(UIRoot, "EntryLabel", "not set", TextAnchor.MiddleLeft, fontSize: 16);
            TopLabel.horizontalOverflow = HorizontalWrapMode.Overflow;

            // key / value titles

            GameObject titleGroup = UIFactory.CreateUIObject("TitleGroup", UIRoot);
            UIFactory.SetLayoutElement(titleGroup, minHeight: 25, flexibleWidth: 9999, flexibleHeight: 0);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(titleGroup, false, true, true, true, padLeft: 65, padRight: 0, childAlignment: TextAnchor.LowerLeft);

            Text keyTitle = UIFactory.CreateLabel(titleGroup, "KeyTitle", "Keys", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(keyTitle.gameObject, minWidth: 100, flexibleWidth: 0);
            KeyTitleLayout = keyTitle.GetComponent<LayoutElement>();

            Text valueTitle = UIFactory.CreateLabel(titleGroup, "ValueTitle", "Values", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(valueTitle.gameObject, minWidth: 100, flexibleWidth: 0);
            ValueTitleLayout = valueTitle.GetComponent<LayoutElement>();

            // entry scroll pool

            DictScrollPool = UIFactory.CreateScrollPool<CacheKeyValuePairCell>(UIRoot, "EntryList", out GameObject scrollObj,
                out GameObject _, new Color(0.09f, 0.09f, 0.09f));
            UIFactory.SetLayoutElement(scrollObj, minHeight: 150, flexibleHeight: 0);
            DictScrollPool.Initialize(this, SetLayout);
            scrollLayout = scrollObj.GetComponent<LayoutElement>();

            NotSupportedLabel = UIFactory.CreateLabel(DictScrollPool.Content.gameObject, "NotSupportedMessage",
                "The IDictionary failed to enumerate. This is likely due to an issue with Unhollowed interfaces.",
                TextAnchor.MiddleLeft, Color.red);

            UIFactory.SetLayoutElement(NotSupportedLabel.gameObject, minHeight: 25, flexibleWidth: 9999);
            NotSupportedLabel.gameObject.SetActive(false);

            return UIRoot;
        }
    }
}
```

`src/CacheObject/IValues/InteractiveEnum.cs`:

```cs
using System.Collections.Specialized;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveEnum : InteractiveValue
    {
        public bool IsFlags;
        public Type EnumType;

        private Type lastType;

        public OrderedDictionary CurrentValues;

        private InputFieldRef inputField;
        private ButtonRef enumHelperButton;
        private EnumCompleter enumCompleter;

        private GameObject toggleHolder;
        private readonly List<Toggle> flagToggles = new();
        private readonly List<Text> flagTexts = new();

        public CachedEnumValue ValueAtIndex(int idx) => (CachedEnumValue)CurrentValues[idx];
        public CachedEnumValue ValueAtKey(object key) => (CachedEnumValue)CurrentValues[key];

        // Setting value from owner
        public override void SetValue(object value)
        {
            EnumType = value.GetType();

            if (lastType != EnumType)
            {
                CurrentValues = GetEnumValues(EnumType);

                IsFlags = EnumType.GetCustomAttributes(typeof(FlagsAttribute), true) is object[] fa && fa.Any();
                if (IsFlags)
                    SetupTogglesForEnumType();
                else
                {
                    inputField.Component.gameObject.SetActive(true);
                    enumHelperButton.Component.gameObject.SetActive(true);
                    toggleHolder.SetActive(false);
                }

                enumCompleter.EnumType = EnumType;
                enumCompleter.CacheEnumValues();

                lastType = EnumType;
            }

            if (!IsFlags)
                inputField.Text = value.ToString();
            else
                SetTogglesForValue(value);

            this.enumCompleter.chosenSuggestion = value.ToString();
            AutoCompleteModal.Instance.ReleaseOwnership(this.enumCompleter);
        }

        private void SetTogglesForValue(object value)
        {
            try
            {
                for (int i = 0; i < CurrentValues.Count; i++)
                    flagToggles[i].isOn = (value as Enum).HasFlag(ValueAtIndex(i).ActualValue as Enum);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting flag toggles: " + ex);
            }
        }

        // Setting value to owner

        private void OnApplyClicked()
        {
            try
            {
                if (!IsFlags)
                {
                    if (ParseUtility.TryParse(this.inputField.Text, EnumType, out object value, out Exception ex))
                        CurrentOwner.SetUserValue(value);
                    else
                        throw ex;
                }
                else
                {
                    SetValueFromFlags();
                }
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting from dropdown: " + ex);
            }
        }

        private void SetValueFromFlags()
        {
            try
            {
                List<string> values = new();
                for (int i = 0; i < CurrentValues.Count; i++)
                {
                    if (flagToggles[i].isOn)
                        values.Add(ValueAtIndex(i).Name);
                }

                CurrentOwner.SetUserValue(Enum.Parse(EnumType, string.Join(", ", values.ToArray())));
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting from flag toggles: " + ex);
            }
        }

        // UI Construction

        private void EnumHelper_OnClick()
        {
            enumCompleter.HelperButtonClicked();
        }

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveEnum", false, false, true, true, 3, new Vector4(4, 4, 4, 4),
                new Color(0.06f, 0.06f, 0.06f));
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, flexibleHeight: 9999, flexibleWidth: 9999);

            GameObject hori = UIFactory.CreateUIObject("Hori", UIRoot);
            UIFactory.SetLayoutElement(hori, minHeight: 25, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(hori, false, false, true, true, 2);

            ButtonRef applyButton = UIFactory.CreateButton(hori, "ApplyButton", "Apply", new Color(0.2f, 0.27f, 0.2f));
            UIFactory.SetLayoutElement(applyButton.Component.gameObject, minHeight: 25, minWidth: 100);
            applyButton.OnClick += OnApplyClicked;

            inputField = UIFactory.CreateInputField(hori, "InputField", "Enter name or underlying value...");
            UIFactory.SetLayoutElement(inputField.UIRoot, minHeight: 25, flexibleHeight: 50, minWidth: 100, flexibleWidth: 1000);
            inputField.Component.lineType = InputField.LineType.MultiLineNewline;
            inputField.UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            enumHelperButton = UIFactory.CreateButton(hori, "EnumHelper", "â–¼");
            UIFactory.SetLayoutElement(enumHelperButton.Component.gameObject, minWidth: 25, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            enumHelperButton.OnClick += EnumHelper_OnClick;

            enumCompleter = new EnumCompleter(this.EnumType, this.inputField);

            toggleHolder = UIFactory.CreateUIObject("ToggleHolder", UIRoot);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(toggleHolder, false, false, true, true, 4);
            UIFactory.SetLayoutElement(toggleHolder, minHeight: 25, flexibleWidth: 9999, flexibleHeight: 9999);

            return UIRoot;
        }

        private void SetupTogglesForEnumType()
        {
            toggleHolder.SetActive(true);
            inputField.Component.gameObject.SetActive(false);
            enumHelperButton.Component.gameObject.SetActive(false);

            // create / set / hide toggles
            for (int i = 0; i < CurrentValues.Count || i < flagToggles.Count; i++)
            {
                if (i >= CurrentValues.Count)
                {
                    if (i >= flagToggles.Count)
                        break;

                    flagToggles[i].gameObject.SetActive(false);
                    continue;
                }

                if (i >= flagToggles.Count)
                    AddToggleRow();

                flagToggles[i].isOn = false;
                flagTexts[i].text = ValueAtIndex(i).Name;
            }
        }

        private void AddToggleRow()
        {
            GameObject row = UIFactory.CreateUIObject("ToggleRow", toggleHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(row, false, false, true, true, 2);
            UIFactory.SetLayoutElement(row, minHeight: 25, flexibleWidth: 9999);

            GameObject toggleObj = UIFactory.CreateToggle(row, "ToggleObj", out Toggle toggle, out Text toggleText);
            UIFactory.SetLayoutElement(toggleObj, minHeight: 25, flexibleWidth: 9999);

            flagToggles.Add(toggle);
            flagTexts.Add(toggleText);
        }

        #region Enum cache 

        internal static readonly Dictionary<string, OrderedDictionary> enumCache = new();

        internal static OrderedDictionary GetEnumValues(Type enumType)
        {
            //isFlags = enumType.GetCustomAttributes(typeof(FlagsAttribute), true) is object[] fa && fa.Any();

            if (!enumCache.ContainsKey(enumType.AssemblyQualifiedName))
            {
                OrderedDictionary dict = new();
                HashSet<string> addedNames = new();

                int i = 0;
                foreach (object value in Enum.GetValues(enumType))
                {
                    string name = value.ToString();
                    if (addedNames.Contains(name))
                        continue;
                    addedNames.Add(name);

                    dict.Add(value, new CachedEnumValue(value, i, name));
                    i++;
                }

                enumCache.Add(enumType.AssemblyQualifiedName, dict);
            }

            return enumCache[enumType.AssemblyQualifiedName];
        }

        #endregion
    }

    public struct CachedEnumValue
    {
        public CachedEnumValue(object value, int index, string name)
        {
            EnumIndex = index;
            Name = name;
            ActualValue = value;
        }

        public readonly object ActualValue;
        public int EnumIndex;
        public readonly string Name;
    }
}

```

`src/CacheObject/IValues/InteractiveList.cs`:

```cs
using System.Collections;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.UI.Panels;
using UniverseLib.UI;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveList : InteractiveValue, ICellPoolDataSource<CacheListEntryCell>, ICacheObjectController
    {
        CacheObjectBase ICacheObjectController.ParentCacheObject => this.CurrentOwner;
        object ICacheObjectController.Target => this.CurrentOwner.Value;
        public Type TargetType { get; private set; }

        public override bool CanWrite => base.CanWrite && ((RefIList != null && !RefIList.IsReadOnly) || IsWritableGenericIList);

        public Type EntryType;
        public IList RefIList;

        private bool IsWritableGenericIList;
        private PropertyInfo genericIndexer;

        public int ItemCount => cachedEntries.Count;
        private readonly List<CacheListEntry> cachedEntries = new();

        public ScrollPool<CacheListEntryCell> ListScrollPool { get; private set; }

        public Text TopLabel;
        private LayoutElement scrollLayout;
        private Text NotSupportedLabel;

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            ListScrollPool.Refresh(true, true);
        }

        public override void ReleaseFromOwner()
        {
            base.ReleaseFromOwner();

            ClearAndRelease();
        }

        private void ClearAndRelease()
        {
            RefIList = null;

            foreach (CacheListEntry entry in cachedEntries)
            {
                entry.UnlinkFromView();
                entry.ReleasePooledObjects();
            }

            cachedEntries.Clear();
        }

        // List entry scroll pool

        public override void SetLayout()
        {
            float minHeight = 5f;

            foreach (CacheListEntryCell cell in ListScrollPool.CellPool)
            {
                if (cell.Enabled)
                    minHeight += cell.Rect.rect.height;
            }

            this.scrollLayout.minHeight = Math.Min(InspectorPanel.CurrentPanelHeight - 400f, minHeight);
        }

        public void OnCellBorrowed(CacheListEntryCell cell) { } // not needed

        public void SetCell(CacheListEntryCell cell, int index)
        {
            CacheObjectControllerHelper.SetCell(cell, index, cachedEntries, null);
        }

        // Setting the List value itself to this model
        public override void SetValue(object value)
        {
            if (value == null)
            {
                // should never be null
                if (cachedEntries.Any())
                    ClearAndRelease();
            }
            else
            {
                Type type = value.GetActualType();
                ReflectionUtility.TryGetEntryType(type, out EntryType);

                CacheEntries(value);

                TopLabel.text = $"[{cachedEntries.Count}] {SignatureHighlighter.Parse(type, false)}";
            }

            //this.ScrollPoolLayout.minHeight = Math.Min(400f, 35f * values.Count);
            this.ListScrollPool.Refresh(true, false);
        }

        private void CacheEntries(object value)
        {
            RefIList = value as IList;

            // Check if the type implements IList<T> but not IList (ie. Il2CppArrayBase)
            if (RefIList == null)
                CheckGenericIList(value);
            else
                IsWritableGenericIList = false;

            int idx = 0;

            if (ReflectionUtility.TryGetEnumerator(value, out IEnumerator enumerator))
            {
                NotSupportedLabel.gameObject.SetActive(false);

                while (enumerator.MoveNext())
                {
                    object entry = enumerator.Current;

                    // If list count increased, create new cache entries
                    CacheListEntry cache;
                    if (idx >= cachedEntries.Count)
                    {
                        cache = new CacheListEntry();
                        cache.SetListOwner(this, idx);
                        cachedEntries.Add(cache);
                    }
                    else
                        cache = cachedEntries[idx];

                    cache.SetFallbackType(this.EntryType);
                    cache.SetValueFromSource(entry);
                    idx++;
                }

                // Remove excess cached entries if list count decreased
                if (cachedEntries.Count > idx)
                {
                    for (int i = cachedEntries.Count - 1; i >= idx; i--)
                    {
                        CacheListEntry cache = cachedEntries[i];
                        if (cache.CellView != null)
                            cache.UnlinkFromView();

                        cache.ReleasePooledObjects();
                        cachedEntries.RemoveAt(i);
                    }
                }
            }
            else
            {
                NotSupportedLabel.gameObject.SetActive(true);
            }
        }

        private void CheckGenericIList(object value)
        {
            try
            {
                Type type = value.GetType();
                if (type.GetInterfaces().Any(it => it.IsGenericType && it.GetGenericTypeDefinition() == typeof(IList<>)))
                    IsWritableGenericIList = !(bool)type.GetProperty("IsReadOnly").GetValue(value, null);
                else
                    IsWritableGenericIList = false;

                if (IsWritableGenericIList)
                {
                    // Find the "this[int index]" property.
                    // It might be a private implementation.
                    foreach (PropertyInfo prop in type.GetProperties(ReflectionUtility.FLAGS))
                    {
                        if ((prop.Name == "Item"
                                || (prop.Name.StartsWith("System.Collections.Generic.IList<") && prop.Name.EndsWith(">.Item")))
                            && prop.GetIndexParameters() is ParameterInfo[] parameters
                            && parameters.Length == 1
                            && parameters[0].ParameterType == typeof(int))
                        {
                            genericIndexer = prop;
                            break;
                        }
                    }

                    if (genericIndexer == null)
                    {
                        ExplorerCore.LogWarning($"Failed to find indexer property for IList<T> type '{type.FullName}'!");
                        IsWritableGenericIList = false;
                    }
                }
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception processing IEnumerable for IList<T> check: {ex.ReflectionExToString()}");
                IsWritableGenericIList = false;
            }
        }

        // Setting the value of an index to the list

        public void TrySetValueToIndex(object value, int index)
        {
            try
            {
                if (!IsWritableGenericIList)
                {
                    RefIList[index] = value;
                }
                else
                {
                    genericIndexer.SetValue(CurrentOwner.Value, value, new object[] { index });
                }

                CacheListEntry entry = cachedEntries[index];
                entry.SetValueFromSource(value);

                if (entry.CellView != null)
                    entry.SetDataToCell(entry.CellView);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting IList value: {ex}");
            }
        }

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveList", true, true, true, true, 6, new Vector4(10, 3, 15, 4),
                new Color(0.05f, 0.05f, 0.05f));
            UIFactory.SetLayoutElement(UIRoot, flexibleWidth: 9999, minHeight: 25, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // Entries label

            TopLabel = UIFactory.CreateLabel(UIRoot, "EntryLabel", "not set", TextAnchor.MiddleLeft, fontSize: 16);
            TopLabel.horizontalOverflow = HorizontalWrapMode.Overflow;

            // entry scroll pool

            ListScrollPool = UIFactory.CreateScrollPool<CacheListEntryCell>(UIRoot, "EntryList", out GameObject scrollObj,
                out GameObject _, new Color(0.09f, 0.09f, 0.09f));
            UIFactory.SetLayoutElement(scrollObj, minHeight: 400, flexibleHeight: 0);
            ListScrollPool.Initialize(this, SetLayout);
            scrollLayout = scrollObj.GetComponent<LayoutElement>();

            NotSupportedLabel = UIFactory.CreateLabel(ListScrollPool.Content.gameObject, "NotSupportedMessage",
                "The IEnumerable failed to enumerate. This is likely due to an issue with Unhollowed interfaces.",
                TextAnchor.MiddleLeft, Color.red);

            UIFactory.SetLayoutElement(NotSupportedLabel.gameObject, minHeight: 25, flexibleWidth: 9999);
            NotSupportedLabel.gameObject.SetActive(false);

            return UIRoot;
        }
    }
}
```

`src/CacheObject/IValues/InteractiveString.cs`:

```cs
using UnityExplorer.Config;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveString : InteractiveValue
    {
        private string RealValue;
        public string EditedValue = "";

        public InputFieldRef inputField;
        public ButtonRef ApplyButton;

        public GameObject SaveFileRow;
        public InputFieldRef SaveFilePath;

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            bool canWrite = owner.CanWrite && owner.State != ValueState.Exception;
            inputField.Component.readOnly = !canWrite;
            ApplyButton.Component.gameObject.SetActive(canWrite);

            SaveFilePath.Text = Path.Combine(ConfigManager.Default_Output_Path.Value, "untitled.txt");
        }

        private bool IsStringTooLong(string s)
        {
            if (s == null)
                return false;

            return s.Length >= UniversalUI.MAX_INPUTFIELD_CHARS;
        }

        public override void SetValue(object value)
        {
            if (CurrentOwner.State == ValueState.Exception)
                value = CurrentOwner.LastException.ToString();

            RealValue = value as string;
            SaveFileRow.SetActive(IsStringTooLong(RealValue));

            if (value == null)
            {
                inputField.Text = "";
                EditedValue = "";
            }
            else
            {
                EditedValue = (string)value;
                inputField.Text = EditedValue;
            }
        }

        private void OnApplyClicked()
        {
            CurrentOwner.SetUserValue(EditedValue);
        }

        private void OnInputChanged(string input)
        {
            EditedValue = input;
            SaveFileRow.SetActive(IsStringTooLong(EditedValue));
        }

        private void OnSaveFileClicked()
        {
            if (RealValue == null)
                return;

            if (string.IsNullOrEmpty(SaveFilePath.Text))
            {
                ExplorerCore.LogWarning("Cannot save an empty file path!");
                return;
            }

            string path = IOUtility.EnsureValidFilePath(SaveFilePath.Text);

            if (File.Exists(path))
                File.Delete(path);

            File.WriteAllText(path, RealValue);
        }

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveString", false, false, true, true, 3, new Vector4(4, 4, 4, 4),
                new Color(0.06f, 0.06f, 0.06f));

            // Save to file helper

            SaveFileRow = UIFactory.CreateUIObject("SaveFileRow", UIRoot);
            UIFactory.SetLayoutElement(SaveFileRow, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(SaveFileRow, false, true, true, true, 3);

            UIFactory.CreateLabel(SaveFileRow, "Info", "<color=red>String is too long! Save to file if you want to see the full string.</color>",
                TextAnchor.MiddleLeft);

            GameObject horizRow = UIFactory.CreateUIObject("Horiz", SaveFileRow);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(horizRow, false, false, true, true, 4);

            ButtonRef saveButton = UIFactory.CreateButton(horizRow, "SaveButton", "Save file");
            UIFactory.SetLayoutElement(saveButton.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            saveButton.OnClick += OnSaveFileClicked;

            SaveFilePath = UIFactory.CreateInputField(horizRow, "SaveInput", "...");
            UIFactory.SetLayoutElement(SaveFilePath.UIRoot, minHeight: 25, flexibleWidth: 9999);

            // Main Input / apply

            ApplyButton = UIFactory.CreateButton(UIRoot, "ApplyButton", "Apply", new Color(0.2f, 0.27f, 0.2f));
            UIFactory.SetLayoutElement(ApplyButton.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            ApplyButton.OnClick += OnApplyClicked;

            inputField = UIFactory.CreateInputField(UIRoot, "InputField", "empty");
            inputField.UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;
            UIFactory.SetLayoutElement(inputField.UIRoot, minHeight: 25, flexibleHeight: 500, flexibleWidth: 9999);
            inputField.Component.lineType = InputField.LineType.MultiLineNewline;
            inputField.OnValueChanged += OnInputChanged;

            return UIRoot;
        }

    }
}

```

`src/CacheObject/IValues/InteractiveValue.cs`:

```cs
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.CacheObject.IValues
{
    public abstract class InteractiveValue : IPooledObject
    {
        public static Type GetIValueTypeForState(ValueState state)
        {
            return state switch
            {
                ValueState.Exception or ValueState.String => typeof(InteractiveString),
                ValueState.Enum => typeof(InteractiveEnum),
                ValueState.Collection => typeof(InteractiveList),
                ValueState.Dictionary => typeof(InteractiveDictionary),
                ValueState.ValueStruct => typeof(InteractiveValueStruct),
                ValueState.Color => typeof(InteractiveColor),
                _ => null,
            };
        }

        public GameObject UIRoot { get; set; }
        public float DefaultHeight => -1f;

        public virtual bool CanWrite => this.CurrentOwner.CanWrite;

        public CacheObjectBase CurrentOwner => owner;
        private CacheObjectBase owner;

        public bool PendingValueWanted;

        public virtual void OnBorrowed(CacheObjectBase owner)
        {
            if (this.owner != null)
            {
                ExplorerCore.LogWarning("Setting an IValue's owner but there is already one set. Maybe it wasn't cleaned up?");
                ReleaseFromOwner();
            }

            this.owner = owner;
        }

        public virtual void ReleaseFromOwner()
        {
            if (this.owner == null)
                return;

            this.owner = null;
        }

        public abstract void SetValue(object value);

        public virtual void SetLayout() { }

        public abstract GameObject CreateContent(GameObject parent);
    }
}

```

`src/CacheObject/IValues/InteractiveValueStruct.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveValueStruct : InteractiveValue
    {
        #region Struct cache / wrapper

        public class StructInfo
        {
            public bool IsSupported;
            public FieldInfo[] Fields;

            public StructInfo(bool isSupported, FieldInfo[] fields)
            {
                IsSupported = isSupported;
                Fields = fields;
            }

            public void SetValue(object instance, string input, int fieldIndex)
            {
                FieldInfo field = Fields[fieldIndex];

                object val;
                if (field.FieldType == typeof(string))
                    val = input;
                else
                {
                    if (!ParseUtility.TryParse(input, field.FieldType, out val, out Exception ex))
                    {
                        ExplorerCore.LogWarning("Unable to parse input!");
                        if (ex != null) ExplorerCore.Log(ex.ReflectionExToString());
                        return;
                    }
                }

                field.SetValue(instance, val);
            }

            public string GetValue(object instance, int fieldIndex)
            {
                FieldInfo field = Fields[fieldIndex];
                object value = field.GetValue(instance);
                return ParseUtility.ToStringForInput(value, field.FieldType);
            }
        }

        private static readonly Dictionary<string, StructInfo> typeSupportCache = new();

        private const BindingFlags INSTANCE_FLAGS = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public;
        private const string SYSTEM_VOID = "System.Void";

        public static bool SupportsType(Type type)
        {
            if (!type.IsValueType || string.IsNullOrEmpty(type.AssemblyQualifiedName) || type.FullName == SYSTEM_VOID)
                return false;

            if (typeSupportCache.TryGetValue(type.AssemblyQualifiedName, out StructInfo info))
                return info.IsSupported;

            bool supported = false;

            FieldInfo[] fields = type.GetFields(INSTANCE_FLAGS);
            if (fields.Length > 0)
            {
                if (fields.Any(it => !ParseUtility.CanParse(it.FieldType)))
                {
                    supported = false;
                    info = new StructInfo(supported, null);
                }
                else
                {
                    supported = true;
                    info = new StructInfo(supported, fields);
                }
            }

            typeSupportCache.Add(type.AssemblyQualifiedName, info);

            return supported;
        }

        #endregion

        public object RefInstance;

        public StructInfo CurrentInfo;
        private Type lastStructType;

        private ButtonRef applyButton;
        private readonly List<GameObject> fieldRows = new();
        private readonly List<InputFieldRef> inputFields = new();
        private readonly List<Text> labels = new();

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            applyButton.Component.gameObject.SetActive(owner.CanWrite);
        }

        // Setting value from owner to this

        public override void SetValue(object value)
        {
            RefInstance = value;

            Type type = RefInstance.GetType();

            if (type != lastStructType)
            {
                CurrentInfo = typeSupportCache[type.AssemblyQualifiedName];
                SetupUIForType();
                lastStructType = type;
            }

            for (int i = 0; i < CurrentInfo.Fields.Length; i++)
            {
                inputFields[i].Text = CurrentInfo.GetValue(RefInstance, i);
            }
        }

        private void OnApplyClicked()
        {
            try
            {
                for (int i = 0; i < CurrentInfo.Fields.Length; i++)
                {
                    CurrentInfo.SetValue(RefInstance, inputFields[i].Text, i);
                }

                CurrentOwner.SetUserValue(RefInstance);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting value: " + ex);
            }
        }

        // UI Setup for type

        private void SetupUIForType()
        {
            for (int i = 0; i < CurrentInfo.Fields.Length || i <= inputFields.Count; i++)
            {
                if (i >= CurrentInfo.Fields.Length)
                {
                    if (i >= inputFields.Count)
                        break;

                    fieldRows[i].SetActive(false);
                    continue;
                }

                if (i >= inputFields.Count)
                    AddEditorRow();

                fieldRows[i].SetActive(true);

                string label = SignatureHighlighter.Parse(CurrentInfo.Fields[i].FieldType, false);
                label += $" <color={SignatureHighlighter.FIELD_INSTANCE}>{CurrentInfo.Fields[i].Name}</color>:";
                labels[i].text = label;
            }
        }

        private void AddEditorRow()
        {
            GameObject row = UIFactory.CreateUIObject("HoriGroup", UIRoot);
            //row.AddComponent<ContentSizeFitter>().horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
            UIFactory.SetLayoutElement(row, minHeight: 25, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(row, false, false, true, true, 8, childAlignment: TextAnchor.MiddleLeft);

            fieldRows.Add(row);

            Text label = UIFactory.CreateLabel(row, "Label", "notset", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(label.gameObject, minHeight: 25, minWidth: 50, flexibleWidth: 0);
            label.horizontalOverflow = HorizontalWrapMode.Wrap;
            labels.Add(label);

            InputFieldRef input = UIFactory.CreateInputField(row, "InputField", "...");
            UIFactory.SetLayoutElement(input.UIRoot, minHeight: 25, minWidth: 200);
            ContentSizeFitter fitter = input.UIRoot.AddComponent<ContentSizeFitter>();
            fitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;
            fitter.horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
            input.Component.lineType = InputField.LineType.MultiLineNewline;
            inputFields.Add(input);
        }

        // UI Construction

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveValueStruct", false, false, true, true, 3, new Vector4(4, 4, 4, 4),
                new Color(0.06f, 0.06f, 0.06f), TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, flexibleWidth: 9999);

            applyButton = UIFactory.CreateButton(UIRoot, "ApplyButton", "Apply", new Color(0.2f, 0.27f, 0.2f));
            UIFactory.SetLayoutElement(applyButton.Component.gameObject, minHeight: 25, minWidth: 175);
            applyButton.OnClick += OnApplyClicked;

            return UIRoot;
        }
    }
}

```

`src/CacheObject/Views/CacheConfigCell.cs`:

```cs
using UniverseLib.UI;

namespace UnityExplorer.CacheObject.Views
{
    public class ConfigEntryCell : CacheObjectCell
    {
        public override GameObject CreateContent(GameObject parent)
        {
            // Main layout

            UIRoot = UIFactory.CreateUIObject(this.GetType().Name, parent, new Vector2(100, 30));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(UIRoot, false, false, true, true, 4, 4, 4, 4, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 100, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // Left label

            NameLabel = UIFactory.CreateLabel(UIRoot, "NameLabel", "<notset>", TextAnchor.MiddleLeft);
            NameLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(NameLabel.gameObject, minHeight: 25, flexibleWidth: 9999, flexibleHeight: 300);
            NameLayout = NameLabel.GetComponent<LayoutElement>();

            // horizontal group

            GameObject horiGroup = UIFactory.CreateUIObject("RightHoriGroup", UIRoot);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(horiGroup, false, false, true, true, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(horiGroup, minHeight: 25, minWidth: 200, flexibleWidth: 9999, flexibleHeight: 800);

            SubContentButton = UIFactory.CreateButton(horiGroup, "SubContentButton", "â–²", subInactiveColor);
            UIFactory.SetLayoutElement(SubContentButton.Component.gameObject, minWidth: 25, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            SubContentButton.OnClick += SubContentClicked;

            // Type label

            TypeLabel = UIFactory.CreateLabel(horiGroup, "TypeLabel", "<notset>", TextAnchor.MiddleLeft);
            TypeLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(TypeLabel.gameObject, minHeight: 25, flexibleHeight: 150, minWidth: 60, flexibleWidth: 0);

            // Bool and number value interaction

            GameObject toggleObj = UIFactory.CreateToggle(horiGroup, "Toggle", out Toggle, out ToggleText);
            UIFactory.SetLayoutElement(toggleObj, minWidth: 70, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            ToggleText.color = SignatureHighlighter.KeywordBlue;
            Toggle.onValueChanged.AddListener(ToggleClicked);

            InputField = UIFactory.CreateInputField(horiGroup, "InputField", "...");
            UIFactory.SetLayoutElement(InputField.UIRoot, minWidth: 150, flexibleWidth: 0, minHeight: 25, flexibleHeight: 0);

            // Apply

            ApplyButton = UIFactory.CreateButton(horiGroup, "ApplyButton", "Apply", new Color(0.15f, 0.19f, 0.15f));
            UIFactory.SetLayoutElement(ApplyButton.Component.gameObject, minWidth: 70, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            ApplyButton.OnClick += ApplyClicked;

            // Main value label

            ValueLabel = UIFactory.CreateLabel(horiGroup, "ValueLabel", "Value goes here", TextAnchor.MiddleLeft);
            ValueLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(ValueLabel.gameObject, minHeight: 25, flexibleHeight: 150, flexibleWidth: 9999);

            // Subcontent

            SubContentHolder = UIFactory.CreateUIObject("SubContent", UIRoot);
            UIFactory.SetLayoutElement(SubContentHolder.gameObject, minHeight: 30, flexibleHeight: 600, minWidth: 100, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(SubContentHolder, true, true, true, true, 2, childAlignment: TextAnchor.UpperLeft);
            //SubContentHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.MinSize;
            SubContentHolder.SetActive(false);

            // Bottom separator
            GameObject separator = UIFactory.CreateUIObject("BottomSeperator", UIRoot);
            UIFactory.SetLayoutElement(separator, minHeight: 1, flexibleHeight: 0, flexibleWidth: 9999);
            separator.AddComponent<Image>().color = Color.black;

            return UIRoot;
        }

        protected override void ConstructEvaluateHolder(GameObject parent) { }
    }
}

```

`src/CacheObject/Views/CacheKeyValuePairCell.cs`:

```cs
using UnityExplorer.CacheObject.IValues;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.CacheObject.Views
{
    public class CacheKeyValuePairCell : CacheObjectCell
    {
        public Image Image { get; private set; }
        public InteractiveDictionary DictOwner => Occupant.Owner as InteractiveDictionary;

        public LayoutElement KeyGroupLayout;
        public Text KeyLabel;
        public ButtonRef KeyInspectButton;
        public InputFieldRef KeyInputField;
        public Text KeyInputTypeLabel;

        public static Color EvenColor = new(0.07f, 0.07f, 0.07f);
        public static Color OddColor = new(0.063f, 0.063f, 0.063f);

        public int AdjustedWidth => (int)Rect.rect.width - 70;

        //public int HalfWidth => (int)(0.5f * Rect.rect.width) - 75;
        //public int AdjustedKeyWidth => HalfWidth - 50;
        //public int AdjustedRightWidth => HalfWidth;

        private void KeyInspectClicked()
        {
            InspectorManager.Inspect((Occupant as CacheKeyValuePair).DictKey, this.Occupant);
        }

        public override GameObject CreateContent(GameObject parent)
        {
            GameObject root = base.CreateContent(parent);

            Image = root.AddComponent<Image>();

            this.NameLayout.minWidth = 70;
            this.NameLayout.flexibleWidth = 0;
            this.NameLayout.minHeight = 30;
            this.NameLayout.flexibleHeight = 0;
            this.NameLabel.alignment = TextAnchor.MiddleRight;

            this.RightGroupLayout.minWidth = AdjustedWidth * 0.55f;

            // Key area
            GameObject keyGroup = UIFactory.CreateUIObject("KeyHolder", root.transform.Find("HoriGroup").gameObject);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(keyGroup, false, false, true, true, 2, 0, 0, 4, 4, childAlignment: TextAnchor.MiddleLeft);
            KeyGroupLayout = UIFactory.SetLayoutElement(keyGroup, minHeight: 30, minWidth: (int)(AdjustedWidth * 0.44f), flexibleWidth: 0);

            // set to be after the NameLabel (our index label), and before the main horizontal group.
            keyGroup.transform.SetSiblingIndex(1);

            // key Inspect

            KeyInspectButton = UIFactory.CreateButton(keyGroup, "KeyInspectButton", "Inspect", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(KeyInspectButton.Component.gameObject, minWidth: 60, flexibleWidth: 0, minHeight: 25, flexibleHeight: 0);
            KeyInspectButton.OnClick += KeyInspectClicked;

            // label

            KeyLabel = UIFactory.CreateLabel(keyGroup, "KeyLabel", "<i>empty</i>", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(KeyLabel.gameObject, minWidth: 50, flexibleWidth: 999, minHeight: 25);

            // Type label for input field

            KeyInputTypeLabel = UIFactory.CreateLabel(keyGroup, "InputTypeLabel", "<i>null</i>", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(KeyInputTypeLabel.gameObject, minWidth: 55, flexibleWidth: 0, minHeight: 25, flexibleHeight: 0);

            // input field

            KeyInputField = UIFactory.CreateInputField(keyGroup, "KeyInput", "empty");
            UIFactory.SetLayoutElement(KeyInputField.UIRoot, minHeight: 25, flexibleHeight: 0, flexibleWidth: 0, preferredWidth: 200);
            //KeyInputField.lineType = InputField.LineType.MultiLineNewline;
            KeyInputField.Component.readOnly = true;

            return root;
        }

        protected override void ConstructEvaluateHolder(GameObject parent)
        {
            // not used
        }
    }
}

```

`src/CacheObject/Views/CacheListEntryCell.cs`:

```cs
using UnityExplorer.CacheObject.IValues;

namespace UnityExplorer.CacheObject.Views
{
    public class CacheListEntryCell : CacheObjectCell
    {
        public Image Image { get; private set; }
        public InteractiveList ListOwner => Occupant.Owner as InteractiveList;

        public static Color EvenColor = new(0.12f, 0.12f, 0.12f);
        public static Color OddColor = new(0.1f, 0.1f, 0.1f);

        public override GameObject CreateContent(GameObject parent)
        {
            GameObject root = base.CreateContent(parent);

            Image = root.AddComponent<Image>();

            this.NameLayout.minWidth = 40;
            this.NameLayout.flexibleWidth = 50;
            this.NameLayout.minHeight = 25;
            this.NameLayout.flexibleHeight = 0;
            this.NameLabel.alignment = TextAnchor.MiddleRight;

            return root;
        }

        protected override void ConstructEvaluateHolder(GameObject parent)
        {
            // not used
        }

        //protected override void ConstructUpdateToggle(GameObject parent)
        //{
        //    // not used
        //}
    }
}

```

`src/CacheObject/Views/CacheMemberCell.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.CacheObject.Views
{
    public class CacheMemberCell : CacheObjectCell
    {
        public CacheMember MemberOccupant => Occupant as CacheMember;

        public GameObject EvaluateHolder;
        public ButtonRef EvaluateButton;

        protected virtual void EvaluateClicked()
        {
            this.MemberOccupant.OnEvaluateClicked();
        }

        protected override void ConstructEvaluateHolder(GameObject parent)
        {
            // Evaluate vert group

            EvaluateHolder = UIFactory.CreateUIObject("EvalGroup", parent);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(EvaluateHolder, false, false, true, true, 3);
            UIFactory.SetLayoutElement(EvaluateHolder, minHeight: 25, flexibleWidth: 9999, flexibleHeight: 775);

            EvaluateButton = UIFactory.CreateButton(EvaluateHolder, "EvaluateButton", "Evaluate", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(EvaluateButton.Component.gameObject, minWidth: 100, minHeight: 25);
            EvaluateButton.OnClick += EvaluateClicked;
        }
    }
}

```

`src/CacheObject/Views/CacheObjectCell.cs`:

```cs
using UnityExplorer.UI.Panels;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.CacheObject.Views
{
    public abstract class CacheObjectCell : ICell
    {
        #region ICell

        public float DefaultHeight => 30f;

        public GameObject UIRoot { get; set; }

        public bool Enabled => m_enabled;
        private bool m_enabled;

        public RectTransform Rect { get; set; }

        public void Disable()
        {
            m_enabled = false;
            UIRoot.SetActive(false);
        }

        public void Enable()
        {
            m_enabled = true;
            UIRoot.SetActive(true);
        }

        #endregion

        public CacheObjectBase Occupant { get; set; }
        public bool SubContentActive => SubContentHolder.activeSelf;

        public LayoutElement NameLayout;
        public GameObject RightGroupContent;
        public LayoutElement RightGroupLayout;
        public GameObject SubContentHolder;

        public Text NameLabel;
        public InputFieldRef HiddenNameLabel; // for selecting the name label
        public Text TypeLabel;
        public Text ValueLabel;
        public Toggle Toggle;
        public Text ToggleText;
        public InputFieldRef InputField;

        public ButtonRef InspectButton;
        public ButtonRef SubContentButton;
        public ButtonRef ApplyButton;

        public ButtonRef CopyButton;
        public ButtonRef PasteButton;

        public readonly Color subInactiveColor = new(0.23f, 0.23f, 0.23f);
        public readonly Color subActiveColor = new(0.23f, 0.33f, 0.23f);

        protected virtual void ApplyClicked()
        {
            Occupant.OnCellApplyClicked();
        }

        protected virtual void InspectClicked()
        {
            InspectorManager.Inspect(Occupant.Value, this.Occupant);
        }

        protected virtual void ToggleClicked(bool value)
        {
            ToggleText.text = value.ToString();
        }

        protected virtual void SubContentClicked()
        {
            this.Occupant.OnCellSubContentToggle();
        }

        protected virtual void OnCopyClicked()
        {
            ClipboardPanel.Copy(this.Occupant.Value);
        }

        protected virtual void OnPasteClicked()
        {
            if (ClipboardPanel.TryPaste(this.Occupant.FallbackType, out object paste))
                this.Occupant.SetUserValue(paste);
        }

        public void RefreshSubcontentButton()
        {
            this.SubContentButton.ButtonText.text = SubContentHolder.activeSelf ? "â–¼" : "â–²";
            Color color = SubContentHolder.activeSelf ? subActiveColor : subInactiveColor;
            RuntimeHelper.SetColorBlock(SubContentButton.Component, color, color * 1.3f);
        }

        protected abstract void ConstructEvaluateHolder(GameObject parent);

        public virtual GameObject CreateContent(GameObject parent)
        {
            // Main layout

            UIRoot = UIFactory.CreateUIObject(this.GetType().Name, parent, new Vector2(100, 30));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(UIRoot, false, false, true, true, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 100, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            GameObject horiRow = UIFactory.CreateUIObject("HoriGroup", UIRoot);
            UIFactory.SetLayoutElement(horiRow, minHeight: 29, flexibleHeight: 150, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(horiRow, false, false, true, true, 5, 2, childAlignment: TextAnchor.UpperLeft);
            horiRow.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // Left name label

            NameLabel = UIFactory.CreateLabel(horiRow, "NameLabel", "<notset>", TextAnchor.MiddleLeft);
            NameLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            NameLayout = UIFactory.SetLayoutElement(NameLabel.gameObject, minHeight: 25, minWidth: 20, flexibleHeight: 300, flexibleWidth: 0);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(NameLabel.gameObject, true, true, true, true);

            HiddenNameLabel = UIFactory.CreateInputField(NameLabel.gameObject, "HiddenNameLabel", "");
            RectTransform hiddenRect = HiddenNameLabel.Component.GetComponent<RectTransform>();
            hiddenRect.anchorMin = Vector2.zero;
            hiddenRect.anchorMax = Vector2.one;
            HiddenNameLabel.Component.readOnly = true;
            HiddenNameLabel.Component.lineType = UnityEngine.UI.InputField.LineType.MultiLineNewline;
            HiddenNameLabel.Component.textComponent.horizontalOverflow = HorizontalWrapMode.Wrap;
            HiddenNameLabel.Component.gameObject.GetComponent<Image>().color = Color.clear;
            HiddenNameLabel.Component.textComponent.color = Color.clear;
            UIFactory.SetLayoutElement(HiddenNameLabel.Component.gameObject, minHeight: 25, minWidth: 20, flexibleHeight: 300, flexibleWidth: 0);

            // Right vertical group

            RightGroupContent = UIFactory.CreateUIObject("RightGroup", horiRow);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(RightGroupContent, false, false, true, true, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(RightGroupContent, minHeight: 25, minWidth: 200, flexibleWidth: 9999, flexibleHeight: 800);
            RightGroupLayout = RightGroupContent.GetComponent<LayoutElement>();

            ConstructEvaluateHolder(RightGroupContent);

            // Right horizontal group

            GameObject rightHoriGroup = UIFactory.CreateUIObject("RightHoriGroup", RightGroupContent);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(rightHoriGroup, false, false, true, true, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(rightHoriGroup, minHeight: 25, minWidth: 200, flexibleWidth: 9999, flexibleHeight: 800);

            SubContentButton = UIFactory.CreateButton(rightHoriGroup, "SubContentButton", "â–²", subInactiveColor);
            UIFactory.SetLayoutElement(SubContentButton.Component.gameObject, minWidth: 25, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            SubContentButton.OnClick += SubContentClicked;

            // Type label

            TypeLabel = UIFactory.CreateLabel(rightHoriGroup, "ReturnLabel", "<notset>", TextAnchor.MiddleLeft);
            TypeLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(TypeLabel.gameObject, minHeight: 25, flexibleHeight: 150, minWidth: 45, flexibleWidth: 0);

            // Bool and number value interaction

            GameObject toggleObj = UIFactory.CreateToggle(rightHoriGroup, "Toggle", out Toggle, out ToggleText);
            UIFactory.SetLayoutElement(toggleObj, minWidth: 70, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            ToggleText.color = SignatureHighlighter.KeywordBlue;
            Toggle.onValueChanged.AddListener(ToggleClicked);

            InputField = UIFactory.CreateInputField(rightHoriGroup, "InputField", "...");
            UIFactory.SetLayoutElement(InputField.UIRoot, minWidth: 150, flexibleWidth: 0, minHeight: 25, flexibleHeight: 0);

            // Apply

            ApplyButton = UIFactory.CreateButton(rightHoriGroup, "ApplyButton", "Apply", new Color(0.15f, 0.19f, 0.15f));
            UIFactory.SetLayoutElement(ApplyButton.Component.gameObject, minWidth: 70, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            ApplyButton.OnClick += ApplyClicked;

            // Inspect 

            InspectButton = UIFactory.CreateButton(rightHoriGroup, "InspectButton", "Inspect", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(InspectButton.Component.gameObject, minWidth: 70, flexibleWidth: 0, minHeight: 25);
            InspectButton.OnClick += InspectClicked;

            // Main value label

            ValueLabel = UIFactory.CreateLabel(rightHoriGroup, "ValueLabel", "Value goes here", TextAnchor.MiddleLeft);
            ValueLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(ValueLabel.gameObject, minHeight: 25, flexibleHeight: 150, flexibleWidth: 9999);

            // Copy and Paste buttons

            GameObject buttonHolder = UIFactory.CreateHorizontalGroup(rightHoriGroup, "CopyPasteButtons", false, false, true, true, 4,
                bgColor: new(1, 1, 1, 0), childAlignment: TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(buttonHolder, minWidth: 60, flexibleWidth: 0);

            CopyButton = UIFactory.CreateButton(buttonHolder, "CopyButton", "Copy", new Color(0.13f, 0.13f, 0.13f, 1f));
            UIFactory.SetLayoutElement(CopyButton.Component.gameObject, minHeight: 25, minWidth: 28, flexibleWidth: 0);
            CopyButton.ButtonText.color = Color.yellow;
            CopyButton.ButtonText.fontSize = 10;
            CopyButton.OnClick += OnCopyClicked;

            PasteButton = UIFactory.CreateButton(buttonHolder, "PasteButton", "Paste", new Color(0.13f, 0.13f, 0.13f, 1f));
            UIFactory.SetLayoutElement(PasteButton.Component.gameObject, minHeight: 25, minWidth: 28, flexibleWidth: 0);
            PasteButton.ButtonText.color = Color.green;
            PasteButton.ButtonText.fontSize = 10;
            PasteButton.OnClick += OnPasteClicked;

            // Subcontent

            SubContentHolder = UIFactory.CreateUIObject("SubContent", UIRoot);
            UIFactory.SetLayoutElement(SubContentHolder.gameObject, minHeight: 30, flexibleHeight: 600, minWidth: 100, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(SubContentHolder, true, true, true, true, 2, childAlignment: TextAnchor.UpperLeft);
            //SubContentHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.MinSize;
            SubContentHolder.SetActive(false);

            // Bottom separator
            GameObject separator = UIFactory.CreateUIObject("BottomSeperator", UIRoot);
            UIFactory.SetLayoutElement(separator, minHeight: 1, flexibleHeight: 0, flexibleWidth: 9999);
            separator.AddComponent<Image>().color = Color.black;

            return UIRoot;
        }
    }
}

```

`src/Config/ConfigElement.cs`:

```cs
namespace UnityExplorer.Config
{
    public class ConfigElement<T> : IConfigElement
    {
        public string Name { get; }
        public string Description { get; }

        public bool IsInternal { get; }
        public Type ElementType => typeof(T);

        public Action<T> OnValueChanged;
        public Action OnValueChangedNotify { get; set; }

        public object DefaultValue { get; }

        public ConfigHandler Handler => IsInternal
            ? ConfigManager.InternalHandler
            : ConfigManager.Handler;

        public T Value
        {
            get => m_value;
            set => SetValue(value);
        }
        private T m_value;

        object IConfigElement.BoxedValue
        {
            get => m_value;
            set => SetValue((T)value);
        }

        public ConfigElement(string name, string description, T defaultValue, bool isInternal = false)
        {
            Name = name;
            Description = description;

            m_value = defaultValue;
            DefaultValue = defaultValue;

            IsInternal = isInternal;

            ConfigManager.RegisterConfigElement(this);
        }

        private void SetValue(T value)
        {
            if ((m_value == null && value == null) || (m_value != null && m_value.Equals(value)))
                return;

            m_value = value;

            Handler.SetConfigValue(this, value);

            OnValueChanged?.Invoke(value);
            OnValueChangedNotify?.Invoke();

            Handler.OnAnyConfigChanged();
        }

        object IConfigElement.GetLoaderConfigValue() => GetLoaderConfigValue();

        public T GetLoaderConfigValue()
        {
            return Handler.GetConfigValue(this);
        }

        public void RevertToDefaultValue()
        {
            Value = (T)DefaultValue;
        }
    }
}

```

`src/Config/ConfigHandler.cs`:

```cs
namespace UnityExplorer.Config
{
    public abstract class ConfigHandler
    {
        public abstract void RegisterConfigElement<T>(ConfigElement<T> element);

        public abstract void SetConfigValue<T>(ConfigElement<T> element, T value);

        public abstract T GetConfigValue<T>(ConfigElement<T> element);

        public abstract void Init();

        public abstract void LoadConfig();

        public abstract void SaveConfig();

        public virtual void OnAnyConfigChanged() { }
    }
}

```

`src/Config/ConfigManager.cs`:

```cs
using UnityExplorer.UI;

namespace UnityExplorer.Config
{
    public static class ConfigManager
    {
        internal static readonly Dictionary<string, IConfigElement> ConfigElements = new();
        internal static readonly Dictionary<string, IConfigElement> InternalConfigs = new();

        // Each Mod Loader has its own ConfigHandler.
        // See the UnityExplorer.Loader namespace for the implementations.
        public static ConfigHandler Handler { get; private set; }

        // Actual UE Settings
        public static ConfigElement<KeyCode> Master_Toggle;
        public static ConfigElement<bool> Hide_On_Startup;
        public static ConfigElement<float> Startup_Delay_Time;
        public static ConfigElement<bool> Disable_EventSystem_Override;
        public static ConfigElement<int> Target_Display;
        public static ConfigElement<bool> Force_Unlock_Mouse;
        public static ConfigElement<KeyCode> Force_Unlock_Toggle;
        public static ConfigElement<string> Default_Output_Path;
        public static ConfigElement<string> DnSpy_Path;
        public static ConfigElement<bool> Log_Unity_Debug;
        public static ConfigElement<UIManager.VerticalAnchor> Main_Navbar_Anchor;
        public static ConfigElement<KeyCode> World_MouseInspect_Keybind;
        public static ConfigElement<KeyCode> UI_MouseInspect_Keybind;
        public static ConfigElement<string> CSConsole_Assembly_Blacklist;
        public static ConfigElement<string> Reflection_Signature_Blacklist;

        // internal configs
        internal static InternalConfigHandler InternalHandler { get; private set; }
        internal static readonly Dictionary<UIManager.Panels, ConfigElement<string>> PanelSaveData = new();

        internal static ConfigElement<string> GetPanelSaveData(UIManager.Panels panel)
        {
            if (!PanelSaveData.ContainsKey(panel))
                PanelSaveData.Add(panel, new ConfigElement<string>(panel.ToString(), string.Empty, string.Empty, true));
            return PanelSaveData[panel];
        }

        public static void Init(ConfigHandler configHandler)
        {
            Handler = configHandler;
            Handler.Init();

            InternalHandler = new InternalConfigHandler();
            InternalHandler.Init();

            CreateConfigElements();

            Handler.LoadConfig();
            InternalHandler.LoadConfig();

#if STANDALONE
            Loader.Standalone.ExplorerEditorBehaviour.Instance?.LoadConfigs();
#endif
        }

        internal static void RegisterConfigElement<T>(ConfigElement<T> configElement)
        {
            if (!configElement.IsInternal)
            {
                Handler.RegisterConfigElement(configElement);
                ConfigElements.Add(configElement.Name, configElement);
            }
            else
            {
                InternalHandler.RegisterConfigElement(configElement);
                InternalConfigs.Add(configElement.Name, configElement);
            }
        }

        private static void CreateConfigElements()
        {
            Master_Toggle = new("UnityExplorer Toggle",
                "The key to enable or disable UnityExplorer's menu and features.",
                KeyCode.F7);

            Hide_On_Startup = new("Hide On Startup",
                "Should UnityExplorer be hidden on startup?",
                false);

            Startup_Delay_Time = new("Startup Delay Time",
                "The delay on startup before the UI is created.",
                1f);

            Target_Display = new("Target Display",
                "The monitor index for UnityExplorer to use, if you have multiple. 0 is the default display, 1 is secondary, etc. " +
                "Restart recommended when changing this setting. Make sure your extra monitors are the same resolution as your primary monitor.",
                0);

            Force_Unlock_Mouse = new("Force Unlock Mouse",
                "Force the Cursor to be unlocked (visible) when the UnityExplorer menu is open.",
                true);
            Force_Unlock_Mouse.OnValueChanged += (bool value) => UniverseLib.Config.ConfigManager.Force_Unlock_Mouse = value;

            Force_Unlock_Toggle = new("Force Unlock Toggle Key",
                "The keybind to toggle the 'Force Unlock Mouse' setting. Only usable when UnityExplorer is open.",
                KeyCode.None);

            Disable_EventSystem_Override = new("Disable EventSystem override",
                "If enabled, UnityExplorer will not override the EventSystem from the game.\n<b>May require restart to take effect.</b>",
                false);
            Disable_EventSystem_Override.OnValueChanged += (bool value) => UniverseLib.Config.ConfigManager.Disable_EventSystem_Override = value;

            Default_Output_Path = new("Default Output Path",
                "The default output path when exporting things from UnityExplorer.",
                Path.Combine(ExplorerCore.ExplorerFolder, "Output"));

            DnSpy_Path = new("dnSpy Path",
                "The full path to dnSpy.exe (64-bit).",
                @"C:/Program Files/dnspy/dnSpy.exe");

            Main_Navbar_Anchor = new("Main Navbar Anchor",
                "The vertical anchor of the main UnityExplorer Navbar, in case you want to move it.",
                UIManager.VerticalAnchor.Top);

            Log_Unity_Debug = new("Log Unity Debug",
                "Should UnityEngine.Debug.Log messages be printed to UnityExplorer's log?",
                false);

            World_MouseInspect_Keybind = new("World Mouse-Inspect Keybind",
                "Optional keybind to being a World-mode Mouse Inspect.",
                KeyCode.None);

            UI_MouseInspect_Keybind = new("UI Mouse-Inspect Keybind",
                "Optional keybind to begin a UI-mode Mouse Inspect.",
                KeyCode.None);

            CSConsole_Assembly_Blacklist = new("CSharp Console Assembly Blacklist", 
                "Use this to blacklist Assembly names from being referenced by the C# Console. Requires a Reset of the C# Console.\n" +
                "Separate each Assembly with a semicolon ';'." +
                "For example, to blacklist Assembly-CSharp, you would add 'Assembly-CSharp;'",
                "");

            Reflection_Signature_Blacklist = new("Member Signature Blacklist",
                "Use this to blacklist certain member signatures if they are known to cause a crash or other issues.\r\n" +
                "Seperate signatures with a semicolon ';'.\r\n" +
                "For example, to blacklist Camera.main, you would add 'UnityEngine.Camera.main;'",
                "");
        }
    }
}

```

`src/Config/IConfigElement.cs`:

```cs
namespace UnityExplorer.Config
{
    public interface IConfigElement
    {
        string Name { get; }
        string Description { get; }

        bool IsInternal { get; }
        Type ElementType { get; }

        object BoxedValue { get; set; }
        object DefaultValue { get; }

        object GetLoaderConfigValue();

        void RevertToDefaultValue();

        Action OnValueChangedNotify { get; set; }
    }
}

```

`src/Config/InternalConfigHandler.cs`:

```cs
using Tomlet;
using Tomlet.Models;
using UnityExplorer.UI;

namespace UnityExplorer.Config
{
    public class InternalConfigHandler : ConfigHandler
    {
        internal static string CONFIG_PATH;

        public override void Init()
        {
            CONFIG_PATH = Path.Combine(ExplorerCore.ExplorerFolder, "data.cfg");
        }

        public override void LoadConfig()
        {
            if (!TryLoadConfig())
                SaveConfig();
        }

        public override void RegisterConfigElement<T>(ConfigElement<T> element)
        {
            // Not necessary
        }

        public override void SetConfigValue<T>(ConfigElement<T> element, T value)
        {
            // Not necessary
        }

        // Not necessary, just return the value.
        public override T GetConfigValue<T>(ConfigElement<T> element) => element.Value;

        // Always just auto-save.
        public override void OnAnyConfigChanged() => SaveConfig();

        public bool TryLoadConfig()
        {
            try
            {
                if (!File.Exists(CONFIG_PATH))
                    return false;

                TomlDocument document = TomlParser.ParseFile(CONFIG_PATH);
                foreach (string key in document.Keys)
                {
                    if (!Enum.IsDefined(typeof(UIManager.Panels), key))
                        continue;

                    UIManager.Panels panelKey = (UIManager.Panels)Enum.Parse(typeof(UIManager.Panels), key);
                    ConfigManager.GetPanelSaveData(panelKey).Value = document.GetString(key);
                }

                return true;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Error loading internal data: " + ex.ToString());
                return false;
            }
        }

        public override void SaveConfig()
        {
            if (UIManager.Initializing)
                return;

            TomlDocument tomlDocument = TomlDocument.CreateEmpty();
            foreach (KeyValuePair<string, IConfigElement> entry in ConfigManager.InternalConfigs)
                tomlDocument.Put(entry.Key, entry.Value.BoxedValue as string, false);

            File.WriteAllText(CONFIG_PATH, tomlDocument.SerializedValue);
        }
    }
}

```

`src/ExplorerBehaviour.cs`:

```cs
using UnityExplorer.UI;
#if CPP
#if UNHOLLOWER
using UnhollowerRuntimeLib;
#else
using Il2CppInterop.Runtime.Injection;
#endif
#endif

namespace UnityExplorer
{
    public class ExplorerBehaviour : MonoBehaviour
    {
        internal static ExplorerBehaviour Instance { get; private set; }

#if CPP
        public ExplorerBehaviour(System.IntPtr ptr) : base(ptr) { }
#endif

        internal static void Setup()
        {
#if CPP
            ClassInjector.RegisterTypeInIl2Cpp<ExplorerBehaviour>();
#endif

            GameObject obj = new("ExplorerBehaviour");
            DontDestroyOnLoad(obj);
            obj.hideFlags = HideFlags.HideAndDontSave;
            Instance = obj.AddComponent<ExplorerBehaviour>();
        }

        internal void Update()
        {
            ExplorerCore.Update();
        }

        // For editor, to clean up objects

        internal void OnDestroy()
        {
            OnApplicationQuit();
        }

        internal bool quitting;

        internal void OnApplicationQuit()
        {
            if (quitting) return;
            quitting = true;

            TryDestroy(UIManager.UIRoot?.transform.root.gameObject);

            TryDestroy((typeof(Universe).Assembly.GetType("UniverseLib.UniversalBehaviour")
                .GetProperty("Instance", BindingFlags.Static | BindingFlags.NonPublic)
                .GetValue(null, null)
                as Component).gameObject);

            TryDestroy(this.gameObject);
        }

        internal void TryDestroy(GameObject obj)
        {
            try
            {
                if (obj)
                    Destroy(obj);
            }
            catch { }
        }
    }
}

```

`src/ExplorerCore.cs`:

```cs
global using System;
global using System.Collections.Generic;
global using System.IO;
global using System.Linq;
global using System.Reflection;
global using UnityEngine;
global using UnityEngine.UI;
global using UniverseLib;
global using UniverseLib.Utility;
using UnityExplorer.Config;
using UnityExplorer.ObjectExplorer;
using UnityExplorer.Runtime;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UniverseLib.Input;

namespace UnityExplorer
{
    public static class ExplorerCore
    {
        public const string NAME = "UnityExplorer";
        public const string VERSION = "4.9.0";
        public const string AUTHOR = "Sinai";
        public const string GUID = "com.sinai.unityexplorer";

        public static IExplorerLoader Loader { get; private set; }
        public static string ExplorerFolder => Path.Combine(Loader.ExplorerFolderDestination, Loader.ExplorerFolderName);
        public const string DEFAULT_EXPLORER_FOLDER_NAME = "sinai-dev-UnityExplorer";

        public static HarmonyLib.Harmony Harmony { get; } = new HarmonyLib.Harmony(GUID);

        /// <summary>
        /// Initialize UnityExplorer with the provided Loader implementation.
        /// </summary>
        public static void Init(IExplorerLoader loader)
        {
            if (Loader != null)
                throw new Exception("UnityExplorer is already loaded.");

            Loader = loader;

            Log($"{NAME} {VERSION} initializing...");

            CheckLegacyExplorerFolder();
            Directory.CreateDirectory(ExplorerFolder);
            ConfigManager.Init(Loader.ConfigHandler);

            Universe.Init(ConfigManager.Startup_Delay_Time.Value, LateInit, Log, new()
            {
                Disable_EventSystem_Override = ConfigManager.Disable_EventSystem_Override.Value,
                Force_Unlock_Mouse = ConfigManager.Force_Unlock_Mouse.Value,
                Unhollowed_Modules_Folder = loader.UnhollowedModulesFolder
            });

            UERuntimeHelper.Init();
            ExplorerBehaviour.Setup();
            UnityCrashPrevention.Init();
        }

        // Do a delayed setup so that objects aren't destroyed instantly.
        // This can happen for a multitude of reasons.
        // Default delay is 1 second which is usually enough.
        static void LateInit()
        {
            SceneHandler.Init();

            Log($"Creating UI...");

            UIManager.InitUI();

            Log($"{NAME} {VERSION} ({Universe.Context}) initialized.");

            // InspectorManager.Inspect(typeof(Tests.TestClass));
        }

        internal static void Update()
        {
            // check master toggle
            if (InputManager.GetKeyDown(ConfigManager.Master_Toggle.Value))
            {
                UIManager.ShowMenu = !UIManager.ShowMenu;
            }
        }


        #region LOGGING

        public static void Log(object message)
            => Log(message, LogType.Log);

        public static void LogWarning(object message)
            => Log(message, LogType.Warning);

        public static void LogError(object message)
            => Log(message, LogType.Error);

        public static void LogUnity(object message, LogType logType)
        {
            if (!ConfigManager.Log_Unity_Debug.Value)
                return;

            Log($"[Unity] {message}", logType);
        }

        private static void Log(object message, LogType logType)
        {
            string log = message?.ToString() ?? "";

            LogPanel.Log(log, logType);

            switch (logType)
            {
                case LogType.Assert:
                case LogType.Log:
                    Loader.OnLogMessage(log);
                    break;

                case LogType.Warning:
                    Loader.OnLogWarning(log);
                    break;

                case LogType.Error:
                case LogType.Exception:
                    Loader.OnLogError(log);
                    break;
            }
        }

        #endregion


        #region LEGACY FOLDER MIGRATION

        // Can be removed eventually. For migration from <4.7.0
        static void CheckLegacyExplorerFolder()
        {
            string legacyPath = Path.Combine(Loader.ExplorerFolderDestination, "UnityExplorer");
            if (Directory.Exists(legacyPath))
            {
                LogWarning($"Attempting to migrate old 'UnityExplorer/' folder to 'sinai-dev-UnityExplorer/'...");

                // If new folder doesn't exist yet, let's just use Move().
                if (!Directory.Exists(ExplorerFolder))
                {
                    try
                    {
                        Directory.Move(legacyPath, ExplorerFolder);
                        Log("Migrated successfully.");
                    }
                    catch (Exception ex)
                    {
                        LogWarning($"Exception migrating folder: {ex}");
                    }
                }
                else // We have to merge
                {
                    try
                    {
                        CopyAll(new(legacyPath), new(ExplorerFolder));
                        Directory.Delete(legacyPath, true);
                        Log("Migrated successfully.");
                    }
                    catch (Exception ex)
                    {
                        LogWarning($"Exception migrating folder: {ex}");
                    }
                }
            }
        }

        public static void CopyAll(DirectoryInfo source, DirectoryInfo target)
        {
            Directory.CreateDirectory(target.FullName);

            // Copy each file into it's new directory.
            foreach (FileInfo fi in source.GetFiles())
                fi.MoveTo(Path.Combine(target.ToString(), fi.Name));

            // Copy each subdirectory using recursion.
            foreach (DirectoryInfo diSourceSubDir in source.GetDirectories())
            {
                DirectoryInfo nextTargetSubDir = target.CreateSubdirectory(diSourceSubDir.Name);
                CopyAll(diSourceSubDir, nextTargetSubDir);
            }
        }

        #endregion
    }
}

```

`src/Hooks/AddHookCell.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.Hooks
{
    public class AddHookCell : ICell
    {
        public bool Enabled => UIRoot.activeSelf;

        public RectTransform Rect { get; set; }
        public GameObject UIRoot { get; set; }

        public float DefaultHeight => 30;

        public Text MethodNameLabel;
        public ButtonRef HookButton;

        public int CurrentDisplayedIndex;

        private void OnHookClicked()
        {
            HookCreator.AddHookClicked(CurrentDisplayedIndex);
        }

        public void Enable()
        {
            this.UIRoot.SetActive(true);
        }

        public void Disable()
        {
            this.UIRoot.SetActive(false);
        }

        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateUIObject(this.GetType().Name, parent, new Vector2(100, 30));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 5, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 100, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            HookButton = UIFactory.CreateButton(UIRoot, "HookButton", "Hook", new Color(0.2f, 0.25f, 0.2f));
            UIFactory.SetLayoutElement(HookButton.Component.gameObject, minHeight: 25, minWidth: 100);
            HookButton.OnClick += OnHookClicked;

            MethodNameLabel = UIFactory.CreateLabel(UIRoot, "MethodName", "NOT SET", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(MethodNameLabel.gameObject, minHeight: 25, flexibleWidth: 9999);

            return UIRoot;
        }
    }
}

```

`src/Hooks/HookCell.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.Hooks
{
    public class HookCell : ICell
    {
        public bool Enabled => UIRoot.activeSelf;

        public RectTransform Rect { get; set; }
        public GameObject UIRoot { get; set; }

        public float DefaultHeight => 30;

        public Text MethodNameLabel;
        public ButtonRef EditPatchButton;
        public ButtonRef ToggleActiveButton;
        public ButtonRef DeleteButton;

        public int CurrentDisplayedIndex;

        private void OnToggleActiveClicked()
        {
            HookList.EnableOrDisableHookClicked(CurrentDisplayedIndex);
        }

        private void OnDeleteClicked()
        {
            HookList.DeleteHookClicked(CurrentDisplayedIndex);
            HookCreator.AddHooksScrollPool.Refresh(true, false);
        }

        private void OnEditPatchClicked()
        {
            HookList.EditPatchClicked(CurrentDisplayedIndex);
        }

        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateUIObject(this.GetType().Name, parent, new Vector2(100, 30));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 100, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            MethodNameLabel = UIFactory.CreateLabel(UIRoot, "MethodName", "NOT SET", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(MethodNameLabel.gameObject, minHeight: 25, flexibleWidth: 9999);

            ToggleActiveButton = UIFactory.CreateButton(UIRoot, "ToggleActiveBtn", "On", new Color(0.15f, 0.2f, 0.15f));
            UIFactory.SetLayoutElement(ToggleActiveButton.Component.gameObject, minHeight: 25, minWidth: 35);
            ToggleActiveButton.OnClick += OnToggleActiveClicked;

            EditPatchButton = UIFactory.CreateButton(UIRoot, "EditButton", "Edit", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(EditPatchButton.Component.gameObject, minHeight: 25, minWidth: 35);
            EditPatchButton.OnClick += OnEditPatchClicked;

            DeleteButton = UIFactory.CreateButton(UIRoot, "DeleteButton", "X", new Color(0.2f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(DeleteButton.Component.gameObject, minHeight: 25, minWidth: 35);
            DeleteButton.OnClick += OnDeleteClicked;

            return UIRoot;
        }

        public void Disable()
        {
            UIRoot.SetActive(false);
        }

        public void Enable()
        {
            UIRoot.SetActive(true);
        }
    }
}

```

`src/Hooks/HookCreator.cs`:

```cs
using HarmonyLib;
using UnityExplorer.CSConsole;
using UnityExplorer.Runtime;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.Hooks
{
    public class HookCreator : ICellPoolDataSource<AddHookCell>
    {
        public int ItemCount => filteredEligibleMethods.Count;

        static readonly List<MethodInfo> currentAddEligibleMethods = new();
        static readonly List<MethodInfo> filteredEligibleMethods = new();
        static readonly List<string> currentEligibleNamesForFiltering = new();

        // hook editor
        static readonly LexerBuilder Lexer = new();
        internal static HookInstance CurrentEditedHook;

        // Add Hooks UI
        internal static GameObject AddHooksRoot;
        internal static ScrollPool<AddHookCell> AddHooksScrollPool;
        internal static Text AddHooksLabel;
        internal static InputFieldRef AddHooksMethodFilterInput;
        internal static InputFieldRef ClassSelectorInputField;
        internal static Type pendingGenericDefinition;
        internal static MethodInfo pendingGenericMethod;

        public static bool PendingGeneric => pendingGenericDefinition != null || pendingGenericMethod != null;

        // Hook Source Editor UI
        public static GameObject EditorRoot { get; private set; }
        public static Text EditingHookLabel { get; private set; }
        public static InputFieldScroller EditorInputScroller { get; private set; }
        public static InputFieldRef EditorInput => EditorInputScroller.InputField;
        public static Text EditorInputText { get; private set; }
        public static Text EditorHighlightText { get; private set; }

        // ~~~~~~ New hook method selector ~~~~~~~

        public void OnClassSelectedForHooks(string typeFullName)
        {
            Type type = ReflectionUtility.GetTypeByName(typeFullName);
            if (type == null)
            {
                ExplorerCore.LogWarning($"Could not find any type by name {typeFullName}!");
                return;
            }
            if (type.IsGenericType)
            {
                pendingGenericDefinition = type;
                HookManagerPanel.genericArgsHandler.Show(OnGenericClassChosen, OnGenericClassCancel, type);
                HookManagerPanel.Instance.SetPage(HookManagerPanel.Pages.GenericArgsSelector);
                return;    
            }

            ShowMethodsForType(type);
        }

        void ShowMethodsForType(Type type)
        {
            SetAddHooksLabelType(SignatureHighlighter.Parse(type, true));

            AddHooksMethodFilterInput.Text = string.Empty;

            filteredEligibleMethods.Clear();
            currentAddEligibleMethods.Clear();
            currentEligibleNamesForFiltering.Clear();
            foreach (MethodInfo method in type.GetMethods(ReflectionUtility.FLAGS))
            {
                if (UERuntimeHelper.IsBlacklisted(method))
                    continue;
                currentAddEligibleMethods.Add(method);
                currentEligibleNamesForFiltering.Add(SignatureHighlighter.RemoveHighlighting(SignatureHighlighter.ParseMethod(method)));
                filteredEligibleMethods.Add(method);
            }

            AddHooksScrollPool.Refresh(true, true);
        }

        void OnGenericClassChosen(Type[] genericArgs)
        {
            Type generic = pendingGenericDefinition.MakeGenericType(genericArgs);
            ShowMethodsForType(generic);
            HookManagerPanel.Instance.SetPage(HookManagerPanel.Pages.ClassMethodSelector);
        }

        void OnGenericClassCancel()
        {
            pendingGenericDefinition = null;
            HookManagerPanel.Instance.SetPage(HookManagerPanel.Pages.ClassMethodSelector);
        }

        public void SetAddHooksLabelType(string typeText)
        {
            AddHooksLabel.text = $"Adding hooks to: {typeText}";

            AddHooksMethodFilterInput.GameObject.SetActive(true);
            AddHooksScrollPool.UIRoot.SetActive(true);
        }

        public static void AddHookClicked(int index)
        {
            if (index >= filteredEligibleMethods.Count)
                return;

            MethodInfo method = filteredEligibleMethods[index];
            if (!method.IsGenericMethod && HookList.hookedSignatures.Contains(method.FullDescription()))
            {
                ExplorerCore.Log($"Non-generic methods can only be hooked once.");
                return;
            }
            else if (method.IsGenericMethod)
            {
                pendingGenericMethod = method;
                HookManagerPanel.genericArgsHandler.Show(OnGenericMethodChosen, OnGenericMethodCancel, method);
                HookManagerPanel.Instance.SetPage(HookManagerPanel.Pages.GenericArgsSelector);
                return;
            }

            AddHook(filteredEligibleMethods[index]);
        }

        static void OnGenericMethodChosen(Type[] arguments)
        {
            MethodInfo generic = pendingGenericMethod.MakeGenericMethod(arguments);
            AddHook(generic);
        }

        static void OnGenericMethodCancel()
        {
            pendingGenericMethod = null;
            HookManagerPanel.Instance.SetPage(HookManagerPanel.Pages.ClassMethodSelector);
        }

        public static void AddHook(MethodInfo method)
        {
            HookManagerPanel.Instance.SetPage(HookManagerPanel.Pages.ClassMethodSelector);

            string sig = method.FullDescription();
            if (HookList.hookedSignatures.Contains(sig))
            {
                ExplorerCore.LogWarning($"Method is already hooked!");
                return;
            }

            HookInstance hook = new(method);
            HookList.hookedSignatures.Add(sig);
            HookList.currentHooks.Add(sig, hook);

            AddHooksScrollPool.Refresh(true, false);
            HookList.HooksScrollPool.Refresh(true, false);
        }

        public void OnAddHookFilterInputChanged(string input)
        {
            filteredEligibleMethods.Clear();

            if (string.IsNullOrEmpty(input))
                filteredEligibleMethods.AddRange(currentAddEligibleMethods);
            else
            {
                for (int i = 0; i < currentAddEligibleMethods.Count; i++)
                {
                    MethodInfo eligible = currentAddEligibleMethods[i];
                    string sig = currentEligibleNamesForFiltering[i];
                    if (sig.ContainsIgnoreCase(input))
                        filteredEligibleMethods.Add(eligible);
                }
            }

            AddHooksScrollPool.Refresh(true, true);
        }

        // Set eligible method cell

        public void OnCellBorrowed(AddHookCell cell) { }

        public void SetCell(AddHookCell cell, int index)
        {
            if (index >= filteredEligibleMethods.Count)
            {
                cell.Disable();
                return;
            }

            cell.CurrentDisplayedIndex = index;
            MethodInfo method = filteredEligibleMethods[index];

            cell.MethodNameLabel.text = SignatureHighlighter.ParseMethod(method);
        }

        // ~~~~~~~~ Hook source editor ~~~~~~~~

        internal static void SetEditedHook(HookInstance hook)
        {
            CurrentEditedHook = hook;
            EditingHookLabel.text = $"Editing: {SignatureHighlighter.Parse(hook.TargetMethod.DeclaringType, false, hook.TargetMethod)}";
            EditorInput.Text = hook.PatchSourceCode;
        }

        internal static void OnEditorInputChanged(string value)
        {
            EditorHighlightText.text = Lexer.BuildHighlightedString(value, 0, value.Length - 1, 0, EditorInput.Component.caretPosition, out _);
        }

        internal static void EditorInputCancel()
        {
            CurrentEditedHook = null;
            HookManagerPanel.Instance.SetPage(HookManagerPanel.Pages.ClassMethodSelector);
        }

        internal static void EditorInputSave()
        {
            string input = EditorInput.Text;
            bool wasEnabled = CurrentEditedHook.Enabled;
            if (CurrentEditedHook.CompileAndGenerateProcessor(input))
            {
                if (wasEnabled)
                    CurrentEditedHook.Patch();

                CurrentEditedHook.PatchSourceCode = input;
                CurrentEditedHook = null;
                HookManagerPanel.Instance.SetPage(HookManagerPanel.Pages.ClassMethodSelector);
            }

            HookList.HooksScrollPool.Refresh(true, false);
        }

        // UI Construction

        internal void ConstructAddHooksView(GameObject rightGroup)
        {
            AddHooksRoot = UIFactory.CreateUIObject("AddHooksPanel", rightGroup);
            UIFactory.SetLayoutElement(AddHooksRoot, flexibleHeight: 9999, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(AddHooksRoot, false, false, true, true);

            GameObject addRow = UIFactory.CreateHorizontalGroup(AddHooksRoot, "AddRow", false, true, true, true, 4,
                new Vector4(2, 2, 2, 2), new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(addRow, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            ClassSelectorInputField = UIFactory.CreateInputField(addRow, "ClassInput", "Enter a class to add hooks to...");
            UIFactory.SetLayoutElement(ClassSelectorInputField.Component.gameObject, flexibleWidth: 9999, minHeight: 25, flexibleHeight: 0);
            TypeCompleter completer = new(typeof(object), ClassSelectorInputField, true, false, true);
            //completer.AllTypes = true;

            ButtonRef addButton = UIFactory.CreateButton(addRow, "AddButton", "View Methods");
            UIFactory.SetLayoutElement(addButton.Component.gameObject, minWidth: 110, minHeight: 25);
            addButton.OnClick += () => { OnClassSelectedForHooks(ClassSelectorInputField.Text); };

            AddHooksLabel = UIFactory.CreateLabel(AddHooksRoot, "AddLabel", "Choose a class to begin...", TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(AddHooksLabel.gameObject, minHeight: 30, minWidth: 100, flexibleWidth: 9999);

            AddHooksMethodFilterInput = UIFactory.CreateInputField(AddHooksRoot, "FilterInputField", "Filter method names...");
            UIFactory.SetLayoutElement(AddHooksMethodFilterInput.Component.gameObject, minHeight: 30, flexibleWidth: 9999);
            AddHooksMethodFilterInput.OnValueChanged += OnAddHookFilterInputChanged;

            AddHooksScrollPool = UIFactory.CreateScrollPool<AddHookCell>(AddHooksRoot, "MethodAddScrollPool",
                out GameObject addScrollRoot, out GameObject addContent);
            UIFactory.SetLayoutElement(addScrollRoot, flexibleHeight: 9999);
            AddHooksScrollPool.Initialize(this);

            AddHooksMethodFilterInput.GameObject.SetActive(false);
            AddHooksScrollPool.UIRoot.SetActive(false);
        }

        public void ConstructEditor(GameObject parent)
        {
            EditorRoot = UIFactory.CreateUIObject("HookSourceEditor", parent);
            UIFactory.SetLayoutElement(EditorRoot, flexibleHeight: 9999, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(EditorRoot, true, true, true, true, 2, 3, 3, 3, 3);

            EditingHookLabel = UIFactory.CreateLabel(EditorRoot, "EditingHookLabel", "NOT SET", TextAnchor.MiddleCenter);
            EditingHookLabel.fontStyle = FontStyle.Bold;
            UIFactory.SetLayoutElement(EditingHookLabel.gameObject, flexibleWidth: 9999, minHeight: 25);

            Text editorLabel = UIFactory.CreateLabel(EditorRoot,
                "EditorLabel",
                "* Accepted method names are <b>Prefix</b>, <b>Postfix</b>, <b>Finalizer</b> and <b>Transpiler</b> (can define multiple).\n" +
                "* Your patch methods must be static.\n" +
                "* Hooks are temporary! Copy the source into your IDE to avoid losing work if you wish to keep it!",
                TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(editorLabel.gameObject, minHeight: 25, flexibleWidth: 9999);

            GameObject editorButtonRow = UIFactory.CreateHorizontalGroup(EditorRoot, "ButtonRow", false, false, true, true, 5);
            UIFactory.SetLayoutElement(editorButtonRow, minHeight: 25, flexibleWidth: 9999);

            ButtonRef editorSaveButton = UIFactory.CreateButton(editorButtonRow, "DoneButton", "Save and Return", new Color(0.2f, 0.3f, 0.2f));
            UIFactory.SetLayoutElement(editorSaveButton.Component.gameObject, minHeight: 25, flexibleWidth: 9999);
            editorSaveButton.OnClick += EditorInputSave;

            ButtonRef editorDoneButton = UIFactory.CreateButton(editorButtonRow, "DoneButton", "Cancel and Return", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(editorDoneButton.Component.gameObject, minHeight: 25, flexibleWidth: 9999);
            editorDoneButton.OnClick += EditorInputCancel;

            int fontSize = 16;
            GameObject inputObj = UIFactory.CreateScrollInputField(EditorRoot, "EditorInput", "", out InputFieldScroller inputScroller, fontSize);
            EditorInputScroller = inputScroller;
            EditorInput.OnValueChanged += OnEditorInputChanged;

            EditorInputText = EditorInput.Component.textComponent;
            EditorInputText.supportRichText = false;
            EditorInputText.color = Color.clear;
            EditorInput.Component.customCaretColor = true;
            EditorInput.Component.caretColor = Color.white;
            EditorInput.PlaceholderText.fontSize = fontSize;

            // Lexer highlight text overlay
            GameObject highlightTextObj = UIFactory.CreateUIObject("HighlightText", EditorInputText.gameObject);
            RectTransform highlightTextRect = highlightTextObj.GetComponent<RectTransform>();
            highlightTextRect.pivot = new Vector2(0, 1);
            highlightTextRect.anchorMin = Vector2.zero;
            highlightTextRect.anchorMax = Vector2.one;
            highlightTextRect.offsetMin = Vector2.zero;
            highlightTextRect.offsetMax = Vector2.zero;

            EditorHighlightText = highlightTextObj.AddComponent<Text>();
            EditorHighlightText.color = Color.white;
            EditorHighlightText.supportRichText = true;
            EditorHighlightText.fontSize = fontSize;

            // Set fonts
            EditorInputText.font = UniversalUI.ConsoleFont;
            EditorInput.PlaceholderText.font = UniversalUI.ConsoleFont;
            EditorHighlightText.font = UniversalUI.ConsoleFont;
        }
    }
}

```

`src/Hooks/HookInstance.cs`:

```cs
using HarmonyLib;
using Mono.CSharp;
using System.Text;
using UnityExplorer.CSConsole;

namespace UnityExplorer.Hooks
{
    public class HookInstance
    {
        // Static 

        static readonly StringBuilder evaluatorOutput;
        static readonly ScriptEvaluator scriptEvaluator = new(new StringWriter(evaluatorOutput = new StringBuilder()));

        static HookInstance()
        {
            scriptEvaluator.Run("using System;");
            scriptEvaluator.Run("using System.Text;");
            scriptEvaluator.Run("using System.Reflection;");
            scriptEvaluator.Run("using System.Collections;");
            scriptEvaluator.Run("using System.Collections.Generic;");
        }

        // Instance

        public bool Enabled;

        public MethodInfo TargetMethod;
        public string PatchSourceCode;

        readonly string signature;
        PatchProcessor patchProcessor;

        MethodInfo postfix;
        MethodInfo prefix;
        MethodInfo finalizer;
        MethodInfo transpiler;

        public HookInstance(MethodInfo targetMethod)
        {
            this.TargetMethod = targetMethod;
            this.signature = TargetMethod.FullDescription();

            GenerateDefaultPatchSourceCode(targetMethod);

            if (CompileAndGenerateProcessor(PatchSourceCode))
                Patch();
        }

        // Evaluator.source_file 
        private static readonly FieldInfo fi_sourceFile = AccessTools.Field(typeof(Evaluator), "source_file");
        // TypeDefinition.Definition
        private static readonly PropertyInfo pi_Definition = AccessTools.Property(typeof(TypeDefinition), "Definition");

        public bool CompileAndGenerateProcessor(string patchSource)
        {
            Unpatch();

            StringBuilder codeBuilder = new();

            try
            {
                patchProcessor = ExplorerCore.Harmony.CreateProcessor(TargetMethod);

                // Dynamically compile the patch method

                codeBuilder.AppendLine($"static class DynamicPatch_{DateTime.Now.Ticks}");
                codeBuilder.AppendLine("{");
                codeBuilder.AppendLine(patchSource);
                codeBuilder.AppendLine("}");

                scriptEvaluator.Run(codeBuilder.ToString());

                if (ScriptEvaluator._reportPrinter.ErrorsCount > 0)
                    throw new FormatException($"Unable to compile the generated patch!");

                // TODO: Publicize MCS to avoid this reflection
                // Get the most recent Patch type in the source file
                TypeContainer typeContainer = ((CompilationSourceFile)fi_sourceFile.GetValue(scriptEvaluator))
                    .Containers
                    .Last(it => it.MemberName.Name.StartsWith("DynamicPatch_"));
                // Get the TypeSpec from the TypeDefinition, then get its "MetaInfo" (System.Type)
                Type patchClass = ((TypeSpec)pi_Definition.GetValue((Class)typeContainer, null)).GetMetaInfo();

                // Create the harmony patches as defined

                postfix = patchClass.GetMethod("Postfix", ReflectionUtility.FLAGS);
                if (postfix != null)
                    patchProcessor.AddPostfix(new HarmonyMethod(postfix));

                prefix = patchClass.GetMethod("Prefix", ReflectionUtility.FLAGS);
                if (prefix != null)
                    patchProcessor.AddPrefix(new HarmonyMethod(prefix));

                finalizer = patchClass.GetMethod("Finalizer", ReflectionUtility.FLAGS);
                if (finalizer != null)
                    patchProcessor.AddFinalizer(new HarmonyMethod(finalizer));

                transpiler = patchClass.GetMethod("Transpiler", ReflectionUtility.FLAGS);
                if (transpiler != null)
                    patchProcessor.AddTranspiler(new HarmonyMethod(transpiler));

                return true;
            }
            catch (Exception ex)
            {
                if (ex is FormatException)
                {
                    string output = scriptEvaluator._textWriter.ToString();
                    string[] outputSplit = output.Split('\n');
                    if (outputSplit.Length >= 2)
                        output = outputSplit[outputSplit.Length - 2];
                    evaluatorOutput.Clear();

                    if (ScriptEvaluator._reportPrinter.ErrorsCount > 0)
                        ExplorerCore.LogWarning($"Unable to compile the code. Evaluator's last output was:\r\n{output}");
                    else
                        ExplorerCore.LogWarning($"Exception generating patch source code: {ex}");
                }
                else
                    ExplorerCore.LogWarning($"Exception generating patch source code: {ex}");

                // ExplorerCore.Log(codeBuilder.ToString());

                return false;
            }
        }

        static string FullDescriptionClean(Type type)
        {
            string description = type.FullDescription().Replace("+", ".");
            if (description.EndsWith("&"))
                description = $"ref {description.Substring(0, description.Length - 1)}";
            return description;
        }

        private string GenerateDefaultPatchSourceCode(MethodInfo targetMethod)
        {
            StringBuilder codeBuilder = new();

            codeBuilder.Append("static void Postfix(");

            bool isStatic = targetMethod.IsStatic;

            List<string> arguments = new();

            if (!isStatic)
                arguments.Add($"{FullDescriptionClean(targetMethod.DeclaringType)} __instance");

            if (targetMethod.ReturnType != typeof(void))
                arguments.Add($"{FullDescriptionClean(targetMethod.ReturnType)} __result");

            ParameterInfo[] parameters = targetMethod.GetParameters();

            int paramIdx = 0;
            foreach (ParameterInfo param in parameters)
            {
                arguments.Add($"{FullDescriptionClean(param.ParameterType)} __{paramIdx}");
                paramIdx++;
            }

            codeBuilder.Append(string.Join(", ", arguments.ToArray()));

            codeBuilder.Append(")\n");

            // Patch body

            codeBuilder.AppendLine("{");
            codeBuilder.AppendLine("    try {");
            codeBuilder.AppendLine("       StringBuilder sb = new StringBuilder();");
            codeBuilder.AppendLine($"       sb.AppendLine(\"--------------------\");");
            codeBuilder.AppendLine($"       sb.AppendLine(\"{signature}\");");

            if (!targetMethod.IsStatic)
                codeBuilder.AppendLine($"       sb.Append(\"- __instance: \").AppendLine(__instance.ToString());");

            paramIdx = 0;
            foreach (ParameterInfo param in parameters)
            {
                codeBuilder.Append($"       sb.Append(\"- Parameter {paramIdx} '{param.Name}': \")");

                Type pType = param.ParameterType;
                if (pType.IsByRef) pType = pType.GetElementType();
                if (pType.IsValueType)
                    codeBuilder.AppendLine($".AppendLine(__{paramIdx}.ToString());");
                else
                    codeBuilder.AppendLine($".AppendLine(__{paramIdx}?.ToString() ?? \"null\");");

                paramIdx++;
            }

            if (targetMethod.ReturnType != typeof(void))
            {
                codeBuilder.Append("       sb.Append(\"- Return value: \")");
                if (targetMethod.ReturnType.IsValueType)
                    codeBuilder.AppendLine(".AppendLine(__result.ToString());");
                else
                    codeBuilder.AppendLine(".AppendLine(__result?.ToString() ?? \"null\");");
            }

            codeBuilder.AppendLine($"       UnityExplorer.ExplorerCore.Log(sb.ToString());");
            codeBuilder.AppendLine("    }");
            codeBuilder.AppendLine("    catch (System.Exception ex) {");
            codeBuilder.AppendLine($"        UnityExplorer.ExplorerCore.LogWarning($\"Exception in patch of {signature}:\\n{{ex}}\");");
            codeBuilder.AppendLine("    }");

            codeBuilder.AppendLine("}");

            return PatchSourceCode = codeBuilder.ToString();
        }

        public void TogglePatch()
        {
            if (!Enabled)
                Patch();
            else
                Unpatch();
        }

        public void Patch()
        {
            try
            {
                patchProcessor.Patch();

                Enabled = true;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception hooking method!\r\n{ex}");
            }
        }

        public void Unpatch()
        {
            try
            {
                if (prefix != null)
                    patchProcessor.Unpatch(prefix);
                if (postfix != null)
                    patchProcessor.Unpatch(postfix);
                if (finalizer != null)
                    patchProcessor.Unpatch(finalizer);
                if (transpiler != null)
                    patchProcessor.Unpatch(transpiler);

                Enabled = false;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception unpatching method: {ex}");
            }
        }
    }
}

```

`src/Hooks/HookList.cs`:

```cs
using HarmonyLib;
using System.Collections.Specialized;
using UnityExplorer.UI.Panels;
using UniverseLib.UI;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.Hooks
{
    public class HookList : ICellPoolDataSource<HookCell>
    {
        public int ItemCount => currentHooks.Count;
        
        internal static readonly HashSet<string> hookedSignatures = new();
        internal static readonly OrderedDictionary currentHooks = new();

        internal static GameObject UIRoot;
        internal static ScrollPool<HookCell> HooksScrollPool;

        public static void EnableOrDisableHookClicked(int index)
        {
            HookInstance hook = (HookInstance)currentHooks[index];
            hook.TogglePatch();

            HooksScrollPool.Refresh(true, false);
        }

        public static void DeleteHookClicked(int index)
        {
            HookInstance hook = (HookInstance)currentHooks[index];

            if (HookCreator.CurrentEditedHook == hook)
                HookCreator.EditorInputCancel();

            hook.Unpatch();
            currentHooks.RemoveAt(index);
            hookedSignatures.Remove(hook.TargetMethod.FullDescription());

            HooksScrollPool.Refresh(true, false);
        }

        public static void EditPatchClicked(int index)
        {
            if (HookCreator.PendingGeneric)
                HookManagerPanel.genericArgsHandler.Cancel();

            HookManagerPanel.Instance.SetPage(HookManagerPanel.Pages.HookSourceEditor);
            HookInstance hook = (HookInstance)currentHooks[index];
            HookCreator.SetEditedHook(hook);
        }

        // Set current hook cell

        public void OnCellBorrowed(HookCell cell) { }

        public void SetCell(HookCell cell, int index)
        {
            if (index >= currentHooks.Count)
            {
                cell.Disable();
                return;
            }

            cell.CurrentDisplayedIndex = index;
            HookInstance hook = (HookInstance)currentHooks[index];

            cell.MethodNameLabel.text = SignatureHighlighter.ParseMethod(hook.TargetMethod);

            cell.ToggleActiveButton.ButtonText.text = hook.Enabled ? "On" : "Off";
            RuntimeHelper.SetColorBlockAuto(cell.ToggleActiveButton.Component,
                hook.Enabled ? new Color(0.15f, 0.2f, 0.15f) : new Color(0.2f, 0.2f, 0.15f));
        }

        // UI

        internal void ConstructUI(GameObject leftGroup)
        {
            UIRoot = UIFactory.CreateUIObject("CurrentHooksPanel", leftGroup);
            UIFactory.SetLayoutElement(UIRoot, preferredHeight: 150, flexibleHeight: 0, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(UIRoot, true, true, true, true);

            Text hooksLabel = UIFactory.CreateLabel(UIRoot, "HooksLabel", "Current Hooks", TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(hooksLabel.gameObject, minHeight: 30, flexibleWidth: 9999);

            HooksScrollPool = UIFactory.CreateScrollPool<HookCell>(UIRoot, "HooksScrollPool",
                out GameObject hooksScroll, out GameObject hooksContent);
            UIFactory.SetLayoutElement(hooksScroll, flexibleHeight: 9999);
            HooksScrollPool.Initialize(this);
        }
    }
}

```

`src/Inspectors/GameObjectInspector.cs`:

```cs
using System.Collections;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.Inspectors
{
    public class GameObjectInspector : InspectorBase
    {
        public new GameObject Target => base.Target as GameObject;

        public GameObject Content;

        public GameObjectControls Controls;

        public TransformTree TransformTree;
        private ScrollPool<TransformCell> transformScroll;
        private readonly List<GameObject> cachedChildren = new();

        public ComponentList ComponentList;
        private ScrollPool<ComponentCell> componentScroll;

        private InputFieldRef addChildInput;
        private InputFieldRef addCompInput;

        public override void OnBorrowedFromPool(object target)
        {
            base.OnBorrowedFromPool(target);

            base.Target = target as GameObject;

            Controls.UpdateGameObjectInfo(true, true);
            Controls.TransformControl.UpdateTransformControlValues(true);

            RuntimeHelper.StartCoroutine(InitCoroutine());
        }

        private IEnumerator InitCoroutine()
        {
            yield return null;

            LayoutRebuilder.ForceRebuildLayoutImmediate(InspectorPanel.Instance.ContentRect);

            TransformTree.Rebuild();

            ComponentList.ScrollPool.Refresh(true, true);
            UpdateComponents();
        }

        public override void OnReturnToPool()
        {
            base.OnReturnToPool();

            addChildInput.Text = "";
            addCompInput.Text = "";

            TransformTree.Clear();
            UpdateComponents();
        }

        public override void CloseInspector()
        {
            InspectorManager.ReleaseInspector(this);
        }

        public void OnTransformCellClicked(GameObject newTarget)
        {
            base.Target = newTarget;
            Controls.UpdateGameObjectInfo(true, true);
            Controls.TransformControl.UpdateTransformControlValues(true);
            TransformTree.RefreshData(true, false, true, false);
            UpdateComponents();
        }

        private float timeOfLastUpdate;

        public override void Update()
        {
            if (!this.IsActive)
                return;

            if (base.Target.IsNullOrDestroyed(false))
            {
                InspectorManager.ReleaseInspector(this);
                return;
            }

            Controls.UpdateVectorSlider();
            Controls.TransformControl.UpdateTransformControlValues(false);

            // Slow update
            if (timeOfLastUpdate.OccuredEarlierThan(1))
            {
                timeOfLastUpdate = Time.realtimeSinceStartup;

                Controls.UpdateGameObjectInfo(false, false);

                TransformTree.RefreshData(true, false, false, false);
                UpdateComponents();
            }
        }

        // Child and Component Lists

        private IEnumerable<GameObject> GetTransformEntries()
        {
            if (!Target)
                return Enumerable.Empty<GameObject>();

            cachedChildren.Clear();
            for (int i = 0; i < Target.transform.childCount; i++)
                cachedChildren.Add(Target.transform.GetChild(i).gameObject);
            return cachedChildren;
        }

        private readonly List<Component> componentEntries = new();
        private readonly HashSet<int> compInstanceIDs = new();
        private readonly List<Behaviour> behaviourEntries = new();
        private readonly List<bool> behaviourEnabledStates = new();

        // ComponentList.GetRootEntriesMethod
        private List<Component> GetComponentEntries() => Target ? componentEntries : Enumerable.Empty<Component>().ToList();

        public void UpdateComponents()
        {
            if (!Target)
            {
                componentEntries.Clear();
                compInstanceIDs.Clear();
                behaviourEntries.Clear();
                behaviourEnabledStates.Clear();
                ComponentList.RefreshData();
                ComponentList.ScrollPool.Refresh(true, true);
                return;
            }

            // Check if we actually need to refresh the component cells or not.
            IEnumerable<Component> comps = Target.GetComponents<Component>();
            IEnumerable<Behaviour> behaviours = Target.GetComponents<Behaviour>();

            bool needRefresh = false;

            int count = 0;
            foreach (Component comp in comps)
            {
                if (!comp)
                    continue;
                count++;
                if (!compInstanceIDs.Contains(comp.GetInstanceID()))
                {
                    needRefresh = true;
                    break;
                }
            }
            if (!needRefresh)
            {
                if (count != componentEntries.Count)
                    needRefresh = true;
                else
                {
                    count = 0;
                    foreach (Behaviour behaviour in behaviours)
                    {
                        if (!behaviour)
                            continue;
                        if (count >= behaviourEnabledStates.Count || behaviour.enabled != behaviourEnabledStates[count])
                        {
                            needRefresh = true;
                            break;
                        }
                        count++;
                    }
                    if (!needRefresh && count != behaviourEntries.Count)
                        needRefresh = true;
                }
            }

            if (!needRefresh)
                return;

            componentEntries.Clear();
            compInstanceIDs.Clear();
            foreach (Component comp in comps)
            {
                if (!comp) 
                    continue;
                componentEntries.Add(comp);
                compInstanceIDs.Add(comp.GetInstanceID());
            }

            behaviourEntries.Clear();
            behaviourEnabledStates.Clear();
            foreach (Behaviour behaviour in behaviours)
            {
                if (!behaviour) 
                    continue;

                // Don't ask me how, but in some games this can be true for certain components.
                // They get picked up from GetComponents<Behaviour>, but they are not actually Behaviour...?
                if (!typeof(Behaviour).IsAssignableFrom(behaviour.GetType()))
                    continue;

                try
                {
                    behaviourEntries.Add(behaviour);
                }
                catch (Exception ex)
                {
                    ExplorerCore.LogWarning(ex);
                }

                behaviourEnabledStates.Add(behaviour.enabled);
            }

            ComponentList.RefreshData();
            ComponentList.ScrollPool.Refresh(true);
        }


        private void OnAddChildClicked(string input)
        {
            GameObject newObject = new(input);
            newObject.transform.parent = Target.transform;

            TransformTree.RefreshData(true, false, true, false);
        }

        private void OnAddComponentClicked(string input)
        {
            if (ReflectionUtility.GetTypeByName(input) is Type type)
            {
                try
                {
                    RuntimeHelper.AddComponent<Component>(Target, type);
                    UpdateComponents();
                }
                catch (Exception ex)
                {
                    ExplorerCore.LogWarning($"Exception adding component: {ex.ReflectionExToString()}");
                }
            }
            else
            {
                ExplorerCore.LogWarning($"Could not find any Type by the name '{input}'!");
            }
        }

        #region UI Construction

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "GameObjectInspector", true, false, true, true, 5,
                new Vector4(4, 4, 4, 4), new Color(0.065f, 0.065f, 0.065f));

            GameObject scrollObj = UIFactory.CreateScrollView(UIRoot, "GameObjectInspector", out Content, out AutoSliderScrollbar scrollbar,
                new Color(0.065f, 0.065f, 0.065f));
            UIFactory.SetLayoutElement(scrollObj, minHeight: 250, preferredHeight: 300, flexibleHeight: 0, flexibleWidth: 9999);

            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(Content, spacing: 3, padTop: 2, padBottom: 2, padLeft: 2, padRight: 2);

            // Construct GO Controls
            Controls = new GameObjectControls(this);

            ConstructLists();

            return UIRoot;
        }

        // Child and Comp Lists

        private void ConstructLists()
        {
            GameObject listHolder = UIFactory.CreateUIObject("ListHolders", UIRoot);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(listHolder, false, true, true, true, 8, 2, 2, 2, 2);
            UIFactory.SetLayoutElement(listHolder, minHeight: 150, flexibleWidth: 9999, flexibleHeight: 9999);

            // Left group (Children)

            GameObject leftGroup = UIFactory.CreateUIObject("ChildrenGroup", listHolder);
            UIFactory.SetLayoutElement(leftGroup, flexibleWidth: 9999, flexibleHeight: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(leftGroup, false, false, true, true, 2);

            Text childrenLabel = UIFactory.CreateLabel(leftGroup, "ChildListTitle", "Children", TextAnchor.MiddleCenter, default, false, 16);
            UIFactory.SetLayoutElement(childrenLabel.gameObject, flexibleWidth: 9999);

            // Add Child
            GameObject addChildRow = UIFactory.CreateUIObject("AddChildRow", leftGroup);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(addChildRow, false, false, true, true, 2);

            addChildInput = UIFactory.CreateInputField(addChildRow, "AddChildInput", "Enter a name...");
            UIFactory.SetLayoutElement(addChildInput.Component.gameObject, minHeight: 25, preferredWidth: 9999);

            ButtonRef addChildButton = UIFactory.CreateButton(addChildRow, "AddChildButton", "Add Child");
            UIFactory.SetLayoutElement(addChildButton.Component.gameObject, minHeight: 25, minWidth: 80);
            addChildButton.OnClick += () => { OnAddChildClicked(addChildInput.Text); };

            // TransformTree

            transformScroll = UIFactory.CreateScrollPool<TransformCell>(leftGroup, "TransformTree", out GameObject transformObj,
                out GameObject transformContent, new Color(0.11f, 0.11f, 0.11f));

            TransformTree = new TransformTree(transformScroll, GetTransformEntries, OnTransformCellClicked);

            // Right group (Components)

            GameObject rightGroup = UIFactory.CreateUIObject("ComponentGroup", listHolder);
            UIFactory.SetLayoutElement(rightGroup, flexibleWidth: 9999, flexibleHeight: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(rightGroup, false, false, true, true, 2);

            Text compLabel = UIFactory.CreateLabel(rightGroup, "CompListTitle", "Components", TextAnchor.MiddleCenter, default, false, 16);
            UIFactory.SetLayoutElement(compLabel.gameObject, flexibleWidth: 9999);

            // Add Comp
            GameObject addCompRow = UIFactory.CreateUIObject("AddCompRow", rightGroup);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(addCompRow, false, false, true, true, 2);

            addCompInput = UIFactory.CreateInputField(addCompRow, "AddCompInput", "Enter a Component type...");
            UIFactory.SetLayoutElement(addCompInput.Component.gameObject, minHeight: 25, preferredWidth: 9999);

            ButtonRef addCompButton = UIFactory.CreateButton(addCompRow, "AddCompButton", "Add Comp");
            UIFactory.SetLayoutElement(addCompButton.Component.gameObject, minHeight: 25, minWidth: 80);
            addCompButton.OnClick += () => { OnAddComponentClicked(addCompInput.Text); };

            // comp autocompleter
            new TypeCompleter(typeof(Component), addCompInput, false, false, false);

            // Component List

            componentScroll = UIFactory.CreateScrollPool<ComponentCell>(rightGroup, "ComponentList", out GameObject compObj,
                out GameObject compContent, new Color(0.11f, 0.11f, 0.11f));
            UIFactory.SetLayoutElement(compObj, flexibleHeight: 9999);
            UIFactory.SetLayoutElement(compContent, flexibleHeight: 9999);

            ComponentList = new ComponentList(componentScroll, GetComponentEntries)
            {
                Parent = this
            };
            componentScroll.Initialize(ComponentList);
        }


        #endregion
    }
}

```

`src/Inspectors/InspectorBase.cs`:

```cs
using UnityExplorer.UI.Panels;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.Inspectors
{
    public abstract class InspectorBase : IPooledObject
    {
        public bool IsActive { get; internal set; }
        public object Target { get; set; }
        public Type TargetType { get; protected set; }

        public InspectorTab Tab { get; internal set; }

        public GameObject UIRoot { get; set; }

        public float DefaultHeight => -1f;
        public abstract GameObject CreateContent(GameObject parent);

        public abstract void Update();

        public abstract void CloseInspector();

        public virtual void OnBorrowedFromPool(object target)
        {
            this.Target = target;
            this.TargetType = target is Type type ? type : target.GetActualType();

            Tab = Pool<InspectorTab>.Borrow();
            Tab.UIRoot.transform.SetParent(InspectorPanel.Instance.NavbarHolder.transform, false);

            Tab.TabButton.OnClick += OnTabButtonClicked;
            Tab.CloseButton.OnClick += CloseInspector;
        }

        public virtual void OnReturnToPool()
        {
            Pool<InspectorTab>.Return(Tab);

            this.Target = null;

            Tab.TabButton.OnClick -= OnTabButtonClicked;
            Tab.CloseButton.OnClick -= CloseInspector;
        }

        public virtual void OnSetActive()
        {
            Tab.SetTabColor(true);
            UIRoot.SetActive(true);
            IsActive = true;
            LayoutRebuilder.ForceRebuildLayoutImmediate(UIRoot.GetComponent<RectTransform>());
        }

        public virtual void OnSetInactive()
        {
            Tab.SetTabColor(false);
            UIRoot.SetActive(false);
            IsActive = false;
        }

        private void OnTabButtonClicked()
        {
            InspectorManager.SetInspectorActive(this);
        }
    }
}

```

`src/Inspectors/InspectorManager.cs`:

```cs
using UnityExplorer.CacheObject;
using UnityExplorer.Inspectors;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer
{
    public static class InspectorManager
    {
        public static readonly List<InspectorBase> Inspectors = new();

        public static InspectorBase ActiveInspector { get; private set; }
        private static InspectorBase lastActiveInspector;

        public static float PanelWidth;

        public static event Action OnInspectedTabsChanged;

        public static void Inspect(object obj, CacheObjectBase parent = null)
        {
            if (obj.IsNullOrDestroyed())
                return;

            obj = obj.TryCast();

            if (TryFocusActiveInspector(obj))
                return;

            if (obj is GameObject)
                CreateInspector<GameObjectInspector>(obj);
            else
                CreateInspector<ReflectionInspector>(obj, false, parent);
        }

        public static void Inspect(Type type)
        {
            if (TryFocusActiveInspector(type))
                return;

            CreateInspector<ReflectionInspector>(type, true);
        }

        static bool TryFocusActiveInspector(object target)
        {
            foreach (InspectorBase inspector in Inspectors)
            {
                bool shouldFocus = false;

                if (target is Type targetAsType)
                {
                    if (inspector.TargetType.FullName == targetAsType.FullName)
                        shouldFocus = true;
                }
                else if(inspector.Target.ReferenceEqual(target))
                {
                    shouldFocus = true;
                }

                if (shouldFocus)
                {
                    UIManager.SetPanelActive(UIManager.Panels.Inspector, true);
                    SetInspectorActive(inspector);
                    return true;
                }
            }
            return false;
        }

        public static void SetInspectorActive(InspectorBase inspector)
        {
            UnsetActiveInspector();

            ActiveInspector = inspector;
            inspector.OnSetActive();
        }

        public static void UnsetActiveInspector()
        {
            if (ActiveInspector != null)
            {
                lastActiveInspector = ActiveInspector;
                ActiveInspector.OnSetInactive();
                ActiveInspector = null;
            }
        }

        public static void CloseAllTabs()
        {
            if (Inspectors.Any())
            {
                for (int i = Inspectors.Count - 1; i >= 0; i--)
                    Inspectors[i].CloseInspector();

                Inspectors.Clear();
            }

            UIManager.SetPanelActive(UIManager.Panels.Inspector, false);
        }

        static void CreateInspector<T>(object target, bool staticReflection = false, CacheObjectBase parent = null) where T : InspectorBase
        {
            T inspector = Pool<T>.Borrow();
            Inspectors.Add(inspector);
            inspector.Target = target;

            if (parent != null && parent.CanWrite)
            {
                // only set parent cache object if we are inspecting a struct, otherwise there is no point.
                if (target.GetType().IsValueType && inspector is ReflectionInspector ri)
                    ri.ParentCacheObject = parent;
            }

            UIManager.SetPanelActive(UIManager.Panels.Inspector, true);
            inspector.UIRoot.transform.SetParent(InspectorPanel.Instance.ContentHolder.transform, false);

            if (inspector is ReflectionInspector reflectInspector)
                reflectInspector.StaticOnly = staticReflection;

            inspector.OnBorrowedFromPool(target);
            SetInspectorActive(inspector);

            OnInspectedTabsChanged?.Invoke();
        }

        public static void ReleaseInspector<T>(T inspector) where T : InspectorBase
        {
            if (lastActiveInspector == inspector)
                lastActiveInspector = null;

            bool wasActive = ActiveInspector == inspector;
            int wasIdx = Inspectors.IndexOf(inspector);

            Inspectors.Remove(inspector);
            inspector.OnReturnToPool();
            Pool<T>.Return(inspector);

            if (wasActive)
            {
                ActiveInspector = null;
                // Try focus another inspector, or close the window.
                if (lastActiveInspector != null)
                {
                    SetInspectorActive(lastActiveInspector);
                    lastActiveInspector = null;
                }
                else if (Inspectors.Any())
                {
                    int newIdx = Math.Min(Inspectors.Count - 1, Math.Max(0, wasIdx - 1));
                    SetInspectorActive(Inspectors[newIdx]);
                }
                else
                {
                    UIManager.SetPanelActive(UIManager.Panels.Inspector, false);
                }
            }

            OnInspectedTabsChanged?.Invoke();
        }

        internal static void Update()
        {
            for (int i = Inspectors.Count - 1; i >= 0; i--)
                Inspectors[i].Update();
        }

        internal static void OnPanelResized(float width)
        {
            PanelWidth = width;

            foreach (InspectorBase obj in Inspectors)
            {
                if (obj is ReflectionInspector inspector)
                {
                    inspector.SetLayouts();
                }
            }
        }
    }
}

```

`src/Inspectors/InspectorTab.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.Inspectors
{
    public class InspectorTab : IPooledObject
    {
        public GameObject UIRoot { get; set; }
        public float DefaultHeight => 25f;

        public ButtonRef TabButton;
        public Text TabText;
        public ButtonRef CloseButton;

        private static readonly Color enabledTabColor = new(0.15f, 0.22f, 0.15f);
        private static readonly Color disabledTabColor = new(0.13f, 0.13f, 0.13f);

        public void SetTabColor(bool active)
        {
            Color color = active ? enabledTabColor : disabledTabColor;
            RuntimeHelper.SetColorBlock(TabButton.Component, color, color * 1.2f);
        }

        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateHorizontalGroup(parent, "TabObject", false, true, true, true, 1,
                default, new Color(0.13f, 0.13f, 0.13f), childAlignment: TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 200, flexibleWidth: 0);
            UIRoot.AddComponent<Mask>();
            UIRoot.AddComponent<Outline>();

            TabButton = UIFactory.CreateButton(UIRoot, "TabButton", "");
            UIFactory.SetLayoutElement(TabButton.Component.gameObject, minWidth: 173, flexibleWidth: 0);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(TabButton.Component.gameObject, false, false, true, true, 0, 0, 0, 3);
            TabButton.GameObject.AddComponent<Mask>();

            TabText = TabButton.ButtonText;
            UIFactory.SetLayoutElement(TabText.gameObject, minHeight: 25, minWidth: 150, flexibleWidth: 0);
            TabText.alignment = TextAnchor.MiddleLeft;
            TabText.fontSize = 12;
            TabText.horizontalOverflow = HorizontalWrapMode.Overflow;

            CloseButton = UIFactory.CreateButton(UIRoot, "CloseButton", "X", new Color(0.15f, 0.15f, 0.15f, 1));
            UIFactory.SetLayoutElement(CloseButton.Component.gameObject, minHeight: 25, minWidth: 25, flexibleWidth: 0);
            CloseButton.ButtonText.color = Color.red;

            return UIRoot;
        }
    }
}

```

`src/Inspectors/MouseInspector.cs`:

```cs
using UnityExplorer.Config;
using UnityExplorer.Inspectors.MouseInspectors;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UniverseLib.Input;
using UniverseLib.UI;
using UniverseLib.UI.Panels;

namespace UnityExplorer.Inspectors
{
    public enum MouseInspectMode
    {
        World,
        UI
    }

    public class MouseInspector : PanelBase
    {
        public static MouseInspector Instance { get; private set; }

        private readonly WorldInspector worldInspector;
        private readonly UiInspector uiInspector;

        public static bool Inspecting { get; set; }
        public static MouseInspectMode Mode { get; set; }

        public MouseInspectorBase CurrentInspector => Mode switch
        {
            MouseInspectMode.UI => uiInspector,
            MouseInspectMode.World => worldInspector,
            _ => null,
        };

        private static Vector3 lastMousePos;

        // UIPanel
        internal static readonly string UIBaseGUID = $"{ExplorerCore.GUID}.MouseInspector";
        internal static UIBase inspectorUIBase;

        public override string Name => "Inspect Under Mouse";
        public override int MinWidth => -1;
        public override int MinHeight => -1;
        public override Vector2 DefaultAnchorMin => Vector2.zero;
        public override Vector2 DefaultAnchorMax => Vector2.zero;

        public override bool CanDragAndResize => false;

        internal Text objNameLabel;
        internal Text objPathLabel;
        internal Text mousePosLabel;

        public MouseInspector(UIBase owner) : base(owner)
        {
            Instance = this;
            worldInspector = new WorldInspector();
            uiInspector = new UiInspector();
        }

        public static void OnDropdownSelect(int index)
        {
            switch (index)
            {
                case 0: return;
                case 1: Instance.StartInspect(MouseInspectMode.World); break;
                case 2: Instance.StartInspect(MouseInspectMode.UI); break;
            }
            InspectorPanel.Instance.MouseInspectDropdown.value = 0;
        }

        public void StartInspect(MouseInspectMode mode)
        {
            Mode = mode;
            Inspecting = true;

            CurrentInspector.OnBeginMouseInspect();

            PanelManager.ForceEndResize();
            UIManager.NavBarRect.gameObject.SetActive(false);
            UIManager.UiBase.Panels.PanelHolder.SetActive(false);
            UIManager.UiBase.SetOnTop();

            SetActive(true);
        }

        internal void ClearHitData()
        {
            CurrentInspector.ClearHitData();

            objNameLabel.text = "No hits...";
            objPathLabel.text = "";
        }

        public void StopInspect()
        {
            CurrentInspector.OnEndInspect();
            ClearHitData();
            Inspecting = false;

            UIManager.NavBarRect.gameObject.SetActive(true);
            UIManager.UiBase.Panels.PanelHolder.SetActive(true);

            Dropdown drop = InspectorPanel.Instance.MouseInspectDropdown;
            if (drop.transform.Find("Dropdown List") is Transform list)
                drop.DestroyDropdownList(list.gameObject);

            UIRoot.SetActive(false);
        }

        private static float timeOfLastRaycast;

        public bool TryUpdate()
        {
            if (InputManager.GetKeyDown(ConfigManager.World_MouseInspect_Keybind.Value))
                Instance.StartInspect(MouseInspectMode.World);

            if (InputManager.GetKeyDown(ConfigManager.UI_MouseInspect_Keybind.Value))
                Instance.StartInspect(MouseInspectMode.UI);

            if (Inspecting)
                UpdateInspect();

            return Inspecting;
        }

        public void UpdateInspect()
        {
            if (InputManager.GetKeyDown(KeyCode.Escape))
            {
                StopInspect();
                return;
            }

            if (InputManager.GetMouseButtonDown(0))
            {
                CurrentInspector.OnSelectMouseInspect();
                StopInspect();
                return;
            }

            Vector3 mousePos = InputManager.MousePosition;
            if (mousePos != lastMousePos)
                UpdatePosition(mousePos);

            if (!timeOfLastRaycast.OccuredEarlierThan(0.1f))
                return;
            timeOfLastRaycast = Time.realtimeSinceStartup;

            CurrentInspector.UpdateMouseInspect(mousePos);
        }

        internal void UpdatePosition(Vector2 mousePos)
        {
            lastMousePos = mousePos;

            // use the raw mouse pos for the label
            mousePosLabel.text = $"<color=grey>Mouse Position:</color> {mousePos.ToString()}";

            // constrain the mouse pos we use within certain bounds
            if (mousePos.x < 350)
                mousePos.x = 350;
            if (mousePos.x > Screen.width - 350)
                mousePos.x = Screen.width - 350;
            if (mousePos.y < Rect.rect.height)
                mousePos.y += Rect.rect.height + 10;
            else
                mousePos.y -= 10;

            // calculate and set our UI position
            Vector3 inversePos = inspectorUIBase.RootObject.transform.InverseTransformPoint(mousePos);
            UIRoot.transform.localPosition = new Vector3(inversePos.x, inversePos.y, 0);
        }

        // UI Construction

        public override void SetDefaultSizeAndPosition()
        {
            base.SetDefaultSizeAndPosition();

            Rect.anchorMin = Vector2.zero;
            Rect.anchorMax = Vector2.zero;
            Rect.pivot = new Vector2(0.5f, 1);
            Rect.sizeDelta = new Vector2(700, 150);
        }

        protected override void ConstructPanelContent()
        {
            // hide title bar
            this.TitleBar.SetActive(false);
            this.UIRoot.transform.SetParent(UIManager.UIRoot.transform, false);

            GameObject inspectContent = UIFactory.CreateVerticalGroup(this.ContentRoot, "InspectContent", true, true, true, true, 3, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(inspectContent, flexibleWidth: 9999, flexibleHeight: 9999);

            // Title text

            Text title = UIFactory.CreateLabel(inspectContent,
                "InspectLabel",
                "<b>Mouse Inspector</b> (press <b>ESC</b> to cancel)",
                TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(title.gameObject, flexibleWidth: 9999);

            mousePosLabel = UIFactory.CreateLabel(inspectContent, "MousePosLabel", "Mouse Position:", TextAnchor.MiddleCenter);

            objNameLabel = UIFactory.CreateLabel(inspectContent, "HitLabelObj", "No hits...", TextAnchor.MiddleLeft);
            objNameLabel.horizontalOverflow = HorizontalWrapMode.Overflow;

            objPathLabel = UIFactory.CreateLabel(inspectContent, "PathLabel", "", TextAnchor.MiddleLeft);
            objPathLabel.fontStyle = FontStyle.Italic;
            objPathLabel.horizontalOverflow = HorizontalWrapMode.Wrap;

            UIFactory.SetLayoutElement(objPathLabel.gameObject, minHeight: 75);

            UIRoot.SetActive(false);

            //// Create a new canvas for this panel to live on.
            //// It needs to always be shown on the main display, other panels can move displays.
            //
            //UIRoot.transform.SetParent(inspectorUIBase.RootObject.transform);
        }
    }
}

```

`src/Inspectors/MouseInspectors/MouseInspectorBase.cs`:

```cs
namespace UnityExplorer.Inspectors.MouseInspectors
{
    public abstract class MouseInspectorBase
    {
        public abstract void OnBeginMouseInspect();

        public abstract void UpdateMouseInspect(Vector2 mousePos);

        public abstract void OnSelectMouseInspect();

        public abstract void ClearHitData();

        public abstract void OnEndInspect();
    }
}

```

`src/Inspectors/MouseInspectors/UiInspector.cs`:

```cs
using System.Collections;
using UnityEngine.EventSystems;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;

namespace UnityExplorer.Inspectors.MouseInspectors
{
    public class UiInspector : MouseInspectorBase
    {
        public static readonly List<GameObject> LastHitObjects = new();

        private static GraphicRaycaster[] graphicRaycasters;

        private static readonly List<GameObject> currentHitObjects = new();

        private static readonly List<Graphic> wasDisabledGraphics = new();
        private static readonly List<CanvasGroup> wasDisabledCanvasGroups = new();
        private static readonly List<GameObject> objectsAddedCastersTo = new();

        public override void OnBeginMouseInspect()
        {
            SetupUIRaycast();
            MouseInspector.Instance.objPathLabel.text = "";
        }

        public override void ClearHitData()
        {
            currentHitObjects.Clear();
        }

        public override void OnSelectMouseInspect()
        {
            LastHitObjects.Clear();
            LastHitObjects.AddRange(currentHitObjects);
            RuntimeHelper.StartCoroutine(SetPanelActiveCoro());
        }

        IEnumerator SetPanelActiveCoro()
        {
            yield return null;
            MouseInspectorResultsPanel panel = UIManager.GetPanel<MouseInspectorResultsPanel>(UIManager.Panels.UIInspectorResults);
            panel.SetActive(true);
            panel.ShowResults();
        }

        public override void UpdateMouseInspect(Vector2 mousePos)
        {
            currentHitObjects.Clear();

            PointerEventData ped = new(null)
            {
                position = mousePos
            };

            foreach (GraphicRaycaster gr in graphicRaycasters)
            {
                if (!gr || !gr.canvas)
                    continue;

                List<RaycastResult> list = new();
                RuntimeHelper.GraphicRaycast(gr, ped, list);
                if (list.Count > 0)
                {
                    foreach (RaycastResult hit in list)
                    {
                        if (hit.gameObject)
                            currentHitObjects.Add(hit.gameObject);
                    }
                }
            }

            if (currentHitObjects.Any())
                MouseInspector.Instance.objNameLabel.text = $"Click to view UI Objects under mouse: {currentHitObjects.Count}";
            else
                MouseInspector.Instance.objNameLabel.text = $"No UI objects under mouse.";
        }

        private static void SetupUIRaycast()
        {
            foreach (UnityEngine.Object obj in RuntimeHelper.FindObjectsOfTypeAll(typeof(Canvas)))
            {
                Canvas canvas = obj.TryCast<Canvas>();
                if (!canvas || !canvas.enabled || !canvas.gameObject.activeInHierarchy)
                    continue;
                if (!canvas.GetComponent<GraphicRaycaster>())
                {
                    canvas.gameObject.AddComponent<GraphicRaycaster>();
                    //ExplorerCore.Log("Added raycaster to " + canvas.name);
                    objectsAddedCastersTo.Add(canvas.gameObject);
                }
            }

            // recache Graphic Raycasters each time we start
            UnityEngine.Object[] casters = RuntimeHelper.FindObjectsOfTypeAll(typeof(GraphicRaycaster));
            graphicRaycasters = new GraphicRaycaster[casters.Length];
            for (int i = 0; i < casters.Length; i++)
            {
                graphicRaycasters[i] = casters[i].TryCast<GraphicRaycaster>();
            }

            // enable raycastTarget on Graphics
            foreach (UnityEngine.Object obj in RuntimeHelper.FindObjectsOfTypeAll(typeof(Graphic)))
            {
                Graphic graphic = obj.TryCast<Graphic>();
                if (!graphic || !graphic.enabled || graphic.raycastTarget || !graphic.gameObject.activeInHierarchy)
                    continue;
                graphic.raycastTarget = true;
                //ExplorerCore.Log("Enabled raycastTarget on " + graphic.name);
                wasDisabledGraphics.Add(graphic);
            }

            // enable blocksRaycasts on CanvasGroups
            foreach (UnityEngine.Object obj in RuntimeHelper.FindObjectsOfTypeAll(typeof(CanvasGroup)))
            {
                CanvasGroup canvas = obj.TryCast<CanvasGroup>();
                if (!canvas || !canvas.gameObject.activeInHierarchy || canvas.blocksRaycasts)
                    continue;
                canvas.blocksRaycasts = true;
                //ExplorerCore.Log("Enabled raycasts on " + canvas.name);
                wasDisabledCanvasGroups.Add(canvas);
            }
        }

        public override void OnEndInspect()
        {
            foreach (GameObject obj in objectsAddedCastersTo)
            {
                if (obj.GetComponent<GraphicRaycaster>() is GraphicRaycaster raycaster)
                    GameObject.Destroy(raycaster);
            }

            foreach (Graphic graphic in wasDisabledGraphics)
                graphic.raycastTarget = false;

            foreach (CanvasGroup canvas in wasDisabledCanvasGroups)
                canvas.blocksRaycasts = false;

            objectsAddedCastersTo.Clear();
            wasDisabledCanvasGroups.Clear();
            wasDisabledGraphics.Clear();
        }
    }
}

```

`src/Inspectors/MouseInspectors/WorldInspector.cs`:

```cs
namespace UnityExplorer.Inspectors.MouseInspectors
{
    public class WorldInspector : MouseInspectorBase
    {
        private static Camera MainCamera;
        private static GameObject lastHitObject;

        public override void OnBeginMouseInspect()
        {
            MainCamera = Camera.main;

            if (!MainCamera)
            {
                ExplorerCore.LogWarning("No MainCamera found! Cannot inspect world!");
                return;
            }
        }

        public override void ClearHitData()
        {
            lastHitObject = null;
        }

        public override void OnSelectMouseInspect()
        {
            InspectorManager.Inspect(lastHitObject);
        }

        public override void UpdateMouseInspect(Vector2 mousePos)
        {
            if (!MainCamera)
                MainCamera = Camera.main;
            if (!MainCamera)
            {
                ExplorerCore.LogWarning("No Main Camera was found, unable to inspect world!");
                MouseInspector.Instance.StopInspect();
                return;
            }

            Ray ray = MainCamera.ScreenPointToRay(mousePos);
            Physics.Raycast(ray, out RaycastHit hit, 1000f);

            if (hit.transform)
                OnHitGameObject(hit.transform.gameObject);
            else if (lastHitObject)
                MouseInspector.Instance.ClearHitData();
        }

        internal void OnHitGameObject(GameObject obj)
        {
            if (obj != lastHitObject)
            {
                lastHitObject = obj;
                MouseInspector.Instance.objNameLabel.text = $"<b>Click to Inspect:</b> <color=cyan>{obj.name}</color>";
                MouseInspector.Instance.objPathLabel.text = $"Path: {obj.transform.GetTransformPath(true)}";
            }
        }

        public override void OnEndInspect()
        {
            // not needed
        }
    }
}

```

`src/Inspectors/ReflectionInspector.cs`:

```cs
using System.Collections;
using System.Diagnostics;
using System.Reflection.Emit;
using UnityExplorer.CacheObject;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.Config;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.Inspectors
{
    [Flags]
    public enum MemberFilter
    {
        None = 0,
        Property = 1,
        Field = 2,
        Constructor = 4,
        Method = 8,
        All = Property | Field | Method | Constructor,
    }

    public class ReflectionInspector : InspectorBase, ICellPoolDataSource<CacheMemberCell>, ICacheObjectController
    {
        public CacheObjectBase ParentCacheObject { get; set; }
        public bool StaticOnly { get; internal set; }
        public bool CanWrite => true;

        public bool AutoUpdateWanted => autoUpdateToggle.isOn;

        List<CacheMember> members = new();
        readonly List<CacheMember> filteredMembers = new();

        string nameFilter;
        BindingFlags scopeFlagsFilter;
        MemberFilter memberFilter = MemberFilter.All;

        // Updating

        bool refreshWanted;
        string lastNameFilter;
        BindingFlags lastFlagsFilter;
        MemberFilter lastMemberFilter = MemberFilter.All;
        float timeOfLastAutoUpdate;

        // UI

        static int LeftGroupWidth { get; set; }
        static int RightGroupWidth { get; set; }

        static readonly Color disabledButtonColor = new(0.24f, 0.24f, 0.24f);
        static readonly Color enabledButtonColor = new(0.2f, 0.27f, 0.2f);

        public GameObject ContentRoot { get; private set; }
        public ScrollPool<CacheMemberCell> MemberScrollPool { get; private set; }
        public int ItemCount => filteredMembers.Count;
        public UnityObjectWidget UnityWidget { get; private set; }
        public string TabButtonText { get; set; }

        InputFieldRef hiddenNameText;
        Text nameText;
        Text assemblyText;
        Toggle autoUpdateToggle;

        ButtonRef dnSpyButton;

        ButtonRef makeGenericButton;
        GenericConstructorWidget genericConstructor;

        InputFieldRef filterInputField;
        readonly List<Toggle> memberTypeToggles = new();
        readonly Dictionary<BindingFlags, ButtonRef> scopeFilterButtons = new();

        // Setup

        public override void OnBorrowedFromPool(object target)
        {
            base.OnBorrowedFromPool(target);
            CalculateLayouts();

            SetTarget(target);

            RuntimeHelper.StartCoroutine(InitCoroutine());
        }

        private IEnumerator InitCoroutine()
        {
            yield return null;
            LayoutRebuilder.ForceRebuildLayoutImmediate(InspectorPanel.Instance.ContentRect);
        }

        public override void CloseInspector()
        {
            InspectorManager.ReleaseInspector(this);
        }

        public override void OnReturnToPool()
        {
            foreach (CacheMember member in members)
            {
                member.UnlinkFromView();
                member.ReleasePooledObjects();
            }

            members.Clear();
            filteredMembers.Clear();

            autoUpdateToggle.isOn = false;

            if (UnityWidget != null)
            {
                UnityWidget.OnReturnToPool();
                Pool.Return(UnityWidget.GetType(), UnityWidget);
                this.UnityWidget = null;
            }

            genericConstructor?.Cancel();

            base.OnReturnToPool();
        }

        // Setting target

        private void SetTarget(object target)
        {
            string prefix;
            if (StaticOnly)
            {
                Target = null;
                TargetType = target as Type;
                prefix = "[S]";

                makeGenericButton.GameObject.SetActive(TargetType.IsGenericTypeDefinition);
            }
            else
            {
                TargetType = target.GetActualType();
                prefix = "[R]";
            }

            // Setup main labels and tab text
            TabButtonText = $"{prefix} {SignatureHighlighter.Parse(TargetType, false)}";
            Tab.TabText.text = TabButtonText;
            nameText.text = SignatureHighlighter.Parse(TargetType, true);
            hiddenNameText.Text = SignatureHighlighter.RemoveHighlighting(nameText.text);

            string asmText;
            if (TargetType.Assembly is AssemblyBuilder || string.IsNullOrEmpty(TargetType.Assembly.Location))
            {
                asmText = $"{TargetType.Assembly.GetName().Name} <color=grey><i>(in memory)</i></color>";
                dnSpyButton.GameObject.SetActive(false);
            }
            else
            {
                asmText = Path.GetFileName(TargetType.Assembly.Location);
                dnSpyButton.GameObject.SetActive(true);
            }
            assemblyText.text = $"<color=grey>Assembly:</color> {asmText}";

            // Unity object helper widget

            if (!StaticOnly)
                this.UnityWidget = UnityObjectWidget.GetUnityWidget(target, TargetType, this);

            // Get cache members

            this.members = CacheMemberFactory.GetCacheMembers(TargetType, this);

            // reset filters

            this.filterInputField.Text = string.Empty;

            SetFilter(string.Empty, StaticOnly ? BindingFlags.Static : BindingFlags.Default);
            scopeFilterButtons[BindingFlags.Default].Component.gameObject.SetActive(!StaticOnly);
            scopeFilterButtons[BindingFlags.Instance].Component.gameObject.SetActive(!StaticOnly);

            foreach (Toggle toggle in memberTypeToggles)
                toggle.isOn = true;

            refreshWanted = true;
        }

        // Updating

        public override void Update()
        {
            if (!this.IsActive)
                return;

            if (!StaticOnly && Target.IsNullOrDestroyed(false))
            {
                InspectorManager.ReleaseInspector(this);
                return;
            }

            // check filter changes or force-refresh
            if (refreshWanted || nameFilter != lastNameFilter || scopeFlagsFilter != lastFlagsFilter || lastMemberFilter != memberFilter)
            {
                lastNameFilter = nameFilter;
                lastFlagsFilter = scopeFlagsFilter;
                lastMemberFilter = memberFilter;

                FilterMembers();
                MemberScrollPool.Refresh(true, true);
                refreshWanted = false;
            }

            // once-per-second updates
            if (timeOfLastAutoUpdate.OccuredEarlierThan(1))
            {
                timeOfLastAutoUpdate = Time.realtimeSinceStartup;

                if (this.UnityWidget != null)
                    UnityWidget.Update();

                if (AutoUpdateWanted)
                    UpdateDisplayedMembers();
            }
        }

        // Filtering

        public void SetFilter(string name, BindingFlags flags)
        {
            this.nameFilter = name;

            if (flags != scopeFlagsFilter)
            {
                Button btn = scopeFilterButtons[scopeFlagsFilter].Component;
                RuntimeHelper.SetColorBlock(btn, disabledButtonColor, disabledButtonColor * 1.3f);

                this.scopeFlagsFilter = flags;
                btn = scopeFilterButtons[scopeFlagsFilter].Component;
                RuntimeHelper.SetColorBlock(btn, enabledButtonColor, enabledButtonColor * 1.3f);
            }
        }

        void FilterMembers()
        {
            filteredMembers.Clear();

            for (int i = 0; i < members.Count; i++)
            {
                CacheMember member = members[i];

                if (scopeFlagsFilter != BindingFlags.Default)
                {
                    if (scopeFlagsFilter == BindingFlags.Instance && member.IsStatic
                        || scopeFlagsFilter == BindingFlags.Static && !member.IsStatic)
                        continue;
                }

                if ((member is CacheMethod && !memberFilter.HasFlag(MemberFilter.Method))
                    || (member is CacheField && !memberFilter.HasFlag(MemberFilter.Field))
                    || (member is CacheProperty && !memberFilter.HasFlag(MemberFilter.Property))
                    || (member is CacheConstructor && !memberFilter.HasFlag(MemberFilter.Constructor)))
                    continue;

                if (!string.IsNullOrEmpty(nameFilter) && !member.NameForFiltering.ContainsIgnoreCase(nameFilter))
                    continue;

                filteredMembers.Add(member);
            }
        }

        void UpdateDisplayedMembers()
        {
            bool shouldRefresh = false;
            foreach (CacheMemberCell cell in MemberScrollPool.CellPool)
            {
                if (!cell.Enabled || cell.Occupant == null)
                    continue;
                CacheMember member = cell.MemberOccupant;
                if (member.ShouldAutoEvaluate)
                {
                    shouldRefresh = true;
                    member.Evaluate();
                    member.SetDataToCell(member.CellView);
                }
            }

            if (shouldRefresh)
                MemberScrollPool.Refresh(false);
        }

        // Member cells

        public void OnCellBorrowed(CacheMemberCell cell) { } // not needed

        public void SetCell(CacheMemberCell cell, int index)
        {
            CacheObjectControllerHelper.SetCell(cell, index, filteredMembers, SetCellLayout);
        }

        // Cell layout (fake table alignment)

        internal void SetLayouts()
        {
            CalculateLayouts();

            foreach (CacheMemberCell cell in MemberScrollPool.CellPool)
                SetCellLayout(cell);
        }

        void CalculateLayouts()
        {
            LeftGroupWidth = (int)Math.Max(200, (0.4f * InspectorManager.PanelWidth) - 5);
            RightGroupWidth = (int)Math.Max(200, InspectorManager.PanelWidth - LeftGroupWidth - 65);
        }

        void SetCellLayout(CacheObjectCell cell)
        {
            cell.NameLayout.minWidth = LeftGroupWidth;
            cell.RightGroupLayout.minWidth = RightGroupWidth;

            if (cell.Occupant?.IValue != null)
                cell.Occupant.IValue.SetLayout();
        }

        // UI listeners

        void OnUpdateClicked()
        {
            UpdateDisplayedMembers();
        }

        public void OnSetNameFilter(string name)
        {
            SetFilter(name, scopeFlagsFilter);
        }

        public void OnSetFlags(BindingFlags flags)
        {
            SetFilter(nameFilter, flags);
        }

        void OnMemberTypeToggled(MemberFilter flag, bool val)
        {
            if (!val)
                memberFilter &= ~flag;
            else
                memberFilter |= flag;
        }

        void OnCopyClicked()
        {
            ClipboardPanel.Copy(this.Target ?? this.TargetType);
        }

        void OnDnSpyButtonClicked()
        {
            string path = ConfigManager.DnSpy_Path.Value;
            if (File.Exists(path) && path.EndsWith("dnspy.exe", StringComparison.OrdinalIgnoreCase))
            {
                Type type = TargetType;
                // if constructed generic type, use the generic type definition
                if (type.IsGenericType && !type.IsGenericTypeDefinition)
                    type = type.GetGenericTypeDefinition();

                string args = $"\"{type.Assembly.Location}\" --select T:{type.FullName}";
                Process.Start(path, args);
            }
            else
            {
                Notification.ShowMessage($"Please set a valid dnSpy path in UnityExplorer Settings.");
            }
        }

        void OnMakeGenericClicked()
        {
            ContentRoot.SetActive(false);

            if (genericConstructor == null)
            {
                genericConstructor = new();
                genericConstructor.ConstructUI(UIRoot);
            }

            genericConstructor.UIRoot.SetActive(true);
            genericConstructor.Show(OnGenericSubmit, OnGenericCancel, TargetType);
        }

        void OnGenericSubmit(Type[] args)
        {
            ContentRoot.SetActive(true);
            genericConstructor.UIRoot.SetActive(false);

            Type newType = TargetType.MakeGenericType(args);
            InspectorManager.Inspect(newType);
            //InspectorManager.ReleaseInspector(this);
        }

        void OnGenericCancel()
        {
            ContentRoot.SetActive(true);
            genericConstructor.UIRoot.SetActive(false);
        }

        // UI Construction

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "ReflectionInspector", true, true, true, true, 5,
                new Vector4(4, 4, 4, 4), new Color(0.065f, 0.065f, 0.065f));

            // Class name, assembly

            GameObject topRow = UIFactory.CreateHorizontalGroup(UIRoot, "TopRow", false, false, true, true, 4, default, 
                new(0.1f, 0.1f, 0.1f), TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(topRow, minHeight: 25, flexibleWidth: 9999);

            GameObject titleHolder = UIFactory.CreateUIObject("TitleHolder", topRow);
            UIFactory.SetLayoutElement(titleHolder, minHeight: 35, flexibleHeight: 0, flexibleWidth: 9999);

            nameText = UIFactory.CreateLabel(titleHolder, "VisibleTitle", "NotSet", TextAnchor.MiddleLeft);
            RectTransform namerect = nameText.GetComponent<RectTransform>();
            namerect.anchorMin = new Vector2(0, 0);
            namerect.anchorMax = new Vector2(1, 1);
            nameText.fontSize = 17;
            UIFactory.SetLayoutElement(nameText.gameObject, minHeight: 35, flexibleHeight: 0, minWidth: 300, flexibleWidth: 9999);

            hiddenNameText = UIFactory.CreateInputField(titleHolder, "Title", "not set");
            RectTransform hiddenrect = hiddenNameText.Component.gameObject.GetComponent<RectTransform>();
            hiddenrect.anchorMin = new Vector2(0, 0);
            hiddenrect.anchorMax = new Vector2(1, 1);
            hiddenNameText.Component.readOnly = true;
            hiddenNameText.Component.lineType = InputField.LineType.MultiLineNewline;
            hiddenNameText.Component.gameObject.GetComponent<Image>().color = Color.clear;
            hiddenNameText.Component.textComponent.horizontalOverflow = HorizontalWrapMode.Wrap;
            hiddenNameText.Component.textComponent.fontSize = 17;
            hiddenNameText.Component.textComponent.color = Color.clear;
            UIFactory.SetLayoutElement(hiddenNameText.Component.gameObject, minHeight: 35, flexibleHeight: 0, flexibleWidth: 9999);

            makeGenericButton = UIFactory.CreateButton(topRow, "MakeGenericButton", "Construct Generic", new Color(0.2f, 0.3f, 0.2f));
            UIFactory.SetLayoutElement(makeGenericButton.GameObject, minWidth: 140, minHeight: 25);
            makeGenericButton.OnClick += OnMakeGenericClicked;
            makeGenericButton.GameObject.SetActive(false);

            ButtonRef copyButton = UIFactory.CreateButton(topRow, "CopyButton", "Copy to Clipboard", new Color(0.2f, 0.2f, 0.2f, 1));
            copyButton.ButtonText.color = Color.yellow;
            UIFactory.SetLayoutElement(copyButton.Component.gameObject, minHeight: 25, minWidth: 120, flexibleWidth: 0);
            copyButton.OnClick += OnCopyClicked;

            // Assembly row

            GameObject asmRow = UIFactory.CreateHorizontalGroup(UIRoot, "AssemblyRow", false, false, true, true, 5, default, new(1, 1, 1, 0));
            UIFactory.SetLayoutElement(asmRow, flexibleWidth: 9999, minHeight: 25);

            assemblyText = UIFactory.CreateLabel(asmRow, "AssemblyLabel", "not set", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(assemblyText.gameObject, minHeight: 25, flexibleWidth: 9999);

            dnSpyButton = UIFactory.CreateButton(asmRow, "DnSpyButton", "View in dnSpy");
            UIFactory.SetLayoutElement(dnSpyButton.GameObject, minWidth: 120, minHeight: 25);
            dnSpyButton.OnClick += OnDnSpyButtonClicked;

            // Content 

            ContentRoot = UIFactory.CreateVerticalGroup(UIRoot, "ContentRoot", false, false, true, true, 5, new Vector4(2, 2, 2, 2),
                new Color(0.12f, 0.12f, 0.12f));
            UIFactory.SetLayoutElement(ContentRoot, flexibleWidth: 9999, flexibleHeight: 9999);

            ConstructFirstRow(ContentRoot);

            ConstructSecondRow(ContentRoot);

            // Member scroll pool

            GameObject memberBorder = UIFactory.CreateVerticalGroup(ContentRoot, "ScrollPoolHolder", false, false, true, true,
                padding: new Vector4(2, 2, 2, 2), bgColor: new Color(0.05f, 0.05f, 0.05f));
            UIFactory.SetLayoutElement(memberBorder, flexibleWidth: 9999, flexibleHeight: 9999);

            MemberScrollPool = UIFactory.CreateScrollPool<CacheMemberCell>(memberBorder, "MemberList", out GameObject scrollObj,
                out GameObject _, new Color(0.09f, 0.09f, 0.09f));
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
            MemberScrollPool.Initialize(this);

            // For debugging scroll pool
            //InspectorPanel.Instance.UIRoot.GetComponent<Mask>().enabled = false;
            //MemberScrollPool.Viewport.GetComponent<Mask>().enabled = false;
            //MemberScrollPool.Viewport.GetComponent<Image>().color = new Color(0.12f, 0.12f, 0.12f);

            return UIRoot;
        }

        // First row

        void ConstructFirstRow(GameObject parent)
        {
            GameObject rowObj = UIFactory.CreateUIObject("FirstRow", parent);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(rowObj, true, true, true, true, 5, 2, 2, 2, 2);
            UIFactory.SetLayoutElement(rowObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            Text nameLabel = UIFactory.CreateLabel(rowObj, "NameFilterLabel", "Filter names:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(nameLabel.gameObject, minHeight: 25, minWidth: 90, flexibleWidth: 0);

            filterInputField = UIFactory.CreateInputField(rowObj, "NameFilterInput", "...");
            UIFactory.SetLayoutElement(filterInputField.UIRoot, minHeight: 25, flexibleWidth: 300);
            filterInputField.OnValueChanged += (string val) => { OnSetNameFilter(val); };

            GameObject spacer = UIFactory.CreateUIObject("Spacer", rowObj);
            UIFactory.SetLayoutElement(spacer, minWidth: 25);

            // Update button and toggle

            ButtonRef updateButton = UIFactory.CreateButton(rowObj, "UpdateButton", "Update displayed values", new Color(0.22f, 0.28f, 0.22f));
            UIFactory.SetLayoutElement(updateButton.Component.gameObject, minHeight: 25, minWidth: 175, flexibleWidth: 0);
            updateButton.OnClick += OnUpdateClicked;

            GameObject toggleObj = UIFactory.CreateToggle(rowObj, "AutoUpdateToggle", out autoUpdateToggle, out Text toggleText);
            UIFactory.SetLayoutElement(toggleObj, minWidth: 125, minHeight: 25);
            autoUpdateToggle.isOn = false;
            toggleText.text = "Auto-update";
        }

        // Second row

        void ConstructSecondRow(GameObject parent)
        {
            GameObject rowObj = UIFactory.CreateUIObject("SecondRow", parent);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(rowObj, false, false, true, true, 5, 2, 2, 2, 2);
            UIFactory.SetLayoutElement(rowObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            // Scope buttons

            Text scopeLabel = UIFactory.CreateLabel(rowObj, "ScopeLabel", "Scope:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(scopeLabel.gameObject, minHeight: 25, minWidth: 60, flexibleWidth: 0);
            AddScopeFilterButton(rowObj, BindingFlags.Default, true);
            AddScopeFilterButton(rowObj, BindingFlags.Instance);
            AddScopeFilterButton(rowObj, BindingFlags.Static);

            GameObject spacer = UIFactory.CreateUIObject("Spacer", rowObj);
            UIFactory.SetLayoutElement(spacer, minWidth: 15);

            // Member type toggles

            AddMemberTypeToggle(rowObj, MemberTypes.Property, 90);
            AddMemberTypeToggle(rowObj, MemberTypes.Field, 70);
            AddMemberTypeToggle(rowObj, MemberTypes.Method, 90);
            AddMemberTypeToggle(rowObj, MemberTypes.Constructor, 110);
        }

        void AddScopeFilterButton(GameObject parent, BindingFlags flags, bool setAsActive = false)
        {
            string lbl = flags == BindingFlags.Default ? "All" : flags.ToString();
            Color color = setAsActive ? enabledButtonColor : disabledButtonColor;

            ButtonRef button = UIFactory.CreateButton(parent, "Filter_" + flags, lbl, color);
            UIFactory.SetLayoutElement(button.Component.gameObject, minHeight: 25, flexibleHeight: 0, minWidth: 70, flexibleWidth: 0);
            scopeFilterButtons.Add(flags, button);

            button.OnClick += () => { OnSetFlags(flags); };
        }

        void AddMemberTypeToggle(GameObject parent, MemberTypes type, int width)
        {
            GameObject toggleObj = UIFactory.CreateToggle(parent, "Toggle_" + type, out Toggle toggle, out Text toggleText);
            UIFactory.SetLayoutElement(toggleObj, minHeight: 25, minWidth: width);
            string color = type switch
            {
                MemberTypes.Method => SignatureHighlighter.METHOD_INSTANCE,
                MemberTypes.Field => SignatureHighlighter.FIELD_INSTANCE,
                MemberTypes.Property => SignatureHighlighter.PROP_INSTANCE,
                MemberTypes.Constructor => SignatureHighlighter.CLASS_INSTANCE,
                _ => throw new NotImplementedException()
            };
            toggleText.text = $"<color={color}>{type}</color>";

            toggle.graphic.TryCast<Image>().color = color.ToColor() * 0.65f;

            MemberFilter flag = type switch
            {
                MemberTypes.Method => MemberFilter.Method,
                MemberTypes.Property => MemberFilter.Property,
                MemberTypes.Field => MemberFilter.Field,
                MemberTypes.Constructor => MemberFilter.Constructor,
                _ => throw new NotImplementedException()
            };

            toggle.onValueChanged.AddListener((bool val) => { OnMemberTypeToggled(flag, val); });

            memberTypeToggles.Add(toggle);
        }
    }
}

```

`src/Loader/BepInEx/BepInExConfigHandler.cs`:

```cs
#if BIE
using BepInEx.Configuration;
using UnityExplorer.Config;

namespace UnityExplorer.Loader.BIE
{
    public class BepInExConfigHandler : ConfigHandler
    {
        private ConfigFile Config => ExplorerBepInPlugin.Instance.Config;

        private const string CTG_NAME = "UnityExplorer";

        public override void Init()
        {
            // Not necessary
        }

        public override void RegisterConfigElement<T>(ConfigElement<T> config)
        {
            ConfigEntry<T> entry = Config.Bind(CTG_NAME, config.Name, config.Value, config.Description);

            entry.SettingChanged += (object o, EventArgs e) =>
            {
                config.Value = entry.Value;
            };
        }

        public override T GetConfigValue<T>(ConfigElement<T> element)
        {
            if (Config.TryGetEntry(CTG_NAME, element.Name, out ConfigEntry<T> configEntry))
                return configEntry.Value;
            else
                throw new Exception("Could not get config entry '" + element.Name + "'");
        }

        public override void SetConfigValue<T>(ConfigElement<T> element, T value)
        {
            if (Config.TryGetEntry(CTG_NAME, element.Name, out ConfigEntry<T> configEntry))
                configEntry.Value = value;
            else
                ExplorerCore.Log("Could not get config entry '" + element.Name + "'");
        }

        public override void LoadConfig()
        {
            foreach (KeyValuePair<string, IConfigElement> entry in ConfigManager.ConfigElements)
            {
                string key = entry.Key;
                ConfigDefinition def = new(CTG_NAME, key);
                if (Config.ContainsKey(def) && Config[def] is ConfigEntryBase configEntry)
                {
                    IConfigElement config = entry.Value;
                    config.BoxedValue = configEntry.BoxedValue;
                }
            }
        }

        public override void SaveConfig()
        {
            Config.Save();
        }
    }
}

#endif
```

`src/Loader/BepInEx/ExplorerBepInPlugin.cs`:

```cs
#if BIE
using BepInEx;
using BepInEx.Logging;
using HarmonyLib;
using UnityExplorer.Config;
using UnityExplorer.Loader.BIE;
#if CPP
using BepInEx.IL2CPP;
#endif

namespace UnityExplorer
{
    [BepInPlugin(ExplorerCore.GUID, "UnityExplorer", ExplorerCore.VERSION)]

    public class ExplorerBepInPlugin :
#if MONO
        BaseUnityPlugin
#else
        BasePlugin
#endif
        , IExplorerLoader
    {
        public static ExplorerBepInPlugin Instance;

        public ManualLogSource LogSource
#if MONO
            => Logger;
#else
            => Log;
#endif
        const string IL2CPP_LIBS_FOLDER =
#if UNHOLLOWER
            "unhollowed"
#else
            "interop"
#endif
            ;
        public string UnhollowedModulesFolder => Path.Combine(Paths.BepInExRootPath, IL2CPP_LIBS_FOLDER);

        public ConfigHandler ConfigHandler => _configHandler;
        private BepInExConfigHandler _configHandler;

        public Harmony HarmonyInstance => s_harmony;
        private static readonly Harmony s_harmony = new(ExplorerCore.GUID);

        public string ExplorerFolderName => ExplorerCore.DEFAULT_EXPLORER_FOLDER_NAME;
        public string ExplorerFolderDestination => Paths.PluginPath;

        public Action<object> OnLogMessage => LogSource.LogMessage;
        public Action<object> OnLogWarning => LogSource.LogWarning;
        public Action<object> OnLogError => LogSource.LogError;

        private void Init()
        {
            Instance = this;
            _configHandler = new BepInExConfigHandler();
            ExplorerCore.Init(this);
        }

#if MONO // Mono
        internal void Awake()
        {
            Init();
        }

#else   // Il2Cpp
        public override void Load()
        {
            Init();
        }
#endif
    }
}
#endif
```

`src/Loader/IExplorerLoader.cs`:

```cs
using UnityExplorer.Config;

namespace UnityExplorer
{
    public interface IExplorerLoader
    {
        string ExplorerFolderDestination { get; }
        string ExplorerFolderName { get; }
        string UnhollowedModulesFolder { get; }

        ConfigHandler ConfigHandler { get; }

        Action<object> OnLogMessage { get; }
        Action<object> OnLogWarning { get; }
        Action<object> OnLogError { get; }
    }
}

```

`src/Loader/MelonLoader/ExplorerMelonMod.cs`:

```cs
#if ML
using System;
using System.IO;
using MelonLoader;
using UnityExplorer;
using UnityExplorer.Config;
using UnityExplorer.Loader.ML;

#if CPP
[assembly: MelonPlatformDomain(MelonPlatformDomainAttribute.CompatibleDomains.IL2CPP)]
#else
[assembly: MelonPlatformDomain(MelonPlatformDomainAttribute.CompatibleDomains.MONO)]
#endif

[assembly: MelonInfo(typeof(ExplorerMelonMod), ExplorerCore.NAME, ExplorerCore.VERSION, ExplorerCore.AUTHOR)]
[assembly: MelonGame(null, null)]
[assembly: MelonColor(ConsoleColor.DarkCyan)]

namespace UnityExplorer
{
    public class ExplorerMelonMod : MelonMod, IExplorerLoader
    {
        public string ExplorerFolderName => ExplorerCore.DEFAULT_EXPLORER_FOLDER_NAME;
        public string ExplorerFolderDestination => MelonHandler.ModsDirectory;

        public string UnhollowedModulesFolder => Path.Combine(
            Path.GetDirectoryName(MelonHandler.ModsDirectory),
            Path.Combine("MelonLoader", "Managed"));

        public ConfigHandler ConfigHandler => _configHandler;
        public MelonLoaderConfigHandler _configHandler;

        public Action<object> OnLogMessage => LoggerInstance.Msg;
        public Action<object> OnLogWarning => LoggerInstance.Warning;
        public Action<object> OnLogError   => LoggerInstance.Error;

        public override void OnApplicationStart()
        {
            _configHandler = new MelonLoaderConfigHandler();
            ExplorerCore.Init(this);
        }
    }
}
#endif
```

`src/Loader/MelonLoader/MelonLoaderConfigHandler.cs`:

```cs
#if ML
using MelonLoader;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityExplorer.Config;

namespace UnityExplorer.Loader.ML
{
    public class MelonLoaderConfigHandler : ConfigHandler
    {
        internal const string CTG_NAME = "UnityExplorer";

        internal MelonPreferences_Category prefCategory;

        public override void Init()
        {
            prefCategory = MelonPreferences.CreateCategory(CTG_NAME, $"{CTG_NAME} Settings", false, true);
        }

        public override void LoadConfig()
        {
            foreach (var entry in ConfigManager.ConfigElements)
            {
                var key = entry.Key;
                if (prefCategory.GetEntry(key) is MelonPreferences_Entry)
                {
                    var config = entry.Value;
                    config.BoxedValue = config.GetLoaderConfigValue();
                }
            }
        }

        // This wrapper exists to handle the "LemonAction" delegates which ML now uses in 0.4.4+.
        // Reflection is required since the delegate type changed between 0.4.3 and 0.4.4.
        // A wrapper class is required to link the MelonPreferences_Entry and the delegate instance.
        public class EntryDelegateWrapper<T>
        {
            public MelonPreferences_Entry<T> entry;
            public ConfigElement<T> config;

            public EntryDelegateWrapper(MelonPreferences_Entry<T> entry, ConfigElement<T> config)
            {
                this.entry = entry;
                this.config = config;
                var evt = entry.GetType().GetEvent("OnValueChangedUntyped");
                evt.AddEventHandler(entry, Delegate.CreateDelegate(evt.EventHandlerType, this, GetType().GetMethod("OnChanged")));
            }

            public void OnChanged()
            {
                if ((entry.Value == null && config.Value == null) || config.Value.Equals(entry.Value))
                    return;
                config.Value = entry.Value;
            }
        }

        public override void RegisterConfigElement<T>(ConfigElement<T> config)
        {
            var entry = prefCategory.CreateEntry(config.Name, config.Value, null, config.Description, config.IsInternal, false);
            new EntryDelegateWrapper<T>(entry, config);
        }

        public override void SetConfigValue<T>(ConfigElement<T> config, T value)
        {
            if (prefCategory.GetEntry<T>(config.Name) is MelonPreferences_Entry<T> entry)
            { 
                entry.Value = value;
                //entry.Save();
            }
        }

        public override T GetConfigValue<T>(ConfigElement<T> config)
        {
            if (prefCategory.GetEntry<T>(config.Name) is MelonPreferences_Entry<T> entry)
                return entry.Value;

            return default;
        }

        public override void OnAnyConfigChanged()
        {
        }

        public override void SaveConfig()
        {
            MelonPreferences.Save();
        }
    }
}
#endif
```

`src/Loader/Standalone/Editor/ExplorerEditorBehaviour.cs`:

```cs
#if STANDALONE
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityExplorer.Config;
using UnityExplorer.UI;
using UniverseLib;

namespace UnityExplorer.Loader.Standalone
{
    public class ExplorerEditorBehaviour : MonoBehaviour
    {
        internal static ExplorerEditorBehaviour Instance { get; private set; }

        public bool Hide_On_Startup = true;
        public KeyCode Master_Toggle_Key = KeyCode.F7;
        public UIManager.VerticalAnchor Main_Navbar_Anchor = UIManager.VerticalAnchor.Top;
        public bool Log_Unity_Debug = false;
        public float Startup_Delay_Time = 1f;
        public KeyCode World_MouseInspect_Keybind;
        public KeyCode UI_MouseInspect_Keybind;
        public bool Force_Unlock_Mouse = true;
        public KeyCode Force_Unlock_Toggle;
        public bool Disable_EventSystem_Override;

        internal void Awake()
        {
            Instance = this;

            ExplorerEditorLoader.Initialize();
            DontDestroyOnLoad(this);
            this.gameObject.hideFlags = HideFlags.HideAndDontSave;
        }

        internal void OnApplicationQuit()
        {
            Destroy(this.gameObject);
        }
    
        internal void LoadConfigs()
        {
            ConfigManager.Hide_On_Startup.Value = this.Hide_On_Startup;
            ConfigManager.Master_Toggle.Value = this.Master_Toggle_Key;
            ConfigManager.Main_Navbar_Anchor.Value = this.Main_Navbar_Anchor;
            ConfigManager.Log_Unity_Debug.Value = this.Log_Unity_Debug;
            ConfigManager.Startup_Delay_Time.Value = this.Startup_Delay_Time;
            ConfigManager.World_MouseInspect_Keybind.Value = this.World_MouseInspect_Keybind;
            ConfigManager.UI_MouseInspect_Keybind.Value = this.UI_MouseInspect_Keybind;
            ConfigManager.Force_Unlock_Mouse.Value = this.Force_Unlock_Mouse;
            ConfigManager.Force_Unlock_Toggle.Value = this.Force_Unlock_Toggle;
            ConfigManager.Disable_EventSystem_Override.Value = this.Disable_EventSystem_Override;
        }
    }
}
#endif
```

`src/Loader/Standalone/Editor/ExplorerEditorLoader.cs`:

```cs
#if STANDALONE
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;

namespace UnityExplorer.Loader.Standalone
{
    public class ExplorerEditorLoader : ExplorerStandalone
    {
        public new string ExplorerFolderName => $"{ExplorerCore.DEFAULT_EXPLORER_FOLDER_NAME}~";

        public static void Initialize()
        {
            Instance = new ExplorerEditorLoader();
            OnLog += LogHandler;
            Instance.configHandler = new StandaloneConfigHandler();

            ExplorerCore.Init(Instance);
        }

        static void LogHandler(string message, LogType logType)
        {
            switch (logType)
            {
                case LogType.Assert:    Debug.LogError(message); break;
                case LogType.Error:     Debug.LogError(message); break;
                case LogType.Exception: Debug.LogError(message); break;
                case LogType.Log:       Debug.Log(message); break;
                case LogType.Warning:   Debug.LogWarning(message); break;
            }
        }

        protected override void CheckExplorerFolder()
        {
            if (explorerFolderDest == null)
                explorerFolderDest = Path.GetDirectoryName(Application.dataPath);
        }
    }
}
#endif
```

`src/Loader/Standalone/ExplorerStandalone.cs`:

```cs
#if STANDALONE
using HarmonyLib;
using System;
using System.IO;
using System.Reflection;
using UnityEngine;
using UnityExplorer.Config;
using UnityEngine.EventSystems;
using UniverseLib.Input;
using UnityExplorer.Loader.Standalone;
#if CPP
using UnhollowerRuntimeLib;
#endif

namespace UnityExplorer
{
	public class ExplorerStandalone : IExplorerLoader
    {
        public static ExplorerStandalone Instance { get; protected set; }

        /// <summary>
        /// Invoked whenever Explorer logs something. Subscribe to this to handle logging.
        /// </summary>
        public static event Action<string, LogType> OnLog;

        public string UnhollowedModulesFolder => unhollowedPath;
        private string unhollowedPath;

        public ConfigHandler ConfigHandler => configHandler;
        internal StandaloneConfigHandler configHandler;

        public string ExplorerFolderName => ExplorerCore.DEFAULT_EXPLORER_FOLDER_NAME;
        public string ExplorerFolderDestination
        {
            get
            {
                CheckExplorerFolder();
                return explorerFolderDest;
            }
        }
        protected static string explorerFolderDest;
        
        Action<object> IExplorerLoader.OnLogMessage => (object log) => { OnLog?.Invoke(log?.ToString() ?? "", LogType.Log); };
        Action<object> IExplorerLoader.OnLogWarning => (object log) => { OnLog?.Invoke(log?.ToString() ?? "", LogType.Warning); };
        Action<object> IExplorerLoader.OnLogError   => (object log) => { OnLog?.Invoke(log?.ToString() ?? "", LogType.Error); };

        /// <summary>
        /// Call this to initialize UnityExplorer without adding a log listener or Unhollowed modules path.
        /// The default Unhollowed path "sinai-dev-UnityExplorer\Modules\" will be used.
        /// </summary>
        /// <returns>The new (or active, if one exists) instance of ExplorerStandalone.</returns>
        public static ExplorerStandalone CreateInstance() => CreateInstance(null, null);

        /// <summary>
        /// Call this to initialize UnityExplorer and add a listener for UnityExplorer's log messages, without specifying an Unhollowed modules path.
        /// The default Unhollowed path "sinai-dev-UnityExplorer\Modules\" will be used.
        /// </summary>
        /// <param name="logListener">Your log listener to handle UnityExplorer logs.</param>
        /// <returns>The new (or active, if one exists) instance of ExplorerStandalone.</returns>
        public static ExplorerStandalone CreateInstance(Action<string, LogType> logListener) => CreateInstance(logListener, null);

        /// <summary>
        /// Call this to initialize UnityExplorer with the provided log listener and Unhollowed modules path.
        /// </summary>
        /// <param name="logListener">Your log listener to handle UnityExplorer logs.</param>
        /// <param name="unhollowedModulesPath">The path of the Unhollowed modules, either relative or absolute.</param>
        /// <returns>The new (or active, if one exists) instance of ExplorerStandalone.</returns>
        public static ExplorerStandalone CreateInstance(Action<string, LogType> logListener, string unhollowedModulesPath)
        {
            if (Instance != null)
                return Instance;

            var instance = new ExplorerStandalone();
            instance.Init();
            instance.CheckExplorerFolder();

            if (logListener != null)
                OnLog += logListener;

            if (string.IsNullOrEmpty(unhollowedModulesPath) || !Directory.Exists(unhollowedModulesPath))
                instance.unhollowedPath = Path.Combine(ExplorerCore.ExplorerFolder, "Modules");
            else
                instance.unhollowedPath = unhollowedModulesPath;

            return instance;
        }

        internal void Init()
        {
            Instance = this;
            configHandler = new StandaloneConfigHandler();

            ExplorerCore.Init(this);
        }

        protected virtual void CheckExplorerFolder()
        {
            if (explorerFolderDest == null)
            {
                string assemblyLocation = Uri.UnescapeDataString(new Uri(typeof(ExplorerCore).Assembly.CodeBase).AbsolutePath);
                explorerFolderDest = Path.GetDirectoryName(assemblyLocation);
            }
        }
    }
}
#endif
```

`src/Loader/Standalone/StandaloneConfigHandler.cs`:

```cs
#if STANDALONE
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityExplorer.Config;
using System.IO;
using UnityEngine;
using Tomlet;
using Tomlet.Models;

namespace UnityExplorer.Loader.Standalone
{
    public class StandaloneConfigHandler : ConfigHandler
    {
        internal static string CONFIG_PATH;

        public override void Init()
        {
            CONFIG_PATH = Path.Combine(ExplorerCore.ExplorerFolder, "config.cfg");
        }

        public override void LoadConfig()
        {
            if (!TryLoadConfig())
                SaveConfig();
        }

        public override void RegisterConfigElement<T>(ConfigElement<T> element)
        {
            // Not necessary
        }

        public override void SetConfigValue<T>(ConfigElement<T> element, T value)
        {
            // Not necessary, just save.
            SaveConfig();
        }

        public override T GetConfigValue<T>(ConfigElement<T> element)
        {
            // Not necessary, just return the value.
            return element.Value;
        }

        public bool TryLoadConfig()
        {
            try
            {
                if (!File.Exists(CONFIG_PATH))
                    return false;

                var document = TomlParser.ParseFile(CONFIG_PATH);
                foreach (var key in document.Keys)
                {
                    var config = ConfigManager.ConfigElements[key];
                    config.BoxedValue = StringToConfigValue(document.GetValue(key).StringValue, config.ElementType);
                }

                return true;
            }
            catch
            {
                return false;
            }
        }

        public object StringToConfigValue(string value, Type elementType)
        {
            if (elementType == typeof(KeyCode))
                return (KeyCode)Enum.Parse(typeof(KeyCode), value);
            else if (elementType == typeof(bool))
                return bool.Parse(value);
            else if (elementType == typeof(int))
                return int.Parse(value);
            else if (elementType == typeof(float))
                return float.Parse(value);
            else if (elementType.IsEnum)
                return Enum.Parse(elementType, value);
            else
                return value;
        }

        public override void OnAnyConfigChanged()
        {
            SaveConfig();
        }

        public override void SaveConfig()
        {
            var document = TomlDocument.CreateEmpty();
            foreach (var config in ConfigManager.ConfigElements)
                document.Put(config.Key, config.Value.BoxedValue.ToString());

            if (!Directory.Exists(ExplorerCore.ExplorerFolder))
                Directory.CreateDirectory(ExplorerCore.ExplorerFolder);

            File.WriteAllText(CONFIG_PATH, document.SerializedValue);
        }
    }
}

#endif
```

`src/ObjectExplorer/ObjectSearch.cs`:

```cs
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets.ButtonList;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.ObjectExplorer
{
    public class ObjectSearch : UIModel
    {
        public ObjectExplorerPanel Parent { get; }

        public ObjectSearch(ObjectExplorerPanel parent)
        {
            Parent = parent;
        }

        private SearchContext context = SearchContext.UnityObject;
        private SceneFilter sceneFilter = SceneFilter.Any;
        private ChildFilter childFilter = ChildFilter.Any;
        private string desiredTypeInput;
        private string lastCheckedTypeInput;
        private bool lastTypeCanHaveGameObject;

        public ButtonListHandler<object, ButtonCell> dataHandler;
        private ScrollPool<ButtonCell> resultsScrollPool;
        private List<object> currentResults = new();

        //public TypeCompleter typeAutocompleter;
        public TypeCompleter unityObjectTypeCompleter;
        public TypeCompleter allTypesCompleter;

        public override GameObject UIRoot => uiRoot;
        private GameObject uiRoot;
        private GameObject sceneFilterRow;
        private GameObject childFilterRow;
        private GameObject classInputRow;
        private GameObject nameInputRow;
        private InputFieldRef nameInputField;
        private Text resultsLabel;

        public List<object> GetEntries() => currentResults;

        public void DoSearch()
        {
            cachedCellTexts.Clear();

            if (context == SearchContext.Singleton)
                currentResults = SearchProvider.InstanceSearch(desiredTypeInput).ToList();
            else if (context == SearchContext.Class)
                currentResults = SearchProvider.ClassSearch(desiredTypeInput);
            else
                currentResults = SearchProvider.UnityObjectSearch(nameInputField.Text, desiredTypeInput, childFilter, sceneFilter);

            dataHandler.RefreshData();
            resultsScrollPool.Refresh(true);

            resultsLabel.text = $"{currentResults.Count} results";
        }

        public void Update()
        {
            if (context == SearchContext.UnityObject && lastCheckedTypeInput != desiredTypeInput)
            {
                lastCheckedTypeInput = desiredTypeInput;

                //var type = ReflectionUtility.GetTypeByName(desiredTypeInput);
                if (ReflectionUtility.GetTypeByName(desiredTypeInput) is Type cachedType)
                {
                    Type type = cachedType;
                    lastTypeCanHaveGameObject = typeof(Component).IsAssignableFrom(type) || type == typeof(GameObject);
                    sceneFilterRow.SetActive(lastTypeCanHaveGameObject);
                    childFilterRow.SetActive(lastTypeCanHaveGameObject);
                }
                else
                {
                    sceneFilterRow.SetActive(false);
                    childFilterRow.SetActive(false);
                    lastTypeCanHaveGameObject = false;
                }
            }
        }

        // UI Callbacks

        private void OnContextDropdownChanged(int value)
        {
            context = (SearchContext)value;

            lastCheckedTypeInput = null;
            sceneFilterRow.SetActive(false);
            childFilterRow.SetActive(false);

            nameInputRow.SetActive(context == SearchContext.UnityObject);

            switch (context)
            {
                case SearchContext.UnityObject:
                    unityObjectTypeCompleter.Enabled = true;
                    allTypesCompleter.Enabled = false;
                    break;
                case SearchContext.Singleton:
                case SearchContext.Class:
                    allTypesCompleter.Enabled = true;
                    unityObjectTypeCompleter.Enabled = false;
                    break;
            }
        }

        private void OnSceneFilterDropChanged(int value) => sceneFilter = (SceneFilter)value;

        private void OnChildFilterDropChanged(int value) => childFilter = (ChildFilter)value;

        private void OnTypeInputChanged(string val)
        {
            desiredTypeInput = val;

            if (string.IsNullOrEmpty(val))
            {
                sceneFilterRow.SetActive(false);
                childFilterRow.SetActive(false);
                lastCheckedTypeInput = val;
            }
        }

        // Cache the syntax-highlighted text for each search result to reduce allocs.
        private static readonly Dictionary<int, string> cachedCellTexts = new();

        public void SetCell(ButtonCell cell, int index)
        {
            if (!cachedCellTexts.ContainsKey(index))
            {
                string text;
                if (context == SearchContext.Class)
                {
                    Type type = currentResults[index] as Type;
                    text = $"{SignatureHighlighter.Parse(type, true)} <color=grey><i>({type.Assembly.GetName().Name})</i></color>";
                }
                else
                    text = ToStringUtility.ToStringWithType(currentResults[index], currentResults[index]?.GetActualType());

                cachedCellTexts.Add(index, text);
            }

            cell.Button.ButtonText.text = cachedCellTexts[index];
        }

        private void OnCellClicked(int dataIndex)
        {
            if (context == SearchContext.Class)
                InspectorManager.Inspect(currentResults[dataIndex] as Type);
            else
                InspectorManager.Inspect(currentResults[dataIndex]);
        }

        private bool ShouldDisplayCell(object arg1, string arg2) => true;

        public override void ConstructUI(GameObject parent)
        {
            uiRoot = UIFactory.CreateVerticalGroup(parent, "ObjectSearch", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(uiRoot, flexibleHeight: 9999);

            // Search context row

            GameObject contextGroup = UIFactory.CreateHorizontalGroup(uiRoot, "SearchContextRow", false, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(contextGroup, minHeight: 25, flexibleHeight: 0);

            Text contextLbl = UIFactory.CreateLabel(contextGroup, "SearchContextLabel", "Searching for:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(contextLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            GameObject contextDropObj = UIFactory.CreateDropdown(contextGroup, "ContextDropdown", out Dropdown contextDrop, null, 14, OnContextDropdownChanged);
            foreach (string name in Enum.GetNames(typeof(SearchContext)))
                contextDrop.options.Add(new Dropdown.OptionData(name));
            UIFactory.SetLayoutElement(contextDropObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            // Class input

            classInputRow = UIFactory.CreateHorizontalGroup(uiRoot, "ClassRow", false, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(classInputRow, minHeight: 25, flexibleHeight: 0);

            Text unityClassLbl = UIFactory.CreateLabel(classInputRow, "ClassLabel", "Class filter:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(unityClassLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            InputFieldRef classInputField = UIFactory.CreateInputField(classInputRow, "ClassInput", "...");
            UIFactory.SetLayoutElement(classInputField.UIRoot, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            unityObjectTypeCompleter = new(typeof(UnityEngine.Object), classInputField, true, false, true);
            allTypesCompleter = new(null, classInputField, true, false, true);
            allTypesCompleter.Enabled = false;
            classInputField.OnValueChanged += OnTypeInputChanged;

            //unityObjectClassRow.SetActive(false);

            // Child filter row

            childFilterRow = UIFactory.CreateHorizontalGroup(uiRoot, "ChildFilterRow", false, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(childFilterRow, minHeight: 25, flexibleHeight: 0);

            Text childLbl = UIFactory.CreateLabel(childFilterRow, "ChildLabel", "Child filter:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(childLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            GameObject childDropObj = UIFactory.CreateDropdown(childFilterRow, "ChildFilterDropdown", out Dropdown childDrop, null, 14, OnChildFilterDropChanged);
            foreach (string name in Enum.GetNames(typeof(ChildFilter)))
                childDrop.options.Add(new Dropdown.OptionData(name));
            UIFactory.SetLayoutElement(childDropObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            childFilterRow.SetActive(false);

            // Scene filter row

            sceneFilterRow = UIFactory.CreateHorizontalGroup(uiRoot, "SceneFilterRow", false, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(sceneFilterRow, minHeight: 25, flexibleHeight: 0);

            Text sceneLbl = UIFactory.CreateLabel(sceneFilterRow, "SceneLabel", "Scene filter:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(sceneLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            GameObject sceneDropObj = UIFactory.CreateDropdown(sceneFilterRow, "SceneFilterDropdown", out Dropdown sceneDrop, null, 14, OnSceneFilterDropChanged);
            foreach (string name in Enum.GetNames(typeof(SceneFilter)))
            {
                if (!SceneHandler.DontDestroyExists && name == "DontDestroyOnLoad")
                    continue;
                sceneDrop.options.Add(new Dropdown.OptionData(name));
            }
            UIFactory.SetLayoutElement(sceneDropObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            sceneFilterRow.SetActive(false);

            // Name filter input

            nameInputRow = UIFactory.CreateHorizontalGroup(uiRoot, "NameRow", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(nameInputRow, minHeight: 25, flexibleHeight: 0);

            Text nameLbl = UIFactory.CreateLabel(nameInputRow, "NameFilterLabel", "Name contains:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(nameLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            nameInputField = UIFactory.CreateInputField(nameInputRow, "NameFilterInput", "...");
            UIFactory.SetLayoutElement(nameInputField.UIRoot, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            // Search button

            ButtonRef searchButton = UIFactory.CreateButton(uiRoot, "SearchButton", "Search");
            UIFactory.SetLayoutElement(searchButton.Component.gameObject, minHeight: 25, flexibleHeight: 0);
            searchButton.OnClick += DoSearch;

            // Results count label

            GameObject resultsCountRow = UIFactory.CreateHorizontalGroup(uiRoot, "ResultsCountRow", true, true, true, true);
            UIFactory.SetLayoutElement(resultsCountRow, minHeight: 25, flexibleHeight: 0);

            resultsLabel = UIFactory.CreateLabel(resultsCountRow, "ResultsLabel", "0 results", TextAnchor.MiddleCenter);

            // RESULTS SCROLL POOL

            dataHandler = new ButtonListHandler<object, ButtonCell>(resultsScrollPool, GetEntries, SetCell, ShouldDisplayCell, OnCellClicked);
            resultsScrollPool = UIFactory.CreateScrollPool<ButtonCell>(uiRoot, "ResultsList", out GameObject scrollObj,
                out GameObject scrollContent);

            resultsScrollPool.Initialize(dataHandler);
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
        }
    }
}

```

`src/ObjectExplorer/SceneExplorer.cs`:

```cs
using System.Collections;
using UnityEngine.SceneManagement;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;

namespace UnityExplorer.ObjectExplorer
{
    public class SceneExplorer : UIModel
    {
        public ObjectExplorerPanel Parent { get; }

        public SceneExplorer(ObjectExplorerPanel parent)
        {
            Parent = parent;

            SceneHandler.OnInspectedSceneChanged += SceneHandler_OnInspectedSceneChanged;
            SceneHandler.OnLoadedScenesUpdated += SceneHandler_OnLoadedScenesUpdated;
        }

        public override GameObject UIRoot => uiRoot;
        private GameObject uiRoot;

        /// <summary>
        /// Whether to automatically update per auto-update interval or not.
        /// </summary>
        public bool AutoUpdate = false;

        public TransformTree Tree;
        private float timeOfLastUpdate = -1f;

        private GameObject refreshRow;
        private Dropdown sceneDropdown;
        private readonly Dictionary<Scene, Dropdown.OptionData> sceneToDropdownOption = new();

        // scene loader
        private Dropdown allSceneDropdown;
        private ButtonRef loadButton;
        private ButtonRef loadAdditiveButton;

        private IEnumerable<GameObject> GetRootEntries() => SceneHandler.CurrentRootObjects;

        public void Update()
        {
            if ((AutoUpdate || !SceneHandler.InspectingAssetScene) && timeOfLastUpdate.OccuredEarlierThan(1))
            {
                timeOfLastUpdate = Time.realtimeSinceStartup;
                UpdateTree();
            }
        }

        public void UpdateTree()
        {
            SceneHandler.Update();
            Tree.RefreshData(true, false, false, false);
        }

        public void JumpToTransform(Transform transform)
        {
            if (!transform)
                return;

            UIManager.SetPanelActive(this.Parent, true);
            this.Parent.SetTab(0);

            // select the transform's scene
            GameObject go = transform.gameObject;
            if (SceneHandler.SelectedScene != go.scene)
            {
                int idx;
                if (go.scene == default || go.scene.handle == -1)
                    idx = sceneDropdown.options.Count - 1;
                else
                    idx = sceneDropdown.options.IndexOf(sceneToDropdownOption[go.scene]);
                sceneDropdown.value = idx;
            }

            // Let the TransformTree handle the rest
            Tree.JumpAndExpandToTransform(transform);
        }

        private void OnSceneSelectionDropdownChanged(int value)
        {
            if (value < 0 || SceneHandler.LoadedScenes.Count <= value)
                return;

            SceneHandler.SelectedScene = SceneHandler.LoadedScenes[value];
            SceneHandler.Update();
            Tree.RefreshData(true, true, true, false);
            OnSelectedSceneChanged(SceneHandler.SelectedScene.Value);
        }

        private void SceneHandler_OnInspectedSceneChanged(Scene scene)
        {
            if (!sceneToDropdownOption.ContainsKey(scene))
                PopulateSceneDropdown(SceneHandler.LoadedScenes);

            if (sceneToDropdownOption.ContainsKey(scene))
            {
                Dropdown.OptionData opt = sceneToDropdownOption[scene];
                int idx = sceneDropdown.options.IndexOf(opt);
                if (sceneDropdown.value != idx)
                    sceneDropdown.value = idx;
                else
                    sceneDropdown.captionText.text = opt.text;
            }

            OnSelectedSceneChanged(scene);
        }

        private void OnSelectedSceneChanged(Scene scene)
        {
            if (refreshRow)
                refreshRow.SetActive(!scene.IsValid());
        }

        private void SceneHandler_OnLoadedScenesUpdated(List<Scene> loadedScenes)
        {
            PopulateSceneDropdown(loadedScenes);
        }

        private void PopulateSceneDropdown(List<Scene> loadedScenes)
        {
            sceneToDropdownOption.Clear();
            sceneDropdown.options.Clear();

            foreach (Scene scene in loadedScenes)
            {
                if (sceneToDropdownOption.ContainsKey(scene))
                    continue;

                string name = scene.name?.Trim();

                if (!scene.IsValid())
                    name = "HideAndDontSave";
                else if (string.IsNullOrEmpty(name))
                    name = "<untitled>";

                Dropdown.OptionData option = new(name);
                sceneDropdown.options.Add(option);
                sceneToDropdownOption.Add(scene, option);
            }
        }

        private void OnFilterInput(string input)
        {
            if ((!string.IsNullOrEmpty(input) && !Tree.Filtering) || (string.IsNullOrEmpty(input) && Tree.Filtering))
            {
                Tree.Clear();
            }

            Tree.CurrentFilter = input;
            Tree.RefreshData(true, false, true, false);
        }

        private void TryLoadScene(LoadSceneMode mode, Dropdown allSceneDrop)
        {
            string text = allSceneDrop.captionText.text;

            if (text == DEFAULT_LOAD_TEXT)
                return;

            try
            {
                SceneManager.LoadScene(text, mode);
                allSceneDrop.value = 0;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Unable to load the Scene! {ex.ReflectionExToString()}");
            }
        }

        public override void ConstructUI(GameObject content)
        {
            uiRoot = UIFactory.CreateUIObject("SceneExplorer", content);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(uiRoot, true, true, true, true, 0, 2, 2, 2, 2);
            UIFactory.SetLayoutElement(uiRoot, flexibleHeight: 9999);

            // Tool bar (top area)

            GameObject toolbar = UIFactory.CreateVerticalGroup(uiRoot, "Toolbar", true, true, true, true, 2, new Vector4(2, 2, 2, 2),
               new Color(0.15f, 0.15f, 0.15f));

            // Scene selector dropdown

            GameObject dropRow = UIFactory.CreateHorizontalGroup(toolbar, "DropdownRow", true, true, true, true, 5, default, new Color(1, 1, 1, 0));
            UIFactory.SetLayoutElement(dropRow, minHeight: 25, flexibleWidth: 9999);

            Text dropLabel = UIFactory.CreateLabel(dropRow, "SelectorLabel", "Scene:", TextAnchor.MiddleLeft, Color.cyan, false, 15);
            UIFactory.SetLayoutElement(dropLabel.gameObject, minHeight: 25, minWidth: 60, flexibleWidth: 0);

            GameObject dropdownObj = UIFactory.CreateDropdown(dropRow, "SceneDropdown", out sceneDropdown, "<notset>", 13, OnSceneSelectionDropdownChanged);
            UIFactory.SetLayoutElement(dropdownObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            SceneHandler.Update();
            PopulateSceneDropdown(SceneHandler.LoadedScenes);
            sceneDropdown.captionText.text = sceneToDropdownOption.First().Value.text;

            // Filter row

            GameObject filterRow = UIFactory.CreateHorizontalGroup(toolbar, "FilterGroup", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(filterRow, minHeight: 25, flexibleHeight: 0);

            //Filter input field
            InputFieldRef inputField = UIFactory.CreateInputField(filterRow, "FilterInput", "Search and press enter...");
            inputField.Component.targetGraphic.color = new Color(0.2f, 0.2f, 0.2f);
            RuntimeHelper.SetColorBlock(inputField.Component, new Color(0.4f, 0.4f, 0.4f), new Color(0.2f, 0.2f, 0.2f),
                new Color(0.08f, 0.08f, 0.08f));
            UIFactory.SetLayoutElement(inputField.UIRoot, minHeight: 25);
            //inputField.OnValueChanged += OnFilterInput;
            inputField.Component.GetOnEndEdit().AddListener(OnFilterInput);

            // refresh row

            refreshRow = UIFactory.CreateHorizontalGroup(toolbar, "RefreshGroup", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(refreshRow, minHeight: 30, flexibleHeight: 0);

            ButtonRef refreshButton = UIFactory.CreateButton(refreshRow, "RefreshButton", "Update");
            UIFactory.SetLayoutElement(refreshButton.Component.gameObject, minWidth: 65, flexibleWidth: 0);
            refreshButton.OnClick += UpdateTree;

            GameObject refreshToggle = UIFactory.CreateToggle(refreshRow, "RefreshToggle", out Toggle toggle, out Text text);
            UIFactory.SetLayoutElement(refreshToggle, flexibleWidth: 9999);
            text.text = "Auto-update (1 second)";
            text.alignment = TextAnchor.MiddleLeft;
            text.color = Color.white;
            text.fontSize = 12;
            toggle.isOn = false;
            toggle.onValueChanged.AddListener((bool val) => AutoUpdate = val);

            refreshRow.SetActive(false);

            // tree labels row

            GameObject labelsRow = UIFactory.CreateHorizontalGroup(toolbar, "LabelsRow", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(labelsRow, minHeight: 30, flexibleHeight: 0);

            Text nameLabel = UIFactory.CreateLabel(labelsRow, "NameLabel", "Name", TextAnchor.MiddleLeft, color: Color.grey);
            UIFactory.SetLayoutElement(nameLabel.gameObject, flexibleWidth: 9999, minHeight: 25);

            Text indexLabel = UIFactory.CreateLabel(labelsRow, "IndexLabel", "Sibling Index", TextAnchor.MiddleLeft, fontSize: 12, color: Color.grey);
            UIFactory.SetLayoutElement(indexLabel.gameObject, minWidth: 100, flexibleWidth: 0, minHeight: 25);

            // Transform Tree

            UniverseLib.UI.Widgets.ScrollView.ScrollPool<TransformCell> scrollPool = UIFactory.CreateScrollPool<TransformCell>(uiRoot, "TransformTree", out GameObject scrollObj,
                out GameObject scrollContent, new Color(0.11f, 0.11f, 0.11f));
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
            UIFactory.SetLayoutElement(scrollContent, flexibleHeight: 9999);

            Tree = new TransformTree(scrollPool, GetRootEntries, OnCellClicked);
            Tree.RefreshData(true, true, true, false);
            //scrollPool.Viewport.GetComponent<Mask>().enabled = false;
            //UIRoot.GetComponent<Mask>().enabled = false;

            // Scene Loader

            ConstructSceneLoader();

            RuntimeHelper.StartCoroutine(TempFixCoro());
        }

        void OnCellClicked(GameObject obj) => InspectorManager.Inspect(obj);

        // To "fix" a strange FPS drop issue with MelonLoader.
        private IEnumerator TempFixCoro()
        {
            float start = Time.realtimeSinceStartup;

            while (Time.realtimeSinceStartup - start < 2.5f)
                yield return null;

            // Select "HideAndDontSave" and then go back to first scene.
            this.sceneDropdown.value = sceneDropdown.options.Count - 1;
            this.sceneDropdown.value = 0;
        }

        private const string DEFAULT_LOAD_TEXT = "[Select a scene]";

        private void RefreshSceneLoaderOptions(string filter)
        {
            allSceneDropdown.options.Clear();
            allSceneDropdown.options.Add(new Dropdown.OptionData(DEFAULT_LOAD_TEXT));

            foreach (string scene in SceneHandler.AllSceneNames)
            {
                if (string.IsNullOrEmpty(filter) || scene.ContainsIgnoreCase(filter))
                    allSceneDropdown.options.Add(new Dropdown.OptionData(Path.GetFileNameWithoutExtension(scene)));
            }

            allSceneDropdown.RefreshShownValue();

            if (loadButton != null)
                RefreshSceneLoaderButtons();
        }

        private void RefreshSceneLoaderButtons()
        {
            string text = allSceneDropdown.captionText.text;
            if (text == DEFAULT_LOAD_TEXT)
            {
                loadButton.Component.interactable = false;
                loadAdditiveButton.Component.interactable = false;
            }
            else
            {
                loadButton.Component.interactable = true;
                loadAdditiveButton.Component.interactable = true;
            }
        }

        private void ConstructSceneLoader()
        {
            // Scene Loader
            try
            {
                if (SceneHandler.WasAbleToGetScenesInBuild)
                {
                    GameObject sceneLoaderObj = UIFactory.CreateVerticalGroup(uiRoot, "SceneLoader", true, true, true, true);
                    UIFactory.SetLayoutElement(sceneLoaderObj, minHeight: 25);

                    // Title

                    Text loaderTitle = UIFactory.CreateLabel(sceneLoaderObj, "SceneLoaderLabel", "Scene Loader", TextAnchor.MiddleLeft, Color.white, true, 14);
                    UIFactory.SetLayoutElement(loaderTitle.gameObject, minHeight: 25, flexibleHeight: 0);

                    // Search filter

                    InputFieldRef searchFilterObj = UIFactory.CreateInputField(sceneLoaderObj, "SearchFilterInput", "Filter scene names...");
                    UIFactory.SetLayoutElement(searchFilterObj.UIRoot, minHeight: 25, flexibleHeight: 0);
                    searchFilterObj.OnValueChanged += RefreshSceneLoaderOptions;

                    // Dropdown

                    GameObject allSceneDropObj = UIFactory.CreateDropdown(sceneLoaderObj, "SceneLoaderDropdown", out allSceneDropdown, "", 14, null);
                    UIFactory.SetLayoutElement(allSceneDropObj, minHeight: 25, minWidth: 150, flexibleWidth: 0, flexibleHeight: 0);

                    RefreshSceneLoaderOptions(string.Empty);

                    // Button row

                    GameObject buttonRow = UIFactory.CreateHorizontalGroup(sceneLoaderObj, "LoadButtons", true, true, true, true, 4);

                    loadButton = UIFactory.CreateButton(buttonRow, "LoadSceneButton", "Load (Single)", new Color(0.1f, 0.3f, 0.3f));
                    UIFactory.SetLayoutElement(loadButton.Component.gameObject, minHeight: 25, minWidth: 150);
                    loadButton.OnClick += () =>
                    {
                        TryLoadScene(LoadSceneMode.Single, allSceneDropdown);
                    };

                    loadAdditiveButton = UIFactory.CreateButton(buttonRow, "LoadSceneButton", "Load (Additive)", new Color(0.1f, 0.3f, 0.3f));
                    UIFactory.SetLayoutElement(loadAdditiveButton.Component.gameObject, minHeight: 25, minWidth: 150);
                    loadAdditiveButton.OnClick += () =>
                    {
                        TryLoadScene(LoadSceneMode.Additive, allSceneDropdown);
                    };

                    Color disabledColor = new(0.24f, 0.24f, 0.24f);
                    RuntimeHelper.SetColorBlock(loadButton.Component, disabled: disabledColor);
                    RuntimeHelper.SetColorBlock(loadAdditiveButton.Component, disabled: disabledColor);

                    loadButton.Component.interactable = false;
                    loadAdditiveButton.Component.interactable = false;

                    allSceneDropdown.onValueChanged.AddListener((int val) =>
                    {
                        RefreshSceneLoaderButtons();
                    });
                }
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Could not create the Scene Loader helper! {ex.ReflectionExToString()}");
            }
        }
    }
}

```

`src/ObjectExplorer/SceneHandler.cs`:

```cs
using UnityEngine.SceneManagement;

namespace UnityExplorer.ObjectExplorer
{
    public static class SceneHandler
    {
        /// <summary>The currently inspected Scene.</summary>
        public static Scene? SelectedScene
        {
            get => selectedScene;
            internal set
            {
                if (selectedScene.HasValue && selectedScene == value)
                    return;
                selectedScene = value;
                OnInspectedSceneChanged?.Invoke((Scene)selectedScene);
            }
        }
        private static Scene? selectedScene;

        /// <summary>The GameObjects in the currently inspected scene.</summary>
        public static IEnumerable<GameObject> CurrentRootObjects { get; private set; } = new GameObject[0];

        /// <summary>All currently loaded Scenes.</summary>
        public static List<Scene> LoadedScenes { get; private set; } = new();
        //private static HashSet<Scene> previousLoadedScenes;

        /// <summary>The names of all scenes in the build settings, if they could be retrieved.</summary>
        public static List<string> AllSceneNames { get; private set; } = new();

        /// <summary>Invoked when the currently inspected Scene changes. The argument is the new scene.</summary>
        public static event Action<Scene> OnInspectedSceneChanged;

        /// <summary>Invoked whenever the list of currently loaded Scenes changes. The argument contains all loaded scenes after the change.</summary>
        public static event Action<List<Scene>> OnLoadedScenesUpdated;

        /// <summary>Generally will be 2, unless DontDestroyExists == false, then this will be 1.</summary>
        internal static int DefaultSceneCount => 1 + (DontDestroyExists ? 1 : 0);

        /// <summary>Whether or not we are currently inspecting the "HideAndDontSave" asset scene.</summary>
        public static bool InspectingAssetScene => SelectedScene.HasValue && SelectedScene.Value.handle == -1;

        /// <summary>Whether or not we successfuly retrieved the names of the scenes in the build settings.</summary>
        public static bool WasAbleToGetScenesInBuild { get; private set; }

        /// <summary>Whether or not the "DontDestroyOnLoad" scene exists in this game.</summary>
        public static bool DontDestroyExists { get; private set; }

        internal static void Init()
        {
            // Check if the game has "DontDestroyOnLoad"
            DontDestroyExists = Scene.GetNameInternal(-12) == "DontDestroyOnLoad";

            // Try to get all scenes in the build settings. This may not work.
            try
            {
                Type sceneUtil = ReflectionUtility.GetTypeByName("UnityEngine.SceneManagement.SceneUtility");
                if (sceneUtil == null)
                    throw new Exception("This version of Unity does not ship with the 'SceneUtility' class, or it was not unstripped.");

                System.Reflection.MethodInfo method = sceneUtil.GetMethod("GetScenePathByBuildIndex", ReflectionUtility.FLAGS);
                int sceneCount = SceneManager.sceneCountInBuildSettings;
                for (int i = 0; i < sceneCount; i++)
                {
                    string scenePath = (string)method.Invoke(null, new object[] { i });
                    AllSceneNames.Add(scenePath);
                }

                WasAbleToGetScenesInBuild = true;
            }
            catch (Exception ex)
            {
                WasAbleToGetScenesInBuild = false;
                ExplorerCore.LogWarning($"Unable to generate list of all Scenes in the build: {ex}");
            }
        }

        internal static void Update()
        {
            // Inspected scene will exist if it's DontDestroyOnLoad or HideAndDontSave
            bool inspectedExists =
                SelectedScene.HasValue
                && ((DontDestroyExists && SelectedScene.Value.handle == -12)
                    || SelectedScene.Value.handle == -1);

            LoadedScenes.Clear();

            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene scene = SceneManager.GetSceneAt(i);
                if (scene == default || !scene.isLoaded || !scene.IsValid())
                    continue;

                // If we have not yet confirmed inspectedExists, check if this scene is our currently inspected one.
                if (!inspectedExists && scene == SelectedScene)
                    inspectedExists = true;

                LoadedScenes.Add(scene);
            }

            if (DontDestroyExists)
                LoadedScenes.Add(new Scene { m_Handle = -12 });
            LoadedScenes.Add(new Scene { m_Handle = -1 });

            // Default to first scene if none selected or previous selection no longer exists.
            if (!inspectedExists)
                SelectedScene = LoadedScenes.First();

            // Notify on the list changing at all
            OnLoadedScenesUpdated?.Invoke(LoadedScenes);

            // Finally, update the root objects list.
            if (SelectedScene != null && ((Scene)SelectedScene).IsValid())
                CurrentRootObjects = RuntimeHelper.GetRootGameObjects((Scene)SelectedScene);
            else
            {
                UnityEngine.Object[] allObjects = RuntimeHelper.FindObjectsOfTypeAll(typeof(GameObject));
                List<GameObject> objects = new();
                foreach (UnityEngine.Object obj in allObjects)
                {
                    GameObject go = obj.TryCast<GameObject>();
                    if (go.transform.parent == null && !go.scene.IsValid())
                        objects.Add(go);
                }
                CurrentRootObjects = objects;
            }
        }
    }
}

```

`src/ObjectExplorer/SearchProvider.cs`:

```cs
using UnityEngine.SceneManagement;

namespace UnityExplorer.ObjectExplorer
{
    public enum SearchContext
    {
        UnityObject,
        Singleton,
        Class
    }

    public enum ChildFilter
    {
        Any,
        RootObject,
        HasParent
    }

    public enum SceneFilter
    {
        Any,
        ActivelyLoaded,
        DontDestroyOnLoad,
        HideAndDontSave,
    }

    public static class SearchProvider
    {
        private static bool Filter(Scene scene, SceneFilter filter)
        {
            return filter switch
            {
                SceneFilter.Any => true,
                SceneFilter.DontDestroyOnLoad => scene.handle == -12,
                SceneFilter.HideAndDontSave => scene == default,
                SceneFilter.ActivelyLoaded => scene.buildIndex != -1,
                _ => false,
            };
        }

        internal static List<object> UnityObjectSearch(string input, string customTypeInput, ChildFilter childFilter, SceneFilter sceneFilter)
        {
            List<object> results = new();

            Type searchType = null;
            if (!string.IsNullOrEmpty(customTypeInput))
            {
                if (ReflectionUtility.GetTypeByName(customTypeInput) is Type customType)
                {
                    if (typeof(UnityEngine.Object).IsAssignableFrom(customType))
                        searchType = customType;
                    else
                        ExplorerCore.LogWarning($"Custom type '{customType.FullName}' is not assignable from UnityEngine.Object!");
                }
                else
                    ExplorerCore.LogWarning($"Could not find any type by name '{customTypeInput}'!");
            }

            if (searchType == null)
                searchType = typeof(UnityEngine.Object);

            UnityEngine.Object[] allObjects = RuntimeHelper.FindObjectsOfTypeAll(searchType);

            // perform filter comparers

            string nameFilter = null;
            if (!string.IsNullOrEmpty(input))
                nameFilter = input;

            bool shouldFilterGOs = searchType == typeof(GameObject) || typeof(Component).IsAssignableFrom(searchType);

            foreach (UnityEngine.Object obj in allObjects)
            {
                // name check
                if (!string.IsNullOrEmpty(nameFilter) && !obj.name.ContainsIgnoreCase(nameFilter))
                    continue;

                GameObject go = null;
                Type type = obj.GetActualType();

                if (type == typeof(GameObject))
                    go = obj.TryCast<GameObject>();
                else if (typeof(Component).IsAssignableFrom(type))
                    go = obj.TryCast<Component>()?.gameObject;

                if (go)
                {
                    // hide unityexplorer objects
                    if (go.transform.root.name == "UniverseLibCanvas")
                        continue;

                    if (shouldFilterGOs)
                    {
                        // scene check
                        if (sceneFilter != SceneFilter.Any)
                        {
                            if (!Filter(go.scene, sceneFilter))
                                continue;
                        }

                        if (childFilter != ChildFilter.Any)
                        {
                            if (!go)
                                continue;

                            // root object check (no parent)
                            if (childFilter == ChildFilter.HasParent && !go.transform.parent)
                                continue;
                            else if (childFilter == ChildFilter.RootObject && go.transform.parent)
                                continue;
                        }
                    }
                }

                results.Add(obj);
            }

            return results;
        }

        internal static List<object> ClassSearch(string input)
        {
            List<object> list = new();

            string nameFilter = "";
            if (!string.IsNullOrEmpty(input))
                nameFilter = input;

            foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                foreach (Type type in asm.GetTypes())
                {
                    if (!string.IsNullOrEmpty(nameFilter) && !type.FullName.ContainsIgnoreCase(nameFilter))
                        continue;
                    list.Add(type);
                }
            }

            return list;
        }

        internal static string[] instanceNames = new string[]
        {
            "m_instance",
            "m_Instance",
            "s_instance",
            "s_Instance",
            "_instance",
            "_Instance",
            "instance",
            "Instance",
            "<Instance>k__BackingField",
            "<instance>k__BackingField",
        };

        internal static List<object> InstanceSearch(string input)
        {
            List<object> instances = new();

            string nameFilter = "";
            if (!string.IsNullOrEmpty(input))
                nameFilter = input;

            BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static;

            foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                // Search all non-static, non-enum classes.
                foreach (Type type in asm.GetTypes().Where(it => !(it.IsSealed && it.IsAbstract) && !it.IsEnum))
                {
                    try
                    {
                        if (!string.IsNullOrEmpty(nameFilter) && !type.FullName.ContainsIgnoreCase(nameFilter))
                            continue;

                        ReflectionUtility.FindSingleton(instanceNames, type, flags, instances);
                    }
                    catch { }
                }
            }

            return instances;
        }

    }
}

```

`src/Properties/AssemblyInfo.cs`:

```cs
using System.Runtime.InteropServices;
using UnityExplorer;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle(ExplorerCore.NAME)]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany(ExplorerCore.AUTHOR)]
[assembly: AssemblyProduct(ExplorerCore.NAME)]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b21dbde3-5d6f-4726-93ab-cc3cc68bae7d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion(ExplorerCore.VERSION)]
[assembly: AssemblyFileVersion(ExplorerCore.VERSION)]

```

`src/Runtime/Il2CppHelper.cs`:

```cs
#if CPP
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace UnityExplorer.Runtime
{
    public class Il2CppHelper : UERuntimeHelper
    {
        public override void SetupEvents()
        {
            try
            {
                Application.add_logMessageReceived(new Action<string, string, LogType>(Application_logMessageReceived));
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting up Unity log listener, make sure Unity libraries have been unstripped!");
                ExplorerCore.Log(ex);
            }
        }

        private void Application_logMessageReceived(string condition, string stackTrace, LogType type)
        {
            ExplorerCore.LogUnity(condition, type);
        }

        public override string[] DefaultReflectionBlacklist => defaultIl2CppBlacklist.ToArray();

        // These methods currently cause a crash in most il2cpp games,
        // even from doing "GetParameters()" on the MemberInfo.
        // Blacklisting until the issue is fixed in Unhollower.
        public static HashSet<string> defaultIl2CppBlacklist = new()
        {
            // These were deprecated a long time ago, still show up in some IL2CPP games for some reason
            "UnityEngine.MonoBehaviour.allowPrefabModeInPlayMode",
            "UnityEngine.MonoBehaviour.runInEditMode",
            "UnityEngine.Component.animation",
            "UnityEngine.Component.audio",
            "UnityEngine.Component.camera",
            "UnityEngine.Component.collider",
            "UnityEngine.Component.collider2D",
            "UnityEngine.Component.constantForce",
            "UnityEngine.Component.hingeJoint",
            "UnityEngine.Component.light",
            "UnityEngine.Component.networkView",
            "UnityEngine.Component.particleSystem",
            "UnityEngine.Component.renderer",
            "UnityEngine.Component.rigidbody",
            "UnityEngine.Component.rigidbody2D",
            "UnityEngine.Light.flare",
            // These can cause a crash in IL2CPP
            "Il2CppSystem.Type.DeclaringMethod",
            "Il2CppSystem.RuntimeType.DeclaringMethod",
            "Unity.Jobs.LowLevel.Unsafe.JobsUtility.CreateJobReflectionData",
            "Unity.Profiling.ProfilerRecorder.CopyTo",
            "Unity.Profiling.ProfilerRecorder.StartNew",
            "UnityEngine.Analytics.Analytics.RegisterEvent",
            "UnityEngine.Analytics.Analytics.SendEvent",
            "UnityEngine.Analytics.ContinuousEvent+ConfigureEventDelegate.Invoke",
            "UnityEngine.Analytics.ContinuousEvent.ConfigureEvent",
            "UnityEngine.Animations.AnimationLayerMixerPlayable.Create",
            "UnityEngine.Animations.AnimationLayerMixerPlayable.CreateHandle",
            "UnityEngine.Animations.AnimationMixerPlayable.Create",
            "UnityEngine.Animations.AnimationMixerPlayable.CreateHandle",
            "UnityEngine.AssetBundle.RecompressAssetBundleAsync",
            "UnityEngine.Audio.AudioMixerPlayable.Create",
            "UnityEngine.BoxcastCommand.ScheduleBatch",
            "UnityEngine.Camera.CalculateProjectionMatrixFromPhysicalProperties",
            "UnityEngine.Canvas.renderingDisplaySize",
            "UnityEngine.CapsulecastCommand.ScheduleBatch",
            "UnityEngine.Collider2D.Cast",
            "UnityEngine.Collider2D.Raycast",
            "UnityEngine.ComputeBuffer+BeginBufferWriteDelegate.Invoke",
            "UnityEngine.ComputeBuffer+EndBufferWriteDelegate.Invoke",
            "UnityEngine.ComputeBuffer.BeginBufferWrite",
            "UnityEngine.ComputeBuffer.EndBufferWrite",
            "UnityEngine.Cubemap+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.Cubemap+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.Cubemap.SetPixelDataImpl",
            "UnityEngine.Cubemap.SetPixelDataImplArray",
            "UnityEngine.CubemapArray+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.CubemapArray+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.CubemapArray.SetPixelDataImpl",
            "UnityEngine.CubemapArray.SetPixelDataImplArray",
            "UnityEngine.Experimental.Playables.MaterialEffectPlayable.Create",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure+AddInstanceDelegate.Invoke",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure+AddInstance_Procedural_InjectedDelegate.Invoke",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure.AddInstance",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure.AddInstance_Procedural",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure.AddInstance_Procedural_Injected",
            "UnityEngine.Experimental.Rendering.RayTracingShader+DispatchDelegate.Invoke",
            "UnityEngine.Experimental.Rendering.RayTracingShader.Dispatch",
            "UnityEngine.Experimental.Rendering.RenderPassAttachment.Clear",
            "UnityEngine.GUI.DoButtonGrid",
            "UnityEngine.GUI.Slider",
            "UnityEngine.GUI.Toolbar",
            "UnityEngine.Graphics.DrawMeshInstancedIndirect",
            "UnityEngine.Graphics.DrawMeshInstancedProcedural",
            "UnityEngine.Graphics.DrawProcedural",
            "UnityEngine.Graphics.DrawProceduralIndirect",
            "UnityEngine.Graphics.DrawProceduralIndirectNow",
            "UnityEngine.Graphics.DrawProceduralNow",
            "UnityEngine.LineRenderer+BakeMeshDelegate.Invoke",
            "UnityEngine.LineRenderer.BakeMesh",
            "UnityEngine.Mesh.GetIndices",
            "UnityEngine.Mesh.GetTriangles",
            "UnityEngine.Mesh.SetIndices",
            "UnityEngine.Mesh.SetTriangles",
            "UnityEngine.Physics2D.BoxCast",
            "UnityEngine.Physics2D.CapsuleCast",
            "UnityEngine.Physics2D.CircleCast",
            "UnityEngine.PhysicsScene.BoxCast",
            "UnityEngine.PhysicsScene.CapsuleCast",
            "UnityEngine.PhysicsScene.OverlapBox",
            "UnityEngine.PhysicsScene.OverlapCapsule",
            "UnityEngine.PhysicsScene.SphereCast",
            "UnityEngine.PhysicsScene2D.BoxCast",
            "UnityEngine.PhysicsScene2D.CapsuleCast",
            "UnityEngine.PhysicsScene2D.CircleCast",
            "UnityEngine.PhysicsScene2D.GetRayIntersection",
            "UnityEngine.PhysicsScene2D.Linecast",
            "UnityEngine.PhysicsScene2D.OverlapArea",
            "UnityEngine.PhysicsScene2D.OverlapBox",
            "UnityEngine.PhysicsScene2D.OverlapCapsule",
            "UnityEngine.PhysicsScene2D.OverlapCircle",
            "UnityEngine.PhysicsScene2D.OverlapCollider",
            "UnityEngine.PhysicsScene2D.OverlapPoint",
            "UnityEngine.PhysicsScene2D.Raycast",
            "UnityEngine.Playables.Playable.Create",
            "UnityEngine.Profiling.CustomSampler.Create",
            "UnityEngine.RaycastCommand.ScheduleBatch",
            "UnityEngine.RemoteConfigSettings+QueueConfigDelegate.Invoke",
            "UnityEngine.RemoteConfigSettings.QueueConfig",
            "UnityEngine.RenderTexture.GetTemporaryImpl",
            "UnityEngine.Rendering.AsyncGPUReadback.Request",
            "UnityEngine.Rendering.AttachmentDescriptor.ConfigureClear",
            "UnityEngine.Rendering.BatchRendererGroup+AddBatch_InjectedDelegate.Invoke",
            "UnityEngine.Rendering.BatchRendererGroup.AddBatch",
            "UnityEngine.Rendering.BatchRendererGroup.AddBatch_Injected",
            "UnityEngine.Rendering.CommandBuffer+Internal_DispatchRaysDelegate.Invoke",
            "UnityEngine.Rendering.CommandBuffer.DispatchRays",
            "UnityEngine.Rendering.CommandBuffer.DrawMeshInstancedProcedural",
            "UnityEngine.Rendering.CommandBuffer.Internal_DispatchRays",
            "UnityEngine.Rendering.CommandBuffer.ResolveAntiAliasedSurface",
            "UnityEngine.Rendering.ScriptableRenderContext.BeginRenderPass",
            "UnityEngine.Rendering.ScriptableRenderContext.BeginScopedRenderPass",
            "UnityEngine.Rendering.ScriptableRenderContext.BeginScopedSubPass",
            "UnityEngine.Rendering.ScriptableRenderContext.BeginSubPass",
            "UnityEngine.Rendering.ScriptableRenderContext.SetupCameraProperties",
            "UnityEngine.Rigidbody2D.Cast",
            "UnityEngine.Scripting.GarbageCollector+CollectIncrementalDelegate.Invoke",
            "UnityEngine.Scripting.GarbageCollector.CollectIncremental",
            "UnityEngine.SpherecastCommand.ScheduleBatch",
            "UnityEngine.Texture.GetPixelDataSize",
            "UnityEngine.Texture.GetPixelDataOffset",
            "UnityEngine.Texture.GetPixelDataOffset",
            "UnityEngine.Texture2D+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.Texture2D+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.Texture2D.SetPixelDataImpl",
            "UnityEngine.Texture2D.SetPixelDataImplArray",
            "UnityEngine.Texture2DArray+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.Texture2DArray+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.Texture2DArray.SetPixelDataImpl",
            "UnityEngine.Texture2DArray.SetPixelDataImplArray",
            "UnityEngine.Texture3D+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.Texture3D+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.Texture3D.SetPixelDataImpl",
            "UnityEngine.Texture3D.SetPixelDataImplArray",
            "UnityEngine.TrailRenderer+BakeMeshDelegate.Invoke",
            "UnityEngine.TrailRenderer.BakeMesh",
            "UnityEngine.WWW.LoadFromCacheOrDownload",
            "UnityEngine.XR.InputDevice.SendHapticImpulse",
        };
    }
}

#endif
```

`src/Runtime/MonoHelper.cs`:

```cs
#if MONO

namespace UnityExplorer.Runtime
{
    public class MonoHelper : UERuntimeHelper
    {
        public override void SetupEvents()
        {
            Application.logMessageReceived += Application_logMessageReceived;
        }

        private void Application_logMessageReceived(string condition, string stackTrace, LogType type)
             => ExplorerCore.LogUnity(condition, type);
    }
}

#endif
```

`src/Runtime/UERuntimeHelper.cs`:

```cs
using UnityExplorer.Config;

namespace UnityExplorer.Runtime
{
    // Not really that necessary anymore, can eventually just be refactored away into the few classes that use this class.

    public abstract class UERuntimeHelper
    {
        public static UERuntimeHelper Instance;

        public static void Init()
        {
#if CPP
            Instance = new Il2CppHelper();
#else
            Instance = new MonoHelper();
#endif
            Instance.SetupEvents();

            LoadBlacklistString(ConfigManager.Reflection_Signature_Blacklist.Value);
            ConfigManager.Reflection_Signature_Blacklist.OnValueChanged += (string val) =>
            {
                LoadBlacklistString(val);
            };
        }

        public abstract void SetupEvents();

        private static readonly HashSet<string> currentBlacklist = new();

        public virtual string[] DefaultReflectionBlacklist => new string[0];

        public static void LoadBlacklistString(string blacklist)
        {
            try
            {
                if (string.IsNullOrEmpty(blacklist) && !Instance.DefaultReflectionBlacklist.Any())
                    return;

                try
                {
                    string[] sigs = blacklist.Split(';');
                    foreach (string sig in sigs)
                    {
                        string s = sig.Trim();
                        if (string.IsNullOrEmpty(s))
                            continue;
                        if (!currentBlacklist.Contains(s))
                            currentBlacklist.Add(s);
                    }
                }
                catch (Exception ex)
                {
                    ExplorerCore.LogWarning($"Exception parsing blacklist string: {ex.ReflectionExToString()}");
                }

                foreach (string sig in Instance.DefaultReflectionBlacklist)
                {
                    if (!currentBlacklist.Contains(sig))
                        currentBlacklist.Add(sig);
                }

                Mono.CSharp.IL2CPP.Blacklist.SignatureBlacklist = currentBlacklist;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting up reflection blacklist: {ex.ReflectionExToString()}");
            }
        }

        public static bool IsBlacklisted(MemberInfo member)
        {
            if (string.IsNullOrEmpty(member.DeclaringType?.Namespace))
                return false;

            string sig = $"{member.DeclaringType.FullName}.{member.Name}";

            return currentBlacklist.Contains(sig);
        }
    }
}

```

`src/Runtime/UnityCrashPrevention.cs`:

```cs
namespace UnityExplorer.Runtime
{
    internal static class UnityCrashPrevention
    {
        static readonly HarmonyLib.Harmony harmony = new($"{ExplorerCore.GUID}.crashprevention");

        internal static void Init()
        {
            TryPatch<Canvas>("get_renderingDisplaySize", nameof(Canvas_renderingDisplaySize_Prefix));

            IEnumerable<MethodBase> patched = harmony.GetPatchedMethods();
            if (patched.Any())
                ExplorerCore.Log(
                    $"Initialized UnityCrashPrevention for: {string.Join(", ", patched.Select(it => $"{it.DeclaringType.Name}.{it.Name}").ToArray())}");
        }

        internal static void TryPatch<T>(string orig, string prefix, Type[] argTypes = null)
        {
            try
            {
                harmony.Patch(
                    HarmonyLib.AccessTools.Method(typeof(T), orig, argTypes),
                    new HarmonyLib.HarmonyMethod(HarmonyLib.AccessTools.Method(typeof(UnityCrashPrevention), prefix)));
            }
            catch //(Exception ex)
            {
                //ExplorerCore.Log($"Exception patching {typeof(T).Name}.{orig}: {ex}");
            }
        }

        // In Unity 2020 they introduced "Canvas.renderingDisplaySize".
        // If you try to get the value on a Canvas which has a renderMode value of WorldSpace and no worldCamera set,
        // the game will Crash (I think from Unity trying to read from null ptr).
        internal static void Canvas_renderingDisplaySize_Prefix(Canvas __instance)
        {
            if (__instance.renderMode == RenderMode.WorldSpace && !__instance.worldCamera)
                throw new InvalidOperationException("Canvas is set to RenderMode.WorldSpace but not worldCamera is set.");
        }
    }
}

```

`src/Tests/TestClass.cs`:

```cs
using System.Collections;
#if CPP
#if INTEROP
using Il2CppInterop.Runtime.InteropTypes.Arrays;
using Il2CppInterop.Runtime;
#else
using UnhollowerRuntimeLib;
using UnhollowerBaseLib;
#endif
#endif

namespace UnityExplorer.Tests
{
    public class TestClass
    {
        static TestClass()
        {
            Init_Mono();
#if CPP
            Init_IL2CPP();
#endif
        }

        #region MONO

        public static object LiterallyAnything = null;

        public static string Exception
        {
            get
            {
                if (!shouldThrow)
                {
                    shouldThrow = true;
                    throw new Exception("This is a test.");
                }
                else
                {
                    shouldThrow = false;
                    return "No exception";
                }
            }
        }
        static bool shouldThrow;

        // Test enumerables
        public static int[,,] MultiDimensionalArray = new int[45, 45, 45];
        public static List<object> ListOfInts;
        public static List<List<List<string>>> NestedList;
        public static IDictionary MixedDictionary;
        public static Hashtable Hashtable;
        public static byte[] ByteArray = new byte[16];
        public static List<short> ABigList = new(10000);

        // Test const behaviour (should be a readonly field)
        public const int ConstantInt5 = 5;

        // Testing other InteractiveValues
        public static BindingFlags EnumTest;
        public static CameraClearFlags EnumTest2;
        public static Color Color = Color.magenta;
        public static Color32 Color32 = Color.red;
        public static string ALongString = new('#', 10000);

        public static float[] AParseTest(ref List<float[,,]> arg0, ref float[,] arg1)
        {
            return new float[] { 1, 2, 3 };
        }

        public static List<object> RandomList
        {
            get
            {
                List<object> list = new();
                int count = UnityEngine.Random.Range(0, 100);
                for (int i = 0; i < count; i++)
                    list.Add(GetRandomObject());
                return list;
            }
        }

        public int this[int index]
        {
            get => UnityEngine.Random.Range(0, int.MaxValue);
            set => ExplorerCore.Log(index);
        }

        // Test methods

        private static object GetRandomObject()
        {
            return UnityEngine.Random.Range(0, 7) switch
            {
                0 => null,
                1 => 123,
                2 => true,
                3 => "hello",
                4 => 50.5f,
                5 => CameraClearFlags.Color,
                6 => new List<string> { "one", "two" },
                _ => null,
            };
        }

        public static void TestComponent<T>() where T : Component
        {
            ExplorerCore.Log($"Test3 {typeof(T).FullName}");
        }

        public static void TestArgumentParse(string _string,
                                             int integer,
                                             Color color,
                                             CameraClearFlags flags,
                                             Vector3 vector,
                                             Quaternion quaternion,
                                             object obj,
                                             Type type,
                                             GameObject go)
        {
            ExplorerCore.Log($"_string: {_string}, integer: {integer}, color: {color.ToString()}, flags: {flags}, " +
                $"vector: {vector.ToString()}, quaternion: {quaternion.ToString()}, obj: {obj?.ToString() ?? "null"}," +
                $"type: {type?.FullName ?? "null"}, go: {go?.ToString() ?? "null"}");
        }

        private static void Init_Mono()
        {
            ExplorerCore.Log($"1: Basic list");
            ListOfInts = new List<object> { 1, 2, 3, 4, 5 };

            ExplorerCore.Log($"2: Nested list");
            NestedList = new List<List<List<string>>>
            {
                new List<List<string>> {
                    new List<string> { "1", "2", "3" },
                    new List<string> { "4", "5", "6" },
                },
                new List<List<string>>
                {
                    new List<string> { "7", "8", "9" }
                }
            };

            ExplorerCore.Log($"3: Dictionary");
            MixedDictionary = new Dictionary<object, object>
            {
                { 1, 2 },
                { "one", "two" },
                { true, false },
                { new Vector3(0,1,2), new Vector3(1,2,3) },
                { CameraClearFlags.Depth, CameraClearFlags.Color },
                { "################################################\r\n##########", null },
                { "subdict", new Dictionary<object,object> { { "key", "value" } } }
            };

            ExplorerCore.Log($"4: Hashtable");
            Hashtable = new Hashtable { { "One", 1 }, { "Two", 2 } };

            ExplorerCore.Log($"5: Big list");
            for (int i = 0; i < ABigList.Capacity; i++)
                ABigList.Add((short)UnityEngine.Random.Range(0, short.MaxValue));

            ExplorerCore.Log("Finished TestClass Init_Mono");
        }

        #endregion

#if CPP
        public static Il2CppSystem.Collections.Generic.Dictionary<string, string> IL2CPP_Dict;
        public static Il2CppSystem.Collections.Generic.HashSet<string> IL2CPP_HashSet;
        public static Il2CppSystem.Collections.Generic.List<string> IL2CPP_ListString;
        public static Il2CppSystem.Collections.Hashtable IL2CPP_HashTable;
        public static List<Il2CppSystem.Object> IL2CPP_listOfBoxedObjects;
        public static Il2CppStructArray<int> IL2CPP_structArray;
        public static Il2CppReferenceArray<Il2CppSystem.Object> IL2CPP_ReferenceArray;
        public static Il2CppSystem.Collections.IDictionary IL2CPP_IDict;
        public static Il2CppSystem.Collections.IList IL2CPP_IList;
        public static Dictionary<Il2CppSystem.Object, Il2CppSystem.Object> IL2CPP_BoxedDict;
        public static Il2CppSystem.Array IL2CPP_NonGenericArray;

        public static Il2CppSystem.Object IL2CPP_BoxedInt;
        public static Il2CppSystem.Int32 IL2CPP_Int;
        public static Il2CppSystem.Decimal IL2CPP_Decimal;
        public static Il2CppSystem.Object IL2CPP_DecimalBoxed;
        public static Il2CppSystem.Object IL2CPP_Vector3Boxed;
        public static string IL2CPP_systemString = "Test";
        public static Il2CppSystem.Object IL2CPP_objectString = "string boxed as cpp object";
        public static Il2CppSystem.String IL2CPP_il2cppString = "string boxed as cpp string";
        public static string nullString = null;

        private static void Init_IL2CPP()
        {
            ExplorerCore.Log("IL2CPP 0: Non-generic array");
            IL2CPP_NonGenericArray = new Il2CppStructArray<int>(5).TryCast<Il2CppSystem.Array>();

            ExplorerCore.Log($"IL2CPP 1: Il2Cpp Dictionary<string, string>");
            IL2CPP_Dict = new Il2CppSystem.Collections.Generic.Dictionary<string, string>();
            IL2CPP_Dict.Add("key1", "value1");
            IL2CPP_Dict.Add("key2", "value2");
            IL2CPP_Dict.Add("key3", "value3");

            ExplorerCore.Log($"IL2CPP 6: Il2Cpp HashSet of strings");
            IL2CPP_HashSet = new Il2CppSystem.Collections.Generic.HashSet<string>();
            IL2CPP_HashSet.Add("one");
            IL2CPP_HashSet.Add("two");

            ExplorerCore.Log($"IL2CPP 2: Il2Cpp Hashtable");
            IL2CPP_HashTable = new Il2CppSystem.Collections.Hashtable();
            IL2CPP_HashTable.Add("key1", "value1");
            IL2CPP_HashTable.Add("key2", "value2");
            IL2CPP_HashTable.Add("key3", "value3");

            ExplorerCore.Log($"IL2CPP 3: Il2Cpp IDictionary");
            Il2CppSystem.Collections.Generic.Dictionary<string, string> dict2 = new Il2CppSystem.Collections.Generic.Dictionary<string, string>();
            dict2.Add("key1", "value1");
            IL2CPP_IDict = dict2.TryCast<Il2CppSystem.Collections.IDictionary>();

            ExplorerCore.Log($"IL2CPP 4: Il2Cpp List of Il2Cpp Object");
            Il2CppSystem.Collections.Generic.List<Il2CppSystem.Object> list = new Il2CppSystem.Collections.Generic.List<Il2CppSystem.Object>(5);
            list.Add("one");
            list.Add("two");
            IL2CPP_IList = list.TryCast<Il2CppSystem.Collections.IList>();

            ExplorerCore.Log($"IL2CPP 5: Il2Cpp List of strings");
            IL2CPP_ListString = new Il2CppSystem.Collections.Generic.List<string>();
            IL2CPP_ListString.Add("hello,");
            IL2CPP_ListString.Add("world!");


            ExplorerCore.Log($"IL2CPP 7: Dictionary of Il2Cpp String and Il2Cpp Object");
            IL2CPP_BoxedDict = new();
            IL2CPP_BoxedDict[(Il2CppSystem.String)"one"] = new Il2CppSystem.Int32 { m_value = 1 }.BoxIl2CppObject();
            IL2CPP_BoxedDict[(Il2CppSystem.String)"two"] = new Il2CppSystem.Int32 { m_value = 2 }.BoxIl2CppObject();
            IL2CPP_BoxedDict[(Il2CppSystem.String)"three"] = new Il2CppSystem.Int32 { m_value = 3 }.BoxIl2CppObject();
            IL2CPP_BoxedDict[(Il2CppSystem.String)"four"] = new Il2CppSystem.Int32 { m_value = 4 }.BoxIl2CppObject();

            ExplorerCore.Log($"IL2CPP 8: List of boxed Il2Cpp Objects");
            IL2CPP_listOfBoxedObjects = new List<Il2CppSystem.Object>();
            IL2CPP_listOfBoxedObjects.Add((Il2CppSystem.String)"boxedString");
            IL2CPP_listOfBoxedObjects.Add(new Il2CppSystem.Int32 { m_value = 5 }.BoxIl2CppObject());
            IL2CPP_listOfBoxedObjects.Add(Color.red.BoxIl2CppObject());
            // boxed enum test
            try
            {
                Il2CppSystem.Type cppType = Il2CppType.Of<CameraClearFlags>();
                if (cppType is not null)
                {
                    Il2CppSystem.Object boxedEnum = Il2CppSystem.Enum.Parse(cppType, "Color");
                    IL2CPP_listOfBoxedObjects.Add(boxedEnum);
                }

                Il2CppSystem.Object structBox = Vector3.one.BoxIl2CppObject();
                IL2CPP_listOfBoxedObjects.Add(structBox);

            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Boxed enum test fail: {ex}");
            }

            ExplorerCore.Log($"IL2CPP 9: Il2Cpp struct array of ints");
            IL2CPP_structArray = new Il2CppStructArray<int>(5);
            IL2CPP_structArray[0] = 0;
            IL2CPP_structArray[1] = 1;
            IL2CPP_structArray[2] = 2;
            IL2CPP_structArray[3] = 3;
            IL2CPP_structArray[4] = 4;

            ExplorerCore.Log($"IL2CPP 10: Il2Cpp reference array of boxed objects");
            IL2CPP_ReferenceArray = new Il2CppReferenceArray<Il2CppSystem.Object>(3);
            IL2CPP_ReferenceArray[0] = new Il2CppSystem.Int32 { m_value = 5 }.BoxIl2CppObject();
            IL2CPP_ReferenceArray[1] = null;
            IL2CPP_ReferenceArray[2] = (Il2CppSystem.String)"whats up";

            ExplorerCore.Log($"IL2CPP 11: Misc il2cpp members");
            IL2CPP_BoxedInt = new Il2CppSystem.Int32() { m_value = 5 }.BoxIl2CppObject();
            IL2CPP_Int = new Il2CppSystem.Int32 { m_value = 420 };
            IL2CPP_Decimal = new Il2CppSystem.Decimal(1f);
            IL2CPP_DecimalBoxed = new Il2CppSystem.Decimal(1f).BoxIl2CppObject();
            IL2CPP_Vector3Boxed = Vector3.down.BoxIl2CppObject();

            ExplorerCore.Log($"Finished Init_Il2Cpp");
        }

#endif
    }
}

```

`src/UI/DisplayManager.cs`:

```cs
using System.Collections;
using UnityExplorer.Config;
using UniverseLib.Input;

namespace UnityExplorer.UI
{
    public static class DisplayManager
    {
        public static int ActiveDisplayIndex { get; private set; }
        public static Display ActiveDisplay => Display.displays[ActiveDisplayIndex];

        public static int Width => ActiveDisplay.renderingWidth;
        public static int Height => ActiveDisplay.renderingHeight;

        public static Vector3 MousePosition => Application.isEditor
            ? InputManager.MousePosition
            : Display.RelativeMouseAt(InputManager.MousePosition);

        public static bool MouseInTargetDisplay => MousePosition.z == ActiveDisplayIndex;

        private static Camera canvasCamera;

        internal static void Init()
        {
            SetDisplay(ConfigManager.Target_Display.Value);
            ConfigManager.Target_Display.OnValueChanged += SetDisplay;
        }

        public static void SetDisplay(int display)
        {
            if (ActiveDisplayIndex == display)
                return;

            if (Display.displays.Length <= display)
            {
                ExplorerCore.LogWarning($"Cannot set display index to {display} as there are not enough monitors connected!");

                if (ConfigManager.Target_Display.Value == display)
                    ConfigManager.Target_Display.Value = 0;

                return;
            }

            ActiveDisplayIndex = display;
            ActiveDisplay.Activate();

            UIManager.UICanvas.targetDisplay = display;

            // ensure a camera is targeting the display
            if (!Camera.main || Camera.main.targetDisplay != display)
            {
                if (!canvasCamera)
                {
                    canvasCamera = new GameObject("UnityExplorer_CanvasCamera").AddComponent<Camera>();
                    GameObject.DontDestroyOnLoad(canvasCamera.gameObject);
                    canvasCamera.hideFlags = HideFlags.HideAndDontSave;
                }
                canvasCamera.targetDisplay = display;
            }

            RuntimeHelper.StartCoroutine(FixPanels());
        }

        private static IEnumerator FixPanels()
        {
            yield return null;
            yield return null;

            foreach (Panels.UEPanel panel in UIManager.UIPanels.Values)
            {
                panel.EnsureValidSize();
                panel.EnsureValidPosition();
                panel.Dragger.OnEndResize();
            }
        }
    }
}

```

`src/UI/ExplorerUIBase.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Panels;

namespace UnityExplorer.UI
{
    internal class ExplorerUIBase : UIBase
    {
        public ExplorerUIBase(string id, Action updateMethod) : base(id, updateMethod) { }

        protected override PanelManager CreatePanelManager()
        {
            return new UEPanelManager(this);
        }
    }
}

```

`src/UI/Notification.cs`:

```cs
using UniverseLib.UI;

namespace UnityExplorer.UI
{
    public static class Notification
    {
        private static Text popupLabel;

        private static string _currentNotification;
        private static float _timeOfLastNotification;

        public static void Init()
        {
            ConstructUI();
        }

        public static void ShowMessage(string message)
        {
            popupLabel.text = message;
            _currentNotification = message;
            _timeOfLastNotification = Time.realtimeSinceStartup;

            popupLabel.transform.localPosition = UIManager.UIRootRect.InverseTransformPoint(DisplayManager.MousePosition) + (Vector3.up * 25);
        }

        public static void Update()
        {
            if (_currentNotification != null)
            {
                if (Time.realtimeSinceStartup - _timeOfLastNotification > 2f)
                {
                    _currentNotification = null;
                    popupLabel.text = "";
                }
            }
        }

        private static void ConstructUI()
        {
            popupLabel = UIFactory.CreateLabel(UIManager.UIRoot, "ClipboardNotification", "", TextAnchor.MiddleCenter);
            popupLabel.rectTransform.sizeDelta = new(500, 100);
            popupLabel.gameObject.AddComponent<Outline>();
            CanvasGroup popupGroup = popupLabel.gameObject.AddComponent<CanvasGroup>();
            popupGroup.blocksRaycasts = false;
        }
    }
}

```

`src/UI/Panels/AutoCompleteModal.cs`:

```cs
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.Input;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets.ButtonList;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.UI.Panels
{
    // Shared modal panel for "AutoComplete" suggestions.
    // A data source implements ISuggestionProvider and uses TakeOwnership and ReleaseOwnership
    // for control, and SetSuggestions to set the actual suggestion data.

    public class AutoCompleteModal : UEPanel
    {
        public static AutoCompleteModal Instance => UIManager.GetPanel<AutoCompleteModal>(UIManager.Panels.AutoCompleter);

        public override string Name => "AutoCompleter";
        public override UIManager.Panels PanelType => UIManager.Panels.AutoCompleter;

        public override int MinWidth => 100;
        public override int MinHeight => 25;
        public override Vector2 DefaultAnchorMin => new(MIN_X, 0.4f);
        public override Vector2 DefaultAnchorMax => new(0.68f, MAX_Y);
        const float MIN_X = 0.42f;
        const float MAX_Y = 0.6f;

        public override bool CanDragAndResize => true;
        public override bool ShouldSaveActiveState => false;
        public override bool NavButtonWanted => false;

        public static ISuggestionProvider CurrentHandler { get; private set; }

        public static ButtonListHandler<Suggestion, ButtonCell> buttonListDataHandler;
        public static ScrollPool<ButtonCell> scrollPool;
        private static GameObject navigationTipRow;

        private static List<Suggestion> Suggestions = new();
        private static int SelectedIndex = 0;

        public static Suggestion SelectedSuggestion => Suggestions[SelectedIndex];

        public static bool Suggesting(ISuggestionProvider handler) => CurrentHandler == handler && Instance.UIRoot.activeSelf;

        public AutoCompleteModal(UIBase owner) : base(owner)
        {
            UIManager.UiBase.Panels.OnPanelsReordered += UIPanel_OnPanelsReordered;
            UIManager.UiBase.Panels.OnClickedOutsidePanels += AutoCompleter_OnClickedOutsidePanels;
        }

        public static void TakeOwnership(ISuggestionProvider provider)
        {
            CurrentHandler = provider;
            navigationTipRow.SetActive(provider.AllowNavigation);
        }

        public void ReleaseOwnership(ISuggestionProvider provider)
        {
            if (CurrentHandler == null)
                return;

            if (CurrentHandler == provider)
            {
                Suggestions.Clear();
                CurrentHandler = null;
                UIRoot.SetActive(false);
            }
        }

        public void SetSuggestions(List<Suggestion> suggestions, bool jumpToTop = true)
        {
            Suggestions = suggestions;

            if (jumpToTop)
            {
                SelectedIndex = 0;
                if (scrollPool.DataSource.ItemCount > 0)
                    scrollPool.JumpToIndex(0, null);
            }

            if (!Suggestions.Any())
                base.UIRoot.SetActive(false);
            else
            {
                base.UIRoot.SetActive(true);
                base.UIRoot.transform.SetAsLastSibling();
                buttonListDataHandler.RefreshData();
                scrollPool.Refresh(true, jumpToTop);
            }
        }

        private static float timeOfLastNavHold = -1f;

        /// <summary>
        /// Returns true if the AutoCompleteModal used the navigation input, false if not.
        /// The navigation inputs are Control+Up/Down, and Control+Enter.
        /// </summary>
        public static bool CheckNavigation(ISuggestionProvider handler)
        {
            if (!Suggesting(handler))
                return false;

            bool up = InputManager.GetKey(KeyCode.UpArrow);
            bool down = InputManager.GetKey(KeyCode.DownArrow);

            if (up || down)
            {
                if (up)
                {
                    if (InputManager.GetKeyDown(KeyCode.UpArrow))
                    {
                        SetSelectedSuggestion(SelectedIndex - 1);
                        timeOfLastNavHold = Time.realtimeSinceStartup + 0.3f;
                    }
                    else if (timeOfLastNavHold.OccuredEarlierThan(0.05f))
                    {
                        SetSelectedSuggestion(SelectedIndex - 1);
                        timeOfLastNavHold = Time.realtimeSinceStartup;
                    }
                }
                else
                {
                    if (InputManager.GetKeyDown(KeyCode.DownArrow))
                    {
                        SetSelectedSuggestion(SelectedIndex + 1);
                        timeOfLastNavHold = Time.realtimeSinceStartup + 0.3f;
                    }
                    else if (timeOfLastNavHold.OccuredEarlierThan(0.05f))
                    {
                        SetSelectedSuggestion(SelectedIndex + 1);
                        timeOfLastNavHold = Time.realtimeSinceStartup;
                    }
                }

                return true;
            }

            return !timeOfLastNavHold.OccuredEarlierThan(0.2f);
        }

        public static bool CheckEnter(ISuggestionProvider handler)
        {
            return Suggesting(handler) && InputManager.GetKeyDown(KeyCode.Return);
        }

        public static bool CheckEscape(ISuggestionProvider handler)
        {
            return Suggesting(handler) && InputManager.GetKeyDown(KeyCode.Escape);
        }

        private static void SetSelectedSuggestion(int index)
        {
            if (index < 0 || index >= Suggestions.Count)
                return;

            SelectedIndex = index;

            scrollPool.JumpToIndex(index, null);
        }

        // Internal update

        public override void Update()
        {
            if (!UIRoot || !UIRoot.activeSelf)
                return;

            if (Suggestions.Any() && CurrentHandler != null)
            {
                if (!CurrentHandler.InputField.UIRoot.activeInHierarchy)
                    ReleaseOwnership(CurrentHandler);
                else
                    UpdatePosition();
            }
        }

        // Setting autocomplete cell buttons

        private readonly Color selectedSuggestionColor = new(45 / 255f, 75 / 255f, 80 / 255f);
        private readonly Color inactiveSuggestionColor = new(0.11f, 0.11f, 0.11f);

        private List<Suggestion> GetEntries() => Suggestions;

        private bool ShouldDisplay(Suggestion data, string filter) => true;

        private void OnCellClicked(int dataIndex)
        {
            Suggestion suggestion = Suggestions[dataIndex];
            CurrentHandler.OnSuggestionClicked(suggestion);
        }

        private bool setFirstCell;

        private void SetCell(ButtonCell cell, int index)
        {
            if (CurrentHandler == null)
            {
                UIRoot.SetActive(false);
                return;
            }

            if (index < 0 || index >= Suggestions.Count)
            {
                cell.Disable();
                return;
            }

            Suggestion suggestion = Suggestions[index];
            cell.Button.ButtonText.text = suggestion.DisplayText;

            if (CurrentHandler.AllowNavigation && index == SelectedIndex && setFirstCell)
            {
                RuntimeHelper.SetColorBlock(cell.Button.Component, selectedSuggestionColor);
            }
            else
                RuntimeHelper.SetColorBlock(cell.Button.Component, inactiveSuggestionColor);

            setFirstCell = true;
        }

        // Updating panel position

        private int lastCaretPosition;
        private Vector3 lastInputPosition;

        internal void UpdatePosition()
        {
            if (CurrentHandler == null)
                return;

            InputFieldRef input = CurrentHandler.InputField;

            //if (!input.Component.isFocused 
            //    || (input.Component.caretPosition == lastCaretPosition && input.UIRoot.transform.position == lastInputPosition))
            //    return;

            if (input.Component.caretPosition == lastCaretPosition && input.UIRoot.transform.position == lastInputPosition)
                return;
            
            if (CurrentHandler.AnchorToCaretPosition)
            {
                if (!input.Component.isFocused)
                    return;

                TextGenerator textGen = input.Component.cachedInputTextGenerator;
                int caretIdx = Math.Max(0, Math.Min(textGen.characterCount - 1, input.Component.caretPosition));

                // normalize the caret horizontal position
                Vector3 caretPos = textGen.characters[caretIdx].cursorPos;
                // transform to world point
                caretPos = input.UIRoot.transform.TransformPoint(caretPos);
                caretPos += new Vector3(input.Transform.rect.width * 0.5f, -(input.Transform.rect.height * 0.5f), 0);

                uiRoot.transform.position = new Vector3(caretPos.x + 10, caretPos.y - 30, 0);
            }
            else
            {
                uiRoot.transform.position = input.Transform.position + new Vector3(-(input.Transform.rect.width / 2) + 10, -20, 0);
            }

            lastInputPosition = input.UIRoot.transform.position;
            lastCaretPosition = input.Component.caretPosition;

            this.Dragger.OnEndResize();
        }

        // Event listeners for panel

        private void AutoCompleter_OnClickedOutsidePanels()
        {
            if (!this.UIRoot || !this.UIRoot.activeInHierarchy)
                return;

            if (CurrentHandler != null)
                ReleaseOwnership(CurrentHandler);
            else
                UIRoot.SetActive(false);
        }

        private void UIPanel_OnPanelsReordered()
        {
            if (!this.UIRoot || !this.UIRoot.activeInHierarchy)
                return;

            if (this.UIRoot.transform.GetSiblingIndex() != UIManager.UiBase.Panels.PanelHolder.transform.childCount - 1)
            {
                if (CurrentHandler != null)
                    ReleaseOwnership(CurrentHandler);
                else
                    UIRoot.SetActive(false);
            }
        }

        public override void OnFinishResize()
        {
            float xDiff = Rect.anchorMin.x - MIN_X;
            float yDiff = Rect.anchorMax.y - MAX_Y;

            if (xDiff != 0 || yDiff != 0)
            {
                Rect.anchorMin = new(MIN_X, Rect.anchorMin.y - yDiff);
                Rect.anchorMax = new(Rect.anchorMax.x - xDiff, MAX_Y);
            }

            base.OnFinishResize();
        }

        // UI Construction

        protected override void ConstructPanelContent()
        {
            // hide the titlebar
            this.TitleBar.gameObject.SetActive(false);

            buttonListDataHandler = new ButtonListHandler<Suggestion, ButtonCell>(scrollPool, GetEntries, SetCell, ShouldDisplay, OnCellClicked);

            scrollPool = UIFactory.CreateScrollPool<ButtonCell>(this.ContentRoot, "AutoCompleter", out GameObject scrollObj,
                out GameObject scrollContent);
            scrollPool.Initialize(buttonListDataHandler);
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(scrollContent, true, false, true, false);

            navigationTipRow = UIFactory.CreateHorizontalGroup(this.ContentRoot, "BottomRow", true, true, true, true, 0, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(navigationTipRow, minHeight: 20, flexibleWidth: 9999);
            UIFactory.CreateLabel(navigationTipRow, "HelpText", "Up/Down to select, Enter to use, Esc to close",
                TextAnchor.MiddleLeft, Color.grey, false, 13);

            UIRoot.SetActive(false);
        }
    }
}

```

`src/UI/Panels/CSConsolePanel.cs`:

```cs
using System.Collections;
using UnityExplorer.CSConsole;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;

namespace UnityExplorer.UI.Panels
{
    public class CSConsolePanel : UEPanel
    {
        public override string Name => "C# Console";
        public override UIManager.Panels PanelType => UIManager.Panels.CSConsole;

        public override int MinWidth => 750;
        public override int MinHeight => 300;
        public override Vector2 DefaultAnchorMin => new(0.4f, 0.175f);
        public override Vector2 DefaultAnchorMax => new(0.85f, 0.925f);

        public InputFieldScroller InputScroller { get; private set; }
        public InputFieldRef Input => InputScroller.InputField;
        public Text InputText { get; private set; }
        public Text HighlightText { get; private set; }
        public Text LineNumberText { get; private set; }

        public Dropdown HelpDropdown { get; private set; }

        // events
        public Action<string> OnInputChanged;
        public Action OnResetClicked;
        public Action OnCompileClicked;
        public Action<int> OnHelpDropdownChanged;
        public Action<bool> OnCtrlRToggled;
        public Action<bool> OnSuggestionsToggled;
        public Action<bool> OnAutoIndentToggled;
        public Action OnPanelResized;

        public CSConsolePanel(UIBase owner) : base(owner)
        {
        }

        private void InvokeOnValueChanged(string value)
        {
            if (value.Length == UniversalUI.MAX_INPUTFIELD_CHARS)
                ExplorerCore.LogWarning($"Reached maximum InputField character length! ({UniversalUI.MAX_INPUTFIELD_CHARS})");

            OnInputChanged?.Invoke(value);
        }

        public override void Update()
        {
            base.Update();

            ConsoleController.Update();
        }

        // UI Construction

        public override void OnFinishResize()
        {
            OnPanelResized?.Invoke();
        }

        protected override void ConstructPanelContent()
        {
            // Tools Row

            GameObject toolsRow = UIFactory.CreateHorizontalGroup(this.ContentRoot, "ToggleRow", false, false, true, true, 5, new Vector4(8, 8, 10, 5),
                default, TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(toolsRow, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            // Buttons

            ButtonRef compileButton = UIFactory.CreateButton(toolsRow, "CompileButton", "Compile", new Color(0.33f, 0.5f, 0.33f));
            UIFactory.SetLayoutElement(compileButton.Component.gameObject, minHeight: 28, minWidth: 130, flexibleHeight: 0);
            compileButton.ButtonText.fontSize = 15;
            compileButton.OnClick += () => { OnCompileClicked?.Invoke(); };

            ButtonRef resetButton = UIFactory.CreateButton(toolsRow, "ResetButton", "Reset", new Color(0.33f, 0.33f, 0.33f));
            UIFactory.SetLayoutElement(resetButton.Component.gameObject, minHeight: 28, minWidth: 80, flexibleHeight: 0);
            resetButton.ButtonText.fontSize = 15;
            resetButton.OnClick += () => { OnResetClicked?.Invoke(); };

            // Help dropdown

            GameObject helpDrop = UIFactory.CreateDropdown(toolsRow, "HelpDropdown", out Dropdown dropdown, "Help", 14, null);
            UIFactory.SetLayoutElement(helpDrop, minHeight: 25, minWidth: 100);
            HelpDropdown = dropdown;
            HelpDropdown.onValueChanged.AddListener((int val) => { this.OnHelpDropdownChanged?.Invoke(val); });

            // Enable Ctrl+R toggle

            GameObject ctrlRToggleObj = UIFactory.CreateToggle(toolsRow, "CtrlRToggle", out Toggle CtrlRToggle, out Text ctrlRToggleText);
            UIFactory.SetLayoutElement(ctrlRToggleObj, minWidth: 150, flexibleWidth: 0, minHeight: 25);
            ctrlRToggleText.alignment = TextAnchor.UpperLeft;
            ctrlRToggleText.text = "Compile on Ctrl+R";
            CtrlRToggle.onValueChanged.AddListener((bool val) => { OnCtrlRToggled?.Invoke(val); });

            // Enable Suggestions toggle

            GameObject suggestToggleObj = UIFactory.CreateToggle(toolsRow, "SuggestionToggle", out Toggle SuggestionsToggle, out Text suggestToggleText);
            UIFactory.SetLayoutElement(suggestToggleObj, minWidth: 120, flexibleWidth: 0, minHeight: 25);
            suggestToggleText.alignment = TextAnchor.UpperLeft;
            suggestToggleText.text = "Suggestions";
            SuggestionsToggle.onValueChanged.AddListener((bool val) => { OnSuggestionsToggled?.Invoke(val); });

            // Enable Auto-indent toggle

            GameObject autoIndentToggleObj = UIFactory.CreateToggle(toolsRow, "IndentToggle", out Toggle AutoIndentToggle, out Text autoIndentToggleText);
            UIFactory.SetLayoutElement(autoIndentToggleObj, minWidth: 120, flexibleWidth: 0, minHeight: 25);
            autoIndentToggleText.alignment = TextAnchor.UpperLeft;
            autoIndentToggleText.text = "Auto-indent";
            AutoIndentToggle.onValueChanged.AddListener((bool val) => { OnAutoIndentToggled?.Invoke(val); });

            // Console Input

            GameObject inputArea = UIFactory.CreateUIObject("InputGroup", ContentRoot);
            UIFactory.SetLayoutElement(inputArea, flexibleWidth: 9999, flexibleHeight: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(inputArea, false, true, true, true);
            inputArea.AddComponent<Image>().color = Color.white;
            inputArea.AddComponent<Mask>().showMaskGraphic = false;

            // line numbers

            GameObject linesHolder = UIFactory.CreateUIObject("LinesHolder", inputArea);
            RectTransform linesRect = linesHolder.GetComponent<RectTransform>();
            linesRect.pivot = new Vector2(0, 1);
            linesRect.anchorMin = new Vector2(0, 0);
            linesRect.anchorMax = new Vector2(0, 1);
            linesRect.sizeDelta = new Vector2(0, 305000);
            linesRect.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Left, 0, 50);
            linesHolder.AddComponent<Image>().color = new Color(0.05f, 0.05f, 0.05f);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(linesHolder, true, true, true, true);

            LineNumberText = UIFactory.CreateLabel(linesHolder, "LineNumbers", "1", TextAnchor.UpperCenter, Color.grey, fontSize: 16);
            LineNumberText.font = UniversalUI.ConsoleFont;

            // input field

            int fontSize = 16;

            GameObject inputObj = UIFactory.CreateScrollInputField(inputArea, "ConsoleInput", ConsoleController.STARTUP_TEXT,
                out InputFieldScroller inputScroller, fontSize);
            InputScroller = inputScroller;
            ConsoleController.DefaultInputFieldAlpha = Input.Component.selectionColor.a;
            Input.OnValueChanged += InvokeOnValueChanged;

            // move line number text with input field
            linesRect.transform.SetParent(inputObj.transform.Find("Viewport"), false);
            inputScroller.Slider.Scrollbar.onValueChanged.AddListener((float val) => { SetLinesPosition(); });
            inputScroller.Slider.Slider.onValueChanged.AddListener((float val) => { SetLinesPosition(); });
            void SetLinesPosition()
            {
                linesRect.anchoredPosition = new Vector2(linesRect.anchoredPosition.x, inputScroller.ContentRect.anchoredPosition.y);
                //SetInputLayout();
            }

            InputText = Input.Component.textComponent;
            InputText.supportRichText = false;
            InputText.color = Color.clear;
            Input.Component.customCaretColor = true;
            Input.Component.caretColor = Color.white;
            Input.PlaceholderText.fontSize = fontSize;

            // Lexer highlight text overlay
            GameObject highlightTextObj = UIFactory.CreateUIObject("HighlightText", InputText.gameObject);
            RectTransform highlightTextRect = highlightTextObj.GetComponent<RectTransform>();
            highlightTextRect.pivot = new Vector2(0, 1);
            highlightTextRect.anchorMin = Vector2.zero;
            highlightTextRect.anchorMax = Vector2.one;
            highlightTextRect.offsetMin = Vector2.zero;
            highlightTextRect.offsetMax = Vector2.zero;

            HighlightText = highlightTextObj.AddComponent<Text>();
            HighlightText.color = Color.white;
            HighlightText.supportRichText = true;
            HighlightText.fontSize = fontSize;

            // Set fonts
            InputText.font = UniversalUI.ConsoleFont;
            Input.PlaceholderText.font = UniversalUI.ConsoleFont;
            HighlightText.font = UniversalUI.ConsoleFont;

            RuntimeHelper.StartCoroutine(DelayedLayoutSetup());
        }

        private IEnumerator DelayedLayoutSetup()
        {
            yield return null;
            SetInputLayout();
        }

        public void SetInputLayout()
        {
            Input.Transform.offsetMin = new Vector2(52, Input.Transform.offsetMin.y);
            Input.Transform.offsetMax = new Vector2(2, Input.Transform.offsetMax.y);
        }
    }
}

```

`src/UI/Panels/ClipboardPanel.cs`:

```cs
using UniverseLib.UI;

namespace UnityExplorer.UI.Panels
{
    public class ClipboardPanel : UEPanel
    {
        public static object Current { get; private set; }

        public override string Name => "Clipboard";
        public override UIManager.Panels PanelType => UIManager.Panels.Clipboard;

        public override int MinWidth => 500;
        public override int MinHeight => 95;
        public override Vector2 DefaultAnchorMin => new(0.1f, 0.05f);
        public override Vector2 DefaultAnchorMax => new(0.4f, 0.15f);

        public override bool CanDragAndResize => true;
        public override bool NavButtonWanted => true;
        public override bool ShouldSaveActiveState => true;
        public override bool ShowByDefault => true;

        private static Text CurrentPasteLabel;

        public ClipboardPanel(UIBase owner) : base(owner)
        {
        }

        public static void Copy(object obj)
        {
            Current = obj;
            Notification.ShowMessage("Copied!");
            UpdateCurrentPasteInfo();
        }

        public static bool TryPaste(Type targetType, out object paste)
        {
            paste = Current;
            Type pasteType = Current?.GetActualType();

            if (Current != null && !targetType.IsAssignableFrom(pasteType))
            {
                Notification.ShowMessage($"Cannot assign '{pasteType.Name}' to '{targetType.Name}'!");
                return false;
            }

            Notification.ShowMessage("Pasted!");
            return true;
        }

        public static void ClearClipboard()
        {
            Current = null;
            UpdateCurrentPasteInfo();
        }

        private static void UpdateCurrentPasteInfo()
        {
            CurrentPasteLabel.text = ToStringUtility.ToStringWithType(Current, typeof(object), false);
        }

        private static void InspectClipboard()
        {
            if (Current.IsNullOrDestroyed())
            {
                Notification.ShowMessage("Cannot inspect a null or destroyed object!");
                return;
            }

            InspectorManager.Inspect(Current);
        }

        public override void SetDefaultSizeAndPosition()
        {
            base.SetDefaultSizeAndPosition();

            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, MinWidth);
            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, MinHeight);
        }

        protected override void ConstructPanelContent()
        {
            this.UIRoot.GetComponent<Image>().color = new(0.1f, 0.1f, 0.1f);

            // Actual panel content

            GameObject firstRow = UIFactory.CreateHorizontalGroup(ContentRoot, "FirstRow", false, false, true, true, 5, new(2, 2, 2, 2), new(1, 1, 1, 0));
            UIFactory.SetLayoutElement(firstRow, minHeight: 25, flexibleWidth: 999);

            // Title for "Current Paste:"
            Text currentPasteTitle = UIFactory.CreateLabel(firstRow, "CurrentPasteTitle", "Current paste:", TextAnchor.MiddleLeft, color: Color.grey);
            UIFactory.SetLayoutElement(currentPasteTitle.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 999);

            // Clear clipboard button
            UniverseLib.UI.Models.ButtonRef clearButton = UIFactory.CreateButton(firstRow, "ClearPasteButton", "Clear Clipboard");
            UIFactory.SetLayoutElement(clearButton.Component.gameObject, minWidth: 120, minHeight: 25, flexibleWidth: 0);
            clearButton.OnClick += () => Copy(null);

            // Current Paste info row
            GameObject currentPasteHolder = UIFactory.CreateHorizontalGroup(ContentRoot, "SecondRow", false, false, true, true, 0,
                new(2, 2, 2, 2), childAlignment: TextAnchor.UpperCenter);

            // Actual current paste info label
            CurrentPasteLabel = UIFactory.CreateLabel(currentPasteHolder, "CurrentPasteInfo", "not set", TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(CurrentPasteLabel.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 999, flexibleHeight: 999);
            UpdateCurrentPasteInfo();

            // Inspect button
            UniverseLib.UI.Models.ButtonRef inspectButton = UIFactory.CreateButton(currentPasteHolder, "InspectButton", "Inspect");
            UIFactory.SetLayoutElement(inspectButton.Component.gameObject, minHeight: 25, flexibleHeight: 0, minWidth: 80, flexibleWidth: 0);
            inspectButton.OnClick += InspectClipboard;
        }
    }
}

```

`src/UI/Panels/FreeCamPanel.cs`:

```cs
using UniverseLib.Input;
using UniverseLib.UI;
using UniverseLib.UI.Models;
#if UNHOLLOWER
using UnhollowerRuntimeLib;
#endif
#if INTEROP
using Il2CppInterop.Runtime.Injection;
#endif

namespace UnityExplorer.UI.Panels
{
    internal class FreeCamPanel : UEPanel
    {
        public FreeCamPanel(UIBase owner) : base(owner)
        {
        }

        public override string Name => "Freecam";
        public override UIManager.Panels PanelType => UIManager.Panels.Freecam;
        public override int MinWidth => 400;
        public override int MinHeight => 320;
        public override Vector2 DefaultAnchorMin => new(0.4f, 0.4f);
        public override Vector2 DefaultAnchorMax => new(0.6f, 0.6f);
        public override bool NavButtonWanted => true;
        public override bool ShouldSaveActiveState => true;

        internal static bool inFreeCamMode;
        internal static bool usingGameCamera;
        internal static Camera ourCamera;
        internal static Camera lastMainCamera;
        internal static FreeCamBehaviour freeCamScript;

        internal static float desiredMoveSpeed = 10f;

        internal static Vector3 originalCameraPosition;
        internal static Quaternion originalCameraRotation;

        internal static Vector3? currentUserCameraPosition;
        internal static Quaternion? currentUserCameraRotation;

        internal static Vector3 previousMousePosition;

        internal static Vector3 lastSetCameraPosition;

        static ButtonRef startStopButton;
        static Toggle useGameCameraToggle;
        static InputFieldRef positionInput;
        static InputFieldRef moveSpeedInput;
        static ButtonRef inspectButton;

        internal static void BeginFreecam()
        {
            inFreeCamMode = true;

            previousMousePosition = InputManager.MousePosition;

            CacheMainCamera();
            SetupFreeCamera();

            inspectButton.GameObject.SetActive(true);
        }

        static void CacheMainCamera()
        {
            Camera currentMain = Camera.main;
            if (currentMain)
            {
                lastMainCamera = currentMain;
                originalCameraPosition = currentMain.transform.position;
                originalCameraRotation = currentMain.transform.rotation;

                if (currentUserCameraPosition == null)
                {
                    currentUserCameraPosition = currentMain.transform.position;
                    currentUserCameraRotation = currentMain.transform.rotation;
                }
            }
            else
                originalCameraRotation = Quaternion.identity;
        }

        static void SetupFreeCamera()
        {
            if (useGameCameraToggle.isOn)
            {
                if (!lastMainCamera)
                {
                    ExplorerCore.LogWarning($"There is no previous Camera found, reverting to default Free Cam.");
                    useGameCameraToggle.isOn = false;
                }
                else
                {
                    usingGameCamera = true;
                    ourCamera = lastMainCamera;
                }
            }

            if (!useGameCameraToggle.isOn)
            {
                usingGameCamera = false;

                if (lastMainCamera)
                    lastMainCamera.enabled = false;
            }

            if (!ourCamera)
            {
                ourCamera = new GameObject("UE_Freecam").AddComponent<Camera>();
                ourCamera.gameObject.tag = "MainCamera";
                GameObject.DontDestroyOnLoad(ourCamera.gameObject);
                ourCamera.gameObject.hideFlags = HideFlags.HideAndDontSave;
            }

            if (!freeCamScript)
                freeCamScript = ourCamera.gameObject.AddComponent<FreeCamBehaviour>();

            ourCamera.transform.position = (Vector3)currentUserCameraPosition;
            ourCamera.transform.rotation = (Quaternion)currentUserCameraRotation;

            ourCamera.gameObject.SetActive(true);
            ourCamera.enabled = true;
        }

        internal static void EndFreecam()
        {
            inFreeCamMode = false;

            if (usingGameCamera)
            {
                ourCamera = null;

                if (lastMainCamera)
                {
                    lastMainCamera.transform.position = originalCameraPosition;
                    lastMainCamera.transform.rotation = originalCameraRotation;
                }
            }

            if (ourCamera)
                ourCamera.gameObject.SetActive(false);
            else
                inspectButton.GameObject.SetActive(false);

            if (freeCamScript)
            {
                GameObject.Destroy(freeCamScript);
                freeCamScript = null;
            }

            if (lastMainCamera)
                lastMainCamera.enabled = true;
        }

        static void SetCameraPosition(Vector3 pos)
        {
            if (!ourCamera || lastSetCameraPosition == pos)
                return;

            ourCamera.transform.position = pos;
            lastSetCameraPosition = pos;
        }

        internal static void UpdatePositionInput()
        {
            if (!ourCamera)
                return;

            if (positionInput.Component.isFocused)
                return;

            lastSetCameraPosition = ourCamera.transform.position;
            positionInput.Text = ParseUtility.ToStringForInput<Vector3>(lastSetCameraPosition);
        }

        // ~~~~~~~~ UI construction / callbacks ~~~~~~~~

        protected override void ConstructPanelContent()
        {
            startStopButton = UIFactory.CreateButton(ContentRoot, "ToggleButton", "Freecam");
            UIFactory.SetLayoutElement(startStopButton.GameObject, minWidth: 150, minHeight: 25, flexibleWidth: 9999);
            startStopButton.OnClick += StartStopButton_OnClick;
            SetToggleButtonState();

            AddSpacer(5);

            GameObject toggleObj = UIFactory.CreateToggle(ContentRoot, "UseGameCameraToggle", out useGameCameraToggle, out Text toggleText);
            UIFactory.SetLayoutElement(toggleObj, minHeight: 25, flexibleWidth: 9999);
            useGameCameraToggle.onValueChanged.AddListener(OnUseGameCameraToggled);
            useGameCameraToggle.isOn = false;
            toggleText.text = "Use Game Camera?";

            AddSpacer(5);

            GameObject posRow = AddInputField("Position", "Freecam Pos:", "eg. 0 0 0", out positionInput, PositionInput_OnEndEdit);

            ButtonRef resetPosButton = UIFactory.CreateButton(posRow, "ResetButton", "Reset");
            UIFactory.SetLayoutElement(resetPosButton.GameObject, minWidth: 70, minHeight: 25);
            resetPosButton.OnClick += OnResetPosButtonClicked;

            AddSpacer(5);

            AddInputField("MoveSpeed", "Move Speed:", "Default: 1", out moveSpeedInput, MoveSpeedInput_OnEndEdit);
            moveSpeedInput.Text = desiredMoveSpeed.ToString();

            AddSpacer(5);

            string instructions = @"Controls:
- WASD / Arrows: Movement
- Space / PgUp: Move up
- LeftCtrl / PgDown: Move down
- Right Mouse Button: Free look
- Shift: Super speed";

            Text instructionsText = UIFactory.CreateLabel(ContentRoot, "Instructions", instructions, TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(instructionsText.gameObject, flexibleWidth: 9999, flexibleHeight: 9999);

            AddSpacer(5);

            inspectButton = UIFactory.CreateButton(ContentRoot, "InspectButton", "Inspect Free Camera");
            UIFactory.SetLayoutElement(inspectButton.GameObject, flexibleWidth: 9999, minHeight: 25);
            inspectButton.OnClick += () => { InspectorManager.Inspect(ourCamera); };
            inspectButton.GameObject.SetActive(false);

            AddSpacer(5);
        }

        void AddSpacer(int height)
        {
            GameObject obj = UIFactory.CreateUIObject("Spacer", ContentRoot);
            UIFactory.SetLayoutElement(obj, minHeight: height, flexibleHeight: 0);
        }

        GameObject AddInputField(string name, string labelText, string placeHolder, out InputFieldRef inputField, Action<string> onInputEndEdit)
        {
            GameObject row = UIFactory.CreateHorizontalGroup(ContentRoot, $"{name}_Group", false, false, true, true, 3, default, new(1, 1, 1, 0));

            Text posLabel = UIFactory.CreateLabel(row, $"{name}_Label", labelText);
            UIFactory.SetLayoutElement(posLabel.gameObject, minWidth: 100, minHeight: 25);

            inputField = UIFactory.CreateInputField(row, $"{name}_Input", placeHolder);
            UIFactory.SetLayoutElement(inputField.GameObject, minWidth: 125, minHeight: 25, flexibleWidth: 9999);
            inputField.Component.GetOnEndEdit().AddListener(onInputEndEdit);

            return row;
        }

        void StartStopButton_OnClick()
        {
            EventSystemHelper.SetSelectedGameObject(null);

            if (inFreeCamMode)
                EndFreecam();
            else
                BeginFreecam();

            SetToggleButtonState();
        }

        void SetToggleButtonState()
        {
            if (inFreeCamMode)
            {
                RuntimeHelper.SetColorBlockAuto(startStopButton.Component, new(0.4f, 0.2f, 0.2f));
                startStopButton.ButtonText.text = "End Freecam";
            }
            else
            {
                RuntimeHelper.SetColorBlockAuto(startStopButton.Component, new(0.2f, 0.4f, 0.2f));
                startStopButton.ButtonText.text = "Begin Freecam";
            }
        }

        void OnUseGameCameraToggled(bool value)
        {
            EventSystemHelper.SetSelectedGameObject(null);

            if (!inFreeCamMode)
                return;

            EndFreecam();
            BeginFreecam();
        }

        void OnResetPosButtonClicked()
        {
            currentUserCameraPosition = originalCameraPosition;
            currentUserCameraRotation = originalCameraRotation;

            if (inFreeCamMode && ourCamera)
            {
                ourCamera.transform.position = (Vector3)currentUserCameraPosition;
                ourCamera.transform.rotation = (Quaternion)currentUserCameraRotation;
            }

            positionInput.Text = ParseUtility.ToStringForInput<Vector3>(originalCameraPosition);
        }

        void PositionInput_OnEndEdit(string input)
        {
            EventSystemHelper.SetSelectedGameObject(null);

            if (!ParseUtility.TryParse(input, out Vector3 parsed, out Exception parseEx))
            {
                ExplorerCore.LogWarning($"Could not parse position to Vector3: {parseEx.ReflectionExToString()}");
                UpdatePositionInput();
                return;
            }

            SetCameraPosition(parsed);
        }

        void MoveSpeedInput_OnEndEdit(string input)
        {
            EventSystemHelper.SetSelectedGameObject(null);

            if (!ParseUtility.TryParse(input, out float parsed, out Exception parseEx))
            {
                ExplorerCore.LogWarning($"Could not parse value: {parseEx.ReflectionExToString()}");
                moveSpeedInput.Text = desiredMoveSpeed.ToString();
                return;
            }

            desiredMoveSpeed = parsed;
        }
    }

    internal class FreeCamBehaviour : MonoBehaviour
    {
#if CPP
        static FreeCamBehaviour()
        {
            ClassInjector.RegisterTypeInIl2Cpp<FreeCamBehaviour>();
        }

        public FreeCamBehaviour(IntPtr ptr) : base(ptr) { }
#endif

        internal void Update()
        {
            if (FreeCamPanel.inFreeCamMode)
            {
                if (!FreeCamPanel.ourCamera)
                {
                    FreeCamPanel.EndFreecam();
                    return;
                }

                Transform transform = FreeCamPanel.ourCamera.transform;

                FreeCamPanel.currentUserCameraPosition = transform.position;
                FreeCamPanel.currentUserCameraRotation = transform.rotation;

                float moveSpeed = FreeCamPanel.desiredMoveSpeed * Time.deltaTime;

                if (InputManager.GetKey(KeyCode.LeftShift) || InputManager.GetKey(KeyCode.RightShift))
                    moveSpeed *= 10f;

                if (InputManager.GetKey(KeyCode.LeftArrow) || InputManager.GetKey(KeyCode.A))
                    transform.position += transform.right * -1 * moveSpeed;

                if (InputManager.GetKey(KeyCode.RightArrow) || InputManager.GetKey(KeyCode.D))
                    transform.position += transform.right * moveSpeed;

                if (InputManager.GetKey(KeyCode.UpArrow) || InputManager.GetKey(KeyCode.W))
                    transform.position += transform.forward * moveSpeed;

                if (InputManager.GetKey(KeyCode.DownArrow) || InputManager.GetKey(KeyCode.S))
                    transform.position += transform.forward * -1 * moveSpeed;

                if (InputManager.GetKey(KeyCode.Space) || InputManager.GetKey(KeyCode.PageUp))
                    transform.position += transform.up * moveSpeed;

                if (InputManager.GetKey(KeyCode.LeftControl) || InputManager.GetKey(KeyCode.PageDown))
                    transform.position += transform.up * -1 * moveSpeed;

                if (InputManager.GetMouseButton(1))
                {
                    Vector3 mouseDelta = InputManager.MousePosition - FreeCamPanel.previousMousePosition;

                    float newRotationX = transform.localEulerAngles.y + mouseDelta.x * 0.3f;
                    float newRotationY = transform.localEulerAngles.x - mouseDelta.y * 0.3f;
                    transform.localEulerAngles = new Vector3(newRotationY, newRotationX, 0f);
                }

                FreeCamPanel.UpdatePositionInput();

                FreeCamPanel.previousMousePosition = InputManager.MousePosition;
            }
        }
    }
}

```

`src/UI/Panels/HookManagerPanel.cs`:

```cs
using UnityExplorer.Hooks;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI;

namespace UnityExplorer.UI.Panels
{
    public class HookManagerPanel : UEPanel
    {
        public static HookManagerPanel Instance { get; private set; }

        public enum Pages
        {
            ClassMethodSelector,
            HookSourceEditor,
            GenericArgsSelector,
        }

        public static HookCreator hookCreator;
        public static HookList hookList;
        public static GenericConstructorWidget genericArgsHandler;

        // Panel
        public override UIManager.Panels PanelType => UIManager.Panels.HookManager;
        public override string Name => "Hooks";
        public override bool ShowByDefault => false;
        public override int MinWidth => 400;
        public override int MinHeight => 400;
        public override Vector2 DefaultAnchorMin => new(0.5f, 0.5f);
        public override Vector2 DefaultAnchorMax => new(0.5f, 0.5f);

        public Pages CurrentPage { get; private set; } = Pages.ClassMethodSelector;

        public HookManagerPanel(UIBase owner) : base(owner)
        {
        }

        public void SetPage(Pages page)
        {
            switch (page)
            {
                case Pages.ClassMethodSelector:
                    HookCreator.AddHooksRoot.SetActive(true);
                    HookCreator.EditorRoot.SetActive(false);
                    genericArgsHandler.UIRoot.SetActive(false);
                    break;

                case Pages.HookSourceEditor:
                    HookCreator.AddHooksRoot.SetActive(false);
                    HookCreator.EditorRoot.SetActive(true);
                    genericArgsHandler.UIRoot.SetActive(false);
                    break;

                case Pages.GenericArgsSelector:
                    HookCreator.AddHooksRoot.SetActive(false);
                    HookCreator.EditorRoot.SetActive(false);
                    genericArgsHandler.UIRoot.SetActive(true);
                    break;
            }
        }

        public override void SetDefaultSizeAndPosition()
        {
            base.SetDefaultSizeAndPosition();

            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, MinWidth);
            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, MinHeight);
        }

        protected override void ConstructPanelContent()
        {
            Instance = this;
            hookList = new();
            hookCreator = new();
            genericArgsHandler = new();

            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(ContentRoot, true, false);

            // GameObject baseHoriGroup = UIFactory.CreateHorizontalGroup(ContentRoot, "HoriGroup", true, true, true, true);
            // UIFactory.SetLayoutElement(baseHoriGroup, flexibleWidth: 9999, flexibleHeight: 9999);

            // // Left Group

            //GameObject leftGroup = UIFactory.CreateVerticalGroup(ContentRoot, "LeftGroup", true, true, true, true);
            UIFactory.SetLayoutElement(ContentRoot.gameObject, minWidth: 300, flexibleWidth: 9999, flexibleHeight: 9999);

            hookList.ConstructUI(ContentRoot);

            // // Right Group

            //GameObject rightGroup = UIFactory.CreateVerticalGroup(ContentRoot, "RightGroup", true, true, true, true);
            UIFactory.SetLayoutElement(ContentRoot, minWidth: 300, flexibleWidth: 9999, flexibleHeight: 9999);

            hookCreator.ConstructAddHooksView(ContentRoot);

            hookCreator.ConstructEditor(ContentRoot);
            HookCreator.EditorRoot.SetActive(false);

            genericArgsHandler.ConstructUI(ContentRoot);
            genericArgsHandler.UIRoot.SetActive(false);
        }
    }
}

```

`src/UI/Panels/InspectorPanel.cs`:

```cs
using UnityExplorer.Inspectors;
using UniverseLib.UI;

namespace UnityExplorer.UI.Panels
{
    public class InspectorPanel : UEPanel
    {
        public static InspectorPanel Instance { get; private set; }

        public override string Name => "Inspector";
        public override UIManager.Panels PanelType => UIManager.Panels.Inspector;
        public override bool ShouldSaveActiveState => false;

        public override int MinWidth => 810;
        public override int MinHeight => 350;
        public override Vector2 DefaultAnchorMin => new(0.35f, 0.175f);
        public override Vector2 DefaultAnchorMax => new(0.8f, 0.925f);

        public GameObject NavbarHolder;
        public Dropdown MouseInspectDropdown;
        public GameObject ContentHolder;
        public RectTransform ContentRect;

        public static float CurrentPanelWidth => Instance.Rect.rect.width;
        public static float CurrentPanelHeight => Instance.Rect.rect.height;

        public InspectorPanel(UIBase owner) : base(owner)
        {
            Instance = this;
        }

        public override void Update()
        {
            InspectorManager.Update();
        }

        public override void OnFinishResize()
        {
            base.OnFinishResize();

            InspectorManager.PanelWidth = this.Rect.rect.width;
            InspectorManager.OnPanelResized(Rect.rect.width);
        }

        protected override void ConstructPanelContent()
        {
            GameObject closeHolder = this.TitleBar.transform.Find("CloseHolder").gameObject;

            // Inspect under mouse dropdown on title bar

            GameObject mouseDropdown = UIFactory.CreateDropdown(closeHolder, "MouseInspectDropdown", out MouseInspectDropdown, "Mouse Inspect", 14,
                MouseInspector.OnDropdownSelect);
            UIFactory.SetLayoutElement(mouseDropdown, minHeight: 25, minWidth: 140);
            MouseInspectDropdown.options.Add(new Dropdown.OptionData("Mouse Inspect"));
            MouseInspectDropdown.options.Add(new Dropdown.OptionData("World"));
            MouseInspectDropdown.options.Add(new Dropdown.OptionData("UI"));
            mouseDropdown.transform.SetSiblingIndex(0);

            // add close all button to titlebar

            UniverseLib.UI.Models.ButtonRef closeAllBtn = UIFactory.CreateButton(closeHolder.gameObject, "CloseAllBtn", "Close All",
                new Color(0.3f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(closeAllBtn.Component.gameObject, minHeight: 25, minWidth: 80);
            closeAllBtn.Component.transform.SetSiblingIndex(closeAllBtn.Component.transform.GetSiblingIndex() - 1);
            closeAllBtn.OnClick += InspectorManager.CloseAllTabs;

            // this.UIRoot.GetComponent<Mask>().enabled = false;

            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(this.ContentRoot, true, true, true, true, 4, padLeft: 5, padRight: 5);

            this.NavbarHolder = UIFactory.CreateGridGroup(this.ContentRoot, "Navbar", new Vector2(200, 22), new Vector2(4, 4),
                new Color(0.05f, 0.05f, 0.05f));
            //UIFactory.SetLayoutElement(NavbarHolder, flexibleWidth: 9999, minHeight: 0, preferredHeight: 0, flexibleHeight: 9999);
            NavbarHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            this.ContentHolder = UIFactory.CreateVerticalGroup(this.ContentRoot, "ContentHolder", true, true, true, true, 0, default,
                new Color(0.1f, 0.1f, 0.1f));
            UIFactory.SetLayoutElement(ContentHolder, flexibleHeight: 9999);
            ContentRect = ContentHolder.GetComponent<RectTransform>();

            this.SetActive(false);
        }
    }
}
```

`src/UI/Panels/LogPanel.cs`:

```cs
using System.Diagnostics;
using UnityExplorer.Config;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.UI.Panels
{
    public class LogPanel : UEPanel, ICellPoolDataSource<ConsoleLogCell>
    {
        public struct LogInfo
        {
            public string message;
            public LogType type;

            public LogInfo(string message, LogType type) { this.message = message; this.type = type; }
        }

        private static readonly List<LogInfo> Logs = new();
        private static string CurrentStreamPath;

        public override string Name => "Log";
        public override UIManager.Panels PanelType => UIManager.Panels.ConsoleLog;

        public override int MinWidth => 350;
        public override int MinHeight => 75;
        public override Vector2 DefaultAnchorMin => new(0.5f, 0.03f);
        public override Vector2 DefaultAnchorMax => new(0.9f, 0.2f);

        public override bool ShouldSaveActiveState => true;
        public override bool ShowByDefault => true;

        public int ItemCount => Logs.Count;

        private static ScrollPool<ConsoleLogCell> logScrollPool;

        public LogPanel(UIBase owner) : base(owner)
        {
            SetupIO();
        }

        private static bool DoneScrollPoolInit;

        public override void SetActive(bool active)
        {
            base.SetActive(active);

            if (active && !DoneScrollPoolInit)
            {
                LayoutRebuilder.ForceRebuildLayoutImmediate(this.Rect);
                logScrollPool.Initialize(this);
                DoneScrollPoolInit = true;
            }

            logScrollPool.Refresh(true, false);
        }

        private void SetupIO()
        {
            string fileName = $"UnityExplorer {DateTime.Now:u}.txt";
            fileName = IOUtility.EnsureValidFilename(fileName);
            string path = Path.Combine(ExplorerCore.ExplorerFolder, "Logs");
            CurrentStreamPath = IOUtility.EnsureValidFilePath(Path.Combine(path, fileName));

            // clean old log(s)
            string[] files = Directory.GetFiles(path);
            if (files.Length >= 10)
            {
                List<string> sorted = files.ToList();
                // sort by 'datetime.ToString("u")' will put the oldest ones first
                sorted.Sort();
                for (int i = 0; i < files.Length - 9; i++)
                    File.Delete(files[i]);
            }

            File.WriteAllLines(CurrentStreamPath, Logs.Select(it => it.message).ToArray());
        }

        // Logging

        public static void Log(string message, LogType type)
        {
            Logs.Add(new LogInfo(message, type));

            if (CurrentStreamPath != null)
                File.AppendAllText(CurrentStreamPath, '\n' + message);

            if (logScrollPool != null)
                logScrollPool.Refresh(true, false);
        }

        private static void ClearLogs()
        {
            Logs.Clear();
            logScrollPool.Refresh(true, true);
        }

        private static void OpenLogFile()
        {
            if (File.Exists(CurrentStreamPath))
                Process.Start(CurrentStreamPath);
        }

        // Cell pool

        private static readonly Dictionary<LogType, Color> logColors = new()
        {
            { LogType.Log,       Color.white },
            { LogType.Warning,   Color.yellow },
            { LogType.Assert,    Color.yellow },
            { LogType.Error,     Color.red },
            { LogType.Exception, Color.red },
        };

        private readonly Color logEvenColor = new(0.34f, 0.34f, 0.34f);
        private readonly Color logOddColor = new(0.28f, 0.28f, 0.28f);

        public void OnCellBorrowed(ConsoleLogCell cell) { }

        public void SetCell(ConsoleLogCell cell, int index)
        {
            if (index >= Logs.Count)
            {
                cell.Disable();
                return;
            }

            // Logs are displayed in reverse order (newest at top)
            index = Logs.Count - index - 1;

            LogInfo log = Logs[index];
            cell.IndexLabel.text = $"{index}:";
            cell.Input.Text = log.message;
            cell.Input.Component.textComponent.color = logColors[log.type];

            Color color = index % 2 == 0 ? logEvenColor : logOddColor;
            RuntimeHelper.SetColorBlock(cell.Input.Component, color);
        }

        // UI Construction

        protected override void ConstructPanelContent()
        {
            // Log scroll pool

            logScrollPool = UIFactory.CreateScrollPool<ConsoleLogCell>(this.ContentRoot, "Logs", out GameObject scrollObj,
                out GameObject scrollContent, new Color(0.03f, 0.03f, 0.03f));
            UIFactory.SetLayoutElement(scrollObj, flexibleWidth: 9999, flexibleHeight: 9999);

            // Buttons and toggles

            GameObject optionsRow = UIFactory.CreateUIObject("OptionsRow", this.ContentRoot);
            UIFactory.SetLayoutElement(optionsRow, minHeight: 25, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(optionsRow, false, false, true, true, 5, 2, 2, 2, 2);

            ButtonRef clearButton = UIFactory.CreateButton(optionsRow, "ClearButton", "Clear", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(clearButton.Component.gameObject, minHeight: 23, flexibleHeight: 0, minWidth: 60);
            clearButton.OnClick += ClearLogs;
            clearButton.Component.transform.SetSiblingIndex(1);

            ButtonRef fileButton = UIFactory.CreateButton(optionsRow, "FileButton", "Open Log File", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(fileButton.Component.gameObject, minHeight: 23, flexibleHeight: 0, minWidth: 100);
            fileButton.OnClick += OpenLogFile;
            fileButton.Component.transform.SetSiblingIndex(2);

            GameObject unityToggle = UIFactory.CreateToggle(optionsRow, "UnityLogToggle", out Toggle toggle, out Text toggleText);
            UIFactory.SetLayoutElement(unityToggle, minHeight: 25, minWidth: 150);
            toggleText.text = "Log Unity Debug?";
            toggle.isOn = ConfigManager.Log_Unity_Debug.Value;
            ConfigManager.Log_Unity_Debug.OnValueChanged += (bool val) => toggle.isOn = val;
            toggle.onValueChanged.AddListener((bool val) => ConfigManager.Log_Unity_Debug.Value = val);
        }
    }

    #region Log Cell View

    public class ConsoleLogCell : ICell
    {
        public Text IndexLabel;
        public InputFieldRef Input;

        public RectTransform Rect { get; set; }
        public GameObject UIRoot { get; set; }

        public float DefaultHeight => 25;

        public bool Enabled => UIRoot.activeInHierarchy;
        public void Enable() => UIRoot.SetActive(true);
        public void Disable() => UIRoot.SetActive(false);


        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateUIObject("LogCell", parent, new Vector2(25, 25));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 3);
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, minWidth: 50, flexibleWidth: 9999);

            IndexLabel = UIFactory.CreateLabel(UIRoot, "IndexLabel", "i:", TextAnchor.MiddleCenter, Color.grey, false, 12);
            UIFactory.SetLayoutElement(IndexLabel.gameObject, minHeight: 25, minWidth: 30, flexibleWidth: 40);

            Input = UIFactory.CreateInputField(UIRoot, "Input", "");
            //Input.Component.gameObject.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;
            UIFactory.SetLayoutElement(Input.UIRoot, minHeight: 25, flexibleWidth: 9999);
            RuntimeHelper.SetColorBlock(Input.Component, new Color(0.1f, 0.1f, 0.1f), new Color(0.13f, 0.13f, 0.13f),
                new Color(0.07f, 0.07f, 0.07f));
            Input.Component.GetComponent<Image>().color = new Color(0.2f, 0.2f, 0.2f);

            Input.Component.readOnly = true;
            Input.Component.textComponent.supportRichText = true;
            Input.Component.lineType = InputField.LineType.MultiLineNewline;
            Input.Component.textComponent.font = UniversalUI.ConsoleFont;
            Input.PlaceholderText.font = UniversalUI.ConsoleFont;

            return UIRoot;
        }
    }

    #endregion
}

```

`src/UI/Panels/MouseInspectorResultsPanel.cs`:

```cs
using UnityExplorer.Inspectors.MouseInspectors;
using UniverseLib.UI;
using UniverseLib.UI.Widgets.ButtonList;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.UI.Panels
{
    public class MouseInspectorResultsPanel : UEPanel
    {
        public override UIManager.Panels PanelType => UIManager.Panels.UIInspectorResults;

        public override string Name => "UI Inspector Results";

        public override int MinWidth => 500;
        public override int MinHeight => 500;
        public override Vector2 DefaultAnchorMin => new(0.5f, 0.5f);
        public override Vector2 DefaultAnchorMax => new(0.5f, 0.5f);
        
        public override bool CanDragAndResize => true;
        public override bool NavButtonWanted => false;
        public override bool ShouldSaveActiveState => false;
        public override bool ShowByDefault => false;

        private ButtonListHandler<GameObject, ButtonCell> dataHandler;
        private ScrollPool<ButtonCell> buttonScrollPool;

        public MouseInspectorResultsPanel(UIBase owner) : base(owner)
        {
        }

        public void ShowResults()
        {
            dataHandler.RefreshData();
            buttonScrollPool.Refresh(true, true);
        }

        private List<GameObject> GetEntries() => UiInspector.LastHitObjects;

        private bool ShouldDisplayCell(object cell, string filter) => true;

        private void OnCellClicked(int index)
        {
            if (index >= UiInspector.LastHitObjects.Count)
                return;

            InspectorManager.Inspect(UiInspector.LastHitObjects[index]);
        }

        private void SetCell(ButtonCell cell, int index)
        {
            if (index >= UiInspector.LastHitObjects.Count)
                return;

            GameObject obj = UiInspector.LastHitObjects[index];
            cell.Button.ButtonText.text = $"<color=cyan>{obj.name}</color> ({obj.transform.GetTransformPath(true)})";
        }

        public override void SetDefaultSizeAndPosition()
        {
            base.SetDefaultSizeAndPosition();

            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 500f);
            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 500f);
        }

        protected override void ConstructPanelContent()
        {
            dataHandler = new ButtonListHandler<GameObject, ButtonCell>(buttonScrollPool, GetEntries, SetCell, ShouldDisplayCell, OnCellClicked);

            buttonScrollPool = UIFactory.CreateScrollPool<ButtonCell>(this.ContentRoot, "ResultsList", out GameObject scrollObj,
                out GameObject scrollContent);

            buttonScrollPool.Initialize(dataHandler);
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
        }
    }
}

```

`src/UI/Panels/ObjectExplorerPanel.cs`:

```cs
using UnityExplorer.ObjectExplorer;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.UI.Panels
{
    public class ObjectExplorerPanel : UEPanel
    {
        public override string Name => "Object Explorer";
        public override UIManager.Panels PanelType => UIManager.Panels.ObjectExplorer;

        public override int MinWidth => 350;
        public override int MinHeight => 200;
        public override Vector2 DefaultAnchorMin => new(0.125f, 0.175f);
        public override Vector2 DefaultAnchorMax => new(0.325f, 0.925f);

        public SceneExplorer SceneExplorer;
        public ObjectSearch ObjectSearch;

        public override bool ShowByDefault => true;
        public override bool ShouldSaveActiveState => true;

        public int SelectedTab = 0;
        private readonly List<UIModel> tabPages = new();
        private readonly List<ButtonRef> tabButtons = new();

        public ObjectExplorerPanel(UIBase owner) : base(owner)
        {
        }

        public void SetTab(int tabIndex)
        {
            if (SelectedTab != -1)
                DisableTab(SelectedTab);

            UIModel content = tabPages[tabIndex];
            content.SetActive(true);

            ButtonRef button = tabButtons[tabIndex];
            RuntimeHelper.SetColorBlock(button.Component, UniversalUI.EnabledButtonColor, UniversalUI.EnabledButtonColor * 1.2f);

            SelectedTab = tabIndex;
            SaveInternalData();
        }

        private void DisableTab(int tabIndex)
        {
            tabPages[tabIndex].SetActive(false);
            RuntimeHelper.SetColorBlock(tabButtons[tabIndex].Component, UniversalUI.DisabledButtonColor, UniversalUI.DisabledButtonColor * 1.2f);
        }

        public override void Update()
        {
            if (SelectedTab == 0)
                SceneExplorer.Update();
            else
                ObjectSearch.Update();
        }

        public override string ToSaveData()
        {
            return string.Join("|", new string[] { base.ToSaveData(), SelectedTab.ToString() });
        }

        protected override void ApplySaveData(string data)
        {
            base.ApplySaveData(data);

            try
            {
                int tab = int.Parse(data.Split('|').Last());
                SelectedTab = tab;
            }
            catch
            {
                SelectedTab = 0;
            }

            SelectedTab = Math.Max(0, SelectedTab);
            SelectedTab = Math.Min(1, SelectedTab);

            SetTab(SelectedTab);
        }

        protected override void ConstructPanelContent()
        {
            // Tab bar
            GameObject tabGroup = UIFactory.CreateHorizontalGroup(ContentRoot, "TabBar", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(tabGroup, minHeight: 25, flexibleHeight: 0);

            // Scene Explorer
            SceneExplorer = new SceneExplorer(this);
            SceneExplorer.ConstructUI(ContentRoot);
            tabPages.Add(SceneExplorer);

            // Object search
            ObjectSearch = new ObjectSearch(this);
            ObjectSearch.ConstructUI(ContentRoot);
            tabPages.Add(ObjectSearch);

            // set up tabs
            AddTabButton(tabGroup, "Scene Explorer");
            AddTabButton(tabGroup, "Object Search");

            // default active state: Active
            this.SetActive(true);
        }

        private void AddTabButton(GameObject tabGroup, string label)
        {
            ButtonRef button = UIFactory.CreateButton(tabGroup, $"Button_{label}", label);

            int idx = tabButtons.Count;
            //button.onClick.AddListener(() => { SetTab(idx); });
            button.OnClick += () => { SetTab(idx); };

            tabButtons.Add(button);

            DisableTab(tabButtons.Count - 1);
        }
    }
}

```

`src/UI/Panels/OptionsPanel.cs`:

```cs
using UnityExplorer.CacheObject;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.Config;
using UniverseLib.UI;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.UI.Panels
{
    public class OptionsPanel : UEPanel, ICacheObjectController, ICellPoolDataSource<ConfigEntryCell>
    {
        public override string Name => "Options";
        public override UIManager.Panels PanelType => UIManager.Panels.Options;

        public override int MinWidth => 600;
        public override int MinHeight => 200;
        public override Vector2 DefaultAnchorMin => new(0.5f, 0.1f);
        public override Vector2 DefaultAnchorMax => new(0.5f, 0.85f);

        public override bool ShouldSaveActiveState => false;
        public override bool ShowByDefault => false;

        // Entry holders
        private readonly List<CacheConfigEntry> configEntries = new();

        // ICacheObjectController
        public CacheObjectBase ParentCacheObject => null;
        public object Target => null;
        public Type TargetType => null;
        public bool CanWrite => true;

        // ICellPoolDataSource
        public int ItemCount => configEntries.Count;

        public OptionsPanel(UIBase owner) : base(owner)
        {
            foreach (KeyValuePair<string, IConfigElement> entry in ConfigManager.ConfigElements)
            {
                CacheConfigEntry cache = new(entry.Value)
                {
                    Owner = this
                };
                configEntries.Add(cache);
            }

            foreach (CacheConfigEntry config in configEntries)
                config.UpdateValueFromSource();
        }

        public void OnCellBorrowed(ConfigEntryCell cell)
        {
        }

        public void SetCell(ConfigEntryCell cell, int index)
        {
            CacheObjectControllerHelper.SetCell(cell, index, this.configEntries, null);
        }

        // UI Construction

        public override void SetDefaultSizeAndPosition()
        {
            base.SetDefaultSizeAndPosition();

            Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 600f);
        }

        protected override void ConstructPanelContent()
        {
            // Save button

            UniverseLib.UI.Models.ButtonRef saveBtn = UIFactory.CreateButton(this.ContentRoot, "Save", "Save Options", new Color(0.2f, 0.3f, 0.2f));
            UIFactory.SetLayoutElement(saveBtn.Component.gameObject, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 0);
            saveBtn.OnClick += ConfigManager.Handler.SaveConfig;

            // Config entries

            ScrollPool<ConfigEntryCell> scrollPool = UIFactory.CreateScrollPool<ConfigEntryCell>(
                this.ContentRoot, 
                "ConfigEntries", 
                out GameObject scrollObj,
                out GameObject scrollContent);

            scrollPool.Initialize(this);
        }
    }
}

```

`src/UI/Panels/UEPanel.cs`:

```cs
using System.Globalization;
using UnityExplorer.Config;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Panels;

namespace UnityExplorer.UI.Panels
{
    public abstract class UEPanel : PanelBase
    {
        protected UEPanel(UIBase owner) : base(owner) { }

        public abstract UIManager.Panels PanelType { get; }
        public virtual bool ShowByDefault => false;
        public virtual bool ShouldSaveActiveState => true;

        public virtual bool NavButtonWanted => true;
        public ButtonRef NavButton { get; internal set; }

        protected override PanelDragger CreatePanelDragger()
        {
            return new UEPanelDragger(this);
        }

        public override void OnFinishDrag()
        {
            base.OnFinishDrag();
            SaveInternalData();
        }

        public override void OnFinishResize()
        {
            base.OnFinishResize();
            SaveInternalData();
        }

        public override void SetActive(bool active)
        {
            if (this.Enabled != active)
            {
                base.SetActive(active);

                if (!ApplyingSaveData)
                    SaveInternalData();

                if (NavButtonWanted && NavButton != null)
                {
                    Color color = active ? UniversalUI.EnabledButtonColor : UniversalUI.DisabledButtonColor;
                    RuntimeHelper.SetColorBlock(NavButton.Component, color, color * 1.2f);
                }
            }

            if (!active)
            {
                if (Dragger != null)
                    this.Dragger.WasDragging = false;
            }
            else
            {
                this.UIRoot.transform.SetAsLastSibling();
                (this.Owner.Panels as UEPanelManager).DoInvokeOnPanelsReordered();
            }
        }

        // Save Data

        bool setDefault = false;

        public override void SetDefaultSizeAndPosition()
        {
            if (setDefault)
                return;
            setDefault = true;

            base.SetDefaultSizeAndPosition();
        }

        public bool ApplyingSaveData { get; set; }

        public void SaveInternalData()
        {
            if (UIManager.Initializing || ApplyingSaveData)
                return;

            SetSaveDataToConfigValue();
        }

        private void SetSaveDataToConfigValue() 
            => ConfigManager.GetPanelSaveData(this.PanelType).Value = this.ToSaveData();

        public virtual string ToSaveData()
        {
            try
            {
                return string.Join("|", new string[]
                {
                        $"{ShouldSaveActiveState && Enabled}",
                        Rect.RectAnchorsToString(),
                        Rect.RectPositionToString()
                });
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception generating Panel save data: {ex}");
                return "";
            }
        }

        public virtual void ApplySaveData()
        {
            string data = ConfigManager.GetPanelSaveData(this.PanelType).Value;
            ApplySaveData(data);
        }

        protected virtual void ApplySaveData(string data)
        {
            if (string.IsNullOrEmpty(data))
                return;

            string[] split = data.Split('|');

            try
            {
                Rect.SetAnchorsFromString(split[1]);
                Rect.SetPositionFromString(split[2]);
                this.EnsureValidSize();
                this.EnsureValidPosition();
                this.SetActive(bool.Parse(split[0]));
            }
            catch
            {
                ExplorerCore.LogWarning("Invalid or corrupt panel save data! Restoring to default.");
                SetDefaultSizeAndPosition();
                SetSaveDataToConfigValue();
            }
        }

        public override void ConstructUI()
        {
            base.ConstructUI();

            if (NavButtonWanted)
            {
                // create navbar button

                NavButton = UIFactory.CreateButton(UIManager.NavbarTabButtonHolder, $"Button_{PanelType}", Name);
                GameObject navBtn = NavButton.Component.gameObject;
                navBtn.AddComponent<ContentSizeFitter>().horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
                UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(navBtn, false, true, true, true, 0, 0, 0, 5, 5, TextAnchor.MiddleCenter);
                UIFactory.SetLayoutElement(navBtn, minWidth: 80);

                RuntimeHelper.SetColorBlock(NavButton.Component, UniversalUI.DisabledButtonColor, UniversalUI.DisabledButtonColor * 1.2f);
                NavButton.OnClick += () => { UIManager.TogglePanel(PanelType); };

                GameObject txtObj = navBtn.transform.Find("Text").gameObject;
                txtObj.AddComponent<ContentSizeFitter>().horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
            }

            this.SetActive(true);
            this.SetActive(false);
            this.SetActive(ShowByDefault);
        }

        protected override void LateConstructUI()
        {
            ApplyingSaveData = true;

            base.LateConstructUI();

            // apply panel save data or revert to default
            try
            {
                ApplySaveData();
            }
            catch (Exception ex)
            {
                ExplorerCore.Log($"Exception loading panel save data: {ex}");
                SetDefaultSizeAndPosition();
            }

            // simple listener for saving enabled state
            this.OnToggleEnabled += (bool val) =>
            {
                SaveInternalData();
            };

            ApplyingSaveData = false;

            Dragger.OnEndResize();
        }
    }

    #region WINDOW ANCHORS / POSITION SAVE DATA HELPERS

    public static class RectSaveExtensions
    {
        // Window Anchors helpers

        internal static string RectAnchorsToString(this RectTransform rect)
        {
            if (!rect)
                throw new ArgumentNullException("rect");

            return string.Format(CultureInfo.InvariantCulture, "{0},{1},{2},{3}", new object[]
            {
                rect.anchorMin.x,
                rect.anchorMin.y,
                rect.anchorMax.x,
                rect.anchorMax.y
            });
        }

        internal static void SetAnchorsFromString(this RectTransform panel, string stringAnchors)
        {
            if (string.IsNullOrEmpty(stringAnchors))
                throw new ArgumentNullException("stringAnchors");

            if (stringAnchors.Contains(" "))
                // outdated save data, not worth recovering just reset it.
                throw new Exception("invalid save data, resetting.");

            string[] split = stringAnchors.Split(',');

            if (split.Length != 4)
                throw new Exception($"stringAnchors split is unexpected length: {split.Length}");

            Vector4 anchors;
            anchors.x = float.Parse(split[0], CultureInfo.InvariantCulture);
            anchors.y = float.Parse(split[1], CultureInfo.InvariantCulture);
            anchors.z = float.Parse(split[2], CultureInfo.InvariantCulture);
            anchors.w = float.Parse(split[3], CultureInfo.InvariantCulture);

            panel.anchorMin = new Vector2(anchors.x, anchors.y);
            panel.anchorMax = new Vector2(anchors.z, anchors.w);
        }

        internal static string RectPositionToString(this RectTransform rect)
        {
            if (!rect)
                throw new ArgumentNullException("rect");

            return string.Format(CultureInfo.InvariantCulture, "{0},{1}", new object[]
            {
                rect.anchoredPosition.x, rect.anchoredPosition.y
            });
        }

        internal static void SetPositionFromString(this RectTransform rect, string stringPosition)
        {
            if (string.IsNullOrEmpty(stringPosition))
                throw new ArgumentNullException(stringPosition);

            if (stringPosition.Contains(" "))
                // outdated save data, not worth recovering just reset it.
                throw new Exception("invalid save data, resetting.");

            string[] split = stringPosition.Split(',');

            if (split.Length != 2)
                throw new Exception($"stringPosition split is unexpected length: {split.Length}");

            Vector3 vector = rect.anchoredPosition;
            vector.x = float.Parse(split[0], CultureInfo.InvariantCulture);
            vector.y = float.Parse(split[1], CultureInfo.InvariantCulture);
            rect.anchoredPosition = vector;
        }
    }

    #endregion
}

```

`src/UI/Panels/UEPanelDragger.cs`:

```cs
using UniverseLib.UI.Panels;

namespace UnityExplorer.UI.Panels
{
    public class UEPanelDragger : PanelDragger
    {
        public UEPanelDragger(PanelBase uiPanel) : base(uiPanel) { }

        protected override bool MouseInResizeArea(Vector2 mousePos)
        {
            return !UIManager.NavBarRect.rect.Contains(UIManager.NavBarRect.InverseTransformPoint(mousePos))
                && base.MouseInResizeArea(mousePos);
        }
    }
}

```

`src/UI/UEPanelManager.cs`:

```cs
using UnityExplorer.UI.Panels;
using UniverseLib.UI;
using UniverseLib.UI.Panels;

namespace UnityExplorer.UI
{
    public class UEPanelManager : PanelManager
    {
        public UEPanelManager(UIBase owner) : base(owner) { }

        protected override Vector3 MousePosition => DisplayManager.MousePosition;

        protected override Vector2 ScreenDimensions => new(DisplayManager.Width, DisplayManager.Height);

        protected override bool MouseInTargetDisplay => DisplayManager.MouseInTargetDisplay;

        internal void DoInvokeOnPanelsReordered()
        {
            InvokeOnPanelsReordered();
        }

        protected override void SortDraggerHeirarchy()
        {
            base.SortDraggerHeirarchy();

            // move AutoCompleter to first update
            if (!UIManager.Initializing && AutoCompleteModal.Instance != null)
            {
                this.draggerInstances.Remove(AutoCompleteModal.Instance.Dragger);
                this.draggerInstances.Insert(0, AutoCompleteModal.Instance.Dragger);
            }
        }
    }
}

```

`src/UI/UIManager.cs`:

```cs
using UnityExplorer.Config;
using UnityExplorer.CSConsole;
using UnityExplorer.Inspectors;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets;
using UniverseLib.Input;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.UI
{
    public static class UIManager
    {
        public enum Panels
        {
            ObjectExplorer,
            Inspector,
            CSConsole,
            Options,
            ConsoleLog,
            AutoCompleter,
            UIInspectorResults,
            HookManager,
            Clipboard,
            Freecam
        }

        public enum VerticalAnchor
        {
            Top,
            Bottom
        }

        public static VerticalAnchor NavbarAnchor = VerticalAnchor.Top;

        public static bool Initializing { get; internal set; } = true;

        internal static UIBase UiBase { get; private set; }
        public static GameObject UIRoot => UiBase?.RootObject;
        public static RectTransform UIRootRect { get; private set; }
        public static Canvas UICanvas { get; private set; }

        internal static readonly Dictionary<Panels, UEPanel> UIPanels = new();

        public static RectTransform NavBarRect;
        public static GameObject NavbarTabButtonHolder;
        private static readonly Vector2 NAVBAR_DIMENSIONS = new(1020f, 35f);

        private static ButtonRef closeBtn;
        private static TimeScaleWidget timeScaleWidget;

        private static int lastScreenWidth;
        private static int lastScreenHeight;

        public static bool ShowMenu
        {
            get => UiBase != null && UiBase.Enabled;
            set
            {
                if (UiBase == null || !UIRoot || UiBase.Enabled == value)
                    return;

                UniversalUI.SetUIActive(ExplorerCore.GUID, value);
                UniversalUI.SetUIActive(MouseInspector.UIBaseGUID, value);
            }
        }

        // Initialization

        internal static void InitUI()
        {
            UiBase = UniversalUI.RegisterUI<ExplorerUIBase>(ExplorerCore.GUID, Update);

            UIRootRect = UIRoot.GetComponent<RectTransform>();
            UICanvas = UIRoot.GetComponent<Canvas>();

            DisplayManager.Init();

            Display display = DisplayManager.ActiveDisplay;
            lastScreenWidth = display.renderingWidth;
            lastScreenHeight = display.renderingHeight;

            // Create UI.
            CreateTopNavBar();
            // This could be automated with Assembly.GetTypes(),
            // but the order is important and I'd have to write something to handle the order.
            UIPanels.Add(Panels.AutoCompleter, new AutoCompleteModal(UiBase));
            UIPanels.Add(Panels.ObjectExplorer, new ObjectExplorerPanel(UiBase));
            UIPanels.Add(Panels.Inspector, new InspectorPanel(UiBase));
            UIPanels.Add(Panels.CSConsole, new CSConsolePanel(UiBase));
            UIPanels.Add(Panels.HookManager, new HookManagerPanel(UiBase));
            UIPanels.Add(Panels.Freecam, new FreeCamPanel(UiBase));
            UIPanels.Add(Panels.Clipboard, new ClipboardPanel(UiBase));
            UIPanels.Add(Panels.ConsoleLog, new LogPanel(UiBase));
            UIPanels.Add(Panels.Options, new OptionsPanel(UiBase));
            UIPanels.Add(Panels.UIInspectorResults, new MouseInspectorResultsPanel(UiBase));

            MouseInspector.inspectorUIBase = UniversalUI.RegisterUI(MouseInspector.UIBaseGUID, null);
            new MouseInspector(MouseInspector.inspectorUIBase);

            // Call some initialize methods
            Notification.Init();
            ConsoleController.Init();

            // Failsafe fix, in some games all dropdowns displayed values are blank on startup for some reason.
            foreach (Dropdown dropdown in UIRoot.GetComponentsInChildren<Dropdown>(true))
                dropdown.RefreshShownValue();

            Initializing = false;

            if (ConfigManager.Hide_On_Startup.Value)
                ShowMenu = false;
        }

        // Main UI Update loop

        public static void Update()
        {
            if (!UIRoot)
                return;

            // If we are doing a Mouse Inspect, we don't need to update anything else.
            if (MouseInspector.Instance.TryUpdate())
                return;

            // Update Notification modal
            Notification.Update();

            // Check forceUnlockMouse toggle
            if (InputManager.GetKeyDown(ConfigManager.Force_Unlock_Toggle.Value))
                UniverseLib.Config.ConfigManager.Force_Unlock_Mouse = !UniverseLib.Config.ConfigManager.Force_Unlock_Mouse;

            // update the timescale value
            timeScaleWidget.Update();

            // check screen dimension change
            Display display = DisplayManager.ActiveDisplay;
            if (display.renderingWidth != lastScreenWidth || display.renderingHeight != lastScreenHeight)
                OnScreenDimensionsChanged();
        }

        // Panels

        public static UEPanel GetPanel(Panels panel) => UIPanels[panel];

        public static T GetPanel<T>(Panels panel) where T : UEPanel => (T)UIPanels[panel];

        public static void TogglePanel(Panels panel)
        {
            UEPanel uiPanel = GetPanel(panel);
            SetPanelActive(panel, !uiPanel.Enabled);
        }

        public static void SetPanelActive(Panels panelType, bool active)
        {
            GetPanel(panelType).SetActive(active);
        }

        public static void SetPanelActive(UEPanel panel, bool active)
        {
            panel.SetActive(active);
        }

        // navbar

        public static void SetNavBarAnchor()
        {
            switch (NavbarAnchor)
            {
                case VerticalAnchor.Top:
                    NavBarRect.anchorMin = new Vector2(0.5f, 1f);
                    NavBarRect.anchorMax = new Vector2(0.5f, 1f);
                    NavBarRect.anchoredPosition = new Vector2(NavBarRect.anchoredPosition.x, 0);
                    NavBarRect.sizeDelta = NAVBAR_DIMENSIONS;
                    break;

                case VerticalAnchor.Bottom:
                    NavBarRect.anchorMin = new Vector2(0.5f, 0f);
                    NavBarRect.anchorMax = new Vector2(0.5f, 0f);
                    NavBarRect.anchoredPosition = new Vector2(NavBarRect.anchoredPosition.x, 35);
                    NavBarRect.sizeDelta = NAVBAR_DIMENSIONS;
                    break;
            }
        }

        // listeners

        private static void OnScreenDimensionsChanged()
        {
            Display display = DisplayManager.ActiveDisplay;
            lastScreenWidth = display.renderingWidth;
            lastScreenHeight = display.renderingHeight;

            foreach (KeyValuePair<Panels, UEPanel> panel in UIPanels)
            {
                panel.Value.EnsureValidSize();
                panel.Value.EnsureValidPosition();
                panel.Value.Dragger.OnEndResize();
            }
        }

        private static void OnCloseButtonClicked()
        {
            ShowMenu = false;
        }

        private static void Master_Toggle_OnValueChanged(KeyCode val)
        {
            closeBtn.ButtonText.text = val.ToString();
        }

        

        // UI Construction

        private static void CreateTopNavBar()
        {
            GameObject navbarPanel = UIFactory.CreateUIObject("MainNavbar", UIRoot);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(navbarPanel, false, false, true, true, 5, 4, 4, 4, 4, TextAnchor.MiddleCenter);
            navbarPanel.AddComponent<Image>().color = new Color(0.1f, 0.1f, 0.1f);
            NavBarRect = navbarPanel.GetComponent<RectTransform>();
            NavBarRect.pivot = new Vector2(0.5f, 1f);

            NavbarAnchor = ConfigManager.Main_Navbar_Anchor.Value;
            SetNavBarAnchor();
            ConfigManager.Main_Navbar_Anchor.OnValueChanged += (VerticalAnchor val) =>
            {
                NavbarAnchor = val;
                SetNavBarAnchor();
            };

            // UnityExplorer title

            string titleTxt = $"UE <i><color=grey>{ExplorerCore.VERSION}</color></i>";
            Text title = UIFactory.CreateLabel(navbarPanel, "Title", titleTxt, TextAnchor.MiddleCenter, default, true, 14);
            UIFactory.SetLayoutElement(title.gameObject, minWidth: 75, flexibleWidth: 0);

            // panel tabs

            NavbarTabButtonHolder = UIFactory.CreateUIObject("NavTabButtonHolder", navbarPanel);
            UIFactory.SetLayoutElement(NavbarTabButtonHolder, minHeight: 25, flexibleHeight: 999, flexibleWidth: 999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(NavbarTabButtonHolder, false, true, true, true, 4, 2, 2, 2, 2);

            // Time scale widget
            timeScaleWidget = new(navbarPanel);

            //spacer
            GameObject spacer = UIFactory.CreateUIObject("Spacer", navbarPanel);
            UIFactory.SetLayoutElement(spacer, minWidth: 15);

            // Hide menu button

            closeBtn = UIFactory.CreateButton(navbarPanel, "CloseButton", ConfigManager.Master_Toggle.Value.ToString());
            UIFactory.SetLayoutElement(closeBtn.Component.gameObject, minHeight: 25, minWidth: 60, flexibleWidth: 0);
            RuntimeHelper.SetColorBlock(closeBtn.Component, new Color(0.63f, 0.32f, 0.31f),
                new Color(0.81f, 0.25f, 0.2f), new Color(0.6f, 0.18f, 0.16f));

            ConfigManager.Master_Toggle.OnValueChanged += Master_Toggle_OnValueChanged;
            closeBtn.OnClick += OnCloseButtonClicked;
        }
    }
}

```

`src/UI/Widgets/AutoComplete/EnumCompleter.cs`:

```cs
using System.Collections.Specialized;
using UnityExplorer.CacheObject.IValues;
using UnityExplorer.UI.Panels;
using UniverseLib.UI.Models;

namespace UnityExplorer.UI.Widgets.AutoComplete
{
    public class EnumCompleter : ISuggestionProvider
    {
        public bool Enabled
        {
            get => _enabled;
            set
            {
                _enabled = value;
                if (!_enabled)
                    AutoCompleteModal.Instance.ReleaseOwnership(this);
            }
        }
        private bool _enabled = true;

        public event Action<Suggestion> SuggestionClicked;

        public Type EnumType { get; set; }

        public InputFieldRef InputField { get; }
        public bool AnchorToCaretPosition => false;

        private readonly List<Suggestion> suggestions = new();
        private readonly HashSet<string> suggestedValues = new();

        private OrderedDictionary enumValues;

        internal string chosenSuggestion;

        bool ISuggestionProvider.AllowNavigation => false;

        public EnumCompleter(Type enumType, InputFieldRef inputField)
        {
            EnumType = enumType;
            InputField = inputField;

            inputField.OnValueChanged += OnInputFieldChanged;

            if (EnumType != null)
                CacheEnumValues();
        }

        public void CacheEnumValues()
        {
            enumValues = InteractiveEnum.GetEnumValues(EnumType);
        }

        private string GetLastSplitInput(string fullInput)
        {
            string ret = fullInput;

            int lastSplit = fullInput.LastIndexOf(',');
            if (lastSplit >= 0)
            {
                lastSplit++;
                if (lastSplit == fullInput.Length)
                    ret = "";
                else
                    ret = fullInput.Substring(lastSplit);
            }

            return ret;
        }

        public void OnSuggestionClicked(Suggestion suggestion)
        {
            chosenSuggestion = suggestion.UnderlyingValue;

            string lastInput = GetLastSplitInput(InputField.Text);

            if (lastInput != suggestion.UnderlyingValue)
            {
                string valueToSet = InputField.Text;

                if (valueToSet.Length > 0)
                    valueToSet = valueToSet.Substring(0, InputField.Text.Length - lastInput.Length);

                valueToSet += suggestion.UnderlyingValue;

                InputField.Text = valueToSet;

                //InputField.Text += suggestion.UnderlyingValue.Substring(lastInput.Length);
            }

            SuggestionClicked?.Invoke(suggestion);

            suggestions.Clear();
            AutoCompleteModal.Instance.SetSuggestions(suggestions);
        }

        public void HelperButtonClicked()
        {
            GetSuggestions("");
            AutoCompleteModal.TakeOwnership(this);
            AutoCompleteModal.Instance.SetSuggestions(suggestions);
        }

        private void OnInputFieldChanged(string value)
        {
            if (!Enabled)
                return;

            if (string.IsNullOrEmpty(value) || GetLastSplitInput(value) == chosenSuggestion)
            {
                chosenSuggestion = null;
                AutoCompleteModal.Instance.ReleaseOwnership(this);
            }
            else
            {
                GetSuggestions(value);

                AutoCompleteModal.TakeOwnership(this);
                AutoCompleteModal.Instance.SetSuggestions(suggestions);
            }
        }

        private void GetSuggestions(string value)
        {
            suggestions.Clear();
            suggestedValues.Clear();

            if (EnumType == null)
            {
                ExplorerCore.LogWarning("Autocompleter Base enum type is null!");
                return;
            }

            value = GetLastSplitInput(value);

            for (int i = 0; i < this.enumValues.Count; i++)
            {
                CachedEnumValue enumValue = (CachedEnumValue)enumValues[i];
                if (enumValue.Name.ContainsIgnoreCase(value))
                    AddSuggestion(enumValue.Name);
            }
        }

        internal static readonly Dictionary<string, string> sharedValueToLabel = new(4096);

        void AddSuggestion(string value)
        {
            if (suggestedValues.Contains(value))
                return;
            suggestedValues.Add(value);

            if (!sharedValueToLabel.ContainsKey(value))
                sharedValueToLabel.Add(value, $"<color={SignatureHighlighter.CONST}>{value}</color>");

            suggestions.Add(new Suggestion(sharedValueToLabel[value], value));
        }
    }
}

```

`src/UI/Widgets/AutoComplete/ISuggestionProvider.cs`:

```cs
using UniverseLib.UI.Models;

namespace UnityExplorer.UI.Widgets.AutoComplete
{
    public interface ISuggestionProvider
    {
        InputFieldRef InputField { get; }
        bool AnchorToCaretPosition { get; }

        bool AllowNavigation { get; }

        void OnSuggestionClicked(Suggestion suggestion);
    }
}

```

`src/UI/Widgets/AutoComplete/Suggestion.cs`:

```cs
namespace UnityExplorer.UI.Widgets.AutoComplete
{
    public struct Suggestion
    {
        public readonly string DisplayText;
        public readonly string UnderlyingValue;

        public Suggestion(string displayText, string underlyingValue)
        {
            DisplayText = displayText;
            UnderlyingValue = underlyingValue;
        }
    }
}

```

`src/UI/Widgets/AutoComplete/TypeCompleter.cs`:

```cs
using System.Collections;
using System.Diagnostics;
using UnityExplorer.UI.Panels;
using UniverseLib.UI.Models;

namespace UnityExplorer.UI.Widgets.AutoComplete
{
    public class TypeCompleter : ISuggestionProvider
    {
        public bool Enabled
        {
            get => enabled;
            set
            {
                enabled = value;
                if (!enabled)
                { 
                    AutoCompleteModal.Instance.ReleaseOwnership(this);
                    if (getSuggestionsCoroutine != null)
                        RuntimeHelper.StopCoroutine(getSuggestionsCoroutine);
                }
            }
        }
        bool enabled = true;

        public event Action<Suggestion> SuggestionClicked;

        public InputFieldRef InputField { get; }
        public bool AnchorToCaretPosition => false;

        readonly bool allowAbstract;
        readonly bool allowEnum;
        readonly bool allowGeneric;

        public Type BaseType { get; set; }
        HashSet<Type> allowedTypes;
        string pendingInput;
        Coroutine getSuggestionsCoroutine;
        readonly Stopwatch cacheTypesStopwatch = new();

        readonly List<Suggestion> suggestions = new();
        readonly HashSet<string> suggestedTypes = new();
        string chosenSuggestion;

        readonly List<Suggestion> loadingSuggestions = new()
        {
            new("<color=grey>Loading...</color>", "")
        };

        bool ISuggestionProvider.AllowNavigation => false;

        static readonly Dictionary<string, Type> shorthandToType = new()
        {
            { "object", typeof(object) },
            { "string", typeof(string) },
            { "bool", typeof(bool) },
            { "byte", typeof(byte) },
            { "sbyte", typeof(sbyte) },
            { "char", typeof(char) },
            { "decimal", typeof(decimal) },
            { "double", typeof(double) },
            { "float", typeof(float) },
            { "int", typeof(int) },
            { "uint", typeof(uint) },
            { "long", typeof(long) },
            { "ulong", typeof(ulong) },
            { "short", typeof(short) },
            { "ushort", typeof(ushort) },
            { "void", typeof(void) },
        };

        public TypeCompleter(Type baseType, InputFieldRef inputField) : this(baseType, inputField, true, true, true) { }

        public TypeCompleter(Type baseType, InputFieldRef inputField, bool allowAbstract, bool allowEnum, bool allowGeneric)
        {
            BaseType = baseType;
            InputField = inputField;

            this.allowAbstract = allowAbstract;
            this.allowEnum = allowEnum;
            this.allowGeneric = allowGeneric;

            inputField.OnValueChanged += OnInputFieldChanged;

            CacheTypes();
        }

        public void OnSuggestionClicked(Suggestion suggestion)
        {
            chosenSuggestion = suggestion.UnderlyingValue;
            InputField.Text = suggestion.UnderlyingValue;
            SuggestionClicked?.Invoke(suggestion);

            suggestions.Clear();
            //AutoCompleteModal.Instance.SetSuggestions(suggestions, true);
            AutoCompleteModal.Instance.ReleaseOwnership(this);
        }

        public void CacheTypes()
        {
            allowedTypes = null;
            cacheTypesStopwatch.Reset();
            cacheTypesStopwatch.Start();
            ReflectionUtility.GetImplementationsOf(BaseType, OnTypesCached, allowAbstract, allowGeneric, allowEnum);
        }

        void OnTypesCached(HashSet<Type> set)
        {
            allowedTypes = set;

            // ExplorerCore.Log($"Cached {allowedTypes.Count} TypeCompleter types in {cacheTypesStopwatch.ElapsedMilliseconds * 0.001f} seconds.");

            if (pendingInput != null)
            {
                GetSuggestions(pendingInput);
                pendingInput = null;
            }
        }

        void OnInputFieldChanged(string input)
        {
            if (!Enabled)
                return;

            if (input != chosenSuggestion)
                chosenSuggestion = null;

            if (string.IsNullOrEmpty(input) || input == chosenSuggestion)
            {
                if (getSuggestionsCoroutine != null)
                    RuntimeHelper.StopCoroutine(getSuggestionsCoroutine);
                AutoCompleteModal.Instance.ReleaseOwnership(this);
            }
            else
            {
                GetSuggestions(input);
            }
        }

        void GetSuggestions(string input)
        {
            if (allowedTypes == null)
            {
                if (pendingInput != null)
                {
                    AutoCompleteModal.TakeOwnership(this);
                    AutoCompleteModal.Instance.SetSuggestions(loadingSuggestions, true);
                }

                pendingInput = input;
                return;
            }

            if (getSuggestionsCoroutine != null)
                RuntimeHelper.StopCoroutine(getSuggestionsCoroutine);

            getSuggestionsCoroutine = RuntimeHelper.StartCoroutine(GetSuggestionsAsync(input));
        }

        IEnumerator GetSuggestionsAsync(string input)
        {
            suggestions.Clear();
            suggestedTypes.Clear();

            AutoCompleteModal.TakeOwnership(this);
            AutoCompleteModal.Instance.SetSuggestions(suggestions, true);

            // shorthand types all inherit from System.Object
            if (shorthandToType.TryGetValue(input, out Type shorthand) && allowedTypes.Contains(shorthand))
                AddSuggestion(shorthand);

            foreach (KeyValuePair<string, Type> entry in shorthandToType)
            {
                if (allowedTypes.Contains(entry.Value) && entry.Key.StartsWith(input, StringComparison.InvariantCultureIgnoreCase))
                    AddSuggestion(entry.Value);
            }

            // Check for exact match first
            if (ReflectionUtility.GetTypeByName(input) is Type t && allowedTypes.Contains(t))
                AddSuggestion(t);

            if (!suggestions.Any())
                AutoCompleteModal.Instance.SetSuggestions(loadingSuggestions, false);
            else
                AutoCompleteModal.Instance.SetSuggestions(suggestions, false);

            Stopwatch sw = new();
            sw.Start();

            // ExplorerCore.Log($"Checking {allowedTypes.Count} types...");

            foreach (Type entry in allowedTypes)
            {
                if (AutoCompleteModal.CurrentHandler == null)
                    yield break;

                if (sw.ElapsedMilliseconds > 10)
                {
                    yield return null;
                    if (suggestions.Any())
                        AutoCompleteModal.Instance.SetSuggestions(suggestions, false);

                    sw.Reset();
                    sw.Start();
                }

                if (entry.FullName.ContainsIgnoreCase(input))
                    AddSuggestion(entry);
            }

            AutoCompleteModal.Instance.SetSuggestions(suggestions, false);

            // ExplorerCore.Log($"Fetched {suggestions.Count} TypeCompleter suggestions in {sw.ElapsedMilliseconds * 0.001f} seconds.");
        }

        internal static readonly Dictionary<string, string> sharedTypeToLabel = new();

        void AddSuggestion(Type type)
        {
            if (suggestedTypes.Contains(type.FullName))
                return;
            suggestedTypes.Add(type.FullName);

            if (!sharedTypeToLabel.ContainsKey(type.FullName))
                sharedTypeToLabel.Add(type.FullName, SignatureHighlighter.Parse(type, true));

            suggestions.Add(new Suggestion(sharedTypeToLabel[type.FullName], type.FullName));
        }
    }
}

```

`src/UI/Widgets/EvaluateWidget/BaseArgumentHandler.cs`:

```cs
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.UI.Widgets
{
    public abstract class BaseArgumentHandler : IPooledObject
    {
        internal Text argNameLabel;
        internal InputFieldRef inputField;
        internal TypeCompleter typeCompleter;

        // IPooledObject
        public float DefaultHeight => 25f;
        public GameObject UIRoot { get; set; }

        public abstract void CreateSpecialContent();

        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateUIObject("ArgRow", parent);
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, flexibleHeight: 50, minWidth: 50, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 5);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            argNameLabel = UIFactory.CreateLabel(UIRoot, "ArgLabel", "not set", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(argNameLabel.gameObject, minWidth: 40, flexibleWidth: 90, minHeight: 25, flexibleHeight: 50);
            argNameLabel.horizontalOverflow = HorizontalWrapMode.Wrap;

            inputField = UIFactory.CreateInputField(UIRoot, "InputField", "...");
            UIFactory.SetLayoutElement(inputField.UIRoot, minHeight: 25, flexibleHeight: 50, minWidth: 100, flexibleWidth: 1000);
            inputField.Component.lineType = InputField.LineType.MultiLineNewline;
            inputField.UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            typeCompleter = new TypeCompleter(typeof(object), this.inputField)
            {
                Enabled = false
            };

            CreateSpecialContent();

            return UIRoot;
        }
    }
}

```

`src/UI/Widgets/EvaluateWidget/EvaluateWidget.cs`:

```cs
using UnityExplorer.CacheObject;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.UI.Widgets
{
    public class EvaluateWidget : IPooledObject
    {
        public CacheMember Owner { get; set; }

        public GameObject UIRoot { get; set; }
        public float DefaultHeight => -1f;

        private ParameterInfo[] parameters;
        internal GameObject parametersHolder;
        private ParameterHandler[] paramHandlers;

        private Type[] genericArguments;
        internal GameObject genericArgumentsHolder;
        private GenericArgumentHandler[] genericHandlers;

        public void OnBorrowedFromPool(CacheMember owner)
        {
            this.Owner = owner;

            parameters = owner.Arguments;
            paramHandlers = new ParameterHandler[parameters.Length];

            genericArguments = owner.GenericArguments;
            genericHandlers = new GenericArgumentHandler[genericArguments.Length];

            SetArgRows();

            this.UIRoot.SetActive(true);
        }

        public void OnReturnToPool()
        {
            foreach (ParameterHandler widget in paramHandlers)
            {
                widget.OnReturned();
                Pool<ParameterHandler>.Return(widget);
            }
            paramHandlers = null;

            foreach (GenericArgumentHandler widget in genericHandlers)
            {
                widget.OnReturned();
                Pool<GenericArgumentHandler>.Return(widget);
            }
            genericHandlers = null;

            this.Owner = null;
        }

        public Type[] TryParseGenericArguments()
        {
            Type[] outArgs = new Type[genericArguments.Length];

            for (int i = 0; i < genericArguments.Length; i++)
                outArgs[i] = genericHandlers[i].Evaluate();

            return outArgs;
        }

        public object[] TryParseArguments()
        {
            if (!parameters.Any())
                return ArgumentUtility.EmptyArgs;

            object[] outArgs = new object[parameters.Length];

            for (int i = 0; i < parameters.Length; i++)
                outArgs[i] = paramHandlers[i].Evaluate();

            return outArgs;
        }

        private void SetArgRows()
        {
            if (genericArguments.Any())
            {
                genericArgumentsHolder.SetActive(true);
                SetGenericRows();
            }
            else
                genericArgumentsHolder.SetActive(false);

            if (parameters.Any())
            {
                parametersHolder.SetActive(true);
                SetNormalArgRows();
            }
            else
                parametersHolder.SetActive(false);
        }

        private void SetGenericRows()
        {
            for (int i = 0; i < genericArguments.Length; i++)
            {
                Type type = genericArguments[i];

                GenericArgumentHandler holder = genericHandlers[i] = Pool<GenericArgumentHandler>.Borrow();
                holder.UIRoot.transform.SetParent(this.genericArgumentsHolder.transform, false);
                holder.OnBorrowed(type);
            }
        }

        private void SetNormalArgRows()
        {
            for (int i = 0; i < parameters.Length; i++)
            {
                ParameterInfo param = parameters[i];

                ParameterHandler holder = paramHandlers[i] = Pool<ParameterHandler>.Borrow();
                holder.UIRoot.transform.SetParent(this.parametersHolder.transform, false);
                holder.OnBorrowed(param);
            }
        }


        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "EvaluateWidget", false, false, true, true, 3, new Vector4(2, 2, 2, 2),
                new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(UIRoot, minWidth: 50, flexibleWidth: 9999, minHeight: 50, flexibleHeight: 800);
            //UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // generic args
            this.genericArgumentsHolder = UIFactory.CreateUIObject("GenericHolder", UIRoot);
            UIFactory.SetLayoutElement(genericArgumentsHolder, flexibleWidth: 1000);
            Text genericsTitle = UIFactory.CreateLabel(genericArgumentsHolder, "GenericsTitle", "Generic Arguments", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(genericsTitle.gameObject, minHeight: 25, flexibleWidth: 1000);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(genericArgumentsHolder, false, false, true, true, 3);
            UIFactory.SetLayoutElement(genericArgumentsHolder, minHeight: 25, flexibleHeight: 750, minWidth: 50, flexibleWidth: 9999);
            //genericArgHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // args
            this.parametersHolder = UIFactory.CreateUIObject("ArgHolder", UIRoot);
            UIFactory.SetLayoutElement(parametersHolder, flexibleWidth: 1000);
            Text argsTitle = UIFactory.CreateLabel(parametersHolder, "ArgsTitle", "Arguments", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(argsTitle.gameObject, minHeight: 25, flexibleWidth: 1000);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(parametersHolder, false, false, true, true, 3);
            UIFactory.SetLayoutElement(parametersHolder, minHeight: 25, flexibleHeight: 750, minWidth: 50, flexibleWidth: 9999);
            //argHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // evaluate button
            ButtonRef evalButton = UIFactory.CreateButton(UIRoot, "EvaluateButton", "Evaluate", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(evalButton.Component.gameObject, minHeight: 25, minWidth: 150, flexibleWidth: 0);
            evalButton.OnClick += () =>
            {
                Owner.EvaluateAndSetCell();
            };

            return UIRoot;
        }
    }
}

```

`src/UI/Widgets/EvaluateWidget/GenericArgumentHandler.cs`:

```cs
using System.Text;

namespace UnityExplorer.UI.Widgets
{
    public class GenericArgumentHandler : BaseArgumentHandler
    {
        private Type genericArgument;

        public void OnBorrowed(Type genericArgument)
        {
            this.genericArgument = genericArgument;

            typeCompleter.Enabled = true;
            typeCompleter.BaseType = this.genericArgument;
            typeCompleter.CacheTypes();

            Type[] constraints = this.genericArgument.GetGenericParameterConstraints();

            StringBuilder sb = new($"<color={SignatureHighlighter.CONST}>{this.genericArgument.Name}</color>");

            for (int i = 0; i < constraints.Length; i++)
            {
                if (i == 0) sb.Append(' ').Append('(');
                else sb.Append(',').Append(' ');

                sb.Append(SignatureHighlighter.Parse(constraints[i], false));

                if (i + 1 == constraints.Length)
                    sb.Append(')');
            }

            argNameLabel.text = sb.ToString();
        }

        public void OnReturned()
        {
            this.genericArgument = null;

            this.typeCompleter.Enabled = false;

            this.inputField.Text = "";
        }

        public Type Evaluate()
        {
            return ReflectionUtility.GetTypeByName(this.inputField.Text)
                    ?? throw new Exception($"Could not find any type by name '{this.inputField.Text}'!");
        }

        public override void CreateSpecialContent()
        {
        }
    }
}

```

`src/UI/Widgets/EvaluateWidget/GenericConstructorWidget.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.UI.Widgets
{
    public class GenericConstructorWidget
    {
        GenericArgumentHandler[] handlers;

        Type[] currentGenericParameters;
        Action<Type[]> currentOnSubmit;
        Action currentOnCancel;

        public GameObject UIRoot;
        Text Title;
        GameObject ArgsHolder;

        public void Show(Action<Type[]> onSubmit, Action onCancel, Type genericTypeDefinition)
        {
            Title.text = $"Setting generic arguments for {SignatureHighlighter.Parse(genericTypeDefinition, false)}...";

            OnShow(onSubmit, onCancel, genericTypeDefinition.GetGenericArguments());
        }

        public void Show(Action<Type[]> onSubmit, Action onCancel, MethodInfo genericMethodDefinition)
        {
            Title.text = $"Setting generic arguments for {SignatureHighlighter.ParseMethod(genericMethodDefinition)}...";

            OnShow(onSubmit, onCancel, genericMethodDefinition.GetGenericArguments());
        }

        void OnShow(Action<Type[]> onSubmit, Action onCancel, Type[] genericParameters)
        {
            currentOnSubmit = onSubmit;
            currentOnCancel = onCancel;

            SetGenericParameters(genericParameters);
        }

        void SetGenericParameters(Type[] genericParameters)
        {
            currentGenericParameters = genericParameters;

            handlers = new GenericArgumentHandler[genericParameters.Length];
            for (int i = 0; i < genericParameters.Length; i++)
            {
                Type type = genericParameters[i];

                GenericArgumentHandler holder = handlers[i] = Pool<GenericArgumentHandler>.Borrow();
                holder.UIRoot.transform.SetParent(ArgsHolder.transform, false);
                holder.OnBorrowed(type);
            }
        }

        public void TrySubmit()
        {
            Type[] args = new Type[currentGenericParameters.Length];

            for (int i = 0; i < args.Length; i++)
            {
                GenericArgumentHandler handler = handlers[i];
                Type arg;
                try
                {
                    arg = handler.Evaluate();
                    if (arg == null) throw new Exception();
                }
                catch
                {
                    ExplorerCore.LogWarning($"Generic argument '{handler.inputField.Text}' is not a valid type.");
                    return;
                }
                args[i] = arg;
            }

            OnClose();
            currentOnSubmit(args);
        }

        public void Cancel()
        {
            OnClose();

            currentOnCancel?.Invoke();
        }

        void OnClose()
        {
            if (handlers != null)
            {
                foreach (GenericArgumentHandler widget in handlers)
                {
                    widget.OnReturned();
                    Pool<GenericArgumentHandler>.Return(widget);
                }
                handlers = null;
            }
        }

        // UI Construction

        internal void ConstructUI(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "GenericArgsHandler", false, false, true, true, 5, new Vector4(5, 5, 5, 5), 
                childAlignment: TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(UIRoot, flexibleWidth: 9999, flexibleHeight: 9999);

            ButtonRef submitButton = UIFactory.CreateButton(UIRoot, "SubmitButton", "Submit", new Color(0.2f, 0.3f, 0.2f));
            UIFactory.SetLayoutElement(submitButton.GameObject, minHeight: 25, minWidth: 200);
            submitButton.OnClick += TrySubmit;

            ButtonRef cancelButton = UIFactory.CreateButton(UIRoot, "CancelButton", "Cancel", new Color(0.3f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(cancelButton.GameObject, minHeight: 25, minWidth: 200);
            cancelButton.OnClick += Cancel;

            Title = UIFactory.CreateLabel(UIRoot, "Title", "Generic Arguments", TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(Title.gameObject, minHeight: 25, flexibleWidth: 9999);

            GameObject scrollview = UIFactory.CreateScrollView(UIRoot, "GenericArgsScrollView", out ArgsHolder, out _, new(0.1f, 0.1f, 0.1f));
            UIFactory.SetLayoutElement(scrollview, flexibleWidth: 9999, flexibleHeight: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(ArgsHolder, padTop: 5, padLeft: 5, padBottom: 5, padRight: 5);
        }
    }
}

```

`src/UI/Widgets/EvaluateWidget/ParameterHandler.cs`:

```cs
using HarmonyLib;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.UI.Widgets
{
    public class ParameterHandler : BaseArgumentHandler
    {
        private ParameterInfo paramInfo;
        private Type paramType;

        internal EnumCompleter enumCompleter;
        private ButtonRef enumHelperButton;

        private bool usingBasicLabel;
        private object basicValue;
        private GameObject basicLabelHolder;
        private Text basicLabel;
        private ButtonRef pasteButton;

        public void OnBorrowed(ParameterInfo paramInfo)
        {
            this.paramInfo = paramInfo;

            this.paramType = paramInfo.ParameterType;
            if (paramType.IsByRef)
                paramType = paramType.GetElementType();

            this.argNameLabel.text =
                $"{SignatureHighlighter.Parse(paramType, false)} <color={SignatureHighlighter.LOCAL_ARG}>{paramInfo.Name}</color>";

            if (ParseUtility.CanParse(paramType) || typeof(Type).IsAssignableFrom(paramType))
            {
                usingBasicLabel = false;

                this.inputField.Component.gameObject.SetActive(true);
                this.basicLabelHolder.SetActive(false);
                this.typeCompleter.Enabled = typeof(Type).IsAssignableFrom(paramType);
                this.enumCompleter.Enabled = paramType.IsEnum;
                this.enumHelperButton.Component.gameObject.SetActive(paramType.IsEnum);

                if (!typeCompleter.Enabled)
                {
                    if (paramType == typeof(string))
                        inputField.PlaceholderText.text = "...";
                    else
                        inputField.PlaceholderText.text = $"eg. {ParseUtility.GetExampleInput(paramType)}";
                }
                else
                {
                    inputField.PlaceholderText.text = "Enter a Type name...";
                    this.typeCompleter.BaseType = typeof(object);
                    this.typeCompleter.CacheTypes();
                }

                if (enumCompleter.Enabled)
                {
                    enumCompleter.EnumType = paramType;
                    enumCompleter.CacheEnumValues();
                }
            }
            else
            {
                // non-parsable, and not a Type
                usingBasicLabel = true;

                this.inputField.Component.gameObject.SetActive(false);
                this.basicLabelHolder.SetActive(true);
                this.typeCompleter.Enabled = false;
                this.enumCompleter.Enabled = false;
                this.enumHelperButton.Component.gameObject.SetActive(false);

                SetDisplayedValueFromPaste();
            }
        }

        public void OnReturned()
        {
            this.paramInfo = null;

            this.enumCompleter.Enabled = false;
            this.typeCompleter.Enabled = false;

            this.inputField.Text = "";

            this.usingBasicLabel = false;
            this.basicValue = null;
        }

        public object Evaluate()
        {
            if (usingBasicLabel)
                return basicValue;

            string input = this.inputField.Text;

            if (typeof(Type).IsAssignableFrom(paramType))
                return ReflectionUtility.GetTypeByName(input);

            if (paramType == typeof(string))
                return input;

            if (string.IsNullOrEmpty(input))
            {
                if (paramInfo.IsOptional)
                    return paramInfo.DefaultValue;
                else
                    return null;
            }

            if (!ParseUtility.TryParse(input, paramType, out object parsed, out Exception ex))
            {
                ExplorerCore.LogWarning($"Cannot parse argument '{paramInfo.Name}' ({paramInfo.ParameterType.Name})" +
                    $"{(ex == null ? "" : $", {ex.GetType().Name}: {ex.Message}")}");
                return null;
            }
            else
                return parsed;
        }

        private void OnPasteClicked()
        {
            if (ClipboardPanel.TryPaste(this.paramType, out object paste))
            {
                basicValue = paste;
                SetDisplayedValueFromPaste();
            }
        }

        private void SetDisplayedValueFromPaste()
        {
            if (usingBasicLabel)
                basicLabel.text = ToStringUtility.ToStringWithType(basicValue, paramType, false);
            else
            {
                if (typeof(Type).IsAssignableFrom(paramType))
                    inputField.Text = (basicValue as Type).FullDescription();
                else
                    inputField.Text = ParseUtility.ToStringForInput(basicValue, paramType);
            }
        }

        public override void CreateSpecialContent()
        {
            enumCompleter = new(paramType, this.inputField)
            {
                Enabled = false
            };

            enumHelperButton = UIFactory.CreateButton(UIRoot, "EnumHelper", "â–¼");
            UIFactory.SetLayoutElement(enumHelperButton.Component.gameObject, minWidth: 25, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            enumHelperButton.OnClick += enumCompleter.HelperButtonClicked;

            basicLabelHolder = UIFactory.CreateHorizontalGroup(UIRoot, "BasicLabelHolder", true, true, true, true, bgColor: new(0.1f, 0.1f, 0.1f));
            UIFactory.SetLayoutElement(basicLabelHolder, minHeight: 25, flexibleHeight: 50, minWidth: 100, flexibleWidth: 1000);
            basicLabel = UIFactory.CreateLabel(basicLabelHolder, "BasicLabel", "null", TextAnchor.MiddleLeft);
            basicLabel.gameObject.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            pasteButton = UIFactory.CreateButton(UIRoot, "PasteButton", "Paste", new Color(0.13f, 0.13f, 0.13f, 1f));
            UIFactory.SetLayoutElement(pasteButton.Component.gameObject, minHeight: 25, minWidth: 28, flexibleWidth: 0);
            pasteButton.ButtonText.color = Color.green;
            pasteButton.ButtonText.fontSize = 10;
            pasteButton.OnClick += OnPasteClicked;
        }
    }
}

```

`src/UI/Widgets/GameObjects/AxisControl.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.UI.Widgets
{
    // Handles the slider and +/- buttons for a specific axis of a transform property.

    public class AxisControl
    {
        public readonly Vector3Control parent;

        public readonly int axis;
        public readonly Slider slider;

        public AxisControl(int axis, Slider slider, Vector3Control parentControl)
        {
            this.parent = parentControl;
            this.axis = axis;
            this.slider = slider;
        }

        void OnVectorSliderChanged(float value)
        {
            parent.Owner.CurrentSlidingAxisControl = value == 0f ? null : this;
        }

        void OnVectorMinusClicked()
        {
            parent.Owner.AxisControlOperation(-this.parent.Increment, this.parent, this.axis);
        }

        void OnVectorPlusClicked()
        {
            parent.Owner.AxisControlOperation(this.parent.Increment, this.parent, this.axis);
        }

        public static AxisControl Create(GameObject parent, string title, int axis, Vector3Control owner)
        {
            Text label = UIFactory.CreateLabel(parent, $"Label_{title}", $"{title}:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(label.gameObject, minHeight: 25, minWidth: 30);

            GameObject sliderObj = UIFactory.CreateSlider(parent, $"Slider_{title}", out Slider slider);
            UIFactory.SetLayoutElement(sliderObj, minHeight: 25, minWidth: 75, flexibleWidth: 0);
            slider.m_FillImage.color = Color.clear;

            slider.minValue = -0.1f;
            slider.maxValue = 0.1f;

            AxisControl sliderControl = new(axis, slider, owner);

            slider.onValueChanged.AddListener(sliderControl.OnVectorSliderChanged);

            ButtonRef minusButton = UIFactory.CreateButton(parent, "MinusIncrementButton", "-");
            UIFactory.SetLayoutElement(minusButton.GameObject, minWidth: 20, flexibleWidth: 0, minHeight: 25);
            minusButton.OnClick += sliderControl.OnVectorMinusClicked;

            ButtonRef plusButton = UIFactory.CreateButton(parent, "PlusIncrementButton", "+");
            UIFactory.SetLayoutElement(plusButton.GameObject, minWidth: 20, flexibleWidth: 0, minHeight: 25);
            plusButton.OnClick += sliderControl.OnVectorPlusClicked;

            return sliderControl;
        }
    }
}

```

`src/UI/Widgets/GameObjects/ComponentCell.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets.ButtonList;

namespace UnityExplorer.UI.Widgets
{
    public class ComponentCell : ButtonCell
    {
        public Toggle BehaviourToggle;
        public ButtonRef DestroyButton;

        public Action<bool, int> OnBehaviourToggled;
        public Action<int> OnDestroyClicked;

        private void BehaviourToggled(bool val)
        {
            OnBehaviourToggled?.Invoke(val, CurrentDataIndex);
        }

        private void DestroyClicked()
        {
            OnDestroyClicked?.Invoke(CurrentDataIndex);
        }

        public override GameObject CreateContent(GameObject parent)
        {
            GameObject root = base.CreateContent(parent);

            // Add mask to button so text doesnt overlap on Close button
            //this.Button.Component.gameObject.AddComponent<Mask>().showMaskGraphic = true;
            this.Button.ButtonText.horizontalOverflow = HorizontalWrapMode.Wrap;

            // Behaviour toggle

            GameObject toggleObj = UIFactory.CreateToggle(UIRoot, "BehaviourToggle", out BehaviourToggle, out Text behavText);
            UIFactory.SetLayoutElement(toggleObj, minHeight: 25, minWidth: 25);
            BehaviourToggle.onValueChanged.AddListener(BehaviourToggled);
            // put at first object
            toggleObj.transform.SetSiblingIndex(0);

            // Destroy button

            DestroyButton = UIFactory.CreateButton(UIRoot, "DestroyButton", "X", new Color(0.3f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(DestroyButton.Component.gameObject, minHeight: 21, minWidth: 25);
            DestroyButton.OnClick += DestroyClicked;

            return root;
        }
    }
}

```

`src/UI/Widgets/GameObjects/ComponentList.cs`:

```cs
using UnityExplorer.Inspectors;
using UniverseLib.UI.Widgets.ButtonList;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.UI.Widgets
{
    public class ComponentList : ButtonListHandler<Component, ComponentCell>
    {
        public GameObjectInspector Parent;

        public ComponentList(ScrollPool<ComponentCell> scrollPool, Func<List<Component>> getEntriesMethod)
            : base(scrollPool, getEntriesMethod, null, null, null)
        {
            base.SetICell = SetComponentCell;
            base.ShouldDisplay = CheckShouldDisplay;
            base.OnCellClicked = OnComponentClicked;
        }

        public void Clear()
        {
            RefreshData();
            ScrollPool.Refresh(true, true);
        }

        private bool CheckShouldDisplay(Component _, string __) => true;

        public override void OnCellBorrowed(ComponentCell cell)
        {
            base.OnCellBorrowed(cell);

            cell.OnBehaviourToggled += OnBehaviourToggled;
            cell.OnDestroyClicked += OnDestroyClicked;
        }

        public override void SetCell(ComponentCell cell, int index)
        {
            base.SetCell(cell, index);
        }

        private void OnComponentClicked(int index)
        {
            List<Component> entries = GetEntries();

            if (index < 0 || index >= entries.Count)
                return;

            Component comp = entries[index];
            if (comp)
                InspectorManager.Inspect(comp);
        }

        private void OnBehaviourToggled(bool value, int index)
        {
            try
            {
                List<Component> entries = GetEntries();
                Component comp = entries[index];

                if (comp.TryCast<Behaviour>() is Behaviour behaviour)
                    behaviour.enabled = value;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception toggling Behaviour.enabled: {ex.ReflectionExToString()}");
            }
        }

        private void OnDestroyClicked(int index)
        {
            try
            {
                List<Component> entries = GetEntries();
                Component comp = entries[index];

                GameObject.DestroyImmediate(comp);

                Parent.UpdateComponents();
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception destroying Component: {ex.ReflectionExToString()}");
            }
        }

        private static readonly Dictionary<string, string> compToStringCache = new();

        // Called from ButtonListHandler.SetCell, will be valid
        private void SetComponentCell(ComponentCell cell, int index)
        {
            List<Component> entries = GetEntries();
            cell.Enable();

            Component comp = entries[index];
            Type type = comp.GetActualType();

            if (!compToStringCache.ContainsKey(type.AssemblyQualifiedName))
                compToStringCache.Add(type.AssemblyQualifiedName, SignatureHighlighter.Parse(type, true));

            cell.Button.ButtonText.text = compToStringCache[type.AssemblyQualifiedName];

            if (typeof(Behaviour).IsAssignableFrom(type))
            {
                cell.BehaviourToggle.interactable = true;
                cell.BehaviourToggle.Set(comp.TryCast<Behaviour>().enabled, false);
                cell.BehaviourToggle.graphic.color = new Color(0.8f, 1, 0.8f, 0.3f);
            }
            else
            {
                cell.BehaviourToggle.interactable = false;
                cell.BehaviourToggle.Set(true, false);
                //RuntimeHelper.SetColorBlock(cell.BehaviourToggle,)
                cell.BehaviourToggle.graphic.color = new Color(0.2f, 0.2f, 0.2f);
            }

            // if component is the first index it must be the transform, dont show Destroy button for it.
            if (index == 0 && cell.DestroyButton.Component.gameObject.activeSelf)
                cell.DestroyButton.Component.gameObject.SetActive(false);
            else if (index > 0 && !cell.DestroyButton.Component.gameObject.activeSelf)
                cell.DestroyButton.Component.gameObject.SetActive(true);
        }
    }
}

```

`src/UI/Widgets/GameObjects/GameObjectControls.cs`:

```cs
using UnityExplorer.Inspectors;

namespace UnityExplorer.UI.Widgets
{
    // The base wrapper to hold a reference to the parent Inspector and the GameObjectInfo and TransformControls widgets.

    public class GameObjectControls
    {
        public GameObjectInspector Parent { get; }
        public GameObject Target => Parent.Target;

        public GameObjectInfoPanel GameObjectInfo { get; }

        public TransformControls TransformControl { get; }

        public GameObjectControls(GameObjectInspector parent)
        {
            this.Parent = parent;

            this.GameObjectInfo = new(this);
            this.TransformControl = new(this);
        }

        public void UpdateGameObjectInfo(bool firstUpdate, bool force)
        {
            GameObjectInfo.UpdateGameObjectInfo(firstUpdate, force);
        }

        public void UpdateVectorSlider()
        {
            TransformControl.UpdateVectorSlider();
        }
    }
}

```

`src/UI/Widgets/GameObjects/GameObjectInfoPanel.cs`:

```cs
using UnityExplorer.UI.Panels;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.UI.Widgets
{
    public class GameObjectInfoPanel
    {
        public GameObjectControls Owner { get; }
        GameObject Target => Owner.Target;

        string lastGoName;
        string lastPath;
        bool lastParentState;
        int lastSceneHandle;
        string lastTag;
        int lastLayer;
        int lastFlags;

        ButtonRef ViewParentButton;
        InputFieldRef PathInput;

        InputFieldRef NameInput;
        Toggle ActiveSelfToggle;
        Text ActiveSelfText;
        Toggle IsStaticToggle;

        ButtonRef SceneButton;

        InputFieldRef InstanceIDInput;
        InputFieldRef TagInput;

        Dropdown LayerDropdown;
        Dropdown FlagsDropdown;

        public GameObjectInfoPanel(GameObjectControls owner)
        {
            this.Owner = owner;
            Create();
        }

        public void UpdateGameObjectInfo(bool firstUpdate, bool force)
        {
            if (firstUpdate)
            {
                InstanceIDInput.Text = Target.GetInstanceID().ToString();
            }

            if (force || (!NameInput.Component.isFocused && Target.name != lastGoName))
            {
                lastGoName = Target.name;
                Owner.Parent.Tab.TabText.text = $"[G] {Target.name}";
                NameInput.Text = Target.name;
            }

            if (force || !PathInput.Component.isFocused)
            {
                string path = Target.transform.GetTransformPath();
                if (path != lastPath)
                {
                    lastPath = path;
                    PathInput.Text = path;
                }
            }

            if (force || Target.transform.parent != lastParentState)
            {
                lastParentState = Target.transform.parent;
                ViewParentButton.Component.interactable = lastParentState;
                if (lastParentState)
                {
                    ViewParentButton.ButtonText.color = Color.white;
                    ViewParentButton.ButtonText.text = "â—„ View Parent";
                }
                else
                {
                    ViewParentButton.ButtonText.color = Color.grey;
                    ViewParentButton.ButtonText.text = "No parent";
                }
            }

            if (force || Target.activeSelf != ActiveSelfToggle.isOn)
            {
                ActiveSelfToggle.Set(Target.activeSelf, false);
                ActiveSelfText.color = ActiveSelfToggle.isOn ? Color.green : Color.red;
            }

            if (force || Target.isStatic != IsStaticToggle.isOn)
            {
                IsStaticToggle.Set(Target.isStatic, false);
            }

            if (force || Target.scene.handle != lastSceneHandle)
            {
                lastSceneHandle = Target.scene.handle;
                SceneButton.ButtonText.text = Target.scene.IsValid() ? Target.scene.name : "None (Asset/Resource)";
            }

            if (force || (!TagInput.Component.isFocused && Target.tag != lastTag))
            {
                lastTag = Target.tag;
                TagInput.Text = lastTag;
            }

            if (force || (Target.layer != lastLayer))
            {
                lastLayer = Target.layer;
                LayerDropdown.value = Target.layer;
            }

            if (force || ((int)Target.hideFlags != lastFlags))
            {
                lastFlags = (int)Target.hideFlags;
                FlagsDropdown.captionText.text = Target.hideFlags.ToString();
            }
        }

        void DoSetParent(Transform transform)
        {
            ExplorerCore.Log($"Setting target's transform parent to: {(transform == null ? "null" : $"'{transform.name}'")}");

            if (Target.GetComponent<RectTransform>())
                Target.transform.SetParent(transform, false);
            else
                Target.transform.parent = transform;

            UpdateGameObjectInfo(false, false);

            Owner.TransformControl.UpdateTransformControlValues(false);
        }


        #region UI event listeners

        void OnViewParentClicked()
        {
            if (this.Target && this.Target.transform.parent)
            {
                Owner.Parent.OnTransformCellClicked(this.Target.transform.parent.gameObject);
            }
        }

        void OnPathEndEdit(string input)
        {
            lastPath = input;

            if (string.IsNullOrEmpty(input))
            {
                DoSetParent(null);
            }
            else
            {
                Transform parentToSet = null;

                if (input.EndsWith("/"))
                    input = input.Remove(input.Length - 1);

                // try the easy way
                if (GameObject.Find(input) is GameObject found)
                {
                    parentToSet = found.transform;
                }
                else
                {
                    // look for inactive objects
                    string name = input.Split('/').Last();
                    UnityEngine.Object[] allObjects = RuntimeHelper.FindObjectsOfTypeAll(typeof(GameObject));
                    List<GameObject> shortList = new();
                    foreach (UnityEngine.Object obj in allObjects)
                        if (obj.name == name) shortList.Add(obj.TryCast<GameObject>());
                    foreach (GameObject go in shortList)
                    {
                        string path = go.transform.GetTransformPath(true);
                        if (path.EndsWith("/"))
                            path = path.Remove(path.Length - 1);
                        if (path == input)
                        {
                            parentToSet = go.transform;
                            break;
                        }
                    }
                }

                if (parentToSet)
                    DoSetParent(parentToSet);
                else
                {
                    ExplorerCore.LogWarning($"Could not find any GameObject name or path '{input}'!");
                    UpdateGameObjectInfo(false, true);
                }
            }

        }

        void OnNameEndEdit(string value)
        {
            Target.name = value;
            UpdateGameObjectInfo(false, true);
        }

        void OnCopyClicked()
        {
            ClipboardPanel.Copy(this.Target);
        }

        void OnActiveSelfToggled(bool value)
        {
            Target.SetActive(value);
            UpdateGameObjectInfo(false, true);
        }

        void OnTagEndEdit(string value)
        {
            try
            {
                Target.tag = value;
                UpdateGameObjectInfo(false, true);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting tag! {ex.ReflectionExToString()}");
            }
        }
        
        void OnSceneButtonClicked()
        {
            InspectorManager.Inspect(Target.scene);
        }

        void OnExploreButtonClicked()
        {
            ObjectExplorerPanel panel = UIManager.GetPanel<ObjectExplorerPanel>(UIManager.Panels.ObjectExplorer);
            panel.SceneExplorer.JumpToTransform(this.Owner.Parent.Target.transform);
        }

        void OnLayerDropdownChanged(int value)
        {
            Target.layer = value;
            UpdateGameObjectInfo(false, true);
        }

        void OnFlagsDropdownChanged(int value)
        {
            try
            {
                HideFlags enumVal = hideFlagsValues[FlagsDropdown.options[value].text];
                Target.hideFlags = enumVal;

                UpdateGameObjectInfo(false, true);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting hideFlags: {ex}");
            }
        }

        void OnDestroyClicked()
        {
            GameObject.Destroy(this.Target);
            InspectorManager.ReleaseInspector(Owner.Parent);
        }

        void OnInstantiateClicked()
        {
            GameObject clone = GameObject.Instantiate(this.Target);
            InspectorManager.Inspect(clone);
        }

        #endregion


        #region UI Construction

        public void Create()
        {
            GameObject topInfoHolder = UIFactory.CreateVerticalGroup(Owner.Parent.Content, "TopInfoHolder", false, false, true, true, 3,
                new Vector4(3, 3, 3, 3), new Color(0.1f, 0.1f, 0.1f), TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(topInfoHolder, minHeight: 100, flexibleWidth: 9999);
            topInfoHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // first row (parent, path)

            GameObject firstRow = UIFactory.CreateUIObject("ParentRow", topInfoHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(firstRow, false, false, true, true, 5, 0, 0, 0, 0, default);
            UIFactory.SetLayoutElement(firstRow, minHeight: 25, flexibleWidth: 9999);

            ViewParentButton = UIFactory.CreateButton(firstRow, "ViewParentButton", "â—„ View Parent", new Color(0.2f, 0.2f, 0.2f));
            ViewParentButton.ButtonText.fontSize = 13;
            UIFactory.SetLayoutElement(ViewParentButton.Component.gameObject, minHeight: 25, minWidth: 100);
            ViewParentButton.OnClick += OnViewParentClicked;

            this.PathInput = UIFactory.CreateInputField(firstRow, "PathInput", "...");
            PathInput.Component.textComponent.color = Color.grey;
            PathInput.Component.textComponent.fontSize = 14;
            UIFactory.SetLayoutElement(PathInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 9999);
            PathInput.Component.lineType = InputField.LineType.MultiLineSubmit;

            ButtonRef copyButton = UIFactory.CreateButton(firstRow, "CopyButton", "Copy to Clipboard", new Color(0.2f, 0.2f, 0.2f, 1));
            copyButton.ButtonText.color = Color.yellow;
            UIFactory.SetLayoutElement(copyButton.Component.gameObject, minHeight: 25, minWidth: 120);
            copyButton.OnClick += OnCopyClicked;

            PathInput.Component.GetOnEndEdit().AddListener((string val) => { OnPathEndEdit(val); });

            // Title and update row

            GameObject titleRow = UIFactory.CreateUIObject("TitleRow", topInfoHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(titleRow, false, false, true, true, 5);

            Text titleLabel = UIFactory.CreateLabel(titleRow, "Title", SignatureHighlighter.Parse(typeof(GameObject), false),
                TextAnchor.MiddleLeft, fontSize: 17);
            UIFactory.SetLayoutElement(titleLabel.gameObject, minHeight: 30, minWidth: 100);

            // name

            NameInput = UIFactory.CreateInputField(titleRow, "NameInput", "untitled");
            UIFactory.SetLayoutElement(NameInput.Component.gameObject, minHeight: 30, minWidth: 100, flexibleWidth: 9999);
            NameInput.Component.textComponent.fontSize = 15;
            NameInput.Component.GetOnEndEdit().AddListener((string val) => { OnNameEndEdit(val); });

            // second row (toggles, instanceID, tag, buttons)

            GameObject secondRow = UIFactory.CreateUIObject("ParentRow", topInfoHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(secondRow, false, false, true, true, 5, 0, 0, 0, 0, default);
            UIFactory.SetLayoutElement(secondRow, minHeight: 25, flexibleWidth: 9999);

            // activeSelf
            GameObject activeToggleObj = UIFactory.CreateToggle(secondRow, "ActiveSelf", out ActiveSelfToggle, out ActiveSelfText);
            UIFactory.SetLayoutElement(activeToggleObj, minHeight: 25, minWidth: 100);
            ActiveSelfText.text = "ActiveSelf";
            ActiveSelfToggle.onValueChanged.AddListener(OnActiveSelfToggled);

            // isStatic
            GameObject isStaticObj = UIFactory.CreateToggle(secondRow, "IsStatic", out IsStaticToggle, out Text staticText);
            UIFactory.SetLayoutElement(isStaticObj, minHeight: 25, minWidth: 80);
            staticText.text = "IsStatic";
            staticText.color = Color.grey;
            IsStaticToggle.interactable = false;

            // InstanceID
            Text instanceIdLabel = UIFactory.CreateLabel(secondRow, "InstanceIDLabel", "Instance ID:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(instanceIdLabel.gameObject, minHeight: 25, minWidth: 90);

            InstanceIDInput = UIFactory.CreateInputField(secondRow, "InstanceIDInput", "error");
            UIFactory.SetLayoutElement(InstanceIDInput.Component.gameObject, minHeight: 25, minWidth: 110);
            InstanceIDInput.Component.textComponent.color = Color.grey;
            InstanceIDInput.Component.readOnly = true;

            //Tag
            Text tagLabel = UIFactory.CreateLabel(secondRow, "TagLabel", "Tag:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(tagLabel.gameObject, minHeight: 25, minWidth: 40);

            TagInput = UIFactory.CreateInputField(secondRow, "TagInput", "none");
            UIFactory.SetLayoutElement(TagInput.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 999);
            TagInput.Component.textComponent.color = Color.white;
            TagInput.Component.GetOnEndEdit().AddListener((string val) => { OnTagEndEdit(val); });

            // Instantiate
            ButtonRef instantiateBtn = UIFactory.CreateButton(secondRow, "InstantiateBtn", "Instantiate", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(instantiateBtn.Component.gameObject, minHeight: 25, minWidth: 120);
            instantiateBtn.OnClick += OnInstantiateClicked;

            // Destroy
            ButtonRef destroyBtn = UIFactory.CreateButton(secondRow, "DestroyBtn", "Destroy", new Color(0.3f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(destroyBtn.Component.gameObject, minHeight: 25, minWidth: 80);
            destroyBtn.OnClick += OnDestroyClicked;

            // third row (scene, layer, flags)

            GameObject thirdrow = UIFactory.CreateUIObject("ParentRow", topInfoHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(thirdrow, false, false, true, true, 5, 0, 0, 0, 0, default);
            UIFactory.SetLayoutElement(thirdrow, minHeight: 25, flexibleWidth: 9999);

            // Inspect in Explorer button
            ButtonRef explorerBtn = UIFactory.CreateButton(thirdrow, "ExploreBtn", "Show in Explorer", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(explorerBtn.Component.gameObject, minHeight: 25, minWidth: 100);
            explorerBtn.ButtonText.fontSize = 12;
            explorerBtn.OnClick += OnExploreButtonClicked;

            // Scene
            Text sceneLabel = UIFactory.CreateLabel(thirdrow, "SceneLabel", "Scene:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(sceneLabel.gameObject, minHeight: 25, minWidth: 50);

            SceneButton = UIFactory.CreateButton(thirdrow, "SceneButton", "untitled");
            UIFactory.SetLayoutElement(SceneButton.Component.gameObject, minHeight: 25, minWidth: 120, flexibleWidth: 999);
            SceneButton.OnClick += OnSceneButtonClicked;

            // Layer
            Text layerLabel = UIFactory.CreateLabel(thirdrow, "LayerLabel", "Layer:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(layerLabel.gameObject, minHeight: 25, minWidth: 50);

            GameObject layerDrop = UIFactory.CreateDropdown(thirdrow, "LayerDropdown", out LayerDropdown, "0", 14, OnLayerDropdownChanged);
            UIFactory.SetLayoutElement(layerDrop, minHeight: 25, minWidth: 110, flexibleWidth: 999);
            LayerDropdown.captionText.color = SignatureHighlighter.EnumGreen;
            if (layerToNames == null)
                GetLayerNames();
            foreach (string name in layerToNames)
                LayerDropdown.options.Add(new Dropdown.OptionData(name));
            LayerDropdown.value = 0;
            LayerDropdown.RefreshShownValue();

            // Flags
            Text flagsLabel = UIFactory.CreateLabel(thirdrow, "FlagsLabel", "Flags:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(flagsLabel.gameObject, minHeight: 25, minWidth: 50);

            GameObject flagsDrop = UIFactory.CreateDropdown(thirdrow, "FlagsDropdown", out FlagsDropdown, "None", 14, OnFlagsDropdownChanged);
            FlagsDropdown.captionText.color = SignatureHighlighter.EnumGreen;
            UIFactory.SetLayoutElement(flagsDrop, minHeight: 25, minWidth: 135, flexibleWidth: 999);
            if (hideFlagsValues == null)
                GetHideFlagNames();
            foreach (string name in hideFlagsValues.Keys)
                FlagsDropdown.options.Add(new Dropdown.OptionData(name));
            FlagsDropdown.value = 0;
            FlagsDropdown.RefreshShownValue();
        }

        private static List<string> layerToNames;

        private static void GetLayerNames()
        {
            layerToNames = new List<string>();
            for (int i = 0; i < 32; i++)
            {
                string name = RuntimeHelper.LayerToName(i);
                if (string.IsNullOrEmpty(name))
                    name = i.ToString();
                layerToNames.Add(name);
            }
        }

        private static Dictionary<string, HideFlags> hideFlagsValues;

        private static void GetHideFlagNames()
        {
            hideFlagsValues = new Dictionary<string, HideFlags>();

            Array names = Enum.GetValues(typeof(HideFlags));
            foreach (HideFlags value in names)
            {
                hideFlagsValues.Add(value.ToString(), value);
            }
        }

        #endregion
   
    }
}

```

`src/UI/Widgets/GameObjects/TransformControls.cs`:

```cs
using UniverseLib.Input;
using UniverseLib.UI;

namespace UnityExplorer.UI.Widgets
{
    // Handles axis change operations and holds references to the Vector3Controls for each transform property

    public class TransformControls
    {
        public GameObjectControls Owner { get; }
        GameObject Target => Owner.Target;

        public AxisControl CurrentSlidingAxisControl { get; set; }

        Vector3Control PositionControl;
        Vector3Control LocalPositionControl;
        Vector3Control RotationControl;
        Vector3Control ScaleControl;

        public TransformControls(GameObjectControls owner)
        {
            this.Owner = owner;
            Create();
        }

        public void UpdateTransformControlValues(bool force)
        {
            PositionControl.Update(force);
            LocalPositionControl.Update(force);
            RotationControl.Update(force);
            ScaleControl.Update(force);
        }

        public void UpdateVectorSlider()
        {
            AxisControl control = CurrentSlidingAxisControl;

            if (control == null)
                return;

            if (!InputManager.GetMouseButton(0))
            {
                control.slider.value = 0f;
                control = null;
                return;
            }

            AxisControlOperation(control.slider.value, control.parent, control.axis);
        }

        public void AxisControlOperation(float value, Vector3Control parent, int axis)
        {
            Transform transform = Target.transform;

            Vector3 vector = parent.Type switch
            {
                TransformType.Position => transform.position,
                TransformType.LocalPosition => transform.localPosition,
                TransformType.Rotation => transform.localEulerAngles,
                TransformType.Scale => transform.localScale,
                _ => throw new NotImplementedException()
            };

            // apply vector value change
            switch (axis)
            {
                case 0:
                    vector.x += value; break;
                case 1:
                    vector.y += value; break;
                case 2:
                    vector.z += value; break;
            }

            // set vector back to transform
            switch (parent.Type)
            {
                case TransformType.Position:
                    transform.position = vector; break;
                case TransformType.LocalPosition:
                    transform.localPosition = vector; break;
                case TransformType.Rotation:
                    transform.localEulerAngles = vector; break;
                case TransformType.Scale:
                    transform.localScale = vector; break;
            }

            UpdateTransformControlValues(false);
        }

        public void Create()
        {
            GameObject transformGroup = UIFactory.CreateVerticalGroup(Owner.Parent.Content, "TransformControls", false, false, true, true, 2,
                new Vector4(2, 2, 0, 0), new Color(0.1f, 0.1f, 0.1f));
            UIFactory.SetLayoutElement(transformGroup, minHeight: 100, flexibleWidth: 9999);

            PositionControl = Vector3Control.Create(this, transformGroup, "Position:", TransformType.Position);
            LocalPositionControl = Vector3Control.Create(this, transformGroup, "Local Position:", TransformType.LocalPosition);
            RotationControl = Vector3Control.Create(this, transformGroup, "Rotation:", TransformType.Rotation);
            ScaleControl = Vector3Control.Create(this, transformGroup, "Scale:", TransformType.Scale);
        }
    }
}

```

`src/UI/Widgets/GameObjects/TransformType.cs`:

```cs
namespace UnityExplorer.UI.Widgets
{
    public enum TransformType { Position, LocalPosition, Rotation, Scale }
}

```

`src/UI/Widgets/GameObjects/Vector3Control.cs`:

```cs
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.UI.Widgets
{
    // Controls a Vector3 property of a Transform, and holds references to each AxisControl for X/Y/Z.

    public class Vector3Control
    {
        public TransformControls Owner { get; }
        public GameObject Target => Owner.Owner.Target;
        public Transform Transform => Target.transform;
        public TransformType Type { get; }

        public InputFieldRef MainInput { get; }

        public AxisControl[] AxisControls { get; } = new AxisControl[3];

        public InputFieldRef IncrementInput { get; set; }
        public float Increment { get; set; } = 0.1f;

        Vector3 lastValue;

        Vector3 CurrentValue => Type switch
        {
            TransformType.Position => Transform.position,
            TransformType.LocalPosition => Transform.localPosition,
            TransformType.Rotation => Transform.localEulerAngles,
            TransformType.Scale => Transform.localScale,
            _ => throw new NotImplementedException()
        };

        public Vector3Control(TransformControls owner, TransformType type, InputFieldRef input)
        {
            this.Owner = owner;
            this.Type = type;
            this.MainInput = input;
        }

        public void Update(bool force)
        {
            Vector3 currValue = CurrentValue;
            if (force || (!MainInput.Component.isFocused && !lastValue.Equals(currValue)))
            {
                MainInput.Text = ParseUtility.ToStringForInput<Vector3>(currValue);
                lastValue = currValue;
            }
        }

        void OnTransformInputEndEdit(TransformType type, string input)
        {
            switch (type)
            {
                case TransformType.Position:
                    {
                        if (ParseUtility.TryParse(input, out Vector3 val, out _))
                            Target.transform.position = val;
                    }
                    break;
                case TransformType.LocalPosition:
                    {
                        if (ParseUtility.TryParse(input, out Vector3 val, out _))
                            Target.transform.localPosition = val;
                    }
                    break;
                case TransformType.Rotation:
                    {
                        if (ParseUtility.TryParse(input, out Vector3 val, out _))
                            Target.transform.localEulerAngles = val;
                    }
                    break;
                case TransformType.Scale:
                    {
                        if (ParseUtility.TryParse(input, out Vector3 val, out _))
                            Target.transform.localScale = val;
                    }
                    break;
            }

            Owner.UpdateTransformControlValues(true);
        }

        void IncrementInput_OnEndEdit(string value)
        {
            if (!ParseUtility.TryParse(value, out float increment, out _))
                IncrementInput.Text = ParseUtility.ToStringForInput<float>(Increment);
            else
            {
                Increment = increment;
                foreach (AxisControl slider in AxisControls)
                {
                    slider.slider.minValue = -increment;
                    slider.slider.maxValue = increment;
                }
            }
        }

        public static Vector3Control Create(TransformControls owner, GameObject transformGroup, string title, TransformType type)
        {
            GameObject rowObj = UIFactory.CreateUIObject($"Row_{title}", transformGroup);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(rowObj, false, false, true, true, 5, 0, 0, 0, 0, default);
            UIFactory.SetLayoutElement(rowObj, minHeight: 25, flexibleWidth: 9999);

            Text titleLabel = UIFactory.CreateLabel(rowObj, "PositionLabel", title, TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(titleLabel.gameObject, minHeight: 25, minWidth: 110);

            InputFieldRef inputField = UIFactory.CreateInputField(rowObj, "InputField", "...");
            UIFactory.SetLayoutElement(inputField.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 999);

            Vector3Control control = new(owner, type, inputField);

            inputField.Component.GetOnEndEdit().AddListener((string value) => { control.OnTransformInputEndEdit(type, value); });

            control.AxisControls[0] = AxisControl.Create(rowObj, "X", 0, control);
            control.AxisControls[1] = AxisControl.Create(rowObj, "Y", 1, control);
            control.AxisControls[2] = AxisControl.Create(rowObj, "Z", 2, control);

            control.IncrementInput = UIFactory.CreateInputField(rowObj, "IncrementInput", "...");
            control.IncrementInput.Text = "0.1";
            UIFactory.SetLayoutElement(control.IncrementInput.GameObject, minWidth: 30, flexibleWidth: 0, minHeight: 25);
            control.IncrementInput.Component.GetOnEndEdit().AddListener(control.IncrementInput_OnEndEdit);

            return control;
        }
    }
}

```

`src/UI/Widgets/TimeScaleWidget.cs`:

```cs
using HarmonyLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
#if UNHOLLOWER
using IL2CPPUtils = UnhollowerBaseLib.UnhollowerUtils;
#endif
#if INTEROP
using IL2CPPUtils = Il2CppInterop.Common.Il2CppInteropUtils;
#endif

namespace UnityExplorer.UI.Widgets
{
    internal class TimeScaleWidget
    {
        public TimeScaleWidget(GameObject parent)
        {
            Instance = this;

            ConstructUI(parent);

            InitPatch();
        }

        static TimeScaleWidget Instance;

        ButtonRef lockBtn;
        bool locked;
        InputFieldRef timeInput;
        float desiredTime;
        bool settingTimeScale;

        public void Update()
        {
            // Fallback in case Time.timeScale patch failed for whatever reason
            if (locked)
                SetTimeScale(desiredTime);

            if (!timeInput.Component.isFocused)
                timeInput.Text = Time.timeScale.ToString("F2");
        }

        void SetTimeScale(float time)
        {
            settingTimeScale = true;
            Time.timeScale = time;
            settingTimeScale = false;
        }

        // UI event listeners

        void OnTimeInputEndEdit(string val)
        {
            if (float.TryParse(val, out float f))
            {
                SetTimeScale(f);
                desiredTime = f;
            }
        }

        void OnPauseButtonClicked()
        {
            OnTimeInputEndEdit(timeInput.Text);

            locked = !locked;

            Color color = locked ? new Color(0.3f, 0.3f, 0.2f) : new Color(0.2f, 0.2f, 0.2f);
            RuntimeHelper.SetColorBlock(lockBtn.Component, color, color * 1.2f, color * 0.7f);
            lockBtn.ButtonText.text = locked ? "Unlock" : "Lock";
        }

        // UI Construction

        void ConstructUI(GameObject parent)
        {
            Text timeLabel = UIFactory.CreateLabel(parent, "TimeLabel", "Time:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(timeLabel.gameObject, minHeight: 25, minWidth: 35);

            timeInput = UIFactory.CreateInputField(parent, "TimeInput", "timeScale");
            UIFactory.SetLayoutElement(timeInput.Component.gameObject, minHeight: 25, minWidth: 40);
            timeInput.Component.GetOnEndEdit().AddListener(OnTimeInputEndEdit);

            timeInput.Text = string.Empty;
            timeInput.Text = Time.timeScale.ToString();

            lockBtn = UIFactory.CreateButton(parent, "PauseButton", "Lock", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(lockBtn.Component.gameObject, minHeight: 25, minWidth: 50);
            lockBtn.OnClick += OnPauseButtonClicked;
        }

        // Only allow Time.timeScale to be set if the user hasn't "locked" it or if we are setting the value internally.

        static void InitPatch()
        {

            try
            {
                MethodInfo target = typeof(Time).GetProperty("timeScale").GetSetMethod();
#if CPP
                if (IL2CPPUtils.GetIl2CppMethodInfoPointerFieldForGeneratedMethod(target) == null)
                    return;
#endif
                ExplorerCore.Harmony.Patch(target,
                    prefix: new(AccessTools.Method(typeof(TimeScaleWidget), nameof(Prefix_Time_set_timeScale))));
            }
            catch { }
        }

        static bool Prefix_Time_set_timeScale()
        {
            return !Instance.locked || Instance.settingTimeScale;
        }
    }
}

```

`src/UI/Widgets/UnityObjects/AudioClipWidget.cs`:

```cs
using System.Collections;
using System.Text;
using UnityExplorer.Config;
using UnityExplorer.Inspectors;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;
#if CPP
#if INTEROP
using Il2CppInterop.Runtime;
using Il2CppInterop.Runtime.InteropTypes.Arrays;
#else
using UnhollowerRuntimeLib;
using UnhollowerBaseLib;
#endif
#endif

namespace UnityExplorer.UI.Widgets
{
    public class AudioClipWidget : UnityObjectWidget
    {
        static GameObject AudioPlayerObject;
        static AudioSource Source;
        static AudioClipWidget CurrentlyPlaying;
        static Coroutine CurrentlyPlayingCoroutine;
        static readonly string zeroLengthString = GetLengthString(0f);

        public AudioClip audioClip;
        string fullLengthText;

        ButtonRef toggleButton;
        bool audioPlayerWanted;

        GameObject audioPlayerRoot;
        ButtonRef playStopButton;
        Text progressLabel;
        GameObject saveObjectRow;
        InputFieldRef savePathInput;
        GameObject cantSaveRow;

        public override void OnBorrowed(object target, Type targetType, ReflectionInspector inspector)
        {
            base.OnBorrowed(target, targetType, inspector);

            this.audioPlayerRoot.transform.SetParent(inspector.UIRoot.transform);
            this.audioPlayerRoot.transform.SetSiblingIndex(inspector.UIRoot.transform.childCount - 2);

            audioClip = target.TryCast<AudioClip>();
            this.fullLengthText = GetLengthString(audioClip.length);

            if (audioClip.loadType == AudioClipLoadType.DecompressOnLoad)
            {
                cantSaveRow.SetActive(false);
                saveObjectRow.SetActive(true);
                SetDefaultSavePath();
            }
            else
            {
                cantSaveRow.SetActive(true);
                saveObjectRow.SetActive(false);
            }

            ResetProgressLabel();
        }

        public override void OnReturnToPool()
        {
            audioClip = null;

            if (audioPlayerWanted)
                ToggleAudioWidget();

            if (CurrentlyPlaying == this)
                StopClip();

            this.audioPlayerRoot.transform.SetParent(Pool<AudioClipWidget>.Instance.InactiveHolder.transform);

            base.OnReturnToPool();
        }

        private void ToggleAudioWidget()
        {
            if (audioPlayerWanted)
            {
                audioPlayerWanted = false;

                toggleButton.ButtonText.text = "Show Player";
                audioPlayerRoot.SetActive(false);
            }
            else
            {
                audioPlayerWanted = true;

                toggleButton.ButtonText.text = "Hide Player";
                audioPlayerRoot.SetActive(true);
            }
        }

        void SetDefaultSavePath()
        {
            string name = audioClip.name;
            if (string.IsNullOrEmpty(name))
                name = "untitled";
            savePathInput.Text = Path.Combine(ConfigManager.Default_Output_Path.Value, $"{name}.wav");
        }

        static string GetLengthString(float seconds)
        {
            TimeSpan ts = TimeSpan.FromSeconds(seconds);

            StringBuilder sb = new();

            if (ts.Hours > 0)
                sb.Append($"{ts.Hours}:");

            sb.Append($"{ts.Minutes:00}:");
            sb.Append($"{ts.Seconds:00}:");
            sb.Append($"{ts.Milliseconds:000}");

            return sb.ToString();
        }

        private void ResetProgressLabel()
        {
            this.progressLabel.text = $"{zeroLengthString} / {fullLengthText}";
        }

        private void OnPlayStopClicked()
        {
            SetupAudioPlayer();

            if (CurrentlyPlaying == this)
            {
                // we are playing a clip. stop it.
                StopClip();
            }
            else
            {
                // If something else is playing a clip, stop that.
                if (CurrentlyPlaying != null)
                    CurrentlyPlaying.StopClip();

                // we want to start playing a clip.
                CurrentlyPlayingCoroutine = RuntimeHelper.StartCoroutine(PlayClipCoroutine());
            }
        }

        static void SetupAudioPlayer()
        {
            if (AudioPlayerObject)
                return;

            AudioPlayerObject = new GameObject("UnityExplorer.AudioPlayer");
            UnityEngine.Object.DontDestroyOnLoad(AudioPlayerObject);
            AudioPlayerObject.hideFlags = HideFlags.HideAndDontSave;
            AudioPlayerObject.transform.position = new(int.MinValue, int.MinValue); // move it as far away as possible
#if CPP
            Source = AudioPlayerObject.AddComponent(Il2CppType.Of<AudioSource>()).TryCast<AudioSource>();
#else
            Source = AudioPlayerObject.AddComponent<AudioSource>();
#endif
            AudioPlayerObject.AddComponent<AudioListener>();
        }

        private IEnumerator PlayClipCoroutine()
        {
            playStopButton.ButtonText.text = "Stop Clip";
            CurrentlyPlaying = this;
            Source.clip = this.audioClip;
            Source.Play();

            while (Source.isPlaying)
            {
                progressLabel.text = $"{GetLengthString(Source.time)} / {fullLengthText}";
                yield return null;
            }

            CurrentlyPlayingCoroutine = null;
            StopClip();
        }

        private void StopClip()
        {
            if (CurrentlyPlayingCoroutine != null)
                RuntimeHelper.StopCoroutine(CurrentlyPlayingCoroutine);

            Source.Stop();
            CurrentlyPlaying = null;
            CurrentlyPlayingCoroutine = null;
            playStopButton.ButtonText.text = "Play Clip";

            ResetProgressLabel();
        }

        public void OnSaveClipClicked()
        {
            if (!audioClip)
            {
                ExplorerCore.LogWarning("AudioClip is null, maybe it was destroyed?");
                return;
            }

            if (string.IsNullOrEmpty(savePathInput.Text))
            {
                ExplorerCore.LogWarning("Save path cannot be empty!");
                return;
            }

            string path = savePathInput.Text;
            if (!path.EndsWith(".wav", StringComparison.InvariantCultureIgnoreCase))
                path += ".wav";

            path = IOUtility.EnsureValidFilePath(path);

            if (File.Exists(path))
                File.Delete(path);

            SavWav.Save(audioClip, path);
        }

        public override GameObject CreateContent(GameObject uiRoot)
        {
            GameObject ret = base.CreateContent(uiRoot);

            // Toggle Button

            toggleButton = UIFactory.CreateButton(UIRoot, "AudioWidgetToggleButton", "Show Player", new Color(0.2f, 0.3f, 0.2f));
            toggleButton.Transform.SetSiblingIndex(0);
            UIFactory.SetLayoutElement(toggleButton.Component.gameObject, minHeight: 25, minWidth: 170);
            toggleButton.OnClick += ToggleAudioWidget;

            // Actual widget

            audioPlayerRoot = UIFactory.CreateVerticalGroup(uiRoot, "AudioWidget", false, false, true, true, spacing: 5);
            UIFactory.SetLayoutElement(audioPlayerRoot, flexibleWidth: 9999, flexibleHeight: 50);
            audioPlayerRoot.SetActive(false);

            // Player 

            GameObject playerRow = UIFactory.CreateHorizontalGroup(audioPlayerRoot, "PlayerWidget", false, false, true, true,
                spacing: 5, padding: new() { x = 3f, w = 3f, y = 3f, z = 3f });

            playStopButton = UIFactory.CreateButton(playerRow, "PlayerButton", "Play", normalColor: new(0.2f, 0.4f, 0.2f));
            playStopButton.OnClick += OnPlayStopClicked;
            UIFactory.SetLayoutElement(playStopButton.GameObject, minWidth: 60, minHeight: 25);

            progressLabel = UIFactory.CreateLabel(playerRow, "ProgressLabel", "0 / 0");
            UIFactory.SetLayoutElement(progressLabel.gameObject, flexibleWidth: 9999, minHeight: 25);

            ResetProgressLabel();

            // Save helper

            saveObjectRow = UIFactory.CreateHorizontalGroup(audioPlayerRoot, "SaveRow", false, false, true, true, 2, new Vector4(2, 2, 2, 2),
                new Color(0.1f, 0.1f, 0.1f));

            ButtonRef saveBtn = UIFactory.CreateButton(saveObjectRow, "SaveButton", "Save .WAV", new Color(0.2f, 0.25f, 0.2f));
            UIFactory.SetLayoutElement(saveBtn.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            saveBtn.OnClick += OnSaveClipClicked;

            savePathInput = UIFactory.CreateInputField(saveObjectRow, "SaveInput", "...");
            UIFactory.SetLayoutElement(savePathInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 9999);

            // cant save label
            cantSaveRow = UIFactory.CreateHorizontalGroup(audioPlayerRoot, "CantSaveRow", true, true, true, true);
            UIFactory.SetLayoutElement(cantSaveRow, minHeight: 25, flexibleWidth: 9999);
            UIFactory.CreateLabel(
                cantSaveRow,
                "CantSaveLabel",
                "Cannot save this AudioClip as the data is compressed or streamed. Try a tool such as AssetRipper to unpack it.",
                color: Color.grey);

            return ret;
        }
    }

#region SavWav

    //	Copyright (c) 2012 Calvin Rien
    //        http://the.darktable.com
    //
    //	This software is provided 'as-is', without any express or implied warranty. In
    //	no event will the authors be held liable for any damages arising from the use
    //	of this software.
    //
    //	Permission is granted to anyone to use this software for any purpose,
    //	including commercial applications, and to alter it and redistribute it freely,
    //	subject to the following restrictions:
    //
    //	1. The origin of this software must not be misrepresented; you must not claim
    //	that you wrote the original software. If you use this software in a product,
    //	an acknowledgment in the product documentation would be appreciated but is not
    //	required.
    //
    //	2. Altered source versions must be plainly marked as such, and must not be
    //	misrepresented as being the original software.
    //
    //	3. This notice may not be removed or altered from any source distribution.
    //
    //  =============================================================================
    //
    //  derived from Gregorio Zanon's script
    //  http://forum.unity3d.com/threads/119295-Writing-AudioListener.GetOutputData-to-wav-problem?p=806734&viewfull=1#post806734

    public static class SavWav
    {
        public const int HEADER_SIZE = 44;
        public const float RESCALE_FACTOR = 32767; // to convert float to Int16

        public static void Save(AudioClip clip, string filepath)
        {
            using FileStream fileStream = CreateEmpty(filepath);

            ConvertAndWrite(fileStream, clip);
            WriteHeader(fileStream, clip);
        }

        static FileStream CreateEmpty(string filepath)
        {
            FileStream fileStream = new(filepath, FileMode.Create);
            byte emptyByte = default;

            for (int i = 0; i < HEADER_SIZE; i++) //preparing the header
                fileStream.WriteByte(emptyByte);

            return fileStream;
        }

        static void ConvertAndWrite(FileStream fileStream, AudioClip clip)
        {
#if CPP
            Il2CppStructArray<float> samples = new float[clip.samples * clip.channels];
            AudioClip.GetData(clip, samples, clip.samples, 0);
#else
            float[] samples = new float[clip.samples * clip.channels];
            clip.GetData(samples, 0);
#endif

            int len = samples.Length;

            // converting in 2 float[] steps to Int16[], then Int16[] to Byte[]
            short[] intData = new short[len];

            // bytesData array is twice the size of dataSource array because a float converted in Int16 is 2 bytes.
            byte[] bytesData = new byte[len * 2];

            for (int i = 0; i < len; i++)
            {
                intData[i] = (short)(samples[i] * RESCALE_FACTOR);
                byte[] byteArr = BitConverter.GetBytes(intData[i]);
                byteArr.CopyTo(bytesData, i * 2);
            }

            fileStream.Write(bytesData, 0, bytesData.Length);
        }

        static void WriteHeader(FileStream stream, AudioClip clip)
        {
            int hz = clip.frequency;
            int channels = clip.channels;
            int samples = clip.samples;

            stream.Seek(0, SeekOrigin.Begin);

            byte[] riff = Encoding.UTF8.GetBytes("RIFF");
            stream.Write(riff, 0, 4);

            byte[] chunkSize = BitConverter.GetBytes(stream.Length - 8);
            stream.Write(chunkSize, 0, 4);

            byte[] wave = Encoding.ASCII.GetBytes("WAVE");
            stream.Write(wave, 0, 4);

            byte[] fmt = Encoding.ASCII.GetBytes("fmt ");
            stream.Write(fmt, 0, 4);

            byte[] subChunk1 = BitConverter.GetBytes(16);
            stream.Write(subChunk1, 0, 4);

            byte[] audioFormat = BitConverter.GetBytes(1);
            stream.Write(audioFormat, 0, 2);

            byte[] numChannels = BitConverter.GetBytes(channels);
            stream.Write(numChannels, 0, 2);

            byte[] sampleRate = BitConverter.GetBytes(hz);
            stream.Write(sampleRate, 0, 4);

            byte[] byteRate = BitConverter.GetBytes(hz * channels * 2); // sampleRate * bytesPerSample*number of channels, here 44100*2*2
            stream.Write(byteRate, 0, 4);

            ushort blockAlign = (ushort)(channels * 2);
            stream.Write(BitConverter.GetBytes(blockAlign), 0, 2);

            ushort bps = 16;
            byte[] bitsPerSample = BitConverter.GetBytes(bps);
            stream.Write(bitsPerSample, 0, 2);

            byte[] datastring = Encoding.UTF8.GetBytes("data");
            stream.Write(datastring, 0, 4);

            byte[] subChunk2 = BitConverter.GetBytes(samples * channels * 2);
            stream.Write(subChunk2, 0, 4);

            stream.Seek(0, SeekOrigin.Begin);
        }

#endregion
    }
}
```

`src/UI/Widgets/UnityObjects/MaterialWidget.cs`:

```cs
using System.Collections;
using UnityExplorer.Config;
using UnityExplorer.Inspectors;
using UnityExplorer.UI.Panels;
using UniverseLib.Runtime;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.UI.Widgets
{
    public class MaterialWidget : UnityObjectWidget
    {
        static MaterialWidget()
        {
            mi_GetTexturePropertyNames = typeof(Material).GetMethod("GetTexturePropertyNames", ArgumentUtility.EmptyTypes);
            MaterialWidgetSupported = mi_GetTexturePropertyNames != null;
        }

        internal static bool MaterialWidgetSupported { get; }
        static readonly MethodInfo mi_GetTexturePropertyNames;

        Material material;
        Texture2D activeTexture;
        readonly Dictionary<string, Texture> textures = new();
        readonly HashSet<Texture2D> texturesToDestroy = new();

        bool textureViewerWanted;
        ButtonRef toggleButton;

        GameObject textureViewerRoot;
        Dropdown textureDropdown;
        InputFieldRef savePathInput;
        Image image;
        LayoutElement imageLayout;

        public override void OnBorrowed(object target, Type targetType, ReflectionInspector inspector)
        {
            base.OnBorrowed(target, targetType, inspector);

            material = target.TryCast<Material>();

            if (material.mainTexture)
                SetActiveTexture(material.mainTexture);

            if (mi_GetTexturePropertyNames.Invoke(material, ArgumentUtility.EmptyArgs) is IEnumerable<string> propNames)
            {
                foreach (string property in propNames)
                {
                    if (material.GetTexture(property) is Texture texture)
                    {
                        if (texture.TryCast<Texture2D>() is null && texture.TryCast<Cubemap>() is null)
                            continue;

                        textures.Add(property, texture);

                        if (!activeTexture)
                            SetActiveTexture(texture);
                    }
                }
            }

            if (textureViewerRoot)
            {
                textureViewerRoot.transform.SetParent(inspector.UIRoot.transform);
                RefreshTextureDropdown();
            }

            InspectorPanel.Instance.Dragger.OnFinishResize += OnInspectorFinishResize;
        }

        void SetActiveTexture(Texture texture)
        {
            if (texture.TryCast<Texture2D>() is Texture2D tex2D)
                activeTexture = tex2D;
            else if (texture.TryCast<Cubemap>() is Cubemap cubemap)
            {
                activeTexture = TextureHelper.UnwrapCubemap(cubemap);
                texturesToDestroy.Add(activeTexture);
            }
        }

        public override void OnReturnToPool()
        {
            InspectorPanel.Instance.Dragger.OnFinishResize -= OnInspectorFinishResize;

            if (texturesToDestroy.Any())
            {
                foreach (Texture2D tex in texturesToDestroy)
                    UnityEngine.Object.Destroy(tex);
                texturesToDestroy.Clear();
            }

            material = null;
            activeTexture = null;
            textures.Clear();

            if (image.sprite)
                UnityEngine.Object.Destroy(image.sprite);

            if (textureViewerWanted)
                ToggleTextureViewer();

            if (textureViewerRoot)
                textureViewerRoot.transform.SetParent(Pool<Texture2DWidget>.Instance.InactiveHolder.transform);

            base.OnReturnToPool();
        }

        void ToggleTextureViewer()
        {
            if (textureViewerWanted)
            {
                // disable

                textureViewerWanted = false;
                textureViewerRoot.SetActive(false);
                toggleButton.ButtonText.text = "View Material";

                owner.ContentRoot.SetActive(true);
            }
            else
            {
                // enable

                if (!image.sprite)
                {
                    RefreshTextureViewer();
                    RefreshTextureDropdown();
                }

                SetImageSize();

                textureViewerWanted = true;
                textureViewerRoot.SetActive(true);
                toggleButton.ButtonText.text = "Hide Material";

                owner.ContentRoot.gameObject.SetActive(false);
            }
        }

        void RefreshTextureViewer()
        {
            if (!this.activeTexture)
            {
                ExplorerCore.LogWarning($"Material has no active textures!");
                savePathInput.Text = string.Empty;
                return;
            }

            if (image.sprite)
                UnityEngine.Object.Destroy(image.sprite);

            string name = activeTexture.name;
            if (string.IsNullOrEmpty(name))
                name = "untitled";
            savePathInput.Text = Path.Combine(ConfigManager.Default_Output_Path.Value, $"{name}.png");

            Sprite sprite = TextureHelper.CreateSprite(activeTexture);
            image.sprite = sprite;
        }

        void RefreshTextureDropdown()
        {
            if (!textureDropdown)
                return;

            textureDropdown.options.Clear();

            foreach (string key in textures.Keys)
                textureDropdown.options.Add(new(key));

            int i = 0;
            foreach (Texture value in textures.Values)
            {
                if (activeTexture.ReferenceEqual(value))
                {
                    textureDropdown.value = i;
                    break;
                }
                i++;
            }

            textureDropdown.RefreshShownValue();
        }

        void OnTextureDropdownChanged(int value)
        {
            Texture tex = textures.ElementAt(value).Value;
            if (activeTexture.ReferenceEqual(tex))
                return;
            SetActiveTexture(tex);
            RefreshTextureViewer();
        }

        void OnInspectorFinishResize()
        {
            SetImageSize();
        }

        void SetImageSize()
        {
            if (!imageLayout)
                return;

            RuntimeHelper.StartCoroutine(SetImageSizeCoro());
        }

        IEnumerator SetImageSizeCoro()
        {
            if (!activeTexture)
                yield break;

            // let unity rebuild layout etc
            yield return null;

            RectTransform imageRect = InspectorPanel.Instance.Rect;

            float rectWidth = imageRect.rect.width - 25;
            float rectHeight = imageRect.rect.height - 196;

            // If our image is smaller than the viewport, just use 100% scaling
            if (activeTexture.width < rectWidth && activeTexture.height < rectHeight)
            {
                imageLayout.minWidth = activeTexture.width;
                imageLayout.minHeight = activeTexture.height;
            }
            else // we will need to scale down the image to fit
            {
                // get the ratio of our viewport dimensions to width and height
                float viewWidthRatio = (float)((decimal)rectWidth / (decimal)activeTexture.width);
                float viewHeightRatio = (float)((decimal)rectHeight / (decimal)activeTexture.height);

                // if width needs to be scaled more than height
                if (viewWidthRatio < viewHeightRatio)
                {
                    imageLayout.minWidth = activeTexture.width * viewWidthRatio;
                    imageLayout.minHeight = activeTexture.height * viewWidthRatio;
                }
                else // if height needs to be scaled more than width
                {
                    imageLayout.minWidth = activeTexture.width * viewHeightRatio;
                    imageLayout.minHeight = activeTexture.height * viewHeightRatio;
                }
            }
        }

        void OnSaveTextureClicked()
        {
            if (!activeTexture)
            {
                ExplorerCore.LogWarning("Texture is null, maybe it was destroyed?");
                return;
            }

            if (string.IsNullOrEmpty(savePathInput.Text))
            {
                ExplorerCore.LogWarning("Save path cannot be empty!");
                return;
            }

            string path = savePathInput.Text;
            if (!path.EndsWith(".png", StringComparison.InvariantCultureIgnoreCase))
                path += ".png";

            path = IOUtility.EnsureValidFilePath(path);

            if (File.Exists(path))
                File.Delete(path);

            TextureHelper.SaveTextureAsPNG(activeTexture, path);
        }

        public override GameObject CreateContent(GameObject uiRoot)
        {
            GameObject ret = base.CreateContent(uiRoot);

            // Button

            toggleButton = UIFactory.CreateButton(UIRoot, "MaterialButton", "View Material", new Color(0.2f, 0.3f, 0.2f));
            toggleButton.Transform.SetSiblingIndex(0);
            UIFactory.SetLayoutElement(toggleButton.Component.gameObject, minHeight: 25, minWidth: 150);
            toggleButton.OnClick += ToggleTextureViewer;

            // Texture viewer

            textureViewerRoot = UIFactory.CreateVerticalGroup(uiRoot, "MaterialViewer", false, false, true, true, 2, new Vector4(5, 5, 5, 5),
                new Color(0.1f, 0.1f, 0.1f), childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(textureViewerRoot, flexibleWidth: 9999, flexibleHeight: 9999);

            // Buttons holder

            GameObject dropdownRow = UIFactory.CreateHorizontalGroup(textureViewerRoot, "DropdownRow", false, true, true, true, 5, new(3, 3, 3, 3));
            UIFactory.SetLayoutElement(dropdownRow, minHeight: 30, flexibleWidth: 9999);

            Text dropdownLabel = UIFactory.CreateLabel(dropdownRow, "DropdownLabel", "Texture:");
            UIFactory.SetLayoutElement(dropdownLabel.gameObject, minWidth: 75, minHeight: 25);

            GameObject dropdownObj = UIFactory.CreateDropdown(dropdownRow, "TextureDropdown", out textureDropdown, "NOT SET", 13, OnTextureDropdownChanged);
            UIFactory.SetLayoutElement(dropdownObj, minWidth: 350, minHeight: 25);

            // Save helper

            GameObject saveRowObj = UIFactory.CreateHorizontalGroup(textureViewerRoot, "SaveRow", false, false, true, true, 2, new Vector4(2, 2, 2, 2),
                new Color(0.1f, 0.1f, 0.1f));

            ButtonRef saveBtn = UIFactory.CreateButton(saveRowObj, "SaveButton", "Save .PNG", new Color(0.2f, 0.25f, 0.2f));
            UIFactory.SetLayoutElement(saveBtn.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            saveBtn.OnClick += OnSaveTextureClicked;

            savePathInput = UIFactory.CreateInputField(saveRowObj, "SaveInput", "...");
            UIFactory.SetLayoutElement(savePathInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 9999);

            // Actual texture viewer

            GameObject imageViewport = UIFactory.CreateVerticalGroup(textureViewerRoot, "ImageViewport", false, false, true, true,
                bgColor: new(1, 1, 1, 0), childAlignment: TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(imageViewport, flexibleWidth: 9999, flexibleHeight: 9999);

            GameObject imageHolder = UIFactory.CreateUIObject("ImageHolder", imageViewport);
            imageLayout = UIFactory.SetLayoutElement(imageHolder, 1, 1, 0, 0);

            GameObject actualImageObj = UIFactory.CreateUIObject("ActualImage", imageHolder);
            RectTransform actualRect = actualImageObj.GetComponent<RectTransform>();
            actualRect.anchorMin = new(0, 0);
            actualRect.anchorMax = new(1, 1);
            image = actualImageObj.AddComponent<Image>();

            textureViewerRoot.SetActive(false);

            return ret;
        }
    }
}

```

`src/UI/Widgets/UnityObjects/Texture2DWidget.cs`:

```cs
using System.Collections;
using UnityExplorer.Config;
using UnityExplorer.Inspectors;
using UnityExplorer.UI.Panels;
using UniverseLib.Runtime;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.UI.Widgets
{
    public class Texture2DWidget : UnityObjectWidget
    {
        Texture2D texture;
        bool shouldDestroyTexture;

        bool textureViewerWanted;
        ButtonRef toggleButton;

        GameObject textureViewerRoot;
        InputFieldRef savePathInput;
        Image image;
        LayoutElement imageLayout;

        public override void OnBorrowed(object target, Type targetType, ReflectionInspector inspector)
        {
            base.OnBorrowed(target, targetType, inspector);

            if (target.TryCast<Cubemap>() is Cubemap cubemap)
            {
                texture = TextureHelper.UnwrapCubemap(cubemap);
                shouldDestroyTexture = true;
            }
            else if (target.TryCast<Sprite>() is Sprite sprite)
            {
                if (sprite.packingMode == SpritePackingMode.Tight)
                    texture = sprite.texture;
                else
                {
                    texture = TextureHelper.CopyTexture(sprite.texture, sprite.textureRect);
                    shouldDestroyTexture = true;
                }
            }
            else if (target.TryCast<Image>() is Image image)
            {
                if (image.sprite.packingMode == SpritePackingMode.Tight)
                    texture = image.sprite.texture;
                else
                {
                    texture = TextureHelper.CopyTexture(image.sprite.texture, image.sprite.textureRect);
                    shouldDestroyTexture = true;
                }
            }
            else
                texture = target.TryCast<Texture2D>();

            if (textureViewerRoot)
                textureViewerRoot.transform.SetParent(inspector.UIRoot.transform);

            InspectorPanel.Instance.Dragger.OnFinishResize += OnInspectorFinishResize;
        }

        public override void OnReturnToPool()
        {
            InspectorPanel.Instance.Dragger.OnFinishResize -= OnInspectorFinishResize;

            if (shouldDestroyTexture)
                UnityEngine.Object.Destroy(texture);

            texture = null;
            shouldDestroyTexture = false;

            if (image.sprite)
                UnityEngine.Object.Destroy(image.sprite);

            if (textureViewerWanted)
                ToggleTextureViewer();

            if (textureViewerRoot)
                textureViewerRoot.transform.SetParent(Pool<Texture2DWidget>.Instance.InactiveHolder.transform);

            base.OnReturnToPool();
        }

        void ToggleTextureViewer()
        {
            if (textureViewerWanted)
            {
                // disable
                textureViewerWanted = false;
                textureViewerRoot.SetActive(false);
                toggleButton.ButtonText.text = "View Texture";

                owner.ContentRoot.SetActive(true);
            }
            else
            {
                // enable
                if (!image.sprite)
                    SetupTextureViewer();

                SetImageSize();

                textureViewerWanted = true;
                textureViewerRoot.SetActive(true);
                toggleButton.ButtonText.text = "Hide Texture";

                owner.ContentRoot.gameObject.SetActive(false);
            }
        }

        void SetupTextureViewer()
        {
            if (!this.texture)
                return;

            string name = texture.name;
            if (string.IsNullOrEmpty(name))
                name = "untitled";
            savePathInput.Text = Path.Combine(ConfigManager.Default_Output_Path.Value, $"{name}.png");

            Sprite sprite = TextureHelper.CreateSprite(texture);
            image.sprite = sprite;
        }

        void OnInspectorFinishResize()
        {
            SetImageSize();
        }

        void SetImageSize()
        {
            if (!imageLayout)
                return;

            RuntimeHelper.StartCoroutine(SetImageSizeCoro());
        }

        IEnumerator SetImageSizeCoro()
        {
            // let unity rebuild layout etc
            yield return null;

            RectTransform imageRect = InspectorPanel.Instance.Rect;

            float rectWidth = imageRect.rect.width - 25;
            float rectHeight = imageRect.rect.height - 196;

            // If our image is smaller than the viewport, just use 100% scaling
            if (texture.width < rectWidth && texture.height < rectHeight)
            {
                imageLayout.minWidth = texture.width;
                imageLayout.minHeight = texture.height;
            }
            else // we will need to scale down the image to fit
            {
                // get the ratio of our viewport dimensions to width and height
                float viewWidthRatio = (float)((decimal)rectWidth / (decimal)texture.width);
                float viewHeightRatio = (float)((decimal)rectHeight / (decimal)texture.height);

                // if width needs to be scaled more than height
                if (viewWidthRatio < viewHeightRatio)
                {
                    imageLayout.minWidth = texture.width * viewWidthRatio;
                    imageLayout.minHeight = texture.height * viewWidthRatio;
                }
                else // if height needs to be scaled more than width
                {
                    imageLayout.minWidth = texture.width * viewHeightRatio;
                    imageLayout.minHeight = texture.height * viewHeightRatio;
                }
            }
        }

        void OnSaveTextureClicked()
        {
            if (!texture)
            {
                ExplorerCore.LogWarning("Texture is null, maybe it was destroyed?");
                return;
            }

            if (string.IsNullOrEmpty(savePathInput.Text))
            {
                ExplorerCore.LogWarning("Save path cannot be empty!");
                return;
            }

            string path = savePathInput.Text;
            if (!path.EndsWith(".png", StringComparison.InvariantCultureIgnoreCase))
                path += ".png";

            path = IOUtility.EnsureValidFilePath(path);

            if (File.Exists(path))
                File.Delete(path);

            TextureHelper.SaveTextureAsPNG(texture, path);
        }

        public override GameObject CreateContent(GameObject uiRoot)
        {
            GameObject ret = base.CreateContent(uiRoot);

            // Button

            toggleButton = UIFactory.CreateButton(UIRoot, "TextureButton", "View Texture", new Color(0.2f, 0.3f, 0.2f));
            toggleButton.Transform.SetSiblingIndex(0);
            UIFactory.SetLayoutElement(toggleButton.Component.gameObject, minHeight: 25, minWidth: 150);
            toggleButton.OnClick += ToggleTextureViewer;

            // Texture viewer

            textureViewerRoot = UIFactory.CreateVerticalGroup(uiRoot, "TextureViewer", false, false, true, true, 2, new Vector4(5, 5, 5, 5),
                new Color(0.1f, 0.1f, 0.1f), childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(textureViewerRoot, flexibleWidth: 9999, flexibleHeight: 9999);

            // Save helper

            GameObject saveRowObj = UIFactory.CreateHorizontalGroup(textureViewerRoot, "SaveRow", false, false, true, true, 2, new Vector4(2, 2, 2, 2),
                new Color(0.1f, 0.1f, 0.1f));

            ButtonRef saveBtn = UIFactory.CreateButton(saveRowObj, "SaveButton", "Save .PNG", new Color(0.2f, 0.25f, 0.2f));
            UIFactory.SetLayoutElement(saveBtn.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            saveBtn.OnClick += OnSaveTextureClicked;

            savePathInput = UIFactory.CreateInputField(saveRowObj, "SaveInput", "...");
            UIFactory.SetLayoutElement(savePathInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 9999);

            // Actual texture viewer

            GameObject imageViewport = UIFactory.CreateVerticalGroup(textureViewerRoot, "ImageViewport", false, false, true, true,
                bgColor: new(1, 1, 1, 0), childAlignment: TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(imageViewport, flexibleWidth: 9999, flexibleHeight: 9999);

            GameObject imageHolder = UIFactory.CreateUIObject("ImageHolder", imageViewport);
            imageLayout = UIFactory.SetLayoutElement(imageHolder, 1, 1, 0, 0);

            GameObject actualImageObj = UIFactory.CreateUIObject("ActualImage", imageHolder);
            RectTransform actualRect = actualImageObj.GetComponent<RectTransform>();
            actualRect.anchorMin = new(0, 0);
            actualRect.anchorMax = new(1, 1);
            image = actualImageObj.AddComponent<Image>();

            textureViewerRoot.SetActive(false);

            return ret;
        }
    }
}

```

`src/UI/Widgets/UnityObjects/UnityObjectWidget.cs`:

```cs
using UnityExplorer.Inspectors;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.UI.Widgets
{
    public class UnityObjectWidget : IPooledObject
    {
        public UnityEngine.Object unityObject;
        public Component component;
        public ReflectionInspector owner;

        protected ButtonRef gameObjectButton;
        protected InputFieldRef nameInput;
        protected InputFieldRef instanceIdInput;

        // IPooledObject
        public GameObject UIRoot { get; set; }
        public float DefaultHeight => -1;

        public static UnityObjectWidget GetUnityWidget(object target, Type targetType, ReflectionInspector inspector)
        {
            if (!typeof(UnityEngine.Object).IsAssignableFrom(targetType))
                return null;

            UnityObjectWidget widget = target switch
            {
                Texture2D or Cubemap => Pool<Texture2DWidget>.Borrow(),
                Sprite s when s.texture => Pool<Texture2DWidget>.Borrow(),
                Image i when i.sprite?.texture => Pool<Texture2DWidget>.Borrow(),

                Material when MaterialWidget.MaterialWidgetSupported => Pool<MaterialWidget>.Borrow(),

                AudioClip => Pool<AudioClipWidget>.Borrow(),

                _ => Pool<UnityObjectWidget>.Borrow()
            };

            widget.OnBorrowed(target, targetType, inspector);

            return widget;
        }

        public virtual void OnBorrowed(object target, Type targetType, ReflectionInspector inspector)
        {
            this.owner = inspector;

            if (!this.UIRoot)
                CreateContent(inspector.UIRoot);
            else
                this.UIRoot.transform.SetParent(inspector.UIRoot.transform);

            this.UIRoot.transform.SetSiblingIndex(inspector.UIRoot.transform.childCount - 2);

            unityObject = target.TryCast<UnityEngine.Object>();
            UIRoot.SetActive(true);

            nameInput.Text = unityObject.name;
            instanceIdInput.Text = unityObject.GetInstanceID().ToString();

            if (typeof(Component).IsAssignableFrom(targetType))
            {
                component = (Component)target.TryCast(typeof(Component));
                gameObjectButton.Component.gameObject.SetActive(true);
            }
            else
                gameObjectButton.Component.gameObject.SetActive(false);
        }

        public virtual void OnReturnToPool()
        {
            unityObject = null;
            component = null;
            owner = null;
        }

        // Update

        public virtual void Update()
        {
            if (this.unityObject)
            {
                nameInput.Text = unityObject.name;
                
                owner.Tab.TabText.text = $"{owner.TabButtonText} \"{unityObject.name}\"";
            }
        }

        // UI Listeners

        private void OnGameObjectButtonClicked()
        {
            if (!component)
            {
                ExplorerCore.LogWarning("Component reference is null or destroyed!");
                return;
            }

            InspectorManager.Inspect(component.gameObject);
        }

        // UI construction

        public virtual GameObject CreateContent(GameObject uiRoot)
        {
            UIRoot = UIFactory.CreateUIObject("UnityObjectRow", uiRoot);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 5);
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            Text nameLabel = UIFactory.CreateLabel(UIRoot, "NameLabel", "Name:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(nameLabel.gameObject, minHeight: 25, minWidth: 45, flexibleWidth: 0);

            nameInput = UIFactory.CreateInputField(UIRoot, "NameInput", "untitled");
            UIFactory.SetLayoutElement(nameInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 1000);
            nameInput.Component.readOnly = true;

            gameObjectButton = UIFactory.CreateButton(UIRoot, "GameObjectButton", "Inspect GameObject", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(gameObjectButton.Component.gameObject, minHeight: 25, minWidth: 160);
            gameObjectButton.OnClick += OnGameObjectButtonClicked;

            Text instanceLabel = UIFactory.CreateLabel(UIRoot, "InstanceLabel", "Instance ID:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(instanceLabel.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);

            instanceIdInput = UIFactory.CreateInputField(UIRoot, "InstanceIDInput", "ERROR");
            UIFactory.SetLayoutElement(instanceIdInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            instanceIdInput.Component.readOnly = true;

            UIRoot.SetActive(false);

            return UIRoot;
        }
    }
}

```

`src/UnityExplorer.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <OutputType>Library</OutputType>
        <PlatformTarget>AnyCPU</PlatformTarget>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
        <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
        <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
        <AllowedReferenceRelatedFileExtensions>none</AllowedReferenceRelatedFileExtensions>
        <DebugSymbols>false</DebugSymbols>
        <DebugType>none</DebugType>
        <RootNamespace>UnityExplorer</RootNamespace>
        <LangVersion>10.0</LangVersion>
        <Configurations>BIE_Cpp;BIE_Cpp_CoreCLR;BIE5_Mono;BIE6_Mono;ML_Cpp_net6;ML_Cpp_net472;ML_Mono;STANDALONE_Mono;STANDALONE_Cpp</Configurations>
    </PropertyGroup>
    <!-- ~~~~~ CONFIGURATIONS ~~~~~ -->
    <!-- ML IL2CPP net6 -->
    <PropertyGroup Condition="'$(Configuration)'=='ML_Cpp_net6'">
        <TargetFramework>net6</TargetFramework>
        <OutputPath>..\Release\UnityExplorer.MelonLoader.IL2CPP.net6preview\</OutputPath>
        <DefineConstants>CPP,ML,UNHOLLOWER</DefineConstants>
		<AssemblyName>UnityExplorer.ML.IL2CPP.net6preview</AssemblyName>
    </PropertyGroup>
    <!-- ML IL2CPP net472 (TEMP) -->
    <PropertyGroup Condition="'$(Configuration)'=='ML_Cpp_net472'">
        <TargetFramework>net472</TargetFramework>
        <OutputPath>..\Release\UnityExplorer.MelonLoader.IL2CPP\</OutputPath>
        <DefineConstants>CPP,ML,UNHOLLOWER</DefineConstants>
        <AssemblyName>UnityExplorer.ML.IL2CPP</AssemblyName>
    </PropertyGroup>
    <!-- ML MONO -->
    <PropertyGroup Condition="'$(Configuration)'=='ML_Mono'">
        <TargetFramework>net35</TargetFramework>
        <OutputPath>..\Release\UnityExplorer.MelonLoader.Mono\</OutputPath>
        <DefineConstants>MONO,ML</DefineConstants>
        <AssemblyName>UnityExplorer.ML.Mono</AssemblyName>
    </PropertyGroup>
    <!-- BEPINEX IL2CPP -->
    <PropertyGroup Condition="'$(Configuration)'=='BIE_Cpp'">
        <TargetFramework>net472</TargetFramework>
        <OutputPath>..\Release\UnityExplorer.BepInEx.IL2CPP\</OutputPath>
        <DefineConstants>CPP,BIE,BIE6,UNHOLLOWER</DefineConstants>
        <AssemblyName>UnityExplorer.BIE.IL2CPP</AssemblyName>
    </PropertyGroup>
    <!-- BEPINEX IL2CPP CoreCLR -->
    <PropertyGroup Condition="'$(Configuration)'=='BIE_Cpp_CoreCLR'">
        <TargetFramework>net6</TargetFramework>
        <OutputPath>..\Release\UnityExplorer.BepInEx.IL2CPP.CoreCLR\</OutputPath>
        <DefineConstants>CPP,BIE,BIE6,INTEROP</DefineConstants>
        <AssemblyName>UnityExplorer.BIE.IL2CPP.CoreCLR</AssemblyName>
    </PropertyGroup>
    <!-- BEPINEX 6 MONO -->
    <PropertyGroup Condition="'$(Configuration)'=='BIE6_Mono'">
        <TargetFramework>net35</TargetFramework>
        <OutputPath>..\Release\UnityExplorer.BepInEx6.Mono\</OutputPath>
        <DefineConstants>MONO,BIE,BIE6</DefineConstants>
        <AssemblyName>UnityExplorer.BIE6.Mono</AssemblyName>
    </PropertyGroup>
    <!-- BEPINEX 5 MONO -->
    <PropertyGroup Condition="'$(Configuration)'=='BIE5_Mono'">
        <TargetFramework>net35</TargetFramework>
        <OutputPath>..\Release\UnityExplorer.BepInEx5.Mono\</OutputPath>
        <DefineConstants>MONO,BIE,BIE5</DefineConstants>
        <AssemblyName>UnityExplorer.BIE5.Mono</AssemblyName>
    </PropertyGroup>
    <!-- STANDALONE Mono -->
    <PropertyGroup Condition="'$(Configuration)'=='STANDALONE_Mono'">
        <TargetFramework>net35</TargetFramework>
        <OutputPath>..\Release\UnityExplorer.Standalone.Mono\</OutputPath>
        <DefineConstants>MONO,STANDALONE</DefineConstants>
        <AssemblyName>UnityExplorer.STANDALONE.Mono</AssemblyName>
    </PropertyGroup>
    <!-- STANDALONE Il2Cpp -->
    <PropertyGroup Condition="'$(Configuration)'=='STANDALONE_Cpp'">
        <TargetFramework>net472</TargetFramework>
        <OutputPath>..\Release\UnityExplorer.Standalone.IL2CPP\</OutputPath>
        <DefineConstants>CPP,STANDALONE,UNHOLLOWER</DefineConstants>
        <AssemblyName>UnityExplorer.STANDALONE.IL2CPP</AssemblyName>
    </PropertyGroup>

    <!-- ~~~~~ NUGET ~~~~~ -->
    <ItemGroup>
        <PackageReference Include="HarmonyX" Version="2.5.2" IncludeAssets="compile" />
        <PackageReference Include="Samboy063.Tomlet" Version="3.1.3" />
    </ItemGroup>
    <!-- il2cpp nuget -->
    <ItemGroup Condition="'$(Configuration)'=='ML_Cpp_net6' or '$(Configuration)'=='ML_Cpp_net472' or '$(Configuration)'=='STANDALONE_Cpp' or '$(Configuration)'=='BIE_Cpp'">
        <PackageReference Include="Il2CppAssemblyUnhollower.BaseLib" Version="0.4.22" />
        <PackageReference Include="UniverseLib.IL2CPP.Unhollower" Version="1.5.1" />
    </ItemGroup>
    <ItemGroup Condition="'$(Configuration)'=='BIE_Cpp_CoreCLR'">
        <PackageReference Include="Il2CppInterop.Common" Version="1.0.0" />
        <PackageReference Include="Il2CppInterop.Runtime" Version="1.0.0" />
        <PackageReference Include="UniverseLib.IL2CPP.Interop" Version="1.5.1" />
    </ItemGroup>
    <!-- mono nuget -->
    <ItemGroup Condition="'$(Configuration)'=='BIE6_Mono' or '$(Configuration)'=='BIE5_Mono' or '$(Configuration)'=='ML_Mono' or '$(Configuration)'=='STANDALONE_Mono'">
        <PackageReference Include="UniverseLib.Mono" Version="1.5.1" />
    </ItemGroup>

    <!-- ~~~~~ ASSEMBLY REFERENCES ~~~~~ -->
    <!-- net6 -->
    <ItemGroup Condition="'$(TargetFramework)'=='net6'">
        <Reference Include="mcs">
            <HintPath>..\lib\net6\mcs.dll</HintPath>
            <Private>True</Private>
        </Reference>
    </ItemGroup>
    <!-- net35 / net472 -->
    <ItemGroup Condition="'$(TargetFramework)'=='net35' or '$(TargetFramework)'=='net472'">
        <Reference Include="mcs">
            <HintPath>..\lib\net35\mcs.dll</HintPath>
            <Private>True</Private>
        </Reference>
    </ItemGroup>
    <!-- MelonLoader net6 -->
    <ItemGroup Condition="'$(Configuration)'=='ML_Cpp_net6'">
        <Reference Include="MelonLoader">
            <HintPath>..\lib\net6\MelonLoader.dll</HintPath>
            <Private>False</Private>
        </Reference>
    </ItemGroup>
    <!-- MelonLoader net35 -->
    <ItemGroup Condition="'$(Configuration)'=='ML_Mono' or '$(Configuration)'=='ML_Cpp_net472'">
        <Reference Include="MelonLoader">
            <HintPath>..\lib\net35\MelonLoader.dll</HintPath>
            <Private>False</Private>
        </Reference>
    </ItemGroup>
    <!-- BepInEx 5 Mono -->
    <ItemGroup Condition="'$(Configuration)'=='BIE5_Mono'">
        <Reference Include="BepInEx">
            <HintPath>..\lib\net35\BepInEx.dll</HintPath>
            <Private>False</Private>
        </Reference>
    </ItemGroup>
    <!-- BepInEx 6 Mono -->
    <ItemGroup Condition="'$(Configuration)'=='BIE6_Mono'">
        <Reference Include="BepInEx">
            <HintPath>..\lib\net35\BepInEx.Core.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="BepInEx.Unity">
            <HintPath>..\lib\net35\BepInEx.Unity.dll</HintPath>
            <Private>False</Private>
        </Reference>
    </ItemGroup>
    <!-- BepInEx Il2Cpp -->
    <ItemGroup Condition="'$(Configuration)'=='BIE_Cpp' or '$(Configuration)'=='BIE_Cpp_CoreCLR'">
        <Reference Include="BepInEx">
            <HintPath>..\lib\net472\BepInEx.Core.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="BepInEx.IL2CPP">
            <HintPath>..\lib\net472\BepInEx.IL2CPP.dll</HintPath>
            <Private>False</Private>
        </Reference>
    </ItemGroup>
    <!-- Mono -->
    <ItemGroup Condition="'$(Configuration)'=='BIE6_Mono' or '$(Configuration)'=='BIE5_Mono' or '$(Configuration)'=='ML_Mono' or '$(Configuration)'=='STANDALONE_Mono'">
        <Reference Include="UnityEngine">
            <HintPath>..\lib\net35\UnityEngine.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.UI">
            <HintPath>..\lib\net35\UnityEngine.UI.dll</HintPath>
            <Private>False</Private>
        </Reference>
    </ItemGroup>
    <!-- Il2Cpp Unhollower -->
    <ItemGroup Condition="'$(Configuration)'=='ML_Cpp_net6' or '$(Configuration)'=='ML_Cpp_net472' or '$(Configuration)'=='STANDALONE_Cpp' or '$(Configuration)'=='BIE_Cpp'">
        <Reference Include="Il2Cppmscorlib">
            <HintPath>..\lib\unhollowed\Il2Cppmscorlib.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="Il2CppSystem.Core">
            <HintPath>..\lib\unhollowed\Il2CppSystem.Core.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine">
            <HintPath>..\lib\unhollowed\UnityEngine.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.AudioModule">
            <HintPath>..\lib\unhollowed\UnityEngine.AudioModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.CoreModule">
            <HintPath>..\lib\unhollowed\UnityEngine.CoreModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.PhysicsModule">
            <HintPath>..\lib\unhollowed\UnityEngine.PhysicsModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.TextRenderingModule">
            <HintPath>..\lib\unhollowed\UnityEngine.TextRenderingModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.UI">
            <HintPath>..\lib\unhollowed\UnityEngine.UI.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.UIModule">
            <HintPath>..\lib\unhollowed\UnityEngine.UIModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.IMGUIModule">
            <HintPath>..\lib\unhollowed\UnityEngine.IMGUIModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
    </ItemGroup>
    <!-- Il2Cpp Interop -->
    <ItemGroup Condition="'$(Configuration)'=='BIE_Cpp_CoreCLR'">
        <Reference Include="Il2Cppmscorlib">
            <HintPath>..\lib\interop\Il2Cppmscorlib.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="Il2CppSystem.Core">
            <HintPath>..\lib\interop\Il2CppSystem.Core.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine">
            <HintPath>..\lib\interop\UnityEngine.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.AudioModule">
            <HintPath>..\lib\interop\UnityEngine.AudioModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.CoreModule">
            <HintPath>..\lib\interop\UnityEngine.CoreModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.PhysicsModule">
            <HintPath>..\lib\interop\UnityEngine.PhysicsModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.TextRenderingModule">
            <HintPath>..\lib\interop\UnityEngine.TextRenderingModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.UI">
            <HintPath>..\lib\interop\UnityEngine.UI.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.UIModule">
            <HintPath>..\lib\interop\UnityEngine.UIModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
        <Reference Include="UnityEngine.IMGUIModule">
            <HintPath>..\lib\interop\UnityEngine.IMGUIModule.dll</HintPath>
            <Private>False</Private>
        </Reference>
    </ItemGroup>
</Project>
```

`src/UnityExplorer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32328.378
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UnityExplorer", "UnityExplorer.csproj", "{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release_BIE_Cpp|Any CPU = Release_BIE_Cpp|Any CPU
		Release_BIE_CoreCLR|Any CPU = Release_BIE_CoreCLR|Any CPU
		Release_BIE5_Mono|Any CPU = Release_BIE5_Mono|Any CPU
		Release_BIE6_Mono|Any CPU = Release_BIE6_Mono|Any CPU
		Release_ML_Cpp_net472|Any CPU = Release_ML_Cpp_net472|Any CPU
		Release_ML_Cpp_net6|Any CPU = Release_ML_Cpp_net6|Any CPU
		Release_ML_Mono|Any CPU = Release_ML_Mono|Any CPU
		Release_STANDALONE_Cpp|Any CPU = Release_STANDALONE_Cpp|Any CPU
		Release_STANDALONE_Mono|Any CPU = Release_STANDALONE_Mono|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE_Cpp|Any CPU.ActiveCfg = BIE_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE_Cpp|Any CPU.Build.0 = BIE_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE_CoreCLR|Any CPU.ActiveCfg = BIE_Cpp_CoreCLR|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE_CoreCLR|Any CPU.Build.0 = BIE_Cpp_CoreCLR|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE5_Mono|Any CPU.ActiveCfg = BIE5_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE5_Mono|Any CPU.Build.0 = BIE5_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE6_Mono|Any CPU.ActiveCfg = BIE6_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE6_Mono|Any CPU.Build.0 = BIE6_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Cpp_net472|Any CPU.ActiveCfg = ML_Cpp_net472|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Cpp_net472|Any CPU.Build.0 = ML_Cpp_net472|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Cpp_net6|Any CPU.ActiveCfg = ML_Cpp_net6|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Cpp_net6|Any CPU.Build.0 = ML_Cpp_net6|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Mono|Any CPU.ActiveCfg = ML_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Mono|Any CPU.Build.0 = ML_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_STANDALONE_Cpp|Any CPU.ActiveCfg = STANDALONE_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_STANDALONE_Cpp|Any CPU.Build.0 = STANDALONE_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_STANDALONE_Mono|Any CPU.ActiveCfg = STANDALONE_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_STANDALONE_Mono|Any CPU.Build.0 = STANDALONE_Mono|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DD5C0A5D-03F1-4CC3-8B4D-E10834908C5A}
	EndGlobalSection
EndGlobal

```

`src/nuget.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <config>
        <add key="dependencyVersion" value="Lowest" />
    </config>

    <packageRestore>
        <!-- Allow NuGet to download missing packages -->
        <add key="enabled" value="True" />

        <!-- Automatically check for missing packages during build in Visual Studio -->
        <add key="automatic" value="True" />
    </packageRestore>

    <packageSources>
        <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
        <add key="BepInEx" value="https://nuget.bepinex.dev/v3/index.json" />
    </packageSources>
</configuration>

```