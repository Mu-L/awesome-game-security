Project Path: arc_MhmRdd_NoHello_gs_ik471

Source Tree:

```txt
arc_MhmRdd_NoHello_gs_ik471
├── LICENSE
├── README.md
├── build.gradle.kts
├── gradle
│   ├── libs.versions.toml
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── module
│   ├── build.gradle.kts
│   ├── src
│   │   └── main
│   │       ├── AndroidManifest.xml
│   │       └── cpp
│   │           ├── Android.mk
│   │           ├── Application.mk
│   │           ├── CMakeLists.txt
│   │           ├── MountRuleParser.cpp
│   │           ├── PropertyManager.cpp
│   │           ├── PropertyManager.h
│   │           ├── external
│   │           │   ├── CMakeLists.txt
│   │           │   ├── android_filesystem_config.h
│   │           │   ├── emoji.h
│   │           │   ├── fdutils
│   │           │   │   ├── fd_utils.cpp
│   │           │   │   ├── fd_utils.h
│   │           │   │   ├── stringprintf.cpp
│   │           │   │   └── stringprintf.h
│   │           │   └── libcxx
│   │           ├── log.h
│   │           ├── mountsinfo.cpp
│   │           ├── nohello.cpp
│   │           ├── utils.cpp
│   │           └── zygisk.hpp
│   └── template
│       ├── META-INF
│       │   └── com
│       │       └── google
│       │           └── android
│       │               ├── update-binary
│       │               └── updater-script
│       ├── cleanup.sh
│       ├── customize.sh
│       ├── module.prop
│       ├── post-fs-data.sh
│       ├── sepolicy.rule
│       ├── service.sh
│       ├── umount
│       ├── uninstall.sh
│       └── verify.sh
└── settings.gradle.kts

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 mhmrdd

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<h2 align="center">Zygisk NoHello</h2>
<p align="center">
  A Zygisk module to hide root.
  </br>
  </br>
  <a href="https://github.com/MhmRdd/NoHello/actions/workflows/build.yml">
    <img src="https://github.com/MhmRdd/Il2Dump/actions/workflows/build.yml/badge.svg?branch=master" alt="Android CI status">
  </a>
  <a href="https://opensource.org/licenses/MIT">
    <img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT">
  </a>
  </br>
  <a href="https://github.com/MhmRdd/NoHello/issues">Report Bug</a>
    ·
  <a href="https://github.com/MhmRdd/NoHello/issues">Request Feature</a>
    ·
  <a href="https://github.com/MhmRdd/NoHello/releases">Latest Release</a>
</p>

> [!NOTE]
> This module currently focuses to hide root & zygisk from apps.
> Updates will gradually implements changes and fixes.

## About The Project

Using the **release** build is recommended over the debug build. Only use debug builds if you are going to make a bug report.

## Usage

### KernelSU & KernelSU Next users:
1. Install ZygiskNext or ReZygisk.
2. Make sure the unmount setting is enabled for the target app in the Manager.
3. Disable Umount modules in settings for Manager (if exists).
4. Disable `Enforce DenyList` in ZygiskNext/ReZygisk settings if there is one.

### APatch users:
1. Install ZygiskNext or ReZygisk.
2. Make sure the unmount setting is enabled for the target app in the Manager.
3. Disable `Enforce DenyList` in ZygiskNext/ReZygisk settings if there is one.

### Magisk users:
1. Update your Magisk to 28.0 or newer for better hiding capabilities. (optional)
2. Turn on Zygisk in Magisk settings (unrecommended) or install ZygiskNext/ReZygisk.
3. Turn off `Enforce DenyList` in Magisk settings.
4. Disable `Enforce DenyList` in ZygiskNext/ReZygisk settings if there is one. (if installed)
5. Add the target app to the deny list unless you're using a Magisk fork with a white list instead.

## Whitelisting (0.0.4+)
You can set the working mode to **whitelist** (instead of the default **blacklist**) by creating an empty regular file `/data/adb/nohello/whitelist`.
>[!WARNING]
> Using **Mount Rule System** with **whitelist**, can cause severe overheating & performance issues, due to how MRS being evaluated each time a process spawns.

This can be solved if you make NoHello evaluates Mount Rule System per boot/companion instance, by creating an empty regular file `/data/adb/nohello/umount_persist`/`data/adb/nohello/umount_persists`

## Mount Rule System

**Since version 0.0.5**, NoHello introduces **Mount Rule System**.</br>
This allows users to define **rules** that control how mount points are evaluated for **auto-unmounting**.</br>
Rules are fully configurable and match based on mount point properties like root path, mount path, filesystem type, or source.</br>
**MountRules** can be customized via `/data/adb/nohello/umount`.

### Rule Format

A rule is made up of **sections**, each consisting of a **keyword**, followed by a list of values enclosed in `{}`:

```
<keyword> { <value1> <value2> ... }
```

Valid **keywords** are:

| Keyword  | Matches against         | Supports Wildcards                                       | Description |
|----------|-------------------------|----------------------------------------------------------|-------------|
| `root`   | Root path of the mount  | Yes (`*`, escape by `\*`)                                | Root of the mount in `/proc/self/mountinfo` |
| `point`  | Mount point path        | Yes (`*`, escape by `\*` only at the beginning & ending) | Where the filesystem is mounted |
| `fs`     | Filesystem type         | No                                                       | Matches exact filesystem type, e.g. `ext4`, `erofs`, etc |
| `source` | Source device or file   | Yes (`*`, escape by `\*`)                                | e.g., `/dev/block/xyz`, `magisk`, etc |

### Example Rules

#### Match all `tmpfs` filesystems mounted under `/data/adb`:
```
fs { "tmpfs" } point { "/data/adb/*" }
```

#### Match anything mounted from a `tmpfs` source:
```
source { "tmpfs" }
```

#### Match a specific mount path exactly:
```
point { "/mnt/specific/path" }
```

#### Match any source ending with `data`:
```
source { "*data" }
```

#### Match root path starting with `/acct` and fs type `cgroup`:
```
root { "/acct*" } fs { "cgroup" }
```

### Quoting Values

You can quote values with **single or double quotes**:

```
point { "/mnt/with space" '/custom\ path' }
```

You may escape characters like `*`, `{`, `}`, and `"` using backslashes (`\`) if needed.

### Wildcard Behavior

Wildcards are supported only in `root`, `point`, and `source`. The supported patterns are:

- `*value*`: matches substring anywhere
- `*value`: matches suffix
- `value*`: matches prefix
- Exact match without `*`


>[!NOTE]
> - You can define **multiple rules**, each as a separate line.
> - All rules are evaluated independently.
> - Matching is case-sensitive and optimized for performance.


## Contributing

Contributions are what make the open source community such an amazing place to learn, inspire, and create. Any contributions you make are **greatly appreciated**.

If you have a suggestion that would make this better, please fork the repo and create a pull request. You can also simply open an issue with the tag "enhancement".
Don't forget to give the project a star! Thanks again!

1. Fork the Project.
2. Create your Feature Branch (`git checkout -b feature/FeatureName`)
3. Commit your Changes (`git commit -m 'Add some FeatureName'`)
4. Push to the Branch (`git push origin feature/FeatureName`)
5. Open a Pull Request.


## Acknowledgement

- [Zygisk Assistant](https://github.com/snake-4/Zygisk-Assistant)

## LICENSE

This project is licensed under the [MIT License](https://opensource.org/licenses/MIT).


```

`build.gradle.kts`:

```kts
import com.android.build.gradle.AppExtension
import java.io.ByteArrayOutputStream

plugins {
    alias(libs.plugins.agp.app) apply false
}

fun String.execute(currentWorkingDir: File = file("./")): String {
    val byteOut = ByteArrayOutputStream()
    project.exec {
        workingDir = currentWorkingDir
        commandLine = split("\\s".toRegex())
        standardOutput = byteOut
    }
    return String(byteOut.toByteArray()).trim()
}

val localProperties by extra(java.util.Properties())
val localPropertiesFile = file("local.properties")
if (localPropertiesFile.exists()) {
    localProperties.load(localPropertiesFile.inputStream())
}

val sdkDir: String by extra(
    localProperties.getProperty("sdk.dir")
        ?: System.getenv("ANDROID_HOME")
        ?: System.getenv("ANDROID_SDK_ROOT")
        ?: ""
)

val zygDir: File by extra(
    localProperties.getProperty("zyg.dir")?.let { File(it) }
        ?: rootProject.layout.projectDirectory.dir(".github/updates").asFile
)

val gitCommitCount = "git rev-list HEAD --count".execute().toInt()
val gitCommitHash = "git rev-parse --verify --short HEAD".execute()

// also the soname
val moduleId by extra("zygisk_nohello")
val moduleName by extra("Nohello")
val verName by extra("v0.0.7")
val verCode by extra(gitCommitCount)
val commitHash by extra(gitCommitHash)
val abiList by extra(listOf("arm64-v8a", "armeabi-v7a", "x86", "x86_64"))

val androidMinSdkVersion by extra(26)
val androidTargetSdkVersion by extra(34)
val androidCompileSdkVersion by extra(34)
val androidBuildToolsVersion by extra("34.0.0")
val androidCompileNdkVersion by extra("26.0.10792818")
val androidSourceCompatibility by extra(JavaVersion.VERSION_17)
val androidTargetCompatibility by extra(JavaVersion.VERSION_17)

tasks.register("Delete", Delete::class) {
    delete(rootProject.buildDir)
}

fun Project.configureBaseExtension() {
    extensions.findByType(AppExtension::class)?.run {
        namespace = "io.github.mhmrdd.zygisk.module.nohello"
        compileSdkVersion(androidCompileSdkVersion)
        ndkVersion = androidCompileNdkVersion
        buildToolsVersion = androidBuildToolsVersion

        defaultConfig {
            minSdk = androidMinSdkVersion
        }

        compileOptions {
            sourceCompatibility = androidSourceCompatibility
            targetCompatibility = androidTargetCompatibility
        }
    }

}

subprojects {
    plugins.withId("com.android.application") {
        configureBaseExtension()
    }
    plugins.withType(JavaPlugin::class.java) {
        extensions.configure(JavaPluginExtension::class.java) {
            sourceCompatibility = androidSourceCompatibility
            targetCompatibility = androidTargetCompatibility
        }
    }
}

```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=true
#org.gradle.configuration-cache=true

```

`gradle/libs.versions.toml`:

```toml
[versions]
agp = "8.5.0"

[plugins]
agp-app = { id = "com.android.application", version.ref = "agp" }

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Sun Dec 31 12:28:57 CST 2023
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`module/build.gradle.kts`:

```kts
import android.databinding.tool.ext.capitalizeUS
import org.apache.tools.ant.filters.FixCrLfFilter
import org.apache.tools.ant.filters.ReplaceTokens
import java.security.MessageDigest

plugins {
    alias(libs.plugins.agp.app)
}

val sdkDir: String by rootProject.extra
val zygDir: File by rootProject.extra
val moduleId: String by rootProject.extra
val moduleName: String by rootProject.extra
val verCode: Int by rootProject.extra
val verName: String by rootProject.extra
val commitHash: String by rootProject.extra
val abiList: List<String> by rootProject.extra

android {
    defaultConfig {
        ndk {
            abiFilters.addAll(abiList)
        }
        externalNativeBuild {
            /*
            ndkBuild {
                arguments("MODULE_NAME=$moduleId")
            }
            */
            cmake {
                cppFlags("-std=c++20")
                arguments(
                    "-DANDROID_STL=none",
                    "-DMODULE_NAME=$moduleId"
                )
            }
        }
    }
    externalNativeBuild {
        /*
        ndkBuild {
            path("src/main/cpp/Android.mk")
        }
        */
        cmake {
            path("src/main/cpp/CMakeLists.txt")
        }
    }
}

val adbPath = "$sdkDir/platform-tools/adb"

androidComponents.onVariants { variant ->
    afterEvaluate {
        val variantLowered = variant.name.lowercase()
        val variantCapped = variant.name.capitalizeUS()
        val buildTypeLowered = variant.buildType?.lowercase()
        val supportedAbis = abiList.map {
            when (it) {
                "arm64-v8a" -> "arm64"
                "armeabi-v7a" -> "arm"
                "x86" -> "x86"
                "x86_64" -> "x64"
                else -> error("unsupported abi $it")
            }
        }.joinToString(" ")

        val moduleDir = layout.buildDirectory.file("outputs/module/$variantLowered")
        val zipFileName =
            "$moduleName-$verName-$verCode-$commitHash-$buildTypeLowered.zip".replace(' ', '-')

        val prepareModuleFilesTask = task<Sync>("prepareModuleFiles$variantCapped") {
            group = "module"
            dependsOn("assemble$variantCapped")
            into(moduleDir)
            from(rootProject.layout.projectDirectory.file("README.md"))
            from(layout.projectDirectory.file("template")) {
                exclude("module.prop", "customize.sh", "post-fs-data.sh", "service.sh")
                filter<FixCrLfFilter>("eol" to FixCrLfFilter.CrLf.newInstance("lf"))
            }
            from(layout.projectDirectory.file("template")) {
                include("module.prop")
                expand(
                    "moduleId" to moduleId,
                    "moduleName" to moduleName,
                    "versionName" to "$verName ($verCode-$commitHash-$variantLowered)",
                    "versionCode" to verCode
                )
            }
            from(layout.projectDirectory.file("template")) {
                include("customize.sh", "post-fs-data.sh", "service.sh")
                val tokens = mapOf(
                    "DEBUG" to if (buildTypeLowered == "debug") "true" else "false",
                    "SONAME" to moduleId,
                    "SUPPORTED_ABIS" to supportedAbis
                )
                filter<ReplaceTokens>("tokens" to tokens)
                filter<FixCrLfFilter>("eol" to FixCrLfFilter.CrLf.newInstance("lf"))
            }
            from(layout.buildDirectory.file("intermediates/stripped_native_libs/$variantLowered/strip${variantCapped}DebugSymbols/out/lib")) {
                into("lib")
            }

            doLast {
                fileTree(moduleDir).visit {
                    if (isDirectory) return@visit
                    val md = MessageDigest.getInstance("SHA-256")
                    file.forEachBlock(4096) { bytes, size ->
                        md.update(bytes, 0, size)
                    }
                    file(file.path + ".sha256").writeText(
                        org.apache.commons.codec.binary.Hex.encodeHexString(
                            md.digest()
                        )
                    )
                }
            }
        }

        val zipTask = task<Zip>("zip$variantCapped") {
            group = "module"
            dependsOn(prepareModuleFilesTask)
            archiveFileName.set(zipFileName)
            destinationDirectory.set(layout.projectDirectory.file("release").asFile)
            from(moduleDir)
        }

        zipTask.doLast {
            val updatesDir = zygDir
            updatesDir.mkdirs()

            val jsonFile = File(updatesDir, "nohello.json")
            val changelogFile = File(updatesDir, "nohello_changelog.md")

            // Update JSON
            val jsonContent = """
            {
                "versionCode": $verCode,
                "version": "$verName",
                "zipUrl": "https://github.com/MhmRdd/nohello/releases/download/${verName.removePrefix("v")}/$zipFileName",
                "changelog": "https://mhmrdd.github.io/01000004/zygisk/nohello_changelog.md"
            }
            """.trimIndent()
            jsonFile.writeText(jsonContent)

            // Get latest Git commit message
            val commitMessage = ProcessBuilder("git", "log", "-1", "--pretty=%B")
                .directory(rootProject.projectDir)
                .redirectErrorStream(true)
                .start()
                .inputStream
                .bufferedReader()
                .readText()
                .trim()

            val newLogEntry = """
                |### $verName ($verCode)
                |
                |- Commit: `$commitHash`
                |- ABI(s): ${abiList.joinToString(", ")}
                |
                |$commitMessage
            """.trimMargin()
            changelogFile.writeText(newLogEntry)
        }


        val pushTask = task<Exec>("push$variantCapped") {
            group = "module"
            dependsOn(zipTask)
            commandLine(adbPath, "push", zipTask.outputs.files.singleFile.path, "/data/local/tmp")
        }

        val installKsuTask = task<Exec>("installKsu$variantCapped") {
            group = "module"
            dependsOn(pushTask)
            commandLine(
                adbPath, "shell", "su", "-c",
                "/data/adb/ksud module install /data/local/tmp/$zipFileName"
            )
        }

        val installMagiskTask = task<Exec>("installMagisk$variantCapped") {
            group = "module"
            dependsOn(pushTask)
            commandLine(
                adbPath,
                "shell",
                "su",
                "-M",
                "-c",
                "magisk --install-module /data/local/tmp/$zipFileName"
            )
        }

        task<Exec>("installKsuAndReboot$variantCapped") {
            group = "module"
            dependsOn(installKsuTask)
            commandLine(adbPath, "reboot")
        }

        task<Exec>("installMagiskAndReboot$variantCapped") {
            group = "module"
            dependsOn(installMagiskTask)
            commandLine(adbPath, "reboot")
        }
    }
}

```

`module/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest/>

```

`module/src/main/cpp/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := $(MODULE_NAME)
LOCAL_SRC_FILES := example.cpp
LOCAL_STATIC_LIBRARIES := libcxx
LOCAL_LDLIBS := -llog
include $(BUILD_SHARED_LIBRARY)

include $(LOCAL_PATH)/external/libcxx/Android.mk

# If you do not want to use libc++, link to system stdc++
# so that you can at least call the new operator in your code

# include $(CLEAR_VARS)
# LOCAL_MODULE := example
# LOCAL_SRC_FILES := example.cpp
# LOCAL_LDLIBS := -llog -lstdc++
# include $(BUILD_SHARED_LIBRARY)

```

`module/src/main/cpp/Application.mk`:

```mk
APP_ABI      := armeabi-v7a arm64-v8a x86 x86_64
APP_CPPFLAGS := -std=c++17 -fno-exceptions -fno-rtti -fvisibility=hidden -fvisibility-inlines-hidden
APP_STL      := none
APP_PLATFORM := android-21

```

`module/src/main/cpp/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22.1)
project(sample)

if (CMAKE_BUILD_TYPE STREQUAL "Debug")
    add_definitions(-DDEBUG_BUILD)
    set(CXX_FLAGS "${CXX_FLAGS} -O0 -g -fno-exceptions -fno-rtti")
    set(LINKER_FLAGS "-g -rdynamic -ffixed-x18 -Wl,--hash-style=both -Wl,--export-dynamic")
else ()
    set(CXX_FLAGS "${CXX_FLAGS} -fno-exceptions -fno-rtti -fvisibility=hidden -fvisibility-inlines-hidden")
    set(LINKER_FLAGS "-ffixed-x18 -Wl,--hash-style=both")
endif ()

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXX_FLAGS}")

set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${LINKER_FLAGS}")
set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} ${LINKER_FLAGS}")

add_library(${MODULE_NAME} SHARED nohello.cpp)
target_link_libraries(${MODULE_NAME} cxx log)

add_subdirectory(external)

```

`module/src/main/cpp/MountRuleParser.cpp`:

```cpp
#include <fstream>
#include <sstream>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <string>
#include "log.h"

class MountRuleParser {
public:
	struct MountRule {
		std::vector<std::string> rootSubstrs;
		std::vector<std::string> mountPointSubstrs;
		std::unordered_set<std::string> fsTypes;
		std::vector<std::string> sources; // changed from unordered_set to vector for wildcard matching

		explicit operator bool() const {
			return !(rootSubstrs.empty() && mountPointSubstrs.empty() && fsTypes.empty() && sources.empty());
		}

		bool matches(const std::string& root, const std::string& mountPoint,
					 const std::string& fsType, const std::string& source) const {
			return matchList(rootSubstrs, root) &&
				   matchList(mountPointSubstrs, mountPoint) &&
				   (fsTypes.empty() || fsTypes.count(fsType) > 0) &&
				   matchSourceList(sources, source);
		}

		bool matches(const std::vector<std::string>& roots, const std::string& mountPoint,
					 const std::string& fsType, const std::string& source) const {
			if (!matchList(mountPointSubstrs, mountPoint) ||
				(!fsTypes.empty() && fsTypes.count(fsType) == 0) ||
				!matchSourceList(sources, source)) {
				return false;
			}
			for (const auto& root : roots) {
				if (matchList(rootSubstrs, root)) {
					return true;
				}
			}
			return false;
		}


	private:
		static bool match_with_wildcard(const std::string& value, const std::string& rawPattern) {
			std::string pattern;
			std::vector<bool> isEscaped;

			for (size_t i = 0; i < rawPattern.size(); ++i) {
				if (rawPattern[i] == '\\' && i + 1 < rawPattern.size()) {
					++i;
					pattern += rawPattern[i];
					isEscaped.push_back(true);
				} else {
					pattern += rawPattern[i];
					isEscaped.push_back(false);
				}
			}

			bool startsWithWildcard = !pattern.empty() && pattern.front() == '*' && !isEscaped[0];
			bool endsWithWildcard = !pattern.empty() &&
									pattern.back() == '*' &&
									!isEscaped[pattern.size() - 1];

			if (startsWithWildcard && endsWithWildcard && pattern.size() > 2) {
				return value.find(pattern.substr(1, pattern.size() - 2)) != std::string::npos;
			} else if (startsWithWildcard) {
				std::string suffix = pattern.substr(1);
				return value.size() >= suffix.size() &&
					   value.compare(value.size() - suffix.size(), suffix.size(), suffix) == 0;
			} else if (endsWithWildcard) {
				std::string prefix = pattern.substr(0, pattern.size() - 1);
				return value.compare(0, prefix.size(), prefix) == 0;
			} else {
				return value == pattern;
			}
		}

		static bool match_source_pattern(const std::string& value, const std::string& rawPattern) {
			std::string pattern;
			std::vector<bool> isEscaped;

			for (size_t i = 0; i < rawPattern.size(); ++i) {
				if (rawPattern[i] == '\\' && i + 1 < rawPattern.size()) {
					++i;
					pattern += rawPattern[i];
					isEscaped.push_back(true);
				} else {
					pattern += rawPattern[i];
					isEscaped.push_back(false);
				}
			}

			bool startsWithWildcard = !pattern.empty() && pattern.front() == '*' && !isEscaped[0];
			bool endsWithWildcard = !pattern.empty() &&
									pattern.back() == '*' &&
									!isEscaped[pattern.size() - 1];

			if (startsWithWildcard && endsWithWildcard && pattern.size() > 2) {
				return value.find(pattern.substr(1, pattern.size() - 2)) != std::string::npos;
			} else if (startsWithWildcard) {
				std::string suffix = pattern.substr(1);
				return value.size() >= suffix.size() &&
					   value.compare(value.size() - suffix.size(), suffix.size(), suffix) == 0;
			} else if (endsWithWildcard) {
				std::string prefix = pattern.substr(0, pattern.size() - 1);
				return value.compare(0, prefix.size(), prefix) == 0;
			} else {
				return value == pattern;
			}
		}

		static bool matchList(const std::vector<std::string>& patterns, const std::string& value) {
			if (patterns.empty()) return true;
			return std::any_of(patterns.begin(), patterns.end(),
							   [&](const std::string& p) { return match_with_wildcard(value, p); });
		}

		static bool matchSourceList(const std::vector<std::string>& patterns, const std::string& value) {
			if (patterns.empty()) return true;
			return std::any_of(patterns.begin(), patterns.end(),
							   [&](const std::string& p) { return match_source_pattern(value, p); });
		}
	};

	// Not necessary anymore
	struct MountEntry {
		std::string root;
		std::string mountPoint;
		std::string fsType;
		std::string mountSource;
	};

	// Used previously for testing its effectiveness
	static MountEntry parseMountinfo(const std::string& line) {
		std::istringstream iss(line);
		std::vector<std::string> tokens;
		std::string token;

		while (iss >> token) tokens.push_back(token);

		auto sep = std::find(tokens.begin(), tokens.end(), "-");
		if (sep == tokens.end() || std::distance(tokens.begin(), sep) < 6) {
			LOGE("[MountRuleParser::parseMultipleRules]: Malformed mountinfo line");
			return {};
		}

		MountEntry entry;
		entry.root = tokens[3];
		entry.mountPoint = tokens[4];
		entry.fsType = *(sep + 1);
		entry.mountSource = *(sep + 2);
		return entry;
	}

	static MountRule parseRuleString(const std::string& ruleText) {
		if (!validateSyntax(ruleText)) {
			return {};
		}

		MountRule rule;
		auto tokens = tokenizePreserveQuotes(ruleText);

		enum Section { NONE, ROOT, POINT, FILESYSTEM, SOURCE } current = NONE;
		enum State { WRITING, IDLE } state = IDLE;

		for (std::string& word : tokens) {
			if (state == IDLE) {
				if (current == NONE) {
					if (word == "root") current = ROOT;
					else if (word == "point") current = POINT;
					else if (word == "fs") current = FILESYSTEM;
					else if (word == "source") current = SOURCE;
				} else if (word == "{") {
					state = WRITING;
				}
			} else if (state == WRITING && word == "}") {
				current = NONE;
				state = IDLE;
			} else {
				if ((word.front() == '"' && word.back() == '"') ||
					(word.front() == '\'' && word.back() == '\'')) {
					word = word.substr(1, word.size() - 2);
				}

				switch (current) {
					case ROOT:
						rule.rootSubstrs.push_back(word);
						break;
					case POINT:
						rule.mountPointSubstrs.push_back(word);
						break;
					case FILESYSTEM:
						rule.fsTypes.insert(word);
						break;
					case SOURCE:
						rule.sources.push_back(word); // changed from insert() to push_back()
						break;
					default:
						break;
				}
			}
		}

		return rule;
	}

	static std::vector<MountRule> parseMultipleRules(const std::vector<std::string>& ruleTexts) {
		std::vector<MountRule> rules;
		for (const auto& text : ruleTexts) {
			MountRule rule = parseRuleString(text);
			if (rule) {
				rules.push_back(rule);
			} else {
				LOGE("[MountRuleParser::parseMultipleRules]: Failed to parse rule: `%s`", text.c_str());
			}
		}
		return rules;
	}

private:
	static bool validateSyntax(const std::string& text) {
		int braceCount = 0;
		bool inDoubleQuotes = false, inSingleQuotes = false;

		for (size_t i = 0; i < text.size(); ++i) {
			char ch = text[i];
			if (ch == '"' && !inSingleQuotes && (i == 0 || text[i - 1] != '\\'))
				inDoubleQuotes = !inDoubleQuotes;
			else if (ch == '\'' && !inDoubleQuotes && (i == 0 || text[i - 1] != '\\'))
				inSingleQuotes = !inSingleQuotes;

			if (!inDoubleQuotes && !inSingleQuotes) {
				if (ch == '{') ++braceCount;
				else if (ch == '}') {
					--braceCount;
					if (braceCount < 0) return false;
				}
			}
		}

		return braceCount == 0 && !inDoubleQuotes && !inSingleQuotes;
	}

	static std::vector<std::string> tokenizePreserveQuotes(const std::string& text) {
		std::vector<std::string> tokens;
		std::string current;
		bool inQuotes = false;
		char quoteChar = '\0';

		for (size_t i = 0; i < text.length(); ++i) {
			char c = text[i];

			if ((c == '"' || c == '\'') && (i == 0 || text[i - 1] != '\\')) {
				if (!inQuotes) {
					inQuotes = true;
					quoteChar = c;
					current += c;
				} else if (c == quoteChar) {
					inQuotes = false;
					current += c;
					tokens.push_back(current);
					current.clear();
				} else {
					current += c;
				}
			} else if (std::isspace(c) && !inQuotes) {
				if (!current.empty()) {
					tokens.push_back(current);
					current.clear();
				}
			} else {
				current += c;
			}
		}

		if (!current.empty()) tokens.push_back(current);
		return tokens;
	}
};

```

`module/src/main/cpp/PropertyManager.cpp`:

```cpp
#include "PropertyManager.h"
#include <fstream>
#include <sstream>
#include <utility>
#include "log.h"

PropertyManager::PropertyManager(std::string path) : filePath(std::move(path)) {
	loadFromFile();
}

bool PropertyManager::loadFromFile() {
	orderedProps.clear();
	keyIndex.clear();

	std::ifstream file(filePath);
	if (!file.is_open()) {
		LOGW("PropertyManager: Could not open %s for loading.", filePath.c_str());
		return false;
	}

	std::string line;
	while (std::getline(file, line)) {
		if (line.empty() || line[0] == '#')
			continue;

		auto pos = line.find('=');
		if (pos == std::string::npos)
			continue;

		std::string key = line.substr(0, pos);
		std::string val = line.substr(pos + 1);

		size_t idx = orderedProps.size();
		orderedProps.emplace_back(key, val);
		keyIndex[key] = idx;
	}

	file.close();
	return true;
}

bool PropertyManager::saveToFile() {
	std::ofstream file(filePath, std::ios::trunc);
	if (!file.is_open()) {
		LOGE("PropertyManager: Could not open %s for saving.", filePath.c_str());
		return false;
	}

	for (const auto& [key, value] : orderedProps) {
		file << key << "=" << value << '\n';
	}

	file.close();
	return true;
}

std::string PropertyManager::getProp(const std::string& key, const std::string& defaultValue) {
	auto it = keyIndex.find(key);
	return it != keyIndex.end() ? orderedProps[it->second].second : defaultValue;
}

void PropertyManager::setProp(const std::string& key, const std::string& value) {
	auto it = keyIndex.find(key);
	if (it != keyIndex.end()) {
		// Update existing
		orderedProps[it->second].second = value;
	} else {
		// Append new
		size_t idx = orderedProps.size();
		orderedProps.emplace_back(key, value);
		keyIndex[key] = idx;
	}

	saveToFile();
}

/* Optional implementations if needed later
bool PropertyManager::hasProp(const std::string& key) const {
    return props.count(key);
}

void PropertyManager::removeProp(const std::string& key) {
    props.erase(key);
    saveToFile();
}
*/

```

`module/src/main/cpp/PropertyManager.h`:

```h
#ifndef NOHELLO_PROPERTYMANAGER_H
#define NOHELLO_PROPERTYMANAGER_H

#include <string>
#include <unordered_map>
#include <vector>

class PropertyManager {
public:
	explicit PropertyManager(std::string  path);

	std::string getProp(const std::string& key, const std::string& defaultValue = "");
	void setProp(const std::string& key, const std::string& value);
  // bool hasProp(const std::string& key) const;
  // void removeProp(const std::string& key);

private:
	std::string filePath;

	// Maintain insertion order
	std::vector<std::pair<std::string, std::string>> orderedProps;

	// Fast lookup: key -> index in orderedProps
	std::unordered_map<std::string, size_t> keyIndex;

	bool loadFromFile();
	bool saveToFile();
};

#endif //NOHELLO_PROPERTYMANAGER_H

```

`module/src/main/cpp/external/CMakeLists.txt`:

```txt
project(external)

# cxx
set(LIBCXX_SOURCES
        algorithm.cpp
        #        any.cpp
        atomic.cpp
        barrier.cpp
        #        bind.cpp
        charconv.cpp
        chrono.cpp
        condition_variable.cpp
        condition_variable_destructor.cpp
        #        debug.cpp
        exception.cpp
                filesystem/directory_iterator.cpp
                filesystem/int128_builtins.cpp
                filesystem/operations.cpp
        functional.cpp
        future.cpp
        hash.cpp
                ios.cpp
                ios.instantiations.cpp
                iostream.cpp
                locale.cpp
        memory.cpp
        mutex.cpp
        mutex_destructor.cpp
        new.cpp
        optional.cpp
        random.cpp
        #        regex.cpp
        #        ryu/d2fixed.cpp
        #        ryu/d2s.cpp
        #        ryu/f2s.cpp
        shared_mutex.cpp
        stdexcept.cpp
        string.cpp
        #        strstream.cpp
        system_error.cpp
        thread.cpp
        #        typeinfo.cpp
        utility.cpp
        valarray.cpp
        variant.cpp
        vector.cpp
)

list(TRANSFORM LIBCXX_SOURCES PREPEND libcxx/src/)

set(LIBCXX_EXPORT_FLAGS
        -DLIBCXX_BUILDING_LIBCXXABI
        -D_LIBCPP_NO_EXCEPTIONS
        -D_LIBCPP_NO_RTTI
        -D_LIBCPP_BUILDING_LIBRARY
        -D_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS
        -D_LIBCXXABI_NO_EXCEPTIONS
        #-D_LIBCPP_HAS_NO_LOCALIZATION
)
set(LIBCXX_FLAGS
        -fvisibility-global-new-delete-hidden
        -fvisibility=hidden
        -fvisibility-inlines-hidden
)
set(LIBCXX_EXPORT_INCLUDES libcxx/include)
set(LIBCXX_INCLUDES libcxx/src)

set(LIBCXXABI_SOURCES
        abort_message.cpp
        cxa_aux_runtime.cpp
        cxa_default_handlers.cpp
        cxa_exception_storage.cpp
        cxa_guard.cpp
        cxa_handlers.cpp
        cxa_noexception.cpp
        cxa_thread_atexit.cpp
        cxa_vector.cpp
        cxa_virtual.cpp
        stdlib_exception.cpp
        stdlib_new_delete.cpp
        stdlib_stdexcept.cpp
        stdlib_typeinfo.cpp
)
list(TRANSFORM LIBCXXABI_SOURCES PREPEND libcxx/src/abi/)
set(LIBCXXABI_FLAGS
        -Wno-macro-redefined
        -Wno-unknown-attributes
        -DHAS_THREAD_LOCAL)
set(LIBCXXABI_INCLUDES libcxx/include/abi)

add_library(cxx STATIC ${LIBCXX_SOURCES} ${LIBCXXABI_SOURCES})
target_compile_options(cxx PUBLIC ${LIBCXX_EXPORT_FLAGS})
target_compile_options(cxx PRIVATE ${LIBCXX_FLAGS} ${LIBCXXABI_FLAGS} -ffunction-sections -fdata-sections)
target_include_directories(cxx PUBLIC ${LIBCXX_EXPORT_INCLUDES})
target_include_directories(cxx PRIVATE ${LIBCXX_INCLUDES} ${LIBCXXABI_INCLUDES})
# end cxx
```

`module/src/main/cpp/external/android_filesystem_config.h`:

```h
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * This file is consumed by build/tools/fs_config and is used
 * for generating various files. Anything #define AID_<name>
 * becomes the mapping for getpwnam/getpwuid, etc. The <name>
 * field is lowercased.
 * For example:
 * #define AID_FOO_BAR 6666 becomes a friendly name of "foo_bar"
 *
 * The above holds true with the exception of:
 *   mediacodec
 *   mediaex
 *   mediadrm
 * Whose friendly names do not match the #define statements.
 *
 * This file must only be used for platform (Google managed, and submitted through AOSP), AIDs.  3rd
 * party AIDs must be added via config.fs, which will place them in the corresponding partition's
 * passwd and group files.  There are ranges in this file reserved for AIDs for each 3rd party
 * partition, from which the system reads passwd and group files.
 */
#pragma once
/* This is the main Users and Groups config for the platform.
 * DO NOT EVER RENUMBER
 */
#define AID_ROOT 0 /* traditional unix root user */
/* The following are for tests like LTP and should only be used for testing. */
#define AID_DAEMON 1 /* Traditional unix daemon owner. */
#define AID_BIN 2    /* Traditional unix binaries owner. */
#define AID_SYS 3    /* A group with the same gid on Linux/macOS/Android. */
#define AID_SYSTEM 1000 /* system server */
#define AID_RADIO 1001           /* telephony subsystem, RIL */
#define AID_BLUETOOTH 1002       /* bluetooth subsystem */
#define AID_GRAPHICS 1003        /* graphics devices */
#define AID_INPUT 1004           /* input devices */
#define AID_AUDIO 1005           /* audio devices */
#define AID_CAMERA 1006          /* camera devices */
#define AID_LOG 1007             /* log devices */
#define AID_COMPASS 1008         /* compass device */
#define AID_MOUNT 1009           /* mountd socket */
#define AID_WIFI 1010            /* wifi subsystem */
#define AID_ADB 1011             /* android debug bridge (adbd) */
#define AID_INSTALL 1012         /* group for installing packages */
#define AID_MEDIA 1013           /* mediaserver process */
#define AID_DHCP 1014            /* dhcp client */
#define AID_SDCARD_RW 1015       /* external storage write access */
#define AID_VPN 1016             /* vpn system */
#define AID_KEYSTORE 1017        /* keystore subsystem */
#define AID_USB 1018             /* USB devices */
#define AID_DRM 1019             /* DRM server */
#define AID_MDNSR 1020           /* MulticastDNSResponder (service discovery) */
#define AID_GPS 1021             /* GPS daemon */
#define AID_UNUSED1 1022         /* deprecated, DO NOT USE */
#define AID_MEDIA_RW 1023        /* internal media storage write access */
#define AID_MTP 1024             /* MTP USB driver access */
#define AID_UNUSED2 1025         /* deprecated, DO NOT USE */
#define AID_DRMRPC 1026          /* group for drm rpc */
#define AID_NFC 1027             /* nfc subsystem */
#define AID_SDCARD_R 1028        /* external storage read access */
#define AID_CLAT 1029            /* clat part of nat464 */
#define AID_LOOP_RADIO 1030      /* loop radio devices */
#define AID_MEDIA_DRM 1031       /* MediaDrm plugins */
#define AID_PACKAGE_INFO 1032    /* access to installed package details */
#define AID_SDCARD_PICS 1033     /* external storage photos access */
#define AID_SDCARD_AV 1034       /* external storage audio/video access */
#define AID_SDCARD_ALL 1035      /* access all users external storage */
#define AID_LOGD 1036            /* log daemon */
#define AID_SHARED_RELRO 1037    /* creator of shared GNU RELRO files */
#define AID_DBUS 1038            /* dbus-daemon IPC broker process */
#define AID_TLSDATE 1039         /* tlsdate unprivileged user */
#define AID_MEDIA_EX 1040        /* mediaextractor process */
#define AID_AUDIOSERVER 1041     /* audioserver process */
#define AID_METRICS_COLL 1042    /* metrics_collector process */
#define AID_METRICSD 1043        /* metricsd process */
#define AID_WEBSERV 1044         /* webservd process */
#define AID_DEBUGGERD 1045       /* debuggerd unprivileged user */
#define AID_MEDIA_CODEC 1046     /* mediacodec process */
#define AID_CAMERASERVER 1047    /* cameraserver process */
#define AID_FIREWALL 1048        /* firewalld process */
#define AID_TRUNKS 1049          /* trunksd process (TPM daemon) */
#define AID_NVRAM 1050           /* Access-controlled NVRAM */
#define AID_DNS 1051             /* DNS resolution daemon (system: netd) */
#define AID_DNS_TETHER 1052      /* DNS resolution daemon (tether: dnsmasq) */
#define AID_WEBVIEW_ZYGOTE 1053  /* WebView zygote process */
#define AID_VEHICLE_NETWORK 1054 /* Vehicle network service */
#define AID_MEDIA_AUDIO 1055     /* GID for audio files on internal media storage */
#define AID_MEDIA_VIDEO 1056     /* GID for video files on internal media storage */
#define AID_MEDIA_IMAGE 1057     /* GID for image files on internal media storage */
#define AID_TOMBSTONED 1058      /* tombstoned user */
#define AID_MEDIA_OBB 1059       /* GID for OBB files on internal media storage */
#define AID_ESE 1060             /* embedded secure element (eSE) subsystem */
#define AID_OTA_UPDATE 1061      /* resource tracking UID for OTA updates */
#define AID_AUTOMOTIVE_EVS 1062  /* Automotive rear and surround view system */
#define AID_LOWPAN 1063          /* LoWPAN subsystem */
#define AID_HSM 1064             /* hardware security module subsystem */
#define AID_RESERVED_DISK 1065   /* GID that has access to reserved disk space */
#define AID_STATSD 1066          /* statsd daemon */
#define AID_INCIDENTD 1067       /* incidentd daemon */
#define AID_SECURE_ELEMENT 1068  /* secure element subsystem */
#define AID_LMKD 1069            /* low memory killer daemon */
#define AID_LLKD 1070            /* live lock daemon */
#define AID_IORAPD 1071          /* input/output readahead and pin daemon */
#define AID_GPU_SERVICE 1072     /* GPU service daemon */
#define AID_NETWORK_STACK 1073   /* network stack service */
#define AID_GSID 1074            /* GSI service daemon */
#define AID_FSVERITY_CERT 1075   /* fs-verity key ownership in keystore */
#define AID_CREDSTORE 1076       /* identity credential manager service */
#define AID_EXTERNAL_STORAGE 1077 /* Full external storage access including USB OTG volumes */
#define AID_EXT_DATA_RW 1078      /* GID for app-private data directories on external storage */
#define AID_EXT_OBB_RW 1079       /* GID for OBB directories on external storage */
#define AID_CONTEXT_HUB 1080      /* GID for access to the Context Hub */
#define AID_VIRTUALIZATIONSERVICE 1081 /* VirtualizationService daemon */
#define AID_ARTD 1082             /* ART Service daemon */
#define AID_UWB 1083              /* UWB subsystem */
#define AID_THREAD_NETWORK 1084   /* Thread Network subsystem */
#define AID_DICED 1085            /* Android's DICE daemon */
#define AID_DMESGD 1086           /* dmesg parsing daemon for kernel report collection */
#define AID_JC_WEAVER 1087        /* Javacard Weaver HAL - to manage omapi ARA rules */
#define AID_JC_STRONGBOX 1088     /* Javacard Strongbox HAL - to manage omapi ARA rules */
#define AID_JC_IDENTITYCRED 1089  /* Javacard Identity Cred HAL - to manage omapi ARA rules */
#define AID_SDK_SANDBOX 1090      /* SDK sandbox virtual UID */
#define AID_SECURITY_LOG_WRITER 1091 /* write to security log */
#define AID_PRNG_SEEDER 1092         /* PRNG seeder daemon */
/* Changes to this file must be made in AOSP, *not* in internal branches. */
#define AID_SHELL 2000 /* adb and debug shell user */
#define AID_CACHE 2001 /* cache access */
#define AID_DIAG 2002  /* access to diagnostic resources */
/* The range 2900-2999 is reserved for the vendor partition */
/* Note that the two 'OEM' ranges pre-dated the vendor partition, so they take the legacy 'OEM'
 * name. Additionally, they pre-dated passwd/group files, so there are users and groups named oem_#
 * created automatically for all values in these ranges.  If there is a user/group in a passwd/group
 * file corresponding to this range, both the oem_# and user/group names will resolve to the same
 * value. */
#define AID_OEM_RESERVED_START 2900
#define AID_OEM_RESERVED_END 2999
/* The 3000 series are intended for use as supplemental group id's only.
 * They indicate special Android capabilities that the kernel is aware of. */
#define AID_NET_BT_ADMIN 3001 /* bluetooth: create any socket */
#define AID_NET_BT 3002       /* bluetooth: create sco, rfcomm or l2cap sockets */
#define AID_INET 3003         /* can create AF_INET and AF_INET6 sockets */
#define AID_NET_RAW 3004      /* can create raw INET sockets */
#define AID_NET_ADMIN 3005    /* can configure interfaces and routing tables. */
#define AID_NET_BW_STATS 3006 /* read bandwidth statistics */
#define AID_NET_BW_ACCT 3007  /* change bandwidth statistics accounting */
#define AID_READPROC 3009     /* Allow /proc read access */
#define AID_WAKELOCK 3010     /* Allow system wakelock read/write access */
#define AID_UHID 3011         /* Allow read/write to /dev/uhid node */
#define AID_READTRACEFS 3012  /* Allow tracefs read */
/* The range 5000-5999 is also reserved for vendor partition. */
#define AID_OEM_RESERVED_2_START 5000
#define AID_OEM_RESERVED_2_END 5999
/* The range 6000-6499 is reserved for the system partition. */
#define AID_SYSTEM_RESERVED_START 6000
#define AID_SYSTEM_RESERVED_END 6499
/* The range 6500-6999 is reserved for the odm partition. */
#define AID_ODM_RESERVED_START 6500
#define AID_ODM_RESERVED_END 6999
/* The range 7000-7499 is reserved for the product partition. */
#define AID_PRODUCT_RESERVED_START 7000
#define AID_PRODUCT_RESERVED_END 7499
/* The range 7500-7999 is reserved for the system_ext partition. */
#define AID_SYSTEM_EXT_RESERVED_START 7500
#define AID_SYSTEM_EXT_RESERVED_END 7999
#define AID_EVERYBODY 9997 /* shared between all apps in the same profile */
#define AID_MISC 9998      /* access to misc storage */
#define AID_NOBODY 9999
#define AID_APP 10000       /* TODO: switch users over to AID_APP_START */
#define AID_APP_START 10000 /* first app user */
#define AID_APP_END 19999   /* last app user */
#define AID_CACHE_GID_START 20000 /* start of gids for apps to mark cached data */
#define AID_CACHE_GID_END 29999   /* end of gids for apps to mark cached data */
#define AID_EXT_GID_START 30000 /* start of gids for apps to mark external data */
#define AID_EXT_GID_END 39999   /* end of gids for apps to mark external data */
#define AID_EXT_CACHE_GID_START 40000 /* start of gids for apps to mark external cached data */
#define AID_EXT_CACHE_GID_END 49999   /* end of gids for apps to mark external cached data */
#define AID_SHARED_GID_START 50000 /* start of gids for apps in each user to share */
#define AID_SHARED_GID_END 59999   /* end of gids for apps in each user to share */
/*
 * This is a magic number in the kernel and not something that was picked
 * arbitrarily. This value is returned whenever a uid that has no mapping in the
 * user namespace is returned to userspace:
 * https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/highuid.h?h=v4.4#n40
 */
#define AID_OVERFLOWUID 65534 /* unmapped user in the user namespace */
/* use the ranges below to determine whether a process is sdk sandbox */
#define AID_SDK_SANDBOX_PROCESS_START 20000 /* start of uids allocated to sdk sandbox processes */
#define AID_SDK_SANDBOX_PROCESS_END 29999   /* end of uids allocated to sdk sandbox processes */
/* use the ranges below to determine whether a process is isolated */
#define AID_ISOLATED_START 90000 /* start of uids for fully isolated sandboxed processes */
#define AID_ISOLATED_END 99999   /* end of uids for fully isolated sandboxed processes */
#define AID_USER 100000        /* TODO: switch users over to AID_USER_OFFSET */
#define AID_USER_OFFSET 100000 /* offset for uid ranges for each user */
/*
 * android_ids has moved to pwd/grp functionality.
 * If you need to add one, the structure is now
 * auto-generated based on the AID_ constraints
 * documented at the top of this header file.
 * Also see build/tools/fs_config for more details.
 */
```

`module/src/main/cpp/external/emoji.h`:

```h

#include <map>
#include <string>

namespace emoji {

	static std::map<std::string, std::string> EMOJIS = {
			{":admission_tickets:" , "\U0001F39F"},
			{":aerial_tramway:" , "\U0001F6A1"},
			{":airplane:" , "\U00002708"},
			{":airplane_arriving:" , "\U0001F6EC"},
			{":airplane_departure:" , "\U0001F6EB"},
			{":alarm_clock:" , "\U000023F0"},
			{":alembic:" , "\U00002697"},
			{":space_invader:" , "\U0001F47E"},
			{":ambulance:" , "\U0001F691"},
			{":football:" , "\U0001F3C8"},
			{":amphora:" , "\U0001F3FA"},
			{":anchor:" , "\U00002693"},
			{":anger:" , "\U0001F4A2"},
			{":angry:" , "\U0001F620"},
			{":anguished:" , "\U0001F627"},
			{":ant:" , "\U0001F41C"},
			{":signal_strength:" , "\U0001F4F6"},
			{":arrows_counterclockwise:" , "\U0001F504"},
			{":aquarius:" , "\U00002652"},
			{":aries:" , "\U00002648"},
			{":arrow_heading_down:" , "\U00002935"},
			{":arrow_heading_up:" , "\U00002934"},
			{":articulated_lorry:" , "\U0001F69B"},
			{":art:" , "\U0001F3A8"},
			{":astonished:" , "\U0001F632"},
			{":athletic_shoe:" , "\U0001F45F"},
			{":atom_symbol:" , "\U0000269B"},
			{":eggplant:" , "\U0001F346"},
			{":atm:" , "\U0001F3E7"},
			{":car:" , "\U0001F697"},
			{":red_car:" , "\U0001F697"},
			{":baby:" , "\U0001F476"},
			{":angel:" , "\U0001F47C"},
			{":baby_bottle:" , "\U0001F37C"},
			{":baby_chick:" , "\U0001F424"},
			{":baby_symbol:" , "\U0001F6BC"},
			{":back:" , "\U0001F519"},
			{":camel:" , "\U0001F42B"},
			{":badminton_racquet_and_shuttlecock:" , "\U0001F3F8"},
			{":baggage_claim:" , "\U0001F6C4"},
			{":balloon:" , "\U0001F388"},
			{":ballot_box_with_ballot:" , "\U0001F5F3"},
			{":ballot_box_with_check:" , "\U00002611"},
			{":banana:" , "\U0001F34C"},
			{":bank:" , "\U0001F3E6"},
			{":dollar:" , "\U0001F4B5"},
			{":euro:" , "\U0001F4B6"},
			{":pound:" , "\U0001F4B7"},
			{":yen:" , "\U0001F4B4"},
			{":bar_chart:" , "\U0001F4CA"},
			{":barber:" , "\U0001F488"},
			{":baseball:" , "\U000026BE"},
			{":basketball:" , "\U0001F3C0"},
			{":bath:" , "\U0001F6C0"},
			{":bathtub:" , "\U0001F6C1"},
			{":battery:" , "\U0001F50B"},
			{":beach_with_umbrella:" , "\U0001F3D6"},
			{":bear:" , "\U0001F43B"},
			{":heartbeat:" , "\U0001F493"},
			{":bed:" , "\U0001F6CF"},
			{":beer:" , "\U0001F37A"},
			{":bell:" , "\U0001F514"},
			{":no_bell:" , "\U0001F515"},
			{":bellhop_bell:" , "\U0001F6CE"},
			{":bento:" , "\U0001F371"},
			{":bike:" , "\U0001F6B2"},
			{":bicyclist:" , "\U0001F6B4"},
			{":bikini:" , "\U0001F459"},
			{":8ball:" , "\U0001F3B1"},
			{":biohazard_sign:" , "\U00002623"},
			{":bird:" , "\U0001F426"},
			{":birthday:" , "\U0001F382"},
			{":black_circle_for_record:" , "\U000023FA"},
			{":clubs:" , "\U00002663"},
			{":diamonds:" , "\U00002666"},
			{":arrow_double_down:" , "\U000023EC"},
			{":hearts:" , "\U00002665"},
			{":black_large_square:" , "\U00002B1B"},
			{":rewind:" , "\U000023EA"},
			{":black_left__pointing_double_triangle_with_vertical_bar:" , "\U000023EE"},
			{":arrow_backward:" , "\U000025C0"},
			{":black_medium_small_square:" , "\U000025FE"},
			{":black_medium_square:" , "\U000025FC"},
			{":black_nib:" , "\U00002712"},
			{":question:" , "\U00002753"},
			{":fast_forward:" , "\U000023E9"},
			{":black_right__pointing_double_triangle_with_vertical_bar:" , "\U000023ED"},
			{":arrow_forward:" , "\U000025B6"},
			{":black_right__pointing_triangle_with_double_vertical_bar:" , "\U000023EF"},
			{":arrow_right:" , "\U000027A1"},
			{":scissors:" , "\U00002702"},
			{":black_small_square:" , "\U000025AA"},
			{":spades:" , "\U00002660"},
			{":black_square_button:" , "\U0001F532"},
			{":black_square_for_stop:" , "\U000023F9"},
			{":sunny:" , "\U00002600"},
			{":phone:" , "\U0000260E"},
			{":telephone:" , "\U0000260E"},
			{":recycle:" , "\U0000267B"},
			{":arrow_double_up:" , "\U000023EB"},
			{":blossom:" , "\U0001F33C"},
			{":blowfish:" , "\U0001F421"},
			{":blue_book:" , "\U0001F4D8"},
			{":blue_heart:" , "\U0001F499"},
			{":boar:" , "\U0001F417"},
			{":bomb:" , "\U0001F4A3"},
			{":bookmark:" , "\U0001F516"},
			{":bookmark_tabs:" , "\U0001F4D1"},
			{":books:" , "\U0001F4DA"},
			{":bottle_with_popping_cork:" , "\U0001F37E"},
			{":bouquet:" , "\U0001F490"},
			{":bow_and_arrow:" , "\U0001F3F9"},
			{":bowling:" , "\U0001F3B3"},
			{":boy:" , "\U0001F466"},
			{":bread:" , "\U0001F35E"},
			{":bride_with_veil:" , "\U0001F470"},
			{":bridge_at_night:" , "\U0001F309"},
			{":briefcase:" , "\U0001F4BC"},
			{":broken_heart:" , "\U0001F494"},
			{":bug:" , "\U0001F41B"},
			{":building_construction:" , "\U0001F3D7"},
			{":burrito:" , "\U0001F32F"},
			{":bus:" , "\U0001F68C"},
			{":busstop:" , "\U0001F68F"},
			{":bust_in_silhouette:" , "\U0001F464"},
			{":busts_in_silhouette:" , "\U0001F465"},
			{":cactus:" , "\U0001F335"},
			{":date:" , "\U0001F4C5"},
			{":camera:" , "\U0001F4F7"},
			{":camera_with_flash:" , "\U0001F4F8"},
			{":camping:" , "\U0001F3D5"},
			{":cancer:" , "\U0000264B"},
			{":candle:" , "\U0001F56F"},
			{":candy:" , "\U0001F36C"},
			{":capricorn:" , "\U00002651"},
			{":card_file_box:" , "\U0001F5C3"},
			{":card_index:" , "\U0001F4C7"},
			{":card_index_dividers:" , "\U0001F5C2"},
			{":carousel_horse:" , "\U0001F3A0"},
			{":flags:" , "\U0001F38F"},
			{":flag_for_sri_lanka:" , "\U0001F1F1\U0001F1F0"},
			{":flag_for_india:", "\U0001F1EE\U0001F1F3"},
			{":cat2:" , "\U0001F408"},
			{":cat:" , "\U0001F431"},
			{":joy_cat:" , "\U0001F639"},
			{":smirk_cat:" , "\U0001F63C"},
			{":chains:" , "\U000026D3"},
			{":chart_with_downwards_trend:" , "\U0001F4C9"},
			{":chart_with_upwards_trend:" , "\U0001F4C8"},
			{":chart:" , "\U0001F4B9"},
			{":mega:" , "\U0001F4E3"},
			{":cheese_wedge:" , "\U0001F9C0"},
			{":checkered_flag:" , "\U0001F3C1"},
			{":cherries:" , "\U0001F352"},
			{":cherry_blossom:" , "\U0001F338"},
			{":chestnut:" , "\U0001F330"},
			{":chicken:" , "\U0001F414"},
			{":children_crossing:" , "\U0001F6B8"},
			{":chipmunk:" , "\U0001F43F"},
			{":chocolate_bar:" , "\U0001F36B"},
			{":christmas_tree:" , "\U0001F384"},
			{":church:" , "\U000026EA"},
			{":cinema:" , "\U0001F3A6"},
			{":accept:" , "\U0001F251"},
			{":ideograph_advantage:" , "\U0001F250"},
			{":congratulations:" , "\U00003297"},
			{":secret:" , "\U00003299"},
			{":m:" , "\U000024C2"},
			{":circus_tent:" , "\U0001F3AA"},
			{":cityscape:" , "\U0001F3D9"},
			{":city_sunset:" , "\U0001F306"},
			{":clapper:" , "\U0001F3AC"},
			{":clap:" , "\U0001F44F"},
			{":classical_building:" , "\U0001F3DB"},
			{":beers:" , "\U0001F37B"},
			{":clipboard:" , "\U0001F4CB"},
			{":clock830:" , "\U0001F563"},
			{":clock8:" , "\U0001F557"},
			{":clock1130:" , "\U0001F566"},
			{":clock11:" , "\U0001F55A"},
			{":clock530:" , "\U0001F560"},
			{":clock5:" , "\U0001F554"},
			{":clock430:" , "\U0001F55F"},
			{":clock4:" , "\U0001F553"},
			{":clock930:" , "\U0001F564"},
			{":clock9:" , "\U0001F558"},
			{":clock130:" , "\U0001F55C"},
			{":clock1:" , "\U0001F550"},
			{":clock730:" , "\U0001F562"},
			{":clock7:" , "\U0001F556"},
			{":clock630:" , "\U0001F561"},
			{":clock6:" , "\U0001F555"},
			{":clock1030:" , "\U0001F565"},
			{":clock10:" , "\U0001F559"},
			{":clock330:" , "\U0001F55E"},
			{":clock3:" , "\U0001F552"},
			{":clock1230:" , "\U0001F567"},
			{":clock12:" , "\U0001F55B"},
			{":clock230:" , "\U0001F55D"},
			{":clock2:" , "\U0001F551"},
			{":arrows_clockwise:" , "\U0001F503"},
			{":repeat:" , "\U0001F501"},
			{":repeat_one:" , "\U0001F502"},
			{":closed_book:" , "\U0001F4D5"},
			{":closed_lock_with_key:" , "\U0001F510"},
			{":mailbox_closed:" , "\U0001F4EA"},
			{":mailbox:" , "\U0001F4EB"},
			{":closed_umbrella:" , "\U0001F302"},
			{":cloud:" , "\U00002601"},
			{":cloud_with_lightning:" , "\U0001F329"},
			{":cloud_with_rain:" , "\U0001F327"},
			{":cloud_with_snow:" , "\U0001F328"},
			{":cloud_with_tornado:" , "\U0001F32A"},
			{":cocktail:" , "\U0001F378"},
			{":coffin:" , "\U000026B0"},
			{":boom:" , "\U0001F4A5"},
			{":collision:" , "\U0001F4A5"},
			{":comet:" , "\U00002604"},
			{":compression:" , "\U0001F5DC"},
			{":confetti_ball:" , "\U0001F38A"},
			{":confounded:" , "\U0001F616"},
			{":confused:" , "\U0001F615"},
			{":construction:" , "\U0001F6A7"},
			{":construction_worker:" , "\U0001F477"},
			{":control_knobs:" , "\U0001F39B"},
			{":convenience_store:" , "\U0001F3EA"},
			{":rice:" , "\U0001F35A"},
			{":cookie:" , "\U0001F36A"},
			{":egg:" , "\U0001F373"},
			{":copyright:" , "\U000000A9"},
			{":couch_and_lamp:" , "\U0001F6CB"},
			{":couple_with_heart:" , "\U0001F491"},
			{":cow2:" , "\U0001F404"},
			{":cow:" , "\U0001F42E"},
			{":crab:" , "\U0001F980"},
			{":credit_card:" , "\U0001F4B3"},
			{":crescent_moon:" , "\U0001F319"},
			{":cricket_bat_and_ball:" , "\U0001F3CF"},
			{":crocodile:" , "\U0001F40A"},
			{":x:" , "\U0000274C"},
			{":crossed_flags:" , "\U0001F38C"},
			{":crossed_swords:" , "\U00002694"},
			{":crown:" , "\U0001F451"},
			{":crying_cat_face:" , "\U0001F63F"},
			{":cry:" , "\U0001F622"},
			{":crystal_ball:" , "\U0001F52E"},
			{":curly_loop:" , "\U000027B0"},
			{":currency_exchange:" , "\U0001F4B1"},
			{":curry:" , "\U0001F35B"},
			{":custard:" , "\U0001F36E"},
			{":customs:" , "\U0001F6C3"},
			{":cyclone:" , "\U0001F300"},
			{":dagger_knife:" , "\U0001F5E1"},
			{":dancer:" , "\U0001F483"},
			{":dango:" , "\U0001F361"},
			{":dark_sunglasses:" , "\U0001F576"},
			{":dash:" , "\U0001F4A8"},
			{":deciduous_tree:" , "\U0001F333"},
			{":truck:" , "\U0001F69A"},
			{":department_store:" , "\U0001F3EC"},
			{":derelict_house_building:" , "\U0001F3DA"},
			{":desert:" , "\U0001F3DC"},
			{":desert_island:" , "\U0001F3DD"},
			{":desktop_computer:" , "\U0001F5A5"},
			{":diamond_shape_with_a_dot_inside:" , "\U0001F4A0"},
			{":dart:" , "\U0001F3AF"},
			{":disappointed_relieved:" , "\U0001F625"},
			{":disappointed:" , "\U0001F61E"},
			{":dizzy_face:" , "\U0001F635"},
			{":dizzy:" , "\U0001F4AB"},
			{":do_not_litter:" , "\U0001F6AF"},
			{":dog2:" , "\U0001F415"},
			{":dog:" , "\U0001F436"},
			{":dolphin:" , "\U0001F42C"},
			{":flipper:" , "\U0001F42C"},
			{":door:" , "\U0001F6AA"},
			{":loop:" , "\U000027BF"},
			{":bangbang:" , "\U0000203C"},
			{":double_vertical_bar:" , "\U000023F8"},
			{":doughnut:" , "\U0001F369"},
			{":dove_of_peace:" , "\U0001F54A"},
			{":small_red_triangle_down:" , "\U0001F53B"},
			{":arrow_down_small:" , "\U0001F53D"},
			{":arrow_down:" , "\U00002B07"},
			{":dragon:" , "\U0001F409"},
			{":dragon_face:" , "\U0001F432"},
			{":dress:" , "\U0001F457"},
			{":dromedary_camel:" , "\U0001F42A"},
			{":droplet:" , "\U0001F4A7"},
			{":dvd:" , "\U0001F4C0"},
			{":e__mail:" , "\U0001F4E7"},
			{":ear:" , "\U0001F442"},
			{":corn:" , "\U0001F33D"},
			{":ear_of_rice:" , "\U0001F33E"},
			{":earth_americas:" , "\U0001F30E"},
			{":earth_asia:" , "\U0001F30F"},
			{":earth_africa:" , "\U0001F30D"},
			{":eight_pointed_black_star:" , "\U00002734"},
			{":eight_spoked_asterisk:" , "\U00002733"},
			{":eject_symbol:" , "\U000023CF"},
			{":bulb:" , "\U0001F4A1"},
			{":electric_plug:" , "\U0001F50C"},
			{":flashlight:" , "\U0001F526"},
			{":elephant:" , "\U0001F418"},
			{":emoji_modifier_fitzpatrick_type__1__2:" , "\U0001F3FB"},
			{":emoji_modifier_fitzpatrick_type__3:" , "\U0001F3FC"},
			{":emoji_modifier_fitzpatrick_type__4:" , "\U0001F3FD"},
			{":emoji_modifier_fitzpatrick_type__5:" , "\U0001F3FE"},
			{":emoji_modifier_fitzpatrick_type__6:" , "\U0001F3FF"},
			{":end:" , "\U0001F51A"},
			{":email:" , "\U00002709"},
			{":envelope:" , "\U00002709"},
			{":envelope_with_arrow:" , "\U0001F4E9"},
			{":european_castle:" , "\U0001F3F0"},
			{":european_post_office:" , "\U0001F3E4"},
			{":evergreen_tree:" , "\U0001F332"},
			{":interrobang:" , "\U00002049"},
			{":expressionless:" , "\U0001F611"},
			{":alien:" , "\U0001F47D"},
			{":eye:" , "\U0001F441"},
			{":eyeglasses:" , "\U0001F453"},
			{":eyes:" , "\U0001F440"},
			{":massage:" , "\U0001F486"},
			{":yum:" , "\U0001F60B"},
			{":scream:" , "\U0001F631"},
			{":kissing_heart:" , "\U0001F618"},
			{":sweat:" , "\U0001F613"},
			{":face_with_head__bandage:" , "\U0001F915"},
			{":triumph:" , "\U0001F624"},
			{":mask:" , "\U0001F637"},
			{":no_good:" , "\U0001F645"},
			{":ok_woman:" , "\U0001F646"},
			{":open_mouth:" , "\U0001F62E"},
			{":cold_sweat:" , "\U0001F630"},
			{":face_with_rolling_eyes:" , "\U0001F644"},
			{":stuck_out_tongue:" , "\U0001F61B"},
			{":stuck_out_tongue_closed_eyes:" , "\U0001F61D"},
			{":stuck_out_tongue_winking_eye:" , "\U0001F61C"},
			{":joy:" , "\U0001F602"},
			{":face_with_thermometer:" , "\U0001F912"},
			{":no_mouth:" , "\U0001F636"},
			{":factory:" , "\U0001F3ED"},
			{":fallen_leaf:" , "\U0001F342"},
			{":family:" , "\U0001F46A"},
			{":santa:" , "\U0001F385"},
			{":fax:" , "\U0001F4E0"},
			{":fearful:" , "\U0001F628"},
			{":ferris_wheel:" , "\U0001F3A1"},
			{":ferry:" , "\U000026F4"},
			{":field_hockey_stick_and_ball:" , "\U0001F3D1"},
			{":file_cabinet:" , "\U0001F5C4"},
			{":file_folder:" , "\U0001F4C1"},
			{":film_frames:" , "\U0001F39E"},
			{":film_projector:" , "\U0001F4FD"},
			{":fire:" , "\U0001F525"},
			{":fire_engine:" , "\U0001F692"},
			{":sparkler:" , "\U0001F387"},
			{":fireworks:" , "\U0001F386"},
			{":first_quarter_moon:" , "\U0001F313"},
			{":first_quarter_moon_with_face:" , "\U0001F31B"},
			{":fish:" , "\U0001F41F"},
			{":fish_cake:" , "\U0001F365"},
			{":fishing_pole_and_fish:" , "\U0001F3A3"},
			{":facepunch:" , "\U0001F44A"},
			{":punch:" , "\U0001F44A"},
			{":golf:" , "\U000026F3"},
			{":fleur__de__lis:" , "\U0000269C"},
			{":muscle:" , "\U0001F4AA"},
			{":floppy_disk:" , "\U0001F4BE"},
			{":flower_playing_cards:" , "\U0001F3B4"},
			{":flushed:" , "\U0001F633"},
			{":fog:" , "\U0001F32B"},
			{":foggy:" , "\U0001F301"},
			{":footprints:" , "\U0001F463"},
			{":fork_and_knife:" , "\U0001F374"},
			{":fork_and_knife_with_plate:" , "\U0001F37D"},
			{":fountain:" , "\U000026F2"},
			{":four_leaf_clover:" , "\U0001F340"},
			{":frame_with_picture:" , "\U0001F5BC"},
			{":fries:" , "\U0001F35F"},
			{":fried_shrimp:" , "\U0001F364"},
			{":frog:" , "\U0001F438"},
			{":hatched_chick:" , "\U0001F425"},
			{":frowning:" , "\U0001F626"},
			{":fuelpump:" , "\U000026FD"},
			{":full_moon:" , "\U0001F315"},
			{":full_moon_with_face:" , "\U0001F31D"},
			{":funeral_urn:" , "\U000026B1"},
			{":game_die:" , "\U0001F3B2"},
			{":gear:" , "\U00002699"},
			{":gem:" , "\U0001F48E"},
			{":gemini:" , "\U0000264A"},
			{":ghost:" , "\U0001F47B"},
			{":girl:" , "\U0001F467"},
			{":globe_with_meridians:" , "\U0001F310"},
			{":star2:" , "\U0001F31F"},
			{":goat:" , "\U0001F410"},
			{":golfer:" , "\U0001F3CC"},
			{":mortar_board:" , "\U0001F393"},
			{":grapes:" , "\U0001F347"},
			{":green_apple:" , "\U0001F34F"},
			{":green_book:" , "\U0001F4D7"},
			{":green_heart:" , "\U0001F49A"},
			{":grimacing:" , "\U0001F62C"},
			{":smile_cat:" , "\U0001F638"},
			{":grinning:" , "\U0001F600"},
			{":grin:" , "\U0001F601"},
			{":heartpulse:" , "\U0001F497"},
			{":guardsman:" , "\U0001F482"},
			{":guitar:" , "\U0001F3B8"},
			{":haircut:" , "\U0001F487"},
			{":hamburger:" , "\U0001F354"},
			{":hammer:" , "\U0001F528"},
			{":hammer_and_pick:" , "\U00002692"},
			{":hammer_and_wrench:" , "\U0001F6E0"},
			{":hamster:" , "\U0001F439"},
			{":handbag:" , "\U0001F45C"},
			{":raising_hand:" , "\U0001F64B"},
			{":hatching_chick:" , "\U0001F423"},
			{":headphones:" , "\U0001F3A7"},
			{":hear_no_evil:" , "\U0001F649"},
			{":heart_decoration:" , "\U0001F49F"},
			{":cupid:" , "\U0001F498"},
			{":gift_heart:" , "\U0001F49D"},
			{":heart:" , "\U00002764"},
			{":heavy_check_mark:" , "\U00002714"},
			{":heavy_division_sign:" , "\U00002797"},
			{":heavy_dollar_sign:" , "\U0001F4B2"},
			{":exclamation:" , "\U00002757"},
			{":heavy_exclamation_mark:" , "\U00002757"},
			{":heavy_heart_exclamation_mark_ornament:" , "\U00002763"},
			{":o:" , "\U00002B55"},
			{":heavy_minus_sign:" , "\U00002796"},
			{":heavy_multiplication_x:" , "\U00002716"},
			{":heavy_plus_sign:" , "\U00002795"},
			{":helicopter:" , "\U0001F681"},
			{":helm_symbol:" , "\U00002388"},
			{":helmet_with_white_cross:" , "\U000026D1"},
			{":herb:" , "\U0001F33F"},
			{":hibiscus:" , "\U0001F33A"},
			{":high_heel:" , "\U0001F460"},
			{":bullettrain_side:" , "\U0001F684"},
			{":bullettrain_front:" , "\U0001F685"},
			{":high_brightness:" , "\U0001F506"},
			{":zap:" , "\U000026A1"},
			{":hocho:" , "\U0001F52A"},
			{":knife:" , "\U0001F52A"},
			{":hole:" , "\U0001F573"},
			{":honey_pot:" , "\U0001F36F"},
			{":bee:" , "\U0001F41D"},
			{":traffic_light:" , "\U0001F6A5"},
			{":racehorse:" , "\U0001F40E"},
			{":horse:" , "\U0001F434"},
			{":horse_racing:" , "\U0001F3C7"},
			{":hospital:" , "\U0001F3E5"},
			{":coffee:" , "\U00002615"},
			{":hot_dog:" , "\U0001F32D"},
			{":hot_pepper:" , "\U0001F336"},
			{":hotsprings:" , "\U00002668"},
			{":hotel:" , "\U0001F3E8"},
			{":hourglass:" , "\U0000231B"},
			{":hourglass_flowing_sand:" , "\U000023F3"},
			{":house:" , "\U0001F3E0"},
			{":house_buildings:" , "\U0001F3D8"},
			{":house_with_garden:" , "\U0001F3E1"},
			{":hugging_face:" , "\U0001F917"},
			{":100:" , "\U0001F4AF"},
			{":hushed:" , "\U0001F62F"},
			{":ice_cream:" , "\U0001F368"},
			{":ice_hockey_stick_and_puck:" , "\U0001F3D2"},
			{":ice_skate:" , "\U000026F8"},
			{":imp:" , "\U0001F47F"},
			{":inbox_tray:" , "\U0001F4E5"},
			{":incoming_envelope:" , "\U0001F4E8"},
			{":information_desk_person:" , "\U0001F481"},
			{":information_source:" , "\U00002139"},
			{":capital_abcd:" , "\U0001F520"},
			{":abc:" , "\U0001F524"},
			{":abcd:" , "\U0001F521"},
			{":1234:" , "\U0001F522"},
			{":symbols:" , "\U0001F523"},
			{":izakaya_lantern:" , "\U0001F3EE"},
			{":lantern:" , "\U0001F3EE"},
			{":jack_o_lantern:" , "\U0001F383"},
			{":japanese_castle:" , "\U0001F3EF"},
			{":dolls:" , "\U0001F38E"},
			{":japanese_goblin:" , "\U0001F47A"},
			{":japanese_ogre:" , "\U0001F479"},
			{":post_office:" , "\U0001F3E3"},
			{":beginner:" , "\U0001F530"},
			{":jeans:" , "\U0001F456"},
			{":joystick:" , "\U0001F579"},
			{":kaaba:" , "\U0001F54B"},
			{":key:" , "\U0001F511"},
			{":keyboard:" , "\U00002328"},
			{":keycap_asterisk:" , "\U0000002A\U000020E3"},
			{":keycap_digit_eight:" , "\U00000038\U000020E3"},
			{":keycap_digit_five:" , "\U00000035\U000020E3"},
			{":keycap_digit_four:" , "\U00000034\U000020E3"},
			{":keycap_digit_nine:" , "\U00000039\U000020E3"},
			{":keycap_digit_one:" , "\U00000031\U000020E3"},
			{":keycap_digit_seven:" , "\U00000037\U000020E3"},
			{":keycap_digit_six:" , "\U00000036\U000020E3"},
			{":keycap_digit_three:" , "\U00000033\U000020E3"},
			{":keycap_digit_two:" , "\U00000032\U000020E3"},
			{":keycap_digit_zero:" , "\U00000030\U000020E3"},
			{":keycap_number_sign:" , "\U00000023\U000020E3"},
			{":keycap_ten:" , "\U0001F51F"},
			{":kimono:" , "\U0001F458"},
			{":couplekiss:" , "\U0001F48F"},
			{":kiss:" , "\U0001F48B"},
			{":kissing_cat:" , "\U0001F63D"},
			{":kissing:" , "\U0001F617"},
			{":kissing_closed_eyes:" , "\U0001F61A"},
			{":kissing_smiling_eyes:" , "\U0001F619"},
			{":koala:" , "\U0001F428"},
			{":label:" , "\U0001F3F7"},
			{":beetle:" , "\U0001F41E"},
			{":large_blue_circle:" , "\U0001F535"},
			{":large_blue_diamond:" , "\U0001F537"},
			{":large_orange_diamond:" , "\U0001F536"},
			{":red_circle:" , "\U0001F534"},
			{":last_quarter_moon:" , "\U0001F317"},
			{":last_quarter_moon_with_face:" , "\U0001F31C"},
			{":latin_cross:" , "\U0000271D"},
			{":leaves:" , "\U0001F343"},
			{":ledger:" , "\U0001F4D2"},
			{":mag:" , "\U0001F50D"},
			{":left_luggage:" , "\U0001F6C5"},
			{":left_right_arrow:" , "\U00002194"},
			{":leftwards_arrow_with_hook:" , "\U000021A9"},
			{":arrow_left:" , "\U00002B05"},
			{":lemon:" , "\U0001F34B"},
			{":leo:" , "\U0000264C"},
			{":leopard:" , "\U0001F406"},
			{":level_slider:" , "\U0001F39A"},
			{":libra:" , "\U0000264E"},
			{":light_rail:" , "\U0001F688"},
			{":link:" , "\U0001F517"},
			{":linked_paperclips:" , "\U0001F587"},
			{":lion_face:" , "\U0001F981"},
			{":lipstick:" , "\U0001F484"},
			{":lock:" , "\U0001F512"},
			{":lock_with_ink_pen:" , "\U0001F50F"},
			{":lollipop:" , "\U0001F36D"},
			{":sob:" , "\U0001F62D"},
			{":love_hotel:" , "\U0001F3E9"},
			{":love_letter:" , "\U0001F48C"},
			{":low_brightness:" , "\U0001F505"},
			{":lower_left_ballpoint_pen:" , "\U0001F58A"},
			{":lower_left_crayon:" , "\U0001F58D"},
			{":lower_left_fountain_pen:" , "\U0001F58B"},
			{":lower_left_paintbrush:" , "\U0001F58C"},
			{":mahjong:" , "\U0001F004"},
			{":man:" , "\U0001F468"},
			{":couple:" , "\U0001F46B"},
			{":man_in_business_suit_levitating:" , "\U0001F574"},
			{":man_with_gua_pi_mao:" , "\U0001F472"},
			{":man_with_turban:" , "\U0001F473"},
			{":mans_shoe:" , "\U0001F45E"},
			{":shoe:" , "\U0001F45E"},
			{":mantelpiece_clock:" , "\U0001F570"},
			{":maple_leaf:" , "\U0001F341"},
			{":meat_on_bone:" , "\U0001F356"},
			{":black_circle:" , "\U000026AB"},
			{":white_circle:" , "\U000026AA"},
			{":melon:" , "\U0001F348"},
			{":memo:" , "\U0001F4DD"},
			{":pencil:" , "\U0001F4DD"},
			{":menorah_with_nine_branches:" , "\U0001F54E"},
			{":mens:" , "\U0001F6B9"},
			{":metro:" , "\U0001F687"},
			{":microphone:" , "\U0001F3A4"},
			{":microscope:" , "\U0001F52C"},
			{":military_medal:" , "\U0001F396"},
			{":milky_way:" , "\U0001F30C"},
			{":minibus:" , "\U0001F690"},
			{":minidisc:" , "\U0001F4BD"},
			{":iphone:" , "\U0001F4F1"},
			{":mobile_phone_off:" , "\U0001F4F4"},
			{":calling:" , "\U0001F4F2"},
			{":money__mouth_face:" , "\U0001F911"},
			{":moneybag:" , "\U0001F4B0"},
			{":money_with_wings:" , "\U0001F4B8"},
			{":monkey:" , "\U0001F412"},
			{":monkey_face:" , "\U0001F435"},
			{":monorail:" , "\U0001F69D"},
			{":rice_scene:" , "\U0001F391"},
			{":mosque:" , "\U0001F54C"},
			{":motor_boat:" , "\U0001F6E5"},
			{":motorway:" , "\U0001F6E3"},
			{":mount_fuji:" , "\U0001F5FB"},
			{":mountain:" , "\U000026F0"},
			{":mountain_bicyclist:" , "\U0001F6B5"},
			{":mountain_cableway:" , "\U0001F6A0"},
			{":mountain_railway:" , "\U0001F69E"},
			{":mouse2:" , "\U0001F401"},
			{":mouse:" , "\U0001F42D"},
			{":lips:" , "\U0001F444"},
			{":movie_camera:" , "\U0001F3A5"},
			{":moyai:" , "\U0001F5FF"},
			{":notes:" , "\U0001F3B6"},
			{":mushroom:" , "\U0001F344"},
			{":musical_keyboard:" , "\U0001F3B9"},
			{":musical_note:" , "\U0001F3B5"},
			{":musical_score:" , "\U0001F3BC"},
			{":nail_care:" , "\U0001F485"},
			{":name_badge:" , "\U0001F4DB"},
			{":national_park:" , "\U0001F3DE"},
			{":necktie:" , "\U0001F454"},
			{":ab:" , "\U0001F18E"},
			{":negative_squared_cross_mark:" , "\U0000274E"},
			{":a:" , "\U0001F170"},
			{":b:" , "\U0001F171"},
			{":o2:" , "\U0001F17E"},
			{":parking:" , "\U0001F17F"},
			{":nerd_face:" , "\U0001F913"},
			{":neutral_face:" , "\U0001F610"},
			{":new_moon:" , "\U0001F311"},
			{":honeybee:" , "\U0001F41D"},
			{":new_moon_with_face:" , "\U0001F31A"},
			{":newspaper:" , "\U0001F4F0"},
			{":night_with_stars:" , "\U0001F303"},
			{":no_bicycles:" , "\U0001F6B3"},
			{":no_entry:" , "\U000026D4"},
			{":no_entry_sign:" , "\U0001F6AB"},
			{":no_mobile_phones:" , "\U0001F4F5"},
			{":underage:" , "\U0001F51E"},
			{":no_pedestrians:" , "\U0001F6B7"},
			{":no_smoking:" , "\U0001F6AD"},
			{":non__potable_water:" , "\U0001F6B1"},
			{":arrow_upper_right:" , "\U00002197"},
			{":arrow_upper_left:" , "\U00002196"},
			{":nose:" , "\U0001F443"},
			{":notebook:" , "\U0001F4D3"},
			{":notebook_with_decorative_cover:" , "\U0001F4D4"},
			{":nut_and_bolt:" , "\U0001F529"},
			{":octopus:" , "\U0001F419"},
			{":oden:" , "\U0001F362"},
			{":office:" , "\U0001F3E2"},
			{":oil_drum:" , "\U0001F6E2"},
			{":ok_hand:" , "\U0001F44C"},
			{":old_key:" , "\U0001F5DD"},
			{":older_man:" , "\U0001F474"},
			{":older_woman:" , "\U0001F475"},
			{":om_symbol:" , "\U0001F549"},
			{":on:" , "\U0001F51B"},
			{":oncoming_automobile:" , "\U0001F698"},
			{":oncoming_bus:" , "\U0001F68D"},
			{":oncoming_police_car:" , "\U0001F694"},
			{":oncoming_taxi:" , "\U0001F696"},
			{":book:" , "\U0001F4D6"},
			{":open_book:" , "\U0001F4D6"},
			{":open_file_folder:" , "\U0001F4C2"},
			{":open_hands:" , "\U0001F450"},
			{":unlock:" , "\U0001F513"},
			{":mailbox_with_no_mail:" , "\U0001F4ED"},
			{":mailbox_with_mail:" , "\U0001F4EC"},
			{":ophiuchus:" , "\U000026CE"},
			{":cd:" , "\U0001F4BF"},
			{":orange_book:" , "\U0001F4D9"},
			{":orthodox_cross:" , "\U00002626"},
			{":outbox_tray:" , "\U0001F4E4"},
			{":ox:" , "\U0001F402"},
			{":package:" , "\U0001F4E6"},
			{":page_facing_up:" , "\U0001F4C4"},
			{":page_with_curl:" , "\U0001F4C3"},
			{":pager:" , "\U0001F4DF"},
			{":palm_tree:" , "\U0001F334"},
			{":panda_face:" , "\U0001F43C"},
			{":paperclip:" , "\U0001F4CE"},
			{":part_alternation_mark:" , "\U0000303D"},
			{":tada:" , "\U0001F389"},
			{":passenger_ship:" , "\U0001F6F3"},
			{":passport_control:" , "\U0001F6C2"},
			{":feet:" , "\U0001F43E"},
			{":paw_prints:" , "\U0001F43E"},
			{":peace_symbol:" , "\U0000262E"},
			{":peach:" , "\U0001F351"},
			{":pear:" , "\U0001F350"},
			{":walking:" , "\U0001F6B6"},
			{":pencil2:" , "\U0000270F"},
			{":penguin:" , "\U0001F427"},
			{":pensive:" , "\U0001F614"},
			{":performing_arts:" , "\U0001F3AD"},
			{":persevere:" , "\U0001F623"},
			{":bow:" , "\U0001F647"},
			{":person_frowning:" , "\U0001F64D"},
			{":raised_hands:" , "\U0001F64C"},
			{":person_with_ball:" , "\U000026F9"},
			{":person_with_blond_hair:" , "\U0001F471"},
			{":pray:" , "\U0001F64F"},
			{":computer:" , "\U0001F4BB"},
			{":pick:" , "\U000026CF"},
			{":pig2:" , "\U0001F416"},
			{":pig:" , "\U0001F437"},
			{":pig_nose:" , "\U0001F43D"},
			{":hankey:" , "\U0001F4A9"},
			{":poop:" , "\U0001F4A9"},
			{":shit:" , "\U0001F4A9"},
			{":pill:" , "\U0001F48A"},
			{":bamboo:" , "\U0001F38D"},
			{":pineapple:" , "\U0001F34D"},
			{":pisces:" , "\U00002653"},
			{":gun:" , "\U0001F52B"},
			{":place_of_worship:" , "\U0001F6D0"},
			{":black_joker:" , "\U0001F0CF"},
			{":police_car:" , "\U0001F693"},
			{":rotating_light:" , "\U0001F6A8"},
			{":cop:" , "\U0001F46E"},
			{":poodle:" , "\U0001F429"},
			{":popcorn:" , "\U0001F37F"},
			{":postal_horn:" , "\U0001F4EF"},
			{":postbox:" , "\U0001F4EE"},
			{":stew:" , "\U0001F372"},
			{":potable_water:" , "\U0001F6B0"},
			{":pouch:" , "\U0001F45D"},
			{":poultry_leg:" , "\U0001F357"},
			{":pouting_cat:" , "\U0001F63E"},
			{":rage:" , "\U0001F621"},
			{":prayer_beads:" , "\U0001F4FF"},
			{":princess:" , "\U0001F478"},
			{":printer:" , "\U0001F5A8"},
			{":loudspeaker:" , "\U0001F4E2"},
			{":purple_heart:" , "\U0001F49C"},
			{":purse:" , "\U0001F45B"},
			{":pushpin:" , "\U0001F4CC"},
			{":put_litter_in_its_place:" , "\U0001F6AE"},
			{":rabbit2:" , "\U0001F407"},
			{":rabbit:" , "\U0001F430"},
			{":racing_car:" , "\U0001F3CE"},
			{":racing_motorcycle:" , "\U0001F3CD"},
			{":radio:" , "\U0001F4FB"},
			{":radio_button:" , "\U0001F518"},
			{":radioactive_sign:" , "\U00002622"},
			{":railway_car:" , "\U0001F683"},
			{":railway_track:" , "\U0001F6E4"},
			{":rainbow:" , "\U0001F308"},
			{":fist:" , "\U0000270A"},
			{":hand:" , "\U0000270B"},
			{":raised_hand:" , "\U0000270B"},
			{":raised_hand_with_fingers_splayed:" , "\U0001F590"},
			{":raised_hand_with_part_between_middle_and_ring_fingers:" , "\U0001F596"},
			{":ram:" , "\U0001F40F"},
			{":rat:" , "\U0001F400"},
			{":blue_car:" , "\U0001F699"},
			{":apple:" , "\U0001F34E"},
			{":registered:" , "\U000000AE"},
			{":relieved:" , "\U0001F60C"},
			{":reminder_ribbon:" , "\U0001F397"},
			{":restroom:" , "\U0001F6BB"},
			{":reversed_hand_with_middle_finger_extended:" , "\U0001F595"},
			{":revolving_hearts:" , "\U0001F49E"},
			{":ribbon:" , "\U0001F380"},
			{":rice_ball:" , "\U0001F359"},
			{":rice_cracker:" , "\U0001F358"},
			{":mag_right:" , "\U0001F50E"},
			{":right_anger_bubble:" , "\U0001F5EF"},
			{":arrow_right_hook:" , "\U000021AA"},
			{":ring:" , "\U0001F48D"},
			{":sweet_potato:" , "\U0001F360"},
			{":robot_face:" , "\U0001F916"},
			{":rocket:" , "\U0001F680"},
			{":rolled__up_newspaper:" , "\U0001F5DE"},
			{":roller_coaster:" , "\U0001F3A2"},
			{":rooster:" , "\U0001F413"},
			{":rose:" , "\U0001F339"},
			{":rosette:" , "\U0001F3F5"},
			{":round_pushpin:" , "\U0001F4CD"},
			{":rowboat:" , "\U0001F6A3"},
			{":rugby_football:" , "\U0001F3C9"},
			{":runner:" , "\U0001F3C3"},
			{":running:" , "\U0001F3C3"},
			{":running_shirt_with_sash:" , "\U0001F3BD"},
			{":sagittarius:" , "\U00002650"},
			{":boat:" , "\U000026F5"},
			{":sailboat:" , "\U000026F5"},
			{":sake:" , "\U0001F376"},
			{":satellite:" , "\U0001F4E1"},
			{":saxophone:" , "\U0001F3B7"},
			{":scales:" , "\U00002696"},
			{":school:" , "\U0001F3EB"},
			{":school_satchel:" , "\U0001F392"},
			{":scorpion:" , "\U0001F982"},
			{":scorpius:" , "\U0000264F"},
			{":scroll:" , "\U0001F4DC"},
			{":seat:" , "\U0001F4BA"},
			{":see_no_evil:" , "\U0001F648"},
			{":seedling:" , "\U0001F331"},
			{":shamrock:" , "\U00002618"},
			{":shaved_ice:" , "\U0001F367"},
			{":sheep:" , "\U0001F411"},
			{":shield:" , "\U0001F6E1"},
			{":shinto_shrine:" , "\U000026E9"},
			{":ship:" , "\U0001F6A2"},
			{":stars:" , "\U0001F320"},
			{":shopping_bags:" , "\U0001F6CD"},
			{":cake:" , "\U0001F370"},
			{":shower:" , "\U0001F6BF"},
			{":sign_of_the_horns:" , "\U0001F918"},
			{":japan:" , "\U0001F5FE"},
			{":six_pointed_star:" , "\U0001F52F"},
			{":ski:" , "\U0001F3BF"},
			{":skier:" , "\U000026F7"},
			{":skull:" , "\U0001F480"},
			{":skull_and_crossbones:" , "\U00002620"},
			{":sleeping_accommodation:" , "\U0001F6CC"},
			{":sleeping:" , "\U0001F634"},
			{":zzz:" , "\U0001F4A4"},
			{":sleepy:" , "\U0001F62A"},
			{":sleuth_or_spy:" , "\U0001F575"},
			{":pizza:" , "\U0001F355"},
			{":slightly_frowning_face:" , "\U0001F641"},
			{":slightly_smiling_face:" , "\U0001F642"},
			{":slot_machine:" , "\U0001F3B0"},
			{":small_airplane:" , "\U0001F6E9"},
			{":small_blue_diamond:" , "\U0001F539"},
			{":small_orange_diamond:" , "\U0001F538"},
			{":heart_eyes_cat:" , "\U0001F63B"},
			{":smiley_cat:" , "\U0001F63A"},
			{":innocent:" , "\U0001F607"},
			{":heart_eyes:" , "\U0001F60D"},
			{":smiling_imp:" , "\U0001F608"},
			{":smiley:" , "\U0001F603"},
			{":sweat_smile:" , "\U0001F605"},
			{":smile:" , "\U0001F604"},
			{":laughing:" , "\U0001F606"},
			{":satisfied:" , "\U0001F606"},
			{":blush:" , "\U0001F60A"},
			{":sunglasses:" , "\U0001F60E"},
			{":smirk:" , "\U0001F60F"},
			{":smoking:" , "\U0001F6AC"},
			{":snail:" , "\U0001F40C"},
			{":snake:" , "\U0001F40D"},
			{":snow_capped_mountain:" , "\U0001F3D4"},
			{":snowboarder:" , "\U0001F3C2"},
			{":snowflake:" , "\U00002744"},
			{":snowman:" , "\U00002603"},
			{":soccer:" , "\U000026BD"},
			{":icecream:" , "\U0001F366"},
			{":soon:" , "\U0001F51C"},
			{":arrow_lower_right:" , "\U00002198"},
			{":arrow_lower_left:" , "\U00002199"},
			{":spaghetti:" , "\U0001F35D"},
			{":sparkle:" , "\U00002747"},
			{":sparkles:" , "\U00002728"},
			{":sparkling_heart:" , "\U0001F496"},
			{":speak_no_evil:" , "\U0001F64A"},
			{":speaker:" , "\U0001F508"},
			{":mute:" , "\U0001F507"},
			{":sound:" , "\U0001F509"},
			{":loud_sound:" , "\U0001F50A"},
			{":speaking_head_in_silhouette:" , "\U0001F5E3"},
			{":speech_balloon:" , "\U0001F4AC"},
			{":speedboat:" , "\U0001F6A4"},
			{":spider:" , "\U0001F577"},
			{":spider_web:" , "\U0001F578"},
			{":spiral_calendar_pad:" , "\U0001F5D3"},
			{":spiral_note_pad:" , "\U0001F5D2"},
			{":shell:" , "\U0001F41A"},
			{":sweat_drops:" , "\U0001F4A6"},
			{":sports_medal:" , "\U0001F3C5"},
			{":whale:" , "\U0001F433"},
			{":u5272:" , "\U0001F239"},
			{":u5408:" , "\U0001F234"},
			{":u55b6:" , "\U0001F23A"},
			{":u6307:" , "\U0001F22F"},
			{":u6708:" , "\U0001F237"},
			{":u6709:" , "\U0001F236"},
			{":u6e80:" , "\U0001F235"},
			{":u7121:" , "\U0001F21A"},
			{":u7533:" , "\U0001F238"},
			{":u7981:" , "\U0001F232"},
			{":u7a7a:" , "\U0001F233"},
			{":cl:" , "\U0001F191"},
			{":cool:" , "\U0001F192"},
			{":free:" , "\U0001F193"},
			{":id:" , "\U0001F194"},
			{":koko:" , "\U0001F201"},
			{":sa:" , "\U0001F202"},
			{":new:" , "\U0001F195"},
			{":ng:" , "\U0001F196"},
			{":ok:" , "\U0001F197"},
			{":sos:" , "\U0001F198"},
			{":up:" , "\U0001F199"},
			{":vs:" , "\U0001F19A"},
			{":stadium:" , "\U0001F3DF"},
			{":star_and_crescent:" , "\U0000262A"},
			{":star_of_david:" , "\U00002721"},
			{":station:" , "\U0001F689"},
			{":statue_of_liberty:" , "\U0001F5FD"},
			{":steam_locomotive:" , "\U0001F682"},
			{":ramen:" , "\U0001F35C"},
			{":stopwatch:" , "\U000023F1"},
			{":straight_ruler:" , "\U0001F4CF"},
			{":strawberry:" , "\U0001F353"},
			{":studio_microphone:" , "\U0001F399"},
			{":partly_sunny:" , "\U000026C5"},
			{":sun_with_face:" , "\U0001F31E"},
			{":sunflower:" , "\U0001F33B"},
			{":sunrise:" , "\U0001F305"},
			{":sunrise_over_mountains:" , "\U0001F304"},
			{":city_sunrise:" , "\U0001F307"},
			{":surfer:" , "\U0001F3C4"},
			{":sushi:" , "\U0001F363"},
			{":suspension_railway:" , "\U0001F69F"},
			{":swimmer:" , "\U0001F3CA"},
			{":synagogue:" , "\U0001F54D"},
			{":syringe:" , "\U0001F489"},
			{":shirt:" , "\U0001F455"},
			{":tshirt:" , "\U0001F455"},
			{":table_tennis_paddle_and_ball:" , "\U0001F3D3"},
			{":taco:" , "\U0001F32E"},
			{":tanabata_tree:" , "\U0001F38B"},
			{":tangerine:" , "\U0001F34A"},
			{":taurus:" , "\U00002649"},
			{":taxi:" , "\U0001F695"},
			{":tea:" , "\U0001F375"},
			{":calendar:" , "\U0001F4C6"},
			{":telephone_receiver:" , "\U0001F4DE"},
			{":telescope:" , "\U0001F52D"},
			{":tv:" , "\U0001F4FA"},
			{":tennis:" , "\U0001F3BE"},
			{":tent:" , "\U000026FA"},
			{":thermometer:" , "\U0001F321"},
			{":thinking_face:" , "\U0001F914"},
			{":thought_balloon:" , "\U0001F4AD"},
			{":three_button_mouse:" , "\U0001F5B1"},
			{":+1:" , "\U0001F44D"},
			{":thumbsup:" , "\U0001F44D"},
			{":__1:" , "\U0001F44E"},
			{":-1:" , "\U0001F44E"},
			{":thumbsdown:" , "\U0001F44E"},
			{":thunder_cloud_and_rain:" , "\U000026C8"},
			{":ticket:" , "\U0001F3AB"},
			{":tiger2:" , "\U0001F405"},
			{":tiger:" , "\U0001F42F"},
			{":timer_clock:" , "\U000023F2"},
			{":tired_face:" , "\U0001F62B"},
			{":toilet:" , "\U0001F6BD"},
			{":tokyo_tower:" , "\U0001F5FC"},
			{":tomato:" , "\U0001F345"},
			{":tongue:" , "\U0001F445"},
			{":tophat:" , "\U0001F3A9"},
			{":top:" , "\U0001F51D"},
			{":trackball:" , "\U0001F5B2"},
			{":tractor:" , "\U0001F69C"},
			{":tm:" , "\U00002122"},
			{":train2:" , "\U0001F686"},
			{":tram:" , "\U0001F68A"},
			{":train:" , "\U0001F68B"},
			{":triangular_flag_on_post:" , "\U0001F6A9"},
			{":triangular_ruler:" , "\U0001F4D0"},
			{":trident:" , "\U0001F531"},
			{":trolleybus:" , "\U0001F68E"},
			{":trophy:" , "\U0001F3C6"},
			{":tropical_drink:" , "\U0001F379"},
			{":tropical_fish:" , "\U0001F420"},
			{":trumpet:" , "\U0001F3BA"},
			{":tulip:" , "\U0001F337"},
			{":turkey:" , "\U0001F983"},
			{":turtle:" , "\U0001F422"},
			{":twisted_rightwards_arrows:" , "\U0001F500"},
			{":two_hearts:" , "\U0001F495"},
			{":two_men_holding_hands:" , "\U0001F46C"},
			{":two_women_holding_hands:" , "\U0001F46D"},
			{":umbrella:" , "\U00002602"},
			{":umbrella_on_ground:" , "\U000026F1"},
			{":unamused:" , "\U0001F612"},
			{":unicorn_face:" , "\U0001F984"},
			{":small_red_triangle:" , "\U0001F53A"},
			{":arrow_up_small:" , "\U0001F53C"},
			{":arrow_up_down:" , "\U00002195"},
			{":upside__down_face:" , "\U0001F643"},
			{":arrow_up:" , "\U00002B06"},
			{":vertical_traffic_light:" , "\U0001F6A6"},
			{":vibration_mode:" , "\U0001F4F3"},
			{":v:" , "\U0000270C"},
			{":video_camera:" , "\U0001F4F9"},
			{":video_game:" , "\U0001F3AE"},
			{":vhs:" , "\U0001F4FC"},
			{":violin:" , "\U0001F3BB"},
			{":virgo:" , "\U0000264D"},
			{":volcano:" , "\U0001F30B"},
			{":volleyball:" , "\U0001F3D0"},
			{":waning_crescent_moon:" , "\U0001F318"},
			{":waning_gibbous_moon:" , "\U0001F316"},
			{":warning:" , "\U000026A0"},
			{":wastebasket:" , "\U0001F5D1"},
			{":watch:" , "\U0000231A"},
			{":water_buffalo:" , "\U0001F403"},
			{":wc:" , "\U0001F6BE"},
			{":ocean:" , "\U0001F30A"},
			{":watermelon:" , "\U0001F349"},
			{":waving_black_flag:" , "\U0001F3F4"},
			{":wave:" , "\U0001F44B"},
			{":waving_white_flag:" , "\U0001F3F3"},
			{":wavy_dash:" , "\U00003030"},
			{":waxing_crescent_moon:" , "\U0001F312"},
			{":moon:" , "\U0001F314"},
			{":waxing_gibbous_moon:" , "\U0001F314"},
			{":scream_cat:" , "\U0001F640"},
			{":weary:" , "\U0001F629"},
			{":wedding:" , "\U0001F492"},
			{":weight_lifter:" , "\U0001F3CB"},
			{":whale2:" , "\U0001F40B"},
			{":wheel_of_dharma:" , "\U00002638"},
			{":wheelchair:" , "\U0000267F"},
			{":point_down:" , "\U0001F447"},
			{":grey_exclamation:" , "\U00002755"},
			{":white_flower:" , "\U0001F4AE"},
			{":white_frowning_face:" , "\U00002639"},
			{":white_check_mark:" , "\U00002705"},
			{":white_large_square:" , "\U00002B1C"},
			{":point_left:" , "\U0001F448"},
			{":white_medium_small_square:" , "\U000025FD"},
			{":white_medium_square:" , "\U000025FB"},
			{":star:" , "\U00002B50"},
			{":grey_question:" , "\U00002754"},
			{":point_right:" , "\U0001F449"},
			{":white_small_square:" , "\U000025AB"},
			{":relaxed:" , "\U0000263A"},
			{":white_square_button:" , "\U0001F533"},
			{":white_sun_behind_cloud:" , "\U0001F325"},
			{":white_sun_behind_cloud_with_rain:" , "\U0001F326"},
			{":white_sun_with_small_cloud:" , "\U0001F324"},
			{":point_up_2:" , "\U0001F446"},
			{":point_up:" , "\U0000261D"},
			{":wind_blowing_face:" , "\U0001F32C"},
			{":wind_chime:" , "\U0001F390"},
			{":wine_glass:" , "\U0001F377"},
			{":wink:" , "\U0001F609"},
			{":wolf:" , "\U0001F43A"},
			{":woman:" , "\U0001F469"},
			{":dancers:" , "\U0001F46F"},
			{":boot:" , "\U0001F462"},
			{":womans_clothes:" , "\U0001F45A"},
			{":womans_hat:" , "\U0001F452"},
			{":sandal:" , "\U0001F461"},
			{":womens:" , "\U0001F6BA"},
			{":world_map:" , "\U0001F5FA"},
			{":worried:" , "\U0001F61F"},
			{":gift:" , "\U0001F381"},
			{":wrench:" , "\U0001F527"},
			{":writing_hand:" , "\U0000270D"},
			{":yellow_heart:" , "\U0001F49B"},
			{":yin_yang:" , "\U0000262F"},
			{":zipper__mouth_face:" , "\U0001F910"}
	};

	std::string emojize(std::string s, bool escape=true) {
		int index = -1;
		int sLen = s.size();
		for (int i = 0; i < sLen; i++) {
			if (s[i] == *L":") {
				// check if colon is escaped
				if(escape && i!=0 && s[i-1]=='\\')
					continue;
				if (index == -1) {
					index = i;
				}
				else {
					if (i - index==1) {
						index = i;
						continue;
					}
					std::map<std::string, std::string>::iterator it;
					it = EMOJIS.find(s.substr(index, i - index + 1));
					if (it == EMOJIS.end()) {
						index = i;
						continue;
					}
					std::string emo = it->second;
					// replace from index to i
					//std::cout << s.substr(index, i - index + 1) << std::endl; // <---- uncomment to see what text is replaced, might be good for debugging
					s.replace(index, i - index + 1 , emo);
					int goBack = i - index + 1 - emo.size();
					sLen -= goBack;
					i -= goBack;
					index = -1;
				}
			}
		}
		return s;
	}
}

```

`module/src/main/cpp/external/fdutils/fd_utils.cpp`:

```cpp
/*
 * This file includes modifications derived from The Android Open Source Project,
 * which is licensed under the Apache License, Version 2.0 (the "License").
 * These modifications are provided under the same License terms as the original work.
 *
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "fd_utils.h"
#include <algorithm>
#include <utility>
#include <fcntl.h>
#include <grp.h>
#include <cstdlib>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/un.h>
#include <unistd.h>
#include <cerrno> // For errno
#include <cstring> // For strerror
#include "stringprintf.cpp"
#include "../../../log.h" // For LOGD

static const char kFdPath[] = "/proc/self/fd";


namespace android::base {
	static bool Readlink(const std::string& path, std::string* result) {
		result->clear();
		// Most Linux file systems (ext2 and ext4, say) limit symbolic links to
		// 4095 bytes. Since we'll copy out into the string anyway, it doesn't
		// waste memory to just start there. We add 1 so that we can recognize
		// whether it actually fit (rather than being truncated to 4095).
		std::vector<char> buf(4095 + 1);
		while (true) {
			ssize_t size = readlink(path.c_str(), &buf[0], buf.size());
			// Unrecoverable error?
			if (size == -1) return false;
			// It fit! (If size == buf.size(), it may have been truncated.)
			if (static_cast<size_t>(size) < buf.size()) {
				result->assign(&buf[0], size);
				return true;
			}
			// Double our buffer and try again.
			buf.resize(buf.size() * 2);
		}
	}
} // namespace android::base


std::unique_ptr<FileDescriptorInfo> FileDescriptorInfo::CreateFromFd(int fd, fail_fn_t fail_fn) {
	struct stat f_stat;
	// This should never happen; the zygote should always have the right set
	// of permissions required to stat all its open files.
	if (TEMP_FAILURE_RETRY(fstat(fd, &f_stat)) == -1) {
		fail_fn(android::base::StringPrintf("Unable to stat %d: %s", fd, strerror(errno)));
		return {};
	}
	if (S_ISSOCK(f_stat.st_mode)) {
		return std::unique_ptr<FileDescriptorInfo>(new FileDescriptorInfo(fd));
	}
	// We only handle allowlisted regular files and character devices. Allowlisted
	// character devices must provide a guarantee of sensible behaviour when
	// reopened.
	//
	// S_ISDIR : Not supported. (We could if we wanted to, but it's unused).
	// S_ISLINK : Not supported.
	// S_ISBLK : Not supported.
	// S_ISFIFO : Not supported. Note that the Zygote and USAPs use pipes to
	// communicate with the child processes across forks but those should have been
	// added to the redirection exemption list.
	if (!S_ISCHR(f_stat.st_mode) && !S_ISREG(f_stat.st_mode)) {
		std::string mode = "Unknown";
		if (S_ISDIR(f_stat.st_mode)) {
			mode = "DIR";
		} else if (S_ISLNK(f_stat.st_mode)) {
			mode = "LINK";
		} else if (S_ISBLK(f_stat.st_mode)) {
			mode = "BLOCK";
		} else if (S_ISFIFO(f_stat.st_mode)) {
			mode = "FIFO";
		}
		fail_fn(android::base::StringPrintf("Unsupported st_mode for FD %d:  %d(%s)", fd, f_stat.st_mode, mode.c_str()));
		return {};
	}
	std::string file_path;
	const std::string fd_path = android::base::StringPrintf("/proc/self/fd/%d", fd);
	if (!android::base::Readlink(fd_path, &file_path)) {
		fail_fn(android::base::StringPrintf("Could not read fd link %s: %s",
											fd_path.c_str(),
											strerror(errno)));
		return {};
	}
	// File descriptor flags : currently on FD_CLOEXEC. We can set these
	// using F_SETFD - we're single threaded at this point of execution so
	// there won't be any races.
	const int fd_flags = TEMP_FAILURE_RETRY(fcntl(fd, F_GETFD));
	if (fd_flags == -1) {
		fail_fn(android::base::StringPrintf("Failed fcntl(%d, F_GETFD) (%s): %s",
											fd,
											file_path.c_str(),
											strerror(errno)));
		return {};
	}
	// File status flags :
	// - File access mode : (O_RDONLY, O_WRONLY...) we'll pass these through
	//   to the open() call.
	//
	// - File creation flags : (O_CREAT, O_EXCL...) - there's not much we can
	//   do about these, since the file has already been created. We shall ignore
	//   them here.
	//
	// - Other flags : We'll have to set these via F_SETFL. On linux, F_SETFL
	//   can only set O_APPEND, O_ASYNC, O_DIRECT, O_NOATIME, and O_NONBLOCK.
	//   In particular, it can't set O_SYNC and O_DSYNC. We'll have to test for
	//   their presence and pass them in to open().
	int fs_flags = TEMP_FAILURE_RETRY(fcntl(fd, F_GETFL));
	if (fs_flags == -1) {
		fail_fn(android::base::StringPrintf("Failed fcntl(%d, F_GETFL) (%s): %s",
											fd,
											file_path.c_str(),
											strerror(errno)));
		return {};
	}
	// File offset : Ignore the offset for non seekable files.
	const off_t offset = TEMP_FAILURE_RETRY(lseek64(fd, 0, SEEK_CUR));
	// We pass the flags that open accepts to open, and use F_SETFL for
	// the rest of them.
	static const int kOpenFlags = (O_RDONLY | O_WRONLY | O_RDWR | O_DSYNC | O_SYNC);
	int open_flags = fs_flags & (kOpenFlags);
	fs_flags = fs_flags & (~(kOpenFlags));
	return std::unique_ptr<FileDescriptorInfo>(
			new FileDescriptorInfo(f_stat, file_path, fd, open_flags, fd_flags, fs_flags, offset));
}

bool FileDescriptorInfo::RefersToSameFile() const {
	struct stat f_stat;
	if (TEMP_FAILURE_RETRY(fstat(fd, &f_stat)) == -1) {
		return false;
	}
	return f_stat.st_ino == stat.st_ino && f_stat.st_dev == stat.st_dev;
}

void FileDescriptorInfo::Detach(fail_fn_t fail_fn) const {
    const int dev_null_fd = TEMP_FAILURE_RETRY(open("/dev/null", O_RDWR | O_CLOEXEC));
    if (dev_null_fd < 0) {
        fail_fn(android::base::StringPrintf("Failed to open /dev/null: %s", strerror(errno)));
        return;
    }

    if (TEMP_FAILURE_RETRY(dup3(dev_null_fd, fd, O_CLOEXEC)) == -1) {
        fail_fn(android::base::StringPrintf("Failed dup3 on descriptor %d to /dev/null: %s",
                                            fd,
                                            strerror(errno)));
        // close(dev_null_fd) should still be attempted
    }

    if (TEMP_FAILURE_RETRY(close(dev_null_fd)) == -1) {
        fail_fn(android::base::StringPrintf("Failed close(/dev/null temp fd %d): %s", dev_null_fd, strerror(errno)));
    }
}

void FileDescriptorInfo::ReopenOrDetach(fail_fn_t fail_fn, bool prefer_detach_to_dev_null) const {
    if (is_sock) {
        // Sockets are always "detached" by replacing their FD with /dev/null.
        LOGD("Detaching socket FD %d to /dev/null", fd);
        return Detach(fail_fn);
    }

    // For non-sockets:
    if (prefer_detach_to_dev_null) {
        LOGD("Detaching non-socket FD %d (path: %s) to /dev/null due to preference.", fd, file_path.c_str());
        return Detach(fail_fn);
    }

    // Original logic for reopening regular files if not detaching.
    LOGD("Reopening non-socket FD %d (path: %s) normally.", fd, file_path.c_str());
	// NOTE: This might happen if the file was unlinked after being opened.
	// It's a common pattern in the case of temporary files and the like but
	// we should not allow such usage from the zygote.
	const int new_fd = TEMP_FAILURE_RETRY(open(file_path.c_str(), open_flags));
	if (new_fd == -1) {
		fail_fn(android::base::StringPrintf("Failed open(%s, %i): %s",
											file_path.c_str(),
											open_flags,
											strerror(errno)));
		return;
	}
	if (TEMP_FAILURE_RETRY(fcntl(new_fd, F_SETFD, fd_flags)) == -1) {
		close(new_fd);
		fail_fn(android::base::StringPrintf("Failed fcntl(%d, F_SETFD, %d) (%s): %s",
											new_fd,
											fd_flags,
											file_path.c_str(),
											strerror(errno)));
		return;
	}
	if (TEMP_FAILURE_RETRY(fcntl(new_fd, F_SETFL, fs_flags)) == -1) {
		close(new_fd);
		fail_fn(android::base::StringPrintf("Failed fcntl(%d, F_SETFL, %d) (%s): %s",
											new_fd,
											fs_flags,
											file_path.c_str(),
											strerror(errno)));
		return;
	}
	if (offset != -1 && TEMP_FAILURE_RETRY(lseek64(new_fd, offset, SEEK_SET)) == -1) {
		close(new_fd);
		fail_fn(android::base::StringPrintf("Failed lseek64(%d, %jd, SEEK_SET) (%s): %s",
											new_fd,
                                            (intmax_t)offset,
											file_path.c_str(),
											strerror(errno)));
		return;
	}
	int dup_flags = (fd_flags & FD_CLOEXEC) ? O_CLOEXEC : 0;
	if (TEMP_FAILURE_RETRY(dup3(new_fd, fd, dup_flags)) == -1) {
		close(new_fd);
		fail_fn(android::base::StringPrintf("Failed dup3(%d, %d, %d) (%s): %s",
											new_fd, // Corrected order: new_fd, fd
											fd,
											dup_flags,
											file_path.c_str(),
											strerror(errno)));
		return;
	}
	close(new_fd);
}

FileDescriptorInfo::FileDescriptorInfo(int fd) :
		fd(fd),
		stat(),
		open_flags(0),
		fd_flags(0),
		fs_flags(0),
		offset(0),
		is_sock(true) {
}
FileDescriptorInfo::FileDescriptorInfo(struct stat stat, const std::string& file_path,
									   int fd, int open_flags, int fd_flags, int fs_flags,
									   off_t offset) :
		fd(fd),
		stat(stat),
		file_path(file_path),
		open_flags(open_flags),
		fd_flags(fd_flags),
		fs_flags(fs_flags),
		offset(offset),
		is_sock(false) {
}

bool FileDescriptorInfo::GetSocketName(std::string* result) {
	sockaddr_storage ss;
	sockaddr* addr = reinterpret_cast<sockaddr*>(&ss);
	socklen_t addr_len = sizeof(ss);
	if (TEMP_FAILURE_RETRY(getsockname(fd, addr, &addr_len)) == -1) {
		return false;
	}
	if (addr->sa_family != AF_UNIX) {
		return false;
	}
	const sockaddr_un* unix_addr = reinterpret_cast<const sockaddr_un*>(&ss);
	size_t path_len = addr_len - offsetof(struct sockaddr_un, sun_path);
	// This is an unnamed local socket, we do not accept it.
	if (path_len == 0) {
		return false;
	}
	// This is a local socket with an abstract address. Remove the leading NUL byte and
	// add a human-readable "ABSTRACT/" prefix.
	if (unix_addr->sun_path[0] == '\0') {
		*result = "ABSTRACT/";
		result->append(&unix_addr->sun_path[1], path_len - 1);
		return true;
	}
	// If we're here, sun_path must refer to a null terminated filesystem
	// pathname (man 7 unix). Remove the terminator before assigning it to an
	// std::string.
	if (unix_addr->sun_path[path_len - 1] ==  '\0') {
		--path_len;
	}
	result->assign(unix_addr->sun_path, path_len);
	return true;
}

// TODO: Move the definitions here and eliminate the forward declarations. They
// temporarily help making code reviews easier.
static int ParseFd(dirent* dir_entry, int dir_fd);

std::unique_ptr<std::set<int>> GetOpenFds(fail_fn_t fail_fn) {
	DIR* proc_fd_dir = opendir(kFdPath);
	if (proc_fd_dir == nullptr) {
		fail_fn(android::base::StringPrintf("Unable to open directory %s: %s",
											kFdPath,
											strerror(errno)));
        return nullptr; // Return nullptr on error
	}
	auto result = std::make_unique<std::set<int>>();
	int dir_fd = dirfd(proc_fd_dir);
	dirent* dir_entry;
	while ((dir_entry = readdir(proc_fd_dir)) != nullptr) {
		const int fd = ParseFd(dir_entry, dir_fd);
		if (fd == -1) {
			continue;
		}

		result->insert(fd);
	}
	if (closedir(proc_fd_dir) == -1) {
		fail_fn(android::base::StringPrintf("Unable to close directory: %s", strerror(errno)));
        	}
	return result;
}

static int ParseFd(dirent* dir_entry, int dir_fd) {
	char* end;
	const int fd = strtol(dir_entry->d_name, &end, 10);
	if ((*end) != '\0') {
		return -1;
	}
	// Don't bother with the standard input/output/error, they're handled
	// specially post-fork anyway.
	if (fd <= STDERR_FILENO || fd == dir_fd) {
		return -1;
	}
	return fd;
}

```

`module/src/main/cpp/external/fdutils/fd_utils.h`:

```h
/*
 * This file includes modifications derived from The Android Open Source Project,
 * which is licensed under the Apache License, Version 2.0 (the "License").
 * These modifications are provided under the same License terms as the original work.
 *
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <memory>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>
#include <functional>

#include <dirent.h>
#include <cinttypes>
#include <sys/stat.h>

typedef const std::function<void(std::string)>& fail_fn_t;

// Returns the set of file descriptors currently open by the process.
std::unique_ptr<std::set<int>> GetOpenFds(fail_fn_t fail_fn);

// Keeps track of all relevant information (flags, offset etc.) of an
// open zygote file descriptor.
class FileDescriptorInfo {
public:
	// Create a FileDescriptorInfo for a given file descriptor.
	static std::unique_ptr<FileDescriptorInfo> CreateFromFd(int fd, fail_fn_t fail_fn);
	// Checks whether the file descriptor associated with this object refers to
	// the same description.
	bool RefersToSameFile() const;
	bool GetSocketName(std::string* result);

    // Reopens non-socket FDs or detaches socket FDs (to /dev/null).
    // If prefer_detach_to_dev_null is true for non-sockets, they are also detached.
	void ReopenOrDetach(fail_fn_t fail_fn, bool prefer_detach_to_dev_null) const;
    
    // Detaches the FD by redirecting it to /dev/null.
    void Detach(fail_fn_t fail_fn) const;


	const int fd;
	const struct stat stat;
	const std::string file_path;
	const int open_flags;
	const int fd_flags;
	const int fs_flags;
	const off_t offset;
	const bool is_sock;
private:
	// Constructs for sockets.
	explicit FileDescriptorInfo(int fd);
	// Constructs for non-socket file descriptors.
	FileDescriptorInfo(struct stat stat, const std::string& file_path, int fd, int open_flags,
					   int fd_flags, int fs_flags, off_t offset);

	FileDescriptorInfo(const FileDescriptorInfo&) = delete;
	void operator=(const FileDescriptorInfo&) = delete;
};

```

`module/src/main/cpp/external/fdutils/stringprintf.cpp`:

```cpp
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "stringprintf.h"
#include <cstdio>
#include <string>


namespace android::base {
	void StringAppendV(std::string* dst, const char* format, va_list ap) {
		// First try with a small fixed size buffer
		char space[1024] __attribute__((__uninitialized__));
		// It's possible for methods that use a va_list to invalidate
		// the data in it upon use.  The fix is to make a copy
		// of the structure before using it and use that copy instead.
		va_list backup_ap;
		va_copy(backup_ap, ap);
		int result = vsnprintf(space, sizeof(space), format, backup_ap);
		va_end(backup_ap);
		if (result < static_cast<int>(sizeof(space))) {
			if (result >= 0) {
				// Normal case -- everything fit.
				dst->append(space, result);
				return;
			}
			if (result < 0) {
				// Just an error.
				return;
			}
		}
		// Increase the buffer size to the size requested by vsnprintf,
		// plus one for the closing \0.
		int length = result + 1;
		char* buf = new char[length];
		// Restore the va_list before we use it again
		va_copy(backup_ap, ap);
		result = vsnprintf(buf, length, format, backup_ap);
		va_end(backup_ap);
		if (result >= 0 && result < length) {
			// It fit
			dst->append(buf, result);
		}
		delete[] buf;
	}
	std::string StringPrintf(const char* fmt, ...) {
		va_list ap;
		va_start(ap, fmt);
		std::string result;
		StringAppendV(&result, fmt, ap);
		va_end(ap);
		return result;
	}
	void StringAppendF(std::string* dst, const char* format, ...) {
		va_list ap;
		va_start(ap, format);
		StringAppendV(dst, format, ap);
		va_end(ap);
	}
} // namespace android::base

```

`module/src/main/cpp/external/fdutils/stringprintf.h`:

```h
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once
#include <cstdarg>
#include <string>

namespace android::base {
// These printf-like functions are implemented in terms of vsnprintf, so they
// use the same attribute for compile-time format string checking.
// Returns a string corresponding to printf-like formatting of the arguments.
	std::string StringPrintf(const char* fmt, ...) __attribute__((__format__(__printf__, 1, 2)));
// Appends a printf-like formatting of the arguments to 'dst'.
	void StringAppendF(std::string* dst, const char* fmt, ...)
	__attribute__((__format__(__printf__, 2, 3)));
// Appends a printf-like formatting of the arguments to 'dst'.
	void StringAppendV(std::string* dst, const char* format, va_list ap)
	__attribute__((__format__(__printf__, 2, 0)));
} // namespace android::base

```

`module/src/main/cpp/log.h`:

```h

#pragma once

#ifndef NOHELLO_LOG_H
#define NOHELLO_LOG_H

#ifdef DEBUG_BUILD
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, "NoHello", __VA_ARGS__)
#else
#define LOGD(...) ((void) 0)
#endif

#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, "NoHello", __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, "NoHello", __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, "NoHello", __VA_ARGS__)
#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, "NoHello", __VA_ARGS__)

#endif //NOHELLO_LOG_H

```

`module/src/main/cpp/mountsinfo.cpp`:

```cpp
#pragma once

#include <string>
#include <unordered_map>
#include <sstream>
#include <fstream>
#include <vector>
#include <cstdint>
#include <type_traits>
#include <algorithm>
#include <sys/types.h>
#include <sys/sysmacros.h>

enum class MountFlags : uint64_t {
	RO         = 1ull << 0,
	RW         = 1ull << 1,
	NOEXEC     = 1ull << 2,
	EXEC       = 1ull << 3,
	NOSUID     = 1ull << 4,
	SUID       = 1ull << 5,
	NODEV      = 1ull << 6,
	DEV        = 1ull << 7,
	RELATIME   = 1ull << 8,
	NORELATIME = 1ull << 9,
	STRICTATIME= 1ull << 10,
	NOATIME    = 1ull << 11,
	ATIME      = 1ull << 12,
	DIRSYNC    = 1ull << 13,
	SYNC       = 1ull << 14,
	MANDLOCK   = 1ull << 15,
	NODIRATIME = 1ull << 16,
	LAZYTIME   = 1ull << 17,
	SECLABEL   = 1ull << 18,
	INDEX      = 1ull << 19,
	NOINDEX    = 1ull << 20,
	METACOPY   = 1ull << 21,
	NOMETACOPY = 1ull << 22,
	BIND       = 1ull << 23,
	RPRIVATE   = 1ull << 24,
	RSHARED    = 1ull << 25,
	RSLAVE     = 1ull << 26,
	PRIVATE    = 1ull << 27,
	SHARED     = 1ull << 28,
	SLAVE      = 1ull << 29,
	REC        = 1ull << 30,
	REMOUNT    = 1ull << 31,
	NOSYMFOLLOW= 1ull << 32
};


inline MountFlags operator|(MountFlags a, MountFlags b) {
	return static_cast<MountFlags>(
			static_cast<std::underlying_type_t<MountFlags>>(a) |
			static_cast<std::underlying_type_t<MountFlags>>(b)
	);
}

inline MountFlags& operator|=(MountFlags& a, MountFlags b) {
	a = a | b;
	return a;
}

inline bool operator&(MountFlags a, MountFlags b) {
	return
			static_cast<std::underlying_type_t<MountFlags>>(a) &
			static_cast<std::underlying_type_t<MountFlags>>(b);
}

enum class PropagationType {
	PRIVATE,
	SHARED,
	SLAVE,
	UNBINDABLE,
	UNKNOWN
};

struct MountPropagation {
	PropagationType type = PropagationType::UNKNOWN;
	int id = -1;
};

static const std::unordered_map<std::string, MountFlags> mountFlags = {
		{"ro", MountFlags::RO}, {"rw", MountFlags::RW}, {"noexec", MountFlags::NOEXEC},
		{"exec", MountFlags::EXEC}, {"nosuid", MountFlags::NOSUID}, {"suid", MountFlags::SUID},
		{"nodev", MountFlags::NODEV}, {"dev", MountFlags::DEV}, {"relatime", MountFlags::RELATIME},
		{"norelatime", MountFlags::NORELATIME}, {"strictatime", MountFlags::STRICTATIME},
		{"noatime", MountFlags::NOATIME}, {"atime", MountFlags::ATIME}, {"dirsync", MountFlags::DIRSYNC},
		{"sync", MountFlags::SYNC}, {"mand", MountFlags::MANDLOCK}, {"nodiratime", MountFlags::NODIRATIME},
		{"lazytime", MountFlags::LAZYTIME}, {"seclabel", MountFlags::SECLABEL}, {"index", MountFlags::INDEX},
		{"noindex", MountFlags::NOINDEX}, {"metacopy", MountFlags::METACOPY},
		{"nometacopy", MountFlags::NOMETACOPY}, {"bind", MountFlags::BIND},
		{"rprivate", MountFlags::RPRIVATE}, {"rshared", MountFlags::RSHARED},
		{"rslave", MountFlags::RSLAVE}, {"private", MountFlags::PRIVATE},
		{"shared", MountFlags::SHARED}, {"slave", MountFlags::SLAVE},
		{"rec", MountFlags::REC}, {"remount", MountFlags::REMOUNT},
		{"nosymfollow", MountFlags::NOSYMFOLLOW}
};

struct MountOptions {
	MountFlags flags = MountFlags(0);
	std::unordered_map<std::string, std::string> flagmap;

	void parse(const std::string& str) {
		std::istringstream s(str);
		std::string opt;
		while (std::getline(s, opt, ',')) {
			auto it = mountFlags.find(opt);
			if (it != mountFlags.end()) {
				flags |= it->second;
			} else {
				size_t eq = opt.find('=');
				if (eq != std::string::npos) {
					flagmap[opt.substr(0, eq)] = opt.substr(eq + 1);
				}
			}
		}
	}
};

class MountInfo {
public:
	explicit MountInfo(const std::string& line) {
		std::istringstream ss(line);
		std::vector<std::string> parts;
		std::string token;
		while (ss >> token)
			parts.push_back(token);
		auto it = std::find(parts.begin(), parts.end(), std::string("-"));
		if (it == parts.end() || std::distance(parts.begin(), it) < 6)
			return;
		size_t sep_idx = std::distance(parts.begin(), it);
		mnt_id = std::stoi(parts[0]);
		mnt_parent_id = std::stoi(parts[1]);
		parseMajorMinor(parts[2]);
		root = parts[3];
		mnt_pnt = parts[4];
		parseFlags(parts[5]);
		for (size_t i = 6; i < sep_idx; ++i)
			parsePropagation(parts[i]);
		fs_type = parts[sep_idx + 1];
		mnt_src = parts[sep_idx + 2];
		parseOptions(parts[sep_idx + 3]);
	}

	~MountInfo() = default;

	[[nodiscard]] int getMountId() const { return mnt_id; }
	[[nodiscard]] int getParentId() const { return mnt_parent_id; }
	[[nodiscard]] dev_t getDev() const { return dev; }
	[[nodiscard]] const std::string& getRoot() const { return root; }
	[[nodiscard]] const std::string& getMountPoint() const { return mnt_pnt; }
	[[nodiscard]] MountFlags getFlags() const { return mnt_flags; }
	[[nodiscard]] const MountPropagation& getPropagation() const { return propagation; }
	[[nodiscard]] const std::string& getFsType() const { return fs_type; }
	[[nodiscard]] const std::string& getMountSource() const { return mnt_src; }
	[[nodiscard]] const MountOptions& getMountOptions() const { return mnt_opts; }

private:
	int mnt_id;
	int mnt_parent_id;
	dev_t dev = 0;
	std::string root;
	std::string mnt_pnt;
	MountFlags mnt_flags = MountFlags(0);
	MountPropagation propagation;
	std::string fs_type;
	std::string mnt_src;
	MountOptions mnt_opts;

	void parseFlags(const std::string& str) {
		std::istringstream s(str);
		std::string opt;
		while (std::getline(s, opt, ',')) {
			auto it = mountFlags.find(opt);
			if (it != mountFlags.end())
				mnt_flags |= it->second;
		}
	}

	void parsePropagation(const std::string& pg) {
		if (pg.find("master:") == 0) {
			propagation.type = PropagationType::SLAVE;
			propagation.id = std::stoi(pg.substr(7));
		} else if (pg.find("shared:") == 0) {
			propagation.type = PropagationType::SHARED;
			propagation.id = std::stoi(pg.substr(7));
		} else if (pg == "unbindable") {
			propagation.type = PropagationType::UNBINDABLE;
		} else if (pg == "private") {
			propagation.type = PropagationType::PRIVATE;
		}
	}

	void parseOptions(const std::string& opt) {
		mnt_opts.parse(opt);
	}

	void parseMajorMinor(const std::string& mmstr) {
		size_t sep = mmstr.find(':');
		if (sep != std::string::npos) {
			int major = std::stoi(mmstr.substr(0, sep));
			int minor = std::stoi(mmstr.substr(sep + 1));
			dev = makedev(major, minor);
		} else {
			dev = 0;
		}
	}
};

class MountRootResolver {
private:
	std::unordered_map<dev_t, std::string> dmm;

public:
	explicit MountRootResolver(const std::vector<MountInfo>& mounts) {
		for (const auto& mount : mounts) {
			if (mount.getRoot() == "/") {
				dmm[mount.getDev()] = mount.getMountPoint();
			}
		}
	}

	~MountRootResolver() = default;

	std::string resolveRoot(const MountInfo& mount) {
		auto dev = mount.getDev();
		auto it = dmm.find(dev);
		if (it != dmm.end()) {
			if (it->second != "/")
				return it->second + mount.getRoot();
		}
		return mount.getRoot();
	}
};

std::vector<MountInfo> getMountInfo(const std::string& path = "/proc/self/mountinfo") {
	std::ifstream mi(path);
	std::vector<MountInfo> mounts;
	std::string line;
	if (!mi.is_open())
		return mounts;
	while (std::getline(mi, line)) {
		MountInfo mountInfo(line);
		mounts.emplace_back(std::move(mountInfo));
	}
	mi.close();
	return mounts;
}
```

`module/src/main/cpp/nohello.cpp`:

```cpp
/* Copyright 2022-2023 John "topjohnwu" Wu
 * Copyright 2024 The NoHello Contributors
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include <cstdlib>
#include <unistd.h>
#include <fcntl.h>
#include <android/log.h>
#include <filesystem>
#include <ranges>
#include <vector>
#include <utility> // For std::pair, std::move

#include "zygisk.hpp"
#include "external/android_filesystem_config.h"
#include "mountsinfo.cpp"
#include "utils.cpp"
#include "external/fdutils/fd_utils.cpp"
#include <sys/mount.h>
#include <sys/ptrace.h>
#include <endian.h>
#include <thread>
#include "log.h"
#include "PropertyManager.cpp"
#include "MountRuleParser.cpp"
#include "external/emoji.h"

using zygisk::Api;
using zygisk::AppSpecializeArgs;
using zygisk::ServerSpecializeArgs;

namespace fs = std::filesystem;

static constexpr off_t EXT_SUPERBLOCK_OFFSET = 0x400;
static constexpr off_t EXT_MAGIC_OFFSET = 0x38;
static constexpr off_t EXT_ERRORS_OFFSET = 0x3C;
static constexpr uint16_t EXT_MAGIC = 0xEF53;
static const std::vector<std::string> defaultRules = {
		R"(source { "KSU", "APatch", "magisk", "worker" } fs { "tmpfs" "overlay" })"
};

enum Advice {
	NORMAL = 0,
	MODULE_CONFLICT = 2,
};

enum State {
	SUCCESS = 0,
	FAILURE = 1
};

static const std::set<std::string> toumount_sources = {"KSU", "APatch", "magisk", "worker"};
static const std::string adbPathPrefix = "/data/adb";

static bool anomaly(MountRootResolver mrs, const MountInfo &mount) {
	const std::string resolved_root = mrs.resolveRoot(mount);
	if (resolved_root.starts_with(adbPathPrefix) || mount.getMountPoint().starts_with(adbPathPrefix)) {
		return true;
	}
	const auto& fs_type = mount.getFsType();
	const auto& mnt_src = mount.getMountSource();
	if (toumount_sources.count(mnt_src)) {
		return true;
	}
	if (fs_type == "overlay") {
		if (toumount_sources.count(mnt_src)) {
			return true;
		}
		const auto& fm = mount.getMountOptions().flagmap;
		if (fm.count("lowerdir") && fm.at("lowerdir").starts_with(adbPathPrefix)) {
			return true;
		}
		if (fm.count("upperdir") && fm.at("upperdir").starts_with(adbPathPrefix)) {
			return true;
		}
		if (fm.count("workdir") && fm.at("workdir").starts_with(adbPathPrefix)) {
			return true;
		}
	} else if (fs_type == "tmpfs") {
		if (toumount_sources.count(mnt_src)) {
			return true;
		}
	}
	return false;
}

static bool anomaly(const MountRuleParser::MountRule& rule, MountRootResolver mrs, const MountInfo &mount) {
	const std::string resolvedRoot = mrs.resolveRoot(mount);
	const auto& fsType = mount.getFsType();
	if (fsType != "overlay") {
		return rule.matches(resolvedRoot, mount.getMountPoint(), fsType, mount.getMountSource());
	} else {
		const auto& fm = mount.getMountOptions().flagmap;
		std::vector<std::string> roots = {resolvedRoot};
		for (const auto* key : {"lowerdir", "upperdir", "workdir"}) {
			auto it = fm.find(key);
			if (it != fm.end()) {
				roots.push_back(it->second);
			}
		}
		return rule.matches(roots, mount.getMountPoint(), fsType, mount.getMountSource());
	}
	return false;
}

static bool anomaly(const std::vector<MountRuleParser::MountRule>& rules, MountRootResolver mrs, const MountInfo &mount) {
	const std::string resolvedRoot = mrs.resolveRoot(mount);
	const auto& fsType = mount.getFsType();
	const auto& fm = mount.getMountOptions().flagmap;
	for (const auto& rule : rules) {
		if (fsType != "overlay") {
			if (rule.matches(resolvedRoot, mount.getMountPoint(), fsType, mount.getMountSource()))
				return true;
		} else {
			std::vector<std::string> roots = {resolvedRoot};
			for (const auto* key : {"lowerdir", "upperdir", "workdir"}) {
				auto it = fm.find(key);
				if (it != fm.end()) {
					roots.push_back(it->second);
				}
			}
			if (rule.matches(roots, mount.getMountPoint(), fsType, mount.getMountSource()))
				return true;
		}
	}
	return false;
}

static std::pair<bool, bool> anomaly(const std::unique_ptr<FileDescriptorInfo> fdi) {
	if (fdi->is_sock) {
		std::string socket_name;
		if (fdi->GetSocketName(&socket_name)) {
			if (socket_name.find("magisk") != std::string::npos ||
				socket_name.find("kernelsu") != std::string::npos || // For KernelSU daemon, common pattern
				socket_name.find("ksud") != std::string::npos || // KernelSU daemon
				socket_name.find("apatchd") != std::string::npos || // For APatch daemon, common pattern
				socket_name.find("apd") != std::string::npos      // APatch daemon
					) {
				LOGD("Marking sensitive socket FD %d (%s) for sanitization.", fdi->fd, socket_name.c_str());
				return {true, true};
			}
		}
	} else { // Not a socket
		if (!fdi->file_path.starts_with("/memfd:") &&
			!fdi->file_path.starts_with("/dev/ashmem") && // Common, usually not root related
			!fdi->file_path.starts_with("[anon_inode:") && // e.g., [anon_inode:sync_fence]
			!fdi->file_path.empty() // Ensure path is not empty
				) {
			if (fdi->file_path.starts_with(adbPathPrefix) ||
				fdi->file_path.find("magisk") != std::string::npos ||
				fdi->file_path.find("kernelsu") != std::string::npos ||
				fdi->file_path.find("apatch") != std::string::npos) {
				LOGD("Marking sensitive file FD %d (%s) for sanitization.", fdi->fd, fdi->file_path.c_str());
				return {true, true};
			}
		}
	}
	return {false, false};
}


static std::unique_ptr<std::string> getExternalErrorBehaviour(const MountInfo& mount) {
	const auto& fs = mount.getFsType();
	if (fs != "ext2" && fs != "ext3" && fs != "ext4")
		return nullptr;
	std::ifstream mntsrc(mount.getMountSource(), std::ios::binary);
	if (!mntsrc || !mntsrc.is_open())
		return nullptr;
	uint16_t magic;
	mntsrc.seekg(EXT_SUPERBLOCK_OFFSET + EXT_MAGIC_OFFSET, std::ios::beg);
	mntsrc.read(reinterpret_cast<char *>(&magic), sizeof(magic));
	if (!mntsrc || mntsrc.gcount() != sizeof(magic))
		return nullptr;
	magic = le16toh(magic);
	if (magic != EXT_MAGIC)
		return nullptr;
	uint16_t errors;
	mntsrc.seekg(EXT_SUPERBLOCK_OFFSET + EXT_ERRORS_OFFSET, std::ios::beg);
	mntsrc.read(reinterpret_cast<char *>(&errors), sizeof(errors));
	if (!mntsrc || mntsrc.gcount() != sizeof(errors))
		return nullptr;
	errors = le16toh(errors);
	switch (errors)
	{
		case 1:
			return std::make_unique<std::string>("continue");
		case 2:
			return std::make_unique<std::string>("remount-ro");
		case 3:
			return std::make_unique<std::string>("panic");
		default:
			return nullptr;
	}
	return nullptr;
}

static void doumount(const std::string& mntPnt);

static void unmount(const std::vector<MountInfo>& mounts) {
	MountRootResolver mrs(mounts);
	for (const auto& mount : std::ranges::reverse_view(mounts)) {
		if (anomaly(mrs, mount))
			doumount(mount.getMountPoint());
	}
}

static void unmount(const std::vector<MountRuleParser::MountRule>& rules, const std::vector<MountInfo>& mounts) {
	MountRootResolver mrs(mounts);
	for (const auto& mount : std::ranges::reverse_view(mounts)) {
		if (anomaly(rules, mrs, mount))
			doumount(mount.getMountPoint());
	}
}

static void unmount(const MountRuleParser::MountRule& rule, const std::vector<MountInfo>& mounts) {
	MountRootResolver mrs(mounts);
	for (const auto& mount : std::ranges::reverse_view(mounts)) {
		if (anomaly(rule, mrs, mount))
			doumount(mount.getMountPoint());
	}
}

static void doumount(const std::string& mntPnt) {
	errno = 0;
	int res;
	const char *mntpnt = mntPnt.c_str();
	if ((res = umount2(mntpnt, MNT_DETACH)) == 0)
		LOGD("umount2(\"%s\", MNT_DETACH): returned (0): 0 (Success)", mntpnt);
	else
		LOGE("umount2(\"%s\", MNT_DETACH): returned %d: %d (%s)", mntpnt, res, errno, strerror(errno));
}

static void remount(const std::vector<MountInfo>& mounts) {
	for (const auto& mount : mounts) {
		if (mount.getMountPoint() == "/data") {
			const auto& mntopts = mount.getMountOptions();
			const auto& fm = mntopts.flagmap;
			if (!fm.count("errors"))
				break;
			auto errors = getExternalErrorBehaviour(mount);
			if (!errors || fm.at("errors") == *errors)
				break;
			auto mntflags = mount.getFlags();
			unsigned int flags = MS_REMOUNT;
			if (mntflags & MountFlags::NOSUID) {
				flags |= MS_NOSUID;
			}
			if (mntflags & MountFlags::NODEV) {
				flags |= MS_NODEV;
			}
			if (mntflags & MountFlags::NOEXEC) {
				flags |= MS_NOEXEC;
			}
			if (mntflags & MountFlags::NOATIME) {
				flags |= MS_NOATIME;
			}
			if (mntflags & MountFlags::NODIRATIME) {
				flags |= MS_NODIRATIME;
			}
			if (mntflags & MountFlags::RELATIME) {
				flags |= MS_RELATIME;
			}
			if (mntflags & MountFlags::NOSYMFOLLOW) {
				flags |= MS_NOSYMFOLLOW;
			}
			int res;
			if ((res = ::mount(nullptr, "/data", nullptr, flags, (std::string("errors=") + *errors).c_str())) == 0)
				LOGD("mount(nullptr, \"/data\", nullptr, 0x%x, \"errors=%s\"): returned 0: 0 (Success)", flags, errors->c_str());
			else
				LOGW("mount(NULL, \"/data\", NULL, 0x%x, \"errors=%s\"): returned %d: %d (%s)", flags, errors->c_str(), res, errno, strerror(errno));
			break;
		}
	}
}

int (*ar_unshare)(int) = nullptr;

static int reshare(int flags) {
    errno = 0;
    return ar_unshare(flags & ~(CLONE_NEWNS | CLONE_NEWCGROUP));
}

class NoHello : public zygisk::ModuleBase {
public:
    void onLoad(Api *_api, JNIEnv *_env) override {
        this->api = _api;
        this->env = _env;
    }

    void preAppSpecialize(AppSpecializeArgs *args) override {
        preSpecialize(args);
    }

	void postAppSpecialize(const AppSpecializeArgs *args) override {
		const char *process = env->GetStringUTFChars(args->nice_name, nullptr);
		postSpecialize(process);
		env->ReleaseStringUTFChars(args->nice_name, process);
	}

    void preServerSpecialize(ServerSpecializeArgs *args) override {
        //preSpecialize("system_server"); // System server usually doesn't need this level of hiding
		api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
    }

private:
    Api *api{};
    JNIEnv *env{};
	int cfd{};
	dev_t rundev{};
	ino_t runinode{};
	dev_t cdev{};
	ino_t cinode{};


    void preSpecialize(AppSpecializeArgs *args) {
		unsigned int flags = api->getFlags();
		const bool whitelist = access("/data/adb/nohello/whitelist", F_OK) == 0;
		const bool nodirtyro = access("/data/adb/nohello/no_dirtyro_ar", F_OK) == 0;
		if (flags & zygisk::StateFlag::PROCESS_GRANTED_ROOT) {
			api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
			return;
		}
		auto fn = [this](const std::string& lib) {
			auto di = devinoby(lib.c_str());
			if (di) {
				return *di;
			} else {
				LOGW("#[zygisk::?] devino[dl_iterate_phdr]: Failed to get device & inode for %s", lib.c_str());
				LOGI("#[zygisk::?] Fallback to use `/proc/self/maps`");
				return devinobymap(lib);
			}
		};
		if ((whitelist && isuserapp(args->uid)) || flags & zygisk::StateFlag::PROCESS_ON_DENYLIST) {
			pid_t pid = getpid(), ppid = getppid();
			cfd = api->connectCompanion(); // Companion FD
			api->exemptFd(cfd);
			if (write(cfd, &ppid, sizeof(ppid)) != sizeof(ppid)) {
				LOGE("#[zygisk::preSpecialize] write: [-> ppid]: %s", strerror(errno));
				close(cfd);
				api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
				return;
			}
			int advice;
			if (read(cfd, &advice, sizeof(advice)) != sizeof(advice)) {
				LOGE("#[zygisk::preSpecialize] read: [<- status]: %s", strerror(errno));
				close(cfd);
				api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
				return;
			}
			if (advice == MODULE_CONFLICT) {
				close(cfd);
				api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
				return;
			}
			std::tie(cdev, cinode) = fn("libc.so");
			if (!cdev && !cinode) {
				LOGE("#[zygisk::preSpecialize] Failed to get device & inode for libc.so");
				close(cfd);
				api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
				return;
			}
			std::tie(rundev, runinode) = fn("libandroid_runtime.so");
			if (!rundev && !runinode) {
				LOGE("#[zygisk::preSpecialize] Failed to get device & inode for libandroid_runtime.so");
				close(cfd);
				api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
				return;
			}
			api->pltHookRegister(rundev, runinode, "unshare", (void*) reshare, (void**) &ar_unshare);
			api->pltHookCommit();
			if (!nodirtyro) {
				if (auto res = robaseby(rundev, runinode)) {
					/*
					 * Temporary workaround to fix detection in apps that checks Shared_Clean
					 * if >= 512kb
					 */
					auto [base, size] = *res;
					long pagesz = sysconf(_SC_PAGESIZE);
					size_t alignedSize = (size + pagesz - 1) & ~(pagesz - 1);
					mprotect(base, alignedSize, PROT_READ | PROT_WRITE);
					for (uintptr_t addr = (uintptr_t) base; addr < (uintptr_t) base + size; addr += pagesz) {
						void* page = reinterpret_cast<void*>(addr);
						uint8_t orig = *(volatile uint8_t*) page;
						*(volatile uint8_t*) page = orig;
					}
					mprotect(base, alignedSize, PROT_READ);
					madvise(base, alignedSize, MADV_REMOVE);
				} else {
					LOGW("#[zygisk::preSpecialize] Failed to get ro block for libandroid_runtime.so");
				}
			}
			std::vector<std::pair<std::unique_ptr<FileDescriptorInfo>, bool>> fdSanitizeList; // bool is shouldDetach
			auto fds = GetOpenFds([](const std::string &error){
				LOGE("#[zygisk::preSpecialize] GetOpenFds: %s", error.c_str());
			});
			if (fds) {
				for (auto &fd : *fds) {
					if (fd == cfd) continue; // Skip companion FD itself
					auto fdi = FileDescriptorInfo::CreateFromFd(fd, [fd](const std::string &error){
						LOGE("#[zygisk::preSpecialize] CreateFromFd(%d): %s", fd, error.c_str());
					});
					if (!fdi)
						continue;
					auto [canSanitize, shouldDetach] = anomaly(std::move(fdi));
					if (canSanitize) {
						fdSanitizeList.emplace_back(std::move(fdi), shouldDetach);
					}
				}
			}

			int res = unshare(CLONE_NEWNS | CLONE_NEWCGROUP);
			if (res != 0) {
				LOGE("#[zygisk::preSpecialize] unshare: %s", strerror(errno));
				// There's nothing we can do except returning
				close(cfd);
				return;
			}
			res = mount("rootfs", "/", nullptr, MS_SLAVE | MS_REC, nullptr);
			if (res != 0) {
				LOGE("#[zygisk::preSpecialize] mount(rootfs, \"/\", nullptr, MS_SLAVE | MS_REC, nullptr): returned %d: %d (%s)", res, errno, strerror(errno));
				// There's nothing we can do except returning
				close(cfd);
				return;
			}

			static std::vector<MountRuleParser::MountRule> mountRules;

			if (write(cfd, &pid, sizeof(pid)) != sizeof(pid)) {
				LOGE("#[zygisk::preSpecialize] write: [-> pid]: %s", strerror(errno));
				res = FAILURE; // Fallback to unmount from zygote
			} else if (read(cfd, &res, sizeof(res)) != sizeof(res)) {
				LOGE("#[zygisk::preSpecialize] read: [<- status]: %s", strerror(errno));
				res = FAILURE; // Fallback to unmount from zygote
			} else if (res == FAILURE) {
				LOGW("#[zygisk::preSpecialize]: Companion failed, fallback to unmount in zygote process");
				mountRules = MountRuleParser::parseMultipleRules([this]() {
					auto sizeOfRulesPtr = xread<std::size_t>(cfd);
					if (!sizeOfRulesPtr) {
						LOGE("#[zygisk::preSpecialize] read: [sizeOfRules]: %s", strerror(errno));
						return defaultRules;
					}
					auto sizeOfRules = *sizeOfRulesPtr;
					std::vector<std::string> rules(sizeOfRules, "");
					for (int i = 0; i < sizeOfRules; ++i) {
						auto rule = xread<std::string>(cfd);
						if (!rule) {
							LOGE("#[zygisk::preSpecialize] read: [rule (at index %d)]: %s", i, strerror(errno));
							return defaultRules;
						}
						rules[i] = std::move(*rule);
					}
					return rules;
				}());
			}

			close(cfd);

			if (res == FAILURE) {
				LOGW("#[zygisk::preSpecialize]: Companion failed, fallback to unmount in zygote process");
				unmount(mountRules, getMountInfo()); // Unmount in current (zygote) namespace as fallback
			}

			// Sanitize FDs after companion communication and potential mount changes
			for (auto &[fdi, shouldDetach] : fdSanitizeList) {
				LOGD("#[zygisk::preSpecialize]: Sanitizing FD %d (path: %s, socket: %d), detach: %d",
					 fdi->fd, fdi->file_path.c_str(), fdi->is_sock, shouldDetach);
				fdi->ReopenOrDetach([
											fd = fdi->fd,
											path = fdi->file_path // Capture path by value for lambda
									](const std::string &error){
					LOGE("#[zygisk::preSpecialize]: Sanitize FD %d (%s): %s", fd, path.c_str(), error.c_str());
				}, shouldDetach);
			}
			return;
		}
        api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
    }

	void postSpecialize(const char *process) {
        // Unhook PLT hooks
		if (ar_unshare) {
			api->pltHookRegister(rundev, runinode, "unshare", (void*) ar_unshare, nullptr);
            ar_unshare = nullptr; // Clear pointer
        }
		api->pltHookCommit();
		//close(cfd);
		api->setOption(zygisk::Option::DLCLOSE_MODULE_LIBRARY);
	}

};

static void NoRoot(int fd) {
	pid_t pid = -1, ppid = -1;
	static unsigned int successRate = 0;
	static const std::string description = [] {
		std::ifstream f("/data/adb/modules/zygisk_nohello/description");
		// This file exists only after installing/updating the module
		// It should have the default description
		// Since this is static const it's only evaluated once per boot since companion won't exit
		return f ? ([](std::ifstream& s){ std::string l; std::getline(s, l); return l; })(f) : "A Zygisk module to hide root.";
	}();
	static PropertyManager pm("/data/adb/modules/zygisk_nohello/module.prop");

	static const int compatbility = [] {
		if (fs::exists("/data/adb/modules/zygisk_shamiko") && !fs::exists("/data/adb/modules/zygisk_shamiko/disable"))
			return MODULE_CONFLICT;
		if (fs::exists("/data/adb/modules/zygisk-assistant") && !fs::exists("/data/adb/modules/zygisk-assistant/disable"))
			return MODULE_CONFLICT;
		if (fs::exists("/data/adb/modules/treat_wheel") && !fs::exists("/data/adb/modules/treat_wheel/disable"))
			return MODULE_CONFLICT;
		if (fs::exists("/data/adb/modules/susfs4ksu") && !fs::exists("/data/adb/modules/susfs4ksu/disable"))
			return MODULE_CONFLICT;
		return NORMAL;
	}();

	static const bool doesUmountPersists = []() {
		return fs::exists("/data/adb/nohello/umount_persist") || fs::exists("/data/adb/nohello/umount_persists");
	}();

	static std::vector<std::string> stringRules;
	static std::vector<MountRuleParser::MountRule> mountRules;
	static bool evaluateOnlyOnce = false;

	if (!evaluateOnlyOnce) {
		stringRules = []() {
			std::vector<std::string> rules;
			std::ifstream f("/data/adb/nohello/umount");
			if (f && f.is_open()) {
				std::string line;
				while (std::getline(f, line)) {
					if (!line.empty() && line[0] != '#')
						rules.push_back(line);
				}
				f.close();
			} else {
				rules = defaultRules;
				std::ofstream redef("/data/adb/nohello/umount");
				if (redef && redef.is_open()) {
					for (const auto &rule: rules)
						redef << rule << std::endl;
					f.close();
				} else
					LOGE("Unable to create `/data/adb/nohello/umount`");
			}
			return rules;
		}();
		mountRules = MountRuleParser::parseMultipleRules(stringRules);
		if (doesUmountPersists)
			evaluateOnlyOnce = true;
	}

	if (read(fd, &ppid, sizeof(ppid)) != sizeof(ppid)) {
		LOGE("#[ps::Companion] Failed to read PPID: %s", strerror(errno));
		close(fd);
		return;
	}

	static const pid_t clrMsgZygote = [ppid]() -> pid_t {
		if (fs::exists("/data/adb/nohello/no_clr_ptracemsg"))
			// Apply the fix only by user's choice
			return ppid;
		if (getKernelVersion() >= KERNEL_VERSION(6, 1, 0))
			// The issue was fixed in 6.1+
			// https://marc.info/?l=linux-arch&m=164124554311501&w=2
			return ppid;
		// Re-work this to avoid issues with bootloops
		// https://github.com/PerformanC/ReZygisk/issues/171
		if (ptrace(PTRACE_ATTACH, ppid, nullptr, nullptr) == -1) {
			LOGE("#[ps::Companion] ptrace(PTRACE_ATTACH, %d, nullptr, nullptr): %s", ppid,
				 strerror(errno));
			return -1;
		}
		waitpid(ppid, nullptr, 0);
		if (ptrace(PTRACE_SYSCALL, ppid, nullptr, nullptr) == -1) {
			LOGE("#[ps::Companion] ptrace(PTRACE_SYSCALL, %d, nullptr, nullptr): %s", ppid, strerror(errno));
			ptrace(PTRACE_DETACH, ppid, nullptr, nullptr);
			return -1;
		}
		waitpid(ppid, nullptr, 0);
		ptrace(PTRACE_DETACH, ppid, nullptr, nullptr);
		LOGD("#[ps::Companion] Cleared ptrace_message for zygote(%d)", ppid);
		return ppid;
	}();

	int result = compatbility;
	if (result == MODULE_CONFLICT) {
		pm.setProp("description", "[" + emoji::emojize(":warning: ") + "Conflicting modules] " + description);
		if (write(fd, &result, sizeof(result)) != sizeof(result)) {
			LOGE("#[ps::Companion] Failed to write result: %s", strerror(errno));
		}
		close(fd);
		return;
	} else {
		if (write(fd, &result, sizeof(result)) != sizeof(result)) {
			LOGE("#[ps::Companion] Failed to write result: %s", strerror(errno));
			close(fd);
			return;
		}
	}

	if (read(fd, &pid, sizeof(pid)) != sizeof(pid)) {
        LOGE("#[ps::Companion] Failed to read PID: %s", strerror(errno));
		close(fd);
		return;
	}

	result = forkcall(
		[pid]()
		{
			int res = nscg2(pid);
			if (!res) { // switchnsto returns true on success (0 from setns)
				LOGE("#[ps::Companion] Switch namespaces failed for PID %d: %s", pid, strerror(errno));
				return FAILURE;
			}
			auto mounts = getMountInfo();
			unmount(mountRules, mounts);
			remount(mounts);
			return SUCCESS;
		}
	);

	if (result == SUCCESS) {
		successRate++;
		pm.setProp("description", "[" + emoji::emojize(":yum: ") + "Nohello unmounted " +
								  std::to_string(successRate) + " time(s)] " + description);
	} else if (result == FAILURE) {
		if (write(fd, &result, sizeof(result)) != sizeof(result)) {
			LOGE("#[ps::Companion] Failed to write result: %s", strerror(errno));
			close(fd);
			return;
		}
		if (xwrite(fd, stringRules.size())) {
			for (int i = 0; i < stringRules.size(); ++i) {
				if (!xwrite(fd, stringRules[i])) {
					LOGE("#[ps::Companion] write: [rule (at index %d)]: %s", i, strerror(errno));
					close(fd);
					return;
				}
			}
		} else {
			LOGE("#[ps::Companion] write: [stringRules.size()]: %s", strerror(errno));
			close(fd);
			return;
		}
		close(fd);
		return;
	}
	if (write(fd, &result, sizeof(result)) != sizeof(result)) {
		LOGE("#[ps::Companion] Failed to write result: %s", strerror(errno));
		close(fd);
		return;
	}
	close(fd);
}

// Register our module class and the companion handler function
REGISTER_ZYGISK_MODULE(NoHello)
REGISTER_ZYGISK_COMPANION(NoRoot)

```

`module/src/main/cpp/utils.cpp`:

```cpp
#include <fstream>
#include <sstream>
#include <string>
#include <utility>
#include <iostream>
#include <iomanip>
#include <sys/sysmacros.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <vector>
#include <tuple>
#include <cstdint>
#include <sys/mman.h>
#include <link.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <linux/version.h>
#include <dirent.h>
#include "log.h"

std::pair<dev_t, ino_t> devinobymap(const std::string& lib, bool useFind = false, unsigned int *ln = nullptr) {
	std::ifstream maps("/proc/self/maps");
	unsigned int index = 0;
	std::string line;
	std::string needle = "/" + lib;
	while (std::getline(maps, line)) {
		if (ln && index < *ln) {
			index++;
			continue;
		}
		if (line.size() >= needle.size() && ((useFind && line.find(needle) != std::string::npos) ||
			line.compare(line.size() - needle.size(), needle.size(), needle) == 0)) {
			std::istringstream iss(line);
			std::string addr, perms, offset, dev, inode_str;
			iss >> addr >> perms >> offset >> dev >> inode_str;
			std::istringstream devsplit(dev);
			std::string major_hex, minor_hex;
			if (std::getline(devsplit, major_hex, ':') &&
				std::getline(devsplit, minor_hex)) {
				int major = std::stoi(major_hex, nullptr, 16);
				int minor = std::stoi(minor_hex, nullptr, 16);
				dev_t devnum = makedev(major, minor);
				ino_t inode = std::stoul(inode_str);
				if (ln)
					*ln = index;
				return {devnum, inode};
			}
		}
		index++;
	}
	if (ln)
		*ln = -1;
	return {dev_t(0), ino_t(0)};
}

std::optional<std::pair<dev_t, ino_t>> devinoby(const char* lib) {
	struct State {
		const char* needle;
		std::optional<std::pair<dev_t, ino_t>> result;
	} state = { lib };

	dl_iterate_phdr([](struct dl_phdr_info* info, size_t, void* data) -> int {
		auto* s = static_cast<State*>(data);
		if (info->dlpi_name && strstr(info->dlpi_name, s->needle)) {
			struct stat st{};
			if (stat(info->dlpi_name, &st) == 0) {
				s->result = std::make_pair(st.st_dev, st.st_ino);
				return 1; // Stop iteration
			}
		}
		return 0; // Continue
	}, &state);

	return state.result;
}

std::optional<std::pair<void*, size_t>> robaseby(dev_t dev, ino_t ino) {
	struct State {
		dev_t dev;
		ino_t ino;
		std::optional<std::pair<void*, size_t>> result;
	} state = { dev, ino };

	dl_iterate_phdr([](struct dl_phdr_info* info, size_t, void* data) -> int {
		auto* s = static_cast<State*>(data);

		struct stat st{};
		if (stat(info->dlpi_name, &st) != 0)
			return 0;

		if (st.st_dev != s->dev || st.st_ino != s->ino)
			return 0;

		for (int i = 0; i < info->dlpi_phnum; ++i) {
			const auto& phdr = info->dlpi_phdr[i];
			if (phdr.p_type == PT_LOAD &&
				(phdr.p_flags & PF_R) &&
				!(phdr.p_flags & PF_X)) // r--p only
			{
				uintptr_t base = info->dlpi_addr + phdr.p_vaddr;
				size_t size = phdr.p_memsz;
				s->result = std::make_pair(reinterpret_cast<void*>(base), size);
				return 1; // Stop searching
			}
		}

		return 0;
	}, &state);

	return state.result;
}

int forkcall(const std::function<int()> &lambda)
{
	pid_t pid = fork();
	if (pid == -1)
		return -1;
	if (pid == 0) {
		exit(lambda());
	} else {
		int status = -1;
		waitpid(pid, &status, 0);
		if (WIFEXITED(status)) {
			return WEXITSTATUS(status);
		}
	}
	return -1;
}

static inline int seccomp(int op, int fd, void *arg) {
	return syscall(SYS_seccomp, op, fd, arg);
}

static int pidfd_open(pid_t pid, unsigned int flags)
{
	return syscall(SYS_pidfd_open, pid, flags);
}

static ssize_t process_vm_readv(pid_t pid,
								 const struct iovec *local_iov,
								 unsigned long liovcnt,
								 const struct iovec *remote_iov,
								 unsigned long riovcnt,
								 unsigned long flags)
{
	return syscall(SYS_process_vm_readv, pid, local_iov, liovcnt, remote_iov, riovcnt, flags);
}

static ssize_t process_vm_writev(pid_t pid,
								 const struct iovec *local_iov,
								 unsigned long liovcnt,
								 const struct iovec *remote_iov,
								 unsigned long riovcnt,
								 unsigned long flags)
{
	return syscall(SYS_process_vm_writev, pid, local_iov, liovcnt, remote_iov, riovcnt, flags);
}

bool nscg2(pid_t pid) {
    int pidfd = pidfd_open(pid, 0);
    if (pidfd != -1) {
    	// https://man7.org/linux/man-pages/man2/setns.2.html
        int res = setns(pidfd, CLONE_NEWNS | CLONE_NEWCGROUP);
        close(pidfd);
        if (res) {
            LOGE("setns(pidfd_open(%d, 0) -> %d (closed), 0): %s", pid, pidfd, strerror(errno));
            goto fallback;
        }
        return true;
    } else {
        LOGE("pidfd_open(%d): %s", pid, strerror(errno));
    }
fallback:
    {
        std::string mntPath = "/proc/" + std::to_string(pid) + "/ns/mnt";
        int mntfd_fallback = open(mntPath.c_str(), O_RDONLY);
        if (mntfd_fallback != -1) {
            int res = setns(mntfd_fallback, CLONE_NEWNS);
            if (res) {
                LOGE("setns(open(\"%s\") -> %d, CLONE_NEWNS): %s", mntPath.c_str(), mntfd_fallback, strerror(errno));
                close(mntfd_fallback);
                return false;
            }
            close(mntfd_fallback);
        } else {
            LOGE("open(\"%s\"): %s", mntPath.c_str(), strerror(errno));
            return false;
        }
    }
    {
        std::string cgPath = "/proc/" + std::to_string(pid) + "/ns/cgroup";
        int cgfd_fallback = open(cgPath.c_str(), O_RDONLY);
        if (cgfd_fallback != -1) {
            int res = setns(cgfd_fallback, CLONE_NEWCGROUP);
            if (res) {
                LOGE("setns(open(\"%s\") -> %d, CLONE_NEWCGROUP): %s", cgPath.c_str(), cgfd_fallback, strerror(errno));
                close(cgfd_fallback);
                return false;
            }
            close(cgfd_fallback);
        } else {
            LOGE("open(\"%s\"): %s", cgPath.c_str(), strerror(errno));
            return false;
        }
    }
    return true;
}


bool isuserapp(int uid) {
	int appid = uid % AID_USER_OFFSET;
	if (appid >= AID_APP_START && appid <= AID_APP_END)
		return true;
	if (appid >= AID_ISOLATED_START && appid <= AID_ISOLATED_END)
		return true;
	return false;
}

static int sendfd(int sockfd, int fd) {
	int data;
	struct iovec iov{};
	struct msghdr msgh{};
	struct cmsghdr *cmsgp;

	/* Allocate a char array of suitable size to hold the ancillary data.
	   However, since this buffer is in reality a 'struct cmsghdr', use a
	   union to ensure that it is suitably aligned. */
	union {
		char buf[CMSG_SPACE(sizeof(int))];
		/* Space large enough to hold an 'int' */
		struct cmsghdr align;
	} controlMsg{};

	/* The 'msg_name' field can be used to specify the address of the
	   destination socket when sending a datagram. However, we do not
	   need to use this field because 'sockfd' is a connected socket. */

	msgh.msg_name = nullptr;
	msgh.msg_namelen = 0;

	/* On Linux, we must transmit at least one byte of real data in
	   order to send ancillary data. We transmit an arbitrary integer
	   whose value is ignored by recvfd(). */

	msgh.msg_iov = &iov;
	msgh.msg_iovlen = 1;
	iov.iov_base = &data;
	iov.iov_len = sizeof(int);
	data = 12345;

	/* Set 'msghdr' fields that describe ancillary data */

	msgh.msg_control = controlMsg.buf;
	msgh.msg_controllen = sizeof(controlMsg.buf);

	/* Set up ancillary data describing file descriptor to send */

	cmsgp = reinterpret_cast<cmsghdr *>(msgh.msg_control);
	cmsgp->cmsg_level = SOL_SOCKET;
	cmsgp->cmsg_type = SCM_RIGHTS;
	cmsgp->cmsg_len = CMSG_LEN(sizeof(int));
	memcpy(CMSG_DATA(cmsgp), &fd, sizeof(int));

	/* Send real plus ancillary data */

	if (sendmsg(sockfd, &msgh, 0) == -1) return -1;

	return 0;
}

static int recvfd(int sockfd) {
	int data, fd;
	ssize_t nr;
	struct iovec iov{};
	struct msghdr msgh{};

	/* Allocate a char buffer for the ancillary data. See the comments
	   in sendfd() */
	union {
		char buf[CMSG_SPACE(sizeof(int))];
		struct cmsghdr align;
	} controlMsg{};
	struct cmsghdr *cmsgp;

	/* The 'msg_name' field can be used to obtain the address of the
	   sending socket. However, we do not need this information. */

	msgh.msg_name = nullptr;
	msgh.msg_namelen = 0;

	/* Specify buffer for receiving real data */

	msgh.msg_iov = &iov;
	msgh.msg_iovlen = 1;
	iov.iov_base = &data; /* Real data is an 'int' */
	iov.iov_len = sizeof(int);

	/* Set 'msghdr' fields that describe ancillary data */

	msgh.msg_control = controlMsg.buf;
	msgh.msg_controllen = sizeof(controlMsg.buf);

	/* Receive real plus ancillary data; real data is ignored */

	nr = recvmsg(sockfd, &msgh, 0);
	if (nr == -1) return -1;

	cmsgp = CMSG_FIRSTHDR(&msgh);

	/* Check the validity of the 'cmsghdr' */

	if (cmsgp == nullptr || cmsgp->cmsg_len != CMSG_LEN(sizeof(int)) ||
		cmsgp->cmsg_level != SOL_SOCKET || cmsgp->cmsg_type != SCM_RIGHTS) {
		errno = EINVAL;
		return -1;
	}

	/* Return the received file descriptor to our caller */

	memcpy(&fd, CMSG_DATA(cmsgp), sizeof(int));
	return fd;
}

static int getKernelVersion() {
	struct utsname un{};
	if (uname(&un) != 0) {
		return 0;
	}
	int kmaj = 0, kmin = 0, kpatch = 0;
	sscanf(un.release, "%d.%d.%d", &kmaj, &kmin, &kpatch);
	return KERNEL_VERSION(kmaj, kmin, kpatch);
}

template <typename T>
bool xwrite(int fd, const T& data) {
	uint64_t size = sizeof(T);
	if (write(fd, &size, sizeof(size)) != sizeof(size)) {
		return false;
	}
	if (write(fd, data.data(), size) != static_cast<ssize_t>(size)) {
		return false;
	}
	return true;
}

template<>
bool xwrite<std::string>(int fd, const std::string& data) {
	uint64_t size = data.size();
	if (write(fd, &size, sizeof(size)) != sizeof(size)) {
		return false;
	}
	if (write(fd, data.data(), size) != static_cast<ssize_t>(size)) {
		return false;
	}
	return true;
}

bool xwrite(int fd, const char* data) {
	if (!data) return false;
	return xwrite(fd, std::string(data));
}

template <>
bool xwrite<bool>(int fd, const bool& data) {
	uint64_t size = sizeof(bool);
	if (write(fd, &size, sizeof(size)) != sizeof(size)) {
		return false;
	}
	uint8_t byteData = data ? 1 : 0;
	if (write(fd, &byteData, sizeof(byteData)) != sizeof(byteData)) {
		return false;
	}
	return true;
}

template <>
bool xwrite<uintptr_t>(int fd, const uintptr_t& data) {
	uint64_t size = sizeof(uintptr_t);
	if (write(fd, &size, sizeof(size)) != sizeof(size)) {
		return false;
	}
	if (write(fd, &data, size) != size) {
		return false;
	}
	return true;
}

template <typename T>
std::unique_ptr<T> xread(int fd) {
	uint64_t size = 0;
	if (read(fd, &size, sizeof(size)) != sizeof(size)) {
		return nullptr;
	}
	if (size != sizeof(T)) {
		return nullptr;
	}
	auto data = std::make_unique<T>();
	if (read(fd, data.get(), size) != static_cast<ssize_t>(size)) {
		return nullptr;
	}
	return data;
}

template<>
std::unique_ptr<std::string> xread<std::string>(int fd) {
	uint64_t size = 0;
	if (read(fd, &size, sizeof(size)) != sizeof(size)) {
		return nullptr;
	}
	auto data = std::make_unique<std::string>(size, '\0');
	if (read(fd, data->data(), size) != static_cast<ssize_t>(size)) {
		return nullptr;
	}
	return data;
}

template <>
std::unique_ptr<bool> xread<bool>(int fd) {
	uint64_t size = 0;
	if (read(fd, &size, sizeof(size)) != sizeof(size)) {
		return nullptr;
	}
	if (size != sizeof(bool)) {
		return nullptr;
	}
	uint8_t byteData = 0;
	if (read(fd, &byteData, sizeof(byteData)) != sizeof(byteData)) {
		return nullptr;
	}
	return std::make_unique<bool>(byteData != 0);
}

template <>
std::unique_ptr<uintptr_t> xread<uintptr_t>(int fd) {
	uint64_t size = 0;
	if (read(fd, &size, sizeof(size)) != sizeof(size)) {
		return nullptr;
	}
	if (size != sizeof(uintptr_t)) {
		return nullptr;
	}
	uintptr_t data = 0;
	if (read(fd, &data, size) != size) {
		return nullptr;
	}
	return std::make_unique<uintptr_t>(data);
}

```

`module/src/main/cpp/zygisk.hpp`:

```hpp
/* Copyright 2022-2023 John "topjohnwu" Wu
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

// This is the public API for Zygisk modules.
// DO NOT MODIFY ANY CODE IN THIS HEADER.

#pragma once

#include <jni.h>

#define ZYGISK_API_VERSION 4

/*

***************
* Introduction
***************

On Android, all app processes are forked from a special daemon called "Zygote".
For each new app process, zygote will fork a new process and perform "specialization".
This specialization operation enforces the Android security sandbox on the newly forked
process to make sure that 3rd party application code is only loaded after it is being
restricted within a sandbox.

On Android, there is also this special process called "system_server". This single
process hosts a significant portion of system services, which controls how the
Android operating system and apps interact with each other.

The Zygisk framework provides a way to allow developers to build modules and run custom
code before and after system_server and any app processes' specialization.
This enable developers to inject code and alter the behavior of system_server and app processes.

Please note that modules will only be loaded after zygote has forked the child process.
THIS MEANS ALL OF YOUR CODE RUNS IN THE APP/SYSTEM_SERVER PROCESS, NOT THE ZYGOTE DAEMON!

*********************
* Development Guide
*********************

Define a class and inherit zygisk::ModuleBase to implement the functionality of your module.
Use the macro REGISTER_ZYGISK_MODULE(className) to register that class to Zygisk.

Example code:

static jint (*orig_logger_entry_max)(JNIEnv *env);
static jint my_logger_entry_max(JNIEnv *env) { return orig_logger_entry_max(env); }

class ExampleModule : public zygisk::ModuleBase {
public:
    void onLoad(zygisk::Api *api, JNIEnv *env) override {
        this->api = api;
        this->env = env;
    }
    void preAppSpecialize(zygisk::AppSpecializeArgs *args) override {
        JNINativeMethod methods[] = {
            { "logger_entry_max_payload_native", "()I", (void*) my_logger_entry_max },
        };
        api->hookJniNativeMethods(env, "android/util/Log", methods, 1);
        *(void **) &orig_logger_entry_max = methods[0].fnPtr;
    }
private:
    zygisk::Api *api;
    JNIEnv *env;
};

REGISTER_ZYGISK_MODULE(ExampleModule)

-----------------------------------------------------------------------------------------

Since your module class's code runs with either Zygote's privilege in pre[XXX]Specialize,
or runs in the sandbox of the target process in post[XXX]Specialize, the code in your class
never runs in a true superuser environment.

If your module require access to superuser permissions, you can create and register
a root companion handler function. This function runs in a separate root companion
daemon process, and an Unix domain socket is provided to allow you to perform IPC between
your target process and the root companion process.

Example code:

static void example_handler(int socket) { ... }

REGISTER_ZYGISK_COMPANION(example_handler)

*/

namespace zygisk {

struct Api;
struct AppSpecializeArgs;
struct ServerSpecializeArgs;

class ModuleBase {
public:

    // This method is called as soon as the module is loaded into the target process.
    // A Zygisk API handle will be passed as an argument.
    virtual void onLoad([[maybe_unused]] Api *api, [[maybe_unused]] JNIEnv *env) {}

    // This method is called before the app process is specialized.
    // At this point, the process just got forked from zygote, but no app specific specialization
    // is applied. This means that the process does not have any sandbox restrictions and
    // still runs with the same privilege of zygote.
    //
    // All the arguments that will be sent and used for app specialization is passed as a single
    // AppSpecializeArgs object. You can read and overwrite these arguments to change how the app
    // process will be specialized.
    //
    // If you need to run some operations as superuser, you can call Api::connectCompanion() to
    // get a socket to do IPC calls with a root companion process.
    // See Api::connectCompanion() for more info.
    virtual void preAppSpecialize([[maybe_unused]] AppSpecializeArgs *args) {}

    // This method is called after the app process is specialized.
    // At this point, the process has all sandbox restrictions enabled for this application.
    // This means that this method runs with the same privilege of the app's own code.
    virtual void postAppSpecialize([[maybe_unused]] const AppSpecializeArgs *args) {}

    // This method is called before the system server process is specialized.
    // See preAppSpecialize(args) for more info.
    virtual void preServerSpecialize([[maybe_unused]] ServerSpecializeArgs *args) {}

    // This method is called after the system server process is specialized.
    // At this point, the process runs with the privilege of system_server.
    virtual void postServerSpecialize([[maybe_unused]] const ServerSpecializeArgs *args) {}
};

struct AppSpecializeArgs {
    // Required arguments. These arguments are guaranteed to exist on all Android versions.
    jint &uid;
    jint &gid;
    jintArray &gids;
    jint &runtime_flags;
    jobjectArray &rlimits;
    jint &mount_external;
    jstring &se_info;
    jstring &nice_name;
    jstring &instruction_set;
    jstring &app_data_dir;

    // Optional arguments. Please check whether the pointer is null before de-referencing
    jintArray *const fds_to_ignore;
    jboolean *const is_child_zygote;
    jboolean *const is_top_app;
    jobjectArray *const pkg_data_info_list;
    jobjectArray *const whitelisted_data_info_list;
    jboolean *const mount_data_dirs;
    jboolean *const mount_storage_dirs;

    AppSpecializeArgs() = delete;
};

struct ServerSpecializeArgs {
    jint &uid;
    jint &gid;
    jintArray &gids;
    jint &runtime_flags;
    jlong &permitted_capabilities;
    jlong &effective_capabilities;

    ServerSpecializeArgs() = delete;
};

namespace internal {
struct api_table;
template <class T> void entry_impl(api_table *, JNIEnv *);
}

// These values are used in Api::setOption(Option)
enum Option : int {
    // Force Magisk's denylist unmount routines to run on this process.
    //
    // Setting this option only makes sense in preAppSpecialize.
    // The actual unmounting happens during app process specialization.
    //
    // Set this option to force all Magisk and modules' files to be unmounted from the
    // mount namespace of the process, regardless of the denylist enforcement status.
    FORCE_DENYLIST_UNMOUNT = 0,

    // When this option is set, your module's library will be dlclose-ed after post[XXX]Specialize.
    // Be aware that after dlclose-ing your module, all of your code will be unmapped from memory.
    // YOU MUST NOT ENABLE THIS OPTION AFTER HOOKING ANY FUNCTIONS IN THE PROCESS.
    DLCLOSE_MODULE_LIBRARY = 1,
};

// Bit masks of the return value of Api::getFlags()
enum StateFlag : uint32_t {
    // The user has granted root access to the current process
    PROCESS_GRANTED_ROOT = (1u << 0),

    // The current process was added on the denylist
    PROCESS_ON_DENYLIST = (1u << 1),
};

// All API methods will stop working after post[XXX]Specialize as Zygisk will be unloaded
// from the specialized process afterwards.
struct Api {

    // Connect to a root companion process and get a Unix domain socket for IPC.
    //
    // This API only works in the pre[XXX]Specialize methods due to SELinux restrictions.
    //
    // The pre[XXX]Specialize methods run with the same privilege of zygote.
    // If you would like to do some operations with superuser permissions, register a handler
    // function that would be called in the root process with REGISTER_ZYGISK_COMPANION(func).
    // Another good use case for a companion process is that if you want to share some resources
    // across multiple processes, hold the resources in the companion process and pass it over.
    //
    // The root companion process is ABI aware; that is, when calling this method from a 32-bit
    // process, you will be connected to a 32-bit companion process, and vice versa for 64-bit.
    //
    // Returns a file descriptor to a socket that is connected to the socket passed to your
    // module's companion request handler. Returns -1 if the connection attempt failed.
    int connectCompanion();

    // Get the file descriptor of the root folder of the current module.
    //
    // This API only works in the pre[XXX]Specialize methods.
    // Accessing the directory returned is only possible in the pre[XXX]Specialize methods
    // or in the root companion process (assuming that you sent the fd over the socket).
    // Both restrictions are due to SELinux and UID.
    //
    // Returns -1 if errors occurred.
    int getModuleDir();

    // Set various options for your module.
    // Please note that this method accepts one single option at a time.
    // Check zygisk::Option for the full list of options available.
    void setOption(Option opt);

    // Get information about the current process.
    // Returns bitwise-or'd zygisk::StateFlag values.
    uint32_t getFlags();

    // Exempt the provided file descriptor from being automatically closed.
    //
    // This API only make sense in preAppSpecialize; calling this method in any other situation
    // is either a no-op (returns true) or an error (returns false).
    //
    // When false is returned, the provided file descriptor will eventually be closed by zygote.
    bool exemptFd(int fd);

    // Hook JNI native methods for a class
    //
    // Lookup all registered JNI native methods and replace it with your own methods.
    // The original function pointer will be saved in each JNINativeMethod's fnPtr.
    // If no matching class, method name, or signature is found, that specific JNINativeMethod.fnPtr
    // will be set to nullptr.
    void hookJniNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *methods, int numMethods);

    // Hook functions in the PLT (Procedure Linkage Table) of ELFs loaded in memory.
    //
    // Parsing /proc/[PID]/maps will give you the memory map of a process. As an example:
    //
    //       <address>       <perms>  <offset>   <dev>  <inode>           <pathname>
    // 56b4346000-56b4347000  r-xp    00002000   fe:00    235       /system/bin/app_process64
    // (More details: https://man7.org/linux/man-pages/man5/proc.5.html)
    //
    // The `dev` and `inode` pair uniquely identifies a file being mapped into memory.
    // For matching ELFs loaded in memory, replace function `symbol` with `newFunc`.
    // If `oldFunc` is not nullptr, the original function pointer will be saved to `oldFunc`.
    void pltHookRegister(dev_t dev, ino_t inode, const char *symbol, void *newFunc, void **oldFunc);

    // Commit all the hooks that was previously registered.
    // Returns false if an error occurred.
    bool pltHookCommit();

private:
    internal::api_table *tbl;
    template <class T> friend void internal::entry_impl(internal::api_table *, JNIEnv *);
};

// Register a class as a Zygisk module

#define REGISTER_ZYGISK_MODULE(clazz) \
void zygisk_module_entry(zygisk::internal::api_table *table, JNIEnv *env) { \
    zygisk::internal::entry_impl<clazz>(table, env);                        \
}

// Register a root companion request handler function for your module
//
// The function runs in a superuser daemon process and handles a root companion request from
// your module running in a target process. The function has to accept an integer value,
// which is a Unix domain socket that is connected to the target process.
// See Api::connectCompanion() for more info.
//
// NOTE: the function can run concurrently on multiple threads.
// Be aware of race conditions if you have globally shared resources.

#define REGISTER_ZYGISK_COMPANION(func) \
void zygisk_companion_entry(int client) { func(client); }

/*********************************************************
 * The following is internal ABI implementation detail.
 * You do not have to understand what it is doing.
 *********************************************************/

namespace internal {

struct module_abi {
    long api_version;
    ModuleBase *impl;

    void (*preAppSpecialize)(ModuleBase *, AppSpecializeArgs *);
    void (*postAppSpecialize)(ModuleBase *, const AppSpecializeArgs *);
    void (*preServerSpecialize)(ModuleBase *, ServerSpecializeArgs *);
    void (*postServerSpecialize)(ModuleBase *, const ServerSpecializeArgs *);

    module_abi(ModuleBase *module) : api_version(ZYGISK_API_VERSION), impl(module) {
        preAppSpecialize = [](auto m, auto args) { m->preAppSpecialize(args); };
        postAppSpecialize = [](auto m, auto args) { m->postAppSpecialize(args); };
        preServerSpecialize = [](auto m, auto args) { m->preServerSpecialize(args); };
        postServerSpecialize = [](auto m, auto args) { m->postServerSpecialize(args); };
    }
};

struct api_table {
    // Base
    void *impl;
    bool (*registerModule)(api_table *, module_abi *);

    void (*hookJniNativeMethods)(JNIEnv *, const char *, JNINativeMethod *, int);
    void (*pltHookRegister)(dev_t, ino_t, const char *, void *, void **);
    bool (*exemptFd)(int);
    bool (*pltHookCommit)();
    int  (*connectCompanion)(void * /* impl */);
    void (*setOption)(void * /* impl */, Option);
    int  (*getModuleDir)(void * /* impl */);
    uint32_t (*getFlags)(void * /* impl */);
};

template <class T>
void entry_impl(api_table *table, JNIEnv *env) {
    static Api api;
    api.tbl = table;
    static T module;
    ModuleBase *m = &module;
    static module_abi abi(m);
    if (!table->registerModule(table, &abi)) return;
    m->onLoad(&api, env);
}

} // namespace internal

inline int Api::connectCompanion() {
    return tbl->connectCompanion ? tbl->connectCompanion(tbl->impl) : -1;
}
inline int Api::getModuleDir() {
    return tbl->getModuleDir ? tbl->getModuleDir(tbl->impl) : -1;
}
inline void Api::setOption(Option opt) {
    if (tbl->setOption) tbl->setOption(tbl->impl, opt);
}
inline uint32_t Api::getFlags() {
    return tbl->getFlags ? tbl->getFlags(tbl->impl) : 0;
}
inline bool Api::exemptFd(int fd) {
    return tbl->exemptFd != nullptr && tbl->exemptFd(fd);
}
inline void Api::hookJniNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *methods, int numMethods) {
    if (tbl->hookJniNativeMethods) tbl->hookJniNativeMethods(env, className, methods, numMethods);
}
inline void Api::pltHookRegister(dev_t dev, ino_t inode, const char *symbol, void *newFunc, void **oldFunc) {
    if (tbl->pltHookRegister) tbl->pltHookRegister(dev, inode, symbol, newFunc, oldFunc);
}
inline bool Api::pltHookCommit() {
    return tbl->pltHookCommit != nullptr && tbl->pltHookCommit();
}

} // namespace zygisk

extern "C" {

[[gnu::visibility("default"), maybe_unused]]
void zygisk_module_entry(zygisk::internal::api_table *, JNIEnv *);

[[gnu::visibility("default"), maybe_unused]]
void zygisk_companion_entry(int);

} // extern "C"

```

`module/template/META-INF/com/google/android/update-binary`:

```
#!/sbin/sh

#################
# Initialization
#################

umask 022

# echo before loading util_functions
ui_print() { echo "$1"; }

require_new_magisk() {
  ui_print "*******************************"
  ui_print " Please install Magisk v20.4+! "
  ui_print "*******************************"
  exit 1
}

#########################
# Load util_functions.sh
#########################

OUTFD=$2
ZIPFILE=$3

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk

install_module
exit 0

```

`module/template/META-INF/com/google/android/updater-script`:

```
#MAGISK

```

`module/template/cleanup.sh`:

```sh
# shellcheck disable=SC2016
sed -i "s/^description=.*/description=$(cat /data/adb/modules/zygisk_nohello/description)/" /data/adb/modules/zygisk_nohello/module.prop

```

`module/template/customize.sh`:

```sh
# shellcheck disable=SC2034
SKIPUNZIP=1

DEBUG=@DEBUG@
SONAME=@SONAME@
SUPPORTED_ABIS="@SUPPORTED_ABIS@"

if [ "$BOOTMODE" ] && [ "$KSU" ]; then
  ui_print "- Installing from KernelSU app"
  ui_print "- KernelSU version: $KSU_KERNEL_VER_CODE (kernel) + $KSU_VER_CODE (ksud)"
  if [ "$(which magisk)" ]; then
    ui_print "*********************************************************"
    ui_print "! Multiple root implementation is NOT supported!"
    ui_print "! Please uninstall Magisk before installing Zygisk Next"
    abort    "*********************************************************"
  fi
elif [ "$BOOTMODE" ] && [ "$MAGISK_VER_CODE" ]; then
  ui_print "- Installing from Magisk app"
else
  ui_print "*********************************************************"
  ui_print "! Install from recovery is not supported"
  ui_print "! Please install from KernelSU or Magisk app"
  abort    "*********************************************************"
fi

VERSION=$(grep_prop version "${TMPDIR}/module.prop")
DESCRIPTION=$(grep_prop description "${TMPDIR}/module.prop")
ui_print "- Installing $SONAME $VERSION"

# check architecture
support=false
for abi in $SUPPORTED_ABIS
do
  if [ "$ARCH" == "$abi" ]; then
    support=true
  fi
done
if [ "$support" == "false" ]; then
  abort "! Unsupported platform: $ARCH"
else
  ui_print "- Device platform: $ARCH"
fi

ui_print "- Extracting verify.sh"
unzip -o "$ZIPFILE" 'verify.sh' -d "$TMPDIR" >&2
if [ ! -f "$TMPDIR/verify.sh" ]; then
  ui_print "*********************************************************"
  ui_print "! Unable to extract verify.sh!"
  ui_print "! This zip may be corrupted, please try downloading again"
  abort    "*********************************************************"
fi
. "$TMPDIR/verify.sh"
extract "$ZIPFILE" 'customize.sh'  "$TMPDIR/.vunzip"
extract "$ZIPFILE" 'verify.sh'     "$TMPDIR/.vunzip"
extract "$ZIPFILE" 'sepolicy.rule' "$TMPDIR"

ui_print "- Extracting module files"
extract "$ZIPFILE" 'module.prop'     "$MODPATH"
extract "$ZIPFILE" 'post-fs-data.sh' "$MODPATH"
extract "$ZIPFILE" 'service.sh'      "$MODPATH"
extract "$ZIPFILE" 'cleanup.sh'      "$MODPATH"
echo $DESCRIPTION > $MODPATH/description
mv "$TMPDIR/sepolicy.rule" "$MODPATH"

HAS32BIT=false && ([ $(getprop ro.product.cpu.abilist32) ] || [ $(getprop ro.system.product.cpu.abilist32) ]) && HAS32BIT=true

if [ ! -d "$CONFIG_DIR" ]; then
  ui_print "- Creating configuration directory"
  mkdir -p "$CONFIG_DIR"
fi

mkdir "$MODPATH/zygisk"

if [ "$ARCH" = "x86" ] || [ "$ARCH" = "x64" ]; then
  if [ "$HAS32BIT" = true ]; then
    ui_print "- Extracting x86 libraries"
    extract "$ZIPFILE" "lib/x86/lib$SONAME.so" "$MODPATH/zygisk/" true
    mv "$MODPATH/zygisk/lib$SONAME.so" "$MODPATH/zygisk/x86.so"
  fi

  ui_print "- Extracting x64 libraries"
  extract "$ZIPFILE" "lib/x86_64/lib$SONAME.so" "$MODPATH/zygisk" true
  mv "$MODPATH/zygisk/lib$SONAME.so" "$MODPATH/zygisk/x86_64.so"
else
  if [ "$HAS32BIT" = true ]; then
    extract "$ZIPFILE" "lib/armeabi-v7a/lib$SONAME.so" "$MODPATH/zygisk" true
    mv "$MODPATH/zygisk/lib$SONAME.so" "$MODPATH/zygisk/armeabi-v7a.so"
  fi

  ui_print "- Extracting arm64 libraries"
  extract "$ZIPFILE" "lib/arm64-v8a/lib$SONAME.so" "$MODPATH/zygisk" true
  mv "$MODPATH/zygisk/lib$SONAME.so" "$MODPATH/zygisk/arm64-v8a.so"
fi

set_perm_recursive "$MODPATH" 0 0 0755 0644

mkdir -p /data/adb/nohello
if [ ! -e "/data/adb/nohello/umount" ]; then
  extract "$ZIPFILE" "umount" "/data/adb/nohello"
  touch "/data/adb/nohello/umount_persist"
fi

ui_print "- ${DESCRIPTION}"

```

`module/template/module.prop`:

```prop
id=${moduleId}
name=${moduleName}
version=${versionName}
versionCode=${versionCode}
author=mhmrdd
description=A Zygisk module to hide root.
updateJson=https://mhmrdd.github.io/01000004/zygisk/nohello.json

```

`module/template/post-fs-data.sh`:

```sh
#!/system/bin/sh
# shellcheck disable=SC2034
MODDIR=${0%/*}

MODULE_MIN_MAGISK_VERSION=27005

MODULE_MIN_ZYGISKSU_VERSION=497
MODULE_MIN_REZYGISK_VERSION=361

HAS_ZYGISKSU=false
HAS_REZYGISK=false

rm -f /data/adb/nohello/no_clr_ptracemsg

if [ -d "/data/adb/modules/zygisksu" ]; then
  if [ ! -f "/data/adb/modules/zygisksu/disable" ]; then
    HAS_ZYGISKSU=true
    ZYGISKSU_VERSION=$(grep versionCode /data/adb/modules/zygisksu/module.prop | sed 's/versionCode=//g')
    if [ -z "$ZYGISKSU_VERSION" ]; then
      touch "$MODDIR/disable"
    elif [ "$ZYGISKSU_VERSION" -lt "$MODULE_MIN_ZYGISKSU_VERSION" ]; then
      touch "$MODDIR/disable"
    elif [ "$ZYGISKSU_VERSION" -ge 521 ]; then
      touch /data/adb/nohello/no_clr_ptracemsg
      touch /data/adb/nohello/no_dirtyro_ar
    fi
  fi
fi

if [ -d "/data/adb/modules/rezygisk" ]; then
  if [ ! -f "/data/adb/modules/rezygisk/disable" ]; then
    HAS_REZYGISK=true
    REZYGISK_VERSION=$(grep versionCode /data/adb/modules/rezygisk/module.prop | sed 's/versionCode=//g')
    if [ -z "$REZYGISK_VERSION" ]; then
      touch "$MODDIR/disable"
    elif [ "$REZYGISK_VERSION" -lt "$MODULE_MIN_REZYGISK_VERSION" ]; then
      touch "$MODDIR/disable"
    elif [ "$REZYGISK_VERSION" -ge 362 ]; then
      touch /data/adb/nohello/no_clr_ptracemsg
    fi
  fi
fi

if [ "$HAS_ZYGISKSU" = true ] && [ "$HAS_REZYGISK" = true ]; then
  touch "$MODDIR/disable"
fi

if [ "$HAS_ZYGISKSU" = false ] && [ "$HAS_REZYGISK" = false ]; then
  MAGISK_VERSION="$(magisk -V)"
  if [ -z "$MAGISK_VERSION" ]; then
    touch "$MODDIR/disable"
  elif [ "$MAGISK_VERSION" -lt "$MODULE_MIN_MAGISK_VERSION" ]; then
    touch "$MODDIR/disable"
  fi
fi

if [ ! -f /data/adb/post-fs-data.d/.nohello_cleanup.sh ]; then
  mkdir -p /data/adb/post-fs-data.d
  cat "$MODDIR/cleanup.sh" > /data/adb/post-fs-data.d/.nohello_cleanup.sh
  chmod +x /data/adb/post-fs-data.d/.nohello_cleanup.sh
fi

```

`module/template/sepolicy.rule`:

```rule
allow zygote adb_data_file dir search

```

`module/template/service.sh`:

```sh
#!/system/bin/sh
DEBUG=@DEBUG@

MODDIR=${0%/*}

check_reset_prop() {
  local NAME=$1
  local EXPECTED=$2
  local VALUE=$(resetprop $NAME)
  [ -z $VALUE ] || [ $VALUE = $EXPECTED ] || resetprop $NAME $EXPECTED
}

contains_reset_prop() {
  local NAME=$1
  local CONTAINS=$2
  local NEWVAL=$3
  [[ "$(resetprop $NAME)" = *"$CONTAINS"* ]] && resetprop $NAME $NEWVAL
}

resetprop -w sys.boot_completed 0

check_reset_prop "ro.boot.vbmeta.device_state" "locked"
check_reset_prop "ro.boot.verifiedbootstate" "green"
check_reset_prop "ro.boot.flash.locked" "1"
check_reset_prop "ro.boot.veritymode" "enforcing"
check_reset_prop "ro.boot.warranty_bit" "0"
check_reset_prop "ro.warranty_bit" "0"
check_reset_prop "ro.debuggable" "0"
check_reset_prop "ro.force.debuggable" "0"
check_reset_prop "ro.secure" "1"
check_reset_prop "ro.adb.secure" "1"
check_reset_prop "ro.build.type" "user"
check_reset_prop "ro.build.tags" "release-keys"
check_reset_prop "ro.vendor.boot.warranty_bit" "0"
check_reset_prop "ro.vendor.warranty_bit" "0"
check_reset_prop "vendor.boot.vbmeta.device_state" "locked"
check_reset_prop "vendor.boot.verifiedbootstate" "green"
check_reset_prop "sys.oem_unlock_allowed" "0"

# MIUI specific
check_reset_prop "ro.secureboot.lockstate" "locked"

# Realme specific
check_reset_prop "ro.boot.realmebootstate" "green"
check_reset_prop "ro.boot.realme.lockstate" "1"

# Hide that we booted from recovery when magisk is in recovery mode
contains_reset_prop "ro.bootmode" "recovery" "unknown"
contains_reset_prop "ro.boot.bootmode" "recovery" "unknown"
contains_reset_prop "vendor.boot.bootmode" "recovery" "unknown"

```

`module/template/umount`:

```
source { "KSU", "APatch", "magisk", "worker" } fs { "tmpfs" "overlay" }
point { "/system/etc/hosts" }


```

`module/template/uninstall.sh`:

```sh

rm -rf /data/adb/post-fs-data.d/.nohello_cleanup.sh
rm -rf /data/adb/nohello

```

`module/template/verify.sh`:

```sh
TMPDIR_FOR_VERIFY="$TMPDIR/.vunzip"
mkdir "$TMPDIR_FOR_VERIFY"

abort_verify() {
  ui_print "*********************************************************"
  ui_print "! $1"
  ui_print "! This zip may be corrupted, please try downloading again"
  abort    "*********************************************************"
}

# extract <zip> <file> <target dir> <junk paths>
extract() {
  zip=$1
  file=$2
  dir=$3
  junk_paths=$4
  [ -z "$junk_paths" ] && junk_paths=false
  opts="-o"
  [ $junk_paths = true ] && opts="-oj"

  file_path=""
  hash_path=""
  if [ $junk_paths = true ]; then
    file_path="$dir/$(basename "$file")"
    hash_path="$TMPDIR_FOR_VERIFY/$(basename "$file").sha256"
  else
    file_path="$dir/$file"
    hash_path="$TMPDIR_FOR_VERIFY/$file.sha256"
  fi

  unzip $opts "$zip" "$file" -d "$dir" >&2
  [ -f "$file_path" ] || abort_verify "$file not exists"

  unzip $opts "$zip" "$file.sha256" -d "$TMPDIR_FOR_VERIFY" >&2
  [ -f "$hash_path" ] || abort_verify "$file.sha256 not exists"

  (echo "$(cat "$hash_path")  $file_path" | sha256sum -c -s -) || abort_verify "Failed to verify $file"
  ui_print "- Verified $file" >&1
}

file="META-INF/com/google/android/update-binary"
file_path="$TMPDIR_FOR_VERIFY/$file"
hash_path="$file_path.sha256"
unzip -o "$ZIPFILE" "META-INF/com/google/android/*" -d "$TMPDIR_FOR_VERIFY" >&2
[ -f "$file_path" ] || abort_verify "$file not exists"
if [ -f "$hash_path" ]; then
  (echo "$(cat "$hash_path")  $file_path" | sha256sum -c -s -) || abort_verify "Failed to verify $file"
  ui_print "- Verified $file" >&1
else
  ui_print "- Download from Magisk app"
fi

```

`settings.gradle.kts`:

```kts
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "NoHello"
include(
    ":module"
)

```