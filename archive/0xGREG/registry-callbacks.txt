Project Path: arc_0xGREG_registry-callbacks_a1rm5w0r

Source Tree:

```txt
arc_0xGREG_registry-callbacks_a1rm5w0r
├── KernelMode
│   ├── Driver.c
│   ├── Driver.h
│   ├── KernelMode.inf
│   ├── KernelMode.vcxproj
│   ├── KernelMode.vcxproj.filters
│   ├── KernelMode.vcxproj.user
│   └── ntos.h
├── README.md
├── RegistryCallbacks.sln
└── UserMode
    ├── Memory.h
    ├── Offsets.h
    ├── UserMode.cpp
    ├── UserMode.vcxproj
    ├── UserMode.vcxproj.filters
    └── UserMode.vcxproj.user

```

`KernelMode/Driver.c`:

```c
#include "Driver.h"

LARGE_INTEGER CmCookie = { 0x115 };
UNICODE_STRING MonitoredKey;

NTSTATUS DriverEntry(PDRIVER_OBJECT _0, PUNICODE_STRING _1) {
	PVOID classpnp = GetModuleBase(L"classpnp.sys");

	if (classpnp == NULL)
		return STATUS_INVALID_HANDLE;

	PVOID jmp = FindJmp(classpnp);

	if (jmp == NULL)
		return STATUS_NOT_FOUND;

	RtlInitUnicodeString(&MonitoredKey, L"DisableAntiSpyware");

	return CmRegisterCallback((PEX_CALLBACK_FUNCTION)jmp, (PVOID)&RegistryCallback, &CmCookie);
}

NTSTATUS RegistryCallback(PVOID callbackContext, PVOID arg1, PVOID arg2) {
	UNREFERENCED_PARAMETER(callbackContext);

	if ((REG_NOTIFY_CLASS)arg1 != RegNtPostSetValueKey)
		return STATUS_SUCCESS;

	PREG_POST_OPERATION_INFORMATION postInfo = (PREG_POST_OPERATION_INFORMATION)arg2;

	PREG_SET_VALUE_KEY_INFORMATION preInfo = (PREG_SET_VALUE_KEY_INFORMATION)postInfo->PreInformation;

	if (preInfo->DataSize != 0x8)
		return STATUS_SUCCESS;

	if (!RtlEqualUnicodeString((PCUNICODE_STRING)preInfo->ValueName, (PCUNICODE_STRING)&MonitoredKey, TRUE))
		return STATUS_SUCCESS;

	PKERNEL_REQUEST Data = *(PKERNEL_REQUEST*)preInfo->Data;

	if (Data->Type == 0)
		ReadVirtualMemory(Data->Instruction);
	else if (Data->Type == 1)
		WriteVirtualMemory(Data->Instruction);
	else if (Data->Type == 2)
		WriteProtectedVirtualMemory(Data->Instruction);
	else if (Data->Type == 3)
		GetProcessBaseAddress(Data->Instruction);
	else if (Data->Type == 4)
		IsRunning(Data->Instruction);

	return STATUS_SUCCESS;
}

PVOID GetModuleBase(LPCWSTR moduleName) {
	PLIST_ENTRY _PsLoadedModuleList = (PLIST_ENTRY)PsLoadedModuleList;

	if (!_PsLoadedModuleList)
		return (PVOID)NULL;

	UNICODE_STRING name;
	RtlInitUnicodeString(&name, moduleName);

	for (PLIST_ENTRY link = _PsLoadedModuleList; link != _PsLoadedModuleList->Blink; link = link->Flink)
	{
		PLDR_DATA_TABLE_ENTRY entry = CONTAINING_RECORD(link, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

		if (RtlEqualUnicodeString((PCUNICODE_STRING)&entry->BaseDllName, (PCUNICODE_STRING)&name, TRUE)) {
			return (PVOID)entry->DllBase;
		}
	}

	return (PVOID)NULL;
}

PVOID FindJmp(PVOID moduleBase) {
	CONST PIMAGE_NT_HEADERS ntHeader = RtlImageNtHeader(moduleBase);

	CONST PIMAGE_SECTION_HEADER firstSection = IMAGE_FIRST_SECTION(ntHeader);

	for (PIMAGE_SECTION_HEADER section = firstSection; section < firstSection + ntHeader->FileHeader.NumberOfSections; section++)
	{
		if (!section)
			continue;

		if (!(section->Characteristics & 0x20000000) || !(section->Characteristics & 0x08000000))
			continue;

		CONST UINT64 sectionStart = (UINT64)moduleBase + section->VirtualAddress;
		CONST UINT64 sectionSize = section->SizeOfRawData;

		for (UINT64 current = sectionStart; current < (sectionStart + sectionSize); current++)
		{
			if (*(USHORT*)current == 0xe1ff) // jmp ecx: FF E1
				return (PVOID)current;
		}
	}

	return (PVOID)NULL;
}

NTSTATUS ReadVirtualMemory(PKERNEL_COPY_REQUEST req) {
	PEPROCESS process;

	NTSTATUS status = PsLookupProcessByProcessId(req->ProcessId, &process);

	if (!NT_SUCCESS(status))
		return status;

	SIZE_T bytes;

	status = MmCopyVirtualMemory(process, req->Source, PsGetCurrentProcess(), req->Destination, req->Size, UserMode, &bytes);

	ObDereferenceObject(process);

	return status;
}

NTSTATUS WriteVirtualMemory(PKERNEL_COPY_REQUEST req) {
	PEPROCESS process;

	NTSTATUS status = PsLookupProcessByProcessId(req->ProcessId, &process);

	if (!NT_SUCCESS(status))
		return status;

	SIZE_T bytes;

	status = MmCopyVirtualMemory(PsGetCurrentProcess(), req->Source, process, req->Destination, req->Size, UserMode, &bytes);

	ObDereferenceObject(process);

	return status;
}

NTSTATUS WriteProtectedVirtualMemory(PKERNEL_COPY_REQUEST req) {
	PEPROCESS pProcess;

	NTSTATUS status = PsLookupProcessByProcessId(req->ProcessId, &pProcess);

	if (!NT_SUCCESS(status))
		return status;

	NTSTATUS Status = STATUS_INVALID_ADDRESS;
	KAPC_STATE APC;

	PVOID Address = (PVOID)req->Destination;
	PVOID ProtectedAddress = (PVOID)req->Destination;
	SIZE_T Size = req->Size;
	SIZE_T ProtectedSize = req->Size;

	PVOID* Buffer = (PVOID*)ExAllocatePool(NonPagedPool, Size);
	if (Buffer == NULL) {
		return STATUS_MEMORY_NOT_ALLOCATED;
	}

	RtlSecureZeroMemory(Buffer, Size);

	__try {
		memcpy(Buffer, req->Source, Size);

		KeStackAttachProcess(pProcess, &APC);

		ULONG OldProtection;
		Status = ZwProtectVirtualMemory(ZwCurrentProcess(), &ProtectedAddress, &ProtectedSize, PAGE_EXECUTE_READWRITE, &OldProtection);
		if (!NT_SUCCESS(Status)) {
			KeUnstackDetachProcess(&APC);

			ExFreePool(Buffer);

			return Status;
		}

		ProtectedAddress = Address;
		ProtectedSize = Size;

		MEMORY_BASIC_INFORMATION info;
		Status = ZwQueryVirtualMemory(ZwCurrentProcess(), Address, MemoryBasicInformation, &info, sizeof(MEMORY_BASIC_INFORMATION), NULL);
		if (!NT_SUCCESS(Status)) {
			KeUnstackDetachProcess(&APC);

			ExFreePool(Buffer);

			return Status;
		}

		if (!(info.State & MEM_COMMIT)) {
			ZwProtectVirtualMemory(ZwCurrentProcess(), &ProtectedAddress, &ProtectedSize, OldProtection, &OldProtection);

			KeUnstackDetachProcess(&APC);

			ExFreePool(Buffer);

			Status = STATUS_ACCESS_DENIED;

			return Status;
		}

		memcpy(Address, Buffer, Size);

		ZwProtectVirtualMemory(ZwCurrentProcess(), &ProtectedAddress, &ProtectedSize, OldProtection, &OldProtection);

		KeUnstackDetachProcess(&APC);

		Status = STATUS_SUCCESS;
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		KeUnstackDetachProcess(&APC);
	}

	ExFreePool(Buffer);

	return Status;
}

NTSTATUS GetProcessBaseAddress(PKERNEL_BASE_REQUEST req) {
	PEPROCESS process;

	NTSTATUS status = PsLookupProcessByProcessId(req->ProcessId, &process);

	if (!NT_SUCCESS(status))
		return status;

	req->ProcessBase = (UINT64)PsGetProcessSectionBaseAddress(process);

	return STATUS_SUCCESS;
}

NTSTATUS IsRunning(PKERNEL_RUNNING_REQUEST req) {
	req->Running = 0x1337;

	return STATUS_SUCCESS;	
}
```

`KernelMode/Driver.h`:

```h
#pragma once
#include "ntos.h"
#include <ntddk.h>
#include <windef.h>

typedef struct _KERNEL_COPY_REQUEST {
	ULONG ProcessId;
	PVOID Destination;
	PVOID Source;
	SIZE_T Size;
} KERNEL_COPY_REQUEST, *PKERNEL_COPY_REQUEST;

typedef struct _KERNEL_BASE_REQUEST {
	ULONG ProcessId;
	UINT64 ProcessBase;
} KERNEL_BASE_REQUEST, *PKERNEL_BASE_REQUEST;

typedef struct _KERNEL_RUNNING_REQUEST {
	UINT32 Running;
} KERNEL_RUNNING_REQUEST, *PKERNEL_RUNNING_REQUEST;

typedef struct _KERNEL_REQUEST {
	UINT32 Type;
	PVOID Instruction;
} KERNEL_REQUEST, *PKERNEL_REQUEST;

NTSTATUS DriverEntry(PDRIVER_OBJECT _0, PUNICODE_STRING _1);
NTSTATUS RegistryCallback(PVOID callbackContext, PVOID arg1, PVOID arg2);
PVOID GetModuleBase(LPCWSTR moduleName);
PVOID FindJmp(PVOID moduleBase);
NTSTATUS ReadVirtualMemory(PKERNEL_COPY_REQUEST req);
NTSTATUS WriteVirtualMemory(PKERNEL_COPY_REQUEST req);
NTSTATUS WriteProtectedVirtualMemory(PKERNEL_COPY_REQUEST req);
NTSTATUS GetProcessBaseAddress(PKERNEL_BASE_REQUEST req);
NTSTATUS IsRunning(PKERNEL_RUNNING_REQUEST req);
```

`KernelMode/KernelMode.inf`:

```inf
;
; KernelMode.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=KernelMode.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
KernelMode_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
KernelMode.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%KernelMode.DeviceDesc%=KernelMode_Device, Root\KernelMode ; TODO: edit hw-id

[KernelMode_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
KernelMode.sys

;-------------- Service installation
[KernelMode_Device.NT.Services]
AddService = KernelMode,%SPSVCINST_ASSOCSERVICE%, KernelMode_Service_Inst

; -------------- KernelMode driver install sections
[KernelMode_Service_Inst]
DisplayName    = %KernelMode.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\KernelMode.sys

;
;--- KernelMode_Device Coinstaller installation ------
;

[KernelMode_Device.NT.CoInstallers]
AddReg=KernelMode_Device_CoInstaller_AddReg
CopyFiles=KernelMode_Device_CoInstaller_CopyFiles

[KernelMode_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[KernelMode_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[KernelMode_Device.NT.Wdf]
KmdfService =  KernelMode, KernelMode_wdfsect
[KernelMode_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "KernelMode Installation Disk"
KernelMode.DeviceDesc = "KernelMode Device"
KernelMode.SVCDESC = "KernelMode Service"

```

`KernelMode/KernelMode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C9029E31-A58A-409F-A628-0752AECE67FF}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>KernelMode</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="KernelMode.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver.h" />
    <ClInclude Include="ntos.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KernelMode/KernelMode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="KernelMode.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntos.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KernelMode/KernelMode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`README.md`:

```md
# Registry Callbacks

## Introduction

This was my first attempt writing kernel code and communicating with the kernel, trying to hide it from BattlEye.

The communication method lets you manual map the driver because it registers the callback in a legit module.

Old code, badly written, should only be used for reference.

## Credits

[yousif](https://github.com/haram) - showing the `jmp ecx` trick
```

`RegistryCallbacks.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.902
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KernelMode", "KernelMode\KernelMode.vcxproj", "{C9029E31-A58A-409F-A628-0752AECE67FF}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UserMode", "UserMode\UserMode.vcxproj", "{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|ARM.ActiveCfg = Debug|ARM
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|ARM.Build.0 = Debug|ARM
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|ARM.Deploy.0 = Debug|ARM
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|ARM64.Build.0 = Debug|ARM64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|x64.ActiveCfg = Debug|x64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|x64.Build.0 = Debug|x64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|x64.Deploy.0 = Debug|x64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|x86.ActiveCfg = Debug|Win32
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|x86.Build.0 = Debug|Win32
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Debug|x86.Deploy.0 = Debug|Win32
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|ARM.ActiveCfg = Release|ARM
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|ARM.Build.0 = Release|ARM
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|ARM.Deploy.0 = Release|ARM
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|ARM64.ActiveCfg = Release|ARM64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|ARM64.Build.0 = Release|ARM64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|ARM64.Deploy.0 = Release|ARM64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|x64.ActiveCfg = Release|x64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|x64.Build.0 = Release|x64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|x64.Deploy.0 = Release|x64
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|x86.ActiveCfg = Release|Win32
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|x86.Build.0 = Release|Win32
		{C9029E31-A58A-409F-A628-0752AECE67FF}.Release|x86.Deploy.0 = Release|Win32
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Debug|ARM.ActiveCfg = Debug|Win32
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Debug|ARM64.ActiveCfg = Debug|Win32
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Debug|x64.ActiveCfg = Debug|x64
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Debug|x64.Build.0 = Debug|x64
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Debug|x86.ActiveCfg = Debug|Win32
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Debug|x86.Build.0 = Debug|Win32
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Release|ARM.ActiveCfg = Release|Win32
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Release|ARM64.ActiveCfg = Release|Win32
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Release|x64.ActiveCfg = Release|x64
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Release|x64.Build.0 = Release|x64
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Release|x86.ActiveCfg = Release|Win32
		{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6DA4D29C-C48E-4E85-A176-2154DC606A4C}
	EndGlobalSection
EndGlobal

```

`UserMode/Memory.h`:

```h
#pragma once
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>

using namespace std;

typedef struct _KERNEL_COPY_REQUEST {
	ULONG ProcessId;
	PVOID Destination;
	PVOID Source;
	SIZE_T Size;
} KERNEL_COPY_REQUEST, *PKERNEL_COPY_REQUEST;

typedef struct _KERNEL_BASE_REQUEST {
	ULONG ProcessId;
	UINT64 ProcessBase;
} KERNEL_BASE_REQUEST, *PKERNEL_BASE_REQUEST;

typedef struct _KERNEL_RUNNING_REQUEST {
	UINT32 Running;
} KERNEL_RUNNING_REQUEST, *PKERNEL_RUNNING_REQUEST;

typedef struct _KERNEL_REQUEST {
	UINT32 Type;
	PVOID Instruction;
} KERNEL_REQUEST, *PKERNEL_REQUEST;

class Memory {
public:
	void WriteRegistry(uint32_t type, void* instruction) {
		HKEY hKey = NULL;

		RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Clipboard", 0, KEY_ALL_ACCESS, &hKey);

		if (hKey == NULL || hKey == INVALID_HANDLE_VALUE) {
			cout << "Registry error\n";
			return;
		}

		KERNEL_REQUEST request;

		request.Type = type;
		request.Instruction = instruction;

		void* pointer = &request;

		RegSetValueExA(hKey, "DisableAntiSpyware", 0, REG_QWORD, reinterpret_cast<BYTE*>(&pointer), sizeof(uint64_t));

		RegCloseKey(hKey);
	}

	template<typename T>
	T ReadMemory(uint64_t address) {
		T result{};

		KERNEL_COPY_REQUEST request;

		request.ProcessId = ProcessId;
		request.Source = reinterpret_cast<void*>(address);
		request.Destination = &result;
		request.Size = sizeof(T);

		WriteRegistry(0, &request);

		return result;
	}

	void WriteMemory(uint64_t address, void* value, size_t size) {
		KERNEL_COPY_REQUEST request;

		request.ProcessId = ProcessId;
		request.Source = value;
		request.Destination = reinterpret_cast<void*>(address);
		request.Size = size;

		WriteRegistry(1, &request);
	}

	template<typename T>
	void WriteMemory(uint64_t address, T value) {
		WriteMemory(address, &value, sizeof(T));
	}

	void WriteProtectedMemory(uint64_t address, void* value, size_t size) {
		KERNEL_COPY_REQUEST request;

		request.ProcessId = ProcessId;
		request.Source = value;
		request.Destination = reinterpret_cast<void*>(address);
		request.Size = size;

		WriteRegistry(2, &request);
	}

	uint64_t GetProcessBase() {
		KERNEL_BASE_REQUEST request;

		request.ProcessId = ProcessId;
		request.ProcessBase = 0;

		WriteRegistry(3, &request);

		return request.ProcessBase;
	}

	bool IsRunning() {
		KERNEL_RUNNING_REQUEST request;

		request.Running = 0;

		WriteRegistry(4, &request);

		return request.Running == 0x1337;
	}

	void AttachProcess(string processName) {
		const wstring wProcessName(processName.begin(), processName.end());

		PROCESSENTRY32 processInfo;
		processInfo.dwSize = sizeof(processInfo);

		HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
		if (processesSnapshot == INVALID_HANDLE_VALUE)
			return;

		Process32First(processesSnapshot, &processInfo);
		if (!wProcessName.compare(processInfo.szExeFile))
		{
			CloseHandle(processesSnapshot);
			ProcessId = processInfo.th32ProcessID;
			return;
		}

		while (Process32Next(processesSnapshot, &processInfo))
		{
			if (!wProcessName.compare(processInfo.szExeFile))
			{
				CloseHandle(processesSnapshot);
				ProcessId = processInfo.th32ProcessID;
				return;
			}
		}

		CloseHandle(processesSnapshot);
		return;
	}
private:
	ULONG ProcessId;
};
```

`UserMode/Offsets.h`:

```h
#pragma once
#define ADDRESS_GAMEMANAGER 0x5306348
#define ADDRESS_ROUNDMANAGER 0x52f5bf8
#define ADDRESS_VTABLE 0x395ba68
#define ADDRESS_UNLOCKALL 0x1138490

#define OFFSET_UNLOCKALL_JNE 0x23c
#define OFFSET_UNLOCKALL_ENABLE 0x259

#define OFFSET_GAMEMANAGER_ENTITYLIST 0x1c8
#define OFFSET_ROUNDMANAGER_STATE 0x2e8
#define OFFSET_ENTITY_ENTITYINFO 0x28
#define OFFSET_ENTITYINFO_MAINCOMPONENT 0xd8
#define OFFSET_MAINCOMPONENT_ESPCHAIN 0x70
#define OFFSET_ESPCHAIN_SPOTTED 0x534

/*

-- Signatures --

gamemanager: 48 8b 05 ? ? ? ? 8b 8e
roundmanager: 48 8b 0d ? ? ? ? e8 ? ? ? ? 83 bb
vtable: 4c 8d 0d ? ? ? ? 48 ? ? ? 48 8d 8b ? ? ? ? 4c ? ? 48 8d ? ? ? ? ? e8
unlock all: E8 ? ? ? ? 48 85 F6 74 ? 48 8B CB E8 ? ? ? ? 48 8B 5C 24 ? 48 8B 6C 24 ? 48 83 C4 ? 41 5E 5F 5E C3
*/
```

`UserMode/UserMode.cpp`:

```cpp
#include <iostream>
#include <thread>
#include "Memory.h"
#include "Offsets.h"

Memory Interface;
uint64_t ProcessBase;

int main()
{
	if (Interface.IsRunning())
		cout << "[Kernel driver loaded]\n";
	else
		cout << "[Kernel driver not loaded]\n";

	cout << "Press [F10] when game loaded into menu...\n";

	while (true)
	{
		if (GetAsyncKeyState(VK_F10))
			break;

		this_thread::sleep_for(20ms);
	}

	Interface.AttachProcess("RainbowSix.exe");

	ProcessBase = Interface.GetProcessBase();

	system("cls");

	cout << "Running!\n";

	// Patch terminateprocess

	uint64_t terminateProcess = (uint64_t)GetProcAddress(GetModuleHandleA("kernel32.dll"), "TerminateProcess");

	uint8_t patch[] = { 0xC3 };

	Interface.WriteProtectedMemory(terminateProcess, patch, sizeof(patch));

	// Patch unlockall

	const uint8_t patch1[] = { 0x19 };
	const uint8_t patch2[] = { 0x0 };

	Interface.WriteProtectedMemory(ProcessBase + ADDRESS_UNLOCKALL + OFFSET_UNLOCKALL_JNE, const_cast<uint8_t*>(patch1), sizeof(patch1));
	Interface.WriteProtectedMemory(ProcessBase + ADDRESS_UNLOCKALL + OFFSET_UNLOCKALL_ENABLE, const_cast<uint8_t*>(patch2), sizeof(patch2));
	
	// ESP

	const uint8_t spotted = 1;

	while (true)
	{
		uint64_t roundManager = Interface.ReadMemory<uint64_t>(ProcessBase + ADDRESS_ROUNDMANAGER);

		int state = Interface.ReadMemory<int>(roundManager + OFFSET_ROUNDMANAGER_STATE);

		if (state == 2 || state == 3) {
			uint64_t gameManager = Interface.ReadMemory<uint64_t>(ProcessBase + ADDRESS_GAMEMANAGER);

			uint64_t entityList = Interface.ReadMemory<uint64_t>(ProcessBase + OFFSET_GAMEMANAGER_ENTITYLIST);

			for (size_t i = 0; i < 16; i++)
			{
				uint64_t entity = Interface.ReadMemory<uint64_t>(entityList + (0x8 * i));

				if (entity == 0)
					continue;

				uint64_t entityInfo = Interface.ReadMemory<uint64_t>(entity + OFFSET_ENTITY_ENTITYINFO);
				uint64_t mainComponent = Interface.ReadMemory<uint64_t>(entityInfo + OFFSET_ENTITYINFO_MAINCOMPONENT);

				for (size_t ii = 0; ii < 30; ii++)
				{
					uint64_t espBase = Interface.ReadMemory<uint64_t>(mainComponent + OFFSET_MAINCOMPONENT_ESPCHAIN + (ii * 0x8));

					uint64_t check = Interface.ReadMemory<uint64_t>(espBase + 0x0) - ProcessBase;

					if (check != ADDRESS_VTABLE)
						continue;

					Interface.WriteMemory(espBase + OFFSET_ESPCHAIN_SPOTTED, spotted);

					break;
				}
			}
		}
	}
}
```

`UserMode/UserMode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{F5206841-B5DD-4492-9A8E-F7A1BE5F6A00}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>UserMode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="UserMode.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Memory.h" />
    <ClInclude Include="Offsets.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UserMode/UserMode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UserMode.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`UserMode/UserMode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```