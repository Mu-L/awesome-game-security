Project Path: arc_canyie_Riru-MomoHider__tw6ynb7

Source Tree:

```txt
arc_canyie_Riru-MomoHider__tw6ynb7
├── README.md
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── module
│   ├── build.gradle
│   ├── proguard-rules.pro
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           └── cpp
│               ├── CMakeLists.txt
│               ├── external
│               │   ├── magisk
│               │   │   ├── hide_policy.cpp
│               │   │   └── magiskhide.h
│               │   └── riru
│               │       └── riru.h
│               ├── log.h
│               └── main.cpp
├── settings.gradle
└── template
    ├── META-INF
    │   └── com
    │       └── google
    │           └── android
    │               ├── update-binary
    │               └── updater-script
    ├── customize.sh
    ├── post-fs-data.sh
    ├── sepolicy.rule
    ├── service.sh
    └── uninstall.sh

```

`README.md`:

```md
# Riru - MomoHider (aka IsolatedMagiskHider)
## Deprecation Notice
Hi, today is 2022/2/1, happy Chinese new year! 

One year ago, I made this project because my bank app detected the device is rooted and reject to run. Initially I just want to help others so I made this public. But in the past year, things are not going the way I want -- someone just downloads my module, changes the author and claim it's their work; more seriously, my module with unknown changes was built into a cheat program. Finally my kindness ended up being a tool for outlaws. So, I chose to develop a new hide module "Shamiko" with other developers in the LSPosed team. The new module will only support Zygisk, and provides more functionality than MagiskHide. I believe the module will be the complete solution if you want to use MagiskHide on Magisk v24+! But, To keep things from getting out of hand again, the new module will NOT open source, and rejects any modification. 

We expect to officially release Shamiko on February 2nd. [Click here to download Shamiko.](https://lsposed.github.io/)

## Background
Many applications now detect Magisk for security, Magisk provided "Magisk Hide" to hide the modified traces but not completely hidden, magisk still can be detected by [MagiskDetector](https://github.com/vvb2060/MagiskDetector). This module tries to make it more hidden.

Features:
| Config name | Description |
|  ----  | ----  |
| isolated | Apply Magisk Hide for isolated process and app zygotes. This feature is deprecated because it will unmount Magisk modified files for every isolated processes, and the unmounting time cannot be well controlled, which may cause some modules to not work. For almost apps, [Magisk Alpha](https://github.com/vvb2060/magisk/tree/alpha) or the latest Magisk canary + [Riru-Unshare](https://github.com/vvb2060/riru-unshare) is enough.|
| setns | Faster new way to hide Magisk in isolated processes. Requires config "isolated" is enabled. |
| app_zygote_magic | Make "Momo" (a root detector app) cannot detect Magisk hide is running. |
| initrc | Hide the modified traces of init.rc |

Note: Since 0.0.3, all features are disabled by default, you need to create a file named `/data/adb/(lite_)modules/riru_momohider/config/<config name>` to enable it.

## Requirement
Rooted Android 7.0+ devices with Magisk and [Riru](https://github.com/RikkaApps/Riru) V25+.

## Test
[Momo](https://t.me/s/magiskalpha/517) is the strongest detection app known.

See also: [MagiskKiller](https://github.com/canyie/MagiskKiller) [MagiskDetector](https://github.com/vvb2060/MagiskDetector) [XposedDetector](https://github.com/vvb2060/XposedDetector) [ApplistDetector](https://github.com/Dr-TSNG/ApplistDetector)

I have studied MagiskHide and found some issues. My module cannot deal with them. I suggest you updating Magisk and use other ways to hide root. Staying on an old unsupported Magisk version is meaningless. Stop cheating yourself.

## Troubleshoot
### Find the "config dir"
The really config dir is `$MODULES/riru_momohider/config`. For Magisk-Lite, the `$MODULES` is `/data/adb/lite_modules`; For the original and other forks, the `$MODULES` is `/data/adb/modules`.

If the module doesn't work, please check the config dir first. You should see a file called magisk_tmp under the config dir.

### Momo shows "environment is broken, service not responding"
Please check your "overlay modules" first. Iterate through $MODULES and check each of its subfolders. For overlay modules, you should see `system/vendor/overlay` or `system/product/overlay` under it.

If you can't find any overlay modules, please go to the "without overlay modules" section.
#### With overlay modules
1. Check your android version. For Android < 10, [Magisk Alpha](https://github.com/vvb2060/magisk/tree/alpha) or the latest Magisk canary + [Riru-Unshare](https://github.com/vvb2060/riru-unshare) is almost enough. After installing the recommended things, you can turn off `isolated` and try again.
2. Disable overlay modules if possible. Or, we can't support this case yet.
3. Try again. If the problem not solved, please try the "without overlay modules" section.

Note: We needs more info to try to support overlay modules, please file a issue with the full log and stacktrace to help me to solve it even if you have solved the problem.

#### Without overlay modules
1. Turn on `setns` and try again.
2. If the problem not solved, please file a bug with your device info and full log.

### Momo still shows "environment is modified"
MomoHider only hide "MagiskHide is enabled", "Found su file", "Found Magisk" and "init.rc is modified" for momo. If you not see these, this is not our problem, please hide it yourself.

But if you see these after enabling these features... please check the following steps:
1. Try run `magiskhide exec which su`, if you see something found, this usually indicates that there are other superuser programs in your system that cause magiskhide not work properly. Please remove other superuser programs.
2. Try installing [MagiskDetector](https://github.com/vvb2060/MagiskDetector), if you see "magiskhide not working", then report to Magisk.
3. Report to me with your device info and logs.

There is our suggestion:
1. Always keep SELinux is enforcing and make sure any sepolicy rules is necessary.
2. Use modern Xposed framework implementations (like [LSPosed](https://github.com/LSPosed/LSPosed) or [Dreamland](https://github.com/canyie/Dreamland) ) and do not use "global mode", only enables Xposed for actually needed apps.

## Build
Run gradle task :module:assembleMagiskRelease from Android Studio or command line, magisk module zip will be saved to module/build/outputs/magisk/.

## Create your own MOD
Welcome to create mod of this project! But, this project is under the GPL V3 License. So please, do NOT make a mod that just changes the author to yourself, and make the source code of your mod is public to your users. Note, just release a patch but not release the complete source code is NOT enough, if you want to ask why, please ask the Free Software Foundation, not me. 
https://www.gnu.org/licenses/gpl-faq.en.html#DistributingSourceIsInconvenient

## Discussion
- [QQ Group: 949888394](https://shang.qq.com/wpa/qunwpa?idkey=25549719b948d2aaeb9e579955e39d71768111844b370fcb824d43b9b20e1c04)
- [Telegram Group: @DreamlandFramework](https://t.me/DreamlandFramework)

## Credits
- [Magisk](https://github.com/topjohnwu/Magisk)
- [Riru](https://github.com/RikkaApps/Riru)
- [xHook](https://github.com/iqiyi/xHook)

## License
The project uses Magisk's source code, so its license follows Magisk's license.
```
Magisk, including all git submodules are free software:
you can redistribute it and/or modify it under the terms of the
GNU General Public License as published by the Free Software Foundation,
either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
```

```

`build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        mavenLocal()
        mavenCentral()
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:7.1.3'
        

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        mavenLocal()
        mavenCentral()
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

ext {
    versionCode = 8
    versionName = '0.0.8'
    minMagisk = 20400
    riruApiVersion = 5 // For Riru v21
    riruNewApiVersion = 25 // For Riru v22+
}
```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=true


```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Fri Jan 01 09:21:07 CST 2021
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.4.2-bin.zip

```

`gradlew`:

```
#!/usr/bin/env sh

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=$(save "$@")

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
  cd "$(dirname "$0")"
fi

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not "%OS%" == "Windows_NT" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`module/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 32
    buildToolsVersion "32.0.0"
    ndkVersion "23.1.7779620"
    defaultConfig {
        applicationId "top.canyie.riru_isolatedmagiskhider"
        minSdkVersion 24
        targetSdkVersion 32
        versionCode 1
        versionName "1.0"

        externalNativeBuild {
            cmake {
                cppFlags "-std=c++17"
                arguments "-DRIRU_NEW_MODULE_API_VERSION=$rootProject.ext.riruNewApiVersion",
                        "-DRIRU_MODULE_VERSION_CODE=$rootProject.ext.versionCode",
                        "-DRIRU_MODULE_VERSION_NAME:STRING=\"$rootProject.ext.versionName\"",
                        "-DANDROID_STL=none"
            }
        }
        ndk {
            moduleName "momohider"
            abiFilters  "arm64-v8a", "armeabi-v7a", "x86_64", "x86"
        }

        buildFeatures {
            prefab true
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.18.1"
        }
    }
}

dependencies {
    implementation 'dev.rikka.ndk.thirdparty:cxx:1.2.0'
    implementation 'dev.rikka.ndk.thirdparty:xhook:1.2.0'
}

def moduleProp = [
        id: 'riru_momohider',
        name: 'Riru - MomoHider',
        author: 'canyie',
        version: rootProject.ext.versionName,
        versionCode: rootProject.ext.versionCode,
        description: 'A Riru module tries to make Magisk more hidden. You can find its source at https://github.com/canyie/Riru-MomoHider',
        minMagisk: rootProject.ext.minMagisk,
        api: rootProject.ext.riruApiVersion
]

def tempPath = "$buildDir/intermediates/magisk"
def tempTemplatePath = "$tempPath/template"
def nativeDir = "$tempTemplatePath/riru/"
def nativeDirX86 = "$tempTemplatePath/riru_x86/"
def nativeAbiToSystemDirMap = ['armeabi-v7a': 'lib', 'arm64-v8a': 'lib64']
def nativeAbiToSystemDirMapX86 = ['x86': 'lib', 'x86_64': 'lib64']
def nativeLibName = 'libmomohider.so'
def releasePath = "$buildDir/outputs/magisk"

task copyMagiskTemplate(type: Copy) {
    from file("$rootDir/template")
    into file(tempTemplatePath)

    inputs.properties moduleProp
    doLast {
        file("$tempTemplatePath/module.prop").withWriter('utf-8') { writer ->
            moduleProp.each { name, value -> writer.write("$name=$value\n") }
        }
    }
}

task copyNativeLibs() {
    doFirst {
        delete file("$nativeDir")
    }

    doLast {
        stripReleaseDebugSymbols.outputs.files.each { baseInputDir ->
            nativeAbiToSystemDirMap.each { origin, to ->
                copy {
                    from file("$baseInputDir/lib/$origin/$nativeLibName")
                    into file("$nativeDir/$to")
                }
            }

            nativeAbiToSystemDirMapX86.each { origin, to ->
                copy {
                    from file("$baseInputDir/lib/$origin/$nativeLibName")
                    into file("$nativeDirX86/$to")
                }
            }
        }
    }
}

task zipMagiskFiles(type: Zip) {
    from file(tempTemplatePath)
    destinationDir file(releasePath)
    baseName 'Riru-MomoHider'
}

task assembleMagiskRelease(type: GradleBuild, dependsOn: build) {
    tasks = [
            'copyMagiskTemplate',
            'copyNativeLibs',
            'zipMagiskFiles'
    ]
}

```

`module/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

```

`module/src/main/AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="top.canyie.riru_momohider">
</manifest>

```

`module/src/main/cpp/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.4.1)

add_definitions(-DRIRU_NEW_MODULE_API_VERSION=${RIRU_NEW_MODULE_API_VERSION})
add_definitions(-DRIRU_MODULE_VERSION_CODE=${RIRU_MODULE_VERSION_CODE})
add_definitions(-DRIRU_MODULE_VERSION_NAME="${RIRU_MODULE_VERSION_NAME}")

set(C_FLAGS "-Wall -Wextra -fvisibility=hidden -fvisibility-inlines-hidden -fno-exceptions -fno-rtti -flto=thin")
set(LINKER_FLAGS "-fuse-ld=lld -flto=thin -Wl,--unresolved-symbols=ignore-in-shared-libs")

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${C_FLAGS}")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${C_FLAGS}")

set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${LINKER_FLAGS}")
set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} ${LINKER_FLAGS}")

add_library(momohider
        SHARED
        main.cpp
        external/magisk/hide_policy.cpp)

find_library(log-lib log)

find_package(xhook REQUIRED CONFIG)
find_package(cxx REQUIRED CONFIG)

target_link_libraries(momohider ${log-lib} cxx::cxx xhook::xhook)

```

`module/src/main/cpp/external/magisk/hide_policy.cpp`:

```cpp
//
// Created by canyie on 2021/1/1.
// This file is sourced from https://github.com/topjohnwu/Magisk/
//

#include <cerrno>
#include <string>
#include <vector>
#include <mntent.h>
#include <sys/mount.h>
#include <unistd.h>
#include "magiskhide.h"
#include "../../log.h"

using namespace std;

#define INTLROOT    ".magisk"
#define BLOCKDIR    INTLROOT "/block"

// MomoHider changed: fn have no return type
void parse_mnt(const char *file, const function<void(mntent*)> &fn) {
    auto fp = std::unique_ptr<FILE, decltype(&fclose)>(setmntent(file, "re"), endmntent);
    if (fp) {
        mntent mentry{};
        char buf[4096];
        while (getmntent_r(fp.get(), &mentry, buf, sizeof(buf))) {
            fn(&mentry);
        }
    }
}

static void lazy_unmount(const char* mountpoint) {
    if (strcmp(mountpoint, "/system/framework/XposedBridge.jar") == 0) {
        LOGE("Skip unmount XposedBridge.jar because the rovo89's Xposed framework can't handle this case.");
        return;
    }
    if (umount2(mountpoint, MNT_DETACH) != -1) {
        //LOGD("hide_policy: Unmounted (%s)\n", mountpoint);
    } else {
        LOGE("hide_policy: can't unmount %s: %s", mountpoint, strerror(errno));
    }
}

// MomoHider changed: don't pass pid, the target process is always myself.
// MomoHider changed: don't print log in app process
void hide_unmount(const char* magisk_tmp) {
    // MomoHider changed: don't change namespace, the target process is always myself.
//    if (switch_mnt_ns())
//        return;

    vector<string> targets;

    // Unmount dummy skeletons and /sbin links
    targets.push_back(magisk_tmp);

#define TMPFS_MNT(dir) (mentry->mnt_type == "tmpfs"sv && \
strncmp(mentry->mnt_dir, "/" #dir, sizeof("/" #dir) - 1) == 0)

    parse_mnt("/proc/self/mounts", [&](mntent *mentry) {
        if (TMPFS_MNT(system) || TMPFS_MNT(vendor) || TMPFS_MNT(product) || TMPFS_MNT(system_ext))
            targets.emplace_back(mentry->mnt_dir);
    });

#undef TMPFS_MNT

    reverse(targets.begin(), targets.end());
    for (auto &s : targets)
        lazy_unmount(s.data());
    targets.clear();

    // Unmount all Magisk created mounts
    parse_mnt("/proc/self/mounts", [&](mntent *mentry) {
        if (strstr(mentry->mnt_fsname, BLOCKDIR)) {
            targets.emplace_back(mentry->mnt_dir);
        }
    });

    reverse(targets.begin(), targets.end());
    for (auto &s : targets)
        lazy_unmount(s.data());
}


```

`module/src/main/cpp/external/magisk/magiskhide.h`:

```h
//
// Created by canyie on 2021/1/1.
//

#ifndef RIRU_MOMOHIDER_MAGISKHIDE_H
#define RIRU_MOMOHIDER_MAGISKHIDE_H

void hide_unmount(const char* magisk_tmp);

#endif //RIRU_MOMOHIDER_MAGISKHIDE_H

```

`module/src/main/cpp/external/riru/riru.h`:

```h
//
// Created by canyie on 2020/12/6.
//

#ifndef RIRU_H
#define RIRU_H

#include <jni.h>
#include <unistd.h>

#ifdef __cplusplus
extern "C" {
#endif

#define EXPORT extern "C" __attribute__ ((visibility ("default"))) __attribute__((used))

typedef void(onModuleLoaded_v9)();

typedef int(shouldSkipUid_v9)(int uid);

typedef void(nativeForkAndSpecializePre_v9)(
        JNIEnv* env, jclass cls, jint* uid, jint* gid, jintArray* gids, jint* runtimeFlags,
        jobjectArray* rlimits, jint* mountExternal, jstring* seInfo, jstring* niceName,
        jintArray* fdsToClose, jintArray* fdsToIgnore, jboolean* is_child_zygote,
        jstring* instructionSet, jstring* appDataDir, jboolean* isTopApp,
        jobjectArray* pkgDataInfoList,
        jobjectArray* whitelistedDataInfoList, jboolean* bindMountAppDataDirs,
        jboolean* bindMountAppStorageDirs);

typedef void(nativeForkAndSpecializePost_v9)(JNIEnv* env, jclass cls, jint res);

typedef void(nativeForkSystemServerPre_v9)(
        JNIEnv* env, jclass cls, uid_t* uid, gid_t* gid, jintArray* gids, jint* runtimeFlags,
        jobjectArray* rlimits, jlong* permittedCapabilities, jlong* effectiveCapabilities);

typedef void(nativeForkSystemServerPost_v9)(JNIEnv* env, jclass cls, jint res);

typedef void(nativeSpecializeAppProcessPre_v9)(
        JNIEnv* env, jclass cls, jint* uid, jint* gid, jintArray* gids, jint* runtimeFlags,
        jobjectArray* rlimits, jint* mountExternal, jstring* seInfo, jstring* niceName,
        jboolean* startChildZygote, jstring* instructionSet, jstring* appDataDir,
        jboolean* isTopApp, jobjectArray* pkgDataInfoList, jobjectArray* whitelistedDataInfoList,
        jboolean* bindMountAppDataDirs, jboolean* bindMountAppStorageDirs);

typedef void(nativeSpecializeAppProcessPost_v9)(JNIEnv* env, jclass cls);

typedef struct {
    int supportHide;
    int version;
    const char *versionName;
    onModuleLoaded_v9 *onModuleLoaded;
    shouldSkipUid_v9 *shouldSkipUid; // Actually unused in Riru V25+
    nativeForkAndSpecializePre_v9 *forkAndSpecializePre;
    nativeForkAndSpecializePost_v9 *forkAndSpecializePost;
    nativeForkSystemServerPre_v9 *forkSystemServerPre;
    nativeForkSystemServerPost_v9 *forkSystemServerPost;
    nativeSpecializeAppProcessPre_v9 *specializeAppProcessPre;
    nativeSpecializeAppProcessPost_v9 *specializeAppProcessPost;
} RiruModuleInfo;

typedef struct {
    int moduleApiVersion;
    RiruModuleInfo moduleInfo;
} RiruVersionedModuleInfo;

// ---------------------------------------------------------

typedef struct {
    int riruApiVersion;
    void *unused;
    const char *magiskModulePath;
    int *allowUnload;
} Riru;

typedef RiruVersionedModuleInfo *(RiruInit_t)(Riru *);

EXPORT void* init(Riru* arg);

#ifdef __cplusplus
}


#endif

#endif //RIRU_H

```

`module/src/main/cpp/log.h`:

```h
//
// Created by canyie on 2021/1/1.
//

#ifndef RIRU_MOMOHIDER_LOG_H
#define RIRU_MOMOHIDER_LOG_H

#include <android/log.h>

#define LOG_TAG "MomoHider"

#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)

#endif //RIRU_MOMOHIDER_LOG_H

```

`module/src/main/cpp/main.cpp`:

```cpp
//
// Created by canyie on 2021/1/1.
//

#include <cstdlib>
#include <cerrno>
#include <cstring>
#include <malloc.h>
#include <fcntl.h>
#include <unistd.h>
#include <sched.h>
#include <pthread.h>
#include <dirent.h>
#include <jni.h>
#include <xhook.h>
#include "log.h"
#include "external/magisk/magiskhide.h"
#include "external/riru/riru.h"

#define USE_NEW_APP_ZYGOTE_MAGIC 1

const char* module_dir_ = nullptr;
constexpr const char* kSetNs = "setns";
constexpr const char* kMagicHandleAppZygote = "app_zygote_magic";
constexpr const char* kMagiskTmp = "magisk_tmp";
constexpr const char* kIsolated = "isolated";

const char* magisk_tmp_ = nullptr;
bool magic_handle_app_zygote_ = false;
bool hide_isolated_ = false;
bool in_child_ = false;
bool isolated_ = false;
bool app_zygote_ = false;
bool no_new_ns_ = false;

jstring* nice_name_ = nullptr;

bool use_nsholder_ = false;
char* nsholder_mnt_ns_ = nullptr;
pid_t nsholder_pid_ = -1;

pid_t (*orig_fork)() = nullptr;
int (*orig_unshare)(int) = nullptr;

int* riru_allow_unload = nullptr;

#if 0
void* DoNothing(void*) {
    return nullptr;
}
#endif

void ConfigPath(const char* name, char* out) {
    snprintf(out, 127, "%s/config/%s", module_dir_, name);
}

bool Exists(const char* name) {
    char path[128] = {0};
    ConfigPath(name, path);
    if (access(path, F_OK) == 0) return true;
    LOGD("access %s failed: %s", path, strerror(errno));
    return false;
}

void AllowUnload() {
    if (riru_allow_unload) *riru_allow_unload = 1;
}

int ReadIntAndClose(int fd) {
    char buf[16] = {0};
    read(fd, buf, 15);
    close(fd);
    return atoi(buf);
}

void WriteIntAndClose(int fd, int value) {
    char buf[16] = {0};
    snprintf(buf, 15, "%d", value);
    write(fd, buf, 15);
    close(fd);
}

const char* ReadMagiskTmp() {
    const char* magisk_tmp = "/sbin";
    char path[128];
    ConfigPath(kMagiskTmp, path);
    FILE* fp = fopen(path, "re");
    if (fp) {
        char tmp[PATH_MAX];
        fseek(fp, 0, SEEK_END);
        long size = ftell(fp);
        rewind(fp);

        if (size == fread(tmp, 1, static_cast<size_t>(size), fp)) {
            tmp[size] = '\0';
            magisk_tmp = strdup(tmp);
        } else {
            LOGE("read magisk tmp failed: %s", strerror(errno));
        }
        fclose(fp);
    } else {
        LOGE("open magisk tmp failed: %s", strerror(errno));
    }
    return magisk_tmp;
}

// Maybe change the mount external mode to make sure the new process will call unshare().
// Returns true if we don't need a new ns for this process
bool EnsureSeparatedNamespace(jint* mountMode, jboolean bindMountAppDataDirs, jboolean bindMountAppStorageDirs) {
    if (*mountMode == 0) {
        bool no_need_newns = bindMountAppDataDirs == JNI_FALSE && bindMountAppStorageDirs == JNI_FALSE;
        LOGI("Changed mount mode from NONE to DEFAULT and %s", no_need_newns ? "skip unshare" : "keep unshare");
        *mountMode = 1;
        return no_need_newns;
    }
    return false;
}

void HideMagisk() {
    hide_unmount(magisk_tmp_);
}

void SetProcessName(JNIEnv* env, jstring name) {
    jclass Process = env->FindClass("android/os/Process");
    jmethodID setArgV0 = env->GetStaticMethodID(Process, "setArgV0", "(Ljava/lang/String;)V");
    if (env->ExceptionCheck()) {
        env->ExceptionClear();
        LOGW("Process.setArgV0(String) not found");
    } else {
        env->CallStaticVoidMethod(Process, setArgV0, name);
        if (env->ExceptionCheck()) {
            env->ExceptionClear();
            LOGW("Process.setArgV0(String) threw exception");
        }
    }
    env->DeleteLocalRef(Process);
}

void MaybeInitNsHolder(JNIEnv* env) {
    if (!use_nsholder_) return;

    if (nsholder_mnt_ns_) {
        if (access(nsholder_mnt_ns_, F_OK) != 0) {
            // Maybe the nsholder died
            LOGW("access %s failed with error %s", nsholder_mnt_ns_, strerror(errno));
            if (nsholder_pid_ > 0) {
                kill(nsholder_pid_, SIGKILL);
            }
            free(nsholder_mnt_ns_);
        } else { // Still alive
            return;
        }
    }

    LOGI("Starting nsholder");
    int read_fd, write_fd;
    {
        int pipe_fd[2];
        if (pipe(pipe_fd) == -1) {
            LOGE("Failed to create pipe for nsholder: %s", strerror(errno));
            return;
        } else {
            read_fd = pipe_fd[0];
            write_fd = pipe_fd[1];
        }
    }

    nsholder_pid_ = orig_fork();
    if (nsholder_pid_ < 0) { // failed, cleanup
        LOGE("fork nsholder failed: %s", strerror(errno));
        close(read_fd);
        close(write_fd);
        nsholder_mnt_ns_ = nullptr;
    } else if (nsholder_pid_ == 0) { // child
        close(read_fd);
        if (orig_unshare(CLONE_NEWNS) == -1) {
            LOGE("nsholder: failed to clone new ns: %s", strerror(errno));
            WriteIntAndClose(write_fd, 1);
            exit(1);
        }
        LOGI("Hiding Magisk in nsholder %d...", getpid());
        HideMagisk();
        LOGI("Unmounted magisk file system.");

        // Change process name
        {
            jstring name = env->NewStringUTF(sizeof(void*) == 8 ? "nsholder64" : "nsholder32");
            SetProcessName(env, name);
            env->DeleteLocalRef(name);
        }

        // We're in the "cleaned" ns, notify the zygote we're ready and stop us
        WriteIntAndClose(write_fd, 0);

        // All done, but we should keep alive, because we need to keep the namespace
        // If a fd references the namespace, the ns won't be destroyed
        // but we need to open a fd in zygote, and Google don't want we opened new fd across fork,
        // zygote will abort with error like "Not whitelisted (41): mnt:[4026533391]"
        // We can manually call the Zygote.nativeAllowAcrossFork(), but this can be detected by app;
        // or, we can use the "fdsToIgnore" argument, but for usap, forkApp() haven't the argument.
        // To keep it simple, just let fd not opened in zygote
        for (;;) {
            // Note: SIGSTOP can't stop us here when magisk hide is enabled
            // I think the magisk hiding catches our SIGSTOP and not handle it properly (didn't resend the signal)
            // raise(SIGSTOP);
            pause();
            LOGW("nsholder wakes up unexpectedly, sleep again");
        }
    } else { // parent, wait the nsholder enter a "clean" ns
        close(write_fd);
        int status = ReadIntAndClose(read_fd);
        if (status == 0) {
            kill(nsholder_pid_, SIGSTOP); // make nsholder is stopped again
            char mnt[32];
            snprintf(mnt, sizeof(mnt), "/proc/%d/ns/mnt", nsholder_pid_);
            LOGI("The nsholder is cleaned and stopped, mnt_ns is %s", mnt);
            nsholder_mnt_ns_ = strdup(mnt);
            return;
        } else {
            LOGE("Unexpected status %d received from the nsholder", status);

            kill(nsholder_pid_, SIGKILL);
            nsholder_pid_ = -1;
            nsholder_mnt_ns_ = nullptr;
            use_nsholder_ = false;
        }
    }
}

bool MaybeSwitchMntNs() {
    if (!nsholder_mnt_ns_) return false;
    int fd = open(nsholder_mnt_ns_, O_RDONLY);
    if (fd < 0) { // Maybe the nsholder died...
        LOGE("Can't open %s: %s", nsholder_mnt_ns_, strerror(errno));
        return false;
    }
    int ret = setns(fd, 0);
    int err = errno;
    close(fd);
    if (ret != 0) {
        LOGE("Failed to switch ns: %s", strerror(err));
        return false;
    }
    return true;
}

bool IsApp(int app_id) {
    return app_id >= 10000 && app_id <= 19999;
}

void InitProcessState(int uid, bool is_child_zygote) {
    int app_id = uid % 100000;
    isolated_ = app_id >= 90000;
    app_zygote_ = is_child_zygote && (IsApp(app_id) || isolated_);
}

void ClearProcessState() {
    isolated_ = false;
    app_zygote_ = false;
    no_new_ns_ = false;
    nice_name_ = nullptr;
}

bool RegisterHook(const char* name, void* replace, void** backup) {
    int ret = xhook_register(".*\\libandroid_runtime.so$", name, replace, backup);
    if (ret != 0) {
        LOGE("Failed to hook %s", name);
        return true;
    }
    return false;
}

void ClearHooks() {
    if (!hide_isolated_ && !magic_handle_app_zygote_) return;
    xhook_enable_debug(0); // Suppress log in app process
    xhook_enable_sigsegv_protection(0);
    bool failed = false;
#define UNHOOK(NAME) \
failed = failed || RegisterHook(#NAME, reinterpret_cast<void*>(orig_##NAME), nullptr)

    UNHOOK(fork);
    if (hide_isolated_) {
        UNHOOK(unshare);
    }
#undef UNHOOK

    if (failed || xhook_refresh(0)) {
        LOGE("Failed to clear hooks!");
        return;
    }
    xhook_clear();
}

#if !USE_NEW_APP_ZYGOTE_MAGIC
pid_t MagicHandleAppZygote() {
    LOGI("Magic handling app zygote");
    // App zygote, fork a new process to run it (after forking magiskhide detachs)
    // This makes some detection not working (but also can be easily detected)
    pid_t pid = orig_fork();
    if (pid > 0) {
        // parent
        LOGI("Child zygote forked substitute %d", pid);
        exit(0);
    } else if (pid == 0) {
        pid = getpid();
    } else { // pid < 0
        LOGE("Failed to fork new process for app zygote");
    }
    return pid;
}
#endif

pid_t ForkReplace() {
    int read_fd = -1, write_fd = -1;

#if !USE_NEW_APP_ZYGOTE_MAGIC
    if (app_zygote_ && magic_handle_app_zygote_) {
        int pipe_fd[2];
        if (pipe(pipe_fd) == -1) {
            LOGE("Failed to create pipe for new app zygote: %s", strerror(errno));
        } else {
            read_fd = pipe_fd[0];
            write_fd = pipe_fd[1];
        }
    }
#endif
    pid_t pid = orig_fork();

    if (pid < 0) {
#if !USE_NEW_APP_ZYGOTE_MAGIC
        // fork() failed, clean up
        if (read_fd != -1)
            close(read_fd);
        if (write_fd != -1)
            close(write_fd);
#endif
    } else if (pid == 0) {
        // child process
        // Do not hide here because the namespace not separated
        in_child_ = true;
#if !USE_NEW_APP_ZYGOTE_MAGIC
        if (read_fd != -1 && write_fd != -1) {
            close(read_fd);
            pid_t new_pid = MagicHandleAppZygote();
            WriteIntAndClose(write_fd, new_pid);
        }
#endif
    } else {
#if !USE_NEW_APP_ZYGOTE_MAGIC
        // parent process
        if (read_fd != -1 && write_fd != -1) {
            close(write_fd);
            pid = ReadIntAndClose(read_fd);
            LOGI("Zygote received new substitute pid %d", pid);
        }
#endif
    }
    return pid;
}

int UnshareReplace(int flags) {
    bool isolated_ns = (flags & CLONE_NEWNS) != 0 && in_child_ && (isolated_ || app_zygote_);
    bool cleaned = false;
    if (isolated_ns) {
        cleaned = MaybeSwitchMntNs();
        if (cleaned && no_new_ns_) {
            // We're in the "cleaned" ns, don't unshare new ns
            // isolated process and app zygote uses the same ns with zygote on pre-11
            // this can be detected by app
            // https://android-review.googlesource.com/c/platform/frameworks/base/+/1554432
            // https://cs.android.com/android/_/android/platform/frameworks/base/+/e986bc4cad9b68e1cf4aedfb3b99381cc64d0497
            if (flags == CLONE_NEWNS) return 0;
            flags &= ~CLONE_NEWNS;
        }
    }
    int res = orig_unshare(flags);
    if (res == -1) return res;
    if (isolated_ns && !cleaned) { // If not in a cleaned ns, try hide directly again
        HideMagisk();
    }
    return res;
}

void RegisterHooks() {
    if (!hide_isolated_ && !magic_handle_app_zygote_) return;
    xhook_enable_debug(1);
    xhook_enable_sigsegv_protection(0);
    bool failed = false;
#define HOOK(NAME, REPLACE) \
failed = failed || RegisterHook(#NAME, reinterpret_cast<void*>(REPLACE), reinterpret_cast<void**>(&orig_##NAME))

    HOOK(fork, ForkReplace);
    if (hide_isolated_) {
        HOOK(unshare, UnshareReplace);
    }

#undef HOOK

    if (failed || xhook_refresh(0)) {
        LOGE("Failed to register hooks!");
        return;
    }
    xhook_clear();
}

void onModuleLoaded() {
    LOGI("Magisk module dir is %s", module_dir_);
    magisk_tmp_ = ReadMagiskTmp();
    LOGI("Magisk temp path is %s", magisk_tmp_);
    hide_isolated_ = Exists(kIsolated);
    magic_handle_app_zygote_ = Exists(kMagicHandleAppZygote);
    use_nsholder_ = Exists(kSetNs);
    RegisterHooks();
}

// After Riru v22
static void forkAndSpecializePre(
        JNIEnv* env, jclass, jint* _uid, jint* gid, jintArray* gids, jint* runtimeFlags,
        jobjectArray* rlimits, jint* mountExternal, jstring* seInfo, jstring* niceName,
        jintArray* fdsToClose, jintArray* fdsToIgnore, jboolean* is_child_zygote,
        jstring* instructionSet, jstring* appDataDir, jboolean* isTopApp,
        jobjectArray* pkgDataInfoList,
        jobjectArray* whitelistedDataInfoList, jboolean* bindMountAppDataDirs,
        jboolean* bindMountAppStorageDirs) {
    InitProcessState(*_uid, *is_child_zygote);
    nice_name_ = niceName;
    if (hide_isolated_) {
        no_new_ns_ = EnsureSeparatedNamespace(mountExternal, *bindMountAppDataDirs, *bindMountAppStorageDirs);
        MaybeInitNsHolder(env);
    }
}

static void forkAndSpecializePost(JNIEnv* env, jclass, jint res) {
#if USE_NEW_APP_ZYGOTE_MAGIC
    if (res == 0 && app_zygote_ && magic_handle_app_zygote_ && nice_name_ && *nice_name_) {
        // forkAndSpecialize() changed the name of the current thread, not the process
        // For normal processes, the process name will be changed in ZygoteConnection.handleChildProc()
        // And use binder to communicate with system_server, which will create a binder thread pool.
        // This triggers MagiskHide to detach and unmount Magisk filesystems.
        // But for App Zygotes, after handleChildProc() there is no thread to start (VM daemon threads had started before)
        // So MagiskHide won't detach and won't unmount Magisk.
        // In this case, we manually set process name, and the start of VM daemon threads will trigger MagiskHide.
        // We only check this because app zygote won't be started with USAP.
        SetProcessName(env, *nice_name_);
#if 0
        // Just in case some ROMs have broken art implementation that won't start daemon threads...
        pthread_t th;
        int r = pthread_create(&th, nullptr, DoNothing, nullptr);
        if (r == 0)
            r = pthread_join(th, nullptr);
        if (r)
            LOGE("Failed to create/join thread for app zygote");
#endif
    }
#endif
    ClearProcessState();
    if (res == 0) {
        ClearHooks();
        AllowUnload();
    }
}

static void specializeAppProcessPre(
        JNIEnv *env, jclass clazz, jint *uid, jint *gid, jintArray *gids, jint *runtimeFlags,
        jobjectArray *rlimits, jint *mountExternal, jstring *seInfo, jstring *niceName,
        jboolean *startChildZygote, jstring *instructionSet, jstring *appDataDir,
        jboolean *isTopApp, jobjectArray *pkgDataInfoList, jobjectArray *whitelistedDataInfoList,
        jboolean *bindMountAppDataDirs, jboolean *bindMountAppStorageDirs) {
    InitProcessState(*uid, *startChildZygote);
    if (hide_isolated_)
        no_new_ns_ = EnsureSeparatedNamespace(mountExternal, *bindMountAppDataDirs, *bindMountAppStorageDirs);
}

static void specializeAppProcessPost(JNIEnv *env, jclass clazz) {
    ClearProcessState();
    ClearHooks();
    AllowUnload();
}

int riru_api_version = 0;
static auto module = RiruVersionedModuleInfo {
        .moduleApiVersion = RIRU_NEW_MODULE_API_VERSION,
        .moduleInfo = RiruModuleInfo {
                .supportHide = true,
                .version = RIRU_MODULE_VERSION_CODE,
                .versionName = RIRU_MODULE_VERSION_NAME,
                .onModuleLoaded = onModuleLoaded,
                .shouldSkipUid = nullptr,
                .forkAndSpecializePre = forkAndSpecializePre,
                .forkAndSpecializePost = forkAndSpecializePost,
                .forkSystemServerPre = nullptr,
                .forkSystemServerPost = nullptr,
                .specializeAppProcessPre = specializeAppProcessPre,
                .specializeAppProcessPost = specializeAppProcessPost
        }
};

EXPORT void* init(Riru* arg) {
    RIRU_MODULE_VERSION_NAME;
    int core_max_api_version = arg->riruApiVersion;
    riru_api_version = core_max_api_version <= RIRU_NEW_MODULE_API_VERSION
                       ? core_max_api_version : RIRU_NEW_MODULE_API_VERSION;
    if (riru_api_version > 10 && riru_api_version < 25) {
        // V24 is pre-release version, not supported
        riru_api_version = 10;
    }
    if (riru_api_version >= 25) {
        module.moduleApiVersion = riru_api_version;
        riru_allow_unload = arg->allowUnload;
        module_dir_ = strdup(arg->magiskModulePath);
        return &module;
    } else {
        LOGE("MomoHider requires Riru V25 or above, but current Riru api version is %d", riru_api_version);
    }
    return nullptr;
}

```

`settings.gradle`:

```gradle
rootProject.name='Riru - MomoHider'
include ':module'

```

`template/META-INF/com/google/android/update-binary`:

```
#!/sbin/sh

#################
# Initialization
#################

umask 022

# echo before loading util_functions
ui_print() { echo "$1"; }

require_new_magisk() {
  ui_print "*******************************"
  ui_print " Please install Magisk v20.4+! "
  ui_print "*******************************"
  exit 1
}

#########################
# Load util_functions.sh
#########################

OUTFD=$2
ZIPFILE=$3

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk

install_module
exit 0
```

`template/META-INF/com/google/android/updater-script`:

```
#MAGISK

```

`template/customize.sh`:

```sh
RIRU_OLD_PATH="/data/misc/riru"
RIRU_NEW_PATH="/data/adb/riru"
RIRU_MODULE_ID="momohider"
DATA_DIR="$MODPATH/config"
OLD_DATA_DIR="/data/adb/momohider"
OLD_DATA_DIR_2="/data/misc/isolatedmagiskhider/"
RIRU_API=0

ui_print "- This is an open source project"
ui_print "- You can find its source code at https://github.com/canyie/Riru-MomoHider"

if [ $ARCH != "arm" ] && [ $ARCH != "arm64" ] && [ $ARCH != "x86" ] && [ $ARCH != "x64" ]; then
  abort "! Unsupported platform: $ARCH"
else
  ui_print "- Device platform: $ARCH"
fi

if [ $API -lt 24 ]; then
  abort "! Unsupported Android API level $API"
else
  ui_print "- Android API level: $API"
fi

MAGISK_TMP=$(magisk --path) || MAGISK_TMP="/sbin"
MAGISK_CURRENT_MODULES="$MAGISK_TMP/.magisk/modules"
MAGISK_CURRENT_RIRU_MODULE_PATH="$MAGISK_CURRENT_MODULES/riru-core"

if [ -f $MAGISK_CURRENT_RIRU_MODULE_PATH/util_functions.sh ]; then
  # Riru V24+, api version is provided in util_functions.sh
  # I don't like this, but I can only follow this change
  RIRU_PATH=$MAGISK_CURRENT_RIRU_MODULE_PATH
  ui_print "- Load $MAGISK_CURRENT_RIRU_MODULE_PATH/util_functions.sh"
  # shellcheck disable=SC1090
  . $MAGISK_CURRENT_RIRU_MODULE_PATH/util_functions.sh

  # Pre Riru 25, as a old module
  if [ "$RIRU_API" -lt 25 ]; then
    ui_print "- Riru API version $RIRU_API is lower than v25"
    RIRU_PATH=$RIRU_NEW_PATH
  fi
elif [ -f $RIRU_OLD_PATH/api_version.new ] || [ -f $RIRU_OLD_PATH/api_version ]; then
  RIRU_PATH=$RIRU_OLD_PATH
elif [ -f $RIRU_NEW_PATH/api_version.new ] || [ -f $RIRU_NEW_PATH/api_version ]; then
  RIRU_PATH=$RIRU_NEW_PATH
else
  abort "! Requirement module 'Riru' is not installed"
fi

[ "$RIRU_API" -lt 25 ] && abort "! MomoHider requires Riru V25 or above"

if [ $MAGISK_VER_CODE -lt 20200 ]; then
  ui_print "- Removing sepolicy.rule for Magisk $MAGISK_VER"
  rm $MODPATH/sepolicy.rule
fi

if [ $ARCH = "x86" ] || [ $ARCH = "x64" ]; then
  ui_print "- Removing arm libraries for x86 device"
  rm -rf "$MODPATH/riru"
  mv -f "$MODPATH/riru_x86" "$MODPATH/riru"
else
  ui_print "- Removing x86 libraries for arm device"
  rm -rf "$MODPATH/riru_x86"
fi

if [ $IS64BIT == false ]; then
  ui_print "- Removing 64-bit libraries"
  rm -rf $MODPATH/riru/lib64
fi

# Riru v25+, maybe the user upgrade from old module without uninstall
# Remove the Riru v22's module path to make sure riru knews we're a new module
RIRU_22_MODULE_PATH="$RIRU_NEW_PATH/modules/$RIRU_MODULE_ID"
ui_print "- Removing $RIRU_22_MODULE_PATH for new Riru $RIRU_API"
rm -rf "$RIRU_22_MODULE_PATH"

ui_print "- Preparing data directory"

CURRENT_CONFIG_DIR="$MAGISK_CURRENT_MODULES/riru_momohider/config"
[ -d "$CURRENT_CONFIG_DIR" ] && cp -r "$CURRENT_CONFIG_DIR" "$DATA_DIR"

if [ -d $OLD_DATA_DIR ]; then
  mv -f "$OLD_DATA_DIR" "$DATA_DIR"
  rm -rf "$OLD_DATA_DIR"
fi

if [ -d $OLD_DATA_DIR_2 ]; then
  mv -f "$OLD_DATA_DIR_2" "$DATA_DIR"
  rm -rf "$OLD_DATA_DIR_2"
fi

[ -d $DATA_DIR ] || mkdir -p $DATA_DIR || abort "! Can't create $DATA_DIR"

ui_print "- Setting permissions"
set_perm_recursive $MODPATH 0 0 0755 0644

```

`template/post-fs-data.sh`:

```sh
#!/system/bin/sh

MODDIR=${0%/*}

DATA_DIR="$MODDIR/config"

MAGISK_TMP=$(magisk --path) || MAGISK_TMP="/sbin"
echo -n "$MAGISK_TMP" > "$DATA_DIR/magisk_tmp"

[ -f $MODDIR/sepolicy.rule ] && exit 0

magiskpolicy --live "allow zygote * filesystem { unmount }" \
"allow zygote zygote capability { sys_ptrace sys_chroot }" \
"allow zygote unlabeled file { open read }"

```

`template/sepolicy.rule`:

```rule
allow zygote * filesystem { unmount }

# For setns()
allow zygote zygote capability { sys_ptrace sys_chroot }
allow zygote unlabeled file { open read }

```

`template/service.sh`:

```sh
#!/system/bin/sh
MODDIR=${0%/*}
DATA_DIR="$MODDIR/config"

[ -f "$DATA_DIR/initrc" ] || exit 0

MAGISK_TMP=$(magisk --path) || MAGISK_TMP="/sbin"

# First try Android 11's new init.rc since some devices use the new path but still have the legacy init.rc file
# https://github.com/topjohnwu/Magisk/pull/4836
INITRC_NAME="system/etc/init/hw/init.rc"

# legacy init.rc (Android 10 and older)
[ -f "/$INITRC_NAME" ] || INITRC_NAME="init.rc"

INITRC="/$INITRC_NAME"

# First try SAR path
MAGISKRC="$MAGISK_TMP/.magisk/rootdir/$INITRC_NAME"

# SAR path not found = Rootfs, Magisk modifies the init.rc file directly
[ -f "$MAGISKRC" ] || MAGISKRC=$INITRC

trim() {
  trimmed=$1
  trimmed=${trimmed%% }
  trimmed=${trimmed## }
  echo $trimmed
}

# https://github.com/topjohnwu/Magisk/blob/master/native/jni/init/rootdir.cpp#L24
grep_flash_recovery() {
  # Some devices don't have the flash_recovery service
  # (like Samsung renamed it to "ota_cleanup" but Magisk won't remove it, so we no need to do anything for this)
  LINE=$(grep "service flash_recovery " "$INITRC") || return 1
  LINE=${LINE#*"service flash_recovery "}
  trim "$LINE"
}

reset_flash_recovery() {
  FLASH_RECOVERY=$(grep_flash_recovery) || return

  # Skip if the flash_recovery service was not removed by Magisk
  grep -qxF "service flash_recovery /system/bin/xxxxx" "$MAGISKRC" || return

  # Skip if the install-recovery.sh does not exist
  [ -f "$FLASH_RECOVERY" ] || return

  # Skip if there is the state set for the service
  [ "$(getprop 'init.svc.flash_recovery' 2>/dev/null)" = "" ] || return

  # Set a "fake" state for the service
  resetprop 'init.svc.flash_recovery' 'stopped'
}

grep_service_name() {
  ARG=$1
  LINE=$(grep "service .* $MAGISK_TMP/magisk --$ARG" "$MAGISKRC")
  LINE=${LINE#*"service "}
  LINE=${LINE%" $MAGISK_TMP"*}
  trim "$LINE"
}

del_service_name() {
  resetprop --delete "init.svc.$1"
}

delete_services() {
  # Wait for boot to complete
  while [ "$(getprop sys.boot_completed)" != "1" ]
  do
    sleep 1
  done

  # Remove Magisk's services' names from system properties
  POST_FS_DATA=$(grep_service_name "post-fs-data")
  LATE_START_SERVICE=$(grep_service_name "service")
  BOOT_COMPLETED=$(grep_service_name "boot-complete")
  del_service_name "$POST_FS_DATA"
  del_service_name "$LATE_START_SERVICE"
  del_service_name "$BOOT_COMPLETED"
}

reset_flash_recovery
delete_services &

```

`template/uninstall.sh`:

```sh
# Before v22
rm -rf /data/misc/riru/modules/momohider

# After v22
rm -rf /data/adb/riru/modules/momohider

rm -rf /data/adb/momohider/
```