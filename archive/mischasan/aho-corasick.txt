Project Path: arc_mischasan_aho-corasick_djmg__3x

Source Tree:

```txt
arc_mischasan_aho-corasick_djmg__3x
├── Aho-Corasick-Interleaved_State_Matrix.pdf
├── GNUmakefile
├── LICENSE
├── README.md
├── _acism.h
├── acism.c
├── acism.h
├── acism.sln
├── acism.vcxproj
├── acism_create.c
├── acism_dump.c
├── acism_file.c
├── acism_mmap_x.c
├── acism_strings.c
├── acism_x.c
├── acism_x.vcxproj
├── acism_x.vcxproj.user
├── deas
├── msutil.c
├── msutil.h
├── rules.mk
├── tap.c
├── tap.h
└── words.gz

```

`GNUmakefile`:

```
~ := acism
include $(word 1, ${RULES} rules.mk)

#---------------- PRIVATE VARS:
acism.x         = acism_x acism_mmap_x

#---------------- PUBLIC (see rules.mk):
all             : libacism.a
test            : acism_t.pass
install         : libacism.a  acism.h
clean           += *.tmp

#---------------- PRIVATE RULES:
libacism.a      : acism.o  acism_create.o  acism_dump.o  acism_file.o
acism_t.pass    : ${acism.x}  words
${acism.x}      : libacism.a  msutil.o  tap.o

#_CFLAGS = -DACISM_SIZE=8

# vim: set nowrap :

```

`LICENSE`:

```
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

```

`README.md`:

```md
aho-corasick
==

Aho-Corasick parallel string search, using interleaved arrays.

Mischa Sandberg mischasan@gmail.com

ACISM is an implementation of Aho-Corasick parallel string search,
using an Interleaved State-transition Matrix.
It combines the fastest possible Aho-Corasick implementation,
with the smallest possible data structure (!).

FEATURES
--------

* Fast. No hashing, no tree traversal; just a straight look-up equivalent to
    matrix[state, input-byte] per input character.

* Tiny. On average, the whole data structure (mostly the array) takes about 2-3 bytes per
    input pattern byte. The original set of pattern strings can be reverse-generated from the machine.

* Shareable. The state machine contains no pointers, so it can be compiled once,
    then memory-mapped by many processes.

* Searches byte vectors, not null-terminated strings.
    Suitable for searching machine code as much as searching text.

* DOS-proof. Well, that's an attribute of Aho-Corasick,
    so no real points for that.

* Stream-ready. The state can be saved between calls to search data.

DOCUMENTATION
-------------

The GoogleDocs description is at http://goo.gl/lE6zG
I originally called it "psearch", but found that name was overused by other authors.

LICENSE
-------

LGPL v3


GETTING STARTED
---------------

Download the source, type "gmake".
"gmake install" exports lib/libacism.a, include/acism.h and bin/acism_x.
"acism_x.c" is a good example of calling acism_create and acism_scan/acism_more.

(If you're interested in the GNUmakefile and rules.mk,
 check my blog posts on non-recursive make, at mischasan.wordpress.com.)
 
HISTORY
-------

The interleaved-array approach was tried and discarded in the late 70's, because the compile time was O(n^2). 
acism_create beats the problem with a "hint" array that tracks the restart points for searches.
That, plus discarding the original idea of how to get maximal density, resulted in the tiny-fast win-win.

ACKNOWLEDGEMENTS
----------------

I'd like to thank Mike Shannon, who wanted to see a machine built to make best use of L1/L2 cache.
The change to do that doubled performance on hardware with a much larger cache than the matrix.
Go figure.

```

`_acism.h`:

```h
/*
** Copyright (C) 2009-2014 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License Version 3 as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/
#ifndef _ACISM_H
#define _ACISM_H

#include <stdint.h>
#include <stdlib.h> // malloc
#include <string.h> // memcpy

typedef int (*qsort_cmp)(const void *, const void *);

// "Width" specifier for different plats 
#if __LONG_MAX__ == 9223372036854775807LL
#   ifdef __APPLE__
#       define F64  "ll"
#   else
#       define F64  "l"
#   endif
#elif __LONG_MAX__ == 2147483647L || defined(_LONG_LONG) || defined(__sun) // AIX 6.1 ...
#   define F64      "ll"
#else
//XXX Assuming F64 is "ll" for VS
#   define F64      "ll"
#endif

#ifndef ACISM_SIZE
#   define ACISM_SIZE 4
#endif

#if ACISM_SIZE == 8
    typedef uint64_t TRAN, STATE, STRNO;
#   define SYM_BITS 9U
#   define SYM_MASK 511
#   define FNO      F64
#else
    typedef uint32_t TRAN, STATE, STRNO;
#   define SYM_BITS psp->sym_bits
#   define SYM_MASK psp->sym_mask
#   define FNO      
#endif

typedef uint16_t  SYMBOL;
typedef unsigned _SYMBOL; // An efficient stacklocal SYMBOL

#define BACK ((SYMBOL)0)
#define ROOT ((STATE) 0)

// MATCH and SUFFIX are the top 2 bits of a TRAN:
enum { 
    IS_MATCH  = (TRAN)1 << (8*sizeof(TRAN) - 1),
    IS_SUFFIX = (TRAN)1 << (8*sizeof(TRAN) - 2),
    T_FLAGS   = IS_MATCH | IS_SUFFIX
};

typedef struct { STATE state; STRNO strno; } STRASH;

struct acism {
    TRAN*   tranv;
    STRASH* hashv;
    unsigned flags;
#   define IS_MMAP 1

#if ACISM_SIZE < 8
    TRAN sym_mask;
    unsigned sym_bits;
#endif
    unsigned hash_mod; // search hashv starting at (state + sym) % hash_mod.
    unsigned hash_size; // #(hashv): hash_mod plus the overflows past [hash_mod-1]
    unsigned tran_size; // #(tranv)
    unsigned nsyms, nchars, nstrs, maxlen;
    SYMBOL symv[256];
};

#include "acism.h"

// p_size: size of tranv + hashv
static INLINE_ size_t p_size(ACISM const *psp)
{ return psp->hash_size * sizeof*psp->hashv
       + psp->tran_size * sizeof*psp->tranv; }

static INLINE_ unsigned  p_hash(ACISM const *psp, STATE s)
    { return s * 107 % psp->hash_mod; }

static INLINE_ void set_tranv(ACISM *psp, void *mem)
    { psp->hashv = (STRASH*)&(psp->tranv = (TRAN*)mem)[psp->tran_size]; }

// TRAN accessors. For ACISM_SIZE=8, SYM_{BITS,MASK} do not use psp.

static INLINE_ TRAN      p_tran(ACISM const *psp, STATE s, _SYMBOL sym)
    { return psp->tranv[s + sym] ^ sym; }

static INLINE_ _SYMBOL t_sym(ACISM const *psp, TRAN t)    { (void)psp; return t & SYM_MASK; }
static INLINE_ STATE   t_next(ACISM const *psp, TRAN t)   { (void)psp; return (t & ~T_FLAGS) >> SYM_BITS; }
static INLINE_ int     t_isleaf(ACISM const *psp, TRAN t) { return t_next(psp, t) >= psp->tran_size; }
static INLINE_ int     t_strno(ACISM const *psp, TRAN t)  { return t_next(psp, t) - psp->tran_size; }
static INLINE_ _SYMBOL t_valid(ACISM const *psp, TRAN t)  { return !t_sym(psp, t); }

#endif//_ACISM_H

```

`acism.c`:

```c
/*
** Copyright (C) 2009-2014 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License Version 3 as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#include "_acism.h"

int
acism_more(ACISM const *psp, MEMREF const text,
           ACISM_ACTION *cb, void *context, int *statep)
{
    char const *cp = text.ptr, *endp = cp + text.len;
    STATE state = *statep;
    int ret = 0;

    while (cp < endp) {
        _SYMBOL sym = psp->symv[(uint8_t)*cp++];
        if (!sym) {
            // Input byte is not in any pattern string.
            state = ROOT;
            continue;
        }

        // Search for a valid transition from this (state, sym),
        //  following the backref chain.

        TRAN next;
        while (!t_valid(psp, next = p_tran(psp, state, sym)) && state != ROOT) {
            TRAN back = p_tran(psp, state, BACK);
            state = t_valid(psp, back) ? t_next(psp, back) : ROOT;
        }

        if (!t_valid(psp, next))
            continue;

        if (!(next & (IS_MATCH | IS_SUFFIX))) {
            // No complete match yet; keep going.
            state = t_next(psp, next);
            continue;
        }

        // At this point, one or more patterns have matched.
        // Find all matches by following the backref chain.
        // A valid node for (sym) with no SUFFIX flag marks the
        //  end of the suffix chain.
        // In the same backref traversal, find a new (state),
        //  if the original transition is to a leaf.

        STATE s = state;

        // Initially state is ROOT. The chain search saves the
        //  first state from which the next char has a transition.
        state = t_isleaf(psp, next) ? 0 : t_next(psp, next);

        while (1) {

            if (t_valid(psp, next)) {

                if (next & IS_MATCH) {
                    unsigned strno, ss = s + sym, i;
                    if (t_isleaf(psp, psp->tranv[ss])) {
                        strno = t_strno(psp, psp->tranv[ss]);
                    } else {
                        for (i = p_hash(psp, ss); psp->hashv[i].state != ss; ++i);
                        strno = psp->hashv[i].strno;
                    }

                    if ((ret = cb(strno, cp - text.ptr, context)))
                        goto EXIT;
                }
                // If the original match was a leaf, state was set to 0, to be set
                //  The first node in the backref chain with a forward transition
                if (!state && !t_isleaf(psp, next))
                    state = t_next(psp, next);
                if ( state && !(next & IS_SUFFIX))
                    break;
            }

            if (s == ROOT)
                break;

            TRAN b = p_tran(psp, s, BACK);
            s = t_valid(psp, b) ? t_next(psp, b) : ROOT;
            next = p_tran(psp, s, sym);
        }
    }
EXIT:
    return *statep = state, ret;
}
//EOF

```

`acism.h`:

```h
/*
** Copyright (C) 2009-2014 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#ifndef ACISM_H
#define ACISM_H

#ifdef __cplusplus
#   define ENTER_C extern "C" {
#   define LEAVE_C }
#else
#   define ENTER_C
#   define LEAVE_C
#endif

ENTER_C

// VS2013 does not have "inline". Per https://github.com/PerMagnusH
#   undef  INLINE_
#ifdef  _MSC_VER
#   define INLINE_ __inline
#else
#   define INLINE_ inline
#endif//_MSC_VER

// "acism" uses MEMREF {ptr,len} bytevec structs for "string" args,
// rather than NUL-terminated "C" strings.

#ifndef MSUTIL_H
#include <stdio.h>
typedef struct { char const *ptr; size_t len; } MEMREF;
#endif

typedef struct acism ACISM;

ACISM* acism_create(MEMREF const *strv, int nstrs);
void   acism_destroy(ACISM*);

// For each match, acism_scan calls its ACISM_ACTION fn,
//  giving it the strv[] index of the matched string,
//  and the text[] offset of the byte PAST the end of the string.
// If ACISM_ACTION returns 0, search continues; otherwise,
//  acism_more returns that nonzero value immediately.

typedef int (ACISM_ACTION)(int strnum, int textpos, void *context);

// If sequential blocks of (text) are passed to repeated acism_more calls,
//  then search continues where the previous acism_more left off --
//  string matches can cross block boundaries.
// *state should initially be (0).

int acism_more(ACISM const*, MEMREF const text,
                 ACISM_ACTION *fn, void *fndata, int *state);

static INLINE_ int acism_scan(ACISM const*psp, MEMREF const text,
                               ACISM_ACTION *fn, void *fndata)
{
    int state = 0;
    return acism_more(psp, text, fn, fndata, &state);
}

void   acism_save(FILE*, ACISM const*);
ACISM* acism_load(FILE*);
ACISM* acism_mmap(FILE*);

// diagnostics
typedef enum {
    PS_STATS=1, PS_TRAN=2, PS_HASH=4, PS_TREE=8, PS_ALL=-1
} PS_DUMP_TYPE;

// If (pattv) is not NULL, dump output includes strings.
void acism_dump(ACISM const*, PS_DUMP_TYPE, FILE*, MEMREF const*pattv);

#define ACISM_STATS 1   // Collect perf stats during acism_create (see acism_dump).

LEAVE_C
#endif//ACISM_H

```

`acism.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27703.2042
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{BF870F04-8306-4C74-B253-F9FD6566E94C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "acism", "acism.vcxproj", "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "acism_x", "acism_x.vcxproj", "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}"
	ProjectSection(ProjectDependencies) = postProject
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001} = {8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}.Debug|x64.ActiveCfg = Debug|x64
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}.Debug|x64.Build.0 = Debug|x64
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}.Debug|x86.ActiveCfg = Debug|Win32
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}.Debug|x86.Build.0 = Debug|Win32
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}.Release|x64.ActiveCfg = Release|x64
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}.Release|x64.Build.0 = Release|x64
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}.Release|x86.ActiveCfg = Release|Win32
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}.Release|x86.Build.0 = Release|Win32
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}.Debug|x64.ActiveCfg = Debug|x64
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}.Debug|x64.Build.0 = Debug|x64
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}.Debug|x86.ActiveCfg = Debug|Win32
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}.Debug|x86.Build.0 = Debug|Win32
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}.Release|x64.ActiveCfg = Release|x64
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}.Release|x64.Build.0 = Release|x64
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}.Release|x86.ActiveCfg = Release|Win32
		{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {58B431D4-08C1-49BA-882A-F289D9ED4ACB}
	EndGlobalSection
EndGlobal

```

`acism.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC001}</ProjectGuid>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <TargetExt>.lib</TargetExt>
  </PropertyGroup>
  <ItemGroup>
    <ClCompile Include="acism.c">
      <AssemblerOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NoListing</AssemblerOutput>
      <AssemblerOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NoListing</AssemblerOutput>
    </ClCompile>
    <ClCompile Include="acism_create.c" />
    <ClCompile Include="acism_dump.c" />
    <ClCompile Include="acism_file.c" />
    <ClCompile Include="msutil.c" />
    <ClCompile Include="tap.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="acism.h" />
    <ClInclude Include="_acism.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`acism_create.c`:

```c
/*
** Copyright (C) 2009-2014 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License Version 3 as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/
#include "_acism.h"

typedef enum { BASE=2, USED=1 } USES;

typedef struct tnode {
    struct tnode *child, *next, *back;
    // nrefs was used in "prune_backlinks".
    //  It will be used again in "curtail".
    unsigned    nrefs;
    STATE       state;
    STRNO       match;
    SYMBOL      sym;
    char        is_suffix;      // "bool"
} TNODE;

//--------------|---------------------------------------------
// bitwid: 1+floor(log2(u))
static inline int bitwid(unsigned u)
{
    int ret = !!u;
    if (u & 0xFFFF0000) u >>= 16, ret += 16;
    if (u & 0x0000FF00) u >>= 8, ret += 8;
    if (u & 0x000000F0) u >>= 4, ret += 4;
    if (u & 0x0000000C) u >>= 2, ret += 2;
    if (u & 0x00000002) ret++;
    return ret;
}

static void   fill_symv(ACISM*, MEMREF const*, int ns);
static int    create_tree(TNODE*, SYMBOL const*symv, MEMREF const*strv, int nstrs);
static void   add_backlinks(TNODE*, TNODE**, TNODE**);
static int    interleave(TNODE*, int nnodes, int nsyms, TNODE**, TNODE**);
static void   fill_tranv(ACISM*, TNODE const*);
static void   fill_hashv(ACISM*, TNODE const*, int nn);

static TNODE* find_child(TNODE*, SYMBOL);

// (ns) is either a STATE, or a (STRNO + tran_size)
static inline void
set_tran(ACISM *psp, STATE s, SYMBOL sym, int match, int suffix, TRAN ns)
{
    psp->tranv[s + sym] = sym    | (match ? IS_MATCH : 0) 
                                | (suffix ? IS_SUFFIX : 0)
                                | (ns << SYM_BITS);
}

// Track statistics for construction
#ifdef ACISM_STATS
typedef struct { long long val; const char *name; } PSSTAT;
extern PSSTAT psstat[];
# define NOTE(n) (psstat[__LINE__] = (PSSTAT) {n, #n})
# define HIT(id) (psstat[__LINE__].val++, psstat[__LINE__].name = id)
#else
# define NOTE(n) (void)0
# define HIT(id) (void)0
#endif //ACISM_STATS

//--------------|---------------------------------------------
ACISM*
acism_create(MEMREF const* strv, int nstrs)
{
    TNODE **v1 = NULL, **v2 = NULL;
    ACISM *psp = calloc(1, sizeof*psp);

    fill_symv(psp, strv, nstrs);
    TNODE *troot = calloc(psp->nchars + 1, sizeof*troot);

    int nnodes = create_tree(troot, psp->symv, strv, nstrs);
    NOTE(nnodes);

    // v1, v2: breadth-first work vectors for add_backlink and interleave.
    int i = (nstrs + 1) * sizeof(TNODE);
    add_backlinks(troot, v1 = malloc(i), v2 = malloc(i));
    
    int     nhash = 0;
    TNODE*  tp = troot + nnodes;
    while (--tp > troot)
        nhash += tp->match && tp->child;
    
    // Calculate each node's offset in tranv[]:
    psp->tran_size = interleave(troot, nnodes, psp->nsyms, v1, v2);
    if (bitwid(psp->tran_size + nstrs - 1) + SYM_BITS > sizeof(TRAN)*8 - 2)
        goto FAIL;

    if (nhash) {
        // Hash table is for match info of non-leaf nodes (only).
        // Set hash_size for p_size(psp):
        psp->hash_mod = nhash * 5 / 4 + 1;
        // Initially oversize the table for overflows without wraparound.
        psp->hash_size = psp->hash_mod + nhash;
    }

    set_tranv(psp, calloc(p_size(psp), 1));
    if (!psp->tranv) goto FAIL;
    fill_tranv(psp, troot);
    // The root state (0) must not look like a valid backref.
    // Any symbol value other than (0) in tranv[0] ensures that.
    psp->tranv[0] = 1;

    if (nhash) {
        fill_hashv(psp, troot, nnodes);
        // Adjust hash_size to include trailing overflows
        //  but trim trailing empty slots.
        psp->hash_size = psp->hash_mod;
        while ( psp->hashv[psp->hash_size].state)     ++psp->hash_size;
        while (!psp->hashv[psp->hash_size - 1].state) --psp->hash_size;
        set_tranv(psp, realloc(psp->tranv, p_size(psp)));
    }

        // Diagnostics/statistics only:
    psp->nstrs = nstrs;
    for (i = psp->maxlen = 0; i < nstrs; ++i)
        if (psp->maxlen < strv[i].len) psp->maxlen = strv[i].len;

    goto DONE;
FAIL: acism_destroy(psp), psp = NULL;
DONE: free(troot), free(v1), free(v2);
    return psp;
}

typedef struct { int freq, rank; } FRANK;
static int frcmp(FRANK*a, FRANK*b) { return a->freq - b->freq; }

static void
fill_symv(ACISM *psp, MEMREF const *strv, int nstrs)
{
    int i, j;
    FRANK frv[256];

    for (i = 0; i < 256; ++i) frv[i] = (FRANK){0,i};
    for (i = 0; i < nstrs; ++i)
        for (psp->nchars += j = strv[i].len; --j >= 0;)
            frv[(uint8_t)strv[i].ptr[j]].freq++;

    qsort(frv, 256, sizeof*frv, (qsort_cmp)frcmp);

    for (i = 256; --i >= 0 && frv[i].freq;)
        psp->symv[frv[i].rank] = ++psp->nsyms;
    ++psp->nsyms;

#if ACISM_SIZE < 8
    psp->sym_bits = bitwid(psp->nsyms);
    psp->sym_mask = ~(~0 << psp->sym_bits);
#endif
}

static int
create_tree(TNODE *Tree, SYMBOL const *symv, MEMREF const *strv, int nstrs)
{
    int i, j;
    TNODE *nextp = Tree + 1;

    for (i = 0; i < nstrs; ++i) {
        TNODE *tp = Tree;

        for (j = 0; tp->child && j < (int)strv[i].len; ++j) {
            SYMBOL sym = symv[(uint8_t)strv[i].ptr[j]];

            if (sym < tp->child->sym) {
                // Prep to insert new node before tp->child
                nextp->next = tp->child;
                break;
            }

            tp = tp->child;
            while (tp->next && sym >= tp->next->sym)
                tp = tp->next;

            // Insert new sibling after tp
            if (sym > tp->sym) {
                nextp->next = tp->next;
                tp = tp->next = nextp++;
                tp->sym = sym;
                tp->back = Tree;
            }
        }

        for (; j < (int) strv[i].len; ++j) {
            tp = tp->child = nextp++;
            tp->sym = symv[(uint8_t)strv[i].ptr[j]];
            tp->back = Tree;
        }

        tp->match = i + 1; // Encode strno as nonzero
    }

    return nextp - Tree;
}

static void
add_backlinks(TNODE *troot, TNODE **v1, TNODE **v2)
{
    TNODE *tp, **tmp;

    for (tp = troot->child, tmp = v1; tp; tp = tp->next)
        *tmp++ = tp;
    *tmp = NULL;

    while (*v1) {
        TNODE **spp = v1, **dpp = v2, *srcp, *dstp;

        while ((srcp = *spp++)) {
            for (dstp = srcp->child; dstp; dstp = dstp->next) {
                TNODE *bp = NULL;
                if (dstp->child)
                    *dpp++ = dstp;

                // Go through the parent (srcp) node's backlink chain,
                //  looking for a useful backlink for the child (dstp).
                // If the parent (srcp) has a backlink to (tp),
                //  and (tp) has a child matching the transition sym 
                //  for (srcp -> dstp), then it is a useful backlink 
                //  for the child (dstp).
                // Note that backlinks do not point at the suffix match;
                //  they point at the PARENT of that match.

                for (tp = srcp->back; tp; tp = tp->back)
                    if ((bp = find_child(tp, dstp->sym)))
                        break;
                if (!bp)
                    bp = troot;

                dstp->back = dstp->child ? bp : tp ? tp : troot;
                dstp->back->nrefs++;
                dstp->is_suffix = bp->match || bp->is_suffix;
            }
        }
        *dpp = 0;
        tmp = v1; v1 = v2; v2 = tmp;
    }
}

static int
interleave(TNODE *troot, int nnodes, int nsyms, TNODE **v1, TNODE **v2)
{
    unsigned usev_size = nnodes + nsyms;
    char *usev = calloc(usev_size, sizeof*usev);
    STATE last_trans = 0, startv[257][2] = { 0 };
    TNODE *cp, **tmp;

    memset(startv, 0, nsyms * sizeof*startv);

    // Iterate through one level of the Tree at a time.
    //  That srsly improves locality (L1-cache use).

    v1[0] = troot, v1[1] = NULL;
    for (; *v1; tmp = v1, v1 = v2, v2 = tmp) {
        TNODE **srcp = v1, **dstp = v2, *tp;
        while ((tp = *srcp++)) {
            if (!tp->child) continue;

            HIT("nonleaf");
            if (tp->back == troot) tp->back = NULL; // simplify tests.
            cp = tp->child;

            STATE pos, *startp = &startv[cp->sym][!!tp->back];
            while ((cp = cp->next)) {
                STATE *newp = &startv[cp->sym][!!tp->back];
                if (*startp < *newp) startp = newp;
            }

            // If (tp) has a backref, we need a slot at offset 0
            //  that is free as a base AND to be used (filled in).
            char need = tp->back ? BASE|USED : BASE;
            for (pos = *startp;; ++pos) {
                if (usev[pos] & need) {
                    HIT("inner loop");
                    continue;
                }

                for (cp = tp->child; cp; cp = cp->next) {
                    HIT("child loop");
                    if (usev[pos + cp->sym] & USED) break;
                }

                // No child needs an in-use slot? We're done.
                if (!cp) break;
            }
            tp->state = pos;

            // Mark node's base and children as used:
            usev[pos] |= need;
            STATE last = 0; // Make compiler happy
            int nkids = 0;
            for (cp = tp->child; cp; *dstp++ = cp, cp = cp->next, ++nkids)
                usev[last = pos + cp->sym] |= USED;

            // This is a HEURISTIC for advancing search for other nodes
            *startp += (pos - *startp) / nkids;

            if (last_trans < last) {
                last_trans = last;
                if (last + nsyms >= usev_size) {
                    usev = realloc(usev, usev_size << 1);
                    memset(usev + usev_size, 0, usev_size);
                    usev_size <<= 1;
                }
            }
        }

        *dstp = NULL;
    }

    free(usev);
    return last_trans + 1;
}

static void
fill_hashv(ACISM *psp, TNODE const treev[], int nnodes)
{
    STRASH *sv = malloc(psp->hash_mod * sizeof*sv), *sp = sv;
    int i;

    // First pass: insert without resolving collisions.
    for (i = 0; i < nnodes; ++i) {
        STATE base = treev[i].state;
        TNODE const *tp;
        for (tp = treev[i].child; tp; tp = tp->next) {
            if (tp->match && tp->child) {
                STATE state = base + tp->sym;
                STRASH *hp = &psp->hashv[p_hash(psp, state)];
                *(hp->state ? sp++ : hp) = (STRASH){state, tp->match - 1};
            }
        }
    }

    while (--sp >= sv) {
        HIT("hash collisions");
        for (i = p_hash(psp, sp->state); psp->hashv[i].state; ++i)
            HIT("hash displacements");
        psp->hashv[i] = *sp;
    }

    free(sv);
}

static void
fill_tranv(ACISM *psp, TNODE const*tp)
{
    TNODE const *cp = tp->child;

    if (cp && tp->back)
            set_tran(psp, tp->state, 0, 0, 0, tp->back->state);

    for (; cp; cp = cp->next) {
        //NOTE: cp->match is (strno+1) so that !cp->match means "no match".
        set_tran(psp, tp->state, cp->sym, cp->match, cp->is_suffix,
                   cp->child ? cp->state : cp->match - 1 + psp->tran_size);
        if (cp->child)
            fill_tranv(psp, cp);
    }
}

static TNODE *
find_child(TNODE *tp, SYMBOL sym)
{
    for (tp = tp->child; tp && tp->sym < sym; tp = tp->next);
    return tp && tp->sym == sym ? tp : NULL;
}

#ifdef ACISM_STATS
PSSTAT psstat[__LINE__] = {{__LINE__,0}};
#endif//ACISM_STATS
//EOF

```

`acism_dump.c`:

```c
/*
** Copyright (C) 2009-2014 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License Version 3 as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/
#include <ctype.h>
#include <stdio.h>
#include "_acism.h"

#if ACISM_SIZE == 4
#   define FX   ""
#elif __LONG_MAX__ < 9223372036854775807
#   define FX   "ll"
#else
#   define FX   "l"
#endif

static void putb(FILE*out, int ch)   
{
    fprintf(out, isprint(ch) ? "'%c" : "%02.2X", ch);
}

static void putsym(FILE*out, int sym, char const*charv)
{
    if (sym) putb(out, charv[sym]); else fputs("--", out);
}

static void printrans(ACISM const*,TRAN,const char*,FILE*,MEMREF const*);
static void printree(ACISM const* psp,
                        int state,
                        int depth,
                        char* str,
                        const char* charv,
                        FILE* out,
                        MEMREF const* pattv);

#define PSTR(_psp,_i,_pattv) _i, \
        _pattv ? (int)_pattv[_i].len : 0, \
        _pattv ? _pattv[_i].ptr : ""

//--------------|---------------------------------------------
void
acism_dump(ACISM const* psp, PS_DUMP_TYPE pdt, FILE *out, MEMREF const*pattv)
{
    int         i, empty, symdist[257] = { 0 };
    char        charv[256];
 
    for (i = 256; --i >=0;) charv[psp->symv[i]] = i;

    if (pdt & PS_STATS) {
        for (i = psp->tran_size, empty = 0; --i >= 0;) {
            if (psp->tranv[i]) {
                ++symdist[t_sym(psp, psp->tranv[i])];
            } else ++empty;
        }
        fprintf(out, "strs:%d syms:%d chars:%d "
                     "trans:%d empty:%d mod:%d hash:%d size:%lu\n",
                psp->nstrs, psp->nsyms, psp->nchars,
                psp->tran_size, empty, psp->hash_mod, psp->hash_size,
                (long)sizeof(ACISM) + p_size(psp));
    }

    // For TRAN/HASH/TREE, print a symbol map (sym -> char/byte).
    if (pdt & ~PS_STATS) {
         for (i = 1; i < (int)psp->nsyms; i++) {
             fprintf(out, "  %u:", i); putsym(out, i, charv);
         }
         putc('\n', out);
     }

    if (pdt & PS_TRAN) {
        fprintf(out, "==== TRAN:\n%8s %8s %3s Ch MS Ref\n", "Cell", "State", "Sym");
        for (i = 1; i < (int)psp->tran_size; ++i) {
            printrans(psp, i, charv, out, pattv);
        }
    }

    if (pdt & PS_HASH && psp->hash_size) {
        fprintf(out, "==== HASH:\n.....:   state strno\n");
        for (i = 0; i < (int)psp->hash_size; ++i) {
            STATE state = psp->hashv[i].state;
            if (state)
                fprintf(out, "%5d: %7"FX"u %3d %8"FX"u %.*s\n",
                        i, state, i - p_hash(psp, state), 
                        PSTR(psp, psp->hashv[i].strno, pattv));
            else
                fprintf(out, "%5d: %7"FX"d --- %8"FX"d\n", i, state,
                        psp->hashv[i].strno);
        }
    }

    if (pdt & PS_TREE) {
        fprintf(out, "==== TREE:\n");
        char *str = (char*)malloc(psp->maxlen + 1);
        printree(psp, 0, 0, str, charv, out, pattv);
        free(str);
    }
    //TODO: calculate stats: backref chain lengths ...
}

static void
printrans(ACISM const*psp, STATE s, char const *charv,
            FILE *out, MEMREF const *pattv)
{
    (void)pattv;
    TRAN x = psp->tranv[s];
    if (!x) {
        fprintf(out, "%8d (empty)\n", s);
        return;
    }

    SYMBOL sym = t_sym(psp, x);
    fprintf(out, "%8d %8d %3u ", s, s - sym, sym);
    putsym(out, sym, charv);
    putc(' ', out);
    putc("M-"[!(x & IS_MATCH)], out);
    putc("S-"[!(x & IS_SUFFIX)], out);

    STATE next = t_next(psp, x);
    if (t_isleaf(psp, x)) {
        fprintf(out, " str= %d\n", t_strno(psp, x));
    } else {
        fprintf(out, " %s %d", sym == 0 ? "back" : "next", next);
        if (x & IS_MATCH) {
            int i;
            for (i = p_hash(psp, s); psp->hashv[i].state != s; ++i);
            fprintf(out, " str# %"FX"d", psp->hashv[i].strno);
        }
        putc('\n', out);
    }
}
static void
printree(ACISM const*psp, int state, int depth, char *str,
            char const *charv, FILE*out, MEMREF const*pattv)
{
    SYMBOL sym;
    TRAN x;

    if (depth > (int)psp->maxlen) {
        fputs("oops\n", out);
        return;
    }

    x = psp->tranv[state];
    fprintf(out, "%5d:%.*s", state, depth, str);
    if (t_valid(psp,x) && t_next(psp,x))
        fprintf(out, " b=%"FX"d%s", t_next(psp,x), x & T_FLAGS ? " BAD" : "");
    fprintf(out, "\n");

    for (sym = 1; sym < psp->nsyms; ++sym) {
        x = p_tran(psp, state, sym);
        if (t_valid(psp, x)) {
            str[depth] = charv[sym];
            fprintf(out, "%*s%c %c%c",
                    depth+6, "", charv[sym],
                    x & IS_MATCH ? 'M' : '-',
                    x & IS_SUFFIX ? 'S' : '-');
            if (x & IS_MATCH && pattv && t_isleaf(psp, x))
                fprintf(out, " %.0d -> %.*s", PSTR(psp, t_strno(psp,x), pattv));
            if (x & IS_SUFFIX)
                fprintf(out, " ->S %"FX"d", t_next(psp, psp->tranv[state]));
            fprintf(out, "\n");
            if (!t_isleaf(psp, x))
                printree(psp, t_next(psp, x), depth+1, str, charv, out, pattv);
        }
    }
}

//EOF

```

`acism_file.c`:

```c
/*
** Copyright (C) 2009-2014 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License Version 3 as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#include "msutil.h"
#include "_acism.h"
#include <assert.h>
#include <stdio.h>
#if !defined(_MSC_VER)
#   include <unistd.h>
#	include <sys/mman.h>
#endif

#ifndef MAP_NOCORE
# define MAP_NOCORE 0
#endif

void
acism_save(FILE *fp, ACISM const*psp)
{
    ACISM ps = *psp;
    // Overwrite pointers with magic signature.
    assert(8 <= sizeof ps.tranv + sizeof ps.hashv);
    memcpy(&ps, "ACMischa", 8);
    ps.flags &= ~IS_MMAP;
    fwrite(&ps, sizeof(ACISM), 1, fp);
    fwrite(psp->tranv, p_size(psp), 1, fp);
}

ACISM*
acism_load(FILE *fp)
{
    ACISM *psp = calloc(sizeof(ACISM), 1);

    if (fread(psp, sizeof(ACISM), 1, fp) == 1
            && !memcmp(psp, "ACMischa", 8)
            && (set_tranv(psp, malloc(p_size(psp))), 1)
            && fread(psp->tranv, p_size(psp), 1, fp)) {
        return psp;
    }

    acism_destroy(psp);
    return NULL;
}

#if !defined(_MSC_VER)
//XXX add mmap for VS
ACISM*
acism_mmap(FILE *fp)
{
    ACISM *mp = mmap(0, lseek(fileno(fp), 0L, 2), PROT_READ,
                    MAP_SHARED|MAP_NOCORE, fileno(fp), 0);
    if (mp == MAP_FAILED) return NULL;

    ACISM *psp = malloc(sizeof*psp);
    *psp = *(ACISM*)mp;
    psp->flags |= IS_MMAP;
    if (memcmp(psp, "ACMischa", 8)) {
        acism_destroy(psp);
        return NULL;
    }

    set_tranv(psp, ((char *)mp) + sizeof(ACISM));
    return psp;
}
#endif//_MSC_VER

void
acism_destroy(ACISM *psp)
{
    if (!psp) return;
#ifdef XXX
    if (psp->flags & IS_MMAP)
        munmap((char*)psp->tranv - sizeof(ACISM), sizeof(ACISM) + p_size(psp));
    else
#endif//XXX
        free(psp->tranv);
    free(psp);
}
//EOF

```

`acism_mmap_x.c`:

```c
/*
** Copyright (C) 2009-2014 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License Version 3 as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#include "msutil.h"
#include "tap.h"
#include "acism.h"

static int nmatches = 0;
static int on_match(int,int,void*);

int
main(int argc, char **argv)
{
    if (argc != 3) die(": requires args: acism_file text_file");

    plan_tests(2);

    FILE *pfp = fopen(argv[1], "r");
    if (!pfp) die(": unable to open %s:", argv[1]);

    MEMREF text = bufref(slurp(argv[2]));
    if (nilref(text)) die(": unable to load %s:", argv[2]);

    ACISM *psp = acism_mmap(pfp);
    ok(psp, "acism_mmap returned");
    fclose(pfp);
    double t0 = tick();
    ok(!acism_scan(psp, text, on_match, NULL),
        "mmap-ed acism object works");

    fprintf(stderr, "# nmatches: %d %.4f secs\n", nmatches, tick() - t0);
    acism_dump(psp, PS_STATS, stderr, NULL);
    acism_destroy(psp);

    return exit_status();
}

static int
on_match(int s, int t, void *c)
{
    (void)s, (void)t, (void)c;
    ++nmatches;
    return 0;
}

```

`acism_strings.c`:

```c
/*
** Copyright (C) 2009-2013 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License Version 3 as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

// acism_strings: reconstruct the input to acism_create.
// Returns: number of strings in strv[].
// strv[] entries are returned in lexical order, not
// necessarily the original order given to acism_create.
// strv[0].ptr points to a contiguous data block to which
// all strv[].ptrs refer.
// The data block size (in bytes) is:
// strv[nstrs-1].ptr - strv[0].ptr + strv[nstrs-1].len
// or alternately, the sum of strv[].len values.

#include "_acism.h"
#ifdef _MSC_VER
#   include <malloc.h>		// Unix alloca is declared in <unistd.h>
#endif//_MSC_VER

typedef struct { MEMREF *strp; char *data; int seqv[256]; } VISIT;

static void visit(VISIT*, ACISM const *psp, TRAN base, int depth);

MEMREF*
acism_strings(ACISM const *psp, int *pnstrs)
{
    char*   data = malloc(psp->nchars);
    MEMREF* strv = malloc(psp->nstrs * sizeof*strv);
    VISIT   vt = { strv, data };

    int     j;
    for (int i = j = 0; i < 256; i++) if (psp->symv[i]) vt.seqv[j++] = i;
    vt.seqv[j] = 0;

    visit(&vt, psp, 0, 0);

    *pnstrs = psp->nstrs;
    return strv;
}

static void
visit(VISIT *vp, ACISM const *psp, TRAN base, int depth)
{
    for (int i = 0; i < psp->nsyms; ++i) {
        TRAN t = t_trans(psp, base, vp->seqv[i]);
        if (!t_valid(psp, t))
            continue;
        //XXX do something!
    }
}

```

`acism_x.c`:

```c
#include "msutil.h"
#include <errno.h> 
#include <fcntl.h> // open(2)
#include "tap.h"
#include "acism.h"

// Move this to common plat.h
#if defined(_MSC_VER)
#define _CRT_SECURE_NO_WARNINGS	1
static FILE* FOPEN(char const*path, char const*mode)
{
    FILE* fp;  return fopen_s(&fp, path, mode) ? NULL : fp;
}
#else//not _MSC_VER
#define FOPEN fopen
#endif//_MSC_VER

#ifdef ACISM_STATS
typedef struct { long long val; const char *name; } PSSTAT;
extern PSSTAT psstat[];
extern int pscand[];
#endif//ACISM_STATS

static int actual = 0, details = 1;

static int
on_match(int strnum, int textpos, MEMREF const *pattv)
{
    (void)strnum, (void)textpos, (void)pattv;
    ++actual;
    if (details) fprintf(stderr, "%9d %7d '%.*s'\n", textpos, strnum, (int)pattv[strnum].len, pattv[strnum].ptr);
    return 0;
}

int
main(int argc, char **argv)
{
    if (argc < 2 || argc > 4)
        usage("pattern_file target_file [[-]expected]\ne.g. acism_x patts act.txt -5");

    MEMBUF patt = chomp(slurp(argv[1]));
    if (!patt.ptr)
        die("cannot read %s", argv[1]);

    int npatts;
    MEMREF *pattv = refsplit(patt.ptr, '\n', &npatts);

    double t = tick();
    ACISM *psp = acism_create(pattv, npatts);
    t = tick() - t;

    plan_tests(argc < 3 ? 1 : 3);

    ok(psp, "acism_create(pattv[%d]) compiled, in %.3f secs", npatts, t);
    acism_dump(psp, PS_ALL, stderr, pattv);
#ifdef ACISM_STATS
    {
    int i;
    for (i = 1; i < (int)psstat[0].val; ++i)
        if (psstat[i].val)
            fprintf(stderr, "%11llu %s\n", psstat[i].val, psstat[i].name);
    }
#endif//ACISM_STATS

    diag("state machine saved as acism.tmp");
    FILE *fp = FOPEN("acism.tmp", "w");
    acism_save(fp, psp);
    fclose(fp);

    if (argc > 2) {
        // Negative count => print match details
        int expected = argc > 3 ? atoi(argv[3]) : 0;
        int details = expected < 0;
        if (details) expected = -expected;
        FILE*	textfp = FOPEN(argv[2], "r");		// REUSE PATTERN FILE AS A TARGET
        if (!fp) die("cannot open %s", argv[2]);
        static char buf[1024*1024];
        MEMREF		text = {buf, 0};
        int			state = 0;
        double		elapsed = 0, start = tick();
        while (0 < (text.len = fread(buf, sizeof*buf, sizeof buf, textfp))) {
            t = tick();
            (void)acism_more(psp, text, (ACISM_ACTION*)on_match, pattv, &state);
            elapsed += tick() - t;
            putc('.', stderr);
        }
        putc('\n', stderr);
        fclose(textfp);
        ok(text.len == 0, "text_file scanned in 1M blocks; read(s) took %.3f secs", tick() - start - elapsed);

        if (!ok(actual == expected || expected == 0, "%d matches found, in %.3f secs", actual, elapsed))
            diag("actual: %d\n", actual);
    }

    buffree(patt);
    free(pattv);
    acism_destroy(psp);

    return exit_status();
}

```

`acism_x.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC002}</ProjectGuid>
    <RootNamespace>acism_x</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
    <ProjectName>acism_x</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>$(IntDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>acism.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>$(IntDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>acism.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(IntDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>acism.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(IntDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>acism.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="acism_x.c" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="patt.txt" />
    <Text Include="test.txt" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`acism_x.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>perfgao.txt perfgao.txt -21</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LocalDebuggerCommandArguments>perfgao.txt perfgao.txt -21</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>perfgao.txt perfgao.txt -21</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommandArguments>perfgao.txt perfgao.txt -21</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`deas`:

```
#!/usr/bin/env perl
use strict;
use warnings;

sub slurpv { open my $fh, $_[0] or die "cannot open $_[0]"; [<$fh>]; }

for my $fname (@ARGV) {
    my @file;       # maps fileno(1...) to [file_lines]
    my $src = slurpv $fname;

    # Calculate simpler labels for jumps.
    # "F.." if a label is only the target of fwd jumps.
    # "B.." if a label is only the target of back jumps.
    # "L.." otherwise

    my %labdef;     # Map .Lxxx to 1...
    my %labuse;     # indicates F and B uses of a label.
    my $labnum = 0;
    for (@$src) {
        if (m{^(\.L[0-9]*):}) {     # ascending numbers for labels
            $labdef{$1} = ++$labnum;
        } elsif (m{\tj[bplasmogen].*(\.L[0-9]*)$}) { # jump => interesting label
            $labuse{$1} = ($labuse{$1} || '') . ($labdef{$1} ? 'B' : 'F');
        } elsif (!m{ "/usr/|<built-in>} && m{\.file (\d+) "([^"]*)"}) {   # source file declaration
            # gcc 4.3.4 may emit "file N <built-in>"
            $file[$1] = -f $2 ? slurpv $2 : [];
            s/^\s*}\s*$|.*(?:__builtin|__extension).*// for @{$file[$1]};
        }
    }

    s{.*FB}{L} for values %labuse;
    $labdef{$_} = substr($labuse{$_},0,1) . $labdef{$_} for keys %labuse;

    # Reprocess output, inserting source lines and replacing labels:
  
    open my $out, ">$fname.tmp" or die "$fname.tmp: cannot create";
    my $skip;
    for (@$src) {
        next if m{^#APP|^#NO|^# .*""};

        # Eliminate C++ template output: /^_ZN\S+:$/,/^\w/-1
        $skip = 0 if m{^_ZN}; $skip = 1 if m{^_ZNSt\S+:$};
        next if $skip;

        # Simplify mangled names:
        #XXX properly decode <count><chars>... DNS-like encoding
        s{\b_Z[KNSt]+\d+}{};
        s{(-?\d{5,20}(?!\(%[a-z]*bp))}{sprintf "0x%X",$1}eg;

        if (m{\.loc\s+(\d+)\s+(\d+)}) { # source file reference
            my $n = $2;
            s{^\s*}{#[$n]\t} if $_ = $file[$1][$n - 1] and m{\w};
            $file[1][$n - 1] = '';
        } elsif (m{^(\.L[0-9]*):}) {    # <label>:
            $_ = "$labdef{$1}:";
        } elsif (my ($L) = m{\tj[bplasmogen].*(\.L[0-9]*)$}) {  # jump <label>
            s{$L}{$labdef{$L}};
        }
        print $out $_ if ($_ && !m{^\t?\.} && !m<^[\t\n {};]*$>sg);
    }

    close $out;
    rename "$fname.tmp", $fname;
}

```

`msutil.c`:

```c
/*
** Copyright (C) 2009-2014 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License Version 3 as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/
// msutil: generic utility functions not dependent on any engine components.

#include "msutil.h"

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>    // open O_RDONLY
#include <stdarg.h>
#include <sys/stat.h>

char const *errname[] = {
    /*_00*/ "",              "EPERM",           "ENOENT",       "ESRCH",           "EINTR",
    /*_05*/ "EIO",           "ENXIO",           "E2BIG",        "ENOEXEC",         "EBADF",
    /*_10*/ "ECHILD",        "EAGAIN",          "ENOMEM",       "EACCES",          "EFAULT",
    /*_15*/ "ENOTBLK",       "EBUSY",           "EEXIST",       "EXDEV",           "ENODEV",
    /*_20*/ "ENOTDIR",       "EISDIR",          "EINVAL",       "ENFILE",          "EMFILE",
    /*_25*/ "ENOTTY",        "ETXTBSY",         "EFBIG",        "ENOSPC",          "ESPIPE",
    /*_30*/ "EROFS",         "EMLINK",          "EPIPE",        "EDOM",            "ERANGE",
#if   defined(__FreeBSD__)
    /*_35*/ "EDEADLK",       "EINPROGRESS",     "EALREADY",     "ENOTSOCK",        "EDESTADDRREQ",
    /*_40*/ "EMSGSIZE",      "EPROTOTYPE",      "ENOPROTOOPT",  "EPROTONOSUPPORT", "ESOCKTNOSUPPORT",
    /*_45*/ "EOPNOTSUPP",    "EPFNOSUPPORT",    "EAFNOSUPPORT", "EADDRINUSE",      "EADDRNOTAVAIL",
    /*_50*/ "ENETDOWN",      "ENETUNREACH",     "ENETRESET",    "ECONNABORTED",    "ECONNRESET",
    /*_55*/ "ENOBUFS",       "EISCONN",         "ENOTCONN",     "ESHUTDOWN",       "ETOOMANYREFS",
    /*_60*/ "ETIMEDOUT",     "ECONNREFUSED",    "ELOOP",        "ENAMETOOLONG",    "EHOSTDOWN",
    /*_65*/ "EHOSTUNREACH",  "ENOTEMPTY",       "EPROCLIM",     "EUSERS",          "EDQUOT",
    /*_70*/ "ESTALE",        "EREMOTE",         "EBADRPC",      "ERPCMISMATCH",    "EPROGUNAVAIL",
    /*_75*/ "EPROGMISMATCH", "EPROCUNAVAIL",    "ENOLCK",       "ENOSYS",          "EFTYPE",
    /*_80*/ "EAUTH",         "ENEEDAUTH",       "EIDRM",        "ENOMSG",          "EOVERFLOW",
    /*_85*/ "ECANCELED",     "EILSEQ",          "ENOATTR",      "EDOOFUS",         "EBADMSG",
    /*_90*/ "EMULTIHOP",     "ENOLINK",         "EPROTO"                           
#elif defined(__linux__)
    /*_35*/ "EDEADLK",       "ENAMETOOLONG",    "ENOLCK",       "ENOSYS",          "ENOTEMPTY",
    /*_40*/ "ELOOP",         "E041",            "ENOMSG",       "EIDRM",           "ECHRNG",
    /*_45*/ "EL2NSYNC",      "EL3HLT",          "EL3RST",       "ELNRNG",          "EUNATCH",
    /*_50*/ "ENOCSI",        "EL2HLT",          "EBADE",        "EBADR",           "EXFULL",
    /*_55*/ "ENOANO",        "EBADRQC",         "EBADSLT",      "E058",            "EBFONT",
    /*_60*/ "ENOSTR",        "ENODATA",         "ETIME",        "ENOSR",           "ENONET",
    /*_65*/ "ENOPKG",        "EREMOTE",         "ENOLINK",      "EADV",            "ESRMNT",
    /*_70*/ "ECOMM",         "EPROTO",          "EMULTIHOP",    "EDOTDOT",         "EBADMSG",
    /*_75*/ "EOVERFLOW",     "ENOTUNIQ",        "EBADFD",       "EREMCHG",         "ELIBACC",
    /*_80*/ "ELIBBAD",       "ELIBSCN",         "ELIBMAX",      "ELIBEXEC",        "EILSEQ",
    /*_85*/ "ERESTART",      "ESTRPIPE",        "EUSERS",       "ENOTSOCK",        "EDESTADDRREQ",
    /*_90*/ "EMSGSIZE",      "EPROTOTYPE",      "ENOPROTOOPT",  "EPROTONOSUPPORT", "ESOCKTNOSUPPORT",
    /*_95*/ "EOPNOTSUPP",    "EPFNOSUPPORT",    "EAFNOSUPPORT", "EADDRINUSE",      "EADDRNOTAVAIL",
    /*100*/ "ENETDOWN",      "ENETUNREACH",     "ENETRESET",    "ECONNABORTED",    "ECONNRESET",
    /*105*/ "ENOBUFS",       "EISCONN",         "ENOTCONN",     "ESHUTDOWN",       "ETOOMANYREFS",
    /*110*/ "ETIMEDOUT",     "ECONNREFUSED",    "EHOSTDOWN",    "EHOSTUNREACH",    "EALREADY",
    /*115*/ "EINPROGRESS",   "ESTALE",          "EUCLEAN",      "ENOTNAM",         "ENAVAIL",
    /*120*/ "EISNAM",        "EREMOTEIO",       "EDQUOT",       "ENOMEDIUM",       "EMEDIUMTYPE",
    /*125*/ "ECANCELED",     "ENOKEY",          "EKEYEXPIRED",  "EKEYREVOKED",     "EKEYREJECTED",
    /*130*/ "EOWNERDEAD",    "ENOTRECOVERABLE", "ERFKILL"                          
#endif
};
int const nerrnames = sizeof(errname)/sizeof(*errname);

MEMBUF
membuf(int size)
{ return size ? (MEMBUF){calloc(size+1, 1), size} : NILBUF; }

void
buffree(MEMBUF buf)
{ free(buf.ptr); }

int
nilbuf(MEMBUF buf)
{ return !buf.ptr; }

int
nilref(MEMREF const ref)
{ return !ref.len && !ref.ptr; }

MEMREF
memref(char const *mem, int len)
{ return mem && len ? (MEMREF){mem,len} : NILREF; }

MEMREF
bufref(MEMBUF const buf)
{ return (MEMREF) {buf.ptr, buf.len}; }

MEMBUF
chomp(MEMBUF buf)
{
    if (buf.ptr)
	while (buf.len > 0 && isspace(buf.ptr[buf.len - 1]))
	    buf.ptr[--buf.len] = 0;
    return  buf;
}

void
die(char const *fmt, ...)
{
    va_list	vargs;
    va_start(vargs, fmt);
#ifdef XXX
    if (*fmt == ':') fputs(getprogname(), stderr);
#endif//XXX
    vfprintf(stderr, fmt, vargs);
    va_end(vargs);
    if (fmt[strlen(fmt)-1] == ':')
        fprintf(stderr, " %s %s", errname[errno], strerror(errno));
    putc('\n', stderr);
    _exit(1);
}

#if defined(__linux__)
char const *
getprogname(void)
{
    static char *progname;

    if (!progname) {
#       ifdef _MSC_VER
        char*   buf = __argv[0];
#       else
        char    buf[999];
        int     len;
        sprintf(buf, "/proc/%d/exe", getpid());
        len = readlink(buf, buf, sizeof(buf));
        if (len < 0 || len == sizeof(buf))
            return NULL;
        buf[len] = 0;
#       endif//_MSC_VER
        char    *cp = strrchr(buf, '/');
        progname = strdup(cp ? cp + 1 : buf);
    }

    return  progname;
}
#endif

MEMREF *
refsplit(char *text, char sep, int *pcount)
{
    char	*cp;
    int		i, nstrs = 0;
    MEMREF      *strv = NULL;

    if (*text) {
        for (cp = text, nstrs = 1; (cp = strchr(cp, sep)); ++cp) 
            ++nstrs;

        strv = malloc(nstrs * sizeof(MEMREF));

        for (i = 0, cp = text; (cp = strchr(strv[i].ptr = cp, sep)); ++i, ++cp) {
            strv[i].len = cp - strv[i].ptr;
            *cp = 0;
        }

        strv[i].len = strlen(strv[i].ptr);
    }

    if (pcount) 
	*pcount = nstrs;
    return    strv;
}

MEMBUF
slurp(const char *filename)
{
    MEMBUF      ret = NILBUF;
    int         fd = filename && *filename && strcmp(filename, "-") ? open(filename, O_RDONLY) : 0;
    struct stat s;
    if (fd < 0 || fstat(fd, &s))
        goto ERROR;
#ifdef XXX
    if (S_ISREG(s.st_mode)) {
#endif
        ret = membuf(s.st_size);
        int nbytes = read(fd, ret.ptr, ret.len);
	    if (nbytes < 0)     // may be less than ret.len if Win does \r\n -> \n
            goto ERROR;
        ret.len = nbytes;
#ifdef XXX
    } else {
        int     len, size = 4096;
        ret.ptr = malloc(size + 1);
        for (;0 < (len = read(fd, ret.ptr+ret.len, size-ret.len)); ret.len += len)
            if (len == size - (int)ret.len)
                ret.ptr = realloc(ret.ptr, (size <<= 1) + 1);
        if (len < 0)
            goto ERROR;
        ret.ptr = realloc(ret.ptr, ret.len + 1);
    }
#endif//XXX
    close(fd);
    ret.ptr[ret.len] = 0;
    return  ret;

ERROR:
    if (fd >= 0) close(fd);
    buffree(ret);
    return NILBUF;
}

double tick(void)
{
#ifndef _MSC_VER
    struct timeval t;
    gettimeofday(&t, 0);
    return t.tv_sec + 1E-6 * t.tv_usec;
#else
    return 0;
#endif//_MSC_VER
       
}

void
usage(char const *str)
{
#ifdef XXX
    fprintf(stderr, "Usage: %s %s\n", getprogname(), str);
#endif//XXX
    _exit(2);
}

```

`msutil.h`:

```h
/*
** Copyright (C) 2009-2014 Mischa Sandberg <mischasan@gmail.com>
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU Lesser General Public License Version 3 as
** published by the Free Software Foundation.  You may not use, modify or
** distribute this program under any other version of the GNU Lesser General
** Public License.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU Lesser General Public License for more details.
**
** You should have received a copy of the GNU Lesser General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

// msutil: convenience functions.
// MEM: manipulating byte-blocks and slices thereaof.
//  "MEMBUF" is a <len,ptr> descriptor of a malloc'd block of memory.
//          The owner of the MEMBUF variable also "owns" the memory.
//  "MEMREF" is a <len,ptr> descriptor of memory allocated elsewhere.
//          A MEMREF can describe a substring of a MEMBUF value.
//	membuf(size)                    Create membuf; membuf(0) => NILBUF
//	buffree(buf)
//	memref(char const*mem, int len) Create memref from (ptr,len)
//	nilbuf(buf)                     Test if buf is a NILBUF
//	nilref(ref)                     Test if ref is a NILREF
//	bufref(buf)                     Create MEMREF from a MEMBUF; NILBUF => NILREF
//
//  chomp(buf)              - Remove trailing >>WHITESPACE<< from a MEMBUF.
//                              chomp(NILBUF) = NILBUF.
//  die(fmt, ...)           - Print message to stderr and exit(1).
//                              If fmt begins with ":", die prepends program name.
//                              If fmt ends in ":", die appends strerror(errno).
//  errname[nerrnames]      - (string) names for errno values. More succinct than strerror(). 
//  getprogname()           - Returns pointer to the program name (basename).
//  refsplit(s,sep,&cnt)    - split text. Replaces every (sep) with \0 in (text).
//                              Returns malloc'd vector of [cnt] MEMREF's.
//  slurp(fname)            - create membuf from a file. fname "-" or NULL reads stdin.
//  tick()                  - High-precision timer returns secs as a (double).
//  usage()                 - generic print program name, usage; then exit(2)
//--------------|---------------------------------------------

#ifndef MSUTIL_H
#define MSUTIL_H

#include <stdint.h>
// Defeat gcc 4.4 cdefs.h defining __wur i.e. __attribute((unused-result))
// for system calls where you just don't care (e.g. vasprintf...)
// This must follow "#include <stdint.h>" and precede everything else.
#undef	__wur
#define __wur

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if !defined(_MSC_VER)
#   include <sys/time.h>
#   include <sys/types.h>
#   include <unistd.h>
#endif

typedef struct { char *ptr; size_t len; }	MEMBUF;
typedef struct { char const *ptr; size_t len; } MEMREF;

#define	NILBUF		(MEMBUF){NULL,0}
#define	NILREF		(MEMREF){NULL,0}

void    buffree(MEMBUF buf);
MEMREF  bufref(MEMBUF const buf);
MEMBUF  chomp(MEMBUF buf);
void    die(char const *fmt, ...);
MEMBUF  membuf(int size);
MEMREF  memref(char const *mem, int len);
int     nilbuf(MEMBUF buf);
int     nilref(MEMREF const ref);
MEMREF* refsplit(char *text, char sep, int *pnrefs);
MEMBUF  slurp(char const *filename);
double  tick(void);
void    usage(char const *);

#if defined(__linux__)
char const *getprogname(void);  // BSD-equivalent
#endif

extern int  const nerrnames;
extern char const *errname[];

#endif//MSUTIL_H

```

`rules.mk`:

```mk
# Environment:
#-IMPORT VARS
#   FORMAT                 One of {,debug,cover,profile}. Needs expansion
#   CFLAGS_,_CFLAGS     Prefix and suffix of ${CFLAGS}
#   CPPFLAGS_,CXXFLAGS_,LDFLAGS_,LDLIBS_,...
#   clean               Additional files for "make clean".
#   env                 Variables of interest to the gmake user...
#
#-EXPORT VARS
#   COMMA           "," -- useful in $(...) commands
#   SPACE           " "
#   OS              OS name (AIX, Darwin, HP-UX, Linux, Solaris)
#   P4_ROOT         P4 client root directory
#   PREFIX          Global imports directory (default: /usr/local)
#   DESTDIR         Global exports directory (default: ${PREFIX})
#   CONFIG          Combination of all settings that affect compiled binary formats.
#
#-TARGETS
#   all clean tags test  ... The usual.
#
#   install         Install dependent .{a,h,so} files in ${DESTDIR}/{lib,include,lib}
#   install.bin     Install dependencies in ${DESTDIR}/bin
#
#-ACTIONS
#   defs            Print all builtin compiler macros (e.g. __LONG_MAX__, __x86_64)
#   env             Print <var>=<value> for every name in ${env}
#   sh              Execute ${SHELL} in the makefile's environment
#   source          List all source files
#
# NOTES
#   LDFLAGS,LDLIBS should *only* be used for standard OS libraries.
#   Any other dependencies are flaky, with the usual security issues of -rpath/LD_LIBRARY_PATH
#-----------------------------------------------------------------------------

# Each module sets "~ := <name>"  (note ":=" not "=").
#   A parent makefile will set <name> to the module's directory.
#   This sets $. = ${<name>}, defaulting to "."

. := $(word 1,${$~} .)
-include $./*.d
# clean uses ${all} to delete *.d
all             += $~

ifndef RULES_MK
RULES_MK        := 1
RULES           := $(word 1,${RULES} $./rules.mk)

export LD_LIBRARY_PATH

COMMA           = ,
OS              = $(shell uname -s)
PS4             = \# # Prefix for "sh -x" output.
SHELL           = bash
SPACE           = $` # " "
PREFIX          ?= /usr/local
DESTDIR         ?= ${PREFIX}

CONFIG          ?= $(call Join,_,${OS} ${ARCH} $(filter-out cc gcc,$(notdir ${CC})) ${FORMAT})

#-----------------------------------------------------------------------------
ARCH.Darwin    ?= universal
ARCH           ?= ${ARCH.${OS}}

BITS.Darwin.universal   = Universal
BITS.Darwin.x8664       = x8664
BITS.Linux.x8664        = 64
BITS                    = ${BITS.${OS}.${ARCH}}

#--- *.${FORMAT}:
# For gcc 4.5+, use: -O3 -flto --- link-time optimization including inlining. Incompatible with -g.

CFLAGS.         = -O3
CFLAGS.cover    = --coverage -DNDEBUG
LDFLAGS.cover   = --coverage
CFLAGS.debug    = -O0 -Wno-uninitialized
CPPFLAGS.debug  = -UNDEBUG
CPPLAGS.profile = -DNDEBUG
CFLAGS.profile  = -pg
LDFLAGS.profile = -pg

# PROFILE tests get stats on syscalls appended to their .pass files.
#   Darwin spells strace "dtruss".
exec.profile    = $(shell which dtruss strace) -cf

#--- *.${OS}:
#XXX HP-UX gcc 4.2.3 does not grok -fstack-protector. Sigh.
CFLAGS.AIX      = -fstack-protector --param ssp-buffer-size=4
CFLAGS.Darwin   = ${CFLAGS.AIX}
CFLAGS.HP-UX    =
CFLAGS.Linux    = ${CFLAGS.AIX}
CFLAGS.SunOS    = ${CFLAGS.AIX}

#LDLIBS.Darwin   += -lstdc++.6
#LDLIBS.Linux   += /usr/lib/libstdc++.so.6

LDLIBS.Linux    = -lm
LDLIBS.FreeBSD  = -lm

#-----------------------------------------------------------------------------
# -fPIC allows all .o's to be built into .so's.

CFLAGS          += ${CFLAGS_} -g -MMD -fPIC -pthread -fdiagnostics-show-option -fno-strict-aliasing
CFLAGS          += -Wall -Wextra -Wcast-align -Wcast-qual -Wformat=2 -Wformat-security -Wmissing-prototypes -Wnested-externs -Wpointer-arith -Wshadow -Wstrict-prototypes -Wunused -Wwrite-strings
CFLAGS          += -Wno-attributes -Wno-cast-qual -Wno-error -Wno-unknown-pragmas -Wno-unused-parameter
CFLAGS          += ${CFLAGS.${FORMAT}} ${CFLAGS.${OS}} ${CFLAGS.${FORMAT}.${OS}} ${_CFLAGS}

CPPFLAGS        += ${CPPFLAGS_} -I${PREFIX}/include -D_FORTIFY_SOURCE=2 -D_GNU_SOURCE ${CPPFLAGS.${FORMAT}} ${CPPFLAGS.${OS}} ${_CPPFLAGS}
CXXFLAGS        += ${CXXFLAGS_} $(filter-out -Wmissing-prototypes -Wnested-externs -Wstrict-prototypes, ${CFLAGS}) ${_CXXFLAGS}
LDFLAGS         += ${LDFLAGS_}  -pthread  -L${PREFIX}/lib  ${LDFLAGS.${FORMAT}}  ${LDFLAGS.${OS}}  ${_LDFLAGS}
LDLIBS          += ${LDLIBS_}   -lstdc++  ${LDLIBS.${OS}}   ${_LDLIBS}
 
#-----------------------------------------------------------------------------
# Explicitly CANCEL THESE EVIL BUILTIN RULES:
%               : %.c
%               : %.cpp
%.c             : %.l
%.c             : %.y
%.r             : %.l

#-----------------------------------------------------------------------------
.PHONY          : all clean cover debug defs env install profile sh source tags test
.DEFAULT_GOAL   := all

# ${all} contains subproject names. It can be used in ACTIONS but not RULES,
#   since it accumulates across every "include <submakefile>"
# ${junkfiles} is how to get metachars (commas) through the ${addsuffix...} call.
junkfiles       = {gmon.out,tags,*.[dis],*.fail,*.gcda,*.gcno,*.gcov,*.prof}

all             :;@echo "$@ done for FORMAT='${FORMAT}'"

clean           :;@( ${MAKE} -nps all install test | sed -n '/^# I/,$${/^[^\#\[%.][^ %]*: /s/:.*//p;}'; \
                    echo ${clean} $(addsuffix /${junkfiles}, $(foreach _,${all},${$_})) $(filter %.d,${MAKEFILE_LIST}) ) | xargs rm -rf

cover           : FORMAT := cover
%.cover         : %.test    ; gcov -bcp ${$@} | covsum

# Expand: translate every occurrence of "${var}" in a file to its env value (or ""):
#   E.G.   ${Expand} foo.tmpl >foo.ini
Expand          = perl -pe 's/ (?<!\\) \$${ ([A-Z_][A-Z_0-9]*) } / $$ENV{$$1} || ""/geix'
Join            = $(subst ${SPACE},$1,$(strip $2))

# Install: do the obvious for include and lib; "bin" files are not obvious ...
Install         = $(if $2, mkdir -p $1; pax -rwpe -s:.*/:: $2 $1)
install         : $(addprefix install., bin man1 man3 sbin) \
                ; $(call Install,${DESTDIR}/include, $(filter %.h,$^) $(filter %.hpp,$^)) \
                ; $(call Install,${DESTDIR}/lib,     $(filter %.a,$^) $(filter %.so,$^) $(filter %.dylib,$^))

# install.% cannot be .PHONY because there is no pattern expansion of phony targets.
install.bin     :           ; $(call Install,${DESTDIR}/bin,$^)
install.man%    :           ; $(call Install,${DESTDIR}/man/$(subst install.,,$@),$^)
install.%       :           ; $(call Install,${DESTDIR}/$(subst install.,,$@),$^)

profile         : FORMAT := profile
profile         : test      ;@for x in ${$*.test:.pass=}; do case `file $$x` in *script*) ;; *) gprof -b $$x >$$x.prof; esac; done

%.test          : ${%.test}

# GMAKE trims leading "./" from $* ; ${*D}/${*F} restores it, so no need to fiddle with $PATH.
%.pass          : %         ; rm -f $@; ${exec.${FORMAT}} ${*D}/${*F} >& $*.fail && mv -f $*.fail $@

%.so            : %.o       ; ${CC} ${LDFLAGS} -o $@ -shared $< ${LDLIBS}
%.so            : %.a       ; ${CC} ${CFLAGS}  -o $@ -shared -Wl,-whole-archive $< ${LDLIBS} -Wl,-no-whole-archive
%.a             :           ; $(if $(filter %.o,$^), ar crs $@ $(filter %.o,$^))
%.yy.c          : %.l       ; flex -o $@ $<
%.tab.c         : %.y       ; bison $<
%/..            :           ;@mkdir -p ${@D}
%               : %.gz      ; gunzip -c $^ >$@

# Ensure that intermediate files (e.g. the foo.o caused by "foo : foo.c")
#  are not auto-deleted --- causing a re-compile every second "make".
.SECONDARY      :

#---------------- Handy make-related commands.
# defs - list gcc's builtin macros
# env - environment relevant to the make. "sort -u" because env entries may not be unique -- "env +=" in multiple makefiles.
# sh - invoke a shell within the makefile's env:
# source - list files used and not built by the "make". Explicitly filters out "*.d" files.
# NOTE: "make tags" BEFORE "make all" is incomplete because *.h dependencies are only in *.d files.

defs            :;@${CC} ${CPPFLAGS} -E -dM - </dev/null | cut -c8- | sort
env             :;@($(foreach _,${env},echo $_=${$_};):) | sort -u
sh              :;@PS1='${PS1} [make] ' ${SHELL}
source          :;@$(if $^, ls $^;) ${MAKE} -nps all test cover profile | sed -n '/^. Not a target/{ n; /^install/d; /^[^ ]*\.d:/!{ /^[^.*][^ ]*:/s/:.*//p; }; }' | sort -u
tags            :; ctags -B $(filter %.c %.cpp %.h %.hpp, $^)

# "make SomeVar." prints ${SomeVar}
%.              :;@echo '${$*}'

#TODO: somehow pick up all the target-specific flags for *.o, for *.[Isi]

# %.I lists all (recursive) #included files; e.g.: "make /usr/include/errno.h.I"
%.I             : %.c       ;@ls -1 2>&- `${CC}  ${CPPFLAGS} ${TARGET_ARCH} -M $<` | sort -u
%.I             : %.cpp     ;@ls -1 2>&- `${CXX} ${CPPFLAGS} ${TARGET_ARCH} -M $<` | sort -u
%.i             : %.c       ; ${COMPILE.c}   -E -o $@ $<
%.i             : %.cpp     ; ${COMPILE.cpp} -E -o $@ $<
%.s             : %.c       ; $(filter-out -Werror,${COMPILE.c}) -DNDEBUG -S -o $@ $< && deas $@
%.s             : %.cpp     ; ${COMPILE.cpp} -S -o $@ $< && deas $@

endif # RULES_MK
# vim: set nowrap :

```

`tap.c`:

```c
/*-
 * Copyright (c) 2004 Nik Clayton
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* FIXME: The real fix is an asprintf module. */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE 1
#endif

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#define flockfile(file)
#define funlockfile(file)
#include <process.h>
#define getpid()          _getpid()

#ifndef PRId64
#define PRId64 "I64d"
#endif
#ifndef PRIx64
#define PRIx64 "I64x"
#endif

#else /* UNIX */
#include <unistd.h>
#include <signal.h>
#include <inttypes.h>
#endif

#if defined(__APPLE__) || defined(__FreeBSD__)
#define sighandler_t sig_t
#endif
#if defined(__APPLE__)
#define _NSIG        __DARWIN_NSIG
#elif defined(__FreeBSD__)
#define _NSIG        NSIG
#endif

#include "tap.h"

static int          no_plan        = 0;
static int          skip_all       = 0;
static int          have_plan      = 0;
static unsigned int test_count     = 0; /* Number of tests that have been run */
static unsigned int e_tests        = 0; /* Expected number of tests to run */
static unsigned int failures       = 0; /* Number of tests that failed */
static char *       todo_msg       = NULL;
static const char * todo_msg_fixed = "libtap malloc issue";
static int          todo           = 0;
static int          test_died      = 0;
static FILE *       tap_out        = NULL;
static const char * test_case_name = NULL;
static unsigned     tap_flags      = 0;
static int          test_pid;

#ifndef _WIN32
static sighandler_t tap_saved_sig_handler[_NSIG];
#endif

/* Encapsulate the pthread code in a conditional.  In the absence of
   libpthread the code does nothing */
#ifdef HAVE_LIBPTHREAD
#include <pthread.h>
static pthread_mutex_t M = PTHREAD_MUTEX_INITIALIZER;
# define LOCK pthread_mutex_lock(&M)
# define UNLOCK pthread_mutex_unlock(&M)
#else
# define LOCK
# define UNLOCK
#endif

static void
_expected_tests(unsigned int tests)
{

    fprintf(tap_out, "1..%d\n", tests);
    e_tests = tests;
}

static int
diagv(const char *fmt, va_list ap)
{
    int len;

    tap_init(stdout);
    fputs("# ", tap_out);
    len = vfprintf(tap_out, fmt, ap);
    fputs("\n", tap_out);

    return len + 3;
}

static void
_diag(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    diagv(fmt, ap);
    va_end(ap);
}

/* Implement our own vasprintf for self-contained implementation on Windows.
 */
static int
my_vasprintf(char **strp, const char *fmt, va_list ap)
{
    char buffer[1024];
    int  ret;

    ret = vsnprintf(buffer, sizeof(buffer), fmt, ap);

    if ((*strp = malloc(ret + 1)) == NULL) {
        return -1;
    }

    strncpy(*strp, buffer, ret + 1);
    return ret;
}

/*
 * Generate a test result.
 *
 * type -- 0 = ok, 1 = is, 2 = is_eq, 3 = is_cmp.
 * got -- For ok: boolean, indicates whether or not the test passed. Else: Value we got.
 * expected -- Value we expected (ignored for ok).
 * cmp -- Compare function (only used for is_cmp).
 * to_str -- Convert object to string (only used for is_cmp).
 * test_name -- the name of the test, may be NULL
 * test_comment -- a comment to print afterwards, may be NULL
 */
unsigned int
_gen_result(int type, uint64_t got, uint64_t expected,
            int (*cmp)(const void * got, const void * expected),
            const char * (*to_str)(const void * object), const char *func,
            const char *file, unsigned int line, const char *test_name, ...)
{
    va_list ap;
    const void *got_ptr = (const void *)(uintptr_t)got;
    const void *exp_ptr = (const void *)(uintptr_t)expected;
    char  * local_test_name = NULL;
    char  * c;
    int     name_is_digits;
    int     ok;

    switch (type) {
    case 1:
        ok = (int)(got == expected);
        break;

    case 2:
        ok = (int)(got_ptr && exp_ptr && strcmp(got_ptr, exp_ptr) == 0);
        break;

    case 3:
        ok = (int)((*cmp)(got_ptr, exp_ptr) == 0);
        break;

    case 4:
        ok = (int)(got_ptr && exp_ptr && strncmp(got_ptr, exp_ptr, (size_t)cmp) == 0);
        break;

    case 5:
        ok = (int)(got_ptr && exp_ptr && strstr(got_ptr, exp_ptr) != NULL);
        break;

    default:
        ok = got;
        break;
    }

/* ===================  LOCK  =================== */
    LOCK;
    flockfile(tap_out);
    flockfile(stderr);

    test_count++;

    /* Start by taking the test name and performing any printf()
       expansions on it */
    if (test_name != NULL) {
        va_start(ap, test_name);
        if (my_vasprintf(&local_test_name, test_name, ap) < 0)
            local_test_name = NULL;
        va_end(ap);

        /* Make sure the test name contains more than digits
           and spaces.  Emit an error message and exit if it
           does */
        if(local_test_name) {
            name_is_digits = 1;
            for(c = local_test_name; *c != '\0'; c++) {
                if(!isdigit(*c) && !isspace(*c)) {
                    name_is_digits = 0;
                    break;
                }
            }

            if(name_is_digits) {
                _diag("    You named your test '%s'.  You shouldn't use numbers for your test names.", local_test_name);
                _diag("    Very confusing.");
            }
        }
    }

    if(!ok) {
        fprintf(tap_out, "not ");
        failures++;
    }

    fprintf(tap_out, "ok %d", test_count);

    if (test_case_name != NULL || test_name != NULL) {
        fprintf(tap_out, " - ");
    }

    if (test_case_name != NULL) {
        fputs(test_case_name, tap_out);
    }

    if(test_name != NULL) {
        if (test_case_name != NULL) {
            fprintf(tap_out, ": ");
        }

        /* Print the test name, escaping any '#' characters it
           might contain */
        if(local_test_name != NULL) {
            for(c = local_test_name; *c != '\0'; c++) {
                if(*c == '#')
                    fputc('\\', tap_out);
                fputc((int)*c, tap_out);
            }
        } else {    /* my_vasprintf() failed, use a fixed message */
            fprintf(tap_out, "%s", todo_msg_fixed);
        }
    }

    /* If we're in a todo_start() block then flag the test as being
       TODO.  todo_msg should contain the message to print at this
       point.  If it's NULL then asprintf() failed, and we should
       use the fixed message.

       This is not counted as a failure, so decrement the counter if
       the test failed. */
    if (todo) {
        fprintf(tap_out, " # TODO %s", todo_msg ? todo_msg : todo_msg_fixed);
        if(!ok)
            failures--;
    }

    fprintf(tap_out, "\n");

    if (!ok) {
        _diag("    Failed %stest (%s:%s() at line %d)",
              todo ? "(TODO) " : "", file, func, line);

        switch (type) {
        case 1:
            if (got > 256 || expected > 256) {
                _diag("         got: 0x%"PRIx64" (%"PRId64")", got, got);
                _diag("    expected: 0x%"PRIx64" (%"PRId64")", expected, expected);
            } else {
                _diag("         got: %"PRId64, got);
                _diag("    expected: %"PRId64, expected);
            }
            break;

        case 2:
            _diag("         got: \"%s\"", (const char *)got_ptr);
            _diag("    expected: \"%s\"", (const char *)exp_ptr);
            break;

        case 3:
            _diag("         got: %s", (*to_str)(got_ptr));
            _diag("    expected: %s", (*to_str)(exp_ptr));
            break;

        case 4:
            _diag("         got: %.*s", got_ptr ? (int)(intptr_t)cmp : 0, (const char *)got_ptr);
            _diag("    expected: %.*s", exp_ptr ? (int)(intptr_t)cmp : 0, (const char *)exp_ptr);
            break;

        case 5:
            _diag("                    got: \"%s\"", (const char *)got_ptr);
            _diag("    expected to contain: \"%s\"", (const char *)exp_ptr);
            break;

        default:
            break;
        }
    }

    free(local_test_name);

    funlockfile(stderr);
    funlockfile(tap_out);
    UNLOCK;
/* =================== UNLOCK =================== */

    if (!ok && !todo && (tap_flags & TAP_FLAG_ON_FAILURE_EXIT)) {
        exit(test_count);
    }

    /* We only care (when testing) that ok is positive, but here we
       specifically only want to return 1 or 0 */
    return ok ? 1 : 0;
}

/*
 * Cleanup at the end of the run, produce any final output that might be
 * required.
 */
static void
_cleanup(void)
{
    /* If we forked, don't do cleanup in child! */
    if (getpid() != test_pid)
        return;

    LOCK;

    /* If plan_no_plan() wasn't called, and we don't have a plan,
       and we're not skipping everything, then something happened
       before we could produce any output */
    if(!no_plan && !have_plan && !skip_all) {
        _diag("Looks like your test died before it could output anything.");
        UNLOCK;
        return;
    }

    if(test_died) {
        _diag("Looks like your test died just after %d.", test_count);
        UNLOCK;
        return;
    }

    /* No plan provided, but now we know how many tests were run, and can
       print the header at the end */
    if(!skip_all && (no_plan || !have_plan)) {
        fprintf(tap_out, "1..%d\n", test_count);
    }

    if((have_plan && !no_plan) && e_tests < test_count) {
        _diag("Looks like you planned %d tests but ran %d extra.",
              e_tests, test_count - e_tests);
        if(failures) {
            _diag("Looks like you failed %d tests of %d run.",
                  failures, test_count);
        }
        UNLOCK;
        return;
    }

    if((have_plan || !no_plan) && e_tests > test_count) {
        _diag("Looks like you planned %d tests but only ran %d.",
              e_tests, test_count);
        if(failures) {
            _diag("Looks like you failed %d tests of %d run.",
                  failures, test_count);
        }
        UNLOCK;
        return;
    }

    if(failures)
        _diag("Looks like you failed %d tests of %d.",
              failures, test_count);

    UNLOCK;
}

#ifndef _WIN32
static void
tap_debug_sig_handler(int sig)
{
    diag("tap_debug_sig_hander(sig=%d):", sig);

    if (tap_saved_sig_handler[sig] == SIG_DFL) {
        diag("    default handling: exiting with an error");
        exit(1);
    }

    if (tap_saved_sig_handler[sig] == SIG_IGN) {
        diag("    signal ignored");
    }
    else {
        diag("    forwarding signal to function at %p", tap_saved_sig_handler[sig]);
        (*tap_saved_sig_handler)(sig);
    }
}
#endif

/**
 * Initialise the TAP library.  Will only do so once, however many times it's
 * called. If you don't call this, calling plan_* will, with stdout as the file.
 */
void
tap_init(FILE * out)
{
    static int run_once = 0;

    if(!run_once) {
        tap_out  = out;
        test_pid = getpid();
        atexit(_cleanup);

        /* stdout needs to be unbuffered so that the output appears
           in the same place relative to stderr output as it does
           with Test::Harness */
        setbuf(tap_out, 0);
        run_once = 1;
    }

#ifndef _WIN32
    if (tap_flags & TAP_FLAG_DEBUG) {
        tap_saved_sig_handler[SIGINT]  = signal(SIGINT,  tap_debug_sig_handler);
        tap_saved_sig_handler[SIGTERM] = signal(SIGTERM, tap_debug_sig_handler);
    }
#endif
}

/*
 * Note that there's no plan.
 */
void
plan_no_plan(void)
{

    LOCK;

    tap_init(stdout);

    if(have_plan != 0) {
        fprintf(stderr, "You tried to plan twice!\n");
        test_died = 1;
        UNLOCK;
        exit(255);
    }

    have_plan = 1;
    no_plan = 1;

    UNLOCK;
}

/*
 * Note that the plan is to skip all tests
 */
void
plan_skip_all(const char * reason)
{
    LOCK;

    tap_init(stdout);
    skip_all = 1;

    fprintf(tap_out, "1..0");

    if(reason != NULL) {
        fprintf(tap_out, " # Skip %s", reason);
    }

    fprintf(tap_out, "\n");
    UNLOCK;
}

void
tap_plan(unsigned tests, unsigned flags, FILE * output)
{
    LOCK;

    tap_flags = flags;
    tap_init(output != NULL ? output : stdout);

    if (have_plan != 0) {
        fprintf(stderr, "You tried to plan twice!\n");
        test_died = 1;
        UNLOCK;
        exit(255);
    }

    if (tests == 0) {
        fprintf(stderr, "You said to run 0 tests!  You've got to run something.\n");
        test_died = 1;
        UNLOCK;
        exit(255);
    }

    have_plan = 1;
    _expected_tests(tests);

    UNLOCK;
}

/*
 * Note the number of tests that will be run.
 */
void
plan_tests(unsigned int tests)
{
	tap_plan(tests, 0, NULL);
}

int
diag(const char *fmt, ...)
{
    va_list ap;
    int     len;

    LOCK;

    va_start(ap, fmt);
    len = diagv(fmt, ap);
    va_end(ap);

    UNLOCK;
    return len;
}

void
skip(unsigned int n, const char *fmt, ...)
{
    va_list ap;
    char *  skip_msg;

    LOCK;

    va_start(ap, fmt);

    if (my_vasprintf(&skip_msg, fmt, ap) < 0)
        skip_msg = NULL;

    va_end(ap);

    while(n-- > 0) {
        test_count++;
        fprintf(tap_out, "ok %d # skip %s\n", test_count,
               skip_msg != NULL ?
               skip_msg : "libtap():malloc() failed");
    }

    free(skip_msg);
    UNLOCK;
}

void
todo_start(const char *fmt, ...)
{
    va_list ap;

    LOCK;

    va_start(ap, fmt);

    if (my_vasprintf(&todo_msg, fmt, ap) < 0)
        todo_msg = NULL;

    va_end(ap);
    todo = 1;

    UNLOCK;
}

void
todo_end(void)
{

    LOCK;

    todo = 0;
    free(todo_msg);

    UNLOCK;
}

int
exit_status(void)
{
    int r;

    if (tap_flags & TAP_FLAG_DEBUG) {
        diag("tap_debug: exit_status(): entering");
    }

    LOCK;

    /* If there's no plan, just return the number of failures */
    if(no_plan || !have_plan) {
        UNLOCK;
        return failures;
    }

    /* Ran too many tests?  Return the number of tests that were run
       that shouldn't have been */
    if(e_tests < test_count) {
        r = test_count - e_tests;
        UNLOCK;
        return r;
    }

    /* Return the number of tests that failed + the number of tests
       that weren't run */
    r = failures + e_tests - test_count;
    UNLOCK;

    if (tap_flags & TAP_FLAG_DEBUG) {
        diag("tap_debug: exit_status(): returning %u", r);
    }

    return r;
}

const char *
tap_get_test_case_name(void)
{
    return test_case_name;
}

void
tap_set_test_case_name(const char * name)
{
    test_case_name = name;
}

```

`tap.h`:

```h
/*-
 * Copyright (c) 2004 Nik Clayton
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef __TAP_H__
#define __TAP_H__

#include <stddef.h>
#include <stdio.h>

#if !defined(_WIN32) || defined(MAKE_MINGW)
#   include <stdint.h>    /* For uintptr_t, which Windows puts in <stddef.h>; Windows doesn't have <stdint.h> */
#endif

/**
 * plan_tests - announce the number of tests you plan to run
 * @tests: the number of tests
 *
 * This should be the first call in your test program: it allows tracing
 * of failures which mean that not all tests are run.
 *
 * If you don't know how many tests will actually be run, assume all of them
 * and use skip() if you don't actually run some tests.
 *
 * Example:
 *	plan_tests(13);
 */
void plan_tests(unsigned int tests);

#ifdef _WIN32
#define __func__ __FUNCTION__
typedef unsigned __int64 uint64_t;
#endif

#if (!defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L) && !defined(__GNUC__) && !defined(_WIN32)
# error "Needs gcc or C99 compiler for variadic macros."
#else

/* Compare integers up to 64-bits */
#define is(g, e, ...)                  _gen_result(1, (uint64_t)(g), (uint64_t)(e), (void *)0, (void *)0, \
                                                   __func__, __FILE__, __LINE__, __VA_ARGS__)

#define is_ptr(g, e, ...)              _gen_result(1, (uint64_t)(uintptr_t)(g), (uint64_t)(uintptr_t)(e), (void *)0, (void *)0, \
                                                   __func__, __FILE__, __LINE__, __VA_ARGS__)

#define is_eq(g, e, ...)               _gen_result(2, (uint64_t)(uintptr_t)(g), (uint64_t)(uintptr_t)(e), (void *)0, (void *)0, \
                                                   __func__, __FILE__, __LINE__, __VA_ARGS__)

#define is_cmp(g, e, cmp, to_str, ...) _gen_result(3, (uint64_t)(uintptr_t)(g), (uint64_t)(uintptr_t)(e), (cmp), (to_str), \
                                                   __func__, __FILE__, __LINE__, __VA_ARGS__)

#define is_strncmp(g, e, len, ...)     _gen_result(4, (uint64_t)(uintptr_t)(g), (uint64_t)(uintptr_t)(e), (void *)(uintptr_t)(len), (void *)0, \
                                                   __func__, __FILE__, __LINE__, __VA_ARGS__)

#define is_strstr(g, e, ...)           _gen_result(5, (uint64_t)(uintptr_t)(g), (uint64_t)(uintptr_t)(e), (void *)0, (void *)0, \
                                                   __func__, __FILE__, __LINE__, __VA_ARGS__)

/**
 * ok1 - Simple conditional test
 * @e: the expression which we expect to be true.
 *
 * This is the simplest kind of test: if the expression is true, the
 * test passes.  The name of the test which is printed will simply be
 * file name, line number, and the expression itself.
 *
 * Example:
 *	ok1(init_subsystem() == 1);
 */
# define ok1(e) ((e) ?                                                                          \
                 _gen_result(0, (uint64_t)1, (uint64_t)0, (void *)0, (void *)0,         \
                             __func__, __FILE__, __LINE__, "%s", #e) :                          \
                 _gen_result(0, (uint64_t)0, (uint64_t)0, (void *)0, (void *)0,         \
                             __func__, __FILE__, __LINE__, "%s", #e))

/**
 * ok - Conditional test with a name
 * @e: the expression which we expect to be true.
 * @...: the printf-style name of the test.
 *
 * If the expression is true, the test passes.  The name of the test will be
 * the filename, line number, and the printf-style string.  This can be clearer
 * than simply the expression itself.
 *
 * Example:
 *	ok1(init_subsystem() == 1);
 *	ok(init_subsystem() == 0, "Second initialization should fail");
 */
# define ok(e, ...) ((e) ?                                                                      \
		     _gen_result(0, (uint64_t)1, (uint64_t)0, (void *)0, (void *)0,     \
                                 __func__, __FILE__, __LINE__, __VA_ARGS__) :                   \
		     _gen_result(0, (uint64_t)0, (uint64_t)0, (void *)0, (void *)0,     \
                                 __func__, __FILE__, __LINE__, __VA_ARGS__))

/**
 * pass - Note that a test passed
 * @...: the printf-style name of the test.
 *
 * For complicated code paths, it can be easiest to simply call pass() in one
 * branch and fail() in another.
 *
 * Example:
 *	x = do_something();
 *	if (!checkable(x) || check_value(x))
 *		pass("do_something() returned a valid value");
 *	else
 *		fail("do_something() returned an invalid value");
 */
# define pass(...) ok(1, __VA_ARGS__)

/**
 * fail - Note that a test failed
 * @...: the printf-style name of the test.
 *
 * For complicated code paths, it can be easiest to simply call pass() in one
 * branch and fail() in another.
 */
# define fail(...) ok(0, __VA_ARGS__)

/* I don't find these to be useful. */
# define skip_if(cond, n, ...)				\
	if (cond) skip((n), __VA_ARGS__);		\
	else

# define skip_start(test, n, ...)			\
	do {						\
		if((test)) {				\
			skip(n,  __VA_ARGS__);		\
			continue;			\
		}

# define skip_end } while(0)

#ifndef PRINTF_ATTRIBUTE
#ifdef __GNUC__
#define PRINTF_ATTRIBUTE(a1, a2) __attribute__ ((format (__printf__, a1, a2)))
#else
#define PRINTF_ATTRIBUTE(a1, a2)
#endif
#endif

unsigned int _gen_result(int type, uint64_t got, uint64_t exp,
            int (*cmp)(const void *, const void *),
            const char * (*to_str)(const void *), const char *func,
            const char *file, unsigned int line, const char *name, ...) PRINTF_ATTRIBUTE(9, 10);

/**
 * diag - print a diagnostic message (use instead of printf/fprintf)
 * @fmt: the format of the printf-style message
 *
 * diag ensures that the output will not be considered to be a test
 * result by the TAP test harness.  It will append '\n' for you.
 *
 * Example:
 *	diag("Now running complex tests");
 */
int diag(const char *fmt, ...) PRINTF_ATTRIBUTE(1, 2);

/**
 * skip - print a diagnostic message (use instead of printf/fprintf)
 * @n: number of tests you're skipping.
 * @fmt: the format of the reason you're skipping the tests.
 *
 * Sometimes tests cannot be run because the test system lacks some feature:
 * you should explicitly document that you're skipping tests using skip().
 *
 * From the Test::More documentation:
 *   If it's something the user might not be able to do, use SKIP.  This
 *   includes optional modules that aren't installed, running under an OS that
 *   doesn't have some feature (like fork() or symlinks), or maybe you need an
 *   Internet connection and one isn't available.
 *
 * Example:
 *	#ifdef HAVE_SOME_FEATURE
 *	ok1(test_some_feature());
 *	#else
 *	skip(1, "Don't have SOME_FEATURE");
 *	#endif
 */
void skip(unsigned int n, const char *fmt, ...) PRINTF_ATTRIBUTE(2, 3);

/**
 * todo_start - mark tests that you expect to fail.
 * @fmt: the reason they currently fail.
 *
 * It's extremely useful to write tests before you implement the matching fix
 * or features: surround these tests by todo_start()/todo_end().  These tests
 * will still be run, but with additional output that indicates that they are
 * expected to fail.
 *
 * This way, should a test start to succeed unexpectedly, tools like prove(1)
 * will indicate this and you can move the test out of the todo block.  This
 * is much more useful than simply commenting out (or '#if 0') the tests.
 *
 * From the Test::More documentation:
 *   If it's something the programmer hasn't done yet, use TODO.  This is for
 *   any code you haven't written yet, or bugs you have yet to fix, but want to
 *   put tests in your testing script (always a good idea).
 *
 * Example:
 *	todo_start("dwim() not returning true yet");
 *	ok(dwim(), "Did what the user wanted");
 *	todo_end();
 */
void todo_start(const char *fmt, ...) PRINTF_ATTRIBUTE(1, 2);

/**
 * todo_end - end of tests you expect to fail.
 *
 * See todo_start().
 */
void todo_end(void);

/**
 * exit_status - the value that main should return.
 *
 * For maximum compatability your test program should return a particular exit
 * code (ie. 0 if all tests were run, and every test which was expected to
 * succeed succeeded).
 *
 * Example:
 *	exit(exit_status());
 */
int exit_status(void);

/**
 * plan_no_plan - I have no idea how many tests I'm going to run.
 *
 * In some situations you may not know how many tests you will be running, or
 * you are developing your test program, and do not want to update the
 * plan_tests() call every time you make a change.  For those situations use
 * plan_no_plan() instead of plan_tests().  It indicates to the test harness
 * that an indeterminate number of tests will be run.
 *
 * Remember, if you fail to plan, you plan to fail.
 *
 * Example:
 *	plan_no_plan();
 *	while (random() % 2)
 *		ok1(some_test());
 *	exit(exit_status());
 */
void plan_no_plan(void);

/**
 * plan_skip_all - Indicate that you will skip all tests.
 * @reason: the string indicating why you can't run any tests.
 *
 * If your test program detects at run time that some required functionality
 * is missing (for example, it relies on a database connection which is not
 * present, or a particular configuration option that has not been included
 * in the running kernel) use plan_skip_all() instead of plan_tests().
 *
 * Example:
 *	if (!have_some_feature) {
 *		plan_skip_all("Need some_feature support");
 *		exit(exit_status());
 *	}
 *	plan_tests(13);
 */
void plan_skip_all(const char *reason);

/* New in libtap2 - See the man page for help */

#define TAP_FLAG_ON_FAILURE_EXIT 0x00000001
#define TAP_FLAG_DEBUG           0x00000002

typedef struct tap_ev       * tap_ev;
typedef struct tap_ev_queue * tap_ev_queue;

extern const char TAP_EV_NO_EVENT[];

void         tap_init(                FILE * out);
void         tap_plan(                unsigned tests, unsigned flags, FILE * output);
const char * tap_get_test_case_name(  void);
void         tap_set_test_case_name(  const char * name);
void *       tap_dup(                 const void * mem, size_t size);

unsigned     tap_ev_arg_count(        tap_ev ev);
void       * tap_ev_arg(              tap_ev ev, const char * name);
unsigned     tap_ev_count(            const char * identifier);
void         tap_ev_free(             tap_ev ev);
const char * tap_ev_identifier(       tap_ev ev);
void         tap_ev_push(             const char * identifier, unsigned argc, ...);
unsigned     tap_ev_length(           void);
tap_ev       tap_ev_shift(            void);
tap_ev       tap_ev_shift_next(       const char * identifier);
void         tap_ev_flush(            void);

unsigned     tap_ev_queue_count(      tap_ev_queue queue, const char * identifier);
void         tap_ev_queue_flush(      tap_ev_queue queue);
tap_ev_queue tap_ev_queue_get_default(void);
unsigned     tap_ev_queue_length(     tap_ev_queue queue);
tap_ev_queue tap_ev_queue_new(        void);
void         tap_ev_queue_push(       tap_ev_queue queue, const char * identifier, unsigned argc, ...);
tap_ev       tap_ev_queue_shift(      tap_ev_queue queue);
tap_ev       tap_ev_queue_shift_next( tap_ev_queue queue, const char * identifier);

#define tap_test_case_name(name) tap_set_test_case_name(name)

#endif /* C99 or gcc */
#endif /* __TAP_H__  */

```