Project Path: arc_serjam_mwclap_6ffn5_mg

Source Tree:

```txt
arc_serjam_mwclap_6ffn5_mg
├── README.md
├── driver.h
├── game.h
├── main.cpp
├── overlay.cpp
├── overlay.h
├── player.h
├── sdk.h
├── ss.png
├── vectors.h
└── xor.h

```

`README.md`:

```md
# MWClap
### External Warzone Hack

![Hack Screenshot](./ss.png)

## Features
- ESP Box
- ESP Name

*This hack requires NVIDIA GeForce Experience's ingame overlay to be installed and enabled!\
*Game must be set to fullscreen borderless 

### Disclaimer
This source code is for educational purposes only. I made this project to learn more about reverse engineering and not to ruin the experience for other gamers. I will not be updating the offsets for this reason.

```

`driver.h`:

```h
#pragma once
#include <Windows.h>
#include <TlHelp32.h>
#include <cstdint>
#include <vector>
#include <memoryapi.h>
#include <string>
#include <chrono>
#include <iostream>
#include "xor.h"

#define CODE_READ				0xA1;
#define CODE_GET_PEB		0xA2;
#define CODE_GET_BASE		0xA3;
#define CODE_SUCCESS		0x0;
#define CODE_FAILURE		0x1;
typedef struct _COMMS
{
	UINT32 code;							// Determines what action to take
	ULONG pid;								// ID of target process
	ULONG64 addy;							// Field used to communicate addresses
	void* buff;								// Pointer to output buffer
	ULONGLONG size;						// Size of output
	const char* str;					// General purpose string field

} COMMS;

static std::uint32_t process_id = 0;
static COMMS m = { 0 };

struct HandleDisposer
{
	using pointer = HANDLE;
	void operator()(HANDLE handle) const
	{
		if (handle != NULL || handle != INVALID_HANDLE_VALUE)
		{
			CloseHandle(handle);
		}
	}
};

using unique_handle = std::unique_ptr<HANDLE, HandleDisposer>;

static std::uint32_t get_process_id(std::string_view process_name) {
	PROCESSENTRY32 processentry;
	const unique_handle snapshot_handle(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0));

	if (snapshot_handle.get() == INVALID_HANDLE_VALUE)
		return 0;

	processentry.dwSize = sizeof(MODULEENTRY32);

	while (Process32Next(snapshot_handle.get(), &processentry) == TRUE) {
		if (process_name.compare(processentry.szExeFile) == 0)
			return processentry.th32ProcessID;
	}
	return 0;
}

template<typename ... A>
uint64_t call_hook(const A ... arguments)
{
	void* control_function = GetProcAddress(LoadLibrary("win32u.dll"), xorstr_("NtOpenCompositionSurfaceSectionInfo"));

	const auto control = static_cast<uint64_t(__stdcall*)(A...)>(control_function);

	return control(arguments ...);
}


static ULONG64 DriverGetBase(const char* modName) {
	m.code = CODE_GET_BASE;
	m.pid = process_id;
	m.str = modName;

	call_hook(&m);
	m.str = nullptr;

	return m.addy;
}

static ULONG64 DriverGetPEB() {
	m.code = CODE_GET_PEB;
	m.pid = process_id;

	call_hook(&m);
	return m.addy;
}

template <typename T>
T Read(UINT_PTR TargetAddress) {

	m.code = CODE_READ;
	m.addy = TargetAddress;
	m.size = sizeof(T);
	T output;
	m.buff = &output;

	call_hook(&m);

	return output;
}





```

`game.h`:

```h
#pragma once
#include "sdk.h"
#include "player.h"
#include "overlay.h"
#include <thread>

class Game {
private:
	Game() {}
	FOverlay* overlay;
	std::thread olayT;
	std::thread addrT;

public:
	bool espOn;
	bool terminate;

	Game(Game const&) = delete;
	Game& operator=(Game const&) = delete;

	static Game& get() {
		static Game mw;
		return mw;
	}

	static void RenderOlay(FOverlay* overlay)
	{
		Game& g_MW = Game::get();
		while (!g_MW.terminate)
		{
			overlay->begin_scene();
			overlay->clear_scene();
			overlay->draw_text_green(10, 20, xorstr_("GLARE HAX v1.0"));
			g_MW.DrawESP();
			overlay->end_scene();
		}
		overlay->clear_screen();
	}
	static void UpdateAddresses() {
		Game& g_MW = Game::get();
		while (!g_MW.terminate) {
			globals::INFO = GetClientInfo();
			globals::BASE = GetClientBase(globals::INFO);
			globals::REFDEF = GetRefDef();
			globals::NAMES = GetNameList();
#if DEBUG
			utils::loghex(xorstr_("[*] Dec Info Ptr: "), globals::INFO);
			utils::loghex(xorstr_("[*] Dec Base Ptr: "), globals::BASE);
			utils::loghex(xorstr_("[*] Dec Refdef Ptr: "), globals::REFDEF);
			utils::loghex(xorstr_("[*] Name List Ptr: "), globals::NAMES);
#endif
			Sleep(15000);
		}
	}

	void Init() {
		overlay = { 0 };
		espOn = false;
		terminate = false;

		addrT = std::thread(UpdateAddresses);

		InitOlay();
	}

	void End() {
		terminate = true;
		olayT.join();
		addrT.join();
		overlay->clear_screen();
		overlay->d2d_shutdown();
	}

	void InitOlay()
	{
		if (!overlay->window_init())
			return;
		if (!overlay->init_d2d())
			return;

		olayT = std::thread(RenderOlay, overlay);

		return;
	}

	Vector3 GetLocalPos()
	{
		uint64_t cptr = Read<uint64_t>(globals::module_base + offsets::CAMERA_BASE);
		return Read<Vector3>(cptr + offsets::CAMERA_POS);
	}

	bool W2S(Vector3 worldLocation, Vector3 cameraPosition,
		int screenWidth, int screenHeight,
		Vector2 fieldOfView, Vector3* matrices, Vector2& out)
	{
		Vector3 local = worldLocation - cameraPosition;

		Vector3 trans = Vector3(local.Dot(matrices[1]), local.Dot(matrices[2]), local.Dot(matrices[0]));

		if (trans.z < 0.01f)
			return false;

		out.x = (((float)screenWidth / 2) * (1 - (trans.x / fieldOfView.x / trans.z)));
		out.y = (((float)screenHeight / 2) * (1 - (trans.y / fieldOfView.y / trans.z)));
		
		if (out.x > screenWidth || out.x < 0 || out.y > screenHeight || out.y < 0)
			return false;

		return true;
	}

	void ToggleESP() { espOn = !espOn; }

	void DrawESP() {
		if (!espOn || !globals::BASE || !globals::NAMES) return;

		Vector3 localPos = GetLocalPos();
		auto rd = Read<refdef_t>(globals::REFDEF);
		Vector2 screenFPos;
		Vector2 screenHPos;

		for (int i = 0; i < 155; i++)
		{
			Player* p = Player::GetPlayerAt(i);
			NameEntry ne = p->getNameEntry();

			if (!p || !p->isValid() || ne.health <= 0)
				continue;

			Vector3 feetPos = p->getOrigin();
			Vector3 headPos = p->getOrigin() + Vector3(0.0, 0.0, 58.0);

			if (W2S(feetPos, localPos, rd.width, rd.height, 
								rd.view.tanHalfFov, rd.view.axis, screenFPos) &&
					W2S(headPos, localPos, rd.width, rd.height,
								rd.view.tanHalfFov, rd.view.axis, screenHPos)) {
				float boxHeight = screenFPos.y - screenHPos.y;
				float boxWidth = boxHeight / 4.0;
				overlay->draw_box(screenHPos.x - boxWidth, screenHPos.y, boxWidth, boxHeight);
				overlay->draw_text_white(10.0, screenFPos.x, screenFPos.y, ne.name);
			}
		}
	}

#if DEBUG
	void PrintEntityDbg() {
		if (!globals::BASE) return;

		Vector3 localPos = GetLocalPos();
		auto rd = Read<refdef_t>(globals::REFDEF);
		Vector2 spos;

		for (int i = 0; i < 155; i++)
		{
			Player* p = Player::GetPlayerAt(i);
			NameEntry ne = p->getNameEntry();

			if (!p || !p->isValid() || ne.health <= 0)
				continue;

			Vector3 pos = p->getOrigin();
			printf(xorstr_("P# %d :: X = %f :: Y = %f :: Z = %f\n"), i, pos.x, pos.y, pos.z);
			printf(xorstr_("NAME = %s :: HEALTH = %d\n"), ne.name, ne.health);
			if (W2S(pos, localPos, rd.width, rd.height, rd.view.tanHalfFov, rd.view.axis, spos)) {
				printf(xorstr_("ESP :: %f, %f\n"), spos.x, spos.y);
			}
			printf("\n");
		}
	}
#endif

};



```

`main.cpp`:

```cpp
#include "sdk.h"
#include "game.h"
#include "xor.h"
#include <thread>


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hSecInstance, LPSTR nCmdLine, INT nCmdShow)
{
	LoadLibrary("user32.dll");

#if DEBUG
	AllocConsole();
	FILE* f;
	freopen_s(&f, "CONOUT$", "w", stdout);
#endif
	
	char* gn = globals::decGn();

	while (!process_id) {
		process_id = get_process_id(gn);
#if DEBUG
		utils::log(xorstr_("[+] Waiting for game to open..."));
#endif
		Sleep(1000);
	}
	globals::module_base = DriverGetBase(gn);

	memset(gn, 0, 18);
	delete[] gn;

	globals::peb = DriverGetPEB();

#if DEBUG
	utils::log(xorstr_("[+] Found Game!"));
	utils::loghex(xorstr_("[>] PEB: "), globals::peb);
	utils::loghex(xorstr_("[>] BASE: "), globals::module_base);
#endif

	Game& g_MW = Game::get();
	g_MW.Init();

	while (1) {
#if DEBUG
		if (GetAsyncKeyState(VK_PRIOR) & 1) {
			g_MW.UpdateAddresses();
		}
		if (GetAsyncKeyState(VK_NEXT) & 1) {
			g_MW.PrintEntityDbg();
		}
#endif
		if (GetAsyncKeyState(VK_HOME) & 1) {
			g_MW.ToggleESP();
		}
		if (GetAsyncKeyState(VK_END) & 1) {
			g_MW.End();
			break;
		}
	}

#if DEBUG
	fclose(f);
	FreeConsole();
#endif

}

```

`overlay.cpp`:

```cpp
#include "overlay.h"
#include "xor.h"

static HWND win;

auto FOverlay::window_set_style() -> void {
  int i = 0;

  i = (int)GetWindowLong(win, -20);

  SetWindowLongPtr(win, -20, (LONG_PTR)(i | 0x20)); //make transparent
  SetWindowDisplayAffinity(win, WDA_MONITOR | WDA_EXCLUDEFROMCAPTURE); //prevent capture
}

auto FOverlay::window_set_transparency() -> void {
  MARGINS margin;
  UINT opacity_flag, color_key_flag, color_key = 0;
  UINT opacity = 0;

  margin.cyBottomHeight = -1;
  margin.cxLeftWidth = -1;
  margin.cxRightWidth = -1;
  margin.cyTopHeight = -1;

  DwmExtendFrameIntoClientArea(win, &margin);

  opacity_flag = 0x02;
  color_key_flag = 0x01;
  color_key = 0x000000;
  opacity = 0xFF;

  SetLayeredWindowAttributes(win, color_key, opacity, opacity_flag);
}

auto FOverlay::window_set_top_most() -> void {
  SetWindowPos(win, HWND_TOPMOST, 0, 0, 0, 0, 0x0002 | 0x0001);
}

auto FOverlay::retrieve_window() -> HWND { return win; }


auto FOverlay::window_init() -> BOOL {
  win = FindWindow(xorstr_("CEF-OSC-WIDGET"), xorstr_("NVIDIA GeForce Overlay"));
  if (!win)
    return FALSE;

  FOverlay::window_set_style();
  FOverlay::window_set_transparency();
  FOverlay::window_set_top_most();

  ShowWindow(win, SW_SHOW);

  return TRUE;
}

/*
Overlay functions
*/

ID2D1Factory* d2d_factory;
ID2D1HwndRenderTarget* tar;
IDWriteFactory* write_factory;
ID2D1SolidColorBrush* brush;
ID2D1SolidColorBrush* red_brush;
ID2D1SolidColorBrush* green_brush;
IDWriteTextFormat* format;

auto FOverlay::d2d_shutdown() -> void {
  // Release
  tar->Release();
  write_factory->Release();
  brush->Release();
  red_brush->Release();
  green_brush->Release();
  d2d_factory->Release();
}

auto FOverlay::init_d2d() -> BOOL {
  HRESULT ret;
  RECT rc;

  // Initialize D2D here
  ret = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &d2d_factory);
  if (FAILED(ret))
    return FALSE;

  ret =
    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
      (IUnknown**)(&write_factory));
  if (FAILED(ret))
    return FALSE;

  write_factory->CreateTextFormat(
    L"Consolas", NULL, DWRITE_FONT_WEIGHT_REGULAR, DWRITE_FONT_STYLE_NORMAL,
    DWRITE_FONT_STRETCH_NORMAL, 13.0, L"en-us", &format);

  GetClientRect(FOverlay::retrieve_window(), &rc);

  ret = d2d_factory->CreateHwndRenderTarget(
    D2D1::RenderTargetProperties(
      D2D1_RENDER_TARGET_TYPE_DEFAULT,
      D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
        D2D1_ALPHA_MODE_PREMULTIPLIED)),
    D2D1::HwndRenderTargetProperties(
      FOverlay::retrieve_window(),
      D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top)),
    &tar);
  if (FAILED(ret))
    return FALSE;

  tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &brush);
  tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &red_brush);
  tar->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Green), &green_brush);

  return TRUE;
}

auto FOverlay::begin_scene() -> void { tar->BeginDraw(); }

auto FOverlay::end_scene() -> void { tar->EndDraw(); }

auto FOverlay::clear_scene() -> void { tar->Clear(); }

auto FOverlay::draw_text_white(float fsize, int x, int y, const char* str, ...) -> void {
  char buf[4096];
  int len = 0;
  wchar_t b[256];

  // if (!draw) // no need for it.
  //	 return;

  va_list arg_list;
  va_start(arg_list, str);
  vsnprintf(buf, sizeof(buf), str, arg_list);
  va_end(arg_list);

  len = strlen(buf);
  mbstowcs(b, buf, len);

  if (format) {
    format->Release();
    format = nullptr;
  }

  write_factory->CreateTextFormat(
    L"Consolas", NULL, DWRITE_FONT_WEIGHT_REGULAR, DWRITE_FONT_STYLE_NORMAL,
    DWRITE_FONT_STRETCH_NORMAL, fsize, L"en-us", &format);


  tar->DrawText(b, len, format, D2D1::RectF(x, y, 1920, 1080), brush,
    D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
}

auto FOverlay::draw_text_red(int x, int y, const char* str, ...) -> void {
  char buf[4096];
  int len = 0;
  wchar_t b[256];

  // if (!draw) // no need for it.
  //	 return;

  va_list arg_list;
  va_start(arg_list, str);
  vsnprintf(buf, sizeof(buf), str, arg_list);
  va_end(arg_list);

  len = strlen(buf);
  mbstowcs(b, buf, len);

  tar->DrawText(b, len, format, D2D1::RectF(x, y, 1920, 1080), red_brush,
    D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
}

auto FOverlay::draw_text_green(int x, int y, const char* str, ...) -> void {
  char buf[4096];
  int len = 0;
  wchar_t b[256];

  // if (!draw) // no need for it.
  //	 return;

  va_list arg_list;
  va_start(arg_list, str);
  vsnprintf(buf, sizeof(buf), str, arg_list);
  va_end(arg_list);

  len = strlen(buf);
  mbstowcs(b, buf, len);

  tar->DrawText(b, len, format, D2D1::RectF(x, y, 1920, 1080), green_brush,
    D2D1_DRAW_TEXT_OPTIONS_NONE, DWRITE_MEASURING_MODE_NATURAL);
}

void FOverlay::draw_box(int x, int y, int width, int height) {
  D2D1_RECT_F box = D2D1::RectF(x, y, x+width, y+height);
  tar->DrawRectangle(&box, red_brush);
}

auto FOverlay::clear_screen() -> void {
  FOverlay::begin_scene();
  FOverlay::clear_scene();
  FOverlay::end_scene();
}
```

`overlay.h`:

```h
#define _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_DEPRECATE
#pragma once

#include <windows.h>
#include <stdio.h>
#include <dwmapi.h> 
#include <d2d1.h>
#include <dwrite.h>
#pragma comment(lib, "Dwrite")
#pragma comment(lib, "Dwmapi.lib") 
#pragma comment(lib, "d2d1.lib")


class FOverlay
{
public:
	auto window_set_style()-> void;
	auto window_set_transparency()-> void;
	auto window_set_top_most()-> void;
	auto retrieve_window()->HWND;
	auto window_init()->BOOL;
	auto d2d_shutdown()-> void;
	auto init_d2d()->BOOL;
	auto begin_scene()-> void;
	auto end_scene()-> void;
	auto clear_scene()-> void;
	auto draw_text_white(float fsize, int x, int y, const char* str, ...)-> void;
	auto draw_text_red(int x, int y, const char* str, ...)-> void;
	auto draw_text_green(int x, int y, const char* str, ...)-> void;
	void draw_box(int x, int y, int width, int height);
	auto clear_screen()-> void;

};


```

`player.h`:

```h
#pragma once
#include "sdk.h"

class Player
{
public:
	static Player* GetPlayerAt(int i) {
		if (!globals::BASE) return nullptr;
		return (Player*)globals::BASE + (i * offsets::PLAYER_SIZE);
	}
	Vector3 getOrigin() {
		uint64_t posptr = Read<uint64_t>((uintptr_t)this + offsets::PLAYER_POS);
		return Read<Vector3>(posptr + 0x40);
	}
	uint32_t getIndex() {
		return ((uintptr_t)this - globals::BASE) / offsets::PLAYER_SIZE;
	}
	NameEntry getNameEntry() {
		auto i = getIndex();
		return Read<NameEntry>(globals::NAMES + (i * offsets::NAME_SIZE));
	}
	bool isValid() {
		uint32_t d1 = Read<uint32_t>((uintptr_t)this + offsets::PLAYER_DEAD_1);
		uint32_t d2 = Read<uint32_t>((uintptr_t)this + offsets::PLAYER_DEAD_2);
		uint32_t v = Read<uint32_t>((uintptr_t)this + offsets::PLAYER_VALID);

		return !d1 && !d2 && v == 1;
	}
};
```

`sdk.h`:

```h
#pragma once
#include "driver.h"
#include "vectors.h"
#include "xor.h"

/* ==== STRUCTS ===================*/
struct RefdefView {
	Vector2 tanHalfFov;		// 0x00
	uint8_t unk1[0xC];		// 0x08
	Vector3 axis[3];      // 0x14
};

struct refdef_t {
	int x;           // 0x00
	int y;           // 0x04
	int width;       // 0x08
	int height;      // 0x0C
	RefdefView view; // 0x10
};

struct refdefKeyStruct
{
	DWORD ref0; // 0x00
	DWORD ref1; // 0x04
	DWORD ref2; // 0x08
};

struct NameEntry {
	uint32_t idx;
	char name[0x24];
	uint8_t unk1[0x64];
	uint32_t health;
};
/* =================================*/

namespace utils {
	bool is_bad_ptr(void* adr) { return adr == nullptr; }
	void log(char* str) {
		std::cout << str << std::endl;
	}
	void loghex(char* str, uint64_t val) {
		std::cout << str << std::hex << val << std::endl;
	}
}
namespace globals {
	uint64_t module_base = 0;
	uint64_t peb = 0;

	uint64_t INFO = 0;
	uint64_t BASE = 0;
	uint64_t REFDEF = 0;
	uint64_t NAMES = 0;

	const char* gn = "Rtijws\\fwkfwj3j}j";
	char* decGn() {
		char* dec = new char[18];
		for (int i = 0; i < 17; i++) {
			dec[i] = gn[i] - 5;
		}
		dec[17] = '\0';
		return dec;
	}
}
namespace offsets {
	/*
	* Short Explanation of Offsets
	* ----------------------------
	* ClientInfo is what contains a pointer to 
	* ClientBase, which is essentially the entity 
	* list and can be indexed with PLAYER_SIZE.
	* 
	* RefDef contains view related info like
	* FOV and projection matrix; also encrypted 
	* 
	* Pointers to Client Info, Client Base, and
	* RefDef are all encrypted and must first be decrypted
	* 
	* Camera contains the local player's world location
	* 
	* Name List contains both player name and health
	* and is indexed using the same index number from ClientBase
	* 
	* Sig Credits: @rmccrystal
	* Decryption Credits: @moleskn
	*/

	// 48 8B 1D ? ? ? ? C6 44 24 ? ? 0F B6 44 24 ?
	constexpr auto CLIENT_INFO = 0x1720EB88;
	// 48 8B 83 ?? ?? ?? ?? C6 44 24 ?? ?? 0F B6
	constexpr auto CLIENT_BASE = 0x9DBE8;

	// 4C 8D 1D ? ? ? ? 44 8B 15 ? ? ? ? 48 8D 1D ? ? ? ? 4C 8B C9
	constexpr auto REFDEF = 0x17211518;
	// 48 8B 05 ? ? ? ? 48 8B 7C 24 ? 48 05 ? ? ? ?
	constexpr auto CAMERA_BASE = 0x144EE700;
	constexpr auto CAMERA_POS = 0x1D8;

	// C7 83 ? ? ? ? ? ? ? ? C7 83 ? ? ? ? ? ? ? ? E8 ? ? ? ? 44 0F B6 C6 48 8B D5 48 8B CF E8 ? ? ? ?
	constexpr auto PLAYER_DEAD_1 = 0x14B8;
	// 41 83 B8 ? ? ? ? ? 0F 85 ? ? ? ? 41 B8 ? ? ? ?
	constexpr auto PLAYER_DEAD_2 = 0x9B0;
	// 49 8B D9 41 0F B6 F0 8B F9 48 8B EA
	constexpr auto PLAYER_POS = 0x4C8;
	// 48 69 D3 ?? ?? ?? ?? 48 03 96 ?? ?? ?? ??
	constexpr auto PLAYER_SIZE = 0x3A88;
	// 8B 87 ? ? ? ? 4C 8B BC 24 ? ? ? ? 4C 8B B4 24 ? ? ? ? 4C 8B AC 24 ? ? ? ? 4C 8B A4 24 ? ? ? ? 85 C0 74 16
	constexpr auto PLAYER_TEAM = 0xB14;
	// C7 87 ?? ?? ?? ?? ?? ?? ?? ?? C7 87 ?? ?? ?? ?? ?? ?? ?? ?? 41
	constexpr auto PLAYER_VALID = 0x3E4;

	// 48 8D 0D ? ? ? ? 48 8B 0C C1 48 8B 01 FF 90 ? ? ? ?
	constexpr auto NAME_LIST = 0x1721C5F8;
	constexpr auto NAME_OFFSET = 0x4C70;
	constexpr auto NAME_SIZE = 0xD0;
}
namespace decryption
{
	auto DecryptClientInfo(uint64_t enc_client) -> uint64_t
	{
		uint64_t rax = 0, rbx = 0, rcx = 0, r8 = 0;
		rbx = enc_client;

		r8 = globals::peb;
		rax = (globals::module_base + 0x777B);
		r8 *= rax;
		rax = 0x1F8F946E8C369BB;
		rbx *= rax;
		r8 ^= rbx;
		rax = r8;
		rax >>= 0x28;
		r8 ^= rax;
		rax = r8;
		rax >>= 0xE;
		r8 ^= rax;
		rax = r8;
		rax >>= 0x1C;
		r8 ^= rax;
		rax = r8;
		rax >>= 0x38;
		r8 ^= rax;
		rax = (globals::module_base + 0xFC0);
		rcx -= rax;
		rax = r8;
		//rcx &= 0xffffffffc0000000;
		rcx = 0;
		rax >>= 0x25;
		rcx <<= 0x10;
		rax ^= r8;
		rcx ^= Read<uint64_t>(globals::module_base + 0x66FA0FC);
		rcx = (~rcx);
		rbx = Read<uint64_t>(rcx + 0x9);
		rbx *= rax;
		return rbx;
	}

	auto DecryptClientBase(uint64_t enc_client_info_base) -> uint64_t
	{
		uint64_t RAX = globals::module_base, RBX = globals::module_base, RCX = globals::module_base, RDX = globals::module_base, R8 = globals::module_base, RDI = globals::module_base, R9 = globals::module_base, R10 = globals::module_base, R11 = globals::module_base, R12 = globals::module_base, R13 = globals::module_base, R14 = globals::module_base, R15 = globals::module_base, RSI = globals::module_base, RSP = globals::module_base, RBP = globals::module_base;
		RAX = enc_client_info_base;
		if (!RAX)
			return 0;
		RBX = globals::peb;
		RBX = (~RBX);
		// test rax,rax
		// je near ptr 0000000001C417DFh
		RCX = RBX;
		RCX = _rotl64(RCX, 0x25);
		// and ecx,0Fh
		RCX &= 0xF;
		switch (RCX)
		{
			case 0:
			{
				RDI = globals::module_base + 0x1D4;
				R14 = globals::module_base + 0x3FF6;
				R9 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RCX = R14;
				RCX -= RBX;
				RAX += RCX;
				RCX = RAX;
				RCX >>= 0x1A;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x34;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x6;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0xC;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x18;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x30;
				RAX ^= RCX;
				RCX = 0x890F42B7FCD615;
				RAX *= RCX;
				RCX = RAX;
				RCX >>= 0x20;
				RAX ^= RCX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R9;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RCX = Read<uint64_t>(RCX + 0x17);
				RAX *= RCX;
				RCX = 0x71294A8B070B9839;
				RAX -= RCX;
				RCX = 0xBF1E74D2D72983AB;
				RAX *= RCX;
				return RAX;
			}
			case 1:
			{
				R11 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RDI = globals::module_base + 0x1D4;
				RDX = globals::module_base + 0x28554F16;
				RCX = RBX;
				RCX ^= RDX;
				RAX -= RCX;
				RCX = RAX;
				RCX >>= 0xE;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x1C;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x38;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0xA;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x14;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x28;
				RAX ^= RCX;
				RCX = 0xE1FD3C86DB19EBF9;
				RAX *= RCX;
				// mov r8,[rbp+108h]
				RDX = globals::module_base + 0x5D7E5CC0;
				R8 -= RDI;
				R8 = 0; // Special case
				R8 = _rotl64(R8, 0x10);
				R8 ^= R11;
				RCX = RBX;
				R8 = (~R8);
				RCX = (~RCX);
				RDX = (~RDX);
				RCX += RAX;
				RDX += RCX;
				RCX = 0x18DB6BC94B2CBA7C;
				if (utils::is_bad_ptr((void*)(R8 + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX = Read<uint64_t>(R8 + 0x17);
				RAX *= RDX;
				RAX ^= RCX;
				RCX = 0x68C819A3C9078EC0;
				RAX ^= RCX;
				return RAX;
			}
			case 2:
			{
				R10 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RDI = globals::module_base + 0x1D4;
				R15 = globals::module_base + 0xD51F;
				R11 = globals::module_base;
				RCX = RAX;
				RCX >>= 0x11;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x22;
				RAX ^= RCX;
				// mov rdx,[rbp+108h]
				RDX -= RDI;
				RDX = 0; // Special case
				RCX = RAX + R11;
				RDX = _rotl64(RDX, 0x10);
				RDX ^= R10;
				RDX = (~RDX);
				if (utils::is_bad_ptr((void*)(RDX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX = Read<uint64_t>(RDX + 0x17);
				RAX *= RCX;
				RCX = 0x4DE64FAFA04AFCC3;
				RAX *= RCX;
				RCX = R15;
				RCX = (~RCX);
				RCX += RBX;
				RAX ^= RCX;
				RAX -= RBX;
				RCX = 0x9EF4528D17D101CD;
				RAX ^= RCX;
				return RAX;
			}
			case 3:
			{
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				R9 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RCX = 0x51DF0317C63BA0B0;
				RAX -= RCX;
				RCX = RAX;
				RCX >>= 0x4;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x8;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x10;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x20;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0xC;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x18;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x30;
				RAX ^= RCX;
				RCX = 0x7B440B4A6B0A8EF5;
				RAX *= RCX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R9;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RCX = Read<uint64_t>(RCX + 0x17);
				RAX *= RCX;
				RAX -= RBX;
				RAX ^= R11;
				RCX = 0x3762E5D919DF6CF0;
				RAX -= RCX;
				return RAX;
			}
			case 4:
			{
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				R15 = globals::module_base + 0x455B9C25;
				R9 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RCX = RBX;
				RBP = globals::module_base + 0x949;
				RCX ^= RBP;
				RAX += RCX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R9;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RCX = Read<uint64_t>(RCX + 0x17);
				RSP = 0xDC393A1CB26C59A9;
				RCX *= RSP;
				RAX *= RCX;
				RAX -= RBX;
				RCX = RBX;
				RCX ^= R15;
				RAX -= RCX;
				RCX = RAX;
				RCX >>= 0x11;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x22;
				RAX ^= RCX;
				RAX -= R11;
				RAX += R11;
				return RAX;
			}
			case 5:
			{
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base + 0x739C6080;
				R9 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RCX = 0xE56F47E25078E80C;
				RAX ^= RCX;
				RCX = 0x36BCDD71AC89676F;
				RAX *= RCX;
				RCX = RAX;
				RCX >>= 0xD;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x1A;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x34;
				RAX ^= RCX;
				RCX = R11;
				RCX = (~RCX);
				RCX ^= RBX;
				RAX ^= RCX;
				RAX += RBX;
				RCX = 0xC824B36FD4F56BF3;
				RAX *= RCX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R9;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX *= Read<uint64_t>(RCX + 0x17);
				RCX = RAX;
				RCX >>= 0xA;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x14;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x28;
				RAX ^= RCX;
				return RAX;
			}
			case 6:
			{
				R10 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				RCX = 0x2EBB8A785E1A856A;
				RAX += RCX;
				RAX ^= R11;
				RCX = 0xC5EE09076CC9FE1C;
				RAX ^= RCX;
				RAX -= RBX;
				RCX = RAX;
				RCX >>= 0x1B;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x36;
				RAX ^= RCX;
				RCX = 0x1AEFC88777814F31;
				RAX *= RCX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R10;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX *= Read<uint64_t>(RCX + 0x17);
				RAX -= RBX;
				return RAX;
			}
			case 7:
			{
				R10 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RDI = globals::module_base + 0x1D4;
				R15 = globals::module_base + 0x39BD428F;
				RCX = 0x4A8E836720C9B049;
				RAX += RCX;
				RAX ^= RBX;
				RAX ^= R15;
				RCX = 0x47ADAA0C40AA79CE;
				RAX += RCX;
				RAX += RBX;
				RCX = RAX;
				RCX >>= 0x13;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x26;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x18;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x30;
				RAX ^= RCX;
				RCX = 0x7404B5F5DE776B17;
				RAX *= RCX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R10;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX *= Read<uint64_t>(RCX + 0x17);
				return RAX;
			}
			case 8:
			{
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				R10 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RDX = RBX;
				RCX = globals::module_base + 0x1818822A;
				RDX *= RCX;
				RCX = R11;
				RCX -= RDX;
				RAX += RCX;
				RCX = 0xF3DCF6EBF3A3997;
				RAX += RCX;
				RCX = 0x4C42D15E4A2708E5;
				RAX *= RCX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R10;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX *= Read<uint64_t>(RCX + 0x17);
				RCX = 0x83DBAD3327E0A500;
				RAX ^= RCX;
				RAX -= RBX;
				RCX = RAX;
				RCX >>= 0x12;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x24;
				RAX ^= RCX;
				return RAX;
			}
			case 9:
			{
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				R10 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RCX = R11 + 0xF50;
				RCX += RBX;
				RAX += RCX;
				RAX ^= RBX;
				// mov rdx,[rbp+108h]
				RDX -= RDI;
				RDX = 0; // Special case
				RCX = 0x9475C968613A0C67;
				RDX = _rotl64(RDX, 0x10);
				RCX += RAX;
				RDX ^= R10;
				RDX = (~RDX);
				if (utils::is_bad_ptr((void*)(RDX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX = Read<uint64_t>(RDX + 0x17);
				RAX *= RCX;
				RCX = globals::module_base + 0x6E91D3AB;
				RCX = (~RCX);
				RCX *= RBX;
				RAX ^= RCX;
				RCX = 0x1A81BB2AD0B4F3AC;
				RAX -= RCX;
				RCX = 0xBBB2C4BB8CE6593;
				RAX *= RCX;
				RCX = RAX;
				RCX >>= 0x19;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x32;
				RAX ^= RCX;
				return RAX;
			}
			case 10:
			{
				R9 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				R15 = globals::module_base + 0x6EA15250;
				RAX += RBX;
				RBP = 0x9BD059290DCB43D3;
				RAX *= RBP;
				RCX = RBX;
				RCX = (~RCX);
				RCX ^= R15;
				RAX -= RCX;
				RAX ^= RBX;
				RAX -= R11;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R9;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX *= Read<uint64_t>(RCX + 0x17);
				RCX = RAX;
				RCX >>= 0x8;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x10;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x20;
				RAX ^= RCX;
				RAX -= RBX;
				return RAX;
			}
			case 11:
			{
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				R10 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RCX = RAX;
				RCX >>= 0x14;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x28;
				RAX ^= RCX;
				RCX = 0x60FC131021EA9670;
				RAX ^= RCX;
				RCX = R11 + 0x8054;
				RCX += RBX;
				RAX += RCX;
				RAX ^= R11;
				// mov rdx,[rbp+108h]
				RDX -= RDI;
				RDX = 0; // Special case
				RCX = RAX;
				RDX = _rotl64(RDX, 0x10);
				RCX ^= R11;
				RDX ^= R10;
				RDX = (~RDX);
				if (utils::is_bad_ptr((void*)(RDX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX = Read<uint64_t>(RDX + 0x17);
				RAX *= RCX;
				RCX = 0x989F1826B9D2513F;
				RAX *= RCX;
				return RAX;
			}
			case 12:
			{
				R10 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				RCX = globals::module_base + 0x56E1284B;
				RCX = (~RCX);
				RCX -= RBX;
				RAX ^= RCX;
				RCX = globals::module_base + 0xD4EC;
				RCX = (~RCX);
				RCX -= RBX;
				RAX += RCX;
				RCX = 0xBBA27374E8361FEB;
				RAX *= RCX;
				RCX = RAX;
				RCX >>= 0x1C;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x38;
				RAX ^= RCX;
				RCX = R11 + 0x42C2;
				RCX += RBX;
				RAX ^= RCX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R10;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX *= Read<uint64_t>(RCX + 0x17);
				RCX = globals::module_base + 0x4FE2BA2B;
				RDX = RBX;
				RAX += RCX;
				RDX = (~RDX);
				RAX += RDX;
				RCX = 0x1EE121203251119E;
				RAX += RCX;
				return RAX;
			}
			case 13:
			{
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				R10 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R10;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX *= Read<uint64_t>(RCX + 0x17);
				RAX += RBX;
				RAX -= R11;
				RCX = 0xF2C3607F255C85D7;
				RAX *= RCX;
				RCX = 0xA0E2B3FEB404B52;
				RAX ^= RCX;
				RCX = RBX;
				RBP = globals::module_base + 0x17773B74;
				RCX *= RBP;
				RAX += RCX;
				RCX = RAX;
				RCX >>= 0x4;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x8;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x10;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x20;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x1E;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x3C;
				RAX ^= RCX;
				return RAX;
			}
			case 14:
			{
				RDI = globals::module_base + 0x1D4;
				R11 = globals::module_base;
				R9 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RAX -= RBX;
				RAX -= R11;
				RAX -= 0x8DEB;
				RAX ^= RBX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R9;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RCX = Read<uint64_t>(RCX + 0x17);
				RSP = 0x87F2757EC1B54FAB;
				RCX *= RSP;
				RAX *= RCX;
				RCX = RAX;
				RCX >>= 0xD;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x1A;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x34;
				RAX ^= RCX;
				RCX = globals::module_base + 0x7E28C7A5;
				RCX -= RBX;
				RAX += RCX;
				RAX -= R11;
				return RAX;
			}
			case 15:
			{
				R10 = Read<uint64_t>(globals::module_base + 0x66FA12A);
				RDI = globals::module_base + 0x1D4;
				RCX = 0x73482614CEAA9160;
				RAX ^= RCX;
				RAX += RBX;
				RCX = RAX;
				RCX >>= 0xB;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x16;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x2C;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x12;
				RAX ^= RCX;
				RCX = RAX;
				RCX >>= 0x24;
				RAX ^= RCX;
				// mov rcx,[rbp+108h]
				RCX -= RDI;
				RCX = 0; // Special case
				RCX = _rotl64(RCX, 0x10);
				RCX ^= R10;
				RCX = (~RCX);
				if (utils::is_bad_ptr((void*)(RCX + 0x17))) return 0xFFFFFFFFFFFFFFFF; RAX *= Read<uint64_t>(RCX + 0x17);
				RCX = 0xFD678AA3934E2FC7;
				RAX *= RCX;
				RCX = globals::module_base + 0x80E2;
				RAX += RCX;
				return RAX;
			}
			default:
				return 0;
		}
	}

	auto DecryptRefDef(refdefKeyStruct crypt)
	{
		uint64_t baseAddr = globals::module_base;

		DWORD lower = crypt.ref0 ^ (crypt.ref2 ^ (uint64_t)(baseAddr + offsets::REFDEF)) * ((crypt.ref2 ^ (uint64_t)(baseAddr + offsets::REFDEF)) + 2);
		DWORD upper = crypt.ref1 ^ (crypt.ref2 ^ (uint64_t)(baseAddr + offsets::REFDEF + 0x4)) * ((crypt.ref2 ^ (uint64_t)(baseAddr + offsets::REFDEF + 0x4)) + 2);

		return (uint64_t)upper << 32 | lower; // Merge Both DWORD into QWORD
	}
}

uint64_t GetRefDef()
{
	auto encrefdef = Read<refdefKeyStruct>(globals::module_base + offsets::REFDEF);
	return decryption::DecryptRefDef(encrefdef);
}
uint64_t GetClientInfo() {
	auto encinfo = Read<uint64_t>(globals::module_base + offsets::CLIENT_INFO);
	return decryption::DecryptClientInfo(encinfo);
}
uint64_t GetClientBase(uint64_t client_info) {
	auto encbase = Read<uint64_t>(client_info + offsets::CLIENT_BASE);
	return decryption::DecryptClientBase(encbase);
}
uint64_t GetNameList() {
	auto ptr = Read<uint64_t>(globals::module_base + offsets::NAME_LIST);
	return ptr + offsets::NAME_OFFSET;
}










```

`vectors.h`:

```h
#pragma once
#include <cmath>
#include <algorithm>

#define M_PI	3.14159265358979323846264338327950288419716939937510

//Vector2
class Vector2
{
public:
	Vector2() : x(0.f), y(0.f)
	{

	}

	Vector2(float _x, float _y) : x(_x), y(_y)
	{

	}
	~Vector2()
	{

	}

	float x;
	float y;
};

//Vector3
class Vector3
{
public:
	Vector3() : x(0.f), y(0.f), z(0.f)
	{

	}

	Vector3(float _x, float _y, float _z) : x(_x), y(_y), z(_z)
	{

	}
	~Vector3()
	{

	}

	float x;
	float y;
	float z;

	inline float Dot(Vector3 v)
	{
		return x * v.x + y * v.y + z * v.z;
	}

	inline float Distance(Vector3 v)
	{
		return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
	}
	inline float Length()
	{
		float ls = x * x + y * y + z * z;
		return sqrt(ls);
	}

	Vector3 operator+(Vector3 v)
	{
		return Vector3(x + v.x, y + v.y, z + v.z);
	}

	Vector3 operator-(Vector3 v)
	{
		return Vector3(x - v.x, y - v.y, z - v.z);
	}

	Vector3 operator*(float number) const {
		return Vector3(x * number, y * number, z * number);
	}		

	Vector3& operator-=( const Vector3& v )
	{
		x -= v.x;
		y -= v.y;
		z -= v.z;

		return *this;
	}


	void clamp()
	{
		if ( x > 75.f ) x = 75.f;
		else if (x < -75.f ) x = -75.f;
		if ( z < -180 ) z += 360.0f;
		else if ( z > 180 ) z -= 360.0f;

		y = 0.f;
	}

};

//Vector4
class Vector4
{
public:
	Vector4() : x(0.f), y(0.f), z(0.f), w(0.f)
	{

	}

	Vector4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w)
	{

	}
	~Vector4()
	{

	}

	float x;
	float y;
	float z;
	float w;
};

```

`xor.h`:

```h
#pragma once
/*
 * Copyright 2017 - 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define JM_XORSTR_DISABLE_AVX_INTRINSICS 1

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define xorstr(str)                                              \
    ::jm::make_xorstr(                                           \
        []() { return str; },                                    \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{},  \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr_(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

 // you can define this macro to get possibly faster code on gcc/clang
 // at the expense of constants being put into data section.
#if !defined(XORSTR_ALLOW_DATA)
// MSVC - no volatile
// GCC and clang - volatile everywhere
#if defined(__clang__) || defined(__GNUC__)
#define XORSTR_VOLATILE volatile
#endif

#endif
#ifndef XORSTR_VOLATILE
#define XORSTR_VOLATILE
#endif

namespace jm {

	namespace detail {

		template<std::size_t S>
		struct unsigned_;

		template<>
		struct unsigned_<1> {
			using type = std::uint8_t;
		};
		template<>
		struct unsigned_<2> {
			using type = std::uint16_t;
		};
		template<>
		struct unsigned_<4> {
			using type = std::uint32_t;
		};

		template<auto C, auto...>
		struct pack_value_type {
			using type = decltype(C);
		};

		template<std::size_t Size>
		constexpr std::size_t _buffer_size()
		{
			return ((Size / 16) + (Size % 16 != 0)) * 2;
		}

		template<auto... Cs>
		struct tstring_ {
			using value_type                  = typename pack_value_type<Cs...>::type;
			constexpr static std::size_t size = sizeof...(Cs);
			constexpr static value_type  str[size] = { Cs... };

			constexpr static std::size_t buffer_size = _buffer_size<sizeof(str)>();
			constexpr static std::size_t buffer_align =
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
			((sizeof(str) > 16) ? 32 : 16);
#else
				16;
#endif
		};

		template<std::size_t I, std::uint64_t K>
		struct _ki {
			constexpr static std::size_t   idx = I;
			constexpr static std::uint64_t key = K;
		};

		template<std::uint32_t Seed>
		constexpr std::uint32_t key4() noexcept
		{
			std::uint32_t value = Seed;
			for (char c : __TIME__)
				value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
			return value;
		}

		template<std::size_t S>
		constexpr std::uint64_t key8()
		{
			constexpr auto first_part = key4<2166136261 + S>();
			constexpr auto second_part = key4<first_part>();
			return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
		}

		// clang and gcc try really hard to place the constants in data
		// sections. to counter that there was a need to create an intermediate
		// constexpr string and then copy it into a non constexpr container with
		// volatile storage so that the constants would be placed directly into
		// code.
		template<class T, std::uint64_t... Keys>
		struct string_storage {
			std::uint64_t storage[T::buffer_size];

			XORSTR_FORCEINLINE constexpr string_storage() noexcept : storage{ Keys... }
			{
				using cast_type =
					typename unsigned_<sizeof(typename T::value_type)>::type;
				constexpr auto value_size = sizeof(typename T::value_type);
				// puts the string into 64 bit integer blocks in a constexpr
				// fashion
				for (std::size_t i = 0; i < T::size; ++i)
					storage[i / (8 / value_size)] ^=
					(std::uint64_t{ static_cast<cast_type>(T::str[i]) }
				<< ((i % (8 / value_size)) * 8 * value_size));
			}
		};

	} // namespace detail

	template<class T, class... Keys>
	class xor_string {
		alignas(T::buffer_align) std::uint64_t _storage[T::buffer_size];

		// _single functions needed because MSVC crashes without them
		XORSTR_FORCEINLINE void _crypt_256_single(const std::uint64_t* keys,
			std::uint64_t* storage) noexcept

		{
			_mm256_store_si256(
				reinterpret_cast<__m256i*>(storage),
				_mm256_xor_si256(
					_mm256_load_si256(reinterpret_cast<const __m256i*>(storage)),
					_mm256_load_si256(reinterpret_cast<const __m256i*>(keys))));
		}

		template<std::size_t... Idxs>
		XORSTR_FORCEINLINE void _crypt_256(const std::uint64_t* keys,
			std::index_sequence<Idxs...>) noexcept
		{
			(_crypt_256_single(keys + Idxs * 4, _storage + Idxs * 4), ...);
		}

		XORSTR_FORCEINLINE void _crypt_128_single(const std::uint64_t* keys,
			std::uint64_t* storage) noexcept
		{
			_mm_store_si128(
				reinterpret_cast<__m128i*>(storage),
				_mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(storage)),
					_mm_load_si128(reinterpret_cast<const __m128i*>(keys))));
		}

		template<std::size_t... Idxs>
		XORSTR_FORCEINLINE void _crypt_128(const std::uint64_t* keys,
			std::index_sequence<Idxs...>) noexcept
		{
			(_crypt_128_single(keys + Idxs * 2, _storage + Idxs * 2), ...);
		}

		// loop generates vectorized code which places constants in data dir
		XORSTR_FORCEINLINE constexpr void _copy() noexcept
		{
			constexpr detail::string_storage<T, Keys::key...> storage;
			static_cast<void>(std::initializer_list<std::uint64_t>{
				(const_cast<XORSTR_VOLATILE std::uint64_t*>(_storage))[Keys::idx] =
					storage.storage[Keys::idx]... });
		}

	public:
		using value_type    = typename T::value_type;
		using size_type     = std::size_t;
		using pointer       = value_type *;
		using const_pointer = const pointer;

		XORSTR_FORCEINLINE xor_string() noexcept { _copy(); }

		XORSTR_FORCEINLINE constexpr size_type size() const noexcept
		{
			return T::size - 1;
		}

		XORSTR_FORCEINLINE void crypt() noexcept
		{
			alignas(T::buffer_align) std::uint64_t keys[T::buffer_size];
			static_cast<void>(std::initializer_list<std::uint64_t>{
				(const_cast<XORSTR_VOLATILE std::uint64_t*>(keys))[Keys::idx] =
					Keys::key... });

			_copy();

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
			_crypt_256(keys, std::make_index_sequence<T::buffer_size / 4>{});
			if constexpr (T::buffer_size % 4 != 0)
				_crypt_128(keys, std::index_sequence<T::buffer_size / 2 - 1>{});
#else
			_crypt_128(keys, std::make_index_sequence<T::buffer_size / 2>{});
#endif
		}

		XORSTR_FORCEINLINE const_pointer get() const noexcept
		{
			return reinterpret_cast<const_pointer>(_storage);
		}

		XORSTR_FORCEINLINE const_pointer crypt_get() noexcept
		{
			crypt();
			return reinterpret_cast<const_pointer>(_storage);
		}
	};

	template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
	XORSTR_FORCEINLINE constexpr auto
		make_xorstr(Tstr str_lambda,
			std::index_sequence<StringIndices...>,
			std::index_sequence<KeyIndices...>) noexcept
	{
		return xor_string<detail::tstring_<str_lambda()[StringIndices]...>,
			detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
	}

} // namespace jm

#endif // include guard
```