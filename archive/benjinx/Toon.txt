Project Path: arc_benjinx_Toon_fsm3suh6

Source Tree:

```txt
arc_benjinx_Toon_fsm3suh6
├── CMake
│   ├── CompileShaders.cmake
│   ├── DefineDemo.cmake
│   ├── DefineModule.cmake
│   ├── FindGSL.cmake
│   ├── FindVulkanSDK.cmake
│   ├── Findpatch.cmake
│   ├── GetGitRevisionDescription.cmake
│   ├── GetGitRevisionDescription.cmake.in
│   ├── Policies.cmake
│   ├── SetSourceGroups.cmake
│   ├── Toon.pc.in
│   ├── ToonConfig.cmake.in
│   └── Version.cmake
├── CMakeLists.txt
├── Demos
│   ├── CMakeLists.txt
│   ├── HelloWorld
│   │   ├── CMakeLists.txt
│   │   ├── HelloWorld.toonproj
│   │   └── Source
│   │       └── Main.cpp
│   ├── Lighting
│   │   ├── Assets
│   │   │   └── Shaders
│   │   │       ├── BlinnPhongLighting.inc.glsl
│   │   │       ├── Lighting.frag.glsl
│   │   │       ├── Lighting.vert.glsl
│   │   │       └── PhongLighting.inc.glsl
│   │   ├── CMakeLists.txt
│   │   ├── Lighting.toonproj
│   │   └── Source
│   │       └── Main.cpp
│   └── Sandbox
│       ├── CMakeLists.txt
│       ├── Sandbox.toonproj
│       └── Source
│           └── Main.cpp
├── Dockerfile
├── Engine
│   ├── Assets
│   │   ├── Shaders
│   │   │   └── Toon
│   │   │       ├── ColorSpace.inc.glsl
│   │   │       ├── Debug
│   │   │       │   ├── NormalColor.frag.glsl
│   │   │       │   └── NormalColor.vert.glsl
│   │   │       ├── Default.frag.glsl
│   │   │       ├── Default.vert.glsl
│   │   │       ├── Default2.frag.glsl
│   │   │       ├── Default2.vert.glsl
│   │   │       ├── FlatColor.frag.glsl
│   │   │       ├── FlatColor.vert.glsl
│   │   │       ├── Globals.inc.glsl
│   │   │       ├── Material.inc.glsl
│   │   │       ├── Math.inc.glsl
│   │   │       ├── TBN.inc.glsl
│   │   │       ├── Transform.inc.glsl
│   │   │       └── VertexAttributes.inc.glsl
│   │   ├── Textures
│   │   │   ├── avatars
│   │   │   │   ├── AvatarBen.png
│   │   │   │   ├── AvatarDan.png
│   │   │   │   ├── AvatarSteve.png
│   │   │   │   └── logo.jpg
│   │   │   ├── brickwall
│   │   │   │   ├── ReadMe.txt
│   │   │   │   ├── brickwall.jpg
│   │   │   │   └── brickwall_normal.jpg
│   │   │   ├── mars
│   │   │   │   └── 2k
│   │   │   │       ├── ReadMe.txt
│   │   │   │       ├── mars.glb
│   │   │   │       ├── mars.mtl
│   │   │   │       ├── mars.obj
│   │   │   │       ├── mars_dm_2k.png
│   │   │   │       ├── mars_nm_2k.png
│   │   │   │       └── mars_nm_2k_os.png
│   │   │   ├── scuffed-plastic
│   │   │   │   ├── About these PBR files.txt
│   │   │   │   ├── scuffed-plastic-alb.png
│   │   │   │   ├── scuffed-plastic-ao.png
│   │   │   │   ├── scuffed-plastic-metal.png
│   │   │   │   ├── scuffed-plastic-normal.png
│   │   │   │   ├── scuffed-plastic-rough.png
│   │   │   │   ├── scuffed-plastic2-alb.png
│   │   │   │   ├── scuffed-plastic3-alb.png
│   │   │   │   ├── scuffed-plastic4-alb.png
│   │   │   │   ├── scuffed-plastic5-alb.png
│   │   │   │   ├── scuffed-plastic6-alb.png
│   │   │   │   ├── scuffed-plastic7-alb.png
│   │   │   │   └── scuffed-plastic8-alb.png
│   │   │   └── skyboxes
│   │   │       └── demo
│   │   │           ├── ReadMe.txt
│   │   │           ├── back.jpg
│   │   │           ├── bottom.jpg
│   │   │           ├── front.jpg
│   │   │           ├── left.jpg
│   │   │           ├── right.jpg
│   │   │           └── top.jpg
│   │   └── models
│   │       ├── DamagedHelmet
│   │       │   ├── AO_metalRoughness.png
│   │       │   ├── DamagedHelmet.bin
│   │       │   ├── DamagedHelmet.gltf
│   │       │   ├── albedo.jpg
│   │       │   ├── emissive.jpg
│   │       │   └── normal.jpg
│   │       ├── Primitives
│   │       │   ├── Obj
│   │       │   │   ├── pCone.mtl
│   │       │   │   ├── pCone.obj
│   │       │   │   ├── pCube.mtl
│   │       │   │   ├── pCube.obj
│   │       │   │   ├── pCylinder.mtl
│   │       │   │   ├── pCylinder.obj
│   │       │   │   ├── pGrid.mtl
│   │       │   │   ├── pGrid.obj
│   │       │   │   ├── pIcoSphere.mtl
│   │       │   │   ├── pIcoSphere.obj
│   │       │   │   ├── pMonkey.mtl
│   │       │   │   ├── pMonkey.obj
│   │       │   │   ├── pPlane.mtl
│   │       │   │   ├── pPlane.obj
│   │       │   │   ├── pSphere.mtl
│   │       │   │   ├── pSphere.obj
│   │       │   │   ├── pTorus.mtl
│   │       │   │   └── pTorus.obj
│   │       │   ├── pCube.glb
│   │       │   ├── pPlane.glb
│   │       │   ├── pSphere.glb
│   │       │   └── pTorus.glb
│   │       └── logo
│   │           └── logo.glb
│   ├── CMakeLists.txt
│   ├── Private
│   │   ├── AxisComponent.cpp
│   │   ├── Buffer.cpp
│   │   ├── Camera.cpp
│   │   ├── Collision.cpp
│   │   ├── Entity.cpp
│   │   ├── Event.cpp
│   │   ├── GraphicsDriver.cpp
│   │   ├── InputDriver.cpp
│   │   ├── Light.cpp
│   │   ├── Log.cpp
│   │   ├── Material.cpp
│   │   ├── Mesh.cpp
│   │   ├── MeshComponent.cpp
│   │   ├── MeshImporter.cpp
│   │   ├── Module.cpp
│   │   ├── Path.cpp
│   │   ├── Primitive.cpp
│   │   ├── PrimitiveData.cpp
│   │   ├── Rigidbody.cpp
│   │   ├── Scene.cpp
│   │   ├── SceneImporter.cpp
│   │   ├── Shader.cpp
│   │   ├── Texture.cpp
│   │   ├── TextureImporter.cpp
│   │   ├── Toon.cpp
│   │   └── Util.cpp
│   └── Public
│       └── Toon
│           ├── AudioDriver.hpp
│           ├── AxisComponent.hpp
│           ├── Benchmark.hpp
│           ├── Buffer.hpp
│           ├── Camera.hpp
│           ├── Collision.hpp
│           ├── CommandList.hpp
│           ├── Component.hpp
│           ├── Config.hpp.in
│           ├── Controller.hpp
│           ├── Entity.hpp
│           ├── Event.hpp
│           ├── Font.hpp
│           ├── GraphicsDriver.hpp
│           ├── InputDriver.hpp
│           ├── JSON.hpp
│           ├── Keyboard.hpp
│           ├── Light.hpp
│           ├── Log.hpp
│           ├── Macros.hpp
│           ├── Material.hpp
│           ├── Math.hpp
│           ├── Mesh.hpp
│           ├── MeshComponent.hpp
│           ├── MeshImporter.hpp
│           ├── Module.hpp
│           ├── Mouse.hpp
│           ├── Path.hpp
│           ├── Pipeline.hpp
│           ├── Platform.hpp
│           ├── Primitive.hpp
│           ├── PrimitiveData.hpp
│           ├── RenderContext.hpp
│           ├── Rigidbody.hpp
│           ├── Scene.hpp
│           ├── SceneImporter.hpp
│           ├── Shader.hpp
│           ├── ShaderGlobals.hpp
│           ├── ShaderMaterial.hpp
│           ├── ShaderScene.hpp
│           ├── ShaderTransform.hpp
│           ├── String.hpp
│           ├── System.hpp
│           ├── Texture.hpp
│           ├── TextureData.hpp
│           ├── TextureImporter.hpp
│           ├── Time.hpp
│           ├── Toon.hpp
│           ├── UpdateContext.hpp
│           ├── Util.hpp
│           ├── Version.hpp
│           └── Vertex.hpp
├── LICENSE
├── Modules
│   ├── CMakeLists.txt
│   ├── GLTF2
│   │   ├── CMakeLists.txt
│   │   ├── Private
│   │   │   ├── Base64.hpp
│   │   │   ├── GLTF2MeshImporter.cpp
│   │   │   ├── GLTF2Module.cpp
│   │   │   ├── GLTF2SceneImporter.cpp
│   │   │   ├── OpenGLStub.hpp
│   │   │   ├── glTF2File.cpp
│   │   │   └── glTF2File.hpp
│   │   └── Public
│   │       └── Toon
│   │           └── GLTF2
│   │               ├── GLTF2Config.hpp
│   │               ├── GLTF2MeshImporter.hpp
│   │               ├── GLTF2PrimitiveData.hpp
│   │               └── GLTF2SceneImporter.hpp
│   ├── OpenGL
│   │   ├── CMakeLists.txt
│   │   ├── Private
│   │   │   ├── OpenGLBuffer.cpp
│   │   │   ├── OpenGLGraphicsDriver.cpp
│   │   │   ├── OpenGLMaterial.cpp
│   │   │   ├── OpenGLMesh.cpp
│   │   │   ├── OpenGLModule.cpp
│   │   │   ├── OpenGLPipeline.cpp
│   │   │   ├── OpenGLPrimitive.cpp
│   │   │   ├── OpenGLShader.cpp
│   │   │   ├── OpenGLTexture.cpp
│   │   │   └── glad
│   │   │       └── gl.c
│   │   └── Public
│   │       ├── KHR
│   │       │   └── khrplatform.h
│   │       ├── Toon
│   │       │   └── OpenGL
│   │       │       ├── OpenGLBuffer.hpp
│   │       │       ├── OpenGLConfig.hpp
│   │       │       ├── OpenGLGraphicsDriver.hpp
│   │       │       ├── OpenGLMaterial.hpp
│   │       │       ├── OpenGLMesh.hpp
│   │       │       ├── OpenGLPipeline.hpp
│   │       │       ├── OpenGLPrimitive.hpp
│   │       │       ├── OpenGLShader.hpp
│   │       │       └── OpenGLTexture.hpp
│   │       └── glad
│   │           └── gl.h
│   ├── SDL2
│   │   ├── CMakeLists.txt
│   │   ├── Private
│   │   │   ├── SDL2GraphicsDriver.cpp
│   │   │   └── SDL2InputDriver.cpp
│   │   └── Public
│   │       └── Toon
│   │           └── SDL2
│   │               ├── SDL2Config.hpp
│   │               ├── SDL2GraphicsDriver.hpp
│   │               └── SDL2InputDriver.hpp
│   ├── STBI
│   │   ├── CMakeLists.txt
│   │   ├── Private
│   │   │   ├── STBIModule.cpp
│   │   │   └── STBITextureImporter.cpp
│   │   └── Public
│   │       ├── Toon
│   │       │   └── STBI
│   │       │       ├── STBIConfig.hpp
│   │       │       ├── STBITextureData.hpp
│   │       │       ├── STBITextureImporter.hpp
│   │       │       └── Tests
│   │       │           └── STBI_TextureImporter_Test.cpp
│   │       └── stb
│   │           └── stb_image.h
│   ├── TinyOBJ
│   │   ├── CMakeLists.txt
│   │   ├── Private
│   │   │   ├── TinyOBJMeshImporter.cpp
│   │   │   ├── TinyOBJModule.cpp
│   │   │   └── tiny_obj_loader.h
│   │   └── Public
│   │       └── Toon
│   │           └── TinyOBJ
│   │               ├── TinyOBJConfig.hpp
│   │               ├── TinyOBJMeshImporter.hpp
│   │               └── TinyOBJPrimitiveData.hpp
│   └── Vulkan
│       ├── CMakeLists.txt
│       ├── Private
│       │   ├── VulkanBuffer.cpp
│       │   ├── VulkanGraphicsDriver.cpp
│       │   ├── VulkanMesh.cpp
│       │   ├── VulkanModule.cpp
│       │   ├── VulkanPipeline.cpp
│       │   ├── VulkanPrimitive.cpp
│       │   ├── VulkanShader.cpp
│       │   ├── VulkanTexture.cpp
│       │   └── glad
│       │       └── vulkan.c
│       └── Public
│           ├── Toon
│           │   └── Vulkan
│           │       ├── VulkanBuffer.hpp
│           │       ├── VulkanConfig.hpp
│           │       ├── VulkanGraphicsDriver.hpp
│           │       ├── VulkanMesh.hpp
│           │       ├── VulkanPipeline.hpp
│           │       ├── VulkanPrimitive.hpp
│           │       ├── VulkanRenderContext.hpp
│           │       ├── VulkanShader.hpp
│           │       └── VulkanTexture.hpp
│           ├── glad
│           │   └── vulkan.h
│           ├── vk_mem_alloc.h
│           └── vk_platform.h
├── README.md
├── Scripts
│   ├── ci-install-vulkan.ps1
│   └── generate-launch-targets.py
├── ThirdParty
│   ├── CMakeLists.txt
│   └── SDL2_vcruntime.patch
├── appveyor.yml
└── old
    ├── Assets
    │   └── shaders
    │       ├── axis.frag
    │       ├── axis.vert
    │       ├── defaultLighting.frag
    │       ├── defaultLighting.vert
    │       ├── misc
    │       │   ├── compile-spirv-shaders.bat
    │       │   ├── gammaCorrection.frag
    │       │   ├── gammaCorrection.vert
    │       │   ├── toonShader.frag
    │       │   └── toonShader.vert
    │       ├── passThruColor.frag
    │       ├── passThruColor.frag.glsl
    │       ├── passThruColor.vert
    │       ├── passThruColor.vert.glsl
    │       ├── passThruTexture.frag
    │       ├── passThruTexture.vert
    │       ├── passThruUV.frag
    │       ├── passThruUV.vert
    │       ├── skybox.frag
    │       ├── skybox.frag.glsl
    │       ├── skybox.vert
    │       ├── skybox.vert.glsl
    │       ├── toonShader.frag
    │       └── toonShader.vert
    ├── CMakeLists.txt
    ├── demos
    │   ├── CMakeLists.txt
    │   ├── Cubemap
    │   │   ├── CMakeLists.txt
    │   │   ├── resources
    │   │   │   └── shaders
    │   │   │       ├── reflection.frag
    │   │   │       ├── reflection.vert
    │   │   │       ├── refraction.frag
    │   │   │       └── refraction.vert
    │   │   └── src
    │   │       ├── GameScene.cpp
    │   │       ├── GameScene.hpp
    │   │       └── Main.cpp
    │   ├── LightCasters
    │   │   ├── CMakeLists.txt
    │   │   ├── resources
    │   │   │   └── shaders
    │   │   │       ├── lightCasters.frag
    │   │   │       └── lightCasters.vert
    │   │   └── src
    │   │       ├── GameScene.cpp
    │   │       ├── GameScene.hpp
    │   │       └── Main.cpp
    │   ├── NormalMapping
    │   │   ├── CMakeLists.txt
    │   │   ├── resources
    │   │   │   ├── images
    │   │   │   │   └── earth
    │   │   │   │       └── 2k
    │   │   │   │           ├── earth_cm_2k.png
    │   │   │   │           ├── earth_dm_2k.png
    │   │   │   │           ├── earth_hm_2k.png
    │   │   │   │           ├── earth_lm_2k.png
    │   │   │   │           ├── earth_nm_2k.png
    │   │   │   │           ├── earth_nm_2k_os.png
    │   │   │   │           └── earth_sm_2k.png
    │   │   │   ├── models
    │   │   │   │   ├── earth.glb
    │   │   │   │   ├── mars.glb
    │   │   │   │   └── moon.glb
    │   │   │   └── shaders
    │   │   │       ├── normalMapping.frag
    │   │   │       └── normalMapping.vert
    │   │   └── src
    │   │       ├── GameScene.cpp
    │   │       ├── GameScene.hpp
    │   │       └── Main.cpp
    │   ├── Sandbox
    │   │   ├── CMakeLists.txt
    │   │   ├── resources
    │   │   │   ├── models
    │   │   │   │   ├── DamagedHelmet.glb
    │   │   │   │   ├── bulbasaur.mtl
    │   │   │   │   └── bulbasaur.obj
    │   │   │   └── shaders
    │   │   │       ├── advLighting.frag
    │   │   │       ├── advLighting.vert
    │   │   │       ├── normalMapping.frag
    │   │   │       ├── normalMapping.vert
    │   │   │       ├── stencil.frag
    │   │   │       ├── stencil.vert
    │   │   │       ├── time.frag
    │   │   │       └── time.vert
    │   │   └── src
    │   │       ├── GameScene.cpp
    │   │       ├── GameScene.hpp
    │   │       └── Main.cpp
    │   └── Stencil
    │       ├── CMakeLists.txt
    │       ├── resources
    │       │   └── shaders
    │       │       ├── advLighting.frag
    │       │       ├── advLighting.vert
    │       │       ├── stencil.frag
    │       │       └── stencil.vert
    │       └── src
    │           ├── GameScene.cpp
    │           ├── GameScene.hpp
    │           └── Main.cpp
    ├── include
    │   └── glTF2.hpp
    └── src
        └── glTF2.cpp

```

`CMake/CompileShaders.cmake`:

```cmake

MACRO(COMPILE_SHADERS shaders_in shaders_out)
    IF(VulkanSDK_FOUND)
        FOREACH(file ${shaders_in})
            GET_FILENAME_COMPONENT(shader_ext ${file} LAST_EXT)
            IF(shader_ext STREQUAL ".glsl")
                GET_FILENAME_COMPONENT(shader_name ${file} NAME_WLE)
                GET_FILENAME_COMPONENT(shader_path ${file} DIRECTORY)
                STRING(REPLACE
                    ${CMAKE_CURRENT_SOURCE_DIR}
                    ${CMAKE_CURRENT_BINARY_DIR}
                    shader_out_path
                    ${shader_path}
                )

                FILE(MAKE_DIRECTORY ${shader_out_path})

                SET(shader_cflags "")
                FOREACH(dir ${TOON_ASSET_PATH})
                    SET(shader_cflags ${shader_cflags} -I"${dir}/Shaders/")
                ENDFOREACH()

                SET(shader_out "${shader_out_path}/${shader_name}.spv")

                GET_FILENAME_COMPONENT(shader_type ${shader_name} LAST_EXT)
                STRING(SUBSTRING ${shader_type} 1 -1 shader_type)

                IF(shader_type STREQUAL "inc")
                    CONTINUE()
                ELSE()
                    SET(shader_cflags ${shader_cflags} -fshader-stage=${shader_type})
                ENDIF()

                ADD_CUSTOM_COMMAND(
                    OUTPUT ${shader_out}
                    COMMAND ${VulkanSDK_glslc_PROGRAM} ${shader_cflags} -o ${shader_out} ${file}
                    DEPENDS ${file}
                    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
                )

                LIST(APPEND ${shaders_out} ${shader_out})
            ENDIF()
        ENDFOREACH()
    ENDIF()
ENDMACRO()
```

`CMake/DefineDemo.cmake`:

```cmake

INCLUDE(CompileShaders)
INCLUDE(SetSourceGroups)

MACRO(DEFINE_DEMO _target)
    FILE(GLOB_RECURSE
        _sources
        "Source/*.h"
        "Source/*.hpp"
        "Source/*.c"
        "Source/*.cpp"
    )

    FILE(GLOB_RECURSE
        _sources_in
        "Source/*.in"
    )

    ###
    ### Template Files
    ###

    FOREACH(file ${_sources_in})
        STRING(REPLACE 
            ${CMAKE_CURRENT_SOURCE_DIR}
            ${CMAKE_CURRENT_BINARY_DIR}
            file_out
            ${file}
        )

        string(REGEX MATCH "^(.*)\\.[^.]*$" file_out ${file_out})
        set(file_out ${CMAKE_MATCH_1})

        CONFIGURE_FILE(${file} ${file_out})
        LIST(APPEND _sources_out ${file_out})
    ENDFOREACH()

    ###
    ### Shader Processing
    ###

    FILE(
        GLOB_RECURSE
        _shaders_in
        Assets/Shaders/*.glsl
        #Assets/Shaders/*.hlsl
    )

    LIST(INSERT TOON_ASSET_PATH 0
        ${CMAKE_CURRENT_SOURCE_DIR}/Assets
        ${CMAKE_CURRENT_BINARY_DIR}/Assets
    )

    COMPILE_SHADERS("${_shaders_in}" _shaders_out)

    ###
    ### Asset Processing
    ###

    FILE(GLOB_RECURSE
        _assets
        Assets/*
    )

    LIST(INSERT TOON_ASSET_PATH 0
        ${CMAKE_CURRENT_SOURCE_DIR}/Assets/
    )

    # Stop VS from trying to "build" our .obj model files
    SET_SOURCE_FILES_PROPERTIES(
        ${_assets}
        PROPERTIES
            HEADER_FILE_ONLY TRUE
    )

    ###
    ### Target Configuration
    ###

    ADD_EXECUTABLE(
        ${_target}
        ${_sources}
        ${_sources_in}
        ${_sources_out}
        ${_shaders_in}
        ${_shaders_out}
        ${_assets}
    )

    SET_SOURCE_GROUPS(${CMAKE_CURRENT_SOURCE_DIR} "${_sources}")
    SET_SOURCE_GROUPS(${CMAKE_CURRENT_SOURCE_DIR} "${_sources_in}")
    SET_SOURCE_GROUPS(${CMAKE_CURRENT_BINARY_DIR} "${_sources_out}")
    SET_SOURCE_GROUPS(${CMAKE_CURRENT_SOURCE_DIR} "${_shaders_in}")
    SET_SOURCE_GROUPS(${CMAKE_CURRENT_SOURCE_DIR} "${_shaders_out}")
    SET_SOURCE_GROUPS(${CMAKE_CURRENT_SOURCE_DIR} "${_assets}")

    TARGET_LINK_LIBRARIES(
        ${_target}
        PRIVATE
            ToonEngine
    )

    TARGET_INCLUDE_DIRECTORIES(
        ${_target}
        PRIVATE
            ${CMAKE_CURRENT_SOURCE_DIR}/Source
            ${CMAKE_CURRENT_BINARY_DIR}/Source
    )

    STRING(LENGTH "${CMAKE_SOURCE_DIR}/" SOURCE_PATH_LENGTH)

    TARGET_COMPILE_DEFINITIONS(
        ${_target}
        PUBLIC
            # Disable VS "not secure" warnings
            $<$<CXX_COMPILER_ID:MSVC>:_CRT_SECURE_NO_WARNINGS>
        PRIVATE
            TOON_SOURCE_PATH_LENGTH=${SOURCE_PATH_LENGTH}
    )

    TARGET_COMPILE_OPTIONS(
        ${_target}
        PRIVATE
            # Configure VS to use C++20, since it ignores CXX_STANDARD
            $<$<CXX_COMPILER_ID:MSVC>: /std:c++latest>

            # Force windows to use UTF-8
            $<$<CXX_COMPILER_ID:MSVC>: /utf-8>

            # Disable unknown pragmas warning, C++ exceptions
            $<$<CXX_COMPILER_ID:GNU>:   -Wall -Wno-unknown-pragmas>
            $<$<CXX_COMPILER_ID:Clang>: -Wall -Wno-unknown-pragmas>
            $<$<CXX_COMPILER_ID:MSVC>:  /MP /wd4068 /EHsc->
    )

    TARGET_LINK_OPTIONS(
        ${_target}
        PUBLIC
            # Fix windows bug in looking for python38.lib
            $<$<CXX_COMPILER_ID:MSVC>:/NODEFAULTLIB:python38.lib>
    )

    SET_TARGET_PROPERTIES(
        ${_target} 
        PROPERTIES
            CXX_STANDARD 20
            CXX_STANDARD_REQUIRED ON
            CXX_EXTENSIONS OFF
    )

    FILE(RELATIVE_PATH folder ${CMAKE_SOURCE_DIR} "${CMAKE_CURRENT_SOURCE_DIR}/..")
    SET_TARGET_PROPERTIES(
        ${_target}
        PROPERTIES
            FOLDER "${folder}"
    )

    STRING(REPLACE " " "\\ " TOON_MODULE_PATH "${TOON_MODULE_PATH}")
    STRING(REPLACE " " "\\ " TOON_ASSET_PATH "${TOON_ASSET_PATH}")

    # TODO: Improve
    SET(_ext "")
    IF(WIN32)
        SET(_ext ".exe")
    ENDIF()

    FILE(RELATIVE_PATH _executable ${CMAKE_BINARY_DIR} ${CMAKE_CURRENT_BINARY_DIR}/${_target}${_ext})
    FILE(TO_NATIVE_PATH ${_executable} _executable)

    EXECUTE_PROCESS(
        COMMAND ${Python3_EXECUTABLE}
            ${CMAKE_SOURCE_DIR}/Scripts/generate-launch-targets.py
            ${CMAKE_CURRENT_SOURCE_DIR}/${_target}.toonproj
            ${CMAKE_BINARY_DIR}
            ${_executable}
            "${TOON_ASSET_PATH}"
            "${TOON_MODULE_PATH}"
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    )
ENDMACRO()
```

`CMake/DefineModule.cmake`:

```cmake

INCLUDE(SetSourceGroups)

MACRO(DEFINE_MODULE _target _prefix)
    FILE(GLOB_RECURSE
        _sources
        "Public/*.h"
        "Public/*.hpp"
        "Private/*.h"
        "Private/*.hpp"
        "Private/*.c"
        "Private/*.cpp"
    )

    FILE(GLOB_RECURSE
        _sources_in
        "Public/*.in"
        "Private/*.in"
    )

    ###
    ### Template Files
    ###

    FOREACH(file ${_sources_in})
        STRING(REPLACE 
            ${CMAKE_CURRENT_SOURCE_DIR}
            ${CMAKE_CURRENT_BINARY_DIR}
            file_out
            ${file}
        )

        string(REGEX MATCH "^(.*)\\.[^.]*$" file_out ${file_out})
        set(file_out ${CMAKE_MATCH_1})

        CONFIGURE_FILE(${file} ${file_out})
        LIST(APPEND _sources_out ${file_out})
    ENDFOREACH()

    ###
    ### Asset Processing
    ###

    FILE(GLOB_RECURSE
        _assets
        Assets/*
    )

    # Stop VS from trying to "build" our .obj model files
    SET_SOURCE_FILES_PROPERTIES(
        ${_assets}
        PROPERTIES
            HEADER_FILE_ONLY TRUE
    )

    ###
    ### Target Configuration
    ###

    ADD_LIBRARY(
        ${_target} SHARED
        ${_sources}
        ${_sources_in}
        ${_sources_out}
    )

    SET_SOURCE_GROUPS(${CMAKE_CURRENT_SOURCE_DIR} "${_sources}")
    SET_SOURCE_GROUPS(${CMAKE_CURRENT_SOURCE_DIR} "${_sources_in}")
    SET_SOURCE_GROUPS(${CMAKE_CURRENT_BINARY_DIR} "${_sources_out}")
    SET_SOURCE_GROUPS(${CMAKE_CURRENT_SOURCE_DIR} "${_assets}")

    IF(NOT _target STREQUAL "ToonEngine")
        TARGET_LINK_LIBRARIES(
            ${_target}
            PRIVATE
                ToonEngine
        )
    ENDIF()

    TARGET_INCLUDE_DIRECTORIES(
        ${_target}
        PUBLIC
            $<INSTALL_INTERFACE:include>
            $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/Public>
            $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/Public>
        PRIVATE
            ${CMAKE_CURRENT_SOURCE_DIR}/Private
            ${CMAKE_CURRENT_BINARY_DIR}/Private
    )

    STRING(LENGTH "${CMAKE_SOURCE_DIR}/" SOURCE_PATH_LENGTH)

    TARGET_COMPILE_DEFINITIONS(
        ${_target}
        PUBLIC
            # Disable VS "not secure" warnings
            $<$<CXX_COMPILER_ID:MSVC>:_CRT_SECURE_NO_WARNINGS>
        PRIVATE
            TOON_SOURCE_PATH_LENGTH=${SOURCE_PATH_LENGTH}
    )

    TARGET_COMPILE_OPTIONS(
        ${_target}
        PRIVATE
            # Configure VS to use C++20, since it ignores CXX_STANDARD
            $<$<CXX_COMPILER_ID:MSVC>: /std:c++latest>

            # Force windows to use UTF-8
            $<$<CXX_COMPILER_ID:MSVC>: /utf-8>

            # Disable unknown pragmas warning, C++ exceptions
            $<$<CXX_COMPILER_ID:GNU>:   -Wall -Wno-unknown-pragmas>
            $<$<CXX_COMPILER_ID:Clang>: -Wall -Wno-unknown-pragmas>
            $<$<CXX_COMPILER_ID:MSVC>:  /MP /wd4068 /EHsc->
    )

    TARGET_LINK_OPTIONS(
        ${_target}
        PUBLIC
            # Fix windows bug in looking for python38.lib
            $<$<CXX_COMPILER_ID:MSVC>:/NODEFAULTLIB:python38.lib>
    )

    SET_TARGET_PROPERTIES(
        ${_target}
        PROPERTIES
            CXX_STANDARD 20
            CXX_STANDARD_REQUIRED ON
            CXX_EXTENSIONS OFF
            DEFINE_SYMBOL "TOON_${_prefix}_EXPORT"
    )

    FILE(RELATIVE_PATH folder ${CMAKE_SOURCE_DIR} "${CMAKE_CURRENT_SOURCE_DIR}/..")
    SET_TARGET_PROPERTIES(
        ${_target}
        PROPERTIES
            FOLDER "${folder}"
    )

    LIST(APPEND TOON_MODULE_PATH ${CMAKE_CURRENT_BINARY_DIR})
    SET(TOON_MODULE_PATH ${TOON_MODULE_PATH} PARENT_SCOPE)
    

ENDMACRO()
```

`CMake/FindGSL.cmake`:

```cmake
# FindGSL.cmake
#
# Finds Microsoft's Guidlines Support Library
#
# This will define the following variables
#
#   GSL_FOUND
#   GSL_INCLUDE_DIR
#
# and the following imported targets
#
#   GSL::GSL
#
# The following variables can be set as arguments
#
#   GSL_ROOT_DIR
#

FIND_PATH(
    GSL_INCLUDE_DIR
    NAMES gsl/gsl
    PATHS 
        ${GSL_ROOT_DIR}
    PATH_SUFFIXES 
        include
)

INCLUDE(FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(
    GSL
    REQUIRED_VARS 
        GSL_INCLUDE_DIR
)

IF(GSL_FOUND)
    ADD_LIBRARY(GSL::GSL INTERFACE IMPORTED)
    SET_TARGET_PROPERTIES(
        GSL::GSL PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${GSL_INCLUDE_DIR}"
    )
ENDIF()
```

`CMake/FindVulkanSDK.cmake`:

```cmake
# FindVulkanSDK.cmake
#
# Finds the Vulkan SDK
#
# This will define the following variables
#
#   VulkanSDK_FOUND
#   VulkanSDK_glslc_PROGRAM
#   VulkanSDK_glslangValidator_PROGRAM
#
# The following variables can be set as arguments
#
#   VulkanSDK_ROOT_DIR
#   ENV{VULKAN_SDK}
#

FIND_PROGRAM(
    VulkanSDK_glslc_PROGRAM
    glslc
    PATHS
        ${VulkanSDK_ROOT_DIR}
        $ENV{VULKAN_SDK}
    PATH_SUFFIXES
        bin
)

FIND_PROGRAM(
    VulkanSDK_glslangValidator_PROGRAM
    glslangValidator
    PATHS
        ${VulkanSDK_ROOT_DIR}
        $ENV{VULKAN_SDK}
    PATH_SUFFIXES
        bin
)

INCLUDE(FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(
    VulkanSDK
    HANDLE_COMPONENTS
    REQUIRED_VARS 
        VulkanSDK_glslc_PROGRAM
        VulkanSDK_glslangValidator_PROGRAM
)
```

`CMake/Findpatch.cmake`:

```cmake
# Findpatch.cmake
#
# Finds the patch command
#
# If not found, and using windows, it will download patch.exe from GnuWin32
#
# This will define the following variables
#
#   patch_FOUND
#   patch_COMMAND
#

FIND_PROGRAM(
    patch_COMMAND
    NAMES patch
    PATHS
        ${CMAKE_BINARY_DIR}
    PATH_SUFFIXES
        bin
)

IF(NOT patch_COMMAND AND WIN32)
    FILE(DOWNLOAD
        "http://prdownloads.sourceforge.net/gnuwin32/patch-2.5.9-7-bin.zip"
        ${CMAKE_BINARY_DIR}/patch.zip
        EXPECTED_MD5 b9c8b31d62f4b2e4f1887bbb63e8a905
    )

    EXECUTE_PROCESS(
        COMMAND ${CMAKE_COMMAND} -E tar xf ${CMAKE_BINARY_DIR}/patch.zip
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    )

    FIND_PROGRAM(
        patch_COMMAND
        NAMES patch
        PATHS
            ${CMAKE_BINARY_DIR}
        PATH_SUFFIXES
            bin
    )
ENDIF()

INCLUDE(FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(
    patch
    REQUIRED_VARS 
        patch_COMMAND
)
```

`CMake/GetGitRevisionDescription.cmake`:

```cmake
# - Returns a version string from Git
#
# These functions force a re-configure on each git commit so that you can
# trust the values of the variables in your build system.
#
#  get_git_head_revision(<refspecvar> <hashvar> [<additional arguments to git describe> ...])
#
# Returns the refspec and sha hash of the current head revision
#
#  git_describe(<var> [<additional arguments to git describe> ...])
#
# Returns the results of git describe on the source tree, and adjusting
# the output so that it tests false if an error occurs.
#
#  git_get_exact_tag(<var> [<additional arguments to git describe> ...])
#
# Returns the results of git describe --exact-match on the source tree,
# and adjusting the output so that it tests false if there was no exact
# matching tag.
#
#  git_local_changes(<var>)
#
# Returns either "CLEAN" or "DIRTY" with respect to uncommitted changes.
# Uses the return code of "git diff-index --quiet HEAD --".
# Does not regard untracked files.
#
# Requires CMake 2.6 or newer (uses the 'function' command)
#
# Original Author:
# 2009-2010 Ryan Pavlik <rpavlik@iastate.edu> <abiryan@ryand.net>
# http://academic.cleardefinition.com
# Iowa State University HCI Graduate Program/VRAC
#
# Copyright Iowa State University 2009-2010.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt)

if(__get_git_revision_description)
    return()
endif()
set(__get_git_revision_description YES)

# We must run the following at "include" time, not at function call time,
# to find the path to this module rather than the path to a calling list file
get_filename_component(_gitdescmoddir ${CMAKE_CURRENT_LIST_FILE} PATH)

function(get_git_head_revision _refspecvar _hashvar)
    set(GIT_PARENT_DIR "${CMAKE_CURRENT_SOURCE_DIR}")
    set(GIT_DIR "${GIT_PARENT_DIR}/.git")
    while(NOT EXISTS "${GIT_DIR}")    # .git dir not found, search parent directories
        set(GIT_PREVIOUS_PARENT "${GIT_PARENT_DIR}")
        get_filename_component(GIT_PARENT_DIR ${GIT_PARENT_DIR} PATH)
        if(GIT_PARENT_DIR STREQUAL GIT_PREVIOUS_PARENT)
            # We have reached the root directory, we are not in git
            set(${_refspecvar} "GITDIR-NOTFOUND" PARENT_SCOPE)
            set(${_hashvar} "GITDIR-NOTFOUND" PARENT_SCOPE)
            return()
        endif()
        set(GIT_DIR "${GIT_PARENT_DIR}/.git")
    endwhile()
    # check if this is a submodule
    if(NOT IS_DIRECTORY ${GIT_DIR})
        file(READ ${GIT_DIR} submodule)
        string(REGEX REPLACE "gitdir: (.*)\n$" "\\1" GIT_DIR_RELATIVE ${submodule})
        get_filename_component(SUBMODULE_DIR ${GIT_DIR} PATH)
        get_filename_component(GIT_DIR ${SUBMODULE_DIR}/${GIT_DIR_RELATIVE} ABSOLUTE)
    endif()
    set(GIT_DATA "${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/git-data")
    if(NOT EXISTS "${GIT_DATA}")
        file(MAKE_DIRECTORY "${GIT_DATA}")
    endif()

    if(NOT EXISTS "${GIT_DIR}/HEAD")
        return()
    endif()
    set(HEAD_FILE "${GIT_DATA}/HEAD")
    configure_file("${GIT_DIR}/HEAD" "${HEAD_FILE}" COPYONLY)

    configure_file("${_gitdescmoddir}/GetGitRevisionDescription.cmake.in"
        "${GIT_DATA}/grabRef.cmake"
        @ONLY)
    include("${GIT_DATA}/grabRef.cmake")

    set(${_refspecvar} "${HEAD_REF}" PARENT_SCOPE)
    set(${_hashvar} "${HEAD_HASH}" PARENT_SCOPE)
endfunction()

function(git_describe _var)
    if(NOT GIT_FOUND)
        find_package(Git QUIET)
    endif()
    get_git_head_revision(refspec hash)
    if(NOT GIT_FOUND)
        set(${_var} "GIT-NOTFOUND" PARENT_SCOPE)
        return()
    endif()
    if(NOT hash)
        set(${_var} "HEAD-HASH-NOTFOUND" PARENT_SCOPE)
        return()
    endif()

    # TODO sanitize
    #if((${ARGN}" MATCHES "&&") OR
    #    (ARGN MATCHES "||") OR
    #    (ARGN MATCHES "\\;"))
    #    message("Please report the following error to the project!")
    #    message(FATAL_ERROR "Looks like someone's doing something nefarious with git_describe! Passed arguments ${ARGN}")
    #endif()

    #message(STATUS "Arguments to execute_process: ${ARGN}")

    execute_process(COMMAND
        "${GIT_EXECUTABLE}"
        describe
        ${hash}
        ${ARGN}
        WORKING_DIRECTORY
        "${CMAKE_CURRENT_SOURCE_DIR}"
        RESULT_VARIABLE
        res
        OUTPUT_VARIABLE
        out
        ERROR_QUIET
        OUTPUT_STRIP_TRAILING_WHITESPACE)
    if(NOT res EQUAL 0)
        set(out "${out}-${res}-NOTFOUND")
    endif()

    set(${_var} "${out}" PARENT_SCOPE)
endfunction()

function(git_get_exact_tag _var)
    git_describe(out --exact-match ${ARGN})
    set(${_var} "${out}" PARENT_SCOPE)
endfunction()

function(git_local_changes _var)
    if(NOT GIT_FOUND)
        find_package(Git QUIET)
    endif()
    get_git_head_revision(refspec hash)
    if(NOT GIT_FOUND)
        set(${_var} "GIT-NOTFOUND" PARENT_SCOPE)
        return()
    endif()
    if(NOT hash)
        set(${_var} "HEAD-HASH-NOTFOUND" PARENT_SCOPE)
        return()
    endif()

    execute_process(COMMAND
        "${GIT_EXECUTABLE}"
        diff-index --quiet HEAD --
        WORKING_DIRECTORY
        "${CMAKE_CURRENT_SOURCE_DIR}"
        RESULT_VARIABLE
        res
        OUTPUT_VARIABLE
        out
        ERROR_QUIET
        OUTPUT_STRIP_TRAILING_WHITESPACE)
    if(res EQUAL 0)
        set(${_var} "CLEAN" PARENT_SCOPE)
    else()
        set(${_var} "DIRTY" PARENT_SCOPE)
    endif()
endfunction()

```

`CMake/GetGitRevisionDescription.cmake.in`:

```in
#
# Internal file for GetGitRevisionDescription.cmake
#
# Requires CMake 2.6 or newer (uses the 'function' command)
#
# Original Author:
# 2009-2010 Ryan Pavlik <rpavlik@iastate.edu> <abiryan@ryand.net>
# http://academic.cleardefinition.com
# Iowa State University HCI Graduate Program/VRAC
#
# Copyright Iowa State University 2009-2010.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt)

set(HEAD_HASH)

file(READ "@HEAD_FILE@" HEAD_CONTENTS LIMIT 1024)

string(STRIP "${HEAD_CONTENTS}" HEAD_CONTENTS)
if(HEAD_CONTENTS MATCHES "ref")
    # named branch
    string(REPLACE "ref: " "" HEAD_REF "${HEAD_CONTENTS}")
    if(EXISTS "@GIT_DIR@/${HEAD_REF}")
        configure_file("@GIT_DIR@/${HEAD_REF}" "@GIT_DATA@/head-ref" COPYONLY)
    else()
        configure_file("@GIT_DIR@/packed-refs" "@GIT_DATA@/packed-refs" COPYONLY)
        file(READ "@GIT_DATA@/packed-refs" PACKED_REFS)
        if(${PACKED_REFS} MATCHES "([0-9a-z]*) ${HEAD_REF}")
            set(HEAD_HASH "${CMAKE_MATCH_1}")
        endif()
    endif()
else()
    # detached HEAD
    configure_file("@GIT_DIR@/HEAD" "@GIT_DATA@/head-ref" COPYONLY)
endif()

if(NOT HEAD_HASH)
    file(READ "@GIT_DATA@/head-ref" HEAD_HASH LIMIT 1024)
    string(STRIP "${HEAD_HASH}" HEAD_HASH)
endif()

```

`CMake/Policies.cmake`:

```cmake

# Allow PROJECT() to manage versions
IF(POLICY CMP0048)
    CMAKE_POLICY(SET CMP0048 NEW)
ENDIF()

# Allow TARGET_SOURCES() to store absolute paths for INTERFACE_SOURCES and 
# sources outside the CMAKE_CURRENT_SOURCE_DIR
IF(POLICY CMP0076)
    CMAKE_POLICY(SET CMP0076 NEW)
ENDIF()

# Allow MSVC_RUNTIME_LIBRARY
IF(POLICY CMP0091)
    CMAKE_POLICY(SET CMP0091 NEW)
ENDIF()

```

`CMake/SetSourceGroups.cmake`:

```cmake

MACRO(SET_SOURCE_GROUPS base_path files)
    FOREACH(file IN ITEMS ${files})
        FILE(RELATIVE_PATH file_path ${base_path} ${file})
        GET_FILENAME_COMPONENT(file_path ${file_path} DIRECTORY)
        FILE(TO_NATIVE_PATH ${file_path} file_path)
        SOURCE_GROUP(${file_path} FILES ${file})
    ENDFOREACH()
ENDMACRO()
```

`CMake/Toon.pc.in`:

```in
prefix=@CMAKE_INSTALL_PREFIX@
includedir=${prefix}/include
libdir=${prefix}/lib

Name: Toon
Description: Toon Game Engine
Version: @VERSION@

Requires:
Cflags: -I${includedir}
Libs: -L${libdir} -lToon

```

`CMake/ToonConfig.cmake.in`:

```in
@PACKAGE_INIT@

include("${CMAKE_CURRENT_LIST_DIR}/ToonTargets.cmake")
check_required_components("@PROJECT_NAME@")

```

`CMake/Version.cmake`:

```cmake

INCLUDE(GetGitRevisionDescription)

# Get Git revision
GET_GIT_HEAD_REVISION(GIT_REFSPEC PROJECT_VERSION_GIT_HASH)
STRING(SUBSTRING "${PROJECT_VERSION_GIT_HASH}" 0 8 PROJECT_VERSION_GIT_HASH)

# Parse version from git tags
GIT_DESCRIBE(VERSION --tags)
IF(VERSION)
    STRING(REGEX REPLACE 
        "^v([0-9]+)\\..*" "\\1" 
        PROJECT_VERSION_MAJOR 
        "${VERSION}"
    )
    STRING(REGEX REPLACE 
        "^v[0-9]+\\.([0-9]+).*" "\\1" 
        PROJECT_VERSION_MINOR 
        "${VERSION}"
    )
    STRING(REGEX REPLACE 
        "^v[0-9]+\\.[0-9]+\\.([0-9]+).*" "\\1" 
        PROJECT_VERSION_PATCH 
        "${VERSION}"
    )
ELSE()
    SET(PROJECT_VERSION_MAJOR 0)
    SET(PROJECT_VERSION_MINOR 0)
    SET(PROJECT_VERSION_PATCH 0)
    
    MESSAGE(WARNING "Failed to parse version from `git describe --tags`")
ENDIF()

SET(PROJECT_VERSION "${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}")
MESSAGE(STATUS "Toon Version ${PROJECT_VERSION}")

```

`CMakeLists.txt`:

```txt
CMAKE_MINIMUM_REQUIRED(VERSION 3.15 FATAL_ERROR)

# Allow for custom CMake modules
LIST(INSERT CMAKE_MODULE_PATH 0 "${CMAKE_SOURCE_DIR}/CMake")

INCLUDE(Policies)

###
### Project
###

PROJECT(Toon)
INCLUDE(Version)

###
### General Configuration
###

# Allow for custom organization of files in VisualStudio, Code::Blocks, etc
SET_PROPERTY(GLOBAL PROPERTY USE_FOLDERS ON)

# Don't use the install RPATH when building
SET(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
SET(CMAKE_INSTALL_RPATH ${CMAKE_INSTALL_PREFIX}/lib)

IF(MSVC)
    # Disable Default Exception Handling
    STRING(REPLACE "/EHsc" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
ENDIF()

###
### Options
###

OPTION(
    VERBOSE_LOGGING
    "Build Toon with Verbose Logging"
    OFF
)
IF(VERBOSE_LOGGING)
    ADD_DEFINITIONS(-DTOON_ENABLE_VERBOSE_LOGGING)
ENDIF()

OPTION(
    BUILD_TESTS
    "Build Tests"
    OFF
)
IF(BUILD_TESTS)
    ENABLE_TESTING()
ENDIF()

OPTION(
    BUILD_DEMOS
    "Build Demo Projects"
    ON
)

OPTION(
    BUILD_THIRDPARTY
    "Build Missing ThirdParty Dependencies"
    ON
)

###
### Modules and Dependencies
###

SET(
    MODULES 
    "All" 
    CACHE STRING
    "Semicolon-separated list of required modules, use 'All' to build all modules"
)

# Generate list of available modules
SET(AVAILABLE_MODULES
    "OpenGL"
    "SDL2"
    "STBI"
    "TinyOBJ"
    "Vulkan"
    "GLTF2"
)

IF(BUILD_DEMOS OR MODULES STREQUAL "All")
    SET(MODULES "${AVAILABLE_MODULES}")
ENDIF()

# Filter requested modules that are not available
SET(REQUIRED_MODULES "")
FOREACH(_module ${MODULES})
    IF(${_module} IN_LIST AVAILABLE_MODULES)
        LIST(APPEND REQUIRED_MODULES ${_module})
    ELSE()
        MESSAGE(WARNING "Module '${_module}' not supported on this platform")
    ENDIF()
ENDFOREACH()

# Generate list of required third party dependencies
SET(REQUIRED_DEPENDENCIES
    "glm"
    "GSL"
    "nlohmann_json"
    "Python3"
    "cflags"
)

IF("OpenGL" IN_LIST REQUIRED_MODULES)
    LIST(APPEND REQUIRED_MODULES "SDL2")
ENDIF()

IF("Vulkan" IN_LIST REQUIRED_MODULES)
    LIST(APPEND REQUIRED_DEPENDENCIES "VulkanSDK")
    LIST(APPEND REQUIRED_MODULES "SDL2")
ENDIF()

IF("SDL2" IN_LIST REQUIRED_MODULES)
    LIST(APPEND REQUIRED_DEPENDENCIES "SDL2")
ENDIF()

IF("Archive" IN_LIST REQUIRED_MODULES)
ENDIF()

IF(BUILD_TESTS)
    LIST(APPEND REQUIRED_DEPENDENCIES "GTest")
ENDIF()

LIST(REMOVE_DUPLICATES REQUIRED_MODULES)
LIST(REMOVE_DUPLICATES REQUIRED_DEPENDENCIES)

MESSAGE(STATUS "Available modules: ${AVAILABLE_MODULES}")
MESSAGE(STATUS "Building Modules: ${REQUIRED_MODULES}")
MESSAGE(STATUS "Required Dependencies: ${REQUIRED_DEPENDENCIES}")

###
### Third Party Dependencies
###

IF(BUILD_THIRDPARTY)
    SET(THIRDPARTY_SOURCE_DIR ${CMAKE_SOURCE_DIR}/ThirdParty)
    SET(THIRDPARTY_BINARY_DIR ${CMAKE_BINARY_DIR}/ThirdParty)

    FILE(MAKE_DIRECTORY ${THIRDPARTY_BINARY_DIR})

    # Set _ROOT variables for config-based packages
    SET(glm_ROOT            ${THIRDPARTY_BINARY_DIR}/glm/cmake)
    SET(nlohmann_json_ROOT  ${THIRDPARTY_BINARY_DIR}/nlohmann_json)
    SET(SDL2_ROOT           ${THIRDPARTY_BINARY_DIR}/SDL2)
    SET(cflags_ROOT         ${THIRDPARTY_BINARY_DIR}/cflags)

    # Set CMAKE_PREFIX_PATH for find-based packages
    LIST(APPEND CMAKE_PREFIX_PATH
        ${THIRDPARTY_BINARY_DIR}/GSL
        ${THIRDPARTY_BINARY_DIR}/GTest
    )

    # CMake refuses to quote the list when passing it on the command line, and `;` will
    # split the command in half, so we have to switch them to a different separator
    STRING(REPLACE ";" ":" _tmp "${REQUIRED_DEPENDENCIES}")
    
    EXECUTE_PROCESS(
        COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" 
            -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}
            -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}
            -DREQUIRED_DEPENDENCIES=${_tmp}
            ${THIRDPARTY_SOURCE_DIR}
            WORKING_DIRECTORY ${THIRDPARTY_BINARY_DIR}
        RESULT_VARIABLE _result
    )
    IF(_result)
        MESSAGE("${_result}")
        MESSAGE(FATAL_ERROR "Failed to configure thirdparty projects")
    ENDIF()

    SET(_THIRDPARTY_BUILD_COMMAND ${CMAKE_COMMAND} --build . )

    # If we're using `make`, we can build with extra cores
    IF(CMAKE_GENERATOR STREQUAL "Unix Makefiles")
        SET(_THIRDPARTY_BUILD_COMMAND ${CMAKE_MAKE_PROGRAM} -l )
    ENDIF()

    EXECUTE_PROCESS(
        COMMAND ${_THIRDPARTY_BUILD_COMMAND}
        WORKING_DIRECTORY ${THIRDPARTY_BINARY_DIR}
        RESULT_VARIABLE _result
    )

    IF(_result)
        MESSAGE("${_result}")
        MESSAGE(FATAL_ERROR "Failed to build thirdparty projects")
    ENDIF()
ENDIF()

IF("glm" IN_LIST REQUIRED_DEPENDENCIES)
    FIND_PACKAGE(glm CONFIG REQUIRED)
    IF(NOT TARGET glm::glm)
        MESSAGE(SEND_ERROR "Incompatible version of glm found.")
    ENDIF()
ENDIF()

IF("GSL" IN_LIST REQUIRED_DEPENDENCIES)
    FIND_PACKAGE(GSL REQUIRED)
ENDIF()

IF("nlohmann_json" IN_LIST REQUIRED_DEPENDENCIES)
    FIND_PACKAGE(nlohmann_json CONFIG REQUIRED)
ENDIF()

IF("SDL2" IN_LIST REQUIRED_DEPENDENCIES)
    FIND_PACKAGE(SDL2 2.0.6 CONFIG REQUIRED)
ENDIF()

IF("GTest" IN_LIST REQUIRED_DEPENDENCIES)
    SET(GTEST_MSVC_SEARCH "MD")
    FIND_PACKAGE(GTest REQUIRED)
ENDIF()

IF("VulkanSDK" IN_LIST REQUIRED_DEPENDENCIES)
    FIND_PACKAGE(VulkanSDK REQUIRED)
ENDIF()

IF("Python3" IN_LIST REQUIRED_DEPENDENCIES)
    FIND_PACKAGE(Python3 3.8 COMPONENTS Interpreter)
ENDIF()

IF("cflags" IN_LIST REQUIRED_DEPENDENCIES)
    FIND_PACKAGE(cflags CONFIG REQUIRED)
ENDIF()

FIND_PROGRAM(gdb_COMMAND gdb)
FIND_PROGRAM(valgrind_COMMAND valgrind)

IF(TARGET SDL2::SDL2)
    GET_TARGET_PROPERTY(_location SDL2::SDL2 IMPORTED_LOCATION)
    GET_FILENAME_COMPONENT(SDL2_RUNTIME_DIR ${_location} DIRECTORY)

    IF (SDL2_RUNTIME_DIR STREQUAL "")
        STRING(TOUPPER ${CMAKE_BUILD_TYPE} _type)
        GET_TARGET_PROPERTY(_location SDL2::SDL2 IMPORTED_LOCATION_${_type})
        GET_FILENAME_COMPONENT(SDL2_RUNTIME_DIR ${_location} DIRECTORY)
    ENDIF()
ENDIF()

SET(TOON_MODULE_PATH 
    ${SDL2_RUNTIME_DIR}
)

###
### Engine
###

ADD_SUBDIRECTORY(Engine)

###
### Modules
###

ADD_SUBDIRECTORY(Modules)

###
### Demos
###

IF(BUILD_DEMOS)
    ADD_SUBDIRECTORY(Demos)
ENDIF()

###
### Docker
###

FIND_PROGRAM(docker_COMMAND docker)

IF(docker_COMMAND)
    ADD_CUSTOM_TARGET(
        build-docker-images
        COMMAND ${docker_COMMAND} build --target builder-minimal -t whobrokethebuild/toon:builder-minimal .
        COMMAND ${docker_COMMAND} build --target builder -t whobrokethebuild/toon:builder .
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    )

    ADD_CUSTOM_TARGET(
        push-docker-images
        COMMAND ${docker_COMMAND} push whobrokethebuild/toon:builder-minimal
        COMMAND ${docker_COMMAND} push whobrokethebuild/toon:builder
        DEPENDS build-docker-images
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    )
ENDIF()

###
### CI
###

FIND_PROGRAM(circleci_COMMAND circleci)

IF(circleci_COMMAND)
    ADD_CUSTOM_TARGET(
        test-circleci
        COMMAND ${circleci_COMMAND} local execute --job "Clang, Release, System"
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    )
ENDIF()
```

`Demos/CMakeLists.txt`:

```txt
INCLUDE(DefineDemo)

#Add Demos Here
ADD_SUBDIRECTORY(HelloWorld)
ADD_SUBDIRECTORY(Sandbox)
ADD_SUBDIRECTORY(Lighting)

SET_PROPERTY(
    DIRECTORY ${CMAKE_SOURCE_DIR}
    PROPERTY
        VS_STARTUP_PROJECT "HelloWorld"
)
```

`Demos/HelloWorld/CMakeLists.txt`:

```txt

SET(_target HelloWorld)

DEFINE_DEMO(${_target})

ADD_DEPENDENCIES(
    ${_target}
    ToonSDL2
    #ToonVulkan
    ToonOpenGL
    ToonSTBI
    ToonTinyOBJ
)
```

`Demos/HelloWorld/HelloWorld.toonproj`:

```toonproj
{
    "name": "HelloWorld",
    "version": "1.0.0",
    "modules": [
        "ToonSTBI",
        "ToonTinyOBJ",
        "ToonGLTF2"
    ],
    "configurations": {
        "Vulkan": {
            "modules": [
                "ToonVulkan"
            ]
        },
        "OpenGL": {
            "modules": [
                "ToonOpenGL"
            ]
        }
    },
    "defaultConfiguration": "Vulkan"
}
```

`Demos/HelloWorld/Source/Main.cpp`:

```cpp
#include <Toon/Toon.hpp>
#include <Toon/Module.hpp>

#include <Toon/Camera.hpp>
#include <Toon/Entity.hpp>
#include <Toon/RenderContext.hpp>
#include <Toon/UpdateContext.hpp>
#include <Toon/Component.hpp>
#include <Toon/MeshComponent.hpp>
#include <Toon/Light.hpp>
#include <Toon/Log.hpp>
#include <Toon/Mesh.hpp>
#include <Toon/Scene.hpp>
#include <Toon/Shader.hpp>
#include <Toon/Texture.hpp>
#include <Toon/Util.hpp>
#include <Toon/GraphicsDriver.hpp>
#include <Toon/TextureImporter.hpp>
#include <Toon/MeshImporter.hpp>
#include <Toon/Version.hpp>

#include <cstdio>
#include <memory>
#include <thread>

#include <chrono>

using namespace std::chrono;
using namespace Toon;

void run()
{
    auto gfx = GetGraphicsDriver();
    if (!gfx) {
        return;
    }

    RenderContext * renderCtx = gfx->GetRenderContext();
    ShaderTransform * shaderTransform = renderCtx->GetShaderTransform();

    Camera camera;
    camera.SetAspect(glm::vec2(640.0f, 480.0f));
    camera.SetFOVX(45.0f);
    camera.SetMode(CameraMode::Perspective);
    camera.SetPosition({ 3, 3, 3 });
    camera.SetLookAt({ 0, 0, 0 });

    auto shader = gfx->CreateShader();
    if (!shader->LoadFromFiles({
        "Toon/DebugNormalColor.vert",
        "Toon/DebugNormalColor.frag",
    })) {
        return;
    }

    auto pipeline = gfx->CreatePipeline(shader);

    Scene scene;
    SetCurrentScene(&scene);

    auto mesh = LoadMeshFromFile("Primitives/Obj/pCube.obj");
    if (!mesh) {
        return;
    }
    
    mesh->SetPipeline(pipeline);

    auto entity = std::unique_ptr<Entity>(new Entity());
    Entity * tmpEntity = entity.get();

    auto meshComponent = std::unique_ptr<MeshComponent>(new MeshComponent());
    meshComponent->SetMesh(mesh);
    entity->AddComponent(std::move(meshComponent));

    scene.AddChild(std::move(entity));

    shaderTransform->View = camera.GetView();
    shaderTransform->Projection = camera.GetProjection();

    RenderContext* rc = new RenderContext();

    gfx->SetWindowTitle("HelloWorld ~ Toon");
    gfx->SetWindowSize({ 1024, 768 });
    while (IsRunning()) {
        gfx->Render();

        gfx->ProcessEvents();
        
    }

}


int main(int argc, char ** argv)
{
    if (!Initialize(argc, argv)) {
        return 1;
    }

    run();

    Terminate();

    return 0;
}


```

`Demos/Lighting/Assets/Shaders/BlinnPhongLighting.inc.glsl`:

```glsl
#ifndef TOON_BLINN_PHONG_LIGHTING_INC_GLSL
#define TOON_BLINN_PHONG_LIGHTING_INC_GLSL

vec4 BlinnPhongLighting(
    vec3 LightColor,
    vec3 LightPosition,
    vec3 CameraPosition,
    vec3 Position,
    vec3 Normal
)
{
    // Ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * LightColor;
      
    // Diffuse 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(LightPosition - Position);

    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * LightColor;

    // Specular
    vec3 specular = vec3(0.0, 0.0, 0.0);

    // We dot the normal and lightDir to make sure it won't 'leak' through the model.
    if (dot(norm, lightDir) >= 0.0f) {
	    // specular
        float specularStrength = 0.5;
        vec3 viewDir = normalize(CameraPosition - Position);
        vec3 halfwayDir = normalize(lightDir + viewDir);
        float spec = pow(max(dot(norm, halfwayDir), 0.0), 32.0);
        specular = specularStrength * spec * LightColor;
    }

    return vec4(ambient.rgb + diffuse.rgb + specular.rgb, 1.0);
}

#endif // TOON_BLINN_PHONG_LIGHTING_INC_GLSL
```

`Demos/Lighting/Assets/Shaders/Lighting.frag.glsl`:

```glsl
#version 450 core

#include <Toon/Globals.inc.glsl>
#include <Toon/Material.inc.glsl>

#include "PhongLighting.inc.glsl"
#include "BlinnPhongLighting.inc.glsl"

layout (location = 0) in vec4 v_Position;
layout (location = 1) in vec4 v_Normal;
layout (location = 5) in vec2 v_TexCoords;

// Targets
layout (location = 0) out vec4 o_Color;

void main()
{
    vec4 baseColorTexture = texture(u_BaseColorMap, v_TexCoords) * u_BaseColorFactor;

    vec4 outputColor = vec4(0.0, 0.0, 0.0, 1.0);

    for (int i = 0; i < LightCount; i++)
    {
        // outputColor += PhongLighting(
        //     Lights[i].Color,
        //     Lights[i].Position,
        //     CameraPosition,
        //     v_Position,
        //     v_Normal
        // );

        outputColor += BlinnPhongLighting(
            Lights[i].Color,
            Lights[i].Position,
            CameraPosition,
            v_Position.xyz,
            v_Normal.xyz
        );
    }

    outputColor /= LightCount;

    // Show our results
    o_Color = vec4(outputColor.rgb * baseColorTexture.rgb, 1.0);
}

```

`Demos/Lighting/Assets/Shaders/Lighting.vert.glsl`:

```glsl
#version 450 core

#include <Toon/Transform.inc.glsl>
#include <Toon/VertexAttributes.inc.glsl>

layout (location = 0) out vec3 v_Position;
layout (location = 1) out vec3 v_Normal;
layout (location = 5) out vec2 v_TexCoords;

void main()
{
    // Move the normal (perpendicular) to tangent space
    v_Normal = vec3(transpose(inverse(u_Model)) * a_Normal);

    vec4 pos = u_Model * a_Position;
    v_Position = pos.xyz / pos.w;

    //v_TexCoords = vec2(u_TexCoord1.x, 1.0 - u_TexCoord1.y);
    v_TexCoords = a_TexCoord1;

    gl_Position = u_MVP * a_Position;
}
```

`Demos/Lighting/Assets/Shaders/PhongLighting.inc.glsl`:

```glsl
#ifndef TOON_PHONG_LIGHTING_INC_GLSL
#define TOON_PHONG_LIGHTING_INC_GLSL

vec4 PhongLighting(
    vec3 LightColor,
    vec3 LightPosition,
    vec3 CameraPosition,
    vec3 Position,
    vec3 Normal
)
{
    // Ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * LightColor;
      
    // Diffuse 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(LightPosition - Position);

    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * LightColor;

    // Specular
    vec3 specular = vec3(0.0, 0.0, 0.0);

    // We dot the normal and lightDir to make sure it won't 'leak' through the model.
    if (dot(norm, lightDir) >= 0.0f) {
	    // specular
        float specularStrength = 0.5;
        vec3 viewDir = normalize(CameraPosition - Position);
        vec3 reflectDir = reflect(-lightDir, norm);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
        specular = specularStrength * spec * LightColor;
    }

    return vec4(ambient.rgb + diffuse.rgb + specular.rgb, 1.0);
}

#endif // TOON_PHONG_LIGHTING_INC_GLSL
```

`Demos/Lighting/CMakeLists.txt`:

```txt

SET(_target Lighting)

DEFINE_DEMO(${_target})

ADD_DEPENDENCIES(
    ${_target}
    ToonSDL2
    ToonVulkan
    ToonOpenGL
    ToonSTBI
    ToonTinyOBJ
)

TARGET_LINK_LIBRARIES(
    ${_target}
    PUBLIC
        ToonGLTF2
)
```

`Demos/Lighting/Lighting.toonproj`:

```toonproj
{
    "name": "Lighting",
    "version": "1.0.0",
    "modules": [
        "ToonSTBI",
        "ToonTinyOBJ",
        "ToonGLTF2"
    ],
    "configurations": {
        "Vulkan": {
            "modules": [
                "ToonVulkan"
            ]
        },
        "OpenGL": {
            "modules": [
                "ToonOpenGL"
            ]
        }
    },
    "defaultConfiguration": "Vulkan"
}
```

`Demos/Lighting/Source/Main.cpp`:

```cpp
#include <Toon/Toon.hpp>

#include <Toon/Camera.hpp>
#include <Toon/Entity.hpp>
#include <Toon/GraphicsDriver.hpp>
#include <Toon/Light.hpp>
#include <Toon/Log.hpp>
#include <Toon/Mesh.hpp>
#include <Toon/MeshComponent.hpp>
#include <Toon/Module.hpp>
#include <Toon/RenderContext.hpp>
#include <Toon/Scene.hpp>
#include <Toon/Texture.hpp>
#include <Toon/UpdateContext.hpp>
#include <Toon/Version.hpp>

#include <cstdio>
#include <memory>
#include <thread>

using namespace Toon;

void Run()
{
    // Grab the current graphicsdriver
    auto gfx = GetGraphicsDriver();
    if (!gfx) {
        return;
    }

    // Set our options
    gfx->SetWindowSize({ 1024, 768 });

    // Create our scene
    Scene scene;
    SetCurrentScene(&scene);

    // Create camera
    Camera camera;
    camera.SetAspect(glm::vec2(640.0f, 480.0f));
    camera.SetFOVX(45.0f);
    camera.SetMode(CameraMode::Perspective);
    camera.SetPosition({ 1.5, 1.5, 1.5 });
    camera.SetLookAt({ 0, 0, 0 });

    // Create our shader and load them
    auto shader = gfx->CreateShader();
    if (!shader->LoadFromFiles({
        "Lighting.vert",
        "Lighting.frag",
    })) {
        return;
    }

    // Create our pipeline (we need a pipeline for each shader)
    auto pipeline = gfx->CreatePipeline(shader);

    // Create and load a mesh
    auto mesh = LoadMeshFromFile("DamagedHelmet.glb");
    if (!mesh) {
        return;
    }

    // Set the pipeline for the mesh, we can set any pipeline for any mesh as needed.
    mesh->SetPipeline(pipeline);

    // Create an entity
    auto entity = std::unique_ptr<Entity>(new Entity());
    Entity * tmpEntity = entity.get();

    // Add components to entity
    auto meshComponent = std::unique_ptr<MeshComponent>(new MeshComponent());
    meshComponent->SetMesh(mesh);
    entity->AddComponent(std::move(meshComponent));

    // Add the new entity to the scene
    auto e = scene.AddChild(std::move(entity));

    // Create a render context and transform data
    RenderContext * renderCtx = gfx->GetRenderContext();
    ShaderTransform * shaderTransform = renderCtx->GetShaderTransform();

    // Set our view and proj matrix (in shaders).
    shaderTransform->View = camera.GetView();
    shaderTransform->Projection = camera.GetProjection();

    // Set camera position (in shaders).
    auto globals = renderCtx->GetShaderGlobals();
    globals->CameraPosition = glm::vec4(camera.GetPosition(), 1.0f);

    // Light Source
    Light* light = new Light();
    light->SetPosition(glm::vec3(10.0f, 10.0f, 10.0f));
    light->SetColor(glm::vec3(1.0f, 1.0f, 0.0f));
    light->SetOrientation(glm::quat(0.0f, 0.0f, 0.0f, 1.0f));
    scene.AddChild(std::unique_ptr<Entity>(light));

    // Add our light(s) to our shaders.
    globals->Lights[globals->LightCount].Color = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
    globals->Lights[globals->LightCount].Direction = glm::vec4(GetWorldForward() * light->GetOrientation(), 1.0f);
    globals->Lights[globals->LightCount].Position = glm::vec4(light->GetPosition(), 1.0f);
    globals->LightCount++;

    // Game loop
    Toon::Run([&]() {
        gfx->Render();

        gfx->ProcessEvents();

        //camera.HandleMovement(gfx->GetUpdateContext()->GetFrameSpeedRatio());

        // Set our view and proj matrix (in shaders).
        shaderTransform->View = camera.GetView();
        shaderTransform->Projection = camera.GetProjection();

        auto uctx = gfx->GetUpdateContext();
        e->SetOrientation(e->GetOrientation() * glm::angleAxis(glm::radians(0.25f * uctx->GetFrameSpeedRatio()), GetWorldUp()));

    });
}


int main(int argc, char ** argv)
{
    // Lets log things
    AddLogFile("lastrun.log");

    // Initialize our demo
    if (!Initialize(argc, argv)) {
        return 1;
    }

    // Run
    Run();

    // Terminate
    Terminate();

    // Lets not log things anymore
    CloseAllLogFiles();

    return 0;
}


```

`Demos/Sandbox/CMakeLists.txt`:

```txt

SET(_target Sandbox)

DEFINE_DEMO(${_target})

ADD_DEPENDENCIES(
    ${_target}
    ToonSDL2
    ToonVulkan
    ToonOpenGL
    ToonSTBI
    ToonTinyOBJ
)

TARGET_LINK_LIBRARIES(
    ${_target}
    PUBLIC
        ToonGLTF2
)
```

`Demos/Sandbox/Sandbox.toonproj`:

```toonproj
{
    "name": "Sandbox",
    "version": "1.0.0",
    "modules": [
        "ToonSTBI",
        "ToonTinyOBJ",
        "ToonGLTF2"
    ],
    "configurations": {
        "Vulkan": {
            "modules": [
                "ToonVulkan"
            ]
        },
        "OpenGL": {
            "modules": [
                "ToonOpenGL"
            ]
        }
    },
    "defaultConfiguration": "Vulkan"
}
```

`Demos/Sandbox/Source/Main.cpp`:

```cpp
#include <Toon/Toon.hpp>

#include <Toon/Camera.hpp>
#include <Toon/Entity.hpp>
#include <Toon/GraphicsDriver.hpp>
#include <Toon/Light.hpp>
#include <Toon/Log.hpp>
#include <Toon/Mesh.hpp>
#include <Toon/MeshComponent.hpp>
#include <Toon/Module.hpp>
#include <Toon/RenderContext.hpp>
#include <Toon/Scene.hpp>
#include <Toon/Texture.hpp>
#include <Toon/UpdateContext.hpp>
#include <Toon/Version.hpp>

#include <cstdio>
#include <memory>
#include <thread>

using namespace Toon;

void Run()
{
    // Grab the current graphicsdriver
    auto gfx = GetGraphicsDriver();
    if (!gfx) {
        return;
    }

    // Set our options   
    gfx->SetWindowSize({ 1024, 768 });

    // Create our scene
    Scene scene; 
    SetCurrentScene(&scene);

    // Create camera
    Camera camera;
    camera.SetAspect(glm::vec2(640.0f, 480.0f));
    camera.SetFOVX(45.0f);
    camera.SetMode(CameraMode::Perspective);
    camera.SetPosition({ 1.5, 1.5, 1.5 });
    camera.SetLookAt({ 0, 0, 0 });

    // Create and load a mesh
    auto mesh = LoadMeshFromFile("DamagedHelmet/DamagedHelmet.gltf");
    if (!mesh) {
        return;
    }

    // Create an entity
    auto entity = std::unique_ptr<Entity>(new Entity());
    auto e = entity.get();

    // Add components to entity
    auto meshComponent = std::unique_ptr<MeshComponent>(new MeshComponent());
    meshComponent->SetMesh(LoadMeshFromFile("DamagedHelmet/DamagedHelmet.gltf"));
    //entity->AddComponent(new MeshComponent(LoadMeshFromFile("DamagedHelmet/DamagedHelmet.gltf")));
    entity->AddComponent(std::move(meshComponent));

    // Add the new entity to the scene
    scene.AddChild(std::move(entity));

    // auto eBush = scene.CreateEntity();
    // eBush->CreateComponent<MeshComponent>(Mesh::LoadFromFile("PATHTOFILE"));
    // eBush->CreateComponent<MeshComponent>(LoadMeshFromFile("Path"));
    // eBush->CreateComponent<RigidBodyComponent>();
    // eBush->AddComponent(new RigidBodyComponent());

    // Create a render context and transform data
    RenderContext * renderCtx = gfx->GetRenderContext();
    ShaderTransform * shaderTransform = renderCtx->GetShaderTransform();

    // Set our view and proj matrix (in shaders).
    shaderTransform->View = camera.GetView();
    shaderTransform->Projection = camera.GetProjection();

    // Set camera position (in shaders).
    auto globals = renderCtx->GetShaderGlobals();
    globals->CameraPosition = camera.GetPosition();

    // Light Source
    Light* light = new Light();
    light->SetPosition({2.0, 3.0, 2.0});
    light->SetColor({1.0f, 1.0f, 1.0f});
    scene.AddChild(std::unique_ptr<Entity>(light));

    // Add our light(s) to our shaders.
    globals->Lights[globals->LightCount].Color = light->GetColor();
    globals->Lights[globals->LightCount].Direction = glm::vec3(GetWorldForward() * light->GetOrientation());
    globals->Lights[globals->LightCount].Position = light->GetPosition();
    globals->LightCount++;

    // Game loop
    Toon::Run([&]() {
        gfx->Render();

        gfx->ProcessEvents();

        //camera.HandleMovement(gfx->GetUpdateContext()->GetFrameSpeedRatio());


        // Set our view and proj matrix (in shaders).
        shaderTransform->View = camera.GetView();
        shaderTransform->Projection = camera.GetProjection();

        auto uctx = gfx->GetUpdateContext();
        e->SetOrientation(e->GetOrientation() * glm::angleAxis(glm::radians(0.25f * uctx->GetFrameSpeedRatio()), GetWorldUp()));

    });
}


int main(int argc, char ** argv)
{
    // Lets log things
    AddLogFile("lastrun.log");

    // Initialize our demo
    if (!Initialize(argc, argv)) {
        return 1;
    }

    // Run
    Run();

    // Terminate
    Terminate();

    // Lets not log things anymore
    CloseAllLogFiles();

    return 0;
}


```

`Dockerfile`:

```
FROM ubuntu:20.04 AS builder-minimal

ENV DEBIAN_FRONTEND=noninteractive

RUN apt update \
    && apt install -y \
        wget \
        software-properties-common \
    && add-apt-repository -y ppa:ubuntu-toolchain-r/test \
    && bash -c "$(wget -O - https://apt.llvm.org/llvm.sh)" \
    && apt purge -y \
        software-properties-common \
    && apt autoremove -y --purge \
    && rm -rf /var/lib/apt/lists/*

RUN apt update \
    && apt install -y \
        g++-8 \
        clang \
        git git-lfs \
        make \
        xorg-dev \
        libglu1-mesa-dev \
    && rm -rf /var/lib/apt/lists/*

ARG CMAKE_VERSION=3.18.4

RUN wget -qO cmake-install.sh https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/cmake-${CMAKE_VERSION}-Linux-x86_64.sh \
    && bash cmake-install.sh --prefix=/usr/ --skip-license --exclude-subdir \
    && rm -f cmake-install.sh

ARG VULKAN_SDK_VERSION=1.2.154.0
ARG VULKAN_SDK_MD5SUM=91c548e851d4c679c072c109aae8a775

RUN wget -qO vulkan-sdk.tar.gz https://sdk.lunarg.com/sdk/download/${VULKAN_SDK_VERSION}/linux/vulkansdk-linux-x86_64-${VULKAN_SDK_VERSION}.tar.gz \
    && echo "${VULKAN_SDK_MD5SUM} vulkan-sdk.tar.gz" > vulkan-sdk.md5 \
    && md5sum --status -c < vulkan-sdk.md5 \
    && mkdir -p /opt/vulkan/ \
    && tar -xf vulkan-sdk.tar.gz -C /opt/vulkan/ \
    && rm -rf /tmp/vulkan-sdk.tar.gz /tmp/vulkan-sdk.md5

ENV VULKAN_SDK=/opt/vulkan/${VULKAN_SDK_VERSION}/x86_64



FROM builder-minimal AS builder

RUN apt update \
    && apt install -y \
        libgtest-dev \
        coreutils \
        unzip \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /tmp

ARG GLM_VERSION=0.9.9.8
ARG GLM_MD5SUM=69895110052f0d711c9c54fbf385f6f5

RUN wget -qO glm.zip https://github.com/g-truc/glm/releases/download/${GLM_VERSION}/glm-${GLM_VERSION}.zip \
    && echo "${GLM_MD5SUM} glm.zip" > glm.md5 \
    && md5sum --status -c < glm.md5 \
    && unzip glm.zip \
    && cp -R glm/glm/ /usr/include/ \
    && cp -R glm/cmake/ /usr/share/ \
    && rm -rf /tmp/glm.zip /tmp/glm.md5 /tmp/glm/

ARG GSL_VERSION=3.1.0
ARG GSL_MD5SUM=b6910c54113f921b03dc06642cf7f11c

RUN wget -qO gsl.tar.gz https://github.com/microsoft/GSL/archive/v${GSL_VERSION}.tar.gz \
    && echo "${GSL_MD5SUM} gsl.tar.gz" > gsl.md5 \
    && md5sum --status -c < gsl.md5 \
    && tar -xf gsl.tar.gz \
    && mkdir -p GSL-${GSL_VERSION}/build \
    && cd GSL-${GSL_VERSION}/build \
    && cmake -DGSL_TEST=OFF .. \
    && make -l install \
    && rm -rf /tmp/gsl.tar.gz /tmp/gsl.md5 /tmp/GSL-${GSL_VERSION}/

ARG JSON_VERSION=3.9.1
ARG JSON_MD5SUM=e386222fb57dd2fcb8a7879fc016d037

RUN wget -qO json.tar.gz https://github.com/nlohmann/json/archive/v${JSON_VERSION}.tar.gz \
    && echo "${JSON_MD5SUM} json.tar.gz" > json.md5 \
    && md5sum --status -c < json.md5 \
    && tar -xf json.tar.gz \
    && mkdir -p json-${JSON_VERSION}/build \
    && cd json-${JSON_VERSION}/build \
    && cmake -DJSON_BuildTests=OFF .. \
    && make -l install \
    && rm -rf /tmp/json.tar.gz /tmp/json.md5 /tmp/json-${JSON_VERSION}

ARG SDL2_VERSION=2.0.12
ARG SDL2_MD5SUM=783b6f2df8ff02b19bb5ce492b99c8ff

RUN wget -qO sdl2.tar.gz https://www.libsdl.org/release/SDL2-${SDL2_VERSION}.tar.gz \
    && echo "${SDL2_MD5SUM} sdl2.tar.gz" > sdl2.md5 \
    && md5sum --status -c < sdl2.md5 \
    && tar -xf sdl2.tar.gz \
    && mkdir -p SDL2-${SDL2_VERSION}/build \
    && cd SDL2-${SDL2_VERSION}/build \
    && cmake -DBUILD_SHARED_LIBS=ON .. \
    && make -l install \
    && rm -rf /tmp/sdl2.tar.gz /tmp/sdl2.md5 /tmp/SDL2-${SDL2_VERSION}

```

`Engine/Assets/Shaders/Toon/ColorSpace.inc.glsl`:

```glsl
#ifndef TOON_COLOR_SPACE_INC_GLSL
#define TOON_COLOR_SPACE_INC_GLSL

// https://en.wikipedia.org/wiki/SRGB

vec4 LinearToSRGB(vec4 color)
{
    return vec4(
        (color.r < 0.0031308 ? 12.92 * color.r : 1.055 * pow(color.r, 1.0 / 2.4) - 0.055),
        (color.g < 0.0031308 ? 12.92 * color.g : 1.055 * pow(color.g, 1.0 / 2.4) - 0.055),
        (color.b < 0.0031308 ? 12.92 * color.b : 1.055 * pow(color.b, 1.0 / 2.4) - 0.055),
        color.a
    );
}

vec4 SRGBToLinear(vec4 color)
{
    return vec4(
	    (color.r < 0.04045 ? (1.0 / 12.92) * color.r : pow((color.r + 0.055) * (1.0 / 1.055), 2.4)),
	    (color.g < 0.04045 ? (1.0 / 12.92) * color.g : pow((color.g + 0.055) * (1.0 / 1.055), 2.4)),
	    (color.b < 0.04045 ? (1.0 / 12.92) * color.b : pow((color.b + 0.055) * (1.0 / 1.055), 2.4)),
        color.a
    );
}

#endif // TOON_COLOR_SPACE_INC_GLSL
```

`Engine/Assets/Shaders/Toon/Debug/NormalColor.frag.glsl`:

```glsl
#version 450 core

#include <Toon/Globals.inc.glsl>

layout(location = 0) in vec4 v_Normal;

layout(location = 0) out vec4 o_Color;

void main()
{
    o_Color = vec4(abs(v_Normal.xyz), 1.0);
}

```

`Engine/Assets/Shaders/Toon/Debug/NormalColor.vert.glsl`:

```glsl
#version 450 core

#include <Toon/Globals.inc.glsl>
#include <Toon/Transform.inc.glsl>
#include <Toon/VertexAttributes.inc.glsl>

layout (location = 0) out vec4 v_Normal;

void main()
{
    gl_Position = u_MVP * a_Position;
    v_Normal = a_Normal;
}
```

`Engine/Assets/Shaders/Toon/Default.frag.glsl`:

```glsl
#version 450 core

#include <Toon/ColorSpace.inc.glsl>
#include <Toon/Globals.inc.glsl>
#include <Toon/Material.inc.glsl>
#include <Toon/Math.inc.glsl>

layout(location = 0) in vec3 v_Position;
layout(location = 1) in vec2 v_TexCoord;
layout(location = 2) in mat3 v_TBN;

layout(location = 0) out vec4 o_Color;

const vec3 c_LightRadiance = vec3(1.0);
const vec3 c_EyePosition = vec3(2.0, 3.0, 2.0);
const vec3 c_LightDirection = -c_EyePosition;

vec3 fresnelSchlick(vec3 F0, float cosTheta)
{
    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a = roughness * roughness;
    float a2 = a*a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;

    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = M_PI * denom * denom;

    return a2 / denom;
}

float GeometrySchlickGGX(float cosTheta, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float denom = cosTheta * (1.0 - k) + k;

    return cosTheta / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

void main()
{
    vec3 N = (2.0 * texture(u_NormalMap, v_TexCoord).rgb - 1.0) * u_NormalScale;
    N = normalize(v_TBN * N);

    vec4 albedo = SRGBToLinear(texture(u_BaseColorMap, v_TexCoord)) * u_BaseColorFactor;
    vec3 metallicRoughness = texture(u_MetallicRoughnessMap, v_TexCoord).rgb;
    float roughness = metallicRoughness.g * u_RoughnessFactor;
    float metallic = metallicRoughness.b * u_MetallicFactor;

    roughness = clamp(roughness, 0.04, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);

    vec3 F0 = mix(vec3(0.04), albedo.rgb, metallic);

    vec3 V = (c_EyePosition - v_Position);

    // Calc relevant per-light variables
    vec3 DirectLighting = vec3(0.0);
    for (int i = 0; i < LightCount; ++i)
    {
        // Calculate per-light radiance
        vec3 L = normalize(Lights[i].Position - v_Position);
        vec3 H = normalize(V + L);
        float distance = length(Lights[i].Position - v_Position);
        float attenuation = 1.0 / (distance * distance);
        vec3 radiance = vec3(1.0);//Lights[i].Color.rgb * attenuation;

        // vec3 L = -c_LightDirection;
        // vec3 H = normalize(V + L);

        // Cook-torrance brdf
        vec3 F  = fresnelSchlick(F0, max(dot(H, V), 0.0));
        float NDF = DistributionGGX(N, H, roughness);
        float G = GeometrySmith(N, V, L, roughness);

        //vec3 kD = vec3(1.0) - F;
        //kD *= 1.0 - metallic;
        vec3 kD = mix(vec3(1.0) - F, vec3(0.0), metallic);

        vec3 numerator = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
        vec3 specular = numerator / max(denominator, 0.001);

        // Add to outgoing radiance directLighting
        float NdotL = max(dot(N, L), 0.0);
        vec3 diffuse = kD * albedo.rgb / M_PI;
        DirectLighting += (diffuse + specular) * radiance * NdotL;
    }

    vec3 ambient = vec3(0.03) * albedo.rgb;
    vec3 color = ambient + DirectLighting;

    // Ambient Occlusion
    float AO = texture(u_OcclusionMap, v_TexCoord).r;
    color = mix(color, color * AO, u_OcclusionStrength);

    // Emissive
    vec3 emissiveLighting = SRGBToLinear(texture(u_EmissiveMap, v_TexCoord)).rgb * u_EmissiveFactor;
    color += emissiveLighting;

    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2));

    o_Color = vec4(color, albedo.a);
}

```

`Engine/Assets/Shaders/Toon/Default.vert.glsl`:

```glsl
#version 450 core

#include <Toon/TBN.inc.glsl>
#include <Toon/Transform.inc.glsl>
#include <Toon/VertexAttributes.inc.glsl>

layout(location = 0) out vec3 v_Position;
layout(location = 1) out vec2 v_TexCoord;
layout(location = 2) out mat3 v_TBN;

void main()
{
    vec4 postion = u_Model * a_Position;
    v_Position = a_Position.xyz / a_Position.w;

    v_TexCoord = a_TexCoord1;

    v_TBN = CalculateTBN(u_Model, a_Normal, a_Tangent);

    gl_Position = u_MVP * a_Position;
}
```

`Engine/Assets/Shaders/Toon/Default2.frag.glsl`:

```glsl
#version 450 core

#include <Toon/Globals.inc.glsl>
#include <Toon/Material.inc.glsl>
#include <Toon/Math.inc.glsl>
#include <Toon/ColorSpace.inc.glsl>

// 
const float c_Epsilon = 0.00001;

// Constant normal incidence Fresnel factor for all dielectrics
const vec3 c_FresnelDielectric = vec3(0.04);

// Gamma correction
float c_Gamma = 2.2;

// TODO: Move
const vec3 c_LightRadiance = vec3(0.2);
const vec3 c_EyePosition = vec3(2.0, 3.0, 2.0);
const vec3 c_LightDirection = -c_EyePosition;

layout(location = 0) in vec3 v_Position;
layout(location = 1) in vec2 v_TexCoord;
layout(location = 2) in mat3 v_TBN;

layout(location = 0) out vec4 o_Color;

// Shlick's approximation of the Fresnel factor
vec3 fresnelSchlick(vec3 F0, float cosTheta)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

// GGX/Towbridge-Reitz normal distribution functions
// Use Disney's reparamaterization of (alpha = roughness^2)
float ndfGGX(float cosLh, float roughness)
{
    float alpha = roughness * roughness;
    float alphaSq = alpha * alpha;

    float denom = (cosLh * cosLh) * (alphaSq - 1.0) + 1.0;
    return alphaSq / (M_PI * denom * denom);
}

// Single term for separable Schlick-GXX (see gaSchlickGGX)
float gaSchlickG1(float cosTheta, float k)
{
    return cosTheta / (cosTheta * (1.0 - k) + k);
}

// Schlick-GGX approximation of geometric attenuation function using Smith's method
float gaSchlickGGX(float cosLi, float cosLo, float roughness)
{
    float r = roughness + 1.0;
    float k = (r * r) / 8.0; // Epic suggests using this roughness remapping for analytic lights
    return gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);
}

void main() 
{

//     vec3 N = normalize(2.0 * texture(u_NormalMap, v_TexCoord).rgb - 1.0);
//     N = normalize(N * v_TBN);

//     vec3 L = -c_LightDirection;

//     float D = max(0.0, dot(N, L));

//     o_Color = vec4(D, D, D, 1.0);



    vec4 albedo = SRGBToLinear(texture(u_BaseColorMap, v_TexCoord)) * u_BaseColorFactor;

    vec3 metallicRoughness = texture(u_MetallicRoughnessMap, v_TexCoord).rgb;
    float roughness = metallicRoughness.g * u_RoughnessFactor;
    float metallic = metallicRoughness.b * u_MetallicFactor;

    // Outgoing light direction (vector from world space fragment position to the eye)
    vec3 Lo = normalize(c_EyePosition - v_Position);

    // Get current normal and transform to world space
    vec3 N = normalize(2.0 * texture(u_NormalMap, v_TexCoord).rgb - 1.0);
    N = normalize(v_TBN * N);

    // Angle between surface normal and outgoing light direction
    float cosLo = max(0.0, dot(N, Lo));

    // Specular reflection vector
    vec3 Lr = 2.0 * cosLo * N - Lo;

    // Fresnel reflectance at normal incidence (for metals use albedo color)
    vec3 F0 = mix(c_FresnelDielectric, albedo.rgb, metallic);

    vec3 Li = -c_LightDirection;
    vec3 Lradiance = c_LightRadiance;

    // Half-vector between Li and Lo
    vec3 Lh = normalize(Li + Lo);

    // Calculate angles between surface normal and light vectors
    // float cosLi = max(0.0, dot(N, Li));
    float cosLi = max(0.0, dot(N, Li));
    float cosLh = max(0.0, dot(N, Lh));

    // Calculate Fresnel term for direct lighting
    vec3 F = fresnelSchlick(F0, max(0.0, dot(Lh, Lo)));

    // Calculate normal distribution for specular BRDF
    float D = ndfGGX(cosLh, roughness);

    // Calculate geometric attenuation for specular BRDF
    float G = gaSchlickGGX(cosLi, cosLo, roughness);

    // Diffuse scattering happens due to light being refracted multiple times by a dielectric medium
    // Metals on the other hand, either reflect or absorb energy, so diffuse contribution is always zero
    // To be energy conserving, we must scale diffuse BRDF contribution based on Fresnel factor and metalness
    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metallic);

    // Lambert diffuse BRDF
    // We don't scale by 1/PI for lighting and material units to be more convenient
    // See https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    vec3 diffuseBRDF = kd * (albedo.rgb / M_PI);

    // Cook-Torrance specular microfacet BRDF
    vec3 specularBRDF = (F * D * G) / max(c_Epsilon, 4.0 * cosLi * cosLo);

    // Total contribution for this light
    vec3 color = (diffuseBRDF + specularBRDF) * Lradiance * cosLi;

    // Ambient Occlusion
    float AO = texture(u_OcclusionMap, v_TexCoord).r;
    color = mix(color, color * AO, u_OcclusionStrength);

    // Emissive
    vec3 emissiveLighting = SRGBToLinear(texture(u_EmissiveMap, v_TexCoord)).rgb * u_EmissiveFactor;
    color += emissiveLighting;

    o_Color = vec4(pow(color, vec3(1.0 / c_Gamma)), albedo.a);
}
```

`Engine/Assets/Shaders/Toon/Default2.vert.glsl`:

```glsl
#version 450 core

#include <Toon/Globals.inc.glsl>
#include <Toon/Transform.inc.glsl>
#include <Toon/VertexAttributes.inc.glsl>
#include <Toon/TBN.inc.glsl>

layout(location = 0) out vec3 v_Position;
layout(location = 1) out vec2 v_TexCoord;
layout(location = 2) out mat3 v_TBN;

void main()
{
    vec4 position = u_Model * a_Position;
    v_Position = position.xyz / position.w;

    v_TexCoord = a_TexCoord1;

    v_TBN = CalculateTBN(u_Model, a_Normal, a_Tangent);

    gl_Position = u_MVP * a_Position;
}
```

`Engine/Assets/Shaders/Toon/FlatColor.frag.glsl`:

```glsl
#version 450 core

#include <Toon/Globals.inc.glsl>

layout(location = 0) out vec4 o_Color;

void main()
{
    o_Color = vec4(1.0, 0.0, 0.0, 1.0);
}

```

`Engine/Assets/Shaders/Toon/FlatColor.vert.glsl`:

```glsl
#version 450 core

#include <Toon/Globals.inc.glsl>
#include <Toon/Transform.inc.glsl>
#include <Toon/VertexAttributes.inc.glsl>

void main()
{
    gl_Position = u_MVP * a_Position;
}
```

`Engine/Assets/Shaders/Toon/Globals.inc.glsl`:

```glsl
#ifndef TOON_GLOBALS_INC_GLSL
#define TOON_GLOBALS_INC_GLSL

struct LightData
{
    vec3 Position;
    vec3 Direction;
    vec3 Color;
};

layout(binding = 0, std140) uniform ToonGlobals
{
    vec2 u_Resolution;
    vec2 u_Mouse;
    int u_FrameCount;
    float u_TotalTime;
    float u_FrameSpeedRatio;
    vec3 CameraPosition;
    int LightCount;
    LightData Lights[10];
};

#endif // TOON_GLOBALS_INC_GLSL
```

`Engine/Assets/Shaders/Toon/Material.inc.glsl`:

```glsl
#ifndef TOON_MATERIAL_INC_GLSL
#define TOON_MATERIAL_INC_GLSL

layout(binding = 2, std140) uniform ToonMaterial
{
    vec4 u_BaseColorFactor;
    vec3 u_EmissiveFactor;
    float u_MetallicFactor;
    float u_RoughnessFactor;
    float u_OcclusionStrength;
    float u_NormalScale;
};

layout (binding = 0) uniform sampler2D u_BaseColorMap;
layout (binding = 1) uniform sampler2D u_NormalMap;
layout (binding = 2) uniform sampler2D u_MetallicRoughnessMap;
layout (binding = 3) uniform sampler2D u_EmissiveMap;
layout (binding = 4) uniform sampler2D u_OcclusionMap;

#endif // TOON_MATERIAL_INC_GLSL
```

`Engine/Assets/Shaders/Toon/Math.inc.glsl`:

```glsl
#ifndef TOON_MATH_INC_GLSL
#define TOON_MATH_INC_GLSL

// e
#define M_E         2.71828182845904523536

// log2(e)
#define M_LOG2E     1.44269504088896340736

// log10(e)
#define M_LOG10E    0.434294481903251827651

// ln(2)
#define M_LN2       0.693147180559945309417

// ln(10)
#define M_LN10      2.30258509299404568402

// pi
#define M_PI        3.14159265358979323846

// pi/2
#define M_PI_2      1.57079632679489661923

// pi/4
#define M_PI_4      0.785398163397448309616

// 1/pi
#define M_1_PI      0.318309886183790671538

// 2/pi
#define M_2_PI      0.636619772367581343076

// 2/sqrt(pi)
#define M_2_SQRTPI  1.12837916709551257390

// sqrt(2)
#define M_SQRT2     1.41421356237309504880

// 1/sqrt(2)
#define M_SQRT1_2   0.707106781186547524401

#endif // TOON_MATH_INC_GLSL
```

`Engine/Assets/Shaders/Toon/TBN.inc.glsl`:

```glsl
#ifndef TOON_TBN_INC_GLSL
#define TOON_TBN_INC_GLSL

mat3 CalculateTBN(mat4 model, vec4 normal, vec4 tangent)
{
    mat3 normalMatrix = transpose(inverse(mat3(model)));

    vec3 T = normalize(normalMatrix * tangent.xyz);
    vec3 N = normalize(normalMatrix * normal.xyz);

    // Gram-Schmidt process to re-orthogonalize the TBN vectors
    T = normalize(T - dot(T, N) * N);

    vec3 B = cross(N, T) * tangent.w;

    return mat3(T, B, N);
}

#endif // TOON_TBN_INC_GLSL
```

`Engine/Assets/Shaders/Toon/Transform.inc.glsl`:

```glsl
#ifndef TOON_TRANSFORM_INC_GLSL
#define TOON_TRANSFORM_INC_GLSL

layout(binding = 1, std140) uniform ToonTransform
{
    mat4 u_Model;
    mat4 u_View;
    mat4 u_Proj;
    mat4 u_MVP;

};

#endif // TOON_TRANSFORM_INC_GLSL
```

`Engine/Assets/Shaders/Toon/VertexAttributes.inc.glsl`:

```glsl
#ifndef VERTEX_ATTRIBUTES_INC_GLSL
#define VERTEX_ATTRIBUTES_INC_GLSL

layout(location = 0) in vec4 a_Position;
layout(location = 1) in vec4 a_Normal;
layout(location = 2) in vec4 a_Tangent;
layout(location = 3) in vec4 a_Bitangent;
layout(location = 4) in vec4 a_Color;
layout(location = 5) in vec2 a_TexCoord1;
layout(location = 6) in vec2 a_TexCoord2;
layout(location = 7) in uvec4 a_Joint;
layout(location = 8) in vec4 a_Weight;

#endif // VERTEX_ATTRIBUTES_INC_GLSL
```

`Engine/Assets/Textures/brickwall/ReadMe.txt`:

```txt
Credits: Joey De Vries
https://learnopengl.com/Advanced-Lighting/Normal-Mapping
```

`Engine/Assets/Textures/mars/2k/ReadMe.txt`:

```txt
http://planetpixelemporium.com/earth8081.html
```

`Engine/Assets/Textures/mars/2k/mars.mtl`:

```mtl
newmtl Mars
Ns 32
Ka 0.1 0.1 0.1
Kd 0.8 0.8 0.8
Ks 0.8 0.8 0.8
d 1
illum 2
map_Kd mars_dm_2k.png
map_Kn mars_nm_2k.png

```

`Engine/Assets/Textures/mars/2k/mars.obj`:

```obj
mtllib mars.mtl
o Mars
v -0.707107 0.707107 0.000000
v -0.693520 0.707107 -0.137950
v -0.815493 0.555570 -0.162212
v -0.707107 -0.707107 -0.000000
v -0.693520 -0.707107 -0.137950
v -0.544895 -0.831470 -0.108386
v -0.831470 0.555570 0.000000
v -0.906127 0.382683 -0.180240
v -0.555570 -0.831470 -0.000000
v -0.375330 -0.923880 -0.074658
v -0.980785 0.195090 0.000000
v -0.923880 0.382683 0.000000
v -0.382683 -0.923880 -0.000000
v -0.191341 -0.980785 -0.038060
v -0.961940 0.195090 -0.191342
v -0.980785 0.000000 -0.195090
v -0.980785 -0.195090 -0.000000
v -1.000000 0.000000 0.000000
v -0.195090 0.980785 0.000000
v -0.191342 0.980785 -0.038060
v -0.375330 0.923880 -0.074658
v -0.961940 -0.195090 -0.191342
v -0.906127 -0.382683 -0.180240
v -0.382683 0.923880 0.000000
v -0.544895 0.831470 -0.108386
v -0.831470 -0.555570 -0.000000
v -0.923880 -0.382683 -0.000000
v -0.555570 0.831470 0.000000
v -0.815493 -0.555570 -0.162212
v -0.853553 -0.382683 -0.353554
v -0.513280 0.831470 -0.212608
v -0.653281 0.707107 -0.270598
v -0.768178 -0.555570 -0.318190
v -0.768178 0.555570 -0.318190
v -0.653281 -0.707107 -0.270598
v -0.513280 -0.831470 -0.212608
v -0.853553 0.382683 -0.353553
v -0.353553 -0.923880 -0.146447
v -0.906127 0.195090 -0.375330
v -0.180240 -0.980785 -0.074658
v -0.923879 0.000000 -0.382684
v -0.906127 -0.195090 -0.375330
v -0.180240 0.980785 -0.074658
v -0.353553 0.923880 -0.146447
v -0.318189 -0.923880 -0.212608
v -0.162211 -0.980785 -0.108386
v -0.815493 0.195090 -0.544895
v -0.831469 0.000000 -0.555570
v -0.815493 -0.195090 -0.544895
v -0.162212 0.980785 -0.108387
v -0.318190 0.923880 -0.212608
v -0.768178 -0.382683 -0.513280
v -0.461940 0.831470 -0.308658
v -0.587938 0.707107 -0.392848
v -0.691342 -0.555570 -0.461940
v -0.587938 -0.707107 -0.392848
v -0.461940 -0.831470 -0.308658
v -0.691342 0.555570 -0.461940
v -0.768178 0.382683 -0.513280
v -0.587938 -0.555570 -0.587938
v -0.500000 -0.707107 -0.500000
v -0.500000 0.707107 -0.500000
v -0.587938 0.555570 -0.587938
v -0.392847 -0.831470 -0.392848
v -0.653281 0.382683 -0.653282
v -0.270598 -0.923880 -0.270598
v -0.137949 -0.980785 -0.137950
v -0.693520 0.195090 -0.693520
v -0.707107 0.000000 -0.707107
v -0.693520 -0.195090 -0.693520
v -0.137950 0.980785 -0.137950
v -0.270598 0.923880 -0.270598
v -0.653281 -0.382683 -0.653282
v -0.392847 0.831470 -0.392848
v -0.555570 0.000000 -0.831470
v -0.544895 -0.195090 -0.815493
v -0.108386 0.980785 -0.162212
v -0.212607 0.923880 -0.318190
v -0.513280 -0.382683 -0.768178
v -0.308658 0.831470 -0.461940
v -0.392847 0.707107 -0.587938
v -0.461940 -0.555570 -0.691342
v -0.461940 0.555570 -0.691342
v -0.392847 -0.707107 -0.587938
v -0.308658 -0.831470 -0.461940
v -0.513280 0.382683 -0.768178
v -0.212607 -0.923880 -0.318190
v -0.108386 -0.980785 -0.162212
v -0.544895 0.195090 -0.815493
v -0.270598 0.707107 -0.653282
v -0.318189 0.555570 -0.768178
v -0.270598 -0.707107 -0.653282
v -0.353553 0.382683 -0.853554
v -0.212607 -0.831470 -0.513280
v -0.146446 -0.923880 -0.353554
v -0.074658 -0.980785 -0.180240
v -0.375330 0.195090 -0.906128
v -0.382683 0.000000 -0.923880
v -0.074658 0.980785 -0.180240
v -0.146446 0.923880 -0.353554
v -0.375330 -0.195090 -0.906128
v -0.353553 -0.382683 -0.853554
v -0.212607 0.831470 -0.513280
v -0.318189 -0.555570 -0.768178
v -0.195090 0.000000 -0.980785
v -0.038060 0.980785 -0.191342
v -0.074658 0.923880 -0.375331
v -0.191341 -0.195090 -0.961940
v -0.180240 -0.382683 -0.906128
v -0.108386 0.831470 -0.544895
v -0.137949 0.707107 -0.693520
v -0.162211 -0.555570 -0.815493
v -0.137949 -0.707107 -0.693520
v -0.162211 0.555570 -0.815493
v -0.180240 0.382683 -0.906128
v -0.108386 -0.831470 -0.544895
v -0.074658 -0.923880 -0.375330
v -0.191341 0.195090 -0.961940
v 0.000000 -0.707107 -0.707107
v 0.000000 0.555570 -0.831470
v 0.000000 0.382683 -0.923880
v 0.000000 -0.831470 -0.555570
v -0.038060 -0.980785 -0.191342
v 0.000000 -0.923880 -0.382684
v 0.000000 0.195090 -0.980785
v 0.000000 0.000000 -1.000000
v 0.000000 -0.195090 -0.980785
v 0.000000 0.980785 -0.195091
v 0.000000 0.923880 -0.382684
v 0.000000 -0.382683 -0.923880
v 0.000000 0.831470 -0.555570
v 0.000000 0.707107 -0.707107
v 0.000000 -0.555570 -0.831470
v 0.038061 0.980785 -0.191342
v 0.074658 0.923880 -0.375331
v 0.191342 -0.195090 -0.961940
v 0.180240 -0.382683 -0.906128
v 0.108387 0.831470 -0.544895
v 0.137950 0.707107 -0.693520
v 0.162212 -0.555570 -0.815493
v 0.137950 -0.707107 -0.693520
v 0.162212 0.555570 -0.815493
v 0.108387 -0.831470 -0.544895
v 0.180240 0.382683 -0.906128
v 0.074658 -0.923880 -0.375330
v 0.000000 -0.980785 -0.195090
v 0.191342 0.195090 -0.961940
v 0.195091 0.000000 -0.980785
v 0.318190 0.555570 -0.768178
v 0.353554 0.382683 -0.853554
v 0.212608 -0.831470 -0.513280
v 0.146447 -0.923880 -0.353553
v 0.038061 -0.980785 -0.191342
v 0.375331 0.195090 -0.906127
v 0.382684 0.000000 -0.923880
v 0.074658 0.980785 -0.180240
v 0.146447 0.923880 -0.353554
v 0.375331 -0.195090 -0.906127
v 0.353554 -0.382683 -0.853554
v 0.212608 0.831470 -0.513280
v 0.270598 0.707107 -0.653282
v 0.318190 -0.555570 -0.768178
v 0.270598 -0.707107 -0.653282
v 0.544895 -0.195090 -0.815493
v 0.513280 -0.382683 -0.768178
v 0.212608 0.923880 -0.318190
v 0.308659 0.831470 -0.461940
v 0.392848 0.707107 -0.587938
v 0.461940 -0.555570 -0.691342
v 0.392848 -0.707107 -0.587938
v 0.461940 0.555570 -0.691342
v 0.513280 0.382683 -0.768178
v 0.308659 -0.831470 -0.461940
v 0.074658 -0.980785 -0.180240
v 0.212608 -0.923880 -0.318190
v 0.544895 0.195090 -0.815493
v 0.555571 0.000000 -0.831470
v 0.108387 0.980785 -0.162212
v 0.392848 -0.831470 -0.392848
v 0.653282 0.382683 -0.653282
v 0.108387 -0.980785 -0.162212
v 0.270598 -0.923880 -0.270598
v 0.693520 0.195090 -0.693520
v 0.707107 0.000000 -0.707107
v 0.693520 -0.195090 -0.693520
v 0.137950 0.980785 -0.137950
v 0.270599 0.923880 -0.270598
v 0.653282 -0.382683 -0.653282
v 0.392848 0.831470 -0.392848
v 0.500000 0.707107 -0.500000
v 0.587938 -0.555570 -0.587938
v 0.500000 -0.707107 -0.500000
v 0.587938 0.555570 -0.587938
v 0.768178 -0.382683 -0.513280
v 0.461940 0.831470 -0.308658
v 0.587938 0.707107 -0.392848
v 0.691342 -0.555570 -0.461940
v 0.587938 -0.707107 -0.392848
v 0.461940 -0.831470 -0.308658
v 0.691342 0.555570 -0.461940
v 0.768178 0.382683 -0.513280
v 0.137950 -0.980785 -0.137950
v 0.318190 -0.923880 -0.212608
v 0.815493 0.195090 -0.544895
v 0.831470 0.000000 -0.555570
v 0.815493 -0.195090 -0.544895
v 0.162212 0.980785 -0.108386
v 0.318190 0.923880 -0.212608
v 0.162212 -0.980785 -0.108386
v 0.353554 -0.923880 -0.146447
v 0.906128 0.195090 -0.375330
v 0.923880 0.000000 -0.382683
v 0.906128 -0.195090 -0.375330
v 0.180240 0.980785 -0.074658
v 0.353554 0.923880 -0.146447
v 0.853554 -0.382683 -0.353553
v 0.513280 0.831470 -0.212608
v 0.768178 -0.555570 -0.318190
v 0.653282 -0.707107 -0.270598
v 0.653282 0.707107 -0.270598
v 0.768178 0.555570 -0.318190
v 0.513280 -0.831470 -0.212608
v 0.853554 0.382683 -0.353553
v 0.544896 0.831470 -0.108386
v 0.815493 -0.555570 -0.162212
v 0.693520 -0.707107 -0.137950
v 0.693520 0.707107 -0.137950
v 0.815493 0.555570 -0.162212
v 0.544895 -0.831470 -0.108386
v 0.906128 0.382683 -0.180240
v 0.375331 -0.923880 -0.074658
v 0.191342 -0.980785 -0.038060
v 0.961940 0.195090 -0.191342
v 0.980786 0.000000 -0.195090
v 0.961940 -0.195090 -0.191342
v 0.191342 0.980785 -0.038060
v 0.375331 0.923880 -0.074658
v 0.906128 -0.382683 -0.180240
v 0.980785 0.195090 0.000000
v 1.000000 0.000000 0.000000
v 0.195091 0.980785 0.000000
v 0.382684 0.923880 0.000000
v 0.980785 -0.195090 -0.000000
v 0.923880 -0.382683 -0.000000
v 0.555571 0.831470 0.000000
v 0.831470 -0.555570 -0.000000
v 0.707107 -0.707107 -0.000000
v 0.707107 0.707107 0.000000
v 0.831470 0.555570 0.000000
v 0.555570 -0.831470 -0.000000
v 0.923880 0.382683 0.000000
v 0.382684 -0.923880 -0.000000
v 0.815493 -0.555570 0.162212
v 0.693520 -0.707107 0.137950
v 0.693520 0.707107 0.137950
v 0.815493 0.555570 0.162212
v 0.906128 0.382683 0.180240
v 0.544895 -0.831470 0.108386
v 0.195091 -0.980785 -0.000000
v 0.375331 -0.923880 0.074658
v 0.961940 0.195090 0.191342
v 0.980786 -0.000000 0.195090
v 0.961940 -0.195090 0.191342
v 0.191342 0.980785 0.038060
v 0.375331 0.923880 0.074658
v 0.906128 -0.382683 0.180240
v 0.544896 0.831470 0.108386
v 0.923880 -0.000000 0.382684
v 0.906127 -0.195090 0.375330
v 0.180240 0.980785 0.074658
v 0.353554 0.923880 0.146447
v 0.853554 -0.382683 0.353553
v 0.513280 0.831470 0.212608
v 0.768178 -0.555570 0.318190
v 0.653282 -0.707107 0.270598
v 0.653282 0.707107 0.270598
v 0.768178 0.555570 0.318190
v 0.513280 -0.831470 0.212608
v 0.853554 0.382683 0.353553
v 0.353554 -0.923880 0.146447
v 0.191342 -0.980785 0.038060
v 0.906127 0.195090 0.375330
v 0.587938 0.707107 0.392847
v 0.587938 -0.707107 0.392847
v 0.691342 0.555570 0.461940
v 0.768178 0.382683 0.513280
v 0.461940 -0.831470 0.308658
v 0.318190 -0.923880 0.212607
v 0.162212 -0.980785 0.108386
v 0.815493 0.195090 0.544895
v 0.831470 -0.000000 0.555570
v 0.815493 -0.195090 0.544895
v 0.162212 0.980785 0.108386
v 0.318190 0.923880 0.212608
v 0.768178 -0.382683 0.513280
v 0.461940 0.831470 0.308658
v 0.691342 -0.555570 0.461940
v 0.707107 -0.000000 0.707107
v 0.693520 -0.195090 0.693520
v 0.137950 0.980785 0.137950
v 0.270598 0.923880 0.270598
v 0.653282 -0.382683 0.653281
v 0.392848 0.831470 0.392848
v 0.587938 -0.555570 0.587938
v 0.500000 -0.707107 0.500000
v 0.500000 0.707107 0.500000
v 0.392848 -0.831470 0.392847
v 0.587938 0.555570 0.587938
v 0.653282 0.382683 0.653281
v 0.270598 -0.923880 0.270598
v 0.693520 0.195090 0.693520
v 0.392848 -0.707107 0.587938
v 0.461940 0.555570 0.691342
v 0.513280 0.382683 0.768178
v 0.308658 -0.831470 0.461940
v 0.212608 -0.923880 0.318190
v 0.108387 -0.980785 0.162212
v 0.544895 0.195090 0.815493
v 0.555570 -0.000000 0.831470
v 0.544895 -0.195090 0.815493
v 0.108387 0.980785 0.162212
v 0.212608 0.923880 0.318190
v 0.513280 -0.382683 0.768178
v 0.308659 0.831470 0.461940
v 0.461940 -0.555570 0.691342
v 0.392848 0.707107 0.587938
v 0.375330 -0.195090 0.906127
v 0.353554 -0.382683 0.853553
v 0.146447 0.923880 0.353553
v 0.212608 0.831470 0.513280
v 0.318190 -0.555570 0.768177
v 0.270598 -0.707107 0.653281
v 0.270598 0.707107 0.653281
v 0.318190 0.555570 0.768177
v 0.212608 -0.831470 0.513280
v 0.353554 0.382683 0.853553
v 0.146447 -0.923880 0.353553
v 0.074658 -0.980785 0.180240
v 0.375330 0.195090 0.906127
v 0.382684 -0.000000 0.923880
v 0.074658 0.980785 0.180240
v 0.108387 -0.831470 0.544895
v 0.180240 0.382683 0.906127
v 0.074658 -0.923880 0.375330
v 0.038061 -0.980785 0.191342
v 0.191342 0.195090 0.961939
v 0.195090 -0.000000 0.980785
v 0.038061 0.980785 0.191342
v 0.074658 0.923880 0.375330
v 0.191342 -0.195090 0.961939
v 0.180240 -0.382683 0.906127
v 0.108387 0.831470 0.544895
v 0.162212 -0.555570 0.815493
v 0.137950 -0.707107 0.693520
v 0.137950 0.707107 0.693520
v 0.162212 0.555570 0.815493
v 0.000000 0.923880 0.382683
v 0.000000 0.831470 0.555570
v 0.000000 -0.382683 0.923879
v 0.000000 -0.555570 0.831469
v 0.000000 -0.707107 0.707107
v 0.000000 0.707107 0.707107
v 0.000000 -0.831470 0.555570
v 0.000000 0.555570 0.831469
v 0.000000 0.382683 0.923879
v 0.000000 -0.923880 0.382683
v 0.000000 -0.980785 0.195090
v 0.000000 0.195090 0.980785
v 0.000000 -0.000000 1.000000
v 0.000000 0.980785 0.195090
v 0.000000 -0.195090 0.980785
v -0.180240 0.382683 0.906127
v -0.074658 -0.923880 0.375330
v -0.038060 -0.980785 0.191342
v -0.191342 0.195090 0.961939
v -0.195090 -0.000000 0.980785
v -0.038060 0.980785 0.191342
v -0.191342 -0.195090 0.961939
v -0.180240 -0.382683 0.906127
v -0.074658 0.923880 0.375330
v -0.108386 0.831470 0.544895
v -0.162211 -0.555570 0.815493
v -0.137949 -0.707107 0.693520
v -0.137949 0.707107 0.693520
v -0.108386 -0.831470 0.544895
v -0.162211 0.555570 0.815493
v -0.353553 -0.382683 0.853553
v -0.212607 0.831470 0.513280
v -0.318189 -0.555570 0.768177
v -0.270598 -0.707107 0.653281
v -0.270598 0.707107 0.653281
v -0.318189 0.555570 0.768177
v -0.353553 0.382683 0.853553
v -0.212607 -0.831470 0.513280
v -0.146446 -0.923880 0.353553
v -0.074657 -0.980785 0.180240
v -0.375330 0.195090 0.906127
v -0.382683 -0.000000 0.923879
v -0.074658 0.980785 0.180240
v -0.375330 -0.195090 0.906127
v -0.146446 0.923880 0.353553
v -0.212607 -0.923880 0.318189
v -0.108386 -0.980785 0.162212
v -0.544895 0.195090 0.815493
v -0.555570 -0.000000 0.831469
v -0.544895 -0.195090 0.815493
v -0.108386 0.980785 0.162212
v -0.513280 -0.382683 0.768178
v -0.212607 0.923880 0.318190
v -0.308658 0.831470 0.461940
v -0.392847 0.707107 0.587938
v -0.461939 -0.555570 0.691341
v -0.392847 -0.707107 0.587938
v -0.308658 -0.831470 0.461940
v -0.461939 0.555570 0.691341
v -0.513280 0.382683 0.768178
v -0.392847 0.831470 0.392847
v -0.500000 0.707107 0.500000
v -0.587937 -0.555570 0.587937
v -0.500000 -0.707107 0.500000
v -0.392847 -0.831470 0.392847
v -0.587937 0.555570 0.587937
v -0.653281 0.382683 0.653281
v -0.270598 -0.923880 0.270598
v -0.137949 -0.980785 0.137950
v -0.693519 0.195090 0.693519
v -0.707106 -0.000000 0.707106
v -0.693519 -0.195090 0.693519
v -0.137949 0.980785 0.137950
v -0.270598 0.923880 0.270598
v -0.653281 -0.382683 0.653281
v -0.815492 0.195090 0.544895
v -0.831469 -0.000000 0.555570
v -0.815492 -0.195090 0.544895
v -0.162211 0.980785 0.108386
v -0.318189 0.923880 0.212607
v -0.768177 -0.382683 0.513280
v -0.461939 0.831470 0.308658
v -0.587937 0.707107 0.392847
v -0.691341 -0.555570 0.461939
v -0.587937 -0.707107 0.392847
v -0.691341 0.555570 0.461939
v -0.768177 0.382683 0.513280
v -0.461939 -0.831470 0.308658
v -0.318189 -0.923880 0.212607
v -0.162211 -0.980785 0.108386
v -0.768177 -0.555570 0.318189
v -0.653281 -0.707107 0.270598
v -0.653281 0.707107 0.270598
v -0.513279 -0.831470 0.212607
v -0.768177 0.555570 0.318189
v -0.853553 0.382683 0.353553
v -0.353553 -0.923880 0.146446
v -0.180240 -0.980785 0.074658
v -0.906127 0.195090 0.375330
v -0.923879 -0.000000 0.382683
v -0.180240 0.980785 0.074658
v -0.906127 -0.195090 0.375330
v -0.853553 -0.382683 0.353553
v -0.353553 0.923880 0.146447
v -0.513280 0.831470 0.212607
v -0.980785 -0.000000 0.195090
v -0.961939 -0.195090 0.191341
v -0.191342 0.980785 0.038060
v -0.375330 0.923880 0.074658
v -0.906127 -0.382683 0.180240
v -0.544895 0.831470 0.108386
v -0.815492 -0.555570 0.162211
v -0.693520 -0.707107 0.137950
v -0.693520 0.707107 0.137950
v -0.544895 -0.831470 0.108386
v -0.815492 0.555570 0.162211
v -0.906127 0.382683 0.180240
v -0.375330 -0.923880 0.074658
v -0.191341 -0.980785 0.038060
v -0.961939 0.195090 0.191341
v -0.195090 -0.980785 -0.000000
v 0.180240 -0.980785 0.074658
v 0.067917 -0.980785 0.028132
v 0.072100 -0.980785 0.014341
v 0.000000 -0.980785 0.073512
v 0.014342 -0.980785 0.072099
v -0.040841 0.980785 -0.061123
v -0.028132 0.980785 -0.067916
v 0.000000 0.980785 -0.073512
v 0.014342 0.980785 -0.072100
v 0.067917 0.980785 -0.028132
v -0.028132 0.980785 0.067916
v -0.040841 0.980785 0.061123
v 0.014342 0.980785 0.072100
v 0.000000 -0.980785 -0.073512
v -0.014341 -0.980785 -0.072100
v -0.073512 -0.980785 -0.000000
v 0.073512 -0.980785 -0.000000
v -0.028132 -0.980785 0.067916
v -0.014341 -0.980785 0.072099
v -0.014341 0.980785 -0.072100
v -0.051981 0.980785 0.051981
v -0.072099 0.980785 0.014341
v -0.073512 0.980785 0.000000
v 0.073512 0.980785 0.000000
v -0.061123 -0.980785 0.040841
v -0.051981 -0.980785 0.051981
v -0.014341 0.980785 0.072100
v 0.061123 0.980785 0.040841
v 0.028132 -0.980785 -0.067916
v -0.028132 -0.980785 -0.067916
v 0.061123 -0.980785 0.040841
v -0.072099 -0.980785 0.014341
v -0.067916 -0.980785 0.028132
v -0.061123 -0.980785 -0.040841
v -0.067916 -0.980785 -0.028132
v 0.067917 0.980785 0.028132
v -0.072099 -0.980785 -0.014342
v 0.051981 -0.980785 -0.051981
v 0.040841 -0.980785 -0.061123
v -0.072099 0.980785 -0.014342
v 0.014342 -0.980785 -0.072100
v -0.067916 0.980785 0.028132
v 0.040841 -0.980785 0.061123
v 0.051981 -0.980785 0.051981
v -0.067916 0.980785 -0.028132
v -0.061123 0.980785 -0.040841
v 0.180240 -0.980785 -0.074658
v 0.067917 -0.980785 -0.028132
v 0.061123 -0.980785 -0.040841
v 0.040841 0.980785 -0.061123
v 0.051981 0.980785 -0.051981
v -0.051981 0.980785 -0.051981
v 0.051981 0.980785 0.051981
v 0.040841 0.980785 0.061123
v -0.040841 -0.980785 -0.061123
v -0.051981 -0.980785 -0.051981
v -0.061123 0.980785 0.040841
v 0.028132 -0.980785 0.067916
v 0.061123 0.980785 -0.040841
v 0.137950 -0.980785 0.137950
v 0.028132 0.980785 0.067916
v 0.028132 0.980785 -0.067916
v 0.072100 0.980785 -0.014342
v 0.000000 0.980785 0.073512
v -0.040841 -0.980785 0.061123
v 0.072100 0.980785 0.014341
v 0.072100 -0.980785 -0.014342
v 0.000000 0.980785 -0.073512
v 0.028132 0.980785 -0.067916
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v -0.051981 0.980785 0.051981
v -0.067916 0.980785 0.028132
v 0.000000 -0.980785 -0.000000
v 0.072100 0.980785 0.014341
v 0.067917 0.980785 -0.028132
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v -0.014341 0.980785 -0.072100
v -0.061123 0.980785 -0.040841
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v -0.040841 0.980785 0.061123
v 0.014342 0.980785 0.072100
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v -0.073512 0.980785 0.000000
v 0.073512 0.980785 0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.051981 0.980785 0.051981
v 0.014342 0.980785 -0.072100
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.061123 0.980785 -0.040841
v -0.061123 0.980785 0.040841
v -0.040841 0.980785 -0.061123
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v -0.028132 0.980785 0.067916
v -0.067916 0.980785 -0.028132
v 0.067917 0.980785 0.028132
v -0.028132 0.980785 -0.067916
v 0.028132 0.980785 0.067916
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.040841 0.980785 -0.061123
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.051981 0.980785 -0.051981
v 0.072100 0.980785 -0.014342
v -0.072099 0.980785 0.014341
v 0.000000 -0.980785 -0.000000
v -0.072099 0.980785 -0.014342
v 0.000000 0.980785 0.073512
v 0.061123 0.980785 0.040841
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v 0.000000 -0.980785 -0.000000
v -0.014341 0.980785 0.072100
v 0.040841 0.980785 0.061123
v -0.051981 0.980785 -0.051981
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
v 0.000000 0.980785 0.000000
vt 0.750000 0.750000
vt 0.718750 0.750000
vt 0.718750 0.687500
vt 0.750000 0.250000
vt 0.718750 0.250000
vt 0.718750 0.187500
vt 0.750000 0.687500
vt 0.718750 0.625000
vt 0.750000 0.187500
vt 0.718750 0.125000
vt 0.750000 0.562500
vt 0.750000 0.625000
vt 0.750000 0.125000
vt 0.718750 0.062500
vt 0.718750 0.562500
vt 0.718750 0.500000
vt 0.750000 0.437500
vt 0.750000 0.500000
vt 0.750000 0.937500
vt 0.718750 0.937500
vt 0.718750 0.875000
vt 0.718750 0.437500
vt 0.718750 0.375000
vt 0.750000 0.875000
vt 0.718750 0.812500
vt 0.750000 0.312500
vt 0.750000 0.375000
vt 0.750000 0.812500
vt 0.718750 0.312500
vt 0.687500 0.375000
vt 0.687500 0.812500
vt 0.687500 0.750000
vt 0.687500 0.312500
vt 0.687500 0.687500
vt 0.687500 0.250000
vt 0.687500 0.187500
vt 0.687500 0.625000
vt 0.687500 0.125000
vt 0.687500 0.562500
vt 0.687500 0.062500
vt 0.687500 0.500000
vt 0.687500 0.437500
vt 0.687500 0.937500
vt 0.687500 0.875000
vt 0.656250 0.125000
vt 0.656250 0.062500
vt 0.656250 0.562500
vt 0.656250 0.500000
vt 0.656250 0.437500
vt 0.656250 0.937500
vt 0.656250 0.875000
vt 0.656250 0.375000
vt 0.656250 0.812500
vt 0.656250 0.750000
vt 0.656250 0.312500
vt 0.656250 0.250000
vt 0.656250 0.187500
vt 0.656250 0.687500
vt 0.656250 0.625000
vt 0.625000 0.312500
vt 0.625000 0.250000
vt 0.625000 0.750000
vt 0.625000 0.687500
vt 0.625000 0.187500
vt 0.625000 0.625000
vt 0.625000 0.125000
vt 0.625000 0.062500
vt 0.625000 0.562500
vt 0.625000 0.500000
vt 0.625000 0.437500
vt 0.625000 0.937500
vt 0.625000 0.875000
vt 0.625000 0.375000
vt 0.625000 0.812500
vt 0.593750 0.500000
vt 0.593750 0.437500
vt 0.593750 0.937500
vt 0.593750 0.875000
vt 0.593750 0.375000
vt 0.593750 0.812500
vt 0.593750 0.750000
vt 0.593750 0.312500
vt 0.593750 0.687500
vt 0.593750 0.250000
vt 0.593750 0.187500
vt 0.593750 0.625000
vt 0.593750 0.125000
vt 0.593750 0.062500
vt 0.593750 0.562500
vt 0.562500 0.750000
vt 0.562500 0.687500
vt 0.562500 0.250000
vt 0.562500 0.625000
vt 0.562500 0.187500
vt 0.562500 0.125000
vt 0.562500 0.062500
vt 0.562500 0.562500
vt 0.562500 0.500000
vt 0.562500 0.937500
vt 0.562500 0.875000
vt 0.562500 0.437500
vt 0.562500 0.375000
vt 0.562500 0.812500
vt 0.562500 0.312500
vt 0.531250 0.500000
vt 0.531250 0.937500
vt 0.531250 0.875000
vt 0.531250 0.437500
vt 0.531250 0.375000
vt 0.531250 0.812500
vt 0.531250 0.750000
vt 0.531250 0.312500
vt 0.531250 0.250000
vt 0.531250 0.687500
vt 0.531250 0.625000
vt 0.531250 0.187500
vt 0.531250 0.125000
vt 0.531250 0.562500
vt 0.500000 0.250000
vt 0.500000 0.687500
vt 0.500000 0.625000
vt 0.500000 0.187500
vt 0.531250 0.062500
vt 0.500000 0.125000
vt 0.500000 0.562500
vt 0.500000 0.500000
vt 0.500000 0.437500
vt 0.500000 0.937500
vt 0.500000 0.875000
vt 0.500000 0.375000
vt 0.500000 0.812500
vt 0.500000 0.750000
vt 0.500000 0.312500
vt 0.468750 0.937500
vt 0.468750 0.875000
vt 0.468750 0.437500
vt 0.468750 0.375000
vt 0.468750 0.812500
vt 0.468750 0.750000
vt 0.468750 0.312500
vt 0.468750 0.250000
vt 0.468750 0.687500
vt 0.468750 0.187500
vt 0.468750 0.625000
vt 0.468750 0.125000
vt 0.500000 0.062500
vt 0.468750 0.562500
vt 0.468750 0.500000
vt 0.437500 0.687500
vt 0.437500 0.625000
vt 0.437500 0.187500
vt 0.437500 0.125000
vt 0.468750 0.062500
vt 0.437500 0.562500
vt 0.437500 0.500000
vt 0.437500 0.937500
vt 0.437500 0.875000
vt 0.437500 0.437500
vt 0.437500 0.375000
vt 0.437500 0.812500
vt 0.437500 0.750000
vt 0.437500 0.312500
vt 0.437500 0.250000
vt 0.406250 0.437500
vt 0.406250 0.375000
vt 0.406250 0.875000
vt 0.406250 0.812500
vt 0.406250 0.750000
vt 0.406250 0.312500
vt 0.406250 0.250000
vt 0.406250 0.687500
vt 0.406250 0.625000
vt 0.406250 0.187500
vt 0.437500 0.062500
vt 0.406250 0.125000
vt 0.406250 0.562500
vt 0.406250 0.500000
vt 0.406250 0.937500
vt 0.375000 0.187500
vt 0.375000 0.625000
vt 0.406250 0.062500
vt 0.375000 0.125000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.375000 0.437500
vt 0.375000 0.937500
vt 0.375000 0.875000
vt 0.375000 0.375000
vt 0.375000 0.812500
vt 0.375000 0.750000
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.375000 0.687500
vt 0.343750 0.375000
vt 0.343750 0.812500
vt 0.343750 0.750000
vt 0.343750 0.312500
vt 0.343750 0.250000
vt 0.343750 0.187500
vt 0.343750 0.687500
vt 0.343750 0.625000
vt 0.375000 0.062500
vt 0.343750 0.125000
vt 0.343750 0.562500
vt 0.343750 0.500000
vt 0.343750 0.437500
vt 0.343750 0.937500
vt 0.343750 0.875000
vt 0.343750 0.062500
vt 0.312500 0.125000
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.312500 0.437500
vt 0.312500 0.937500
vt 0.312500 0.875000
vt 0.312500 0.375000
vt 0.312500 0.812500
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.312500 0.750000
vt 0.312500 0.687500
vt 0.312500 0.187500
vt 0.312500 0.625000
vt 0.281250 0.812500
vt 0.281250 0.312500
vt 0.281250 0.250000
vt 0.281250 0.750000
vt 0.281250 0.687500
vt 0.281250 0.187500
vt 0.281250 0.625000
vt 0.281250 0.125000
vt 0.281250 0.062500
vt 0.281250 0.562500
vt 0.281250 0.500000
vt 0.281250 0.437500
vt 0.281250 0.937500
vt 0.281250 0.875000
vt 0.281250 0.375000
vt 0.250000 0.562500
vt 0.250000 0.500000
vt 0.250000 0.937500
vt 0.250000 0.875000
vt 0.250000 0.437500
vt 0.250000 0.375000
vt 0.250000 0.812500
vt 0.250000 0.312500
vt 0.250000 0.250000
vt 0.250000 0.750000
vt 0.250000 0.687500
vt 0.250000 0.187500
vt 0.250000 0.625000
vt 0.250000 0.125000
vt 0.218750 0.312500
vt 0.218750 0.250000
vt 0.218750 0.750000
vt 0.218750 0.687500
vt 0.218750 0.625000
vt 0.218750 0.187500
vt 0.250000 0.062500
vt 0.218750 0.125000
vt 0.218750 0.562500
vt 0.218750 0.500000
vt 0.218750 0.437500
vt 0.218750 0.937500
vt 0.218750 0.875000
vt 0.218750 0.375000
vt 0.218750 0.812500
vt 0.187500 0.500000
vt 0.187500 0.437500
vt 0.187500 0.937500
vt 0.187500 0.875000
vt 0.187500 0.375000
vt 0.187500 0.812500
vt 0.187500 0.312500
vt 0.187500 0.250000
vt 0.187500 0.750000
vt 0.187500 0.687500
vt 0.187500 0.187500
vt 0.187500 0.625000
vt 0.187500 0.125000
vt 0.218750 0.062500
vt 0.187500 0.562500
vt 0.156250 0.750000
vt 0.156250 0.250000
vt 0.156250 0.687500
vt 0.156250 0.625000
vt 0.156250 0.187500
vt 0.156250 0.125000
vt 0.156250 0.062500
vt 0.156250 0.562500
vt 0.156250 0.500000
vt 0.156250 0.437500
vt 0.156250 0.937500
vt 0.156250 0.875000
vt 0.156250 0.375000
vt 0.156250 0.812500
vt 0.156250 0.312500
vt 0.125000 0.500000
vt 0.125000 0.437500
vt 0.125000 0.937500
vt 0.125000 0.875000
vt 0.125000 0.375000
vt 0.125000 0.812500
vt 0.125000 0.312500
vt 0.125000 0.250000
vt 0.125000 0.750000
vt 0.125000 0.187500
vt 0.125000 0.687500
vt 0.125000 0.625000
vt 0.125000 0.125000
vt 0.125000 0.562500
vt 0.093750 0.250000
vt 0.093750 0.687500
vt 0.093750 0.625000
vt 0.093750 0.187500
vt 0.093750 0.125000
vt 0.093750 0.062500
vt 0.093750 0.562500
vt 0.093750 0.500000
vt 0.093750 0.437500
vt 0.093750 0.937500
vt 0.093750 0.875000
vt 0.093750 0.375000
vt 0.093750 0.812500
vt 0.093750 0.312500
vt 0.093750 0.750000
vt 0.062500 0.437500
vt 0.062500 0.375000
vt 0.062500 0.875000
vt 0.062500 0.812500
vt 0.062500 0.312500
vt 0.062500 0.250000
vt 0.062500 0.750000
vt 0.062500 0.687500
vt 0.062500 0.187500
vt 0.062500 0.625000
vt 0.062500 0.125000
vt 0.062500 0.062500
vt 0.062500 0.562500
vt 0.062500 0.500000
vt 0.062500 0.937500
vt 0.031250 0.187500
vt 0.031250 0.625000
vt 0.031250 0.125000
vt 0.031250 0.062500
vt 0.031250 0.562500
vt 0.031250 0.500000
vt 0.031250 0.937500
vt 0.031250 0.875000
vt 0.031250 0.437500
vt 0.031250 0.375000
vt 0.031250 0.812500
vt 0.031250 0.312500
vt 0.031250 0.250000
vt 0.031250 0.750000
vt 0.031250 0.687500
vt 0.000000 0.875000
vt 0.000000 0.812500
vt 0.000000 0.375000
vt 0.000000 0.312500
vt 0.000000 0.250000
vt 0.000000 0.750000
vt 0.000000 0.187500
vt 0.000000 0.687500
vt 0.000000 0.625000
vt 0.000000 0.125000
vt 0.000000 0.062500
vt 0.000000 0.562500
vt 0.000000 0.500000
vt 0.000000 0.937500
vt 0.000000 0.437500
vt 1.000000 0.562500
vt 1.000000 0.625000
vt 0.968750 0.625000
vt 1.000000 0.125000
vt 0.968750 0.125000
vt 0.968750 0.062500
vt 0.968750 0.562500
vt 0.968750 0.500000
vt 1.000000 0.437500
vt 1.000000 0.500000
vt 1.000000 0.875000
vt 1.000000 0.937500
vt 0.968750 0.937500
vt 0.968750 0.437500
vt 0.968750 0.375000
vt 0.968750 0.875000
vt 0.968750 0.812500
vt 1.000000 0.312500
vt 1.000000 0.375000
vt 1.000000 0.750000
vt 1.000000 0.812500
vt 0.968750 0.312500
vt 0.968750 0.250000
vt 1.000000 0.687500
vt 0.968750 0.750000
vt 1.000000 0.250000
vt 0.968750 0.187500
vt 0.968750 0.687500
vt 1.000000 0.187500
vt 0.937500 0.375000
vt 0.937500 0.812500
vt 0.937500 0.312500
vt 0.937500 0.250000
vt 0.937500 0.750000
vt 0.937500 0.687500
vt 0.937500 0.625000
vt 0.937500 0.187500
vt 0.937500 0.125000
vt 0.937500 0.062500
vt 0.937500 0.562500
vt 0.937500 0.500000
vt 0.937500 0.937500
vt 0.937500 0.437500
vt 0.937500 0.875000
vt 0.906250 0.125000
vt 0.906250 0.062500
vt 0.906250 0.562500
vt 0.906250 0.500000
vt 0.906250 0.437500
vt 0.906250 0.937500
vt 0.906250 0.375000
vt 0.906250 0.875000
vt 0.906250 0.812500
vt 0.906250 0.750000
vt 0.906250 0.312500
vt 0.906250 0.250000
vt 0.906250 0.187500
vt 0.906250 0.687500
vt 0.906250 0.625000
vt 0.875000 0.812500
vt 0.875000 0.750000
vt 0.875000 0.312500
vt 0.875000 0.250000
vt 0.875000 0.187500
vt 0.875000 0.687500
vt 0.875000 0.625000
vt 0.875000 0.125000
vt 0.875000 0.062500
vt 0.875000 0.562500
vt 0.875000 0.500000
vt 0.875000 0.437500
vt 0.875000 0.937500
vt 0.875000 0.875000
vt 0.875000 0.375000
vt 0.843750 0.562500
vt 0.843750 0.500000
vt 0.843750 0.437500
vt 0.843750 0.937500
vt 0.843750 0.875000
vt 0.843750 0.375000
vt 0.843750 0.812500
vt 0.843750 0.750000
vt 0.843750 0.312500
vt 0.843750 0.250000
vt 0.843750 0.687500
vt 0.843750 0.625000
vt 0.843750 0.187500
vt 0.843750 0.125000
vt 0.843750 0.062500
vt 0.812500 0.312500
vt 0.812500 0.250000
vt 0.812500 0.750000
vt 0.812500 0.187500
vt 0.812500 0.687500
vt 0.812500 0.625000
vt 0.812500 0.125000
vt 0.812500 0.062500
vt 0.812500 0.562500
vt 0.812500 0.500000
vt 0.812500 0.937500
vt 0.812500 0.437500
vt 0.812500 0.375000
vt 0.812500 0.875000
vt 0.812500 0.812500
vt 0.781250 0.500000
vt 0.781250 0.437500
vt 0.781250 0.937500
vt 0.781250 0.875000
vt 0.781250 0.375000
vt 0.781250 0.812500
vt 0.781250 0.312500
vt 0.781250 0.250000
vt 0.781250 0.750000
vt 0.781250 0.187500
vt 0.781250 0.687500
vt 0.781250 0.625000
vt 0.781250 0.125000
vt 0.781250 0.062500
vt 0.781250 0.562500
vt 0.750000 0.062500
vt 0.187500 0.062500
vt 0.187500 0.023814
vt 0.218750 0.023814
vt 0.000001 0.023813
vt 0.031251 0.023813
vt 0.593749 0.976187
vt 0.562499 0.976187
vt 0.499999 0.976186
vt 0.468749 0.976186
vt 0.312500 0.976186
vt 0.937501 0.976187
vt 0.906250 0.976187
vt 0.031251 0.976186
vt 0.499999 0.023813
vt 0.531249 0.023813
vt 0.750000 0.023813
vt 0.250000 0.023814
vt 0.937501 0.023813
vt 0.968751 0.023813
vt 0.531249 0.976186
vt 0.875000 0.976187
vt 0.781250 0.976187
vt 0.750000 0.976187
vt 0.250000 0.976186
vt 0.843750 0.023813
vt 0.875000 0.023813
vt 0.968751 0.976187
vt 0.156250 0.976186
vt 0.437499 0.023814
vt 0.562499 0.023813
vt 0.156250 0.023814
vt 0.781250 0.023813
vt 0.812500 0.023813
vt 0.656250 0.023813
vt 0.687500 0.023813
vt 0.187500 0.976186
vt 0.718750 0.023813
vt 0.375000 0.023814
vt 0.406249 0.023814
vt 0.718750 0.976187
vt 0.468749 0.023814
vt 0.812500 0.976187
vt 0.093751 0.023814
vt 0.125001 0.023814
vt 0.687500 0.976187
vt 0.656250 0.976187
vt 0.312500 0.062500
vt 0.312500 0.023814
vt 0.343750 0.023814
vt 0.406249 0.976186
vt 0.375000 0.976186
vt 0.624999 0.976187
vt 0.125001 0.976186
vt 0.093751 0.976186
vt 0.593749 0.023813
vt 0.625000 0.023813
vt 0.843750 0.976187
vt 0.062501 0.023814
vt 0.343750 0.976186
vt 0.125000 0.062500
vt 0.062501 0.976186
vt 0.437499 0.976186
vt 1.000000 0.062500
vt 0.281250 0.976186
vt 1.000001 0.976187
vt 0.906251 0.023813
vt 0.218750 0.976186
vt 0.281250 0.023814
vt 1.000001 0.023813
vt 0.000001 0.976187
vn -0.710100 0.704100 0.000000
vn -0.696500 0.704100 -0.138500
vn -0.817300 0.552800 -0.162600
vn -0.710100 -0.704100 0.000000
vn -0.696500 -0.704100 -0.138500
vn -0.549000 -0.828600 -0.109200
vn -0.833300 0.552800 0.000000
vn -0.907000 0.380500 -0.180400
vn -0.559800 -0.828600 -0.000000
vn -0.380400 -0.921700 -0.075700
vn -0.981000 0.193900 0.000000
vn -0.924800 0.380500 -0.000000
vn -0.387900 -0.921700 -0.000000
vn -0.152700 -0.987800 -0.030400
vn -0.962200 0.193900 -0.191400
vn -0.980800 -0.000000 -0.195100
vn -0.981000 -0.193900 0.000000
vn -1.000000 -0.000000 -0.000000
vn -0.155700 0.987800 -0.000000
vn -0.152700 0.987800 -0.030400
vn -0.380400 0.921700 -0.075700
vn -0.962200 -0.193900 -0.191400
vn -0.907000 -0.380500 -0.180400
vn -0.387900 0.921700 0.000000
vn -0.549000 0.828600 -0.109200
vn -0.833300 -0.552800 0.000000
vn -0.924800 -0.380500 -0.000000
vn -0.559800 0.828600 0.000000
vn -0.817300 -0.552800 -0.162600
vn -0.854400 -0.380500 -0.353900
vn -0.517200 0.828600 -0.214200
vn -0.656100 0.704100 -0.271800
vn -0.769900 -0.552800 -0.318900
vn -0.769900 0.552800 -0.318900
vn -0.656100 -0.704100 -0.271800
vn -0.517200 -0.828600 -0.214200
vn -0.854400 0.380500 -0.353900
vn -0.358400 -0.921700 -0.148400
vn -0.906300 0.193900 -0.375400
vn -0.143800 -0.987800 -0.059600
vn -0.923900 -0.000000 -0.382700
vn -0.906300 -0.193900 -0.375400
vn -0.143800 0.987800 -0.059600
vn -0.358400 0.921700 -0.148400
vn -0.322500 -0.921700 -0.215500
vn -0.129400 -0.987800 -0.086500
vn -0.815700 0.193900 -0.545000
vn -0.831500 0.000000 -0.555600
vn -0.815700 -0.193900 -0.545000
vn -0.129400 0.987800 -0.086500
vn -0.322500 0.921700 -0.215500
vn -0.768900 -0.380500 -0.513800
vn -0.465400 0.828600 -0.311000
vn -0.590500 0.704100 -0.394500
vn -0.692900 -0.552800 -0.463000
vn -0.590500 -0.704100 -0.394500
vn -0.465400 -0.828600 -0.311000
vn -0.692900 0.552800 -0.463000
vn -0.768900 0.380500 -0.513800
vn -0.589300 -0.552800 -0.589300
vn -0.502100 -0.704100 -0.502100
vn -0.502100 0.704100 -0.502100
vn -0.589300 0.552800 -0.589300
vn -0.395800 -0.828600 -0.395800
vn -0.653900 0.380500 -0.653900
vn -0.274300 -0.921700 -0.274300
vn -0.110100 -0.987800 -0.110100
vn -0.693700 0.193900 -0.693700
vn -0.707100 -0.000000 -0.707100
vn -0.693700 -0.193900 -0.693700
vn -0.110100 0.987800 -0.110100
vn -0.274300 0.921700 -0.274300
vn -0.653900 -0.380500 -0.653900
vn -0.395800 0.828600 -0.395800
vn -0.555600 0.000000 -0.831500
vn -0.545000 -0.193900 -0.815700
vn -0.086500 0.987800 -0.129400
vn -0.215500 0.921700 -0.322500
vn -0.513800 -0.380500 -0.768900
vn -0.311000 0.828600 -0.465400
vn -0.394500 0.704100 -0.590500
vn -0.463000 -0.552800 -0.692900
vn -0.463000 0.552800 -0.692900
vn -0.394500 -0.704100 -0.590500
vn -0.311000 -0.828600 -0.465400
vn -0.513800 0.380500 -0.768900
vn -0.215500 -0.921700 -0.322500
vn -0.086500 -0.987800 -0.129400
vn -0.545000 0.193900 -0.815700
vn -0.271800 0.704100 -0.656100
vn -0.318900 0.552800 -0.769900
vn -0.271800 -0.704100 -0.656100
vn -0.353900 0.380500 -0.854400
vn -0.214200 -0.828600 -0.517200
vn -0.148400 -0.921700 -0.358400
vn -0.059600 -0.987800 -0.143800
vn -0.375400 0.193900 -0.906300
vn -0.382700 0.000000 -0.923900
vn -0.059600 0.987800 -0.143800
vn -0.148400 0.921700 -0.358400
vn -0.375400 -0.193900 -0.906300
vn -0.353900 -0.380500 -0.854400
vn -0.214200 0.828600 -0.517200
vn -0.318900 -0.552800 -0.769900
vn -0.195100 -0.000000 -0.980800
vn -0.030400 0.987800 -0.152700
vn -0.075700 0.921700 -0.380400
vn -0.191400 -0.193900 -0.962200
vn -0.180400 -0.380500 -0.907000
vn -0.109200 0.828600 -0.549000
vn -0.138500 0.704100 -0.696500
vn -0.162600 -0.552800 -0.817300
vn -0.138500 -0.704100 -0.696500
vn -0.162600 0.552800 -0.817300
vn -0.180400 0.380500 -0.907000
vn -0.109200 -0.828600 -0.549000
vn -0.075700 -0.921700 -0.380400
vn -0.191400 0.193900 -0.962200
vn -0.000000 -0.704100 -0.710100
vn -0.000000 0.552800 -0.833300
vn 0.000000 0.380500 -0.924800
vn -0.000000 -0.828600 -0.559800
vn -0.030400 -0.987800 -0.152700
vn 0.000000 -0.921700 -0.387900
vn 0.000000 0.193900 -0.981000
vn -0.000000 0.000000 -1.000000
vn -0.000000 -0.193900 -0.981000
vn -0.000000 0.987800 -0.155700
vn -0.000000 0.921700 -0.387900
vn -0.000000 -0.380500 -0.924800
vn -0.000000 0.828600 -0.559800
vn 0.000000 0.704100 -0.710100
vn -0.000000 -0.552800 -0.833300
vn 0.030400 0.987800 -0.152700
vn 0.075700 0.921700 -0.380400
vn 0.191400 -0.193900 -0.962200
vn 0.180400 -0.380500 -0.907000
vn 0.109200 0.828600 -0.549000
vn 0.138500 0.704100 -0.696500
vn 0.162600 -0.552800 -0.817300
vn 0.138500 -0.704100 -0.696500
vn 0.162600 0.552800 -0.817300
vn 0.109200 -0.828600 -0.549000
vn 0.180400 0.380500 -0.907000
vn 0.075700 -0.921700 -0.380400
vn 0.000000 -0.987800 -0.155700
vn 0.191400 0.193900 -0.962200
vn 0.195100 0.000000 -0.980800
vn 0.318900 0.552800 -0.769900
vn 0.353900 0.380500 -0.854400
vn 0.214200 -0.828600 -0.517200
vn 0.148400 -0.921700 -0.358400
vn 0.030400 -0.987800 -0.152700
vn 0.375400 0.193900 -0.906300
vn 0.382700 0.000000 -0.923900
vn 0.059600 0.987800 -0.143800
vn 0.148400 0.921700 -0.358400
vn 0.375400 -0.193900 -0.906300
vn 0.353900 -0.380500 -0.854400
vn 0.214200 0.828600 -0.517200
vn 0.271800 0.704100 -0.656100
vn 0.318900 -0.552800 -0.769900
vn 0.271800 -0.704100 -0.656100
vn 0.545000 -0.193900 -0.815700
vn 0.513800 -0.380500 -0.768900
vn 0.215500 0.921700 -0.322500
vn 0.311000 0.828600 -0.465400
vn 0.394500 0.704100 -0.590500
vn 0.463000 -0.552800 -0.692900
vn 0.394500 -0.704100 -0.590500
vn 0.463000 0.552800 -0.692900
vn 0.513800 0.380500 -0.768900
vn 0.311000 -0.828600 -0.465400
vn 0.059600 -0.987800 -0.143800
vn 0.215500 -0.921700 -0.322500
vn 0.545000 0.193900 -0.815700
vn 0.555600 0.000000 -0.831500
vn 0.086500 0.987800 -0.129400
vn 0.395800 -0.828600 -0.395800
vn 0.653900 0.380500 -0.653900
vn 0.086500 -0.987800 -0.129400
vn 0.274300 -0.921700 -0.274300
vn 0.693700 0.193900 -0.693700
vn 0.707100 0.000000 -0.707100
vn 0.693700 -0.193900 -0.693700
vn 0.110100 0.987800 -0.110100
vn 0.274300 0.921700 -0.274300
vn 0.653900 -0.380500 -0.653900
vn 0.395800 0.828600 -0.395800
vn 0.502100 0.704100 -0.502100
vn 0.589300 -0.552800 -0.589300
vn 0.502100 -0.704100 -0.502100
vn 0.589300 0.552800 -0.589300
vn 0.768900 -0.380500 -0.513800
vn 0.465400 0.828600 -0.311000
vn 0.590500 0.704100 -0.394500
vn 0.692900 -0.552800 -0.463000
vn 0.590500 -0.704100 -0.394500
vn 0.465400 -0.828600 -0.311000
vn 0.692900 0.552800 -0.463000
vn 0.768900 0.380500 -0.513800
vn 0.110100 -0.987800 -0.110100
vn 0.322500 -0.921700 -0.215500
vn 0.815700 0.193900 -0.545000
vn 0.831500 0.000000 -0.555600
vn 0.815700 -0.193900 -0.545000
vn 0.129400 0.987800 -0.086500
vn 0.322500 0.921700 -0.215500
vn 0.129400 -0.987800 -0.086500
vn 0.358400 -0.921700 -0.148400
vn 0.906300 0.193900 -0.375400
vn 0.923900 -0.000000 -0.382700
vn 0.906300 -0.193900 -0.375400
vn 0.143800 0.987800 -0.059600
vn 0.358400 0.921700 -0.148400
vn 0.854400 -0.380500 -0.353900
vn 0.517200 0.828600 -0.214200
vn 0.769900 -0.552800 -0.318900
vn 0.656100 -0.704100 -0.271800
vn 0.656100 0.704100 -0.271800
vn 0.769900 0.552800 -0.318900
vn 0.517200 -0.828600 -0.214200
vn 0.854400 0.380500 -0.353900
vn 0.549000 0.828600 -0.109200
vn 0.817300 -0.552800 -0.162600
vn 0.696500 -0.704100 -0.138500
vn 0.696500 0.704100 -0.138500
vn 0.817300 0.552800 -0.162600
vn 0.549000 -0.828600 -0.109200
vn 0.907000 0.380500 -0.180400
vn 0.380400 -0.921700 -0.075700
vn 0.152700 -0.987800 -0.030400
vn 0.962200 0.193900 -0.191400
vn 0.980800 -0.000000 -0.195100
vn 0.962200 -0.193900 -0.191400
vn 0.152700 0.987800 -0.030400
vn 0.380400 0.921700 -0.075700
vn 0.907000 -0.380500 -0.180400
vn 0.981000 0.193900 0.000000
vn 1.000000 -0.000000 -0.000000
vn 0.155700 0.987800 -0.000000
vn 0.387900 0.921700 0.000000
vn 0.981000 -0.193900 0.000000
vn 0.924800 -0.380500 -0.000000
vn 0.559800 0.828600 -0.000000
vn 0.833300 -0.552800 -0.000000
vn 0.710100 -0.704100 -0.000000
vn 0.710100 0.704100 0.000000
vn 0.833300 0.552800 -0.000000
vn 0.559800 -0.828600 0.000000
vn 0.924800 0.380500 -0.000000
vn 0.387900 -0.921700 -0.000000
vn 0.817300 -0.552800 0.162600
vn 0.696500 -0.704100 0.138500
vn 0.696500 0.704100 0.138500
vn 0.817300 0.552800 0.162600
vn 0.907000 0.380500 0.180400
vn 0.549000 -0.828600 0.109200
vn 0.155700 -0.987800 -0.000000
vn 0.380400 -0.921700 0.075700
vn 0.962200 0.193900 0.191400
vn 0.980800 -0.000000 0.195100
vn 0.962200 -0.193900 0.191400
vn 0.152700 0.987800 0.030400
vn 0.380400 0.921700 0.075700
vn 0.907000 -0.380500 0.180400
vn 0.549000 0.828600 0.109200
vn 0.923900 -0.000000 0.382700
vn 0.906300 -0.193900 0.375400
vn 0.143800 0.987800 0.059600
vn 0.358400 0.921700 0.148400
vn 0.854400 -0.380500 0.353900
vn 0.517200 0.828600 0.214200
vn 0.769900 -0.552800 0.318900
vn 0.656100 -0.704100 0.271800
vn 0.656100 0.704100 0.271800
vn 0.769900 0.552800 0.318900
vn 0.517200 -0.828600 0.214200
vn 0.854400 0.380500 0.353900
vn 0.358400 -0.921700 0.148400
vn 0.152700 -0.987800 0.030400
vn 0.906300 0.193900 0.375400
vn 0.590500 0.704100 0.394500
vn 0.590500 -0.704100 0.394500
vn 0.692900 0.552800 0.463000
vn 0.768900 0.380500 0.513800
vn 0.465400 -0.828600 0.311000
vn 0.322500 -0.921700 0.215500
vn 0.129400 -0.987800 0.086500
vn 0.815700 0.193900 0.545000
vn 0.831500 0.000000 0.555600
vn 0.815700 -0.193900 0.545000
vn 0.129400 0.987800 0.086500
vn 0.322500 0.921700 0.215500
vn 0.768900 -0.380500 0.513800
vn 0.465400 0.828600 0.311000
vn 0.692900 -0.552800 0.463000
vn 0.707100 -0.000000 0.707100
vn 0.693700 -0.193900 0.693700
vn 0.110100 0.987800 0.110100
vn 0.274300 0.921700 0.274300
vn 0.653900 -0.380500 0.653900
vn 0.395800 0.828600 0.395800
vn 0.589300 -0.552800 0.589300
vn 0.502100 -0.704100 0.502100
vn 0.502100 0.704100 0.502100
vn 0.395800 -0.828600 0.395800
vn 0.589300 0.552800 0.589300
vn 0.653900 0.380500 0.653900
vn 0.274300 -0.921700 0.274300
vn 0.693700 0.193900 0.693700
vn 0.394500 -0.704100 0.590500
vn 0.463000 0.552800 0.692900
vn 0.513800 0.380500 0.768900
vn 0.311000 -0.828600 0.465400
vn 0.215500 -0.921700 0.322500
vn 0.086500 -0.987800 0.129400
vn 0.545000 0.193900 0.815700
vn 0.555600 -0.000000 0.831500
vn 0.545000 -0.193900 0.815700
vn 0.086500 0.987800 0.129400
vn 0.215500 0.921700 0.322500
vn 0.513800 -0.380500 0.768900
vn 0.311000 0.828600 0.465400
vn 0.463000 -0.552800 0.692900
vn 0.394500 0.704100 0.590500
vn 0.375400 -0.193900 0.906300
vn 0.353900 -0.380500 0.854400
vn 0.148400 0.921700 0.358400
vn 0.214200 0.828600 0.517200
vn 0.318900 -0.552800 0.769900
vn 0.271800 -0.704100 0.656100
vn 0.271800 0.704100 0.656100
vn 0.318900 0.552800 0.769900
vn 0.214200 -0.828600 0.517200
vn 0.353900 0.380500 0.854400
vn 0.148400 -0.921700 0.358400
vn 0.059600 -0.987800 0.143800
vn 0.375400 0.193900 0.906300
vn 0.382700 -0.000000 0.923900
vn 0.059600 0.987800 0.143800
vn 0.109200 -0.828600 0.549000
vn 0.180400 0.380500 0.907000
vn 0.075700 -0.921700 0.380400
vn 0.030400 -0.987800 0.152700
vn 0.191400 0.193900 0.962200
vn 0.195100 -0.000000 0.980800
vn 0.030400 0.987800 0.152700
vn 0.075700 0.921700 0.380400
vn 0.191400 -0.193900 0.962200
vn 0.180400 -0.380500 0.907000
vn 0.109200 0.828600 0.549000
vn 0.162600 -0.552800 0.817300
vn 0.138500 -0.704100 0.696500
vn 0.138500 0.704100 0.696500
vn 0.162600 0.552800 0.817300
vn 0.000000 0.921700 0.387900
vn -0.000000 0.828600 0.559800
vn 0.000000 -0.380500 0.924800
vn -0.000000 -0.552800 0.833300
vn -0.000000 -0.704100 0.710100
vn -0.000000 0.704100 0.710100
vn -0.000000 -0.828600 0.559800
vn -0.000000 0.552800 0.833300
vn -0.000000 0.380500 0.924800
vn 0.000000 -0.921700 0.387900
vn 0.000000 -0.987800 0.155700
vn 0.000000 0.193900 0.981000
vn 0.000000 -0.000000 1.000000
vn 0.000000 0.987800 0.155700
vn 0.000000 -0.193900 0.981000
vn -0.180400 0.380500 0.907000
vn -0.075700 -0.921700 0.380400
vn -0.030400 -0.987800 0.152700
vn -0.191400 0.193900 0.962200
vn -0.195100 -0.000000 0.980800
vn -0.030400 0.987800 0.152700
vn -0.191400 -0.193900 0.962200
vn -0.180400 -0.380500 0.907000
vn -0.075700 0.921700 0.380400
vn -0.109200 0.828600 0.549000
vn -0.162600 -0.552800 0.817300
vn -0.138500 -0.704100 0.696500
vn -0.138500 0.704100 0.696500
vn -0.109200 -0.828600 0.549000
vn -0.162600 0.552800 0.817300
vn -0.353900 -0.380500 0.854400
vn -0.214200 0.828600 0.517200
vn -0.318900 -0.552800 0.769900
vn -0.271800 -0.704100 0.656100
vn -0.271800 0.704100 0.656100
vn -0.318900 0.552800 0.769900
vn -0.353900 0.380500 0.854400
vn -0.214200 -0.828600 0.517200
vn -0.148400 -0.921700 0.358400
vn -0.059600 -0.987800 0.143800
vn -0.375400 0.193900 0.906300
vn -0.382700 -0.000000 0.923900
vn -0.059600 0.987800 0.143800
vn -0.375400 -0.193900 0.906300
vn -0.148400 0.921700 0.358400
vn -0.215500 -0.921700 0.322500
vn -0.086500 -0.987800 0.129400
vn -0.545000 0.193900 0.815700
vn -0.555600 -0.000000 0.831500
vn -0.545000 -0.193900 0.815700
vn -0.086500 0.987800 0.129400
vn -0.513800 -0.380500 0.768900
vn -0.215500 0.921700 0.322500
vn -0.311000 0.828600 0.465400
vn -0.394500 0.704100 0.590500
vn -0.463000 -0.552800 0.692900
vn -0.394500 -0.704100 0.590500
vn -0.311000 -0.828600 0.465400
vn -0.463000 0.552800 0.692900
vn -0.513800 0.380500 0.768900
vn -0.395800 0.828600 0.395800
vn -0.502100 0.704100 0.502100
vn -0.589300 -0.552800 0.589300
vn -0.502100 -0.704100 0.502100
vn -0.395800 -0.828600 0.395800
vn -0.589300 0.552800 0.589300
vn -0.653900 0.380500 0.653900
vn -0.274300 -0.921700 0.274300
vn -0.110100 -0.987800 0.110100
vn -0.693700 0.193900 0.693700
vn -0.707100 -0.000000 0.707100
vn -0.693700 -0.193900 0.693700
vn -0.110100 0.987800 0.110100
vn -0.274300 0.921700 0.274300
vn -0.653900 -0.380500 0.653900
vn -0.815700 0.193900 0.545000
vn -0.831500 -0.000000 0.555600
vn -0.815700 -0.193900 0.545000
vn -0.129400 0.987800 0.086500
vn -0.322500 0.921700 0.215500
vn -0.768900 -0.380500 0.513800
vn -0.465400 0.828600 0.311000
vn -0.590500 0.704100 0.394500
vn -0.692900 -0.552800 0.463000
vn -0.590500 -0.704100 0.394500
vn -0.692900 0.552800 0.463000
vn -0.768900 0.380500 0.513800
vn -0.465400 -0.828600 0.311000
vn -0.322500 -0.921700 0.215500
vn -0.129400 -0.987800 0.086500
vn -0.769900 -0.552800 0.318900
vn -0.656100 -0.704100 0.271800
vn -0.656100 0.704100 0.271800
vn -0.517200 -0.828600 0.214200
vn -0.769900 0.552800 0.318900
vn -0.854400 0.380500 0.353900
vn -0.358400 -0.921700 0.148400
vn -0.143800 -0.987800 0.059600
vn -0.906300 0.193900 0.375400
vn -0.923900 -0.000000 0.382700
vn -0.143800 0.987800 0.059600
vn -0.906300 -0.193900 0.375400
vn -0.854400 -0.380500 0.353900
vn -0.358400 0.921700 0.148400
vn -0.517200 0.828600 0.214200
vn -0.980800 -0.000000 0.195100
vn -0.962200 -0.193900 0.191400
vn -0.152700 0.987800 0.030400
vn -0.380400 0.921700 0.075700
vn -0.907000 -0.380500 0.180400
vn -0.549000 0.828600 0.109200
vn -0.817300 -0.552800 0.162600
vn -0.696500 -0.704100 0.138500
vn -0.696500 0.704100 0.138500
vn -0.549000 -0.828600 0.109200
vn -0.817300 0.552800 0.162600
vn -0.907000 0.380500 0.180400
vn -0.380400 -0.921700 0.075700
vn -0.152700 -0.987800 0.030400
vn -0.962200 0.193900 0.191400
vn -0.155700 -0.987800 0.000000
vn 0.143800 -0.987800 0.059600
vn 0.000000 -1.000000 0.000000
vn -0.000000 -1.000000 0.000100
vn 0.000000 0.728200 0.685400
vn 0.000000 0.728100 0.685400
vn 0.143800 -0.987800 -0.059600
vn 0.110100 -0.987800 0.110100
vn 0.000000 0.683900 0.729500
vn 0.000000 0.683900 0.729600
vn 0.000000 -0.062400 0.998100
vn 0.000000 -0.041300 0.660300
vn 0.000000 -0.062400 0.998000
vn 0.000000 -0.044300 0.708700
vn 0.000000 -0.044300 0.708300
vn 0.000000 -0.047500 0.759500
vn 0.000000 -0.046800 0.748400
vn 0.000000 0.683800 0.729600
vn 0.000000 0.684000 0.729500
vn 0.000000 0.039800 0.636300
vn 0.000000 0.046800 0.748400
vn 0.000000 0.041300 0.660300
vn 0.000000 0.062400 0.998100
vn 0.000000 0.050700 0.811700
vn 0.000000 -0.059800 -0.956700
vn 0.000000 0.062400 0.998000
vn 0.000000 -0.003900 -0.061800
vn 0.000000 0.062400 0.997900
vn 0.000000 0.002000 0.032200
vn 0.000000 0.038500 0.615300
vn 0.000000 -0.000000 -0.000000
vn 0.000000 0.049400 0.790700
usemtl Mars
s 1
f 1/1/1 2/2/2 3/3/3
f 4/4/4 5/5/5 6/6/6
f 7/7/7 3/3/3 8/8/8
f 9/9/9 6/6/6 10/10/10
f 11/11/11 12/12/12 8/8/8
f 13/13/13 10/10/10 14/14/14
f 11/11/11 15/15/15 16/16/16
f 17/17/17 18/18/18 16/16/16
f 19/19/19 20/20/20 21/21/21
f 17/17/17 22/22/22 23/23/23
f 24/24/24 21/21/21 25/25/25
f 26/26/26 27/27/27 23/23/23
f 28/28/28 25/25/25 2/2/2
f 4/4/4 26/26/26 29/29/29
f 29/29/29 23/23/23 30/30/30
f 25/25/25 31/31/31 32/32/32
f 5/5/5 29/29/29 33/33/33
f 2/2/2 32/32/32 34/34/34
f 5/5/5 35/35/35 36/36/36
f 3/3/3 34/34/34 37/37/37
f 6/6/6 36/36/36 38/38/38
f 8/8/8 37/37/37 39/39/39
f 10/10/10 38/38/38 40/40/40
f 15/15/15 39/39/39 41/41/41
f 16/16/16 41/41/41 42/42/42
f 21/21/21 20/20/20 43/43/43
f 23/23/23 22/22/22 42/42/42
f 21/21/21 44/44/44 31/31/31
f 38/38/38 45/45/45 46/46/46
f 39/39/39 47/47/47 48/48/48
f 41/41/41 48/48/48 49/49/49
f 43/43/43 50/50/50 51/51/51
f 42/42/42 49/49/49 52/52/52
f 44/44/44 51/51/51 53/53/53
f 33/33/33 30/30/30 52/52/52
f 31/31/31 53/53/53 54/54/54
f 33/33/33 55/55/55 56/56/56
f 34/34/34 32/32/32 54/54/54
f 35/35/35 56/56/56 57/57/57
f 34/34/34 58/58/58 59/59/59
f 36/36/36 57/57/57 45/45/45
f 37/37/37 59/59/59 47/47/47
f 55/55/55 60/60/60 61/61/61
f 54/54/54 62/62/62 63/63/63
f 56/56/56 61/61/61 64/64/64
f 58/58/58 63/63/63 65/65/65
f 57/57/57 64/64/64 66/66/66
f 47/47/47 59/59/59 65/65/65
f 45/45/45 66/66/66 67/67/67
f 47/47/47 68/68/68 69/69/69
f 48/48/48 69/69/69 70/70/70
f 50/50/50 71/71/71 72/72/72
f 49/49/49 70/70/70 73/73/73
f 53/53/53 51/51/51 72/72/72
f 55/55/55 52/52/52 73/73/73
f 53/53/53 74/74/74 62/62/62
f 69/69/69 75/75/75 76/76/76
f 71/71/71 77/77/77 78/78/78
f 70/70/70 76/76/76 79/79/79
f 72/72/72 78/78/78 80/80/80
f 60/60/60 73/73/73 79/79/79
f 74/74/74 80/80/80 81/81/81
f 61/61/61 60/60/60 82/82/82
f 62/62/62 81/81/81 83/83/83
f 61/61/61 84/84/84 85/85/85
f 63/63/63 83/83/83 86/86/86
f 64/64/64 85/85/85 87/87/87
f 68/68/68 65/65/65 86/86/86
f 66/66/66 87/87/87 88/88/88
f 69/69/69 68/68/68 89/89/89
f 81/81/81 90/90/90 91/91/91
f 85/85/85 84/84/84 92/92/92
f 83/83/83 91/91/91 93/93/93
f 85/85/85 94/94/94 95/95/95
f 89/89/89 86/86/86 93/93/93
f 87/87/87 95/95/95 96/96/96
f 89/89/89 97/97/97 98/98/98
f 76/76/76 75/75/75 98/98/98
f 77/77/77 99/99/99 100/100/100
f 76/76/76 101/101/101 102/102/102
f 78/78/78 100/100/100 103/103/103
f 82/82/82 79/79/79 102/102/102
f 80/80/80 103/103/103 90/90/90
f 84/84/84 82/82/82 104/104/104
f 101/101/101 98/98/98 105/105/105
f 99/99/99 106/106/106 107/107/107
f 101/101/101 108/108/108 109/109/109
f 100/100/100 107/107/107 110/110/110
f 104/104/104 102/102/102 109/109/109
f 103/103/103 110/110/110 111/111/111
f 104/104/104 112/112/112 113/113/113
f 90/90/90 111/111/111 114/114/114
f 94/94/94 92/92/92 113/113/113
f 91/91/91 114/114/114 115/115/115
f 94/94/94 116/116/116 117/117/117
f 97/97/97 93/93/93 115/115/115
f 96/96/96 95/95/95 117/117/117
f 97/97/97 118/118/118 105/105/105
f 116/116/116 113/113/113 119/119/119
f 114/114/114 120/120/120 121/121/121
f 117/117/117 116/116/116 122/122/122
f 118/118/118 115/115/115 121/121/121
f 123/123/123 117/117/117 124/124/124
f 118/118/118 125/125/125 126/126/126
f 105/105/105 126/126/126 127/127/127
f 106/106/106 128/128/128 129/129/129
f 108/108/108 127/127/127 130/130/130
f 107/107/107 129/129/129 131/131/131
f 112/112/112 109/109/109 130/130/130
f 110/110/110 131/131/131 132/132/132
f 112/112/112 133/133/133 119/119/119
f 111/111/111 132/132/132 120/120/120
f 128/128/128 134/134/134 135/135/135
f 127/127/127 136/136/136 137/137/137
f 131/131/131 129/129/129 135/135/135
f 133/133/133 130/130/130 137/137/137
f 131/131/131 138/138/138 139/139/139
f 133/133/133 140/140/140 141/141/141
f 132/132/132 139/139/139 142/142/142
f 119/119/119 141/141/141 143/143/143
f 120/120/120 142/142/142 144/144/144
f 122/122/122 143/143/143 145/145/145
f 125/125/125 121/121/121 144/144/144
f 146/146/146 124/124/124 145/145/145
f 125/125/125 147/147/147 148/148/148
f 126/126/126 148/148/148 136/136/136
f 142/142/142 149/149/149 150/150/150
f 143/143/143 151/151/151 152/152/152
f 147/147/147 144/144/144 150/150/150
f 153/153/153 145/145/145 152/152/152
f 147/147/147 154/154/154 155/155/155
f 136/136/136 148/148/148 155/155/155
f 134/134/134 156/156/156 157/157/157
f 136/136/136 158/158/158 159/159/159
f 135/135/135 157/157/157 160/160/160
f 140/140/140 137/137/137 159/159/159
f 138/138/138 160/160/160 161/161/161
f 140/140/140 162/162/162 163/163/163
f 142/142/142 139/139/139 161/161/161
f 143/143/143 141/141/141 163/163/163
f 158/158/158 164/164/164 165/165/165
f 157/157/157 166/166/166 167/167/167
f 162/162/162 159/159/159 165/165/165
f 160/160/160 167/167/167 168/168/168
f 162/162/162 169/169/169 170/170/170
f 149/149/149 161/161/161 168/168/168
f 151/151/151 163/163/163 170/170/170
f 149/149/149 171/171/171 172/172/172
f 152/152/152 151/151/151 173/173/173
f 154/154/154 150/150/150 172/172/172
f 174/174/174 152/152/152 175/175/175
f 154/154/154 176/176/176 177/177/177
f 158/158/158 155/155/155 177/177/177
f 156/156/156 178/178/178 166/166/166
f 175/175/175 173/173/173 179/179/179
f 176/176/176 172/172/172 180/180/180
f 181/181/181 175/175/175 182/182/182
f 177/177/177 176/176/176 183/183/183
f 177/177/177 184/184/184 185/185/185
f 178/178/178 186/186/186 187/187/187
f 164/164/164 185/185/185 188/188/188
f 166/166/166 187/187/187 189/189/189
f 169/169/169 165/165/165 188/188/188
f 167/167/167 189/189/189 190/190/190
f 169/169/169 191/191/191 192/192/192
f 168/168/168 190/190/190 193/193/193
f 173/173/173 170/170/170 192/192/192
f 171/171/171 193/193/193 180/180/180
f 191/191/191 188/188/188 194/194/194
f 189/189/189 195/195/195 196/196/196
f 191/191/191 197/197/197 198/198/198
f 193/193/193 190/190/190 196/196/196
f 192/192/192 198/198/198 199/199/199
f 193/193/193 200/200/200 201/201/201
f 182/182/182 179/179/179 199/199/199
f 183/183/183 180/180/180 201/201/201
f 202/202/202 182/182/182 203/203/203
f 184/184/184 183/183/183 204/204/204
f 184/184/184 205/205/205 206/206/206
f 186/186/186 207/207/207 208/208/208
f 185/185/185 206/206/206 194/194/194
f 187/187/187 208/208/208 195/195/195
f 209/209/209 203/203/203 210/210/210
f 205/205/205 204/204/204 211/211/211
f 205/205/205 212/212/212 213/213/213
f 207/207/207 214/214/214 215/215/215
f 206/206/206 213/213/213 216/216/216
f 208/208/208 215/215/215 217/217/217
f 197/197/197 194/194/194 216/216/216
f 196/196/196 195/195/195 217/217/217
f 197/197/197 218/218/218 219/219/219
f 196/196/196 220/220/220 221/221/221
f 198/198/198 219/219/219 222/222/222
f 200/200/200 221/221/221 223/223/223
f 203/203/203 199/199/199 222/222/222
f 204/204/204 201/201/201 223/223/223
f 220/220/220 217/217/217 224/224/224
f 218/218/218 225/225/225 226/226/226
f 220/220/220 227/227/227 228/228/228
f 219/219/219 226/226/226 229/229/229
f 221/221/221 228/228/228 230/230/230
f 222/222/222 229/229/229 231/231/231
f 211/211/211 223/223/223 230/230/230
f 210/210/210 231/231/231 232/232/232
f 211/211/211 233/233/233 234/234/234
f 212/212/212 234/234/234 235/235/235
f 214/214/214 236/236/236 237/237/237
f 213/213/213 235/235/235 238/238/238
f 215/215/215 237/237/237 224/224/224
f 218/218/218 216/216/216 238/238/238
f 233/233/233 239/239/239 240/240/240
f 235/235/235 234/234/234 240/240/240
f 236/236/236 241/241/241 242/242/242
f 235/235/235 243/243/243 244/244/244
f 237/237/237 242/242/242 245/245/245
f 225/225/225 238/238/238 244/244/244
f 227/227/227 224/224/224 245/245/245
f 225/225/225 246/246/246 247/247/247
f 227/227/227 248/248/248 249/249/249
f 226/226/226 247/247/247 250/250/250
f 228/228/228 249/249/249 251/251/251
f 231/231/231 229/229/229 250/250/250
f 233/233/233 230/230/230 251/251/251
f 232/232/232 231/231/231 252/252/252
f 246/246/246 253/253/253 254/254/254
f 248/248/248 255/255/255 256/256/256
f 250/250/250 247/247/247 254/254/254
f 249/249/249 256/256/256 257/257/257
f 252/252/252 250/250/250 258/258/258
f 239/239/239 251/251/251 257/257/257
f 259/259/259 252/252/252 260/260/260
f 239/239/239 261/261/261 262/262/262
f 240/240/240 262/262/262 263/263/263
f 241/241/241 264/264/264 265/265/265
f 243/243/243 263/263/263 266/266/266
f 242/242/242 265/265/265 267/267/267
f 246/246/246 244/244/244 266/266/266
f 245/245/245 267/267/267 255/255/255
f 262/262/262 268/268/268 269/269/269
f 264/264/264 270/270/270 271/271/271
f 263/263/263 269/269/269 272/272/272
f 265/265/265 271/271/271 273/273/273
f 253/253/253 266/266/266 272/272/272
f 255/255/255 267/267/267 273/273/273
f 253/253/253 274/274/274 275/275/275
f 255/255/255 276/276/276 277/277/277
f 254/254/254 275/275/275 278/278/278
f 256/256/256 277/277/277 279/279/279
f 258/258/258 278/278/278 280/280/280
f 261/261/261 257/257/257 279/279/279
f 281/281/281 260/260/260 280/280/280
f 261/261/261 282/282/282 268/268/268
f 277/277/277 276/276/276 283/283/283
f 278/278/278 275/275/275 284/284/284
f 277/277/277 285/285/285 286/286/286
f 280/280/280 278/278/278 287/287/287
f 282/282/282 279/279/279 286/286/286
f 280/280/280 288/288/288 289/289/289
f 282/282/282 290/290/290 291/291/291
f 268/268/268 291/291/291 292/292/292
f 270/270/270 293/293/293 294/294/294
f 269/269/269 292/292/292 295/295/295
f 271/271/271 294/294/294 296/296/296
f 274/274/274 272/272/272 295/295/295
f 276/276/276 273/273/273 296/296/296
f 274/274/274 297/297/297 284/284/284
f 291/291/291 298/298/298 299/299/299
f 293/293/293 300/300/300 301/301/301
f 292/292/292 299/299/299 302/302/302
f 294/294/294 301/301/301 303/303/303
f 297/297/297 295/295/295 302/302/302
f 283/283/283 296/296/296 303/303/303
f 297/297/297 304/304/304 305/305/305
f 285/285/285 283/283/283 306/306/306
f 284/284/284 305/305/305 307/307/307
f 285/285/285 308/308/308 309/309/309
f 288/288/288 287/287/287 307/307/307
f 290/290/290 286/286/286 309/309/309
f 289/289/289 288/288/288 310/310/310
f 291/291/291 290/290/290 311/311/311
f 307/307/307 305/305/305 312/312/312
f 308/308/308 313/313/313 314/314/314
f 310/310/310 307/307/307 315/315/315
f 311/311/311 309/309/309 314/314/314
f 310/310/310 316/316/316 317/317/317
f 311/311/311 318/318/318 319/319/319
f 298/298/298 319/319/319 320/320/320
f 300/300/300 321/321/321 322/322/322
f 299/299/299 320/320/320 323/323/323
f 301/301/301 322/322/322 324/324/324
f 304/304/304 302/302/302 323/323/323
f 306/306/306 303/303/303 324/324/324
f 304/304/304 325/325/325 312/312/312
f 308/308/308 306/306/306 326/326/326
f 320/320/320 327/327/327 328/328/328
f 322/322/322 329/329/329 330/330/330
f 325/325/325 323/323/323 328/328/328
f 326/326/326 324/324/324 330/330/330
f 325/325/325 331/331/331 332/332/332
f 326/326/326 333/333/333 334/334/334
f 312/312/312 332/332/332 335/335/335
f 313/313/313 334/334/334 336/336/336
f 316/316/316 315/315/315 335/335/335
f 318/318/318 314/314/314 336/336/336
f 316/316/316 337/337/337 338/338/338
f 318/318/318 339/339/339 340/340/340
f 319/319/319 340/340/340 327/327/327
f 321/321/321 341/341/341 329/329/329
f 337/337/337 335/335/335 342/342/342
f 339/339/339 336/336/336 343/343/343
f 337/337/337 344/344/344 345/345/345
f 339/339/339 346/346/346 347/347/347
f 327/327/327 340/340/340 347/347/347
f 341/341/341 348/348/348 349/349/349
f 327/327/327 350/350/350 351/351/351
f 329/329/329 349/349/349 352/352/352
f 331/331/331 328/328/328 351/351/351
f 333/333/333 330/330/330 352/352/352
f 331/331/331 353/353/353 354/354/354
f 334/334/334 333/333/333 355/355/355
f 332/332/332 354/354/354 342/342/342
f 334/334/334 356/356/356 343/343/343
f 349/349/349 357/357/357 358/358/358
f 353/353/353 351/351/351 359/359/359
f 355/355/355 352/352/352 358/358/358
f 353/353/353 360/360/360 361/361/361
f 356/356/356 355/355/355 362/362/362
f 354/354/354 361/361/361 363/363/363
f 356/356/356 364/364/364 365/365/365
f 344/344/344 342/342/342 363/363/363
f 346/346/346 343/343/343 365/365/365
f 344/344/344 366/366/366 367/367/367
f 346/346/346 368/368/368 369/369/369
f 350/350/350 347/347/347 369/369/369
f 349/349/349 348/348/348 370/370/370
f 350/350/350 371/371/371 359/359/359
f 368/372/368 365/373/365 372/374/372
f 366/375/366 373/376/373 374/377/374
f 368/372/368 375/378/375 376/379/376
f 371/380/371 369/381/369 376/379/376
f 357/382/357 370/383/370 377/384/377
f 371/380/371 378/385/378 379/386/379
f 357/382/357 380/387/380 381/388/381
f 360/389/360 359/390/359 379/386/379
f 362/391/362 358/392/358 381/388/381
f 360/389/360 382/393/382 383/394/383
f 364/395/364 362/391/362 384/396/384
f 361/397/361 383/394/383 385/398/385
f 364/395/364 386/399/386 372/374/372
f 363/400/363 385/398/385 373/376/373
f 382/393/382 379/386/379 387/401/387
f 384/396/384 381/388/381 388/402/388
f 382/393/382 389/403/389 390/404/390
f 384/396/384 391/405/391 392/406/392
f 385/398/385 383/394/383 390/404/390
f 386/399/386 392/406/392 393/407/393
f 385/398/385 394/408/394 395/409/395
f 375/378/375 372/374/372 393/407/393
f 373/376/373 395/409/395 396/410/396
f 376/379/376 375/378/375 397/411/397
f 378/385/378 376/379/376 398/412/398
f 380/387/380 377/384/377 399/413/399
f 378/385/378 400/414/400 387/401/387
f 381/388/381 380/387/380 401/415/401
f 395/409/395 402/416/402 403/417/403
f 397/411/397 404/418/404 405/419/405
f 398/412/398 405/419/405 406/420/406
f 401/415/401 399/413/399 407/421/407
f 400/414/400 406/420/406 408/422/408
f 401/415/401 409/423/409 410/424/410
f 389/403/389 387/401/387 408/422/408
f 388/402/388 410/424/410 411/425/411
f 389/403/389 412/426/412 413/427/413
f 392/406/392 391/405/391 411/425/411
f 390/404/390 413/427/413 414/428/414
f 392/406/392 415/429/415 416/430/416
f 395/409/395 394/408/394 414/428/414
f 397/411/397 393/407/393 416/430/416
f 410/424/410 417/431/417 418/432/418
f 412/426/412 419/433/419 420/434/420
f 415/429/415 411/425/411 418/432/418
f 413/427/413 420/434/420 421/435/421
f 415/429/415 422/436/422 423/437/423
f 414/428/414 421/435/421 424/438/424
f 404/418/404 416/430/416 423/437/423
f 402/416/402 424/438/424 425/439/425
f 404/418/404 426/440/426 427/441/427
f 405/419/405 427/441/427 428/442/428
f 407/421/407 429/443/429 430/444/430
f 406/420/406 428/442/428 431/445/431
f 409/423/409 430/444/430 417/431/417
f 412/426/412 408/422/408 431/445/431
f 426/440/426 432/446/432 433/447/433
f 427/441/427 433/447/433 434/448/434
f 429/443/429 435/449/435 436/450/436
f 428/442/428 434/448/434 437/451/437
f 430/444/430 436/450/436 438/452/438
f 419/433/419 431/445/431 437/451/437
f 417/431/417 438/452/438 439/453/439
f 419/433/419 440/454/440 441/455/441
f 422/436/422 418/432/418 439/453/439
f 421/435/421 420/434/420 441/455/441
f 422/436/422 442/456/442 443/457/443
f 421/435/421 444/458/444 445/459/445
f 426/440/426 423/437/423 443/457/443
f 424/438/424 445/459/445 446/460/446
f 440/454/440 447/461/447 448/462/448
f 442/456/442 439/453/439 449/463/449
f 441/455/441 448/462/448 450/464/450
f 442/456/442 451/465/451 452/466/452
f 444/458/444 450/464/450 453/467/453
f 432/446/432 443/457/443 452/466/452
f 445/459/445 453/467/453 454/468/454
f 432/446/432 455/469/455 456/470/456
f 434/448/434 433/447/433 456/470/456
f 436/450/436 435/449/435 457/471/457
f 434/448/434 458/472/458 459/473/459
f 438/452/438 436/450/436 460/474/460
f 440/454/440 437/451/437 459/473/459
f 439/453/439 438/452/438 461/475/461
f 456/470/456 462/476/462 463/477/463
f 457/471/457 464/478/464 465/479/465
f 458/472/458 463/477/463 466/480/466
f 460/474/460 465/479/465 467/481/467
f 447/461/447 459/473/459 466/480/466
f 449/463/449 461/475/461 467/481/467
f 447/461/447 468/482/468 469/483/469
f 451/465/451 449/463/449 470/484/470
f 448/462/448 469/483/469 471/485/471
f 451/465/451 472/486/472 473/487/473
f 450/464/450 471/485/471 474/488/474
f 455/469/455 452/466/452 473/487/473
f 453/467/453 474/488/474 475/489/475
f 455/469/455 476/490/476 462/476/462
f 469/483/469 4/4/4 9/9/9
f 473/487/473 472/486/472 7/7/7
f 471/485/471 9/9/9 13/13/13
f 476/490/476 473/487/473 12/12/12
f 474/488/474 13/13/13 477/491/477
f 462/476/462 476/490/476 11/11/11
f 462/476/462 18/18/18 17/17/17
f 465/479/465 464/478/464 19/19/19
f 463/477/463 17/17/17 27/27/27
f 467/481/467 465/479/465 24/24/24
f 466/480/466 27/27/27 26/26/26
f 470/484/470 467/481/467 28/28/28
f 468/482/468 26/26/26 4/4/4
f 472/486/472 470/484/470 1/1/1
f 478/492/478 479/493/479 480/494/479
f 367/367/367 481/495/479 482/496/480
f 77/77/77 483/497/481 484/498/481
f 128/128/128 485/499/481 486/500/481
f 236/236/236 214/214/214 487/501/481
f 399/413/399 488/502/481 489/503/481
f 370/370/370 348/348/348 490/504/481
f 146/146/146 491/505/479 492/506/479
f 475/489/475 477/491/477 493/507/479
f 281/281/281 480/494/479 494/508/479
f 396/410/396 495/509/480 496/510/479
f 128/128/128 106/106/106 497/511/481
f 435/449/435 429/443/429 498/512/481
f 464/478/464 499/513/481 500/514/481
f 264/264/264 241/241/241 501/515/481
f 446/460/446 502/516/479 503/517/480
f 377/384/377 504/518/481 488/502/481
f 300/300/300 293/293/293 505/519/482
f 153/153/153 174/174/174 506/520/480
f 123/123/123 492/506/479 507/521/480
f 289/289/289 508/522/479 479/493/479
f 475/489/475 509/523/479 510/524/480
f 46/46/46 511/525/479 512/526/480
f 403/417/403 425/439/425 503/517/480
f 156/156/156 134/134/134 486/500/481
f 270/270/270 513/527/481 505/519/482
f 14/14/14 514/528/480 493/507/479
f 429/443/429 407/421/407 489/503/481
f 202/202/202 515/529/480 516/530/479
f 19/19/19 500/514/481 517/531/481
f 146/146/146 153/153/153 518/532/479
f 457/471/457 519/533/481 499/513/481
f 317/317/317 520/534/479 521/535/480
f 43/43/43 522/536/482 523/537/481
f 524/538/483 525/539/479 526/540/479
f 454/468/454 510/524/480 502/516/479
f 178/178/178 527/541/481 528/542/481
f 71/71/71 529/543/481 483/497/481
f 300/300/300 530/544/481 531/545/481
f 88/88/88 532/546/479 533/547/480
f 435/449/435 534/548/481 519/533/481
f 40/40/40 512/526/480 514/528/480
f 345/345/345 482/496/480 535/549/480
f 181/181/181 516/530/479 506/520/480
f 214/214/214 207/207/207 536/550/481
f 537/551/484 521/535/480 508/522/479
f 20/20/20 517/531/481 522/536/482
f 341/341/341 538/552/481 490/504/481
f 156/156/156 539/553/481 527/541/481
f 67/67/67 533/547/480 511/525/479
f 367/554/367 374/377/374 496/510/479
f 202/202/202 209/209/209 526/540/479
f 236/236/236 540/555/482 501/515/481
f 338/338/338 535/549/480 520/534/479
f 71/71/71 50/50/50 523/537/481
f 232/232/232 259/259/259 494/508/479
f 207/207/207 186/186/186 528/542/481
f 370/383/370 541/556/481 504/518/481
f 106/106/106 99/99/99 484/498/481
f 403/417/403 542/557/479 495/509/480
f 341/341/341 321/321/321 531/545/481
f 96/96/96 507/521/480 532/546/479
f 264/264/264 543/558/481 513/527/481
f 232/232/232 544/559/479 525/539/479
f 486/500/481 485/499/481 545/499/485
f 527/541/481 539/553/481 546/553/486
f 503/517/480 502/516/479 547/516/487
f 480/494/479 479/493/479 548/493/487
f 514/528/480 512/526/480 549/526/487
f 481/560/479 496/510/479 550/510/488
f 534/548/481 498/512/481 551/512/486
f 499/513/481 519/533/481 552/533/486
f 520/534/479 535/549/480 553/549/489
f 513/527/481 543/558/481 554/558/485
f 540/555/482 487/501/481 555/501/486
f 506/520/480 516/530/479 556/530/487
f 525/539/479 544/559/479 557/559/489
f 510/524/480 509/523/479 558/523/489
f 485/499/481 497/511/481 559/511/485
f 529/543/481 523/537/481 560/537/485
f 492/506/479 491/505/479 561/505/487
f 511/525/479 533/547/480 562/547/487
f 498/512/481 489/503/481 563/503/485
f 541/561/481 490/504/481 564/504/485
f 542/557/479 503/517/480 565/517/487
f 482/496/480 481/495/479 566/495/487
f 517/531/481 500/514/481 567/514/486
f 543/558/481 501/515/481 568/515/485
f 493/507/479 514/528/480 569/528/490
f 494/508/479 480/494/479 570/494/491
f 531/545/481 530/544/481 571/544/486
f 539/553/481 486/500/481 572/500/485
f 521/535/480 520/534/479 573/534/487
f 518/532/479 506/520/480 574/520/489
f 515/529/480 526/540/479 575/540/487
f 487/501/481 536/550/481 576/550/486
f 519/533/481 534/548/481 577/548/485
f 484/498/481 483/497/481 578/497/485
f 507/521/480 492/506/479 579/506/489
f 502/516/479 510/524/480 580/524/487
f 496/510/479 495/509/480 581/509/492
f 489/503/481 488/502/481 582/502/486
f 523/537/481 522/536/482 583/536/486
f 505/519/482 513/527/481 584/527/486
f 497/511/481 484/498/481 585/498/486
f 490/504/481 538/552/481 586/552/486
f 479/493/479 508/522/479 587/522/487
f 526/540/479 525/539/479 588/539/487
f 544/559/479 494/508/479 589/508/493
f 528/542/481 527/541/481 590/541/485
f 508/522/479 521/535/480 591/535/487
f 512/526/480 511/525/479 592/525/487
f 533/547/480 532/546/479 593/546/487
f 536/550/481 528/542/481 594/542/486
f 501/515/481 540/555/482 595/555/485
f 500/514/481 499/513/481 596/513/486
f 495/509/480 542/557/479 597/557/487
f 522/536/482 517/531/481 598/531/494
f 504/518/481 541/556/481 599/556/485
f 530/544/481 505/519/482 600/519/495
f 535/549/480 482/496/480 601/496/489
f 516/530/479 515/529/480 602/529/487
f 532/546/479 507/521/480 603/521/489
f 491/505/479 518/532/479 604/532/489
f 509/523/479 493/507/479 605/507/488
f 488/502/481 504/518/481 606/518/486
f 538/552/481 531/545/481 607/545/486
f 483/497/481 529/543/481 608/543/486
f 552/533/486 577/548/485 609/548/496
f 598/531/494 567/514/486 610/514/497
f 600/519/495 584/527/486 611/527/498
f 578/497/485 608/543/486 612/543/499
f 555/501/486 576/550/486 613/550/500
f 545/499/485 559/511/485 614/511/499
f 596/513/486 552/533/486 615/533/501
f 554/558/485 568/515/485 616/515/498
f 571/544/486 600/519/495 617/519/502
f 577/548/485 551/512/486 618/512/499
f 560/537/485 583/536/486 619/536/497
f 595/555/485 555/501/486 620/501/503
f 594/542/486 590/541/485 621/541/504
f 563/503/485 582/502/486 622/502/504
f 599/561/485 564/504/485 623/504/499
f 576/550/486 594/542/486 624/542/499
f 584/527/486 554/558/485 625/558/498
f 606/518/486 599/556/485 626/556/499
f 586/552/486 607/545/486 627/545/500
f 583/536/486 598/531/494 628/531/497
f 551/512/486 563/503/485 629/503/502
f 590/541/485 546/553/486 630/553/502
f 585/498/486 578/497/485 631/497/496
f 546/553/486 572/500/485 632/500/499
f 567/514/486 596/513/486 633/513/505
f 564/504/485 586/552/486 634/552/506
f 572/500/485 545/499/485 635/499/499
f 568/515/485 595/555/485 636/555/507
f 582/502/486 606/518/486 637/518/499
f 559/511/485 585/498/486 638/498/508
f 608/543/486 560/537/485 639/537/504
f 607/545/486 571/544/486 640/544/499
f 7/7/7 1/1/1 3/3/3
f 9/9/9 4/4/4 6/6/6
f 12/12/12 7/7/7 8/8/8
f 13/13/13 9/9/9 10/10/10
f 15/15/15 11/11/11 8/8/8
f 477/491/477 13/13/13 14/14/14
f 18/18/18 11/11/11 16/16/16
f 22/22/22 17/17/17 16/16/16
f 24/24/24 19/19/19 21/21/21
f 27/27/27 17/17/17 23/23/23
f 28/28/28 24/24/24 25/25/25
f 29/29/29 26/26/26 23/23/23
f 1/1/1 28/28/28 2/2/2
f 5/5/5 4/4/4 29/29/29
f 33/33/33 29/29/29 30/30/30
f 2/2/2 25/25/25 32/32/32
f 35/35/35 5/5/5 33/33/33
f 3/3/3 2/2/2 34/34/34
f 6/6/6 5/5/5 36/36/36
f 8/8/8 3/3/3 37/37/37
f 10/10/10 6/6/6 38/38/38
f 15/15/15 8/8/8 39/39/39
f 14/14/14 10/10/10 40/40/40
f 16/16/16 15/15/15 41/41/41
f 22/22/22 16/16/16 42/42/42
f 44/44/44 21/21/21 43/43/43
f 30/30/30 23/23/23 42/42/42
f 25/25/25 21/21/21 31/31/31
f 40/40/40 38/38/38 46/46/46
f 41/41/41 39/39/39 48/48/48
f 42/42/42 41/41/41 49/49/49
f 44/44/44 43/43/43 51/51/51
f 30/30/30 42/42/42 52/52/52
f 31/31/31 44/44/44 53/53/53
f 55/55/55 33/33/33 52/52/52
f 32/32/32 31/31/31 54/54/54
f 35/35/35 33/33/33 56/56/56
f 58/58/58 34/34/34 54/54/54
f 36/36/36 35/35/35 57/57/57
f 37/37/37 34/34/34 59/59/59
f 38/38/38 36/36/36 45/45/45
f 39/39/39 37/37/37 47/47/47
f 56/56/56 55/55/55 61/61/61
f 58/58/58 54/54/54 63/63/63
f 57/57/57 56/56/56 64/64/64
f 59/59/59 58/58/58 65/65/65
f 45/45/45 57/57/57 66/66/66
f 68/68/68 47/47/47 65/65/65
f 46/46/46 45/45/45 67/67/67
f 48/48/48 47/47/47 69/69/69
f 49/49/49 48/48/48 70/70/70
f 51/51/51 50/50/50 72/72/72
f 52/52/52 49/49/49 73/73/73
f 74/74/74 53/53/53 72/72/72
f 60/60/60 55/55/55 73/73/73
f 54/54/54 53/53/53 62/62/62
f 70/70/70 69/69/69 76/76/76
f 72/72/72 71/71/71 78/78/78
f 73/73/73 70/70/70 79/79/79
f 74/74/74 72/72/72 80/80/80
f 82/82/82 60/60/60 79/79/79
f 62/62/62 74/74/74 81/81/81
f 84/84/84 61/61/61 82/82/82
f 63/63/63 62/62/62 83/83/83
f 64/64/64 61/61/61 85/85/85
f 65/65/65 63/63/63 86/86/86
f 66/66/66 64/64/64 87/87/87
f 89/89/89 68/68/68 86/86/86
f 67/67/67 66/66/66 88/88/88
f 75/75/75 69/69/69 89/89/89
f 83/83/83 81/81/81 91/91/91
f 94/94/94 85/85/85 92/92/92
f 86/86/86 83/83/83 93/93/93
f 87/87/87 85/85/85 95/95/95
f 97/97/97 89/89/89 93/93/93
f 88/88/88 87/87/87 96/96/96
f 75/75/75 89/89/89 98/98/98
f 101/101/101 76/76/76 98/98/98
f 78/78/78 77/77/77 100/100/100
f 79/79/79 76/76/76 102/102/102
f 80/80/80 78/78/78 103/103/103
f 104/104/104 82/82/82 102/102/102
f 81/81/81 80/80/80 90/90/90
f 92/92/92 84/84/84 104/104/104
f 108/108/108 101/101/101 105/105/105
f 100/100/100 99/99/99 107/107/107
f 102/102/102 101/101/101 109/109/109
f 103/103/103 100/100/100 110/110/110
f 112/112/112 104/104/104 109/109/109
f 90/90/90 103/103/103 111/111/111
f 92/92/92 104/104/104 113/113/113
f 91/91/91 90/90/90 114/114/114
f 116/116/116 94/94/94 113/113/113
f 93/93/93 91/91/91 115/115/115
f 95/95/95 94/94/94 117/117/117
f 118/118/118 97/97/97 115/115/115
f 123/123/123 96/96/96 117/117/117
f 98/98/98 97/97/97 105/105/105
f 122/122/122 116/116/116 119/119/119
f 115/115/115 114/114/114 121/121/121
f 124/124/124 117/117/117 122/122/122
f 125/125/125 118/118/118 121/121/121
f 146/146/146 123/123/123 124/124/124
f 105/105/105 118/118/118 126/126/126
f 108/108/108 105/105/105 127/127/127
f 107/107/107 106/106/106 129/129/129
f 109/109/109 108/108/108 130/130/130
f 110/110/110 107/107/107 131/131/131
f 133/133/133 112/112/112 130/130/130
f 111/111/111 110/110/110 132/132/132
f 113/113/113 112/112/112 119/119/119
f 114/114/114 111/111/111 120/120/120
f 129/129/129 128/128/128 135/135/135
f 130/130/130 127/127/127 137/137/137
f 138/138/138 131/131/131 135/135/135
f 140/140/140 133/133/133 137/137/137
f 132/132/132 131/131/131 139/139/139
f 119/119/119 133/133/133 141/141/141
f 120/120/120 132/132/132 142/142/142
f 122/122/122 119/119/119 143/143/143
f 121/121/121 120/120/120 144/144/144
f 124/124/124 122/122/122 145/145/145
f 147/147/147 125/125/125 144/144/144
f 153/153/153 146/146/146 145/145/145
f 126/126/126 125/125/125 148/148/148
f 127/127/127 126/126/126 136/136/136
f 144/144/144 142/142/142 150/150/150
f 145/145/145 143/143/143 152/152/152
f 154/154/154 147/147/147 150/150/150
f 174/174/174 153/153/153 152/152/152
f 148/148/148 147/147/147 155/155/155
f 158/158/158 136/136/136 155/155/155
f 135/135/135 134/134/134 157/157/157
f 137/137/137 136/136/136 159/159/159
f 138/138/138 135/135/135 160/160/160
f 162/162/162 140/140/140 159/159/159
f 139/139/139 138/138/138 161/161/161
f 141/141/141 140/140/140 163/163/163
f 149/149/149 142/142/142 161/161/161
f 151/151/151 143/143/143 163/163/163
f 159/159/159 158/158/158 165/165/165
f 160/160/160 157/157/157 167/167/167
f 169/169/169 162/162/162 165/165/165
f 161/161/161 160/160/160 168/168/168
f 163/163/163 162/162/162 170/170/170
f 171/171/171 149/149/149 168/168/168
f 173/173/173 151/151/151 170/170/170
f 150/150/150 149/149/149 172/172/172
f 175/175/175 152/152/152 173/173/173
f 176/176/176 154/154/154 172/172/172
f 181/181/181 174/174/174 175/175/175
f 155/155/155 154/154/154 177/177/177
f 164/164/164 158/158/158 177/177/177
f 157/157/157 156/156/156 166/166/166
f 182/182/182 175/175/175 179/179/179
f 183/183/183 176/176/176 180/180/180
f 202/202/202 181/181/181 182/182/182
f 184/184/184 177/177/177 183/183/183
f 164/164/164 177/177/177 185/185/185
f 166/166/166 178/178/178 187/187/187
f 165/165/165 164/164/164 188/188/188
f 167/167/167 166/166/166 189/189/189
f 191/191/191 169/169/169 188/188/188
f 168/168/168 167/167/167 190/190/190
f 170/170/170 169/169/169 192/192/192
f 171/171/171 168/168/168 193/193/193
f 179/179/179 173/173/173 192/192/192
f 172/172/172 171/171/171 180/180/180
f 197/197/197 191/191/191 194/194/194
f 190/190/190 189/189/189 196/196/196
f 192/192/192 191/191/191 198/198/198
f 200/200/200 193/193/193 196/196/196
f 179/179/179 192/192/192 199/199/199
f 180/180/180 193/193/193 201/201/201
f 203/203/203 182/182/182 199/199/199
f 204/204/204 183/183/183 201/201/201
f 209/209/209 202/202/202 203/203/203
f 205/205/205 184/184/184 204/204/204
f 185/185/185 184/184/184 206/206/206
f 187/187/187 186/186/186 208/208/208
f 188/188/188 185/185/185 194/194/194
f 189/189/189 187/187/187 195/195/195
f 524/538/483 209/209/209 210/210/210
f 212/212/212 205/205/205 211/211/211
f 206/206/206 205/205/205 213/213/213
f 208/208/208 207/207/207 215/215/215
f 194/194/194 206/206/206 216/216/216
f 195/195/195 208/208/208 217/217/217
f 218/218/218 197/197/197 216/216/216
f 220/220/220 196/196/196 217/217/217
f 198/198/198 197/197/197 219/219/219
f 200/200/200 196/196/196 221/221/221
f 199/199/199 198/198/198 222/222/222
f 201/201/201 200/200/200 223/223/223
f 210/210/210 203/203/203 222/222/222
f 211/211/211 204/204/204 223/223/223
f 227/227/227 220/220/220 224/224/224
f 219/219/219 218/218/218 226/226/226
f 221/221/221 220/220/220 228/228/228
f 222/222/222 219/219/219 229/229/229
f 223/223/223 221/221/221 230/230/230
f 210/210/210 222/222/222 231/231/231
f 233/233/233 211/211/211 230/230/230
f 524/538/483 210/210/210 232/232/232
f 212/212/212 211/211/211 234/234/234
f 213/213/213 212/212/212 235/235/235
f 215/215/215 214/214/214 237/237/237
f 216/216/216 213/213/213 238/238/238
f 217/217/217 215/215/215 224/224/224
f 225/225/225 218/218/218 238/238/238
f 234/234/234 233/233/233 240/240/240
f 243/243/243 235/235/235 240/240/240
f 237/237/237 236/236/236 242/242/242
f 238/238/238 235/235/235 244/244/244
f 224/224/224 237/237/237 245/245/245
f 246/246/246 225/225/225 244/244/244
f 248/248/248 227/227/227 245/245/245
f 226/226/226 225/225/225 247/247/247
f 228/228/228 227/227/227 249/249/249
f 229/229/229 226/226/226 250/250/250
f 230/230/230 228/228/228 251/251/251
f 252/252/252 231/231/231 250/250/250
f 239/239/239 233/233/233 251/251/251
f 259/259/259 232/232/232 252/252/252
f 247/247/247 246/246/246 254/254/254
f 249/249/249 248/248/248 256/256/256
f 258/258/258 250/250/250 254/254/254
f 251/251/251 249/249/249 257/257/257
f 260/260/260 252/252/252 258/258/258
f 261/261/261 239/239/239 257/257/257
f 281/281/281 259/259/259 260/260/260
f 240/240/240 239/239/239 262/262/262
f 243/243/243 240/240/240 263/263/263
f 242/242/242 241/241/241 265/265/265
f 244/244/244 243/243/243 266/266/266
f 245/245/245 242/242/242 267/267/267
f 253/253/253 246/246/246 266/266/266
f 248/248/248 245/245/245 255/255/255
f 263/263/263 262/262/262 269/269/269
f 265/265/265 264/264/264 271/271/271
f 266/266/266 263/263/263 272/272/272
f 267/267/267 265/265/265 273/273/273
f 274/274/274 253/253/253 272/272/272
f 276/276/276 255/255/255 273/273/273
f 254/254/254 253/253/253 275/275/275
f 256/256/256 255/255/255 277/277/277
f 258/258/258 254/254/254 278/278/278
f 257/257/257 256/256/256 279/279/279
f 260/260/260 258/258/258 280/280/280
f 282/282/282 261/261/261 279/279/279
f 478/492/478 281/281/281 280/280/280
f 262/262/262 261/261/261 268/268/268
f 285/285/285 277/277/277 283/283/283
f 287/287/287 278/278/278 284/284/284
f 279/279/279 277/277/277 286/286/286
f 288/288/288 280/280/280 287/287/287
f 290/290/290 282/282/282 286/286/286
f 478/492/478 280/280/280 289/289/289
f 268/268/268 282/282/282 291/291/291
f 269/269/269 268/268/268 292/292/292
f 271/271/271 270/270/270 294/294/294
f 272/272/272 269/269/269 295/295/295
f 273/273/273 271/271/271 296/296/296
f 297/297/297 274/274/274 295/295/295
f 283/283/283 276/276/276 296/296/296
f 275/275/275 274/274/274 284/284/284
f 292/292/292 291/291/291 299/299/299
f 294/294/294 293/293/293 301/301/301
f 295/295/295 292/292/292 302/302/302
f 296/296/296 294/294/294 303/303/303
f 304/304/304 297/297/297 302/302/302
f 306/306/306 283/283/283 303/303/303
f 284/284/284 297/297/297 305/305/305
f 308/308/308 285/285/285 306/306/306
f 287/287/287 284/284/284 307/307/307
f 286/286/286 285/285/285 309/309/309
f 310/310/310 288/288/288 307/307/307
f 311/311/311 290/290/290 309/309/309
f 537/551/484 289/289/289 310/310/310
f 298/298/298 291/291/291 311/311/311
f 315/315/315 307/307/307 312/312/312
f 309/309/309 308/308/308 314/314/314
f 316/316/316 310/310/310 315/315/315
f 318/318/318 311/311/311 314/314/314
f 537/551/484 310/310/310 317/317/317
f 298/298/298 311/311/311 319/319/319
f 299/299/299 298/298/298 320/320/320
f 301/301/301 300/300/300 322/322/322
f 302/302/302 299/299/299 323/323/323
f 303/303/303 301/301/301 324/324/324
f 325/325/325 304/304/304 323/323/323
f 326/326/326 306/306/306 324/324/324
f 305/305/305 304/304/304 312/312/312
f 313/313/313 308/308/308 326/326/326
f 323/323/323 320/320/320 328/328/328
f 324/324/324 322/322/322 330/330/330
f 331/331/331 325/325/325 328/328/328
f 333/333/333 326/326/326 330/330/330
f 312/312/312 325/325/325 332/332/332
f 313/313/313 326/326/326 334/334/334
f 315/315/315 312/312/312 335/335/335
f 314/314/314 313/313/313 336/336/336
f 337/337/337 316/316/316 335/335/335
f 339/339/339 318/318/318 336/336/336
f 317/317/317 316/316/316 338/338/338
f 319/319/319 318/318/318 340/340/340
f 320/320/320 319/319/319 327/327/327
f 322/322/322 321/321/321 329/329/329
f 344/344/344 337/337/337 342/342/342
f 346/346/346 339/339/339 343/343/343
f 338/338/338 337/337/337 345/345/345
f 340/340/340 339/339/339 347/347/347
f 350/350/350 327/327/327 347/347/347
f 329/329/329 341/341/341 349/349/349
f 328/328/328 327/327/327 351/351/351
f 330/330/330 329/329/329 352/352/352
f 353/353/353 331/331/331 351/351/351
f 355/355/355 333/333/333 352/352/352
f 332/332/332 331/331/331 354/354/354
f 356/356/356 334/334/334 355/355/355
f 335/335/335 332/332/332 342/342/342
f 336/336/336 334/334/334 343/343/343
f 352/352/352 349/349/349 358/358/358
f 360/360/360 353/353/353 359/359/359
f 362/362/362 355/355/355 358/358/358
f 354/354/354 353/353/353 361/361/361
f 364/364/364 356/356/356 362/362/362
f 342/342/342 354/354/354 363/363/363
f 343/343/343 356/356/356 365/365/365
f 366/366/366 344/344/344 363/363/363
f 368/368/368 346/346/346 365/365/365
f 345/345/345 344/344/344 367/367/367
f 347/347/347 346/346/346 369/369/369
f 371/371/371 350/350/350 369/369/369
f 357/357/357 349/349/349 370/370/370
f 351/351/351 350/350/350 359/359/359
f 375/378/375 368/372/368 372/374/372
f 367/554/367 366/375/366 374/377/374
f 369/381/369 368/372/368 376/379/376
f 378/385/378 371/380/371 376/379/376
f 380/387/380 357/382/357 377/384/377
f 359/390/359 371/380/371 379/386/379
f 358/392/358 357/382/357 381/388/381
f 382/393/382 360/389/360 379/386/379
f 384/396/384 362/391/362 381/388/381
f 361/397/361 360/389/360 383/394/383
f 386/399/386 364/395/364 384/396/384
f 363/400/363 361/397/361 385/398/385
f 365/373/365 364/395/364 372/374/372
f 366/375/366 363/400/363 373/376/373
f 389/403/389 382/393/382 387/401/387
f 391/405/391 384/396/384 388/402/388
f 383/394/383 382/393/382 390/404/390
f 386/399/386 384/396/384 392/406/392
f 394/408/394 385/398/385 390/404/390
f 372/374/372 386/399/386 393/407/393
f 373/376/373 385/398/385 395/409/395
f 397/411/397 375/378/375 393/407/393
f 374/377/374 373/376/373 396/410/396
f 398/412/398 376/379/376 397/411/397
f 400/414/400 378/385/378 398/412/398
f 401/415/401 380/387/380 399/413/399
f 379/386/379 378/385/378 387/401/387
f 388/402/388 381/388/381 401/415/401
f 396/410/396 395/409/395 403/417/403
f 398/412/398 397/411/397 405/419/405
f 400/414/400 398/412/398 406/420/406
f 409/423/409 401/415/401 407/421/407
f 387/401/387 400/414/400 408/422/408
f 388/402/388 401/415/401 410/424/410
f 412/426/412 389/403/389 408/422/408
f 391/405/391 388/402/388 411/425/411
f 390/404/390 389/403/389 413/427/413
f 415/429/415 392/406/392 411/425/411
f 394/408/394 390/404/390 414/428/414
f 393/407/393 392/406/392 416/430/416
f 402/416/402 395/409/395 414/428/414
f 404/418/404 397/411/397 416/430/416
f 411/425/411 410/424/410 418/432/418
f 413/427/413 412/426/412 420/434/420
f 422/436/422 415/429/415 418/432/418
f 414/428/414 413/427/413 421/435/421
f 416/430/416 415/429/415 423/437/423
f 402/416/402 414/428/414 424/438/424
f 426/440/426 404/418/404 423/437/423
f 403/417/403 402/416/402 425/439/425
f 405/419/405 404/418/404 427/441/427
f 406/420/406 405/419/405 428/442/428
f 409/423/409 407/421/407 430/444/430
f 408/422/408 406/420/406 431/445/431
f 410/424/410 409/423/409 417/431/417
f 419/433/419 412/426/412 431/445/431
f 427/441/427 426/440/426 433/447/433
f 428/442/428 427/441/427 434/448/434
f 430/444/430 429/443/429 436/450/436
f 431/445/431 428/442/428 437/451/437
f 417/431/417 430/444/430 438/452/438
f 440/454/440 419/433/419 437/451/437
f 418/432/418 417/431/417 439/453/439
f 420/434/420 419/433/419 441/455/441
f 442/456/442 422/436/422 439/453/439
f 444/458/444 421/435/421 441/455/441
f 423/437/423 422/436/422 443/457/443
f 424/438/424 421/435/421 445/459/445
f 432/446/432 426/440/426 443/457/443
f 425/439/425 424/438/424 446/460/446
f 441/455/441 440/454/440 448/462/448
f 451/465/451 442/456/442 449/463/449
f 444/458/444 441/455/441 450/464/450
f 443/457/443 442/456/442 452/466/452
f 445/459/445 444/458/444 453/467/453
f 455/469/455 432/446/432 452/466/452
f 446/460/446 445/459/445 454/468/454
f 433/447/433 432/446/432 456/470/456
f 458/472/458 434/448/434 456/470/456
f 460/474/460 436/450/436 457/471/457
f 437/451/437 434/448/434 459/473/459
f 461/475/461 438/452/438 460/474/460
f 447/461/447 440/454/440 459/473/459
f 449/463/449 439/453/439 461/475/461
f 458/472/458 456/470/456 463/477/463
f 460/474/460 457/471/457 465/479/465
f 459/473/459 458/472/458 466/480/466
f 461/475/461 460/474/460 467/481/467
f 468/482/468 447/461/447 466/480/466
f 470/484/470 449/463/449 467/481/467
f 448/462/448 447/461/447 469/483/469
f 472/486/472 451/465/451 470/484/470
f 450/464/450 448/462/448 471/485/471
f 452/466/452 451/465/451 473/487/473
f 453/467/453 450/464/450 474/488/474
f 476/490/476 455/469/455 473/487/473
f 454/468/454 453/467/453 475/489/475
f 456/470/456 455/469/455 462/476/462
f 471/485/471 469/483/469 9/9/9
f 12/12/12 473/487/473 7/7/7
f 474/488/474 471/485/471 13/13/13
f 11/11/11 476/490/476 12/12/12
f 475/489/475 474/488/474 477/491/477
f 18/18/18 462/476/462 11/11/11
f 463/477/463 462/476/462 17/17/17
f 24/24/24 465/479/465 19/19/19
f 466/480/466 463/477/463 27/27/27
f 28/28/28 467/481/467 24/24/24
f 468/482/468 466/480/466 26/26/26
f 1/1/1 470/484/470 28/28/28
f 469/483/469 468/482/468 4/4/4
f 7/7/7 472/486/472 1/1/1
f 281/281/281 478/492/478 480/494/479
f 345/345/345 367/367/367 482/496/480
f 99/99/99 77/77/77 484/498/481
f 134/134/134 128/128/128 486/500/481
f 540/555/482 236/236/236 487/501/481
f 407/421/407 399/413/399 489/503/481
f 541/561/481 370/370/370 490/504/481
f 123/123/123 146/146/146 492/506/479
f 509/523/479 475/489/475 493/507/479
f 259/259/259 281/281/281 494/508/479
f 374/377/374 396/410/396 496/510/479
f 485/499/481 128/128/128 497/511/481
f 534/548/481 435/449/435 498/512/481
f 19/19/19 464/478/464 500/514/481
f 543/558/481 264/264/264 501/515/481
f 425/439/425 446/460/446 503/517/480
f 399/413/399 377/384/377 488/502/481
f 530/544/481 300/300/300 505/519/482
f 518/532/479 153/153/153 506/520/480
f 96/96/96 123/123/123 507/521/480
f 478/492/478 289/289/289 479/493/479
f 454/468/454 475/489/475 510/524/480
f 40/40/40 46/46/46 512/526/480
f 542/557/479 403/417/403 503/517/480
f 539/553/481 156/156/156 486/500/481
f 293/293/293 270/270/270 505/519/482
f 477/491/477 14/14/14 493/507/479
f 498/512/481 429/443/429 489/503/481
f 181/181/181 202/202/202 516/530/479
f 20/20/20 19/19/19 517/531/481
f 491/505/479 146/146/146 518/532/479
f 464/478/464 457/471/457 499/513/481
f 537/551/484 317/317/317 521/535/480
f 50/50/50 43/43/43 523/537/481
f 209/209/209 524/538/483 526/540/479
f 446/460/446 454/468/454 502/516/479
f 186/186/186 178/178/178 528/542/481
f 77/77/77 71/71/71 483/497/481
f 321/321/321 300/300/300 531/545/481
f 67/67/67 88/88/88 533/547/480
f 457/471/457 435/449/435 519/533/481
f 14/14/14 40/40/40 514/528/480
f 338/338/338 345/345/345 535/549/480
f 174/174/174 181/181/181 506/520/480
f 487/501/481 214/214/214 536/550/481
f 289/289/289 537/551/484 508/522/479
f 43/43/43 20/20/20 522/536/482
f 348/348/348 341/341/341 490/504/481
f 178/178/178 156/156/156 527/541/481
f 46/46/46 67/67/67 511/525/479
f 481/560/479 367/554/367 496/510/479
f 515/529/480 202/202/202 526/540/479
f 241/241/241 236/236/236 501/515/481
f 317/317/317 338/338/338 520/534/479
f 529/543/481 71/71/71 523/537/481
f 544/559/479 232/232/232 494/508/479
f 536/550/481 207/207/207 528/542/481
f 377/384/377 370/383/370 504/518/481
f 497/511/481 106/106/106 484/498/481
f 396/410/396 403/417/403 495/509/480
f 538/552/481 341/341/341 531/545/481
f 88/88/88 96/96/96 532/546/479
f 270/270/270 264/264/264 513/527/481
f 524/538/483 232/232/232 525/539/479
f 572/500/485 486/500/481 545/499/485
f 590/541/485 527/541/481 546/553/486
f 565/517/487 503/517/480 547/516/487
f 570/494/491 480/494/479 548/493/487
f 569/528/490 514/528/480 549/526/487
f 566/560/487 481/560/479 550/510/488
f 577/548/485 534/548/481 551/512/486
f 596/513/486 499/513/481 552/533/486
f 573/534/487 520/534/479 553/549/489
f 584/527/486 513/527/481 554/558/485
f 595/555/485 540/555/482 555/501/486
f 574/520/489 506/520/480 556/530/487
f 588/539/487 525/539/479 557/559/489
f 580/524/487 510/524/480 558/523/489
f 545/499/485 485/499/481 559/511/485
f 608/543/486 529/543/481 560/537/485
f 579/506/489 492/506/479 561/505/487
f 592/525/487 511/525/479 562/547/487
f 551/512/486 498/512/481 563/503/485
f 599/561/485 541/561/481 564/504/485
f 597/557/487 542/557/479 565/517/487
f 601/496/489 482/496/480 566/495/487
f 598/531/494 517/531/481 567/514/486
f 554/558/485 543/558/481 568/515/485
f 605/507/488 493/507/479 569/528/490
f 589/508/493 494/508/479 570/494/491
f 607/545/486 531/545/481 571/544/486
f 546/553/486 539/553/481 572/500/485
f 591/535/487 521/535/480 573/534/487
f 604/532/489 518/532/479 574/520/489
f 602/529/487 515/529/480 575/540/487
f 555/501/486 487/501/481 576/550/486
f 552/533/486 519/533/481 577/548/485
f 585/498/486 484/498/481 578/497/485
f 603/521/489 507/521/480 579/506/489
f 547/516/487 502/516/479 580/524/487
f 550/510/488 496/510/479 581/509/492
f 563/503/485 489/503/481 582/502/486
f 560/537/485 523/537/481 583/536/486
f 600/519/495 505/519/482 584/527/486
f 559/511/485 497/511/481 585/498/486
f 564/504/485 490/504/481 586/552/486
f 548/493/487 479/493/479 587/522/487
f 575/540/487 526/540/479 588/539/487
f 557/559/489 544/559/479 589/508/493
f 594/542/486 528/542/481 590/541/485
f 587/522/487 508/522/479 591/535/487
f 549/526/487 512/526/480 592/525/487
f 562/547/487 533/547/480 593/546/487
f 576/550/486 536/550/481 594/542/486
f 568/515/485 501/515/481 595/555/485
f 567/514/486 500/514/481 596/513/486
f 581/509/492 495/509/480 597/557/487
f 583/536/486 522/536/482 598/531/494
f 606/518/486 504/518/481 599/556/485
f 571/544/486 530/544/481 600/519/495
f 553/549/489 535/549/480 601/496/489
f 556/530/487 516/530/479 602/529/487
f 593/546/487 532/546/479 603/521/489
f 561/505/487 491/505/479 604/532/489
f 558/523/489 509/523/479 605/507/488
f 582/502/486 488/502/481 606/518/486
f 586/552/486 538/552/481 607/545/486
f 578/497/485 483/497/481 608/543/486
f 615/533/501 552/533/486 609/548/496
f 628/531/497 598/531/494 610/514/497
f 617/519/502 600/519/495 611/527/498
f 631/497/496 578/497/485 612/543/499
f 620/501/503 555/501/486 613/550/500
f 635/499/499 545/499/485 614/511/499
f 633/513/505 596/513/486 615/533/501
f 625/558/498 554/558/485 616/515/498
f 640/544/499 571/544/486 617/519/502
f 609/548/496 577/548/485 618/512/499
f 639/537/504 560/537/485 619/536/497
f 636/555/507 595/555/485 620/501/503
f 624/542/499 594/542/486 621/541/504
f 629/503/502 563/503/485 622/502/504
f 626/561/499 599/561/485 623/504/499
f 613/550/500 576/550/486 624/542/499
f 611/527/498 584/527/486 625/558/498
f 637/518/499 606/518/486 626/556/499
f 634/552/506 586/552/486 627/545/500
f 619/536/497 583/536/486 628/531/497
f 618/512/499 551/512/486 629/503/502
f 621/541/504 590/541/485 630/553/502
f 638/498/508 585/498/486 631/497/496
f 630/553/502 546/553/486 632/500/499
f 610/514/497 567/514/486 633/513/505
f 623/504/499 564/504/485 634/552/506
f 632/500/499 572/500/485 635/499/499
f 616/515/498 568/515/485 636/555/507
f 622/502/504 582/502/486 637/518/499
f 614/511/499 559/511/485 638/498/508
f 612/543/499 608/543/486 639/537/504
f 627/545/500 607/545/486 640/544/499

```

`Engine/Assets/Textures/scuffed-plastic/About these PBR files.txt`:

```txt
These texture files were created by FreePBR.com and may be used freely in your video games and 3d work at no cost. They may not however be redistributed on other websites or anywhere else other than FreePBR.com. We think that is more than fair. :) We also would greatly appreciate it if some sorrt of credit was given if you do indeed use these textures in a published game. Other than that, keep on creating and have fun. :)
```

`Engine/Assets/Textures/skyboxes/demo/ReadMe.txt`:

```txt
Credits: Joey De Vries
https://learnopengl.com/Advanced-OpenGL/Cubemaps
https://learnopengl.com/img/textures/skybox.zip
```

`Engine/Assets/models/DamagedHelmet/DamagedHelmet.gltf`:

```gltf
{
    "asset" : {
        "generator" : "Khronos glTF Blender I/O v1.3.48",
        "version" : "2.0"
    },
    "scene" : 0,
    "scenes" : [
        {
            "name" : "Scene",
            "nodes" : [
                0
            ]
        }
    ],
    "nodes" : [
        {
            "mesh" : 0,
            "name" : "node_damagedHelmet_-6514",
            "rotation" : [
                0.7071068286895752,
                0,
                0,
                0.7071068286895752
            ]
        }
    ],
    "materials" : [
        {
            "emissiveFactor" : [
                1,
                1,
                1
            ],
            "emissiveTexture" : {
                "index" : 0,
                "texCoord" : 0
            },
            "name" : "Material_MR.001",
            "normalTexture" : {
                "index" : 1,
                "texCoord" : 0
            },
            "occlusionTexture" : {
                "index" : 2,
                "texCoord" : 0
            },
            "pbrMetallicRoughness" : {
                "baseColorTexture" : {
                    "index" : 3,
                    "texCoord" : 0
                },
                "metallicRoughnessTexture" : {
                    "index" : 2,
                    "texCoord" : 0
                }
            }
        }
    ],
    "meshes" : [
        {
            "name" : "mesh_helmet_LP_13930damagedHelmet.001",
            "primitives" : [
                {
                    "attributes" : {
                        "POSITION" : 0,
                        "NORMAL" : 1,
                        "TEXCOORD_0" : 2
                    },
                    "indices" : 3,
                    "material" : 0
                }
            ]
        }
    ],
    "textures" : [
        {
            "source" : 0
        },
        {
            "source" : 1
        },
        {
            "source" : 2
        },
        {
            "source" : 3
        }
    ],
    "images" : [
        {
            "mimeType" : "image/jpeg",
            "name" : "emissive",
            "uri" : "emissive.jpg"
        },
        {
            "mimeType" : "image/jpeg",
            "name" : "normal",
            "uri" : "normal.jpg"
        },
        {
            "mimeType" : "image/png",
            "name" : "AO_metalRoughness",
            "uri" : "AO_metalRoughness.png"
        },
        {
            "mimeType" : "image/jpeg",
            "name" : "albedo",
            "uri" : "albedo.jpg"
        }
    ],
    "accessors" : [
        {
            "bufferView" : 0,
            "componentType" : 5126,
            "count" : 16445,
            "max" : [
                0.9424954056739807,
                0.9009949564933777,
                0.8128451108932495
            ],
            "min" : [
                -0.9474585652351379,
                -0.900973916053772,
                -1.18715500831604
            ],
            "type" : "VEC3"
        },
        {
            "bufferView" : 1,
            "componentType" : 5126,
            "count" : 16445,
            "type" : "VEC3"
        },
        {
            "bufferView" : 2,
            "componentType" : 5126,
            "count" : 16445,
            "type" : "VEC2"
        },
        {
            "bufferView" : 3,
            "componentType" : 5123,
            "count" : 46356,
            "type" : "SCALAR"
        }
    ],
    "bufferViews" : [
        {
            "buffer" : 0,
            "byteLength" : 197340,
            "byteOffset" : 0
        },
        {
            "buffer" : 0,
            "byteLength" : 197340,
            "byteOffset" : 197340
        },
        {
            "buffer" : 0,
            "byteLength" : 131560,
            "byteOffset" : 394680
        },
        {
            "buffer" : 0,
            "byteLength" : 92712,
            "byteOffset" : 526240
        }
    ],
    "buffers" : [
        {
            "byteLength" : 618952,
            "uri" : "DamagedHelmet.bin"
        }
    ]
}

```

`Engine/Assets/models/Primitives/Obj/pCone.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl None
Ns 500
Ka 0.8 0.8 0.8
Kd 0.8 0.8 0.8
Ks 0.8 0.8 0.8
d 1
illum 2

```

`Engine/Assets/models/Primitives/Obj/pCone.obj`:

```obj
# Blender v2.90.0 OBJ File: ''
# www.blender.org
mtllib pCone.mtl
o Cone_Cone.001
v 0.000000 1.000000 -1.000000
v -0.195090 1.000000 -0.980785
v -0.382683 1.000000 -0.923880
v -0.555570 1.000000 -0.831470
v -0.707107 1.000000 -0.707107
v -0.831470 1.000000 -0.555570
v -0.923880 1.000000 -0.382683
v -0.980785 1.000000 -0.195090
v -1.000000 1.000000 -0.000000
v -0.980785 1.000000 0.195090
v -0.923880 1.000000 0.382683
v -0.831470 1.000000 0.555570
v -0.707107 1.000000 0.707107
v -0.555570 1.000000 0.831470
v -0.382683 1.000000 0.923880
v -0.195090 1.000000 0.980785
v 0.000000 1.000000 1.000000
v 0.195091 1.000000 0.980785
v 0.382684 1.000000 0.923879
v 0.555571 1.000000 0.831469
v 0.707107 1.000000 0.707106
v 0.831470 1.000000 0.555570
v 0.923880 1.000000 0.382683
v 0.980785 1.000000 0.195089
v 1.000000 1.000000 -0.000001
v 0.980785 1.000000 -0.195091
v 0.923879 1.000000 -0.382684
v 0.831469 1.000000 -0.555571
v 0.707106 1.000000 -0.707108
v 0.555569 1.000000 -0.831470
v 0.382682 1.000000 -0.923880
v 0.195089 1.000000 -0.980786
v 0.000000 -1.000000 0.000000
vt 0.250000 0.490000
vt 0.250000 0.250000
vt 0.296822 0.485388
vt 0.341844 0.471731
vt 0.383337 0.449553
vt 0.419706 0.419706
vt 0.449553 0.383337
vt 0.471731 0.341844
vt 0.485388 0.296822
vt 0.490000 0.250000
vt 0.485388 0.203178
vt 0.471731 0.158156
vt 0.449553 0.116663
vt 0.419706 0.080294
vt 0.383337 0.050447
vt 0.341844 0.028269
vt 0.296822 0.014612
vt 0.250000 0.010000
vt 0.203178 0.014612
vt 0.158156 0.028269
vt 0.116663 0.050447
vt 0.080294 0.080294
vt 0.050447 0.116663
vt 0.028269 0.158156
vt 0.014611 0.203179
vt 0.010000 0.250000
vt 0.014612 0.296822
vt 0.028269 0.341844
vt 0.050447 0.383337
vt 0.080295 0.419706
vt 0.116663 0.449553
vt 0.158156 0.471731
vt 0.985388 0.296822
vt 0.796822 0.014612
vt 0.514611 0.203179
vt 0.203179 0.485389
vt 0.703179 0.485389
vt 0.750000 0.490000
vt 0.796822 0.485388
vt 0.841844 0.471731
vt 0.883337 0.449553
vt 0.919706 0.419706
vt 0.949553 0.383337
vt 0.971731 0.341844
vt 0.990000 0.250000
vt 0.985388 0.203178
vt 0.971731 0.158156
vt 0.949553 0.116663
vt 0.919706 0.080294
vt 0.883337 0.050447
vt 0.841844 0.028269
vt 0.750000 0.010000
vt 0.703178 0.014612
vt 0.658156 0.028269
vt 0.616663 0.050447
vt 0.580294 0.080294
vt 0.550447 0.116663
vt 0.528269 0.158156
vt 0.510000 0.250000
vt 0.514612 0.296822
vt 0.528269 0.341844
vt 0.550447 0.383337
vt 0.580295 0.419706
vt 0.616663 0.449553
vt 0.658156 0.471731
vn -0.0878 -0.4455 -0.8910
vn -0.2599 -0.4455 -0.8567
vn -0.4220 -0.4455 -0.7896
vn -0.5680 -0.4455 -0.6921
vn -0.6921 -0.4455 -0.5680
vn -0.7896 -0.4455 -0.4220
vn -0.8567 -0.4455 -0.2599
vn -0.8910 -0.4455 -0.0878
vn -0.8910 -0.4455 0.0878
vn -0.8567 -0.4455 0.2599
vn -0.7896 -0.4455 0.4220
vn -0.6921 -0.4455 0.5680
vn -0.5680 -0.4455 0.6921
vn -0.4220 -0.4455 0.7896
vn -0.2599 -0.4455 0.8567
vn -0.0878 -0.4455 0.8910
vn 0.0878 -0.4455 0.8910
vn 0.2599 -0.4455 0.8567
vn 0.4220 -0.4455 0.7896
vn 0.5680 -0.4455 0.6921
vn 0.6921 -0.4455 0.5680
vn 0.7896 -0.4455 0.4220
vn 0.8567 -0.4455 0.2599
vn 0.8910 -0.4455 0.0878
vn 0.8910 -0.4455 -0.0878
vn 0.8567 -0.4455 -0.2599
vn 0.7896 -0.4455 -0.4220
vn 0.6921 -0.4455 -0.5680
vn 0.5680 -0.4455 -0.6921
vn 0.4220 -0.4455 -0.7896
vn 0.0000 1.0000 0.0000
vn 0.2599 -0.4455 -0.8567
vn 0.0878 -0.4455 -0.8910
usemtl None
s off
f 1/1/1 33/2/1 2/3/1
f 2/3/2 33/2/2 3/4/2
f 3/4/3 33/2/3 4/5/3
f 4/5/4 33/2/4 5/6/4
f 5/6/5 33/2/5 6/7/5
f 6/7/6 33/2/6 7/8/6
f 7/8/7 33/2/7 8/9/7
f 8/9/8 33/2/8 9/10/8
f 9/10/9 33/2/9 10/11/9
f 10/11/10 33/2/10 11/12/10
f 11/12/11 33/2/11 12/13/11
f 12/13/12 33/2/12 13/14/12
f 13/14/13 33/2/13 14/15/13
f 14/15/14 33/2/14 15/16/14
f 15/16/15 33/2/15 16/17/15
f 16/17/16 33/2/16 17/18/16
f 17/18/17 33/2/17 18/19/17
f 18/19/18 33/2/18 19/20/18
f 19/20/19 33/2/19 20/21/19
f 20/21/20 33/2/20 21/22/20
f 21/22/21 33/2/21 22/23/21
f 22/23/22 33/2/22 23/24/22
f 23/24/23 33/2/23 24/25/23
f 24/25/24 33/2/24 25/26/24
f 25/26/25 33/2/25 26/27/25
f 26/27/26 33/2/26 27/28/26
f 27/28/27 33/2/27 28/29/27
f 28/29/28 33/2/28 29/30/28
f 29/30/29 33/2/29 30/31/29
f 30/31/30 33/2/30 31/32/30
f 8/33/31 16/34/31 24/35/31
f 31/32/32 33/2/32 32/36/32
f 32/36/33 33/2/33 1/1/33
f 32/37/31 1/38/31 2/39/31
f 2/39/31 3/40/31 4/41/31
f 4/41/31 5/42/31 6/43/31
f 6/43/31 7/44/31 4/41/31
f 7/44/31 8/33/31 4/41/31
f 8/33/31 9/45/31 10/46/31
f 10/46/31 11/47/31 8/33/31
f 11/47/31 12/48/31 8/33/31
f 12/48/31 13/49/31 16/34/31
f 13/49/31 14/50/31 16/34/31
f 14/50/31 15/51/31 16/34/31
f 16/34/31 17/52/31 18/53/31
f 18/53/31 19/54/31 20/55/31
f 20/55/31 21/56/31 22/57/31
f 22/57/31 23/58/31 24/35/31
f 24/35/31 25/59/31 26/60/31
f 26/60/31 27/61/31 28/62/31
f 28/62/31 29/63/31 32/37/31
f 29/63/31 30/64/31 32/37/31
f 30/64/31 31/65/31 32/37/31
f 32/37/31 2/39/31 4/41/31
f 16/34/31 18/53/31 24/35/31
f 18/53/31 20/55/31 24/35/31
f 20/55/31 22/57/31 24/35/31
f 24/35/31 26/60/31 32/37/31
f 26/60/31 28/62/31 32/37/31
f 32/37/31 4/41/31 8/33/31
f 8/33/31 12/48/31 16/34/31
f 32/37/31 8/33/31 24/35/31

```

`Engine/Assets/models/Primitives/Obj/pCube.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl cube.001
Ns 0.000000
Ka 1.000000 1.000000 1.000000
Kd 0.800000 0.800000 0.800000
Ks 0.500000 0.500000 0.500000
Ke 0.000000 0.000000 0.000000
Ni 1.450000
d 1.000000
illum 3
map_Kd C:\\Users\\Benji\\AppData\\Local\\Temp\\gltfimg-4kgm_ihh\\Kd.png

```

`Engine/Assets/models/Primitives/Obj/pCube.obj`:

```obj
# Blender v2.90.0 OBJ File: ''
# www.blender.org
mtllib pCube.mtl
o cube_cube.001
v 1.000000 1.000000 1.000000
v -1.000000 1.000000 1.000000
v 1.000000 -1.000000 1.000000
v -1.000000 -1.000000 1.000000
v 1.000000 -1.000000 1.000000
v -1.000000 -1.000000 1.000000
v 1.000000 -1.000000 -1.000000
v -1.000000 -1.000000 -1.000000
v 1.000000 -1.000000 -1.000000
v -1.000000 -1.000000 -1.000000
v 1.000000 1.000000 -1.000000
v -1.000000 1.000000 -1.000000
v 1.000000 1.000000 -1.000000
v -1.000000 1.000000 -1.000000
v 1.000000 1.000000 1.000000
v -1.000000 1.000000 1.000000
v -1.000000 1.000000 1.000000
v -1.000000 1.000000 -1.000000
v -1.000000 -1.000000 1.000000
v -1.000000 -1.000000 -1.000000
v 1.000000 1.000000 -1.000000
v 1.000000 1.000000 1.000000
v 1.000000 -1.000000 -1.000000
v 1.000000 -1.000000 1.000000
vt 0.000000 0.000000
vt 1.000000 0.000000
vt 0.000000 1.000000
vt 1.000000 1.000000
vt 0.000000 0.000000
vt 1.000000 0.000000
vt 0.000000 1.000000
vt 1.000000 1.000000
vt 1.000000 1.000000
vt 0.000000 1.000000
vt 1.000000 0.000000
vt 0.000000 0.000000
vt 0.000000 0.000000
vt 1.000000 0.000000
vt 0.000000 1.000000
vt 1.000000 1.000000
vt 0.000000 0.000000
vt 1.000000 0.000000
vt 0.000000 1.000000
vt 1.000000 1.000000
vt 0.000000 0.000000
vt 1.000000 0.000000
vt 0.000000 1.000000
vt 1.000000 1.000000
vn 0.0000 0.0000 1.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 1.0000 0.0000
vn -1.0000 0.0000 0.0000
vn 1.0000 0.0000 0.0000
usemtl cube.001
s 1
f 1/1/1 2/2/1 3/3/1
f 3/3/1 2/2/1 4/4/1
f 5/5/2 6/6/2 7/7/2
f 7/7/2 6/6/2 8/8/2
f 9/9/3 10/10/3 11/11/3
f 11/11/3 10/10/3 12/12/3
f 13/13/4 14/14/4 15/15/4
f 15/15/4 14/14/4 16/16/4
f 17/17/5 18/18/5 19/19/5
f 19/19/5 18/18/5 20/20/5
f 21/21/6 22/22/6 23/23/6
f 23/23/6 22/22/6 24/24/6

```

`Engine/Assets/models/Primitives/Obj/pCylinder.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl None
Ns 500
Ka 0.8 0.8 0.8
Kd 0.8 0.8 0.8
Ks 0.8 0.8 0.8
d 1
illum 2

```

`Engine/Assets/models/Primitives/Obj/pCylinder.obj`:

```obj
# Blender v2.90.0 OBJ File: ''
# www.blender.org
mtllib pCylinder.mtl
o Cylinder
v 0.000000 -1.000000 -1.000000
v 0.000000 1.000000 -1.000000
v 0.195090 -1.000000 -0.980785
v 0.195090 1.000000 -0.980785
v 0.382683 -1.000000 -0.923880
v 0.382683 1.000000 -0.923880
v 0.555570 -1.000000 -0.831470
v 0.555570 1.000000 -0.831470
v 0.707107 -1.000000 -0.707107
v 0.707107 1.000000 -0.707107
v 0.831470 -1.000000 -0.555570
v 0.831470 1.000000 -0.555570
v 0.923880 -1.000000 -0.382683
v 0.923880 1.000000 -0.382683
v 0.980785 -1.000000 -0.195090
v 0.980785 1.000000 -0.195090
v 1.000000 -1.000000 -0.000000
v 1.000000 1.000000 -0.000000
v 0.980785 -1.000000 0.195090
v 0.980785 1.000000 0.195090
v 0.923880 -1.000000 0.382683
v 0.923880 1.000000 0.382683
v 0.831470 -1.000000 0.555570
v 0.831470 1.000000 0.555570
v 0.707107 -1.000000 0.707107
v 0.707107 1.000000 0.707107
v 0.555570 -1.000000 0.831470
v 0.555570 1.000000 0.831470
v 0.382683 -1.000000 0.923880
v 0.382683 1.000000 0.923880
v 0.195090 -1.000000 0.980785
v 0.195090 1.000000 0.980785
v -0.000000 -1.000000 1.000000
v -0.000000 1.000000 1.000000
v -0.195091 -1.000000 0.980785
v -0.195091 1.000000 0.980785
v -0.382684 -1.000000 0.923879
v -0.382684 1.000000 0.923879
v -0.555571 -1.000000 0.831469
v -0.555571 1.000000 0.831469
v -0.707107 -1.000000 0.707106
v -0.707107 1.000000 0.707106
v -0.831470 -1.000000 0.555570
v -0.831470 1.000000 0.555570
v -0.923880 -1.000000 0.382683
v -0.923880 1.000000 0.382683
v -0.980785 -1.000000 0.195089
v -0.980785 1.000000 0.195089
v -1.000000 -1.000000 -0.000001
v -1.000000 1.000000 -0.000001
v -0.980785 -1.000000 -0.195091
v -0.980785 1.000000 -0.195091
v -0.923879 -1.000000 -0.382684
v -0.923879 1.000000 -0.382684
v -0.831469 -1.000000 -0.555571
v -0.831469 1.000000 -0.555571
v -0.707106 -1.000000 -0.707108
v -0.707106 1.000000 -0.707108
v -0.555569 -1.000000 -0.831470
v -0.555569 1.000000 -0.831470
v -0.382682 -1.000000 -0.923880
v -0.382682 1.000000 -0.923880
v -0.195089 -1.000000 -0.980786
v -0.195089 1.000000 -0.980786
vt 1.000000 1.000000
vt 0.968750 0.500000
vt 1.000000 0.500000
vt 0.968750 1.000000
vt 0.937500 0.500000
vt 0.937500 1.000000
vt 0.906250 0.500000
vt 0.906250 1.000000
vt 0.875000 0.500000
vt 0.875000 1.000000
vt 0.843750 0.500000
vt 0.843750 1.000000
vt 0.812500 0.500000
vt 0.812500 1.000000
vt 0.781250 0.500000
vt 0.781250 1.000000
vt 0.750000 0.500000
vt 0.750000 1.000000
vt 0.718750 0.500000
vt 0.718750 1.000000
vt 0.687500 0.500000
vt 0.687500 1.000000
vt 0.656250 0.500000
vt 0.656250 1.000000
vt 0.625000 0.500000
vt 0.625000 1.000000
vt 0.593750 0.500000
vt 0.593750 1.000000
vt 0.562500 0.500000
vt 0.562500 1.000000
vt 0.531250 0.500000
vt 0.531250 1.000000
vt 0.500000 0.500000
vt 0.500000 1.000000
vt 0.468750 0.500000
vt 0.468750 1.000000
vt 0.437500 0.500000
vt 0.437500 1.000000
vt 0.406250 0.500000
vt 0.406250 1.000000
vt 0.375000 0.500000
vt 0.375000 1.000000
vt 0.343750 0.500000
vt 0.343750 1.000000
vt 0.312500 0.500000
vt 0.312500 1.000000
vt 0.281250 0.500000
vt 0.281250 1.000000
vt 0.250000 0.500000
vt 0.250000 1.000000
vt 0.218750 0.500000
vt 0.218750 1.000000
vt 0.187500 0.500000
vt 0.187500 1.000000
vt 0.156250 0.500000
vt 0.156250 1.000000
vt 0.125000 0.500000
vt 0.125000 1.000000
vt 0.093750 0.500000
vt 0.093750 1.000000
vt 0.062500 0.500000
vt 0.028269 0.341844
vt 0.158156 0.028269
vt 0.471731 0.158156
vt 0.062500 1.000000
vt 0.031250 0.500000
vt 0.031250 1.000000
vt 0.000000 0.500000
vt 0.985388 0.296822
vt 0.796822 0.014612
vt 0.514611 0.203179
vt 0.341844 0.471731
vt 0.296822 0.485388
vt 0.250000 0.490000
vt 0.203179 0.485389
vt 0.158156 0.471731
vt 0.116663 0.449553
vt 0.080295 0.419706
vt 0.050447 0.383337
vt 0.014612 0.296822
vt 0.010000 0.250000
vt 0.014611 0.203179
vt 0.028269 0.158156
vt 0.050447 0.116663
vt 0.080294 0.080294
vt 0.116663 0.050447
vt 0.203178 0.014612
vt 0.250000 0.010000
vt 0.296822 0.014612
vt 0.341844 0.028269
vt 0.383337 0.050447
vt 0.419706 0.080294
vt 0.449553 0.116663
vt 0.485388 0.203178
vt 0.490000 0.250000
vt 0.485388 0.296822
vt 0.471731 0.341844
vt 0.449553 0.383337
vt 0.419706 0.419706
vt 0.383337 0.449553
vt 0.000000 1.000000
vt 0.703179 0.485389
vt 0.750000 0.490000
vt 0.796822 0.485388
vt 0.841844 0.471731
vt 0.883337 0.449553
vt 0.919706 0.419706
vt 0.949553 0.383337
vt 0.971731 0.341844
vt 0.990000 0.250000
vt 0.985388 0.203178
vt 0.971731 0.158156
vt 0.949553 0.116663
vt 0.919706 0.080294
vt 0.883337 0.050447
vt 0.841844 0.028269
vt 0.750000 0.010000
vt 0.703178 0.014612
vt 0.658156 0.028269
vt 0.616663 0.050447
vt 0.580294 0.080294
vt 0.550447 0.116663
vt 0.528269 0.158156
vt 0.510000 0.250000
vt 0.514612 0.296822
vt 0.528269 0.341844
vt 0.550447 0.383337
vt 0.580295 0.419706
vt 0.616663 0.449553
vt 0.658156 0.471731
vn 0.0980 0.0000 -0.9952
vn 0.2903 0.0000 -0.9569
vn 0.4714 0.0000 -0.8819
vn 0.6344 0.0000 -0.7730
vn 0.7730 0.0000 -0.6344
vn 0.8819 0.0000 -0.4714
vn 0.9569 0.0000 -0.2903
vn 0.9952 0.0000 -0.0980
vn 0.9952 0.0000 0.0980
vn 0.9569 0.0000 0.2903
vn 0.8819 0.0000 0.4714
vn 0.7730 0.0000 0.6344
vn 0.6344 0.0000 0.7730
vn 0.4714 0.0000 0.8819
vn 0.2903 0.0000 0.9569
vn 0.0980 0.0000 0.9952
vn -0.0980 0.0000 0.9952
vn -0.2903 0.0000 0.9569
vn -0.4714 0.0000 0.8819
vn -0.6344 0.0000 0.7730
vn -0.7730 0.0000 0.6344
vn -0.8819 0.0000 0.4714
vn -0.9569 0.0000 0.2903
vn -0.9952 0.0000 0.0980
vn -0.9952 0.0000 -0.0980
vn -0.9569 0.0000 -0.2903
vn -0.8819 0.0000 -0.4714
vn -0.7730 0.0000 -0.6344
vn -0.6344 0.0000 -0.7730
vn -0.4714 0.0000 -0.8819
vn 0.0000 1.0000 0.0000
vn -0.2903 0.0000 -0.9569
vn -0.0980 0.0000 -0.9952
vn 0.0000 -1.0000 0.0000
usemtl None
s off
f 2/1/1 3/2/1 1/3/1
f 4/4/2 5/5/2 3/2/2
f 6/6/3 7/7/3 5/5/3
f 8/8/4 9/9/4 7/7/4
f 10/10/5 11/11/5 9/9/5
f 12/12/6 13/13/6 11/11/6
f 14/14/7 15/15/7 13/13/7
f 16/16/8 17/17/8 15/15/8
f 18/18/9 19/19/9 17/17/9
f 20/20/10 21/21/10 19/19/10
f 22/22/11 23/23/11 21/21/11
f 24/24/12 25/25/12 23/23/12
f 26/26/13 27/27/13 25/25/13
f 28/28/14 29/29/14 27/27/14
f 30/30/15 31/31/15 29/29/15
f 32/32/16 33/33/16 31/31/16
f 34/34/17 35/35/17 33/33/17
f 36/36/18 37/37/18 35/35/18
f 38/38/19 39/39/19 37/37/19
f 40/40/20 41/41/20 39/39/20
f 42/42/21 43/43/21 41/41/21
f 44/44/22 45/45/22 43/43/22
f 46/46/23 47/47/23 45/45/23
f 48/48/24 49/49/24 47/47/24
f 50/50/25 51/51/25 49/49/25
f 52/52/26 53/53/26 51/51/26
f 54/54/27 55/55/27 53/53/27
f 56/56/28 57/57/28 55/55/28
f 58/58/29 59/59/29 57/57/29
f 60/60/30 61/61/30 59/59/30
f 54/62/31 38/63/31 22/64/31
f 62/65/32 63/66/32 61/61/32
f 64/67/33 1/68/33 63/66/33
f 15/69/34 31/70/34 47/71/34
f 2/1/1 4/4/1 3/2/1
f 4/4/2 6/6/2 5/5/2
f 6/6/3 8/8/3 7/7/3
f 8/8/4 10/10/4 9/9/4
f 10/10/5 12/12/5 11/11/5
f 12/12/6 14/14/6 13/13/6
f 14/14/7 16/16/7 15/15/7
f 16/16/8 18/18/8 17/17/8
f 18/18/9 20/20/9 19/19/9
f 20/20/10 22/22/10 21/21/10
f 22/22/11 24/24/11 23/23/11
f 24/24/12 26/26/12 25/25/12
f 26/26/13 28/28/13 27/27/13
f 28/28/14 30/30/14 29/29/14
f 30/30/15 32/32/15 31/31/15
f 32/32/16 34/34/16 33/33/16
f 34/34/17 36/36/17 35/35/17
f 36/36/18 38/38/18 37/37/18
f 38/38/19 40/40/19 39/39/19
f 40/40/20 42/42/20 41/41/20
f 42/42/21 44/44/21 43/43/21
f 44/44/22 46/46/22 45/45/22
f 46/46/23 48/48/23 47/47/23
f 48/48/24 50/50/24 49/49/24
f 50/50/25 52/52/25 51/51/25
f 52/52/26 54/54/26 53/53/26
f 54/54/27 56/56/27 55/55/27
f 56/56/28 58/58/28 57/57/28
f 58/58/29 60/60/29 59/59/29
f 60/60/30 62/65/30 61/61/30
f 6/72/31 4/73/31 2/74/31
f 2/74/31 64/75/31 6/72/31
f 64/75/31 62/76/31 6/72/31
f 62/76/31 60/77/31 58/78/31
f 58/78/31 56/79/31 54/62/31
f 54/62/31 52/80/31 50/81/31
f 50/81/31 48/82/31 54/62/31
f 48/82/31 46/83/31 54/62/31
f 46/83/31 44/84/31 38/63/31
f 44/84/31 42/85/31 38/63/31
f 42/85/31 40/86/31 38/63/31
f 38/63/31 36/87/31 34/88/31
f 34/88/31 32/89/31 30/90/31
f 30/90/31 28/91/31 26/92/31
f 26/92/31 24/93/31 22/64/31
f 22/64/31 20/94/31 18/95/31
f 18/95/31 16/96/31 22/64/31
f 16/96/31 14/97/31 22/64/31
f 14/97/31 12/98/31 10/99/31
f 10/99/31 8/100/31 6/72/31
f 62/76/31 58/78/31 6/72/31
f 58/78/31 54/62/31 6/72/31
f 38/63/31 34/88/31 22/64/31
f 34/88/31 30/90/31 22/64/31
f 30/90/31 26/92/31 22/64/31
f 14/97/31 10/99/31 22/64/31
f 10/99/31 6/72/31 22/64/31
f 54/62/31 46/83/31 38/63/31
f 6/72/31 54/62/31 22/64/31
f 62/65/32 64/67/32 63/66/32
f 64/67/33 2/101/33 1/68/33
f 63/102/34 1/103/34 3/104/34
f 3/104/34 5/105/34 7/106/34
f 7/106/34 9/107/34 11/108/34
f 11/108/34 13/109/34 7/106/34
f 13/109/34 15/69/34 7/106/34
f 15/69/34 17/110/34 19/111/34
f 19/111/34 21/112/34 15/69/34
f 21/112/34 23/113/34 15/69/34
f 23/113/34 25/114/34 31/70/34
f 25/114/34 27/115/34 31/70/34
f 27/115/34 29/116/34 31/70/34
f 31/70/34 33/117/34 35/118/34
f 35/118/34 37/119/34 39/120/34
f 39/120/34 41/121/34 43/122/34
f 43/122/34 45/123/34 47/71/34
f 47/71/34 49/124/34 51/125/34
f 51/125/34 53/126/34 55/127/34
f 55/127/34 57/128/34 63/102/34
f 57/128/34 59/129/34 63/102/34
f 59/129/34 61/130/34 63/102/34
f 63/102/34 3/104/34 7/106/34
f 31/70/34 35/118/34 47/71/34
f 35/118/34 39/120/34 47/71/34
f 39/120/34 43/122/34 47/71/34
f 47/71/34 51/125/34 63/102/34
f 51/125/34 55/127/34 63/102/34
f 63/102/34 7/106/34 15/69/34
f 15/69/34 23/113/34 31/70/34
f 63/102/34 15/69/34 47/71/34

```

`Engine/Assets/models/Primitives/Obj/pGrid.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl None
Ns 500
Ka 0.8 0.8 0.8
Kd 0.8 0.8 0.8
Ks 0.8 0.8 0.8
d 1
illum 2

```

`Engine/Assets/models/Primitives/Obj/pGrid.obj`:

```obj
# Blender v2.90.0 OBJ File: ''
# www.blender.org
mtllib pGrid.mtl
o Grid_Grid.001
v 1.000000 0.000000 1.000000
v 0.777778 0.000000 1.000000
v 0.555556 0.000000 1.000000
v 0.333333 0.000000 1.000000
v 0.111111 0.000000 1.000000
v -0.111111 0.000000 1.000000
v -0.333333 0.000000 1.000000
v -0.555556 0.000000 1.000000
v -0.777778 0.000000 1.000000
v -1.000000 0.000000 1.000000
v 1.000000 0.000000 0.777778
v 0.777778 0.000000 0.777778
v 0.555556 0.000000 0.777778
v 0.333333 0.000000 0.777778
v 0.111111 0.000000 0.777778
v -0.111111 0.000000 0.777778
v -0.333333 0.000000 0.777778
v -0.555556 0.000000 0.777778
v -0.777778 0.000000 0.777778
v -1.000000 0.000000 0.777778
v 1.000000 0.000000 0.555556
v 0.777778 0.000000 0.555556
v 0.555556 0.000000 0.555556
v 0.333333 0.000000 0.555556
v 0.111111 0.000000 0.555556
v -0.111111 0.000000 0.555556
v -0.333333 0.000000 0.555556
v -0.555556 0.000000 0.555556
v -0.777778 0.000000 0.555556
v -1.000000 0.000000 0.555556
v 1.000000 0.000000 0.333333
v 0.777778 0.000000 0.333333
v 0.555556 0.000000 0.333333
v 0.333333 0.000000 0.333333
v 0.111111 0.000000 0.333333
v -0.111111 0.000000 0.333333
v -0.333333 0.000000 0.333333
v -0.555556 0.000000 0.333333
v -0.777778 0.000000 0.333333
v -1.000000 0.000000 0.333333
v 1.000000 0.000000 0.111111
v 0.777778 0.000000 0.111111
v 0.555556 0.000000 0.111111
v 0.333333 0.000000 0.111111
v 0.111111 0.000000 0.111111
v -0.111111 0.000000 0.111111
v -0.333333 0.000000 0.111111
v -0.555556 0.000000 0.111111
v -0.777778 0.000000 0.111111
v -1.000000 0.000000 0.111111
v 1.000000 0.000000 -0.111111
v 0.777778 0.000000 -0.111111
v 0.555556 0.000000 -0.111111
v 0.333333 0.000000 -0.111111
v 0.111111 0.000000 -0.111111
v -0.111111 0.000000 -0.111111
v -0.333333 0.000000 -0.111111
v -0.555556 0.000000 -0.111111
v -0.777778 0.000000 -0.111111
v -1.000000 0.000000 -0.111111
v 1.000000 0.000000 -0.333333
v 0.777778 0.000000 -0.333333
v 0.555556 0.000000 -0.333333
v 0.333333 0.000000 -0.333333
v 0.111111 0.000000 -0.333333
v -0.111111 0.000000 -0.333333
v -0.333333 0.000000 -0.333333
v -0.555556 0.000000 -0.333333
v -0.777778 0.000000 -0.333333
v -1.000000 0.000000 -0.333333
v 1.000000 0.000000 -0.555556
v 0.777778 0.000000 -0.555556
v 0.555556 0.000000 -0.555556
v 0.333333 0.000000 -0.555556
v 0.111111 0.000000 -0.555556
v -0.111111 0.000000 -0.555556
v -0.333333 0.000000 -0.555556
v -0.555556 0.000000 -0.555556
v -0.777778 0.000000 -0.555556
v -1.000000 0.000000 -0.555556
v 1.000000 0.000000 -0.777778
v 0.777778 0.000000 -0.777778
v 0.555556 0.000000 -0.777778
v 0.333333 0.000000 -0.777778
v 0.111111 0.000000 -0.777778
v -0.111111 0.000000 -0.777778
v -0.333333 0.000000 -0.777778
v -0.555556 0.000000 -0.777778
v -0.777778 0.000000 -0.777778
v -1.000000 0.000000 -0.777778
v 1.000000 0.000000 -1.000000
v 0.777778 0.000000 -1.000000
v 0.555556 0.000000 -1.000000
v 0.333333 0.000000 -1.000000
v 0.111111 0.000000 -1.000000
v -0.111111 0.000000 -1.000000
v -0.333333 0.000000 -1.000000
v -0.555556 0.000000 -1.000000
v -0.777778 0.000000 -1.000000
v -1.000000 0.000000 -1.000000
vt 0.111111 0.000000
vt 0.000000 0.111111
vt 0.000000 0.000000
vt 0.222222 0.000000
vt 0.111111 0.111111
vt 0.333333 0.000000
vt 0.222222 0.111111
vt 0.444444 0.000000
vt 0.333333 0.111111
vt 0.555556 0.000000
vt 0.444444 0.111111
vt 0.666667 0.000000
vt 0.555556 0.111111
vt 0.777778 0.000000
vt 0.666667 0.111111
vt 0.888889 0.000000
vt 0.777778 0.111111
vt 1.000000 0.000000
vt 0.888889 0.111111
vt 0.000000 0.222222
vt 0.111111 0.222222
vt 0.222222 0.222222
vt 0.333333 0.222222
vt 0.444444 0.222222
vt 0.555556 0.222222
vt 0.666667 0.222222
vt 0.777778 0.222222
vt 1.000000 0.111111
vt 0.888889 0.222222
vt 0.000000 0.333333
vt 0.111111 0.333333
vt 0.222222 0.333333
vt 0.333333 0.333333
vt 0.444444 0.333333
vt 0.555556 0.333333
vt 0.666667 0.333333
vt 0.777778 0.333333
vt 1.000000 0.222222
vt 0.888889 0.333333
vt 0.000000 0.444444
vt 0.111111 0.444444
vt 0.222222 0.444444
vt 0.333333 0.444444
vt 0.444444 0.444444
vt 0.555556 0.444444
vt 0.666667 0.444444
vt 0.777778 0.444444
vt 1.000000 0.333333
vt 0.888889 0.444444
vt 0.000000 0.555556
vt 0.111111 0.555556
vt 0.222222 0.555556
vt 0.333333 0.555556
vt 0.444444 0.555556
vt 0.555556 0.555556
vt 0.666667 0.555556
vt 0.777778 0.555556
vt 1.000000 0.444444
vt 0.888889 0.555556
vt 0.000000 0.666667
vt 0.111111 0.666667
vt 0.222222 0.666667
vt 0.333333 0.666667
vt 0.444444 0.666667
vt 0.555556 0.666667
vt 0.666667 0.666667
vt 0.777778 0.666667
vt 1.000000 0.555556
vt 0.888889 0.666667
vt 0.000000 0.777778
vt 0.111111 0.777778
vt 0.222222 0.777778
vt 0.333333 0.777778
vt 0.444444 0.777778
vt 0.555556 0.777778
vt 0.666667 0.777778
vt 0.777778 0.777778
vt 1.000000 0.666667
vt 0.888889 0.777778
vt 0.000000 0.888889
vt 0.111111 0.888889
vt 0.222222 0.888889
vt 0.333333 0.888889
vt 0.444444 0.888889
vt 0.555556 0.888889
vt 0.666667 0.888889
vt 0.777778 0.888889
vt 1.000000 0.777778
vt 0.888889 0.888889
vt 0.000000 1.000000
vt 0.111111 1.000000
vt 0.222222 1.000000
vt 0.333333 1.000000
vt 0.444444 1.000000
vt 0.555556 1.000000
vt 0.666667 1.000000
vt 0.777778 1.000000
vt 1.000000 0.888889
vt 0.888889 1.000000
vt 1.000000 1.000000
vn 0.0000 -1.0000 0.0000
usemtl None
s off
f 2/1/1 11/2/1 1/3/1
f 3/4/1 12/5/1 2/1/1
f 4/6/1 13/7/1 3/4/1
f 5/8/1 14/9/1 4/6/1
f 6/10/1 15/11/1 5/8/1
f 7/12/1 16/13/1 6/10/1
f 8/14/1 17/15/1 7/12/1
f 9/16/1 18/17/1 8/14/1
f 10/18/1 19/19/1 9/16/1
f 12/5/1 21/20/1 11/2/1
f 13/7/1 22/21/1 12/5/1
f 14/9/1 23/22/1 13/7/1
f 15/11/1 24/23/1 14/9/1
f 16/13/1 25/24/1 15/11/1
f 17/15/1 26/25/1 16/13/1
f 18/17/1 27/26/1 17/15/1
f 19/19/1 28/27/1 18/17/1
f 20/28/1 29/29/1 19/19/1
f 22/21/1 31/30/1 21/20/1
f 23/22/1 32/31/1 22/21/1
f 24/23/1 33/32/1 23/22/1
f 25/24/1 34/33/1 24/23/1
f 26/25/1 35/34/1 25/24/1
f 27/26/1 36/35/1 26/25/1
f 28/27/1 37/36/1 27/26/1
f 29/29/1 38/37/1 28/27/1
f 30/38/1 39/39/1 29/29/1
f 32/31/1 41/40/1 31/30/1
f 33/32/1 42/41/1 32/31/1
f 34/33/1 43/42/1 33/32/1
f 35/34/1 44/43/1 34/33/1
f 36/35/1 45/44/1 35/34/1
f 37/36/1 46/45/1 36/35/1
f 38/37/1 47/46/1 37/36/1
f 39/39/1 48/47/1 38/37/1
f 40/48/1 49/49/1 39/39/1
f 42/41/1 51/50/1 41/40/1
f 43/42/1 52/51/1 42/41/1
f 44/43/1 53/52/1 43/42/1
f 45/44/1 54/53/1 44/43/1
f 46/45/1 55/54/1 45/44/1
f 47/46/1 56/55/1 46/45/1
f 48/47/1 57/56/1 47/46/1
f 49/49/1 58/57/1 48/47/1
f 50/58/1 59/59/1 49/49/1
f 52/51/1 61/60/1 51/50/1
f 53/52/1 62/61/1 52/51/1
f 54/53/1 63/62/1 53/52/1
f 55/54/1 64/63/1 54/53/1
f 56/55/1 65/64/1 55/54/1
f 57/56/1 66/65/1 56/55/1
f 58/57/1 67/66/1 57/56/1
f 59/59/1 68/67/1 58/57/1
f 60/68/1 69/69/1 59/59/1
f 62/61/1 71/70/1 61/60/1
f 63/62/1 72/71/1 62/61/1
f 64/63/1 73/72/1 63/62/1
f 65/64/1 74/73/1 64/63/1
f 66/65/1 75/74/1 65/64/1
f 67/66/1 76/75/1 66/65/1
f 68/67/1 77/76/1 67/66/1
f 69/69/1 78/77/1 68/67/1
f 70/78/1 79/79/1 69/69/1
f 72/71/1 81/80/1 71/70/1
f 73/72/1 82/81/1 72/71/1
f 74/73/1 83/82/1 73/72/1
f 75/74/1 84/83/1 74/73/1
f 76/75/1 85/84/1 75/74/1
f 77/76/1 86/85/1 76/75/1
f 78/77/1 87/86/1 77/76/1
f 79/79/1 88/87/1 78/77/1
f 80/88/1 89/89/1 79/79/1
f 82/81/1 91/90/1 81/80/1
f 83/82/1 92/91/1 82/81/1
f 84/83/1 93/92/1 83/82/1
f 85/84/1 94/93/1 84/83/1
f 86/85/1 95/94/1 85/84/1
f 87/86/1 96/95/1 86/85/1
f 88/87/1 97/96/1 87/86/1
f 89/89/1 98/97/1 88/87/1
f 90/98/1 99/99/1 89/89/1
f 2/1/1 12/5/1 11/2/1
f 3/4/1 13/7/1 12/5/1
f 4/6/1 14/9/1 13/7/1
f 5/8/1 15/11/1 14/9/1
f 6/10/1 16/13/1 15/11/1
f 7/12/1 17/15/1 16/13/1
f 8/14/1 18/17/1 17/15/1
f 9/16/1 19/19/1 18/17/1
f 10/18/1 20/28/1 19/19/1
f 12/5/1 22/21/1 21/20/1
f 13/7/1 23/22/1 22/21/1
f 14/9/1 24/23/1 23/22/1
f 15/11/1 25/24/1 24/23/1
f 16/13/1 26/25/1 25/24/1
f 17/15/1 27/26/1 26/25/1
f 18/17/1 28/27/1 27/26/1
f 19/19/1 29/29/1 28/27/1
f 20/28/1 30/38/1 29/29/1
f 22/21/1 32/31/1 31/30/1
f 23/22/1 33/32/1 32/31/1
f 24/23/1 34/33/1 33/32/1
f 25/24/1 35/34/1 34/33/1
f 26/25/1 36/35/1 35/34/1
f 27/26/1 37/36/1 36/35/1
f 28/27/1 38/37/1 37/36/1
f 29/29/1 39/39/1 38/37/1
f 30/38/1 40/48/1 39/39/1
f 32/31/1 42/41/1 41/40/1
f 33/32/1 43/42/1 42/41/1
f 34/33/1 44/43/1 43/42/1
f 35/34/1 45/44/1 44/43/1
f 36/35/1 46/45/1 45/44/1
f 37/36/1 47/46/1 46/45/1
f 38/37/1 48/47/1 47/46/1
f 39/39/1 49/49/1 48/47/1
f 40/48/1 50/58/1 49/49/1
f 42/41/1 52/51/1 51/50/1
f 43/42/1 53/52/1 52/51/1
f 44/43/1 54/53/1 53/52/1
f 45/44/1 55/54/1 54/53/1
f 46/45/1 56/55/1 55/54/1
f 47/46/1 57/56/1 56/55/1
f 48/47/1 58/57/1 57/56/1
f 49/49/1 59/59/1 58/57/1
f 50/58/1 60/68/1 59/59/1
f 52/51/1 62/61/1 61/60/1
f 53/52/1 63/62/1 62/61/1
f 54/53/1 64/63/1 63/62/1
f 55/54/1 65/64/1 64/63/1
f 56/55/1 66/65/1 65/64/1
f 57/56/1 67/66/1 66/65/1
f 58/57/1 68/67/1 67/66/1
f 59/59/1 69/69/1 68/67/1
f 60/68/1 70/78/1 69/69/1
f 62/61/1 72/71/1 71/70/1
f 63/62/1 73/72/1 72/71/1
f 64/63/1 74/73/1 73/72/1
f 65/64/1 75/74/1 74/73/1
f 66/65/1 76/75/1 75/74/1
f 67/66/1 77/76/1 76/75/1
f 68/67/1 78/77/1 77/76/1
f 69/69/1 79/79/1 78/77/1
f 70/78/1 80/88/1 79/79/1
f 72/71/1 82/81/1 81/80/1
f 73/72/1 83/82/1 82/81/1
f 74/73/1 84/83/1 83/82/1
f 75/74/1 85/84/1 84/83/1
f 76/75/1 86/85/1 85/84/1
f 77/76/1 87/86/1 86/85/1
f 78/77/1 88/87/1 87/86/1
f 79/79/1 89/89/1 88/87/1
f 80/88/1 90/98/1 89/89/1
f 82/81/1 92/91/1 91/90/1
f 83/82/1 93/92/1 92/91/1
f 84/83/1 94/93/1 93/92/1
f 85/84/1 95/94/1 94/93/1
f 86/85/1 96/95/1 95/94/1
f 87/86/1 97/96/1 96/95/1
f 88/87/1 98/97/1 97/96/1
f 89/89/1 99/99/1 98/97/1
f 90/98/1 100/100/1 99/99/1

```

`Engine/Assets/models/Primitives/Obj/pIcoSphere.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl None
Ns 500
Ka 0.8 0.8 0.8
Kd 0.8 0.8 0.8
Ks 0.8 0.8 0.8
d 1
illum 2

```

`Engine/Assets/models/Primitives/Obj/pIcoSphere.obj`:

```obj
# Blender v2.90.0 OBJ File: ''
# www.blender.org
mtllib pIcoSphere.mtl
o Cylinder_Cylinder.001
v 0.000000 1.000000 -1.000000
v 0.000000 -1.000000 -1.000000
v -0.195090 1.000000 -0.980785
v -0.195090 -1.000000 -0.980785
v -0.382683 1.000000 -0.923880
v -0.382683 -1.000000 -0.923880
v -0.555570 1.000000 -0.831470
v -0.555570 -1.000000 -0.831470
v -0.707107 1.000000 -0.707107
v -0.707107 -1.000000 -0.707107
v -0.831470 1.000000 -0.555570
v -0.831470 -1.000000 -0.555570
v -0.923880 1.000000 -0.382683
v -0.923880 -1.000000 -0.382683
v -0.980785 1.000000 -0.195090
v -0.980785 -1.000000 -0.195090
v -1.000000 1.000000 -0.000000
v -1.000000 -1.000000 -0.000000
v -0.980785 1.000000 0.195090
v -0.980785 -1.000000 0.195090
v -0.923880 1.000000 0.382683
v -0.923880 -1.000000 0.382683
v -0.831470 1.000000 0.555570
v -0.831470 -1.000000 0.555570
v -0.707107 1.000000 0.707107
v -0.707107 -1.000000 0.707107
v -0.555570 1.000000 0.831470
v -0.555570 -1.000000 0.831470
v -0.382683 1.000000 0.923880
v -0.382683 -1.000000 0.923880
v -0.195090 1.000000 0.980785
v -0.195090 -1.000000 0.980785
v 0.000000 1.000000 1.000000
v 0.000000 -1.000000 1.000000
v 0.195091 1.000000 0.980785
v 0.195091 -1.000000 0.980785
v 0.382684 1.000000 0.923879
v 0.382684 -1.000000 0.923879
v 0.555571 1.000000 0.831469
v 0.555571 -1.000000 0.831469
v 0.707107 1.000000 0.707106
v 0.707107 -1.000000 0.707106
v 0.831470 1.000000 0.555570
v 0.831470 -1.000000 0.555570
v 0.923880 1.000000 0.382683
v 0.923880 -1.000000 0.382683
v 0.980785 1.000000 0.195089
v 0.980785 -1.000000 0.195089
v 1.000000 1.000000 -0.000001
v 1.000000 -1.000000 -0.000001
v 0.980785 1.000000 -0.195091
v 0.980785 -1.000000 -0.195091
v 0.923879 1.000000 -0.382684
v 0.923879 -1.000000 -0.382684
v 0.831469 1.000000 -0.555571
v 0.831469 -1.000000 -0.555571
v 0.707106 1.000000 -0.707108
v 0.707106 -1.000000 -0.707108
v 0.555569 1.000000 -0.831470
v 0.555569 -1.000000 -0.831470
v 0.382682 1.000000 -0.923880
v 0.382682 -1.000000 -0.923880
v 0.195089 1.000000 -0.980786
v 0.195089 -1.000000 -0.980786
vt 1.000000 1.000000
vt 0.968750 0.500000
vt 1.000000 0.500000
vt 0.968750 1.000000
vt 0.937500 0.500000
vt 0.937500 1.000000
vt 0.906250 0.500000
vt 0.906250 1.000000
vt 0.875000 0.500000
vt 0.875000 1.000000
vt 0.843750 0.500000
vt 0.843750 1.000000
vt 0.812500 0.500000
vt 0.812500 1.000000
vt 0.781250 0.500000
vt 0.781250 1.000000
vt 0.750000 0.500000
vt 0.750000 1.000000
vt 0.718750 0.500000
vt 0.718750 1.000000
vt 0.687500 0.500000
vt 0.687500 1.000000
vt 0.656250 0.500000
vt 0.656250 1.000000
vt 0.625000 0.500000
vt 0.625000 1.000000
vt 0.593750 0.500000
vt 0.593750 1.000000
vt 0.562500 0.500000
vt 0.562500 1.000000
vt 0.531250 0.500000
vt 0.531250 1.000000
vt 0.500000 0.500000
vt 0.500000 1.000000
vt 0.468750 0.500000
vt 0.468750 1.000000
vt 0.437500 0.500000
vt 0.437500 1.000000
vt 0.406250 0.500000
vt 0.406250 1.000000
vt 0.375000 0.500000
vt 0.375000 1.000000
vt 0.343750 0.500000
vt 0.343750 1.000000
vt 0.312500 0.500000
vt 0.312500 1.000000
vt 0.281250 0.500000
vt 0.281250 1.000000
vt 0.250000 0.500000
vt 0.250000 1.000000
vt 0.218750 0.500000
vt 0.218750 1.000000
vt 0.187500 0.500000
vt 0.187500 1.000000
vt 0.156250 0.500000
vt 0.156250 1.000000
vt 0.125000 0.500000
vt 0.125000 1.000000
vt 0.093750 0.500000
vt 0.093750 1.000000
vt 0.062500 0.500000
vt 0.028269 0.341844
vt 0.158156 0.028269
vt 0.471731 0.158156
vt 0.062500 1.000000
vt 0.031250 0.500000
vt 0.031250 1.000000
vt 0.000000 0.500000
vt 0.985388 0.296822
vt 0.796822 0.014612
vt 0.514611 0.203179
vt 0.341844 0.471731
vt 0.296822 0.485388
vt 0.250000 0.490000
vt 0.203179 0.485389
vt 0.158156 0.471731
vt 0.116663 0.449553
vt 0.080295 0.419706
vt 0.050447 0.383337
vt 0.014612 0.296822
vt 0.010000 0.250000
vt 0.014611 0.203179
vt 0.028269 0.158156
vt 0.050447 0.116663
vt 0.080294 0.080294
vt 0.116663 0.050447
vt 0.203178 0.014612
vt 0.250000 0.010000
vt 0.296822 0.014612
vt 0.341844 0.028269
vt 0.383337 0.050447
vt 0.419706 0.080294
vt 0.449553 0.116663
vt 0.485388 0.203178
vt 0.490000 0.250000
vt 0.485388 0.296822
vt 0.471731 0.341844
vt 0.449553 0.383337
vt 0.419706 0.419706
vt 0.383337 0.449553
vt 0.000000 1.000000
vt 0.703179 0.485389
vt 0.750000 0.490000
vt 0.796822 0.485388
vt 0.841844 0.471731
vt 0.883337 0.449553
vt 0.919706 0.419706
vt 0.949553 0.383337
vt 0.971731 0.341844
vt 0.990000 0.250000
vt 0.985388 0.203178
vt 0.971731 0.158156
vt 0.949553 0.116663
vt 0.919706 0.080294
vt 0.883337 0.050447
vt 0.841844 0.028269
vt 0.750000 0.010000
vt 0.703178 0.014612
vt 0.658156 0.028269
vt 0.616663 0.050447
vt 0.580294 0.080294
vt 0.550447 0.116663
vt 0.528269 0.158156
vt 0.510000 0.250000
vt 0.514612 0.296822
vt 0.528269 0.341844
vt 0.550447 0.383337
vt 0.580295 0.419706
vt 0.616663 0.449553
vt 0.658156 0.471731
vn -0.0980 0.0000 -0.9952
vn -0.2903 0.0000 -0.9569
vn -0.4714 0.0000 -0.8819
vn -0.6344 0.0000 -0.7730
vn -0.7730 0.0000 -0.6344
vn -0.8819 0.0000 -0.4714
vn -0.9569 0.0000 -0.2903
vn -0.9952 0.0000 -0.0980
vn -0.9952 0.0000 0.0980
vn -0.9569 0.0000 0.2903
vn -0.8819 0.0000 0.4714
vn -0.7730 0.0000 0.6344
vn -0.6344 0.0000 0.7730
vn -0.4714 0.0000 0.8819
vn -0.2903 0.0000 0.9569
vn -0.0980 0.0000 0.9952
vn 0.0980 0.0000 0.9952
vn 0.2903 0.0000 0.9569
vn 0.4714 0.0000 0.8819
vn 0.6344 0.0000 0.7730
vn 0.7730 0.0000 0.6344
vn 0.8819 0.0000 0.4714
vn 0.9569 0.0000 0.2903
vn 0.9952 0.0000 0.0980
vn 0.9952 0.0000 -0.0980
vn 0.9569 0.0000 -0.2903
vn 0.8819 0.0000 -0.4714
vn 0.7730 0.0000 -0.6344
vn 0.6344 0.0000 -0.7730
vn 0.4714 0.0000 -0.8819
vn 0.0000 -1.0000 0.0000
vn 0.2903 0.0000 -0.9569
vn 0.0980 0.0000 -0.9952
vn 0.0000 1.0000 0.0000
usemtl None
s off
f 2/1/1 3/2/1 1/3/1
f 4/4/2 5/5/2 3/2/2
f 6/6/3 7/7/3 5/5/3
f 8/8/4 9/9/4 7/7/4
f 10/10/5 11/11/5 9/9/5
f 12/12/6 13/13/6 11/11/6
f 14/14/7 15/15/7 13/13/7
f 16/16/8 17/17/8 15/15/8
f 18/18/9 19/19/9 17/17/9
f 20/20/10 21/21/10 19/19/10
f 22/22/11 23/23/11 21/21/11
f 24/24/12 25/25/12 23/23/12
f 26/26/13 27/27/13 25/25/13
f 28/28/14 29/29/14 27/27/14
f 30/30/15 31/31/15 29/29/15
f 32/32/16 33/33/16 31/31/16
f 34/34/17 35/35/17 33/33/17
f 36/36/18 37/37/18 35/35/18
f 38/38/19 39/39/19 37/37/19
f 40/40/20 41/41/20 39/39/20
f 42/42/21 43/43/21 41/41/21
f 44/44/22 45/45/22 43/43/22
f 46/46/23 47/47/23 45/45/23
f 48/48/24 49/49/24 47/47/24
f 50/50/25 51/51/25 49/49/25
f 52/52/26 53/53/26 51/51/26
f 54/54/27 55/55/27 53/53/27
f 56/56/28 57/57/28 55/55/28
f 58/58/29 59/59/29 57/57/29
f 60/60/30 61/61/30 59/59/30
f 54/62/31 38/63/31 22/64/31
f 62/65/32 63/66/32 61/61/32
f 64/67/33 1/68/33 63/66/33
f 15/69/34 31/70/34 47/71/34
f 2/1/1 4/4/1 3/2/1
f 4/4/2 6/6/2 5/5/2
f 6/6/3 8/8/3 7/7/3
f 8/8/4 10/10/4 9/9/4
f 10/10/5 12/12/5 11/11/5
f 12/12/6 14/14/6 13/13/6
f 14/14/7 16/16/7 15/15/7
f 16/16/8 18/18/8 17/17/8
f 18/18/9 20/20/9 19/19/9
f 20/20/10 22/22/10 21/21/10
f 22/22/11 24/24/11 23/23/11
f 24/24/12 26/26/12 25/25/12
f 26/26/13 28/28/13 27/27/13
f 28/28/14 30/30/14 29/29/14
f 30/30/15 32/32/15 31/31/15
f 32/32/16 34/34/16 33/33/16
f 34/34/17 36/36/17 35/35/17
f 36/36/18 38/38/18 37/37/18
f 38/38/19 40/40/19 39/39/19
f 40/40/20 42/42/20 41/41/20
f 42/42/21 44/44/21 43/43/21
f 44/44/22 46/46/22 45/45/22
f 46/46/23 48/48/23 47/47/23
f 48/48/24 50/50/24 49/49/24
f 50/50/25 52/52/25 51/51/25
f 52/52/26 54/54/26 53/53/26
f 54/54/27 56/56/27 55/55/27
f 56/56/28 58/58/28 57/57/28
f 58/58/29 60/60/29 59/59/29
f 60/60/30 62/65/30 61/61/30
f 6/72/31 4/73/31 2/74/31
f 2/74/31 64/75/31 6/72/31
f 64/75/31 62/76/31 6/72/31
f 62/76/31 60/77/31 58/78/31
f 58/78/31 56/79/31 54/62/31
f 54/62/31 52/80/31 50/81/31
f 50/81/31 48/82/31 54/62/31
f 48/82/31 46/83/31 54/62/31
f 46/83/31 44/84/31 38/63/31
f 44/84/31 42/85/31 38/63/31
f 42/85/31 40/86/31 38/63/31
f 38/63/31 36/87/31 34/88/31
f 34/88/31 32/89/31 30/90/31
f 30/90/31 28/91/31 26/92/31
f 26/92/31 24/93/31 22/64/31
f 22/64/31 20/94/31 18/95/31
f 18/95/31 16/96/31 22/64/31
f 16/96/31 14/97/31 22/64/31
f 14/97/31 12/98/31 10/99/31
f 10/99/31 8/100/31 6/72/31
f 62/76/31 58/78/31 6/72/31
f 58/78/31 54/62/31 6/72/31
f 38/63/31 34/88/31 22/64/31
f 34/88/31 30/90/31 22/64/31
f 30/90/31 26/92/31 22/64/31
f 14/97/31 10/99/31 22/64/31
f 10/99/31 6/72/31 22/64/31
f 54/62/31 46/83/31 38/63/31
f 6/72/31 54/62/31 22/64/31
f 62/65/32 64/67/32 63/66/32
f 64/67/33 2/101/33 1/68/33
f 63/102/34 1/103/34 3/104/34
f 3/104/34 5/105/34 7/106/34
f 7/106/34 9/107/34 11/108/34
f 11/108/34 13/109/34 7/106/34
f 13/109/34 15/69/34 7/106/34
f 15/69/34 17/110/34 19/111/34
f 19/111/34 21/112/34 15/69/34
f 21/112/34 23/113/34 15/69/34
f 23/113/34 25/114/34 31/70/34
f 25/114/34 27/115/34 31/70/34
f 27/115/34 29/116/34 31/70/34
f 31/70/34 33/117/34 35/118/34
f 35/118/34 37/119/34 39/120/34
f 39/120/34 41/121/34 43/122/34
f 43/122/34 45/123/34 47/71/34
f 47/71/34 49/124/34 51/125/34
f 51/125/34 53/126/34 55/127/34
f 55/127/34 57/128/34 63/102/34
f 57/128/34 59/129/34 63/102/34
f 59/129/34 61/130/34 63/102/34
f 63/102/34 3/104/34 7/106/34
f 31/70/34 35/118/34 47/71/34
f 35/118/34 39/120/34 47/71/34
f 39/120/34 43/122/34 47/71/34
f 47/71/34 51/125/34 63/102/34
f 51/125/34 55/127/34 63/102/34
f 63/102/34 7/106/34 15/69/34
f 15/69/34 23/113/34 31/70/34
f 63/102/34 15/69/34 47/71/34

```

`Engine/Assets/models/Primitives/Obj/pMonkey.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl None
Ns 500
Ka 0.8 0.8 0.8
Kd 0.8 0.8 0.8
Ks 0.8 0.8 0.8
d 1
illum 2

```

`Engine/Assets/models/Primitives/Obj/pMonkey.obj`:

```obj
# Blender v2.90.0 OBJ File: ''
# www.blender.org
mtllib pMonkey.mtl
o Suzanne_Suzanne.001
v -0.437500 -0.164062 0.765625
v 0.437500 -0.164062 0.765625
v -0.500000 -0.093750 0.687500
v 0.500000 -0.093750 0.687500
v -0.546875 -0.054688 0.578125
v 0.546875 -0.054688 0.578125
v -0.351562 0.023438 0.617188
v 0.351562 0.023438 0.617188
v -0.351562 -0.031250 0.718750
v 0.351562 -0.031250 0.718750
v -0.351562 -0.132812 0.781250
v 0.351562 -0.132812 0.781250
v -0.273438 -0.164062 0.796875
v 0.273438 -0.164062 0.796875
v -0.203125 -0.093750 0.742188
v 0.203125 -0.093750 0.742188
v -0.156250 -0.054688 0.648438
v 0.156250 -0.054688 0.648438
v -0.078125 -0.242188 0.656250
v 0.078125 -0.242188 0.656250
v -0.140625 -0.242188 0.742188
v 0.140625 -0.242188 0.742188
v -0.242188 -0.242188 0.796875
v 0.242188 -0.242188 0.796875
v -0.273438 -0.328125 0.796875
v 0.273438 -0.328125 0.796875
v -0.203125 -0.390625 0.742188
v 0.203125 -0.390625 0.742188
v -0.156250 -0.437500 0.648438
v 0.156250 -0.437500 0.648438
v -0.351562 -0.515625 0.617188
v 0.351562 -0.515625 0.617188
v -0.351562 -0.453125 0.718750
v 0.351562 -0.453125 0.718750
v -0.351562 -0.359375 0.781250
v 0.351562 -0.359375 0.781250
v -0.437500 -0.328125 0.765625
v 0.437500 -0.328125 0.765625
v -0.500000 -0.390625 0.687500
v 0.500000 -0.390625 0.687500
v -0.546875 -0.437500 0.578125
v 0.546875 -0.437500 0.578125
v -0.625000 -0.242188 0.562500
v 0.625000 -0.242188 0.562500
v -0.562500 -0.242188 0.671875
v 0.562500 -0.242188 0.671875
v -0.468750 -0.242188 0.757812
v 0.468750 -0.242188 0.757812
v -0.476562 -0.242188 0.773438
v 0.476562 -0.242188 0.773438
v -0.445312 -0.335938 0.781250
v 0.445312 -0.335938 0.781250
v -0.351562 -0.375000 0.804688
v 0.351562 -0.375000 0.804688
v -0.265625 -0.335938 0.820312
v 0.265625 -0.335938 0.820312
v -0.226562 -0.242188 0.820312
v 0.226562 -0.242188 0.820312
v -0.265625 -0.156250 0.820312
v 0.265625 -0.156250 0.820312
v -0.351562 -0.242188 0.828125
v 0.351562 -0.242188 0.828125
v -0.351562 -0.117188 0.804688
v 0.351562 -0.117188 0.804688
v -0.445312 -0.156250 0.781250
v 0.445312 -0.156250 0.781250
v 0.000000 -0.429688 0.742188
v 0.000000 -0.351562 0.820312
v 0.000000 0.679688 0.734375
v 0.000000 0.320312 0.781250
v 0.000000 0.187500 0.796875
v 0.000000 0.773438 0.718750
v 0.000000 -0.406250 0.601562
v 0.000000 -0.570312 0.570312
v 0.000000 -0.898438 -0.546875
v 0.000000 -0.562500 -0.851562
v 0.000000 -0.070312 -0.828125
v 0.000000 0.382812 -0.351562
v -0.203125 0.187500 0.562500
v 0.203125 0.187500 0.562500
v -0.312500 0.437500 0.570312
v 0.312500 0.437500 0.570312
v -0.351562 0.695312 0.570312
v 0.351562 0.695312 0.570312
v -0.367188 0.890625 0.531250
v 0.367188 0.890625 0.531250
v -0.328125 0.945312 0.523438
v 0.328125 0.945312 0.523438
v -0.179688 0.968750 0.554688
v 0.179688 0.968750 0.554688
v 0.000000 0.984375 0.578125
v -0.437500 0.140625 0.531250
v 0.437500 0.140625 0.531250
v -0.632812 0.039062 0.539062
v 0.632812 0.039062 0.539062
v -0.828125 -0.148438 0.445312
v 0.828125 -0.148438 0.445312
v -0.859375 -0.429688 0.593750
v 0.859375 -0.429688 0.593750
v -0.710938 -0.484375 0.625000
v 0.710938 -0.484375 0.625000
v -0.492188 -0.601562 0.687500
v 0.492188 -0.601562 0.687500
v -0.320312 -0.757812 0.734375
v 0.320312 -0.757812 0.734375
v -0.156250 -0.718750 0.757812
v 0.156250 -0.718750 0.757812
v -0.062500 -0.492188 0.750000
v 0.062500 -0.492188 0.750000
v -0.164062 -0.414062 0.773438
v 0.164062 -0.414062 0.773438
v -0.125000 -0.304688 0.765625
v 0.125000 -0.304688 0.765625
v -0.203125 -0.093750 0.742188
v 0.203125 -0.093750 0.742188
v -0.375000 -0.015625 0.703125
v 0.375000 -0.015625 0.703125
v -0.492188 -0.062500 0.671875
v 0.492188 -0.062500 0.671875
v -0.625000 -0.187500 0.648438
v 0.625000 -0.187500 0.648438
v -0.640625 -0.296875 0.648438
v 0.640625 -0.296875 0.648438
v -0.601562 -0.375000 0.664062
v 0.601562 -0.375000 0.664062
v -0.429688 -0.437500 0.718750
v 0.429688 -0.437500 0.718750
v -0.250000 -0.468750 0.757812
v 0.250000 -0.468750 0.757812
v 0.000000 0.765625 0.734375
v -0.109375 0.718750 0.734375
v 0.109375 0.718750 0.734375
v -0.117188 0.835938 0.710938
v 0.117188 0.835938 0.710938
v -0.062500 0.882812 0.695312
v 0.062500 0.882812 0.695312
v 0.000000 0.890625 0.687500
v 0.000000 0.195312 0.750000
v 0.000000 0.140625 0.742188
v -0.101562 0.148438 0.742188
v 0.101562 0.148438 0.742188
v -0.125000 0.226562 0.750000
v 0.125000 0.226562 0.750000
v -0.085938 0.289062 0.742188
v 0.085938 0.289062 0.742188
v -0.398438 0.046875 0.671875
v 0.398438 0.046875 0.671875
v -0.617188 -0.054688 0.625000
v 0.617188 -0.054688 0.625000
v -0.726562 -0.203125 0.601562
v 0.726562 -0.203125 0.601562
v -0.742188 -0.375000 0.656250
v 0.742188 -0.375000 0.656250
v -0.687500 -0.414062 0.726562
v 0.687500 -0.414062 0.726562
v -0.437500 -0.546875 0.796875
v 0.437500 -0.546875 0.796875
v -0.312500 -0.640625 0.835938
v 0.312500 -0.640625 0.835938
v -0.203125 -0.617188 0.851562
v 0.203125 -0.617188 0.851562
v -0.101562 -0.429688 0.843750
v 0.101562 -0.429688 0.843750
v -0.125000 0.101562 0.812500
v 0.125000 0.101562 0.812500
v -0.210938 0.445312 0.710938
v 0.210938 0.445312 0.710938
v -0.250000 0.703125 0.687500
v 0.250000 0.703125 0.687500
v -0.265625 0.820312 0.664062
v 0.265625 0.820312 0.664062
v -0.234375 0.914062 0.632812
v 0.234375 0.914062 0.632812
v -0.164062 0.929688 0.632812
v 0.164062 0.929688 0.632812
v 0.000000 0.945312 0.640625
v 0.000000 -0.046875 0.726562
v 0.000000 -0.210938 0.765625
v -0.328125 -0.476562 0.742188
v 0.328125 -0.476562 0.742188
v -0.164062 -0.140625 0.750000
v 0.164062 -0.140625 0.750000
v -0.132812 -0.210938 0.757812
v 0.132812 -0.210938 0.757812
v -0.117188 0.687500 0.734375
v 0.117188 0.687500 0.734375
v -0.078125 0.445312 0.750000
v 0.078125 0.445312 0.750000
v 0.000000 0.445312 0.750000
v 0.000000 0.328125 0.742188
v -0.093750 0.273438 0.781250
v 0.093750 0.273438 0.781250
v -0.132812 0.226562 0.796875
v 0.132812 0.226562 0.796875
v -0.109375 0.132812 0.781250
v 0.109375 0.132812 0.781250
v -0.039062 0.125000 0.781250
v 0.039062 0.125000 0.781250
v 0.000000 0.203125 0.828125
v -0.046875 0.148438 0.812500
v 0.046875 0.148438 0.812500
v -0.093750 0.156250 0.812500
v 0.093750 0.156250 0.812500
v -0.109375 0.226562 0.828125
v 0.109375 0.226562 0.828125
v -0.078125 0.250000 0.804688
v 0.078125 0.250000 0.804688
v 0.000000 0.289062 0.804688
v -0.257812 0.312500 0.554688
v 0.257812 0.312500 0.554688
v -0.164062 0.242188 0.710938
v 0.164062 0.242188 0.710938
v -0.179688 0.312500 0.710938
v 0.179688 0.312500 0.710938
v -0.234375 0.250000 0.554688
v 0.234375 0.250000 0.554688
v 0.000000 0.875000 0.687500
v -0.046875 0.867188 0.687500
v 0.046875 0.867188 0.687500
v -0.093750 0.820312 0.710938
v 0.093750 0.820312 0.710938
v -0.093750 0.742188 0.726562
v 0.093750 0.742188 0.726562
v 0.000000 0.781250 0.656250
v -0.093750 0.750000 0.664062
v 0.093750 0.750000 0.664062
v -0.093750 0.812500 0.640625
v 0.093750 0.812500 0.640625
v -0.046875 0.851562 0.632812
v 0.046875 0.851562 0.632812
v 0.000000 0.859375 0.632812
v -0.171875 -0.218750 0.781250
v 0.171875 -0.218750 0.781250
v -0.187500 -0.156250 0.773438
v 0.187500 -0.156250 0.773438
v -0.335938 -0.429688 0.757812
v 0.335938 -0.429688 0.757812
v -0.273438 -0.421875 0.773438
v 0.273438 -0.421875 0.773438
v -0.421875 -0.398438 0.773438
v 0.421875 -0.398438 0.773438
v -0.562500 -0.351562 0.695312
v 0.562500 -0.351562 0.695312
v -0.585938 -0.289062 0.687500
v 0.585938 -0.289062 0.687500
v -0.578125 -0.195312 0.679688
v 0.578125 -0.195312 0.679688
v -0.476562 -0.101562 0.718750
v 0.476562 -0.101562 0.718750
v -0.375000 -0.062500 0.742188
v 0.375000 -0.062500 0.742188
v -0.226562 -0.109375 0.781250
v 0.226562 -0.109375 0.781250
v -0.179688 -0.296875 0.781250
v 0.179688 -0.296875 0.781250
v -0.210938 -0.375000 0.781250
v 0.210938 -0.375000 0.781250
v -0.234375 -0.359375 0.757812
v 0.234375 -0.359375 0.757812
v -0.195312 -0.296875 0.757812
v 0.195312 -0.296875 0.757812
v -0.242188 -0.125000 0.757812
v 0.242188 -0.125000 0.757812
v -0.375000 -0.085938 0.726562
v 0.375000 -0.085938 0.726562
v -0.460938 -0.117188 0.703125
v 0.460938 -0.117188 0.703125
v -0.546875 -0.210938 0.671875
v 0.546875 -0.210938 0.671875
v -0.554688 -0.281250 0.671875
v 0.554688 -0.281250 0.671875
v -0.531250 -0.335938 0.679688
v 0.531250 -0.335938 0.679688
v -0.414062 -0.390625 0.750000
v 0.414062 -0.390625 0.750000
v -0.281250 -0.398438 0.765625
v 0.281250 -0.398438 0.765625
v -0.335938 -0.406250 0.750000
v 0.335938 -0.406250 0.750000
v -0.203125 -0.171875 0.750000
v 0.203125 -0.171875 0.750000
v -0.195312 -0.226562 0.750000
v 0.195312 -0.226562 0.750000
v -0.109375 -0.460938 0.609375
v 0.109375 -0.460938 0.609375
v -0.195312 -0.664062 0.617188
v 0.195312 -0.664062 0.617188
v -0.335938 -0.687500 0.593750
v 0.335938 -0.687500 0.593750
v -0.484375 -0.554688 0.554688
v 0.484375 -0.554688 0.554688
v -0.679688 -0.453125 0.492188
v 0.679688 -0.453125 0.492188
v -0.796875 -0.406250 0.460938
v 0.796875 -0.406250 0.460938
v -0.773438 -0.164062 0.375000
v 0.773438 -0.164062 0.375000
v -0.601562 0.000000 0.414062
v 0.601562 0.000000 0.414062
v -0.437500 0.093750 0.468750
v 0.437500 0.093750 0.468750
v 0.000000 -0.898438 0.289062
v 0.000000 -0.984375 -0.078125
v 0.000000 0.195312 -0.671875
v 0.000000 0.460938 0.187500
v 0.000000 0.976562 0.460938
v 0.000000 0.804688 0.343750
v 0.000000 0.570312 0.320312
v 0.000000 0.484375 0.281250
v -0.851562 -0.234375 0.054688
v 0.851562 -0.234375 0.054688
v -0.859375 -0.320312 -0.046875
v 0.859375 -0.320312 -0.046875
v -0.773438 -0.265625 -0.437500
v 0.773438 -0.265625 -0.437500
v -0.460938 -0.437500 -0.703125
v 0.460938 -0.437500 -0.703125
v -0.734375 0.046875 0.070312
v 0.734375 0.046875 0.070312
v -0.593750 0.125000 -0.164062
v 0.593750 0.125000 -0.164062
v -0.640625 0.007812 -0.429688
v 0.640625 0.007812 -0.429688
v -0.335938 -0.054688 -0.664062
v 0.335938 -0.054688 -0.664062
v -0.234375 0.351562 0.406250
v 0.234375 0.351562 0.406250
v -0.179688 0.414062 0.257812
v 0.179688 0.414062 0.257812
v -0.289062 0.710938 0.382812
v 0.289062 0.710938 0.382812
v -0.250000 0.500000 0.390625
v 0.250000 0.500000 0.390625
v -0.328125 0.914062 0.398438
v 0.328125 0.914062 0.398438
v -0.140625 0.757812 0.367188
v 0.140625 0.757812 0.367188
v -0.125000 0.539062 0.359375
v 0.125000 0.539062 0.359375
v -0.164062 0.945312 0.437500
v 0.164062 0.945312 0.437500
v -0.218750 0.281250 0.429688
v 0.218750 0.281250 0.429688
v -0.210938 0.226562 0.468750
v 0.210938 0.226562 0.468750
v -0.203125 0.171875 0.500000
v 0.203125 0.171875 0.500000
v -0.210938 0.390625 0.164062
v 0.210938 0.390625 0.164062
v -0.296875 0.312500 -0.265625
v 0.296875 0.312500 -0.265625
v -0.343750 0.148438 -0.539062
v 0.343750 0.148438 -0.539062
v -0.453125 -0.867188 -0.382812
v 0.453125 -0.867188 -0.382812
v -0.453125 -0.929688 -0.070312
v 0.453125 -0.929688 -0.070312
v -0.453125 -0.851562 0.234375
v 0.453125 -0.851562 0.234375
v -0.460938 -0.523438 0.429688
v 0.460938 -0.523438 0.429688
v -0.726562 -0.406250 0.335938
v 0.726562 -0.406250 0.335938
v -0.632812 -0.453125 0.281250
v 0.632812 -0.453125 0.281250
v -0.640625 -0.703125 0.054688
v 0.640625 -0.703125 0.054688
v -0.796875 -0.562500 0.125000
v 0.796875 -0.562500 0.125000
v -0.796875 -0.617188 -0.117188
v 0.796875 -0.617188 -0.117188
v -0.640625 -0.750000 -0.195312
v 0.640625 -0.750000 -0.195312
v -0.640625 -0.679688 -0.445312
v 0.640625 -0.679688 -0.445312
v -0.796875 -0.539062 -0.359375
v 0.796875 -0.539062 -0.359375
v -0.617188 -0.328125 -0.585938
v 0.617188 -0.328125 -0.585938
v -0.484375 -0.023438 -0.546875
v 0.484375 -0.023438 -0.546875
v -0.820312 -0.328125 -0.203125
v 0.820312 -0.328125 -0.203125
v -0.406250 0.171875 0.148438
v 0.406250 0.171875 0.148438
v -0.429688 0.195312 -0.210938
v 0.429688 0.195312 -0.210938
v -0.890625 -0.406250 -0.234375
v 0.890625 -0.406250 -0.234375
v -0.773438 0.140625 -0.125000
v 0.773438 0.140625 -0.125000
v -1.039062 0.101562 -0.328125
v 1.039062 0.101562 -0.328125
v -1.281250 -0.054688 -0.429688
v 1.281250 -0.054688 -0.429688
v -1.351562 -0.320312 -0.421875
v 1.351562 -0.320312 -0.421875
v -1.234375 -0.507812 -0.421875
v 1.234375 -0.507812 -0.421875
v -1.023438 -0.476562 -0.312500
v 1.023438 -0.476562 -0.312500
v -1.015625 -0.414062 -0.289062
v 1.015625 -0.414062 -0.289062
v -1.187500 -0.437500 -0.390625
v 1.187500 -0.437500 -0.390625
v -1.265625 -0.289062 -0.406250
v 1.265625 -0.289062 -0.406250
v -1.210938 -0.078125 -0.406250
v 1.210938 -0.078125 -0.406250
v -1.031250 0.039062 -0.304688
v 1.031250 0.039062 -0.304688
v -0.828125 0.070312 -0.132812
v 0.828125 0.070312 -0.132812
v -0.921875 -0.359375 -0.218750
v 0.921875 -0.359375 -0.218750
v -0.945312 -0.304688 -0.289062
v 0.945312 -0.304688 -0.289062
v -0.882812 0.023438 -0.210938
v 0.882812 0.023438 -0.210938
v -1.039062 0.000000 -0.367188
v 1.039062 0.000000 -0.367188
v -1.187500 -0.093750 -0.445312
v 1.187500 -0.093750 -0.445312
v -1.234375 -0.250000 -0.445312
v 1.234375 -0.250000 -0.445312
v -1.171875 -0.359375 -0.437500
v 1.171875 -0.359375 -0.437500
v -1.023438 -0.343750 -0.359375
v 1.023438 -0.343750 -0.359375
v -0.843750 -0.289062 -0.210938
v 0.843750 -0.289062 -0.210938
v -0.835938 -0.171875 -0.273438
v 0.835938 -0.171875 -0.273438
v -0.757812 -0.093750 -0.273438
v 0.757812 -0.093750 -0.273438
v -0.820312 -0.085938 -0.273438
v 0.820312 -0.085938 -0.273438
v -0.843750 -0.015625 -0.273438
v 0.843750 -0.015625 -0.273438
v -0.812500 0.015625 -0.273438
v 0.812500 0.015625 -0.273438
v -0.726562 0.000000 -0.070312
v 0.726562 0.000000 -0.070312
v -0.718750 0.023438 -0.171875
v 0.718750 0.023438 -0.171875
v -0.718750 -0.039062 -0.187500
v 0.718750 -0.039062 -0.187500
v -0.796875 -0.203125 -0.210938
v 0.796875 -0.203125 -0.210938
v -0.890625 -0.242188 -0.265625
v 0.890625 -0.242188 -0.265625
v -0.890625 -0.234375 -0.320312
v 0.890625 -0.234375 -0.320312
v -0.812500 0.015625 -0.320312
v 0.812500 0.015625 -0.320312
v -0.851562 -0.015625 -0.320312
v 0.851562 -0.015625 -0.320312
v -0.828125 -0.078125 -0.320312
v 0.828125 -0.078125 -0.320312
v -0.765625 -0.093750 -0.320312
v 0.765625 -0.093750 -0.320312
v -0.843750 -0.171875 -0.320312
v 0.843750 -0.171875 -0.320312
v -1.039062 -0.328125 -0.414062
v 1.039062 -0.328125 -0.414062
v -1.187500 -0.343750 -0.484375
v 1.187500 -0.343750 -0.484375
v -1.257812 -0.242188 -0.492188
v 1.257812 -0.242188 -0.492188
v -1.210938 -0.085938 -0.484375
v 1.210938 -0.085938 -0.484375
v -1.046875 0.000000 -0.421875
v 1.046875 0.000000 -0.421875
v -0.882812 0.015625 -0.265625
v 0.882812 0.015625 -0.265625
v -0.953125 -0.289062 -0.343750
v 0.953125 -0.289062 -0.343750
v -0.890625 -0.109375 -0.328125
v 0.890625 -0.109375 -0.328125
v -0.937500 -0.062500 -0.335938
v 0.937500 -0.062500 -0.335938
v -1.000000 -0.125000 -0.367188
v 1.000000 -0.125000 -0.367188
v -0.960938 -0.171875 -0.351562
v 0.960938 -0.171875 -0.351562
v -1.015625 -0.234375 -0.375000
v 1.015625 -0.234375 -0.375000
v -1.054688 -0.187500 -0.382812
v 1.054688 -0.187500 -0.382812
v -1.109375 -0.210938 -0.390625
v 1.109375 -0.210938 -0.390625
v -1.085938 -0.273438 -0.390625
v 1.085938 -0.273438 -0.390625
v -1.023438 -0.437500 -0.484375
v 1.023438 -0.437500 -0.484375
v -1.250000 -0.468750 -0.546875
v 1.250000 -0.468750 -0.546875
v -1.367188 -0.296875 -0.500000
v 1.367188 -0.296875 -0.500000
v -1.312500 -0.054688 -0.531250
v 1.312500 -0.054688 -0.531250
v -1.039062 0.085938 -0.492188
v 1.039062 0.085938 -0.492188
v -0.789062 0.125000 -0.328125
v 0.789062 0.125000 -0.328125
v -0.859375 -0.382812 -0.382812
v 0.859375 -0.382812 -0.382812
vt 0.890955 0.590063
vt 0.860081 0.560115
vt 0.904571 0.559404
vt 0.856226 0.850547
vt 0.888398 0.821999
vt 0.900640 0.853232
vt 0.853018 0.521562
vt 0.920166 0.524546
vt 0.847458 0.888748
vt 0.914672 0.888748
vt 0.798481 0.569535
vt 0.795104 0.838402
vt 0.870622 0.589649
vt 0.828900 0.590771
vt 0.826436 0.818537
vt 0.868067 0.821510
vt 0.854402 0.604754
vt 0.828171 0.633354
vt 0.827598 0.775964
vt 0.852534 0.805700
vt 0.791018 0.645443
vt 0.791018 0.762238
vt 0.855181 0.668527
vt 0.856142 0.742025
vt 0.844839 0.707525
vt 0.854107 0.625459
vt 0.853157 0.785002
vt 0.867508 0.642291
vt 0.900375 0.666964
vt 0.901223 0.745592
vt 0.867293 0.768782
vt 0.842358 0.702491
vt 0.921180 0.713713
vt 0.931889 0.636832
vt 0.918898 0.699697
vt 0.931368 0.777093
vt 0.968213 0.770220
vt 0.905882 0.627902
vt 0.890474 0.641909
vt 0.904990 0.784860
vt 0.906232 0.605742
vt 0.904357 0.807013
vt 0.931250 0.820926
vt 0.933717 0.593037
vt 0.968392 0.645333
vt 0.965038 0.841671
vt 0.968392 0.573812
vt 0.889591 0.593275
vt 0.887178 0.818729
vt 0.900583 0.804677
vt 0.902359 0.607909
vt 0.898822 0.786233
vt 0.899781 0.626257
vt 0.890219 0.770183
vt 0.887351 0.775442
vt 0.887842 0.636527
vt 0.870376 0.775972
vt 0.859881 0.623942
vt 0.870908 0.635245
vt 0.858859 0.786774
vt 0.859664 0.608186
vt 0.857942 0.802505
vt 0.871664 0.593961
vt 0.869299 0.817249
vt 0.879400 0.616512
vt 0.878029 0.795063
vt 0.536419 0.062072
vt 0.518916 0.050294
vt 0.540260 0.053805
vt 0.501452 0.062043
vt 0.518925 0.059681
vt 0.542788 0.064089
vt 0.551930 0.058338
vt 0.495083 0.064047
vt 0.497626 0.053770
vt 0.555073 0.061900
vt 0.482805 0.061829
vt 0.485955 0.058273
vt 0.563812 0.076586
vt 0.546290 0.072669
vt 0.491565 0.072625
vt 0.474014 0.076511
vt 0.583135 0.108495
vt 0.548333 0.084893
vt 0.489507 0.084858
vt 0.454527 0.108481
vt 0.605512 0.165134
vt 0.621513 0.227818
vt 0.553118 0.209599
vt 0.416514 0.229490
vt 0.432024 0.165644
vt 0.485339 0.210053
vt 0.676379 0.233241
vt 0.647395 0.200502
vt 0.360308 0.235899
vt 0.372747 0.256357
vt 0.683908 0.279995
vt 0.664761 0.253225
vt 0.353696 0.284606
vt 0.707254 0.310054
vt 0.715342 0.265392
vt 0.330721 0.316853
vt 0.351187 0.317440
vt 0.697446 0.332673
vt 0.687515 0.311539
vt 0.341964 0.339667
vt 0.362723 0.329722
vt 0.662817 0.372521
vt 0.676824 0.323937
vt 0.379297 0.378686
vt 0.402772 0.362131
vt 0.618316 0.375151
vt 0.639050 0.357330
vt 0.424583 0.379267
vt 0.604826 0.397804
vt 0.626842 0.395792
vt 0.439252 0.401540
vt 0.442396 0.381222
vt 0.553095 0.390512
vt 0.600808 0.377857
vt 0.490934 0.391862
vt 0.482938 0.358497
vt 0.521923 0.386009
vt 0.559674 0.357011
vt 0.521086 0.343868
vt 0.599845 0.344815
vt 0.577279 0.340156
vt 0.441977 0.347815
vt 0.615546 0.342005
vt 0.634472 0.332311
vt 0.425972 0.345582
vt 0.662406 0.312804
vt 0.406362 0.336480
vt 0.668440 0.297958
vt 0.377061 0.317685
vt 0.664101 0.277872
vt 0.370304 0.302644
vt 0.639236 0.253047
vt 0.374100 0.281778
vt 0.613992 0.242662
vt 0.398938 0.255633
vt 0.572941 0.258564
vt 0.424464 0.244473
vt 0.519760 0.248864
vt 0.466409 0.259709
vt 0.558527 0.316594
vt 0.482619 0.317843
vt 0.520277 0.294764
vt 0.556923 0.291214
vt 0.483433 0.292249
vt 0.563905 0.272007
vt 0.475886 0.273078
vt 0.525483 0.068967
vt 0.512375 0.068956
vt 0.531231 0.073829
vt 0.506626 0.073811
vt 0.531019 0.087431
vt 0.555621 0.121749
vt 0.532669 0.090920
vt 0.505177 0.090908
vt 0.482177 0.121781
vt 0.506827 0.087416
vt 0.518981 0.151749
vt 0.532042 0.127713
vt 0.538112 0.158382
vt 0.505828 0.127728
vt 0.518941 0.128358
vt 0.518925 0.093952
vt 0.518927 0.085180
vt 0.548362 0.173560
vt 0.535214 0.166808
vt 0.502799 0.166857
vt 0.489683 0.173693
vt 0.499851 0.158434
vt 0.544281 0.193366
vt 0.537959 0.175966
vt 0.500100 0.176033
vt 0.493996 0.193428
vt 0.528757 0.191785
vt 0.519841 0.200843
vt 0.509219 0.191626
vt 0.500890 0.187571
vt 0.519132 0.185382
vt 0.517577 0.190607
vt 0.518998 0.159028
vt 0.519016 0.165599
vt 0.506910 0.171667
vt 0.528222 0.186316
vt 0.509787 0.186260
vt 0.533528 0.184215
vt 0.537248 0.187577
vt 0.504547 0.184206
vt 0.504604 0.176791
vt 0.531131 0.171631
vt 0.533449 0.176739
vt 0.519099 0.179457
vt 0.561572 0.167779
vt 0.476363 0.167996
vt 0.478371 0.149447
vt 0.559475 0.149319
vt 0.596138 0.133426
vt 0.441395 0.133592
vt 0.601169 0.147885
vt 0.436337 0.148194
vt 0.528933 0.084957
vt 0.508915 0.084945
vt 0.518925 0.083865
vt 0.529036 0.075429
vt 0.508820 0.075415
vt 0.523751 0.070508
vt 0.514106 0.070501
vt 0.518928 0.067899
vt 0.518929 0.069468
vt 0.518928 0.074259
vt 0.516297 0.074966
vt 0.524236 0.076691
vt 0.521560 0.074970
vt 0.513619 0.076684
vt 0.524601 0.079886
vt 0.513252 0.079879
vt 0.518926 0.079331
vt 0.571787 0.277295
vt 0.568351 0.292904
vt 0.468070 0.278617
vt 0.471978 0.294282
vt 0.573085 0.311386
vt 0.467790 0.313081
vt 0.584855 0.327708
vt 0.456477 0.329961
vt 0.458737 0.268049
vt 0.611720 0.255725
vt 0.580734 0.266620
vt 0.427062 0.257728
vt 0.632494 0.262853
vt 0.406068 0.265508
vt 0.653658 0.279971
vt 0.384904 0.283634
vt 0.656064 0.297636
vt 0.383015 0.301864
vt 0.386858 0.314615
vt 0.652752 0.310186
vt 0.411556 0.327673
vt 0.614408 0.331972
vt 0.629040 0.323864
vt 0.426727 0.335361
vt 0.601033 0.333624
vt 0.440344 0.336537
vt 0.601799 0.328453
vt 0.439372 0.331331
vt 0.450408 0.323919
vt 0.613335 0.327083
vt 0.427623 0.330358
vt 0.626851 0.320513
vt 0.413648 0.324175
vt 0.646248 0.306421
vt 0.393381 0.310510
vt 0.649541 0.296225
vt 0.389662 0.300183
vt 0.647785 0.283486
vt 0.391040 0.287071
vt 0.629829 0.267263
vt 0.408893 0.269959
vt 0.612641 0.261560
vt 0.426254 0.263693
vt 0.585166 0.270991
vt 0.454369 0.272583
vt 0.578124 0.281900
vt 0.461798 0.283441
vt 0.579548 0.309340
vt 0.590644 0.321516
vt 0.461204 0.311233
vt 0.577524 0.293776
vt 0.462754 0.295432
vt 0.553209 0.433063
vt 0.523031 0.433628
vt 0.492809 0.434538
vt 0.609819 0.431516
vt 0.435860 0.435740
vt 0.416915 0.400552
vt 0.396518 0.425416
vt 0.648174 0.419316
vt 0.350292 0.396229
vt 0.692106 0.388274
vt 0.312756 0.350588
vt 0.735879 0.312112
vt 0.726332 0.341754
vt 0.301067 0.320593
vt 0.320452 0.270303
vt 0.304876 0.261087
vt 0.698172 0.216906
vt 0.729900 0.256393
vt 0.337414 0.219179
vt 0.663103 0.190671
vt 0.373474 0.191872
vt 0.649444 0.022378
vt 0.621440 0.048089
vt 0.626908 0.015608
vt 0.388827 0.021586
vt 0.416419 0.047631
vt 0.376796 0.075296
vt 0.577206 0.032801
vt 0.567460 0.000144
vt 0.411318 0.015131
vt 0.460782 0.032656
vt 0.547413 0.041724
vt 0.518922 0.024886
vt 0.470636 0.000144
vt 0.490511 0.041669
vt 0.558059 0.053871
vt 0.479842 0.053785
vt 0.576951 0.057998
vt 0.460920 0.057845
vt 0.611687 0.078268
vt 0.425932 0.077985
vt 0.660451 0.076084
vt 0.626663 0.111357
vt 0.410618 0.111244
vt 0.629482 0.130456
vt 0.407648 0.130594
vt 0.413741 0.147158
vt 0.619303 0.159841
vt 0.418035 0.160361
vt 0.389677 0.201890
vt 0.886245 0.121777
vt 0.891780 0.036916
vt 0.945900 0.079569
vt 0.141314 0.112482
vt 0.142277 0.021467
vt 0.183115 0.092127
vt 0.849114 0.099732
vt 0.805584 0.010786
vt 0.232648 0.003484
vt 0.246353 0.076510
vt 0.687018 0.077204
vt 0.672384 0.022201
vt 0.349875 0.075955
vt 0.365979 0.020991
vt 0.760215 0.193244
vt 0.789046 0.233323
vt 0.271553 0.193871
vt 0.241255 0.236977
vt 0.909112 0.183261
vt 0.994525 0.167705
vt 0.107928 0.179083
vt 0.078961 0.060719
vt 0.862868 0.338556
vt 0.962901 0.344752
vt 0.911671 0.402429
vt 0.160557 0.356821
vt 0.043968 0.367038
vt 0.123776 0.315519
vt 0.915360 0.259804
vt 0.999856 0.254640
vt 0.098965 0.266968
vt 0.000144 0.259113
vt 0.011829 0.155367
vt 0.749542 0.334683
vt 0.766337 0.300809
vt 0.789162 0.313727
vt 0.267408 0.310142
vt 0.288183 0.346496
vt 0.242992 0.325552
vt 0.815314 0.276388
vt 0.846174 0.293397
vt 0.213065 0.285164
vt 0.178537 0.304983
vt 0.845007 0.256352
vt 0.873517 0.265922
vt 0.179662 0.263312
vt 0.147089 0.274284
vt 0.859075 0.228168
vt 0.886999 0.233769
vt 0.162803 0.231720
vt 0.131514 0.237587
vt 0.875030 0.184705
vt 0.842355 0.195160
vt 0.145224 0.182749
vt 0.894128 0.301884
vt 0.794286 0.364062
vt 0.770185 0.379538
vt 0.239776 0.382592
vt 0.845499 0.449967
vt 0.106400 0.432652
vt 0.815858 0.445381
vt 0.755700 0.418603
vt 0.287033 0.442912
vt 0.219260 0.477186
vt 0.268122 0.398737
vt 0.185281 0.484099
vt 0.819845 0.468071
vt 0.215894 0.503605
vt 0.809631 0.233887
vt 0.219168 0.237388
vt 0.829287 0.219562
vt 0.199067 0.222464
vt 0.788458 0.080826
vt 0.715482 0.139727
vt 0.319538 0.139409
vt 0.246666 0.114850
vt 0.785486 0.152330
vt 0.245969 0.151002
vt 0.623495 0.146796
vt 0.837382 0.156361
vt 0.196622 0.155241
vt 0.171653 0.132294
vt 0.786480 0.117591
vt 0.858171 0.137775
vt 0.432388 0.894943
vt 0.491058 0.881714
vt 0.506166 0.904851
vt 0.321637 0.893225
vt 0.263032 0.878321
vt 0.315867 0.868209
vt 0.572792 0.860484
vt 0.604825 0.879946
vt 0.181486 0.854693
vt 0.247207 0.901159
vt 0.148729 0.873349
vt 0.619962 0.791615
vt 0.136063 0.784093
vt 0.169745 0.787474
vt 0.586396 0.793977
vt 0.563786 0.739211
vt 0.194086 0.733241
vt 0.208656 0.740879
vt 0.549027 0.746412
vt 0.508270 0.697693
vt 0.250811 0.693249
vt 0.258399 0.707497
vt 0.438641 0.680683
vt 0.434803 0.658882
vt 0.320962 0.677959
vt 0.325318 0.656224
vt 0.500314 0.711729
vt 0.452955 0.700023
vt 0.306136 0.696976
vt 0.505666 0.730944
vt 0.252524 0.726592
vt 0.568148 0.787367
vt 0.188269 0.781375
vt 0.214575 0.750414
vt 0.555495 0.826352
vt 0.199850 0.820889
vt 0.501231 0.844356
vt 0.253846 0.840502
vt 0.457832 0.840040
vt 0.297562 0.837358
vt 0.783193 0.187449
vt 0.246955 0.187075
vt 0.233625 0.175620
vt 0.394766 0.686125
vt 0.391039 0.611891
vt 0.364838 0.684445
vt 0.391747 0.862097
vt 0.438797 0.870229
vt 0.363377 0.861308
vt 0.435018 0.718280
vt 0.323658 0.715731
vt 0.384658 0.710299
vt 0.433669 0.729661
vt 0.374400 0.708969
vt 0.410995 0.747662
vt 0.427812 0.742828
vt 0.324726 0.727177
vt 0.347028 0.745816
vt 0.330270 0.740536
vt 0.384657 0.795423
vt 0.418086 0.784946
vt 0.372270 0.794472
vt 0.431333 0.817535
vt 0.401605 0.841460
vt 0.324790 0.815460
vt 0.338952 0.783073
vt 0.354026 0.840297
vt 0.825107 0.209762
vt 0.199767 0.214827
vt 0.816266 0.203086
vt 0.209828 0.206161
vt 0.226485 0.183086
vt 0.796021 0.176969
vt 0.802192 0.184609
vt 0.448505 0.804621
vt 0.473386 0.824700
vt 0.307886 0.802031
vt 0.282357 0.821525
vt 0.321237 0.777208
vt 0.423718 0.754191
vt 0.435868 0.779569
vt 0.334089 0.752045
vt 0.319919 0.747250
vt 0.437950 0.749777
vt 0.312907 0.729222
vt 0.440995 0.724383
vt 0.445392 0.731997
vt 0.317510 0.721697
vt 0.455277 0.713731
vt 0.303460 0.710657
vt 0.512485 0.828811
vt 0.242975 0.824574
vt 0.550942 0.811814
vt 0.204839 0.806417
vt 0.552139 0.787682
vt 0.204331 0.782156
vt 0.539407 0.764539
vt 0.542850 0.755753
vt 0.217774 0.759319
vt 0.508439 0.743135
vt 0.249419 0.738732
vt 0.454776 0.761665
vt 0.302729 0.758742
vt 0.286960 0.745020
vt 0.470841 0.748408
vt 0.475403 0.783904
vt 0.281439 0.780511
vt 0.268291 0.766661
vt 0.503673 0.787562
vt 0.494476 0.802470
vt 0.252972 0.783410
vt 0.261790 0.798626
vt 0.516802 0.807339
vt 0.239243 0.802891
vt 0.237920 0.787045
vt 0.518562 0.791602
vt 0.484068 0.628776
vt 0.543385 0.683538
vt 0.276936 0.625067
vt 0.216123 0.678120
vt 0.581052 0.726933
vt 0.177176 0.720426
vt 0.616701 0.759965
vt 0.140379 0.752377
vt 0.660647 0.741167
vt 0.707492 0.759884
vt 0.097038 0.732052
vt 0.677256 0.670436
vt 0.745511 0.652100
vt 0.049526 0.748824
vt 0.083564 0.662038
vt 0.671403 0.592656
vt 0.740843 0.572428
vt 0.019409 0.639749
vt 0.092820 0.589862
vt 0.834705 0.206959
vt 0.051216 0.522659
vt 0.033664 0.564403
vt 0.620420 0.565675
vt 0.498072 0.552315
vt 0.145041 0.562595
vt 0.264218 0.550140
vt 0.369913 0.610196
vt 0.464579 0.342230
vt 0.176788 0.196179
vt 0.770572 0.444261
vt 0.271364 0.473316
vt 0.488870 0.770464
vt 0.834578 0.206879
vn -0.6617 0.2026 0.7219
vn 0.6617 0.2026 0.7219
vn -0.8268 0.3051 0.4725
vn 0.8268 0.3051 0.4725
vn -0.4076 0.7905 0.4570
vn 0.4076 0.7905 0.4570
vn -0.3791 0.5163 0.7679
vn 0.3791 0.5163 0.7679
vn 0.0859 0.5222 0.8485
vn -0.0859 0.5222 0.8485
vn 0.2664 0.8487 0.4570
vn -0.2664 0.8487 0.4570
vn 0.7824 0.3294 0.5285
vn -0.7606 0.3400 0.5531
vn 0.4706 0.1981 0.8598
vn -0.4706 0.1981 0.8598
vn 0.4649 -0.1958 0.8634
vn -0.4649 -0.1958 0.8634
vn 0.7656 -0.3223 0.5568
vn -0.7683 -0.3293 0.5488
vn 0.2560 -0.8073 0.5317
vn -0.2487 -0.8249 0.5076
vn 0.0821 -0.6023 0.7940
vn -0.1017 -0.5518 0.8277
vn -0.3329 -0.5231 0.7846
vn 0.3861 -0.5446 0.7445
vn -0.4246 -0.7711 0.4745
vn 0.4059 -0.7641 0.5014
vn -0.8251 -0.2968 0.4808
vn 0.8299 -0.2940 0.4742
vn -0.6888 -0.1868 0.7005
vn 0.6617 -0.2026 0.7219
vn -0.8400 -0.3436 -0.4200
vn 0.7816 -0.3058 -0.5437
vn -0.2074 -0.8296 -0.5185
vn 0.2037 -0.8146 -0.5431
vn 0.4056 -0.7605 -0.5070
vn -0.4381 -0.7988 -0.4123
vn 0.8642 -0.3143 -0.3928
vn -0.7861 -0.3276 -0.5241
vn 0.7782 0.3537 -0.5188
vn -0.7782 0.3537 -0.5188
vn 0.4381 0.7988 -0.4123
vn -0.4381 0.7988 -0.4123
vn -0.2037 0.8146 -0.5431
vn 0.2037 0.8146 -0.5431
vn -0.7683 0.3293 -0.5488
vn 0.7683 0.3293 -0.5488
vn -0.4000 0.0623 0.9144
vn 0.4000 0.0623 0.9144
vn -0.3069 0.1754 0.9354
vn 0.3069 0.1754 0.9354
vn -0.0945 0.1835 0.9785
vn 0.0945 0.1835 0.9785
vn 0.0624 0.0283 0.9977
vn -0.0624 0.0283 0.9977
vn 0.0624 -0.0260 0.9977
vn -0.0624 -0.0260 0.9977
vn -0.0996 -0.1729 0.9799
vn 0.0996 -0.1729 0.9799
vn -0.3036 -0.1656 0.9383
vn 0.3036 -0.1656 0.9383
vn -0.4002 -0.0572 0.9147
vn 0.4002 -0.0572 0.9147
vn -0.1367 0.8748 0.4648
vn 0.1054 0.8433 0.5270
vn -0.2303 0.8656 0.4447
vn 0.1916 0.8620 0.4693
vn -0.5788 0.5049 0.6404
vn 0.5788 0.5049 0.6404
vn -0.7763 0.0633 0.6272
vn 0.7763 0.0633 0.6272
vn -0.7471 -0.1132 0.6550
vn 0.7471 -0.1132 0.6550
vn -0.3747 0.8345 0.4040
vn 0.3747 0.8345 0.4040
vn -0.3557 0.7290 0.5848
vn 0.4177 0.5751 0.7034
vn -0.6947 0.4197 0.5841
vn 0.6947 0.4197 0.5841
vn -0.7028 0.3915 0.5939
vn 0.5537 0.2978 0.7777
vn -0.3127 -0.3425 0.8860
vn 0.8227 -0.3606 0.4395
vn -0.5091 -0.6482 0.5663
vn 0.5041 -0.6448 0.5745
vn -0.5977 -0.5565 0.5771
vn 0.5977 -0.5565 0.5771
vn 0.0486 -0.6560 0.7532
vn -0.0371 -0.6685 0.7428
vn 0.7104 -0.2715 0.6494
vn -0.7386 -0.3768 0.5590
vn 0.6013 -0.5262 0.6013
vn -0.5774 -0.5774 0.5774
vn -0.5070 0.6281 0.5903
vn 0.5364 0.3230 0.7797
vn -0.2226 0.4694 0.8545
vn 0.2226 0.4694 0.8545
vn 0.0348 0.5792 0.8144
vn -0.1073 0.5010 0.8588
vn 0.0899 0.7843 0.6138
vn -0.0770 0.5759 0.8139
vn -0.0547 0.1695 0.9840
vn 0.0279 0.8645 0.5019
vn -0.4260 0.0609 0.9027
vn 0.1687 0.3128 0.9347
vn -0.3352 0.1828 0.9243
vn 0.4350 0.1812 0.8820
vn -0.3579 0.3068 0.8819
vn 0.3223 0.2762 0.9054
vn -0.3069 -0.2113 0.9280
vn 0.4815 0.2408 0.8427
vn 0.1598 -0.3903 0.9067
vn -0.1598 -0.3903 0.9067
vn -0.6819 0.2915 0.6709
vn 0.1854 0.4956 0.8485
vn -0.0585 0.0781 0.9952
vn 0.0585 0.0781 0.9952
vn 0.0066 0.2316 0.9728
vn 0.0585 0.0845 0.9947
vn -0.1008 0.7103 0.6966
vn 0.1008 0.7103 0.6966
vn -0.1322 0.5947 0.7930
vn 0.1322 0.5947 0.7930
vn -0.3128 0.1662 0.9352
vn 0.3143 0.3928 0.8642
vn -0.3288 0.0360 0.9437
vn 0.3288 0.0360 0.9437
vn -0.3233 0.0808 0.9429
vn 0.3233 0.0808 0.9429
vn 0.0232 -0.0511 0.9984
vn 0.0000 -0.0665 0.9978
vn 0.0043 0.0651 0.9979
vn 0.0000 0.0665 0.9978
vn 0.0000 0.0000 1.0000
vn -0.8447 0.5335 0.0445
vn 0.8447 0.5335 0.0445
vn -0.9500 -0.2692 -0.1583
vn 0.9500 -0.2692 -0.1583
vn -0.0693 -0.9004 -0.4294
vn 0.1018 -0.9165 -0.3870
vn 1.0000 0.0000 0.0000
vn -0.6905 -0.5492 0.4708
vn -0.4071 0.8956 0.1791
vn 0.4319 0.8639 0.2592
vn -0.2873 0.5747 0.7663
vn 0.2873 0.5747 0.7663
vn 0.6326 -0.5353 0.5596
vn -0.6326 -0.5353 0.5596
vn -0.0862 -0.7759 0.6250
vn 0.0862 -0.7759 0.6250
vn -0.7532 -0.2870 0.5918
vn 0.7639 -0.2971 0.5729
vn -0.3416 0.5409 0.7686
vn 0.3416 0.5409 0.7686
vn -0.0502 -0.2343 0.9709
vn 0.0375 -0.2247 0.9737
vn 0.1304 0.6087 0.7826
vn -0.1304 0.6087 0.7826
vn 0.5059 -0.0716 0.8596
vn -0.5059 -0.0716 0.8596
vn 0.5774 0.5774 0.5774
vn -0.5774 0.5774 0.5774
vn -0.5460 0.4310 0.7184
vn 0.3319 -0.0738 0.9404
vn -0.3231 -0.0311 0.9459
vn 0.2815 -0.0662 0.9573
vn -0.7357 -0.3910 0.5531
vn 0.8753 -0.2059 0.4376
vn -0.8480 -0.3180 0.4240
vn 0.8973 -0.1994 0.3938
vn -0.8505 -0.3798 0.3638
vn 0.8505 -0.3798 0.3638
vn -0.1783 0.4161 0.8917
vn 0.2524 0.8655 0.4327
vn 0.1296 0.1945 0.9723
vn -0.1296 0.1945 0.9723
vn 0.4472 0.0000 0.8944
vn -0.4472 0.0000 0.8944
vn 0.1582 -0.9494 0.2713
vn -0.1582 -0.9494 0.2713
vn 0.6463 -0.7337 0.2096
vn -0.6463 -0.7337 0.2096
vn -1.0000 0.0000 0.0000
vn -0.3051 0.9450 0.1181
vn 0.3051 0.9450 0.1181
vn -0.0217 0.3031 0.9527
vn 0.0217 0.3031 0.9527
vn -0.1353 0.3479 0.9277
vn 0.1353 0.3479 0.9277
vn 0.4681 0.2239 0.8548
vn -0.4681 0.2239 0.8548
vn 0.2710 -0.0271 0.9622
vn -0.2710 -0.0271 0.9622
vn 0.1717 0.0090 0.9851
vn -0.2595 -0.1038 0.9601
vn 0.4332 0.4874 0.7581
vn -0.6684 0.4595 0.5849
vn 0.1599 0.8797 0.4478
vn -0.1599 0.8797 0.4478
vn -0.3900 0.5895 0.7074
vn 0.3900 0.5895 0.7074
vn -0.6547 0.4589 0.6007
vn 0.6547 0.4589 0.6007
vn -0.5378 0.1144 0.8353
vn 0.5378 0.1144 0.8353
vn -0.5657 -0.1197 0.8159
vn 0.5774 -0.1155 0.8083
vn -0.4082 -0.4082 0.8165
vn 0.5214 -0.6574 0.5441
vn -0.1796 -0.7882 0.5886
vn 0.1796 -0.7882 0.5886
vn -0.1881 -0.3387 0.9219
vn 0.1881 -0.3387 0.9219
vn 0.0870 -0.2756 0.9573
vn -0.0870 -0.2756 0.9573
vn -0.2804 0.2181 0.9348
vn 0.3553 0.5739 0.7379
vn -0.3015 0.3015 0.9045
vn 0.3015 0.3015 0.9045
vn 0.3766 0.8339 0.4035
vn -0.0631 0.3156 0.9468
vn -0.0823 0.7822 0.6175
vn -0.2016 0.9071 0.3696
vn 0.3707 0.2851 0.8839
vn -0.3707 0.2851 0.8839
vn 0.2692 0.0577 0.9614
vn -0.4568 -0.0508 0.8881
vn 0.2797 -0.5245 0.8042
vn -0.2797 -0.5245 0.8042
vn 0.0213 -0.5546 0.8319
vn -0.0487 -0.6815 0.7302
vn -0.3778 -0.6342 0.6746
vn 0.3378 -0.5221 0.7831
vn -0.4988 -0.5300 0.6858
vn 0.4988 -0.5300 0.6858
vn -0.5425 0.3391 0.7686
vn 0.5425 0.3391 0.7686
vn -0.8305 0.0615 0.5536
vn 0.8305 0.0615 0.5536
vn -0.7814 -0.1116 0.6140
vn 0.7814 -0.1116 0.6140
vn 0.4338 -0.8888 -0.1481
vn -0.4338 -0.8888 -0.1481
vn 0.8515 -0.3744 -0.3670
vn -0.8515 -0.3744 -0.3670
vn 0.2664 -0.8710 -0.4127
vn -0.2197 -0.8626 -0.4557
vn -0.5932 -0.7445 -0.3063
vn 0.5914 -0.7489 -0.2991
vn -0.3714 -0.8685 -0.3284
vn 0.3653 -0.8833 -0.2938
vn -0.2901 -0.9141 -0.2833
vn 0.2901 -0.9141 -0.2833
vn -0.8873 -0.1343 -0.4412
vn 0.7964 -0.1323 -0.5901
vn -0.5108 0.6649 -0.5450
vn 0.5108 0.6649 -0.5450
vn -0.3695 0.8566 -0.3601
vn 0.3695 0.8566 -0.3601
vn -0.3617 0.3858 -0.8487
vn 0.1649 0.6644 -0.7289
vn -0.1952 0.0976 -0.9759
vn 0.3011 0.0125 -0.9535
vn 0.0107 0.5633 -0.8262
vn 0.2562 0.3112 -0.9152
vn -0.1533 0.9649 -0.2134
vn 0.1533 0.9649 -0.2134
vn -0.1260 0.9624 -0.2406
vn 0.1260 0.9624 -0.2406
vn -0.9396 -0.1573 -0.3041
vn 0.9396 -0.1573 -0.3041
vn -0.9278 -0.1838 -0.3246
vn 0.9278 -0.1838 -0.3246
vn -0.2192 -0.0766 -0.9727
vn 0.2192 -0.0766 -0.9727
vn -0.1211 0.0530 -0.9912
vn -0.1497 0.3635 -0.9195
vn -0.9094 -0.1371 -0.3927
vn 0.3706 0.6780 -0.6349
vn -0.9202 -0.1355 -0.3672
vn 0.9202 -0.1355 -0.3672
vn -0.9173 -0.3440 -0.2007
vn 0.9457 -0.2673 -0.1850
vn -0.9004 -0.3642 -0.2380
vn 0.9337 -0.2813 -0.2215
vn -0.8945 -0.4337 0.1084
vn 0.9501 -0.2455 -0.1922
vn -0.1596 0.9577 -0.2394
vn 0.1835 0.7864 -0.5898
vn -0.3693 0.4712 -0.8010
vn 0.3727 0.4759 -0.7966
vn -0.2986 0.8236 -0.4821
vn 0.3263 0.8342 -0.4446
vn -0.2995 0.9442 -0.1368
vn 0.2995 0.9442 -0.1368
vn -0.3287 0.9163 -0.2291
vn 0.3287 0.9163 -0.2291
vn -0.8305 -0.3333 -0.4463
vn 0.8642 0.4737 0.1696
vn -0.9166 0.3740 0.1414
vn 0.9166 0.3740 0.1414
vn -0.2950 0.0454 -0.9544
vn 0.4189 0.2265 -0.8793
vn -0.1272 -0.9658 0.2260
vn 0.1119 -0.9626 0.2468
vn -0.1320 -0.9750 -0.1788
vn 0.1320 -0.9750 -0.1788
vn -0.3878 -0.6192 -0.6828
vn 0.3878 -0.6192 -0.6828
vn -0.4951 -0.8618 -0.1100
vn 0.4951 -0.8618 -0.1100
vn -0.2561 -0.6447 0.7202
vn 0.2561 -0.6447 0.7202
vn -0.5966 -0.7888 0.1479
vn 0.5966 -0.7888 0.1479
vn -0.7125 -0.6755 -0.1900
vn 0.7125 -0.6755 -0.1900
vn -0.7104 -0.1364 -0.6904
vn 0.6304 -0.2517 -0.7343
vn -0.6823 -0.2318 -0.6933
vn 0.6823 -0.2318 -0.6933
vn -0.6574 -0.7254 -0.2040
vn 0.6574 -0.7254 -0.2040
vn -0.7289 -0.6729 0.1262
vn 0.7289 -0.6729 0.1262
vn -0.7791 -0.4074 0.4764
vn 0.7791 -0.4074 0.4764
vn -0.3669 -0.8840 -0.2898
vn 0.3238 -0.9434 -0.0720
vn -0.2854 -0.6237 0.7277
vn 0.1548 -0.5080 0.8473
vn 0.1681 -0.1005 -0.9806
vn -0.1681 -0.1005 -0.9806
vn -0.2925 -0.5674 0.7697
vn 0.2925 -0.5674 0.7697
vn 0.1616 -0.1847 0.9694
vn -0.1616 -0.1847 0.9694
vn -0.8681 -0.0893 -0.4883
vn 0.9340 -0.2255 0.2773
vn -0.9276 -0.0762 0.3657
vn 0.9276 -0.0762 0.3657
vn -0.9750 -0.2169 0.0490
vn 0.9750 -0.2169 0.0490
vn -0.9817 0.0304 -0.1882
vn 0.9956 -0.0893 -0.0288
vn -0.7466 0.6646 0.0285
vn 0.6374 0.7651 0.0915
vn -0.3723 0.9243 0.0847
vn 0.3720 0.9244 0.0845
vn -0.3986 0.8754 0.2734
vn 0.3986 0.8754 0.2734
vn -0.6328 0.7642 0.1247
vn 0.6328 0.7642 0.1247
vn -0.7325 0.6368 0.2407
vn 0.7325 0.6368 0.2407
vn -0.2637 0.4499 0.8533
vn 0.2637 0.4499 0.8533
vn -0.5881 0.3070 -0.7483
vn 0.5236 0.3290 -0.7859
vn -0.4694 0.2400 -0.8498
vn 0.5396 0.3343 -0.7727
vn -0.4463 0.8452 -0.2941
vn 0.2144 0.8341 -0.5082
vn -0.6973 0.6610 -0.2771
vn 0.7365 0.6154 -0.2808
vn -0.4972 0.4408 -0.7473
vn 0.4972 0.4408 -0.7473
vn -0.3691 -0.2855 0.8844
vn 0.3244 -0.4867 0.8111
vn -0.4467 -0.0975 0.8894
vn 0.4467 -0.0975 0.8894
vn -0.3188 -0.1993 0.9266
vn 0.1817 0.0079 0.9833
vn -0.2076 0.0836 0.9746
vn 0.2925 0.0758 0.9533
vn -0.3398 -0.0824 0.9369
vn 0.5847 0.2198 0.7809
vn -0.5957 0.3850 0.7049
vn 0.5957 0.3850 0.7049
vn -0.4843 -0.5580 0.6738
vn 0.4843 -0.5580 0.6738
vn 0.2675 -0.8318 0.4864
vn -0.2675 -0.8318 0.4864
vn 0.8576 -0.2223 0.4637
vn -0.7885 -0.2366 0.5677
vn 0.5257 0.3579 0.7717
vn -0.5242 0.3548 0.7742
vn -0.4663 0.5991 0.6509
vn 0.4390 0.5252 0.7290
vn -0.7104 0.4567 0.5356
vn 0.7104 0.4567 0.5356
vn -0.7507 0.6131 -0.2461
vn 0.6302 0.7658 0.1282
vn 0.1788 -0.2923 0.9395
vn -0.2175 -0.2733 0.9370
vn -0.9042 0.3578 -0.2332
vn 0.9042 0.3578 -0.2332
vn -0.0400 -0.3399 0.9396
vn 0.0400 -0.3399 0.9396
vn -0.2734 -0.9064 0.3221
vn 0.2734 -0.9064 0.3221
vn -0.4480 0.4480 0.7737
vn 0.7177 -0.1689 0.6755
vn -0.5534 0.5534 0.6225
vn 0.9008 0.4075 0.1501
vn -0.5724 0.3122 0.7582
vn 0.5815 0.5217 0.6243
vn -0.5597 0.5533 0.6169
vn 0.6138 0.2571 0.7465
vn -0.8271 -0.5323 -0.1802
vn 0.8271 -0.5323 -0.1802
vn -0.9227 0.3765 -0.0825
vn 0.8717 0.4446 -0.2063
vn -0.9972 0.0181 -0.0725
vn 0.9972 0.0181 -0.0725
vn -0.6895 0.6644 0.2883
vn 0.6895 0.6644 0.2883
vn -0.7815 0.6176 0.0882
vn 0.7930 0.5947 0.1322
vn -0.7022 0.7022 0.1170
vn 0.7022 0.7022 0.1170
vn -0.1240 -0.9921 0.0207
vn 0.2408 -0.9631 -0.1204
vn -0.9435 -0.3145 0.1048
vn 0.9251 -0.3469 0.1542
vn -0.6213 0.7767 0.1036
vn 0.6213 0.7767 0.1036
vn 0.0000 -1.0000 0.0000
vn -0.6197 0.6899 0.3742
vn 0.6197 0.6899 0.3742
vn -0.2752 0.8808 0.3853
vn 0.2752 0.8808 0.3853
vn 0.7929 0.5252 -0.3089
vn -0.7929 0.5252 -0.3089
vn 0.8096 -0.2429 -0.5343
vn -0.8538 -0.2328 -0.4657
vn 0.5621 -0.8231 -0.0803
vn -0.5433 -0.6985 -0.4657
vn 0.0071 -0.9899 0.1414
vn -0.1096 -0.9939 -0.0157
vn -0.1046 -0.0392 0.9937
vn 0.1738 -0.0097 0.9847
vn -0.2461 -0.0852 0.9655
vn 0.4134 -0.0413 0.9096
vn -0.3009 -0.0926 0.9491
vn 0.3009 -0.0926 0.9491
vn -0.2104 -0.0124 0.9775
vn 0.1220 -0.0458 0.9915
vn 0.0099 -0.3867 0.9221
vn -0.0099 -0.3867 0.9221
vn -0.3787 0.0364 0.9248
vn 0.4244 0.0320 0.9049
vn -0.2530 0.1897 0.9487
vn 0.2570 -0.0723 0.9637
vn 0.4870 -0.6088 0.6262
vn -0.2981 -0.7454 0.5963
vn -0.6693 -0.1802 0.7208
vn 0.6693 -0.1802 0.7208
vn -0.4388 0.2008 0.8759
vn 0.4723 0.1986 0.8588
vn -0.5786 0.1334 0.8046
vn 0.2975 0.4062 0.8640
vn -0.5002 -0.2833 0.8182
vn 0.5002 -0.2833 0.8182
vn -0.2980 -0.5802 0.7580
vn 0.2980 -0.5802 0.7580
vn -0.0929 0.9912 -0.0944
vn 0.0929 0.9912 -0.0944
vn -0.4688 0.8715 0.1442
vn 0.4688 0.8715 0.1442
vn -0.9309 0.2541 0.2624
vn 0.9264 0.2460 0.2851
vn -0.8465 -0.5291 -0.0595
vn 0.8267 -0.5627 -0.0035
vn 0.2511 -0.9439 -0.2145
vn -0.2146 -0.9243 -0.3157
vn 0.4841 -0.8743 -0.0361
vn -0.4196 -0.8851 -0.2012
vn 0.5256 0.0030 -0.8507
vn -0.5470 0.0144 -0.8370
vn 0.1466 -0.0104 -0.9891
vn -0.1466 -0.0104 -0.9891
vn -0.4046 -0.0266 -0.9141
vn 0.4046 -0.0266 -0.9141
vn 0.8073 -0.5901 0.0041
vn -0.7330 -0.6786 0.0472
vn -0.4200 0.2291 -0.8781
vn 0.4200 0.2291 -0.8781
vn 0.0687 0.9943 -0.0818
vn -0.0687 0.9943 -0.0818
vn -0.6713 0.1971 0.7145
vn 0.6713 0.1971 0.7145
vn -0.8326 0.3017 0.4646
vn 0.8326 0.3017 0.4646
vn -0.4258 0.7967 0.4290
vn 0.4258 0.7967 0.4290
vn -0.3265 0.4954 0.8050
vn 0.3265 0.4954 0.8050
vn 0.0649 0.5714 0.8181
vn -0.0649 0.5714 0.8181
vn 0.2738 0.8315 0.4834
vn -0.2738 0.8315 0.4834
vn 0.7606 0.3400 0.5531
vn -0.7824 0.3294 0.5285
vn 0.4658 0.1863 0.8651
vn -0.4658 0.1863 0.8651
vn 0.4983 -0.1812 0.8478
vn -0.4983 -0.1812 0.8478
vn 0.7683 -0.3293 0.5488
vn -0.7656 -0.3223 0.5568
vn 0.2487 -0.8249 0.5076
vn -0.2560 -0.8073 0.5317
vn 0.1017 -0.5518 0.8277
vn -0.0821 -0.6023 0.7940
vn -0.3861 -0.5446 0.7445
vn 0.3329 -0.5231 0.7846
vn -0.4059 -0.7641 0.5014
vn 0.4246 -0.7711 0.4745
vn -0.8299 -0.2940 0.4742
vn 0.8251 -0.2968 0.4808
vn -0.6617 -0.2026 0.7219
vn 0.6888 -0.1868 0.7005
vn -0.7816 -0.3058 -0.5437
vn 0.8400 -0.3436 -0.4200
vn -0.2037 -0.8146 -0.5431
vn 0.2074 -0.8296 -0.5185
vn 0.4381 -0.7988 -0.4123
vn -0.4056 -0.7605 -0.5070
vn 0.7861 -0.3276 -0.5241
vn -0.8642 -0.3143 -0.3928
vn 0.8519 0.3408 -0.3976
vn -0.8519 0.3408 -0.3976
vn 0.4056 0.7605 -0.5070
vn -0.4056 0.7605 -0.5070
vn -0.2074 0.8296 -0.5185
vn 0.2074 0.8296 -0.5185
vn -0.8297 0.3734 -0.4149
vn 0.8297 0.3734 -0.4149
vn -0.1054 0.8433 0.5270
vn 0.1367 0.8748 0.4648
vn -0.1916 0.8620 0.4693
vn 0.2303 0.8656 0.4447
vn -0.5959 0.4256 0.6810
vn 0.5959 0.4256 0.6810
vn -0.7563 0.0299 0.6535
vn 0.7563 0.0299 0.6535
vn -0.8069 -0.0689 0.5866
vn 0.8069 -0.0689 0.5866
vn -0.2334 0.7779 0.5834
vn 0.2334 0.7779 0.5834
vn -0.4177 0.5751 0.7034
vn 0.3557 0.7290 0.5848
vn -0.6872 0.4191 0.5934
vn 0.6872 0.4191 0.5934
vn -0.5537 0.2978 0.7777
vn 0.7028 0.3915 0.5939
vn -0.8227 -0.3606 0.4395
vn 0.3127 -0.3425 0.8860
vn -0.5041 -0.6448 0.5745
vn 0.5091 -0.6482 0.5663
vn -0.6155 -0.4924 0.6155
vn 0.6155 -0.4924 0.6155
vn 0.0371 -0.6685 0.7428
vn -0.0486 -0.6560 0.7532
vn 0.7386 -0.3768 0.5590
vn -0.7104 -0.2715 0.6494
vn 0.5774 -0.5774 0.5774
vn -0.6013 -0.5262 0.6013
vn -0.5364 0.3230 0.7797
vn 0.5070 0.6281 0.5903
vn -0.2181 0.4685 0.8561
vn 0.2181 0.4685 0.8561
vn 0.1073 0.5010 0.8588
vn -0.0348 0.5792 0.8144
vn 0.0770 0.5759 0.8139
vn -0.0899 0.7843 0.6138
vn -0.0279 0.8645 0.5019
vn 0.0547 0.1695 0.9840
vn -0.1687 0.3128 0.9347
vn 0.4260 0.0609 0.9027
vn -0.4350 0.1812 0.8820
vn 0.3352 0.1828 0.9243
vn -0.3223 0.2762 0.9054
vn 0.3579 0.3068 0.8819
vn -0.4815 0.2408 0.8427
vn 0.3069 -0.2113 0.9280
vn 0.0317 0.1899 0.9813
vn -0.0317 0.1899 0.9813
vn -0.1854 0.4956 0.8485
vn 0.6819 0.2915 0.6709
vn -0.2623 0.3498 0.8994
vn 0.2623 0.3498 0.8994
vn -0.0585 0.0845 0.9947
vn -0.0066 0.2316 0.9728
vn 0.0136 0.6507 0.7592
vn -0.0136 0.6507 0.7592
vn -0.2404 0.5476 0.8014
vn 0.2404 0.5476 0.8014
vn -0.3143 0.3928 0.8642
vn 0.3128 0.1662 0.9352
vn -0.2821 0.0164 0.9592
vn 0.2821 0.0164 0.9592
vn -0.3273 0.1432 0.9340
vn 0.3273 0.1432 0.9340
vn -0.0232 -0.0511 0.9984
vn -0.0043 0.0651 0.9979
vn -0.7826 0.6087 -0.1304
vn 0.7826 0.6087 -0.1304
vn -0.9448 -0.1919 -0.2657
vn 0.9448 -0.1919 -0.2657
vn -0.1018 -0.9165 -0.3870
vn 0.0693 -0.9004 -0.4294
vn 0.6905 -0.5492 0.4708
vn -0.4319 0.8639 0.2592
vn 0.4071 0.8956 0.1791
vn 0.6667 -0.6667 0.3333
vn -0.6667 -0.6667 0.3333
vn -0.1348 -0.8086 0.5727
vn 0.1348 -0.8086 0.5727
vn -0.7639 -0.2971 0.5729
vn 0.7532 -0.2870 0.5918
vn -0.4116 0.8575 0.3087
vn 0.4116 0.8575 0.3087
vn -0.0375 -0.2247 0.9737
vn 0.0502 -0.2343 0.9709
vn -0.1304 0.2609 0.9565
vn 0.1304 0.2609 0.9565
vn 0.0631 0.8206 0.5681
vn -0.0631 0.8206 0.5681
vn -0.7325 -0.2817 0.6198
vn 0.7325 -0.2817 0.6198
vn -0.3319 -0.0738 0.9404
vn 0.5460 0.4310 0.7184
vn -0.2815 -0.0662 0.9573
vn 0.3231 -0.0311 0.9459
vn -0.8753 -0.2059 0.4376
vn 0.7357 -0.3910 0.5531
vn -0.8973 -0.1994 0.3938
vn 0.8480 -0.3180 0.4240
vn -0.9586 -0.0664 0.2767
vn 0.9586 -0.0664 0.2767
vn -0.2524 0.8655 0.4327
vn 0.1783 0.4161 0.8917
vn 0.1751 0.2043 0.9631
vn -0.1751 0.2043 0.9631
vn 0.1219 0.1829 0.9755
vn -0.1219 0.1829 0.9755
vn 0.1562 -0.3123 0.9370
vn -0.1562 -0.3123 0.9370
vn 0.7238 -0.6857 0.0762
vn -0.7238 -0.6857 0.0762
vn -0.0478 0.2870 0.9567
vn 0.0478 0.2870 0.9567
vn 0.5488 0.3293 0.7683
vn -0.5488 0.3293 0.7683
vn 0.4945 0.1130 0.8618
vn -0.4945 0.1130 0.8618
vn 0.2595 -0.1038 0.9601
vn -0.1717 0.0090 0.9851
vn 0.6684 0.4595 0.5849
vn -0.4332 0.4874 0.7581
vn 0.1156 0.6359 0.7631
vn -0.1156 0.6359 0.7631
vn -0.4242 0.6211 0.6590
vn 0.4242 0.6211 0.6590
vn -0.4767 0.3557 0.8039
vn 0.4767 0.3557 0.8039
vn -0.5871 0.0839 0.8052
vn 0.5871 0.0839 0.8052
vn -0.5774 -0.1155 0.8083
vn 0.5657 -0.1197 0.8159
vn -0.5214 -0.6574 0.5441
vn 0.4082 -0.4082 0.8165
vn -0.3358 -0.3478 0.8754
vn 0.3358 -0.3478 0.8754
vn -0.1452 -0.3774 0.9146
vn 0.1452 -0.3774 0.9146
vn -0.0301 -0.2306 0.9726
vn 0.0301 -0.2306 0.9726
vn -0.3553 0.5739 0.7379
vn 0.2804 0.2181 0.9348
vn -0.2627 0.2252 0.9382
vn 0.2627 0.2252 0.9382
vn 0.0631 0.3156 0.9468
vn -0.3766 0.8339 0.4035
vn 0.2016 0.9071 0.3696
vn 0.0823 0.7822 0.6175
vn 0.3356 0.2397 0.9110
vn -0.3356 0.2397 0.9110
vn 0.4568 -0.0508 0.8881
vn -0.2692 0.0577 0.9614
vn 0.0247 -0.4072 0.9130
vn -0.0247 -0.4072 0.9130
vn 0.0487 -0.6815 0.7302
vn -0.0213 -0.5546 0.8319
vn -0.3378 -0.5221 0.7831
vn 0.3778 -0.6342 0.6746
vn -0.7895 0.3158 0.5263
vn 0.7895 0.3158 0.5263
vn -0.8070 0.0807 0.5851
vn 0.8070 0.0807 0.5851
vn -0.7868 -0.1210 0.6052
vn 0.7868 -0.1210 0.6052
vn 0.6357 -0.6811 -0.3633
vn -0.6357 -0.6811 -0.3633
vn 0.8507 -0.3650 -0.3783
vn -0.8507 -0.3650 -0.3783
vn 0.2197 -0.8626 -0.4557
vn -0.2664 -0.8710 -0.4127
vn -0.5914 -0.7489 -0.2991
vn 0.5932 -0.7445 -0.3063
vn -0.3653 -0.8833 -0.2938
vn 0.3714 -0.8685 -0.3284
vn -0.2760 -0.9159 -0.2915
vn 0.2760 -0.9159 -0.2915
vn -0.7964 -0.1323 -0.5901
vn 0.8873 -0.1343 -0.4412
vn -0.5442 0.7524 -0.3712
vn 0.5442 0.7524 -0.3712
vn -0.4027 0.7323 -0.5492
vn 0.4027 0.7323 -0.5492
vn -0.1649 0.6644 -0.7289
vn 0.3617 0.3858 -0.8487
vn -0.3011 0.0125 -0.9535
vn 0.1952 0.0976 -0.9759
vn -0.2562 0.3112 -0.9152
vn -0.0107 0.5633 -0.8262
vn -0.0779 0.9948 -0.0663
vn 0.0779 0.9948 -0.0663
vn -0.1094 0.9718 -0.2089
vn 0.1094 0.9718 -0.2089
vn -0.8150 0.5621 -0.1405
vn 0.8150 0.5621 -0.1405
vn -0.9358 -0.1396 -0.3236
vn 0.9358 -0.1396 -0.3236
vn -0.1132 0.0274 -0.9932
vn 0.1132 0.0274 -0.9932
vn 0.1497 0.3635 -0.9195
vn 0.1211 0.0530 -0.9912
vn -0.3706 0.6780 -0.6349
vn 0.9094 -0.1371 -0.3927
vn -0.9193 -0.1393 -0.3682
vn 0.9193 -0.1393 -0.3682
vn -0.9457 -0.2673 -0.1850
vn 0.9173 -0.3440 -0.2007
vn -0.9337 -0.2813 -0.2215
vn 0.9004 -0.3642 -0.2380
vn -0.9501 -0.2455 -0.1922
vn 0.8945 -0.4337 0.1084
vn -0.1835 0.7864 -0.5898
vn 0.1596 0.9577 -0.2394
vn -0.3727 0.4759 -0.7966
vn 0.3693 0.4712 -0.8010
vn -0.3263 0.8342 -0.4446
vn 0.2986 0.8236 -0.4821
vn -0.2620 0.9574 -0.1217
vn 0.2620 0.9574 -0.1217
vn -0.2996 0.9443 -0.1362
vn 0.2996 0.9443 -0.1362
vn -0.8642 0.4737 0.1696
vn 0.8305 -0.3333 -0.4463
vn -0.6869 0.6358 0.3521
vn 0.6869 0.6358 0.3521
vn -0.4189 0.2265 -0.8793
vn 0.2950 0.0454 -0.9544
vn -0.1119 -0.9626 0.2468
vn 0.1272 -0.9658 0.2260
vn -0.1208 -0.9734 -0.1947
vn 0.1208 -0.9734 -0.1947
vn -0.3140 -0.5711 -0.7585
vn 0.3140 -0.5711 -0.7585
vn -0.3231 -0.9288 -0.1817
vn 0.3231 -0.9288 -0.1817
vn -0.0452 -0.7955 0.6043
vn 0.0452 -0.7955 0.6043
vn -0.6144 -0.7696 0.1738
vn 0.6144 -0.7696 0.1738
vn -0.6935 -0.6857 -0.2212
vn 0.6935 -0.6857 -0.2212
vn -0.6304 -0.2517 -0.7343
vn 0.7104 -0.1364 -0.6904
vn -0.3179 -0.5704 -0.7574
vn 0.3179 -0.5704 -0.7574
vn -0.6289 -0.7624 -0.1525
vn 0.6289 -0.7624 -0.1525
vn -0.7088 -0.6833 0.1752
vn 0.7088 -0.6833 0.1752
vn -0.6885 -0.3830 0.6158
vn 0.6885 -0.3830 0.6158
vn -0.3238 -0.9434 -0.0720
vn 0.3669 -0.8840 -0.2898
vn -0.1548 -0.5080 0.8473
vn 0.2854 -0.6237 0.7277
vn 0.1819 -0.1145 -0.9766
vn -0.1819 -0.1145 -0.9766
vn 0.2638 -0.9462 -0.1871
vn -0.2638 -0.9462 -0.1871
vn -0.9340 -0.2255 0.2773
vn 0.8681 -0.0893 -0.4883
vn -0.9758 -0.1241 0.1800
vn 0.9758 -0.1241 0.1800
vn -0.9613 -0.1472 -0.2330
vn 0.9613 -0.1472 -0.2330
vn -0.9956 -0.0893 -0.0288
vn 0.9817 0.0304 -0.1882
vn -0.6374 0.7651 0.0915
vn 0.7466 0.6646 0.0285
vn -0.3720 0.9244 0.0845
vn 0.3723 0.9243 0.0847
vn -0.5281 0.8354 0.1522
vn 0.5281 0.8354 0.1522
vn -0.3070 0.5237 0.7946
vn 0.3070 0.5237 0.7946
vn -0.5236 0.3290 -0.7859
vn 0.5881 0.3070 -0.7483
vn -0.5396 0.3343 -0.7727
vn 0.4694 0.2400 -0.8498
vn -0.2144 0.8341 -0.5082
vn 0.4463 0.8452 -0.2941
vn -0.7365 0.6154 -0.2808
vn 0.6973 0.6610 -0.2771
vn -0.3244 -0.4867 0.8111
vn 0.3691 -0.2855 0.8844
vn -0.4649 -0.2593 0.8465
vn 0.4649 -0.2593 0.8465
vn -0.1817 0.0079 0.9833
vn 0.3188 -0.1993 0.9266
vn -0.2925 0.0758 0.9533
vn 0.2076 0.0836 0.9746
vn -0.5847 0.2198 0.7809
vn 0.3398 -0.0824 0.9369
vn -0.6509 0.1939 0.7340
vn 0.6509 0.1939 0.7340
vn -0.4075 -0.7506 0.5201
vn 0.4075 -0.7506 0.5201
vn 0.2655 -0.8296 0.4911
vn -0.2655 -0.8296 0.4911
vn 0.7885 -0.2366 0.5677
vn -0.8576 -0.2223 0.4637
vn 0.5242 0.3548 0.7742
vn -0.5257 0.3579 0.7717
vn -0.4390 0.5252 0.7290
vn 0.4663 0.5991 0.6509
vn -0.6888 0.4428 0.5740
vn 0.6888 0.4428 0.5740
vn -0.6302 0.7658 0.1282
vn 0.7507 0.6131 -0.2461
vn 0.2175 -0.2733 0.9370
vn -0.1788 -0.2923 0.9395
vn -0.9046 0.3869 -0.1792
vn 0.9046 0.3869 -0.1792
vn -0.1782 0.0891 0.9800
vn 0.1782 0.0891 0.9800
vn 0.2335 -0.8972 0.3749
vn -0.2335 -0.8972 0.3749
vn -0.7177 -0.1689 0.6755
vn 0.4480 0.4480 0.7737
vn -0.5313 -0.5844 0.6134
vn 0.5313 -0.5844 0.6134
vn -0.9008 0.4075 0.1501
vn 0.5534 0.5534 0.6225
vn -0.5815 0.5217 0.6243
vn 0.5724 0.3122 0.7582
vn -0.6138 0.2571 0.7465
vn 0.5597 0.5533 0.6169
vn -0.8779 0.4788 0.0076
vn 0.8779 0.4788 0.0076
vn -0.8717 0.4446 -0.2063
vn 0.9227 0.3765 -0.0825
vn -0.7661 0.6363 0.0909
vn 0.7661 0.6363 0.0909
vn -0.7930 0.5947 0.1322
vn 0.7815 0.6176 0.0882
vn -0.2408 -0.9631 -0.1204
vn 0.1240 -0.9921 0.0207
vn -0.9251 -0.3469 0.1542
vn 0.9435 -0.3145 0.1048
vn -0.7071 0.7071 0.0000
vn 0.7071 0.7071 0.0000
vn 0.0157 -0.9898 0.1414
vn -0.0157 -0.9898 0.1414
vn -0.6266 0.7211 0.2956
vn 0.6266 0.7211 0.2956
vn -0.2714 0.9022 0.3353
vn 0.2714 0.9022 0.3353
vn 0.8651 0.4853 -0.1266
vn -0.8651 0.4853 -0.1266
vn 0.8538 -0.2328 -0.4657
vn -0.8096 -0.2429 -0.5343
vn 0.5433 -0.6985 -0.4657
vn -0.5621 -0.8231 -0.0803
vn 0.1096 -0.9939 -0.0157
vn -0.0071 -0.9899 0.1414
vn -0.1738 -0.0097 0.9847
vn 0.1046 -0.0392 0.9937
vn -0.4134 -0.0413 0.9096
vn 0.2461 -0.0852 0.9655
vn -0.3228 0.0461 0.9453
vn 0.3228 0.0461 0.9453
vn -0.1220 -0.0458 0.9915
vn 0.2104 -0.0124 0.9775
vn -0.5679 -0.1916 0.8005
vn 0.5679 -0.1916 0.8005
vn -0.4244 0.0320 0.9049
vn 0.3787 0.0364 0.9248
vn -0.2570 -0.0723 0.9637
vn 0.2530 0.1897 0.9487
vn -0.1351 0.0225 0.9906
vn 0.1351 0.0225 0.9906
vn 0.2981 -0.7454 0.5963
vn -0.4870 -0.6088 0.6262
vn -0.5571 0.1486 0.8171
vn 0.5571 0.1486 0.8171
vn -0.4723 0.1986 0.8588
vn 0.4388 0.2008 0.8759
vn -0.2975 0.4062 0.8640
vn 0.5786 0.1334 0.8046
vn -0.5771 -0.2164 0.7875
vn 0.5771 -0.2164 0.7875
vn -0.0931 0.9932 -0.0692
vn 0.0931 0.9932 -0.0692
vn -0.5161 0.8527 -0.0812
vn 0.5161 0.8527 -0.0812
vn -0.9264 0.2460 0.2851
vn 0.9309 0.2541 0.2624
vn -0.8267 -0.5627 -0.0035
vn 0.8465 -0.5291 -0.0595
vn 0.2146 -0.9243 -0.3157
vn -0.2511 -0.9439 -0.2145
vn 0.4196 -0.8851 -0.2012
vn -0.4841 -0.8743 -0.0361
vn 0.5470 0.0144 -0.8370
vn -0.5256 0.0030 -0.8507
vn 0.2556 0.0749 -0.9639
vn -0.2556 0.0749 -0.9639
vn 0.7330 -0.6786 0.0472
vn -0.8073 -0.5901 0.0041
vn -0.6844 0.1711 -0.7088
vn 0.6844 0.1711 -0.7088
vn 0.3604 0.8283 -0.4290
vn -0.3604 0.8283 -0.4290
usemtl None
s off
f 47/1/1 3/2/1 45/3/1
f 4/4/2 48/5/2 46/6/2
f 45/3/3 5/7/3 43/8/3
f 6/9/4 46/6/4 44/10/4
f 3/2/5 7/11/5 5/7/5
f 8/12/6 4/4/6 6/9/6
f 1/13/7 9/14/7 3/2/7
f 10/15/8 2/16/8 4/4/8
f 11/17/9 15/18/9 9/14/9
f 16/19/10 12/20/10 10/15/10
f 9/14/11 17/21/11 7/11/11
f 18/22/12 10/15/12 8/12/12
f 21/23/13 17/21/13 15/18/13
f 22/24/14 18/22/14 20/25/14
f 13/26/15 21/23/15 15/18/15
f 22/24/16 14/27/16 16/19/16
f 23/28/17 27/29/17 21/23/17
f 28/30/18 24/31/18 22/24/18
f 27/29/19 19/32/19 21/23/19
f 28/30/20 20/25/20 30/33/20
f 33/34/21 29/35/21 27/29/21
f 34/36/22 30/33/22 32/37/22
f 35/38/23 27/29/23 25/39/23
f 36/40/24 28/30/24 34/36/24
f 37/41/25 33/34/25 35/38/25
f 38/42/26 34/36/26 40/43/26
f 39/44/27 31/45/27 33/34/27
f 40/43/28 32/37/28 42/46/28
f 45/3/29 41/47/29 39/44/29
f 46/6/30 42/46/30 44/10/30
f 47/1/31 39/44/31 37/41/31
f 48/5/32 40/43/32 46/6/32
f 37/41/33 49/48/33 47/1/33
f 38/42/34 50/49/34 52/50/34
f 35/38/35 51/51/35 37/41/35
f 36/40/36 52/50/36 54/52/36
f 25/39/37 53/53/37 35/38/37
f 26/54/38 54/52/38 56/55/38
f 23/28/39 55/56/39 25/39/39
f 24/31/40 56/55/40 58/57/40
f 23/28/41 59/58/41 57/59/41
f 60/60/42 24/31/42 58/57/42
f 13/26/43 63/61/43 59/58/43
f 64/62/44 14/27/44 60/60/44
f 11/17/45 65/63/45 63/61/45
f 66/64/46 12/20/46 64/62/46
f 1/13/47 49/48/47 65/63/47
f 50/49/48 2/16/48 66/64/48
f 61/65/49 65/63/49 49/48/49
f 50/49/50 66/64/50 62/66/50
f 63/61/51 65/63/51 61/65/51
f 62/66/52 66/64/52 64/62/52
f 61/65/53 59/58/53 63/61/53
f 64/62/54 60/60/54 62/66/54
f 61/65/55 57/59/55 59/58/55
f 60/60/56 58/57/56 62/66/56
f 61/65/57 55/56/57 57/59/57
f 58/57/58 56/55/58 62/66/58
f 61/65/59 53/53/59 55/56/59
f 56/55/60 54/52/60 62/66/60
f 61/65/61 51/51/61 53/53/61
f 54/52/62 52/50/62 62/66/62
f 61/65/63 49/48/63 51/51/63
f 52/50/64 50/49/64 62/66/64
f 174/67/65 91/68/65 89/69/65
f 175/70/66 91/68/66 176/71/66
f 172/72/67 89/69/67 87/73/67
f 173/74/68 90/75/68 175/70/68
f 85/76/69 172/72/69 87/73/69
f 173/74/70 86/77/70 88/78/70
f 83/79/71 170/80/71 85/76/71
f 171/81/72 84/82/72 86/77/72
f 81/83/73 168/84/73 83/79/73
f 169/85/74 82/86/74 84/82/74
f 79/87/75 146/88/75 164/89/75
f 147/90/76 80/91/76 165/92/76
f 94/93/77 146/88/77 92/94/77
f 95/95/78 147/90/78 149/96/78
f 94/93/79 150/97/79 148/98/79
f 151/99/80 95/95/80 149/96/80
f 98/100/81 150/97/81 96/101/81
f 99/102/82 151/99/82 153/103/82
f 100/104/83 152/105/83 98/100/83
f 101/106/84 153/103/84 155/107/84
f 102/108/85 154/109/85 100/104/85
f 103/110/86 155/107/86 157/111/86
f 102/108/87 158/112/87 156/113/87
f 159/114/88 103/110/88 157/111/88
f 106/115/89 158/112/89 104/116/89
f 107/117/90 159/114/90 161/118/90
f 108/119/91 160/120/91 106/115/91
f 109/121/92 161/118/92 163/122/92
f 67/123/93 162/124/93 108/119/93
f 67/123/94 163/122/94 68/125/94
f 128/126/95 162/124/95 110/127/95
f 129/128/96 163/122/96 161/118/96
f 128/126/97 158/112/97 160/120/97
f 159/114/98 129/128/98 161/118/98
f 156/113/99 179/129/99 126/130/99
f 157/111/100 180/131/100 159/114/100
f 154/109/101 126/130/101 124/132/101
f 155/107/102 127/133/102 157/111/102
f 152/105/103 124/132/103 122/134/103
f 153/103/104 125/135/104 155/107/104
f 150/97/105 122/134/105 120/136/105
f 151/99/106 123/137/106 153/103/106
f 148/98/107 120/136/107 118/138/107
f 149/96/108 121/139/108 151/99/108
f 146/88/109 118/138/109 116/140/109
f 147/90/110 119/141/110 149/96/110
f 164/89/111 116/140/111 114/142/111
f 165/92/112 117/143/112 147/90/112
f 114/142/113 177/144/113 164/89/113
f 177/144/114 115/145/114 165/92/114
f 162/124/115 112/146/115 110/127/115
f 163/122/116 113/147/116 68/125/116
f 112/146/117 178/148/117 183/149/117
f 178/148/118 113/147/118 184/150/118
f 181/151/119 178/148/119 177/144/119
f 182/152/120 178/148/120 184/150/120
f 135/153/121 176/71/121 174/67/121
f 176/71/122 136/154/122 175/70/122
f 133/155/123 174/67/123 172/72/123
f 175/70/124 134/156/124 173/74/124
f 133/155/125 170/80/125 131/157/125
f 134/156/126 171/81/126 173/74/126
f 166/158/127 185/159/127 168/84/127
f 186/160/128 167/161/128 169/85/128
f 131/157/129 168/84/129 185/159/129
f 169/85/130 132/162/130 186/160/130
f 190/163/131 187/164/131 144/165/131
f 190/163/132 188/166/132 189/167/132
f 187/164/133 69/168/133 185/159/133
f 188/166/134 69/168/134 189/167/134
f 131/157/135 69/168/135 130/169/135
f 132/162/135 69/168/135 186/160/135
f 142/170/136 191/171/136 144/165/136
f 192/172/137 143/173/137 145/174/137
f 140/175/138 193/176/138 142/170/138
f 194/177/139 141/178/139 143/173/139
f 197/179/140 140/175/140 139/180/140
f 198/181/141 141/178/141 196/182/141
f 71/183/142 139/180/142 138/184/142
f 71/183/143 139/180/143 198/181/143
f 144/165/144 70/185/144 190/163/144
f 145/174/145 70/185/145 192/172/145
f 191/171/146 208/186/146 70/185/146
f 192/172/147 208/186/147 207/187/147
f 71/183/148 200/188/148 197/179/148
f 201/189/149 71/183/149 198/181/149
f 197/179/150 202/190/150 195/191/150
f 203/192/151 198/181/151 196/182/151
f 202/190/152 193/176/152 195/191/152
f 203/192/153 194/177/153 205/193/153
f 193/176/154 206/194/154 191/171/154
f 207/187/155 194/177/155 192/172/155
f 204/195/156 200/188/156 199/196/156
f 205/193/157 201/189/157 203/192/157
f 199/196/158 206/194/158 204/195/158
f 207/187/159 199/196/159 205/193/159
f 139/180/160 164/89/160 177/144/160
f 165/92/161 139/180/161 177/144/161
f 140/175/162 211/197/162 164/89/162
f 212/198/163 141/178/163 165/92/163
f 144/165/164 211/197/164 142/170/164
f 145/174/165 212/198/165 214/199/165
f 187/164/166 213/200/166 144/165/166
f 188/166/167 214/199/167 167/161/167
f 209/201/168 166/158/168 81/83/168
f 210/202/169 167/161/169 214/199/169
f 215/203/170 213/200/170 209/201/170
f 216/204/171 214/199/171 212/198/171
f 79/87/172 211/197/172 215/203/172
f 212/198/173 80/91/173 216/204/173
f 130/169/174 222/205/174 131/157/174
f 130/169/175 223/206/175 72/207/175
f 133/155/176 222/205/176 220/208/176
f 223/206/177 134/156/177 221/209/177
f 135/153/178 220/208/178 218/210/178
f 221/209/179 136/154/179 219/211/179
f 137/212/135 218/210/135 217/213/135
f 219/211/135 137/212/135 217/213/135
f 218/210/180 231/214/180 217/213/180
f 219/211/181 231/214/181 230/215/181
f 218/210/182 227/216/182 229/217/182
f 228/218/183 219/211/183 230/215/183
f 220/208/142 225/219/142 227/216/142
f 226/220/184 221/209/184 228/218/184
f 72/207/185 225/219/185 222/205/185
f 72/207/186 226/220/186 224/221/186
f 224/221/187 229/217/187 225/219/187
f 230/215/188 224/221/188 226/220/188
f 225/219/189 229/217/189 227/216/189
f 228/218/190 230/215/190 226/220/190
f 183/149/191 234/222/191 232/223/191
f 235/224/192 184/150/192 233/225/192
f 112/146/193 232/223/193 254/226/193
f 233/225/194 113/147/194 255/227/194
f 112/146/195 256/228/195 110/127/195
f 113/147/196 257/229/196 255/227/196
f 114/142/197 234/222/197 181/151/197
f 115/145/198 235/224/198 253/230/198
f 114/142/199 250/231/199 252/232/199
f 251/233/200 115/145/200 253/230/200
f 116/140/201 248/234/201 250/231/201
f 249/235/202 117/143/202 251/233/202
f 118/138/203 246/236/203 248/234/203
f 247/237/204 119/141/204 249/235/204
f 120/136/205 244/238/205 246/236/205
f 245/239/206 121/139/206 247/237/206
f 124/132/207 244/238/207 122/134/207
f 125/135/208 245/239/208 243/240/208
f 126/130/209 242/241/209 124/132/209
f 127/133/210 243/240/210 241/242/210
f 126/130/211 236/243/211 240/244/211
f 237/245/212 127/133/212 241/242/212
f 179/129/213 238/246/213 236/243/213
f 239/247/214 180/131/214 237/245/214
f 128/126/215 256/228/215 238/246/215
f 257/229/216 129/128/216 239/247/216
f 256/228/217 276/248/217 238/246/217
f 257/229/218 277/249/218 259/250/218
f 236/243/219 276/248/219 278/251/219
f 277/249/220 237/245/220 279/252/220
f 236/243/221 274/253/221 240/244/221
f 237/245/222 275/254/222 279/252/222
f 240/244/223 272/255/223 242/241/223
f 241/242/224 273/256/224 275/254/224
f 244/238/225 272/255/225 270/257/225
f 273/256/226 245/239/226 271/258/226
f 244/238/227 268/259/227 246/236/227
f 245/239/228 269/260/228 271/258/228
f 248/234/229 268/259/229 266/261/229
f 269/260/230 249/235/230 267/262/230
f 248/234/231 264/263/231 250/231/231
f 249/235/232 265/264/232 267/262/232
f 250/231/233 262/265/233 252/232/233
f 251/233/234 263/266/234 265/264/234
f 234/222/235 262/265/235 280/267/235
f 263/266/236 235/224/236 281/268/236
f 256/228/237 260/269/237 258/270/237
f 261/271/238 257/229/238 259/250/238
f 254/226/239 282/272/239 260/269/239
f 283/273/240 255/227/240 261/271/240
f 232/223/241 280/267/241 282/272/241
f 281/268/242 233/225/242 283/273/242
f 67/123/243 284/274/243 73/275/243
f 285/276/244 67/123/244 73/275/244
f 108/119/245 286/277/245 284/274/245
f 287/278/246 109/121/246 285/276/246
f 104/116/247 286/277/247 106/115/247
f 105/279/248 287/278/248 289/280/248
f 102/108/249 288/281/249 104/116/249
f 103/110/250 289/280/250 291/282/250
f 100/104/251 290/283/251 102/108/251
f 101/106/252 291/282/252 293/284/252
f 100/104/253 294/285/253 292/286/253
f 295/287/254 101/106/254 293/284/254
f 96/101/255 294/285/255 98/100/255
f 97/288/256 295/287/256 297/289/256
f 96/101/257 298/290/257 296/291/257
f 299/292/258 97/288/258 297/289/258
f 94/93/259 300/293/259 298/290/259
f 301/294/260 95/95/260 299/292/260
f 309/295/261 338/296/261 308/297/261
f 309/298/262 339/299/262 329/300/262
f 308/297/263 336/301/263 307/302/263
f 308/303/264 337/304/264 339/299/264
f 307/302/265 340/305/265 306/306/265
f 307/307/266 341/308/266 337/304/266
f 89/69/267 306/306/267 340/305/267
f 306/306/268 90/75/268 341/308/268
f 87/73/269 340/305/269 334/309/269
f 341/308/270 88/78/270 335/310/270
f 85/76/271 334/309/271 330/311/271
f 335/310/272 86/77/272 331/312/272
f 83/79/273 330/311/273 332/313/273
f 331/312/274 84/82/274 333/314/274
f 330/311/275 338/296/275 332/313/275
f 339/299/276 331/312/276 333/314/276
f 334/309/277 336/301/277 330/311/277
f 335/310/278 337/304/278 341/308/278
f 332/313/279 328/315/279 326/316/279
f 333/314/280 329/300/280 339/299/280
f 81/83/281 332/313/281 326/316/281
f 333/314/282 82/86/282 327/317/282
f 342/318/283 215/203/283 209/201/283
f 343/319/284 216/204/284 345/320/284
f 326/316/285 209/201/285 81/83/285
f 327/317/286 210/202/286 343/319/286
f 215/203/287 346/321/287 79/87/287
f 216/204/288 347/322/288 345/320/288
f 346/321/289 92/94/289 79/87/289
f 347/322/290 93/323/290 301/294/290
f 324/324/291 304/325/291 77/326/291
f 325/327/292 304/328/292 353/329/292
f 352/330/293 78/331/293 304/325/293
f 353/329/294 78/332/294 351/333/294
f 78/331/295 348/334/295 305/335/295
f 349/336/296 78/332/296 305/337/296
f 305/335/297 328/315/297 309/295/297
f 329/300/298 305/337/298 309/298/298
f 328/315/299 342/318/299 326/316/299
f 329/300/300 343/319/300 349/336/300
f 296/291/301 318/338/301 310/339/301
f 319/340/302 297/289/302 311/341/302
f 316/342/303 77/326/303 76/343/303
f 317/344/304 77/345/304 325/327/304
f 358/346/305 303/347/305 302/348/305
f 359/349/306 303/350/306 357/351/306
f 303/347/307 354/352/307 75/353/307
f 355/354/308 303/350/308 75/355/308
f 75/353/309 316/342/309 76/343/309
f 317/344/310 75/355/310 76/356/310
f 292/357/311 362/358/311 364/359/311
f 363/360/312 293/361/312 365/362/312
f 364/359/313 368/363/313 366/364/313
f 369/365/314 365/362/314 367/366/314
f 366/364/315 370/367/315 372/368/315
f 371/369/316 367/366/316 373/370/316
f 372/368/317 376/371/317 374/372/317
f 377/373/318 373/370/318 375/374/318
f 378/375/319 376/371/319 314/376/319
f 379/377/320 377/373/320 375/374/320
f 316/342/321 374/372/321 378/375/321
f 375/374/322 317/344/322 379/377/322
f 354/352/323 372/368/323 374/372/323
f 373/370/324 355/354/324 375/374/324
f 356/378/325 366/364/325 372/368/325
f 367/366/326 357/351/326 373/370/326
f 358/346/327 364/359/327 366/364/327
f 365/362/328 359/349/328 367/366/328
f 292/357/329 360/379/329 290/380/329
f 293/361/330 361/381/330 365/362/330
f 360/379/331 302/348/331 74/382/331
f 361/381/332 302/383/332 359/349/332
f 284/384/333 288/385/333 290/380/333
f 289/386/334 285/387/334 291/388/334
f 284/384/335 360/379/335 74/382/335
f 361/381/336 285/387/336 74/389/336
f 73/390/337 284/384/337 74/382/337
f 74/389/338 285/387/338 73/391/338
f 296/291/339 362/358/339 294/285/339
f 297/289/340 363/360/340 311/341/340
f 310/339/341 368/363/341 362/358/341
f 369/365/342 311/341/342 363/360/342
f 312/392/343 370/367/343 368/363/343
f 371/369/344 313/393/344 369/365/344
f 376/371/345 382/394/345 314/376/345
f 377/373/346 383/395/346 371/369/346
f 350/396/347 384/397/347 348/334/347
f 351/333/348 385/398/348 387/399/348
f 384/397/349 320/400/349 318/338/349
f 385/398/350 321/401/350 387/399/350
f 298/290/351 384/397/351 318/338/351
f 385/398/352 299/292/352 319/340/352
f 300/293/353 342/318/353 384/397/353
f 343/319/354 301/294/354 385/398/354
f 342/318/355 348/334/355 384/397/355
f 385/398/356 349/336/356 343/319/356
f 300/293/357 346/321/357 344/402/357
f 345/320/358 347/322/358 301/294/358
f 322/403/359 378/375/359 314/376/359
f 323/404/360 379/377/360 381/405/360
f 378/375/361 324/324/361 316/342/361
f 379/377/362 325/327/362 381/405/362
f 386/406/363 322/403/363 320/400/363
f 387/399/364 323/404/364 381/405/364
f 352/330/365 386/406/365 350/396/365
f 353/329/366 387/399/366 381/405/366
f 324/324/367 380/407/367 352/330/367
f 353/329/368 381/405/368 325/327/368
f 388/408/369 402/409/369 400/410/369
f 389/411/370 403/412/370 415/413/370
f 400/410/371 404/414/371 398/415/371
f 405/416/372 401/417/372 399/418/372
f 404/414/373 396/419/373 398/415/373
f 405/416/374 397/420/374 407/421/374
f 406/422/375 394/423/375 396/419/375
f 407/421/376 395/424/376 409/425/376
f 408/426/377 392/427/377 394/423/377
f 409/425/378 393/428/378 411/429/378
f 392/427/379 412/430/379 390/431/379
f 413/432/380 393/428/380 391/433/380
f 410/434/381 418/435/381 412/430/381
f 419/436/382 411/429/382 413/432/382
f 408/426/383 420/437/383 410/434/383
f 421/438/384 409/425/384 411/429/384
f 424/439/385 408/426/385 406/422/385
f 425/440/386 409/425/386 423/441/386
f 426/442/387 406/422/387 404/414/387
f 427/443/388 407/421/388 425/440/388
f 428/444/389 404/414/389 402/409/389
f 429/445/390 405/416/390 427/443/390
f 402/409/391 416/446/391 428/444/391
f 417/447/392 403/412/392 429/445/392
f 320/400/393 442/448/393 318/338/393
f 321/401/394 443/449/394 445/450/394
f 390/431/395 444/451/395 320/452/395
f 391/433/396 445/453/396 413/432/396
f 310/339/397 442/448/397 312/392/397
f 443/449/398 311/341/398 313/393/398
f 382/454/399 414/455/399 388/408/399
f 415/413/400 383/456/400 389/411/400
f 412/430/401 440/457/401 444/451/401
f 441/458/402 413/432/402 445/453/402
f 446/459/403 440/457/403 438/460/403
f 447/461/404 441/458/404 445/453/404
f 434/462/135 438/460/135 436/463/135
f 439/464/135 435/465/135 437/466/135
f 448/467/405 434/462/405 432/468/405
f 449/469/406 435/465/406 447/461/406
f 448/467/407 450/470/407 430/471/407
f 449/469/408 451/472/408 433/473/408
f 430/471/409 416/446/409 414/455/409
f 431/474/410 417/447/410 451/472/410
f 312/392/411 430/475/411 382/394/411
f 431/476/412 313/393/412 383/395/412
f 442/448/413 448/477/413 312/392/413
f 443/449/414 449/478/414 447/479/414
f 442/448/415 444/480/415 446/481/415
f 447/479/416 445/450/416 443/449/416
f 416/446/417 452/482/417 476/483/417
f 453/484/418 417/447/418 477/485/418
f 432/468/419 452/482/419 450/470/419
f 433/473/420 453/484/420 463/486/420
f 432/468/421 460/487/421 462/488/421
f 461/489/422 433/473/422 463/486/422
f 436/463/423 460/487/423 434/462/423
f 437/466/424 461/489/424 459/490/424
f 438/460/425 458/491/425 436/463/425
f 439/464/426 459/490/426 457/492/426
f 438/460/427 454/493/427 456/494/427
f 455/495/428 439/464/428 457/492/428
f 440/457/429 474/496/429 454/493/429
f 475/497/429 441/458/429 455/495/429
f 428/444/430 476/483/430 464/498/430
f 477/485/431 429/445/431 465/499/431
f 426/442/432 464/498/432 466/500/432
f 465/499/433 427/443/433 467/501/433
f 424/439/434 466/500/434 468/502/434
f 467/501/435 425/440/435 469/503/435
f 424/439/436 470/504/436 422/505/436
f 425/440/437 471/506/437 469/503/437
f 422/505/438 472/507/438 420/437/438
f 423/441/439 473/508/439 471/506/439
f 420/437/440 474/496/440 418/435/440
f 421/438/441 475/497/441 473/508/441
f 456/494/442 478/509/442 458/491/442
f 457/492/443 479/510/443 481/511/443
f 480/512/444 484/513/444 478/509/444
f 481/511/445 485/514/445 483/515/445
f 484/513/446 488/516/446 486/517/446
f 489/518/447 485/514/447 487/519/447
f 488/516/448 492/520/448 486/517/448
f 489/518/449 493/521/449 491/522/449
f 464/498/450 486/517/450 492/520/450
f 487/519/451 465/499/451 493/521/451
f 484/513/452 476/483/452 452/482/452
f 485/514/453 477/485/453 487/519/453
f 462/488/454 484/513/454 452/482/454
f 463/486/455 485/514/455 479/510/455
f 458/491/135 462/488/135 460/487/135
f 463/486/135 459/490/135 461/489/135
f 474/496/456 456/494/456 454/493/456
f 475/497/457 457/492/457 481/511/457
f 472/507/458 480/512/458 474/496/458
f 481/511/459 473/508/459 475/497/459
f 488/516/460 472/507/460 470/504/460
f 489/518/461 473/508/461 483/515/461
f 490/523/462 470/504/462 468/502/462
f 491/522/463 471/506/463 489/518/463
f 466/500/464 490/523/464 468/502/464
f 491/522/465 467/501/465 469/503/465
f 464/498/466 492/520/466 466/500/466
f 467/501/467 493/521/467 465/499/467
f 392/427/468 504/524/468 502/525/468
f 505/526/469 393/428/469 503/527/469
f 394/423/470 502/525/470 500/528/470
f 503/527/471 395/424/471 501/529/471
f 394/423/472 498/530/472 396/419/472
f 395/424/473 499/531/473 501/529/473
f 396/419/474 496/532/474 398/533/474
f 397/420/475 497/534/475 499/531/475
f 398/533/476 494/535/476 400/536/476
f 399/537/477 495/538/477 497/534/477
f 400/536/478 506/539/478 388/540/478
f 401/541/479 507/542/479 495/538/479
f 502/525/480 506/539/480 494/535/480
f 503/527/481 507/542/481 505/526/481
f 494/535/482 500/528/482 502/525/482
f 501/529/483 495/538/483 503/527/483
f 496/532/484 498/530/484 500/528/484
f 501/529/485 499/531/485 497/534/485
f 382/394/486 506/543/486 314/376/486
f 383/544/487 507/542/487 389/545/487
f 314/546/488 504/524/488 322/547/488
f 505/526/489 315/548/489 323/549/489
f 320/452/490 504/524/490 390/431/490
f 505/526/491 321/550/491 391/433/491
f 47/1/492 1/13/492 3/2/492
f 4/4/493 2/16/493 48/5/493
f 45/3/494 3/2/494 5/7/494
f 6/9/495 4/4/495 46/6/495
f 3/2/496 9/14/496 7/11/496
f 8/12/497 10/15/497 4/4/497
f 1/13/498 11/17/498 9/14/498
f 10/15/499 12/20/499 2/16/499
f 11/17/500 13/26/500 15/18/500
f 16/19/501 14/27/501 12/20/501
f 9/14/502 15/18/502 17/21/502
f 18/22/503 16/19/503 10/15/503
f 21/23/504 19/32/504 17/21/504
f 22/24/505 16/19/505 18/22/505
f 13/26/506 23/28/506 21/23/506
f 22/24/507 24/31/507 14/27/507
f 23/28/508 25/39/508 27/29/508
f 28/30/509 26/54/509 24/31/509
f 27/29/510 29/35/510 19/32/510
f 28/30/511 22/24/511 20/25/511
f 33/34/512 31/45/512 29/35/512
f 34/36/513 28/30/513 30/33/513
f 35/38/514 33/34/514 27/29/514
f 36/40/515 26/54/515 28/30/515
f 37/41/516 39/44/516 33/34/516
f 38/42/517 36/40/517 34/36/517
f 39/44/518 41/47/518 31/45/518
f 40/43/519 34/36/519 32/37/519
f 45/3/520 43/8/520 41/47/520
f 46/6/521 40/43/521 42/46/521
f 47/1/522 45/3/522 39/44/522
f 48/5/523 38/42/523 40/43/523
f 37/41/524 51/51/524 49/48/524
f 38/42/525 48/5/525 50/49/525
f 35/38/526 53/53/526 51/51/526
f 36/40/527 38/42/527 52/50/527
f 25/39/528 55/56/528 53/53/528
f 26/54/529 36/40/529 54/52/529
f 23/28/530 57/59/530 55/56/530
f 24/31/531 26/54/531 56/55/531
f 23/28/532 13/26/532 59/58/532
f 60/60/533 14/27/533 24/31/533
f 13/26/534 11/17/534 63/61/534
f 64/62/535 12/20/535 14/27/535
f 11/17/536 1/13/536 65/63/536
f 66/64/537 2/16/537 12/20/537
f 1/13/538 47/1/538 49/48/538
f 50/49/539 48/5/539 2/16/539
f 174/67/540 176/71/540 91/68/540
f 175/70/541 90/75/541 91/68/541
f 172/72/542 174/67/542 89/69/542
f 173/74/543 88/78/543 90/75/543
f 85/76/544 170/80/544 172/72/544
f 173/74/545 171/81/545 86/77/545
f 83/79/546 168/84/546 170/80/546
f 171/81/547 169/85/547 84/82/547
f 81/83/548 166/158/548 168/84/548
f 169/85/549 167/161/549 82/86/549
f 79/87/550 92/94/550 146/88/550
f 147/90/551 93/323/551 80/91/551
f 94/93/552 148/98/552 146/88/552
f 95/95/553 93/323/553 147/90/553
f 94/93/554 96/101/554 150/97/554
f 151/99/555 97/288/555 95/95/555
f 98/100/556 152/105/556 150/97/556
f 99/102/557 97/288/557 151/99/557
f 100/104/558 154/109/558 152/105/558
f 101/106/559 99/102/559 153/103/559
f 102/108/560 156/113/560 154/109/560
f 103/110/561 101/106/561 155/107/561
f 102/108/562 104/116/562 158/112/562
f 159/114/563 105/279/563 103/110/563
f 106/115/564 160/120/564 158/112/564
f 107/117/565 105/279/565 159/114/565
f 108/119/566 162/124/566 160/120/566
f 109/121/567 107/117/567 161/118/567
f 67/123/568 68/125/568 162/124/568
f 67/123/569 109/121/569 163/122/569
f 128/126/570 160/120/570 162/124/570
f 129/128/571 111/551/571 163/122/571
f 128/126/572 179/129/572 158/112/572
f 159/114/573 180/131/573 129/128/573
f 156/113/574 158/112/574 179/129/574
f 157/111/575 127/133/575 180/131/575
f 154/109/576 156/113/576 126/130/576
f 155/107/577 125/135/577 127/133/577
f 152/105/578 154/109/578 124/132/578
f 153/103/579 123/137/579 125/135/579
f 150/97/580 152/105/580 122/134/580
f 151/99/581 121/139/581 123/137/581
f 148/98/582 150/97/582 120/136/582
f 149/96/583 119/141/583 121/139/583
f 146/88/584 148/98/584 118/138/584
f 147/90/585 117/143/585 119/141/585
f 164/89/586 146/88/586 116/140/586
f 165/92/587 115/145/587 117/143/587
f 114/142/588 181/151/588 177/144/588
f 177/144/589 182/152/589 115/145/589
f 162/124/590 68/125/590 112/146/590
f 163/122/591 111/551/591 113/147/591
f 112/146/592 68/125/592 178/148/592
f 178/148/593 68/125/593 113/147/593
f 181/151/594 183/149/594 178/148/594
f 182/152/595 177/144/595 178/148/595
f 135/153/596 137/212/596 176/71/596
f 176/71/597 137/212/597 136/154/597
f 133/155/598 135/153/598 174/67/598
f 175/70/599 136/154/599 134/156/599
f 133/155/600 172/72/600 170/80/600
f 134/156/601 132/162/601 171/81/601
f 166/158/602 187/164/602 185/159/602
f 186/160/603 188/166/603 167/161/603
f 131/157/604 170/80/604 168/84/604
f 169/85/605 171/81/605 132/162/605
f 190/163/132 189/167/132 187/164/132
f 190/163/606 145/174/606 188/166/606
f 187/164/134 189/167/134 69/168/134
f 188/166/607 186/160/607 69/168/607
f 131/157/135 185/159/135 69/168/135
f 132/162/135 130/169/135 69/168/135
f 142/170/608 193/176/608 191/171/608
f 192/172/609 194/177/609 143/173/609
f 140/175/610 195/191/610 193/176/610
f 194/177/611 196/182/611 141/178/611
f 197/179/612 195/191/612 140/175/612
f 198/181/613 139/180/613 141/178/613
f 71/183/614 197/179/614 139/180/614
f 71/183/184 138/184/184 139/180/184
f 144/165/615 191/171/615 70/185/615
f 145/174/616 190/163/616 70/185/616
f 191/171/146 206/194/146 208/186/146
f 192/172/147 70/185/147 208/186/147
f 71/183/617 199/196/617 200/188/617
f 201/189/618 199/196/618 71/183/618
f 197/179/619 200/188/619 202/190/619
f 203/192/620 201/189/620 198/181/620
f 202/190/621 204/195/621 193/176/621
f 203/192/622 196/182/622 194/177/622
f 193/176/623 204/195/623 206/194/623
f 207/187/624 205/193/624 194/177/624
f 204/195/625 202/190/625 200/188/625
f 205/193/626 199/196/626 201/189/626
f 199/196/627 208/186/627 206/194/627
f 207/187/628 208/186/628 199/196/628
f 139/180/629 140/175/629 164/89/629
f 165/92/630 141/178/630 139/180/630
f 140/175/631 142/170/631 211/197/631
f 212/198/632 143/173/632 141/178/632
f 144/165/633 213/200/633 211/197/633
f 145/174/634 143/173/634 212/198/634
f 187/164/635 166/158/635 213/200/635
f 188/166/636 145/174/636 214/199/636
f 209/201/637 213/200/637 166/158/637
f 210/202/638 82/86/638 167/161/638
f 215/203/639 211/197/639 213/200/639
f 216/204/640 210/202/640 214/199/640
f 79/87/641 164/89/641 211/197/641
f 212/198/642 165/92/642 80/91/642
f 130/169/643 72/207/643 222/205/643
f 130/169/644 132/162/644 223/206/644
f 133/155/645 131/157/645 222/205/645
f 223/206/646 132/162/646 134/156/646
f 135/153/647 133/155/647 220/208/647
f 221/209/648 134/156/648 136/154/648
f 137/212/649 135/153/649 218/210/649
f 219/211/650 136/154/650 137/212/650
f 218/210/180 229/217/180 231/214/180
f 219/211/181 217/213/181 231/214/181
f 218/210/651 220/208/651 227/216/651
f 228/218/652 221/209/652 219/211/652
f 220/208/142 222/205/142 225/219/142
f 226/220/184 223/206/184 221/209/184
f 72/207/185 224/221/185 225/219/185
f 72/207/186 223/206/186 226/220/186
f 224/221/653 231/214/653 229/217/653
f 230/215/654 231/214/654 224/221/654
f 183/149/655 181/151/655 234/222/655
f 235/224/656 182/152/656 184/150/656
f 112/146/657 183/149/657 232/223/657
f 233/225/658 184/150/658 113/147/658
f 112/146/659 254/226/659 256/228/659
f 113/147/660 111/551/660 257/229/660
f 114/142/661 252/232/661 234/222/661
f 115/145/662 182/152/662 235/224/662
f 114/142/663 116/140/663 250/231/663
f 251/233/664 117/143/664 115/145/664
f 116/140/665 118/138/665 248/234/665
f 249/235/666 119/141/666 117/143/666
f 118/138/667 120/136/667 246/236/667
f 247/237/668 121/139/668 119/141/668
f 120/136/669 122/134/669 244/238/669
f 245/239/670 123/137/670 121/139/670
f 124/132/671 242/241/671 244/238/671
f 125/135/672 123/137/672 245/239/672
f 126/130/673 240/244/673 242/241/673
f 127/133/674 125/135/674 243/240/674
f 126/130/675 179/129/675 236/243/675
f 237/245/676 180/131/676 127/133/676
f 179/129/677 128/126/677 238/246/677
f 239/247/678 129/128/678 180/131/678
f 128/126/679 110/127/679 256/228/679
f 257/229/680 111/551/680 129/128/680
f 256/228/681 258/270/681 276/248/681
f 257/229/682 239/247/682 277/249/682
f 236/243/683 238/246/683 276/248/683
f 277/249/684 239/247/684 237/245/684
f 236/243/685 278/251/685 274/253/685
f 237/245/686 241/242/686 275/254/686
f 240/244/687 274/253/687 272/255/687
f 241/242/688 243/240/688 273/256/688
f 244/238/689 242/241/689 272/255/689
f 273/256/690 243/240/690 245/239/690
f 244/238/691 270/257/691 268/259/691
f 245/239/692 247/237/692 269/260/692
f 248/234/693 246/236/693 268/259/693
f 269/260/694 247/237/694 249/235/694
f 248/234/695 266/261/695 264/263/695
f 249/235/696 251/233/696 265/264/696
f 250/231/697 264/263/697 262/265/697
f 251/233/698 253/230/698 263/266/698
f 234/222/235 252/232/235 262/265/235
f 263/266/236 253/230/236 235/224/236
f 256/228/699 254/226/699 260/269/699
f 261/271/700 255/227/700 257/229/700
f 254/226/701 232/223/701 282/272/701
f 283/273/702 233/225/702 255/227/702
f 232/223/703 234/222/703 280/267/703
f 281/268/704 235/224/704 233/225/704
f 67/123/705 108/119/705 284/274/705
f 285/276/706 109/121/706 67/123/706
f 108/119/707 106/115/707 286/277/707
f 287/278/708 107/117/708 109/121/708
f 104/116/709 288/281/709 286/277/709
f 105/279/710 107/117/710 287/278/710
f 102/108/711 290/283/711 288/281/711
f 103/110/712 105/279/712 289/280/712
f 100/104/713 292/286/713 290/283/713
f 101/106/714 103/110/714 291/282/714
f 100/104/715 98/100/715 294/285/715
f 295/287/716 99/102/716 101/106/716
f 96/101/717 296/291/717 294/285/717
f 97/288/718 99/102/718 295/287/718
f 96/101/719 94/93/719 298/290/719
f 299/292/720 95/95/720 97/288/720
f 94/93/721 92/94/721 300/293/721
f 301/294/722 93/323/722 95/95/722
f 309/295/723 328/315/723 338/296/723
f 309/298/724 308/303/724 339/299/724
f 308/297/725 338/296/725 336/301/725
f 308/303/726 307/307/726 337/304/726
f 307/302/727 336/301/727 340/305/727
f 307/307/728 306/306/728 341/308/728
f 89/69/729 91/68/729 306/306/729
f 306/306/730 91/68/730 90/75/730
f 87/73/731 89/69/731 340/305/731
f 341/308/732 90/75/732 88/78/732
f 85/76/733 87/73/733 334/309/733
f 335/310/734 88/78/734 86/77/734
f 83/79/735 85/76/735 330/311/735
f 331/312/736 86/77/736 84/82/736
f 330/311/737 336/301/737 338/296/737
f 339/299/738 337/304/738 331/312/738
f 334/309/739 340/305/739 336/301/739
f 335/310/740 331/312/740 337/304/740
f 332/313/741 338/296/741 328/315/741
f 333/314/742 327/317/742 329/300/742
f 81/83/743 83/79/743 332/313/743
f 333/314/744 84/82/744 82/86/744
f 342/318/745 344/402/745 215/203/745
f 343/319/746 210/202/746 216/204/746
f 326/316/747 342/318/747 209/201/747
f 327/317/748 82/86/748 210/202/748
f 215/203/749 344/402/749 346/321/749
f 216/204/750 80/91/750 347/322/750
f 346/321/751 300/293/751 92/94/751
f 347/322/752 80/91/752 93/323/752
f 324/324/753 352/330/753 304/325/753
f 325/327/754 77/345/754 304/328/754
f 352/330/755 350/396/755 78/331/755
f 353/329/756 304/328/756 78/332/756
f 78/331/757 350/396/757 348/334/757
f 349/336/758 351/333/758 78/332/758
f 305/335/759 348/334/759 328/315/759
f 329/300/760 349/336/760 305/337/760
f 328/315/761 348/334/761 342/318/761
f 329/300/762 327/317/762 343/319/762
f 296/291/763 298/290/763 318/338/763
f 319/340/764 299/292/764 297/289/764
f 316/342/765 324/324/765 77/326/765
f 317/344/766 76/356/766 77/345/766
f 358/346/767 356/378/767 303/347/767
f 359/349/768 302/383/768 303/350/768
f 303/347/769 356/378/769 354/352/769
f 355/354/770 357/351/770 303/350/770
f 75/353/771 354/352/771 316/342/771
f 317/344/772 355/354/772 75/355/772
f 292/357/773 294/285/773 362/358/773
f 363/360/774 295/287/774 293/361/774
f 364/359/775 362/358/775 368/363/775
f 369/365/776 363/360/776 365/362/776
f 366/364/777 368/363/777 370/367/777
f 371/369/778 369/365/778 367/366/778
f 372/368/779 370/367/779 376/371/779
f 377/373/780 371/369/780 373/370/780
f 378/375/781 374/372/781 376/371/781
f 379/377/782 315/552/782 377/373/782
f 316/342/783 354/352/783 374/372/783
f 375/374/784 355/354/784 317/344/784
f 354/352/785 356/378/785 372/368/785
f 373/370/786 357/351/786 355/354/786
f 356/378/787 358/346/787 366/364/787
f 367/366/788 359/349/788 357/351/788
f 358/346/789 360/379/789 364/359/789
f 365/362/790 361/381/790 359/349/790
f 292/357/791 364/359/791 360/379/791
f 293/361/792 291/388/792 361/381/792
f 360/379/793 358/346/793 302/348/793
f 361/381/794 74/389/794 302/383/794
f 284/384/795 286/553/795 288/385/795
f 289/386/796 287/554/796 285/387/796
f 284/384/797 290/380/797 360/379/797
f 361/381/798 291/388/798 285/387/798
f 296/291/799 310/339/799 362/358/799
f 297/289/800 295/287/800 363/360/800
f 310/339/801 312/392/801 368/363/801
f 369/365/802 313/393/802 311/341/802
f 312/392/803 382/394/803 370/367/803
f 371/369/804 383/395/804 313/393/804
f 376/371/805 370/367/805 382/394/805
f 377/373/806 315/552/806 383/395/806
f 350/396/807 386/406/807 384/397/807
f 351/333/808 349/336/808 385/398/808
f 384/397/809 386/406/809 320/400/809
f 385/398/810 319/340/810 321/401/810
f 298/290/811 300/293/811 384/397/811
f 385/398/812 301/294/812 299/292/812
f 300/293/813 344/402/813 342/318/813
f 343/319/814 345/320/814 301/294/814
f 322/403/815 380/407/815 378/375/815
f 323/404/816 315/552/816 379/377/816
f 378/375/817 380/407/817 324/324/817
f 379/377/818 317/344/818 325/327/818
f 386/406/819 380/407/819 322/403/819
f 387/399/820 321/401/820 323/404/820
f 352/330/821 380/407/821 386/406/821
f 353/329/822 351/333/822 387/399/822
f 388/408/823 414/455/823 402/409/823
f 389/411/824 401/417/824 403/412/824
f 400/410/825 402/409/825 404/414/825
f 405/416/826 403/412/826 401/417/826
f 404/414/827 406/422/827 396/419/827
f 405/416/828 399/418/828 397/420/828
f 406/422/829 408/426/829 394/423/829
f 407/421/830 397/420/830 395/424/830
f 408/426/831 410/434/831 392/427/831
f 409/425/832 395/424/832 393/428/832
f 392/427/833 410/434/833 412/430/833
f 413/432/834 411/429/834 393/428/834
f 410/434/835 420/437/835 418/435/835
f 419/436/836 421/438/836 411/429/836
f 408/426/837 422/505/837 420/437/837
f 421/438/838 423/441/838 409/425/838
f 424/439/839 422/505/839 408/426/839
f 425/440/840 407/421/840 409/425/840
f 426/442/841 424/439/841 406/422/841
f 427/443/842 405/416/842 407/421/842
f 428/444/843 426/442/843 404/414/843
f 429/445/844 403/412/844 405/416/844
f 402/409/845 414/455/845 416/446/845
f 417/447/846 415/413/846 403/412/846
f 320/400/847 444/480/847 442/448/847
f 321/401/848 319/340/848 443/449/848
f 390/431/849 412/430/849 444/451/849
f 391/433/850 321/550/850 445/453/850
f 310/339/851 318/338/851 442/448/851
f 443/449/852 319/340/852 311/341/852
f 382/454/853 430/471/853 414/455/853
f 415/413/854 431/474/854 383/456/854
f 412/430/855 418/435/855 440/457/855
f 441/458/856 419/436/856 413/432/856
f 446/459/857 444/451/857 440/457/857
f 447/461/858 439/464/858 441/458/858
f 434/462/859 446/459/859 438/460/859
f 439/464/860 447/461/860 435/465/860
f 448/467/861 446/459/861 434/462/861
f 449/469/862 433/473/862 435/465/862
f 448/467/863 432/468/863 450/470/863
f 449/469/864 431/474/864 451/472/864
f 430/471/865 450/470/865 416/446/865
f 431/474/866 415/413/866 417/447/866
f 312/392/867 448/477/867 430/475/867
f 431/476/868 449/478/868 313/393/868
f 442/448/869 446/481/869 448/477/869
f 443/449/870 313/393/870 449/478/870
f 416/446/871 450/470/871 452/482/871
f 453/484/872 451/472/872 417/447/872
f 432/468/873 462/488/873 452/482/873
f 433/473/874 451/472/874 453/484/874
f 432/468/421 434/462/421 460/487/421
f 461/489/422 435/465/422 433/473/422
f 436/463/875 458/491/875 460/487/875
f 437/466/876 435/465/876 461/489/876
f 438/460/877 456/494/877 458/491/877
f 439/464/878 437/466/878 459/490/878
f 438/460/879 440/457/879 454/493/879
f 455/495/880 441/458/880 439/464/880
f 440/457/881 418/435/881 474/496/881
f 475/497/882 419/436/882 441/458/882
f 428/444/883 416/446/883 476/483/883
f 477/485/884 417/447/884 429/445/884
f 426/442/885 428/444/885 464/498/885
f 465/499/886 429/445/886 427/443/886
f 424/439/887 426/442/887 466/500/887
f 467/501/888 427/443/888 425/440/888
f 424/439/889 468/502/889 470/504/889
f 425/440/890 423/441/890 471/506/890
f 422/505/891 470/504/891 472/507/891
f 423/441/892 421/438/892 473/508/892
f 420/437/893 472/507/893 474/496/893
f 421/438/894 419/436/894 475/497/894
f 456/494/895 480/512/895 478/509/895
f 457/492/896 459/490/896 479/510/896
f 480/512/897 482/555/897 484/513/897
f 481/511/898 479/510/898 485/514/898
f 484/513/899 482/555/899 488/516/899
f 489/518/900 483/515/900 485/514/900
f 488/516/901 490/523/901 492/520/901
f 489/518/902 487/519/902 493/521/902
f 464/498/903 476/483/903 486/517/903
f 487/519/904 477/485/904 465/499/904
f 484/513/905 486/517/905 476/483/905
f 485/514/906 453/484/906 477/485/906
f 462/488/907 478/509/907 484/513/907
f 463/486/908 453/484/908 485/514/908
f 458/491/909 478/509/909 462/488/909
f 463/486/910 479/510/910 459/490/910
f 474/496/911 480/512/911 456/494/911
f 475/497/912 455/495/912 457/492/912
f 472/507/913 482/555/913 480/512/913
f 481/511/914 483/515/914 473/508/914
f 488/516/915 482/555/915 472/507/915
f 489/518/916 471/506/916 473/508/916
f 490/523/917 488/516/917 470/504/917
f 491/522/918 469/503/918 471/506/918
f 466/500/919 492/520/919 490/523/919
f 491/522/920 493/521/920 467/501/920
f 392/427/921 390/431/921 504/524/921
f 505/526/922 391/433/922 393/428/922
f 394/423/923 392/427/923 502/525/923
f 503/527/924 393/428/924 395/424/924
f 394/423/925 500/528/925 498/530/925
f 395/424/926 397/420/926 499/531/926
f 396/419/927 498/530/927 496/532/927
f 397/420/928 399/537/928 497/534/928
f 398/533/929 496/532/929 494/535/929
f 399/537/930 401/541/930 495/538/930
f 400/536/931 494/535/931 506/539/931
f 401/541/932 389/545/932 507/542/932
f 502/525/933 504/524/933 506/539/933
f 503/527/934 495/538/934 507/542/934
f 494/535/935 496/532/935 500/528/935
f 501/529/936 497/534/936 495/538/936
f 382/394/937 388/556/937 506/543/937
f 383/544/938 315/548/938 507/542/938
f 314/546/939 506/539/939 504/524/939
f 505/526/940 507/542/940 315/548/940
f 320/452/941 322/547/941 504/524/941
f 505/526/942 323/549/942 321/550/942

```

`Engine/Assets/models/Primitives/Obj/pPlane.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl None
Ns 500
Ka 0.8 0.8 0.8
Kd 0.8 0.8 0.8
Ks 0.8 0.8 0.8
d 1
illum 2

```

`Engine/Assets/models/Primitives/Obj/pPlane.obj`:

```obj
# Blender v2.90.0 OBJ File: ''
# www.blender.org
mtllib pPlane.mtl
o Plane_Plane.002
v 1.000000 0.000000 1.000000
v -1.000000 0.000000 1.000000
v 1.000000 0.000000 -1.000000
v -1.000000 0.000000 -1.000000
vt 1.000000 0.000000
vt 0.000000 1.000000
vt 0.000000 0.000000
vt 1.000000 1.000000
vn 0.0000 -1.0000 0.0000
usemtl None
s off
f 2/1/1 3/2/1 1/3/1
f 2/1/1 4/4/1 3/2/1

```

`Engine/Assets/models/Primitives/Obj/pSphere.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl None
Ns 500
Ka 0.8 0.8 0.8
Kd 0.8 0.8 0.8
Ks 0.8 0.8 0.8
d 1
illum 2

```

`Engine/Assets/models/Primitives/Obj/pSphere.obj`:

```obj
# Blender v2.90.0 OBJ File: ''
# www.blender.org
mtllib pSphere.mtl
o Sphere_Sphere.002
v 0.000000 -0.980785 -0.195090
v 0.000000 -0.923880 -0.382683
v 0.000000 -0.831470 -0.555570
v 0.000000 -0.707107 -0.707107
v 0.000000 -0.555570 -0.831470
v 0.000000 -0.382683 -0.923880
v 0.000000 -0.195090 -0.980785
v 0.000000 -0.000000 -1.000000
v 0.000000 0.195090 -0.980785
v 0.000000 0.831470 -0.555570
v -0.038060 -0.980785 -0.191342
v -0.074658 -0.923880 -0.375330
v -0.108386 -0.831470 -0.544895
v -0.137950 -0.707107 -0.693520
v -0.162212 -0.555570 -0.815493
v -0.180240 -0.382683 -0.906127
v -0.191342 -0.195090 -0.961940
v -0.195090 -0.000000 -0.980785
v -0.191342 0.195090 -0.961940
v -0.180240 0.382683 -0.906127
v -0.162212 0.555570 -0.815493
v -0.137950 0.707107 -0.693520
v -0.108386 0.831470 -0.544895
v -0.074658 0.923880 -0.375330
v -0.038060 0.980785 -0.191341
v -0.074658 -0.980785 -0.180240
v -0.146447 -0.923880 -0.353553
v -0.212608 -0.831470 -0.513280
v -0.270598 -0.707107 -0.653281
v -0.318190 -0.555570 -0.768178
v -0.353553 -0.382683 -0.853553
v -0.375330 -0.195090 -0.906127
v -0.382684 -0.000000 -0.923879
v -0.375330 0.195090 -0.906127
v -0.353554 0.382683 -0.853553
v -0.318190 0.555570 -0.768178
v -0.270598 0.707107 -0.653281
v -0.212608 0.831470 -0.513280
v -0.146447 0.923880 -0.353553
v -0.074658 0.980785 -0.180240
v -0.108387 -0.980785 -0.162212
v -0.212608 -0.923880 -0.318190
v -0.308658 -0.831470 -0.461940
v -0.392848 -0.707107 -0.587938
v -0.461940 -0.555570 -0.691342
v -0.513280 -0.382683 -0.768178
v -0.544895 -0.195090 -0.815493
v -0.555570 -0.000000 -0.831469
v -0.544895 0.195090 -0.815493
v -0.513280 0.382683 -0.768178
v -0.461940 0.555570 -0.691342
v -0.392848 0.707107 -0.587938
v -0.308658 0.831470 -0.461940
v -0.212608 0.923880 -0.318189
v -0.108386 0.980785 -0.162211
v -0.137950 -0.980785 -0.137950
v -0.270598 -0.923880 -0.270598
v -0.392848 -0.831470 -0.392847
v -0.500000 -0.707107 -0.500000
v -0.587938 -0.555570 -0.587938
v -0.653282 -0.382683 -0.653281
v -0.693520 -0.195090 -0.693520
v -0.707107 -0.000000 -0.707107
v -0.693520 0.195090 -0.693520
v -0.653282 0.382683 -0.653281
v -0.587938 0.555570 -0.587938
v -0.500000 0.707107 -0.500000
v -0.392848 0.831470 -0.392847
v -0.270598 0.923880 -0.270598
v -0.137950 0.980785 -0.137949
v -0.162212 -0.980785 -0.108386
v -0.318190 -0.923880 -0.212607
v -0.461940 -0.831470 -0.308658
v -0.587938 -0.707107 -0.392847
v -0.691342 -0.555570 -0.461940
v -0.768178 -0.382683 -0.513280
v -0.815493 -0.195090 -0.544895
v -0.831470 -0.000000 -0.555570
v -0.815493 0.195090 -0.544895
v -0.768178 0.382683 -0.513280
v -0.691342 0.555570 -0.461940
v -0.587938 0.707107 -0.392847
v -0.461940 0.831470 -0.308658
v -0.318190 0.923880 -0.212607
v -0.162212 0.980785 -0.108386
v -0.180240 -0.980785 -0.074658
v -0.353554 -0.923880 -0.146446
v -0.513280 -0.831470 -0.212607
v -0.653282 -0.707107 -0.270598
v -0.768178 -0.555570 -0.318189
v -0.853554 -0.382683 -0.353553
v -0.906128 -0.195090 -0.375330
v -0.923880 -0.000000 -0.382683
v -0.906128 0.195090 -0.375330
v -0.853554 0.382683 -0.353553
v -0.768178 0.555570 -0.318189
v -0.653282 0.707107 -0.270598
v -0.513280 0.831470 -0.212607
v -0.353554 0.923880 -0.146446
v -0.180240 0.980785 -0.074658
v -0.191342 -0.980785 -0.038060
v -0.375331 -0.923880 -0.074658
v -0.544895 -0.831470 -0.108386
v -0.693520 -0.707107 -0.137949
v -0.815493 -0.555570 -0.162211
v -0.906128 -0.382683 -0.180240
v -0.961940 -0.195090 -0.191341
v -0.980785 -0.000000 -0.195090
v -0.961940 0.195090 -0.191341
v -0.906128 0.382683 -0.180240
v -0.815493 0.555570 -0.162211
v -0.693520 0.707107 -0.137949
v -0.544895 0.831470 -0.108386
v -0.375330 0.923880 -0.074658
v -0.191342 0.980785 -0.038060
v -0.195091 -0.980785 0.000000
v -0.382684 -0.923880 0.000000
v -0.555570 -0.831470 0.000000
v -0.707107 -0.707107 0.000000
v -0.831470 -0.555570 0.000000
v -0.923880 -0.382683 0.000000
v -0.980785 -0.195090 0.000000
v -1.000000 -0.000000 0.000000
v -0.980785 0.195090 0.000000
v -0.923880 0.382683 0.000000
v -0.831470 0.555570 0.000000
v -0.707107 0.707107 0.000000
v -0.555570 0.831470 0.000000
v -0.382684 0.923880 0.000000
v -0.195090 0.980785 0.000000
v -0.191342 -0.980785 0.038061
v -0.375331 -0.923880 0.074658
v -0.544895 -0.831470 0.108387
v -0.693520 -0.707107 0.137950
v -0.815493 -0.555570 0.162212
v -0.906128 -0.382683 0.180240
v -0.961940 -0.195090 0.191342
v -0.980785 -0.000000 0.195091
v -0.961940 0.195090 0.191342
v -0.906128 0.382683 0.180240
v -0.815493 0.555570 0.162212
v -0.693520 0.707107 0.137950
v -0.544895 0.831470 0.108387
v -0.375330 0.923880 0.074658
v -0.191342 0.980785 0.038061
v -0.180240 -0.980785 0.074658
v -0.353554 -0.923880 0.146447
v -0.513280 -0.831470 0.212608
v -0.653282 -0.707107 0.270598
v -0.768178 -0.555570 0.318190
v -0.853554 -0.382683 0.353554
v -0.906127 -0.195090 0.375331
v -0.923880 -0.000000 0.382684
v -0.906127 0.195090 0.375331
v -0.853554 0.382683 0.353554
v -0.768178 0.555570 0.318190
v -0.653282 0.707107 0.270598
v -0.513280 0.831470 0.212608
v -0.353553 0.923880 0.146447
v -0.180240 0.980785 0.074658
v -0.162212 -0.980785 0.108387
v -0.318190 -0.923880 0.212608
v -0.461940 -0.831470 0.308659
v -0.587938 -0.707107 0.392848
v -0.691342 -0.555570 0.461940
v -0.768178 -0.382683 0.513280
v -0.815493 -0.195090 0.544895
v -0.831470 -0.000000 0.555571
v -0.815493 0.195090 0.544895
v -0.768178 0.382683 0.513280
v -0.691342 0.555570 0.461940
v -0.587938 0.707107 0.392848
v -0.461940 0.831470 0.308659
v -0.318190 0.923880 0.212608
v -0.162212 0.980785 0.108387
v -0.137950 -0.980785 0.137950
v -0.270598 -0.923880 0.270599
v -0.392848 -0.831470 0.392848
v -0.500000 -0.707107 0.500000
v -0.587938 -0.555570 0.587938
v -0.653282 -0.382683 0.653282
v -0.693520 -0.195090 0.693520
v -0.707107 -0.000000 0.707107
v -0.693520 0.195090 0.693520
v -0.653282 0.382683 0.653282
v -0.587938 0.555570 0.587938
v -0.500000 0.707107 0.500000
v -0.392848 0.831470 0.392848
v -0.270598 0.923880 0.270598
v -0.137950 0.980785 0.137950
v -0.108386 -0.980785 0.162212
v -0.212608 -0.923880 0.318190
v -0.308658 -0.831470 0.461940
v -0.392848 -0.707107 0.587938
v -0.461940 -0.555570 0.691342
v -0.513280 -0.382683 0.768178
v -0.544895 -0.195090 0.815493
v -0.555570 -0.000000 0.831470
v -0.544895 0.195090 0.815493
v -0.513280 0.382683 0.768178
v -0.461940 0.555570 0.691342
v -0.392848 0.707107 0.587938
v -0.308658 0.831470 0.461940
v -0.212608 0.923880 0.318190
v -0.108386 0.980785 0.162212
v 0.000000 1.000000 0.000000
v -0.074658 -0.980785 0.180240
v -0.146447 -0.923880 0.353554
v -0.212608 -0.831470 0.513280
v -0.270598 -0.707107 0.653282
v -0.318190 -0.555570 0.768178
v -0.353553 -0.382683 0.853554
v -0.375330 -0.195090 0.906128
v -0.382683 -0.000000 0.923880
v -0.375330 0.195090 0.906128
v -0.353553 0.382683 0.853554
v -0.318190 0.555570 0.768178
v -0.270598 0.707107 0.653282
v -0.212608 0.831470 0.513280
v -0.146447 0.923880 0.353554
v -0.074658 0.980785 0.180240
v -0.038060 -0.980785 0.191342
v -0.074658 -0.923880 0.375331
v -0.108386 -0.831470 0.544896
v -0.137950 -0.707107 0.693520
v -0.162212 -0.555570 0.815493
v -0.180240 -0.382683 0.906128
v -0.191342 -0.195090 0.961940
v -0.195090 -0.000000 0.980786
v -0.191342 0.195090 0.961940
v -0.180240 0.382683 0.906128
v -0.162212 0.555570 0.815493
v -0.137950 0.707107 0.693520
v -0.108386 0.831470 0.544895
v -0.074658 0.923880 0.375331
v -0.038060 0.980785 0.191342
v 0.000000 -0.980785 0.195091
v -0.000000 -0.923880 0.382684
v -0.000000 -0.831470 0.555571
v 0.000000 -0.707107 0.707107
v 0.000000 -0.555570 0.831470
v -0.000000 -0.382683 0.923880
v 0.000000 -0.195090 0.980785
v 0.000000 -0.000000 1.000000
v 0.000000 0.195090 0.980785
v -0.000000 0.382683 0.923880
v 0.000000 0.555570 0.831470
v 0.000000 0.707107 0.707107
v 0.000000 0.831470 0.555570
v -0.000000 0.923880 0.382684
v -0.000000 0.980785 0.195091
v 0.038060 -0.980785 0.191342
v 0.074658 -0.923880 0.375331
v 0.108386 -0.831470 0.544896
v 0.137950 -0.707107 0.693520
v 0.162212 -0.555570 0.815493
v 0.180240 -0.382683 0.906128
v 0.191342 -0.195090 0.961940
v 0.195090 -0.000000 0.980786
v 0.191342 0.195090 0.961940
v 0.180240 0.382683 0.906128
v 0.162212 0.555570 0.815493
v 0.137950 0.707107 0.693520
v 0.108386 0.831470 0.544895
v 0.074658 0.923880 0.375331
v 0.038060 0.980785 0.191342
v 0.074658 -0.980785 0.180240
v 0.146447 -0.923880 0.353554
v 0.212608 -0.831470 0.513280
v 0.270598 -0.707107 0.653282
v 0.318190 -0.555570 0.768178
v 0.353553 -0.382683 0.853554
v 0.375330 -0.195090 0.906127
v 0.382684 -0.000000 0.923880
v 0.375330 0.195090 0.906127
v 0.353553 0.382683 0.853554
v 0.318190 0.555570 0.768178
v 0.270598 0.707107 0.653282
v 0.212608 0.831470 0.513280
v 0.146447 0.923880 0.353554
v 0.074658 0.980785 0.180240
v 0.108386 -0.980785 0.162212
v 0.212608 -0.923880 0.318190
v 0.308658 -0.831470 0.461940
v 0.392847 -0.707107 0.587938
v 0.461940 -0.555570 0.691342
v 0.513280 -0.382683 0.768178
v 0.544895 -0.195090 0.815493
v 0.555570 -0.000000 0.831470
v 0.544895 0.195090 0.815493
v 0.513280 0.382683 0.768178
v 0.461940 0.555570 0.691342
v 0.392847 0.707107 0.587938
v 0.308658 0.831470 0.461940
v 0.212607 0.923880 0.318190
v 0.108386 0.980785 0.162212
v 0.000000 -1.000000 0.000001
v 0.137950 -0.980785 0.137950
v 0.270598 -0.923880 0.270598
v 0.392848 -0.831470 0.392848
v 0.500000 -0.707107 0.500000
v 0.587938 -0.555570 0.587938
v 0.653281 -0.382683 0.653282
v 0.693520 -0.195090 0.693520
v 0.707107 -0.000000 0.707107
v 0.693520 0.195090 0.693520
v 0.653281 0.382683 0.653282
v 0.587938 0.555570 0.587938
v 0.500000 0.707107 0.500000
v 0.392847 0.831470 0.392848
v 0.270598 0.923880 0.270598
v 0.137950 0.980785 0.137950
v 0.162212 -0.980785 0.108387
v 0.318190 -0.923880 0.212608
v 0.461940 -0.831470 0.308659
v 0.587938 -0.707107 0.392848
v 0.691342 -0.555570 0.461940
v 0.768178 -0.382683 0.513280
v 0.815493 -0.195090 0.544895
v 0.831470 -0.000000 0.555570
v 0.815493 0.195090 0.544895
v 0.768178 0.382683 0.513280
v 0.691342 0.555570 0.461940
v 0.587938 0.707107 0.392848
v 0.461940 0.831470 0.308658
v 0.318190 0.923880 0.212608
v 0.162212 0.980785 0.108387
v 0.180240 -0.980785 0.074658
v 0.353553 -0.923880 0.146447
v 0.513280 -0.831470 0.212608
v 0.653281 -0.707107 0.270598
v 0.768177 -0.555570 0.318190
v 0.853553 -0.382683 0.353554
v 0.906127 -0.195090 0.375330
v 0.923880 -0.000000 0.382684
v 0.906127 0.195090 0.375330
v 0.853553 0.382683 0.353554
v 0.768177 0.555570 0.318190
v 0.653281 0.707107 0.270598
v 0.513280 0.831470 0.212608
v 0.353553 0.923880 0.146447
v 0.180240 0.980785 0.074658
v 0.191342 -0.980785 0.038061
v 0.375330 -0.923880 0.074658
v 0.544895 -0.831470 0.108387
v 0.693520 -0.707107 0.137950
v 0.815493 -0.555570 0.162212
v 0.906127 -0.382683 0.180240
v 0.961939 -0.195090 0.191342
v 0.980785 -0.000000 0.195090
v 0.961939 0.195090 0.191342
v 0.906127 0.382683 0.180240
v 0.815493 0.555570 0.162212
v 0.693520 0.707107 0.137950
v 0.544895 0.831470 0.108387
v 0.375330 0.923880 0.074658
v 0.191342 0.980785 0.038061
v 0.195090 -0.980785 0.000000
v 0.382683 -0.923880 0.000000
v 0.555570 -0.831470 0.000000
v 0.707107 -0.707107 0.000000
v 0.831469 -0.555570 0.000000
v 0.923879 -0.382683 0.000000
v 0.980785 -0.195090 0.000000
v 1.000000 -0.000000 0.000000
v 0.980785 0.195090 0.000000
v 0.923879 0.382683 0.000000
v 0.831469 0.555570 0.000000
v 0.707107 0.707107 0.000000
v 0.555570 0.831470 0.000000
v 0.382683 0.923880 0.000000
v 0.195090 0.980785 0.000000
v 0.191342 -0.980785 -0.038060
v 0.375330 -0.923880 -0.074658
v 0.544895 -0.831470 -0.108386
v 0.693520 -0.707107 -0.137949
v 0.815493 -0.555570 -0.162211
v 0.906127 -0.382683 -0.180240
v 0.961939 -0.195090 -0.191342
v 0.980785 -0.000000 -0.195090
v 0.961939 0.195090 -0.191342
v 0.906127 0.382683 -0.180240
v 0.815493 0.555570 -0.162211
v 0.693520 0.707107 -0.137949
v 0.544895 0.831470 -0.108386
v 0.375330 0.923880 -0.074658
v 0.191342 0.980785 -0.038060
v 0.180240 -0.980785 -0.074658
v 0.353553 -0.923880 -0.146446
v 0.513280 -0.831470 -0.212607
v 0.653281 -0.707107 -0.270598
v 0.768177 -0.555570 -0.318189
v 0.853553 -0.382683 -0.353553
v 0.906127 -0.195090 -0.375330
v 0.923879 -0.000000 -0.382683
v 0.906127 0.195090 -0.375330
v 0.853553 0.382683 -0.353553
v 0.768177 0.555570 -0.318189
v 0.653281 0.707107 -0.270598
v 0.513280 0.831470 -0.212607
v 0.353553 0.923880 -0.146446
v 0.180240 0.980785 -0.074657
v 0.162212 -0.980785 -0.108386
v 0.318190 -0.923880 -0.212607
v 0.461940 -0.831470 -0.308658
v 0.587938 -0.707107 -0.392847
v 0.691341 -0.555570 -0.461939
v 0.768178 -0.382683 -0.513280
v 0.815493 -0.195090 -0.544895
v 0.831469 -0.000000 -0.555570
v 0.815493 0.195090 -0.544895
v 0.768178 0.382683 -0.513280
v 0.691341 0.555570 -0.461939
v 0.587938 0.707107 -0.392847
v 0.461940 0.831470 -0.308658
v 0.318189 0.923880 -0.212607
v 0.162212 0.980785 -0.108386
v 0.137950 -0.980785 -0.137949
v 0.270598 -0.923880 -0.270598
v 0.392847 -0.831470 -0.392847
v 0.500000 -0.707107 -0.500000
v 0.587937 -0.555570 -0.587937
v 0.653281 -0.382683 -0.653281
v 0.693519 -0.195090 -0.693519
v 0.707106 -0.000000 -0.707106
v 0.693519 0.195090 -0.693519
v 0.653281 0.382683 -0.653281
v 0.587937 0.555570 -0.587937
v 0.500000 0.707107 -0.500000
v 0.392847 0.831470 -0.392847
v 0.270598 0.923880 -0.270598
v 0.137950 0.980785 -0.137949
v 0.108386 -0.980785 -0.162211
v 0.212607 -0.923880 -0.318189
v 0.308658 -0.831470 -0.461939
v 0.392847 -0.707107 -0.587937
v 0.461939 -0.555570 -0.691341
v 0.513280 -0.382683 -0.768177
v 0.544895 -0.195090 -0.815492
v 0.555570 -0.000000 -0.831469
v 0.544895 0.195090 -0.815492
v 0.513280 0.382683 -0.768177
v 0.461939 0.555570 -0.691341
v 0.392847 0.707107 -0.587937
v 0.308658 0.831470 -0.461939
v 0.212607 0.923880 -0.318189
v 0.108386 0.980785 -0.162211
v 0.074658 -0.980785 -0.180240
v 0.146447 -0.923880 -0.353553
v 0.212607 -0.831470 -0.513280
v 0.270598 -0.707107 -0.653281
v 0.318189 -0.555570 -0.768177
v 0.353553 -0.382683 -0.853553
v 0.375330 -0.195090 -0.906127
v 0.382683 -0.000000 -0.923879
v 0.375330 0.195090 -0.906127
v 0.353553 0.382683 -0.853553
v 0.318189 0.555570 -0.768177
v 0.270598 0.707107 -0.653281
v 0.212607 0.831470 -0.513279
v 0.146446 0.923880 -0.353553
v 0.074658 0.980785 -0.180240
v 0.038060 -0.980785 -0.191342
v 0.074658 -0.923880 -0.375330
v 0.108386 -0.831470 -0.544895
v 0.137950 -0.707107 -0.693520
v 0.162211 -0.555570 -0.815492
v 0.180240 -0.382683 -0.906127
v 0.191341 -0.195090 -0.961939
v 0.195090 -0.000000 -0.980785
v 0.191341 0.195090 -0.961939
v 0.180240 0.382683 -0.906127
v 0.162211 0.555570 -0.815492
v 0.137950 0.707107 -0.693520
v 0.108386 0.831470 -0.544895
v 0.074658 0.923880 -0.375330
v 0.038060 0.980785 -0.191341
v -0.000000 0.382683 -0.923879
v -0.000000 0.555570 -0.831469
v -0.000000 0.707107 -0.707106
v -0.000000 0.923880 -0.382683
v -0.000000 0.980785 -0.195090
vt 0.750000 0.250000
vt 0.718750 0.187500
vt 0.750000 0.187500
vt 0.750000 0.687500
vt 0.718750 0.625000
vt 0.750000 0.625000
vt 0.718750 0.125000
vt 0.750000 0.125000
vt 0.718750 0.562500
vt 0.750000 0.562500
vt 0.718750 0.062500
vt 0.750000 0.062500
vt 0.718750 0.500000
vt 0.750000 0.500000
vt 0.750000 0.937500
vt 0.734375 1.000000
vt 0.718750 0.937500
vt 0.734375 0.000000
vt 0.718750 0.437500
vt 0.750000 0.437500
vt 0.718750 0.875000
vt 0.750000 0.875000
vt 0.718750 0.375000
vt 0.750000 0.375000
vt 0.750000 0.812500
vt 0.718750 0.812500
vt 0.718750 0.312500
vt 0.750000 0.312500
vt 0.718750 0.750000
vt 0.750000 0.750000
vt 0.718750 0.250000
vt 0.718750 0.687500
vt 0.687500 0.750000
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.687500 0.687500
vt 0.687500 0.187500
vt 0.687500 0.625000
vt 0.687500 0.125000
vt 0.687500 0.562500
vt 0.687500 0.062500
vt 0.687500 0.500000
vt 0.703125 1.000000
vt 0.687500 0.937500
vt 0.703125 0.000000
vt 0.687500 0.437500
vt 0.687500 0.875000
vt 0.687500 0.375000
vt 0.687500 0.812500
vt 0.656250 0.500000
vt 0.671875 1.000000
vt 0.656250 0.937500
vt 0.671875 0.000000
vt 0.656250 0.062500
vt 0.656250 0.437500
vt 0.656250 0.875000
vt 0.656250 0.375000
vt 0.656250 0.812500
vt 0.656250 0.312500
vt 0.656250 0.750000
vt 0.656250 0.250000
vt 0.656250 0.687500
vt 0.656250 0.187500
vt 0.656250 0.625000
vt 0.656250 0.125000
vt 0.656250 0.562500
vt 0.625000 0.250000
vt 0.625000 0.687500
vt 0.625000 0.187500
vt 0.625000 0.625000
vt 0.625000 0.125000
vt 0.625000 0.562500
vt 0.625000 0.062500
vt 0.625000 0.500000
vt 0.640625 1.000000
vt 0.625000 0.937500
vt 0.640625 0.000000
vt 0.625000 0.437500
vt 0.625000 0.875000
vt 0.625000 0.375000
vt 0.625000 0.812500
vt 0.625000 0.312500
vt 0.625000 0.750000
vt 0.609375 0.000000
vt 0.593750 0.062500
vt 0.593750 0.437500
vt 0.593750 0.875000
vt 0.593750 0.375000
vt 0.593750 0.812500
vt 0.593750 0.312500
vt 0.593750 0.750000
vt 0.593750 0.250000
vt 0.593750 0.687500
vt 0.593750 0.187500
vt 0.593750 0.625000
vt 0.593750 0.125000
vt 0.593750 0.562500
vt 0.593750 0.500000
vt 0.609375 1.000000
vt 0.593750 0.937500
vt 0.562500 0.187500
vt 0.562500 0.625000
vt 0.562500 0.125000
vt 0.562500 0.562500
vt 0.562500 0.062500
vt 0.562500 0.500000
vt 0.578125 1.000000
vt 0.562500 0.937500
vt 0.578125 0.000000
vt 0.562500 0.437500
vt 0.562500 0.875000
vt 0.562500 0.375000
vt 0.562500 0.812500
vt 0.562500 0.312500
vt 0.562500 0.750000
vt 0.562500 0.250000
vt 0.562500 0.687500
vt 0.531250 0.875000
vt 0.531250 0.375000
vt 0.531250 0.812500
vt 0.531250 0.312500
vt 0.531250 0.750000
vt 0.531250 0.250000
vt 0.531250 0.687500
vt 0.531250 0.187500
vt 0.531250 0.625000
vt 0.531250 0.125000
vt 0.531250 0.562500
vt 0.531250 0.062500
vt 0.531250 0.500000
vt 0.546875 1.000000
vt 0.531250 0.937500
vt 0.546875 0.000000
vt 0.531250 0.437500
vt 0.500000 0.625000
vt 0.500000 0.187500
vt 0.500000 0.125000
vt 0.500000 0.562500
vt 0.500000 0.062500
vt 0.500000 0.500000
vt 0.515625 1.000000
vt 0.500000 0.937500
vt 0.515625 0.000000
vt 0.500000 0.437500
vt 0.500000 0.875000
vt 0.500000 0.375000
vt 0.500000 0.812500
vt 0.500000 0.312500
vt 0.500000 0.750000
vt 0.500000 0.250000
vt 0.500000 0.687500
vt 0.468750 0.375000
vt 0.468750 0.812500
vt 0.468750 0.312500
vt 0.468750 0.750000
vt 0.468750 0.250000
vt 0.468750 0.687500
vt 0.468750 0.187500
vt 0.468750 0.625000
vt 0.468750 0.125000
vt 0.468750 0.562500
vt 0.468750 0.062500
vt 0.468750 0.500000
vt 0.484374 1.000000
vt 0.468750 0.937500
vt 0.484375 0.000000
vt 0.468750 0.437500
vt 0.468750 0.875000
vt 0.437500 0.187500
vt 0.437500 0.125000
vt 0.437500 0.625000
vt 0.437500 0.562500
vt 0.437500 0.062500
vt 0.437500 0.500000
vt 0.453124 1.000000
vt 0.437500 0.937500
vt 0.453125 0.000000
vt 0.437500 0.437500
vt 0.437500 0.875000
vt 0.437500 0.375000
vt 0.437500 0.812500
vt 0.437500 0.312500
vt 0.437500 0.750000
vt 0.437500 0.250000
vt 0.437500 0.687500
vt 0.406250 0.812500
vt 0.406250 0.375000
vt 0.406250 0.312500
vt 0.406250 0.750000
vt 0.406250 0.250000
vt 0.406250 0.687500
vt 0.406250 0.187500
vt 0.406250 0.625000
vt 0.406250 0.125000
vt 0.406250 0.562500
vt 0.406250 0.062500
vt 0.406250 0.500000
vt 0.421874 1.000000
vt 0.406250 0.937500
vt 0.421875 0.000000
vt 0.406250 0.437500
vt 0.406250 0.875000
vt 0.375000 0.625000
vt 0.375000 0.562500
vt 0.375000 0.125000
vt 0.375000 0.062500
vt 0.375000 0.500000
vt 0.390625 1.000000
vt 0.375000 0.937500
vt 0.390625 0.000000
vt 0.375000 0.437500
vt 0.375000 0.875000
vt 0.375000 0.375000
vt 0.375000 0.812500
vt 0.375000 0.312500
vt 0.375000 0.750000
vt 0.375000 0.250000
vt 0.375000 0.687500
vt 0.375000 0.187500
vt 0.343750 0.375000
vt 0.343750 0.312500
vt 0.343750 0.812500
vt 0.343750 0.750000
vt 0.343750 0.250000
vt 0.343750 0.687500
vt 0.343750 0.187500
vt 0.343750 0.625000
vt 0.343750 0.125000
vt 0.343750 0.562500
vt 0.343750 0.062500
vt 0.343750 0.500000
vt 0.359375 1.000000
vt 0.343750 0.937500
vt 0.359375 0.000000
vt 0.343750 0.437500
vt 0.343750 0.875000
vt 0.312500 0.062500
vt 0.312500 0.500000
vt 0.328125 1.000000
vt 0.312500 0.937500
vt 0.328125 0.000000
vt 0.312500 0.437500
vt 0.312500 0.875000
vt 0.312500 0.375000
vt 0.312500 0.812500
vt 0.312500 0.312500
vt 0.312500 0.750000
vt 0.312500 0.250000
vt 0.312500 0.687500
vt 0.312500 0.187500
vt 0.312500 0.625000
vt 0.312500 0.125000
vt 0.312500 0.562500
vt 0.281250 0.250000
vt 0.281250 0.687500
vt 0.281250 0.187500
vt 0.281250 0.625000
vt 0.281250 0.125000
vt 0.281250 0.562500
vt 0.281250 0.062500
vt 0.281250 0.500000
vt 0.296875 1.000000
vt 0.281250 0.937500
vt 0.296875 0.000000
vt 0.281250 0.437500
vt 0.281250 0.875000
vt 0.281250 0.375000
vt 0.281250 0.812500
vt 0.281250 0.312500
vt 0.281250 0.750000
vt 0.265625 1.000000
vt 0.250000 0.937500
vt 0.265625 0.000000
vt 0.250000 0.062500
vt 0.250000 0.437500
vt 0.250000 0.875000
vt 0.250000 0.375000
vt 0.250000 0.812500
vt 0.250000 0.312500
vt 0.250000 0.750000
vt 0.250000 0.250000
vt 0.250000 0.687500
vt 0.250000 0.187500
vt 0.250000 0.625000
vt 0.250000 0.125000
vt 0.250000 0.562500
vt 0.250000 0.500000
vt 0.218750 0.750000
vt 0.218750 0.687500
vt 0.218750 0.187500
vt 0.218750 0.625000
vt 0.218750 0.125000
vt 0.218750 0.562500
vt 0.218750 0.062500
vt 0.218750 0.500000
vt 0.234375 1.000000
vt 0.218750 0.937500
vt 0.234375 0.000000
vt 0.218750 0.437500
vt 0.218750 0.875000
vt 0.218750 0.375000
vt 0.218750 0.812500
vt 0.218750 0.312500
vt 0.218750 0.250000
vt 0.187500 0.500000
vt 0.187500 0.437500
vt 0.187500 0.875000
vt 0.187500 0.375000
vt 0.187500 0.812500
vt 0.187500 0.312500
vt 0.187500 0.750000
vt 0.187500 0.250000
vt 0.187500 0.687500
vt 0.187500 0.187500
vt 0.187500 0.625000
vt 0.187500 0.125000
vt 0.187500 0.562500
vt 0.187500 0.062500
vt 0.203125 1.000000
vt 0.187500 0.937500
vt 0.203125 0.000000
vt 0.156250 0.250000
vt 0.156250 0.187500
vt 0.156250 0.625000
vt 0.156250 0.125000
vt 0.156250 0.562500
vt 0.156250 0.062500
vt 0.156250 0.500000
vt 0.171875 1.000000
vt 0.156250 0.937500
vt 0.171875 0.000000
vt 0.156250 0.437500
vt 0.156250 0.875000
vt 0.156250 0.375000
vt 0.156250 0.812500
vt 0.156250 0.312500
vt 0.156250 0.750000
vt 0.156250 0.687500
vt 0.125000 0.875000
vt 0.125000 0.375000
vt 0.125000 0.812500
vt 0.125000 0.312500
vt 0.125000 0.750000
vt 0.125000 0.250000
vt 0.125000 0.687500
vt 0.125000 0.187500
vt 0.125000 0.625000
vt 0.125000 0.125000
vt 0.125000 0.562500
vt 0.125000 0.062500
vt 0.125000 0.500000
vt 0.140625 1.000000
vt 0.125000 0.937500
vt 0.140625 0.000000
vt 0.125000 0.437500
vt 0.093750 0.625000
vt 0.093750 0.187500
vt 0.093750 0.125000
vt 0.093750 0.562500
vt 0.093750 0.062500
vt 0.093750 0.500000
vt 0.109375 1.000000
vt 0.093750 0.937500
vt 0.109375 0.000000
vt 0.093750 0.437500
vt 0.093750 0.875000
vt 0.093750 0.375000
vt 0.093750 0.812500
vt 0.093750 0.312500
vt 0.093750 0.750000
vt 0.093750 0.250000
vt 0.093750 0.687500
vt 0.062500 0.375000
vt 0.062500 0.812500
vt 0.062500 0.312500
vt 0.062500 0.750000
vt 0.062500 0.250000
vt 0.062500 0.687500
vt 0.062500 0.187500
vt 0.062500 0.625000
vt 0.062500 0.125000
vt 0.062500 0.562500
vt 0.062500 0.062500
vt 0.062500 0.500000
vt 0.078125 1.000000
vt 0.062500 0.937500
vt 0.078125 0.000000
vt 0.062500 0.437500
vt 0.062500 0.875000
vt 0.031250 0.187500
vt 0.031250 0.125000
vt 0.031250 0.625000
vt 0.031250 0.562500
vt 0.031250 0.062500
vt 0.031250 0.500000
vt 0.046875 1.000000
vt 0.031250 0.937500
vt 0.046875 0.000000
vt 0.031250 0.437500
vt 0.031250 0.875000
vt 0.031250 0.375000
vt 0.031250 0.812500
vt 0.031250 0.312500
vt 0.031250 0.750000
vt 0.031250 0.250000
vt 0.031250 0.687500
vt 0.000000 0.375000
vt 0.000000 0.312500
vt 0.000000 0.812500
vt 0.000000 0.750000
vt 0.000000 0.250000
vt 0.000000 0.687500
vt 0.000000 0.187500
vt 0.000000 0.625000
vt 0.000000 0.125000
vt 0.000000 0.562500
vt 0.000000 0.062500
vt 0.000000 0.500000
vt 0.015625 1.000000
vt 0.000000 0.937500
vt 0.015625 0.000000
vt 0.000000 0.437500
vt 0.000000 0.875000
vt 1.000000 0.125000
vt 0.968750 0.062500
vt 1.000000 0.062500
vt 1.000000 0.562500
vt 0.968750 0.500000
vt 1.000000 0.500000
vt 1.000000 0.937500
vt 0.984375 1.000000
vt 0.968750 0.937500
vt 0.984375 0.000000
vt 1.000000 0.437500
vt 0.968750 0.437500
vt 1.000000 0.875000
vt 0.968750 0.875000
vt 0.968750 0.375000
vt 1.000000 0.375000
vt 0.968750 0.812500
vt 1.000000 0.812500
vt 1.000000 0.312500
vt 0.968750 0.312500
vt 1.000000 0.750000
vt 0.968750 0.750000
vt 0.968750 0.250000
vt 1.000000 0.250000
vt 1.000000 0.687500
vt 0.968750 0.687500
vt 0.968750 0.187500
vt 1.000000 0.187500
vt 0.968750 0.625000
vt 1.000000 0.625000
vt 0.968750 0.125000
vt 0.968750 0.562500
vt 0.937500 0.812500
vt 0.937500 0.750000
vt 0.937500 0.250000
vt 0.937500 0.687500
vt 0.937500 0.187500
vt 0.937500 0.625000
vt 0.937500 0.125000
vt 0.937500 0.562500
vt 0.937500 0.062500
vt 0.937500 0.500000
vt 0.953125 1.000000
vt 0.937500 0.937500
vt 0.953125 0.000000
vt 0.937500 0.437500
vt 0.937500 0.875000
vt 0.937500 0.375000
vt 0.937500 0.312500
vt 0.906250 0.500000
vt 0.921875 1.000000
vt 0.906250 0.937500
vt 0.921875 0.000000
vt 0.906250 0.062500
vt 0.906250 0.437500
vt 0.906250 0.875000
vt 0.906250 0.375000
vt 0.906250 0.812500
vt 0.906250 0.312500
vt 0.906250 0.750000
vt 0.906250 0.250000
vt 0.906250 0.687500
vt 0.906250 0.187500
vt 0.906250 0.625000
vt 0.906250 0.125000
vt 0.906250 0.562500
vt 0.875000 0.250000
vt 0.875000 0.750000
vt 0.875000 0.687500
vt 0.875000 0.187500
vt 0.875000 0.625000
vt 0.875000 0.125000
vt 0.875000 0.562500
vt 0.875000 0.062500
vt 0.875000 0.500000
vt 0.890625 1.000000
vt 0.875000 0.937500
vt 0.890625 0.000000
vt 0.875000 0.437500
vt 0.875000 0.875000
vt 0.875000 0.375000
vt 0.875000 0.812500
vt 0.875000 0.312500
vt 0.859375 1.000000
vt 0.843750 0.937500
vt 0.859375 0.000000
vt 0.843750 0.062500
vt 0.843750 0.437500
vt 0.843750 0.875000
vt 0.843750 0.375000
vt 0.843750 0.812500
vt 0.843750 0.312500
vt 0.843750 0.750000
vt 0.843750 0.250000
vt 0.843750 0.687500
vt 0.843750 0.187500
vt 0.843750 0.625000
vt 0.843750 0.125000
vt 0.843750 0.562500
vt 0.843750 0.500000
vt 0.812500 0.750000
vt 0.812500 0.687500
vt 0.812500 0.187500
vt 0.812500 0.625000
vt 0.812500 0.125000
vt 0.812500 0.562500
vt 0.812500 0.062500
vt 0.812500 0.500000
vt 0.828125 1.000000
vt 0.812500 0.937500
vt 0.828125 0.000000
vt 0.812500 0.437500
vt 0.812500 0.875000
vt 0.812500 0.375000
vt 0.812500 0.812500
vt 0.812500 0.312500
vt 0.812500 0.250000
vt 0.781250 0.437500
vt 0.781250 0.875000
vt 0.781250 0.375000
vt 0.781250 0.812500
vt 0.781250 0.312500
vt 0.781250 0.750000
vt 0.781250 0.250000
vt 0.781250 0.687500
vt 0.781250 0.187500
vt 0.781250 0.625000
vt 0.781250 0.125000
vt 0.781250 0.562500
vt 0.781250 0.062500
vt 0.781250 0.500000
vt 0.796875 1.000000
vt 0.781250 0.937500
vt 0.796875 0.000000
vt 0.765625 1.000000
vt 0.765625 0.000000
vn -0.0624 0.7715 -0.6332
vn -0.0865 -0.4696 -0.8786
vn -0.0464 0.8810 -0.4709
vn -0.0938 -0.2890 -0.9527
vn -0.0286 0.9565 -0.2902
vn -0.0975 -0.0975 -0.9904
vn -0.0097 -0.9951 -0.0980
vn -0.0097 0.9951 -0.0980
vn -0.0975 0.0975 -0.9904
vn -0.0286 -0.9565 -0.2902
vn -0.0938 0.2890 -0.9527
vn -0.0464 -0.8810 -0.4709
vn -0.0865 0.4696 -0.8786
vn -0.0624 -0.7715 -0.6332
vn -0.0759 0.6326 -0.7708
vn -0.0759 -0.6326 -0.7708
vn -0.1847 -0.7715 -0.6088
vn -0.2248 0.6326 -0.7412
vn -0.2248 -0.6326 -0.7412
vn -0.1847 0.7715 -0.6088
vn -0.2563 -0.4696 -0.8448
vn -0.1374 0.8810 -0.4528
vn -0.2779 -0.2890 -0.9161
vn -0.0846 0.9565 -0.2790
vn -0.2889 -0.0975 -0.9524
vn -0.0286 -0.9951 -0.0942
vn -0.0286 0.9951 -0.0942
vn -0.2889 0.0975 -0.9524
vn -0.0846 -0.9565 -0.2790
vn -0.2779 0.2890 -0.9161
vn -0.1374 -0.8810 -0.4528
vn -0.2563 0.4696 -0.8448
vn -0.4691 -0.0975 -0.8777
vn -0.0464 -0.9951 -0.0869
vn -0.0464 0.9951 -0.0869
vn -0.4691 0.0975 -0.8777
vn -0.1374 -0.9565 -0.2571
vn -0.4513 0.2890 -0.8443
vn -0.2230 -0.8810 -0.4173
vn -0.4162 0.4696 -0.7786
vn -0.2999 -0.7715 -0.5611
vn -0.3651 0.6326 -0.6831
vn -0.3651 -0.6326 -0.6831
vn -0.2999 0.7715 -0.5611
vn -0.4162 -0.4696 -0.7786
vn -0.2230 0.8810 -0.4173
vn -0.4513 -0.2890 -0.8443
vn -0.1374 0.9565 -0.2571
vn -0.4913 0.6326 -0.5987
vn -0.4913 -0.6326 -0.5987
vn -0.4036 0.7715 -0.4918
vn -0.5601 -0.4696 -0.6825
vn -0.3002 0.8810 -0.3658
vn -0.6073 -0.2890 -0.7400
vn -0.1850 0.9565 -0.2254
vn -0.6314 -0.0976 -0.7693
vn -0.0625 -0.9951 -0.0761
vn -0.0625 0.9951 -0.0761
vn -0.6314 0.0976 -0.7693
vn -0.1850 -0.9565 -0.2254
vn -0.6073 0.2890 -0.7400
vn -0.3002 -0.8810 -0.3658
vn -0.5601 0.4696 -0.6825
vn -0.4036 -0.7715 -0.4918
vn -0.0761 0.9951 -0.0625
vn -0.7693 0.0975 -0.6314
vn -0.2254 -0.9565 -0.1850
vn -0.7400 0.2890 -0.6073
vn -0.3658 -0.8810 -0.3002
vn -0.6825 0.4696 -0.5601
vn -0.4918 -0.7715 -0.4036
vn -0.5987 0.6326 -0.4913
vn -0.5987 -0.6326 -0.4913
vn -0.4918 0.7715 -0.4036
vn -0.6825 -0.4696 -0.5601
vn -0.3658 0.8810 -0.3002
vn -0.7400 -0.2890 -0.6073
vn -0.2254 0.9565 -0.1850
vn -0.7693 -0.0976 -0.6314
vn -0.0761 -0.9951 -0.0625
vn -0.5611 0.7715 -0.2999
vn -0.7786 -0.4696 -0.4162
vn -0.4173 0.8810 -0.2230
vn -0.8443 -0.2890 -0.4513
vn -0.2571 0.9565 -0.1374
vn -0.8777 -0.0976 -0.4691
vn -0.0869 -0.9951 -0.0464
vn -0.0869 0.9951 -0.0464
vn -0.8777 0.0976 -0.4691
vn -0.2571 -0.9565 -0.1374
vn -0.8443 0.2890 -0.4513
vn -0.4173 -0.8810 -0.2231
vn -0.7786 0.4696 -0.4162
vn -0.5611 -0.7715 -0.2999
vn -0.6831 0.6326 -0.3651
vn -0.6831 -0.6326 -0.3651
vn -0.2790 -0.9565 -0.0846
vn -0.9161 0.2890 -0.2779
vn -0.4528 -0.8810 -0.1374
vn -0.8448 0.4696 -0.2563
vn -0.6088 -0.7715 -0.1847
vn -0.7412 0.6326 -0.2248
vn -0.7412 -0.6326 -0.2248
vn -0.6088 0.7715 -0.1847
vn -0.8448 -0.4696 -0.2563
vn -0.4528 0.8810 -0.1374
vn -0.9161 -0.2890 -0.2779
vn -0.2790 0.9565 -0.0846
vn -0.9524 -0.0976 -0.2889
vn -0.0942 -0.9951 -0.0286
vn -0.0942 0.9951 -0.0286
vn -0.9524 0.0976 -0.2889
vn -0.8786 -0.4696 -0.0865
vn -0.4709 0.8810 -0.0464
vn -0.9527 -0.2890 -0.0938
vn -0.2902 0.9565 -0.0286
vn -0.9904 -0.0976 -0.0975
vn -0.0980 -0.9951 -0.0097
vn -0.0980 0.9951 -0.0097
vn -0.9904 0.0976 -0.0975
vn -0.2902 -0.9565 -0.0286
vn -0.9527 0.2890 -0.0938
vn -0.4709 -0.8810 -0.0464
vn -0.8786 0.4696 -0.0865
vn -0.6332 -0.7715 -0.0624
vn -0.7708 0.6326 -0.0759
vn -0.7708 -0.6326 -0.0759
vn -0.6332 0.7715 -0.0624
vn -0.9527 0.2890 0.0938
vn -0.4709 -0.8810 0.0464
vn -0.8786 0.4696 0.0865
vn -0.6332 -0.7715 0.0624
vn -0.7708 0.6326 0.0759
vn -0.7708 -0.6326 0.0759
vn -0.6332 0.7715 0.0624
vn -0.8786 -0.4696 0.0865
vn -0.4709 0.8810 0.0464
vn -0.9527 -0.2890 0.0938
vn -0.2902 0.9565 0.0286
vn -0.9904 -0.0976 0.0975
vn -0.0980 -0.9951 0.0097
vn -0.0980 0.9951 0.0097
vn -0.9904 0.0976 0.0975
vn -0.2902 -0.9565 0.0286
vn -0.4528 0.8810 0.1374
vn -0.9161 -0.2890 0.2779
vn -0.2790 0.9565 0.0846
vn -0.9524 -0.0976 0.2889
vn -0.0942 -0.9951 0.0286
vn -0.0942 0.9951 0.0286
vn -0.9524 0.0976 0.2889
vn -0.2790 -0.9565 0.0846
vn -0.9161 0.2890 0.2779
vn -0.4528 -0.8810 0.1374
vn -0.8448 0.4696 0.2563
vn -0.6088 -0.7715 0.1847
vn -0.7412 0.6326 0.2248
vn -0.7412 -0.6326 0.2248
vn -0.6088 0.7715 0.1847
vn -0.8448 -0.4696 0.2563
vn -0.4173 -0.8810 0.2231
vn -0.7786 0.4696 0.4162
vn -0.5611 -0.7715 0.2999
vn -0.6831 0.6326 0.3651
vn -0.6831 -0.6326 0.3651
vn -0.5611 0.7715 0.2999
vn -0.7786 -0.4696 0.4162
vn -0.4173 0.8810 0.2230
vn -0.8443 -0.2890 0.4513
vn -0.2571 0.9566 0.1374
vn -0.8777 -0.0976 0.4691
vn -0.0869 -0.9951 0.0464
vn -0.0869 0.9951 0.0464
vn -0.8777 0.0976 0.4691
vn -0.2571 -0.9565 0.1374
vn -0.8443 0.2890 0.4513
vn -0.7400 -0.2890 0.6073
vn -0.2254 0.9566 0.1850
vn -0.7693 -0.0976 0.6314
vn -0.0761 -0.9951 0.0625
vn -0.0761 0.9951 0.0625
vn -0.7693 0.0976 0.6314
vn -0.2254 -0.9565 0.1850
vn -0.7400 0.2890 0.6073
vn -0.3658 -0.8810 0.3002
vn -0.6825 0.4696 0.5601
vn -0.4918 -0.7715 0.4036
vn -0.5987 0.6326 0.4913
vn -0.5987 -0.6326 0.4913
vn -0.4918 0.7715 0.4036
vn -0.6825 -0.4696 0.5601
vn -0.3658 0.8810 0.3002
vn -0.5601 0.4696 0.6825
vn -0.4036 -0.7715 0.4918
vn -0.4913 0.6326 0.5987
vn -0.4913 -0.6326 0.5987
vn -0.4036 0.7715 0.4918
vn -0.5601 -0.4696 0.6825
vn -0.3002 0.8810 0.3658
vn -0.6073 -0.2890 0.7400
vn -0.1850 0.9565 0.2254
vn -0.6314 -0.0976 0.7693
vn -0.0625 -0.9951 0.0761
vn -0.0625 0.9951 0.0761
vn -0.6314 0.0976 0.7693
vn -0.1850 -0.9565 0.2254
vn -0.6073 0.2890 0.7400
vn -0.3002 -0.8810 0.3658
vn -0.1374 0.9566 0.2571
vn -0.4691 -0.0976 0.8777
vn -0.0464 -0.9951 0.0869
vn -0.0464 0.9951 0.0869
vn -0.4691 0.0976 0.8777
vn -0.1374 -0.9565 0.2571
vn -0.4513 0.2890 0.8443
vn -0.2230 -0.8810 0.4173
vn -0.4162 0.4696 0.7786
vn -0.2999 -0.7715 0.5611
vn -0.3651 0.6326 0.6831
vn -0.3651 -0.6326 0.6831
vn -0.2999 0.7715 0.5611
vn -0.4162 -0.4696 0.7786
vn -0.2231 0.8810 0.4173
vn -0.4513 -0.2890 0.8443
vn -0.2248 0.6326 0.7412
vn -0.2248 -0.6326 0.7412
vn -0.1847 0.7715 0.6088
vn -0.2563 -0.4696 0.8448
vn -0.1374 0.8810 0.4528
vn -0.2779 -0.2890 0.9161
vn -0.0846 0.9565 0.2790
vn -0.2889 -0.0976 0.9524
vn -0.0286 -0.9951 0.0942
vn -0.0286 0.9951 0.0942
vn -0.2889 0.0976 0.9524
vn -0.0846 -0.9565 0.2790
vn -0.2779 0.2890 0.9161
vn -0.1374 -0.8810 0.4528
vn -0.2563 0.4696 0.8448
vn -0.1847 -0.7715 0.6088
vn -0.0097 -0.9951 0.0980
vn -0.0097 0.9951 0.0980
vn -0.0975 0.0976 0.9904
vn -0.0286 -0.9565 0.2902
vn -0.0938 0.2890 0.9527
vn -0.0464 -0.8810 0.4709
vn -0.0865 0.4696 0.8786
vn -0.0624 -0.7715 0.6332
vn -0.0759 0.6326 0.7708
vn -0.0759 -0.6326 0.7708
vn -0.0624 0.7715 0.6332
vn -0.0865 -0.4696 0.8786
vn -0.0464 0.8810 0.4709
vn -0.0938 -0.2890 0.9527
vn -0.0286 0.9565 0.2902
vn -0.0975 -0.0976 0.9904
vn 0.0759 -0.6326 0.7708
vn 0.0624 0.7715 0.6332
vn 0.0865 -0.4696 0.8786
vn 0.0464 0.8810 0.4709
vn 0.0938 -0.2890 0.9527
vn 0.0286 0.9565 0.2902
vn 0.0976 -0.0976 0.9904
vn 0.0097 -0.9951 0.0980
vn 0.0097 0.9951 0.0980
vn 0.0976 0.0976 0.9904
vn 0.0286 -0.9565 0.2902
vn 0.0938 0.2890 0.9527
vn 0.0464 -0.8810 0.4709
vn 0.0865 0.4696 0.8786
vn 0.0624 -0.7715 0.6332
vn 0.0759 0.6326 0.7708
vn 0.2889 0.0976 0.9524
vn 0.0846 -0.9565 0.2790
vn 0.2779 0.2890 0.9161
vn 0.1374 -0.8810 0.4528
vn 0.2563 0.4696 0.8448
vn 0.1847 -0.7715 0.6088
vn 0.2248 0.6326 0.7412
vn 0.2248 -0.6326 0.7412
vn 0.1847 0.7715 0.6088
vn 0.2563 -0.4696 0.8448
vn 0.1374 0.8810 0.4528
vn 0.2779 -0.2890 0.9161
vn 0.0846 0.9565 0.2790
vn 0.2889 -0.0976 0.9524
vn 0.0286 -0.9951 0.0942
vn 0.0286 0.9951 0.0942
vn 0.2999 0.7715 0.5611
vn 0.4162 -0.4696 0.7786
vn 0.2230 0.8810 0.4173
vn 0.4513 -0.2890 0.8443
vn 0.1374 0.9565 0.2571
vn 0.4691 -0.0976 0.8777
vn 0.0464 -0.9951 0.0869
vn 0.0464 0.9951 0.0869
vn 0.4691 0.0976 0.8777
vn 0.1374 -0.9565 0.2571
vn 0.4513 0.2890 0.8443
vn 0.2230 -0.8810 0.4173
vn 0.4162 0.4696 0.7786
vn 0.2999 -0.7715 0.5611
vn 0.3651 0.6326 0.6831
vn 0.3651 -0.6326 0.6831
vn 0.1850 -0.9565 0.2254
vn 0.6073 0.2890 0.7400
vn 0.3002 -0.8810 0.3658
vn 0.5601 0.4696 0.6825
vn 0.4036 -0.7715 0.4918
vn 0.4913 0.6326 0.5987
vn 0.4913 -0.6326 0.5987
vn 0.4036 0.7715 0.4918
vn 0.5601 -0.4696 0.6825
vn 0.3002 0.8810 0.3658
vn 0.6073 -0.2890 0.7400
vn 0.1850 0.9565 0.2254
vn 0.6314 -0.0976 0.7693
vn 0.0625 -0.9951 0.0761
vn 0.0625 0.9951 0.0761
vn 0.6314 0.0976 0.7693
vn 0.6825 -0.4696 0.5601
vn 0.3658 0.8810 0.3002
vn 0.7400 -0.2890 0.6073
vn 0.2254 0.9565 0.1850
vn 0.7693 -0.0976 0.6314
vn 0.0761 -0.9951 0.0625
vn 0.0761 0.9951 0.0625
vn 0.7693 0.0976 0.6314
vn 0.2254 -0.9565 0.1850
vn 0.7400 0.2890 0.6073
vn 0.3658 -0.8810 0.3002
vn 0.6825 0.4696 0.5601
vn 0.4918 -0.7715 0.4036
vn 0.5987 0.6326 0.4913
vn 0.5987 -0.6326 0.4913
vn 0.4918 0.7715 0.4036
vn 0.8443 0.2890 0.4513
vn 0.4173 -0.8810 0.2230
vn 0.7786 0.4696 0.4162
vn 0.5611 -0.7715 0.2999
vn 0.6831 0.6326 0.3651
vn 0.6831 -0.6326 0.3651
vn 0.5611 0.7715 0.2999
vn 0.7786 -0.4696 0.4162
vn 0.4173 0.8810 0.2231
vn 0.8443 -0.2890 0.4513
vn 0.2571 0.9565 0.1374
vn 0.8777 -0.0976 0.4691
vn 0.0869 -0.9951 0.0464
vn 0.0869 0.9951 0.0464
vn 0.8777 0.0976 0.4691
vn 0.2571 -0.9565 0.1374
vn 0.4528 0.8810 0.1374
vn 0.9161 -0.2890 0.2779
vn 0.2790 0.9565 0.0846
vn 0.9524 -0.0976 0.2889
vn 0.0942 -0.9951 0.0286
vn 0.0942 0.9951 0.0286
vn 0.9524 0.0976 0.2889
vn 0.2790 -0.9565 0.0846
vn 0.9161 0.2890 0.2779
vn 0.4528 -0.8810 0.1374
vn 0.8448 0.4696 0.2563
vn 0.6088 -0.7715 0.1847
vn 0.7412 0.6326 0.2248
vn 0.7412 -0.6326 0.2248
vn 0.6088 0.7715 0.1847
vn 0.8448 -0.4696 0.2563
vn 0.8786 0.4696 0.0865
vn 0.6332 -0.7715 0.0624
vn 0.7708 0.6326 0.0759
vn 0.7708 -0.6326 0.0759
vn 0.6332 0.7715 0.0624
vn 0.8786 -0.4696 0.0865
vn 0.4709 0.8810 0.0464
vn 0.9527 -0.2890 0.0938
vn 0.2902 0.9565 0.0286
vn 0.9904 -0.0976 0.0975
vn 0.0980 -0.9951 0.0097
vn 0.0980 0.9951 0.0097
vn 0.9904 0.0976 0.0975
vn 0.2902 -0.9565 0.0286
vn 0.9527 0.2890 0.0938
vn 0.4709 -0.8810 0.0464
vn 0.2902 0.9565 -0.0286
vn 0.9904 -0.0976 -0.0976
vn 0.0980 -0.9951 -0.0097
vn 0.0980 0.9951 -0.0097
vn 0.9904 0.0976 -0.0976
vn 0.2902 -0.9565 -0.0286
vn 0.9527 0.2890 -0.0938
vn 0.4709 -0.8810 -0.0464
vn 0.8786 0.4696 -0.0865
vn 0.6332 -0.7715 -0.0624
vn 0.7708 0.6326 -0.0759
vn 0.7708 -0.6326 -0.0759
vn 0.6332 0.7715 -0.0624
vn 0.8786 -0.4696 -0.0865
vn 0.4709 0.8810 -0.0464
vn 0.9527 -0.2890 -0.0938
vn 0.6088 -0.7715 -0.1847
vn 0.7412 0.6326 -0.2248
vn 0.7412 -0.6326 -0.2248
vn 0.6088 0.7715 -0.1847
vn 0.8448 -0.4696 -0.2563
vn 0.4528 0.8810 -0.1374
vn 0.9161 -0.2890 -0.2779
vn 0.2790 0.9565 -0.0846
vn 0.9524 -0.0976 -0.2889
vn 0.0942 -0.9951 -0.0286
vn 0.0942 0.9951 -0.0286
vn 0.9524 0.0976 -0.2889
vn 0.2790 -0.9565 -0.0846
vn 0.9161 0.2890 -0.2779
vn 0.4528 -0.8810 -0.1374
vn 0.8448 0.4696 -0.2563
vn 0.8777 -0.0976 -0.4691
vn 0.0869 -0.9951 -0.0464
vn 0.0869 0.9951 -0.0464
vn 0.8777 0.0976 -0.4691
vn 0.2571 -0.9565 -0.1374
vn 0.8443 0.2890 -0.4513
vn 0.4173 -0.8810 -0.2231
vn 0.7786 0.4696 -0.4162
vn 0.5611 -0.7715 -0.2999
vn 0.6831 0.6326 -0.3651
vn 0.6831 -0.6326 -0.3651
vn 0.5611 0.7715 -0.2999
vn 0.7786 -0.4696 -0.4162
vn 0.4173 0.8810 -0.2231
vn 0.8443 -0.2890 -0.4513
vn 0.2571 0.9565 -0.1374
vn 0.5987 0.6326 -0.4913
vn 0.5987 -0.6326 -0.4913
vn 0.4918 0.7715 -0.4036
vn 0.6825 -0.4696 -0.5601
vn 0.3658 0.8810 -0.3002
vn 0.7400 -0.2890 -0.6073
vn 0.2254 0.9565 -0.1850
vn 0.7693 -0.0976 -0.6314
vn 0.0761 -0.9951 -0.0625
vn 0.0761 0.9951 -0.0625
vn 0.7693 0.0976 -0.6314
vn 0.2254 -0.9565 -0.1850
vn 0.7400 0.2890 -0.6073
vn 0.3658 -0.8810 -0.3002
vn 0.6825 0.4696 -0.5601
vn 0.4918 -0.7715 -0.4036
vn 0.0625 -0.9951 -0.0761
vn 0.0625 0.9951 -0.0761
vn 0.6314 0.0976 -0.7693
vn 0.1850 -0.9565 -0.2254
vn 0.6073 0.2890 -0.7400
vn 0.3002 -0.8810 -0.3658
vn 0.5601 0.4696 -0.6825
vn 0.4036 -0.7715 -0.4918
vn 0.4913 0.6326 -0.5987
vn 0.4913 -0.6326 -0.5987
vn 0.4036 0.7715 -0.4918
vn 0.5601 -0.4696 -0.6825
vn 0.3002 0.8810 -0.3658
vn 0.6073 -0.2890 -0.7400
vn 0.1850 0.9565 -0.2254
vn 0.6314 -0.0976 -0.7693
vn 0.3651 -0.6326 -0.6831
vn 0.2999 0.7715 -0.5611
vn 0.4162 -0.4696 -0.7786
vn 0.2231 0.8810 -0.4173
vn 0.4513 -0.2890 -0.8443
vn 0.1374 0.9565 -0.2571
vn 0.4691 -0.0976 -0.8777
vn 0.0464 -0.9951 -0.0869
vn 0.0464 0.9951 -0.0869
vn 0.4691 0.0976 -0.8777
vn 0.1374 -0.9565 -0.2571
vn 0.4513 0.2890 -0.8443
vn 0.2230 -0.8810 -0.4173
vn 0.4162 0.4696 -0.7786
vn 0.2999 -0.7715 -0.5611
vn 0.3651 0.6326 -0.6831
vn 0.2889 0.0976 -0.9524
vn 0.0846 -0.9565 -0.2790
vn 0.2779 0.2890 -0.9161
vn 0.1374 -0.8810 -0.4528
vn 0.2563 0.4696 -0.8448
vn 0.1847 -0.7715 -0.6088
vn 0.2248 0.6326 -0.7412
vn 0.2248 -0.6326 -0.7412
vn 0.1847 0.7715 -0.6088
vn 0.2563 -0.4696 -0.8448
vn 0.1374 0.8810 -0.4528
vn 0.2779 -0.2890 -0.9161
vn 0.0846 0.9565 -0.2790
vn 0.2889 -0.0976 -0.9524
vn 0.0286 -0.9951 -0.0942
vn 0.0286 0.9951 -0.0942
vn 0.0624 0.7715 -0.6332
vn 0.0865 -0.4696 -0.8786
vn 0.0464 0.8810 -0.4709
vn 0.0938 -0.2890 -0.9527
vn 0.0286 0.9565 -0.2902
vn 0.0976 -0.0975 -0.9904
vn 0.0097 -0.9951 -0.0980
vn 0.0097 0.9951 -0.0980
vn 0.0976 0.0976 -0.9904
vn 0.0286 -0.9565 -0.2902
vn 0.0938 0.2890 -0.9527
vn 0.0464 -0.8810 -0.4709
vn 0.0865 0.4696 -0.8786
vn 0.0624 -0.7715 -0.6332
vn 0.0759 0.6326 -0.7708
vn 0.0759 -0.6326 -0.7708
vn -0.0976 -0.0975 -0.9904
vn -0.0976 0.0975 -0.9904
vn -0.0846 -0.9566 -0.2790
vn -0.2231 -0.8810 -0.4173
vn -0.7693 0.0976 -0.6314
vn -0.7693 -0.0975 -0.6314
vn -0.4173 0.8810 -0.2231
vn -0.9524 0.0975 -0.2889
vn -0.4173 0.8810 0.2231
vn -0.2571 0.9565 0.1374
vn -0.2254 0.9565 0.1850
vn -0.1374 0.9565 0.2571
vn -0.2230 0.8810 0.4173
vn 0.0846 -0.9566 0.2790
vn 0.2231 0.8810 0.4173
vn 0.1374 -0.9566 0.2571
vn 0.4173 -0.8810 0.2231
vn 0.4173 0.8810 -0.2230
vn 0.2230 0.8810 -0.4173
vn 0.0976 -0.0976 -0.9904
vn 0.0976 0.0975 -0.9904
usemtl None
s off
f 480/1/1 23/2/1 10/3/1
f 5/4/2 16/5/2 6/6/2
f 10/3/3 24/7/3 481/8/3
f 6/6/4 17/9/4 7/10/4
f 481/8/5 25/11/5 482/12/5
f 7/10/6 18/13/6 8/14/6
f 1/15/7 297/16/7 11/17/7
f 206/18/8 482/12/8 25/11/8
f 8/14/9 19/19/9 9/20/9
f 1/15/10 12/21/10 2/22/10
f 9/20/11 20/23/11 478/24/11
f 3/25/12 12/21/12 13/26/12
f 478/24/13 21/27/13 479/28/13
f 3/25/14 14/29/14 4/30/14
f 479/28/15 22/31/15 480/1/15
f 4/30/16 15/32/16 5/4/16
f 13/26/17 29/33/17 14/29/17
f 22/31/18 36/34/18 37/35/18
f 14/29/19 30/36/19 15/32/19
f 22/31/20 38/37/20 23/2/20
f 15/32/21 31/38/21 16/5/21
f 23/2/22 39/39/22 24/7/22
f 16/5/23 32/40/23 17/9/23
f 24/7/24 40/41/24 25/11/24
f 17/9/25 33/42/25 18/13/25
f 11/17/26 297/43/26 26/44/26
f 206/45/27 25/11/27 40/41/27
f 19/19/28 33/42/28 34/46/28
f 11/17/29 27/47/29 12/21/29
f 20/23/30 34/46/30 35/48/30
f 12/21/31 28/49/31 13/26/31
f 20/23/32 36/34/32 21/27/32
f 32/40/33 48/50/33 33/42/33
f 26/44/34 297/51/34 41/52/34
f 206/53/35 40/41/35 55/54/35
f 33/42/36 49/55/36 34/46/36
f 26/44/37 42/56/37 27/47/37
f 34/46/38 50/57/38 35/48/38
f 27/47/39 43/58/39 28/49/39
f 36/34/40 50/57/40 51/59/40
f 28/49/41 44/60/41 29/33/41
f 37/35/42 51/59/42 52/61/42
f 29/33/43 45/62/43 30/36/43
f 37/35/44 53/63/44 38/37/44
f 30/36/45 46/64/45 31/38/45
f 38/37/46 54/65/46 39/39/46
f 32/40/47 46/64/47 47/66/47
f 39/39/48 55/54/48 40/41/48
f 51/59/49 67/67/49 52/61/49
f 44/60/50 60/68/50 45/62/50
f 52/61/51 68/69/51 53/63/51
f 45/62/52 61/70/52 46/64/52
f 53/63/53 69/71/53 54/65/53
f 46/64/54 62/72/54 47/66/54
f 54/65/55 70/73/55 55/54/55
f 48/50/56 62/72/56 63/74/56
f 41/52/57 297/75/57 56/76/57
f 206/77/58 55/54/58 70/73/58
f 48/50/59 64/78/59 49/55/59
f 41/52/60 57/79/60 42/56/60
f 49/55/61 65/80/61 50/57/61
f 42/56/62 58/81/62 43/58/62
f 51/59/63 65/80/63 66/82/63
f 43/58/64 59/83/64 44/60/64
f 206/84/65 70/73/65 85/85/65
f 63/74/66 79/86/66 64/78/66
f 56/76/67 72/87/67 57/79/67
f 64/78/68 80/88/68 65/80/68
f 57/79/69 73/89/69 58/81/69
f 66/82/70 80/88/70 81/90/70
f 58/81/71 74/91/71 59/83/71
f 66/82/72 82/92/72 67/67/72
f 60/68/73 74/91/73 75/93/73
f 68/69/74 82/92/74 83/94/74
f 60/68/75 76/95/75 61/70/75
f 69/71/76 83/94/76 84/96/76
f 61/70/77 77/97/77 62/72/77
f 69/71/78 85/85/78 70/73/78
f 63/74/79 77/97/79 78/98/79
f 56/76/80 297/99/80 71/100/80
f 82/92/81 98/101/81 83/94/81
f 75/93/82 91/102/82 76/95/82
f 84/96/83 98/101/83 99/103/83
f 77/97/84 91/102/84 92/104/84
f 84/96/85 100/105/85 85/85/85
f 77/97/86 93/106/86 78/98/86
f 71/100/87 297/107/87 86/108/87
f 206/109/88 85/85/88 100/105/88
f 78/98/89 94/110/89 79/86/89
f 71/100/90 87/111/90 72/87/90
f 79/86/91 95/112/91 80/88/91
f 72/87/92 88/113/92 73/89/92
f 81/90/93 95/112/93 96/114/93
f 73/89/94 89/115/94 74/91/94
f 82/92/95 96/114/95 97/116/95
f 75/93/96 89/115/96 90/117/96
f 86/108/97 102/118/97 87/111/97
f 94/110/98 110/119/98 95/112/98
f 87/111/99 103/120/99 88/113/99
f 96/114/100 110/119/100 111/121/100
f 89/115/101 103/120/101 104/122/101
f 97/116/102 111/121/102 112/123/102
f 89/115/103 105/124/103 90/117/103
f 97/116/104 113/125/104 98/101/104
f 90/117/105 106/126/105 91/102/105
f 98/101/106 114/127/106 99/103/106
f 92/104/107 106/126/107 107/128/107
f 100/105/108 114/127/108 115/129/108
f 92/104/109 108/130/109 93/106/109
f 86/108/110 297/131/110 101/132/110
f 206/133/111 100/105/111 115/129/111
f 93/106/112 109/134/112 94/110/112
f 105/124/113 121/135/113 106/126/113
f 114/127/114 128/136/114 129/137/114
f 107/128/115 121/135/115 122/138/115
f 115/129/116 129/137/116 130/139/116
f 107/128/117 123/140/117 108/130/117
f 101/132/118 297/141/118 116/142/118
f 206/143/119 115/129/119 130/139/119
f 109/134/120 123/140/120 124/144/120
f 101/132/121 117/145/121 102/118/121
f 109/134/122 125/146/122 110/119/122
f 102/118/123 118/147/123 103/120/123
f 111/121/124 125/146/124 126/148/124
f 103/120/125 119/149/125 104/122/125
f 111/121/126 127/150/126 112/123/126
f 104/122/127 120/151/127 105/124/127
f 113/125/128 127/150/128 128/136/128
f 124/144/129 140/152/129 125/146/129
f 117/145/130 133/153/130 118/147/130
f 126/148/131 140/152/131 141/154/131
f 118/147/132 134/155/132 119/149/132
f 126/148/133 142/156/133 127/150/133
f 120/151/134 134/155/134 135/157/134
f 128/136/135 142/156/135 143/158/135
f 120/151/136 136/159/136 121/135/136
f 128/136/137 144/160/137 129/137/137
f 122/138/138 136/159/138 137/161/138
f 130/139/139 144/160/139 145/162/139
f 122/138/140 138/163/140 123/140/140
f 116/142/141 297/164/141 131/165/141
f 206/166/142 130/139/142 145/162/142
f 123/140/143 139/167/143 124/144/143
f 117/145/144 131/165/144 132/168/144
f 144/160/145 158/169/145 159/170/145
f 137/161/146 151/171/146 152/172/146
f 144/160/147 160/173/147 145/162/147
f 137/161/148 153/174/148 138/163/148
f 131/165/149 297/175/149 146/176/149
f 206/177/150 145/162/150 160/173/150
f 138/163/151 154/178/151 139/167/151
f 131/165/152 147/179/152 132/168/152
f 139/167/153 155/180/153 140/152/153
f 133/153/154 147/179/154 148/181/154
f 141/154/155 155/180/155 156/182/155
f 133/153/156 149/183/156 134/155/156
f 141/154/157 157/184/157 142/156/157
f 134/155/158 150/185/158 135/157/158
f 142/156/159 158/169/159 143/158/159
f 135/157/160 151/171/160 136/159/160
f 147/179/161 163/186/161 148/181/161
f 156/182/162 170/187/162 171/188/162
f 148/181/163 164/189/163 149/183/163
f 156/182/164 172/190/164 157/184/164
f 150/185/165 164/189/165 165/191/165
f 158/169/166 172/190/166 173/192/166
f 150/185/167 166/193/167 151/171/167
f 158/169/168 174/194/168 159/170/168
f 152/172/169 166/193/169 167/195/169
f 159/170/170 175/196/170 160/173/170
f 152/172/171 168/197/171 153/174/171
f 146/176/172 297/198/172 161/199/172
f 206/200/173 160/173/173 175/196/173
f 154/178/174 168/197/174 169/201/174
f 146/176/175 162/202/175 147/179/175
f 154/178/176 170/187/176 155/180/176
f 167/195/177 181/203/177 182/204/177
f 175/196/178 189/205/178 190/206/178
f 167/195/179 183/207/179 168/197/179
f 161/199/180 297/208/180 176/209/180
f 206/210/181 175/196/181 190/206/181
f 168/197/182 184/211/182 169/201/182
f 161/199/183 177/212/183 162/202/183
f 169/201/184 185/213/184 170/187/184
f 162/202/185 178/214/185 163/186/185
f 170/187/186 186/215/186 171/188/186
f 163/186/187 179/216/187 164/189/187
f 171/188/188 187/217/188 172/190/188
f 164/189/189 180/218/189 165/191/189
f 173/192/190 187/217/190 188/219/190
f 165/191/191 181/203/191 166/193/191
f 173/192/192 189/205/192 174/194/192
f 186/215/193 200/220/193 201/221/193
f 179/216/194 193/222/194 194/223/194
f 186/215/195 202/224/195 187/217/195
f 180/218/196 194/223/196 195/225/196
f 188/219/197 202/224/197 203/226/197
f 180/218/198 196/227/198 181/203/198
f 188/219/199 204/228/199 189/205/199
f 182/204/200 196/227/200 197/229/200
f 190/206/201 204/228/201 205/230/201
f 182/204/202 198/231/202 183/207/202
f 176/209/203 297/232/203 191/233/203
f 206/234/204 190/206/204 205/230/204
f 184/211/205 198/231/205 199/235/205
f 176/209/206 192/236/206 177/212/206
f 184/211/207 200/220/207 185/213/207
f 177/212/208 193/222/208 178/214/208
f 204/228/209 221/237/209 205/230/209
f 197/229/210 214/238/210 198/231/210
f 191/233/211 297/239/211 207/240/211
f 206/241/212 205/230/212 221/237/212
f 198/231/213 215/242/213 199/235/213
f 191/233/214 208/243/214 192/236/214
f 199/235/215 216/244/215 200/220/215
f 193/222/216 208/243/216 209/245/216
f 201/221/217 216/244/217 217/246/217
f 193/222/218 210/247/218 194/223/218
f 201/221/219 218/248/219 202/224/219
f 194/223/220 211/249/220 195/225/220
f 203/226/221 218/248/221 219/250/221
f 195/225/222 212/251/222 196/227/222
f 203/226/223 220/252/223 204/228/223
f 197/229/224 212/251/224 213/253/224
f 217/246/225 233/254/225 218/248/225
f 210/247/226 226/255/226 211/249/226
f 218/248/227 234/256/227 219/250/227
f 211/249/228 227/257/228 212/251/228
f 219/250/229 235/258/229 220/252/229
f 213/253/230 227/257/230 228/259/230
f 221/237/231 235/258/231 236/260/231
f 213/253/232 229/261/232 214/238/232
f 207/240/233 297/262/233 222/263/233
f 206/264/234 221/237/234 236/260/234
f 214/238/235 230/265/235 215/242/235
f 207/240/236 223/266/236 208/243/236
f 215/242/237 231/267/237 216/244/237
f 208/243/238 224/268/238 209/245/238
f 217/246/239 231/267/239 232/269/239
f 209/245/240 225/270/240 210/247/240
f 222/263/241 297/271/241 237/272/241
f 206/273/242 236/260/242 251/274/242
f 229/261/243 245/275/243 230/265/243
f 222/263/244 238/276/244 223/266/244
f 230/265/245 246/277/245 231/267/245
f 224/268/246 238/276/246 239/278/246
f 232/269/247 246/277/247 247/279/247
f 225/270/248 239/278/248 240/280/248
f 232/269/249 248/281/249 233/254/249
f 225/270/250 241/282/250 226/255/250
f 234/256/251 248/281/251 249/283/251
f 226/255/252 242/284/252 227/257/252
f 234/256/253 250/285/253 235/258/253
f 228/259/254 242/284/254 243/286/254
f 236/260/255 250/285/255 251/274/255
f 228/259/256 244/287/256 229/261/256
f 241/282/257 255/288/257 256/289/257
f 248/281/258 264/290/258 249/283/258
f 241/282/259 257/291/259 242/284/259
f 249/283/260 265/292/260 250/285/260
f 243/286/261 257/291/261 258/293/261
f 250/285/262 266/294/262 251/274/262
f 243/286/263 259/295/263 244/287/263
f 237/272/264 297/296/264 252/297/264
f 206/298/265 251/274/265 266/294/265
f 244/287/266 260/299/266 245/275/266
f 237/272/267 253/300/267 238/276/267
f 245/275/268 261/301/268 246/277/268
f 238/276/269 254/302/269 239/278/269
f 247/279/270 261/301/270 262/303/270
f 240/280/271 254/302/271 255/288/271
f 247/279/272 263/304/272 248/281/272
f 260/299/273 274/305/273 275/306/273
f 252/297/274 268/307/274 253/300/274
f 260/299/275 276/308/275 261/301/275
f 253/300/276 269/309/276 254/302/276
f 262/303/277 276/308/277 277/310/277
f 255/288/278 269/309/278 270/311/278
f 262/303/279 278/312/279 263/304/279
f 256/289/280 270/311/280 271/313/280
f 263/304/281 279/314/281 264/290/281
f 256/289/282 272/315/282 257/291/282
f 265/292/283 279/314/283 280/316/283
f 258/293/284 272/315/284 273/317/284
f 266/294/285 280/316/285 281/318/285
f 258/293/286 274/305/286 259/295/286
f 252/297/287 297/319/287 267/320/287
f 206/321/288 266/294/288 281/318/288
f 279/314/289 293/322/289 294/323/289
f 271/313/290 287/324/290 272/315/290
f 279/314/291 295/325/291 280/316/291
f 273/317/292 287/324/292 288/326/292
f 281/318/293 295/325/293 296/327/293
f 273/317/294 289/328/294 274/305/294
f 267/320/295 297/329/295 282/330/295
f 206/331/296 281/318/296 296/327/296
f 274/305/297 290/332/297 275/306/297
f 267/320/298 283/333/298 268/307/298
f 275/306/299 291/334/299 276/308/299
f 268/307/300 284/335/300 269/309/300
f 277/310/301 291/334/301 292/336/301
f 269/309/302 285/337/302 270/311/302
f 277/310/303 293/322/303 278/312/303
f 271/313/304 285/337/304 286/338/304
f 282/330/305 299/339/305 283/333/305
f 290/332/306 307/340/306 291/334/306
f 283/333/307 300/341/307 284/335/307
f 292/336/308 307/340/308 308/342/308
f 285/337/309 300/341/309 301/343/309
f 292/336/310 309/344/310 293/322/310
f 286/338/311 301/343/311 302/345/311
f 293/322/312 310/346/312 294/323/312
f 286/338/313 303/347/313 287/324/313
f 294/323/314 311/348/314 295/325/314
f 288/326/315 303/347/315 304/349/315
f 295/325/316 312/350/316 296/327/316
f 289/328/317 304/349/317 305/351/317
f 282/330/318 297/352/318 298/353/318
f 206/354/319 296/327/319 312/350/319
f 289/328/320 306/355/320 290/332/320
f 302/345/321 318/356/321 303/347/321
f 311/348/322 325/357/322 326/358/322
f 304/349/323 318/356/323 319/359/323
f 311/348/324 327/360/324 312/350/324
f 304/349/325 320/361/325 305/351/325
f 298/353/326 297/362/326 313/363/326
f 206/364/327 312/350/327 327/360/327
f 305/351/328 321/365/328 306/355/328
f 298/353/329 314/366/329 299/339/329
f 306/355/330 322/367/330 307/340/330
f 299/339/331 315/368/331 300/341/331
f 308/342/332 322/367/332 323/369/332
f 301/343/333 315/368/333 316/370/333
f 308/342/334 324/371/334 309/344/334
f 302/345/335 316/370/335 317/372/335
f 309/344/336 325/357/336 310/346/336
f 321/365/337 337/373/337 322/367/337
f 314/366/338 330/374/338 315/368/338
f 323/369/339 337/373/339 338/375/339
f 316/370/340 330/374/340 331/376/340
f 324/371/341 338/375/341 339/377/341
f 317/372/342 331/376/342 332/378/342
f 324/371/343 340/379/343 325/357/343
f 317/372/344 333/380/344 318/356/344
f 326/358/345 340/379/345 341/381/345
f 319/359/346 333/380/346 334/382/346
f 327/360/347 341/381/347 342/383/347
f 319/359/348 335/384/348 320/361/348
f 313/363/349 297/385/349 328/386/349
f 206/387/350 327/360/350 342/383/350
f 320/361/351 336/388/351 321/365/351
f 313/363/352 329/389/352 314/366/352
f 341/381/353 355/390/353 356/391/353
f 334/382/354 348/392/354 349/393/354
f 341/381/355 357/394/355 342/383/355
f 334/382/356 350/395/356 335/384/356
f 328/386/357 297/396/357 343/397/357
f 206/398/358 342/383/358 357/394/358
f 335/384/359 351/399/359 336/388/359
f 329/389/360 343/397/360 344/400/360
f 336/388/361 352/401/361 337/373/361
f 329/389/362 345/402/362 330/374/362
f 338/375/363 352/401/363 353/403/363
f 331/376/364 345/402/364 346/404/364
f 338/375/365 354/405/365 339/377/365
f 332/378/366 346/404/366 347/406/366
f 339/377/367 355/390/367 340/379/367
f 332/378/368 348/392/368 333/380/368
f 353/403/369 367/407/369 368/408/369
f 346/404/370 360/409/370 361/410/370
f 353/403/371 369/411/371 354/405/371
f 346/404/372 362/412/372 347/406/372
f 355/390/373 369/411/373 370/413/373
f 347/406/374 363/414/374 348/392/374
f 356/391/375 370/413/375 371/415/375
f 349/393/376 363/414/376 364/416/376
f 356/391/377 372/417/377 357/394/377
f 349/393/378 365/418/378 350/395/378
f 343/397/379 297/419/379 358/420/379
f 206/421/380 357/394/380 372/417/380
f 351/399/381 365/418/381 366/422/381
f 344/400/382 358/420/382 359/423/382
f 351/399/383 367/407/383 352/401/383
f 344/400/384 360/409/384 345/402/384
f 371/424/385 387/425/385 372/426/385
f 364/427/386 380/428/386 365/429/386
f 358/430/387 297/431/387 373/432/387
f 206/433/388 372/426/388 387/425/388
f 366/434/389 380/428/389 381/435/389
f 359/436/390 373/432/390 374/437/390
f 366/434/391 382/438/391 367/439/391
f 359/436/392 375/440/392 360/441/392
f 368/442/393 382/438/393 383/443/393
f 361/444/394 375/440/394 376/445/394
f 368/442/395 384/446/395 369/447/395
f 362/448/396 376/445/396 377/449/396
f 369/447/397 385/450/397 370/451/397
f 362/448/398 378/452/398 363/453/398
f 371/424/399 385/450/399 386/454/399
f 364/427/400 378/452/400 379/455/400
f 376/445/401 390/456/401 391/457/401
f 383/443/402 399/458/402 384/446/402
f 376/445/403 392/459/403 377/449/403
f 384/446/404 400/460/404 385/450/404
f 377/449/405 393/461/405 378/452/405
f 386/454/406 400/460/406 401/462/406
f 379/455/407 393/461/407 394/463/407
f 386/454/408 402/464/408 387/425/408
f 379/455/409 395/465/409 380/428/409
f 373/432/410 297/466/410 388/467/410
f 206/468/411 387/425/411 402/464/411
f 380/428/412 396/469/412 381/435/412
f 373/432/413 389/470/413 374/437/413
f 381/435/414 397/471/414 382/438/414
f 374/437/415 390/456/415 375/440/415
f 383/443/416 397/471/416 398/472/416
f 394/463/417 410/473/417 395/465/417
f 388/467/418 297/474/418 403/475/418
f 206/476/419 402/464/419 417/477/419
f 396/469/420 410/473/420 411/478/420
f 388/467/421 404/479/421 389/470/421
f 396/469/422 412/480/422 397/471/422
f 390/456/423 404/479/423 405/481/423
f 398/472/424 412/480/424 413/482/424
f 391/457/425 405/481/425 406/483/425
f 398/472/426 414/484/426 399/458/426
f 392/459/427 406/483/427 407/485/427
f 399/458/428 415/486/428 400/460/428
f 392/459/429 408/487/429 393/461/429
f 401/462/430 415/486/430 416/488/430
f 394/463/431 408/487/431 409/489/431
f 401/462/432 417/477/432 402/464/432
f 413/482/433 429/490/433 414/484/433
f 407/485/434 421/491/434 422/492/434
f 414/484/435 430/493/435 415/486/435
f 407/485/436 423/494/436 408/487/436
f 415/486/437 431/495/437 416/488/437
f 409/489/438 423/494/438 424/496/438
f 416/488/439 432/497/439 417/477/439
f 409/489/440 425/498/440 410/473/440
f 403/475/441 297/499/441 418/500/441
f 206/501/442 417/477/442 432/497/442
f 411/478/443 425/498/443 426/502/443
f 403/475/444 419/503/444 404/479/444
f 411/478/445 427/504/445 412/480/445
f 404/479/446 420/505/446 405/481/446
f 413/482/447 427/504/447 428/506/447
f 405/481/448 421/491/448 406/483/448
f 418/500/449 297/507/449 433/508/449
f 206/509/450 432/497/450 447/510/450
f 425/498/451 441/511/451 426/502/451
f 418/500/452 434/512/452 419/503/452
f 426/502/453 442/513/453 427/504/453
f 419/503/454 435/514/454 420/505/454
f 428/506/455 442/513/455 443/515/455
f 420/505/456 436/516/456 421/491/456
f 428/506/457 444/517/457 429/490/457
f 422/492/458 436/516/458 437/518/458
f 430/493/459 444/517/459 445/519/459
f 422/492/460 438/520/460 423/494/460
f 430/493/461 446/521/461 431/495/461
f 424/496/462 438/520/462 439/522/462
f 431/495/463 447/510/463 432/497/463
f 425/498/464 439/522/464 440/523/464
f 437/518/465 451/524/465 452/525/465
f 444/517/466 460/526/466 445/519/466
f 437/518/467 453/527/467 438/520/467
f 445/519/468 461/528/468 446/521/468
f 439/522/469 453/527/469 454/529/469
f 446/521/470 462/530/470 447/510/470
f 439/522/471 455/531/471 440/523/471
f 433/508/472 297/532/472 448/533/472
f 206/534/473 447/510/473 462/530/473
f 440/523/474 456/535/474 441/511/474
f 434/512/475 448/533/475 449/536/475
f 441/511/476 457/537/476 442/513/476
f 435/514/477 449/536/477 450/538/477
f 443/515/478 457/537/478 458/539/478
f 436/516/479 450/538/479 451/524/479
f 443/515/480 459/540/480 444/517/480
f 455/531/481 471/541/481 456/535/481
f 448/533/482 464/542/482 449/536/482
f 456/535/483 472/543/483 457/537/483
f 449/536/484 465/544/484 450/538/484
f 458/539/485 472/543/485 473/545/485
f 450/538/486 466/546/486 451/524/486
f 458/539/487 474/547/487 459/540/487
f 452/525/488 466/546/488 467/548/488
f 459/540/489 475/549/489 460/526/489
f 452/525/490 468/550/490 453/527/490
f 460/526/491 476/551/491 461/528/491
f 454/529/492 468/550/492 469/552/492
f 462/530/493 476/551/493 477/553/493
f 454/529/494 470/554/494 455/531/494
f 448/533/495 297/555/495 463/556/495
f 206/557/496 462/530/496 477/553/496
f 474/547/497 10/3/497 475/549/497
f 468/550/498 5/4/498 6/6/498
f 475/549/499 481/8/499 476/551/499
f 469/552/500 6/6/500 7/10/500
f 476/551/501 482/12/501 477/553/501
f 470/554/502 7/10/502 8/14/502
f 463/556/503 297/558/503 1/15/503
f 206/559/504 477/553/504 482/12/504
f 470/554/505 9/20/505 471/541/505
f 464/542/506 1/15/506 2/22/506
f 471/541/507 478/24/507 472/543/507
f 465/544/508 2/22/508 3/25/508
f 473/545/509 478/24/509 479/28/509
f 466/546/510 3/25/510 4/30/510
f 473/545/511 480/1/511 474/547/511
f 467/548/512 4/30/512 5/4/512
f 480/1/1 22/31/1 23/2/1
f 5/4/2 15/32/2 16/5/2
f 10/3/3 23/2/3 24/7/3
f 6/6/4 16/5/4 17/9/4
f 481/8/5 24/7/5 25/11/5
f 7/10/513 17/9/513 18/13/513
f 8/14/514 18/13/514 19/19/514
f 1/15/10 11/17/10 12/21/10
f 9/20/11 19/19/11 20/23/11
f 3/25/12 2/22/12 12/21/12
f 478/24/13 20/23/13 21/27/13
f 3/25/14 13/26/14 14/29/14
f 479/28/15 21/27/15 22/31/15
f 4/30/16 14/29/16 15/32/16
f 13/26/17 28/49/17 29/33/17
f 22/31/18 21/27/18 36/34/18
f 14/29/19 29/33/19 30/36/19
f 22/31/20 37/35/20 38/37/20
f 15/32/21 30/36/21 31/38/21
f 23/2/22 38/37/22 39/39/22
f 16/5/23 31/38/23 32/40/23
f 24/7/24 39/39/24 40/41/24
f 17/9/25 32/40/25 33/42/25
f 19/19/28 18/13/28 33/42/28
f 11/17/515 26/44/515 27/47/515
f 20/23/30 19/19/30 34/46/30
f 12/21/31 27/47/31 28/49/31
f 20/23/32 35/48/32 36/34/32
f 32/40/33 47/66/33 48/50/33
f 33/42/36 48/50/36 49/55/36
f 26/44/37 41/52/37 42/56/37
f 34/46/38 49/55/38 50/57/38
f 27/47/516 42/56/516 43/58/516
f 36/34/40 35/48/40 50/57/40
f 28/49/41 43/58/41 44/60/41
f 37/35/42 36/34/42 51/59/42
f 29/33/43 44/60/43 45/62/43
f 37/35/44 52/61/44 53/63/44
f 30/36/45 45/62/45 46/64/45
f 38/37/46 53/63/46 54/65/46
f 32/40/47 31/38/47 46/64/47
f 39/39/48 54/65/48 55/54/48
f 51/59/49 66/82/49 67/67/49
f 44/60/50 59/83/50 60/68/50
f 52/61/51 67/67/51 68/69/51
f 45/62/52 60/68/52 61/70/52
f 53/63/53 68/69/53 69/71/53
f 46/64/54 61/70/54 62/72/54
f 54/65/55 69/71/55 70/73/55
f 48/50/56 47/66/56 62/72/56
f 48/50/59 63/74/59 64/78/59
f 41/52/60 56/76/60 57/79/60
f 49/55/61 64/78/61 65/80/61
f 42/56/62 57/79/62 58/81/62
f 51/59/63 50/57/63 65/80/63
f 43/58/64 58/81/64 59/83/64
f 63/74/517 78/98/517 79/86/517
f 56/76/67 71/100/67 72/87/67
f 64/78/68 79/86/68 80/88/68
f 57/79/69 72/87/69 73/89/69
f 66/82/70 65/80/70 80/88/70
f 58/81/71 73/89/71 74/91/71
f 66/82/72 81/90/72 82/92/72
f 60/68/73 59/83/73 74/91/73
f 68/69/74 67/67/74 82/92/74
f 60/68/75 75/93/75 76/95/75
f 69/71/76 68/69/76 83/94/76
f 61/70/77 76/95/77 77/97/77
f 69/71/78 84/96/78 85/85/78
f 63/74/518 62/72/518 77/97/518
f 82/92/81 97/116/81 98/101/81
f 75/93/82 90/117/82 91/102/82
f 84/96/519 83/94/519 98/101/519
f 77/97/84 76/95/84 91/102/84
f 84/96/85 99/103/85 100/105/85
f 77/97/86 92/104/86 93/106/86
f 78/98/89 93/106/89 94/110/89
f 71/100/90 86/108/90 87/111/90
f 79/86/91 94/110/91 95/112/91
f 72/87/92 87/111/92 88/113/92
f 81/90/93 80/88/93 95/112/93
f 73/89/94 88/113/94 89/115/94
f 82/92/95 81/90/95 96/114/95
f 75/93/96 74/91/96 89/115/96
f 86/108/97 101/132/97 102/118/97
f 94/110/98 109/134/98 110/119/98
f 87/111/99 102/118/99 103/120/99
f 96/114/100 95/112/100 110/119/100
f 89/115/101 88/113/101 103/120/101
f 97/116/102 96/114/102 111/121/102
f 89/115/103 104/122/103 105/124/103
f 97/116/104 112/123/104 113/125/104
f 90/117/105 105/124/105 106/126/105
f 98/101/106 113/125/106 114/127/106
f 92/104/107 91/102/107 106/126/107
f 100/105/108 99/103/108 114/127/108
f 92/104/109 107/128/109 108/130/109
f 93/106/520 108/130/520 109/134/520
f 105/124/113 120/151/113 121/135/113
f 114/127/114 113/125/114 128/136/114
f 107/128/115 106/126/115 121/135/115
f 115/129/116 114/127/116 129/137/116
f 107/128/117 122/138/117 123/140/117
f 109/134/120 108/130/120 123/140/120
f 101/132/121 116/142/121 117/145/121
f 109/134/122 124/144/122 125/146/122
f 102/118/123 117/145/123 118/147/123
f 111/121/124 110/119/124 125/146/124
f 103/120/125 118/147/125 119/149/125
f 111/121/126 126/148/126 127/150/126
f 104/122/127 119/149/127 120/151/127
f 113/125/128 112/123/128 127/150/128
f 124/144/129 139/167/129 140/152/129
f 117/145/130 132/168/130 133/153/130
f 126/148/131 125/146/131 140/152/131
f 118/147/132 133/153/132 134/155/132
f 126/148/133 141/154/133 142/156/133
f 120/151/134 119/149/134 134/155/134
f 128/136/135 127/150/135 142/156/135
f 120/151/136 135/157/136 136/159/136
f 128/136/137 143/158/137 144/160/137
f 122/138/138 121/135/138 136/159/138
f 130/139/139 129/137/139 144/160/139
f 122/138/140 137/161/140 138/163/140
f 123/140/143 138/163/143 139/167/143
f 117/145/144 116/142/144 131/165/144
f 144/160/145 143/158/145 158/169/145
f 137/161/146 136/159/146 151/171/146
f 144/160/147 159/170/147 160/173/147
f 137/161/148 152/172/148 153/174/148
f 138/163/151 153/174/151 154/178/151
f 131/165/152 146/176/152 147/179/152
f 139/167/153 154/178/153 155/180/153
f 133/153/154 132/168/154 147/179/154
f 141/154/155 140/152/155 155/180/155
f 133/153/156 148/181/156 149/183/156
f 141/154/157 156/182/157 157/184/157
f 134/155/158 149/183/158 150/185/158
f 142/156/159 157/184/159 158/169/159
f 135/157/160 150/185/160 151/171/160
f 147/179/161 162/202/161 163/186/161
f 156/182/162 155/180/162 170/187/162
f 148/181/163 163/186/163 164/189/163
f 156/182/164 171/188/164 172/190/164
f 150/185/165 149/183/165 164/189/165
f 158/169/166 157/184/166 172/190/166
f 150/185/167 165/191/167 166/193/167
f 158/169/521 173/192/521 174/194/521
f 152/172/169 151/171/169 166/193/169
f 159/170/522 174/194/522 175/196/522
f 152/172/171 167/195/171 168/197/171
f 154/178/174 153/174/174 168/197/174
f 146/176/175 161/199/175 162/202/175
f 154/178/176 169/201/176 170/187/176
f 167/195/177 166/193/177 181/203/177
f 175/196/523 174/194/523 189/205/523
f 167/195/179 182/204/179 183/207/179
f 168/197/182 183/207/182 184/211/182
f 161/199/183 176/209/183 177/212/183
f 169/201/184 184/211/184 185/213/184
f 162/202/185 177/212/185 178/214/185
f 170/187/186 185/213/186 186/215/186
f 163/186/187 178/214/187 179/216/187
f 171/188/188 186/215/188 187/217/188
f 164/189/189 179/216/189 180/218/189
f 173/192/190 172/190/190 187/217/190
f 165/191/191 180/218/191 181/203/191
f 173/192/192 188/219/192 189/205/192
f 186/215/193 185/213/193 200/220/193
f 179/216/194 178/214/194 193/222/194
f 186/215/195 201/221/195 202/224/195
f 180/218/196 179/216/196 194/223/196
f 188/219/197 187/217/197 202/224/197
f 180/218/198 195/225/198 196/227/198
f 188/219/199 203/226/199 204/228/199
f 182/204/200 181/203/200 196/227/200
f 190/206/201 189/205/201 204/228/201
f 182/204/202 197/229/202 198/231/202
f 184/211/205 183/207/205 198/231/205
f 176/209/206 191/233/206 192/236/206
f 184/211/207 199/235/207 200/220/207
f 177/212/208 192/236/208 193/222/208
f 204/228/524 220/252/524 221/237/524
f 197/229/210 213/253/210 214/238/210
f 198/231/213 214/238/213 215/242/213
f 191/233/214 207/240/214 208/243/214
f 199/235/215 215/242/215 216/244/215
f 193/222/216 192/236/216 208/243/216
f 201/221/217 200/220/217 216/244/217
f 193/222/218 209/245/218 210/247/218
f 201/221/219 217/246/219 218/248/219
f 194/223/220 210/247/220 211/249/220
f 203/226/221 202/224/221 218/248/221
f 195/225/222 211/249/222 212/251/222
f 203/226/525 219/250/525 220/252/525
f 197/229/224 196/227/224 212/251/224
f 217/246/225 232/269/225 233/254/225
f 210/247/226 225/270/226 226/255/226
f 218/248/227 233/254/227 234/256/227
f 211/249/228 226/255/228 227/257/228
f 219/250/229 234/256/229 235/258/229
f 213/253/230 212/251/230 227/257/230
f 221/237/231 220/252/231 235/258/231
f 213/253/232 228/259/232 229/261/232
f 214/238/235 229/261/235 230/265/235
f 207/240/236 222/263/236 223/266/236
f 215/242/237 230/265/237 231/267/237
f 208/243/238 223/266/238 224/268/238
f 217/246/239 216/244/239 231/267/239
f 209/245/240 224/268/240 225/270/240
f 229/261/243 244/287/243 245/275/243
f 222/263/244 237/272/244 238/276/244
f 230/265/245 245/275/245 246/277/245
f 224/268/246 223/266/246 238/276/246
f 232/269/247 231/267/247 246/277/247
f 225/270/248 224/268/248 239/278/248
f 232/269/249 247/279/249 248/281/249
f 225/270/250 240/280/250 241/282/250
f 234/256/251 233/254/251 248/281/251
f 226/255/252 241/282/252 242/284/252
f 234/256/253 249/283/253 250/285/253
f 228/259/254 227/257/254 242/284/254
f 236/260/255 235/258/255 250/285/255
f 228/259/256 243/286/256 244/287/256
f 241/282/257 240/280/257 255/288/257
f 248/281/258 263/304/258 264/290/258
f 241/282/259 256/289/259 257/291/259
f 249/283/260 264/290/260 265/292/260
f 243/286/261 242/284/261 257/291/261
f 250/285/262 265/292/262 266/294/262
f 243/286/263 258/293/263 259/295/263
f 244/287/266 259/295/266 260/299/266
f 237/272/267 252/297/267 253/300/267
f 245/275/268 260/299/268 261/301/268
f 238/276/269 253/300/269 254/302/269
f 247/279/270 246/277/270 261/301/270
f 240/280/271 239/278/271 254/302/271
f 247/279/272 262/303/272 263/304/272
f 260/299/273 259/295/273 274/305/273
f 252/297/526 267/320/526 268/307/526
f 260/299/275 275/306/275 276/308/275
f 253/300/276 268/307/276 269/309/276
f 262/303/277 261/301/277 276/308/277
f 255/288/278 254/302/278 269/309/278
f 262/303/279 277/310/279 278/312/279
f 256/289/280 255/288/280 270/311/280
f 263/304/281 278/312/281 279/314/281
f 256/289/282 271/313/282 272/315/282
f 265/292/283 264/290/283 279/314/283
f 258/293/284 257/291/284 272/315/284
f 266/294/285 265/292/285 280/316/285
f 258/293/286 273/317/286 274/305/286
f 279/314/289 278/312/289 293/322/289
f 271/313/290 286/338/290 287/324/290
f 279/314/527 294/323/527 295/325/527
f 273/317/292 272/315/292 287/324/292
f 281/318/293 280/316/293 295/325/293
f 273/317/294 288/326/294 289/328/294
f 274/305/297 289/328/297 290/332/297
f 267/320/528 282/330/528 283/333/528
f 275/306/299 290/332/299 291/334/299
f 268/307/300 283/333/300 284/335/300
f 277/310/301 276/308/301 291/334/301
f 269/309/302 284/335/302 285/337/302
f 277/310/303 292/336/303 293/322/303
f 271/313/304 270/311/304 285/337/304
f 282/330/305 298/353/305 299/339/305
f 290/332/306 306/355/306 307/340/306
f 283/333/307 299/339/307 300/341/307
f 292/336/308 291/334/308 307/340/308
f 285/337/309 284/335/309 300/341/309
f 292/336/310 308/342/310 309/344/310
f 286/338/311 285/337/311 301/343/311
f 293/322/312 309/344/312 310/346/312
f 286/338/313 302/345/313 303/347/313
f 294/323/314 310/346/314 311/348/314
f 288/326/315 287/324/315 303/347/315
f 295/325/316 311/348/316 312/350/316
f 289/328/317 288/326/317 304/349/317
f 289/328/320 305/351/320 306/355/320
f 302/345/321 317/372/321 318/356/321
f 311/348/322 310/346/322 325/357/322
f 304/349/323 303/347/323 318/356/323
f 311/348/324 326/358/324 327/360/324
f 304/349/325 319/359/325 320/361/325
f 305/351/328 320/361/328 321/365/328
f 298/353/329 313/363/329 314/366/329
f 306/355/330 321/365/330 322/367/330
f 299/339/331 314/366/331 315/368/331
f 308/342/332 307/340/332 322/367/332
f 301/343/333 300/341/333 315/368/333
f 308/342/334 323/369/334 324/371/334
f 302/345/335 301/343/335 316/370/335
f 309/344/336 324/371/336 325/357/336
f 321/365/337 336/388/337 337/373/337
f 314/366/529 329/389/529 330/374/529
f 323/369/339 322/367/339 337/373/339
f 316/370/340 315/368/340 330/374/340
f 324/371/341 323/369/341 338/375/341
f 317/372/342 316/370/342 331/376/342
f 324/371/343 339/377/343 340/379/343
f 317/372/344 332/378/344 333/380/344
f 326/358/345 325/357/345 340/379/345
f 319/359/346 318/356/346 333/380/346
f 327/360/347 326/358/347 341/381/347
f 319/359/348 334/382/348 335/384/348
f 320/361/351 335/384/351 336/388/351
f 313/363/352 328/386/352 329/389/352
f 341/381/353 340/379/353 355/390/353
f 334/382/354 333/380/354 348/392/354
f 341/381/355 356/391/355 357/394/355
f 334/382/356 349/393/356 350/395/356
f 335/384/359 350/395/359 351/399/359
f 329/389/360 328/386/360 343/397/360
f 336/388/361 351/399/361 352/401/361
f 329/389/362 344/400/362 345/402/362
f 338/375/363 337/373/363 352/401/363
f 331/376/364 330/374/364 345/402/364
f 338/375/365 353/403/365 354/405/365
f 332/378/366 331/376/366 346/404/366
f 339/377/367 354/405/367 355/390/367
f 332/378/368 347/406/368 348/392/368
f 353/403/369 352/401/369 367/407/369
f 346/404/370 345/402/370 360/409/370
f 353/403/371 368/408/371 369/411/371
f 346/404/372 361/410/372 362/412/372
f 355/390/373 354/405/373 369/411/373
f 347/406/374 362/412/374 363/414/374
f 356/391/375 355/390/375 370/413/375
f 349/393/376 348/392/376 363/414/376
f 356/391/377 371/415/377 372/417/377
f 349/393/378 364/416/378 365/418/378
f 351/399/381 350/395/381 365/418/381
f 344/400/382 343/397/382 358/420/382
f 351/399/383 366/422/383 367/407/383
f 344/400/384 359/423/384 360/409/384
f 371/424/385 386/454/385 387/425/385
f 364/427/386 379/455/386 380/428/386
f 366/434/389 365/429/389 380/428/389
f 359/436/390 358/430/390 373/432/390
f 366/434/391 381/435/391 382/438/391
f 359/436/392 374/437/392 375/440/392
f 368/442/393 367/439/393 382/438/393
f 361/444/394 360/441/394 375/440/394
f 368/442/395 383/443/395 384/446/395
f 362/448/396 361/444/396 376/445/396
f 369/447/397 384/446/397 385/450/397
f 362/448/398 377/449/398 378/452/398
f 371/424/399 370/451/399 385/450/399
f 364/427/400 363/453/400 378/452/400
f 376/445/401 375/440/401 390/456/401
f 383/443/402 398/472/402 399/458/402
f 376/445/403 391/457/403 392/459/403
f 384/446/404 399/458/404 400/460/404
f 377/449/405 392/459/405 393/461/405
f 386/454/406 385/450/406 400/460/406
f 379/455/407 378/452/407 393/461/407
f 386/454/408 401/462/408 402/464/408
f 379/455/409 394/463/409 395/465/409
f 380/428/412 395/465/412 396/469/412
f 373/432/413 388/467/413 389/470/413
f 381/435/414 396/469/414 397/471/414
f 374/437/415 389/470/415 390/456/415
f 383/443/416 382/438/416 397/471/416
f 394/463/417 409/489/417 410/473/417
f 396/469/420 395/465/420 410/473/420
f 388/467/421 403/475/421 404/479/421
f 396/469/422 411/478/422 412/480/422
f 390/456/423 389/470/423 404/479/423
f 398/472/424 397/471/424 412/480/424
f 391/457/425 390/456/425 405/481/425
f 398/472/426 413/482/426 414/484/426
f 392/459/427 391/457/427 406/483/427
f 399/458/428 414/484/428 415/486/428
f 392/459/429 407/485/429 408/487/429
f 401/462/530 400/460/530 415/486/530
f 394/463/431 393/461/431 408/487/431
f 401/462/432 416/488/432 417/477/432
f 413/482/433 428/506/433 429/490/433
f 407/485/434 406/483/434 421/491/434
f 414/484/435 429/490/435 430/493/435
f 407/485/436 422/492/436 423/494/436
f 415/486/437 430/493/437 431/495/437
f 409/489/438 408/487/438 423/494/438
f 416/488/439 431/495/439 432/497/439
f 409/489/440 424/496/440 425/498/440
f 411/478/443 410/473/443 425/498/443
f 403/475/444 418/500/444 419/503/444
f 411/478/445 426/502/445 427/504/445
f 404/479/446 419/503/446 420/505/446
f 413/482/447 412/480/447 427/504/447
f 405/481/448 420/505/448 421/491/448
f 425/498/451 440/523/451 441/511/451
f 418/500/452 433/508/452 434/512/452
f 426/502/453 441/511/453 442/513/453
f 419/503/454 434/512/454 435/514/454
f 428/506/455 427/504/455 442/513/455
f 420/505/456 435/514/456 436/516/456
f 428/506/457 443/515/457 444/517/457
f 422/492/458 421/491/458 436/516/458
f 430/493/459 429/490/459 444/517/459
f 422/492/460 437/518/460 438/520/460
f 430/493/461 445/519/461 446/521/461
f 424/496/462 423/494/462 438/520/462
f 431/495/463 446/521/463 447/510/463
f 425/498/464 424/496/464 439/522/464
f 437/518/465 436/516/465 451/524/465
f 444/517/466 459/540/466 460/526/466
f 437/518/467 452/525/467 453/527/467
f 445/519/531 460/526/531 461/528/531
f 439/522/469 438/520/469 453/527/469
f 446/521/470 461/528/470 462/530/470
f 439/522/471 454/529/471 455/531/471
f 440/523/474 455/531/474 456/535/474
f 434/512/475 433/508/475 448/533/475
f 441/511/476 456/535/476 457/537/476
f 435/514/477 434/512/477 449/536/477
f 443/515/478 442/513/478 457/537/478
f 436/516/479 435/514/479 450/538/479
f 443/515/480 458/539/480 459/540/480
f 455/531/481 470/554/481 471/541/481
f 448/533/482 463/556/482 464/542/482
f 456/535/483 471/541/483 472/543/483
f 449/536/484 464/542/484 465/544/484
f 458/539/485 457/537/485 472/543/485
f 450/538/486 465/544/486 466/546/486
f 458/539/487 473/545/487 474/547/487
f 452/525/488 451/524/488 466/546/488
f 459/540/489 474/547/489 475/549/489
f 452/525/490 467/548/490 468/550/490
f 460/526/491 475/549/491 476/551/491
f 454/529/492 453/527/492 468/550/492
f 462/530/493 461/528/493 476/551/493
f 454/529/494 469/552/494 470/554/494
f 474/547/497 480/1/497 10/3/497
f 468/550/498 467/548/498 5/4/498
f 475/549/499 10/3/499 481/8/499
f 469/552/500 468/550/500 6/6/500
f 476/551/501 481/8/501 482/12/501
f 470/554/532 469/552/532 7/10/532
f 470/554/533 8/14/533 9/20/533
f 464/542/506 463/556/506 1/15/506
f 471/541/507 9/20/507 478/24/507
f 465/544/508 464/542/508 2/22/508
f 473/545/509 472/543/509 478/24/509
f 466/546/510 465/544/510 3/25/510
f 473/545/511 479/28/511 480/1/511
f 467/548/512 466/546/512 4/30/512

```

`Engine/Assets/models/Primitives/Obj/pTorus.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl None
Ns 500
Ka 0.8 0.8 0.8
Kd 0.8 0.8 0.8
Ks 0.8 0.8 0.8
d 1
illum 2

```

`Engine/Assets/models/Primitives/Obj/pTorus.obj`:

```obj
# Blender v2.90.0 OBJ File: ''
# www.blender.org
mtllib pTorus.mtl
o Torus.001
v -1.250000 0.000000 0.000000
v -1.216506 -0.125000 0.000000
v -1.125000 -0.216506 0.000000
v -1.000000 -0.250000 0.000000
v -0.875000 -0.216506 0.000000
v -0.783494 -0.125000 0.000000
v -0.750000 -0.000000 0.000000
v -0.783494 0.125000 0.000000
v -0.875000 0.216506 0.000000
v -1.000000 0.250000 0.000000
v -1.125000 0.216506 0.000000
v -1.216506 0.125000 0.000000
v -1.239306 0.000000 -0.163158
v -1.206099 -0.125000 -0.158786
v -1.115376 -0.216506 -0.146842
v -0.991445 -0.250000 -0.130526
v -0.867514 -0.216506 -0.114210
v -0.776791 -0.125000 -0.102266
v -0.743584 -0.000000 -0.097895
v -0.776791 0.125000 -0.102266
v -0.867514 0.216506 -0.114210
v -0.991445 0.250000 -0.130526
v -1.115376 0.216506 -0.146842
v -1.206099 0.125000 -0.158786
v -1.207407 0.000000 -0.323524
v -1.175055 -0.125000 -0.314855
v -1.086667 -0.216506 -0.291171
v -0.965926 -0.250000 -0.258819
v -0.845185 -0.216506 -0.226467
v -0.756797 -0.125000 -0.202783
v -0.724444 -0.000000 -0.194114
v -0.756797 0.125000 -0.202783
v -0.845185 0.216506 -0.226467
v -0.965926 0.250000 -0.258819
v -1.086667 0.216506 -0.291171
v -1.175055 0.125000 -0.314855
v -1.154849 0.000000 -0.478354
v -1.123905 -0.125000 -0.465537
v -1.039364 -0.216506 -0.430519
v -0.923880 -0.250000 -0.382683
v -0.808395 -0.216506 -0.334848
v -0.723854 -0.125000 -0.299830
v -0.692910 -0.000000 -0.287013
v -0.723854 0.125000 -0.299830
v -0.808395 0.216506 -0.334848
v -0.923880 0.250000 -0.382683
v -1.039364 0.216506 -0.430519
v -1.123905 0.125000 -0.465537
v -1.082532 0.000000 -0.625000
v -1.053525 -0.125000 -0.608253
v -0.974279 -0.216506 -0.562500
v -0.866025 -0.250000 -0.500000
v -0.757772 -0.216506 -0.437500
v -0.678525 -0.125000 -0.391747
v -0.649519 -0.000000 -0.375000
v -0.678525 0.125000 -0.391747
v -0.757772 0.216506 -0.437500
v -0.866025 0.250000 -0.500000
v -0.974279 0.216506 -0.562500
v -1.053525 0.125000 -0.608253
v -0.991692 0.000000 -0.760952
v -0.965119 -0.125000 -0.740562
v -0.892523 -0.216506 -0.684856
v -0.793353 -0.250000 -0.608761
v -0.694184 -0.216506 -0.532666
v -0.621587 -0.125000 -0.476961
v -0.595015 -0.000000 -0.456571
v -0.621587 0.125000 -0.476961
v -0.694184 0.216506 -0.532666
v -0.793353 0.250000 -0.608761
v -0.892523 0.216506 -0.684856
v -0.965119 0.125000 -0.740562
v -0.883883 0.000000 -0.883884
v -0.860200 -0.125000 -0.860200
v -0.795495 -0.216506 -0.795495
v -0.707107 -0.250000 -0.707107
v -0.618718 -0.216506 -0.618719
v -0.554014 -0.125000 -0.554014
v -0.530330 -0.000000 -0.530330
v -0.554014 0.125000 -0.554014
v -0.618718 0.216506 -0.618719
v -0.707107 0.250000 -0.707107
v -0.795495 0.216506 -0.795495
v -0.860200 0.125000 -0.860200
v -0.760952 0.000000 -0.991691
v -0.740562 -0.125000 -0.965119
v -0.684857 -0.216506 -0.892522
v -0.608762 -0.250000 -0.793353
v -0.532666 -0.216506 -0.694184
v -0.476961 -0.125000 -0.621587
v -0.456571 -0.000000 -0.595015
v -0.476961 0.125000 -0.621587
v -0.532666 0.216506 -0.694184
v -0.608762 0.250000 -0.793353
v -0.684857 0.216506 -0.892522
v -0.740562 0.125000 -0.965119
v -0.625000 0.000000 -1.082532
v -0.608253 -0.125000 -1.053525
v -0.562500 -0.216506 -0.974279
v -0.500000 -0.250000 -0.866025
v -0.437500 -0.216506 -0.757772
v -0.391747 -0.125000 -0.678525
v -0.375000 -0.000000 -0.649519
v -0.391747 0.125000 -0.678525
v -0.437500 0.216506 -0.757772
v -0.500000 0.250000 -0.866025
v -0.562500 0.216506 -0.974279
v -0.608253 0.125000 -1.053525
v -0.478355 0.000000 -1.154849
v -0.465537 -0.125000 -1.123905
v -0.430519 -0.216506 -1.039364
v -0.382684 -0.250000 -0.923879
v -0.334848 -0.216506 -0.808394
v -0.299830 -0.125000 -0.723854
v -0.287013 -0.000000 -0.692910
v -0.299830 0.125000 -0.723854
v -0.334848 0.216506 -0.808394
v -0.382684 0.250000 -0.923879
v -0.430519 0.216506 -1.039364
v -0.465537 0.125000 -1.123905
v -0.323524 0.000000 -1.207407
v -0.314855 -0.125000 -1.175055
v -0.291171 -0.216506 -1.086667
v -0.258819 -0.250000 -0.965926
v -0.226467 -0.216506 -0.845185
v -0.202783 -0.125000 -0.756797
v -0.194114 -0.000000 -0.724444
v -0.202783 0.125000 -0.756797
v -0.226467 0.216506 -0.845185
v -0.258819 0.250000 -0.965926
v -0.291171 0.216506 -1.086667
v -0.314855 0.125000 -1.175055
v -0.163158 0.000000 -1.239306
v -0.158786 -0.125000 -1.206099
v -0.146842 -0.216506 -1.115376
v -0.130526 -0.250000 -0.991445
v -0.114210 -0.216506 -0.867514
v -0.102266 -0.125000 -0.776791
v -0.097895 -0.000000 -0.743584
v -0.102266 0.125000 -0.776791
v -0.114210 0.216506 -0.867514
v -0.130526 0.250000 -0.991445
v -0.146842 0.216506 -1.115376
v -0.158786 0.125000 -1.206099
v -0.000000 0.000000 -1.250000
v -0.000000 -0.125000 -1.216506
v -0.000000 -0.216506 -1.125000
v -0.000000 -0.250000 -1.000000
v -0.000000 -0.216506 -0.875000
v -0.000000 -0.125000 -0.783494
v -0.000000 -0.000000 -0.750000
v -0.000000 0.125000 -0.783494
v -0.000000 0.216506 -0.875000
v -0.000000 0.250000 -1.000000
v -0.000000 0.216506 -1.125000
v -0.000000 0.125000 -1.216506
v 0.163158 0.000000 -1.239306
v 0.158786 -0.125000 -1.206099
v 0.146842 -0.216506 -1.115375
v 0.130526 -0.250000 -0.991445
v 0.114211 -0.216506 -0.867514
v 0.102267 -0.125000 -0.776791
v 0.097895 -0.000000 -0.743584
v 0.102267 0.125000 -0.776791
v 0.114211 0.216506 -0.867514
v 0.130526 0.250000 -0.991445
v 0.146842 0.216506 -1.115375
v 0.158786 0.125000 -1.206099
v 0.323524 0.000000 -1.207407
v 0.314855 -0.125000 -1.175055
v 0.291171 -0.216506 -1.086667
v 0.258819 -0.250000 -0.965926
v 0.226467 -0.216506 -0.845185
v 0.202783 -0.125000 -0.756797
v 0.194114 -0.000000 -0.724444
v 0.202783 0.125000 -0.756797
v 0.226467 0.216506 -0.845185
v 0.258819 0.250000 -0.965926
v 0.291171 0.216506 -1.086667
v 0.314855 0.125000 -1.175055
v 0.478354 0.000000 -1.154849
v 0.465537 -0.125000 -1.123905
v 0.430519 -0.216506 -1.039364
v 0.382684 -0.250000 -0.923880
v 0.334848 -0.216506 -0.808395
v 0.299830 -0.125000 -0.723854
v 0.287013 -0.000000 -0.692910
v 0.299830 0.125000 -0.723854
v 0.334848 0.216506 -0.808395
v 0.382684 0.250000 -0.923880
v 0.430519 0.216506 -1.039364
v 0.465537 0.125000 -1.123905
v 0.625000 0.000000 -1.082532
v 0.608253 -0.125000 -1.053526
v 0.562500 -0.216506 -0.974279
v 0.500000 -0.250000 -0.866026
v 0.437500 -0.216506 -0.757772
v 0.391747 -0.125000 -0.678525
v 0.375000 -0.000000 -0.649519
v 0.391747 0.125000 -0.678525
v 0.437500 0.216506 -0.757772
v 0.500000 0.250000 -0.866026
v 0.562500 0.216506 -0.974279
v 0.608253 0.125000 -1.053526
v 0.760952 0.000000 -0.991692
v 0.740562 -0.125000 -0.965119
v 0.684857 -0.216506 -0.892522
v 0.608761 -0.250000 -0.793353
v 0.532666 -0.216506 -0.694184
v 0.476961 -0.125000 -0.621587
v 0.456571 -0.000000 -0.595015
v 0.476961 0.125000 -0.621587
v 0.532666 0.216506 -0.694184
v 0.608761 0.250000 -0.793353
v 0.684857 0.216506 -0.892522
v 0.740562 0.125000 -0.965119
v 0.883884 0.000000 -0.883883
v 0.860200 -0.125000 -0.860200
v 0.795495 -0.216506 -0.795495
v 0.707107 -0.250000 -0.707107
v 0.618719 -0.216506 -0.618718
v 0.554014 -0.125000 -0.554013
v 0.530330 -0.000000 -0.530330
v 0.554014 0.125000 -0.554013
v 0.618719 0.216506 -0.618718
v 0.707107 0.250000 -0.707107
v 0.795495 0.216506 -0.795495
v 0.860200 0.125000 -0.860200
v 0.991692 0.000000 -0.760952
v 0.965119 -0.125000 -0.740562
v 0.892522 -0.216506 -0.684857
v 0.793353 -0.250000 -0.608761
v 0.694184 -0.216506 -0.532666
v 0.621587 -0.125000 -0.476961
v 0.595015 -0.000000 -0.456571
v 0.621587 0.125000 -0.476961
v 0.694184 0.216506 -0.532666
v 0.793353 0.250000 -0.608761
v 0.892522 0.216506 -0.684857
v 0.965119 0.125000 -0.740562
v 1.082532 0.000000 -0.625000
v 1.053525 -0.125000 -0.608253
v 0.974278 -0.216506 -0.562500
v 0.866025 -0.250000 -0.500000
v 0.757772 -0.216506 -0.437500
v 0.678525 -0.125000 -0.391747
v 0.649519 -0.000000 -0.375000
v 0.678525 0.125000 -0.391747
v 0.757772 0.216506 -0.437500
v 0.866025 0.250000 -0.500000
v 0.974278 0.216506 -0.562500
v 1.053525 0.125000 -0.608253
v 1.154849 0.000000 -0.478354
v 1.123905 -0.125000 -0.465537
v 1.039364 -0.216506 -0.430519
v 0.923880 -0.250000 -0.382683
v 0.808395 -0.216506 -0.334848
v 0.723854 -0.125000 -0.299830
v 0.692910 -0.000000 -0.287013
v 0.723854 0.125000 -0.299830
v 0.808395 0.216506 -0.334848
v 0.923880 0.250000 -0.382683
v 1.039364 0.216506 -0.430519
v 1.123905 0.125000 -0.465537
v 1.207407 0.000000 -0.323524
v 1.175055 -0.125000 -0.314855
v 1.086667 -0.216506 -0.291171
v 0.965926 -0.250000 -0.258819
v 0.845185 -0.216506 -0.226467
v 0.756797 -0.125000 -0.202783
v 0.724444 -0.000000 -0.194114
v 0.756797 0.125000 -0.202783
v 0.845185 0.216506 -0.226467
v 0.965926 0.250000 -0.258819
v 1.086667 0.216506 -0.291171
v 1.175055 0.125000 -0.314855
v 1.239306 0.000000 -0.163158
v 1.206099 -0.125000 -0.158786
v 1.115375 -0.216506 -0.146842
v 0.991445 -0.250000 -0.130526
v 0.867514 -0.216506 -0.114211
v 0.776791 -0.125000 -0.102267
v 0.743584 -0.000000 -0.097895
v 0.776791 0.125000 -0.102267
v 0.867514 0.216506 -0.114211
v 0.991445 0.250000 -0.130526
v 1.115375 0.216506 -0.146842
v 1.206099 0.125000 -0.158786
v 1.250000 0.000000 -0.000000
v 1.216506 -0.125000 -0.000000
v 1.125000 -0.216506 -0.000000
v 1.000000 -0.250000 -0.000000
v 0.875000 -0.216506 -0.000000
v 0.783494 -0.125000 -0.000000
v 0.750000 -0.000000 -0.000000
v 0.783494 0.125000 -0.000000
v 0.875000 0.216506 -0.000000
v 1.000000 0.250000 -0.000000
v 1.125000 0.216506 -0.000000
v 1.216506 0.125000 -0.000000
v 1.239306 0.000000 0.163158
v 1.206099 -0.125000 0.158786
v 1.115375 -0.216506 0.146842
v 0.991445 -0.250000 0.130526
v 0.867514 -0.216506 0.114211
v 0.776791 -0.125000 0.102267
v 0.743584 -0.000000 0.097895
v 0.776791 0.125000 0.102267
v 0.867514 0.216506 0.114211
v 0.991445 0.250000 0.130526
v 1.115375 0.216506 0.146842
v 1.206099 0.125000 0.158786
v 1.207407 0.000000 0.323524
v 1.175055 -0.125000 0.314855
v 1.086667 -0.216506 0.291171
v 0.965926 -0.250000 0.258819
v 0.845185 -0.216506 0.226467
v 0.756797 -0.125000 0.202783
v 0.724444 -0.000000 0.194114
v 0.756797 0.125000 0.202783
v 0.845185 0.216506 0.226467
v 0.965926 0.250000 0.258819
v 1.086667 0.216506 0.291171
v 1.175055 0.125000 0.314855
v 1.154850 0.000000 0.478354
v 1.123906 -0.125000 0.465536
v 1.039365 -0.216506 0.430518
v 0.923880 -0.250000 0.382683
v 0.808395 -0.216506 0.334848
v 0.723854 -0.125000 0.299830
v 0.692910 -0.000000 0.287012
v 0.723854 0.125000 0.299830
v 0.808395 0.216506 0.334848
v 0.923880 0.250000 0.382683
v 1.039365 0.216506 0.430518
v 1.123906 0.125000 0.465536
v 1.082532 0.000000 0.625000
v 1.053526 -0.125000 0.608253
v 0.974279 -0.216506 0.562500
v 0.866026 -0.250000 0.500000
v 0.757772 -0.216506 0.437500
v 0.678525 -0.125000 0.391747
v 0.649519 -0.000000 0.375000
v 0.678525 0.125000 0.391747
v 0.757772 0.216506 0.437500
v 0.866026 0.250000 0.500000
v 0.974279 0.216506 0.562500
v 1.053526 0.125000 0.608253
v 0.991692 0.000000 0.760952
v 0.965119 -0.125000 0.740562
v 0.892522 -0.216506 0.684857
v 0.793353 -0.250000 0.608761
v 0.694184 -0.216506 0.532666
v 0.621587 -0.125000 0.476961
v 0.595015 -0.000000 0.456571
v 0.621587 0.125000 0.476961
v 0.694184 0.216506 0.532666
v 0.793353 0.250000 0.608761
v 0.892522 0.216506 0.684857
v 0.965119 0.125000 0.740562
v 0.883884 0.000000 0.883883
v 0.860200 -0.125000 0.860200
v 0.795495 -0.216506 0.795495
v 0.707107 -0.250000 0.707107
v 0.618719 -0.216506 0.618718
v 0.554014 -0.125000 0.554013
v 0.530330 -0.000000 0.530330
v 0.554014 0.125000 0.554013
v 0.618719 0.216506 0.618718
v 0.707107 0.250000 0.707107
v 0.795495 0.216506 0.795495
v 0.860200 0.125000 0.860200
v 0.760952 0.000000 0.991691
v 0.740563 -0.125000 0.965119
v 0.684857 -0.216506 0.892522
v 0.608762 -0.250000 0.793353
v 0.532667 -0.216506 0.694184
v 0.476961 -0.125000 0.621587
v 0.456571 -0.000000 0.595015
v 0.476961 0.125000 0.621587
v 0.532667 0.216506 0.694184
v 0.608762 0.250000 0.793353
v 0.684857 0.216506 0.892522
v 0.740563 0.125000 0.965119
v 0.625000 0.000000 1.082532
v 0.608253 -0.125000 1.053526
v 0.562500 -0.216506 0.974279
v 0.500000 -0.250000 0.866026
v 0.437500 -0.216506 0.757772
v 0.391747 -0.125000 0.678525
v 0.375000 -0.000000 0.649519
v 0.391747 0.125000 0.678525
v 0.437500 0.216506 0.757772
v 0.500000 0.250000 0.866026
v 0.562500 0.216506 0.974279
v 0.608253 0.125000 1.053526
v 0.478354 0.000000 1.154849
v 0.465537 -0.125000 1.123905
v 0.430519 -0.216506 1.039364
v 0.382684 -0.250000 0.923880
v 0.334848 -0.216506 0.808395
v 0.299830 -0.125000 0.723854
v 0.287013 -0.000000 0.692910
v 0.299830 0.125000 0.723854
v 0.334848 0.216506 0.808395
v 0.382684 0.250000 0.923880
v 0.430519 0.216506 1.039364
v 0.465537 0.125000 1.123905
v 0.323524 0.000000 1.207407
v 0.314855 -0.125000 1.175055
v 0.291172 -0.216506 1.086666
v 0.258819 -0.250000 0.965926
v 0.226467 -0.216506 0.845185
v 0.202783 -0.125000 0.756797
v 0.194115 -0.000000 0.724444
v 0.202783 0.125000 0.756797
v 0.226467 0.216506 0.845185
v 0.258819 0.250000 0.965926
v 0.291172 0.216506 1.086666
v 0.314855 0.125000 1.175055
v 0.163158 0.000000 1.239306
v 0.158787 -0.125000 1.206099
v 0.146843 -0.216506 1.115375
v 0.130527 -0.250000 0.991445
v 0.114211 -0.216506 0.867514
v 0.102267 -0.125000 0.776791
v 0.097895 -0.000000 0.743584
v 0.102267 0.125000 0.776791
v 0.114211 0.216506 0.867514
v 0.130527 0.250000 0.991445
v 0.146843 0.216506 1.115375
v 0.158787 0.125000 1.206099
v -0.000000 0.000000 1.250000
v -0.000000 -0.125000 1.216506
v -0.000000 -0.216506 1.125000
v -0.000000 -0.250000 1.000000
v -0.000000 -0.216506 0.875000
v -0.000000 -0.125000 0.783494
v -0.000000 -0.000000 0.750000
v -0.000000 0.125000 0.783494
v -0.000000 0.216506 0.875000
v -0.000000 0.250000 1.000000
v -0.000000 0.216506 1.125000
v -0.000000 0.125000 1.216506
v -0.163158 0.000000 1.239306
v -0.158786 -0.125000 1.206099
v -0.146842 -0.216506 1.115376
v -0.130526 -0.250000 0.991445
v -0.114210 -0.216506 0.867514
v -0.102266 -0.125000 0.776791
v -0.097895 -0.000000 0.743584
v -0.102266 0.125000 0.776791
v -0.114210 0.216506 0.867514
v -0.130526 0.250000 0.991445
v -0.146842 0.216506 1.115376
v -0.158786 0.125000 1.206099
v -0.323523 0.000000 1.207407
v -0.314854 -0.125000 1.175055
v -0.291171 -0.216506 1.086667
v -0.258819 -0.250000 0.965926
v -0.226466 -0.216506 0.845185
v -0.202783 -0.125000 0.756797
v -0.194114 -0.000000 0.724444
v -0.202783 0.125000 0.756797
v -0.226466 0.216506 0.845185
v -0.258819 0.250000 0.965926
v -0.291171 0.216506 1.086667
v -0.314854 0.125000 1.175055
v -0.478355 0.000000 1.154849
v -0.465537 -0.125000 1.123905
v -0.430519 -0.216506 1.039364
v -0.382684 -0.250000 0.923879
v -0.334848 -0.216506 0.808394
v -0.299830 -0.125000 0.723854
v -0.287013 -0.000000 0.692910
v -0.299830 0.125000 0.723854
v -0.334848 0.216506 0.808394
v -0.382684 0.250000 0.923879
v -0.430519 0.216506 1.039364
v -0.465537 0.125000 1.123905
v -0.625000 0.000000 1.082532
v -0.608253 -0.125000 1.053525
v -0.562500 -0.216506 0.974279
v -0.500000 -0.250000 0.866025
v -0.437500 -0.216506 0.757772
v -0.391747 -0.125000 0.678525
v -0.375000 -0.000000 0.649519
v -0.391747 0.125000 0.678525
v -0.437500 0.216506 0.757772
v -0.500000 0.250000 0.866025
v -0.562500 0.216506 0.974279
v -0.608253 0.125000 1.053525
v -0.760952 0.000000 0.991692
v -0.740562 -0.125000 0.965120
v -0.684856 -0.216506 0.892523
v -0.608761 -0.250000 0.793353
v -0.532666 -0.216506 0.694184
v -0.476961 -0.125000 0.621587
v -0.456571 -0.000000 0.595015
v -0.476961 0.125000 0.621587
v -0.532666 0.216506 0.694184
v -0.608761 0.250000 0.793353
v -0.684856 0.216506 0.892523
v -0.740562 0.125000 0.965120
v -0.883883 0.000000 0.883884
v -0.860199 -0.125000 0.860200
v -0.795495 -0.216506 0.795496
v -0.707106 -0.250000 0.707107
v -0.618718 -0.216506 0.618719
v -0.554013 -0.125000 0.554014
v -0.530330 -0.000000 0.530330
v -0.554013 0.125000 0.554014
v -0.618718 0.216506 0.618719
v -0.707106 0.250000 0.707107
v -0.795495 0.216506 0.795496
v -0.860199 0.125000 0.860200
v -0.991692 0.000000 0.760952
v -0.965119 -0.125000 0.740562
v -0.892523 -0.216506 0.684856
v -0.793353 -0.250000 0.608761
v -0.694184 -0.216506 0.532666
v -0.621587 -0.125000 0.476961
v -0.595015 -0.000000 0.456571
v -0.621587 0.125000 0.476961
v -0.694184 0.216506 0.532666
v -0.793353 0.250000 0.608761
v -0.892523 0.216506 0.684856
v -0.965119 0.125000 0.740562
v -1.082532 0.000000 0.625000
v -1.053525 -0.125000 0.608253
v -0.974279 -0.216506 0.562500
v -0.866025 -0.250000 0.500000
v -0.757772 -0.216506 0.437500
v -0.678525 -0.125000 0.391747
v -0.649519 -0.000000 0.375000
v -0.678525 0.125000 0.391747
v -0.757772 0.216506 0.437500
v -0.866025 0.250000 0.500000
v -0.974279 0.216506 0.562500
v -1.053525 0.125000 0.608253
v -1.154849 0.000000 0.478355
v -1.123905 -0.125000 0.465537
v -1.039364 -0.216506 0.430519
v -0.923879 -0.250000 0.382684
v -0.808394 -0.216506 0.334848
v -0.723854 -0.125000 0.299830
v -0.692910 -0.000000 0.287013
v -0.723854 0.125000 0.299830
v -0.808394 0.216506 0.334848
v -0.923879 0.250000 0.382684
v -1.039364 0.216506 0.430519
v -1.123905 0.125000 0.465537
v -1.207407 0.000000 0.323523
v -1.175055 -0.125000 0.314855
v -1.086667 -0.216506 0.291171
v -0.965926 -0.250000 0.258819
v -0.845185 -0.216506 0.226466
v -0.756797 -0.125000 0.202783
v -0.724444 -0.000000 0.194114
v -0.756797 0.125000 0.202783
v -0.845185 0.216506 0.226466
v -0.965926 0.250000 0.258819
v -1.086667 0.216506 0.291171
v -1.175055 0.125000 0.314855
v -1.239306 0.000000 0.163158
v -1.206099 -0.125000 0.158786
v -1.115376 -0.216506 0.146842
v -0.991445 -0.250000 0.130526
v -0.867514 -0.216506 0.114210
v -0.776791 -0.125000 0.102266
v -0.743584 -0.000000 0.097895
v -0.776791 0.125000 0.102266
v -0.867514 0.216506 0.114210
v -0.991445 0.250000 0.130526
v -1.115376 0.216506 0.146842
v -1.206099 0.125000 0.158786
vt 0.520833 0.500000
vt 0.500000 0.583333
vt 0.500000 0.500000
vt 0.520833 0.666667
vt 0.500000 0.666667
vt 0.500000 0.750000
vt 0.520833 0.750000
vt 0.500000 0.833333
vt 0.520833 0.833333
vt 0.500000 0.916667
vt 0.520833 1.000000
vt 0.500000 1.000000
vt 0.520833 0.000000
vt 0.500000 0.083333
vt 0.500000 0.000000
vt 0.520833 0.083333
vt 0.500000 0.166667
vt 0.520833 0.166667
vt 0.500000 0.250000
vt 0.520833 0.250000
vt 0.500000 0.333333
vt 0.520833 0.333333
vt 0.500000 0.416667
vt 0.520833 0.416667
vt 0.541667 0.500000
vt 0.520833 0.583333
vt 0.541667 0.583333
vt 0.541667 0.666667
vt 0.541667 0.750000
vt 0.541667 0.916667
vt 0.520833 0.916667
vt 0.541667 0.000000
vt 0.541667 0.083333
vt 0.541667 0.250000
vt 0.541667 0.333333
vt 0.541667 0.416667
vt 0.562500 0.583333
vt 0.562500 0.666667
vt 0.562500 0.833333
vt 0.541667 0.833333
vt 0.562500 0.916667
vt 0.562500 1.000000
vt 0.541667 1.000000
vt 0.562500 0.000000
vt 0.562500 0.083333
vt 0.541667 0.166667
vt 0.562500 0.250000
vt 0.562500 0.333333
vt 0.562500 0.416667
vt 0.562500 0.500000
vt 0.583333 0.583333
vt 0.583333 0.666667
vt 0.583333 0.750000
vt 0.562500 0.750000
vt 0.583333 0.916667
vt 0.583333 0.000000
vt 0.583333 0.083333
vt 0.562500 0.166667
vt 0.583333 0.250000
vt 0.583333 0.333333
vt 0.583333 0.416667
vt 0.604167 0.500000
vt 0.583333 0.500000
vt 0.604167 0.666667
vt 0.604167 0.750000
vt 0.583333 0.833333
vt 0.604167 0.916667
vt 0.583333 1.000000
vt 0.604167 0.000000
vt 0.604167 0.083333
vt 0.583333 0.166667
vt 0.604167 0.166667
vt 0.604167 0.250000
vt 0.604167 0.333333
vt 0.625000 0.500000
vt 0.604167 0.583333
vt 0.625000 0.583333
vt 0.625000 0.666667
vt 0.625000 0.750000
vt 0.604167 0.833333
vt 0.625000 0.833333
vt 0.625000 0.916667
vt 0.604167 1.000000
vt 0.625000 0.083333
vt 0.625000 0.166667
vt 0.625000 0.250000
vt 0.625000 0.416667
vt 0.604167 0.416667
vt 0.645833 0.500000
vt 0.645833 0.666667
vt 0.645833 0.750000
vt 0.645833 0.916667
vt 0.625000 1.000000
vt 0.645833 0.000000
vt 0.625000 0.000000
vt 0.645833 0.083333
vt 0.645833 0.250000
vt 0.645833 0.333333
vt 0.625000 0.333333
vt 0.645833 0.416667
vt 0.666667 0.500000
vt 0.645833 0.583333
vt 0.666667 0.666667
vt 0.666667 0.750000
vt 0.645833 0.833333
vt 0.666667 0.916667
vt 0.645833 1.000000
vt 0.666667 0.000000
vt 0.666667 0.083333
vt 0.645833 0.166667
vt 0.666667 0.166667
vt 0.666667 0.250000
vt 0.666667 0.333333
vt 0.666667 0.416667
vt 0.687500 0.583333
vt 0.666667 0.583333
vt 0.687500 0.666667
vt 0.687500 0.750000
vt 0.666667 0.833333
vt 0.687500 0.833333
vt 0.687500 0.916667
vt 0.666667 1.000000
vt 0.687500 0.000000
vt 0.687500 0.083333
vt 0.687500 0.250000
vt 0.687500 0.333333
vt 0.687500 0.416667
vt 0.708333 0.500000
vt 0.687500 0.500000
vt 0.708333 0.583333
vt 0.708333 0.666667
vt 0.708333 0.750000
vt 0.708333 0.916667
vt 0.687500 1.000000
vt 0.708333 0.000000
vt 0.708333 0.083333
vt 0.687500 0.166667
vt 0.708333 0.166667
vt 0.708333 0.250000
vt 0.708333 0.333333
vt 0.708333 0.416667
vt 0.729167 0.500000
vt 0.729167 0.583333
vt 0.729167 0.750000
vt 0.708333 0.833333
vt 0.729167 0.833333
vt 0.729167 0.916667
vt 0.708333 1.000000
vt 0.729167 0.083333
vt 0.729167 0.250000
vt 0.729167 0.333333
vt 0.729167 0.416667
vt 0.750000 0.500000
vt 0.750000 0.583333
vt 0.729167 0.666667
vt 0.750000 0.666667
vt 0.750000 0.833333
vt 0.750000 0.916667
vt 0.729167 1.000000
vt 0.750000 0.000000
vt 0.729167 0.000000
vt 0.750000 0.083333
vt 0.729167 0.166667
vt 0.750000 0.166667
vt 0.750000 0.250000
vt 0.750000 0.333333
vt 0.770833 0.500000
vt 0.770833 0.583333
vt 0.770833 0.666667
vt 0.750000 0.750000
vt 0.770833 0.750000
vt 0.770833 0.833333
vt 0.770833 0.916667
vt 0.750000 1.000000
vt 0.770833 0.083333
vt 0.770833 0.250000
vt 0.770833 0.333333
vt 0.770833 0.416667
vt 0.750000 0.416667
vt 0.791667 0.500000
vt 0.791667 0.666667
vt 0.791667 0.750000
vt 0.791667 0.833333
vt 0.791667 0.916667
vt 0.770833 1.000000
vt 0.791667 0.000000
vt 0.770833 0.000000
vt 0.791667 0.083333
vt 0.770833 0.166667
vt 0.791667 0.166667
vt 0.791667 0.250000
vt 0.791667 0.333333
vt 0.791667 0.416667
vt 0.812500 0.500000
vt 0.791667 0.583333
vt 0.812500 0.583333
vt 0.812500 0.666667
vt 0.812500 0.833333
vt 0.812500 0.916667
vt 0.791667 1.000000
vt 0.812500 0.000000
vt 0.812500 0.083333
vt 0.812500 0.250000
vt 0.812500 0.416667
vt 0.833333 0.500000
vt 0.833333 0.666667
vt 0.812500 0.750000
vt 0.833333 0.750000
vt 0.833333 0.833333
vt 0.833333 0.916667
vt 0.812500 1.000000
vt 0.833333 0.000000
vt 0.833333 0.083333
vt 0.812500 0.166667
vt 0.833333 0.166667
vt 0.833333 0.250000
vt 0.812500 0.333333
vt 0.833333 0.333333
vt 0.833333 0.416667
vt 0.854167 0.500000
vt 0.833333 0.583333
vt 0.854167 0.583333
vt 0.854167 0.666667
vt 0.854167 0.750000
vt 0.854167 0.833333
vt 0.854167 1.000000
vt 0.833333 1.000000
vt 0.854167 0.000000
vt 0.854167 0.166667
vt 0.854167 0.250000
vt 0.854167 0.333333
vt 0.854167 0.416667
vt 0.875000 0.500000
vt 0.875000 0.583333
vt 0.875000 0.750000
vt 0.875000 0.833333
vt 0.854167 0.916667
vt 0.875000 0.916667
vt 0.875000 0.000000
vt 0.854167 0.083333
vt 0.875000 0.166667
vt 0.875000 0.250000
vt 0.875000 0.333333
vt 0.875000 0.416667
vt 0.895833 0.500000
vt 0.895833 0.583333
vt 0.875000 0.666667
vt 0.895833 0.666667
vt 0.895833 0.833333
vt 0.895833 0.916667
vt 0.875000 1.000000
vt 0.895833 0.000000
vt 0.875000 0.083333
vt 0.895833 0.166667
vt 0.895833 0.250000
vt 0.895833 0.416667
vt 0.916667 0.583333
vt 0.916667 0.750000
vt 0.895833 0.750000
vt 0.916667 0.833333
vt 0.916667 0.916667
vt 0.895833 1.000000
vt 0.916667 0.000000
vt 0.895833 0.083333
vt 0.916667 0.083333
vt 0.916667 0.250000
vt 0.895833 0.333333
vt 0.916667 0.333333
vt 0.916667 0.416667
vt 0.937500 0.500000
vt 0.916667 0.500000
vt 0.937500 0.583333
vt 0.916667 0.666667
vt 0.937500 0.666667
vt 0.937500 0.833333
vt 0.937500 0.916667
vt 0.916667 1.000000
vt 0.937500 0.083333
vt 0.916667 0.166667
vt 0.937500 0.166667
vt 0.937500 0.250000
vt 0.937500 0.416667
vt 0.958333 0.583333
vt 0.958333 0.666667
vt 0.937500 0.750000
vt 0.958333 0.833333
vt 0.958333 0.916667
vt 0.937500 1.000000
vt 0.958333 0.000000
vt 0.937500 0.000000
vt 0.958333 0.083333
vt 0.958333 0.166667
vt 0.958333 0.333333
vt 0.937500 0.333333
vt 0.958333 0.416667
vt 0.979167 0.500000
vt 0.958333 0.500000
vt 0.979167 0.583333
vt 0.979167 0.666667
vt 0.958333 0.750000
vt 0.979167 0.750000
vt 0.979167 0.833333
vt 0.979167 0.916667
vt 0.958333 1.000000
vt 0.979167 0.000000
vt 0.979167 0.166667
vt 0.979167 0.250000
vt 0.958333 0.250000
vt 0.979167 0.333333
vt 0.979167 0.416667
vt 1.000000 0.583333
vt 1.000000 0.666667
vt 1.000000 0.750000
vt 1.000000 0.833333
vt 1.000000 0.916667
vt 0.979167 1.000000
vt 1.000000 0.000000
vt 0.979167 0.083333
vt 1.000000 0.166667
vt 1.000000 0.250000
vt 1.000000 0.333333
vt 1.000000 0.416667
vt 0.020833 0.500000
vt 0.000000 0.583333
vt 0.000000 0.500000
vt 0.020833 0.583333
vt 0.000000 0.666667
vt 0.020833 0.666667
vt 0.000000 0.750000
vt 0.020833 0.750000
vt 0.000000 0.833333
vt 0.020833 0.833333
vt 0.000000 0.916667
vt 0.020833 0.916667
vt 0.000000 1.000000
vt 0.000000 0.000000
vt 0.020833 0.083333
vt 0.000000 0.083333
vt 0.000000 0.166667
vt 0.020833 0.250000
vt 0.000000 0.250000
vt 0.020833 0.333333
vt 0.000000 0.333333
vt 0.020833 0.416667
vt 0.000000 0.416667
vt 0.041667 0.583333
vt 0.041667 0.666667
vt 0.041667 0.750000
vt 0.041667 0.833333
vt 0.041667 0.916667
vt 0.020833 1.000000
vt 0.041667 0.000000
vt 0.020833 0.000000
vt 0.041667 0.083333
vt 0.020833 0.166667
vt 0.041667 0.166667
vt 0.041667 0.250000
vt 0.041667 0.333333
vt 0.041667 0.500000
vt 0.062500 0.500000
vt 0.062500 0.583333
vt 0.062500 0.750000
vt 0.062500 0.833333
vt 0.062500 0.916667
vt 0.041667 1.000000
vt 0.062500 0.000000
vt 0.062500 0.166667
vt 0.062500 0.250000
vt 0.062500 0.416667
vt 0.041667 0.416667
vt 0.083333 0.500000
vt 0.083333 0.583333
vt 0.062500 0.666667
vt 0.083333 0.666667
vt 0.083333 0.750000
vt 0.083333 0.833333
vt 0.083333 1.000000
vt 0.062500 1.000000
vt 0.083333 0.000000
vt 0.062500 0.083333
vt 0.083333 0.083333
vt 0.083333 0.166667
vt 0.083333 0.333333
vt 0.062500 0.333333
vt 0.083333 0.416667
vt 0.104167 0.500000
vt 0.104167 0.583333
vt 0.104167 0.666667
vt 0.104167 0.833333
vt 0.083333 0.916667
vt 0.104167 0.916667
vt 0.104167 0.000000
vt 0.104167 0.166667
vt 0.083333 0.250000
vt 0.104167 0.250000
vt 0.104167 0.416667
vt 0.125000 0.500000
vt 0.125000 0.666667
vt 0.104167 0.750000
vt 0.125000 0.750000
vt 0.125000 0.833333
vt 0.125000 0.916667
vt 0.104167 1.000000
vt 0.125000 0.000000
vt 0.104167 0.083333
vt 0.125000 0.083333
vt 0.125000 0.250000
vt 0.104167 0.333333
vt 0.125000 0.333333
vt 0.125000 0.416667
vt 0.145833 0.583333
vt 0.125000 0.583333
vt 0.145833 0.666667
vt 0.145833 0.833333
vt 0.145833 0.916667
vt 0.125000 1.000000
vt 0.145833 0.000000
vt 0.145833 0.083333
vt 0.125000 0.166667
vt 0.145833 0.166667
vt 0.145833 0.250000
vt 0.145833 0.333333
vt 0.145833 0.416667
vt 0.145833 0.500000
vt 0.166667 0.583333
vt 0.166667 0.666667
vt 0.145833 0.750000
vt 0.166667 0.750000
vt 0.166667 0.916667
vt 0.145833 1.000000
vt 0.166667 0.000000
vt 0.166667 0.083333
vt 0.166667 0.166667
vt 0.166667 0.333333
vt 0.166667 0.416667
vt 0.187500 0.500000
vt 0.166667 0.500000
vt 0.187500 0.583333
vt 0.187500 0.666667
vt 0.187500 0.750000
vt 0.166667 0.833333
vt 0.187500 0.833333
vt 0.187500 0.916667
vt 0.166667 1.000000
vt 0.187500 0.000000
vt 0.187500 0.083333
vt 0.187500 0.250000
vt 0.166667 0.250000
vt 0.187500 0.416667
vt 0.208333 0.500000
vt 0.208333 0.583333
vt 0.208333 0.666667
vt 0.208333 0.750000
vt 0.208333 0.916667
vt 0.187500 1.000000
vt 0.208333 0.000000
vt 0.208333 0.083333
vt 0.187500 0.166667
vt 0.208333 0.166667
vt 0.208333 0.250000
vt 0.187500 0.333333
vt 0.208333 0.416667
vt 0.229167 0.500000
vt 0.229167 0.666667
vt 0.229167 0.750000
vt 0.208333 0.833333
vt 0.229167 0.916667
vt 0.208333 1.000000
vt 0.229167 0.000000
vt 0.229167 0.083333
vt 0.229167 0.250000
vt 0.208333 0.333333
vt 0.229167 0.333333
vt 0.229167 0.416667
vt 0.250000 0.500000
vt 0.229167 0.583333
vt 0.250000 0.583333
vt 0.250000 0.750000
vt 0.250000 0.833333
vt 0.229167 0.833333
vt 0.250000 1.000000
vt 0.229167 1.000000
vt 0.250000 0.000000
vt 0.250000 0.083333
vt 0.229167 0.166667
vt 0.250000 0.166667
vt 0.250000 0.250000
vt 0.250000 0.333333
vt 0.250000 0.416667
vt 0.270833 0.583333
vt 0.250000 0.666667
vt 0.270833 0.666667
vt 0.270833 0.750000
vt 0.270833 0.833333
vt 0.250000 0.916667
vt 0.270833 0.916667
vt 0.270833 0.000000
vt 0.270833 0.166667
vt 0.270833 0.250000
vt 0.270833 0.333333
vt 0.270833 0.416667
vt 0.291667 0.500000
vt 0.270833 0.500000
vt 0.291667 0.583333
vt 0.291667 0.666667
vt 0.291667 0.750000
vt 0.291667 0.833333
vt 0.291667 1.000000
vt 0.270833 1.000000
vt 0.291667 0.000000
vt 0.270833 0.083333
vt 0.291667 0.083333
vt 0.291667 0.250000
vt 0.291667 0.333333
vt 0.291667 0.416667
vt 0.312500 0.500000
vt 0.312500 0.583333
vt 0.312500 0.666667
vt 0.312500 0.750000
vt 0.312500 0.833333
vt 0.291667 0.916667
vt 0.312500 0.916667
vt 0.312500 0.000000
vt 0.312500 0.083333
vt 0.291667 0.166667
vt 0.312500 0.166667
vt 0.312500 0.333333
vt 0.312500 0.416667
vt 0.333333 0.500000
vt 0.333333 0.583333
vt 0.333333 0.750000
vt 0.333333 0.833333
vt 0.333333 0.916667
vt 0.312500 1.000000
vt 0.333333 0.000000
vt 0.333333 0.083333
vt 0.333333 0.166667
vt 0.312500 0.250000
vt 0.333333 0.250000
vt 0.333333 0.333333
vt 0.354167 0.583333
vt 0.333333 0.666667
vt 0.354167 0.666667
vt 0.354167 0.750000
vt 0.354167 0.833333
vt 0.354167 0.916667
vt 0.333333 1.000000
vt 0.354167 0.000000
vt 0.354167 0.083333
vt 0.354167 0.166667
vt 0.354167 0.250000
vt 0.354167 0.416667
vt 0.333333 0.416667
vt 0.354167 0.500000
vt 0.375000 0.583333
vt 0.375000 0.750000
vt 0.375000 0.833333
vt 0.375000 0.916667
vt 0.354167 1.000000
vt 0.375000 0.000000
vt 0.375000 0.083333
vt 0.375000 0.166667
vt 0.375000 0.250000
vt 0.354167 0.333333
vt 0.375000 0.416667
vt 0.375000 0.500000
vt 0.395833 0.583333
vt 0.375000 0.666667
vt 0.395833 0.750000
vt 0.395833 0.833333
vt 0.395833 0.916667
vt 0.375000 1.000000
vt 0.395833 0.000000
vt 0.395833 0.166667
vt 0.395833 0.250000
vt 0.375000 0.333333
vt 0.395833 0.333333
vt 0.395833 0.416667
vt 0.416667 0.500000
vt 0.395833 0.500000
vt 0.416667 0.583333
vt 0.395833 0.666667
vt 0.416667 0.666667
vt 0.416667 0.750000
vt 0.416667 0.833333
vt 0.416667 0.916667
vt 0.395833 1.000000
vt 0.416667 0.000000
vt 0.395833 0.083333
vt 0.416667 0.166667
vt 0.416667 0.250000
vt 0.416667 0.416667
vt 0.437500 0.500000
vt 0.437500 0.583333
vt 0.437500 0.750000
vt 0.437500 0.833333
vt 0.437500 0.916667
vt 0.416667 1.000000
vt 0.437500 0.000000
vt 0.416667 0.083333
vt 0.437500 0.083333
vt 0.437500 0.166667
vt 0.437500 0.250000
vt 0.416667 0.333333
vt 0.437500 0.333333
vt 0.437500 0.416667
vt 0.458333 0.500000
vt 0.458333 0.583333
vt 0.437500 0.666667
vt 0.458333 0.666667
vt 0.458333 0.750000
vt 0.458333 0.833333
vt 0.458333 0.916667
vt 0.437500 1.000000
vt 0.458333 0.000000
vt 0.458333 0.166667
vt 0.458333 0.250000
vt 0.458333 0.333333
vt 0.458333 0.416667
vt 0.479167 0.583333
vt 0.479167 0.666667
vt 0.479167 0.750000
vt 0.479167 0.833333
vt 0.479167 1.000000
vt 0.458333 1.000000
vt 0.479167 0.000000
vt 0.458333 0.083333
vt 0.479167 0.083333
vt 0.479167 0.250000
vt 0.479167 0.333333
vt 0.479167 0.416667
vt 0.479167 0.500000
vt 0.479167 0.916667
vt 0.479167 0.166667
vt 1.000000 0.500000
vt 1.000000 1.000000
vt 1.000000 0.083333
vn -0.9640 -0.2583 -0.0632
vn -0.7063 -0.7063 -0.0463
vn -0.2588 -0.9658 -0.0170
vn 0.2588 -0.9658 0.0170
vn 0.7063 -0.7063 0.0463
vn 0.9640 -0.2583 0.0632
vn 0.9640 0.2583 0.0632
vn 0.7063 0.7063 0.0463
vn 0.2588 0.9658 0.0170
vn -0.2588 0.9658 -0.0170
vn -0.7063 0.7063 -0.0463
vn -0.9640 0.2583 -0.0632
vn -0.9475 -0.2583 -0.1885
vn -0.6943 -0.7063 -0.1381
vn -0.2544 -0.9658 -0.0506
vn 0.2544 -0.9658 0.0506
vn 0.6943 -0.7063 0.1381
vn 0.9475 -0.2583 0.1885
vn 0.9475 0.2583 0.1885
vn 0.6943 0.7063 0.1381
vn 0.2544 0.9658 0.0506
vn -0.2544 0.9658 -0.0506
vn -0.6943 0.7063 -0.1381
vn -0.9475 0.2583 -0.1885
vn -0.9148 -0.2583 -0.3105
vn -0.6703 -0.7063 -0.2275
vn -0.2456 -0.9658 -0.0834
vn 0.2456 -0.9658 0.0834
vn 0.6703 -0.7063 0.2275
vn 0.9148 -0.2583 0.3105
vn 0.9148 0.2583 0.3105
vn 0.6703 0.7063 0.2275
vn 0.2456 0.9658 0.0834
vn -0.2456 0.9658 -0.0834
vn -0.6703 0.7063 -0.2275
vn -0.9148 0.2583 -0.3105
vn -0.8664 -0.2583 -0.4273
vn -0.6349 -0.7063 -0.3131
vn -0.2326 -0.9658 -0.1147
vn 0.2326 -0.9658 0.1147
vn 0.6349 -0.7063 0.3131
vn 0.8664 -0.2583 0.4273
vn 0.8664 0.2583 0.4273
vn 0.6349 0.7063 0.3131
vn 0.2326 0.9658 0.1147
vn -0.2326 0.9658 -0.1147
vn -0.6349 0.7063 -0.3131
vn -0.8664 0.2583 -0.4273
vn -0.8033 -0.2583 -0.5367
vn -0.5886 -0.7063 -0.3933
vn -0.2156 -0.9658 -0.1441
vn 0.2156 -0.9658 0.1441
vn 0.5886 -0.7063 0.3933
vn 0.8033 -0.2583 0.5367
vn 0.8033 0.2583 0.5367
vn 0.5886 0.7063 0.3933
vn 0.2156 0.9658 0.1441
vn -0.2156 0.9658 -0.1441
vn -0.5886 0.7063 -0.3933
vn -0.8033 0.2583 -0.5367
vn -0.7263 -0.2583 -0.6370
vn -0.5322 -0.7063 -0.4667
vn -0.1950 -0.9658 -0.1710
vn 0.1950 -0.9658 0.1710
vn 0.5322 -0.7063 0.4667
vn 0.7263 -0.2583 0.6370
vn 0.7263 0.2583 0.6370
vn 0.5322 0.7063 0.4667
vn 0.1950 0.9658 0.1710
vn -0.1950 0.9658 -0.1710
vn -0.5322 0.7063 -0.4667
vn -0.7263 0.2583 -0.6370
vn -0.6370 -0.2583 -0.7263
vn -0.4667 -0.7063 -0.5322
vn -0.1710 -0.9658 -0.1950
vn 0.1710 -0.9658 0.1950
vn 0.4667 -0.7063 0.5322
vn 0.6370 -0.2583 0.7263
vn 0.6370 0.2583 0.7263
vn 0.4667 0.7063 0.5322
vn 0.1710 0.9658 0.1950
vn -0.1710 0.9658 -0.1950
vn -0.4667 0.7063 -0.5322
vn -0.6370 0.2583 -0.7263
vn -0.5367 -0.2583 -0.8033
vn -0.3933 -0.7063 -0.5886
vn -0.1441 -0.9658 -0.2156
vn 0.1441 -0.9658 0.2156
vn 0.3933 -0.7063 0.5886
vn 0.5367 -0.2583 0.8033
vn 0.5367 0.2583 0.8033
vn 0.3933 0.7063 0.5886
vn 0.1441 0.9658 0.2156
vn -0.1441 0.9658 -0.2156
vn -0.3933 0.7063 -0.5886
vn -0.5367 0.2583 -0.8033
vn -0.4273 -0.2583 -0.8664
vn -0.3131 -0.7063 -0.6349
vn -0.1147 -0.9658 -0.2326
vn 0.1147 -0.9658 0.2326
vn 0.3131 -0.7063 0.6349
vn 0.4273 -0.2583 0.8664
vn 0.4273 0.2583 0.8664
vn 0.3131 0.7063 0.6349
vn 0.1147 0.9658 0.2326
vn -0.1147 0.9658 -0.2326
vn -0.3131 0.7063 -0.6349
vn -0.4273 0.2583 -0.8664
vn -0.3105 -0.2583 -0.9148
vn -0.2275 -0.7063 -0.6703
vn -0.0834 -0.9658 -0.2456
vn 0.0834 -0.9658 0.2456
vn 0.2275 -0.7063 0.6703
vn 0.3105 -0.2583 0.9148
vn 0.3105 0.2583 0.9148
vn 0.2275 0.7063 0.6703
vn 0.0834 0.9658 0.2456
vn -0.0834 0.9658 -0.2456
vn -0.2275 0.7063 -0.6703
vn -0.3105 0.2583 -0.9148
vn -0.1885 -0.2583 -0.9475
vn -0.1381 -0.7063 -0.6943
vn -0.0506 -0.9658 -0.2544
vn 0.0506 -0.9658 0.2544
vn 0.1381 -0.7063 0.6943
vn 0.1885 -0.2583 0.9475
vn 0.1885 0.2583 0.9475
vn 0.1381 0.7063 0.6943
vn 0.0506 0.9658 0.2544
vn -0.0506 0.9658 -0.2544
vn -0.1381 0.7063 -0.6943
vn -0.1885 0.2583 -0.9475
vn -0.0632 -0.2583 -0.9640
vn -0.0463 -0.7063 -0.7063
vn -0.0170 -0.9658 -0.2588
vn 0.0170 -0.9658 0.2588
vn 0.0463 -0.7063 0.7063
vn 0.0632 -0.2583 0.9640
vn 0.0632 0.2583 0.9640
vn 0.0463 0.7063 0.7063
vn 0.0170 0.9658 0.2588
vn -0.0170 0.9658 -0.2588
vn -0.0463 0.7063 -0.7063
vn -0.0632 0.2583 -0.9640
vn 0.0632 -0.2583 -0.9640
vn 0.0463 -0.7063 -0.7063
vn 0.0170 -0.9658 -0.2588
vn -0.0170 -0.9658 0.2588
vn -0.0463 -0.7063 0.7063
vn -0.0632 -0.2583 0.9640
vn -0.0632 0.2583 0.9640
vn -0.0463 0.7063 0.7063
vn -0.0170 0.9658 0.2588
vn 0.0170 0.9658 -0.2588
vn 0.0463 0.7063 -0.7063
vn 0.0632 0.2583 -0.9640
vn 0.1885 -0.2583 -0.9475
vn 0.1381 -0.7063 -0.6943
vn 0.0506 -0.9658 -0.2544
vn -0.0506 -0.9658 0.2544
vn -0.1381 -0.7063 0.6943
vn -0.1885 -0.2583 0.9475
vn -0.1885 0.2583 0.9475
vn -0.1381 0.7063 0.6943
vn -0.0506 0.9658 0.2544
vn 0.0506 0.9658 -0.2544
vn 0.1381 0.7063 -0.6943
vn 0.1885 0.2583 -0.9475
vn 0.3105 -0.2583 -0.9148
vn 0.2275 -0.7063 -0.6703
vn 0.0834 -0.9658 -0.2456
vn -0.0834 -0.9658 0.2456
vn -0.2275 -0.7063 0.6703
vn -0.3105 -0.2583 0.9148
vn -0.3105 0.2583 0.9148
vn -0.2275 0.7063 0.6703
vn -0.0834 0.9658 0.2456
vn 0.0834 0.9658 -0.2456
vn 0.2275 0.7063 -0.6703
vn 0.3105 0.2583 -0.9148
vn 0.4273 -0.2583 -0.8664
vn 0.3131 -0.7063 -0.6349
vn 0.1147 -0.9658 -0.2326
vn -0.1147 -0.9658 0.2326
vn -0.3131 -0.7063 0.6349
vn -0.4273 -0.2583 0.8664
vn -0.4273 0.2583 0.8664
vn -0.3131 0.7063 0.6349
vn -0.1147 0.9658 0.2326
vn 0.1147 0.9658 -0.2326
vn 0.3131 0.7063 -0.6349
vn 0.4273 0.2583 -0.8664
vn 0.5367 -0.2583 -0.8033
vn 0.3933 -0.7063 -0.5886
vn 0.1441 -0.9658 -0.2156
vn -0.1441 -0.9658 0.2156
vn -0.3933 -0.7063 0.5886
vn -0.5367 -0.2583 0.8033
vn -0.5367 0.2583 0.8033
vn -0.3933 0.7063 0.5886
vn -0.1441 0.9658 0.2156
vn 0.1441 0.9658 -0.2156
vn 0.3933 0.7063 -0.5886
vn 0.5367 0.2583 -0.8033
vn 0.6370 -0.2583 -0.7263
vn 0.4667 -0.7063 -0.5322
vn 0.1710 -0.9658 -0.1950
vn -0.1710 -0.9658 0.1950
vn -0.4667 -0.7063 0.5322
vn -0.6370 -0.2583 0.7263
vn -0.6370 0.2583 0.7263
vn -0.4667 0.7063 0.5322
vn -0.1710 0.9658 0.1950
vn 0.1710 0.9658 -0.1950
vn 0.4667 0.7063 -0.5322
vn 0.6370 0.2583 -0.7263
vn 0.7263 -0.2583 -0.6370
vn 0.5322 -0.7063 -0.4667
vn 0.1950 -0.9658 -0.1710
vn -0.1950 -0.9658 0.1710
vn -0.5322 -0.7063 0.4667
vn -0.7263 -0.2583 0.6370
vn -0.7263 0.2583 0.6370
vn -0.5322 0.7063 0.4667
vn -0.1950 0.9658 0.1710
vn 0.1950 0.9658 -0.1710
vn 0.5322 0.7063 -0.4667
vn 0.7263 0.2583 -0.6370
vn 0.8033 -0.2583 -0.5367
vn 0.5886 -0.7063 -0.3933
vn 0.2156 -0.9658 -0.1441
vn -0.2156 -0.9658 0.1441
vn -0.5886 -0.7063 0.3933
vn -0.8033 -0.2583 0.5367
vn -0.8033 0.2583 0.5367
vn -0.5886 0.7063 0.3933
vn -0.2156 0.9658 0.1441
vn 0.2156 0.9658 -0.1441
vn 0.5886 0.7063 -0.3933
vn 0.8033 0.2583 -0.5367
vn 0.8664 -0.2583 -0.4273
vn 0.6349 -0.7063 -0.3131
vn 0.2326 -0.9658 -0.1147
vn -0.2326 -0.9658 0.1147
vn -0.6349 -0.7063 0.3131
vn -0.8664 -0.2583 0.4273
vn -0.8664 0.2583 0.4273
vn -0.6349 0.7063 0.3131
vn -0.2326 0.9658 0.1147
vn 0.2326 0.9658 -0.1147
vn 0.6349 0.7063 -0.3131
vn 0.8664 0.2583 -0.4273
vn 0.9148 -0.2583 -0.3105
vn 0.6703 -0.7063 -0.2275
vn 0.2456 -0.9658 -0.0834
vn -0.2456 -0.9658 0.0834
vn -0.6703 -0.7063 0.2275
vn -0.9148 -0.2583 0.3105
vn -0.9148 0.2583 0.3105
vn -0.6703 0.7063 0.2275
vn -0.2456 0.9658 0.0834
vn 0.2456 0.9658 -0.0834
vn 0.6703 0.7063 -0.2275
vn 0.9148 0.2583 -0.3105
vn 0.9475 -0.2583 -0.1885
vn 0.6943 -0.7063 -0.1381
vn 0.2544 -0.9658 -0.0506
vn -0.2544 -0.9658 0.0506
vn -0.6943 -0.7063 0.1381
vn -0.9475 -0.2583 0.1885
vn -0.9475 0.2583 0.1885
vn -0.6943 0.7063 0.1381
vn -0.2544 0.9658 0.0506
vn 0.2544 0.9658 -0.0506
vn 0.6943 0.7063 -0.1381
vn 0.9475 0.2583 -0.1885
vn 0.9640 -0.2583 -0.0632
vn 0.7063 -0.7063 -0.0463
vn 0.2588 -0.9658 -0.0170
vn -0.2588 -0.9658 0.0170
vn -0.7063 -0.7063 0.0463
vn -0.9640 -0.2583 0.0632
vn -0.9640 0.2583 0.0632
vn -0.7063 0.7063 0.0463
vn -0.2588 0.9658 0.0170
vn 0.2588 0.9658 -0.0170
vn 0.7063 0.7063 -0.0463
vn 0.9640 0.2583 -0.0632
usemtl None
s off
f 13/1/1 2/2/1 1/3/1
f 2/2/2 15/4/2 3/5/2
f 15/4/3 4/6/3 3/5/3
f 16/7/4 5/8/4 4/6/4
f 17/9/5 6/10/5 5/8/5
f 6/10/6 19/11/6 7/12/6
f 19/13/7 8/14/7 7/15/7
f 20/16/8 9/17/8 8/14/8
f 21/18/9 10/19/9 9/17/9
f 22/20/10 11/21/10 10/19/10
f 23/22/11 12/23/11 11/21/11
f 24/24/12 1/3/12 12/23/12
f 25/25/13 14/26/13 13/1/13
f 26/27/14 15/4/14 14/26/14
f 27/28/15 16/7/15 15/4/15
f 28/29/16 17/9/16 16/7/16
f 17/9/17 30/30/17 18/31/17
f 30/30/18 19/11/18 18/31/18
f 31/32/19 20/16/19 19/13/19
f 32/33/20 21/18/20 20/16/20
f 21/18/21 34/34/21 22/20/21
f 22/20/22 35/35/22 23/22/22
f 23/22/23 36/36/23 24/24/23
f 36/36/24 13/1/24 24/24/24
f 25/25/25 38/37/25 26/27/25
f 38/37/26 27/28/26 26/27/26
f 39/38/27 28/29/27 27/28/27
f 28/29/28 41/39/28 29/40/28
f 29/40/29 42/41/29 30/30/29
f 30/30/30 43/42/30 31/43/30
f 43/44/31 32/33/31 31/32/31
f 44/45/32 33/46/32 32/33/32
f 33/46/33 46/47/33 34/34/33
f 34/34/34 47/48/34 35/35/34
f 35/35/35 48/49/35 36/36/35
f 48/49/36 25/25/36 36/36/36
f 37/50/37 50/51/37 38/37/37
f 38/37/38 51/52/38 39/38/38
f 39/38/39 52/53/39 40/54/39
f 52/53/40 41/39/40 40/54/40
f 41/39/41 54/55/41 42/41/41
f 54/55/42 43/42/42 42/41/42
f 55/56/43 44/45/43 43/44/43
f 56/57/44 45/58/44 44/45/44
f 45/58/45 58/59/45 46/47/45
f 58/59/46 47/48/46 46/47/46
f 59/60/47 48/49/47 47/48/47
f 60/61/48 37/50/48 48/49/48
f 61/62/49 50/51/49 49/63/49
f 50/51/50 63/64/50 51/52/50
f 63/64/51 52/53/51 51/52/51
f 64/65/52 53/66/52 52/53/52
f 53/66/53 66/67/53 54/55/53
f 66/67/54 55/68/54 54/55/54
f 67/69/55 56/57/55 55/56/55
f 68/70/56 57/71/56 56/57/56
f 69/72/57 58/59/57 57/71/57
f 70/73/58 59/60/58 58/59/58
f 71/74/59 60/61/59 59/60/59
f 60/61/60 61/62/60 49/63/60
f 73/75/61 62/76/61 61/62/61
f 74/77/62 63/64/62 62/76/62
f 75/78/63 64/65/63 63/64/63
f 76/79/64 65/80/64 64/65/64
f 77/81/65 66/67/65 65/80/65
f 78/82/66 67/83/66 66/67/66
f 67/69/67 80/84/67 68/70/67
f 80/84/68 69/72/68 68/70/68
f 81/85/69 70/73/69 69/72/69
f 82/86/70 71/74/70 70/73/70
f 71/74/71 84/87/71 72/88/71
f 84/87/72 61/62/72 72/88/72
f 85/89/73 74/77/73 73/75/73
f 74/77/74 87/90/74 75/78/74
f 87/90/75 76/79/75 75/78/75
f 88/91/76 77/81/76 76/79/76
f 77/81/77 90/92/77 78/82/77
f 90/92/78 79/93/78 78/82/78
f 91/94/79 80/84/79 79/95/79
f 92/96/80 81/85/80 80/84/80
f 81/85/81 94/97/81 82/86/81
f 82/86/82 95/98/82 83/99/82
f 95/98/83 84/87/83 83/99/83
f 96/100/84 73/75/84 84/87/84
f 97/101/85 86/102/85 85/89/85
f 86/102/86 99/103/86 87/90/86
f 87/90/87 100/104/87 88/91/87
f 100/104/88 89/105/88 88/91/88
f 89/105/89 102/106/89 90/92/89
f 102/106/90 91/107/90 90/92/90
f 103/108/91 92/96/91 91/94/91
f 104/109/92 93/110/92 92/96/92
f 105/111/93 94/97/93 93/110/93
f 106/112/94 95/98/94 94/97/94
f 107/113/95 96/100/95 95/98/95
f 108/114/96 85/89/96 96/100/96
f 97/101/97 110/115/97 98/116/97
f 110/115/98 99/103/98 98/116/98
f 111/117/99 100/104/99 99/103/99
f 112/118/100 101/119/100 100/104/100
f 113/120/101 102/106/101 101/119/101
f 114/121/102 103/122/102 102/106/102
f 115/123/103 104/109/103 103/108/103
f 116/124/104 105/111/104 104/109/104
f 105/111/105 118/125/105 106/112/105
f 106/112/106 119/126/106 107/113/106
f 119/126/107 108/114/107 107/113/107
f 120/127/108 97/101/108 108/114/108
f 121/128/109 110/115/109 109/129/109
f 122/130/110 111/117/110 110/115/110
f 123/131/111 112/118/111 111/117/111
f 124/132/112 113/120/112 112/118/112
f 113/120/113 126/133/113 114/121/113
f 126/133/114 115/134/114 114/121/114
f 127/135/115 116/124/115 115/123/115
f 128/136/116 117/137/116 116/124/116
f 129/138/117 118/125/117 117/137/117
f 130/139/118 119/126/118 118/125/118
f 131/140/119 120/127/119 119/126/119
f 132/141/120 109/129/120 120/127/120
f 133/142/121 122/130/121 121/128/121
f 134/143/122 123/131/122 122/130/122
f 123/131/123 136/144/123 124/132/123
f 136/144/124 125/145/124 124/132/124
f 137/146/125 126/133/125 125/145/125
f 138/147/126 127/148/126 126/133/126
f 127/135/127 140/149/127 128/136/127
f 140/149/128 129/138/128 128/136/128
f 129/138/129 142/150/129 130/139/129
f 142/150/130 131/140/130 130/139/130
f 143/151/131 132/141/131 131/140/131
f 144/152/132 121/128/132 132/141/132
f 145/153/133 134/143/133 133/142/133
f 146/154/134 135/155/134 134/143/134
f 147/156/135 136/144/135 135/155/135
f 136/144/136 149/157/136 137/146/136
f 137/146/137 150/158/137 138/147/137
f 150/158/138 139/159/138 138/147/138
f 151/160/139 140/149/139 139/161/139
f 152/162/140 141/163/140 140/149/140
f 153/164/141 142/150/141 141/163/141
f 154/165/142 143/151/142 142/150/142
f 155/166/143 144/152/143 143/151/143
f 144/152/144 145/153/144 133/142/144
f 157/167/145 146/154/145 145/153/145
f 158/168/146 147/156/146 146/154/146
f 159/169/147 148/170/147 147/156/147
f 160/171/148 149/157/148 148/170/148
f 161/172/149 150/158/149 149/157/149
f 162/173/150 151/174/150 150/158/150
f 151/160/151 164/175/151 152/162/151
f 164/175/152 153/164/152 152/162/152
f 153/164/153 166/176/153 154/165/153
f 154/165/154 167/177/154 155/166/154
f 155/166/155 168/178/155 156/179/155
f 156/179/156 157/167/156 145/153/156
f 169/180/157 158/168/157 157/167/157
f 158/168/158 171/181/158 159/169/158
f 159/169/159 172/182/159 160/171/159
f 172/182/160 161/172/160 160/171/160
f 173/183/161 162/173/161 161/172/161
f 174/184/162 163/185/162 162/173/162
f 175/186/163 164/175/163 163/187/163
f 176/188/164 165/189/164 164/175/164
f 177/190/165 166/176/165 165/189/165
f 178/191/166 167/177/166 166/176/166
f 179/192/167 168/178/167 167/177/167
f 180/193/168 157/167/168 168/178/168
f 181/194/169 170/195/169 169/180/169
f 182/196/170 171/181/170 170/195/170
f 183/197/171 172/182/171 171/181/171
f 172/182/172 185/198/172 173/183/172
f 185/198/173 174/184/173 173/183/173
f 186/199/174 175/200/174 174/184/174
f 187/201/175 176/188/175 175/186/175
f 188/202/176 177/190/176 176/188/176
f 177/190/177 190/203/177 178/191/177
f 190/203/178 179/192/178 178/191/178
f 179/192/179 192/204/179 180/193/179
f 192/204/180 169/180/180 180/193/180
f 193/205/181 182/196/181 181/194/181
f 182/196/182 195/206/182 183/197/182
f 195/206/183 184/207/183 183/197/183
f 196/208/184 185/198/184 184/207/184
f 197/209/185 186/199/185 185/198/185
f 198/210/186 187/211/186 186/199/186
f 199/212/187 188/202/187 187/201/187
f 200/213/188 189/214/188 188/202/188
f 201/215/189 190/203/189 189/214/189
f 202/216/190 191/217/190 190/203/190
f 203/218/191 192/204/191 191/217/191
f 204/219/192 181/194/192 192/204/192
f 205/220/193 194/221/193 193/205/193
f 206/222/194 195/206/194 194/221/194
f 207/223/195 196/208/195 195/206/195
f 208/224/196 197/209/196 196/208/196
f 209/225/197 198/210/197 197/209/197
f 198/210/198 211/226/198 199/227/198
f 211/228/199 200/213/199 199/212/199
f 200/213/200 213/229/200 201/215/200
f 201/215/201 214/230/201 202/216/201
f 202/216/202 215/231/202 203/218/202
f 203/218/203 216/232/203 204/219/203
f 216/232/204 193/205/204 204/219/204
f 217/233/205 206/222/205 205/220/205
f 218/234/206 207/223/206 206/222/206
f 207/223/207 220/235/207 208/224/207
f 220/235/208 209/225/208 208/224/208
f 221/236/209 210/237/209 209/225/209
f 222/238/210 211/226/210 210/237/210
f 223/239/211 212/240/211 211/228/211
f 212/240/212 225/241/212 213/229/212
f 225/241/213 214/230/213 213/229/213
f 226/242/214 215/231/214 214/230/214
f 227/243/215 216/232/215 215/231/215
f 228/244/216 205/220/216 216/232/216
f 229/245/217 218/234/217 217/233/217
f 230/246/218 219/247/218 218/234/218
f 231/248/219 220/235/219 219/247/219
f 220/235/220 233/249/220 221/236/220
f 233/249/221 222/238/221 221/236/221
f 234/250/222 223/251/222 222/238/222
f 235/252/223 224/253/223 223/239/223
f 224/253/224 237/254/224 225/241/224
f 237/254/225 226/242/225 225/241/225
f 238/255/226 227/243/226 226/242/226
f 227/243/227 240/256/227 228/244/227
f 240/256/228 217/233/228 228/244/228
f 229/245/229 242/257/229 230/246/229
f 242/257/230 231/248/230 230/246/230
f 231/248/231 244/258/231 232/259/231
f 244/258/232 233/249/232 232/259/232
f 245/260/233 234/250/233 233/249/233
f 246/261/234 235/262/234 234/250/234
f 247/263/235 236/264/235 235/252/235
f 248/265/236 237/254/236 236/264/236
f 237/254/237 250/266/237 238/255/237
f 250/266/238 239/267/238 238/255/238
f 251/268/239 240/256/239 239/267/239
f 252/269/240 229/245/240 240/256/240
f 253/270/241 242/257/241 241/271/241
f 254/272/242 243/273/242 242/257/242
f 255/274/243 244/258/243 243/273/243
f 244/258/244 257/275/244 245/260/244
f 257/275/245 246/261/245 245/260/245
f 258/276/246 247/277/246 246/261/246
f 247/263/247 260/278/247 248/265/247
f 260/278/248 249/279/248 248/265/248
f 261/280/249 250/266/249 249/279/249
f 262/281/250 251/268/250 250/266/250
f 251/268/251 264/282/251 252/269/251
f 264/282/252 241/271/252 252/269/252
f 253/270/253 266/283/253 254/272/253
f 266/283/254 255/274/254 254/272/254
f 267/284/255 256/285/255 255/274/255
f 256/285/256 269/286/256 257/275/256
f 269/286/257 258/276/257 257/275/257
f 270/287/258 259/288/258 258/276/258
f 271/289/259 260/278/259 259/290/259
f 272/291/260 261/280/260 260/278/260
f 273/292/261 262/281/261 261/280/261
f 262/281/262 275/293/262 263/294/262
f 275/293/263 264/282/263 263/294/263
f 276/295/264 253/270/264 264/282/264
f 277/296/265 266/283/265 265/297/265
f 278/298/266 267/284/266 266/283/266
f 279/299/267 268/300/267 267/284/267
f 280/301/268 269/286/268 268/300/268
f 281/302/269 270/287/269 269/286/269
f 282/303/270 271/304/270 270/287/270
f 283/305/271 272/291/271 271/289/271
f 272/291/272 285/306/272 273/292/272
f 273/292/273 286/307/273 274/308/273
f 274/308/274 287/309/274 275/293/274
f 275/293/275 288/310/275 276/295/275
f 276/295/276 277/296/276 265/297/276
f 277/296/277 290/311/277 278/298/277
f 290/311/278 279/299/278 278/298/278
f 291/312/279 280/301/279 279/299/279
f 292/313/280 281/302/280 280/301/280
f 293/314/281 282/303/281 281/302/281
f 294/315/282 283/316/282 282/303/282
f 295/317/283 284/318/283 283/305/283
f 284/318/284 297/319/284 285/306/284
f 297/319/285 286/307/285 285/306/285
f 298/320/286 287/309/286 286/307/286
f 299/321/287 288/310/287 287/309/287
f 300/322/288 277/296/288 288/310/288
f 301/323/6 290/324/6 289/325/6
f 302/326/5 291/327/5 290/324/5
f 303/328/4 292/329/4 291/327/4
f 304/330/3 293/331/3 292/329/3
f 305/332/2 294/333/2 293/331/2
f 306/334/1 295/335/1 294/333/1
f 295/336/12 308/337/12 296/338/12
f 308/337/11 297/339/11 296/338/11
f 297/339/10 310/340/10 298/341/10
f 298/341/9 311/342/9 299/343/9
f 299/343/8 312/344/8 300/345/8
f 300/345/7 301/323/7 289/325/7
f 301/323/18 314/346/18 302/326/18
f 302/326/17 315/347/17 303/328/17
f 303/328/16 316/348/16 304/330/16
f 304/330/15 317/349/15 305/332/15
f 305/332/14 318/350/14 306/334/14
f 318/350/13 307/351/13 306/334/13
f 319/352/24 308/337/24 307/353/24
f 320/354/23 309/355/23 308/337/23
f 321/356/22 310/340/22 309/355/22
f 322/357/21 311/342/21 310/340/21
f 323/358/20 312/344/20 311/342/20
f 312/344/19 313/359/19 301/323/19
f 325/360/30 314/346/30 313/359/30
f 326/361/29 315/347/29 314/346/29
f 315/347/28 328/362/28 316/348/28
f 328/362/27 317/349/27 316/348/27
f 329/363/26 318/350/26 317/349/26
f 330/364/25 319/365/25 318/350/25
f 331/366/36 320/354/36 319/352/36
f 320/354/35 333/367/35 321/356/35
f 333/367/34 322/357/34 321/356/34
f 334/368/33 323/358/33 322/357/33
f 323/358/32 336/369/32 324/370/32
f 324/370/31 325/360/31 313/359/31
f 337/371/42 326/361/42 325/360/42
f 338/372/41 327/373/41 326/361/41
f 339/374/40 328/362/40 327/373/40
f 340/375/39 329/363/39 328/362/39
f 341/376/38 330/364/38 329/363/38
f 330/364/37 343/377/37 331/378/37
f 343/379/48 332/380/48 331/366/48
f 344/381/47 333/367/47 332/380/47
f 345/382/46 334/368/46 333/367/46
f 334/368/45 347/383/45 335/384/45
f 335/384/44 348/385/44 336/369/44
f 348/385/43 325/360/43 336/369/43
f 349/386/54 338/372/54 337/371/54
f 350/387/53 339/374/53 338/372/53
f 351/388/52 340/375/52 339/374/52
f 340/375/51 353/389/51 341/376/51
f 353/389/50 342/390/50 341/376/50
f 354/391/49 343/377/49 342/390/49
f 355/392/60 344/381/60 343/379/60
f 344/381/59 357/393/59 345/382/59
f 357/393/58 346/394/58 345/382/58
f 358/395/57 347/383/57 346/394/57
f 347/383/56 360/396/56 348/385/56
f 360/396/55 337/371/55 348/385/55
f 361/397/66 350/387/66 349/386/66
f 350/387/65 363/398/65 351/388/65
f 363/398/64 352/399/64 351/388/64
f 364/400/63 353/389/63 352/399/63
f 365/401/62 354/391/62 353/389/62
f 366/402/61 355/403/61 354/391/61
f 367/404/72 356/405/72 355/392/72
f 368/406/71 357/393/71 356/405/71
f 357/393/70 370/407/70 358/395/70
f 370/407/69 359/408/69 358/395/69
f 371/409/68 360/396/68 359/408/68
f 372/410/67 349/386/67 360/396/67
f 361/397/78 374/411/78 362/412/78
f 362/412/77 375/413/77 363/398/77
f 375/413/76 364/400/76 363/398/76
f 364/400/75 377/414/75 365/401/75
f 377/414/74 366/402/74 365/401/74
f 378/415/73 367/416/73 366/402/73
f 379/417/84 368/406/84 367/404/84
f 380/418/83 369/419/83 368/406/83
f 381/420/82 370/407/82 369/419/82
f 382/421/81 371/409/81 370/407/81
f 383/422/80 372/410/80 371/409/80
f 384/423/79 361/397/79 372/410/79
f 373/424/90 386/425/90 374/411/90
f 386/425/89 375/413/89 374/411/89
f 387/426/88 376/427/88 375/413/88
f 388/428/87 377/414/87 376/427/87
f 377/414/86 390/429/86 378/415/86
f 390/429/85 379/430/85 378/415/85
f 391/431/96 380/418/96 379/417/96
f 392/432/95 381/420/95 380/418/95
f 393/433/94 382/421/94 381/420/94
f 382/421/93 395/434/93 383/422/93
f 383/422/92 396/435/92 384/423/92
f 396/435/91 373/424/91 384/423/91
f 397/436/102 386/425/102 385/437/102
f 398/438/101 387/426/101 386/425/101
f 399/439/100 388/428/100 387/426/100
f 400/440/99 389/441/99 388/428/99
f 401/442/98 390/429/98 389/441/98
f 402/443/97 391/444/97 390/429/97
f 403/445/108 392/432/108 391/431/108
f 404/446/107 393/433/107 392/432/107
f 393/433/106 406/447/106 394/448/106
f 406/447/105 395/434/105 394/448/105
f 395/434/104 408/449/104 396/435/104
f 408/449/103 385/437/103 396/435/103
f 409/450/114 398/438/114 397/436/114
f 410/451/113 399/439/113 398/438/113
f 411/452/112 400/440/112 399/439/112
f 412/453/111 401/442/111 400/440/111
f 401/442/110 414/454/110 402/443/110
f 414/454/109 403/455/109 402/443/109
f 415/456/120 404/446/120 403/445/120
f 416/457/119 405/458/119 404/446/119
f 417/459/118 406/447/118 405/458/118
f 418/460/117 407/461/117 406/447/117
f 407/461/116 420/462/116 408/449/116
f 420/462/115 397/436/115 408/449/115
f 421/463/126 410/451/126 409/450/126
f 410/451/125 423/464/125 411/452/125
f 423/464/124 412/453/124 411/452/124
f 424/465/123 413/466/123 412/453/123
f 413/466/122 426/467/122 414/454/122
f 426/467/121 415/468/121 414/454/121
f 427/469/132 416/457/132 415/456/132
f 428/470/131 417/459/131 416/457/131
f 417/459/130 430/471/130 418/460/130
f 430/471/129 419/472/129 418/460/129
f 431/473/128 420/462/128 419/472/128
f 432/474/127 409/450/127 420/462/127
f 433/475/138 422/476/138 421/463/138
f 434/477/137 423/464/137 422/476/137
f 423/464/136 436/478/136 424/465/136
f 424/465/135 437/479/135 425/480/135
f 437/479/134 426/467/134 425/480/134
f 426/467/133 439/481/133 427/482/133
f 439/483/144 428/470/144 427/469/144
f 440/484/143 429/485/143 428/470/143
f 441/486/142 430/471/142 429/485/142
f 442/487/141 431/473/141 430/471/141
f 443/488/140 432/474/140 431/473/140
f 444/489/139 421/463/139 432/474/139
f 433/475/150 446/490/150 434/477/150
f 446/490/149 435/491/149 434/477/149
f 447/492/148 436/478/148 435/491/148
f 448/493/147 437/479/147 436/478/147
f 449/494/146 438/495/146 437/479/146
f 450/496/145 439/481/145 438/495/145
f 451/497/156 440/484/156 439/483/156
f 440/484/155 453/498/155 441/486/155
f 441/486/154 454/499/154 442/487/154
f 454/499/153 443/488/153 442/487/153
f 455/500/152 444/489/152 443/488/152
f 456/501/151 433/475/151 444/489/151
f 457/502/162 446/490/162 445/503/162
f 458/504/161 447/492/161 446/490/161
f 459/505/160 448/493/160 447/492/160
f 460/506/159 449/494/159 448/493/159
f 461/507/158 450/496/158 449/494/158
f 450/496/157 463/508/157 451/509/157
f 463/510/168 452/511/168 451/497/168
f 464/512/167 453/498/167 452/511/167
f 453/498/166 466/513/166 454/499/166
f 454/499/165 467/514/165 455/500/165
f 467/514/164 456/501/164 455/500/164
f 468/515/163 445/503/163 456/501/163
f 469/516/174 458/504/174 457/502/174
f 470/517/173 459/505/173 458/504/173
f 471/518/172 460/506/172 459/505/172
f 472/519/171 461/507/171 460/506/171
f 473/520/170 462/521/170 461/507/170
f 474/522/169 463/508/169 462/521/169
f 475/523/180 464/512/180 463/510/180
f 476/524/179 465/525/179 464/512/179
f 477/526/178 466/513/178 465/525/178
f 466/513/177 479/527/177 467/514/177
f 467/514/176 480/528/176 468/515/176
f 480/528/175 457/502/175 468/515/175
f 481/529/186 470/517/186 469/516/186
f 482/530/185 471/518/185 470/517/185
f 471/518/184 484/531/184 472/519/184
f 472/519/183 485/532/183 473/520/183
f 485/532/182 474/522/182 473/520/182
f 486/533/181 475/534/181 474/522/181
f 487/535/192 476/524/192 475/523/192
f 488/536/191 477/526/191 476/524/191
f 489/537/190 478/538/190 477/526/190
f 490/539/189 479/527/189 478/538/189
f 491/540/188 480/528/188 479/527/188
f 480/528/187 481/529/187 469/516/187
f 481/529/198 494/541/198 482/530/198
f 494/541/197 483/542/197 482/530/197
f 495/543/196 484/531/196 483/542/196
f 496/544/195 485/532/195 484/531/195
f 497/545/194 486/533/194 485/532/194
f 498/546/193 487/547/193 486/533/193
f 499/548/204 488/536/204 487/535/204
f 500/549/203 489/537/203 488/536/203
f 501/550/202 490/539/202 489/537/202
f 502/551/201 491/540/201 490/539/201
f 491/540/200 504/552/200 492/553/200
f 504/552/199 481/529/199 492/553/199
f 493/554/210 506/555/210 494/541/210
f 506/555/209 495/543/209 494/541/209
f 495/543/208 508/556/208 496/544/208
f 496/544/207 509/557/207 497/545/207
f 497/545/206 510/558/206 498/546/206
f 510/558/205 499/559/205 498/546/205
f 511/560/216 500/549/216 499/548/216
f 512/561/215 501/550/215 500/549/215
f 513/562/214 502/551/214 501/550/214
f 514/563/213 503/564/213 502/551/213
f 503/564/212 516/565/212 504/552/212
f 516/565/211 493/554/211 504/552/211
f 505/566/222 518/567/222 506/555/222
f 518/567/221 507/568/221 506/555/221
f 507/568/220 520/569/220 508/556/220
f 520/569/219 509/557/219 508/556/219
f 521/570/218 510/558/218 509/557/218
f 522/571/217 511/572/217 510/558/217
f 523/573/228 512/561/228 511/560/228
f 512/561/227 525/574/227 513/562/227
f 513/562/226 526/575/226 514/563/226
f 526/575/225 515/576/225 514/563/225
f 527/577/224 516/565/224 515/576/224
f 528/578/223 505/566/223 516/565/223
f 529/579/234 518/567/234 517/580/234
f 530/581/233 519/582/233 518/567/233
f 531/583/232 520/569/232 519/582/232
f 532/584/231 521/570/231 520/569/231
f 533/585/230 522/571/230 521/570/230
f 534/586/229 523/587/229 522/571/229
f 535/588/240 524/589/240 523/573/240
f 524/589/239 537/590/239 525/574/239
f 537/590/238 526/575/238 525/574/238
f 538/591/237 527/577/237 526/575/237
f 527/577/236 540/592/236 528/578/236
f 540/592/235 517/580/235 528/578/235
f 541/593/246 530/581/246 529/579/246
f 542/594/245 531/583/245 530/581/245
f 531/583/244 544/595/244 532/584/244
f 544/595/243 533/585/243 532/584/243
f 545/596/242 534/586/242 533/585/242
f 546/597/241 535/598/241 534/586/241
f 547/599/252 536/600/252 535/588/252
f 548/601/251 537/590/251 536/600/251
f 549/602/250 538/591/250 537/590/250
f 550/603/249 539/604/249 538/591/249
f 551/605/248 540/592/248 539/604/248
f 552/606/247 529/579/247 540/592/247
f 553/607/258 542/594/258 541/593/258
f 554/608/257 543/609/257 542/594/257
f 555/610/256 544/595/256 543/609/256
f 556/611/255 545/596/255 544/595/255
f 557/612/254 546/597/254 545/596/254
f 558/613/253 547/614/253 546/597/253
f 559/615/264 548/601/264 547/599/264
f 548/601/263 561/616/263 549/602/263
f 561/616/262 550/603/262 549/602/262
f 562/617/261 551/605/261 550/603/261
f 563/618/260 552/606/260 551/605/260
f 564/619/259 541/593/259 552/606/259
f 553/607/270 566/620/270 554/608/270
f 554/608/269 567/621/269 555/610/269
f 555/610/268 568/622/268 556/611/268
f 568/622/267 557/612/267 556/611/267
f 569/623/266 558/613/266 557/612/266
f 558/613/265 571/624/265 559/625/265
f 571/626/276 560/627/276 559/615/276
f 572/628/275 561/616/275 560/627/275
f 561/616/274 574/629/274 562/617/274
f 574/629/273 563/618/273 562/617/273
f 575/630/272 564/619/272 563/618/272
f 576/631/271 553/607/271 564/619/271
f 1/3/282 566/620/282 565/632/282
f 2/2/281 567/621/281 566/620/281
f 3/5/280 568/622/280 567/621/280
f 4/6/279 569/623/279 568/622/279
f 5/8/278 570/633/278 569/623/278
f 6/10/277 571/624/277 570/633/277
f 571/626/288 8/14/288 572/628/288
f 8/14/287 573/634/287 572/628/287
f 9/17/286 574/629/286 573/634/286
f 10/19/285 575/630/285 574/629/285
f 575/630/284 12/23/284 576/631/284
f 576/631/283 1/3/283 565/632/283
f 13/1/1 14/26/1 2/2/1
f 2/2/2 14/26/2 15/4/2
f 15/4/3 16/7/3 4/6/3
f 16/7/4 17/9/4 5/8/4
f 17/9/5 18/31/5 6/10/5
f 6/10/6 18/31/6 19/11/6
f 19/13/7 20/16/7 8/14/7
f 20/16/8 21/18/8 9/17/8
f 21/18/9 22/20/9 10/19/9
f 22/20/10 23/22/10 11/21/10
f 23/22/11 24/24/11 12/23/11
f 24/24/12 13/1/12 1/3/12
f 25/25/13 26/27/13 14/26/13
f 26/27/14 27/28/14 15/4/14
f 27/28/15 28/29/15 16/7/15
f 28/29/16 29/40/16 17/9/16
f 17/9/17 29/40/17 30/30/17
f 30/30/18 31/43/18 19/11/18
f 31/32/19 32/33/19 20/16/19
f 32/33/20 33/46/20 21/18/20
f 21/18/21 33/46/21 34/34/21
f 22/20/22 34/34/22 35/35/22
f 23/22/23 35/35/23 36/36/23
f 36/36/24 25/25/24 13/1/24
f 25/25/25 37/50/25 38/37/25
f 38/37/26 39/38/26 27/28/26
f 39/38/27 40/54/27 28/29/27
f 28/29/28 40/54/28 41/39/28
f 29/40/29 41/39/29 42/41/29
f 30/30/30 42/41/30 43/42/30
f 43/44/31 44/45/31 32/33/31
f 44/45/32 45/58/32 33/46/32
f 33/46/33 45/58/33 46/47/33
f 34/34/34 46/47/34 47/48/34
f 35/35/35 47/48/35 48/49/35
f 48/49/36 37/50/36 25/25/36
f 37/50/37 49/63/37 50/51/37
f 38/37/38 50/51/38 51/52/38
f 39/38/39 51/52/39 52/53/39
f 52/53/40 53/66/40 41/39/40
f 41/39/41 53/66/41 54/55/41
f 54/55/42 55/68/42 43/42/42
f 55/56/43 56/57/43 44/45/43
f 56/57/44 57/71/44 45/58/44
f 45/58/45 57/71/45 58/59/45
f 58/59/46 59/60/46 47/48/46
f 59/60/47 60/61/47 48/49/47
f 60/61/48 49/63/48 37/50/48
f 61/62/49 62/76/49 50/51/49
f 50/51/50 62/76/50 63/64/50
f 63/64/51 64/65/51 52/53/51
f 64/65/52 65/80/52 53/66/52
f 53/66/53 65/80/53 66/67/53
f 66/67/54 67/83/54 55/68/54
f 67/69/55 68/70/55 56/57/55
f 68/70/56 69/72/56 57/71/56
f 69/72/57 70/73/57 58/59/57
f 70/73/58 71/74/58 59/60/58
f 71/74/59 72/88/59 60/61/59
f 60/61/60 72/88/60 61/62/60
f 73/75/61 74/77/61 62/76/61
f 74/77/62 75/78/62 63/64/62
f 75/78/63 76/79/63 64/65/63
f 76/79/64 77/81/64 65/80/64
f 77/81/65 78/82/65 66/67/65
f 78/82/66 79/93/66 67/83/66
f 67/69/67 79/95/67 80/84/67
f 80/84/68 81/85/68 69/72/68
f 81/85/69 82/86/69 70/73/69
f 82/86/70 83/99/70 71/74/70
f 71/74/71 83/99/71 84/87/71
f 84/87/72 73/75/72 61/62/72
f 85/89/73 86/102/73 74/77/73
f 74/77/74 86/102/74 87/90/74
f 87/90/75 88/91/75 76/79/75
f 88/91/76 89/105/76 77/81/76
f 77/81/77 89/105/77 90/92/77
f 90/92/78 91/107/78 79/93/78
f 91/94/79 92/96/79 80/84/79
f 92/96/80 93/110/80 81/85/80
f 81/85/81 93/110/81 94/97/81
f 82/86/82 94/97/82 95/98/82
f 95/98/83 96/100/83 84/87/83
f 96/100/84 85/89/84 73/75/84
f 97/101/85 98/116/85 86/102/85
f 86/102/86 98/116/86 99/103/86
f 87/90/87 99/103/87 100/104/87
f 100/104/88 101/119/88 89/105/88
f 89/105/89 101/119/89 102/106/89
f 102/106/90 103/122/90 91/107/90
f 103/108/91 104/109/91 92/96/91
f 104/109/92 105/111/92 93/110/92
f 105/111/93 106/112/93 94/97/93
f 106/112/94 107/113/94 95/98/94
f 107/113/95 108/114/95 96/100/95
f 108/114/96 97/101/96 85/89/96
f 97/101/97 109/129/97 110/115/97
f 110/115/98 111/117/98 99/103/98
f 111/117/99 112/118/99 100/104/99
f 112/118/100 113/120/100 101/119/100
f 113/120/101 114/121/101 102/106/101
f 114/121/102 115/134/102 103/122/102
f 115/123/103 116/124/103 104/109/103
f 116/124/104 117/137/104 105/111/104
f 105/111/105 117/137/105 118/125/105
f 106/112/106 118/125/106 119/126/106
f 119/126/107 120/127/107 108/114/107
f 120/127/108 109/129/108 97/101/108
f 121/128/109 122/130/109 110/115/109
f 122/130/110 123/131/110 111/117/110
f 123/131/111 124/132/111 112/118/111
f 124/132/112 125/145/112 113/120/112
f 113/120/113 125/145/113 126/133/113
f 126/133/114 127/148/114 115/134/114
f 127/135/115 128/136/115 116/124/115
f 128/136/116 129/138/116 117/137/116
f 129/138/117 130/139/117 118/125/117
f 130/139/118 131/140/118 119/126/118
f 131/140/119 132/141/119 120/127/119
f 132/141/120 121/128/120 109/129/120
f 133/142/121 134/143/121 122/130/121
f 134/143/122 135/155/122 123/131/122
f 123/131/123 135/155/123 136/144/123
f 136/144/124 137/146/124 125/145/124
f 137/146/125 138/147/125 126/133/125
f 138/147/126 139/159/126 127/148/126
f 127/135/127 139/161/127 140/149/127
f 140/149/128 141/163/128 129/138/128
f 129/138/129 141/163/129 142/150/129
f 142/150/130 143/151/130 131/140/130
f 143/151/131 144/152/131 132/141/131
f 144/152/132 133/142/132 121/128/132
f 145/153/133 146/154/133 134/143/133
f 146/154/134 147/156/134 135/155/134
f 147/156/135 148/170/135 136/144/135
f 136/144/136 148/170/136 149/157/136
f 137/146/137 149/157/137 150/158/137
f 150/158/138 151/174/138 139/159/138
f 151/160/139 152/162/139 140/149/139
f 152/162/140 153/164/140 141/163/140
f 153/164/141 154/165/141 142/150/141
f 154/165/142 155/166/142 143/151/142
f 155/166/143 156/179/143 144/152/143
f 144/152/144 156/179/144 145/153/144
f 157/167/145 158/168/145 146/154/145
f 158/168/146 159/169/146 147/156/146
f 159/169/147 160/171/147 148/170/147
f 160/171/148 161/172/148 149/157/148
f 161/172/149 162/173/149 150/158/149
f 162/173/150 163/185/150 151/174/150
f 151/160/151 163/187/151 164/175/151
f 164/175/152 165/189/152 153/164/152
f 153/164/153 165/189/153 166/176/153
f 154/165/154 166/176/154 167/177/154
f 155/166/155 167/177/155 168/178/155
f 156/179/156 168/178/156 157/167/156
f 169/180/157 170/195/157 158/168/157
f 158/168/158 170/195/158 171/181/158
f 159/169/159 171/181/159 172/182/159
f 172/182/160 173/183/160 161/172/160
f 173/183/161 174/184/161 162/173/161
f 174/184/162 175/200/162 163/185/162
f 175/186/163 176/188/163 164/175/163
f 176/188/164 177/190/164 165/189/164
f 177/190/165 178/191/165 166/176/165
f 178/191/166 179/192/166 167/177/166
f 179/192/167 180/193/167 168/178/167
f 180/193/168 169/180/168 157/167/168
f 181/194/169 182/196/169 170/195/169
f 182/196/170 183/197/170 171/181/170
f 183/197/171 184/207/171 172/182/171
f 172/182/172 184/207/172 185/198/172
f 185/198/173 186/199/173 174/184/173
f 186/199/174 187/211/174 175/200/174
f 187/201/175 188/202/175 176/188/175
f 188/202/176 189/214/176 177/190/176
f 177/190/177 189/214/177 190/203/177
f 190/203/178 191/217/178 179/192/178
f 179/192/179 191/217/179 192/204/179
f 192/204/180 181/194/180 169/180/180
f 193/205/181 194/221/181 182/196/181
f 182/196/182 194/221/182 195/206/182
f 195/206/183 196/208/183 184/207/183
f 196/208/184 197/209/184 185/198/184
f 197/209/185 198/210/185 186/199/185
f 198/210/186 199/227/186 187/211/186
f 199/212/187 200/213/187 188/202/187
f 200/213/188 201/215/188 189/214/188
f 201/215/189 202/216/189 190/203/189
f 202/216/190 203/218/190 191/217/190
f 203/218/191 204/219/191 192/204/191
f 204/219/192 193/205/192 181/194/192
f 205/220/193 206/222/193 194/221/193
f 206/222/194 207/223/194 195/206/194
f 207/223/195 208/224/195 196/208/195
f 208/224/196 209/225/196 197/209/196
f 209/225/197 210/237/197 198/210/197
f 198/210/198 210/237/198 211/226/198
f 211/228/199 212/240/199 200/213/199
f 200/213/200 212/240/200 213/229/200
f 201/215/201 213/229/201 214/230/201
f 202/216/202 214/230/202 215/231/202
f 203/218/203 215/231/203 216/232/203
f 216/232/204 205/220/204 193/205/204
f 217/233/205 218/234/205 206/222/205
f 218/234/206 219/247/206 207/223/206
f 207/223/207 219/247/207 220/235/207
f 220/235/208 221/236/208 209/225/208
f 221/236/209 222/238/209 210/237/209
f 222/238/210 223/251/210 211/226/210
f 223/239/211 224/253/211 212/240/211
f 212/240/212 224/253/212 225/241/212
f 225/241/213 226/242/213 214/230/213
f 226/242/214 227/243/214 215/231/214
f 227/243/215 228/244/215 216/232/215
f 228/244/216 217/233/216 205/220/216
f 229/245/217 230/246/217 218/234/217
f 230/246/218 231/248/218 219/247/218
f 231/248/219 232/259/219 220/235/219
f 220/235/220 232/259/220 233/249/220
f 233/249/221 234/250/221 222/238/221
f 234/250/222 235/262/222 223/251/222
f 235/252/223 236/264/223 224/253/223
f 224/253/224 236/264/224 237/254/224
f 237/254/225 238/255/225 226/242/225
f 238/255/226 239/267/226 227/243/226
f 227/243/227 239/267/227 240/256/227
f 240/256/228 229/245/228 217/233/228
f 229/245/229 241/271/229 242/257/229
f 242/257/230 243/273/230 231/248/230
f 231/248/231 243/273/231 244/258/231
f 244/258/232 245/260/232 233/249/232
f 245/260/233 246/261/233 234/250/233
f 246/261/234 247/277/234 235/262/234
f 247/263/235 248/265/235 236/264/235
f 248/265/236 249/279/236 237/254/236
f 237/254/237 249/279/237 250/266/237
f 250/266/238 251/268/238 239/267/238
f 251/268/239 252/269/239 240/256/239
f 252/269/240 241/271/240 229/245/240
f 253/270/241 254/272/241 242/257/241
f 254/272/242 255/274/242 243/273/242
f 255/274/243 256/285/243 244/258/243
f 244/258/244 256/285/244 257/275/244
f 257/275/245 258/276/245 246/261/245
f 258/276/246 259/288/246 247/277/246
f 247/263/247 259/290/247 260/278/247
f 260/278/248 261/280/248 249/279/248
f 261/280/249 262/281/249 250/266/249
f 262/281/250 263/294/250 251/268/250
f 251/268/251 263/294/251 264/282/251
f 264/282/252 253/270/252 241/271/252
f 253/270/253 265/297/253 266/283/253
f 266/283/254 267/284/254 255/274/254
f 267/284/255 268/300/255 256/285/255
f 256/285/256 268/300/256 269/286/256
f 269/286/257 270/287/257 258/276/257
f 270/287/258 271/304/258 259/288/258
f 271/289/259 272/291/259 260/278/259
f 272/291/260 273/292/260 261/280/260
f 273/292/261 274/308/261 262/281/261
f 262/281/262 274/308/262 275/293/262
f 275/293/263 276/295/263 264/282/263
f 276/295/264 265/297/264 253/270/264
f 277/296/265 278/298/265 266/283/265
f 278/298/266 279/299/266 267/284/266
f 279/299/267 280/301/267 268/300/267
f 280/301/268 281/302/268 269/286/268
f 281/302/269 282/303/269 270/287/269
f 282/303/270 283/316/270 271/304/270
f 283/305/271 284/318/271 272/291/271
f 272/291/272 284/318/272 285/306/272
f 273/292/273 285/306/273 286/307/273
f 274/308/274 286/307/274 287/309/274
f 275/293/275 287/309/275 288/310/275
f 276/295/276 288/310/276 277/296/276
f 277/296/277 289/635/277 290/311/277
f 290/311/278 291/312/278 279/299/278
f 291/312/279 292/313/279 280/301/279
f 292/313/280 293/314/280 281/302/280
f 293/314/281 294/315/281 282/303/281
f 294/315/282 295/636/282 283/316/282
f 295/317/283 296/637/283 284/318/283
f 284/318/284 296/637/284 297/319/284
f 297/319/285 298/320/285 286/307/285
f 298/320/286 299/321/286 287/309/286
f 299/321/287 300/322/287 288/310/287
f 300/322/288 289/635/288 277/296/288
f 301/323/6 302/326/6 290/324/6
f 302/326/5 303/328/5 291/327/5
f 303/328/4 304/330/4 292/329/4
f 304/330/3 305/332/3 293/331/3
f 305/332/2 306/334/2 294/333/2
f 306/334/1 307/351/1 295/335/1
f 295/336/12 307/353/12 308/337/12
f 308/337/11 309/355/11 297/339/11
f 297/339/10 309/355/10 310/340/10
f 298/341/9 310/340/9 311/342/9
f 299/343/8 311/342/8 312/344/8
f 300/345/7 312/344/7 301/323/7
f 301/323/18 313/359/18 314/346/18
f 302/326/17 314/346/17 315/347/17
f 303/328/16 315/347/16 316/348/16
f 304/330/15 316/348/15 317/349/15
f 305/332/14 317/349/14 318/350/14
f 318/350/13 319/365/13 307/351/13
f 319/352/24 320/354/24 308/337/24
f 320/354/23 321/356/23 309/355/23
f 321/356/22 322/357/22 310/340/22
f 322/357/21 323/358/21 311/342/21
f 323/358/20 324/370/20 312/344/20
f 312/344/19 324/370/19 313/359/19
f 325/360/30 326/361/30 314/346/30
f 326/361/29 327/373/29 315/347/29
f 315/347/28 327/373/28 328/362/28
f 328/362/27 329/363/27 317/349/27
f 329/363/26 330/364/26 318/350/26
f 330/364/25 331/378/25 319/365/25
f 331/366/36 332/380/36 320/354/36
f 320/354/35 332/380/35 333/367/35
f 333/367/34 334/368/34 322/357/34
f 334/368/33 335/384/33 323/358/33
f 323/358/32 335/384/32 336/369/32
f 324/370/31 336/369/31 325/360/31
f 337/371/42 338/372/42 326/361/42
f 338/372/41 339/374/41 327/373/41
f 339/374/40 340/375/40 328/362/40
f 340/375/39 341/376/39 329/363/39
f 341/376/38 342/390/38 330/364/38
f 330/364/37 342/390/37 343/377/37
f 343/379/48 344/381/48 332/380/48
f 344/381/47 345/382/47 333/367/47
f 345/382/46 346/394/46 334/368/46
f 334/368/45 346/394/45 347/383/45
f 335/384/44 347/383/44 348/385/44
f 348/385/43 337/371/43 325/360/43
f 349/386/54 350/387/54 338/372/54
f 350/387/53 351/388/53 339/374/53
f 351/388/52 352/399/52 340/375/52
f 340/375/51 352/399/51 353/389/51
f 353/389/50 354/391/50 342/390/50
f 354/391/49 355/403/49 343/377/49
f 355/392/60 356/405/60 344/381/60
f 344/381/59 356/405/59 357/393/59
f 357/393/58 358/395/58 346/394/58
f 358/395/57 359/408/57 347/383/57
f 347/383/56 359/408/56 360/396/56
f 360/396/55 349/386/55 337/371/55
f 361/397/66 362/412/66 350/387/66
f 350/387/65 362/412/65 363/398/65
f 363/398/64 364/400/64 352/399/64
f 364/400/63 365/401/63 353/389/63
f 365/401/62 366/402/62 354/391/62
f 366/402/61 367/416/61 355/403/61
f 367/404/72 368/406/72 356/405/72
f 368/406/71 369/419/71 357/393/71
f 357/393/70 369/419/70 370/407/70
f 370/407/69 371/409/69 359/408/69
f 371/409/68 372/410/68 360/396/68
f 372/410/67 361/397/67 349/386/67
f 361/397/78 373/424/78 374/411/78
f 362/412/77 374/411/77 375/413/77
f 375/413/76 376/427/76 364/400/76
f 364/400/75 376/427/75 377/414/75
f 377/414/74 378/415/74 366/402/74
f 378/415/73 379/430/73 367/416/73
f 379/417/84 380/418/84 368/406/84
f 380/418/83 381/420/83 369/419/83
f 381/420/82 382/421/82 370/407/82
f 382/421/81 383/422/81 371/409/81
f 383/422/80 384/423/80 372/410/80
f 384/423/79 373/424/79 361/397/79
f 373/424/90 385/437/90 386/425/90
f 386/425/89 387/426/89 375/413/89
f 387/426/88 388/428/88 376/427/88
f 388/428/87 389/441/87 377/414/87
f 377/414/86 389/441/86 390/429/86
f 390/429/85 391/444/85 379/430/85
f 391/431/96 392/432/96 380/418/96
f 392/432/95 393/433/95 381/420/95
f 393/433/94 394/448/94 382/421/94
f 382/421/93 394/448/93 395/434/93
f 383/422/92 395/434/92 396/435/92
f 396/435/91 385/437/91 373/424/91
f 397/436/102 398/438/102 386/425/102
f 398/438/101 399/439/101 387/426/101
f 399/439/100 400/440/100 388/428/100
f 400/440/99 401/442/99 389/441/99
f 401/442/98 402/443/98 390/429/98
f 402/443/97 403/455/97 391/444/97
f 403/445/108 404/446/108 392/432/108
f 404/446/107 405/458/107 393/433/107
f 393/433/106 405/458/106 406/447/106
f 406/447/105 407/461/105 395/434/105
f 395/434/104 407/461/104 408/449/104
f 408/449/103 397/436/103 385/437/103
f 409/450/114 410/451/114 398/438/114
f 410/451/113 411/452/113 399/439/113
f 411/452/112 412/453/112 400/440/112
f 412/453/111 413/466/111 401/442/111
f 401/442/110 413/466/110 414/454/110
f 414/454/109 415/468/109 403/455/109
f 415/456/120 416/457/120 404/446/120
f 416/457/119 417/459/119 405/458/119
f 417/459/118 418/460/118 406/447/118
f 418/460/117 419/472/117 407/461/117
f 407/461/116 419/472/116 420/462/116
f 420/462/115 409/450/115 397/436/115
f 421/463/126 422/476/126 410/451/126
f 410/451/125 422/476/125 423/464/125
f 423/464/124 424/465/124 412/453/124
f 424/465/123 425/480/123 413/466/123
f 413/466/122 425/480/122 426/467/122
f 426/467/121 427/482/121 415/468/121
f 427/469/132 428/470/132 416/457/132
f 428/470/131 429/485/131 417/459/131
f 417/459/130 429/485/130 430/471/130
f 430/471/129 431/473/129 419/472/129
f 431/473/128 432/474/128 420/462/128
f 432/474/127 421/463/127 409/450/127
f 433/475/138 434/477/138 422/476/138
f 434/477/137 435/491/137 423/464/137
f 423/464/136 435/491/136 436/478/136
f 424/465/135 436/478/135 437/479/135
f 437/479/134 438/495/134 426/467/134
f 426/467/133 438/495/133 439/481/133
f 439/483/144 440/484/144 428/470/144
f 440/484/143 441/486/143 429/485/143
f 441/486/142 442/487/142 430/471/142
f 442/487/141 443/488/141 431/473/141
f 443/488/140 444/489/140 432/474/140
f 444/489/139 433/475/139 421/463/139
f 433/475/150 445/503/150 446/490/150
f 446/490/149 447/492/149 435/491/149
f 447/492/148 448/493/148 436/478/148
f 448/493/147 449/494/147 437/479/147
f 449/494/146 450/496/146 438/495/146
f 450/496/145 451/509/145 439/481/145
f 451/497/156 452/511/156 440/484/156
f 440/484/155 452/511/155 453/498/155
f 441/486/154 453/498/154 454/499/154
f 454/499/153 455/500/153 443/488/153
f 455/500/152 456/501/152 444/489/152
f 456/501/151 445/503/151 433/475/151
f 457/502/162 458/504/162 446/490/162
f 458/504/161 459/505/161 447/492/161
f 459/505/160 460/506/160 448/493/160
f 460/506/159 461/507/159 449/494/159
f 461/507/158 462/521/158 450/496/158
f 450/496/157 462/521/157 463/508/157
f 463/510/168 464/512/168 452/511/168
f 464/512/167 465/525/167 453/498/167
f 453/498/166 465/525/166 466/513/166
f 454/499/165 466/513/165 467/514/165
f 467/514/164 468/515/164 456/501/164
f 468/515/163 457/502/163 445/503/163
f 469/516/174 470/517/174 458/504/174
f 470/517/173 471/518/173 459/505/173
f 471/518/172 472/519/172 460/506/172
f 472/519/171 473/520/171 461/507/171
f 473/520/170 474/522/170 462/521/170
f 474/522/169 475/534/169 463/508/169
f 475/523/180 476/524/180 464/512/180
f 476/524/179 477/526/179 465/525/179
f 477/526/178 478/538/178 466/513/178
f 466/513/177 478/538/177 479/527/177
f 467/514/176 479/527/176 480/528/176
f 480/528/175 469/516/175 457/502/175
f 481/529/186 482/530/186 470/517/186
f 482/530/185 483/542/185 471/518/185
f 471/518/184 483/542/184 484/531/184
f 472/519/183 484/531/183 485/532/183
f 485/532/182 486/533/182 474/522/182
f 486/533/181 487/547/181 475/534/181
f 487/535/192 488/536/192 476/524/192
f 488/536/191 489/537/191 477/526/191
f 489/537/190 490/539/190 478/538/190
f 490/539/189 491/540/189 479/527/189
f 491/540/188 492/553/188 480/528/188
f 480/528/187 492/553/187 481/529/187
f 481/529/198 493/554/198 494/541/198
f 494/541/197 495/543/197 483/542/197
f 495/543/196 496/544/196 484/531/196
f 496/544/195 497/545/195 485/532/195
f 497/545/194 498/546/194 486/533/194
f 498/546/193 499/559/193 487/547/193
f 499/548/204 500/549/204 488/536/204
f 500/549/203 501/550/203 489/537/203
f 501/550/202 502/551/202 490/539/202
f 502/551/201 503/564/201 491/540/201
f 491/540/200 503/564/200 504/552/200
f 504/552/199 493/554/199 481/529/199
f 493/554/210 505/566/210 506/555/210
f 506/555/209 507/568/209 495/543/209
f 495/543/208 507/568/208 508/556/208
f 496/544/207 508/556/207 509/557/207
f 497/545/206 509/557/206 510/558/206
f 510/558/205 511/572/205 499/559/205
f 511/560/216 512/561/216 500/549/216
f 512/561/215 513/562/215 501/550/215
f 513/562/214 514/563/214 502/551/214
f 514/563/213 515/576/213 503/564/213
f 503/564/212 515/576/212 516/565/212
f 516/565/211 505/566/211 493/554/211
f 505/566/222 517/580/222 518/567/222
f 518/567/221 519/582/221 507/568/221
f 507/568/220 519/582/220 520/569/220
f 520/569/219 521/570/219 509/557/219
f 521/570/218 522/571/218 510/558/218
f 522/571/217 523/587/217 511/572/217
f 523/573/228 524/589/228 512/561/228
f 512/561/227 524/589/227 525/574/227
f 513/562/226 525/574/226 526/575/226
f 526/575/225 527/577/225 515/576/225
f 527/577/224 528/578/224 516/565/224
f 528/578/223 517/580/223 505/566/223
f 529/579/234 530/581/234 518/567/234
f 530/581/233 531/583/233 519/582/233
f 531/583/232 532/584/232 520/569/232
f 532/584/231 533/585/231 521/570/231
f 533/585/230 534/586/230 522/571/230
f 534/586/229 535/598/229 523/587/229
f 535/588/240 536/600/240 524/589/240
f 524/589/239 536/600/239 537/590/239
f 537/590/238 538/591/238 526/575/238
f 538/591/237 539/604/237 527/577/237
f 527/577/236 539/604/236 540/592/236
f 540/592/235 529/579/235 517/580/235
f 541/593/246 542/594/246 530/581/246
f 542/594/245 543/609/245 531/583/245
f 531/583/244 543/609/244 544/595/244
f 544/595/243 545/596/243 533/585/243
f 545/596/242 546/597/242 534/586/242
f 546/597/241 547/614/241 535/598/241
f 547/599/252 548/601/252 536/600/252
f 548/601/251 549/602/251 537/590/251
f 549/602/250 550/603/250 538/591/250
f 550/603/249 551/605/249 539/604/249
f 551/605/248 552/606/248 540/592/248
f 552/606/247 541/593/247 529/579/247
f 553/607/258 554/608/258 542/594/258
f 554/608/257 555/610/257 543/609/257
f 555/610/256 556/611/256 544/595/256
f 556/611/255 557/612/255 545/596/255
f 557/612/254 558/613/254 546/597/254
f 558/613/253 559/625/253 547/614/253
f 559/615/264 560/627/264 548/601/264
f 548/601/263 560/627/263 561/616/263
f 561/616/262 562/617/262 550/603/262
f 562/617/261 563/618/261 551/605/261
f 563/618/260 564/619/260 552/606/260
f 564/619/259 553/607/259 541/593/259
f 553/607/270 565/632/270 566/620/270
f 554/608/269 566/620/269 567/621/269
f 555/610/268 567/621/268 568/622/268
f 568/622/267 569/623/267 557/612/267
f 569/623/266 570/633/266 558/613/266
f 558/613/265 570/633/265 571/624/265
f 571/626/276 572/628/276 560/627/276
f 572/628/275 573/634/275 561/616/275
f 561/616/274 573/634/274 574/629/274
f 574/629/273 575/630/273 563/618/273
f 575/630/272 576/631/272 564/619/272
f 576/631/271 565/632/271 553/607/271
f 1/3/282 2/2/282 566/620/282
f 2/2/281 3/5/281 567/621/281
f 3/5/280 4/6/280 568/622/280
f 4/6/279 5/8/279 569/623/279
f 5/8/278 6/10/278 570/633/278
f 6/10/277 7/12/277 571/624/277
f 571/626/288 7/15/288 8/14/288
f 8/14/287 9/17/287 573/634/287
f 9/17/286 10/19/286 574/629/286
f 10/19/285 11/21/285 575/630/285
f 575/630/284 11/21/284 12/23/284
f 576/631/283 12/23/283 1/3/283

```

`Engine/CMakeLists.txt`:

```txt

INCLUDE(DefineModule)
INCLUDE(CompileShaders)
INCLUDE(SetSourceGroups)

SET(_target ToonEngine)

DEFINE_MODULE(${_target} ENGINE)

TARGET_LINK_LIBRARIES(
    ${_target}
    PUBLIC
        glm::glm
        GSL::GSL
        nlohmann_json::nlohmann_json
        cflags::cflags
        ${CMAKE_DL_LIBS}
)

###
### Shader Processing
###

FILE(
    GLOB_RECURSE
    _shaders_in
    Assets/Shaders/*.glsl
    #Assets/Shaders/*.hlsl
)

LIST(APPEND TOON_ASSET_PATH
    ${CMAKE_CURRENT_SOURCE_DIR}/Assets
    ${CMAKE_CURRENT_BINARY_DIR}/Assets
)

SET(TOON_ASSET_PATH ${TOON_ASSET_PATH} PARENT_SCOPE)

COMPILE_SHADERS("${_shaders_in}" _shaders_out)

TARGET_SOURCES(
    ${_target}
    PRIVATE
        ${_shaders_in}
        ${_shaders_out}
)

SET_SOURCE_GROUPS(${CMAKE_CURRENT_SOURCE_DIR} "${_shaders_in}")
SET_SOURCE_GROUPS(${CMAKE_CURRENT_BINARY_DIR} "${_shaders_out}")
```

`Engine/Private/AxisComponent.cpp`:

```cpp
#include "Toon/AxisComponent.hpp"

#include <Toon/GraphicsDriver.hpp>
#include <Toon/Entity.hpp>

namespace Toon {

// TOON_ENGINE_API
// AxisPrimitiveData AxisComponent::_PrimitiveData;

TOON_ENGINE_API
AxisComponent::AxisComponent()
{
    auto gfx = GetGraphicsDriver();

    _shader = gfx->CreateShader();
    _shader->LoadFromFiles({
        "Toon/axis.vert",
        "Toon/axis.frag",
    });

    _mesh = gfx->CreateMesh();
    // _mesh->Load(&_PrimitiveData);
    // TODO: Make GL_LINES
}

TOON_ENGINE_API
void AxisComponent::Render(RenderContext * ctx)
{
    //auto gfx = GetGraphicsDriver();
    auto transformData = ctx->GetShaderTransform();

    transformData->Model = GetEntity()->GetWorldTransform();
    transformData->UpdateMVP();
    
    // gfx->SetShaderData("ToonTransformData", sizeof(TransformData), transformData);

    // _shader->Bind();
    // _mesh->Render();
}

} // namespace Toon
```

`Engine/Private/Buffer.cpp`:

```cpp
#include <Toon/Buffer.hpp>
#include <Toon/Log.hpp>

#include <Toon/String.hpp>
#include <cstring>

namespace Toon {

TOON_ENGINE_API
bool Buffer::ReadFrom(size_t offset, size_t length, uint8_t * data)
{
    if (_memoryUsage != MemoryUsage::Download) {
        ToonLogError("Unable to read data from buffer with MemoryUsage: %s",
            MemoryUsageToString(_memoryUsage));
        return false;
    }

    if (!_mappedBufferMemory) {
        ToonLogError("Buffer is not mapped for reading");
        return false;
    }

    memcpy(data, _mappedBufferMemory, length);

    return true;
}

TOON_ENGINE_API
bool Buffer::WriteTo(size_t offset, size_t length, uint8_t * data)
{
    if (_memoryUsage != MemoryUsage::UploadOnce && _memoryUsage != MemoryUsage::UploadOften) {
        ToonLogError("Unable to write data to buffer with MemoryUsage: %s",
            MemoryUsageToString(_memoryUsage));
        return false;
    }

    if (!_mappedBufferMemory) {
        ToonLogError("Buffer is not mapped for writing");
        return false;
    }

    memcpy(_mappedBufferMemory, data, length);

    return true;
}

} // namespace Toon
```

`Engine/Private/Camera.cpp`:

```cpp
#include <Toon/Camera.hpp>

#include <Toon/GraphicsDriver.hpp>

namespace Toon {

TOON_ENGINE_API
Camera::Camera()
{
    auto gfx = GetGraphicsDriver();

    const glm::ivec2& size = gfx->GetWindowSize();
    SetAspect(size);
    SetViewportSize(size);

    _windowResizedEventHandlerID = gfx->WindowResizedEvent.AddListener(
        [=](const WindowResizedEventData * data) {
            SetAspect(data->Size);
            SetViewportSize(data->Size);
        }
    );
}

TOON_ENGINE_API
Camera::~Camera()
{
    auto gfx = GetGraphicsDriver();
    //gfx->WindowResizedEvent.RemoveListener(_windowResizedEventHandlerID);
}

TOON_ENGINE_API
glm::mat4 Camera::GetView() const
{
    return glm::lookAt(GetWorldPosition(), GetWorldPosition() + GetForward(), GetUp());
}

TOON_ENGINE_API
glm::mat4 Camera::GetProjection() const
{
    if (_mode == CameraMode::Perspective)
    {
        return glm::perspective(_fovX, _aspect, _clip[0], _clip[1]);
    }
    else if (_mode == CameraMode::Orthographic)
    {
        const auto& view = GetViewport();
        return glm::ortho(view[0], view[1], view[2], view[3], _clip[0], _clip[1]);
    }

    return glm::mat4(1.0f);
}

TOON_ENGINE_API
void Camera::SetMode(CameraMode mode)
{
    _mode = mode;
}

TOON_ENGINE_API
void Camera::SetClip(const glm::vec2& clip)
{
    _clip = clip;
}

TOON_ENGINE_API
void Camera::SetUp(const glm::vec3& up)
{
    _up = up;
}

TOON_ENGINE_API
void Camera::SetForward(const glm::vec3& forward)
{
    if ((normalize(forward) + _up) == glm::vec3(0.0f))
    {
        SetOrientation(glm::angleAxis(glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f)));
    }
    else
    {
        SetOrientation(glm::quatLookAt(glm::normalize(forward), _up));
    }
}

TOON_ENGINE_API
glm::vec3 Camera::GetForward() const
{
    return glm::rotate(GetWorldOrientation(), GetWorldForward());
}

TOON_ENGINE_API
glm::vec3 Camera::GetRight() const
{
    return glm::normalize(glm::cross(GetForward(), GetUp()));
}

TOON_ENGINE_API
void Camera::SetAspect(float aspect)
{
    _aspect = aspect;
}

TOON_ENGINE_API
void Camera::SetAspect(const glm::vec2& size)
{
    _aspect = size.x / size.y;
}

TOON_ENGINE_API
void Camera::SetFOVX(float fovx)
{
    _fovX = fovx;
}

TOON_ENGINE_API
void Camera::SetFOVY(float fovy)
{
    _fovX = 2.0f * atanf(tanf(fovy * 0.5f) * _aspect);
}

TOON_ENGINE_API
void Camera::SetLookAt(const glm::vec3& point)
{
    SetForward(point - GetPosition());
}

TOON_ENGINE_API
void Camera::SetViewportSize(const glm::vec2& viewSize)
{
    _viewportSize = viewSize;
}

TOON_ENGINE_API
void Camera::SetViewportScale(const glm::vec4& viewScale)
{
    _viewportScale = viewScale;
}

TOON_ENGINE_API
glm::vec4 Camera::GetViewport() const
{
    glm::vec4 scale = GetViewportScale();
    glm::vec2 size = GetViewportSize();

    if (_aspect > 1.0f) {
        size.y /= _aspect;
    }
    else {
        size.x *= _aspect;
    }

    return glm::vec4(
        size.x * scale[0],
        size.x * scale[1],
        size.y * scale[2],
        size.y * scale[3]);
}


TOON_ENGINE_API
void Camera::SetDirection(glm::vec3 dir)
{
    _direction = dir;
}

TOON_ENGINE_API
void Camera::HandleMovement(float dt)
{
    float velocity = _movementSpeed * dt;

    glm::vec3 right = glm::normalize(glm::cross(_up, GetForward()));

    auto pos = GetPosition();

    _direction = glm::vec3(0.0f, 0.0f, 1.0f);//GetWorldForward();//glm::axisAngle(GetWorldForward(), GetWorldOrientation());

    pos += glm::normalize(glm::cross(GetForward(), _up)) * velocity * _direction.x;
    pos += glm::normalize(glm::cross(GetForward(), right)) * velocity * _direction.y;
    pos += GetForward() * velocity * _direction.z;

    SetPosition(pos);
}

TOON_ENGINE_API
void Camera::HandleRotation(float deltaX, float deltaY)
{
    glm::vec2 delta(deltaX, deltaY);

    delta *= _rotateSpeed;
    delta.x *= -1.0f;

    if (_invserse)
        delta.y *= -1.0f;

    glm::vec3 forward = GetForward();
    glm::vec3 right = glm::normalize(glm::cross(GetWorldUp(), forward));
    SetUp(glm::cross(forward, right));

    glm::quat rotation = GetOrientation();
    rotation = glm::angleAxis(delta.x, GetUp()) * rotation;
    rotation = glm::angleAxis(delta.y, GetRight()) * rotation;
    SetOrientation(rotation);
}

} // namespace Toon
```

`Engine/Private/Collision.cpp`:

```cpp
#include "Toon/Collision.hpp"

Collision::Collision()
{

}
```

`Engine/Private/Entity.cpp`:

```cpp
#include <Toon/Entity.hpp>

#include <Toon/SceneImporter.hpp>

namespace Toon {

TOON_ENGINE_API
bool Entity::LoadFromFile(const string& filename)
{
    const auto& importers = GetAllSceneImporters();
    for (const auto& importer : importers) {
        if (importer->LoadFromFile(this, filename)) {
            return true;
        }
    }
    return false;
}

TOON_ENGINE_API
void Entity::SetParent(Entity * parent)
{
    _parent = parent;
}

TOON_ENGINE_API
Entity * Entity::AddChild(std::unique_ptr<Entity> && child)
{
    child->SetParent(this);
    _childPtrs.push_back(child.get());
    _children.push_back(std::move(child));

    return _childPtrs.back();
}

TOON_ENGINE_API
std::vector<Entity *> Entity::GetChildren() const
{
    return _childPtrs;
}

TOON_ENGINE_API
Component * Entity::AddComponent(std::unique_ptr<Component> && component)
{
    component->Attach(this);
    _componentPtrs.push_back(component.get());
    _components.push_back(std::move(component));

    return _componentPtrs.back();
}

TOON_ENGINE_API
std::vector<Component *> Entity::GetComponents() const
{
    return _componentPtrs;
}

TOON_ENGINE_API
void Entity::SetName(const string& name)
{
    _name = name;
}

TOON_ENGINE_API
void Entity::SetPosition(const glm::vec3& position)
{
    _position = position;
}

TOON_ENGINE_API
void Entity::SetOrientation(const glm::quat& orientation)
{
    _orientation = orientation;
}

TOON_ENGINE_API
void Entity::SetScale(const glm::vec3& scale)
{
    _scale = scale;
}

TOON_ENGINE_API
glm::mat4 Entity::GetTransform() const
{
    glm::mat4 transform = glm::mat4(1.0f);
    transform = glm::translate(transform, GetPosition());
    transform *= glm::mat4_cast(GetOrientation());
    transform = glm::scale(transform, GetScale());
    return transform;
}

TOON_ENGINE_API
glm::vec3 Entity::GetWorldPosition() const
{
    if (_parent) {
        return _parent->GetWorldPosition() + GetPosition();
    }
    return GetPosition();
}

TOON_ENGINE_API
glm::quat Entity::GetWorldOrientation() const
{
    if (_parent) {
        return _parent->GetWorldOrientation() * GetOrientation();
    }
    return GetOrientation();
}

TOON_ENGINE_API
glm::vec3 Entity::GetWorldScale() const
{
    if (_parent) {
        return _parent->GetWorldScale() * GetScale();
    }
    return GetScale();
}

TOON_ENGINE_API
glm::mat4 Entity::GetWorldTransform() const
{
    if (_parent) {
        return _parent->GetWorldTransform() * GetTransform();
    }
    return GetTransform();
}

TOON_ENGINE_API
void Entity::Update(UpdateContext * ctx)
{
    // Check if enabled
    if (!_mEnabled) {
        return;
    }

    for (auto& comp : _components) {
        comp->Update(ctx);
    }

    for (auto& child : _children) {
        child->Update(ctx);
    }
}

TOON_ENGINE_API
void Entity::Render(RenderContext * ctx)
{
    // Check for visibility
    if (!_mVisibility) {
        return;
    }

    for (auto& comp : _components) {
        comp->Render(ctx);
    }
    
    for (auto& child : _children) {
        child->Render(ctx);
    }
}

TOON_ENGINE_API
Entity* Entity::FindEntity(std::string name)
{
    for (auto& entity : _children)
    {
        if (entity->GetName() == name)
        {
            return entity.get();
        }
    }

    for (auto& entity : _children)
    {
        auto tmp = entity->FindEntity(name);
        if (tmp)
        {
            return tmp;
        }
    }

    return nullptr;
}

} // namespace Toon
```

`Engine/Private/Event.cpp`:

```cpp
#include <Toon/Event.hpp>

#include <Toon/Log.hpp>

//unsigned ScriptEvent::AddPythonListener(PyObject* listener)
//{
//    if (!PyCallable_Check(listener)) {
//        ToonLogError("PyObject not callable");
//        return 0;
//    }
//
//    ++_mMaxPythonListenerID;
//    Py_INCREF(listener);
//    _mPythonListeners.emplace(_mMaxPythonListenerID, listener);
//
//    return _mMaxPythonListenerID;
//}
//
//bool ScriptEvent::RemovePythonListener(PyObject* listener)
//{
//    auto it = _mPythonListeners.begin();
//    while (it != _mPythonListeners.end()) {
//        if (it->second == listener) {
//            break;
//        }
//    }
//
//    if (it != _mPythonListeners.end()) {
//        _mPythonListeners.erase(it);
//        return true;
//    }
//
//    return false;
//}

// bool ScriptEvent::RemovePythonListener(unsigned id)
// {
//     auto it = _mPythonListeners.find(id);

//     if (it != _mPythonListeners.end()) {
//        _nPythonListeners.erase(it);
//        return true;
//     }

//     return false;
// }

// void ScriptEvent::CallPython(const EventData * data)
// {
//     PyObject* dict = data->GetPyObject();
//     PyObject* arg = Py_BuildValue("(O)", dict);

//     ToonLogInfo("Calling Python Listeners");
//     for (const auto& it : _mPythonListeners) {
//        PyObject* result = PyEval_CallObject(it.second, arg);
//        if (!result) {
//            ToonLogError("Failed to call Python Event Listener");
//            PyPrintStackTrace();
//        }
//     }

//     Py_DECREF(arg);
//     Py_DECREF(dict);
// }

// void ScriptEvent::RemoveAllPythonListeners()
// {
//     for (const auto& it : _mPythonListeners) {
//        Py_DECREF(it.second);
//     }
//     _mPythonListeners.clear();
// }
```

`Engine/Private/GraphicsDriver.cpp`:

```cpp
#include <Toon/GraphicsDriver.hpp>
#include <Toon/Log.hpp>

namespace Toon {

static std::unique_ptr<GraphicsDriver> _GraphicsDriver(nullptr);

TOON_ENGINE_API
void GraphicsDriver::InitializeUpdateContext()
{
    if (!_updateContext) {
        _updateContext.reset(new UpdateContext());
    }

    _updateContext->SetTargetFPS(60.0f);
    _updateContext->ResetTime();
}

TOON_ENGINE_API
void GraphicsDriver::InitializeRenderContext()
{
    if (!_renderContext) {
        _renderContext.reset(new RenderContext());
    }

    auto globals = _renderContext->GetShaderGlobals();
    globals->Resolution = GetWindowSize();
    globals->Mouse = {0, 0};
    globals->FrameCount = 0;
    globals->TotalTime = 0;
    globals->FrameSpeedRatio = 0.0f;
    globals->LightCount = 0;

    auto transform = _renderContext->GetShaderTransform();
    transform->Model = glm::mat4(1.0f);
    transform->View = glm::mat4(1.0f);
    transform->Projection = glm::mat4(1.0f);
    transform->MVP = glm::mat4(1.0f);
}

TOON_ENGINE_API
bool GraphicsDriver::InitializeConstantBuffers()
{
    bool result;

    _shaderGlobalsBuffer = CreateBuffer();
    result = _shaderGlobalsBuffer->Initialize(
        sizeof(ShaderGlobals),
        nullptr,
        BufferUsage::Constant,
        MemoryUsage::UploadOften
    );

    return result;
}

TOON_ENGINE_API
bool GraphicsDriver::InitializeDefaults()
{
    uint8_t pixel[4] = { 255, 255, 255, 255 };
    std::unique_ptr<TextureData> textureData(new ConstantTextureData(
        pixel, uvec2(1, 1), 4, TextureDataType::UnsignedByte
    ));

    _defaultTexture = CreateTexture();
    if (!_defaultTexture->Load(textureData, Texture::Options())) {
        ToonLogError("Failed to create default texture");
        return false;
    }

    _defaultMaterial = CreateMaterial();
    _defaultMaterial->Initialize();

    auto shader = CreateShader();
    if (!shader->LoadFromFiles({
        "Toon/Default.vert",
        "Toon/Default.frag",
    })) {
        ToonLogError("Failed to create default shader");
        return false;
    }

    _defaultPipeline = CreatePipeline(shader);

    return true;
}

TOON_ENGINE_API
void GraphicsDriver::Render()
{
    UpdateContext * updateCtx = GetUpdateContext();

    // Update FPS
    _fpsUpdateElapsedTime += updateCtx->GetPreviousFrameDuration();
    if (_fpsUpdateFrameCount >= updateCtx->GetTargetFPS()) {
        float currentFPS = (float)_fpsUpdateFrameCount / (float)_fpsUpdateElapsedTime.count();
        currentFPS *= 1000000.0f; // Microseconds -> Seconds

        char buffer[32];
        snprintf(buffer, sizeof(buffer), "%.2f FPS", currentFPS);
        UpdateWindowTitle(_windowTitle + " - " + buffer); // FIX

        _fpsUpdateElapsedTime = 0ms;
        _fpsUpdateFrameCount = 0;
    }

    ++_fpsUpdateFrameCount;

    auto input = GetInputDriver();

    auto globals = _renderContext->GetShaderGlobals();
    globals->Resolution = GetWindowSize();
    globals->Mouse = input->GetMouseCoordinates();
    ++globals->FrameCount;
    globals->TotalTime = (float)_updateContext->GetTotalDuration().count() / 100.0f;
    globals->FrameSpeedRatio = _updateContext->GetFrameSpeedRatio();

    _shaderGlobalsBuffer->WriteTo(0, sizeof(ShaderGlobals), reinterpret_cast<uint8_t *>(globals));
}

TOON_ENGINE_API
UpdateContext * GraphicsDriver::GetUpdateContext()
{
    return _updateContext.get();
}

TOON_ENGINE_API
RenderContext * GraphicsDriver::GetRenderContext()
{
    return _renderContext.get();
}

// PyObject * WindowResizedEventData::GetPyObject() const
// {
//     PyObject * dict = PyDict_New();

//     PyObject * size = PyTuple_New(2);
//     PyTuple_SET_ITEM(size, 0, PyLong_FromLong(Size.x));
//     PyTuple_SET_ITEM(size, 1, PyLong_FromLong(Size.y));
//     PyDict_SetItemString(dict, "Size", size);

//     return dict;
// }

TOON_ENGINE_API 
void SetGraphicsDriver(std::unique_ptr<GraphicsDriver> && driver)
{
    if (_GraphicsDriver) {
        _GraphicsDriver->Terminate();
    }
    _GraphicsDriver = std::move(driver);
}

TOON_ENGINE_API 
GraphicsDriver * GetGraphicsDriver()
{
    return _GraphicsDriver.get();
}

} // namespace Toon
```

`Engine/Private/InputDriver.cpp`:

```cpp
#include <Toon/InputDriver.hpp>

namespace Toon {

static std::unique_ptr<InputDriver> _InputDriver(nullptr);

TOON_ENGINE_API
void SetInputDriver(std::unique_ptr<InputDriver> && driver)
{
    _InputDriver = std::move(driver);
}

TOON_ENGINE_API
InputDriver * GetInputDriver()
{
    return _InputDriver.get();
}

} // namespace Toon

```

`Engine/Private/Light.cpp`:

```cpp
#include <Toon/Light.hpp>

namespace Toon {

void Light::SetType(LightType type)
{
    _type = type;
}

void Light::FillLightData(LightData1 * data)
{
    data->Type = static_cast<uint8_t>(_type);
    data->Position = GetPosition();
    data->Direction = GetOrientation() * GetWorldForward();
    data->Color = _color;
    data->InnerCutOff = _innerCutOff;
    data->OuterCutOff = _outerCutOff;
}

void Light::SetColor(glm::vec3 color)
{
    _color = color;
}

void Light::SetInnerCutOff(float cutOff)
{
    _innerCutOff = cutOff;
}

void Light::SetOuterCutOff(float cutOff)
{
    _outerCutOff = cutOff;
}

} // namespace Toon
```

`Engine/Private/Log.cpp`:

```cpp
#include <Toon/Log.hpp>

namespace Toon {

static std::vector<FILE *> _LogFiles;

TOON_ENGINE_API
bool AddLogFile(const string& filename)
{
    FILE * file = nullptr;
    file = fopen(filename.c_str(), "wt");
    if (file) {
        _LogFiles.push_back(file);
        ToonLogVerbose("Adding log file '%s'", filename);
        return true;
    }

    ToonLogError("Failed to add log file '%s'", filename);
    return false;
}

TOON_ENGINE_API
std::vector<FILE *> GetAllLogFiles()
{
    return _LogFiles;
}

TOON_ENGINE_API
void CloseAllLogFiles()
{
    for (FILE * file : _LogFiles) {
        fclose(file);
    }
    _LogFiles.clear();
}

} // namespace Toon
```

`Engine/Private/Material.cpp`:

```cpp
#include <Toon/Material.hpp>
#include <Toon/GraphicsDriver.hpp>

namespace Toon {

void Material::Initialize()
{
    auto gfx = GetGraphicsDriver();

    _shaderMaterialBuffer = gfx->CreateBuffer();
    bool result = _shaderMaterialBuffer->Initialize(
        sizeof(ShaderMaterial),
        nullptr,
        BufferUsage::Constant,
        MemoryUsage::UploadOften
    );

    // TODO:
    (void)(result);

    UpdateBuffer();
}

void Material::Terminate()
{
    if (_shaderMaterialBuffer) {
        _shaderMaterialBuffer->Terminate();
        _shaderMaterialBuffer.reset();
    }
}

void Material::UpdateBuffer()
{
    if (_shaderMaterialBuffer) {
        uint8_t * data = reinterpret_cast<uint8_t *>(&_shaderMaterial);
        _shaderMaterialBuffer->WriteTo(0, sizeof(ShaderMaterial), data);
    }
}

} // namespace Toon
```

`Engine/Private/Mesh.cpp`:

```cpp
#include <Toon/Mesh.hpp>
#include <Toon/MeshImporter.hpp>
#include <Toon/GraphicsDriver.hpp>
#include <Toon/Log.hpp>
#include <Toon/Benchmark.hpp>

namespace Toon {

TOON_ENGINE_API
bool Mesh::Initialize()
{
    bool result = true;

    GraphicsDriver* gfx = GetGraphicsDriver();

    _pipeline = gfx->GetDefaultPipeline();

    _shaderTransformBuffer = gfx->CreateBuffer();
    result = _shaderTransformBuffer->Initialize(
        sizeof(ShaderTransform),
        nullptr,
        BufferUsage::Constant,
        MemoryUsage::UploadOften
    );

    return result;
}

TOON_ENGINE_API
void Mesh::Terminate()
{
    if (_shaderTransformBuffer) {
        _shaderTransformBuffer->Terminate();
        _shaderTransformBuffer.reset();
    }
}

TOON_ENGINE_API
bool Mesh::Load(const std::vector<std::unique_ptr<PrimitiveData>>& data)
{
    GraphicsDriver * gfx = GetGraphicsDriver();
    
    for (const auto& primitiveData : data) {
        auto primitive = gfx->CreatePrimitive();
        if (!primitive || !primitive->Load(primitiveData)) {
            return false;
        }
        _primitiveList.push_back(std::move(primitive));
    }
    
    return true;
}

TOON_ENGINE_API
std::shared_ptr<Mesh> LoadMeshFromFile(const string& filename)
{
    ToonBenchmarkStart();
    GraphicsDriver * gfx = GetGraphicsDriver();

    const auto& importers = GetAllMeshImporters();
    for (const auto& importer : importers) {
        const auto& primitiveList = importer->LoadFromFile(filename);
        if (primitiveList.empty()) {
            continue;
        }

        auto mesh = gfx->CreateMesh();
        if (!mesh->Load(primitiveList)) {
            break;
        }

        return mesh;
    }

    ToonLogError("Failed to load mesh '%s'", filename);
    ToonBenchmarkEnd();
    return nullptr;
}

TOON_ENGINE_API
void Mesh::Render(RenderContext * ctx)
{
    if (_shaderTransformBuffer) {
        uint8_t * data = reinterpret_cast<uint8_t *>(ctx->GetShaderTransform());
        _shaderTransformBuffer->WriteTo(0, sizeof(ShaderTransform), data);
    }
}

} // namespace Toon
```

`Engine/Private/MeshComponent.cpp`:

```cpp
#include <Toon/MeshComponent.hpp>
#include <Toon/MeshImporter.hpp>
#include <Toon/GraphicsDriver.hpp>
#include <Toon/Entity.hpp>
#include <Toon/Log.hpp>

namespace Toon {

TOON_ENGINE_API
MeshComponent::MeshComponent(std::shared_ptr<Mesh> mesh)
{
    SetMesh(mesh);
}

TOON_ENGINE_API
void MeshComponent::SetMesh(std::shared_ptr<Mesh> mesh)
{
    _mesh = mesh;
}

TOON_ENGINE_API
void MeshComponent::Render(RenderContext * ctx)
{
    auto gfx = GetGraphicsDriver();
    auto transformData = ctx->GetShaderTransform();

    transformData->Model = GetEntity()->GetWorldTransform();
    transformData->UpdateMVP();

    _mesh->Render(ctx);
}

} // namespace Toon
```

`Engine/Private/MeshImporter.cpp`:

```cpp
#include <Toon/MeshImporter.hpp>

#include <unordered_map>

namespace Toon {

static std::unordered_map<string, std::unique_ptr<MeshImporter>> _MeshImporters;

static std::vector<MeshImporter*> _MeshImporterList;

void updateMeshImporterList()
{
    _MeshImporterList.clear();
    for (const auto& it : _MeshImporters) {
        _MeshImporterList.push_back(it.second.get());
    }
}

TOON_ENGINE_API
void AddMeshImporter(const string& id, std::unique_ptr<MeshImporter> importer)
{
    _MeshImporters[id] = std::move(importer);
    updateMeshImporterList();
}

TOON_ENGINE_API
void RemoveMeshImporter(const string& id)
{
    auto it = _MeshImporters.find(id);
    if (it != _MeshImporters.end()) {
        _MeshImporters.erase(it);
    }

    updateMeshImporterList();
}

TOON_ENGINE_API
const std::vector<MeshImporter*>& GetAllMeshImporters()
{
    return _MeshImporterList;
}

} // namespace Toon
```

`Engine/Private/Module.cpp`:

```cpp
#include <Toon/Module.hpp>
#include <Toon/Log.hpp>

#if defined(TOON_PLATFORM_WINDOWS)
    typedef HMODULE ModuleHandle;
#else
    #include <dlfcn.h>
    typedef void * ModuleHandle;
#endif

#include <unordered_map>

namespace Toon {

std::unordered_map<string, ModuleHandle> _gModules;

ModuleHandle _dlopen(const string& filename)
{
    ModuleHandle handle = nullptr;

    #if defined(TOON_PLATFORM_WINDOWS)

        ToonLogVerbose("Loading Module from PATH: '%s'", getenv("PATH"));

        handle = LoadLibraryA(filename.c_str());
        if (!handle) {
            //WindowsErrorMessage msg(HRESULT_FROM_WIN32(GetLastError()));
            //ToonLogError("Failed to load '%s', %s", filename, msg);
            return nullptr;
        }
        
    #else

        ToonLogVerbose("Loading Module from LD_LIBRARY_PATH: '%s'", getenv("LD_LIBRARY_PATH"));

        #if defined(TOON_PLATFORM_APPLE)

            string libFilename = "lib" + filename + ".dylib";

        #else

            string libFilename = "lib" + filename + ".so";

        #endif

        handle = dlopen(libFilename.c_str(), RTLD_GLOBAL | RTLD_NOW);
        if (!handle) {
            ToonLogError("Failed to load '%s', %s", libFilename, dlerror());
            return nullptr;
        }

    #endif

    return handle;
}

void * _dlsym(ModuleHandle handle, const string& symbol)
{
    #if defined(TOON_PLATFORM_WINDOWS)

        return GetProcAddress(handle, symbol.c_str());

    #else

        return dlsym(handle, symbol.c_str());

    #endif
}

void _dlclose(ModuleHandle handle)
{
    #if defined(TOON_PLATFORM_WINDOWS)

        FreeLibrary(handle);

    #else

        dlclose(handle);

    #endif
}

bool LoadModule(const string& name)
{
    ToonLogLoad("Loading module '%s'", name);

    ModuleHandle handle = _dlopen(name);
    if (!handle) {
        return false;
    }

    ToonModule * def = static_cast<ToonModule *>(_dlsym(handle, "_ToonModule"));

    if (!def) {
        ToonLogError("Failed to find _Module symbol");
        return false;
    }

    if (def->Initialize) {
        if (!def->Initialize()) {
            _dlclose(handle);

            ToonLogError("Failed to initialize module '%s'", name);
            return false;
        }
    }

    _gModules.emplace(name, handle);

    return true;
}

void FreeModule(const string& name)
{
    auto it = _gModules.find(name);
    if (it == _gModules.end()) {
        ToonLogWarn("Failed to free module '%s', module is not loaded", name);
        return;
    }

    ModuleHandle handle = it->second;
    ToonModule * def = static_cast<ToonModule *>(_dlsym(handle, "_ToonModule"));

    if (def && def->Terminate) {
        def->Terminate();
    }

    _dlclose(handle);

    _gModules.erase(it);
}

void FreeAllModules()
{
    for (const auto& it : _gModules) {
        ModuleHandle handle = it.second;
        ToonModule * def = static_cast<ToonModule *>(_dlsym(handle, "_ToonModule"));
        if (def && def->Terminate) {
            def->Terminate();
        }

        _dlclose(handle);
    }

    _gModules.clear();
}

}
```

`Engine/Private/Path.cpp`:

```cpp
#include <Toon/Path.hpp>

#include <algorithm>
#include <cstdio>
#include <climits>
#include <sstream>

#if defined(TOON_PLATFORM_WINDOWS)

    #include <direct.h>

#else

    #include <unistd.h>

#endif

namespace Toon {

TOON_ENGINE_API
Path::Path(const Path& rhs)
    : _path(rhs._path)
{ }

TOON_ENGINE_API
Path::Path(const string& str)
    : _path(str)
{
    Normalize();
}

TOON_ENGINE_API
Path::Path(const char * cstr)
    : _path(cstr)
{
    Normalize();
}

Path& Path::Append(const Path& rhs)
{
    // If path is empty, and doesn't have a trailing separator, append one
    if (rhs._path.empty()) {
        if (!_path.empty() && _path.back() != Separator) {
            _path += Separator;
        }
        return *this;
    }

    if (IsAbsolute() && rhs.IsAbsolute() && GetRootPath() != rhs.GetRootPath()) {
        // Unable to append absolute paths
        _path = rhs._path;
        return *this;
    }


    if (_path.back() != Separator) {
        _path += Separator;
    }

    _path += rhs._path;
    return *this;
}

Path& Path::Concatenate(const Path& path)
{
    _path += path._path;
    return *this;
}

bool Path::Equals(const Path& rhs) const
{
    #if defined(TOON_PLATFORM_WINDOWS)

        return StringEqualCaseInsensitive(_path, rhs._path);

    #else

        return (_path == rhs._path);

    #endif
}

// std::vector<string> Path::GetParts() const
// {
//     std::vector<string> parts;

//     auto it = GetRootNameLength();

//     if (IsAbsolute()) {
//         parts.push_back(string(1, Separator));
//         ++it;
//     }

//     // stringstream ss(_path.substr(it));
//     std::stringstream ss(_path.data() + it);

//     string token;
//     while (getline(ss, token, Separator)) {
//         parts.push_back(token);
//     }

//     return parts;
// }

TOON_ENGINE_API
void Path::Normalize()
{
    if (_path.empty()) {
        return;
    }

    // TODO: Check valid UTF-8

    // TODO: Strip windows long filename marker "\\?\"

    #if defined(TOON_PLATFORM_WINDOWS)

        // Convert slashes to native format
        for (auto& c : _path) {
            if (c == '/') {
                c = '\\';
            }
        }

    #endif

    auto begin = _path.begin();
    auto end = _path.end();

    // Skip double slashes for paths starting like "\\server"
    if (_path.length() >= 2 && _path[0] == Separator && _path[1] == Separator) {
        begin += 2;
    }

    auto newEnd = std::unique(begin, end,
        [](char lhs, char rhs) {
            return (lhs == rhs && lhs == Separator);
        }
    );

    _path.erase(newEnd, end);
}

size_t Path::GetRootNameLength() const
{
    #if defined(TOON_PLATFORM_WINDOWS)

        // Check for windows drive letter, such as "C:"
        if (_path.length() >= 2 && _path[1] == ':') {
            char first = std::toupper(_path[0]);
            if (first >= 'A' && first <= 'Z') {
                return 2;
            }
        }

    #endif

    // Check for network path, such as "//server"
    if (_path.length() >= 3 && _path[0] == Separator && _path[1] == Separator) {
        if (_path[2] != Separator && std::isprint(_path[2])) {
            // Find first separator after server name
            size_t pos = _path.find_first_of(Separator, 3);
            if (pos == string::npos) {
                // The entire path is just a network share name
                return _path.length();
            }
            else {
                return pos;
            }
        }
    }

    // There is no root name
    return 0;
}

Path GetCurrentPath()
{
#if defined(TOON_PLATFORM_WINDOWS)

    std::unique_ptr<char> cwd(_getcwd(nullptr, 0));
    if (cwd) {
        return Path(string(cwd.get()));
    }

#else

    char cwd[PATH_MAX];
    if (getcwd(cwd, sizeof(cwd))) {
        return Path(cwd);
    }

#endif
    
    return Path();
}

} // namespace Toon
```

`Engine/Private/Primitive.cpp`:

```cpp
#include <Toon/Primitive.hpp>
#include <Toon/PrimitiveData.hpp>

#include <Toon/Log.hpp>

namespace Toon {


} // namespace Toon
```

`Engine/Private/PrimitiveData.cpp`:

```cpp
#include <Toon/PrimitiveData.hpp>

#include <Toon/Log.hpp>

namespace Toon {

void PrimitiveData::CalculateTangents()
{
    auto topology = GetTopology();
    auto indexList = GetIndexList();
    auto vertexList = GetVertexList();

    auto calcVertex = [](Vertex& v1, Vertex& v2, Vertex& v3)
    {
        glm::vec3 v = glm::vec3(v2.Position) - glm::vec3(v1.Position);
        glm::vec3 w = glm::vec3(v3.Position) - glm::vec3(v1.Position);
        glm::vec2 s = v2.TexCoord1 - v1.TexCoord1;
        glm::vec2 t = v3.TexCoord1 - v1.TexCoord1;

        float dir = 1.0f;
        if ((t.x * s.y - t.y * s.x) < 0.0f) {
            dir = -1.0f;
        }

        glm::vec3 tangent = {
        dir * (w.x * s.y - v.x * t.y),
        dir * (w.y * s.y - v.y * t.y),
        dir * (w.z * s.y - v.z * t.y),
        };

        v1.Tangent = glm::vec4(tangent - glm::vec3(v1.Normal) * (tangent * glm::vec3(v1.Normal)), 1.0f);
        v2.Tangent = glm::vec4(tangent - glm::vec3(v2.Normal) * (tangent * glm::vec3(v2.Normal)), 1.0f);
        v3.Tangent = glm::vec4(tangent - glm::vec3(v3.Normal) * (tangent * glm::vec3(v3.Normal)), 1.0f);

        v1.Tangent = glm::normalize(v1.Tangent);
        v2.Tangent = glm::normalize(v2.Tangent);
        v3.Tangent = glm::normalize(v3.Tangent);

        // TODO: Account for NaN and smoothing
    };

    if (topology == PrimitiveTopology::TriangleList) {
        if (indexList.empty()) {
            for (size_t i = 0; i < vertexList.size(); i += 3) {
                calcVertex(
                    vertexList[i + 0],
                    vertexList[i + 1],
                    vertexList[i + 2]
                );
            }
        }
        else {
            for (size_t i = 0; i < indexList.size(); i += 3) {
                calcVertex(
                    vertexList[indexList[i + 0]],
                    vertexList[indexList[i + 1]],
                    vertexList[indexList[i + 2]]
                );
            }
        }
    }
    else if (topology == PrimitiveTopology::TriangleStrip) {
        if (indexList.empty()) {
            for (size_t i = 0; i < vertexList.size(); ++i) {
                calcVertex(
                    vertexList[i + 0],
                    vertexList[i + 1],
                    vertexList[i + 2]
                );
            }
        }
        else {
            for (size_t i = 0; i < indexList.size(); ++i) {
                calcVertex(
                    vertexList[indexList[i + 0]],
                    vertexList[indexList[i + 1]],
                    vertexList[indexList[i + 2]]
                );
            }
        }
    }
}

} // namespace Toon
```

`Engine/Private/Rigidbody.cpp`:

```cpp
#include "Toon/Rigidbody.hpp"
#include "Toon/Entity.hpp"
#include <iostream>

namespace Toon {

void Rigidbody::AddForce(const glm::vec3 force)
{
    _mForce += force;
}

void Rigidbody::SetMass(const float mass)
{
    if (mass > 0.0f)
    {
        _mMassInv = 1.0f / (_mMass = mass);
    }
    else
    {
        _mMassInv = (_mMass = 0.0f);
    }
}

void Rigidbody::UpdateAcceleration()
{
    // F = ma --> a = F/m --> a = (F * mInv)
    _mAcceleration = (_mForce * _mMassInv) + _mAccelerationFixed;
    _mForce = glm::vec3(0);
}

void Rigidbody::UpdateFirstOrder(Entity* entity, const float dt)
{
    //if (_mVelocity.x > 0.01f || _mVelocity.y > 0.01f || _mVelocity.z > 0.01f)
    //{
        entity->SetPosition(entity->GetPosition() + (_mVelocity * dt));
        _mVelocity += _mAcceleration * dt;

        UpdateAcceleration();
    //}


    std::cout << "pos: " << entity->GetPosition().x << " " << entity->GetPosition().y << " " << entity->GetPosition().z << std::endl;
    std::cout << "dt: " << dt << std::endl;
    std::cout << "acc: " << _mAcceleration.x << " " << _mAcceleration.y << " " << _mAcceleration.z << std::endl;
    std::cout << "vel: " << _mVelocity.x << " " << _mVelocity.y << " " << _mVelocity.z << std::endl;
}

// clamp to ground (simple bounce): 
//    if object goes into ground, clamp it to the ground and 
//    use the remaining velocity for a bounce
void Rigidbody::ClampToGround(Entity* entity, const float groundHeight, const float restitution)
{
    if (entity->GetPosition().y < groundHeight)
    {
        if (!(entity->GetPosition().y > 0.001f))
        {
            glm::vec3 newPos = entity->GetPosition();
            newPos.y = groundHeight + (groundHeight - entity->GetPosition().y);
            entity->SetPosition(newPos);
            _mVelocity.y = (-_mVelocity.y) * restitution;
        }
        else
            entity->SetPosition(glm::vec3(entity->GetPosition().x, entity->GetPosition().y * 0, entity->GetPosition().z));

        // Rv = V - 2dot(N, v) * N
        // N is surface normal
    }
}

} // namespace Toon
```

`Engine/Private/Scene.cpp`:

```cpp
#include "Toon/Scene.hpp"

namespace Toon {

static Toon::Scene * _CurrentScene = nullptr;

TOON_ENGINE_API
System * Scene::AddSystem(std::unique_ptr<System> && sys)
{
    _systemPtrs.push_back(sys.get());
    _systems.push_back(std::move(sys));

    return _systemPtrs.back();
}

TOON_ENGINE_API
std::vector<System *> Scene::GetSystems() const
{
    return _systemPtrs;
}

TOON_ENGINE_API
void SetCurrentScene(Scene * scene)
{
    _CurrentScene = scene;
}

TOON_ENGINE_API
Scene * GetCurrentScene()
{
    return _CurrentScene;
}

} // namespace Toon
```

`Engine/Private/SceneImporter.cpp`:

```cpp
#include <Toon/SceneImporter.hpp>

#include <unordered_map>

namespace Toon {

static std::unordered_map<string, std::unique_ptr<SceneImporter>> _SceneImporters;

static std::vector<SceneImporter *> _SceneImporterList;

void updateSceneImporterList()
{
    _SceneImporterList.clear();
    for (const auto& it : _SceneImporters) {
        _SceneImporterList.push_back(it.second.get());
    }
}

TOON_ENGINE_API
void AddSceneImporter(const string& id, std::unique_ptr<SceneImporter> importer)
{
    _SceneImporters[id] = std::move(importer);
    updateSceneImporterList();
}

TOON_ENGINE_API
void RemoveSceneImporter(const string& id)
{
    auto it = _SceneImporters.find(id);
    if (it != _SceneImporters.end()) {
        _SceneImporters.erase(it);
    }

    updateSceneImporterList();
}

TOON_ENGINE_API
const std::vector<SceneImporter *>& GetAllSceneImporters()
{
    return _SceneImporterList;
}

} // namespace Toon
```

`Engine/Private/Shader.cpp`:

```cpp
#include <Toon/Shader.hpp>
#include <Toon/Log.hpp>

namespace Toon {


} // namespace Toon
```

`Engine/Private/Texture.cpp`:

```cpp
#include <Toon/Texture.hpp>
#include <Toon/TextureImporter.hpp>
#include <Toon/GraphicsDriver.hpp>
#include <Toon/Log.hpp>

namespace Toon {

TOON_ENGINE_API
std::shared_ptr<Texture> LoadTextureFromFile(const string& filename, bool useAssetPath /*= true*/, Texture::Options opts /*= Texture::Options()*/)
{
    GraphicsDriver * gfx = GetGraphicsDriver();

    const auto& importers = GetAllTextureImporters();
    for (const auto& importer : importers) {
        auto textureData = importer->LoadFromFile(filename, useAssetPath);
        if (!textureData) {
            continue;
        }

        auto texture = gfx->CreateTexture();

        if (!texture->Load(textureData, opts)) {
            break;
        }

        return texture;
    }

    ToonLogError("Failed to load texture '%s'", filename);
    return nullptr;
}

TOON_ENGINE_API
std::shared_ptr<Texture> LoadTextureFromMemory(const uint8_t* buffer, size_t length, Texture::Options opts /*= Texture::Options()*/)
{
    GraphicsDriver * gfx = GetGraphicsDriver();

    const auto& importers = GetAllTextureImporters();
    for (const auto& importer : importers) {
        auto textureData = importer->LoadFromMemory(buffer, length);
        if (!textureData) {
            continue;
        }

        auto texture = gfx->CreateTexture();

        if (!texture->Load(textureData, opts)) {
            break;
        }

        return texture;
    }

    ToonLogError("Failed to load texture from memory");
    return nullptr;
}

} // namespace Toon
```

`Engine/Private/TextureImporter.cpp`:

```cpp
#include <Toon/TextureImporter.hpp>

namespace Toon {

static std::unordered_map<string, std::unique_ptr<TextureImporter>> _TextureImporters;

static std::vector<TextureImporter *> _TextureImporterList;

void updateTextureImporterList()
{
    _TextureImporterList.clear();
    for (const auto& it : _TextureImporters) {
        _TextureImporterList.push_back(it.second.get());
    }
}

TOON_ENGINE_API
void AddTextureImporter(const string& id, std::unique_ptr<TextureImporter> importer)
{
    _TextureImporters[id] = std::move(importer);
    updateTextureImporterList();
}

TOON_ENGINE_API
void RemoveTextureImporter(const string& id)
{
    auto it = _TextureImporters.find(id);
    if (it != _TextureImporters.end()) {
        _TextureImporters.erase(it);
    }
    
    updateTextureImporterList();
}

TOON_ENGINE_API
const std::vector<TextureImporter *>& GetAllTextureImporters()
{
    return _TextureImporterList;
}

} // namespace Toon
```

`Engine/Private/Toon.cpp`:

```cpp
#include <Toon/Toon.hpp>

#include <Toon/Log.hpp>
#include <Toon/Module.hpp>
#include <Toon/GraphicsDriver.hpp>
#include <Toon/Time.hpp>
#include <Toon/Scene.hpp>

// #include <Python/PyDusk.hpp>

// #include <Python.h>
// #include <frameobject.h>

#include <Toon/String.hpp>

#include <Toon/JSON.hpp>
#include <vector>
#include <cstdio>
#include <thread>

#include <cflags.h>

#include <fstream>

namespace Toon {

TOON_ENGINE_API
bool Initialize(int argc, char ** argv) 
{
    cflags_t * flags = cflags_init();

    bool help = false;
    cflags_add_bool(flags, '\0', "help", &help, "Display this help and exit");

    const char * config = NULL;
    cflags_add_string(flags, 'c', "config", &config, "Configuration to use");

    cflags_parse(flags, argc, argv);

    if (help) {
        cflags_print_usage(flags,
            "[OPTION]...",
            "Toon game and simulation engine",
            "Additional information about this library can be found at:\n"
            "  https://github.com/WhoBrokeTheBuild/Toon"
        );
    }

    if (flags->argc > 1) {
        LoadConfigurationFile(flags->argv[1], (config ? config : ""));
    }

    // InitMemoryTracking();

    // PyImport_AppendInittab("Toon", PyInit_Toon);

    // wchar_t *program = Py_DecodeLocale(argv[0], NULL);
    // if (program) {
    //     Py_SetProgramName(program);
    // }

    // PyMem_RawFree(program);
    
    // Py_Initialize();

    // PyImport_ImportModule("Toon");
    
    ToonLogVerbose("Toon Version: %s", GetVersion());
    ToonLogVerbose("Application Name: %s", GetApplicationName());
    ToonLogVerbose("Application Version: %s", GetApplicationVersion());

    return true;
}

TOON_ENGINE_API
void Terminate()
{
    //Py_Finalize();

    FreeAllModules();

    //TermMemoryTracking();
    
    //CloseAllLogFiles();
}

TOON_ENGINE_API
void LoadConfigurationFile(const Path& path, string_view configName)
{
    std::ifstream file(path);
    if (!file.is_open()) {
        ToonLogFatal("No.");
    }

    json data;
    data << file;

    auto applyConfig = [](json& data) {
        const auto& modules = data.value<std::vector<string>>("modules", {});
        for (const auto& name : modules) {
            LoadModule(name);
        }
    };

    SetApplicationName(data.value("name", ""));
    SetApplicationVersion(data.value("version", ""));

    applyConfig(data);

    if (!configName.empty()) {
        auto it = data.find("configurations");
        if (it != data.end()) {
            auto& configurations = it.value();
            if (configurations.is_object()) {
                it = configurations.find(configName);
                if (it != configurations.end()) {
                    applyConfig(it.value());
                }
            }
        }
    }
}

static bool _Running = true;

TOON_ENGINE_API
bool IsRunning()
{
    return _Running;
}

TOON_ENGINE_API
void SetRunning(bool running)
{
    _Running = running;
}

TOON_ENGINE_API
bool Run(std::function<void()> update)
{
    using namespace std::chrono;

    GraphicsDriver * gfx = GetGraphicsDriver();
    UpdateContext * updateCtx = gfx->GetUpdateContext();

    high_resolution_clock::time_point startTime = high_resolution_clock::now();
    high_resolution_clock::time_point previousTime = startTime;

    Toon::SetRunning(true);

    while (Toon::IsRunning()) {
        high_resolution_clock::time_point currentTime = high_resolution_clock::now();
        auto totalDuration = duration_cast<milliseconds>(currentTime - startTime);
        auto previousFrameDuration = duration_cast<microseconds>(currentTime - previousTime);
        previousTime = currentTime;

        updateCtx->SetTotalDuration(totalDuration);
        updateCtx->SetPreviousFrameDuration(previousFrameDuration);
        auto frameEndTime = currentTime + updateCtx->GetExpectedFrameDuration();

        gfx->ProcessEvents();

        update();

        auto scene = GetCurrentScene();
        if (scene) {
            scene->Update(gfx->GetUpdateContext());
        }

        gfx->Render();

        currentTime = high_resolution_clock::now();
        auto timeToSleep = duration_cast<milliseconds>(frameEndTime - currentTime);
        if (timeToSleep > 1ms) { // TODO: Find "minimum" sleep time
            std::this_thread::sleep_for(timeToSleep);
        }
    }

    return true;
}

TOON_ENGINE_API
bool RunScriptFile(const string& filename)
{
    FILE * file = nullptr;

    const auto& assetPaths = GetAssetPathList();

    for (const auto& path : assetPaths) {
        Path fullPath = path / "Scripts" / filename;
        ToonLogVerbose("Checking '%s'", fullPath);

        file = fopen(fullPath.ToCString(), "rt");
        if (file) {
            break;
        }
    }

    if (!file) {
        ToonLogError("Failed to run script file '%s'", filename);
    }

    // PyObject * pyMain = PyImport_AddModule("__main__");
    // PyObject * pyMainDict = PyModule_GetDict(pyMain);
    // PyObject * pyLocalDict = PyDict_New();

    // PyRun_File(file, filename.c_str(), Py_file_input, pyMainDict, pyLocalDict);

    // PyCheckError();

    fclose(file);
    return true;
}

TOON_ENGINE_API
bool RunScriptString(const string& code)
{
    // PyObject * pyMain = PyImport_AddModule("__main__");
    // PyObject * pyMainDict = PyModule_GetDict(pyMain);
    // PyObject * pyLocalDict = PyDict_New();

    // PyRun_String(code.c_str(), Py_single_input, pyMainDict, pyLocalDict);

    // PyCheckError();
    return true;
}

TOON_ENGINE_API
Version GetVersion()
{
    return Version(TOON_VERSION_MAJOR, TOON_VERSION_MINOR, TOON_VERSION_PATCH);
}

static string _ApplicationName;

TOON_ENGINE_API
void SetApplicationName(const string& name)
{
    _ApplicationName = name;
}

TOON_ENGINE_API
string GetApplicationName()
{
    return _ApplicationName;
}

static Version _ApplicationVersion;

TOON_ENGINE_API
void SetApplicationVersion(unsigned major, unsigned minor, unsigned patch)
{
    _ApplicationVersion = Version(major, minor, patch);
}

TOON_ENGINE_API
void SetApplicationVersion(const Version& version)
{
    _ApplicationVersion = version;
}

TOON_ENGINE_API
Version GetApplicationVersion()
{
    return _ApplicationVersion;
}

} // namespace Toon
```

`Engine/Private/Util.cpp`:

```cpp
#include <Toon/Util.hpp>
#include <Toon/Log.hpp>

#include <sstream>

namespace Toon {

TOON_ENGINE_API
string GetDirname(string path)
{
    size_t pivot = path.find_last_of('/');
    if (pivot == string::npos) {
        pivot = path.find_last_of('\\');
    }
    return (
        pivot == string::npos
        ? path
        : path.substr(0, pivot)
    );
}

TOON_ENGINE_API
string GetBasename(string path)
{
    size_t pivot = path.find_last_of('/');
    if (pivot == string::npos) {
        pivot = path.find_last_of('\\');
    }
    return (
        pivot == string::npos
        ? path
        : path.substr(pivot + 1)
    );
}

TOON_ENGINE_API
string GetExtension(string path)
{
    size_t pivot = path.find_last_of('.');
    return (
        pivot == string::npos
        ? string()
        : path.substr(pivot + 1)
    );
}

TOON_ENGINE_API
std::vector<Path> GetAssetPathList()
{
    static std::vector<Path> paths;
    if (!paths.empty()) {
        return paths;
    }

    paths.push_back(Path("Assets"));

    const char * path = getenv("TOON_ASSET_PATH");
    ToonLogVerbose("TOON_ASSET_PATH=%s", path);
    
    if (path) {
        std::istringstream iss(path);
        string p;
        while (std::getline(iss, p, TOON_PATH_SEPARATOR)) {
            paths.push_back(Path(p));
        }
    }
    
    return paths;
}

#if defined(TOON_PLATFORM_WINDOWS)

TOON_ENGINE_API
std::wstring ConvertUTF8ToWideString(string str)
{
    size_t maxSize = str.size() + 1;

    // Initialize to maximum potential size
    std::vector<wchar_t> wide(maxSize);

    int result = MultiByteToWideChar(
        CP_UTF8, 0, 
        str.c_str(), -1, 
        wide.data(), wide.size());
    
    if (result <= 0) {
        return std::wstring();
    }

    return std::wstring(wide.data());
}

TOON_ENGINE_API
string ConvertWideStringToUTF8(std::wstring wstr)
{
    size_t maxSize = (wstr.size() * 4) + 1;

    // Initialize to maximum potential size
    std::vector<char> utf8(maxSize);

    int result = WideCharToMultiByte(
        CP_UTF8, 0,
        wstr.c_str(), -1,
        utf8.data(), utf8.size(), 
        NULL, NULL);
        
    if (result <= 0) {
        return string();
    }

    return string(utf8.data());
}

#endif // defined(TOON_PLATFORM_WINDOWS)

} // namespace Toon
```

`Engine/Public/Toon/AudioDriver.hpp`:

```hpp
#ifndef TOON_AUDIO_DRIVER_HPP
#define TOON_AUDIO_DRIVER_HPP

#include <Toon/Config.hpp>

namespace Toon {

class TOON_ENGINE_API AudioDriver
{
public:

    DISALLOW_COPY_AND_ASSIGN(AudioDriver)

    AudioDriver() = default;

    virtual ~AudioDriver() = defualt;

}; // class AudioDriver

void SetAudioDriver(AudioDriver * driver);

AudioDriver * GetAudioDriver();

} // namespace Toon

#endif // TOON_AUDIO_DRIVER_HPP
```

`Engine/Public/Toon/AxisComponent.hpp`:

```hpp
#ifndef TOON_AXIS_COMPONENT_HPP
#define TOON_AXIS_COMPONENT_HPP

#include <Toon/Config.hpp>
#include <Toon/Component.hpp>
#include <Toon/Mesh.hpp>
#include <Toon/Shader.hpp>

namespace Toon {

// class TOON_ENGINE_API AxisPrimitiveData : public PrimitiveData
// {
// public:

//     const unsigned Indices[6] = {
//         0, 1, 
//         2, 3, 
//         4, 5,
//     };

//     const float Vertices[24] = { 
//         0.f, 0.f, 0.f, 1.0f,
//         1.f, 0.f, 0.f, 1.0f,
//         0.f, 0.f, 0.f, 1.0f,
//         0.f, 1.f, 0.f, 1.0f,
//         0.f, 0.f, 0.f, 1.0f,
//         0.f, 0.f, 1.f, 1.0f,
//     };

//     const float Colors[24] = { 
//         1.f, 0.f, 0.f, 1.0f,
//         1.f, 0.f, 0.f, 1.0f,
//         0.f, 1.f, 0.f, 1.0f,
//         0.f, 1.f, 0.f, 1.0f,
//         0.f, 0.f, 1.f, 1.0f,
//         0.f, 0.f, 1.f, 1.0f,
//     };

//     Mode GetMode() const override {
//         return Mode::Lines;
//     }

//     gsl::span<const unsigned> GetIndices() const override {
//         return gsl::span(Indices, 6);
//     }

//     gsl::span<const float> GetVertices() const override {
//         return gsl::span(Vertices, 24);
//     }

//     gsl::span<const float> GetNormals() const override {
//         return gsl::span<float>();
//     }

//     gsl::span<const float> GetUVs() const override {
//         return gsl::span<float>();
//     }

//     gsl::span<const float> GetColors() const override {
//         return gsl::span(Colors, 24);
//     }

//     gsl::span<const float> GetTangents() const override {
//         return gsl::span<float>();
//     }

//     gsl::span<const float> GetBitangents() const override {
//         return gsl::span<float>();
//     }

// }; // class PrimitiveData

class TOON_ENGINE_API AxisComponent : public Component
{
public:

    DISALLOW_COPY_AND_ASSIGN(AxisComponent)

    AxisComponent();

    virtual ~AxisComponent() = default;

    void Render(RenderContext * ctx) override;
private:
    //static AxisPrimitiveData _PrimitiveData;

    std::shared_ptr<Shader> _shader;

    std::shared_ptr<Mesh> _mesh;

}; // class AxisComponent


} // namespace Toon

#endif // TOON_AXIS_COMPONENT_HPP
```

`Engine/Public/Toon/Benchmark.hpp`:

```hpp
#ifndef TOON_BENCHMARK_HPP
#define TOON_BENCHMARK_HPP
/// Start Benchmark

#include <chrono>

#define ToonBenchmarkStart() \
    auto toonBenchClockStart = std::chrono::high_resolution_clock::now();

#define ToonBenchmarkEnd()                                                          \
    ToonLogPerf("Function: %s took %.3f millis\n", TOON_FUNCTION_NAME(),            \
        std::chrono::duration_cast<std::chrono::duration<double, std::milli>>(  \
            std::chrono::high_resolution_clock::now() - toonBenchClockStart     \
        ).count());

/// End Benchmark

#endif // TOON_BENCHMARK_HPP
```

`Engine/Public/Toon/Buffer.hpp`:

```hpp
#ifndef TOON_BUFFER_HPP
#define TOON_BUFFER_HPP

#include <Toon/Config.hpp>
#include <Toon/String.hpp>

#include <cstdint>

namespace Toon {

enum class BufferUsage
{
    Index,
    Vertex,
    Constant,
}; // enum class BufferUsage

enum class MemoryUsage
{
    GPU,
    UploadOnce,
    UploadOften,
    Download,
}; // enum class MemoryUsage

class TOON_ENGINE_API Buffer
{
public:
    
    DISALLOW_COPY_AND_ASSIGN(Buffer)

    Buffer() = default;

    virtual ~Buffer() = default;

    virtual bool Initialize(size_t size, uint8_t * data, BufferUsage bufferUsage, MemoryUsage memoryUsage) = 0;

    virtual void Terminate() = 0;

    virtual bool ReadFrom(size_t offset, size_t length, uint8_t * data);

    virtual bool WriteTo(size_t offset, size_t length, uint8_t * data);

protected:

    BufferUsage _bufferUsage;

    MemoryUsage _memoryUsage;

    void * _mappedBufferMemory = nullptr;

}; // class Buffer

inline string BufferUsageToString(BufferUsage bufferUsage)
{
    switch (bufferUsage) {
        case BufferUsage::Index:
            return "Index";
        case BufferUsage::Vertex:
            return "Vertex";
        case BufferUsage::Constant:
            return "Constant";
    }

    return "Unknown";
}

inline string MemoryUsageToString(MemoryUsage memoryUsage)
{
    switch (memoryUsage) {
        case MemoryUsage::GPU:
            return "GPU";
        case MemoryUsage::UploadOnce:
            return "UploadOnce";
        case MemoryUsage::UploadOften:
            return "UploadOften";
        case MemoryUsage::Download:
            return "Download";
    }

    return "Unknown";
}

} // namespace Toon

#endif // TOON_BUFFER_HPP
```

`Engine/Public/Toon/Camera.hpp`:

```hpp
#ifndef TOON_CAMERA_H
#define TOON_CAMERA_H

#include <Toon/Config.hpp>
#include <Toon/Entity.hpp>
#include <Toon/Math.hpp>

#include <Toon/String.hpp>

namespace Toon {

enum CameraMode {
    Perspective,
    Orthographic,
}; // enum CameraMode

class TOON_ENGINE_API Camera : public Entity
{
public:

    DISALLOW_COPY_AND_ASSIGN(Camera)
        
    Camera();

    virtual ~Camera();

    glm::mat4 GetView() const;

    glm::mat4 GetProjection() const;

    void SetMode(CameraMode mode);

    inline CameraMode GetMode() const {
        return _mode;
    }

    void SetClip(const glm::vec2& clip);

    inline glm::vec2 GetClip() const {
        return _clip;
    }

    void SetUp(const glm::vec3& up);

    inline glm::vec3 GetUp() const {
        return _up;
    }

    void SetForward(const glm::vec3& forward);

    glm::vec3 GetForward() const;

    glm::vec3 GetRight() const;

    void SetAspect (float aspect);
    
    void SetAspect(const glm::vec2& size);

    inline float GetAspect() const {
        return _aspect;
    }

    // Perspective

    void SetFOVX(float fovx);

    inline float GetFOVX() const {
        return _fovX;
    }

    void SetFOVY(float fovy);

    void SetLookAt(const glm::vec3& point);

    // Orthographic

    void SetViewportSize(const glm::vec2& viewSize);

    inline glm::vec2 GetViewportSize() const {
        return _viewportSize;
    }

    void SetViewportScale(const glm::vec4& viewScale);

    inline glm::vec4 GetViewportScale() const {
        return _viewportScale;
    }

    glm::vec4 GetViewport() const;

    // Movement
    void HandleMovement(float dt);
    void HandleRotation(float xoffset, float yoffset);

    void SetDirection(glm::vec3 dir);
    glm::vec3& GetDirection() { return _direction; }

private:

    CameraMode _mode = CameraMode::Perspective;

    glm::vec2 _clip = { 0.1f, 10000.0f };

    glm::vec3 _up = GetWorldUp();

    float _aspect = 16.0f / 9.0f; // 16:9

    unsigned _windowResizedEventHandlerID;

    // Perspective
    float _fovX = glm::radians(45.0f);

    // Orthographic
    glm::vec2 _viewportSize = glm::vec2(1920.0f, 1080.0f);

    glm::vec4 _viewportScale = glm::vec4(-0.5f, 0.5f, 0.5f, -0.5f);

    // Movement
    float _movementSpeed = 0.25f;

    float _rotateSpeed = 0.001f;

    bool _invserse = false;

    glm::vec3 _direction = glm::vec3(0);
};

} // namespace Toon

#endif // TOON_CAMERA_H

```

`Engine/Public/Toon/Collision.hpp`:

```hpp
#ifndef COLLISION_H
#define COLLISION_H

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>

#include <vector>

// SHAPES
struct Circle
{
    double radius;
};

struct Sphere
{
    double radius;
};

struct Plane
{
    double width, height;
};

struct Box
{
    double width, height, depth;
};

struct Cylinder
{
    double radius, height;
};
// SHAPES

// COLLISION BOUNDS
struct BoundingVolumeSphere
{
    const Sphere *shape; // holds radius
};

struct BoundingVolumeBox
{
    
    const Box *shapeLimits; // half dimensions

    // axis-aligned flag
    int isAxisAligned;

    // all corners in local and world space
    // Point localCorners[8];
    // Point worldCorners[8];

    std::vector<glm::vec3> localCorners[8];
    std::vector<glm::vec3> worldCorners[8];
    unsigned int numCorners; // 4 if 2D, 8 if 3D
};
// COLLISION BOUNDS

class Collision
{
public:
    Collision();

private:

};

#endif // COLLISION_H

```

`Engine/Public/Toon/CommandList.hpp`:

```hpp
#ifndef TOON_COMMAND_LIST_HPP
#define TOON_COMMAND_LIST_HPP

#include <Toon/Config.hpp>
#include <Toon/Pipeline.hpp>
#include <Toon/Primitive.hpp>

#include <memory>

namespace Toon {

class Buffer;

enum class CommandType
{
    SetPipeline,
    SetIndexBuffer,
    SetVertexBuffers,
}; // enum class CommandType

struct Viewport
{
    union
    {
        glm::vec2 Position;

        struct
        {
            float X;
            float Y;
        };
    };

    union
    {
        glm::vec2 Size;

        struct
        {
            float Width;
            float Height;
        };
    };

    union
    {
        glm::vec2 Depth;

        struct
        {
            float Near;
            float Far;
        };
    };
}; // struct Viewport

struct Command
{
    CommandType Type;

    union
    {
        struct
        {
            std::shared_ptr<Pipeline> Pipeline;

        } SetPipeline;

        struct
        {
            std::shared_ptr<Buffer> IndexBuffer;

        } SetIndexBuffer;

        struct
        {
            std::vector<std::shared_ptr<Buffer>> VertexBuffers;

        } SetVertexBuffers;

        struct
        {
            glm::vec2 Position;
            glm::vec2 Size;

        } SetScissor;

        struct
        {
            Viewport viewport;

        } SetViewport;
        
        struct
        {
            uint32_t VertexCount;
            uint32_t FirstVertex;
            

        } Draw;

        struct
        {
            uint32_t IndexCount;
            uint32_t FirstIndex;
            
        } DrawIndexed;

        struct 
        {
            std::shared_ptr<Buffer> Source;
            std::shared_ptr<Buffer> Destination;
            // Regions?

        } CopyBuffer;

    };
}; // struct Command

class Command
{
public:

}; // class Command

class SetPipelineCommand : public Command
{
public:

    SetPipelineCommand(std::shared_ptr<Pipeline> pipeline)
        : _pipeline(pipeline)
    { }

protected:

    std::shared_ptr<Pipeline> _pipeline;
}; // class SetPipelineCommand

class VulkanSetPipelineCommand : SetPipelineCommand
{
public:

    void Execute() override {
        auto vulkanCommandBuffer = TOON_VULKAN_COMMAND_LIST(list.get()));
        auto vulkanPipeline = TOON_VULKAN_PIPELINE(_pipeline.get());
        vkCmdBindPipeline(vulkanCommandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, vulkanPipeline);
    }
}; // class VulkanSetPipelineCommand

class OpenGLSetPipelineCommand : SetPipelineCommand
{
public:
    
    void Execute() override {
        auto openglPipeline = DUSK_OPENGL_PIPELINE(_pipeline.get());
        openglPipeline->Bind();
    }
}; // class OpenGLSetPipelineCommand


// Command Bundles?




enum class CommandListUsage
{
    // TODO: Improve
    Default,
    OneTime,

}; // enum class CommandListUsage

class TOON_ENGINE_API CommandAllocator : public Object
{
public:

    // TODO: Revisit

}; // class CommandAllocator

class TOON_ENGINE_API RenderTarget : public Object
{
public:

private:

}; // class RenderTarget

class TOON_VULKAN_API VulkanRenderTarget : public RenderTarget
{
public:

    VulkanRenderTarget(VkFramebuffer * framebuffer);

};

class TOON_DIRECTX_API DirectXRenderTarget : public RenderTarget
{
public:

    DirectXRenderTarget(ComPtr<ID3D12Resource> renderTarget);
};

class TOON_ENGINE_API CommandList : public Object
{
public:

    DISALLOW_COPY_AND_ASSIGN(CommandList)

    CommandList() = default;

    virtual ~CommandList() = default;

    virtual bool Initialize(CommandAllocator * commandAllocator, CommandListUsage commandListUsage) = 0;

    virtual void Terminate() = 0;

    virtual void Begin(Pipeline * initialPipeline) = 0;

    virtual void End() = 0;

    virtual void BeginRenderPass(RenderTarget * framebuffer, vec4 clearColor, float depth, int stencil) = 0;

    virtual void EndRenderPass() = 0;

    virtual void SetPipeline(std::shared_ptr<Pipeline> pipeline) = 0;

    virtual void SetIndexBuffer(std::shared_ptr<Buffer> indexBuffer) = 0;

    virtual void SetVertexBuffers(std::vector<std::shared_ptr<Buffer>> vertexBuffers) = 0;

    // BindDescriptorSets?
    // PushConstants?
    // RootSignature?

    virtual void Draw() = 0;


    // SetRenderTarget (Framebuffer)
    // ClearColor
    // ClearDepth

    // void AddSetViewportCommand(Viewport viewport);

private:

    std::vector<Command> _commands;

}; // class CommandList

} // namespace Toon

#endif // TOON_COMMAND_LIST_HPP
```

`Engine/Public/Toon/Component.hpp`:

```hpp
#ifndef TOON_COMPONENT_HPP
#define TOON_COMPONENT_HPP

#include <Toon/Config.hpp>
#include <Toon/UpdateContext.hpp>
#include <Toon/RenderContext.hpp>

namespace Toon {

class Entity;

class TOON_ENGINE_API Component
{
public:
    DISALLOW_COPY_AND_ASSIGN(Component)

    Component() = default;

    virtual ~Component() = default;

    virtual inline void Attach(Entity* entity) {
        _mEntity = entity;
    }

    virtual inline void Detach() {
        _mEntity = nullptr;
    }

    virtual inline bool IsAttached() const {
        return (_mEntity != nullptr);
    }

    virtual Entity * GetEntity() const {
        return _mEntity;
    }

    virtual inline void Update(UpdateContext * ctx) { }

    virtual inline void Render(RenderContext * ctx) { }

private:

    Entity* _mEntity = nullptr;

}; // class Component

} // namespacee Toon

#endif // TOON_COMPONENT_HPP
```

`Engine/Public/Toon/Config.hpp.in`:

```in
#ifndef TOON_CONFIG_HPP
#define TOON_CONFIG_HPP

#include <Toon/Macros.hpp>

#define TOON_VERSION_MAJOR @PROJECT_VERSION_MAJOR@
#define TOON_VERSION_MINOR @PROJECT_VERSION_MINOR@
#define TOON_VERSION_PATCH @PROJECT_VERSION_PATCH@
#define TOON_REVISION "@PROJECT_VERSION_GIT_HASH@"

#define TOON_VERSION_NUMBER(MAJOR, MINOR, PATCH) \
    (((MAJOR << 16) | (MINOR << 8) | PATCH))

#define TOON_VERSION \
    TOON_VERSION_NUMBER(TOON_VERSION_MAJOR, TOON_VERSION_MINOR, TOON_VERSION_PATCH)

#define TOON_VERSION_STRING "@PROJECT_VERSION@-@PROJECT_VERSION_GIT_HASH@"

#if defined(TOON_COMPILER_MSVC)
    #define TOON_API_EXPORT __declspec(dllexport)
    #define TOON_API_IMPORT __declspec(dllimport)
#else
    #if TOON_COMPILER_GCC >= 4 || defined(TOON_COMPILER_CLANG)
        #define TOON_API_EXPORT __attribute__ ((__visibility__ ("default")))
        #define TOON_API_IMPORT __attribute__ ((__visibility__ ("default")))
    #endif
#endif

#if defined(TOON_ENGINE_EXPORT)
    #define TOON_ENGINE_API TOON_API_EXPORT
#else
    #define TOON_ENGINE_API TOON_API_IMPORT
#endif


#endif // TOON_CONFIG_HPP
```

`Engine/Public/Toon/Controller.hpp`:

```hpp
#ifndef TOON_CONTROLLER_HPP
#define TOON_CONTROLLER_HPP

#include <Toon/Config.hpp>

#include <Toon/String.hpp>

namespace Toon {

enum class ControllerButton
{
    Unknown = -1,

    A,
    B,
    X,
    Y,
    Back,
    Guide,
    Start,
    LeftStick,
    RightStick,
    LeftShoulder,
    RightShoulder,
    DPadUp,
    DPadDown,
    DPadLeft,
    DPadRight,

}; // enum ControllerButton

static inline string GetControllerButtonName(ControllerButton button)
{
    switch (button) {
    case ControllerButton::A:
        return "A";
    case ControllerButton::B:
        return "B";
    case ControllerButton::X:
        return "X";
    case ControllerButton::Y:
        return "Y";
    case ControllerButton::Back:
        return "Back";
    case ControllerButton::Guide:
        return "Guide";
    case ControllerButton::Start:
        return "Start";
    case ControllerButton::LeftStick:
        return "Left Stick";
    case ControllerButton::RightStick:
        return "Right Stick";
    case ControllerButton::LeftShoulder:
        return "Left Shoulder";
    case ControllerButton::RightShoulder:
        return "Right Shoulder";
    case ControllerButton::DPadUp:
        return "D-Pad Up";
    case ControllerButton::DPadDown:
        return "D-Pad Down";
    case ControllerButton::DPadLeft:
        return "D-Pad Left";
    case ControllerButton::DPadRight:
        return "D-Pad Right";
    default: ;
    }

    return string();
};

} // namespace Toon

#endif // TOON_CONTROLLER_HPP

```

`Engine/Public/Toon/Entity.hpp`:

```hpp
#ifndef TOON_ENTITY_HPP
#define TOON_ENTITY_HPP

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>
#include <Toon/Component.hpp>
#include <Toon/UpdateContext.hpp>
#include <Toon/RenderContext.hpp>
#include <Toon/Macros.hpp>
#include <Toon/String.hpp>

#include <vector>
#include <memory>

namespace Toon {

TOON_ENGINE_API
constexpr glm::vec3 GetWorldUp() {
    return { 0.0f, 1.0f, 0.0f };
}

TOON_ENGINE_API
constexpr glm::vec3 GetWorldForward() {
    return { 0.0f, 0.0f, -1.0f };
}

class TOON_ENGINE_API Entity
{
public:

    DISALLOW_COPY_AND_ASSIGN(Entity)

    Entity() = default;
    
    virtual ~Entity() = default;

    bool LoadFromFile(const string& filename);

    void SetParent(Entity* parent);

    inline Entity* GetParent() const { 
        return _parent;
    }

    Entity * AddChild(std::unique_ptr<Entity>&& child);

    Entity* FindEntity(string name);

    std::vector<Entity *> GetChildren() const;

    Component * AddComponent(std::unique_ptr<Component>&& component);

    std::vector<Component *> GetComponents() const;

    void SetName(const string& name);

    inline string GetName() const {
        return _name;
    }

    // Remember matrix order is Translate (Position), Orientate, Scale
    void SetPosition(const glm::vec3& position);

    inline glm::vec3 GetPosition() const {
        return _position;
    }

    // Remember matrix order is Translate (Position), Orientate, Scale
    void SetOrientation(const glm::quat& orientation);

    inline glm::quat GetOrientation() const {
        return _orientation;
    }

    // Remember matrix order is Translate (Position), Orientate, Scale
    void SetScale(const glm::vec3& scale);

    inline glm::vec3 GetScale() const {
        return _scale;
    }

    glm::mat4 GetTransform() const;

    glm::vec3 GetWorldPosition() const;

    glm::quat GetWorldOrientation() const;

    glm::vec3 GetWorldScale() const;

    glm::mat4 GetWorldTransform() const;
    
    virtual void Update(UpdateContext * ctx);

    virtual void Render(RenderContext * ctx);

    // Enabled/disabled
    void SetEnabled(bool value) { _mEnabled = value; }
    bool GetEnabled() { return _mEnabled; }

    // Visibility
    void SetVisibility(bool value) { _mVisibility = value; }
    bool GetVisibility() { return _mVisibility; }

    
private:
    Entity* _parent = nullptr;

    string _name;

    std::vector<std::unique_ptr<Entity>> _children;

    std::vector<Entity *> _childPtrs;

    std::vector<std::unique_ptr<Component>> _components;
    
    std::vector<Component *> _componentPtrs;

    // Pos, rot, scale
    glm::vec3 _position = glm::vec3(0.0f);

    glm::quat _orientation = glm::quat(1.0f, 0.0f, 0.0f, 0.0f);

    glm::vec3 _scale = glm::vec3(1.0f);

    // Enabled
    bool _mEnabled = true;

    // Visibility
    bool _mVisibility = true;

};

} // namespace Toon

#endif // TOON_ENTITY_HPP
```

`Engine/Public/Toon/Event.hpp`:

```hpp
#ifndef EVENT_HPP
#define EVENT_HPP

//#include <Python.h>

#include <unordered_map>
#include <functional>
#include <type_traits>

class EventData {
public:
    template <class T>
    const T* GetAs() const {
        return dynamic_cast<const T*>(this);
    }

    //virtual PyObject* getPyObject() const = 0;
};

class ScriptEvent {
public:
    explicit ScriptEvent() = default;

    virtual ~ScriptEvent() = default;

    //unsigned AddPythonListener(PyObject* listener);

    //bool RemovePythonListener(PyObject* listener);

    // bool RemovePythonListener(unsigned id);

    // void CallPython(const EventData* data);

    // void RemoveAllPythonListeners();

private:
    // unsigned _mMaxPythonListenerID = 0;
    
    //std::unordered_map<unsigned, PyObject*> _mPythonListeners;
};

template <class EventDataType>
class Event : public ScriptEvent
{
    static_assert(
        std::is_base_of<EventData, EventDataType>::value,
        "EventDataType must be a descendant of EventData"
    );

public:
    explicit Event() = default;

    virtual ~Event() = default;

    typedef std::function<void(const EventDataType*)> Listener;

    unsigned AddListener(Listener listener) {
        ++_mMaxListenerID;
        _mListeners.emplace(_mMaxListenerID, listener);
        return _mMaxListenerID;
    }

    bool RemoveListener(unsigned id) {
        auto it = _mListeners.find(id);

        if (it != _mListeners.end()) {
            _mListeners.erase(it);
            return true;
        }

        return false;
    }

    void Call(const EventDataType* data) {
        for (const auto& it : _mListeners) {
            it.second(data);
        }

        // CallPython(static_cast<const EventData*>(data));
    }

    void RemoveAllListeners() {
        _mListeners.clear();

        // RemoveAllPythonListeners();
    }

private:
    unsigned _mMaxListenerID;

    std::unordered_map<int, Listener> _mListeners;
};

#endif // EVENT_HPP
```

`Engine/Public/Toon/Font.hpp`:

```hpp
#ifndef TOON_FONT_HPP
#define TOON_FONT_HPP

#include <Toon/Config.hpp>

#include <Toon/String.hpp>

namespace Toon {

class TOON_ENGINE_API Font
{
public:

    DISALLOW_COPY_AND_ASSIGN(Font)

    bool LoadFromFile(const string& filename);

}; // class Font

}; // namespace Toon

#endif // TOON_FONT_HPP
```

`Engine/Public/Toon/GraphicsDriver.hpp`:

```hpp
#ifndef TOON_GRAPHICS_DRIVER_HPP
#define TOON_GRAPHICS_DRIVER_HPP

#include <Toon/Config.hpp>
#include <Toon/Buffer.hpp>
#include <Toon/Event.hpp>
#include <Toon/Pipeline.hpp>
#include <Toon/InputDriver.hpp>
#include <Toon/Math.hpp>
#include <Toon/Mesh.hpp>
#include <Toon/RenderContext.hpp>
#include <Toon/Shader.hpp>
#include <Toon/String.hpp>
#include <Toon/Texture.hpp>
#include <Toon/Time.hpp>
#include <Toon/UpdateContext.hpp>
#include <Toon/Material.hpp>

#include <vector>
#include <memory>

namespace Toon {

class TOON_ENGINE_API WindowResizedEventData : public EventData
{
public:

    glm::ivec2 Size;

    //PyObject * GetPyObject() const override;

}; // class WindowResizedEventData

class TOON_ENGINE_API GraphicsDriver
{
public:

    DISALLOW_COPY_AND_ASSIGN(GraphicsDriver)

    GraphicsDriver() = default;

    virtual ~GraphicsDriver() = default;

    virtual bool Initialize() = 0;

    virtual void Terminate() = 0;

    virtual void InitializeUpdateContext();

    virtual void InitializeRenderContext();

    virtual bool InitializeConstantBuffers();

    virtual bool InitializeDefaults();

    virtual void SetWindowTitle(const string& title) {
        _windowTitle = title;
        UpdateWindowTitle(title);
    }

    virtual string GetWindowTitle() {
        return _windowTitle;
    }

    virtual void SetWindowSize(const glm::ivec2& size) {
        _windowSize = size;
        UpdateWindowSize(size);
    }

    virtual glm::ivec2 GetWindowSize() {
        return _windowSize;
    }

    virtual void SetBackbufferCount(unsigned backbufferCount) {
        _backbufferCount = backbufferCount;
    }

    virtual unsigned GetBackbufferCount() const {
        return _backbufferCount;
    }

    virtual void SetClearColor(const glm::vec4& color) {
        _clearColor = color;
    }

    virtual glm::vec4 GetClearColor() const {
        return _clearColor;
    }

    virtual void ProcessEvents() = 0;
    
    virtual void Render() = 0;

    virtual std::shared_ptr<Buffer> CreateBuffer() = 0;

    virtual std::shared_ptr<Pipeline> CreatePipeline(std::shared_ptr<Shader> shader) = 0;

    virtual std::shared_ptr<Texture> CreateTexture() = 0;

    virtual std::shared_ptr<Shader> CreateShader() = 0;

    virtual std::shared_ptr<Mesh> CreateMesh() = 0;

    virtual std::shared_ptr<Material> CreateMaterial() = 0;

    virtual std::shared_ptr<Primitive> CreatePrimitive() = 0;

    virtual UpdateContext * GetUpdateContext();

    virtual RenderContext * GetRenderContext();

    Event<Toon::WindowResizedEventData> WindowResizedEvent;

    virtual inline std::shared_ptr<Buffer> GetShaderGlobalsBuffer() {
        return _shaderGlobalsBuffer;
    }

    virtual inline std::shared_ptr<Texture> GetDefaultTexture() {
        return _defaultTexture;
    }

    virtual inline std::shared_ptr<Pipeline> GetDefaultPipeline() {
        return _defaultPipeline;
    }

    virtual inline std::shared_ptr<Material> GetDefaultMaterial() {
        return _defaultMaterial;
    }

protected:

    virtual void UpdateWindowTitle(const string& title) = 0;

    virtual void UpdateWindowSize(const glm::ivec2& size) = 0;

    string _windowTitle = "Toon";

    glm::ivec2 _windowSize = { 640, 480 };

    microseconds _fpsUpdateElapsedTime = 0us;

    uintmax_t _fpsUpdateFrameCount = 0;
    
    // Push Constants?

    glm::vec4 _clearColor = glm::vec4(0.392f, 0.584f, 0.929f, 1.0f);

    std::unique_ptr<UpdateContext> _updateContext;

    std::unique_ptr<RenderContext> _renderContext;

    unsigned _backbufferCount = 2;

    std::unordered_map<unsigned, std::shared_ptr<Buffer>> _constantBufferBindings;

    std::shared_ptr<Buffer> _shaderGlobalsBuffer;

    std::shared_ptr<Texture> _defaultTexture;

    std::shared_ptr<Pipeline> _defaultPipeline;

    std::shared_ptr<Material> _defaultMaterial;

}; // class GraphicsDriver

TOON_ENGINE_API
void SetGraphicsDriver(std::unique_ptr<GraphicsDriver> && driver);

TOON_ENGINE_API
GraphicsDriver * GetGraphicsDriver();

} // namespace Toon

#endif // TOON_GRAPHICS_DRIVER_HPP
```

`Engine/Public/Toon/InputDriver.hpp`:

```hpp
#ifndef TOON_INPUT_DRIVER_HPP
#define TOON_INPUT_DRIVER_HPP

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>
#include <Toon/Keyboard.hpp>
#include <Toon/Mouse.hpp>
#include <Toon/Controller.hpp>

#include <memory>

namespace Toon {

// class MouseMovedEventData : public EventData
// {
// public:

//     ivec2 Position;
//     ivec2 Delta;

//     PyObject * PySerialize() const override {
//         PyObject * dict = PyDict_New();

//         PyObject * pos = PyTuple_New(2);
//         PyTuple_SET_ITEM(pos, 0, PyLong_FromLong(Position.x));
//         PyTuple_SET_ITEM(pos, 1, PyLong_FromLong(Position.y));
//         PyDict_SetItemString(dict, "Position", pos);

//         PyObject * delta = PyTuple_New(2);
//         PyTuple_SET_ITEM(delta, 0, PyLong_FromLong(Delta.x));
//         PyTuple_SET_ITEM(delta, 1, PyLong_FromLong(Delta.y));
//         PyDict_SetItemString(dict, "Delta", delta);

//         return dict;
//     }

// }; // class MouseMovedEventData

class TOON_ENGINE_API InputDriver
{
public:

    DISALLOW_COPY_AND_ASSIGN(InputDriver)

    InputDriver() = default;

    virtual ~InputDriver() = default;

    virtual glm::ivec2 GetMouseCoordinates() const = 0;

}; // class InputDriver

TOON_ENGINE_API
void SetInputDriver(std::unique_ptr<InputDriver> && driver);

TOON_ENGINE_API
InputDriver * GetInputDriver();

} // namespace Toon

#endif // TOON_INPUT_DRIVER_HPP

```

`Engine/Public/Toon/JSON.hpp`:

```hpp
#ifndef TOON_JSON_HPP
#define TOON_JSON_HPP

#include <Toon/Config.hpp>
#include <Toon/String.hpp>

#include <nlohmann/json.hpp>

namespace Toon {

typedef nlohmann::basic_json<
    std::map,
    std::vector,
    string,
    bool,
    int,
    unsigned,
    float,
    std::allocator> json;

inline glm::vec2 ExtractVec2(const json& value, glm::vec2 def)
{
    if (value.is_array() && value.size() == 2) {
        const auto& v = value.get<std::vector<float>>();
        return glm::make_vec2(v.data());
    }

    return def;
}

inline glm::vec3 ExtractVec3(const json& value, glm::vec3 def)
{
    if (value.is_array() && value.size() == 3) {
        const auto& v = value.get<std::vector<float>>();
        return glm::make_vec3(v.data());
    }

    return def;
}

inline glm::vec4 ExtractVec4(const json& value, glm::vec4 def)
{
    if (value.is_array() && value.size() == 4) {
        const auto& v = value.get<std::vector<float>>();
        return glm::make_vec4(v.data());
    }

    return def;
}

inline glm::quat ExtractQuat(const json& value, glm::quat def)
{
    if (value.is_array() && value.size() == 4) {
        const auto& v = value.get<std::vector<float>>();
        return glm::quat(v[3], v[0], v[1], v[2]);
    }

    return def;
}

} // namespace Toon

#endif // TOON_JSON_HPP
```

`Engine/Public/Toon/Keyboard.hpp`:

```hpp
#ifndef TOON_KEYBOARD_HPP
#define TOON_KEYBOARD_HPP

#include <Toon/Config.hpp>

#include <Toon/String.hpp>

namespace Toon {

enum class KeyboardKey
{
    Unknown = -1,

    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    Num0,
    Num1,
    Num2,
    Num3,
    Num4,
    Num5,
    Num6,
    Num7,
    Num8,
    Num9,
    Numpad0,
    Numpad1,
    Numpad2,
    Numpad3,
    Numpad4,
    Numpad5,
    Numpad6,
    Numpad7,
    Numpad8,
    Numpad9,
    NumpadPlus,
    NumpadMinus,
    NumpadMultiply,
    NumpadDivide,
    NumpadEnter,
    NumpadPeriod,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    F20,
    F21,
    F22,
    F23,
    F24,
    Escape,
    Delete,
    Insert,
    Home,
    End,
    PageUp,
    PageDown,
    Backspace,
    Enter,
    Space,
    LeftShift,
    RightShift,
    LeftControl,
    RightControl,
    LeftAlt,
    RightAlt,
    PrintScreen,
    Break,
    Grave,
    Tab,
    CapsLock,
    NumLock,
    ScrollLock,
    LeftSuper,
    RightSuper,
    Menu,
    Left,
    Right,
    Up,
    Down,
    Minus,
    Equals,
    Semicolon,
    Quote,
    Slash,
    Backslash,
    Comma,
    Period,
    LeftBracket,
    RightBracket,
}; // enum KeyboardKey

static inline string GetKeyboardKeyName(KeyboardKey key)
{
    switch (key) {
    case KeyboardKey::A:
        return "A";
    case KeyboardKey::B:
        return "B";
    case KeyboardKey::C:
        return "C";
    case KeyboardKey::D:
        return "D";
    case KeyboardKey::E:
        return "E";
    case KeyboardKey::F:
        return "F";
    case KeyboardKey::G:
        return "G";
    case KeyboardKey::H:
        return "H";
    case KeyboardKey::I:
        return "I";
    case KeyboardKey::J:
        return "J";
    case KeyboardKey::K:
        return "K";
    case KeyboardKey::L:
        return "L";
    case KeyboardKey::M:
        return "M";
    case KeyboardKey::N:
        return "N";
    case KeyboardKey::O:
        return "O";
    case KeyboardKey::P:
        return "P";
    case KeyboardKey::Q:
        return "Q";
    case KeyboardKey::R:
        return "R";
    case KeyboardKey::S:
        return "S";
    case KeyboardKey::T:
        return "T";
    case KeyboardKey::U:
        return "U";
    case KeyboardKey::V:
        return "V";
    case KeyboardKey::W:
        return "W";
    case KeyboardKey::X:
        return "X";
    case KeyboardKey::Y:
        return "Y";
    case KeyboardKey::Z:
        return "Z";
    case KeyboardKey::Num0:
        return "0";
    case KeyboardKey::Num1:
        return "1";
    case KeyboardKey::Num2:
        return "2";
    case KeyboardKey::Num3:
        return "3";
    case KeyboardKey::Num4:
        return "4";
    case KeyboardKey::Num5:
        return "5";
    case KeyboardKey::Num6:
        return "6";
    case KeyboardKey::Num7:
        return "7";
    case KeyboardKey::Num8:
        return "8";
    case KeyboardKey::Num9:
        return "9";
    case KeyboardKey::Numpad0:
        return "Numpad 0";
    case KeyboardKey::Numpad1:
        return "Numpad 1";
    case KeyboardKey::Numpad2:
        return "Numpad 2";
    case KeyboardKey::Numpad3:
        return "Numpad 3";
    case KeyboardKey::Numpad4:
        return "Numpad 4";
    case KeyboardKey::Numpad5:
        return "Numpad 5";
    case KeyboardKey::Numpad6:
        return "Numpad 6";
    case KeyboardKey::Numpad7:
        return "Numpad 7";
    case KeyboardKey::Numpad8:
        return "Numpad 8";
    case KeyboardKey::Numpad9:
        return "Numpad 9";
    case KeyboardKey::NumpadPlus:
        return "Numpad +";
    case KeyboardKey::NumpadMinus:
        return "Numpad -";
    case KeyboardKey::NumpadMultiply:
        return "Numpad *";
    case KeyboardKey::NumpadDivide:
        return "Numpad /";
    case KeyboardKey::NumpadEnter:
        return "Numpad Enter";
    case KeyboardKey::NumpadPeriod:
        return "Numpad .";
    case KeyboardKey::F1:
        return "F1";
    case KeyboardKey::F2:
        return "F2";
    case KeyboardKey::F3:
        return "F3";
    case KeyboardKey::F4:
        return "F4";
    case KeyboardKey::F5:
        return "F5";
    case KeyboardKey::F6:
        return "F6";
    case KeyboardKey::F7:
        return "F7";
    case KeyboardKey::F8:
        return "F8";
    case KeyboardKey::F9:
        return "F9";
    case KeyboardKey::F10:
        return "F10";
    case KeyboardKey::F11:
        return "F11";
    case KeyboardKey::F12:
        return "F12";
    case KeyboardKey::F13:
        return "F13";
    case KeyboardKey::F14:
        return "F14";
    case KeyboardKey::F15:
        return "F15";
    case KeyboardKey::F16:
        return "F16";
    case KeyboardKey::F17:
        return "F17";
    case KeyboardKey::F18:
        return "F18";
    case KeyboardKey::F19:
        return "F19";
    case KeyboardKey::F20:
        return "F20";
    case KeyboardKey::F21:
        return "F21";
    case KeyboardKey::F22:
        return "F22";
    case KeyboardKey::F23:
        return "F23";
    case KeyboardKey::F24:
        return "F24";
    case KeyboardKey::Escape:
        return "Escape";
    case KeyboardKey::Delete:
        return "Delete";
    case KeyboardKey::Insert:
        return "Insert";
    case KeyboardKey::Home:
        return "Home";
    case KeyboardKey::End:
        return "End";
    case KeyboardKey::PageUp:
        return "Page Up";
    case KeyboardKey::PageDown:
        return "Page Down";
    case KeyboardKey::Backspace:
        return "Backspace";
    case KeyboardKey::Enter:
        return "Enter";
    case KeyboardKey::Space:
        return "Space";
    case KeyboardKey::LeftShift:
        return "Left Shift";
    case KeyboardKey::RightShift:
        return "Right Shift";
    case KeyboardKey::LeftControl:
        return "Left Control";
    case KeyboardKey::RightControl:
        return "Right Control";
    case KeyboardKey::LeftAlt:
        return "Left Alt";
    case KeyboardKey::RightAlt:
        return "Right Alt";
    case KeyboardKey::PrintScreen:
        return "Print Screen";
    case KeyboardKey::Break:
        return "Break";
    case KeyboardKey::Grave:
        return "`";
    case KeyboardKey::Tab:
        return "Tab";
    case KeyboardKey::CapsLock:
        return "Caps Lock";
    case KeyboardKey::NumLock:
        return "Num Lock";
    case KeyboardKey::ScrollLock:
        return "Scroll Lock";
    case KeyboardKey::LeftSuper:
        return "Left Super";
    case KeyboardKey::RightSuper:
        return "Right Super";
    case KeyboardKey::Menu:
        return "Menu";
    case KeyboardKey::Left:
        return "Left";
    case KeyboardKey::Right:
        return "Right";
    case KeyboardKey::Up:
        return "Up";
    case KeyboardKey::Down:
        return "Down";
    case KeyboardKey::Minus:
        return "-";
    case KeyboardKey::Equals:
        return "=";
    case KeyboardKey::Semicolon:
        return ";";
    case KeyboardKey::Quote:
        return "'";
    case KeyboardKey::Slash:
        return "/";
    case KeyboardKey::Backslash:
        return "\\";
    case KeyboardKey::Comma:
        return ",";
    case KeyboardKey::Period:
        return ".";
    case KeyboardKey::LeftBracket:
        return "[";
    case KeyboardKey::RightBracket:
        return "]";
    default: ;
    }

    return string();
};

} // namespace Toon

#endif // TOON_KEYBOARD_HPP

```

`Engine/Public/Toon/Light.hpp`:

```hpp
#ifndef TOON_LIGHT_H
#define TOON_LIGHT_H

#include <Toon/Config.hpp>
#include <Toon/Entity.hpp>
#include <Toon/Math.hpp>
#include <Toon/ShaderScene.hpp>

namespace Toon {

enum class LightType
{
    Point = 0,
    Spot = 1,
    Directional = 2,

}; // enum class LightType

class TOON_ENGINE_API Light : public Entity
{
public:

    DISALLOW_COPY_AND_ASSIGN(Light)

    Light() = default;

    virtual ~Light() = default;

    void SetType(LightType type);

    inline LightType GetType() const {
        return _type;
    }

    void FillLightData(LightData1 * data);

    void SetColor(glm::vec3 color);

    inline glm::vec3 GetColor() const {
        return _color;
    }

    // Spot
    void SetInnerCutOff(float cutOff);

    inline float GetInnerCutOff() const {
        return _innerCutOff;
    }
    void SetOuterCutOff(float cutOff);

    inline float GetOuterCutOff() const {
        return _outerCutOff;
    }

private:

    LightType _type;

    glm::vec3 _color;

    // Spot

    float _innerCutOff;

    float _outerCutOff;
};

} // namespace Toon

#endif // TOON_LIGHT_H
```

`Engine/Public/Toon/Log.hpp`:

```hpp
#ifndef TOON_LOG_HPP
#define TOON_LOG_HPP

#include <Toon/Util.hpp>
#include <Toon/Macros.hpp>

#include <cstdio> // for printf, vsnprintf

#if !defined(TOON_PLATFORM_WINDOWS)

    #include <unistd.h>

#endif

namespace Toon {

    enum class LogLevel {
        Fatal,
        Error,
        Warning,
        Info,
        Performance,
        Load,
        Verbose,
    };

    TOON_ENGINE_API
    bool AddLogFile(const string& filename);

    TOON_ENGINE_API
    std::vector<FILE *> GetAllLogFiles();

    TOON_ENGINE_API
    void CloseAllLogFiles();


    template <class T>
    static auto LogWrap(const T& v) {
        return v;
    }

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

    template <>
    auto LogWrap<string>(const string& v) {
        return v.c_str();
    }

    template <>
    inline auto LogWrap<Path>(const Path& v) {
        return v.ToCString();
    }

    #if defined(DUSK_PLATFORM_WINDOWS)

        template <>
        inline auto LogWrap<WindowsErrorMessage>(const WindowsErrorMessage& v) {
            return v.GetMessage();
        }

    #endif

#pragma clang diagnostic pop

template <class ...Args>
static inline void Log(LogLevel level, const char* format, Args... args)
{
    #if defined(TOON_PLATFORM_WINDOWS)

        static HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

        const int DEFAULT = 7;

        int color = DEFAULT;

        switch (level)
        {
        case LogLevel::Info:
            color = 7; // White
            break;
        case LogLevel::Warning:
            color = 6; // Yellow
            break;
        case LogLevel::Error:
        case LogLevel::Fatal:
            color = 4; // Red
            break;
        case LogLevel::Performance:
            color = 5; // Magenta
            break;
        case LogLevel::Verbose:
            color = 8; // Grey
            break;
        case LogLevel::Load:
            color = 2; // Green
            break;
        }

        SetConsoleTextAttribute(hConsole, color);

    #else
    
        static bool isTTY = isatty(fileno(stdout));

        const char * Default = "0;39";

        const char * color = Default;

        switch (level)
        {
        case LogLevel::Info:
            color = "0;97"; // White
            break;
        case LogLevel::Warning:
            color = "0;33"; // Yellow
            break;
        case LogLevel::Error:
        case LogLevel::Fatal:
            color = "0;31"; // Red
            break;
        case LogLevel::Performance:
            color = "0;35"; // Magenta
            break;
        case LogLevel::Verbose:
            color = "1;37"; // Grey
            break;
        case LogLevel::Load:
            color = "0;32"; // Green
            break;
        }

        if (isTTY) {
            printf("\033[%sm", color);
        }


    #endif

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-security"

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-security"
        
    printf(format, LogWrap(args)...);

    const auto& logFiles = GetAllLogFiles();
    for (FILE * file : logFiles) {
        fprintf(file, format, LogWrap(args)...);
        fflush(file);
    }

#pragma clang diagnostic pop

#pragma GCC diagnostic pop

#if defined(TOON_PLATFORM_WINDOWS)

        SetConsoleTextAttribute(hConsole, DEFAULT);

#else

        if (isTTY) {
            printf("\033[%sm", Default);
        }

#endif
}

#if !defined(TOON_SOURCE_PATH_LENGTH)
    #define TOON_SOURCE_PATH_LENGTH 0
#endif

#define TOON_FILENAME (&__FILE__[TOON_SOURCE_PATH_LENGTH])

#ifndef TOON_ENABLE_VERBOSE_LOGGING
#   define ToonLogVerbose(M, ...)  do { } while(0)
#else
#   define ToonLogVerbose(M, ...) \
        do { Log(Toon::LogLevel::Verbose, "[VERB](%s:%d) " M "\n", \
        TOON_FILENAME, __LINE__, ##__VA_ARGS__); } while (0)
#endif

#define ToonLogInfo(M, ...) \
    do { Log(Toon::LogLevel::Info, "[INFO](%s:%d) " M "\n", \
        TOON_FILENAME, __LINE__, ##__VA_ARGS__); } while (0)

#define ToonLogWarn(M, ...) \
    do { Log(Toon::LogLevel::Warning, "[WARN](%s:%d) " M "\n", \
        TOON_FILENAME, __LINE__, ##__VA_ARGS__); } while (0)

#define ToonLogError(M, ...) \
    do { Log(Toon::LogLevel::Error, "[ERRO](%s:%d) " M "\n", \
        TOON_FILENAME, __LINE__, ##__VA_ARGS__); } while (0)

#define ToonLogFatal(M, ...) \
    do { Log(Toon::LogLevel::Fatal, "[FATL](%s:%d) " M "\n", \
        TOON_FILENAME, __LINE__, ##__VA_ARGS__); \
        std::terminate(); } while (0)

#define ToonLogPerf(M, ...) \
    do { Log(Toon::LogLevel::Performance, "[PERF](%s:%d) " M "\n", \
        TOON_FILENAME, __LINE__, ##__VA_ARGS__); } while (0)

#define ToonLogLoad(M, ...) \
    do { Log(Toon::LogLevel::Load, "[LOAD](%s:%d) " M "\n", \
        TOON_FILENAME, __LINE__, ##__VA_ARGS__); } while (0)

} // namespace Toon
#endif // TOON_LOG_HPP
```

`Engine/Public/Toon/Macros.hpp`:

```hpp
#ifndef TOON_MACROS_HPP
#define TOON_MACROS_HPP

#include <Toon/Platform.hpp>

#define DISALLOW_COPY_AND_ASSIGN(TypeName)          \
    TypeName(const TypeName&) = delete;             \
    TypeName& operator=(const TypeName&) = delete;

#define TOON_STRINGIFY(x) _TOON_STRINGIFY(x)
#define _TOON_STRINGIFY(x) #x

#if defined(TOON_COMPILER_MSVC)
    #define TOON_FUNCTION_NAME() __FUNCSIG__
#elif defined(TOON_COMPILER_GCC) || defined(TOON_COMPILER_CLANG)
    #define TOON_FUNCTION_NAME() __PRETTY_FUNCTION__
#else
    #define TOON_FUNCTION_NAME() __func__
#endif

#if defined(TOON_COMPILER_MSVC)
    #define DISABLE_WARNINGS() \
        _Pragma("warning(push, 0)")
    
    #define ENABLE_WARNINGS() \
        _Pragma("warning(pop)")
#elif defined(TOON_COMPILER_GCC)
    #define DISABLE_WARNINGS() \
        _Pragma("GCC diagnostic push")                      \
        _Pragma("GCC diagnostic ignored \"-Wall\"")
    
    #define ENABLE_WARNINGS() \
        _Pragma("GCC diagnostic pop")
#elif defined(TOON_COMPILER_CLANG)
    #define DISABLE_WARNINGS() \
        _Pragma("clang diagnostic push")                    \
        _Pragma("clang diagnostic ignored \"-Wall\"")
    
    #define ENABLE_WARNINGS() \
        _Pragma("clang diagnostic pop")
#else
    #define DISABLE_WARNINGS()
#endif

#endif // TOON_MACROS_HPP
```

`Engine/Public/Toon/Material.hpp`:

```hpp
#ifndef TOON_MATERIAL_HPP
#define TOON_MATERIAL_HPP

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>
#include <Toon/Buffer.hpp>
#include <Toon/Texture.hpp>
#include <Toon/ShaderMaterial.hpp>

namespace Toon {

class TOON_ENGINE_API Material
{
public:

    DISALLOW_COPY_AND_ASSIGN(Material)

    Material() = default;

    virtual ~Material() = default;

    virtual void Initialize();

    virtual void Terminate();

    virtual inline glm::vec4 GetBaseColorFactor() const {
        return _shaderMaterial.BaseColorFactor;
    }

    virtual inline glm::vec3 GetEmissiveFactor() const {
        return _shaderMaterial.EmissiveFactor;
    }

    virtual inline float GetMetallicFactor() const {
        return _shaderMaterial.MetallicFactor;
    }

    virtual inline float GetRoughnessFactor() const {
        return _shaderMaterial.RoughnessFactor;
    }

    virtual inline float GetOcclusionStrength() const {
        return _shaderMaterial.OcclusionStrength;
    }

    virtual inline float GetNormalScale() const {
        return _shaderMaterial.NormalScale;
    }

    virtual inline void SetBaseColorFactor(glm::vec4 factor) {
        _shaderMaterial.BaseColorFactor = factor;
        UpdateBuffer();
    }

    virtual inline void SetEmissiveFactor(glm::vec3 factor) {
        _shaderMaterial.EmissiveFactor = factor;
        UpdateBuffer();
    }

    virtual inline void SetMetallicFactor(float factor) {
        _shaderMaterial.MetallicFactor = factor;
        UpdateBuffer();
    }

    virtual inline void SetRoughnessFactor(float factor) {
        _shaderMaterial.RoughnessFactor = factor;
        UpdateBuffer();
    }

    virtual inline void SetOcclusionStrength(float strength) {
        _shaderMaterial.OcclusionStrength = strength;
        UpdateBuffer();
    }

    virtual inline void SetNormalScale(float scale) {
        _shaderMaterial.NormalScale = scale;
        UpdateBuffer();
    }

    virtual inline void SetBaseColorMap(std::shared_ptr<Texture> map) {
        _baseColorMap = map;
    }

    virtual inline void SetNormalMap(std::shared_ptr<Texture> map) {
        _normalMap = map;
    }

    virtual inline void SetMetallicRoughnessMap(std::shared_ptr<Texture> map) {
        _metallicRoughnessMap = map;
    }

    virtual inline void SetEmissiveMap(std::shared_ptr<Texture> map) {
        _emissiveMap = map;
    }

    virtual inline void SetOcclusionMap(std::shared_ptr<Texture> map) {
        _occlusionMap = map;
    }

    virtual inline std::shared_ptr<Texture> GetBaseColorMap() {
        return _baseColorMap;
    }

    virtual inline std::shared_ptr<Texture> GetNormalMap() {
        return _normalMap;
    }

    virtual inline std::shared_ptr<Texture> GetMetallicRoughnessMap() {
        return _metallicRoughnessMap;
    }

    virtual inline std::shared_ptr<Texture> GetEmissiveMap() {
        return _emissiveMap;
    }

    virtual inline std::shared_ptr<Texture> GetOcclusionMap() {
        return _occlusionMap;
    }

    // TODO: Fix buffer thrashing when setting multiple variables
    virtual void UpdateBuffer();

protected:

    std::shared_ptr<Buffer> _shaderMaterialBuffer;

    ShaderMaterial _shaderMaterial;

    std::shared_ptr<Texture> _baseColorMap;

    std::shared_ptr<Texture> _normalMap;

    std::shared_ptr<Texture> _metallicRoughnessMap;

    std::shared_ptr<Texture> _emissiveMap;

    std::shared_ptr<Texture> _occlusionMap;

}; // class Material

} // namespace Toon


    // Lambert (Phong/BlinnPhong)
    // - Ambient
    // - Diffuse
    // - Specular*
    // - Shininess*
    // * (not exactly used in Lambert due to removing the 'matte' effect that is lambert)

    // Principled BSDF (Ref: Blender)
    // - Subsurface
    // - Subsurface Radius
    // - Subsurface Color
    // - Base Color
    // - Metallic
    // - Specular
    // - Specular Tint
    // - Roughness
    // - Anisotropic
    // - Anisotropic Rotation
    // - Sheen
    // - Sheen Tint
    // - Clearcoat
    // - Clearcoat Roughness
    // - IOR
    // - Transmission
    // - Transmission Roughness
    // - Emission
    // - Alpha
    // - Normal
    // - Clearcoat Normal
    // - Tangent

    // PBR (Ref: Unreal Engine)
    // - Base Color
    // - Metallic
    // - Specular
    // - Roughness
    // - Anisotropy
    // - Emissive Color
    // - Opacity
    // - Opacity Mask
    // - Normal
    // - Tangent
    // - World Position Offset
    // - World Displacement
    // - Tessellation Multiplier
    // - Subsurface Color
    // - Custom Data 0?
    // - Custom Data 1?
    // - Ambient Occlusion
    // - Refraction
    // - Pixel Depth Offset
    // - Shading Model

    // Bare Minimum:
    // - Base Color
    // - Metallic
    // - Roughness
    // - Emissive
    // - Ambient Occlusion
    // - Normal


#endif // TOON_MATERIAL_HPP
```

`Engine/Public/Toon/Math.hpp`:

```hpp
#ifndef MATH_HPP
#define MATH_HPP

#define GLM_ENABLE_EXPERIMENTAL
#define GLM_FORCE_RIGHT_HANDED
#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <glm/ext.hpp>

#include <limits>

namespace Toon {

using glm::quat;

using glm::mat2;
using glm::mat3;
using glm::mat4;

using glm::vec2;
using glm::vec3;
using glm::vec4;

using glm::bvec2;
using glm::bvec3;
using glm::bvec4;

using glm::ivec2;
using glm::ivec3;
using glm::ivec4;

using glm::uvec2;
using glm::uvec3;
using glm::uvec4;

template <typename T>
constexpr float NormalizeInteger(T value)
{
    return (
        value < 0 
        ? -static_cast<float>(value) / static_cast<float>(std::numeric_limits<T>::min())
        :  static_cast<float>(value) / static_cast<float>(std::numeric_limits<T>::max())
    );
}

} // namespace Toon

#endif // MATH_HPP
```

`Engine/Public/Toon/Mesh.hpp`:

```hpp
#ifndef TOON_MESH_HPP
#define TOON_MESH_HPP

#include <Toon/Config.hpp>
#include <Toon/Buffer.hpp>
#include <Toon/Primitive.hpp>
#include <Toon/PrimitiveData.hpp>
#include <Toon/Pipeline.hpp>
#include <Toon/RenderContext.hpp>
#include <Toon/Texture.hpp>

#include <vector>
#include <memory>

namespace Toon {

class TOON_ENGINE_API Mesh
{
public:

    DISALLOW_COPY_AND_ASSIGN(Mesh)

    Mesh() = default;

    virtual ~Mesh() = default;

    virtual bool Initialize();

    virtual void Terminate();

    virtual bool Load(const std::vector<std::unique_ptr<PrimitiveData>>& data);

    virtual void Render(RenderContext * ctx) = 0;

    virtual void SetPipeline(std::shared_ptr<Pipeline> pipeline) {
        _pipeline = pipeline;
    }

protected:

    std::vector<std::shared_ptr<Primitive>> _primitiveList;

    std::shared_ptr<Pipeline> _pipeline;

    std::shared_ptr<Buffer> _shaderTransformBuffer;

}; // class Mesh

TOON_ENGINE_API
std::shared_ptr<Mesh> LoadMeshFromFile(const string& filename);

} // namespace Toon

#endif // TOON_MESH_HPP
```

`Engine/Public/Toon/MeshComponent.hpp`:

```hpp
#ifndef TOON_MESH_COMPONENT_HPP
#define TOON_MESH_COMPONENT_HPP

#include <Toon/Config.hpp>
#include <Toon/Buffer.hpp>
#include <Toon/Component.hpp>
#include <Toon/Mesh.hpp>

#include <memory>
#include <vector>

namespace Toon {

class TOON_ENGINE_API MeshComponent : public Component
{
public:
    DISALLOW_COPY_AND_ASSIGN(MeshComponent)

    MeshComponent() = default;

    MeshComponent(std::shared_ptr<Mesh> mesh);

    virtual ~MeshComponent() = default;

    void SetMesh(std::shared_ptr<Mesh> mesh);
    
    void Render(RenderContext * ctx) override;

private:

    std::shared_ptr<Mesh> _mesh;

}; // class MeshComponent

} // namespace Toon

#endif // TOON_MESH_COMPONENT_HPP
```

`Engine/Public/Toon/MeshImporter.hpp`:

```hpp
#ifndef TOON_MESH_IMPORTER_HPP
#define TOON_MESH_IMPORTER_HPP

#include <Toon/Config.hpp>
#include <Toon/Mesh.hpp>

#include <Toon/String.hpp>
#include <memory>
#include <vector>

namespace Toon {

class TOON_ENGINE_API MeshImporter
{
public:
    DISALLOW_COPY_AND_ASSIGN(MeshImporter)

    MeshImporter() = default;

    virtual ~MeshImporter() = default;

    virtual std::vector<std::unique_ptr<PrimitiveData>> LoadFromFile(const string& filename, bool useAssetPath = true) = 0;
    
}; // class MeshImporter

TOON_ENGINE_API
void AddMeshImporter(const string& id, std::unique_ptr<MeshImporter> importer);

TOON_ENGINE_API
void RemoveMeshImporter(const string& id);

TOON_ENGINE_API
const std::vector<MeshImporter*>& GetAllMeshImporters();

} // namespace Toon

#endif // TOON_MESH_IMPORTER_HPP
```

`Engine/Public/Toon/Module.hpp`:

```hpp
#ifndef TOON_MODULE_HPP
#define TOON_MODULE_HPP

#include <Toon/Config.hpp>
#include <Toon/Version.hpp>

#include <Toon/String.hpp>

#include <initializer_list>

namespace Toon {

struct TOON_ENGINE_API ToonModule {
    const char * Name;
    bool (*Initialize)();
    void (*Terminate)();
};

TOON_ENGINE_API
bool LoadModule(const string& name);

TOON_ENGINE_API
void FreeModule(const string& name);

TOON_ENGINE_API
void FreeAllModules();

#define TOON_MODULE \
    extern "C" TOON_API_EXPORT struct ToonModule _ToonModule =

}

#endif // TOON_MODULE_HPP
```

`Engine/Public/Toon/Mouse.hpp`:

```hpp
#ifndef TOON_MOUSE_HPP
#define TOON_MOUSE_HPP

#include <Toon/Config.hpp>

#include <Toon/String.hpp>

namespace Toon {

enum class MouseButton
{
    Unknown = -1,

    Left,
    Right,
    Middle,

}; // enum MouseButton

static inline string GetMouseButtonName(MouseButton button)
{
    switch(button) {
    case MouseButton::Left:
        return "Left";
    case MouseButton::Right:
        return "Right";
    case MouseButton::Middle:
        return "Middle";
    default: ;
    }

    return string();
};

} // namespace Toon

#endif // TOON_MOUSE_HPP

```

`Engine/Public/Toon/Path.hpp`:

```hpp
#ifndef TOON_PATH_HPP
#define TOON_PATH_HPP

#include <Toon/Config.hpp>
#include <Toon/String.hpp>

#include <vector>

namespace Toon {

// class PathIterator;

class TOON_ENGINE_API Path
{
public:

    // typedef PathIterator Iterator;
    // typedef PathIterator ConstIterator;

    static const char Separator = TOON_PATH_SLASH;

    Path() = default;

    Path(const Path& rhs);

    Path(const string& str);

    Path(const char * cstr);

    // Appends a new element to the path with a separator
    Path& Append(const Path& rhs);

    // Concatenates the paths without adding a separator
    Path& Concatenate(const Path& rhs);

    inline string ToString() const {
        return _path;
    }

    inline const char * ToCString() const {
        return _path.c_str();
    }

    inline operator string() const {
        return _path;
    }

    inline bool IsAbsolute() const {
        return HasRootDirectory();
    }

    inline bool IsRelative() const {
        return !HasRootDirectory();
    }

    inline bool HasRootName() const {
        return (GetRootNameLength() > 0);
    }

    /// The root identifier on a filesystem with multiple roots, such as "C:" or "//server"
    inline Path GetRootName() const {
        return _path.substr(0, GetRootNameLength());
    }

    inline bool HasRootDirectory() const {
        size_t rootNameLen = GetRootNameLength();
        return (_path.length() > rootNameLen && _path[rootNameLen] == Separator);
    }

    inline Path GetRootDirectory() const {
        if (HasRootDirectory()) {
            return string(1, Separator);
        }
        return Path();
    }

    inline bool HasRootPath() const {
        return (HasRootName() || HasRootDirectory());
    }

    inline Path GetRootPath() const {
        return GetRootName() + GetRootDirectory();
    }

    inline Path GetParentPath() const {
        size_t pivot = _path.find_last_of(Separator);
        return (
            pivot <= GetRootNameLength() || pivot == string::npos
            ? _path
            : _path.substr(0, pivot)
        );
    }

    inline Path GetFilename() const {
        size_t pivot = _path.find_last_of(Separator);
        return (
            pivot <= GetRootNameLength() || pivot == string::npos
            ? _path
            : _path.substr(pivot + 1)
        );
    }

    inline Path GetStem() const {
        string filename = GetFilename();
        size_t pivot = filename.find_last_of('.');
        return (
            pivot == 0 || pivot == string::npos
            ? filename
            : filename.substr(0, pivot)
        );
    }

    inline Path GetExtension() const {
        string filename = GetFilename();
        size_t pivot = filename.find_last_of('.');
        return (
            pivot == 0 || pivot == string::npos
            ? string()
            : filename.substr(pivot + 1)
        );
    }

    inline Path& operator=(const Path& rhs) {
        _path = rhs._path;
        return *this;
    }

    inline Path& operator/=(const Path& rhs) {
        return Append(rhs);
    }

    inline Path& operator+=(const Path& rhs) {
        return Concatenate(rhs);
    }

    bool Equals(const Path& rhs) const;

    inline friend bool operator==(const Path& lhs, const Path& rhs) {
        return lhs.Equals(rhs);
    }

    inline friend bool operator!=(const Path& lhs, const Path& rhs) {
        return !lhs.Equals(rhs);
    }

    inline friend Path operator/(const Path& lhs, const Path& rhs)
    {
        Path tmp(lhs);
        tmp /= rhs;
        return tmp;
    }

    inline friend Path operator+(const Path& lhs, const Path& rhs)
    {
        Path tmp(lhs);
        tmp += rhs;
        return tmp;
    }

    // std::vector<string> GetParts() const;

    // Iterator begin();

    // Iterator end();

    // ConstIterator begin() const;

    // ConstIterator end() const;

private:

    void Normalize();

    size_t GetRootNameLength() const;

    string _path;

}; // class Path

// class TOON_ENGINE_API Path::Iterator
// {
// public:

    

// }; // class Iterator

TOON_ENGINE_API
Path GetCurrentPath();

} // namespace Toon

#endif // TOON_PATH_HPP
```

`Engine/Public/Toon/Pipeline.hpp`:

```hpp
#ifndef TOON_PIPELINE_HPP
#define TOON_PIPELINE_HPP

#include <Toon/Config.hpp>

#include <Toon/Shader.hpp>
#include <Toon/Primitive.hpp>

#include <memory>

namespace Toon {

enum class FrontFace
{
    Clockwise,
    CounterClockwise,
}; // enum class FrontFace

enum class CullMode
{
    None,
    Front,
    Back,
}; // enum class CullMode

enum class FillMode
{
    Fill,
    Line,
}; // enum class FillMode

enum class DepthBiasMode
{
    Clamp,
    Clip,
}; // enum class DepthBiasMode

enum class BlendOperation
{
    Add,
    Subtract,
    ReverseSubtract,
    Min,
    Max,
}; // enum class BlendOperation

enum class BlendFactor
{
    Zero,
    One,
    SrcColor,
    OneMinusSrcColor,
    SrcAlpha,
    OneMinusSrcAlpha,
    DstColor,
    OneMinusDstColor,
    DstAlpha,
    OneMinusDstAlpha,
    ConstantColor,
    OneMinusConstantColor,
    ConstantAlpha,
    OneMinusConstantAlpha,
    SrcAlphaSaturated, // TODO: Investigate
}; // enum class BlendFactor

enum class CompareOperation
{
    Never,
    Less,
    LessOrEqual,
    Greater,
    GreaterOrEqual,
    Equal,
    NotEqual,
    Always,
}; // enum class CompareOperation

class TOON_ENGINE_API Pipeline
{
public:

    DISALLOW_COPY_AND_ASSIGN(Pipeline)

    Pipeline() = default;

    virtual ~Pipeline() = default;

    inline virtual bool Initialize(std::shared_ptr<Shader> shader) {
        _shader = shader;
        return true;
    }

    inline virtual void Terminate() {
        _shader.reset();
    }

    inline void SetShader(std::shared_ptr<Shader> shader) {
        _shader = shader;
        // Reset?
    }

    inline void SetPrimitiveTopology(PrimitiveTopology primitiveTopology) {
        _primitiveTopology = primitiveTopology;
    }

    inline void SetFrontFace(FrontFace frontFace) {
        _frontFace = frontFace;
    }

    inline void SetCullMode(CullMode mode) {
        _cullMode = mode;
    }

    inline void SetFillMode(FillMode mode) {
        _fillMode = mode;
    }

    inline void SetDepthBiasFactor(float factor) {
        _depthBiasFactor = factor;
    }

    inline void SetDepthBiasSlopeFactor(float factor) {
        _depthBiasSlopeFactor = factor;
    }

    inline void SetDepthBiasClamp(float clamp) {
        _depthBiasClamp = clamp;
    }

    inline void SetDepthBiasMode(DepthBiasMode mode) {
        _depthBiasMode = mode;
    }

    inline void SetDepthCompareOperation(CompareOperation op) {
        _depthCompareOperation = op;
    }

protected:

    std::shared_ptr<Shader> _shader = nullptr;

    PrimitiveTopology _primitiveTopology = PrimitiveTopology::TriangleList;

    FrontFace _frontFace = FrontFace::CounterClockwise;

    CullMode _cullMode = CullMode::Back;

    FillMode _fillMode = FillMode::Fill;

    float _depthBiasFactor = 0.0f;

    float _depthBiasSlopeFactor = 0.0f;

    float _depthBiasClamp = 0.0f;

    DepthBiasMode _depthBiasMode = DepthBiasMode::Clip;

    CompareOperation _depthCompareOperation = CompareOperation::Less;

    bool _blendEnabled = false;

    BlendOperation _colorBlendOp = BlendOperation::Add;

    BlendOperation _alphaBlendOp = BlendOperation::Add;

    BlendFactor _srcColorFactor = BlendFactor::One;

    BlendFactor _dstColorFactor = BlendFactor::One;

    BlendFactor _srcAlphaFactor = BlendFactor::One;

    BlendFactor _dstAlphaFactor = BlendFactor::One;
    
}; // class Pipeline

inline string FrontFaceToString(FrontFace frontFace)
{
    switch (frontFace) {
    case FrontFace::Clockwise:
        return "Clockwise";
    case FrontFace::CounterClockwise:
        return "CounterClockwise";
    }

    return "Unknown";
}

inline string CullModeToString(CullMode cullMode)
{
    switch (cullMode) {
    case CullMode::None:
        return "None";
    case CullMode::Front:
        return "Front";
    case CullMode::Back:
        return "Back";
    }

    return "Unknown";
}

inline string CullModeToString(FillMode fillMode)
{
    switch (fillMode) {
    case FillMode::Fill:
        return "Fill";
    case FillMode::Line:
        return "Line";
    }

    return "Unknown";
}

inline string DepthBiasModeToString(DepthBiasMode depthBiasMode)
{
    switch (depthBiasMode) {
    case DepthBiasMode::Clamp:
        return "Clamp";
    case DepthBiasMode::Clip:
        return "Clip";
    }

    return "Unknown";
}

inline string BlendOperationToString(BlendOperation blendOperation)
{
    switch (blendOperation) {
    case BlendOperation::Add:
        return "Add";
    case BlendOperation::Subtract:
        return "Subtract";
    case BlendOperation::ReverseSubtract:
        return "ReverseSubtract";
    case BlendOperation::Min:
        return "Min";
    case BlendOperation::Max:
        return "Max";
    }

    return "Unknown";
}

inline string BlendFactorToString(BlendFactor blendFactor)
{
    switch (blendFactor) {
        case BlendFactor::Zero:
            return "Zero";
        case BlendFactor::One:
            return "One";
        case BlendFactor::SrcColor:
            return "SrcColor";
        case BlendFactor::OneMinusSrcColor:
            return "OneMinusSrcColor";
        case BlendFactor::SrcAlpha:
            return "SrcAlpha";
        case BlendFactor::OneMinusSrcAlpha:
            return "OneMinusSrcAlpha";
        case BlendFactor::DstColor:
            return "DstColor";
        case BlendFactor::OneMinusDstColor:
            return "OneMinusDstColor";
        case BlendFactor::DstAlpha:
            return "DstAlpha";
        case BlendFactor::OneMinusDstAlpha:
            return "OneMinusDstAlpha";
        case BlendFactor::ConstantColor:
            return "ConstantColor";
        case BlendFactor::OneMinusConstantColor:
            return "OneMinusConstantColor";
        case BlendFactor::ConstantAlpha:
            return "ConstantAlpha";
        case BlendFactor::OneMinusConstantAlpha:
            return "OneMinusConstantAlpha";
        case BlendFactor::SrcAlphaSaturated:
            return "SrcAlphaSaturated";
    }

    return "Unknown";
}

inline string CompareOperationToString(CompareOperation compareOperation)
{
    switch (compareOperation) {
        case CompareOperation::Never:
            return "Never";
        case CompareOperation::Less:
            return "Less";
        case CompareOperation::LessOrEqual:
            return "LessOrEqual";
        case CompareOperation::Greater:
            return "Greater";
        case CompareOperation::GreaterOrEqual:
            return "GreaterOrEqual";
        case CompareOperation::Equal:
            return "Equal";
        case CompareOperation::NotEqual:
            return "NotEqual";
        case CompareOperation::Always:
            return "Always";
    }

    return "Unknown";
}

} // namespace Toon

#endif // TOON_PIPELINE_HPP
```

`Engine/Public/Toon/Platform.hpp`:

```hpp
#ifndef TOON_PLATFORM_HPP
#define TOON_PLATFORM_HPP

#if defined(_WIN32)

    // Windows
    #define TOON_PLATFORM_WINDOWS

    #ifdef __has_include
        #if __has_include(<winapifamily.h>)
            #include <winapifamily.h>
            #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
                // Universal Windows Platform
                #define DUSK_PLATFORM_UWP
            #endif
        #endif
    #endif

#elif defined(__APPLE__) && defined(__MACH__)

    #define TOON_PLATFORM_APPLE
    
    // Apple
    #include "TargetConditionals.h"

    #if TARGET_PLATFORM_IPHONE || TARGET_IPHONE_SIMULATOR
        // iPhone iOS
        #define TOON_PLATFORM_IOS
    #elif TARGET_PLATFORM_MAC
        // Mac OSX
        #define TOON_PLATFORM_OSX
    #endif

#elif defined(__unix__)

    #if defined(__ANDROID__)
        // Android
        #define TOON_PLATFORM_ANDROID
    #elif defined(__linux__)
        // Linux
        #define TOON_PLATFORM_LINUX
    #else
        #error Unsupported UNIX Operating System
    #endif

#else

    // Unknown
    #error Unsupported Operating System

#endif

#if defined(_MSC_VER)

    // Microsoft VisualStudio C/C++
    #define TOON_COMPILER_MSVC _MSC_VER

#elif defined(__clang__)

    // Apple Clang Compiler
    #define TOON_COMPILER_CLANG __clang__

#elif defined(__GNUC__) || defined(__GNUG__)
    
    // GNU Compiler Collection
    #define TOON_COMPILER_GCC __GNUC__

#elif defined(__ICC) || defined(__INTEL_COMPILER)

    #define TOON_COMPILER_ICC __INTEL_COMPILER

#else

    // Unknown
    #warning Unsupported Compiler

#endif

#if defined(NDEBUG)

    #define TOON_BUILD_RELEASE

#else

    #define TOON_BUILD_DEBUG

#endif

#if defined(TOON_PLATFORM_WINDOWS)

    #define TOON_PATH_SLASH '\\'
    #define TOON_PATH_SEPARATOR ';'

    // Disable min/max defines
    #define NOMINMAX

    // Disable python defines for snprintf/vsnprintf
    #define HAVE_SNPRINTF

    // Disable extra includes from Windows.h
    #define VC_EXTRALEAN

    #include <Windows.h>

    #undef LoadModule
    #undef FreeModule
    #undef CreateWindow
    
    #undef OPAQUE

#else

    #define TOON_PATH_SLASH '/'
    #define TOON_PATH_SEPARATOR ':'

#endif

#endif // TOON_PLATFORM_HPP
```

`Engine/Public/Toon/Primitive.hpp`:

```hpp
#ifndef TOON_PRIMITIVE_HPP
#define TOON_PRIMITIVE_HPP

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>
#include <Toon/Vertex.hpp>
#include <Toon/Material.hpp>

#include <memory>

namespace Toon {

enum class PrimitiveTopology 
{
    PointList,
    LineList,
    LineStrip,
    TriangleList,
    TriangleStrip,

}; // enum class PrimitiveTopology

class PrimitiveData;

class TOON_ENGINE_API Primitive
{
public:

    DISALLOW_COPY_AND_ASSIGN(Primitive)

    Primitive() = default;

    virtual ~Primitive() = default;

    virtual void Terminate() { }

    virtual bool Load(const std::unique_ptr<PrimitiveData>& data) = 0;

    virtual inline void SetMaterial(std::shared_ptr<Material> material) {
        _material = material;
    }

    virtual inline std::shared_ptr<Material> GetMaterial() {
        return _material;
    }

protected:

    std::shared_ptr<Material> _material;

}; // class Primitive

inline string PrimitiveTopologyToString(PrimitiveTopology primitiveTopology)
{
    switch (primitiveTopology) {
    case PrimitiveTopology::PointList:
        return "Points";
    case PrimitiveTopology::LineList:
        return "Lines";
    case PrimitiveTopology::LineStrip:
        return "LineStrip";
    case PrimitiveTopology::TriangleList:
        return "TriangleList";
    case PrimitiveTopology::TriangleStrip:
        return "TriangleStrip";
    }

    return "Unknown";
}

} // namespace Toon

#endif // TOON_PRIMITIVE_HPP
```

`Engine/Public/Toon/PrimitiveData.hpp`:

```hpp
#ifndef TOON_PRIMITIVE_DATA_HPP
#define TOON_PRIMITIVE_DATA_HPP

#include <Toon/Config.hpp>
#include <Toon/Primitive.hpp>

#include <gsl/gsl>

namespace Toon {

class TOON_ENGINE_API PrimitiveData
{
public:

    DISALLOW_COPY_AND_ASSIGN(PrimitiveData)

    PrimitiveData() = default;

    virtual ~PrimitiveData() = default;

    virtual PrimitiveTopology GetTopology() const = 0;

    virtual gsl::span<uint32_t> GetIndexList() {
        return gsl::span<uint32_t>();
    }
    
    virtual gsl::span<Vertex> GetVertexList() = 0;

    virtual std::shared_ptr<Material> GetMaterial() {
        return nullptr;
    }

    virtual void CalculateTangents();

}; // class PrimitiveData

} // namespace Toon

#endif // TOON_PRIMITIVE_DATA_HPP
```

`Engine/Public/Toon/RenderContext.hpp`:

```hpp
#ifndef TOON_RENDER_CONTEXT_HPP
#define TOON_RENDER_CONTEXT_HPP

#include <Toon/Config.hpp>
#include <Toon/ShaderGlobals.hpp>
#include <Toon/ShaderTransform.hpp>

namespace Toon {

class TOON_ENGINE_API RenderContext
{
public:

    DISALLOW_COPY_AND_ASSIGN(RenderContext)

    RenderContext() = default;

    virtual ~RenderContext() = default;

    virtual ShaderGlobals * GetShaderGlobals() {
        return &_shaderGlobals;
    }

    virtual ShaderTransform* GetShaderTransform() {
        return &_shaderTransform;
    }

private:

    ShaderGlobals _shaderGlobals;

    ShaderTransform _shaderTransform;
    
}; // class RenderContext

} // namesapce Toon

#endif // TOON_RENDER_CONTEXT_HPP
```

`Engine/Public/Toon/Rigidbody.hpp`:

```hpp
#ifndef RIGIDBODY_H
#define RIGIDBODY_H

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>

namespace Toon {

class Entity;

class Rigidbody
{
public:
    void AddForce(const glm::vec3 force);
    void SetMass(const float mass);
    void UpdateAcceleration();
    void UpdateFirstOrder(Entity* entity, const float dt);
    void ClampToGround(Entity* entity, const float groundHeight, const float restitution);

    void SetFixedAcceleration(glm::vec3 fixedAcceleration) { _mAccelerationFixed = fixedAcceleration; }
    void SetVelocity(glm::vec3 velocity) { _mVelocity = velocity; }
    void SetAcceleration(glm::vec3 acceleration) { _mAcceleration = acceleration; }
private:
    // transform
    
    // movement
    glm::vec3 _mVelocity, _mAccelerationFixed;

    // newton's stuff
    glm::vec3 _mAcceleration, _mForce;
    float _mMass, _mMassInv;
};

} // namespace Toon

#endif // !RIGIDBODY_H

```

`Engine/Public/Toon/Scene.hpp`:

```hpp
#ifndef TOON_SCENE_H
#define TOON_SCENE_H

#include <Toon/Config.hpp>
#include <Toon/Entity.hpp>
#include <Toon/System.hpp>

#include <memory>
#include <vector>

namespace Toon {

class TOON_ENGINE_API Scene : public Entity
{
public:

    DISALLOW_COPY_AND_ASSIGN(Scene)

    Scene() = default;

    virtual ~Scene() = default;
    
    System * AddSystem(std::unique_ptr<System> && sys);

    std::vector<System *> GetSystems() const;

private:
    std::vector<std::unique_ptr<System>> _systems;

    std::vector<System *> _systemPtrs;

}; // class Scene

TOON_ENGINE_API
void SetCurrentScene(Scene * scene);

TOON_ENGINE_API
Scene * GetCurrentScene();

} // namespace Toon

#endif // TOON_SCENE_H
```

`Engine/Public/Toon/SceneImporter.hpp`:

```hpp
#ifndef TOON_SCENE_IMPORTER_HPP
#define TOON_SCENE_IMPORTER_HPP

#include <Toon/Config.hpp>
#include <Toon/Entity.hpp>

#include <Toon/String.hpp>
#include <memory>
#include <vector>

namespace Toon {

class TOON_ENGINE_API SceneImporter
{
public:

    DISALLOW_COPY_AND_ASSIGN(SceneImporter)

    SceneImporter() = default;

    virtual ~SceneImporter() = default;

    virtual bool LoadFromFile(Entity * root, const string& filename) = 0;

}; // class SceneImporter

TOON_ENGINE_API
void AddSceneImporter(const string& id, std::unique_ptr<SceneImporter> importer);

TOON_ENGINE_API
void RemoveSceneImporter(const string& id);

TOON_ENGINE_API
const std::vector<SceneImporter *>& GetAllSceneImporters();

} // namespace Toon

#endif // TOON_SCENE_IMPORTER_HPP

```

`Engine/Public/Toon/Shader.hpp`:

```hpp
#ifndef TOON_SHADER_HPP
#define TOON_SHADER_HPP

#include <Toon/Config.hpp>

#include <Toon/String.hpp>
#include <vector>

namespace Toon {

enum class ShaderStage
{
    Vertex,
    Fragment,
    Geometry,
    Compute,
    TessControl,
    TessEvaluation,

}; // enum class ShaderStage

class TOON_ENGINE_API Shader
{
public:
    DISALLOW_COPY_AND_ASSIGN(Shader)

    Shader() = default;

    virtual ~Shader() = default;

    virtual void Terminate() { }

    virtual bool LoadFromFiles(const std::vector<string>& filenames, bool useAssetPath = true) = 0;

}; // class Shader

inline string ShaderStageToString(ShaderStage shaderStage)
{
    switch (shaderStage) {
        case ShaderStage::Vertex:
            return "Vertex";
        case ShaderStage::Fragment:
            return "Fragment";
        case ShaderStage::Geometry:
            return "Geometry";
        case ShaderStage::Compute:
            return "Compute";
        case ShaderStage::TessControl:
            return "TessControl";
        case ShaderStage::TessEvaluation:
            return "TessEvaluation";
    }

    return "Unknown";
}

} // namespace Toon

#endif // TOON_SHADER_HPP
```

`Engine/Public/Toon/ShaderGlobals.hpp`:

```hpp
#ifndef TOON_SHADER_GLOBALS_HPP
#define TOON_SHADER_GLOBALS_HPP

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>

namespace Toon {

#define TOON_SHADER_GLOBALS_BINDING 0

struct LightData
{
    alignas(16) glm::vec3 Position;
    alignas(16) glm::vec3 Direction;
    alignas(16) glm::vec3 Color;
};

struct TOON_ENGINE_API ShaderGlobals
{
public:

    alignas(8) glm::vec2 Resolution;
    alignas(8) glm::vec2 Mouse;
    alignas(4) int FrameCount;
    alignas(4) float TotalTime;
    alignas(4) float FrameSpeedRatio;
    alignas(16) glm::vec3 CameraPosition;
    alignas(4) int LightCount;
    LightData Lights[10];

}; // struct ShaderGlobals

} // namespace Toon

#endif // TOON_SHADER_GLOBALS_HPP
```

`Engine/Public/Toon/ShaderMaterial.hpp`:

```hpp
#ifndef TOON_SHADER_MATERIAL_HPP
#define TOON_SHADER_MATERIAL_HPP

#include <Toon/Config.hpp>

namespace Toon {

#define TOON_SHADER_MATERIAL_BINDING 2

struct TOON_ENGINE_API ShaderMaterial
{
public:
    alignas(16) glm::vec4 BaseColorFactor = vec4(1.0f, 1.0f, 1.0f, 1.0f);
    alignas(16) glm::vec3 EmissiveFactor = vec3(1.0f, 1.0f, 1.0f);
    alignas(4) float NormalScale = 1.0f;
    alignas(4) float MetallicFactor = 1.0f;
    alignas(4) float RoughnessFactor = 1.0f;
    alignas(4) float OcclusionStrength = 1.0f;

}; // struct ShaderMaterial

enum class MaterialTexture
{
    BaseColorMap,
    NormalMap,
    MetallicRoughnessMap,
    EmissiveMap,
    OcclusionMap,

}; // enum class MaterialTexture

inline string MaterialTextureToString(MaterialTexture materialTexture)
{
    switch (materialTexture) {
    case MaterialTexture::BaseColorMap:
        return "BaseColorMap";
    case MaterialTexture::NormalMap:
        return "NormalMap";
    case MaterialTexture::MetallicRoughnessMap:
        return "MetallicRoughnessMap";
    case MaterialTexture::EmissiveMap:
        return "EmissiveMap";
    case MaterialTexture::OcclusionMap:
        return "OcclusionMap";
    }

    return "Unknown";
}

inline uint32_t GetMaterialTextureBinding(MaterialTexture materialTexture)
{
    switch (materialTexture) {
    case MaterialTexture::BaseColorMap:
        return 0;
    case MaterialTexture::NormalMap:
        return 1;
    case MaterialTexture::MetallicRoughnessMap:
        return 2;
    case MaterialTexture::EmissiveMap:
        return 3;
    case MaterialTexture::OcclusionMap:
        return 4;
    }

    return UINT32_MAX;
}

} // namespace Toon

#endif // TOON_SHADER_MATERIAL_HPP
```

`Engine/Public/Toon/ShaderScene.hpp`:

```hpp
#ifndef TOON_SHADER_SCENE_HPP
#define TOON_SHADER_SCENE_HPP

#include <Toon/Math.hpp>

namespace Toon {

#define TOON_MAX_LIGHT_COUNT 10

struct LightData1
{
    alignas(16) glm::vec3 Position;
    alignas(4)  uint8_t Type;
    alignas(16) glm::vec3 Direction;
    alignas(4)  float InnerCutOff;
    alignas(16) glm::vec3 Color;
    alignas(4)  float OuterCutOff;
}; // struct LightData

struct ShaderScene
{
    glm::vec3 CameraPosition;

    glm::vec3 AmbientLightColor;
    glm::vec3 AmbientLightDirection;

    LightData Lights[TOON_MAX_LIGHT_COUNT];
}; // struct ShaderScene

} // namespace Toon

#endif // TOON_SHADER_SCENE_HPP
```

`Engine/Public/Toon/ShaderTransform.hpp`:

```hpp
#ifndef TOON_SHADER_TRANSFORM_HPP
#define TOON_SHADER_TRANSFORM_HPP

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>

namespace Toon {

#define TOON_SHADER_TRANSFORM_BINDING 1

struct TOON_ENGINE_API ShaderTransform
{
public:
    alignas(64) glm::mat4 Model;
    alignas(64) glm::mat4 View;
    alignas(64) glm::mat4 Projection;
    alignas(64) glm::mat4 MVP;

    inline void UpdateMVP() {
        MVP = Projection * View * Model;
    }

}; // struct ShaderTransform

} // namespace Toon

#endif // TOON_SHADER_TRANSFORM_HPP
```

`Engine/Public/Toon/String.hpp`:

```hpp
#ifndef TOON_STRING_HPP
#define TOON_STRING_HPP

#include <Toon/Config.hpp>

#include <string>
#include <algorithm>

namespace Toon {

using std::string;
using std::string_view;

inline bool StringEqualCaseInsensitive(const string& a, const string& b) {
    return std::equal(
        a.begin(), a.end(),
        b.begin(), b.end(),
        [](char a, char b) {
            return tolower(a) == tolower(b);
        }
    );
}

} // namespace Toon

#endif // TOON_STRING_HPP
```

`Engine/Public/Toon/System.hpp`:

```hpp
#ifndef TOON_SYSTEM_HPP
#define TOON_SYSTEM_HPP

#include <Toon/Config.hpp>
#include <Toon/UpdateContext.hpp>
#include <Toon/RenderContext.hpp>

namespace Toon {

class TOON_ENGINE_API System
{
public:

    DISALLOW_COPY_AND_ASSIGN(System)

    System() = default;

    virtual ~System() = default;

    virtual inline void Update(UpdateContext * ctx) { }

    virtual inline void Render(RenderContext * ctx) { }

}; // class System

} // namespace Toon

#endif // TOON_SYSTEM_HPP
```

`Engine/Public/Toon/Texture.hpp`:

```hpp
#ifndef TOON_TEXTURE_HPP
#define TOON_TEXTURE_HPP

#include <Toon/Config.hpp>
#include <Toon/TextureImporter.hpp>

namespace Toon {

enum class TextureWrapType
{
    Repeat,
    MirroredRepeat,
    ClampToEdge,
    ClampToBorder,

}; // enum TextureWrapType

enum class TextureFilterType
{
    Nearest,
    NearestMipmapNearest,
    NearestMipmapLinear,
    Linear,
    LinearMipmapNearest,
    LinearMipmapLinear,

}; // enum TextureFilterType

class TOON_ENGINE_API Texture
{
public:

    struct Options
    {
        Options() { }

        TextureWrapType WrapS = TextureWrapType::Repeat;
        TextureWrapType WrapT = TextureWrapType::Repeat;

        TextureFilterType MagFilter = TextureFilterType::Nearest;
        TextureFilterType MinFilter = TextureFilterType::Nearest;

        bool GenerateMipmaps = true;

    }; // struct Options

    DISALLOW_COPY_AND_ASSIGN(Texture)
    
    Texture() = default;

    virtual ~Texture() = default;

    virtual bool Load(const std::unique_ptr<TextureData>& data, Options opts = Options()) = 0;
    
}; // class Texture

TOON_ENGINE_API
std::shared_ptr<Texture> LoadTextureFromFile(const string& filename, bool useAssetPath = true, Texture::Options opts = Texture::Options());

TOON_ENGINE_API
std::shared_ptr<Texture> LoadTextureFromMemory(const uint8_t* buffer, size_t length, Texture::Options opts = Texture::Options());

inline string TextureWrapTypeToString(TextureWrapType textureWrapType)
{
    switch(textureWrapType) {
        case TextureWrapType::Repeat:
            return "Repeat";
        case TextureWrapType::MirroredRepeat:
            return "MirroredRepeat";
        case TextureWrapType::ClampToEdge:
            return "ClampToEdge";
        case TextureWrapType::ClampToBorder:
            return "ClampToBorder";
    }

    return "Unknown";
}

inline string TextureWrapTypeToString(TextureFilterType textureFilterType)
{
    switch (textureFilterType) {
        case TextureFilterType::Nearest:
            return "Nearest";
        case TextureFilterType::NearestMipmapNearest:
            return "NearestMipmapNearest";
        case TextureFilterType::NearestMipmapLinear:
            return "NearestMipmapLinear";
        case TextureFilterType::Linear:
            return "Linear";
        case TextureFilterType::LinearMipmapNearest:
            return "LinearMipmapNearest";
        case TextureFilterType::LinearMipmapLinear:
            return "LinearMipmapLinear";
    }

    return "Unknown";
}

} // namespace Toon

#endif // TOON_TEXTURE_HPP
```

`Engine/Public/Toon/TextureData.hpp`:

```hpp
#ifndef TOON_TEXTURE_DATA_HPP
#define TOON_TEXTURE_DATA_HPP

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>
#include <Toon/String.hpp>

#include <gsl/gsl>

namespace Toon {

enum class TextureDataType
{
    UnsignedByte,
    Byte,
    UnsignedShort,
    Short,
    UnsignedInt,
    Int,
}; // enum TextureDataType

class TOON_ENGINE_API TextureData
{
public:

    DISALLOW_COPY_AND_ASSIGN(TextureData)

    TextureData() = default;

    virtual ~TextureData() = default;

    // Pointer to pixel data Buffer
    virtual uint8_t* GetData() const = 0;

    // Width and Height in pixels
    virtual glm::uvec2 GetSize() const = 0;

    // Format of the data in the buffer
    virtual TextureDataType GetDataType() const = 0;
}; // class TextureData

class ConstantTextureData : public TextureData
{
public:

    ConstantTextureData(uint8_t * data, uvec2 size, int components, TextureDataType dataType)
        : _data(data)
        , _size(size)
        , _dataType(dataType)
    { }

    uint8_t * GetData() const override {
        return _data;
    }

    glm::uvec2 GetSize() const override {
        return _size;
    }

    TextureDataType GetDataType() const override {
        return _dataType;
    }

private:

    uint8_t * _data;

    glm::uvec2 _size;

    TextureDataType _dataType;

}; // class ConstantTextureData

TOON_ENGINE_API
inline string TextureDataTypeToString(TextureDataType textureDataType)
{
    switch (textureDataType) {
        case TextureDataType::UnsignedByte:
            return "UnsignedByte";
        case TextureDataType::Byte:
            return "Byte";
        case TextureDataType::UnsignedShort:
            return "UnsignedShort";
        case TextureDataType::Short:
            return "Short";
        case TextureDataType::UnsignedInt:
            return "UnsignedInt";
        case TextureDataType::Int:
            return "Int";
    }

    return "Unknown";
}

} // namespace Toon

#endif // TOON_TEXTURE_DATA_HPP
```

`Engine/Public/Toon/TextureImporter.hpp`:

```hpp
#ifndef TOON_TEXTURE_IMPORTER_HPP
#define TOON_TEXTURE_IMPORTER_HPP

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>
#include <Toon/TextureData.hpp>
#include <Toon/String.hpp>

#include <memory>
#include <unordered_map>
#include <vector>

namespace Toon {

class TOON_ENGINE_API TextureImporter
{
public:

    DISALLOW_COPY_AND_ASSIGN(TextureImporter)

    TextureImporter() = default;

    virtual ~TextureImporter() = default;

    virtual std::unique_ptr<TextureData> LoadFromFile(const string& filename, bool useAssetPath = true) = 0;

    virtual std::unique_ptr<TextureData> LoadFromMemory(const uint8_t * buffer, size_t length) = 0;

}; // class TextureImporter

TOON_ENGINE_API
void AddTextureImporter(const string& id, std::unique_ptr<TextureImporter> importer);

TOON_ENGINE_API
void RemoveTextureImporter(const string& id);

TOON_ENGINE_API
const std::vector<TextureImporter *>& GetAllTextureImporters();

} // namespace Toon

#endif // TOON_TEXTURE_IMPORTER_HPP
```

`Engine/Public/Toon/Time.hpp`:

```hpp
#ifndef TOON_TIME_HPP
#define TOON_TIME_HPP

#include <chrono>

namespace Toon {

using namespace std::chrono;

}

#endif // TOON_TIME_HPP
```

`Engine/Public/Toon/Toon.hpp`:

```hpp
#ifndef TOON_HPP
#define TOON_HPP

#include <Toon/Config.hpp>
#include <Toon/Version.hpp>
#include <Toon/String.hpp>

#include <functional>
#include <Toon/Path.hpp>
// #include <Toon/Camera.hpp>
// #include <Toon/Entity.hpp>
// #include <Toon/RenderContext.hpp>
// #include <Toon/UpdateContext.hpp>
// #include <Toon/Component.hpp>
// #include <Toon/MeshComponent.hpp>
// #include <Toon/Light.hpp>
// #include <Toon/Log.hpp>
// #include <Toon/Mesh.hpp>
// #include <Toon/Shader.hpp>
// #include <Toon/Texture.hpp>
// #include <Toon/Util.hpp>
// #include <Toon/GraphicsDriver.hpp>
// #include <Toon/TextureImporter.hpp>
// #include <Toon/MeshImporter.hpp>
// #include <Toon/Version.hpp>

namespace Toon {

TOON_ENGINE_API
bool Initialize(int argc, char ** argv);

TOON_ENGINE_API
void Terminate();

TOON_ENGINE_API
void LoadConfigurationFile(const Path& path, string_view configName);

TOON_ENGINE_API
void SetRunning(bool running);

TOON_ENGINE_API
bool IsRunning();

TOON_ENGINE_API
bool Run(std::function<void()> update);

TOON_ENGINE_API
bool RunScriptFile(const string& filename);

TOON_ENGINE_API
bool RunScriptString(const string& code);

TOON_ENGINE_API
Version GetVersion();

TOON_ENGINE_API
void SetApplicationName(const string& name);

TOON_ENGINE_API
string GetApplicationName();

TOON_ENGINE_API
void SetApplicationVersion(unsigned major, unsigned minor, unsigned patch);

TOON_ENGINE_API
void SetApplicationVersion(const Version& version);

TOON_ENGINE_API
Version GetApplicationVersion();

} // namespace Toon

#endif // TOON_HPP
```

`Engine/Public/Toon/UpdateContext.hpp`:

```hpp
#ifndef TOON_UPDATE_CONTEXT_HPP
#define TOON_UPDATE_CONTEXT_HPP

#include <Toon/Config.hpp>
#include <Toon/Time.hpp>
#include <cstdint>

namespace Toon {

class TOON_ENGINE_API UpdateContext
{
public:
    DISALLOW_COPY_AND_ASSIGN(UpdateContext)

    UpdateContext() = default;

    virtual ~UpdateContext() = default;

    // Target Frames/Second
    virtual inline float GetTargetFPS() const {
        return _mTargetFPS;
    }

    virtual inline void SetTargetFPS(float fps) {
        _mTargetFPS = fps;
        _expectedFrameDuration = microseconds((int64_t)(1000000.0f / GetTargetFPS()));
    }

    // Ratio between Target FPS and Current FPS
    // > 1.0 means Current is less than Target
    // < 1.0 means Current is greater than Target
    virtual inline float GetFrameSpeedRatio() const {
        return _frameSpeedRatio;
    }

    // Time since program start in Milliseconds
    virtual inline milliseconds GetTotalDuration() const {
        return _totalDuration;
    }

    // Time that a frame should take in Milliseconds
    virtual inline microseconds GetExpectedFrameDuration() const {
        return _expectedFrameDuration;
    }

    // Time the previous frame took in Milliseconds
    virtual inline microseconds GetPreviousFrameDuration() const {
        return _previousFrameDuration;
    }

    virtual inline void ResetTime() {
        _totalDuration = 0ms;
        _previousFrameDuration = 0ms;
        _frameSpeedRatio = 1.0f;
    }

    virtual inline void SetTotalDuration(milliseconds totalFrameDuration) {
        _totalDuration = totalFrameDuration;
    }

    virtual inline void SetPreviousFrameDuration(microseconds previousFrameDuration)
    {
        _previousFrameDuration = previousFrameDuration;
        _frameSpeedRatio = previousFrameDuration / _expectedFrameDuration;
    }

private:
    float _mTargetFPS = 0.0f;

    float _frameSpeedRatio = 1.0f;

    milliseconds _totalDuration = 0ms;

    microseconds _expectedFrameDuration = 1ms;

    microseconds _previousFrameDuration = 0ms;

}; // class UpdateContext

} // namespace Toon

#endif // TOON_UPDATE_CONTEXT_HPP
```

`Engine/Public/Toon/Util.hpp`:

```hpp
#ifndef TOON_UTIL_HPP
#define TOON_UTIL_HPP

#include <Toon/Config.hpp>
#include <Toon/Platform.hpp>
#include <Toon/Path.hpp>

#include <Toon/String.hpp>
#include <vector>

namespace Toon {

TOON_ENGINE_API
string GetDirname(string path);

TOON_ENGINE_API
string GetBasename(string path);

TOON_ENGINE_API
string GetExtension(string path);

TOON_ENGINE_API
std::vector<Path> GetAssetPathList();

#if defined(TOON_PLATFORM_WINDOWS)

TOON_ENGINE_API
std::wstring ConvertUTF8ToWideString(string str);

TOON_ENGINE_API
string ConvertWideStringToUTF8(std::wstring str);

class WindowsErrorMessage
{
public:

    WindowsErrorMessage(HRESULT hResult) {
        FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            nullptr,
            hResult,
            GetUserDefaultUILanguage(),
            (LPTSTR)&_message,
            0,
            nullptr
        );

    };

    ~WindowsErrorMessage() {
        if (_message) {
            LocalFree(_message);
            _message = nullptr;
        }
    }

    char * GetMessage() const {
        return _message;
    }

private:

    char * _message = nullptr;

};

#endif // defined(TOON_PLATFORM_WINDOWS)

} // namespace Toon

#endif // TOON_UTIL_HPP
```

`Engine/Public/Toon/Version.hpp`:

```hpp
#ifndef TOON_VERSION_HPP
#define TOON_VERSION_HPP

#include <Toon/Config.hpp>

#include <Toon/String.hpp>
#include <regex>

namespace Toon {

struct TOON_ENGINE_API Version
{
    int Major;
    int Minor;
    int Patch;

    Version(int major = 0, int minor = 0, int patch = 0)
        : Major(major)
        , Minor(minor)
        , Patch(patch)
    { }

    Version(const Version& rhs)
        : Major(rhs.Major)
        , Minor(rhs.Minor)
        , Patch(rhs.Patch)
    { }

    Version(const string& str)
    {
        FromString(str);
    }

    inline Version& operator=(const Version& rhs)
    {
        Major = rhs.Major;
        Minor = rhs.Minor;
        Patch = rhs.Patch;
        return *this;
    }

    inline bool operator==(const Version& rhs)
    {
        return (Compare(*this, rhs) == 0);
    }

    inline bool operator!=(const Version& rhs)
    {
        return !(*this == rhs);
    }

    inline friend bool operator>(const Version& lhs, const Version& rhs)
    {
        return (Version::Compare(lhs, rhs) == 1);
    }

    inline friend bool operator>=(const Version& lhs, const Version& rhs)
    {
        int res = Version::Compare(lhs, rhs);
        return (res == 0 || res == 1);
    }

    inline friend bool operator<(const Version& lhs, const Version& rhs)
    {
        return (Version::Compare(lhs, rhs) == -1);
    }

    inline friend bool operator<=(const Version& lhs, const Version& rhs)
    {
        int res = Version::Compare(lhs, rhs);
        return (res == 0 || res == -1);
    }

    inline string ToString() const
    {
        return std::to_string(Major) +
            "." +
            std::to_string(Minor) +
            "." +
            std::to_string(Patch);
    }

    inline operator string() const
    {
        return ToString();
    }

    inline void FromString(const string& string)
    {
        std::smatch match;
        std::regex regex("^.*?([0-9])+\\.([0-9]+)\\.([0-9]+).*");
        std::regex_match(string, match, regex);

        if (match.size() == 4) {
            Major = std::strtol(match[1].str().c_str(), nullptr, 10);
            Minor = std::strtol(match[2].str().c_str(), nullptr, 10);
            Patch = std::strtol(match[3].str().c_str(), nullptr, 10);
        }
    }

    inline static int Compare(const Version& a, const Version& b)
    {
        auto cmp = [](int a, int b) {
            if (a == b) {
                return 0;
            }
            if (a > b) {
                return 1;
            }
            return -1;
        };

        int result = cmp(a.Major, b.Major);
        if (result == 0) {
            result = cmp(a.Minor, b.Minor);
            if (result == 0) {
                result = cmp(a.Patch, b.Patch);
            }
        }
        return result;
    }
}; // struct Version

} // namespace Toon

#endif // TOON_VERSION_HPP
```

`Engine/Public/Toon/Vertex.hpp`:

```hpp
#ifndef TOON_VERTEX_HPP
#define TOON_VERTEX_HPP

#include <Toon/Config.hpp>
#include <Toon/Math.hpp>
#include <Toon/String.hpp>

namespace Toon {

struct Vertex
{
    glm::vec4 Position;
    glm::vec4 Normal;
    glm::vec4 Tangent;
    glm::vec4 Bitangent;
    
    glm::vec4 Color;

    glm::vec2 TexCoord1;
    glm::vec2 TexCoord2;

    uvec2 Joints;
    vec4 Weights;
    
}; // struct Vertex

enum class VertexAttribute
{
    Position,
    Normal,
    Tangent,
    Bitangent,
    Color,
    TexCoord1,
    TexCoord2,
    Joints,
    Weights,

}; // enum class VertexAttribute

inline string VertexAttributeToString(VertexAttribute vertexAttribute)
{
    switch (vertexAttribute) {
        case VertexAttribute::Position:
            return "Position";
        case VertexAttribute::Normal:
            return "Normal";
        case VertexAttribute::Tangent:
            return "Tangent";
        case VertexAttribute::Bitangent:
            return "Bitangent";
        case VertexAttribute::Color:
            return "Color";
        case VertexAttribute::TexCoord1:
            return "TexCoord1";
        case VertexAttribute::TexCoord2:
            return "TexCoord2";
        case VertexAttribute::Joints:
            return "Joints";
        case VertexAttribute::Weights:
            return "Weights";
    }

    return "Unknown";
}

inline uint32_t GetVertexAttributeLocation(VertexAttribute attribute)
{
    switch (attribute) {
    case VertexAttribute::Position:
        return 0;
    case VertexAttribute::Normal:
        return 1;
    case VertexAttribute::Tangent:
        return 2;
    case VertexAttribute::Bitangent:
        return 3;
    case VertexAttribute::Color:
        return 4;
    case VertexAttribute::TexCoord1:
        return 5;
    case VertexAttribute::TexCoord2:
        return 6;
    case VertexAttribute::Joints:
        return 7;
    case VertexAttribute::Weights:
        return 8;
    }

    return UINT32_MAX;
}

} // namespace Toon

#endif // TOON_VERTEX_HPP

```

`LICENSE`:

```
MIT License

Copyright (c) 2017 Stephen Lane-Walsh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Modules/CMakeLists.txt`:

```txt

INCLUDE(DefineModule)

###
### Include Modules
###

FOREACH(_module ${REQUIRED_MODULES})
    ADD_SUBDIRECTORY(${_module})
ENDFOREACH()

# Update the global TOON_ASSET_PATH
SET(TOON_ASSET_PATH ${TOON_ASSET_PATH} PARENT_SCOPE)

# Update the global TOON_MODULE_PATH to include paths to the module's libraries
SET(TOON_MODULE_PATH ${TOON_MODULE_PATH} PARENT_SCOPE)

```

`Modules/GLTF2/CMakeLists.txt`:

```txt

SET(_target ToonGLTF2)

DEFINE_MODULE(${_target} GLTF2)

```

`Modules/GLTF2/Private/Base64.hpp`:

```hpp
#ifndef _MACARON_BASE64_H_
#define _MACARON_BASE64_H_

/**
* The MIT License (MIT)
* Copyright (c) 2016 tomykaira
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include <string>
#include <vector>
#include <cstdint>

namespace macaron {

    class Base64 {
    public:

        static std::string Encode(const std::string data) {
            static constexpr char sEncodingTable[] = {
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
                'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
                'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
                'w', 'x', 'y', 'z', '0', '1', '2', '3',
                '4', '5', '6', '7', '8', '9', '+', '/'
            };

            size_t in_len = data.size();
            size_t out_len = 4 * ((in_len + 2) / 3);
            std::string ret(out_len, '\0');
            size_t i;
            char *p = const_cast<char*>(ret.c_str());

            for (i = 0; i < in_len - 2; i += 3) {
                *p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
                *p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int)(data[i + 1] & 0xF0) >> 4)];
                *p++ = sEncodingTable[((data[i + 1] & 0xF) << 2) | ((int)(data[i + 2] & 0xC0) >> 6)];
                *p++ = sEncodingTable[data[i + 2] & 0x3F];
            }
            if (i < in_len) {
                *p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
                if (i == (in_len - 1)) {
                    *p++ = sEncodingTable[((data[i] & 0x3) << 4)];
                    *p++ = '=';
                }
                else {
                    *p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int)(data[i + 1] & 0xF0) >> 4)];
                    *p++ = sEncodingTable[((data[i + 1] & 0xF) << 2)];
                }
                *p++ = '=';
            }

            return ret;
        }

        static std::vector<uint8_t> Decode(const std::string& input) {
            static constexpr unsigned char kDecodingTable[] = {
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
                64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
                64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64
            };

            std::vector<uint8_t> out;

            size_t in_len = input.size();
            if (in_len % 4 != 0) return out;

            size_t out_len = in_len / 4 * 3;
            if (input[in_len - 1] == '=') out_len--;
            if (input[in_len - 2] == '=') out_len--;

            out.resize(out_len);

            for (size_t i = 0, j = 0; i < in_len;) {
                uint32_t a = input[i] == '=' ? 0 & i++ : kDecodingTable[static_cast<int>(input[i++])];
                uint32_t b = input[i] == '=' ? 0 & i++ : kDecodingTable[static_cast<int>(input[i++])];
                uint32_t c = input[i] == '=' ? 0 & i++ : kDecodingTable[static_cast<int>(input[i++])];
                uint32_t d = input[i] == '=' ? 0 & i++ : kDecodingTable[static_cast<int>(input[i++])];

                uint32_t triple = (a << 3 * 6) + (b << 2 * 6) + (c << 1 * 6) + (d << 0 * 6);

                if (j < out_len) out[j++] = (triple >> 2 * 8) & 0xFF;
                if (j < out_len) out[j++] = (triple >> 1 * 8) & 0xFF;
                if (j < out_len) out[j++] = (triple >> 0 * 8) & 0xFF;
            }

            return out;
        }

    };

}

#endif /* _MACARON_BASE64_H_ */
```

`Modules/GLTF2/Private/GLTF2MeshImporter.cpp`:

```cpp
#include <Toon/GLTF2/GLTF2MeshImporter.hpp>

#include <Toon/Log.hpp>
#include <Toon/Benchmark.hpp>
#include <Toon/Util.hpp>
#include <Toon/Path.hpp>
#include <Toon/GLTF2/GLTF2PrimitiveData.hpp>

#include "glTF2File.hpp"

namespace Toon::GLTF2 {

TOON_GLTF2_API
std::vector<std::unique_ptr<PrimitiveData>> GLTF2MeshImporter::LoadFromFile(const string& filename, bool useAssetPath /*= true*/)
{
    ToonBenchmarkStart();

    glTF2File file;
    bool result = false;

    if (useAssetPath) {
        const auto& getAssetPathList = GetAssetPathList();

        for (const auto& path : getAssetPathList) {
            Path fullPath = path / "Models" / filename;
            ToonLogVerbose("Checking '%s'", fullPath);

            result = file.LoadFromFile(fullPath);

            if (result) {
                break;
            }
        }
    }
    else {
        result = file.LoadFromFile(filename);
    }

    if (!result) {
        return { };
    }

    auto primitiveList = file.LoadMesh();

    ToonBenchmarkEnd();

    return primitiveList;
}

} // namespace Toon::GLTF2
```

`Modules/GLTF2/Private/GLTF2Module.cpp`:

```cpp
#include <Toon/Module.hpp>

#include <Toon/GLTF2/GLTF2MeshImporter.hpp>
#include <Toon/GLTF2/GLTF2SceneImporter.hpp>

namespace Toon::GLTF2 {

bool ModuleInit() {
    AddMeshImporter("GLTF2", std::unique_ptr<MeshImporter>(new GLTF2MeshImporter()));
    AddSceneImporter("GLTF2", std::unique_ptr<SceneImporter>(new GLTF2SceneImporter()));

    return true;
}

void ModuleTerm() {
    RemoveSceneImporter("GLTF2");
    RemoveMeshImporter("GLTF2");
}

TOON_MODULE {
    .Name       = "ToonGLTF2",
    .Initialize = ModuleInit,
    .Terminate  = ModuleTerm,
};

} // namespace Toon::GLTF2
```

`Modules/GLTF2/Private/GLTF2SceneImporter.cpp`:

```cpp
#include <Toon/GLTF2/GLTF2SceneImporter.hpp>

namespace Toon::GLTF2 {

TOON_GLTF2_API
bool GLTF2SceneImporter::LoadFromFile(Entity * root, const string& filename)
{
    // glTF2File file;
    // return file.LoadFromFile(filename);
    return false;
}

} // namespace Toon::GLTF2
```

`Modules/GLTF2/Private/OpenGLStub.hpp`:

```hpp
#ifndef TOON_GLTF2_OPENGL_STUB_HPP
#define TOON_GLTF2_OPENGL_STUB_HPP

#include <cstdint>

typedef uint32_t GLenum;

#define GL_INVALID_ENUM             0x0500

// Texture Options

#define GL_REPEAT                   0x2901
#define GL_MIRRORED_REPEAT          0x8370
#define GL_CLAMP_TO_EDGE            0x812F
#define GL_CLAMP_TO_BORDER          0x812D
#define GL_NEAREST                  0x2600
#define GL_NEAREST_MIPMAP_LINEAR    0x2702
#define GL_NEAREST_MIPMAP_NEAREST   0x2700
#define GL_LINEAR                   0x2601
#define GL_LINEAR_MIPMAP_LINEAR     0x2703
#define GL_LINEAR_MIPMAP_NEAREST    0x2701

// Data Types

#define GL_UNSIGNED_BYTE            0x1401
#define GL_UNSIGNED_SHORT           0x1403
#define GL_UNSIGNED_INT             0x1405
#define GL_FLOAT                    0x1406

// Primitive Topology
#define GL_POINTS				    0x0000
#define GL_LINES				    0x0001
#define GL_LINE_LOOP				0x0002
#define GL_LINE_STRIP				0x0003
#define GL_TRIANGLES				0x0004
#define GL_TRIANGLE_STRIP			0x0005
#define GL_TRIANGLE_FAN				0x0006

#endif // TOON_GLTF2_OPENGL_STUB_HPP
```

`Modules/GLTF2/Private/glTF2File.cpp`:

```cpp
#include "glTF2File.hpp"

#include <Toon/GraphicsDriver.hpp>
#include <Toon/Benchmark.hpp>
#include <Toon/Log.hpp>
#include <Toon/GLTF2/GLTF2PrimitiveData.hpp>

#include "Base64.hpp"
#include <fstream>

namespace Toon::GLTF2 {

bool glTF2File::IsValidTexture(int index, int texCoord)
{
    if (index < 0 || index > static_cast<int>(Textures.size())) {
        ToonLogError("Invalid glTF2 Texture Index: %d", index);
        return false;
    }

    if (texCoord > 0) {
        ToonLogWarn("Multiple glTF2 TEXCOORDs not supported");
        return false;
    }

    return true;
}

bool glTF2File::LoadFromFile(const string& filename)
{
    ToonBenchmarkStart();

    Filename = filename;
    BaseDir = GetDirname(Filename);

    std::ifstream file;
    file.open(Filename, std::ios::in | std::ios::binary);

    if (!file.is_open()) {
        return false;
    }

    const auto& ext = GetExtension(Filename);
    
    if (ext == "glb") {
        // Header
        uint32_t magic;
        file.read(reinterpret_cast<char *>(&magic), sizeof(magic));
        if (magic != MAGIC) {
            ToonLogError("Invalid binary glTF2 file header");
            return false;
        }

        uint32_t version;
        file.read(reinterpret_cast<char *>(&version), sizeof(version));
        if (version != 2) {
            ToonLogError("Invalid binary glTF2 container version, %u", version);
            return false;
        }

        uint32_t length;
        file.read(reinterpret_cast<char *>(&length), sizeof(length));

        // JSON Chunk

        uint32_t jsonChunkLength;
        file.read(reinterpret_cast<char *>(&jsonChunkLength), sizeof(jsonChunkLength));

        ChunkType jsonChunkType;
        file.read(reinterpret_cast<char *>(&jsonChunkType), sizeof(jsonChunkType));

        if (jsonChunkType != ChunkType::JSON) {
            ToonLogError("Invalid binary glTF2 file. The first chunk must be JSON, found '%08x'", jsonChunkType);
            return false;
        }

        std::vector<char> jsonChunk(jsonChunkLength + 1);
        file.read(jsonChunk.data(), jsonChunkLength);
        jsonChunk.back() = '\0';

        try {
            JSON = json::parse(jsonChunk.data());
        }
        catch (...) {
            return false;
        }

        // Buffer Chunk (Optional)

        if (file.tellg() < length) {
            uint32_t bufferChunkLength;
            file.read(reinterpret_cast<char *>(&bufferChunkLength), sizeof(bufferChunkLength));

            ChunkType bufferChunkType;
            file.read(reinterpret_cast<char *>(&bufferChunkType), sizeof(bufferChunkType));

            if (bufferChunkType != ChunkType::BIN) {
                ToonLogError("Invalid binary glTF2 file. The second chunk must be BIN, found '%08x'", bufferChunkType);
                return false;
            }

            Buffers.push_back(std::vector<uint8_t>(bufferChunkLength));
            file.read(reinterpret_cast<char *>(Buffers.back().data()), bufferChunkLength);
        }
    }
    else {
        try {
            file >> JSON;
        }
        catch (...) {
            return false;
        }

        if (!LoadBuffers()) {
            return false;
        }
    }

    const auto VERSION_PATH = json::json_pointer("/asset/version");

    if (JSON.contains(VERSION_PATH)) {
        auto version = JSON[VERSION_PATH].get<string>();
        ToonLogVerbose("glTF2 Version: %s", version);
    }

    const auto GENERATOR_PATH = json::json_pointer("/asset/generator");

    if (JSON.contains(GENERATOR_PATH)) {
        auto generator = JSON[GENERATOR_PATH].get<string>();
        ToonLogVerbose("glTF2 Generator: %s", generator);
    }

    if (!LoadBufferViews()) {
        return false;
    }

    if (!LoadAccessors()) {
        return false;
    }

    if (!LoadImages()) {
        return false;
    }

    if (!LoadSamplers()) {
        return false;
    }

    if (!LoadTextures()) {
        return false;
    }

    if (!LoadMaterials()) {
        return false;
    }

    if (!LoadCameras()) {
        return false;
    }

    ToonBenchmarkEnd();
    return true;
}

bool glTF2File::LoadBuffers()
{
    const auto BUFFERS_PATH = json::json_pointer("/buffers");

    if (JSON.contains(BUFFERS_PATH)) {
        for (const auto& object : JSON[BUFFERS_PATH]) {
            const auto& byteLength = object.value<size_t>("byteLength", 0);
            const auto& uri = object.value("uri", "");

            if (uri.rfind("data:", 0) == 0) {
                size_t pivot = uri.find(',');
                Buffers.push_back(macaron::Base64::Decode(uri.substr(pivot + 1)));
            }
            else {
                ToonLogVerbose("Loading glTF2 buffer from '%s'", uri);

                string path = BaseDir + TOON_PATH_SLASH + uri;
                std::ifstream file(path, std::ios::in | std::ios::binary);
                if (!file.is_open()) {
                    ToonLogError("Failed to read glTF2 buffer from '%s'", uri);
                    return false;
                }

                Buffers.push_back(std::vector<uint8_t>(byteLength));
                file.read(reinterpret_cast<char *>(Buffers.back().data()), byteLength);

                ToonLogLoad("glTF2 buffer '%s'", path);
            }
        }
    }
    else {
        return false;
    }

    ToonLogVerbose("Loaded %d Buffer(s)", Buffers.size());

    return true;
}

bool glTF2File::LoadBufferViews()
{
    const auto BUFFER_VIEWS_PATH = json::json_pointer("/bufferViews");

    if (JSON.contains(BUFFER_VIEWS_PATH)) {
        for (const auto& object : JSON[BUFFER_VIEWS_PATH]) {
            BufferViews.push_back(BufferViewData{
                object.value<int>("buffer", -1),
                object.value<size_t>("byteLength", 0),
                object.value<size_t>("byteOffset", 0),
                object.value<size_t>("byteStride", 0),
                object.value<GLenum>("target", GL_INVALID_ENUM),
            });
        }
    }
    else {
        return false;
    }

    ToonLogVerbose("Loaded %d Buffer View(s)", BufferViews.size());

    return true;
}

bool glTF2File::LoadAccessors()
{
    const auto ACCESSORS_PATH = json::json_pointer("/accessors");

    if (JSON.contains(ACCESSORS_PATH)) {
        for (const auto& object : JSON[ACCESSORS_PATH]) {
            Accessors.push_back(AccessorData{
                object.value<int>("bufferView", -1),
                object.value<size_t>("byteOffset", 0),
                object.value<size_t>("count", 0),
                object.value<string>("type", ""),
                object.value<GLenum>("componentType", GL_INVALID_ENUM),
                object.value<bool>("normalized", false),
            });
        }
    }
    else {
        return false;
    }

    ToonLogVerbose("Loaded %d Accessor(s)", Accessors.size());

    return true;
}

bool glTF2File::LoadImages()
{
    const auto IMAGES_PATH = json::json_pointer("/images");

    if (JSON.contains(IMAGES_PATH)) {
        for (const auto& object : JSON[IMAGES_PATH]) {
            Images.push_back(ImageData{
                object.value("uri", ""),
                object.value("bufferView", -1),
                object.value("mimeType", ""),
            });
        }
    }

    ToonLogVerbose("Loaded %d Image(s)", Images.size());

    return true;
}

bool glTF2File::LoadSamplers()
{
    const auto SAMPLERS_PATH = json::json_pointer("/samplers");

    if (JSON.contains(SAMPLERS_PATH)) {
        for (const auto& object : JSON[SAMPLERS_PATH]) {
            Toon::Texture::Options options;
            options.WrapS = GetWrapType(object.value("wrapS", 0));
            options.WrapT = GetWrapType(object.value("wrapT", 0));
            options.MagFilter = GetFilterType(object.value("magFilter", 0));
            options.MinFilter = GetFilterType(object.value("minFilter", 0));
            options.GenerateMipmaps = false;
            Samplers.push_back(options);
        }
    }

    ToonLogVerbose("Loaded %d Samplers(s)", Samplers.size());

    return true;
}

bool glTF2File::LoadTextures()
{
    const auto TEXTURES_PATH = json::json_pointer("/textures");

    GraphicsDriver * gfx = Toon::GetGraphicsDriver();
    if (!gfx) {
        ToonLogError("Unable to load textures from a glTF2 file without a graphics driver");
        return false;
    }

    if (JSON.contains(TEXTURES_PATH)) {
        for (const auto& object : JSON[TEXTURES_PATH]) {
            int sampler = object.value("sampler", -1);
            int source = object.value("source", -1);

            if (source < 0 || source >= Images.size()) {
                ToonLogError("Invalid glTF2 sourceimage: %d\n", source);
                return false;
            }

            Toon::Texture::Options opts;
            if (sampler >= 0 && sampler < Samplers.size()) {
                opts = Samplers[sampler];
            }

            const auto& image = Images[source];
            if (image.bufferView >= 0) {
                ToonLogVerbose("Loading glTF2 texture from bufferView");

                const auto& bufferView = BufferViews[image.bufferView];
                const auto& buffer = Buffers[bufferView.buffer];

                if (bufferView.byteStride > 0) {
                    ToonLogError("Unsupported glTF2 bufferView, byteStride != 0");
                    return false;
                }

                const uint8_t * ptr = buffer.data() + bufferView.byteOffset;

                auto texture = LoadTextureFromMemory(ptr, bufferView.byteLength, opts);
                if (!texture) {
                    return false;
                }

                Textures.push_back(texture);
            }
            else if (image.uri.rfind("data:", 0) == 0) {
                ToonLogVerbose("Loading glTF2 texture from base64 encoded uri");
                
                size_t pivot = image.uri.find(',');
                const auto& data = macaron::Base64::Decode(image.uri.substr(pivot + 1));

                auto texture = LoadTextureFromMemory(data.data(), data.size(), opts);
                if (!texture) {
                    return false;
                }

                Textures.push_back(texture);
            }
            else {
                string path = BaseDir + TOON_PATH_SLASH + image.uri;
                ToonLogVerbose("Loading glTF2 texture from file: '%s'", path);
                
                auto texture = LoadTextureFromFile(path, false, opts);
                if (!texture) {
                    return false;
                }

                Textures.push_back(texture);
            }
        }
    }

    ToonLogVerbose("Loaded %d Texture(s)", Textures.size());

    return true;
}

bool glTF2File::LoadMaterials()
{
    const auto MATERIALS_PATH = json::json_pointer("/materials");

    GraphicsDriver * gfx = Toon::GetGraphicsDriver();
    if (!gfx) {
        ToonLogError("Unable to load textures from a glTF2 file without a graphics driver");
        return false;
    }

    if (JSON.contains(MATERIALS_PATH)) {
        for (const auto& object : JSON[MATERIALS_PATH]) {
            auto material = gfx->CreateMaterial();
            material->Initialize();

            auto it = object.find("normalTexture");
            if (it != object.end()) {
                const auto& value = it.value();
                if (value.is_object()) {
                    int index = value.value("index", -1);
                    int texCoord = value.value("texCoord", 0);

                    if (IsValidTexture(index, texCoord)) {
                        material->SetNormalMap(Textures[index]);
                    }

                    material->SetNormalScale(value.value("scale", material->GetNormalScale()));
                }
                else {
                    ToonLogWarn("Malformed glTF2 normalTexture");
                }
            }

            // TODO: Investigate vs stephens change (We think gltf2 exports a value of 1.0, 1.0, 1.0 if we have a texture)
            it = object.find("emissiveFactor");
            if (it != object.end()) {
                material->SetEmissiveFactor(ExtractVec3(it.value(), material->GetEmissiveFactor()));
            }

            it = object.find("emissiveTexture");
            if (it != object.end()) {
                const auto& value = it.value();
                if (value.is_object()) {
                    int index = value.value("index", -1);
                    int texCoord = value.value("texCoord", 0);

                    if (IsValidTexture(index, texCoord)) {
                        material->SetEmissiveMap(Textures[index]);
                    }
                }
                else {
                    ToonLogWarn("Malformed glTF2 emissiveTexture");
                }
            }

            it = object.find("occlusionTexture");
            if (it != object.end()) {
                const auto& value = it.value();
                if (value.is_object()) {
                    int index = value.value("index", -1);
                    int texCoord = value.value("texCoord", 0);

                    if (IsValidTexture(index, texCoord)) {
                        material->SetOcclusionMap(Textures[index]);
                    }

                    material->SetOcclusionStrength(value.value("strength", material->GetOcclusionStrength()));
                }
                else {
                    ToonLogWarn("Malformed glTF2 occlusionTexture");
                }
            }

            it = object.find("pbrMetallicRoughness");
            if (it != object.end()) {
                const auto& group = it.value();
                if (group.is_object()) {
                    it = group.find("baseColorFactor");
                    if (it != group.end()) {
                        material->SetBaseColorFactor(ExtractVec4(it.value(), material->GetBaseColorFactor()));
                    }

                    it = group.find("baseColorTexture");
                    if (it != group.end()) {
                        const auto& value = it.value();
                        if (value.is_object()) {
                            int index = value.value("index", -1);
                            int texCoord = value.value("texCoord", 0);

                            if (IsValidTexture(index, texCoord)) {
                                material->SetBaseColorMap(Textures[index]);
                            }
                        }
                        else {
                            ToonLogWarn("Malformed glTF2 baseColorTexture");
                        }
                    }

                    material->SetMetallicFactor(group.value("metallicFactor", material->GetMetallicFactor()));

                    material->SetRoughnessFactor(group.value("roughnessFactor", material->GetRoughnessFactor()));

                    it = group.find("metallicRoughnessTexture");
                    if (it != group.end()) {
                        const auto& value = it.value();
                        if (value.is_object()) {
                            int index = value.value("index", -1);
                            int texCoord = value.value("texCoord", 0);

                            if (IsValidTexture(index, texCoord)) {
                                material->SetMetallicRoughnessMap(Textures[index]);
                            }
                        }
                        else {
                            ToonLogWarn("Malformed glTF2 metallicRoughnessTexture");
                        }
                    }
                }
            }

            // it = object.find("pbrSpecularGlossiness");
            // if (it != object.end()) {
            // }

            // extensions
            /// KHR_materials_transmission
            /// KHR_materials_clearcoat
            /// KHR_materials_pbrSpecularGlossiness
            /// KHR_materials_variants
            /// KHR_techniques_webgl

            // name

            // [alphaMode] ?
            /// OPAQUE, MASK, BLEND

            // [doubleSided]

            Materials.push_back(material);
        }
    }

    ToonLogVerbose("Loaded %d Material(s)", Materials.size());

    return true;
}

bool glTF2File::LoadCameras()
{
    const auto CAMERAS_PATH = json::json_pointer("/cameras");

    if (JSON.contains(CAMERAS_PATH)) {
        for (const auto& object : JSON[CAMERAS_PATH]) {
            Cameras.push_back(CameraData{
                object.value<string>("name", ""),
                object.value<string>("type", ""),
            });
            auto& camera = Cameras.back();

            if (camera.type == "perspective") {
                auto it = object.find("perspective");
                if (it == object.end()) {
                    ToonLogError("Invalid glTF2 perspective camera");
                    return false;
                }

                const auto& perspective = it.value();
                camera.aspectRatio = perspective.value<float>("aspectRatio", 0.0f);
                camera.yfov = perspective.value<float>("yfov", 0.0f);
                camera.zfar = perspective.value<float>("zfar", 0.0f);
                camera.znear = perspective.value<float>("znear", 0.0f);
            }
            else if (camera.type == "orthographic") {
                auto it = object.find("orthographic");
                if (it == object.end()) {
                    ToonLogError("Invalid glTF2 orthographic camera");
                    return false;
                }

                const auto& orthographic = it.value();
                camera.xmag = orthographic.value("xmag", 0.0f);
                camera.ymag = orthographic.value("ymag", 0.0f);
                camera.zfar = orthographic.value("zfar", 0.0f);
                camera.znear = orthographic.value("znear", 0.0f);
            }
            else {
                ToonLogWarn("Unknown glTF2 camera type: '%s'", camera.type);
            }
        }
    }

    ToonLogVerbose("Loaded %d Camera(s)", Cameras.size());

    return true;
}

std::vector<std::unique_ptr<PrimitiveData>> glTF2File::LoadMesh()
{
    const auto MESHES_PATH = json::json_pointer("/meshes");

    if (JSON.contains(MESHES_PATH)) {
        std::vector<std::unique_ptr<PrimitiveData>> primitiveDataList;
        for (const auto& object : JSON[MESHES_PATH]) {

            auto iter = object.find("primitives");
            if (iter != object.end()) {
                const auto& primitives = iter.value();
                if (!primitives.is_array()) {
                    ToonLogError("Invalid glTF2 mesh, missing primitives array");
                    continue;
                }

                for (const auto& primitive : primitives) {
                    // TODO: Possibly change
                    GLTF2PrimitiveData * primitiveData = new GLTF2PrimitiveData();
                    primitiveDataList.push_back(std::unique_ptr<PrimitiveData>(primitiveData));

                    int materialIndex = primitive.value("material", -1);
                    if (materialIndex >= 0) {
                        primitiveData->material = Materials[materialIndex];
                    }

                    int indicesIndex = primitive.value("indices", -1);
                    GLenum primitiveType = primitive.value<GLenum>("mode", GL_TRIANGLES);

                    if (primitiveType == GL_LINE_LOOP) {
                        ToonLogWarn("Unsupported glTF2 primitive mode: GL_LINE_LOOP");
                        continue;
                    }
                    else if (primitiveType == GL_TRIANGLE_FAN) {
                        ToonLogWarn("Unsupported glTF2 primitive mode: GL_TRIANGLE_FAN");
                        continue;
                    }

                    switch (primitiveType) {
                    case GL_POINTS:
                        primitiveData->topology = PrimitiveTopology::PointList;
                        break;
                    case GL_LINES:
                        primitiveData->topology = PrimitiveTopology::LineList;
                        break;
                    case GL_LINE_STRIP:
                        primitiveData->topology = PrimitiveTopology::LineStrip;
                        break;
                    case GL_TRIANGLES:
                        primitiveData->topology = PrimitiveTopology::TriangleList;
                        break;
                    case GL_TRIANGLE_STRIP:
                        primitiveData->topology = PrimitiveTopology::TriangleStrip;
                        break;
                    }
                    
                    if (indicesIndex >= 0) {
                        const auto& accessor = Accessors[indicesIndex];
                        primitiveData->indexList.resize(accessor.count);

                        AccessorIterator iterIndex(this, indicesIndex);
                        for (auto& index : primitiveData->indexList) {
                            index = iterIndex.getInteger();
                            ++iterIndex;
                        }
                    }

                    iter = primitive.find("attributes");
                    if (iter != primitive.end()) {
                        const auto& attributes = iter.value();
                        if (!attributes.is_object()) {
                            ToonLogError("Invalid glTF2 primitive, missing attributes dictionary");
                            continue;
                        }

                        int positionIndex = attributes.value("POSITION", -1);
                        if (positionIndex < 0) {
                            ToonLogError("Invalid glTF2 primitive, missing POSITION");
                            continue;
                        }

                        int tangentIndex = attributes.value("TANGENT", -1);

                        const auto& positionAccessor = Accessors[positionIndex];
                        primitiveData->vertexList.resize(positionAccessor.count);

                        AccessorIterator iterPosition (this, positionIndex);
                        AccessorIterator iterNormal   (this, attributes.value("NORMAL", -1));
                        AccessorIterator iterTangent  (this, tangentIndex);
                        AccessorIterator iterTexCoord1(this, attributes.value("TEXCOORD_0", -1));
                        AccessorIterator iterTexCoord2(this, attributes.value("TEXCOORD_1", -1));
                        AccessorIterator iterColor    (this, attributes.value("COLOR_0", -1));
                        AccessorIterator iterJoints   (this, attributes.value("JOINTS_0", -1));
                        AccessorIterator iterWeights  (this, attributes.value("WEIGHTS_0", -1));

                        for (auto& vertex : primitiveData->vertexList) {
                            vertex.Position = iterPosition.getVec4({ 0.0f, 0.0f, 0.0f, 1.0f });
                            ++iterPosition;

                            vertex.Normal = iterNormal.getVec4({ 0.0f, 0.0f, 0.0f, 1.0f });
                            ++iterNormal;

                            vertex.Tangent = iterTangent.getVec4();
                            ++iterTangent;

                            vertex.TexCoord1 = iterTexCoord1.getVec2();
                            ++iterTexCoord1;

                            vertex.TexCoord2 = iterTexCoord2.getVec2();
                            ++iterTexCoord2;

                            vertex.Color = iterColor.getVec4({ 0.0f, 0.0f, 0.0f, 1.0f });
                            ++iterColor;

                            vertex.Joints = iterJoints.getUVec4();
                            ++iterJoints;

                            vertex.Weights = iterWeights.getVec4();
                            ++iterWeights;
                        }

                        if (tangentIndex < 0) {
                            primitiveData->CalculateTangents();
                        }
                    }
                }
            }
            
            return primitiveDataList;
        }
    }

    return { };
}

} // namespace Toon::GLTF2
```

`Modules/GLTF2/Private/glTF2File.hpp`:

```hpp
#ifndef TOON_GLTF2_GLTF2_FILE_HPP
#define TOON_GLTF2_GLTF2_FILE_HPP

#include <Toon/GLTF2/GLTF2Config.hpp>

#include <Toon/Math.hpp>
#include <Toon/JSON.hpp>
#include <Toon/Texture.hpp>
#include <Toon/TextureImporter.hpp>
#include <Toon/Material.hpp>
#include <Toon/PrimitiveData.hpp>

#include "OpenGLStub.hpp"

#include <cstdint>
#include <iterator>

namespace Toon::GLTF2 {

TOON_GLTF2_API
inline TextureWrapType GetWrapType(const GLenum& type)
{
    switch (type) {
    case GL_REPEAT:
        return TextureWrapType::Repeat;
    case GL_MIRRORED_REPEAT:
        return TextureWrapType::MirroredRepeat;
    case GL_CLAMP_TO_EDGE:
        return TextureWrapType::ClampToEdge;
    case GL_CLAMP_TO_BORDER:
        return TextureWrapType::ClampToBorder;
    }

    return TextureWrapType::Repeat;
}

TOON_GLTF2_API
inline TextureFilterType GetFilterType(const GLenum& type)
{
    switch (type) {
    case GL_NEAREST:
        return TextureFilterType::Nearest;
    case GL_NEAREST_MIPMAP_NEAREST:
        return TextureFilterType::NearestMipmapNearest;
    case GL_NEAREST_MIPMAP_LINEAR:
        return TextureFilterType::NearestMipmapLinear;
    case GL_LINEAR:
        return TextureFilterType::Linear;
    case GL_LINEAR_MIPMAP_NEAREST:
        return TextureFilterType::LinearMipmapNearest;
    case GL_LINEAR_MIPMAP_LINEAR:
        return TextureFilterType::LinearMipmapLinear;
    }

    return TextureFilterType::Nearest;
}

struct BufferViewData
{
    int buffer;
    size_t byteLength;
    size_t byteOffset;
    size_t byteStride;
    GLenum target;
};

struct AccessorData
{
    int bufferView;
    size_t byteOffset;
    size_t count;
    string type;
    GLenum componentType;
    bool normalized;
    // TODO: min, max
};

struct ImageData
{
    string uri;
    
    int bufferView;
    string mimeType;
};

struct CameraData
{
    string name;
    string type;

    // Perspective
    float aspectRatio;
    float yfov;

    // Orthographic
    float xmag;
    float ymag;

    // Both
    float zfar;
    float znear;
};

class TOON_GLTF2_API glTF2File
{
public:

    DISALLOW_COPY_AND_ASSIGN(glTF2File);

    glTF2File() = default;

    virtual ~glTF2File() = default;

    bool LoadFromFile(const string& filename);

    const uint32_t MAGIC = 0x46546C67; // glTF

    enum class ChunkType : uint32_t
    {
        JSON    = 0x4E4F534A, // JSON
        BIN     = 0x004E4942, // BIN
    };

    string Filename;

    string BaseDir;

    json JSON;

    std::vector<std::vector<uint8_t>> Buffers;

    std::vector<BufferViewData> BufferViews;

    std::vector<AccessorData> Accessors;

    std::vector<ImageData> Images;

    std::vector<Texture::Options> Samplers;

    std::vector<std::shared_ptr<Texture>> Textures;

    std::vector<std::shared_ptr<Material>> Materials;

    std::vector<CameraData> Cameras;
    
    // std::vector<>

    bool IsValidTexture(int index, int texCoord);

    bool LoadBuffers();

    bool LoadBufferViews();

    bool LoadAccessors();

    bool LoadImages();
    
    bool LoadSamplers();

    bool LoadTextures();

    bool LoadMaterials();
    
    bool LoadCameras();

    std::vector<std::unique_ptr<PrimitiveData>> LoadMesh();

};

class AccessorIterator
{
public:

    AccessorIterator(glTF2File * file, int index)
    {
        if (index < 0) {
            _ptr = nullptr;
            return;
        }

        _accessor = &file->Accessors[index];
        _bufferView = &file->BufferViews[_accessor->bufferView];
        _buffer = &file->Buffers[_bufferView->buffer];

        _ptr = _buffer->data() + _accessor->byteOffset + _bufferView->byteOffset;

        if (_accessor->type == "SCALAR") {
            _componentCount = 1;
        }
        else if (_accessor->type == "VEC2") {
            _componentCount = 2;
        }
        else if (_accessor->type == "VEC3") {
            _componentCount = 3;
        }
        else if (_accessor->type == "VEC4") {
            _componentCount = 4;
        }

        _stride = _bufferView->byteStride;
        if (_stride == 0) {
            switch (_accessor->componentType) {
            case GL_UNSIGNED_BYTE:
                _stride = _componentCount * sizeof(uint8_t);
                break;
            case GL_UNSIGNED_SHORT:
                _stride = _componentCount * sizeof(uint16_t);
                break;
            case GL_UNSIGNED_INT:
                _stride = _componentCount * sizeof(uint32_t);
                break;
            case GL_FLOAT:
                _stride = _componentCount * sizeof(float);
                break;
            }
        }
    }

    inline float getFloat(size_t index = 0, float def = 0.0f)
    {
        if (_ptr && index < _componentCount) {
            switch (_accessor->componentType) {
            case GL_UNSIGNED_BYTE:
                return NormalizeInteger(getAs<uint8_t>(index));
            case GL_UNSIGNED_SHORT:
                return NormalizeInteger(getAs<uint16_t>(index));
            case GL_UNSIGNED_INT:
                return NormalizeInteger(getAs<uint32_t>(index));
            case GL_FLOAT:
                return getAs<float>(index);
            }
        }

        return def;
    }

    inline uint32_t getInteger(size_t index = 0, unsigned def = 0)
    {
        if (_ptr && index < _componentCount) {
            switch (_accessor->componentType) {
            case GL_UNSIGNED_BYTE:
                return getAs<uint8_t>(index);
            case GL_UNSIGNED_SHORT:
                return getAs<uint16_t>(index);
            case GL_UNSIGNED_INT:
                return getAs<uint32_t>(index);
            case GL_FLOAT:
                return getAs<float>(index);
            }
        }

        return def;
    }

    inline glm::vec2 getVec2(glm::vec2 def = glm::vec2()) {
        return glm::vec2(
            getFloat(0, def[0]),
            getFloat(1, def[1])
        );
    }

    inline glm::vec4 getVec4(glm::vec4 def = glm::vec4()) {
        return glm::vec4(
            getFloat(0, def[0]),
            getFloat(1, def[1]),
            getFloat(2, def[2]),
            getFloat(3, def[3])
        );
    }

    inline glm::uvec4 getUVec4(glm::uvec4 def = glm::uvec4()) {
        return glm::vec4(
            getInteger(0, def[0]),
            getInteger(1, def[1]),
            getInteger(2, def[2]),
            getInteger(3, def[3])
        );
    }

    AccessorIterator& operator++() {
        if (_ptr) {
            _ptr += _stride;
            if (_ptr >= _buffer->data() + _buffer->size()) {
                _ptr = nullptr;
            }
        }

        return *this;
    }

private: 

    template <typename T>
    inline T getAs(size_t index) {
        return *reinterpret_cast<T *>(_ptr + (sizeof(T) * index));
    }

    uint8_t * _ptr;

    size_t _stride;

    size_t _componentCount;
    
    AccessorData * _accessor = nullptr;

    BufferViewData * _bufferView = nullptr;

    std::vector<uint8_t> * _buffer = nullptr;

}; // class AccessorIterator

} // namespace Toon::GLTF2

#endif // TOON_GLTF2_GLTF2_FILE_HPP
```

`Modules/GLTF2/Public/Toon/GLTF2/GLTF2Config.hpp`:

```hpp
#ifndef TOON_GLTF2_CONFIG_HPP
#define TOON_GLTF2_CONFIG_HPP

#include <Toon/Config.hpp>

#if defined(TOON_GLTF2_EXPORT)
    #define TOON_GLTF2_API TOON_API_EXPORT
#else
    #define TOON_GLTF2_API TOON_API_IMPORT
#endif

#endif // TOON_GLTF2_CONFIG_HPP
```

`Modules/GLTF2/Public/Toon/GLTF2/GLTF2MeshImporter.hpp`:

```hpp
#ifndef TOON_GLTF2_MESH_IMPORTER_HPP
#define TOON_GLTF2_MESH_IMPORTER_HPP

#include <Toon/GLTF2/GLTF2Config.hpp>

#include <Toon/MeshImporter.hpp>
#include <Toon/GLTF2/GLTF2PrimitiveData.hpp>

#include <vector>

namespace Toon::GLTF2 {

class TOON_GLTF2_API GLTF2MeshImporter : public MeshImporter
{
public:

    DISALLOW_COPY_AND_ASSIGN(GLTF2MeshImporter)

    GLTF2MeshImporter() = default;

    std::vector<std::unique_ptr<PrimitiveData>> LoadFromFile(const string& filename, bool useAssetPath = true) override;

}; // class GLTF2MeshImporter

} // namespace Toon::GLTF2

#endif // TOON_GLTF2_MESH_IMPORTER_HPP
```

`Modules/GLTF2/Public/Toon/GLTF2/GLTF2PrimitiveData.hpp`:

```hpp
#ifndef TOON_GLTF2_PRIMITIVE_DATA_HPP
#define TOON_GLTF2_PRIMITIVE_DATA_HPP

#include <Toon/PrimitiveData.hpp>

namespace Toon::GLTF2 {

class TOON_GLTF2_API GLTF2PrimitiveData : public PrimitiveData
{
public:

    DISALLOW_COPY_AND_ASSIGN(GLTF2PrimitiveData)

    GLTF2PrimitiveData() = default;

    virtual ~GLTF2PrimitiveData() = default;

    PrimitiveTopology topology;

    std::vector<uint32_t> indexList;

    std::vector<Vertex> vertexList;

    std::shared_ptr<Material> material;

    PrimitiveTopology GetTopology() const override {
        return PrimitiveTopology::TriangleList;
    }

    gsl::span<uint32_t> GetIndexList() override {
        return indexList;
    }

    gsl::span<Vertex> GetVertexList() override {
        return vertexList;
    }

    std::shared_ptr<Material> GetMaterial() override {
        return material;
    }

}; // class GLTF2PrimitiveData

} // namespace Toon::GLTF2

#endif // TOON_GLTF2_PRIMITIVE_DATA_HPP
```

`Modules/GLTF2/Public/Toon/GLTF2/GLTF2SceneImporter.hpp`:

```hpp
#ifndef TOON_GLTF2_SCENE_IMPORTER_HPP
#define TOON_GLTF2_SCENE_IMPORTER_HPP

#include <Toon/GLTF2/GLTF2Config.hpp>

#include <Toon/SceneImporter.hpp>

namespace Toon::GLTF2 {

class TOON_GLTF2_API GLTF2SceneImporter : public SceneImporter
{
public:

    DISALLOW_COPY_AND_ASSIGN(GLTF2SceneImporter)

    GLTF2SceneImporter() = default;

    virtual bool LoadFromFile(Entity * root, const string& filename) override;

}; // class GLTF2SceneImporter

} // namespace Toon::GLTF2

#endif // TOON_GLTF2_SCENE_IMPORTER_HPP
```

`Modules/OpenGL/CMakeLists.txt`:

```txt

SET(_target ToonOpenGL)

DEFINE_MODULE(${_target} OPENGL)

TARGET_LINK_LIBRARIES(
    ${_target}
    PUBLIC
        ToonSDL2
)
```

`Modules/OpenGL/Private/OpenGLBuffer.cpp`:

```cpp
#include <Toon/OpenGL/OpenGLBuffer.hpp>

#include <Toon/Log.hpp>

#include <Toon/String.hpp>

namespace Toon::OpenGL {

TOON_OPENGL_API
bool OpenGLBuffer::Initialize(size_t size, uint8_t * data, BufferUsage bufferUsage, MemoryUsage memoryUsage)
{
    _bufferUsage = bufferUsage;
    _memoryUsage = memoryUsage;
    _size = size;

    if (!data && _memoryUsage == MemoryUsage::GPU) {
        ToonLogError("Attempting to create an empty buffer with MemoryUsage GPU");
        return false;
    }
    
    _glTarget = GetGLBufferUsage(_bufferUsage);
    if (_glTarget == GL_INVALID_ENUM) {
        return false;
    }

    GLbitfield flags = GetGLMemoryUsage(_memoryUsage);

    glGenBuffers(1, &_glID);
    glBindBuffer(_glTarget, _glID);
    glBufferStorage(_glTarget, _size, data, flags);

    // TODO: Limit to only mappable memory usages
    _mappedBufferMemory = glMapBufferRange(_glTarget, 0, _size, flags);
    if (!_mappedBufferMemory) {
        ToonLogError("glMapBuffer() failed");
        return false;
    }

    glBindBuffer(_glTarget, 0);

    return true;
}

TOON_OPENGL_API
void OpenGLBuffer::Terminate()
{
    if (_mappedBufferMemory) {
        glBindBuffer(_glTarget, _glID);
        glUnmapBuffer(_glTarget);
        glBindBuffer(_glTarget, 0);
        
        _mappedBufferMemory = nullptr;
    }

    glDeleteBuffers(1, &_glID);
}

TOON_OPENGL_API
void OpenGLBuffer::Bind()
{
    glBindBuffer(_glTarget, _glID);
}

} // namespace Toon::OpenGL
```

`Modules/OpenGL/Private/OpenGLGraphicsDriver.cpp`:

```cpp
#include <Toon/OpenGL/OpenGLGraphicsDriver.hpp>

#include <Toon/Toon.hpp>
#include <Toon/Log.hpp>
#include <Toon/Scene.hpp>

namespace Toon::OpenGL {

TOON_OPENGL_API
bool OpenGLGraphicsDriver::Initialize()
{
    if (!SDL2GraphicsDriver::Initialize()) {
        return false;
    }

    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 6);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, GL_TRUE);
    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 4);

    #if defined(TOON_BUILD_DEBUG)

        SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_DEBUG_FLAG);

    #endif

    if (!SDL2GraphicsDriver::CreateWindow(SDL_WINDOW_OPENGL)) {
        return false;
    }

    _glContext = SDL_GL_CreateContext(GetSDL2Window());
    if (!_glContext) {
        ToonLogError("Failed to create OpenGL context, %s", SDL_GetError());
        return false;
    }

    if (!gladLoadGL((GLADloadfunc) SDL_GL_GetProcAddress)) {
        ToonLogError("Failed to initialize OpenGL context");
        return false;
    }

    #if defined(TOON_BUILD_DEBUG)

        InitDebugMessageCallback();

    #endif

    SDL_GL_SetSwapInterval(0);
    
    ToonLogVerbose("OpenGL Version: %s",  glGetString(GL_VERSION));
    ToonLogVerbose("GLSL Version: %s",    glGetString(GL_SHADING_LANGUAGE_VERSION));
    ToonLogVerbose("OpenGL Vendor: %s",   glGetString(GL_VENDOR));
    ToonLogVerbose("OpenGL Renderer: %s", glGetString(GL_RENDERER));

    int value = 0;

    glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &value);
    ToonLogVerbose("Max Vertex Attributes: %d", value);

    glGetIntegerv(GL_MAX_VERTEX_UNIFORM_COMPONENTS, &value);
    ToonLogVerbose("Max Vertex Uniform Components: %d", value);

    glGetIntegerv(GL_MAX_VERTEX_OUTPUT_COMPONENTS, &value);
    ToonLogVerbose("Max Vertex Output Components: %d", value);

    glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS, &value);
    ToonLogVerbose("Max Fragment Uniform Components: %d", value);

    glGetIntegerv(GL_MAX_FRAGMENT_INPUT_COMPONENTS, &value);
    ToonLogVerbose("Max Fragment Input Components: %d", value);

    glGetIntegerv(GL_MAX_DRAW_BUFFERS, &value);
    ToonLogVerbose("Max Draw Buffers: %d", value);

    glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &value);
    ToonLogVerbose("Max Fragment Texture Image Units: %d", value);

    glGetIntegerv(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, &value);
    ToonLogVerbose("Max Vertex Texture Image Units: %d", value);
    
    glGetIntegerv(GL_MAX_UNIFORM_BUFFER_BINDINGS, &value);
    ToonLogVerbose("Max Uniform Buffer Bindings: %d", value);
    
    glGetIntegerv(GL_MAX_VERTEX_UNIFORM_BLOCKS, &value);
    ToonLogVerbose("Max Vertex Uniform Blocks: %d", value);
    
    glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_BLOCKS, &value);
    ToonLogVerbose("Max Fragment Uniform Blocks: %d", value);
    
    glGetIntegerv(GL_MAX_UNIFORM_BLOCK_SIZE, &value);
    ToonLogVerbose("Max Uniform Block Size: %d", value);

    InitializeUpdateContext();
    InitializeRenderContext();

    if (!InitializeConstantBuffers()) {
        return false;
    }

    if (!InitializeDefaults()) {
        return false;
    }

    return true;
}

TOON_OPENGL_API
void OpenGLGraphicsDriver::Terminate()
{
    if (_glContext) {
        SDL_GL_DeleteContext(_glContext);
        _glContext = nullptr;
    }

    SDL2GraphicsDriver::Terminate();
}

TOON_OPENGL_API
void OpenGLGraphicsDriver::Render()
{
    glm::vec4 cc = GetClearColor();
    glClearColor(cc[0], cc[1], cc[2], cc[3]);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    GraphicsDriver::Render();

    uint8_t * data = reinterpret_cast<uint8_t *>(_renderContext->GetShaderGlobals());
    _shaderGlobalsBuffer->WriteTo(0, sizeof(ShaderGlobals), data);

    OpenGLBuffer * glGlobalsBuffer = TOON_OPENGL_BUFFER(_shaderGlobalsBuffer.get());
    glBindBufferBase(GL_UNIFORM_BUFFER, TOON_SHADER_GLOBALS_BINDING, glGlobalsBuffer->GetGLID());

    Scene * scene = GetCurrentScene();
    if (scene) {
        scene->Render(_renderContext.get());
    }

    SDL_GL_SwapWindow(GetSDL2Window());
}

TOON_OPENGL_API
std::shared_ptr<Buffer> OpenGLGraphicsDriver::CreateBuffer()
{
    return std::shared_ptr<Buffer>(new OpenGLBuffer());
}

TOON_OPENGL_API
std::shared_ptr<Pipeline> OpenGLGraphicsDriver::CreatePipeline(std::shared_ptr<Shader> shader)
{
    auto ptr = std::shared_ptr<Pipeline>(new OpenGLPipeline());
    ptr->SetShader(shader);
    return ptr;
}

TOON_OPENGL_API
std::shared_ptr<Texture> OpenGLGraphicsDriver::CreateTexture()
{
    return std::shared_ptr<Texture>(new OpenGLTexture());
}

TOON_OPENGL_API
std::shared_ptr<Shader> OpenGLGraphicsDriver::CreateShader()
{
    auto shader = std::shared_ptr<Shader>(new OpenGLShader());
    _shaderList.push_back(shader);
    return shader;
}

TOON_OPENGL_API
std::shared_ptr<Mesh> OpenGLGraphicsDriver::CreateMesh()
{
    auto ptr = std::shared_ptr<Mesh>(new OpenGLMesh());
    ptr->Initialize();
    return ptr;
}

TOON_OPENGL_API
std::shared_ptr<Material> OpenGLGraphicsDriver::CreateMaterial()
{
    return std::shared_ptr<Material>(new OpenGLMaterial());
}

TOON_OPENGL_API
std::shared_ptr<Primitive> OpenGLGraphicsDriver::CreatePrimitive()
{
    return std::shared_ptr<Primitive>(new OpenGLPrimitive());
}

void GLAPIENTRY
_OpenGLDebugMessageCallback(
    GLenum source, GLenum type, GLenum id, GLenum severity,
    GLsizei length, const GLchar * message, const void * userData)
{
    if (type == GL_DEBUG_TYPE_PERFORMANCE) {
        Log(LogLevel::Performance, "[PERF](OpenGLDebugMessage) %s\n", message);
    }
    else {
        switch (severity) {
        case GL_DEBUG_SEVERITY_HIGH:
        case GL_DEBUG_SEVERITY_MEDIUM:
            Log(LogLevel::Error, "[ERRO](OpenGLDebugMessage) %s\n", message);
            break;
        case GL_DEBUG_SEVERITY_LOW:
            Log(LogLevel::Warning, "[WARN](OpenGLDebugMessage) %s\n", message);
            break;

        #if defined(TOON_BUILD_DEBUG)

            case GL_DEBUG_SEVERITY_NOTIFICATION:
                //if (IsVerboseLoggingEnabled()) {
                    Log(LogLevel::Verbose, "[VERB](OpenGLDebugMessage) %s\n", message);
                //}
                break;
                
        #endif

        }
    }
}

TOON_OPENGL_API
void OpenGLGraphicsDriver::InitDebugMessageCallback()
{
    glEnable(GL_DEBUG_OUTPUT);
    glDebugMessageCallback(_OpenGLDebugMessageCallback, nullptr);
}

} // namespace Toon::OpenGL

```

`Modules/OpenGL/Private/OpenGLMaterial.cpp`:

```cpp
#include <Toon/OpenGL/OpenGLMaterial.hpp>
#include <Toon/OpenGL/OpenGLBuffer.hpp>
#include <Toon/OpenGL/OpenGLTexture.hpp>
#include <Toon/GraphicsDriver.hpp>

namespace Toon::OpenGL {

void OpenGLMaterial::Bind()
{
    auto gfx = GetGraphicsDriver();

    OpenGLBuffer * glMaterialBuffer = TOON_OPENGL_BUFFER(_shaderMaterialBuffer.get());
    glBindBufferBase(GL_UNIFORM_BUFFER, TOON_SHADER_MATERIAL_BINDING, glMaterialBuffer->GetGLID());

    OpenGLTexture * glDefaultTexture = TOON_OPENGL_TEXTURE(gfx->GetDefaultTexture().get());
    GLuint defaultTextureID = (glDefaultTexture ? glDefaultTexture->GetGLID() : 0);

    OpenGLTexture * glTexture = nullptr;

    glActiveTexture(GL_TEXTURE0 + GetMaterialTextureBinding(MaterialTexture::BaseColorMap));
    glTexture = TOON_OPENGL_TEXTURE(_baseColorMap.get());
    glBindTexture(GL_TEXTURE_2D, (glTexture ? glTexture->GetGLID() : defaultTextureID));

    glActiveTexture(GL_TEXTURE0 + GetMaterialTextureBinding(MaterialTexture::BaseColorMap));
    glTexture = TOON_OPENGL_TEXTURE(_baseColorMap.get());
    glBindTexture(GL_TEXTURE_2D, (glTexture ? glTexture->GetGLID() : defaultTextureID));

    glActiveTexture(GL_TEXTURE0 + GetMaterialTextureBinding(MaterialTexture::NormalMap));
    glTexture = TOON_OPENGL_TEXTURE(_normalMap.get());
    glBindTexture(GL_TEXTURE_2D, (glTexture ? glTexture->GetGLID() : defaultTextureID));

    glActiveTexture(GL_TEXTURE0 + GetMaterialTextureBinding(MaterialTexture::MetallicRoughnessMap));
    glTexture = TOON_OPENGL_TEXTURE(_metallicRoughnessMap.get());
    glBindTexture(GL_TEXTURE_2D, (glTexture ? glTexture->GetGLID() : defaultTextureID));

    glActiveTexture(GL_TEXTURE0 + GetMaterialTextureBinding(MaterialTexture::EmissiveMap));
    glTexture = TOON_OPENGL_TEXTURE(_emissiveMap.get());
    glBindTexture(GL_TEXTURE_2D, (glTexture ? glTexture->GetGLID() : defaultTextureID));

    glActiveTexture(GL_TEXTURE0 + GetMaterialTextureBinding(MaterialTexture::OcclusionMap));
    glTexture = TOON_OPENGL_TEXTURE(_occlusionMap.get());
    glBindTexture(GL_TEXTURE_2D, (glTexture ? glTexture->GetGLID() : defaultTextureID));
}

} // namespace Toon::OpenGL
```

`Modules/OpenGL/Private/OpenGLMesh.cpp`:

```cpp
#include <Toon/OpenGL/OpenGLMesh.hpp>

#include <Toon/Log.hpp>
#include <Toon/OpenGL/OpenGLPrimitive.hpp>
#include <Toon/OpenGL/OpenGLPipeline.hpp>
#include <Toon/OpenGL/OpenGLGraphicsDriver.hpp>

namespace Toon::OpenGL {

TOON_OPENGL_API
void OpenGLMesh::Render(RenderContext * ctx)
{
    Mesh::Render(ctx);

    OpenGLPipeline * glPipeline = TOON_OPENGL_PIPELINE(_pipeline.get());
    glPipeline->Bind();

    OpenGLBuffer * glTransformBuffer = TOON_OPENGL_BUFFER(_shaderTransformBuffer.get());
    glBindBufferBase(GL_UNIFORM_BUFFER, TOON_SHADER_TRANSFORM_BINDING, glTransformBuffer->GetGLID());

    for (const auto& primitive : _primitiveList) {
        OpenGLPrimitive * glPrimitive = TOON_OPENGL_PRIMITIVE(primitive.get());
        glPrimitive->Render();
    }
}

} // namespace Toon::OpenGL
```

`Modules/OpenGL/Private/OpenGLModule.cpp`:

```cpp
#include <Toon/Module.hpp>
#include <Toon/OpenGL/OpenGLGraphicsDriver.hpp>

namespace Toon::OpenGL {

bool ModuleInit() {
    SetGraphicsDriver(std::unique_ptr<GraphicsDriver>(new OpenGLGraphicsDriver()));
    if (!GetGraphicsDriver()->Initialize()) {
        SetGraphicsDriver(nullptr);
        return false;
    }

    return true;
}

void ModuleTerm() {
    SetGraphicsDriver(nullptr);
}

TOON_MODULE {
    .Name       = "OpenGL",
    .Initialize = ModuleInit,
    .Terminate  = ModuleTerm,
};

} // namespace Toon::OpenGL
```

`Modules/OpenGL/Private/OpenGLPipeline.cpp`:

```cpp
#include <Toon/OpenGL/OpenGLPipeline.hpp>

#include <Toon/GraphicsDriver.hpp>
#include <Toon/OpenGL/OpenGLShader.hpp>

#include <cassert>

namespace Toon::OpenGL {

TOON_OPENGL_API
bool OpenGLPipeline::Bind()
{
    auto gfx = GetGraphicsDriver();
    glm::ivec2 windowSize = gfx->GetWindowSize();

    OpenGLShader * shader = TOON_OPENGL_SHADER(_shader.get());
    if (shader) {
        shader->Bind();
    }

    glViewport(0, 0, windowSize.x, windowSize.y);

    glFrontFace(GetGLFrontFace(_frontFace));

    if (_cullMode == CullMode::None) {
        glDisable(GL_CULL_FACE);
    }
    else {
        glEnable(GL_CULL_FACE);
        glCullFace(GetGLCullMode(_cullMode));
    }

    glPolygonMode(GL_FRONT_AND_BACK, GetGLFillMode(_fillMode));

    switch (_depthBiasMode) {
        case DepthBiasMode::Clamp:
            glDisable(GL_DEPTH_TEST);
            glEnable(GL_POLYGON_OFFSET_FILL);
            glPolygonOffset(_depthBiasSlopeFactor, _depthBiasFactor);
            break;
        case DepthBiasMode::Clip:
            glEnable(GL_DEPTH_TEST);
            glDisable(GL_POLYGON_OFFSET_FILL);
            glDepthFunc(GetGLCompareOperation(_depthCompareOperation));
        break;
    }

    if (_blendEnabled) {
        glEnable(GL_BLEND);

        glBlendFuncSeparate(
            GetGLBlendFactor(_srcColorFactor),
            GetGLBlendFactor(_dstColorFactor),
            GetGLBlendFactor(_srcAlphaFactor),
            GetGLBlendFactor(_dstAlphaFactor)
        );

        glBlendEquationSeparate(
            GetGLBlendOperation(_colorBlendOp),
            GetGLBlendOperation(_alphaBlendOp)
        );
    }
    else {
        glDisable(GL_BLEND);
    }

    return true;
}

} // namespace Toon::OpenGL
```

`Modules/OpenGL/Private/OpenGLPrimitive.cpp`:

```cpp
#include <Toon/OpenGL/OpenGLPrimitive.hpp>
#include <Toon/OpenGL/OpenGLMaterial.hpp>
#include <Toon/GraphicsDriver.hpp>

#include <Toon/Log.hpp>
#include <Toon/Benchmark.hpp>

namespace Toon::OpenGL {

TOON_OPENGL_API
void OpenGLPrimitive::Render()
{
    glBindVertexArray(_glVAO);

    OpenGLMaterial * glMaterial = TOON_OPENGL_MATERIAL(_material.get());
    if (glMaterial) {
        glMaterial->Bind();
    }

    if (_indexed) {
        glDrawElements(_glMode, _glCount, GL_UNSIGNED_INT, NULL);
    }
    else {
        glDrawArrays(_glMode, 0, _glCount);
    }

    glBindVertexArray(0);
}

TOON_OPENGL_API
bool OpenGLPrimitive::Load(const std::unique_ptr<PrimitiveData>& data)
{
    ToonBenchmarkStart();

    auto gfx = GetGraphicsDriver();

    _material = data->GetMaterial();
    if (!_material) {
        _material = gfx->GetDefaultMaterial();
    }

    glGenVertexArrays(1, &_glVAO);
    glBindVertexArray(_glVAO);

    const auto& indexList = data->GetIndexList();
    const auto& vertexList = data->GetVertexList();

    _glMode = GetGLPrimitiveTopology(data->GetTopology());

    GLuint vbo;
    std::vector<GLuint> vbos;

    if (indexList.empty()) {
        _indexed = false;
        _glCount = vertexList.size();
    }
    else {
        _indexed = true;
        _glCount = indexList.size();

        glGenBuffers(1, &vbo);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo);
        glBufferStorage(GL_ELEMENT_ARRAY_BUFFER, indexList.size() * sizeof(uint32_t), indexList.data(), 0);

        vbos.push_back(vbo);
    }

    glGenBuffers(1, &vbo);

    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferStorage(GL_ARRAY_BUFFER, vertexList.size() * sizeof(Vertex), vertexList.data(), 0);

    vbos.push_back(vbo);

    GLuint location;

    location = GetVertexAttributeLocation(VertexAttribute::Position);
    glEnableVertexAttribArray(location);
    glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, Position));

    location = GetVertexAttributeLocation(VertexAttribute::Normal);
    glEnableVertexAttribArray(location);
    glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, Normal));

    location = GetVertexAttributeLocation(VertexAttribute::Tangent);
    glEnableVertexAttribArray(location);
    glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, Tangent));

    location = GetVertexAttributeLocation(VertexAttribute::Bitangent);
    glEnableVertexAttribArray(location);
    glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, Bitangent));

    location = GetVertexAttributeLocation(VertexAttribute::Color);
    glEnableVertexAttribArray(location);
    glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, Color));

    location = GetVertexAttributeLocation(VertexAttribute::TexCoord1);
    glEnableVertexAttribArray(location);
    glVertexAttribPointer(location, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, TexCoord1));

    location = GetVertexAttributeLocation(VertexAttribute::TexCoord2);
    glEnableVertexAttribArray(location);
    glVertexAttribPointer(location, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, TexCoord2));

    location = GetVertexAttributeLocation(VertexAttribute::Joints);
    glEnableVertexAttribArray(location);
    glVertexAttribPointer(location, 4, GL_SHORT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, Joints));

    location = GetVertexAttributeLocation(VertexAttribute::Weights);
    glEnableVertexAttribArray(location);
    glVertexAttribPointer(location, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, Weights));

    glBindVertexArray(0);

    ToonBenchmarkEnd();
    return true;
}

}
```

`Modules/OpenGL/Private/OpenGLShader.cpp`:

```cpp
#include <Toon/OpenGL/OpenGLShader.hpp>
#include <Toon/Log.hpp>
#include <Toon/Util.hpp>
#include <Toon/Benchmark.hpp>

#include <fstream>
#include <vector>
#include <sstream>
#include <functional>

namespace Toon::OpenGL {

TOON_OPENGL_API
bool OpenGLShader::LoadFromFiles(const std::vector<std::string>& filenames, bool useAssetPath /*= true*/)
{
    ToonBenchmarkStart();

    std::vector<GLuint> shaders;

    for (const auto& filename : filenames) {
        GLuint shader = 0;

        const string& ext = GetExtension(filename);

        if (ext == "spv") {
            shader = LoadSPV(filename, useAssetPath);
        }
        else if (ext == "glsl") {
            shader = LoadGLSL(filename, useAssetPath);
        }
        else {
            shader = LoadSPV(filename + ".spv", useAssetPath);
            if (shader == 0) {
                shader = LoadGLSL(filename + ".glsl", useAssetPath);
            }
        }

        if (shader == 0) {
            for (GLuint shader : shaders) {
                glDeleteShader(shader);
            }

            ToonLogError("Failed to load '%s'", filename);
            return false;
        }

        GLint compiled = GL_FALSE;
        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
        if (!compiled) {
            GLint logLength = 0;
            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLength);

            std::vector<GLchar> log(logLength);
            glGetShaderInfoLog(shader, logLength, &logLength, log.data());

            for (GLuint shader : shaders) {
                glDeleteShader(shader);
            }

            ToonLogError("Failed to compile shader '%s'\n%s", filename, log.data());
            return false;
        }

        shaders.push_back(shader);
    }

    _glID = glCreateProgram();
    if (!_glID) {
        ToonLogError("Failed to create shader program");
        return false;
    }

    for (GLuint shader : shaders) {
        glAttachShader(_glID, shader);
    }

    glLinkProgram(_glID);
    
    GLint linked = GL_FALSE;
    glGetProgramiv(_glID, GL_LINK_STATUS, &linked);
    if (!linked) {
        GLint logLength = 0;
        glGetProgramiv(_glID, GL_INFO_LOG_LENGTH, &logLength);

        std::vector<GLchar> log(logLength);
        glGetProgramInfoLog(_glID, logLength, &logLength, log.data());

        glDeleteProgram(_glID);
        _glID = 0;

        for (GLuint shader : shaders) {
            glDeleteShader(shader);
        }

        ToonLogError("Failed to link shader\n%s", log.data());
        return false;
    }

    for (GLuint shader : shaders) {
        glDetachShader(_glID, shader);
    }

    ToonBenchmarkEnd();
    return true;
}

TOON_OPENGL_API
void OpenGLShader::Bind()
{
    glUseProgram(_glID);
}

TOON_OPENGL_API
GLuint OpenGLShader::GetID()
{
    return _glID;
}

TOON_OPENGL_API
GLuint OpenGLShader::LoadSPV(const std::string& filename, bool useAssetPath)
{
    ToonLogVerbose("Looking for SPIR-V shader '%s'", filename);

    const auto& assetPathList = GetAssetPathList();

    std::ifstream file;

    if (useAssetPath) {
        for (const auto& path : assetPathList) {
            Path fullPath = path / "Shaders" / filename;
            ToonLogVerbose("Checking '%s'", fullPath);
            
            file.open(fullPath.ToString(), std::ios::binary);
            if (file.is_open()) {
                break;
            }
        }
    }
    else {
        file.open(filename, std::ios::binary);
    }

    if (!file.is_open()) {
        return 0;
    }

    file.unsetf(std::ios::skipws);

    ToonLogLoad("Loading SPIR-V shader '%s'", filename);

    std::vector<uint8_t> data(
        (std::istreambuf_iterator<char>(file)),
        std::istreambuf_iterator<char>()
    );

    GLenum type = GetGLShaderType(filename);
    if (type == GL_INVALID_ENUM) {
        ToonLogError("Failed to determine shader type of '%s'", filename);
        return 0;
    }

    GLuint shader = glCreateShader(type);

    glShaderBinary(1, &shader, GL_SHADER_BINARY_FORMAT_SPIR_V, data.data(), data.size());

    glSpecializeShader(shader, "main", 0, nullptr, nullptr);

    return shader;
}

TOON_OPENGL_API
GLuint OpenGLShader::LoadGLSL(const std::string& filename, bool useAssetPath)
{
    ToonLogVerbose("Looking for GLSL shader '%s'", filename);

    const auto& assetPaths = GetAssetPathList();

    std::ifstream file;

    if (useAssetPath) {
        for (const auto& path : assetPaths) {
            Path fullPath = path / "Shaders" / filename;
            ToonLogVerbose("Checking '%s'", fullPath);
            
            file.open(fullPath.ToString());
            if (file.is_open()) {
                break;
            }
        }
    }
    else {
        file.open(filename);
    }

    if (!file.is_open()) {
        return 0;
    }
    
    ToonLogLoad("Loading GLSL shader '%s'", filename);

    string code(
        (std::istreambuf_iterator<char>(file)),
        std::istreambuf_iterator<char>()
    );

    // TODO: Support relative includes, without asset path

    std::function<string(string)> preprocessGLSL = 
        [&](string code) -> string {
            std::istringstream iss(code);
            string outCode;
            string line;

            while (std::getline(iss, line)) {
                if (line.compare(0, sizeof("#include")-1, "#include") == 0) {
                    size_t left = line.find('"');
                    size_t right = line.rfind('"');

                    if (left == string::npos || right == string::npos) {
                        left = line.find('<');
                        right = line.rfind('>');

                        if (left == string::npos || right == string::npos) {
                            ToonLogError("Unable to parse filename from shader include");
                            return "";
                        }
                    }

                    string incFilename = line.substr(left + 1, right - left - 1);
                    std::ifstream incFile;

                    for (const auto& path : assetPaths) {
                        Path fullPath = path / "Shaders" / incFilename;
                        ToonLogVerbose("Checking '%s'", fullPath);
                        
                        incFile.open(fullPath);
                        if (incFile.is_open()) {
                            break;
                        }
                    }

                    if (!incFile.is_open()) {
                        ToonLogError("Unable to find shader include '%s'", incFilename);
                        return "";
                    }

                    string incCode(
                        (std::istreambuf_iterator<char>(incFile)),
                        std::istreambuf_iterator<char>()
                    );

                    outCode += preprocessGLSL(incCode);
                }
                else {
                    outCode += line + "\n";
                }
            }

            return outCode;
        };

    code = preprocessGLSL(code);

    GLenum type = GetGLShaderType(filename);
    if (type == GL_INVALID_ENUM) {
        ToonLogError("Unable to determine shader type of '%s'", filename);
        return 0;
    }

    GLuint shader = glCreateShader(type);
    
    const char * ptr = code.c_str();
    glShaderSource(shader, 1, (const GLchar **)&ptr, nullptr);

    glCompileShader(shader);

    glSpecializeShader(shader, "main", 0, nullptr, nullptr);

    return shader;
}

TOON_OPENGL_API
GLenum OpenGLShader::GetGLShaderType(const std::string& filename)
{
    std::string ext = GetExtension(filename);
    if (ext == "spv" || ext == "glsl") {
        size_t pivot = filename.find_last_of('.');
        if (pivot == std::string::npos) {
            return GL_INVALID_ENUM;
        }
        ext = GetExtension(filename.substr(0, pivot));
    }

    if (ext == "vert" || ext == "vertex") {
        return GL_VERTEX_SHADER;
    }
    else if (ext == "frag" || ext == "fragment") {
        return GL_FRAGMENT_SHADER;
    }
    else if (ext == "tesc" || ext == "tesscontrol") {
        return GL_TESS_CONTROL_SHADER;
    }
    else if (ext == "tese" || ext == "tesseval") {
        return GL_TESS_EVALUATION_SHADER;
    }
    else if (ext == "comp" || ext == "compute") {
        return GL_COMPUTE_SHADER;
    }

    return GL_INVALID_ENUM;
}

} // namespace Toon::OpenGL
```

`Modules/OpenGL/Private/OpenGLTexture.cpp`:

```cpp
#include <Toon/OpenGL/OpenGLTexture.hpp>

#include <Toon/Benchmark.hpp>
#include <Toon/Log.hpp>

namespace Toon::OpenGL {

TOON_OPENGL_API
OpenGLTexture::~OpenGLTexture()
{
    if (_glID) {
        glDeleteTextures(1, &_glID);
        _glID = 0;
    }
}

TOON_OPENGL_API
bool OpenGLTexture::Load(const std::unique_ptr<TextureData>& data, Options opts /*= Options()*/)
{
    ToonBenchmarkStart();

    if (_glID) {
        glDeleteTextures(1, &_glID);
        _glID = 0;
    }

    glGenTextures(1, &_glID);
    if (!_glID) {
        ToonLogError("Failed to create GL Texture");
        return false;
    }

    GLenum glType = GetGLDataType(data->GetDataType());

    glBindTexture(GL_TEXTURE_2D, _glID);

    const auto& size = data->GetSize();

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, size.x, size.y, 0, GL_RGBA, glType, data->GetData());

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GetGLWrapType(opts.WrapS));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GetGLWrapType(opts.WrapT));

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GetGLFilterType(opts.MagFilter));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GetGLFilterType(opts.MinFilter));

    ToonLogVerbose("Bound texture to ID %d", _glID);

    glBindTexture(GL_TEXTURE_2D, 0);

    ToonBenchmarkEnd();
    return true;
}

TOON_OPENGL_API
GLenum OpenGLTexture::GetGLDataType(const TextureDataType& type)
{
    switch (type) {
    case TextureDataType::UnsignedByte:
        return GL_UNSIGNED_BYTE;
    case TextureDataType::Byte:
        return GL_BYTE;
    case TextureDataType::UnsignedShort:
        return GL_UNSIGNED_SHORT;
    case TextureDataType::Short:
        return GL_SHORT;
    case TextureDataType::UnsignedInt:
        return GL_UNSIGNED_INT;
    case TextureDataType::Int:
        return GL_INT;
    }

    return GL_INVALID_ENUM;
}

TOON_OPENGL_API
GLenum OpenGLTexture::GetGLWrapType(const TextureWrapType& type)
{
    switch (type) {
    case TextureWrapType::Repeat:
        return GL_REPEAT;
    case TextureWrapType::MirroredRepeat:
        return GL_MIRRORED_REPEAT;
    case TextureWrapType::ClampToEdge:
        return GL_CLAMP_TO_EDGE;
    case TextureWrapType::ClampToBorder:
        return GL_CLAMP_TO_BORDER;
    }

    return GL_INVALID_ENUM;
}

TOON_OPENGL_API
GLenum OpenGLTexture::GetGLFilterType(const TextureFilterType& type)
{
    switch (type) {
    case TextureFilterType::Nearest:
        return GL_NEAREST;
    case TextureFilterType::NearestMipmapLinear:
        // return GL_NEAREST_MIPMAP_LINEAR;
        return GL_NEAREST;
    case TextureFilterType::NearestMipmapNearest:
        // return GL_NEAREST_MIPMAP_NEAREST;
        return GL_NEAREST;
    case TextureFilterType::Linear:
        return GL_LINEAR;
    case TextureFilterType::LinearMipmapLinear:
        // return GL_LINEAR_MIPMAP_LINEAR;
        return GL_LINEAR;
    case TextureFilterType::LinearMipmapNearest:
        // return GL_LINEAR_MIPMAP_NEAREST;
        return GL_LINEAR;
    }

    return GL_INVALID_ENUM;
}

} // namespace Toon::OpenGL
```

`Modules/OpenGL/Private/glad/gl.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <glad/gl.h>

#ifndef GLAD_IMPL_UTIL_C_
#define GLAD_IMPL_UTIL_C_

#ifdef _MSC_VER
#define GLAD_IMPL_UTIL_SSCANF sscanf_s
#else
#define GLAD_IMPL_UTIL_SSCANF sscanf
#endif

#endif /* GLAD_IMPL_UTIL_C_ */


int GLAD_GL_VERSION_1_0 = 0;
int GLAD_GL_VERSION_1_1 = 0;
int GLAD_GL_VERSION_1_2 = 0;
int GLAD_GL_VERSION_1_3 = 0;
int GLAD_GL_VERSION_1_4 = 0;
int GLAD_GL_VERSION_1_5 = 0;
int GLAD_GL_VERSION_2_0 = 0;
int GLAD_GL_VERSION_2_1 = 0;
int GLAD_GL_VERSION_3_0 = 0;
int GLAD_GL_VERSION_3_1 = 0;
int GLAD_GL_VERSION_3_2 = 0;
int GLAD_GL_VERSION_3_3 = 0;
int GLAD_GL_VERSION_4_0 = 0;
int GLAD_GL_VERSION_4_1 = 0;
int GLAD_GL_VERSION_4_2 = 0;
int GLAD_GL_VERSION_4_3 = 0;
int GLAD_GL_VERSION_4_4 = 0;
int GLAD_GL_VERSION_4_5 = 0;
int GLAD_GL_VERSION_4_6 = 0;
int GLAD_GL_AMD_blend_minmax_factor = 0;
int GLAD_GL_AMD_conservative_depth = 0;
int GLAD_GL_AMD_debug_output = 0;
int GLAD_GL_AMD_depth_clamp_separate = 0;
int GLAD_GL_AMD_draw_buffers_blend = 0;
int GLAD_GL_AMD_framebuffer_sample_positions = 0;
int GLAD_GL_AMD_gcn_shader = 0;
int GLAD_GL_AMD_gpu_shader_half_float = 0;
int GLAD_GL_AMD_gpu_shader_int16 = 0;
int GLAD_GL_AMD_gpu_shader_int64 = 0;
int GLAD_GL_AMD_interleaved_elements = 0;
int GLAD_GL_AMD_multi_draw_indirect = 0;
int GLAD_GL_AMD_name_gen_delete = 0;
int GLAD_GL_AMD_occlusion_query_event = 0;
int GLAD_GL_AMD_performance_monitor = 0;
int GLAD_GL_AMD_pinned_memory = 0;
int GLAD_GL_AMD_query_buffer_object = 0;
int GLAD_GL_AMD_sample_positions = 0;
int GLAD_GL_AMD_seamless_cubemap_per_texture = 0;
int GLAD_GL_AMD_shader_atomic_counter_ops = 0;
int GLAD_GL_AMD_shader_ballot = 0;
int GLAD_GL_AMD_shader_explicit_vertex_parameter = 0;
int GLAD_GL_AMD_shader_stencil_export = 0;
int GLAD_GL_AMD_shader_trinary_minmax = 0;
int GLAD_GL_AMD_sparse_texture = 0;
int GLAD_GL_AMD_stencil_operation_extended = 0;
int GLAD_GL_AMD_texture_gather_bias_lod = 0;
int GLAD_GL_AMD_texture_texture4 = 0;
int GLAD_GL_AMD_transform_feedback3_lines_triangles = 0;
int GLAD_GL_AMD_transform_feedback4 = 0;
int GLAD_GL_AMD_vertex_shader_layer = 0;
int GLAD_GL_AMD_vertex_shader_tessellator = 0;
int GLAD_GL_AMD_vertex_shader_viewport_index = 0;
int GLAD_GL_APPLE_aux_depth_stencil = 0;
int GLAD_GL_APPLE_client_storage = 0;
int GLAD_GL_APPLE_element_array = 0;
int GLAD_GL_APPLE_fence = 0;
int GLAD_GL_APPLE_float_pixels = 0;
int GLAD_GL_APPLE_flush_buffer_range = 0;
int GLAD_GL_APPLE_object_purgeable = 0;
int GLAD_GL_APPLE_rgb_422 = 0;
int GLAD_GL_APPLE_row_bytes = 0;
int GLAD_GL_APPLE_specular_vector = 0;
int GLAD_GL_APPLE_texture_range = 0;
int GLAD_GL_APPLE_transform_hint = 0;
int GLAD_GL_APPLE_vertex_array_object = 0;
int GLAD_GL_APPLE_vertex_array_range = 0;
int GLAD_GL_APPLE_vertex_program_evaluators = 0;
int GLAD_GL_APPLE_ycbcr_422 = 0;
int GLAD_GL_ARB_ES2_compatibility = 0;
int GLAD_GL_ARB_ES3_1_compatibility = 0;
int GLAD_GL_ARB_ES3_2_compatibility = 0;
int GLAD_GL_ARB_ES3_compatibility = 0;
int GLAD_GL_ARB_arrays_of_arrays = 0;
int GLAD_GL_ARB_base_instance = 0;
int GLAD_GL_ARB_bindless_texture = 0;
int GLAD_GL_ARB_blend_func_extended = 0;
int GLAD_GL_ARB_buffer_storage = 0;
int GLAD_GL_ARB_cl_event = 0;
int GLAD_GL_ARB_clear_buffer_object = 0;
int GLAD_GL_ARB_clear_texture = 0;
int GLAD_GL_ARB_clip_control = 0;
int GLAD_GL_ARB_color_buffer_float = 0;
int GLAD_GL_ARB_compatibility = 0;
int GLAD_GL_ARB_compressed_texture_pixel_storage = 0;
int GLAD_GL_ARB_compute_shader = 0;
int GLAD_GL_ARB_compute_variable_group_size = 0;
int GLAD_GL_ARB_conditional_render_inverted = 0;
int GLAD_GL_ARB_conservative_depth = 0;
int GLAD_GL_ARB_copy_buffer = 0;
int GLAD_GL_ARB_copy_image = 0;
int GLAD_GL_ARB_cull_distance = 0;
int GLAD_GL_ARB_debug_output = 0;
int GLAD_GL_ARB_depth_buffer_float = 0;
int GLAD_GL_ARB_depth_clamp = 0;
int GLAD_GL_ARB_depth_texture = 0;
int GLAD_GL_ARB_derivative_control = 0;
int GLAD_GL_ARB_direct_state_access = 0;
int GLAD_GL_ARB_draw_buffers = 0;
int GLAD_GL_ARB_draw_buffers_blend = 0;
int GLAD_GL_ARB_draw_elements_base_vertex = 0;
int GLAD_GL_ARB_draw_indirect = 0;
int GLAD_GL_ARB_draw_instanced = 0;
int GLAD_GL_ARB_enhanced_layouts = 0;
int GLAD_GL_ARB_explicit_attrib_location = 0;
int GLAD_GL_ARB_explicit_uniform_location = 0;
int GLAD_GL_ARB_fragment_coord_conventions = 0;
int GLAD_GL_ARB_fragment_layer_viewport = 0;
int GLAD_GL_ARB_fragment_program = 0;
int GLAD_GL_ARB_fragment_program_shadow = 0;
int GLAD_GL_ARB_fragment_shader = 0;
int GLAD_GL_ARB_fragment_shader_interlock = 0;
int GLAD_GL_ARB_framebuffer_no_attachments = 0;
int GLAD_GL_ARB_framebuffer_object = 0;
int GLAD_GL_ARB_framebuffer_sRGB = 0;
int GLAD_GL_ARB_geometry_shader4 = 0;
int GLAD_GL_ARB_get_program_binary = 0;
int GLAD_GL_ARB_get_texture_sub_image = 0;
int GLAD_GL_ARB_gl_spirv = 0;
int GLAD_GL_ARB_gpu_shader5 = 0;
int GLAD_GL_ARB_gpu_shader_fp64 = 0;
int GLAD_GL_ARB_gpu_shader_int64 = 0;
int GLAD_GL_ARB_half_float_pixel = 0;
int GLAD_GL_ARB_half_float_vertex = 0;
int GLAD_GL_ARB_imaging = 0;
int GLAD_GL_ARB_indirect_parameters = 0;
int GLAD_GL_ARB_instanced_arrays = 0;
int GLAD_GL_ARB_internalformat_query = 0;
int GLAD_GL_ARB_internalformat_query2 = 0;
int GLAD_GL_ARB_invalidate_subdata = 0;
int GLAD_GL_ARB_map_buffer_alignment = 0;
int GLAD_GL_ARB_map_buffer_range = 0;
int GLAD_GL_ARB_matrix_palette = 0;
int GLAD_GL_ARB_multi_bind = 0;
int GLAD_GL_ARB_multi_draw_indirect = 0;
int GLAD_GL_ARB_multisample = 0;
int GLAD_GL_ARB_multitexture = 0;
int GLAD_GL_ARB_occlusion_query = 0;
int GLAD_GL_ARB_occlusion_query2 = 0;
int GLAD_GL_ARB_parallel_shader_compile = 0;
int GLAD_GL_ARB_pipeline_statistics_query = 0;
int GLAD_GL_ARB_pixel_buffer_object = 0;
int GLAD_GL_ARB_point_parameters = 0;
int GLAD_GL_ARB_point_sprite = 0;
int GLAD_GL_ARB_polygon_offset_clamp = 0;
int GLAD_GL_ARB_post_depth_coverage = 0;
int GLAD_GL_ARB_program_interface_query = 0;
int GLAD_GL_ARB_provoking_vertex = 0;
int GLAD_GL_ARB_query_buffer_object = 0;
int GLAD_GL_ARB_robust_buffer_access_behavior = 0;
int GLAD_GL_ARB_robustness = 0;
int GLAD_GL_ARB_robustness_isolation = 0;
int GLAD_GL_ARB_sample_locations = 0;
int GLAD_GL_ARB_sample_shading = 0;
int GLAD_GL_ARB_sampler_objects = 0;
int GLAD_GL_ARB_seamless_cube_map = 0;
int GLAD_GL_ARB_seamless_cubemap_per_texture = 0;
int GLAD_GL_ARB_separate_shader_objects = 0;
int GLAD_GL_ARB_shader_atomic_counter_ops = 0;
int GLAD_GL_ARB_shader_atomic_counters = 0;
int GLAD_GL_ARB_shader_ballot = 0;
int GLAD_GL_ARB_shader_bit_encoding = 0;
int GLAD_GL_ARB_shader_clock = 0;
int GLAD_GL_ARB_shader_draw_parameters = 0;
int GLAD_GL_ARB_shader_group_vote = 0;
int GLAD_GL_ARB_shader_image_load_store = 0;
int GLAD_GL_ARB_shader_image_size = 0;
int GLAD_GL_ARB_shader_objects = 0;
int GLAD_GL_ARB_shader_precision = 0;
int GLAD_GL_ARB_shader_stencil_export = 0;
int GLAD_GL_ARB_shader_storage_buffer_object = 0;
int GLAD_GL_ARB_shader_subroutine = 0;
int GLAD_GL_ARB_shader_texture_image_samples = 0;
int GLAD_GL_ARB_shader_texture_lod = 0;
int GLAD_GL_ARB_shader_viewport_layer_array = 0;
int GLAD_GL_ARB_shading_language_100 = 0;
int GLAD_GL_ARB_shading_language_420pack = 0;
int GLAD_GL_ARB_shading_language_include = 0;
int GLAD_GL_ARB_shading_language_packing = 0;
int GLAD_GL_ARB_shadow = 0;
int GLAD_GL_ARB_shadow_ambient = 0;
int GLAD_GL_ARB_sparse_buffer = 0;
int GLAD_GL_ARB_sparse_texture = 0;
int GLAD_GL_ARB_sparse_texture2 = 0;
int GLAD_GL_ARB_sparse_texture_clamp = 0;
int GLAD_GL_ARB_spirv_extensions = 0;
int GLAD_GL_ARB_stencil_texturing = 0;
int GLAD_GL_ARB_sync = 0;
int GLAD_GL_ARB_tessellation_shader = 0;
int GLAD_GL_ARB_texture_barrier = 0;
int GLAD_GL_ARB_texture_border_clamp = 0;
int GLAD_GL_ARB_texture_buffer_object = 0;
int GLAD_GL_ARB_texture_buffer_object_rgb32 = 0;
int GLAD_GL_ARB_texture_buffer_range = 0;
int GLAD_GL_ARB_texture_compression = 0;
int GLAD_GL_ARB_texture_compression_bptc = 0;
int GLAD_GL_ARB_texture_compression_rgtc = 0;
int GLAD_GL_ARB_texture_cube_map = 0;
int GLAD_GL_ARB_texture_cube_map_array = 0;
int GLAD_GL_ARB_texture_env_add = 0;
int GLAD_GL_ARB_texture_env_combine = 0;
int GLAD_GL_ARB_texture_env_crossbar = 0;
int GLAD_GL_ARB_texture_env_dot3 = 0;
int GLAD_GL_ARB_texture_filter_anisotropic = 0;
int GLAD_GL_ARB_texture_filter_minmax = 0;
int GLAD_GL_ARB_texture_float = 0;
int GLAD_GL_ARB_texture_gather = 0;
int GLAD_GL_ARB_texture_mirror_clamp_to_edge = 0;
int GLAD_GL_ARB_texture_mirrored_repeat = 0;
int GLAD_GL_ARB_texture_multisample = 0;
int GLAD_GL_ARB_texture_non_power_of_two = 0;
int GLAD_GL_ARB_texture_query_levels = 0;
int GLAD_GL_ARB_texture_query_lod = 0;
int GLAD_GL_ARB_texture_rectangle = 0;
int GLAD_GL_ARB_texture_rg = 0;
int GLAD_GL_ARB_texture_rgb10_a2ui = 0;
int GLAD_GL_ARB_texture_stencil8 = 0;
int GLAD_GL_ARB_texture_storage = 0;
int GLAD_GL_ARB_texture_storage_multisample = 0;
int GLAD_GL_ARB_texture_swizzle = 0;
int GLAD_GL_ARB_texture_view = 0;
int GLAD_GL_ARB_timer_query = 0;
int GLAD_GL_ARB_transform_feedback2 = 0;
int GLAD_GL_ARB_transform_feedback3 = 0;
int GLAD_GL_ARB_transform_feedback_instanced = 0;
int GLAD_GL_ARB_transform_feedback_overflow_query = 0;
int GLAD_GL_ARB_transpose_matrix = 0;
int GLAD_GL_ARB_uniform_buffer_object = 0;
int GLAD_GL_ARB_vertex_array_bgra = 0;
int GLAD_GL_ARB_vertex_array_object = 0;
int GLAD_GL_ARB_vertex_attrib_64bit = 0;
int GLAD_GL_ARB_vertex_attrib_binding = 0;
int GLAD_GL_ARB_vertex_blend = 0;
int GLAD_GL_ARB_vertex_buffer_object = 0;
int GLAD_GL_ARB_vertex_program = 0;
int GLAD_GL_ARB_vertex_shader = 0;
int GLAD_GL_ARB_vertex_type_10f_11f_11f_rev = 0;
int GLAD_GL_ARB_vertex_type_2_10_10_10_rev = 0;
int GLAD_GL_ARB_viewport_array = 0;
int GLAD_GL_ARB_window_pos = 0;
int GLAD_GL_ATI_draw_buffers = 0;
int GLAD_GL_ATI_element_array = 0;
int GLAD_GL_ATI_envmap_bumpmap = 0;
int GLAD_GL_ATI_fragment_shader = 0;
int GLAD_GL_ATI_map_object_buffer = 0;
int GLAD_GL_ATI_meminfo = 0;
int GLAD_GL_ATI_pixel_format_float = 0;
int GLAD_GL_ATI_pn_triangles = 0;
int GLAD_GL_ATI_separate_stencil = 0;
int GLAD_GL_ATI_text_fragment_shader = 0;
int GLAD_GL_ATI_texture_env_combine3 = 0;
int GLAD_GL_ATI_texture_float = 0;
int GLAD_GL_ATI_texture_mirror_once = 0;
int GLAD_GL_ATI_vertex_array_object = 0;
int GLAD_GL_ATI_vertex_attrib_array_object = 0;
int GLAD_GL_ATI_vertex_streams = 0;
int GLAD_GL_EXT_422_pixels = 0;
int GLAD_GL_EXT_abgr = 0;
int GLAD_GL_EXT_bgra = 0;
int GLAD_GL_EXT_bindable_uniform = 0;
int GLAD_GL_EXT_blend_color = 0;
int GLAD_GL_EXT_blend_equation_separate = 0;
int GLAD_GL_EXT_blend_func_separate = 0;
int GLAD_GL_EXT_blend_logic_op = 0;
int GLAD_GL_EXT_blend_minmax = 0;
int GLAD_GL_EXT_blend_subtract = 0;
int GLAD_GL_EXT_clip_volume_hint = 0;
int GLAD_GL_EXT_cmyka = 0;
int GLAD_GL_EXT_color_subtable = 0;
int GLAD_GL_EXT_compiled_vertex_array = 0;
int GLAD_GL_EXT_convolution = 0;
int GLAD_GL_EXT_coordinate_frame = 0;
int GLAD_GL_EXT_copy_texture = 0;
int GLAD_GL_EXT_cull_vertex = 0;
int GLAD_GL_EXT_debug_label = 0;
int GLAD_GL_EXT_debug_marker = 0;
int GLAD_GL_EXT_depth_bounds_test = 0;
int GLAD_GL_EXT_direct_state_access = 0;
int GLAD_GL_EXT_draw_buffers2 = 0;
int GLAD_GL_EXT_draw_instanced = 0;
int GLAD_GL_EXT_draw_range_elements = 0;
int GLAD_GL_EXT_external_buffer = 0;
int GLAD_GL_EXT_fog_coord = 0;
int GLAD_GL_EXT_framebuffer_blit = 0;
int GLAD_GL_EXT_framebuffer_multisample = 0;
int GLAD_GL_EXT_framebuffer_multisample_blit_scaled = 0;
int GLAD_GL_EXT_framebuffer_object = 0;
int GLAD_GL_EXT_framebuffer_sRGB = 0;
int GLAD_GL_EXT_geometry_shader4 = 0;
int GLAD_GL_EXT_gpu_program_parameters = 0;
int GLAD_GL_EXT_gpu_shader4 = 0;
int GLAD_GL_EXT_histogram = 0;
int GLAD_GL_EXT_index_array_formats = 0;
int GLAD_GL_EXT_index_func = 0;
int GLAD_GL_EXT_index_material = 0;
int GLAD_GL_EXT_index_texture = 0;
int GLAD_GL_EXT_light_texture = 0;
int GLAD_GL_EXT_memory_object = 0;
int GLAD_GL_EXT_memory_object_fd = 0;
int GLAD_GL_EXT_memory_object_win32 = 0;
int GLAD_GL_EXT_misc_attribute = 0;
int GLAD_GL_EXT_multi_draw_arrays = 0;
int GLAD_GL_EXT_multisample = 0;
int GLAD_GL_EXT_packed_depth_stencil = 0;
int GLAD_GL_EXT_packed_float = 0;
int GLAD_GL_EXT_packed_pixels = 0;
int GLAD_GL_EXT_paletted_texture = 0;
int GLAD_GL_EXT_pixel_buffer_object = 0;
int GLAD_GL_EXT_pixel_transform = 0;
int GLAD_GL_EXT_pixel_transform_color_table = 0;
int GLAD_GL_EXT_point_parameters = 0;
int GLAD_GL_EXT_polygon_offset = 0;
int GLAD_GL_EXT_polygon_offset_clamp = 0;
int GLAD_GL_EXT_post_depth_coverage = 0;
int GLAD_GL_EXT_provoking_vertex = 0;
int GLAD_GL_EXT_raster_multisample = 0;
int GLAD_GL_EXT_rescale_normal = 0;
int GLAD_GL_EXT_secondary_color = 0;
int GLAD_GL_EXT_semaphore = 0;
int GLAD_GL_EXT_semaphore_fd = 0;
int GLAD_GL_EXT_semaphore_win32 = 0;
int GLAD_GL_EXT_separate_shader_objects = 0;
int GLAD_GL_EXT_separate_specular_color = 0;
int GLAD_GL_EXT_shader_image_load_formatted = 0;
int GLAD_GL_EXT_shader_image_load_store = 0;
int GLAD_GL_EXT_shader_integer_mix = 0;
int GLAD_GL_EXT_shadow_funcs = 0;
int GLAD_GL_EXT_shared_texture_palette = 0;
int GLAD_GL_EXT_sparse_texture2 = 0;
int GLAD_GL_EXT_stencil_clear_tag = 0;
int GLAD_GL_EXT_stencil_two_side = 0;
int GLAD_GL_EXT_stencil_wrap = 0;
int GLAD_GL_EXT_subtexture = 0;
int GLAD_GL_EXT_texture = 0;
int GLAD_GL_EXT_texture3D = 0;
int GLAD_GL_EXT_texture_array = 0;
int GLAD_GL_EXT_texture_buffer_object = 0;
int GLAD_GL_EXT_texture_compression_latc = 0;
int GLAD_GL_EXT_texture_compression_rgtc = 0;
int GLAD_GL_EXT_texture_compression_s3tc = 0;
int GLAD_GL_EXT_texture_cube_map = 0;
int GLAD_GL_EXT_texture_env_add = 0;
int GLAD_GL_EXT_texture_env_combine = 0;
int GLAD_GL_EXT_texture_env_dot3 = 0;
int GLAD_GL_EXT_texture_filter_anisotropic = 0;
int GLAD_GL_EXT_texture_filter_minmax = 0;
int GLAD_GL_EXT_texture_integer = 0;
int GLAD_GL_EXT_texture_lod_bias = 0;
int GLAD_GL_EXT_texture_mirror_clamp = 0;
int GLAD_GL_EXT_texture_object = 0;
int GLAD_GL_EXT_texture_perturb_normal = 0;
int GLAD_GL_EXT_texture_sRGB = 0;
int GLAD_GL_EXT_texture_sRGB_decode = 0;
int GLAD_GL_EXT_texture_shared_exponent = 0;
int GLAD_GL_EXT_texture_snorm = 0;
int GLAD_GL_EXT_texture_swizzle = 0;
int GLAD_GL_EXT_timer_query = 0;
int GLAD_GL_EXT_transform_feedback = 0;
int GLAD_GL_EXT_vertex_array = 0;
int GLAD_GL_EXT_vertex_array_bgra = 0;
int GLAD_GL_EXT_vertex_attrib_64bit = 0;
int GLAD_GL_EXT_vertex_shader = 0;
int GLAD_GL_EXT_vertex_weighting = 0;
int GLAD_GL_EXT_win32_keyed_mutex = 0;
int GLAD_GL_EXT_window_rectangles = 0;
int GLAD_GL_EXT_x11_sync_object = 0;
int GLAD_GL_INTEL_conservative_rasterization = 0;
int GLAD_GL_INTEL_fragment_shader_ordering = 0;
int GLAD_GL_INTEL_framebuffer_CMAA = 0;
int GLAD_GL_INTEL_map_texture = 0;
int GLAD_GL_INTEL_parallel_arrays = 0;
int GLAD_GL_INTEL_performance_query = 0;
int GLAD_GL_KHR_blend_equation_advanced = 0;
int GLAD_GL_KHR_blend_equation_advanced_coherent = 0;
int GLAD_GL_KHR_context_flush_control = 0;
int GLAD_GL_KHR_debug = 0;
int GLAD_GL_KHR_no_error = 0;
int GLAD_GL_KHR_parallel_shader_compile = 0;
int GLAD_GL_KHR_robust_buffer_access_behavior = 0;
int GLAD_GL_KHR_robustness = 0;
int GLAD_GL_KHR_texture_compression_astc_hdr = 0;
int GLAD_GL_KHR_texture_compression_astc_ldr = 0;
int GLAD_GL_KHR_texture_compression_astc_sliced_3d = 0;
int GLAD_GL_MESAX_texture_stack = 0;
int GLAD_GL_MESA_pack_invert = 0;
int GLAD_GL_MESA_resize_buffers = 0;
int GLAD_GL_MESA_shader_integer_functions = 0;
int GLAD_GL_MESA_window_pos = 0;
int GLAD_GL_MESA_ycbcr_texture = 0;
int GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers = 0;
int GLAD_GL_NVX_conditional_render = 0;
int GLAD_GL_NVX_gpu_memory_info = 0;
int GLAD_GL_NVX_linked_gpu_multicast = 0;
int GLAD_GL_NV_alpha_to_coverage_dither_control = 0;
int GLAD_GL_NV_bindless_multi_draw_indirect = 0;
int GLAD_GL_NV_bindless_multi_draw_indirect_count = 0;
int GLAD_GL_NV_bindless_texture = 0;
int GLAD_GL_NV_blend_equation_advanced = 0;
int GLAD_GL_NV_blend_equation_advanced_coherent = 0;
int GLAD_GL_NV_blend_minmax_factor = 0;
int GLAD_GL_NV_blend_square = 0;
int GLAD_GL_NV_clip_space_w_scaling = 0;
int GLAD_GL_NV_command_list = 0;
int GLAD_GL_NV_compute_program5 = 0;
int GLAD_GL_NV_conditional_render = 0;
int GLAD_GL_NV_conservative_raster = 0;
int GLAD_GL_NV_conservative_raster_dilate = 0;
int GLAD_GL_NV_conservative_raster_pre_snap_triangles = 0;
int GLAD_GL_NV_copy_depth_to_color = 0;
int GLAD_GL_NV_copy_image = 0;
int GLAD_GL_NV_deep_texture3D = 0;
int GLAD_GL_NV_depth_buffer_float = 0;
int GLAD_GL_NV_depth_clamp = 0;
int GLAD_GL_NV_draw_texture = 0;
int GLAD_GL_NV_draw_vulkan_image = 0;
int GLAD_GL_NV_evaluators = 0;
int GLAD_GL_NV_explicit_multisample = 0;
int GLAD_GL_NV_fence = 0;
int GLAD_GL_NV_fill_rectangle = 0;
int GLAD_GL_NV_float_buffer = 0;
int GLAD_GL_NV_fog_distance = 0;
int GLAD_GL_NV_fragment_coverage_to_color = 0;
int GLAD_GL_NV_fragment_program = 0;
int GLAD_GL_NV_fragment_program2 = 0;
int GLAD_GL_NV_fragment_program4 = 0;
int GLAD_GL_NV_fragment_program_option = 0;
int GLAD_GL_NV_fragment_shader_interlock = 0;
int GLAD_GL_NV_framebuffer_mixed_samples = 0;
int GLAD_GL_NV_framebuffer_multisample_coverage = 0;
int GLAD_GL_NV_geometry_program4 = 0;
int GLAD_GL_NV_geometry_shader4 = 0;
int GLAD_GL_NV_geometry_shader_passthrough = 0;
int GLAD_GL_NV_gpu_multicast = 0;
int GLAD_GL_NV_gpu_program4 = 0;
int GLAD_GL_NV_gpu_program5 = 0;
int GLAD_GL_NV_gpu_program5_mem_extended = 0;
int GLAD_GL_NV_gpu_shader5 = 0;
int GLAD_GL_NV_half_float = 0;
int GLAD_GL_NV_internalformat_sample_query = 0;
int GLAD_GL_NV_light_max_exponent = 0;
int GLAD_GL_NV_multisample_coverage = 0;
int GLAD_GL_NV_multisample_filter_hint = 0;
int GLAD_GL_NV_occlusion_query = 0;
int GLAD_GL_NV_packed_depth_stencil = 0;
int GLAD_GL_NV_parameter_buffer_object = 0;
int GLAD_GL_NV_parameter_buffer_object2 = 0;
int GLAD_GL_NV_path_rendering = 0;
int GLAD_GL_NV_path_rendering_shared_edge = 0;
int GLAD_GL_NV_pixel_data_range = 0;
int GLAD_GL_NV_point_sprite = 0;
int GLAD_GL_NV_present_video = 0;
int GLAD_GL_NV_primitive_restart = 0;
int GLAD_GL_NV_query_resource = 0;
int GLAD_GL_NV_query_resource_tag = 0;
int GLAD_GL_NV_register_combiners = 0;
int GLAD_GL_NV_register_combiners2 = 0;
int GLAD_GL_NV_robustness_video_memory_purge = 0;
int GLAD_GL_NV_sample_locations = 0;
int GLAD_GL_NV_sample_mask_override_coverage = 0;
int GLAD_GL_NV_shader_atomic_counters = 0;
int GLAD_GL_NV_shader_atomic_float = 0;
int GLAD_GL_NV_shader_atomic_float64 = 0;
int GLAD_GL_NV_shader_atomic_fp16_vector = 0;
int GLAD_GL_NV_shader_atomic_int64 = 0;
int GLAD_GL_NV_shader_buffer_load = 0;
int GLAD_GL_NV_shader_buffer_store = 0;
int GLAD_GL_NV_shader_storage_buffer_object = 0;
int GLAD_GL_NV_shader_thread_group = 0;
int GLAD_GL_NV_shader_thread_shuffle = 0;
int GLAD_GL_NV_stereo_view_rendering = 0;
int GLAD_GL_NV_tessellation_program5 = 0;
int GLAD_GL_NV_texgen_emboss = 0;
int GLAD_GL_NV_texgen_reflection = 0;
int GLAD_GL_NV_texture_barrier = 0;
int GLAD_GL_NV_texture_compression_vtc = 0;
int GLAD_GL_NV_texture_env_combine4 = 0;
int GLAD_GL_NV_texture_expand_normal = 0;
int GLAD_GL_NV_texture_multisample = 0;
int GLAD_GL_NV_texture_rectangle = 0;
int GLAD_GL_NV_texture_rectangle_compressed = 0;
int GLAD_GL_NV_texture_shader = 0;
int GLAD_GL_NV_texture_shader2 = 0;
int GLAD_GL_NV_texture_shader3 = 0;
int GLAD_GL_NV_transform_feedback = 0;
int GLAD_GL_NV_transform_feedback2 = 0;
int GLAD_GL_NV_uniform_buffer_unified_memory = 0;
int GLAD_GL_NV_vdpau_interop = 0;
int GLAD_GL_NV_vertex_array_range = 0;
int GLAD_GL_NV_vertex_array_range2 = 0;
int GLAD_GL_NV_vertex_attrib_integer_64bit = 0;
int GLAD_GL_NV_vertex_buffer_unified_memory = 0;
int GLAD_GL_NV_vertex_program = 0;
int GLAD_GL_NV_vertex_program1_1 = 0;
int GLAD_GL_NV_vertex_program2 = 0;
int GLAD_GL_NV_vertex_program2_option = 0;
int GLAD_GL_NV_vertex_program3 = 0;
int GLAD_GL_NV_vertex_program4 = 0;
int GLAD_GL_NV_video_capture = 0;
int GLAD_GL_NV_viewport_array2 = 0;
int GLAD_GL_NV_viewport_swizzle = 0;



PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC glad_glAcquireKeyedMutexWin32EXT = NULL;
PFNGLACTIVEPROGRAMEXTPROC glad_glActiveProgramEXT = NULL;
PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram = NULL;
PFNGLACTIVESTENCILFACEEXTPROC glad_glActiveStencilFaceEXT = NULL;
PFNGLACTIVETEXTUREPROC glad_glActiveTexture = NULL;
PFNGLACTIVETEXTUREARBPROC glad_glActiveTextureARB = NULL;
PFNGLACTIVEVARYINGNVPROC glad_glActiveVaryingNV = NULL;
PFNGLALPHAFRAGMENTOP1ATIPROC glad_glAlphaFragmentOp1ATI = NULL;
PFNGLALPHAFRAGMENTOP2ATIPROC glad_glAlphaFragmentOp2ATI = NULL;
PFNGLALPHAFRAGMENTOP3ATIPROC glad_glAlphaFragmentOp3ATI = NULL;
PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC glad_glAlphaToCoverageDitherControlNV = NULL;
PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC glad_glApplyFramebufferAttachmentCMAAINTEL = NULL;
PFNGLAPPLYTEXTUREEXTPROC glad_glApplyTextureEXT = NULL;
PFNGLAREPROGRAMSRESIDENTNVPROC glad_glAreProgramsResidentNV = NULL;
PFNGLARETEXTURESRESIDENTEXTPROC glad_glAreTexturesResidentEXT = NULL;
PFNGLARRAYELEMENTPROC glad_glArrayElement = NULL;
PFNGLARRAYELEMENTEXTPROC glad_glArrayElementEXT = NULL;
PFNGLARRAYOBJECTATIPROC glad_glArrayObjectATI = NULL;
PFNGLATTACHOBJECTARBPROC glad_glAttachObjectARB = NULL;
PFNGLATTACHSHADERPROC glad_glAttachShader = NULL;
PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender = NULL;
PFNGLBEGINCONDITIONALRENDERNVPROC glad_glBeginConditionalRenderNV = NULL;
PFNGLBEGINCONDITIONALRENDERNVXPROC glad_glBeginConditionalRenderNVX = NULL;
PFNGLBEGINFRAGMENTSHADERATIPROC glad_glBeginFragmentShaderATI = NULL;
PFNGLBEGINOCCLUSIONQUERYNVPROC glad_glBeginOcclusionQueryNV = NULL;
PFNGLBEGINPERFMONITORAMDPROC glad_glBeginPerfMonitorAMD = NULL;
PFNGLBEGINPERFQUERYINTELPROC glad_glBeginPerfQueryINTEL = NULL;
PFNGLBEGINQUERYPROC glad_glBeginQuery = NULL;
PFNGLBEGINQUERYARBPROC glad_glBeginQueryARB = NULL;
PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed = NULL;
PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback = NULL;
PFNGLBEGINTRANSFORMFEEDBACKEXTPROC glad_glBeginTransformFeedbackEXT = NULL;
PFNGLBEGINTRANSFORMFEEDBACKNVPROC glad_glBeginTransformFeedbackNV = NULL;
PFNGLBEGINVERTEXSHADEREXTPROC glad_glBeginVertexShaderEXT = NULL;
PFNGLBEGINVIDEOCAPTURENVPROC glad_glBeginVideoCaptureNV = NULL;
PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation = NULL;
PFNGLBINDATTRIBLOCATIONARBPROC glad_glBindAttribLocationARB = NULL;
PFNGLBINDBUFFERPROC glad_glBindBuffer = NULL;
PFNGLBINDBUFFERARBPROC glad_glBindBufferARB = NULL;
PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase = NULL;
PFNGLBINDBUFFERBASEEXTPROC glad_glBindBufferBaseEXT = NULL;
PFNGLBINDBUFFERBASENVPROC glad_glBindBufferBaseNV = NULL;
PFNGLBINDBUFFEROFFSETEXTPROC glad_glBindBufferOffsetEXT = NULL;
PFNGLBINDBUFFEROFFSETNVPROC glad_glBindBufferOffsetNV = NULL;
PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange = NULL;
PFNGLBINDBUFFERRANGEEXTPROC glad_glBindBufferRangeEXT = NULL;
PFNGLBINDBUFFERRANGENVPROC glad_glBindBufferRangeNV = NULL;
PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase = NULL;
PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange = NULL;
PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation = NULL;
PFNGLBINDFRAGDATALOCATIONEXTPROC glad_glBindFragDataLocationEXT = NULL;
PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed = NULL;
PFNGLBINDFRAGMENTSHADERATIPROC glad_glBindFragmentShaderATI = NULL;
PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer = NULL;
PFNGLBINDFRAMEBUFFEREXTPROC glad_glBindFramebufferEXT = NULL;
PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture = NULL;
PFNGLBINDIMAGETEXTUREEXTPROC glad_glBindImageTextureEXT = NULL;
PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures = NULL;
PFNGLBINDLIGHTPARAMETEREXTPROC glad_glBindLightParameterEXT = NULL;
PFNGLBINDMATERIALPARAMETEREXTPROC glad_glBindMaterialParameterEXT = NULL;
PFNGLBINDMULTITEXTUREEXTPROC glad_glBindMultiTextureEXT = NULL;
PFNGLBINDPARAMETEREXTPROC glad_glBindParameterEXT = NULL;
PFNGLBINDPROGRAMARBPROC glad_glBindProgramARB = NULL;
PFNGLBINDPROGRAMNVPROC glad_glBindProgramNV = NULL;
PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline = NULL;
PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer = NULL;
PFNGLBINDRENDERBUFFEREXTPROC glad_glBindRenderbufferEXT = NULL;
PFNGLBINDSAMPLERPROC glad_glBindSampler = NULL;
PFNGLBINDSAMPLERSPROC glad_glBindSamplers = NULL;
PFNGLBINDTEXGENPARAMETEREXTPROC glad_glBindTexGenParameterEXT = NULL;
PFNGLBINDTEXTUREPROC glad_glBindTexture = NULL;
PFNGLBINDTEXTUREEXTPROC glad_glBindTextureEXT = NULL;
PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit = NULL;
PFNGLBINDTEXTUREUNITPARAMETEREXTPROC glad_glBindTextureUnitParameterEXT = NULL;
PFNGLBINDTEXTURESPROC glad_glBindTextures = NULL;
PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback = NULL;
PFNGLBINDTRANSFORMFEEDBACKNVPROC glad_glBindTransformFeedbackNV = NULL;
PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray = NULL;
PFNGLBINDVERTEXARRAYAPPLEPROC glad_glBindVertexArrayAPPLE = NULL;
PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer = NULL;
PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers = NULL;
PFNGLBINDVERTEXSHADEREXTPROC glad_glBindVertexShaderEXT = NULL;
PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC glad_glBindVideoCaptureStreamBufferNV = NULL;
PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC glad_glBindVideoCaptureStreamTextureNV = NULL;
PFNGLBINORMAL3BEXTPROC glad_glBinormal3bEXT = NULL;
PFNGLBINORMAL3BVEXTPROC glad_glBinormal3bvEXT = NULL;
PFNGLBINORMAL3DEXTPROC glad_glBinormal3dEXT = NULL;
PFNGLBINORMAL3DVEXTPROC glad_glBinormal3dvEXT = NULL;
PFNGLBINORMAL3FEXTPROC glad_glBinormal3fEXT = NULL;
PFNGLBINORMAL3FVEXTPROC glad_glBinormal3fvEXT = NULL;
PFNGLBINORMAL3IEXTPROC glad_glBinormal3iEXT = NULL;
PFNGLBINORMAL3IVEXTPROC glad_glBinormal3ivEXT = NULL;
PFNGLBINORMAL3SEXTPROC glad_glBinormal3sEXT = NULL;
PFNGLBINORMAL3SVEXTPROC glad_glBinormal3svEXT = NULL;
PFNGLBINORMALPOINTEREXTPROC glad_glBinormalPointerEXT = NULL;
PFNGLBLENDBARRIERPROC glad_glBlendBarrier = NULL;
PFNGLBLENDBARRIERKHRPROC glad_glBlendBarrierKHR = NULL;
PFNGLBLENDBARRIERNVPROC glad_glBlendBarrierNV = NULL;
PFNGLBLENDCOLORPROC glad_glBlendColor = NULL;
PFNGLBLENDCOLOREXTPROC glad_glBlendColorEXT = NULL;
PFNGLBLENDEQUATIONPROC glad_glBlendEquation = NULL;
PFNGLBLENDEQUATIONEXTPROC glad_glBlendEquationEXT = NULL;
PFNGLBLENDEQUATIONINDEXEDAMDPROC glad_glBlendEquationIndexedAMD = NULL;
PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate = NULL;
PFNGLBLENDEQUATIONSEPARATEEXTPROC glad_glBlendEquationSeparateEXT = NULL;
PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC glad_glBlendEquationSeparateIndexedAMD = NULL;
PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei = NULL;
PFNGLBLENDEQUATIONSEPARATEIARBPROC glad_glBlendEquationSeparateiARB = NULL;
PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi = NULL;
PFNGLBLENDEQUATIONIARBPROC glad_glBlendEquationiARB = NULL;
PFNGLBLENDFUNCPROC glad_glBlendFunc = NULL;
PFNGLBLENDFUNCINDEXEDAMDPROC glad_glBlendFuncIndexedAMD = NULL;
PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate = NULL;
PFNGLBLENDFUNCSEPARATEEXTPROC glad_glBlendFuncSeparateEXT = NULL;
PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC glad_glBlendFuncSeparateIndexedAMD = NULL;
PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei = NULL;
PFNGLBLENDFUNCSEPARATEIARBPROC glad_glBlendFuncSeparateiARB = NULL;
PFNGLBLENDFUNCIPROC glad_glBlendFunci = NULL;
PFNGLBLENDFUNCIARBPROC glad_glBlendFunciARB = NULL;
PFNGLBLENDPARAMETERINVPROC glad_glBlendParameteriNV = NULL;
PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer = NULL;
PFNGLBLITFRAMEBUFFEREXTPROC glad_glBlitFramebufferEXT = NULL;
PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer = NULL;
PFNGLBUFFERADDRESSRANGENVPROC glad_glBufferAddressRangeNV = NULL;
PFNGLBUFFERDATAPROC glad_glBufferData = NULL;
PFNGLBUFFERDATAARBPROC glad_glBufferDataARB = NULL;
PFNGLBUFFERPAGECOMMITMENTARBPROC glad_glBufferPageCommitmentARB = NULL;
PFNGLBUFFERPARAMETERIAPPLEPROC glad_glBufferParameteriAPPLE = NULL;
PFNGLBUFFERSTORAGEPROC glad_glBufferStorage = NULL;
PFNGLBUFFERSTORAGEEXTERNALEXTPROC glad_glBufferStorageExternalEXT = NULL;
PFNGLBUFFERSTORAGEMEMEXTPROC glad_glBufferStorageMemEXT = NULL;
PFNGLBUFFERSUBDATAPROC glad_glBufferSubData = NULL;
PFNGLBUFFERSUBDATAARBPROC glad_glBufferSubDataARB = NULL;
PFNGLCALLCOMMANDLISTNVPROC glad_glCallCommandListNV = NULL;
PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus = NULL;
PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC glad_glCheckFramebufferStatusEXT = NULL;
PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus = NULL;
PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC glad_glCheckNamedFramebufferStatusEXT = NULL;
PFNGLCLAMPCOLORPROC glad_glClampColor = NULL;
PFNGLCLAMPCOLORARBPROC glad_glClampColorARB = NULL;
PFNGLCLEARPROC glad_glClear = NULL;
PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData = NULL;
PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData = NULL;
PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi = NULL;
PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv = NULL;
PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv = NULL;
PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv = NULL;
PFNGLCLEARCOLORPROC glad_glClearColor = NULL;
PFNGLCLEARCOLORIIEXTPROC glad_glClearColorIiEXT = NULL;
PFNGLCLEARCOLORIUIEXTPROC glad_glClearColorIuiEXT = NULL;
PFNGLCLEARDEPTHPROC glad_glClearDepth = NULL;
PFNGLCLEARDEPTHDNVPROC glad_glClearDepthdNV = NULL;
PFNGLCLEARDEPTHFPROC glad_glClearDepthf = NULL;
PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData = NULL;
PFNGLCLEARNAMEDBUFFERDATAEXTPROC glad_glClearNamedBufferDataEXT = NULL;
PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData = NULL;
PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC glad_glClearNamedBufferSubDataEXT = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv = NULL;
PFNGLCLEARSTENCILPROC glad_glClearStencil = NULL;
PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage = NULL;
PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage = NULL;
PFNGLCLIENTACTIVETEXTUREPROC glad_glClientActiveTexture = NULL;
PFNGLCLIENTACTIVETEXTUREARBPROC glad_glClientActiveTextureARB = NULL;
PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC glad_glClientActiveVertexStreamATI = NULL;
PFNGLCLIENTATTRIBDEFAULTEXTPROC glad_glClientAttribDefaultEXT = NULL;
PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync = NULL;
PFNGLCLIPCONTROLPROC glad_glClipControl = NULL;
PFNGLCOLOR3HNVPROC glad_glColor3hNV = NULL;
PFNGLCOLOR3HVNVPROC glad_glColor3hvNV = NULL;
PFNGLCOLOR4HNVPROC glad_glColor4hNV = NULL;
PFNGLCOLOR4HVNVPROC glad_glColor4hvNV = NULL;
PFNGLCOLORFORMATNVPROC glad_glColorFormatNV = NULL;
PFNGLCOLORFRAGMENTOP1ATIPROC glad_glColorFragmentOp1ATI = NULL;
PFNGLCOLORFRAGMENTOP2ATIPROC glad_glColorFragmentOp2ATI = NULL;
PFNGLCOLORFRAGMENTOP3ATIPROC glad_glColorFragmentOp3ATI = NULL;
PFNGLCOLORMASKPROC glad_glColorMask = NULL;
PFNGLCOLORMASKINDEXEDEXTPROC glad_glColorMaskIndexedEXT = NULL;
PFNGLCOLORMASKIPROC glad_glColorMaski = NULL;
PFNGLCOLORPOINTEREXTPROC glad_glColorPointerEXT = NULL;
PFNGLCOLORPOINTERVINTELPROC glad_glColorPointervINTEL = NULL;
PFNGLCOLORSUBTABLEPROC glad_glColorSubTable = NULL;
PFNGLCOLORSUBTABLEEXTPROC glad_glColorSubTableEXT = NULL;
PFNGLCOLORTABLEPROC glad_glColorTable = NULL;
PFNGLCOLORTABLEEXTPROC glad_glColorTableEXT = NULL;
PFNGLCOMBINERINPUTNVPROC glad_glCombinerInputNV = NULL;
PFNGLCOMBINEROUTPUTNVPROC glad_glCombinerOutputNV = NULL;
PFNGLCOMBINERPARAMETERFNVPROC glad_glCombinerParameterfNV = NULL;
PFNGLCOMBINERPARAMETERFVNVPROC glad_glCombinerParameterfvNV = NULL;
PFNGLCOMBINERPARAMETERINVPROC glad_glCombinerParameteriNV = NULL;
PFNGLCOMBINERPARAMETERIVNVPROC glad_glCombinerParameterivNV = NULL;
PFNGLCOMBINERSTAGEPARAMETERFVNVPROC glad_glCombinerStageParameterfvNV = NULL;
PFNGLCOMMANDLISTSEGMENTSNVPROC glad_glCommandListSegmentsNV = NULL;
PFNGLCOMPILECOMMANDLISTNVPROC glad_glCompileCommandListNV = NULL;
PFNGLCOMPILESHADERPROC glad_glCompileShader = NULL;
PFNGLCOMPILESHADERARBPROC glad_glCompileShaderARB = NULL;
PFNGLCOMPILESHADERINCLUDEARBPROC glad_glCompileShaderIncludeARB = NULL;
PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC glad_glCompressedMultiTexImage1DEXT = NULL;
PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC glad_glCompressedMultiTexImage2DEXT = NULL;
PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC glad_glCompressedMultiTexImage3DEXT = NULL;
PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC glad_glCompressedMultiTexSubImage1DEXT = NULL;
PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC glad_glCompressedMultiTexSubImage2DEXT = NULL;
PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC glad_glCompressedMultiTexSubImage3DEXT = NULL;
PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D = NULL;
PFNGLCOMPRESSEDTEXIMAGE1DARBPROC glad_glCompressedTexImage1DARB = NULL;
PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D = NULL;
PFNGLCOMPRESSEDTEXIMAGE2DARBPROC glad_glCompressedTexImage2DARB = NULL;
PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D = NULL;
PFNGLCOMPRESSEDTEXIMAGE3DARBPROC glad_glCompressedTexImage3DARB = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC glad_glCompressedTexSubImage1DARB = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC glad_glCompressedTexSubImage2DARB = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC glad_glCompressedTexSubImage3DARB = NULL;
PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC glad_glCompressedTextureImage1DEXT = NULL;
PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC glad_glCompressedTextureImage2DEXT = NULL;
PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC glad_glCompressedTextureImage3DEXT = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC glad_glCompressedTextureSubImage1DEXT = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC glad_glCompressedTextureSubImage2DEXT = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC glad_glCompressedTextureSubImage3DEXT = NULL;
PFNGLCONSERVATIVERASTERPARAMETERFNVPROC glad_glConservativeRasterParameterfNV = NULL;
PFNGLCONSERVATIVERASTERPARAMETERINVPROC glad_glConservativeRasterParameteriNV = NULL;
PFNGLCONVOLUTIONFILTER1DPROC glad_glConvolutionFilter1D = NULL;
PFNGLCONVOLUTIONFILTER1DEXTPROC glad_glConvolutionFilter1DEXT = NULL;
PFNGLCONVOLUTIONFILTER2DPROC glad_glConvolutionFilter2D = NULL;
PFNGLCONVOLUTIONFILTER2DEXTPROC glad_glConvolutionFilter2DEXT = NULL;
PFNGLCONVOLUTIONPARAMETERFPROC glad_glConvolutionParameterf = NULL;
PFNGLCONVOLUTIONPARAMETERFEXTPROC glad_glConvolutionParameterfEXT = NULL;
PFNGLCONVOLUTIONPARAMETERFVPROC glad_glConvolutionParameterfv = NULL;
PFNGLCONVOLUTIONPARAMETERFVEXTPROC glad_glConvolutionParameterfvEXT = NULL;
PFNGLCONVOLUTIONPARAMETERIPROC glad_glConvolutionParameteri = NULL;
PFNGLCONVOLUTIONPARAMETERIEXTPROC glad_glConvolutionParameteriEXT = NULL;
PFNGLCONVOLUTIONPARAMETERIVPROC glad_glConvolutionParameteriv = NULL;
PFNGLCONVOLUTIONPARAMETERIVEXTPROC glad_glConvolutionParameterivEXT = NULL;
PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData = NULL;
PFNGLCOPYCOLORSUBTABLEPROC glad_glCopyColorSubTable = NULL;
PFNGLCOPYCOLORSUBTABLEEXTPROC glad_glCopyColorSubTableEXT = NULL;
PFNGLCOPYCONVOLUTIONFILTER1DPROC glad_glCopyConvolutionFilter1D = NULL;
PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC glad_glCopyConvolutionFilter1DEXT = NULL;
PFNGLCOPYCONVOLUTIONFILTER2DPROC glad_glCopyConvolutionFilter2D = NULL;
PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC glad_glCopyConvolutionFilter2DEXT = NULL;
PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData = NULL;
PFNGLCOPYIMAGESUBDATANVPROC glad_glCopyImageSubDataNV = NULL;
PFNGLCOPYMULTITEXIMAGE1DEXTPROC glad_glCopyMultiTexImage1DEXT = NULL;
PFNGLCOPYMULTITEXIMAGE2DEXTPROC glad_glCopyMultiTexImage2DEXT = NULL;
PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC glad_glCopyMultiTexSubImage1DEXT = NULL;
PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC glad_glCopyMultiTexSubImage2DEXT = NULL;
PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC glad_glCopyMultiTexSubImage3DEXT = NULL;
PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData = NULL;
PFNGLCOPYPATHNVPROC glad_glCopyPathNV = NULL;
PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D = NULL;
PFNGLCOPYTEXIMAGE1DEXTPROC glad_glCopyTexImage1DEXT = NULL;
PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D = NULL;
PFNGLCOPYTEXIMAGE2DEXTPROC glad_glCopyTexImage2DEXT = NULL;
PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D = NULL;
PFNGLCOPYTEXSUBIMAGE1DEXTPROC glad_glCopyTexSubImage1DEXT = NULL;
PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D = NULL;
PFNGLCOPYTEXSUBIMAGE2DEXTPROC glad_glCopyTexSubImage2DEXT = NULL;
PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D = NULL;
PFNGLCOPYTEXSUBIMAGE3DEXTPROC glad_glCopyTexSubImage3DEXT = NULL;
PFNGLCOPYTEXTUREIMAGE1DEXTPROC glad_glCopyTextureImage1DEXT = NULL;
PFNGLCOPYTEXTUREIMAGE2DEXTPROC glad_glCopyTextureImage2DEXT = NULL;
PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D = NULL;
PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC glad_glCopyTextureSubImage1DEXT = NULL;
PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D = NULL;
PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC glad_glCopyTextureSubImage2DEXT = NULL;
PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D = NULL;
PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC glad_glCopyTextureSubImage3DEXT = NULL;
PFNGLCOVERFILLPATHINSTANCEDNVPROC glad_glCoverFillPathInstancedNV = NULL;
PFNGLCOVERFILLPATHNVPROC glad_glCoverFillPathNV = NULL;
PFNGLCOVERSTROKEPATHINSTANCEDNVPROC glad_glCoverStrokePathInstancedNV = NULL;
PFNGLCOVERSTROKEPATHNVPROC glad_glCoverStrokePathNV = NULL;
PFNGLCOVERAGEMODULATIONNVPROC glad_glCoverageModulationNV = NULL;
PFNGLCOVERAGEMODULATIONTABLENVPROC glad_glCoverageModulationTableNV = NULL;
PFNGLCREATEBUFFERSPROC glad_glCreateBuffers = NULL;
PFNGLCREATECOMMANDLISTSNVPROC glad_glCreateCommandListsNV = NULL;
PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers = NULL;
PFNGLCREATEMEMORYOBJECTSEXTPROC glad_glCreateMemoryObjectsEXT = NULL;
PFNGLCREATEPERFQUERYINTELPROC glad_glCreatePerfQueryINTEL = NULL;
PFNGLCREATEPROGRAMPROC glad_glCreateProgram = NULL;
PFNGLCREATEPROGRAMOBJECTARBPROC glad_glCreateProgramObjectARB = NULL;
PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines = NULL;
PFNGLCREATEQUERIESPROC glad_glCreateQueries = NULL;
PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers = NULL;
PFNGLCREATESAMPLERSPROC glad_glCreateSamplers = NULL;
PFNGLCREATESHADERPROC glad_glCreateShader = NULL;
PFNGLCREATESHADEROBJECTARBPROC glad_glCreateShaderObjectARB = NULL;
PFNGLCREATESHADERPROGRAMEXTPROC glad_glCreateShaderProgramEXT = NULL;
PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv = NULL;
PFNGLCREATESTATESNVPROC glad_glCreateStatesNV = NULL;
PFNGLCREATESYNCFROMCLEVENTARBPROC glad_glCreateSyncFromCLeventARB = NULL;
PFNGLCREATETEXTURESPROC glad_glCreateTextures = NULL;
PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks = NULL;
PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays = NULL;
PFNGLCULLFACEPROC glad_glCullFace = NULL;
PFNGLCULLPARAMETERDVEXTPROC glad_glCullParameterdvEXT = NULL;
PFNGLCULLPARAMETERFVEXTPROC glad_glCullParameterfvEXT = NULL;
PFNGLCURRENTPALETTEMATRIXARBPROC glad_glCurrentPaletteMatrixARB = NULL;
PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback = NULL;
PFNGLDEBUGMESSAGECALLBACKAMDPROC glad_glDebugMessageCallbackAMD = NULL;
PFNGLDEBUGMESSAGECALLBACKARBPROC glad_glDebugMessageCallbackARB = NULL;
PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl = NULL;
PFNGLDEBUGMESSAGECONTROLARBPROC glad_glDebugMessageControlARB = NULL;
PFNGLDEBUGMESSAGEENABLEAMDPROC glad_glDebugMessageEnableAMD = NULL;
PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert = NULL;
PFNGLDEBUGMESSAGEINSERTAMDPROC glad_glDebugMessageInsertAMD = NULL;
PFNGLDEBUGMESSAGEINSERTARBPROC glad_glDebugMessageInsertARB = NULL;
PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers = NULL;
PFNGLDELETEBUFFERSARBPROC glad_glDeleteBuffersARB = NULL;
PFNGLDELETECOMMANDLISTSNVPROC glad_glDeleteCommandListsNV = NULL;
PFNGLDELETEFENCESAPPLEPROC glad_glDeleteFencesAPPLE = NULL;
PFNGLDELETEFENCESNVPROC glad_glDeleteFencesNV = NULL;
PFNGLDELETEFRAGMENTSHADERATIPROC glad_glDeleteFragmentShaderATI = NULL;
PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers = NULL;
PFNGLDELETEFRAMEBUFFERSEXTPROC glad_glDeleteFramebuffersEXT = NULL;
PFNGLDELETEMEMORYOBJECTSEXTPROC glad_glDeleteMemoryObjectsEXT = NULL;
PFNGLDELETENAMEDSTRINGARBPROC glad_glDeleteNamedStringARB = NULL;
PFNGLDELETENAMESAMDPROC glad_glDeleteNamesAMD = NULL;
PFNGLDELETEOBJECTARBPROC glad_glDeleteObjectARB = NULL;
PFNGLDELETEOCCLUSIONQUERIESNVPROC glad_glDeleteOcclusionQueriesNV = NULL;
PFNGLDELETEPATHSNVPROC glad_glDeletePathsNV = NULL;
PFNGLDELETEPERFMONITORSAMDPROC glad_glDeletePerfMonitorsAMD = NULL;
PFNGLDELETEPERFQUERYINTELPROC glad_glDeletePerfQueryINTEL = NULL;
PFNGLDELETEPROGRAMPROC glad_glDeleteProgram = NULL;
PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines = NULL;
PFNGLDELETEPROGRAMSARBPROC glad_glDeleteProgramsARB = NULL;
PFNGLDELETEPROGRAMSNVPROC glad_glDeleteProgramsNV = NULL;
PFNGLDELETEQUERIESPROC glad_glDeleteQueries = NULL;
PFNGLDELETEQUERIESARBPROC glad_glDeleteQueriesARB = NULL;
PFNGLDELETEQUERYRESOURCETAGNVPROC glad_glDeleteQueryResourceTagNV = NULL;
PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers = NULL;
PFNGLDELETERENDERBUFFERSEXTPROC glad_glDeleteRenderbuffersEXT = NULL;
PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers = NULL;
PFNGLDELETESEMAPHORESEXTPROC glad_glDeleteSemaphoresEXT = NULL;
PFNGLDELETESHADERPROC glad_glDeleteShader = NULL;
PFNGLDELETESTATESNVPROC glad_glDeleteStatesNV = NULL;
PFNGLDELETESYNCPROC glad_glDeleteSync = NULL;
PFNGLDELETETEXTURESPROC glad_glDeleteTextures = NULL;
PFNGLDELETETEXTURESEXTPROC glad_glDeleteTexturesEXT = NULL;
PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks = NULL;
PFNGLDELETETRANSFORMFEEDBACKSNVPROC glad_glDeleteTransformFeedbacksNV = NULL;
PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays = NULL;
PFNGLDELETEVERTEXARRAYSAPPLEPROC glad_glDeleteVertexArraysAPPLE = NULL;
PFNGLDELETEVERTEXSHADEREXTPROC glad_glDeleteVertexShaderEXT = NULL;
PFNGLDEPTHBOUNDSEXTPROC glad_glDepthBoundsEXT = NULL;
PFNGLDEPTHBOUNDSDNVPROC glad_glDepthBoundsdNV = NULL;
PFNGLDEPTHFUNCPROC glad_glDepthFunc = NULL;
PFNGLDEPTHMASKPROC glad_glDepthMask = NULL;
PFNGLDEPTHRANGEPROC glad_glDepthRange = NULL;
PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv = NULL;
PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed = NULL;
PFNGLDEPTHRANGEDNVPROC glad_glDepthRangedNV = NULL;
PFNGLDEPTHRANGEFPROC glad_glDepthRangef = NULL;
PFNGLDETACHOBJECTARBPROC glad_glDetachObjectARB = NULL;
PFNGLDETACHSHADERPROC glad_glDetachShader = NULL;
PFNGLDISABLEPROC glad_glDisable = NULL;
PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC glad_glDisableClientStateIndexedEXT = NULL;
PFNGLDISABLECLIENTSTATEIEXTPROC glad_glDisableClientStateiEXT = NULL;
PFNGLDISABLEINDEXEDEXTPROC glad_glDisableIndexedEXT = NULL;
PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC glad_glDisableVariantClientStateEXT = NULL;
PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib = NULL;
PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC glad_glDisableVertexArrayAttribEXT = NULL;
PFNGLDISABLEVERTEXARRAYEXTPROC glad_glDisableVertexArrayEXT = NULL;
PFNGLDISABLEVERTEXATTRIBAPPLEPROC glad_glDisableVertexAttribAPPLE = NULL;
PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray = NULL;
PFNGLDISABLEVERTEXATTRIBARRAYARBPROC glad_glDisableVertexAttribArrayARB = NULL;
PFNGLDISABLEIPROC glad_glDisablei = NULL;
PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute = NULL;
PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC glad_glDispatchComputeGroupSizeARB = NULL;
PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect = NULL;
PFNGLDRAWARRAYSPROC glad_glDrawArrays = NULL;
PFNGLDRAWARRAYSEXTPROC glad_glDrawArraysEXT = NULL;
PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect = NULL;
PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced = NULL;
PFNGLDRAWARRAYSINSTANCEDARBPROC glad_glDrawArraysInstancedARB = NULL;
PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance = NULL;
PFNGLDRAWARRAYSINSTANCEDEXTPROC glad_glDrawArraysInstancedEXT = NULL;
PFNGLDRAWBUFFERPROC glad_glDrawBuffer = NULL;
PFNGLDRAWBUFFERSPROC glad_glDrawBuffers = NULL;
PFNGLDRAWBUFFERSARBPROC glad_glDrawBuffersARB = NULL;
PFNGLDRAWBUFFERSATIPROC glad_glDrawBuffersATI = NULL;
PFNGLDRAWCOMMANDSADDRESSNVPROC glad_glDrawCommandsAddressNV = NULL;
PFNGLDRAWCOMMANDSNVPROC glad_glDrawCommandsNV = NULL;
PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC glad_glDrawCommandsStatesAddressNV = NULL;
PFNGLDRAWCOMMANDSSTATESNVPROC glad_glDrawCommandsStatesNV = NULL;
PFNGLDRAWELEMENTARRAYAPPLEPROC glad_glDrawElementArrayAPPLE = NULL;
PFNGLDRAWELEMENTARRAYATIPROC glad_glDrawElementArrayATI = NULL;
PFNGLDRAWELEMENTSPROC glad_glDrawElements = NULL;
PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex = NULL;
PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect = NULL;
PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced = NULL;
PFNGLDRAWELEMENTSINSTANCEDARBPROC glad_glDrawElementsInstancedARB = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance = NULL;
PFNGLDRAWELEMENTSINSTANCEDEXTPROC glad_glDrawElementsInstancedEXT = NULL;
PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC glad_glDrawRangeElementArrayAPPLE = NULL;
PFNGLDRAWRANGEELEMENTARRAYATIPROC glad_glDrawRangeElementArrayATI = NULL;
PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements = NULL;
PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex = NULL;
PFNGLDRAWRANGEELEMENTSEXTPROC glad_glDrawRangeElementsEXT = NULL;
PFNGLDRAWTEXTURENVPROC glad_glDrawTextureNV = NULL;
PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback = NULL;
PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced = NULL;
PFNGLDRAWTRANSFORMFEEDBACKNVPROC glad_glDrawTransformFeedbackNV = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced = NULL;
PFNGLDRAWVKIMAGENVPROC glad_glDrawVkImageNV = NULL;
PFNGLEDGEFLAGFORMATNVPROC glad_glEdgeFlagFormatNV = NULL;
PFNGLEDGEFLAGPOINTEREXTPROC glad_glEdgeFlagPointerEXT = NULL;
PFNGLELEMENTPOINTERAPPLEPROC glad_glElementPointerAPPLE = NULL;
PFNGLELEMENTPOINTERATIPROC glad_glElementPointerATI = NULL;
PFNGLENABLEPROC glad_glEnable = NULL;
PFNGLENABLECLIENTSTATEINDEXEDEXTPROC glad_glEnableClientStateIndexedEXT = NULL;
PFNGLENABLECLIENTSTATEIEXTPROC glad_glEnableClientStateiEXT = NULL;
PFNGLENABLEINDEXEDEXTPROC glad_glEnableIndexedEXT = NULL;
PFNGLENABLEVARIANTCLIENTSTATEEXTPROC glad_glEnableVariantClientStateEXT = NULL;
PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib = NULL;
PFNGLENABLEVERTEXARRAYATTRIBEXTPROC glad_glEnableVertexArrayAttribEXT = NULL;
PFNGLENABLEVERTEXARRAYEXTPROC glad_glEnableVertexArrayEXT = NULL;
PFNGLENABLEVERTEXATTRIBAPPLEPROC glad_glEnableVertexAttribAPPLE = NULL;
PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray = NULL;
PFNGLENABLEVERTEXATTRIBARRAYARBPROC glad_glEnableVertexAttribArrayARB = NULL;
PFNGLENABLEIPROC glad_glEnablei = NULL;
PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender = NULL;
PFNGLENDCONDITIONALRENDERNVPROC glad_glEndConditionalRenderNV = NULL;
PFNGLENDCONDITIONALRENDERNVXPROC glad_glEndConditionalRenderNVX = NULL;
PFNGLENDFRAGMENTSHADERATIPROC glad_glEndFragmentShaderATI = NULL;
PFNGLENDOCCLUSIONQUERYNVPROC glad_glEndOcclusionQueryNV = NULL;
PFNGLENDPERFMONITORAMDPROC glad_glEndPerfMonitorAMD = NULL;
PFNGLENDPERFQUERYINTELPROC glad_glEndPerfQueryINTEL = NULL;
PFNGLENDQUERYPROC glad_glEndQuery = NULL;
PFNGLENDQUERYARBPROC glad_glEndQueryARB = NULL;
PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed = NULL;
PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback = NULL;
PFNGLENDTRANSFORMFEEDBACKEXTPROC glad_glEndTransformFeedbackEXT = NULL;
PFNGLENDTRANSFORMFEEDBACKNVPROC glad_glEndTransformFeedbackNV = NULL;
PFNGLENDVERTEXSHADEREXTPROC glad_glEndVertexShaderEXT = NULL;
PFNGLENDVIDEOCAPTURENVPROC glad_glEndVideoCaptureNV = NULL;
PFNGLEVALMAPSNVPROC glad_glEvalMapsNV = NULL;
PFNGLEVALUATEDEPTHVALUESARBPROC glad_glEvaluateDepthValuesARB = NULL;
PFNGLEXECUTEPROGRAMNVPROC glad_glExecuteProgramNV = NULL;
PFNGLEXTRACTCOMPONENTEXTPROC glad_glExtractComponentEXT = NULL;
PFNGLFENCESYNCPROC glad_glFenceSync = NULL;
PFNGLFINALCOMBINERINPUTNVPROC glad_glFinalCombinerInputNV = NULL;
PFNGLFINISHPROC glad_glFinish = NULL;
PFNGLFINISHFENCEAPPLEPROC glad_glFinishFenceAPPLE = NULL;
PFNGLFINISHFENCENVPROC glad_glFinishFenceNV = NULL;
PFNGLFINISHOBJECTAPPLEPROC glad_glFinishObjectAPPLE = NULL;
PFNGLFLUSHPROC glad_glFlush = NULL;
PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange = NULL;
PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC glad_glFlushMappedBufferRangeAPPLE = NULL;
PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange = NULL;
PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC glad_glFlushMappedNamedBufferRangeEXT = NULL;
PFNGLFLUSHPIXELDATARANGENVPROC glad_glFlushPixelDataRangeNV = NULL;
PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC glad_glFlushVertexArrayRangeAPPLE = NULL;
PFNGLFLUSHVERTEXARRAYRANGENVPROC glad_glFlushVertexArrayRangeNV = NULL;
PFNGLFOGCOORDFORMATNVPROC glad_glFogCoordFormatNV = NULL;
PFNGLFOGCOORDPOINTERPROC glad_glFogCoordPointer = NULL;
PFNGLFOGCOORDPOINTEREXTPROC glad_glFogCoordPointerEXT = NULL;
PFNGLFOGCOORDDPROC glad_glFogCoordd = NULL;
PFNGLFOGCOORDDEXTPROC glad_glFogCoorddEXT = NULL;
PFNGLFOGCOORDDVPROC glad_glFogCoorddv = NULL;
PFNGLFOGCOORDDVEXTPROC glad_glFogCoorddvEXT = NULL;
PFNGLFOGCOORDFPROC glad_glFogCoordf = NULL;
PFNGLFOGCOORDFEXTPROC glad_glFogCoordfEXT = NULL;
PFNGLFOGCOORDFVPROC glad_glFogCoordfv = NULL;
PFNGLFOGCOORDFVEXTPROC glad_glFogCoordfvEXT = NULL;
PFNGLFOGCOORDHNVPROC glad_glFogCoordhNV = NULL;
PFNGLFOGCOORDHVNVPROC glad_glFogCoordhvNV = NULL;
PFNGLFRAGMENTCOVERAGECOLORNVPROC glad_glFragmentCoverageColorNV = NULL;
PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC glad_glFramebufferDrawBufferEXT = NULL;
PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC glad_glFramebufferDrawBuffersEXT = NULL;
PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri = NULL;
PFNGLFRAMEBUFFERREADBUFFEREXTPROC glad_glFramebufferReadBufferEXT = NULL;
PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer = NULL;
PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC glad_glFramebufferRenderbufferEXT = NULL;
PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glad_glFramebufferSampleLocationsfvARB = NULL;
PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glFramebufferSampleLocationsfvNV = NULL;
PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC glad_glFramebufferSamplePositionsfvAMD = NULL;
PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture = NULL;
PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D = NULL;
PFNGLFRAMEBUFFERTEXTURE1DEXTPROC glad_glFramebufferTexture1DEXT = NULL;
PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D = NULL;
PFNGLFRAMEBUFFERTEXTURE2DEXTPROC glad_glFramebufferTexture2DEXT = NULL;
PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D = NULL;
PFNGLFRAMEBUFFERTEXTURE3DEXTPROC glad_glFramebufferTexture3DEXT = NULL;
PFNGLFRAMEBUFFERTEXTUREARBPROC glad_glFramebufferTextureARB = NULL;
PFNGLFRAMEBUFFERTEXTUREEXTPROC glad_glFramebufferTextureEXT = NULL;
PFNGLFRAMEBUFFERTEXTUREFACEARBPROC glad_glFramebufferTextureFaceARB = NULL;
PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC glad_glFramebufferTextureFaceEXT = NULL;
PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer = NULL;
PFNGLFRAMEBUFFERTEXTURELAYERARBPROC glad_glFramebufferTextureLayerARB = NULL;
PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC glad_glFramebufferTextureLayerEXT = NULL;
PFNGLFREEOBJECTBUFFERATIPROC glad_glFreeObjectBufferATI = NULL;
PFNGLFRONTFACEPROC glad_glFrontFace = NULL;
PFNGLGENBUFFERSPROC glad_glGenBuffers = NULL;
PFNGLGENBUFFERSARBPROC glad_glGenBuffersARB = NULL;
PFNGLGENFENCESAPPLEPROC glad_glGenFencesAPPLE = NULL;
PFNGLGENFENCESNVPROC glad_glGenFencesNV = NULL;
PFNGLGENFRAGMENTSHADERSATIPROC glad_glGenFragmentShadersATI = NULL;
PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers = NULL;
PFNGLGENFRAMEBUFFERSEXTPROC glad_glGenFramebuffersEXT = NULL;
PFNGLGENNAMESAMDPROC glad_glGenNamesAMD = NULL;
PFNGLGENOCCLUSIONQUERIESNVPROC glad_glGenOcclusionQueriesNV = NULL;
PFNGLGENPATHSNVPROC glad_glGenPathsNV = NULL;
PFNGLGENPERFMONITORSAMDPROC glad_glGenPerfMonitorsAMD = NULL;
PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines = NULL;
PFNGLGENPROGRAMSARBPROC glad_glGenProgramsARB = NULL;
PFNGLGENPROGRAMSNVPROC glad_glGenProgramsNV = NULL;
PFNGLGENQUERIESPROC glad_glGenQueries = NULL;
PFNGLGENQUERIESARBPROC glad_glGenQueriesARB = NULL;
PFNGLGENQUERYRESOURCETAGNVPROC glad_glGenQueryResourceTagNV = NULL;
PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers = NULL;
PFNGLGENRENDERBUFFERSEXTPROC glad_glGenRenderbuffersEXT = NULL;
PFNGLGENSAMPLERSPROC glad_glGenSamplers = NULL;
PFNGLGENSEMAPHORESEXTPROC glad_glGenSemaphoresEXT = NULL;
PFNGLGENSYMBOLSEXTPROC glad_glGenSymbolsEXT = NULL;
PFNGLGENTEXTURESPROC glad_glGenTextures = NULL;
PFNGLGENTEXTURESEXTPROC glad_glGenTexturesEXT = NULL;
PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks = NULL;
PFNGLGENTRANSFORMFEEDBACKSNVPROC glad_glGenTransformFeedbacksNV = NULL;
PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays = NULL;
PFNGLGENVERTEXARRAYSAPPLEPROC glad_glGenVertexArraysAPPLE = NULL;
PFNGLGENVERTEXSHADERSEXTPROC glad_glGenVertexShadersEXT = NULL;
PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap = NULL;
PFNGLGENERATEMIPMAPEXTPROC glad_glGenerateMipmapEXT = NULL;
PFNGLGENERATEMULTITEXMIPMAPEXTPROC glad_glGenerateMultiTexMipmapEXT = NULL;
PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap = NULL;
PFNGLGENERATETEXTUREMIPMAPEXTPROC glad_glGenerateTextureMipmapEXT = NULL;
PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv = NULL;
PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib = NULL;
PFNGLGETACTIVEATTRIBARBPROC glad_glGetActiveAttribARB = NULL;
PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv = NULL;
PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform = NULL;
PFNGLGETACTIVEUNIFORMARBPROC glad_glGetActiveUniformARB = NULL;
PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName = NULL;
PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv = NULL;
PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName = NULL;
PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv = NULL;
PFNGLGETACTIVEVARYINGNVPROC glad_glGetActiveVaryingNV = NULL;
PFNGLGETARRAYOBJECTFVATIPROC glad_glGetArrayObjectfvATI = NULL;
PFNGLGETARRAYOBJECTIVATIPROC glad_glGetArrayObjectivATI = NULL;
PFNGLGETATTACHEDOBJECTSARBPROC glad_glGetAttachedObjectsARB = NULL;
PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders = NULL;
PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation = NULL;
PFNGLGETATTRIBLOCATIONARBPROC glad_glGetAttribLocationARB = NULL;
PFNGLGETBOOLEANINDEXEDVEXTPROC glad_glGetBooleanIndexedvEXT = NULL;
PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v = NULL;
PFNGLGETBOOLEANVPROC glad_glGetBooleanv = NULL;
PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v = NULL;
PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv = NULL;
PFNGLGETBUFFERPARAMETERIVARBPROC glad_glGetBufferParameterivARB = NULL;
PFNGLGETBUFFERPARAMETERUI64VNVPROC glad_glGetBufferParameterui64vNV = NULL;
PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv = NULL;
PFNGLGETBUFFERPOINTERVARBPROC glad_glGetBufferPointervARB = NULL;
PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData = NULL;
PFNGLGETBUFFERSUBDATAARBPROC glad_glGetBufferSubDataARB = NULL;
PFNGLGETCOLORTABLEPROC glad_glGetColorTable = NULL;
PFNGLGETCOLORTABLEEXTPROC glad_glGetColorTableEXT = NULL;
PFNGLGETCOLORTABLEPARAMETERFVPROC glad_glGetColorTableParameterfv = NULL;
PFNGLGETCOLORTABLEPARAMETERFVEXTPROC glad_glGetColorTableParameterfvEXT = NULL;
PFNGLGETCOLORTABLEPARAMETERIVPROC glad_glGetColorTableParameteriv = NULL;
PFNGLGETCOLORTABLEPARAMETERIVEXTPROC glad_glGetColorTableParameterivEXT = NULL;
PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC glad_glGetCombinerInputParameterfvNV = NULL;
PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC glad_glGetCombinerInputParameterivNV = NULL;
PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC glad_glGetCombinerOutputParameterfvNV = NULL;
PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC glad_glGetCombinerOutputParameterivNV = NULL;
PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC glad_glGetCombinerStageParameterfvNV = NULL;
PFNGLGETCOMMANDHEADERNVPROC glad_glGetCommandHeaderNV = NULL;
PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC glad_glGetCompressedMultiTexImageEXT = NULL;
PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage = NULL;
PFNGLGETCOMPRESSEDTEXIMAGEARBPROC glad_glGetCompressedTexImageARB = NULL;
PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage = NULL;
PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC glad_glGetCompressedTextureImageEXT = NULL;
PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage = NULL;
PFNGLGETCONVOLUTIONFILTEREXTPROC glad_glGetConvolutionFilterEXT = NULL;
PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC glad_glGetConvolutionParameterfvEXT = NULL;
PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC glad_glGetConvolutionParameterivEXT = NULL;
PFNGLGETCOVERAGEMODULATIONTABLENVPROC glad_glGetCoverageModulationTableNV = NULL;
PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog = NULL;
PFNGLGETDEBUGMESSAGELOGAMDPROC glad_glGetDebugMessageLogAMD = NULL;
PFNGLGETDEBUGMESSAGELOGARBPROC glad_glGetDebugMessageLogARB = NULL;
PFNGLGETDOUBLEINDEXEDVEXTPROC glad_glGetDoubleIndexedvEXT = NULL;
PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v = NULL;
PFNGLGETDOUBLEI_VEXTPROC glad_glGetDoublei_vEXT = NULL;
PFNGLGETDOUBLEVPROC glad_glGetDoublev = NULL;
PFNGLGETERRORPROC glad_glGetError = NULL;
PFNGLGETFENCEIVNVPROC glad_glGetFenceivNV = NULL;
PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC glad_glGetFinalCombinerInputParameterfvNV = NULL;
PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC glad_glGetFinalCombinerInputParameterivNV = NULL;
PFNGLGETFIRSTPERFQUERYIDINTELPROC glad_glGetFirstPerfQueryIdINTEL = NULL;
PFNGLGETFLOATINDEXEDVEXTPROC glad_glGetFloatIndexedvEXT = NULL;
PFNGLGETFLOATI_VPROC glad_glGetFloati_v = NULL;
PFNGLGETFLOATI_VEXTPROC glad_glGetFloati_vEXT = NULL;
PFNGLGETFLOATVPROC glad_glGetFloatv = NULL;
PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex = NULL;
PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation = NULL;
PFNGLGETFRAGDATALOCATIONEXTPROC glad_glGetFragDataLocationEXT = NULL;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv = NULL;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC glad_glGetFramebufferAttachmentParameterivEXT = NULL;
PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC glad_glGetFramebufferParameterfvAMD = NULL;
PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv = NULL;
PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC glad_glGetFramebufferParameterivEXT = NULL;
PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus = NULL;
PFNGLGETGRAPHICSRESETSTATUSARBPROC glad_glGetGraphicsResetStatusARB = NULL;
PFNGLGETHANDLEARBPROC glad_glGetHandleARB = NULL;
PFNGLGETHISTOGRAMEXTPROC glad_glGetHistogramEXT = NULL;
PFNGLGETHISTOGRAMPARAMETERFVEXTPROC glad_glGetHistogramParameterfvEXT = NULL;
PFNGLGETHISTOGRAMPARAMETERIVEXTPROC glad_glGetHistogramParameterivEXT = NULL;
PFNGLGETIMAGEHANDLEARBPROC glad_glGetImageHandleARB = NULL;
PFNGLGETIMAGEHANDLENVPROC glad_glGetImageHandleNV = NULL;
PFNGLGETINFOLOGARBPROC glad_glGetInfoLogARB = NULL;
PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v = NULL;
PFNGLGETINTEGER64VPROC glad_glGetInteger64v = NULL;
PFNGLGETINTEGERINDEXEDVEXTPROC glad_glGetIntegerIndexedvEXT = NULL;
PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v = NULL;
PFNGLGETINTEGERUI64I_VNVPROC glad_glGetIntegerui64i_vNV = NULL;
PFNGLGETINTEGERUI64VNVPROC glad_glGetIntegerui64vNV = NULL;
PFNGLGETINTEGERVPROC glad_glGetIntegerv = NULL;
PFNGLGETINTERNALFORMATSAMPLEIVNVPROC glad_glGetInternalformatSampleivNV = NULL;
PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v = NULL;
PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ = NULL;
PFNGLGETINVARIANTBOOLEANVEXTPROC glad_glGetInvariantBooleanvEXT = NULL;
PFNGLGETINVARIANTFLOATVEXTPROC glad_glGetInvariantFloatvEXT = NULL;
PFNGLGETINVARIANTINTEGERVEXTPROC glad_glGetInvariantIntegervEXT = NULL;
PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC glad_glGetLocalConstantBooleanvEXT = NULL;
PFNGLGETLOCALCONSTANTFLOATVEXTPROC glad_glGetLocalConstantFloatvEXT = NULL;
PFNGLGETLOCALCONSTANTINTEGERVEXTPROC glad_glGetLocalConstantIntegervEXT = NULL;
PFNGLGETMAPATTRIBPARAMETERFVNVPROC glad_glGetMapAttribParameterfvNV = NULL;
PFNGLGETMAPATTRIBPARAMETERIVNVPROC glad_glGetMapAttribParameterivNV = NULL;
PFNGLGETMAPCONTROLPOINTSNVPROC glad_glGetMapControlPointsNV = NULL;
PFNGLGETMAPPARAMETERFVNVPROC glad_glGetMapParameterfvNV = NULL;
PFNGLGETMAPPARAMETERIVNVPROC glad_glGetMapParameterivNV = NULL;
PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC glad_glGetMemoryObjectParameterivEXT = NULL;
PFNGLGETMINMAXEXTPROC glad_glGetMinmaxEXT = NULL;
PFNGLGETMINMAXPARAMETERFVEXTPROC glad_glGetMinmaxParameterfvEXT = NULL;
PFNGLGETMINMAXPARAMETERIVEXTPROC glad_glGetMinmaxParameterivEXT = NULL;
PFNGLGETMULTITEXENVFVEXTPROC glad_glGetMultiTexEnvfvEXT = NULL;
PFNGLGETMULTITEXENVIVEXTPROC glad_glGetMultiTexEnvivEXT = NULL;
PFNGLGETMULTITEXGENDVEXTPROC glad_glGetMultiTexGendvEXT = NULL;
PFNGLGETMULTITEXGENFVEXTPROC glad_glGetMultiTexGenfvEXT = NULL;
PFNGLGETMULTITEXGENIVEXTPROC glad_glGetMultiTexGenivEXT = NULL;
PFNGLGETMULTITEXIMAGEEXTPROC glad_glGetMultiTexImageEXT = NULL;
PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC glad_glGetMultiTexLevelParameterfvEXT = NULL;
PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC glad_glGetMultiTexLevelParameterivEXT = NULL;
PFNGLGETMULTITEXPARAMETERIIVEXTPROC glad_glGetMultiTexParameterIivEXT = NULL;
PFNGLGETMULTITEXPARAMETERIUIVEXTPROC glad_glGetMultiTexParameterIuivEXT = NULL;
PFNGLGETMULTITEXPARAMETERFVEXTPROC glad_glGetMultiTexParameterfvEXT = NULL;
PFNGLGETMULTITEXPARAMETERIVEXTPROC glad_glGetMultiTexParameterivEXT = NULL;
PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv = NULL;
PFNGLGETMULTISAMPLEFVNVPROC glad_glGetMultisamplefvNV = NULL;
PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v = NULL;
PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv = NULL;
PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC glad_glGetNamedBufferParameterivEXT = NULL;
PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC glad_glGetNamedBufferParameterui64vNV = NULL;
PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv = NULL;
PFNGLGETNAMEDBUFFERPOINTERVEXTPROC glad_glGetNamedBufferPointervEXT = NULL;
PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData = NULL;
PFNGLGETNAMEDBUFFERSUBDATAEXTPROC glad_glGetNamedBufferSubDataEXT = NULL;
PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv = NULL;
PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC glad_glGetNamedFramebufferAttachmentParameterivEXT = NULL;
PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC glad_glGetNamedFramebufferParameterfvAMD = NULL;
PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv = NULL;
PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC glad_glGetNamedFramebufferParameterivEXT = NULL;
PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC glad_glGetNamedProgramLocalParameterIivEXT = NULL;
PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC glad_glGetNamedProgramLocalParameterIuivEXT = NULL;
PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC glad_glGetNamedProgramLocalParameterdvEXT = NULL;
PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC glad_glGetNamedProgramLocalParameterfvEXT = NULL;
PFNGLGETNAMEDPROGRAMSTRINGEXTPROC glad_glGetNamedProgramStringEXT = NULL;
PFNGLGETNAMEDPROGRAMIVEXTPROC glad_glGetNamedProgramivEXT = NULL;
PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv = NULL;
PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC glad_glGetNamedRenderbufferParameterivEXT = NULL;
PFNGLGETNAMEDSTRINGARBPROC glad_glGetNamedStringARB = NULL;
PFNGLGETNAMEDSTRINGIVARBPROC glad_glGetNamedStringivARB = NULL;
PFNGLGETNEXTPERFQUERYIDINTELPROC glad_glGetNextPerfQueryIdINTEL = NULL;
PFNGLGETOBJECTBUFFERFVATIPROC glad_glGetObjectBufferfvATI = NULL;
PFNGLGETOBJECTBUFFERIVATIPROC glad_glGetObjectBufferivATI = NULL;
PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel = NULL;
PFNGLGETOBJECTLABELEXTPROC glad_glGetObjectLabelEXT = NULL;
PFNGLGETOBJECTPARAMETERFVARBPROC glad_glGetObjectParameterfvARB = NULL;
PFNGLGETOBJECTPARAMETERIVAPPLEPROC glad_glGetObjectParameterivAPPLE = NULL;
PFNGLGETOBJECTPARAMETERIVARBPROC glad_glGetObjectParameterivARB = NULL;
PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel = NULL;
PFNGLGETOCCLUSIONQUERYIVNVPROC glad_glGetOcclusionQueryivNV = NULL;
PFNGLGETOCCLUSIONQUERYUIVNVPROC glad_glGetOcclusionQueryuivNV = NULL;
PFNGLGETPATHCOMMANDSNVPROC glad_glGetPathCommandsNV = NULL;
PFNGLGETPATHCOORDSNVPROC glad_glGetPathCoordsNV = NULL;
PFNGLGETPATHDASHARRAYNVPROC glad_glGetPathDashArrayNV = NULL;
PFNGLGETPATHLENGTHNVPROC glad_glGetPathLengthNV = NULL;
PFNGLGETPATHMETRICRANGENVPROC glad_glGetPathMetricRangeNV = NULL;
PFNGLGETPATHMETRICSNVPROC glad_glGetPathMetricsNV = NULL;
PFNGLGETPATHPARAMETERFVNVPROC glad_glGetPathParameterfvNV = NULL;
PFNGLGETPATHPARAMETERIVNVPROC glad_glGetPathParameterivNV = NULL;
PFNGLGETPATHSPACINGNVPROC glad_glGetPathSpacingNV = NULL;
PFNGLGETPERFCOUNTERINFOINTELPROC glad_glGetPerfCounterInfoINTEL = NULL;
PFNGLGETPERFMONITORCOUNTERDATAAMDPROC glad_glGetPerfMonitorCounterDataAMD = NULL;
PFNGLGETPERFMONITORCOUNTERINFOAMDPROC glad_glGetPerfMonitorCounterInfoAMD = NULL;
PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC glad_glGetPerfMonitorCounterStringAMD = NULL;
PFNGLGETPERFMONITORCOUNTERSAMDPROC glad_glGetPerfMonitorCountersAMD = NULL;
PFNGLGETPERFMONITORGROUPSTRINGAMDPROC glad_glGetPerfMonitorGroupStringAMD = NULL;
PFNGLGETPERFMONITORGROUPSAMDPROC glad_glGetPerfMonitorGroupsAMD = NULL;
PFNGLGETPERFQUERYDATAINTELPROC glad_glGetPerfQueryDataINTEL = NULL;
PFNGLGETPERFQUERYIDBYNAMEINTELPROC glad_glGetPerfQueryIdByNameINTEL = NULL;
PFNGLGETPERFQUERYINFOINTELPROC glad_glGetPerfQueryInfoINTEL = NULL;
PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC glad_glGetPixelTransformParameterfvEXT = NULL;
PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC glad_glGetPixelTransformParameterivEXT = NULL;
PFNGLGETPOINTERINDEXEDVEXTPROC glad_glGetPointerIndexedvEXT = NULL;
PFNGLGETPOINTERI_VEXTPROC glad_glGetPointeri_vEXT = NULL;
PFNGLGETPOINTERVPROC glad_glGetPointerv = NULL;
PFNGLGETPOINTERVEXTPROC glad_glGetPointervEXT = NULL;
PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary = NULL;
PFNGLGETPROGRAMENVPARAMETERIIVNVPROC glad_glGetProgramEnvParameterIivNV = NULL;
PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC glad_glGetProgramEnvParameterIuivNV = NULL;
PFNGLGETPROGRAMENVPARAMETERDVARBPROC glad_glGetProgramEnvParameterdvARB = NULL;
PFNGLGETPROGRAMENVPARAMETERFVARBPROC glad_glGetProgramEnvParameterfvARB = NULL;
PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog = NULL;
PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv = NULL;
PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC glad_glGetProgramLocalParameterIivNV = NULL;
PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC glad_glGetProgramLocalParameterIuivNV = NULL;
PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC glad_glGetProgramLocalParameterdvARB = NULL;
PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC glad_glGetProgramLocalParameterfvARB = NULL;
PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC glad_glGetProgramNamedParameterdvNV = NULL;
PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC glad_glGetProgramNamedParameterfvNV = NULL;
PFNGLGETPROGRAMPARAMETERDVNVPROC glad_glGetProgramParameterdvNV = NULL;
PFNGLGETPROGRAMPARAMETERFVNVPROC glad_glGetProgramParameterfvNV = NULL;
PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog = NULL;
PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv = NULL;
PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex = NULL;
PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName = NULL;
PFNGLGETPROGRAMRESOURCEFVNVPROC glad_glGetProgramResourcefvNV = NULL;
PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv = NULL;
PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv = NULL;
PFNGLGETPROGRAMSTRINGARBPROC glad_glGetProgramStringARB = NULL;
PFNGLGETPROGRAMSTRINGNVPROC glad_glGetProgramStringNV = NULL;
PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC glad_glGetProgramSubroutineParameteruivNV = NULL;
PFNGLGETPROGRAMIVPROC glad_glGetProgramiv = NULL;
PFNGLGETPROGRAMIVARBPROC glad_glGetProgramivARB = NULL;
PFNGLGETPROGRAMIVNVPROC glad_glGetProgramivNV = NULL;
PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v = NULL;
PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv = NULL;
PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v = NULL;
PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv = NULL;
PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv = NULL;
PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v = NULL;
PFNGLGETQUERYOBJECTI64VEXTPROC glad_glGetQueryObjecti64vEXT = NULL;
PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv = NULL;
PFNGLGETQUERYOBJECTIVARBPROC glad_glGetQueryObjectivARB = NULL;
PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v = NULL;
PFNGLGETQUERYOBJECTUI64VEXTPROC glad_glGetQueryObjectui64vEXT = NULL;
PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv = NULL;
PFNGLGETQUERYOBJECTUIVARBPROC glad_glGetQueryObjectuivARB = NULL;
PFNGLGETQUERYIVPROC glad_glGetQueryiv = NULL;
PFNGLGETQUERYIVARBPROC glad_glGetQueryivARB = NULL;
PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv = NULL;
PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC glad_glGetRenderbufferParameterivEXT = NULL;
PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv = NULL;
PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv = NULL;
PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv = NULL;
PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv = NULL;
PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC glad_glGetSemaphoreParameterui64vEXT = NULL;
PFNGLGETSEPARABLEFILTEREXTPROC glad_glGetSeparableFilterEXT = NULL;
PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog = NULL;
PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat = NULL;
PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource = NULL;
PFNGLGETSHADERSOURCEARBPROC glad_glGetShaderSourceARB = NULL;
PFNGLGETSHADERIVPROC glad_glGetShaderiv = NULL;
PFNGLGETSTAGEINDEXNVPROC glad_glGetStageIndexNV = NULL;
PFNGLGETSTRINGPROC glad_glGetString = NULL;
PFNGLGETSTRINGIPROC glad_glGetStringi = NULL;
PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex = NULL;
PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation = NULL;
PFNGLGETSYNCIVPROC glad_glGetSynciv = NULL;
PFNGLGETTEXBUMPPARAMETERFVATIPROC glad_glGetTexBumpParameterfvATI = NULL;
PFNGLGETTEXBUMPPARAMETERIVATIPROC glad_glGetTexBumpParameterivATI = NULL;
PFNGLGETTEXIMAGEPROC glad_glGetTexImage = NULL;
PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv = NULL;
PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv = NULL;
PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv = NULL;
PFNGLGETTEXPARAMETERIIVEXTPROC glad_glGetTexParameterIivEXT = NULL;
PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv = NULL;
PFNGLGETTEXPARAMETERIUIVEXTPROC glad_glGetTexParameterIuivEXT = NULL;
PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC glad_glGetTexParameterPointervAPPLE = NULL;
PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv = NULL;
PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv = NULL;
PFNGLGETTEXTUREHANDLEARBPROC glad_glGetTextureHandleARB = NULL;
PFNGLGETTEXTUREHANDLENVPROC glad_glGetTextureHandleNV = NULL;
PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage = NULL;
PFNGLGETTEXTUREIMAGEEXTPROC glad_glGetTextureImageEXT = NULL;
PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv = NULL;
PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC glad_glGetTextureLevelParameterfvEXT = NULL;
PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv = NULL;
PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC glad_glGetTextureLevelParameterivEXT = NULL;
PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv = NULL;
PFNGLGETTEXTUREPARAMETERIIVEXTPROC glad_glGetTextureParameterIivEXT = NULL;
PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv = NULL;
PFNGLGETTEXTUREPARAMETERIUIVEXTPROC glad_glGetTextureParameterIuivEXT = NULL;
PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv = NULL;
PFNGLGETTEXTUREPARAMETERFVEXTPROC glad_glGetTextureParameterfvEXT = NULL;
PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv = NULL;
PFNGLGETTEXTUREPARAMETERIVEXTPROC glad_glGetTextureParameterivEXT = NULL;
PFNGLGETTEXTURESAMPLERHANDLEARBPROC glad_glGetTextureSamplerHandleARB = NULL;
PFNGLGETTEXTURESAMPLERHANDLENVPROC glad_glGetTextureSamplerHandleNV = NULL;
PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage = NULL;
PFNGLGETTRACKMATRIXIVNVPROC glad_glGetTrackMatrixivNV = NULL;
PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying = NULL;
PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC glad_glGetTransformFeedbackVaryingEXT = NULL;
PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC glad_glGetTransformFeedbackVaryingNV = NULL;
PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v = NULL;
PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v = NULL;
PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv = NULL;
PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex = NULL;
PFNGLGETUNIFORMBUFFERSIZEEXTPROC glad_glGetUniformBufferSizeEXT = NULL;
PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices = NULL;
PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation = NULL;
PFNGLGETUNIFORMLOCATIONARBPROC glad_glGetUniformLocationARB = NULL;
PFNGLGETUNIFORMOFFSETEXTPROC glad_glGetUniformOffsetEXT = NULL;
PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv = NULL;
PFNGLGETUNIFORMDVPROC glad_glGetUniformdv = NULL;
PFNGLGETUNIFORMFVPROC glad_glGetUniformfv = NULL;
PFNGLGETUNIFORMFVARBPROC glad_glGetUniformfvARB = NULL;
PFNGLGETUNIFORMI64VARBPROC glad_glGetUniformi64vARB = NULL;
PFNGLGETUNIFORMI64VNVPROC glad_glGetUniformi64vNV = NULL;
PFNGLGETUNIFORMIVPROC glad_glGetUniformiv = NULL;
PFNGLGETUNIFORMIVARBPROC glad_glGetUniformivARB = NULL;
PFNGLGETUNIFORMUI64VARBPROC glad_glGetUniformui64vARB = NULL;
PFNGLGETUNIFORMUI64VNVPROC glad_glGetUniformui64vNV = NULL;
PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv = NULL;
PFNGLGETUNIFORMUIVEXTPROC glad_glGetUniformuivEXT = NULL;
PFNGLGETUNSIGNEDBYTEI_VEXTPROC glad_glGetUnsignedBytei_vEXT = NULL;
PFNGLGETUNSIGNEDBYTEVEXTPROC glad_glGetUnsignedBytevEXT = NULL;
PFNGLGETVARIANTARRAYOBJECTFVATIPROC glad_glGetVariantArrayObjectfvATI = NULL;
PFNGLGETVARIANTARRAYOBJECTIVATIPROC glad_glGetVariantArrayObjectivATI = NULL;
PFNGLGETVARIANTBOOLEANVEXTPROC glad_glGetVariantBooleanvEXT = NULL;
PFNGLGETVARIANTFLOATVEXTPROC glad_glGetVariantFloatvEXT = NULL;
PFNGLGETVARIANTINTEGERVEXTPROC glad_glGetVariantIntegervEXT = NULL;
PFNGLGETVARIANTPOINTERVEXTPROC glad_glGetVariantPointervEXT = NULL;
PFNGLGETVARYINGLOCATIONNVPROC glad_glGetVaryingLocationNV = NULL;
PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv = NULL;
PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv = NULL;
PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC glad_glGetVertexArrayIntegeri_vEXT = NULL;
PFNGLGETVERTEXARRAYINTEGERVEXTPROC glad_glGetVertexArrayIntegervEXT = NULL;
PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC glad_glGetVertexArrayPointeri_vEXT = NULL;
PFNGLGETVERTEXARRAYPOINTERVEXTPROC glad_glGetVertexArrayPointervEXT = NULL;
PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv = NULL;
PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC glad_glGetVertexAttribArrayObjectfvATI = NULL;
PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC glad_glGetVertexAttribArrayObjectivATI = NULL;
PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv = NULL;
PFNGLGETVERTEXATTRIBIIVEXTPROC glad_glGetVertexAttribIivEXT = NULL;
PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv = NULL;
PFNGLGETVERTEXATTRIBIUIVEXTPROC glad_glGetVertexAttribIuivEXT = NULL;
PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv = NULL;
PFNGLGETVERTEXATTRIBLDVEXTPROC glad_glGetVertexAttribLdvEXT = NULL;
PFNGLGETVERTEXATTRIBLI64VNVPROC glad_glGetVertexAttribLi64vNV = NULL;
PFNGLGETVERTEXATTRIBLUI64VARBPROC glad_glGetVertexAttribLui64vARB = NULL;
PFNGLGETVERTEXATTRIBLUI64VNVPROC glad_glGetVertexAttribLui64vNV = NULL;
PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv = NULL;
PFNGLGETVERTEXATTRIBPOINTERVARBPROC glad_glGetVertexAttribPointervARB = NULL;
PFNGLGETVERTEXATTRIBPOINTERVNVPROC glad_glGetVertexAttribPointervNV = NULL;
PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv = NULL;
PFNGLGETVERTEXATTRIBDVARBPROC glad_glGetVertexAttribdvARB = NULL;
PFNGLGETVERTEXATTRIBDVNVPROC glad_glGetVertexAttribdvNV = NULL;
PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv = NULL;
PFNGLGETVERTEXATTRIBFVARBPROC glad_glGetVertexAttribfvARB = NULL;
PFNGLGETVERTEXATTRIBFVNVPROC glad_glGetVertexAttribfvNV = NULL;
PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv = NULL;
PFNGLGETVERTEXATTRIBIVARBPROC glad_glGetVertexAttribivARB = NULL;
PFNGLGETVERTEXATTRIBIVNVPROC glad_glGetVertexAttribivNV = NULL;
PFNGLGETVIDEOCAPTURESTREAMDVNVPROC glad_glGetVideoCaptureStreamdvNV = NULL;
PFNGLGETVIDEOCAPTURESTREAMFVNVPROC glad_glGetVideoCaptureStreamfvNV = NULL;
PFNGLGETVIDEOCAPTURESTREAMIVNVPROC glad_glGetVideoCaptureStreamivNV = NULL;
PFNGLGETVIDEOCAPTUREIVNVPROC glad_glGetVideoCaptureivNV = NULL;
PFNGLGETVIDEOI64VNVPROC glad_glGetVideoi64vNV = NULL;
PFNGLGETVIDEOIVNVPROC glad_glGetVideoivNV = NULL;
PFNGLGETVIDEOUI64VNVPROC glad_glGetVideoui64vNV = NULL;
PFNGLGETVIDEOUIVNVPROC glad_glGetVideouivNV = NULL;
PFNGLGETVKPROCADDRNVPROC glad_glGetVkProcAddrNV = NULL;
PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage = NULL;
PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC glad_glGetnCompressedTexImageARB = NULL;
PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage = NULL;
PFNGLGETNTEXIMAGEARBPROC glad_glGetnTexImageARB = NULL;
PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv = NULL;
PFNGLGETNUNIFORMDVARBPROC glad_glGetnUniformdvARB = NULL;
PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv = NULL;
PFNGLGETNUNIFORMFVARBPROC glad_glGetnUniformfvARB = NULL;
PFNGLGETNUNIFORMI64VARBPROC glad_glGetnUniformi64vARB = NULL;
PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv = NULL;
PFNGLGETNUNIFORMIVARBPROC glad_glGetnUniformivARB = NULL;
PFNGLGETNUNIFORMUI64VARBPROC glad_glGetnUniformui64vARB = NULL;
PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv = NULL;
PFNGLGETNUNIFORMUIVARBPROC glad_glGetnUniformuivARB = NULL;
PFNGLHINTPROC glad_glHint = NULL;
PFNGLHISTOGRAMPROC glad_glHistogram = NULL;
PFNGLHISTOGRAMEXTPROC glad_glHistogramEXT = NULL;
PFNGLIMPORTMEMORYFDEXTPROC glad_glImportMemoryFdEXT = NULL;
PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC glad_glImportMemoryWin32HandleEXT = NULL;
PFNGLIMPORTMEMORYWIN32NAMEEXTPROC glad_glImportMemoryWin32NameEXT = NULL;
PFNGLIMPORTSEMAPHOREFDEXTPROC glad_glImportSemaphoreFdEXT = NULL;
PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC glad_glImportSemaphoreWin32HandleEXT = NULL;
PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC glad_glImportSemaphoreWin32NameEXT = NULL;
PFNGLIMPORTSYNCEXTPROC glad_glImportSyncEXT = NULL;
PFNGLINDEXFORMATNVPROC glad_glIndexFormatNV = NULL;
PFNGLINDEXFUNCEXTPROC glad_glIndexFuncEXT = NULL;
PFNGLINDEXMATERIALEXTPROC glad_glIndexMaterialEXT = NULL;
PFNGLINDEXPOINTEREXTPROC glad_glIndexPointerEXT = NULL;
PFNGLINSERTCOMPONENTEXTPROC glad_glInsertComponentEXT = NULL;
PFNGLINSERTEVENTMARKEREXTPROC glad_glInsertEventMarkerEXT = NULL;
PFNGLINTERPOLATEPATHSNVPROC glad_glInterpolatePathsNV = NULL;
PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData = NULL;
PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData = NULL;
PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData = NULL;
PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer = NULL;
PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage = NULL;
PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage = NULL;
PFNGLISBUFFERPROC glad_glIsBuffer = NULL;
PFNGLISBUFFERARBPROC glad_glIsBufferARB = NULL;
PFNGLISBUFFERRESIDENTNVPROC glad_glIsBufferResidentNV = NULL;
PFNGLISCOMMANDLISTNVPROC glad_glIsCommandListNV = NULL;
PFNGLISENABLEDPROC glad_glIsEnabled = NULL;
PFNGLISENABLEDINDEXEDEXTPROC glad_glIsEnabledIndexedEXT = NULL;
PFNGLISENABLEDIPROC glad_glIsEnabledi = NULL;
PFNGLISFENCEAPPLEPROC glad_glIsFenceAPPLE = NULL;
PFNGLISFENCENVPROC glad_glIsFenceNV = NULL;
PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer = NULL;
PFNGLISFRAMEBUFFEREXTPROC glad_glIsFramebufferEXT = NULL;
PFNGLISIMAGEHANDLERESIDENTARBPROC glad_glIsImageHandleResidentARB = NULL;
PFNGLISIMAGEHANDLERESIDENTNVPROC glad_glIsImageHandleResidentNV = NULL;
PFNGLISMEMORYOBJECTEXTPROC glad_glIsMemoryObjectEXT = NULL;
PFNGLISNAMEAMDPROC glad_glIsNameAMD = NULL;
PFNGLISNAMEDBUFFERRESIDENTNVPROC glad_glIsNamedBufferResidentNV = NULL;
PFNGLISNAMEDSTRINGARBPROC glad_glIsNamedStringARB = NULL;
PFNGLISOBJECTBUFFERATIPROC glad_glIsObjectBufferATI = NULL;
PFNGLISOCCLUSIONQUERYNVPROC glad_glIsOcclusionQueryNV = NULL;
PFNGLISPATHNVPROC glad_glIsPathNV = NULL;
PFNGLISPOINTINFILLPATHNVPROC glad_glIsPointInFillPathNV = NULL;
PFNGLISPOINTINSTROKEPATHNVPROC glad_glIsPointInStrokePathNV = NULL;
PFNGLISPROGRAMPROC glad_glIsProgram = NULL;
PFNGLISPROGRAMARBPROC glad_glIsProgramARB = NULL;
PFNGLISPROGRAMNVPROC glad_glIsProgramNV = NULL;
PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline = NULL;
PFNGLISQUERYPROC glad_glIsQuery = NULL;
PFNGLISQUERYARBPROC glad_glIsQueryARB = NULL;
PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer = NULL;
PFNGLISRENDERBUFFEREXTPROC glad_glIsRenderbufferEXT = NULL;
PFNGLISSAMPLERPROC glad_glIsSampler = NULL;
PFNGLISSEMAPHOREEXTPROC glad_glIsSemaphoreEXT = NULL;
PFNGLISSHADERPROC glad_glIsShader = NULL;
PFNGLISSTATENVPROC glad_glIsStateNV = NULL;
PFNGLISSYNCPROC glad_glIsSync = NULL;
PFNGLISTEXTUREPROC glad_glIsTexture = NULL;
PFNGLISTEXTUREEXTPROC glad_glIsTextureEXT = NULL;
PFNGLISTEXTUREHANDLERESIDENTARBPROC glad_glIsTextureHandleResidentARB = NULL;
PFNGLISTEXTUREHANDLERESIDENTNVPROC glad_glIsTextureHandleResidentNV = NULL;
PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback = NULL;
PFNGLISTRANSFORMFEEDBACKNVPROC glad_glIsTransformFeedbackNV = NULL;
PFNGLISVARIANTENABLEDEXTPROC glad_glIsVariantEnabledEXT = NULL;
PFNGLISVERTEXARRAYPROC glad_glIsVertexArray = NULL;
PFNGLISVERTEXARRAYAPPLEPROC glad_glIsVertexArrayAPPLE = NULL;
PFNGLISVERTEXATTRIBENABLEDAPPLEPROC glad_glIsVertexAttribEnabledAPPLE = NULL;
PFNGLLGPUCOPYIMAGESUBDATANVXPROC glad_glLGPUCopyImageSubDataNVX = NULL;
PFNGLLGPUINTERLOCKNVXPROC glad_glLGPUInterlockNVX = NULL;
PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC glad_glLGPUNamedBufferSubDataNVX = NULL;
PFNGLLABELOBJECTEXTPROC glad_glLabelObjectEXT = NULL;
PFNGLLINEWIDTHPROC glad_glLineWidth = NULL;
PFNGLLINKPROGRAMPROC glad_glLinkProgram = NULL;
PFNGLLINKPROGRAMARBPROC glad_glLinkProgramARB = NULL;
PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC glad_glListDrawCommandsStatesClientNV = NULL;
PFNGLLOADPROGRAMNVPROC glad_glLoadProgramNV = NULL;
PFNGLLOADTRANSPOSEMATRIXDPROC glad_glLoadTransposeMatrixd = NULL;
PFNGLLOADTRANSPOSEMATRIXDARBPROC glad_glLoadTransposeMatrixdARB = NULL;
PFNGLLOADTRANSPOSEMATRIXFPROC glad_glLoadTransposeMatrixf = NULL;
PFNGLLOADTRANSPOSEMATRIXFARBPROC glad_glLoadTransposeMatrixfARB = NULL;
PFNGLLOCKARRAYSEXTPROC glad_glLockArraysEXT = NULL;
PFNGLLOGICOPPROC glad_glLogicOp = NULL;
PFNGLMAKEBUFFERNONRESIDENTNVPROC glad_glMakeBufferNonResidentNV = NULL;
PFNGLMAKEBUFFERRESIDENTNVPROC glad_glMakeBufferResidentNV = NULL;
PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC glad_glMakeImageHandleNonResidentARB = NULL;
PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC glad_glMakeImageHandleNonResidentNV = NULL;
PFNGLMAKEIMAGEHANDLERESIDENTARBPROC glad_glMakeImageHandleResidentARB = NULL;
PFNGLMAKEIMAGEHANDLERESIDENTNVPROC glad_glMakeImageHandleResidentNV = NULL;
PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC glad_glMakeNamedBufferNonResidentNV = NULL;
PFNGLMAKENAMEDBUFFERRESIDENTNVPROC glad_glMakeNamedBufferResidentNV = NULL;
PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC glad_glMakeTextureHandleNonResidentARB = NULL;
PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC glad_glMakeTextureHandleNonResidentNV = NULL;
PFNGLMAKETEXTUREHANDLERESIDENTARBPROC glad_glMakeTextureHandleResidentARB = NULL;
PFNGLMAKETEXTUREHANDLERESIDENTNVPROC glad_glMakeTextureHandleResidentNV = NULL;
PFNGLMAPBUFFERPROC glad_glMapBuffer = NULL;
PFNGLMAPBUFFERARBPROC glad_glMapBufferARB = NULL;
PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange = NULL;
PFNGLMAPCONTROLPOINTSNVPROC glad_glMapControlPointsNV = NULL;
PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer = NULL;
PFNGLMAPNAMEDBUFFEREXTPROC glad_glMapNamedBufferEXT = NULL;
PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange = NULL;
PFNGLMAPNAMEDBUFFERRANGEEXTPROC glad_glMapNamedBufferRangeEXT = NULL;
PFNGLMAPOBJECTBUFFERATIPROC glad_glMapObjectBufferATI = NULL;
PFNGLMAPPARAMETERFVNVPROC glad_glMapParameterfvNV = NULL;
PFNGLMAPPARAMETERIVNVPROC glad_glMapParameterivNV = NULL;
PFNGLMAPTEXTURE2DINTELPROC glad_glMapTexture2DINTEL = NULL;
PFNGLMAPVERTEXATTRIB1DAPPLEPROC glad_glMapVertexAttrib1dAPPLE = NULL;
PFNGLMAPVERTEXATTRIB1FAPPLEPROC glad_glMapVertexAttrib1fAPPLE = NULL;
PFNGLMAPVERTEXATTRIB2DAPPLEPROC glad_glMapVertexAttrib2dAPPLE = NULL;
PFNGLMAPVERTEXATTRIB2FAPPLEPROC glad_glMapVertexAttrib2fAPPLE = NULL;
PFNGLMATRIXFRUSTUMEXTPROC glad_glMatrixFrustumEXT = NULL;
PFNGLMATRIXINDEXPOINTERARBPROC glad_glMatrixIndexPointerARB = NULL;
PFNGLMATRIXINDEXUBVARBPROC glad_glMatrixIndexubvARB = NULL;
PFNGLMATRIXINDEXUIVARBPROC glad_glMatrixIndexuivARB = NULL;
PFNGLMATRIXINDEXUSVARBPROC glad_glMatrixIndexusvARB = NULL;
PFNGLMATRIXLOAD3X2FNVPROC glad_glMatrixLoad3x2fNV = NULL;
PFNGLMATRIXLOAD3X3FNVPROC glad_glMatrixLoad3x3fNV = NULL;
PFNGLMATRIXLOADIDENTITYEXTPROC glad_glMatrixLoadIdentityEXT = NULL;
PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC glad_glMatrixLoadTranspose3x3fNV = NULL;
PFNGLMATRIXLOADTRANSPOSEDEXTPROC glad_glMatrixLoadTransposedEXT = NULL;
PFNGLMATRIXLOADTRANSPOSEFEXTPROC glad_glMatrixLoadTransposefEXT = NULL;
PFNGLMATRIXLOADDEXTPROC glad_glMatrixLoaddEXT = NULL;
PFNGLMATRIXLOADFEXTPROC glad_glMatrixLoadfEXT = NULL;
PFNGLMATRIXMULT3X2FNVPROC glad_glMatrixMult3x2fNV = NULL;
PFNGLMATRIXMULT3X3FNVPROC glad_glMatrixMult3x3fNV = NULL;
PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC glad_glMatrixMultTranspose3x3fNV = NULL;
PFNGLMATRIXMULTTRANSPOSEDEXTPROC glad_glMatrixMultTransposedEXT = NULL;
PFNGLMATRIXMULTTRANSPOSEFEXTPROC glad_glMatrixMultTransposefEXT = NULL;
PFNGLMATRIXMULTDEXTPROC glad_glMatrixMultdEXT = NULL;
PFNGLMATRIXMULTFEXTPROC glad_glMatrixMultfEXT = NULL;
PFNGLMATRIXORTHOEXTPROC glad_glMatrixOrthoEXT = NULL;
PFNGLMATRIXPOPEXTPROC glad_glMatrixPopEXT = NULL;
PFNGLMATRIXPUSHEXTPROC glad_glMatrixPushEXT = NULL;
PFNGLMATRIXROTATEDEXTPROC glad_glMatrixRotatedEXT = NULL;
PFNGLMATRIXROTATEFEXTPROC glad_glMatrixRotatefEXT = NULL;
PFNGLMATRIXSCALEDEXTPROC glad_glMatrixScaledEXT = NULL;
PFNGLMATRIXSCALEFEXTPROC glad_glMatrixScalefEXT = NULL;
PFNGLMATRIXTRANSLATEDEXTPROC glad_glMatrixTranslatedEXT = NULL;
PFNGLMATRIXTRANSLATEFEXTPROC glad_glMatrixTranslatefEXT = NULL;
PFNGLMAXSHADERCOMPILERTHREADSARBPROC glad_glMaxShaderCompilerThreadsARB = NULL;
PFNGLMAXSHADERCOMPILERTHREADSKHRPROC glad_glMaxShaderCompilerThreadsKHR = NULL;
PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier = NULL;
PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion = NULL;
PFNGLMEMORYBARRIEREXTPROC glad_glMemoryBarrierEXT = NULL;
PFNGLMEMORYOBJECTPARAMETERIVEXTPROC glad_glMemoryObjectParameterivEXT = NULL;
PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading = NULL;
PFNGLMINSAMPLESHADINGARBPROC glad_glMinSampleShadingARB = NULL;
PFNGLMINMAXPROC glad_glMinmax = NULL;
PFNGLMINMAXEXTPROC glad_glMinmaxEXT = NULL;
PFNGLMULTTRANSPOSEMATRIXDPROC glad_glMultTransposeMatrixd = NULL;
PFNGLMULTTRANSPOSEMATRIXDARBPROC glad_glMultTransposeMatrixdARB = NULL;
PFNGLMULTTRANSPOSEMATRIXFPROC glad_glMultTransposeMatrixf = NULL;
PFNGLMULTTRANSPOSEMATRIXFARBPROC glad_glMultTransposeMatrixfARB = NULL;
PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays = NULL;
PFNGLMULTIDRAWARRAYSEXTPROC glad_glMultiDrawArraysEXT = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC glad_glMultiDrawArraysIndirectAMD = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC glad_glMultiDrawArraysIndirectBindlessCountNV = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC glad_glMultiDrawArraysIndirectBindlessNV = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC glad_glMultiDrawArraysIndirectCountARB = NULL;
PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC glad_glMultiDrawElementArrayAPPLE = NULL;
PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements = NULL;
PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex = NULL;
PFNGLMULTIDRAWELEMENTSEXTPROC glad_glMultiDrawElementsEXT = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC glad_glMultiDrawElementsIndirectAMD = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC glad_glMultiDrawElementsIndirectBindlessCountNV = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC glad_glMultiDrawElementsIndirectBindlessNV = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC glad_glMultiDrawElementsIndirectCountARB = NULL;
PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC glad_glMultiDrawRangeElementArrayAPPLE = NULL;
PFNGLMULTITEXBUFFEREXTPROC glad_glMultiTexBufferEXT = NULL;
PFNGLMULTITEXCOORD1DPROC glad_glMultiTexCoord1d = NULL;
PFNGLMULTITEXCOORD1DARBPROC glad_glMultiTexCoord1dARB = NULL;
PFNGLMULTITEXCOORD1DVPROC glad_glMultiTexCoord1dv = NULL;
PFNGLMULTITEXCOORD1DVARBPROC glad_glMultiTexCoord1dvARB = NULL;
PFNGLMULTITEXCOORD1FPROC glad_glMultiTexCoord1f = NULL;
PFNGLMULTITEXCOORD1FARBPROC glad_glMultiTexCoord1fARB = NULL;
PFNGLMULTITEXCOORD1FVPROC glad_glMultiTexCoord1fv = NULL;
PFNGLMULTITEXCOORD1FVARBPROC glad_glMultiTexCoord1fvARB = NULL;
PFNGLMULTITEXCOORD1HNVPROC glad_glMultiTexCoord1hNV = NULL;
PFNGLMULTITEXCOORD1HVNVPROC glad_glMultiTexCoord1hvNV = NULL;
PFNGLMULTITEXCOORD1IPROC glad_glMultiTexCoord1i = NULL;
PFNGLMULTITEXCOORD1IARBPROC glad_glMultiTexCoord1iARB = NULL;
PFNGLMULTITEXCOORD1IVPROC glad_glMultiTexCoord1iv = NULL;
PFNGLMULTITEXCOORD1IVARBPROC glad_glMultiTexCoord1ivARB = NULL;
PFNGLMULTITEXCOORD1SPROC glad_glMultiTexCoord1s = NULL;
PFNGLMULTITEXCOORD1SARBPROC glad_glMultiTexCoord1sARB = NULL;
PFNGLMULTITEXCOORD1SVPROC glad_glMultiTexCoord1sv = NULL;
PFNGLMULTITEXCOORD1SVARBPROC glad_glMultiTexCoord1svARB = NULL;
PFNGLMULTITEXCOORD2DPROC glad_glMultiTexCoord2d = NULL;
PFNGLMULTITEXCOORD2DARBPROC glad_glMultiTexCoord2dARB = NULL;
PFNGLMULTITEXCOORD2DVPROC glad_glMultiTexCoord2dv = NULL;
PFNGLMULTITEXCOORD2DVARBPROC glad_glMultiTexCoord2dvARB = NULL;
PFNGLMULTITEXCOORD2FPROC glad_glMultiTexCoord2f = NULL;
PFNGLMULTITEXCOORD2FARBPROC glad_glMultiTexCoord2fARB = NULL;
PFNGLMULTITEXCOORD2FVPROC glad_glMultiTexCoord2fv = NULL;
PFNGLMULTITEXCOORD2FVARBPROC glad_glMultiTexCoord2fvARB = NULL;
PFNGLMULTITEXCOORD2HNVPROC glad_glMultiTexCoord2hNV = NULL;
PFNGLMULTITEXCOORD2HVNVPROC glad_glMultiTexCoord2hvNV = NULL;
PFNGLMULTITEXCOORD2IPROC glad_glMultiTexCoord2i = NULL;
PFNGLMULTITEXCOORD2IARBPROC glad_glMultiTexCoord2iARB = NULL;
PFNGLMULTITEXCOORD2IVPROC glad_glMultiTexCoord2iv = NULL;
PFNGLMULTITEXCOORD2IVARBPROC glad_glMultiTexCoord2ivARB = NULL;
PFNGLMULTITEXCOORD2SPROC glad_glMultiTexCoord2s = NULL;
PFNGLMULTITEXCOORD2SARBPROC glad_glMultiTexCoord2sARB = NULL;
PFNGLMULTITEXCOORD2SVPROC glad_glMultiTexCoord2sv = NULL;
PFNGLMULTITEXCOORD2SVARBPROC glad_glMultiTexCoord2svARB = NULL;
PFNGLMULTITEXCOORD3DPROC glad_glMultiTexCoord3d = NULL;
PFNGLMULTITEXCOORD3DARBPROC glad_glMultiTexCoord3dARB = NULL;
PFNGLMULTITEXCOORD3DVPROC glad_glMultiTexCoord3dv = NULL;
PFNGLMULTITEXCOORD3DVARBPROC glad_glMultiTexCoord3dvARB = NULL;
PFNGLMULTITEXCOORD3FPROC glad_glMultiTexCoord3f = NULL;
PFNGLMULTITEXCOORD3FARBPROC glad_glMultiTexCoord3fARB = NULL;
PFNGLMULTITEXCOORD3FVPROC glad_glMultiTexCoord3fv = NULL;
PFNGLMULTITEXCOORD3FVARBPROC glad_glMultiTexCoord3fvARB = NULL;
PFNGLMULTITEXCOORD3HNVPROC glad_glMultiTexCoord3hNV = NULL;
PFNGLMULTITEXCOORD3HVNVPROC glad_glMultiTexCoord3hvNV = NULL;
PFNGLMULTITEXCOORD3IPROC glad_glMultiTexCoord3i = NULL;
PFNGLMULTITEXCOORD3IARBPROC glad_glMultiTexCoord3iARB = NULL;
PFNGLMULTITEXCOORD3IVPROC glad_glMultiTexCoord3iv = NULL;
PFNGLMULTITEXCOORD3IVARBPROC glad_glMultiTexCoord3ivARB = NULL;
PFNGLMULTITEXCOORD3SPROC glad_glMultiTexCoord3s = NULL;
PFNGLMULTITEXCOORD3SARBPROC glad_glMultiTexCoord3sARB = NULL;
PFNGLMULTITEXCOORD3SVPROC glad_glMultiTexCoord3sv = NULL;
PFNGLMULTITEXCOORD3SVARBPROC glad_glMultiTexCoord3svARB = NULL;
PFNGLMULTITEXCOORD4DPROC glad_glMultiTexCoord4d = NULL;
PFNGLMULTITEXCOORD4DARBPROC glad_glMultiTexCoord4dARB = NULL;
PFNGLMULTITEXCOORD4DVPROC glad_glMultiTexCoord4dv = NULL;
PFNGLMULTITEXCOORD4DVARBPROC glad_glMultiTexCoord4dvARB = NULL;
PFNGLMULTITEXCOORD4FPROC glad_glMultiTexCoord4f = NULL;
PFNGLMULTITEXCOORD4FARBPROC glad_glMultiTexCoord4fARB = NULL;
PFNGLMULTITEXCOORD4FVPROC glad_glMultiTexCoord4fv = NULL;
PFNGLMULTITEXCOORD4FVARBPROC glad_glMultiTexCoord4fvARB = NULL;
PFNGLMULTITEXCOORD4HNVPROC glad_glMultiTexCoord4hNV = NULL;
PFNGLMULTITEXCOORD4HVNVPROC glad_glMultiTexCoord4hvNV = NULL;
PFNGLMULTITEXCOORD4IPROC glad_glMultiTexCoord4i = NULL;
PFNGLMULTITEXCOORD4IARBPROC glad_glMultiTexCoord4iARB = NULL;
PFNGLMULTITEXCOORD4IVPROC glad_glMultiTexCoord4iv = NULL;
PFNGLMULTITEXCOORD4IVARBPROC glad_glMultiTexCoord4ivARB = NULL;
PFNGLMULTITEXCOORD4SPROC glad_glMultiTexCoord4s = NULL;
PFNGLMULTITEXCOORD4SARBPROC glad_glMultiTexCoord4sARB = NULL;
PFNGLMULTITEXCOORD4SVPROC glad_glMultiTexCoord4sv = NULL;
PFNGLMULTITEXCOORD4SVARBPROC glad_glMultiTexCoord4svARB = NULL;
PFNGLMULTITEXCOORDPOINTEREXTPROC glad_glMultiTexCoordPointerEXT = NULL;
PFNGLMULTITEXENVFEXTPROC glad_glMultiTexEnvfEXT = NULL;
PFNGLMULTITEXENVFVEXTPROC glad_glMultiTexEnvfvEXT = NULL;
PFNGLMULTITEXENVIEXTPROC glad_glMultiTexEnviEXT = NULL;
PFNGLMULTITEXENVIVEXTPROC glad_glMultiTexEnvivEXT = NULL;
PFNGLMULTITEXGENDEXTPROC glad_glMultiTexGendEXT = NULL;
PFNGLMULTITEXGENDVEXTPROC glad_glMultiTexGendvEXT = NULL;
PFNGLMULTITEXGENFEXTPROC glad_glMultiTexGenfEXT = NULL;
PFNGLMULTITEXGENFVEXTPROC glad_glMultiTexGenfvEXT = NULL;
PFNGLMULTITEXGENIEXTPROC glad_glMultiTexGeniEXT = NULL;
PFNGLMULTITEXGENIVEXTPROC glad_glMultiTexGenivEXT = NULL;
PFNGLMULTITEXIMAGE1DEXTPROC glad_glMultiTexImage1DEXT = NULL;
PFNGLMULTITEXIMAGE2DEXTPROC glad_glMultiTexImage2DEXT = NULL;
PFNGLMULTITEXIMAGE3DEXTPROC glad_glMultiTexImage3DEXT = NULL;
PFNGLMULTITEXPARAMETERIIVEXTPROC glad_glMultiTexParameterIivEXT = NULL;
PFNGLMULTITEXPARAMETERIUIVEXTPROC glad_glMultiTexParameterIuivEXT = NULL;
PFNGLMULTITEXPARAMETERFEXTPROC glad_glMultiTexParameterfEXT = NULL;
PFNGLMULTITEXPARAMETERFVEXTPROC glad_glMultiTexParameterfvEXT = NULL;
PFNGLMULTITEXPARAMETERIEXTPROC glad_glMultiTexParameteriEXT = NULL;
PFNGLMULTITEXPARAMETERIVEXTPROC glad_glMultiTexParameterivEXT = NULL;
PFNGLMULTITEXRENDERBUFFEREXTPROC glad_glMultiTexRenderbufferEXT = NULL;
PFNGLMULTITEXSUBIMAGE1DEXTPROC glad_glMultiTexSubImage1DEXT = NULL;
PFNGLMULTITEXSUBIMAGE2DEXTPROC glad_glMultiTexSubImage2DEXT = NULL;
PFNGLMULTITEXSUBIMAGE3DEXTPROC glad_glMultiTexSubImage3DEXT = NULL;
PFNGLMULTICASTBARRIERNVPROC glad_glMulticastBarrierNV = NULL;
PFNGLMULTICASTBLITFRAMEBUFFERNVPROC glad_glMulticastBlitFramebufferNV = NULL;
PFNGLMULTICASTBUFFERSUBDATANVPROC glad_glMulticastBufferSubDataNV = NULL;
PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC glad_glMulticastCopyBufferSubDataNV = NULL;
PFNGLMULTICASTCOPYIMAGESUBDATANVPROC glad_glMulticastCopyImageSubDataNV = NULL;
PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glMulticastFramebufferSampleLocationsfvNV = NULL;
PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC glad_glMulticastGetQueryObjecti64vNV = NULL;
PFNGLMULTICASTGETQUERYOBJECTIVNVPROC glad_glMulticastGetQueryObjectivNV = NULL;
PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC glad_glMulticastGetQueryObjectui64vNV = NULL;
PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC glad_glMulticastGetQueryObjectuivNV = NULL;
PFNGLMULTICASTWAITSYNCNVPROC glad_glMulticastWaitSyncNV = NULL;
PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData = NULL;
PFNGLNAMEDBUFFERDATAEXTPROC glad_glNamedBufferDataEXT = NULL;
PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC glad_glNamedBufferPageCommitmentARB = NULL;
PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC glad_glNamedBufferPageCommitmentEXT = NULL;
PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage = NULL;
PFNGLNAMEDBUFFERSTORAGEEXTPROC glad_glNamedBufferStorageEXT = NULL;
PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC glad_glNamedBufferStorageExternalEXT = NULL;
PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC glad_glNamedBufferStorageMemEXT = NULL;
PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData = NULL;
PFNGLNAMEDBUFFERSUBDATAEXTPROC glad_glNamedBufferSubDataEXT = NULL;
PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC glad_glNamedCopyBufferSubDataEXT = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers = NULL;
PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri = NULL;
PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC glad_glNamedFramebufferParameteriEXT = NULL;
PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer = NULL;
PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC glad_glNamedFramebufferRenderbufferEXT = NULL;
PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glad_glNamedFramebufferSampleLocationsfvARB = NULL;
PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glNamedFramebufferSampleLocationsfvNV = NULL;
PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC glad_glNamedFramebufferSamplePositionsfvAMD = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC glad_glNamedFramebufferTexture1DEXT = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC glad_glNamedFramebufferTexture2DEXT = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC glad_glNamedFramebufferTexture3DEXT = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC glad_glNamedFramebufferTextureEXT = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC glad_glNamedFramebufferTextureFaceEXT = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC glad_glNamedFramebufferTextureLayerEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC glad_glNamedProgramLocalParameter4dEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC glad_glNamedProgramLocalParameter4dvEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC glad_glNamedProgramLocalParameter4fEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC glad_glNamedProgramLocalParameter4fvEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC glad_glNamedProgramLocalParameterI4iEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC glad_glNamedProgramLocalParameterI4ivEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC glad_glNamedProgramLocalParameterI4uiEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC glad_glNamedProgramLocalParameterI4uivEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC glad_glNamedProgramLocalParameters4fvEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC glad_glNamedProgramLocalParametersI4ivEXT = NULL;
PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC glad_glNamedProgramLocalParametersI4uivEXT = NULL;
PFNGLNAMEDPROGRAMSTRINGEXTPROC glad_glNamedProgramStringEXT = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC glad_glNamedRenderbufferStorageEXT = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC glad_glNamedRenderbufferStorageMultisampleCoverageEXT = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC glad_glNamedRenderbufferStorageMultisampleEXT = NULL;
PFNGLNAMEDSTRINGARBPROC glad_glNamedStringARB = NULL;
PFNGLNEWOBJECTBUFFERATIPROC glad_glNewObjectBufferATI = NULL;
PFNGLNORMAL3HNVPROC glad_glNormal3hNV = NULL;
PFNGLNORMAL3HVNVPROC glad_glNormal3hvNV = NULL;
PFNGLNORMALFORMATNVPROC glad_glNormalFormatNV = NULL;
PFNGLNORMALPOINTEREXTPROC glad_glNormalPointerEXT = NULL;
PFNGLNORMALPOINTERVINTELPROC glad_glNormalPointervINTEL = NULL;
PFNGLNORMALSTREAM3BATIPROC glad_glNormalStream3bATI = NULL;
PFNGLNORMALSTREAM3BVATIPROC glad_glNormalStream3bvATI = NULL;
PFNGLNORMALSTREAM3DATIPROC glad_glNormalStream3dATI = NULL;
PFNGLNORMALSTREAM3DVATIPROC glad_glNormalStream3dvATI = NULL;
PFNGLNORMALSTREAM3FATIPROC glad_glNormalStream3fATI = NULL;
PFNGLNORMALSTREAM3FVATIPROC glad_glNormalStream3fvATI = NULL;
PFNGLNORMALSTREAM3IATIPROC glad_glNormalStream3iATI = NULL;
PFNGLNORMALSTREAM3IVATIPROC glad_glNormalStream3ivATI = NULL;
PFNGLNORMALSTREAM3SATIPROC glad_glNormalStream3sATI = NULL;
PFNGLNORMALSTREAM3SVATIPROC glad_glNormalStream3svATI = NULL;
PFNGLOBJECTLABELPROC glad_glObjectLabel = NULL;
PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel = NULL;
PFNGLOBJECTPURGEABLEAPPLEPROC glad_glObjectPurgeableAPPLE = NULL;
PFNGLOBJECTUNPURGEABLEAPPLEPROC glad_glObjectUnpurgeableAPPLE = NULL;
PFNGLPNTRIANGLESFATIPROC glad_glPNTrianglesfATI = NULL;
PFNGLPNTRIANGLESIATIPROC glad_glPNTrianglesiATI = NULL;
PFNGLPASSTEXCOORDATIPROC glad_glPassTexCoordATI = NULL;
PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv = NULL;
PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri = NULL;
PFNGLPATHCOMMANDSNVPROC glad_glPathCommandsNV = NULL;
PFNGLPATHCOORDSNVPROC glad_glPathCoordsNV = NULL;
PFNGLPATHCOVERDEPTHFUNCNVPROC glad_glPathCoverDepthFuncNV = NULL;
PFNGLPATHDASHARRAYNVPROC glad_glPathDashArrayNV = NULL;
PFNGLPATHGLYPHINDEXARRAYNVPROC glad_glPathGlyphIndexArrayNV = NULL;
PFNGLPATHGLYPHINDEXRANGENVPROC glad_glPathGlyphIndexRangeNV = NULL;
PFNGLPATHGLYPHRANGENVPROC glad_glPathGlyphRangeNV = NULL;
PFNGLPATHGLYPHSNVPROC glad_glPathGlyphsNV = NULL;
PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC glad_glPathMemoryGlyphIndexArrayNV = NULL;
PFNGLPATHPARAMETERFNVPROC glad_glPathParameterfNV = NULL;
PFNGLPATHPARAMETERFVNVPROC glad_glPathParameterfvNV = NULL;
PFNGLPATHPARAMETERINVPROC glad_glPathParameteriNV = NULL;
PFNGLPATHPARAMETERIVNVPROC glad_glPathParameterivNV = NULL;
PFNGLPATHSTENCILDEPTHOFFSETNVPROC glad_glPathStencilDepthOffsetNV = NULL;
PFNGLPATHSTENCILFUNCNVPROC glad_glPathStencilFuncNV = NULL;
PFNGLPATHSTRINGNVPROC glad_glPathStringNV = NULL;
PFNGLPATHSUBCOMMANDSNVPROC glad_glPathSubCommandsNV = NULL;
PFNGLPATHSUBCOORDSNVPROC glad_glPathSubCoordsNV = NULL;
PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback = NULL;
PFNGLPAUSETRANSFORMFEEDBACKNVPROC glad_glPauseTransformFeedbackNV = NULL;
PFNGLPIXELDATARANGENVPROC glad_glPixelDataRangeNV = NULL;
PFNGLPIXELSTOREFPROC glad_glPixelStoref = NULL;
PFNGLPIXELSTOREIPROC glad_glPixelStorei = NULL;
PFNGLPIXELTRANSFORMPARAMETERFEXTPROC glad_glPixelTransformParameterfEXT = NULL;
PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC glad_glPixelTransformParameterfvEXT = NULL;
PFNGLPIXELTRANSFORMPARAMETERIEXTPROC glad_glPixelTransformParameteriEXT = NULL;
PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC glad_glPixelTransformParameterivEXT = NULL;
PFNGLPOINTALONGPATHNVPROC glad_glPointAlongPathNV = NULL;
PFNGLPOINTPARAMETERFPROC glad_glPointParameterf = NULL;
PFNGLPOINTPARAMETERFARBPROC glad_glPointParameterfARB = NULL;
PFNGLPOINTPARAMETERFEXTPROC glad_glPointParameterfEXT = NULL;
PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv = NULL;
PFNGLPOINTPARAMETERFVARBPROC glad_glPointParameterfvARB = NULL;
PFNGLPOINTPARAMETERFVEXTPROC glad_glPointParameterfvEXT = NULL;
PFNGLPOINTPARAMETERIPROC glad_glPointParameteri = NULL;
PFNGLPOINTPARAMETERINVPROC glad_glPointParameteriNV = NULL;
PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv = NULL;
PFNGLPOINTPARAMETERIVNVPROC glad_glPointParameterivNV = NULL;
PFNGLPOINTSIZEPROC glad_glPointSize = NULL;
PFNGLPOLYGONMODEPROC glad_glPolygonMode = NULL;
PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset = NULL;
PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp = NULL;
PFNGLPOLYGONOFFSETCLAMPEXTPROC glad_glPolygonOffsetClampEXT = NULL;
PFNGLPOLYGONOFFSETEXTPROC glad_glPolygonOffsetEXT = NULL;
PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup = NULL;
PFNGLPOPGROUPMARKEREXTPROC glad_glPopGroupMarkerEXT = NULL;
PFNGLPRESENTFRAMEDUALFILLNVPROC glad_glPresentFrameDualFillNV = NULL;
PFNGLPRESENTFRAMEKEYEDNVPROC glad_glPresentFrameKeyedNV = NULL;
PFNGLPRIMITIVEBOUNDINGBOXPROC glad_glPrimitiveBoundingBox = NULL;
PFNGLPRIMITIVEBOUNDINGBOXARBPROC glad_glPrimitiveBoundingBoxARB = NULL;
PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex = NULL;
PFNGLPRIMITIVERESTARTINDEXNVPROC glad_glPrimitiveRestartIndexNV = NULL;
PFNGLPRIMITIVERESTARTNVPROC glad_glPrimitiveRestartNV = NULL;
PFNGLPRIORITIZETEXTURESPROC glad_glPrioritizeTextures = NULL;
PFNGLPRIORITIZETEXTURESEXTPROC glad_glPrioritizeTexturesEXT = NULL;
PFNGLPROGRAMBINARYPROC glad_glProgramBinary = NULL;
PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC glad_glProgramBufferParametersIivNV = NULL;
PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC glad_glProgramBufferParametersIuivNV = NULL;
PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC glad_glProgramBufferParametersfvNV = NULL;
PFNGLPROGRAMENVPARAMETER4DARBPROC glad_glProgramEnvParameter4dARB = NULL;
PFNGLPROGRAMENVPARAMETER4DVARBPROC glad_glProgramEnvParameter4dvARB = NULL;
PFNGLPROGRAMENVPARAMETER4FARBPROC glad_glProgramEnvParameter4fARB = NULL;
PFNGLPROGRAMENVPARAMETER4FVARBPROC glad_glProgramEnvParameter4fvARB = NULL;
PFNGLPROGRAMENVPARAMETERI4INVPROC glad_glProgramEnvParameterI4iNV = NULL;
PFNGLPROGRAMENVPARAMETERI4IVNVPROC glad_glProgramEnvParameterI4ivNV = NULL;
PFNGLPROGRAMENVPARAMETERI4UINVPROC glad_glProgramEnvParameterI4uiNV = NULL;
PFNGLPROGRAMENVPARAMETERI4UIVNVPROC glad_glProgramEnvParameterI4uivNV = NULL;
PFNGLPROGRAMENVPARAMETERS4FVEXTPROC glad_glProgramEnvParameters4fvEXT = NULL;
PFNGLPROGRAMENVPARAMETERSI4IVNVPROC glad_glProgramEnvParametersI4ivNV = NULL;
PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC glad_glProgramEnvParametersI4uivNV = NULL;
PFNGLPROGRAMLOCALPARAMETER4DARBPROC glad_glProgramLocalParameter4dARB = NULL;
PFNGLPROGRAMLOCALPARAMETER4DVARBPROC glad_glProgramLocalParameter4dvARB = NULL;
PFNGLPROGRAMLOCALPARAMETER4FARBPROC glad_glProgramLocalParameter4fARB = NULL;
PFNGLPROGRAMLOCALPARAMETER4FVARBPROC glad_glProgramLocalParameter4fvARB = NULL;
PFNGLPROGRAMLOCALPARAMETERI4INVPROC glad_glProgramLocalParameterI4iNV = NULL;
PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC glad_glProgramLocalParameterI4ivNV = NULL;
PFNGLPROGRAMLOCALPARAMETERI4UINVPROC glad_glProgramLocalParameterI4uiNV = NULL;
PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC glad_glProgramLocalParameterI4uivNV = NULL;
PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC glad_glProgramLocalParameters4fvEXT = NULL;
PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC glad_glProgramLocalParametersI4ivNV = NULL;
PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC glad_glProgramLocalParametersI4uivNV = NULL;
PFNGLPROGRAMNAMEDPARAMETER4DNVPROC glad_glProgramNamedParameter4dNV = NULL;
PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC glad_glProgramNamedParameter4dvNV = NULL;
PFNGLPROGRAMNAMEDPARAMETER4FNVPROC glad_glProgramNamedParameter4fNV = NULL;
PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC glad_glProgramNamedParameter4fvNV = NULL;
PFNGLPROGRAMPARAMETER4DNVPROC glad_glProgramParameter4dNV = NULL;
PFNGLPROGRAMPARAMETER4DVNVPROC glad_glProgramParameter4dvNV = NULL;
PFNGLPROGRAMPARAMETER4FNVPROC glad_glProgramParameter4fNV = NULL;
PFNGLPROGRAMPARAMETER4FVNVPROC glad_glProgramParameter4fvNV = NULL;
PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri = NULL;
PFNGLPROGRAMPARAMETERIARBPROC glad_glProgramParameteriARB = NULL;
PFNGLPROGRAMPARAMETERIEXTPROC glad_glProgramParameteriEXT = NULL;
PFNGLPROGRAMPARAMETERS4DVNVPROC glad_glProgramParameters4dvNV = NULL;
PFNGLPROGRAMPARAMETERS4FVNVPROC glad_glProgramParameters4fvNV = NULL;
PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC glad_glProgramPathFragmentInputGenNV = NULL;
PFNGLPROGRAMSTRINGARBPROC glad_glProgramStringARB = NULL;
PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC glad_glProgramSubroutineParametersuivNV = NULL;
PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d = NULL;
PFNGLPROGRAMUNIFORM1DEXTPROC glad_glProgramUniform1dEXT = NULL;
PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv = NULL;
PFNGLPROGRAMUNIFORM1DVEXTPROC glad_glProgramUniform1dvEXT = NULL;
PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f = NULL;
PFNGLPROGRAMUNIFORM1FEXTPROC glad_glProgramUniform1fEXT = NULL;
PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv = NULL;
PFNGLPROGRAMUNIFORM1FVEXTPROC glad_glProgramUniform1fvEXT = NULL;
PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i = NULL;
PFNGLPROGRAMUNIFORM1I64ARBPROC glad_glProgramUniform1i64ARB = NULL;
PFNGLPROGRAMUNIFORM1I64NVPROC glad_glProgramUniform1i64NV = NULL;
PFNGLPROGRAMUNIFORM1I64VARBPROC glad_glProgramUniform1i64vARB = NULL;
PFNGLPROGRAMUNIFORM1I64VNVPROC glad_glProgramUniform1i64vNV = NULL;
PFNGLPROGRAMUNIFORM1IEXTPROC glad_glProgramUniform1iEXT = NULL;
PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv = NULL;
PFNGLPROGRAMUNIFORM1IVEXTPROC glad_glProgramUniform1ivEXT = NULL;
PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui = NULL;
PFNGLPROGRAMUNIFORM1UI64ARBPROC glad_glProgramUniform1ui64ARB = NULL;
PFNGLPROGRAMUNIFORM1UI64NVPROC glad_glProgramUniform1ui64NV = NULL;
PFNGLPROGRAMUNIFORM1UI64VARBPROC glad_glProgramUniform1ui64vARB = NULL;
PFNGLPROGRAMUNIFORM1UI64VNVPROC glad_glProgramUniform1ui64vNV = NULL;
PFNGLPROGRAMUNIFORM1UIEXTPROC glad_glProgramUniform1uiEXT = NULL;
PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv = NULL;
PFNGLPROGRAMUNIFORM1UIVEXTPROC glad_glProgramUniform1uivEXT = NULL;
PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d = NULL;
PFNGLPROGRAMUNIFORM2DEXTPROC glad_glProgramUniform2dEXT = NULL;
PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv = NULL;
PFNGLPROGRAMUNIFORM2DVEXTPROC glad_glProgramUniform2dvEXT = NULL;
PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f = NULL;
PFNGLPROGRAMUNIFORM2FEXTPROC glad_glProgramUniform2fEXT = NULL;
PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv = NULL;
PFNGLPROGRAMUNIFORM2FVEXTPROC glad_glProgramUniform2fvEXT = NULL;
PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i = NULL;
PFNGLPROGRAMUNIFORM2I64ARBPROC glad_glProgramUniform2i64ARB = NULL;
PFNGLPROGRAMUNIFORM2I64NVPROC glad_glProgramUniform2i64NV = NULL;
PFNGLPROGRAMUNIFORM2I64VARBPROC glad_glProgramUniform2i64vARB = NULL;
PFNGLPROGRAMUNIFORM2I64VNVPROC glad_glProgramUniform2i64vNV = NULL;
PFNGLPROGRAMUNIFORM2IEXTPROC glad_glProgramUniform2iEXT = NULL;
PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv = NULL;
PFNGLPROGRAMUNIFORM2IVEXTPROC glad_glProgramUniform2ivEXT = NULL;
PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui = NULL;
PFNGLPROGRAMUNIFORM2UI64ARBPROC glad_glProgramUniform2ui64ARB = NULL;
PFNGLPROGRAMUNIFORM2UI64NVPROC glad_glProgramUniform2ui64NV = NULL;
PFNGLPROGRAMUNIFORM2UI64VARBPROC glad_glProgramUniform2ui64vARB = NULL;
PFNGLPROGRAMUNIFORM2UI64VNVPROC glad_glProgramUniform2ui64vNV = NULL;
PFNGLPROGRAMUNIFORM2UIEXTPROC glad_glProgramUniform2uiEXT = NULL;
PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv = NULL;
PFNGLPROGRAMUNIFORM2UIVEXTPROC glad_glProgramUniform2uivEXT = NULL;
PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d = NULL;
PFNGLPROGRAMUNIFORM3DEXTPROC glad_glProgramUniform3dEXT = NULL;
PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv = NULL;
PFNGLPROGRAMUNIFORM3DVEXTPROC glad_glProgramUniform3dvEXT = NULL;
PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f = NULL;
PFNGLPROGRAMUNIFORM3FEXTPROC glad_glProgramUniform3fEXT = NULL;
PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv = NULL;
PFNGLPROGRAMUNIFORM3FVEXTPROC glad_glProgramUniform3fvEXT = NULL;
PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i = NULL;
PFNGLPROGRAMUNIFORM3I64ARBPROC glad_glProgramUniform3i64ARB = NULL;
PFNGLPROGRAMUNIFORM3I64NVPROC glad_glProgramUniform3i64NV = NULL;
PFNGLPROGRAMUNIFORM3I64VARBPROC glad_glProgramUniform3i64vARB = NULL;
PFNGLPROGRAMUNIFORM3I64VNVPROC glad_glProgramUniform3i64vNV = NULL;
PFNGLPROGRAMUNIFORM3IEXTPROC glad_glProgramUniform3iEXT = NULL;
PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv = NULL;
PFNGLPROGRAMUNIFORM3IVEXTPROC glad_glProgramUniform3ivEXT = NULL;
PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui = NULL;
PFNGLPROGRAMUNIFORM3UI64ARBPROC glad_glProgramUniform3ui64ARB = NULL;
PFNGLPROGRAMUNIFORM3UI64NVPROC glad_glProgramUniform3ui64NV = NULL;
PFNGLPROGRAMUNIFORM3UI64VARBPROC glad_glProgramUniform3ui64vARB = NULL;
PFNGLPROGRAMUNIFORM3UI64VNVPROC glad_glProgramUniform3ui64vNV = NULL;
PFNGLPROGRAMUNIFORM3UIEXTPROC glad_glProgramUniform3uiEXT = NULL;
PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv = NULL;
PFNGLPROGRAMUNIFORM3UIVEXTPROC glad_glProgramUniform3uivEXT = NULL;
PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d = NULL;
PFNGLPROGRAMUNIFORM4DEXTPROC glad_glProgramUniform4dEXT = NULL;
PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv = NULL;
PFNGLPROGRAMUNIFORM4DVEXTPROC glad_glProgramUniform4dvEXT = NULL;
PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f = NULL;
PFNGLPROGRAMUNIFORM4FEXTPROC glad_glProgramUniform4fEXT = NULL;
PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv = NULL;
PFNGLPROGRAMUNIFORM4FVEXTPROC glad_glProgramUniform4fvEXT = NULL;
PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i = NULL;
PFNGLPROGRAMUNIFORM4I64ARBPROC glad_glProgramUniform4i64ARB = NULL;
PFNGLPROGRAMUNIFORM4I64NVPROC glad_glProgramUniform4i64NV = NULL;
PFNGLPROGRAMUNIFORM4I64VARBPROC glad_glProgramUniform4i64vARB = NULL;
PFNGLPROGRAMUNIFORM4I64VNVPROC glad_glProgramUniform4i64vNV = NULL;
PFNGLPROGRAMUNIFORM4IEXTPROC glad_glProgramUniform4iEXT = NULL;
PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv = NULL;
PFNGLPROGRAMUNIFORM4IVEXTPROC glad_glProgramUniform4ivEXT = NULL;
PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui = NULL;
PFNGLPROGRAMUNIFORM4UI64ARBPROC glad_glProgramUniform4ui64ARB = NULL;
PFNGLPROGRAMUNIFORM4UI64NVPROC glad_glProgramUniform4ui64NV = NULL;
PFNGLPROGRAMUNIFORM4UI64VARBPROC glad_glProgramUniform4ui64vARB = NULL;
PFNGLPROGRAMUNIFORM4UI64VNVPROC glad_glProgramUniform4ui64vNV = NULL;
PFNGLPROGRAMUNIFORM4UIEXTPROC glad_glProgramUniform4uiEXT = NULL;
PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv = NULL;
PFNGLPROGRAMUNIFORM4UIVEXTPROC glad_glProgramUniform4uivEXT = NULL;
PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC glad_glProgramUniformHandleui64ARB = NULL;
PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC glad_glProgramUniformHandleui64NV = NULL;
PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC glad_glProgramUniformHandleui64vARB = NULL;
PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC glad_glProgramUniformHandleui64vNV = NULL;
PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC glad_glProgramUniformMatrix2dvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC glad_glProgramUniformMatrix2fvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC glad_glProgramUniformMatrix2x3dvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC glad_glProgramUniformMatrix2x3fvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC glad_glProgramUniformMatrix2x4dvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC glad_glProgramUniformMatrix2x4fvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC glad_glProgramUniformMatrix3dvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC glad_glProgramUniformMatrix3fvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC glad_glProgramUniformMatrix3x2dvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC glad_glProgramUniformMatrix3x2fvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC glad_glProgramUniformMatrix3x4dvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC glad_glProgramUniformMatrix3x4fvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC glad_glProgramUniformMatrix4dvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC glad_glProgramUniformMatrix4fvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC glad_glProgramUniformMatrix4x2dvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC glad_glProgramUniformMatrix4x2fvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC glad_glProgramUniformMatrix4x3dvEXT = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC glad_glProgramUniformMatrix4x3fvEXT = NULL;
PFNGLPROGRAMUNIFORMUI64NVPROC glad_glProgramUniformui64NV = NULL;
PFNGLPROGRAMUNIFORMUI64VNVPROC glad_glProgramUniformui64vNV = NULL;
PFNGLPROGRAMVERTEXLIMITNVPROC glad_glProgramVertexLimitNV = NULL;
PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex = NULL;
PFNGLPROVOKINGVERTEXEXTPROC glad_glProvokingVertexEXT = NULL;
PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC glad_glPushClientAttribDefaultEXT = NULL;
PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup = NULL;
PFNGLPUSHGROUPMARKEREXTPROC glad_glPushGroupMarkerEXT = NULL;
PFNGLQUERYCOUNTERPROC glad_glQueryCounter = NULL;
PFNGLQUERYOBJECTPARAMETERUIAMDPROC glad_glQueryObjectParameteruiAMD = NULL;
PFNGLQUERYRESOURCENVPROC glad_glQueryResourceNV = NULL;
PFNGLQUERYRESOURCETAGNVPROC glad_glQueryResourceTagNV = NULL;
PFNGLRASTERSAMPLESEXTPROC glad_glRasterSamplesEXT = NULL;
PFNGLREADBUFFERPROC glad_glReadBuffer = NULL;
PFNGLREADPIXELSPROC glad_glReadPixels = NULL;
PFNGLREADNPIXELSPROC glad_glReadnPixels = NULL;
PFNGLREADNPIXELSARBPROC glad_glReadnPixelsARB = NULL;
PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC glad_glReleaseKeyedMutexWin32EXT = NULL;
PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler = NULL;
PFNGLRENDERGPUMASKNVPROC glad_glRenderGpuMaskNV = NULL;
PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage = NULL;
PFNGLRENDERBUFFERSTORAGEEXTPROC glad_glRenderbufferStorageEXT = NULL;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample = NULL;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC glad_glRenderbufferStorageMultisampleCoverageNV = NULL;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC glad_glRenderbufferStorageMultisampleEXT = NULL;
PFNGLREQUESTRESIDENTPROGRAMSNVPROC glad_glRequestResidentProgramsNV = NULL;
PFNGLRESETHISTOGRAMPROC glad_glResetHistogram = NULL;
PFNGLRESETHISTOGRAMEXTPROC glad_glResetHistogramEXT = NULL;
PFNGLRESETMINMAXPROC glad_glResetMinmax = NULL;
PFNGLRESETMINMAXEXTPROC glad_glResetMinmaxEXT = NULL;
PFNGLRESIZEBUFFERSMESAPROC glad_glResizeBuffersMESA = NULL;
PFNGLRESOLVEDEPTHVALUESNVPROC glad_glResolveDepthValuesNV = NULL;
PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback = NULL;
PFNGLRESUMETRANSFORMFEEDBACKNVPROC glad_glResumeTransformFeedbackNV = NULL;
PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage = NULL;
PFNGLSAMPLECOVERAGEARBPROC glad_glSampleCoverageARB = NULL;
PFNGLSAMPLEMAPATIPROC glad_glSampleMapATI = NULL;
PFNGLSAMPLEMASKEXTPROC glad_glSampleMaskEXT = NULL;
PFNGLSAMPLEMASKINDEXEDNVPROC glad_glSampleMaskIndexedNV = NULL;
PFNGLSAMPLEMASKIPROC glad_glSampleMaski = NULL;
PFNGLSAMPLEPATTERNEXTPROC glad_glSamplePatternEXT = NULL;
PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv = NULL;
PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv = NULL;
PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf = NULL;
PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv = NULL;
PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri = NULL;
PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv = NULL;
PFNGLSCISSORPROC glad_glScissor = NULL;
PFNGLSCISSORARRAYVPROC glad_glScissorArrayv = NULL;
PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed = NULL;
PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv = NULL;
PFNGLSECONDARYCOLOR3BPROC glad_glSecondaryColor3b = NULL;
PFNGLSECONDARYCOLOR3BEXTPROC glad_glSecondaryColor3bEXT = NULL;
PFNGLSECONDARYCOLOR3BVPROC glad_glSecondaryColor3bv = NULL;
PFNGLSECONDARYCOLOR3BVEXTPROC glad_glSecondaryColor3bvEXT = NULL;
PFNGLSECONDARYCOLOR3DPROC glad_glSecondaryColor3d = NULL;
PFNGLSECONDARYCOLOR3DEXTPROC glad_glSecondaryColor3dEXT = NULL;
PFNGLSECONDARYCOLOR3DVPROC glad_glSecondaryColor3dv = NULL;
PFNGLSECONDARYCOLOR3DVEXTPROC glad_glSecondaryColor3dvEXT = NULL;
PFNGLSECONDARYCOLOR3FPROC glad_glSecondaryColor3f = NULL;
PFNGLSECONDARYCOLOR3FEXTPROC glad_glSecondaryColor3fEXT = NULL;
PFNGLSECONDARYCOLOR3FVPROC glad_glSecondaryColor3fv = NULL;
PFNGLSECONDARYCOLOR3FVEXTPROC glad_glSecondaryColor3fvEXT = NULL;
PFNGLSECONDARYCOLOR3HNVPROC glad_glSecondaryColor3hNV = NULL;
PFNGLSECONDARYCOLOR3HVNVPROC glad_glSecondaryColor3hvNV = NULL;
PFNGLSECONDARYCOLOR3IPROC glad_glSecondaryColor3i = NULL;
PFNGLSECONDARYCOLOR3IEXTPROC glad_glSecondaryColor3iEXT = NULL;
PFNGLSECONDARYCOLOR3IVPROC glad_glSecondaryColor3iv = NULL;
PFNGLSECONDARYCOLOR3IVEXTPROC glad_glSecondaryColor3ivEXT = NULL;
PFNGLSECONDARYCOLOR3SPROC glad_glSecondaryColor3s = NULL;
PFNGLSECONDARYCOLOR3SEXTPROC glad_glSecondaryColor3sEXT = NULL;
PFNGLSECONDARYCOLOR3SVPROC glad_glSecondaryColor3sv = NULL;
PFNGLSECONDARYCOLOR3SVEXTPROC glad_glSecondaryColor3svEXT = NULL;
PFNGLSECONDARYCOLOR3UBPROC glad_glSecondaryColor3ub = NULL;
PFNGLSECONDARYCOLOR3UBEXTPROC glad_glSecondaryColor3ubEXT = NULL;
PFNGLSECONDARYCOLOR3UBVPROC glad_glSecondaryColor3ubv = NULL;
PFNGLSECONDARYCOLOR3UBVEXTPROC glad_glSecondaryColor3ubvEXT = NULL;
PFNGLSECONDARYCOLOR3UIPROC glad_glSecondaryColor3ui = NULL;
PFNGLSECONDARYCOLOR3UIEXTPROC glad_glSecondaryColor3uiEXT = NULL;
PFNGLSECONDARYCOLOR3UIVPROC glad_glSecondaryColor3uiv = NULL;
PFNGLSECONDARYCOLOR3UIVEXTPROC glad_glSecondaryColor3uivEXT = NULL;
PFNGLSECONDARYCOLOR3USPROC glad_glSecondaryColor3us = NULL;
PFNGLSECONDARYCOLOR3USEXTPROC glad_glSecondaryColor3usEXT = NULL;
PFNGLSECONDARYCOLOR3USVPROC glad_glSecondaryColor3usv = NULL;
PFNGLSECONDARYCOLOR3USVEXTPROC glad_glSecondaryColor3usvEXT = NULL;
PFNGLSECONDARYCOLORFORMATNVPROC glad_glSecondaryColorFormatNV = NULL;
PFNGLSECONDARYCOLORPOINTERPROC glad_glSecondaryColorPointer = NULL;
PFNGLSECONDARYCOLORPOINTEREXTPROC glad_glSecondaryColorPointerEXT = NULL;
PFNGLSELECTPERFMONITORCOUNTERSAMDPROC glad_glSelectPerfMonitorCountersAMD = NULL;
PFNGLSEMAPHOREPARAMETERUI64VEXTPROC glad_glSemaphoreParameterui64vEXT = NULL;
PFNGLSEPARABLEFILTER2DPROC glad_glSeparableFilter2D = NULL;
PFNGLSEPARABLEFILTER2DEXTPROC glad_glSeparableFilter2DEXT = NULL;
PFNGLSETFENCEAPPLEPROC glad_glSetFenceAPPLE = NULL;
PFNGLSETFENCENVPROC glad_glSetFenceNV = NULL;
PFNGLSETFRAGMENTSHADERCONSTANTATIPROC glad_glSetFragmentShaderConstantATI = NULL;
PFNGLSETINVARIANTEXTPROC glad_glSetInvariantEXT = NULL;
PFNGLSETLOCALCONSTANTEXTPROC glad_glSetLocalConstantEXT = NULL;
PFNGLSETMULTISAMPLEFVAMDPROC glad_glSetMultisamplefvAMD = NULL;
PFNGLSHADERBINARYPROC glad_glShaderBinary = NULL;
PFNGLSHADEROP1EXTPROC glad_glShaderOp1EXT = NULL;
PFNGLSHADEROP2EXTPROC glad_glShaderOp2EXT = NULL;
PFNGLSHADEROP3EXTPROC glad_glShaderOp3EXT = NULL;
PFNGLSHADERSOURCEPROC glad_glShaderSource = NULL;
PFNGLSHADERSOURCEARBPROC glad_glShaderSourceARB = NULL;
PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding = NULL;
PFNGLSIGNALSEMAPHOREEXTPROC glad_glSignalSemaphoreEXT = NULL;
PFNGLSIGNALVKFENCENVPROC glad_glSignalVkFenceNV = NULL;
PFNGLSIGNALVKSEMAPHORENVPROC glad_glSignalVkSemaphoreNV = NULL;
PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader = NULL;
PFNGLSPECIALIZESHADERARBPROC glad_glSpecializeShaderARB = NULL;
PFNGLSTATECAPTURENVPROC glad_glStateCaptureNV = NULL;
PFNGLSTENCILCLEARTAGEXTPROC glad_glStencilClearTagEXT = NULL;
PFNGLSTENCILFILLPATHINSTANCEDNVPROC glad_glStencilFillPathInstancedNV = NULL;
PFNGLSTENCILFILLPATHNVPROC glad_glStencilFillPathNV = NULL;
PFNGLSTENCILFUNCPROC glad_glStencilFunc = NULL;
PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate = NULL;
PFNGLSTENCILFUNCSEPARATEATIPROC glad_glStencilFuncSeparateATI = NULL;
PFNGLSTENCILMASKPROC glad_glStencilMask = NULL;
PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate = NULL;
PFNGLSTENCILOPPROC glad_glStencilOp = NULL;
PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate = NULL;
PFNGLSTENCILOPSEPARATEATIPROC glad_glStencilOpSeparateATI = NULL;
PFNGLSTENCILOPVALUEAMDPROC glad_glStencilOpValueAMD = NULL;
PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC glad_glStencilStrokePathInstancedNV = NULL;
PFNGLSTENCILSTROKEPATHNVPROC glad_glStencilStrokePathNV = NULL;
PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC glad_glStencilThenCoverFillPathInstancedNV = NULL;
PFNGLSTENCILTHENCOVERFILLPATHNVPROC glad_glStencilThenCoverFillPathNV = NULL;
PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC glad_glStencilThenCoverStrokePathInstancedNV = NULL;
PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC glad_glStencilThenCoverStrokePathNV = NULL;
PFNGLSUBPIXELPRECISIONBIASNVPROC glad_glSubpixelPrecisionBiasNV = NULL;
PFNGLSWIZZLEEXTPROC glad_glSwizzleEXT = NULL;
PFNGLSYNCTEXTUREINTELPROC glad_glSyncTextureINTEL = NULL;
PFNGLTANGENT3BEXTPROC glad_glTangent3bEXT = NULL;
PFNGLTANGENT3BVEXTPROC glad_glTangent3bvEXT = NULL;
PFNGLTANGENT3DEXTPROC glad_glTangent3dEXT = NULL;
PFNGLTANGENT3DVEXTPROC glad_glTangent3dvEXT = NULL;
PFNGLTANGENT3FEXTPROC glad_glTangent3fEXT = NULL;
PFNGLTANGENT3FVEXTPROC glad_glTangent3fvEXT = NULL;
PFNGLTANGENT3IEXTPROC glad_glTangent3iEXT = NULL;
PFNGLTANGENT3IVEXTPROC glad_glTangent3ivEXT = NULL;
PFNGLTANGENT3SEXTPROC glad_glTangent3sEXT = NULL;
PFNGLTANGENT3SVEXTPROC glad_glTangent3svEXT = NULL;
PFNGLTANGENTPOINTEREXTPROC glad_glTangentPointerEXT = NULL;
PFNGLTESSELLATIONFACTORAMDPROC glad_glTessellationFactorAMD = NULL;
PFNGLTESSELLATIONMODEAMDPROC glad_glTessellationModeAMD = NULL;
PFNGLTESTFENCEAPPLEPROC glad_glTestFenceAPPLE = NULL;
PFNGLTESTFENCENVPROC glad_glTestFenceNV = NULL;
PFNGLTESTOBJECTAPPLEPROC glad_glTestObjectAPPLE = NULL;
PFNGLTEXBUFFERPROC glad_glTexBuffer = NULL;
PFNGLTEXBUFFERARBPROC glad_glTexBufferARB = NULL;
PFNGLTEXBUFFEREXTPROC glad_glTexBufferEXT = NULL;
PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange = NULL;
PFNGLTEXBUMPPARAMETERFVATIPROC glad_glTexBumpParameterfvATI = NULL;
PFNGLTEXBUMPPARAMETERIVATIPROC glad_glTexBumpParameterivATI = NULL;
PFNGLTEXCOORD1HNVPROC glad_glTexCoord1hNV = NULL;
PFNGLTEXCOORD1HVNVPROC glad_glTexCoord1hvNV = NULL;
PFNGLTEXCOORD2HNVPROC glad_glTexCoord2hNV = NULL;
PFNGLTEXCOORD2HVNVPROC glad_glTexCoord2hvNV = NULL;
PFNGLTEXCOORD3HNVPROC glad_glTexCoord3hNV = NULL;
PFNGLTEXCOORD3HVNVPROC glad_glTexCoord3hvNV = NULL;
PFNGLTEXCOORD4HNVPROC glad_glTexCoord4hNV = NULL;
PFNGLTEXCOORD4HVNVPROC glad_glTexCoord4hvNV = NULL;
PFNGLTEXCOORDFORMATNVPROC glad_glTexCoordFormatNV = NULL;
PFNGLTEXCOORDPOINTEREXTPROC glad_glTexCoordPointerEXT = NULL;
PFNGLTEXCOORDPOINTERVINTELPROC glad_glTexCoordPointervINTEL = NULL;
PFNGLTEXIMAGE1DPROC glad_glTexImage1D = NULL;
PFNGLTEXIMAGE2DPROC glad_glTexImage2D = NULL;
PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample = NULL;
PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC glad_glTexImage2DMultisampleCoverageNV = NULL;
PFNGLTEXIMAGE3DPROC glad_glTexImage3D = NULL;
PFNGLTEXIMAGE3DEXTPROC glad_glTexImage3DEXT = NULL;
PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample = NULL;
PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC glad_glTexImage3DMultisampleCoverageNV = NULL;
PFNGLTEXPAGECOMMITMENTARBPROC glad_glTexPageCommitmentARB = NULL;
PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv = NULL;
PFNGLTEXPARAMETERIIVEXTPROC glad_glTexParameterIivEXT = NULL;
PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv = NULL;
PFNGLTEXPARAMETERIUIVEXTPROC glad_glTexParameterIuivEXT = NULL;
PFNGLTEXPARAMETERFPROC glad_glTexParameterf = NULL;
PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv = NULL;
PFNGLTEXPARAMETERIPROC glad_glTexParameteri = NULL;
PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv = NULL;
PFNGLTEXRENDERBUFFERNVPROC glad_glTexRenderbufferNV = NULL;
PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D = NULL;
PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D = NULL;
PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample = NULL;
PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D = NULL;
PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample = NULL;
PFNGLTEXSTORAGEMEM1DEXTPROC glad_glTexStorageMem1DEXT = NULL;
PFNGLTEXSTORAGEMEM2DEXTPROC glad_glTexStorageMem2DEXT = NULL;
PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC glad_glTexStorageMem2DMultisampleEXT = NULL;
PFNGLTEXSTORAGEMEM3DEXTPROC glad_glTexStorageMem3DEXT = NULL;
PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC glad_glTexStorageMem3DMultisampleEXT = NULL;
PFNGLTEXSTORAGESPARSEAMDPROC glad_glTexStorageSparseAMD = NULL;
PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D = NULL;
PFNGLTEXSUBIMAGE1DEXTPROC glad_glTexSubImage1DEXT = NULL;
PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D = NULL;
PFNGLTEXSUBIMAGE2DEXTPROC glad_glTexSubImage2DEXT = NULL;
PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D = NULL;
PFNGLTEXSUBIMAGE3DEXTPROC glad_glTexSubImage3DEXT = NULL;
PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier = NULL;
PFNGLTEXTUREBARRIERNVPROC glad_glTextureBarrierNV = NULL;
PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer = NULL;
PFNGLTEXTUREBUFFEREXTPROC glad_glTextureBufferEXT = NULL;
PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange = NULL;
PFNGLTEXTUREBUFFERRANGEEXTPROC glad_glTextureBufferRangeEXT = NULL;
PFNGLTEXTUREIMAGE1DEXTPROC glad_glTextureImage1DEXT = NULL;
PFNGLTEXTUREIMAGE2DEXTPROC glad_glTextureImage2DEXT = NULL;
PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC glad_glTextureImage2DMultisampleCoverageNV = NULL;
PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC glad_glTextureImage2DMultisampleNV = NULL;
PFNGLTEXTUREIMAGE3DEXTPROC glad_glTextureImage3DEXT = NULL;
PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC glad_glTextureImage3DMultisampleCoverageNV = NULL;
PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC glad_glTextureImage3DMultisampleNV = NULL;
PFNGLTEXTURELIGHTEXTPROC glad_glTextureLightEXT = NULL;
PFNGLTEXTUREMATERIALEXTPROC glad_glTextureMaterialEXT = NULL;
PFNGLTEXTURENORMALEXTPROC glad_glTextureNormalEXT = NULL;
PFNGLTEXTUREPAGECOMMITMENTEXTPROC glad_glTexturePageCommitmentEXT = NULL;
PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv = NULL;
PFNGLTEXTUREPARAMETERIIVEXTPROC glad_glTextureParameterIivEXT = NULL;
PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv = NULL;
PFNGLTEXTUREPARAMETERIUIVEXTPROC glad_glTextureParameterIuivEXT = NULL;
PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf = NULL;
PFNGLTEXTUREPARAMETERFEXTPROC glad_glTextureParameterfEXT = NULL;
PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv = NULL;
PFNGLTEXTUREPARAMETERFVEXTPROC glad_glTextureParameterfvEXT = NULL;
PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri = NULL;
PFNGLTEXTUREPARAMETERIEXTPROC glad_glTextureParameteriEXT = NULL;
PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv = NULL;
PFNGLTEXTUREPARAMETERIVEXTPROC glad_glTextureParameterivEXT = NULL;
PFNGLTEXTURERANGEAPPLEPROC glad_glTextureRangeAPPLE = NULL;
PFNGLTEXTURERENDERBUFFEREXTPROC glad_glTextureRenderbufferEXT = NULL;
PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D = NULL;
PFNGLTEXTURESTORAGE1DEXTPROC glad_glTextureStorage1DEXT = NULL;
PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D = NULL;
PFNGLTEXTURESTORAGE2DEXTPROC glad_glTextureStorage2DEXT = NULL;
PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample = NULL;
PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC glad_glTextureStorage2DMultisampleEXT = NULL;
PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D = NULL;
PFNGLTEXTURESTORAGE3DEXTPROC glad_glTextureStorage3DEXT = NULL;
PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample = NULL;
PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC glad_glTextureStorage3DMultisampleEXT = NULL;
PFNGLTEXTURESTORAGEMEM1DEXTPROC glad_glTextureStorageMem1DEXT = NULL;
PFNGLTEXTURESTORAGEMEM2DEXTPROC glad_glTextureStorageMem2DEXT = NULL;
PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC glad_glTextureStorageMem2DMultisampleEXT = NULL;
PFNGLTEXTURESTORAGEMEM3DEXTPROC glad_glTextureStorageMem3DEXT = NULL;
PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC glad_glTextureStorageMem3DMultisampleEXT = NULL;
PFNGLTEXTURESTORAGESPARSEAMDPROC glad_glTextureStorageSparseAMD = NULL;
PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D = NULL;
PFNGLTEXTURESUBIMAGE1DEXTPROC glad_glTextureSubImage1DEXT = NULL;
PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D = NULL;
PFNGLTEXTURESUBIMAGE2DEXTPROC glad_glTextureSubImage2DEXT = NULL;
PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D = NULL;
PFNGLTEXTURESUBIMAGE3DEXTPROC glad_glTextureSubImage3DEXT = NULL;
PFNGLTEXTUREVIEWPROC glad_glTextureView = NULL;
PFNGLTRACKMATRIXNVPROC glad_glTrackMatrixNV = NULL;
PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC glad_glTransformFeedbackAttribsNV = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange = NULL;
PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC glad_glTransformFeedbackStreamAttribsNV = NULL;
PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings = NULL;
PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC glad_glTransformFeedbackVaryingsEXT = NULL;
PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC glad_glTransformFeedbackVaryingsNV = NULL;
PFNGLTRANSFORMPATHNVPROC glad_glTransformPathNV = NULL;
PFNGLUNIFORM1DPROC glad_glUniform1d = NULL;
PFNGLUNIFORM1DVPROC glad_glUniform1dv = NULL;
PFNGLUNIFORM1FPROC glad_glUniform1f = NULL;
PFNGLUNIFORM1FARBPROC glad_glUniform1fARB = NULL;
PFNGLUNIFORM1FVPROC glad_glUniform1fv = NULL;
PFNGLUNIFORM1FVARBPROC glad_glUniform1fvARB = NULL;
PFNGLUNIFORM1IPROC glad_glUniform1i = NULL;
PFNGLUNIFORM1I64ARBPROC glad_glUniform1i64ARB = NULL;
PFNGLUNIFORM1I64NVPROC glad_glUniform1i64NV = NULL;
PFNGLUNIFORM1I64VARBPROC glad_glUniform1i64vARB = NULL;
PFNGLUNIFORM1I64VNVPROC glad_glUniform1i64vNV = NULL;
PFNGLUNIFORM1IARBPROC glad_glUniform1iARB = NULL;
PFNGLUNIFORM1IVPROC glad_glUniform1iv = NULL;
PFNGLUNIFORM1IVARBPROC glad_glUniform1ivARB = NULL;
PFNGLUNIFORM1UIPROC glad_glUniform1ui = NULL;
PFNGLUNIFORM1UI64ARBPROC glad_glUniform1ui64ARB = NULL;
PFNGLUNIFORM1UI64NVPROC glad_glUniform1ui64NV = NULL;
PFNGLUNIFORM1UI64VARBPROC glad_glUniform1ui64vARB = NULL;
PFNGLUNIFORM1UI64VNVPROC glad_glUniform1ui64vNV = NULL;
PFNGLUNIFORM1UIEXTPROC glad_glUniform1uiEXT = NULL;
PFNGLUNIFORM1UIVPROC glad_glUniform1uiv = NULL;
PFNGLUNIFORM1UIVEXTPROC glad_glUniform1uivEXT = NULL;
PFNGLUNIFORM2DPROC glad_glUniform2d = NULL;
PFNGLUNIFORM2DVPROC glad_glUniform2dv = NULL;
PFNGLUNIFORM2FPROC glad_glUniform2f = NULL;
PFNGLUNIFORM2FARBPROC glad_glUniform2fARB = NULL;
PFNGLUNIFORM2FVPROC glad_glUniform2fv = NULL;
PFNGLUNIFORM2FVARBPROC glad_glUniform2fvARB = NULL;
PFNGLUNIFORM2IPROC glad_glUniform2i = NULL;
PFNGLUNIFORM2I64ARBPROC glad_glUniform2i64ARB = NULL;
PFNGLUNIFORM2I64NVPROC glad_glUniform2i64NV = NULL;
PFNGLUNIFORM2I64VARBPROC glad_glUniform2i64vARB = NULL;
PFNGLUNIFORM2I64VNVPROC glad_glUniform2i64vNV = NULL;
PFNGLUNIFORM2IARBPROC glad_glUniform2iARB = NULL;
PFNGLUNIFORM2IVPROC glad_glUniform2iv = NULL;
PFNGLUNIFORM2IVARBPROC glad_glUniform2ivARB = NULL;
PFNGLUNIFORM2UIPROC glad_glUniform2ui = NULL;
PFNGLUNIFORM2UI64ARBPROC glad_glUniform2ui64ARB = NULL;
PFNGLUNIFORM2UI64NVPROC glad_glUniform2ui64NV = NULL;
PFNGLUNIFORM2UI64VARBPROC glad_glUniform2ui64vARB = NULL;
PFNGLUNIFORM2UI64VNVPROC glad_glUniform2ui64vNV = NULL;
PFNGLUNIFORM2UIEXTPROC glad_glUniform2uiEXT = NULL;
PFNGLUNIFORM2UIVPROC glad_glUniform2uiv = NULL;
PFNGLUNIFORM2UIVEXTPROC glad_glUniform2uivEXT = NULL;
PFNGLUNIFORM3DPROC glad_glUniform3d = NULL;
PFNGLUNIFORM3DVPROC glad_glUniform3dv = NULL;
PFNGLUNIFORM3FPROC glad_glUniform3f = NULL;
PFNGLUNIFORM3FARBPROC glad_glUniform3fARB = NULL;
PFNGLUNIFORM3FVPROC glad_glUniform3fv = NULL;
PFNGLUNIFORM3FVARBPROC glad_glUniform3fvARB = NULL;
PFNGLUNIFORM3IPROC glad_glUniform3i = NULL;
PFNGLUNIFORM3I64ARBPROC glad_glUniform3i64ARB = NULL;
PFNGLUNIFORM3I64NVPROC glad_glUniform3i64NV = NULL;
PFNGLUNIFORM3I64VARBPROC glad_glUniform3i64vARB = NULL;
PFNGLUNIFORM3I64VNVPROC glad_glUniform3i64vNV = NULL;
PFNGLUNIFORM3IARBPROC glad_glUniform3iARB = NULL;
PFNGLUNIFORM3IVPROC glad_glUniform3iv = NULL;
PFNGLUNIFORM3IVARBPROC glad_glUniform3ivARB = NULL;
PFNGLUNIFORM3UIPROC glad_glUniform3ui = NULL;
PFNGLUNIFORM3UI64ARBPROC glad_glUniform3ui64ARB = NULL;
PFNGLUNIFORM3UI64NVPROC glad_glUniform3ui64NV = NULL;
PFNGLUNIFORM3UI64VARBPROC glad_glUniform3ui64vARB = NULL;
PFNGLUNIFORM3UI64VNVPROC glad_glUniform3ui64vNV = NULL;
PFNGLUNIFORM3UIEXTPROC glad_glUniform3uiEXT = NULL;
PFNGLUNIFORM3UIVPROC glad_glUniform3uiv = NULL;
PFNGLUNIFORM3UIVEXTPROC glad_glUniform3uivEXT = NULL;
PFNGLUNIFORM4DPROC glad_glUniform4d = NULL;
PFNGLUNIFORM4DVPROC glad_glUniform4dv = NULL;
PFNGLUNIFORM4FPROC glad_glUniform4f = NULL;
PFNGLUNIFORM4FARBPROC glad_glUniform4fARB = NULL;
PFNGLUNIFORM4FVPROC glad_glUniform4fv = NULL;
PFNGLUNIFORM4FVARBPROC glad_glUniform4fvARB = NULL;
PFNGLUNIFORM4IPROC glad_glUniform4i = NULL;
PFNGLUNIFORM4I64ARBPROC glad_glUniform4i64ARB = NULL;
PFNGLUNIFORM4I64NVPROC glad_glUniform4i64NV = NULL;
PFNGLUNIFORM4I64VARBPROC glad_glUniform4i64vARB = NULL;
PFNGLUNIFORM4I64VNVPROC glad_glUniform4i64vNV = NULL;
PFNGLUNIFORM4IARBPROC glad_glUniform4iARB = NULL;
PFNGLUNIFORM4IVPROC glad_glUniform4iv = NULL;
PFNGLUNIFORM4IVARBPROC glad_glUniform4ivARB = NULL;
PFNGLUNIFORM4UIPROC glad_glUniform4ui = NULL;
PFNGLUNIFORM4UI64ARBPROC glad_glUniform4ui64ARB = NULL;
PFNGLUNIFORM4UI64NVPROC glad_glUniform4ui64NV = NULL;
PFNGLUNIFORM4UI64VARBPROC glad_glUniform4ui64vARB = NULL;
PFNGLUNIFORM4UI64VNVPROC glad_glUniform4ui64vNV = NULL;
PFNGLUNIFORM4UIEXTPROC glad_glUniform4uiEXT = NULL;
PFNGLUNIFORM4UIVPROC glad_glUniform4uiv = NULL;
PFNGLUNIFORM4UIVEXTPROC glad_glUniform4uivEXT = NULL;
PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding = NULL;
PFNGLUNIFORMBUFFEREXTPROC glad_glUniformBufferEXT = NULL;
PFNGLUNIFORMHANDLEUI64ARBPROC glad_glUniformHandleui64ARB = NULL;
PFNGLUNIFORMHANDLEUI64NVPROC glad_glUniformHandleui64NV = NULL;
PFNGLUNIFORMHANDLEUI64VARBPROC glad_glUniformHandleui64vARB = NULL;
PFNGLUNIFORMHANDLEUI64VNVPROC glad_glUniformHandleui64vNV = NULL;
PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv = NULL;
PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv = NULL;
PFNGLUNIFORMMATRIX2FVARBPROC glad_glUniformMatrix2fvARB = NULL;
PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv = NULL;
PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv = NULL;
PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv = NULL;
PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv = NULL;
PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv = NULL;
PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv = NULL;
PFNGLUNIFORMMATRIX3FVARBPROC glad_glUniformMatrix3fvARB = NULL;
PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv = NULL;
PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv = NULL;
PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv = NULL;
PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv = NULL;
PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv = NULL;
PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv = NULL;
PFNGLUNIFORMMATRIX4FVARBPROC glad_glUniformMatrix4fvARB = NULL;
PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv = NULL;
PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv = NULL;
PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv = NULL;
PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv = NULL;
PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv = NULL;
PFNGLUNIFORMUI64NVPROC glad_glUniformui64NV = NULL;
PFNGLUNIFORMUI64VNVPROC glad_glUniformui64vNV = NULL;
PFNGLUNLOCKARRAYSEXTPROC glad_glUnlockArraysEXT = NULL;
PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer = NULL;
PFNGLUNMAPBUFFERARBPROC glad_glUnmapBufferARB = NULL;
PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer = NULL;
PFNGLUNMAPNAMEDBUFFEREXTPROC glad_glUnmapNamedBufferEXT = NULL;
PFNGLUNMAPOBJECTBUFFERATIPROC glad_glUnmapObjectBufferATI = NULL;
PFNGLUNMAPTEXTURE2DINTELPROC glad_glUnmapTexture2DINTEL = NULL;
PFNGLUPDATEOBJECTBUFFERATIPROC glad_glUpdateObjectBufferATI = NULL;
PFNGLUSEPROGRAMPROC glad_glUseProgram = NULL;
PFNGLUSEPROGRAMOBJECTARBPROC glad_glUseProgramObjectARB = NULL;
PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages = NULL;
PFNGLUSESHADERPROGRAMEXTPROC glad_glUseShaderProgramEXT = NULL;
PFNGLVDPAUFININVPROC glad_glVDPAUFiniNV = NULL;
PFNGLVDPAUGETSURFACEIVNVPROC glad_glVDPAUGetSurfaceivNV = NULL;
PFNGLVDPAUINITNVPROC glad_glVDPAUInitNV = NULL;
PFNGLVDPAUISSURFACENVPROC glad_glVDPAUIsSurfaceNV = NULL;
PFNGLVDPAUMAPSURFACESNVPROC glad_glVDPAUMapSurfacesNV = NULL;
PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC glad_glVDPAURegisterOutputSurfaceNV = NULL;
PFNGLVDPAUREGISTERVIDEOSURFACENVPROC glad_glVDPAURegisterVideoSurfaceNV = NULL;
PFNGLVDPAUSURFACEACCESSNVPROC glad_glVDPAUSurfaceAccessNV = NULL;
PFNGLVDPAUUNMAPSURFACESNVPROC glad_glVDPAUUnmapSurfacesNV = NULL;
PFNGLVDPAUUNREGISTERSURFACENVPROC glad_glVDPAUUnregisterSurfaceNV = NULL;
PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram = NULL;
PFNGLVALIDATEPROGRAMARBPROC glad_glValidateProgramARB = NULL;
PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline = NULL;
PFNGLVARIANTARRAYOBJECTATIPROC glad_glVariantArrayObjectATI = NULL;
PFNGLVARIANTPOINTEREXTPROC glad_glVariantPointerEXT = NULL;
PFNGLVARIANTBVEXTPROC glad_glVariantbvEXT = NULL;
PFNGLVARIANTDVEXTPROC glad_glVariantdvEXT = NULL;
PFNGLVARIANTFVEXTPROC glad_glVariantfvEXT = NULL;
PFNGLVARIANTIVEXTPROC glad_glVariantivEXT = NULL;
PFNGLVARIANTSVEXTPROC glad_glVariantsvEXT = NULL;
PFNGLVARIANTUBVEXTPROC glad_glVariantubvEXT = NULL;
PFNGLVARIANTUIVEXTPROC glad_glVariantuivEXT = NULL;
PFNGLVARIANTUSVEXTPROC glad_glVariantusvEXT = NULL;
PFNGLVERTEX2HNVPROC glad_glVertex2hNV = NULL;
PFNGLVERTEX2HVNVPROC glad_glVertex2hvNV = NULL;
PFNGLVERTEX3HNVPROC glad_glVertex3hNV = NULL;
PFNGLVERTEX3HVNVPROC glad_glVertex3hvNV = NULL;
PFNGLVERTEX4HNVPROC glad_glVertex4hNV = NULL;
PFNGLVERTEX4HVNVPROC glad_glVertex4hvNV = NULL;
PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding = NULL;
PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat = NULL;
PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat = NULL;
PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat = NULL;
PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC glad_glVertexArrayBindVertexBufferEXT = NULL;
PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor = NULL;
PFNGLVERTEXARRAYCOLOROFFSETEXTPROC glad_glVertexArrayColorOffsetEXT = NULL;
PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC glad_glVertexArrayEdgeFlagOffsetEXT = NULL;
PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer = NULL;
PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC glad_glVertexArrayFogCoordOffsetEXT = NULL;
PFNGLVERTEXARRAYINDEXOFFSETEXTPROC glad_glVertexArrayIndexOffsetEXT = NULL;
PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC glad_glVertexArrayMultiTexCoordOffsetEXT = NULL;
PFNGLVERTEXARRAYNORMALOFFSETEXTPROC glad_glVertexArrayNormalOffsetEXT = NULL;
PFNGLVERTEXARRAYPARAMETERIAPPLEPROC glad_glVertexArrayParameteriAPPLE = NULL;
PFNGLVERTEXARRAYRANGEAPPLEPROC glad_glVertexArrayRangeAPPLE = NULL;
PFNGLVERTEXARRAYRANGENVPROC glad_glVertexArrayRangeNV = NULL;
PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC glad_glVertexArraySecondaryColorOffsetEXT = NULL;
PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC glad_glVertexArrayTexCoordOffsetEXT = NULL;
PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC glad_glVertexArrayVertexAttribBindingEXT = NULL;
PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC glad_glVertexArrayVertexAttribDivisorEXT = NULL;
PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC glad_glVertexArrayVertexAttribFormatEXT = NULL;
PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC glad_glVertexArrayVertexAttribIFormatEXT = NULL;
PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC glad_glVertexArrayVertexAttribIOffsetEXT = NULL;
PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC glad_glVertexArrayVertexAttribLFormatEXT = NULL;
PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC glad_glVertexArrayVertexAttribLOffsetEXT = NULL;
PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC glad_glVertexArrayVertexAttribOffsetEXT = NULL;
PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC glad_glVertexArrayVertexBindingDivisorEXT = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers = NULL;
PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC glad_glVertexArrayVertexOffsetEXT = NULL;
PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d = NULL;
PFNGLVERTEXATTRIB1DARBPROC glad_glVertexAttrib1dARB = NULL;
PFNGLVERTEXATTRIB1DNVPROC glad_glVertexAttrib1dNV = NULL;
PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv = NULL;
PFNGLVERTEXATTRIB1DVARBPROC glad_glVertexAttrib1dvARB = NULL;
PFNGLVERTEXATTRIB1DVNVPROC glad_glVertexAttrib1dvNV = NULL;
PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f = NULL;
PFNGLVERTEXATTRIB1FARBPROC glad_glVertexAttrib1fARB = NULL;
PFNGLVERTEXATTRIB1FNVPROC glad_glVertexAttrib1fNV = NULL;
PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv = NULL;
PFNGLVERTEXATTRIB1FVARBPROC glad_glVertexAttrib1fvARB = NULL;
PFNGLVERTEXATTRIB1FVNVPROC glad_glVertexAttrib1fvNV = NULL;
PFNGLVERTEXATTRIB1HNVPROC glad_glVertexAttrib1hNV = NULL;
PFNGLVERTEXATTRIB1HVNVPROC glad_glVertexAttrib1hvNV = NULL;
PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s = NULL;
PFNGLVERTEXATTRIB1SARBPROC glad_glVertexAttrib1sARB = NULL;
PFNGLVERTEXATTRIB1SNVPROC glad_glVertexAttrib1sNV = NULL;
PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv = NULL;
PFNGLVERTEXATTRIB1SVARBPROC glad_glVertexAttrib1svARB = NULL;
PFNGLVERTEXATTRIB1SVNVPROC glad_glVertexAttrib1svNV = NULL;
PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d = NULL;
PFNGLVERTEXATTRIB2DARBPROC glad_glVertexAttrib2dARB = NULL;
PFNGLVERTEXATTRIB2DNVPROC glad_glVertexAttrib2dNV = NULL;
PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv = NULL;
PFNGLVERTEXATTRIB2DVARBPROC glad_glVertexAttrib2dvARB = NULL;
PFNGLVERTEXATTRIB2DVNVPROC glad_glVertexAttrib2dvNV = NULL;
PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f = NULL;
PFNGLVERTEXATTRIB2FARBPROC glad_glVertexAttrib2fARB = NULL;
PFNGLVERTEXATTRIB2FNVPROC glad_glVertexAttrib2fNV = NULL;
PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv = NULL;
PFNGLVERTEXATTRIB2FVARBPROC glad_glVertexAttrib2fvARB = NULL;
PFNGLVERTEXATTRIB2FVNVPROC glad_glVertexAttrib2fvNV = NULL;
PFNGLVERTEXATTRIB2HNVPROC glad_glVertexAttrib2hNV = NULL;
PFNGLVERTEXATTRIB2HVNVPROC glad_glVertexAttrib2hvNV = NULL;
PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s = NULL;
PFNGLVERTEXATTRIB2SARBPROC glad_glVertexAttrib2sARB = NULL;
PFNGLVERTEXATTRIB2SNVPROC glad_glVertexAttrib2sNV = NULL;
PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv = NULL;
PFNGLVERTEXATTRIB2SVARBPROC glad_glVertexAttrib2svARB = NULL;
PFNGLVERTEXATTRIB2SVNVPROC glad_glVertexAttrib2svNV = NULL;
PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d = NULL;
PFNGLVERTEXATTRIB3DARBPROC glad_glVertexAttrib3dARB = NULL;
PFNGLVERTEXATTRIB3DNVPROC glad_glVertexAttrib3dNV = NULL;
PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv = NULL;
PFNGLVERTEXATTRIB3DVARBPROC glad_glVertexAttrib3dvARB = NULL;
PFNGLVERTEXATTRIB3DVNVPROC glad_glVertexAttrib3dvNV = NULL;
PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f = NULL;
PFNGLVERTEXATTRIB3FARBPROC glad_glVertexAttrib3fARB = NULL;
PFNGLVERTEXATTRIB3FNVPROC glad_glVertexAttrib3fNV = NULL;
PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv = NULL;
PFNGLVERTEXATTRIB3FVARBPROC glad_glVertexAttrib3fvARB = NULL;
PFNGLVERTEXATTRIB3FVNVPROC glad_glVertexAttrib3fvNV = NULL;
PFNGLVERTEXATTRIB3HNVPROC glad_glVertexAttrib3hNV = NULL;
PFNGLVERTEXATTRIB3HVNVPROC glad_glVertexAttrib3hvNV = NULL;
PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s = NULL;
PFNGLVERTEXATTRIB3SARBPROC glad_glVertexAttrib3sARB = NULL;
PFNGLVERTEXATTRIB3SNVPROC glad_glVertexAttrib3sNV = NULL;
PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv = NULL;
PFNGLVERTEXATTRIB3SVARBPROC glad_glVertexAttrib3svARB = NULL;
PFNGLVERTEXATTRIB3SVNVPROC glad_glVertexAttrib3svNV = NULL;
PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv = NULL;
PFNGLVERTEXATTRIB4NBVARBPROC glad_glVertexAttrib4NbvARB = NULL;
PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv = NULL;
PFNGLVERTEXATTRIB4NIVARBPROC glad_glVertexAttrib4NivARB = NULL;
PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv = NULL;
PFNGLVERTEXATTRIB4NSVARBPROC glad_glVertexAttrib4NsvARB = NULL;
PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub = NULL;
PFNGLVERTEXATTRIB4NUBARBPROC glad_glVertexAttrib4NubARB = NULL;
PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv = NULL;
PFNGLVERTEXATTRIB4NUBVARBPROC glad_glVertexAttrib4NubvARB = NULL;
PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv = NULL;
PFNGLVERTEXATTRIB4NUIVARBPROC glad_glVertexAttrib4NuivARB = NULL;
PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv = NULL;
PFNGLVERTEXATTRIB4NUSVARBPROC glad_glVertexAttrib4NusvARB = NULL;
PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv = NULL;
PFNGLVERTEXATTRIB4BVARBPROC glad_glVertexAttrib4bvARB = NULL;
PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d = NULL;
PFNGLVERTEXATTRIB4DARBPROC glad_glVertexAttrib4dARB = NULL;
PFNGLVERTEXATTRIB4DNVPROC glad_glVertexAttrib4dNV = NULL;
PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv = NULL;
PFNGLVERTEXATTRIB4DVARBPROC glad_glVertexAttrib4dvARB = NULL;
PFNGLVERTEXATTRIB4DVNVPROC glad_glVertexAttrib4dvNV = NULL;
PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f = NULL;
PFNGLVERTEXATTRIB4FARBPROC glad_glVertexAttrib4fARB = NULL;
PFNGLVERTEXATTRIB4FNVPROC glad_glVertexAttrib4fNV = NULL;
PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv = NULL;
PFNGLVERTEXATTRIB4FVARBPROC glad_glVertexAttrib4fvARB = NULL;
PFNGLVERTEXATTRIB4FVNVPROC glad_glVertexAttrib4fvNV = NULL;
PFNGLVERTEXATTRIB4HNVPROC glad_glVertexAttrib4hNV = NULL;
PFNGLVERTEXATTRIB4HVNVPROC glad_glVertexAttrib4hvNV = NULL;
PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv = NULL;
PFNGLVERTEXATTRIB4IVARBPROC glad_glVertexAttrib4ivARB = NULL;
PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s = NULL;
PFNGLVERTEXATTRIB4SARBPROC glad_glVertexAttrib4sARB = NULL;
PFNGLVERTEXATTRIB4SNVPROC glad_glVertexAttrib4sNV = NULL;
PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv = NULL;
PFNGLVERTEXATTRIB4SVARBPROC glad_glVertexAttrib4svARB = NULL;
PFNGLVERTEXATTRIB4SVNVPROC glad_glVertexAttrib4svNV = NULL;
PFNGLVERTEXATTRIB4UBNVPROC glad_glVertexAttrib4ubNV = NULL;
PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv = NULL;
PFNGLVERTEXATTRIB4UBVARBPROC glad_glVertexAttrib4ubvARB = NULL;
PFNGLVERTEXATTRIB4UBVNVPROC glad_glVertexAttrib4ubvNV = NULL;
PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv = NULL;
PFNGLVERTEXATTRIB4UIVARBPROC glad_glVertexAttrib4uivARB = NULL;
PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv = NULL;
PFNGLVERTEXATTRIB4USVARBPROC glad_glVertexAttrib4usvARB = NULL;
PFNGLVERTEXATTRIBARRAYOBJECTATIPROC glad_glVertexAttribArrayObjectATI = NULL;
PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding = NULL;
PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor = NULL;
PFNGLVERTEXATTRIBDIVISORARBPROC glad_glVertexAttribDivisorARB = NULL;
PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat = NULL;
PFNGLVERTEXATTRIBFORMATNVPROC glad_glVertexAttribFormatNV = NULL;
PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i = NULL;
PFNGLVERTEXATTRIBI1IEXTPROC glad_glVertexAttribI1iEXT = NULL;
PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv = NULL;
PFNGLVERTEXATTRIBI1IVEXTPROC glad_glVertexAttribI1ivEXT = NULL;
PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui = NULL;
PFNGLVERTEXATTRIBI1UIEXTPROC glad_glVertexAttribI1uiEXT = NULL;
PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv = NULL;
PFNGLVERTEXATTRIBI1UIVEXTPROC glad_glVertexAttribI1uivEXT = NULL;
PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i = NULL;
PFNGLVERTEXATTRIBI2IEXTPROC glad_glVertexAttribI2iEXT = NULL;
PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv = NULL;
PFNGLVERTEXATTRIBI2IVEXTPROC glad_glVertexAttribI2ivEXT = NULL;
PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui = NULL;
PFNGLVERTEXATTRIBI2UIEXTPROC glad_glVertexAttribI2uiEXT = NULL;
PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv = NULL;
PFNGLVERTEXATTRIBI2UIVEXTPROC glad_glVertexAttribI2uivEXT = NULL;
PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i = NULL;
PFNGLVERTEXATTRIBI3IEXTPROC glad_glVertexAttribI3iEXT = NULL;
PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv = NULL;
PFNGLVERTEXATTRIBI3IVEXTPROC glad_glVertexAttribI3ivEXT = NULL;
PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui = NULL;
PFNGLVERTEXATTRIBI3UIEXTPROC glad_glVertexAttribI3uiEXT = NULL;
PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv = NULL;
PFNGLVERTEXATTRIBI3UIVEXTPROC glad_glVertexAttribI3uivEXT = NULL;
PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv = NULL;
PFNGLVERTEXATTRIBI4BVEXTPROC glad_glVertexAttribI4bvEXT = NULL;
PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i = NULL;
PFNGLVERTEXATTRIBI4IEXTPROC glad_glVertexAttribI4iEXT = NULL;
PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv = NULL;
PFNGLVERTEXATTRIBI4IVEXTPROC glad_glVertexAttribI4ivEXT = NULL;
PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv = NULL;
PFNGLVERTEXATTRIBI4SVEXTPROC glad_glVertexAttribI4svEXT = NULL;
PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv = NULL;
PFNGLVERTEXATTRIBI4UBVEXTPROC glad_glVertexAttribI4ubvEXT = NULL;
PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui = NULL;
PFNGLVERTEXATTRIBI4UIEXTPROC glad_glVertexAttribI4uiEXT = NULL;
PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv = NULL;
PFNGLVERTEXATTRIBI4UIVEXTPROC glad_glVertexAttribI4uivEXT = NULL;
PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv = NULL;
PFNGLVERTEXATTRIBI4USVEXTPROC glad_glVertexAttribI4usvEXT = NULL;
PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat = NULL;
PFNGLVERTEXATTRIBIFORMATNVPROC glad_glVertexAttribIFormatNV = NULL;
PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer = NULL;
PFNGLVERTEXATTRIBIPOINTEREXTPROC glad_glVertexAttribIPointerEXT = NULL;
PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d = NULL;
PFNGLVERTEXATTRIBL1DEXTPROC glad_glVertexAttribL1dEXT = NULL;
PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv = NULL;
PFNGLVERTEXATTRIBL1DVEXTPROC glad_glVertexAttribL1dvEXT = NULL;
PFNGLVERTEXATTRIBL1I64NVPROC glad_glVertexAttribL1i64NV = NULL;
PFNGLVERTEXATTRIBL1I64VNVPROC glad_glVertexAttribL1i64vNV = NULL;
PFNGLVERTEXATTRIBL1UI64ARBPROC glad_glVertexAttribL1ui64ARB = NULL;
PFNGLVERTEXATTRIBL1UI64NVPROC glad_glVertexAttribL1ui64NV = NULL;
PFNGLVERTEXATTRIBL1UI64VARBPROC glad_glVertexAttribL1ui64vARB = NULL;
PFNGLVERTEXATTRIBL1UI64VNVPROC glad_glVertexAttribL1ui64vNV = NULL;
PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d = NULL;
PFNGLVERTEXATTRIBL2DEXTPROC glad_glVertexAttribL2dEXT = NULL;
PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv = NULL;
PFNGLVERTEXATTRIBL2DVEXTPROC glad_glVertexAttribL2dvEXT = NULL;
PFNGLVERTEXATTRIBL2I64NVPROC glad_glVertexAttribL2i64NV = NULL;
PFNGLVERTEXATTRIBL2I64VNVPROC glad_glVertexAttribL2i64vNV = NULL;
PFNGLVERTEXATTRIBL2UI64NVPROC glad_glVertexAttribL2ui64NV = NULL;
PFNGLVERTEXATTRIBL2UI64VNVPROC glad_glVertexAttribL2ui64vNV = NULL;
PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d = NULL;
PFNGLVERTEXATTRIBL3DEXTPROC glad_glVertexAttribL3dEXT = NULL;
PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv = NULL;
PFNGLVERTEXATTRIBL3DVEXTPROC glad_glVertexAttribL3dvEXT = NULL;
PFNGLVERTEXATTRIBL3I64NVPROC glad_glVertexAttribL3i64NV = NULL;
PFNGLVERTEXATTRIBL3I64VNVPROC glad_glVertexAttribL3i64vNV = NULL;
PFNGLVERTEXATTRIBL3UI64NVPROC glad_glVertexAttribL3ui64NV = NULL;
PFNGLVERTEXATTRIBL3UI64VNVPROC glad_glVertexAttribL3ui64vNV = NULL;
PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d = NULL;
PFNGLVERTEXATTRIBL4DEXTPROC glad_glVertexAttribL4dEXT = NULL;
PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv = NULL;
PFNGLVERTEXATTRIBL4DVEXTPROC glad_glVertexAttribL4dvEXT = NULL;
PFNGLVERTEXATTRIBL4I64NVPROC glad_glVertexAttribL4i64NV = NULL;
PFNGLVERTEXATTRIBL4I64VNVPROC glad_glVertexAttribL4i64vNV = NULL;
PFNGLVERTEXATTRIBL4UI64NVPROC glad_glVertexAttribL4ui64NV = NULL;
PFNGLVERTEXATTRIBL4UI64VNVPROC glad_glVertexAttribL4ui64vNV = NULL;
PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat = NULL;
PFNGLVERTEXATTRIBLFORMATNVPROC glad_glVertexAttribLFormatNV = NULL;
PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer = NULL;
PFNGLVERTEXATTRIBLPOINTEREXTPROC glad_glVertexAttribLPointerEXT = NULL;
PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui = NULL;
PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv = NULL;
PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui = NULL;
PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv = NULL;
PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui = NULL;
PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv = NULL;
PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui = NULL;
PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv = NULL;
PFNGLVERTEXATTRIBPARAMETERIAMDPROC glad_glVertexAttribParameteriAMD = NULL;
PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer = NULL;
PFNGLVERTEXATTRIBPOINTERARBPROC glad_glVertexAttribPointerARB = NULL;
PFNGLVERTEXATTRIBPOINTERNVPROC glad_glVertexAttribPointerNV = NULL;
PFNGLVERTEXATTRIBS1DVNVPROC glad_glVertexAttribs1dvNV = NULL;
PFNGLVERTEXATTRIBS1FVNVPROC glad_glVertexAttribs1fvNV = NULL;
PFNGLVERTEXATTRIBS1HVNVPROC glad_glVertexAttribs1hvNV = NULL;
PFNGLVERTEXATTRIBS1SVNVPROC glad_glVertexAttribs1svNV = NULL;
PFNGLVERTEXATTRIBS2DVNVPROC glad_glVertexAttribs2dvNV = NULL;
PFNGLVERTEXATTRIBS2FVNVPROC glad_glVertexAttribs2fvNV = NULL;
PFNGLVERTEXATTRIBS2HVNVPROC glad_glVertexAttribs2hvNV = NULL;
PFNGLVERTEXATTRIBS2SVNVPROC glad_glVertexAttribs2svNV = NULL;
PFNGLVERTEXATTRIBS3DVNVPROC glad_glVertexAttribs3dvNV = NULL;
PFNGLVERTEXATTRIBS3FVNVPROC glad_glVertexAttribs3fvNV = NULL;
PFNGLVERTEXATTRIBS3HVNVPROC glad_glVertexAttribs3hvNV = NULL;
PFNGLVERTEXATTRIBS3SVNVPROC glad_glVertexAttribs3svNV = NULL;
PFNGLVERTEXATTRIBS4DVNVPROC glad_glVertexAttribs4dvNV = NULL;
PFNGLVERTEXATTRIBS4FVNVPROC glad_glVertexAttribs4fvNV = NULL;
PFNGLVERTEXATTRIBS4HVNVPROC glad_glVertexAttribs4hvNV = NULL;
PFNGLVERTEXATTRIBS4SVNVPROC glad_glVertexAttribs4svNV = NULL;
PFNGLVERTEXATTRIBS4UBVNVPROC glad_glVertexAttribs4ubvNV = NULL;
PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor = NULL;
PFNGLVERTEXBLENDARBPROC glad_glVertexBlendARB = NULL;
PFNGLVERTEXBLENDENVFATIPROC glad_glVertexBlendEnvfATI = NULL;
PFNGLVERTEXBLENDENVIATIPROC glad_glVertexBlendEnviATI = NULL;
PFNGLVERTEXFORMATNVPROC glad_glVertexFormatNV = NULL;
PFNGLVERTEXPOINTEREXTPROC glad_glVertexPointerEXT = NULL;
PFNGLVERTEXPOINTERVINTELPROC glad_glVertexPointervINTEL = NULL;
PFNGLVERTEXSTREAM1DATIPROC glad_glVertexStream1dATI = NULL;
PFNGLVERTEXSTREAM1DVATIPROC glad_glVertexStream1dvATI = NULL;
PFNGLVERTEXSTREAM1FATIPROC glad_glVertexStream1fATI = NULL;
PFNGLVERTEXSTREAM1FVATIPROC glad_glVertexStream1fvATI = NULL;
PFNGLVERTEXSTREAM1IATIPROC glad_glVertexStream1iATI = NULL;
PFNGLVERTEXSTREAM1IVATIPROC glad_glVertexStream1ivATI = NULL;
PFNGLVERTEXSTREAM1SATIPROC glad_glVertexStream1sATI = NULL;
PFNGLVERTEXSTREAM1SVATIPROC glad_glVertexStream1svATI = NULL;
PFNGLVERTEXSTREAM2DATIPROC glad_glVertexStream2dATI = NULL;
PFNGLVERTEXSTREAM2DVATIPROC glad_glVertexStream2dvATI = NULL;
PFNGLVERTEXSTREAM2FATIPROC glad_glVertexStream2fATI = NULL;
PFNGLVERTEXSTREAM2FVATIPROC glad_glVertexStream2fvATI = NULL;
PFNGLVERTEXSTREAM2IATIPROC glad_glVertexStream2iATI = NULL;
PFNGLVERTEXSTREAM2IVATIPROC glad_glVertexStream2ivATI = NULL;
PFNGLVERTEXSTREAM2SATIPROC glad_glVertexStream2sATI = NULL;
PFNGLVERTEXSTREAM2SVATIPROC glad_glVertexStream2svATI = NULL;
PFNGLVERTEXSTREAM3DATIPROC glad_glVertexStream3dATI = NULL;
PFNGLVERTEXSTREAM3DVATIPROC glad_glVertexStream3dvATI = NULL;
PFNGLVERTEXSTREAM3FATIPROC glad_glVertexStream3fATI = NULL;
PFNGLVERTEXSTREAM3FVATIPROC glad_glVertexStream3fvATI = NULL;
PFNGLVERTEXSTREAM3IATIPROC glad_glVertexStream3iATI = NULL;
PFNGLVERTEXSTREAM3IVATIPROC glad_glVertexStream3ivATI = NULL;
PFNGLVERTEXSTREAM3SATIPROC glad_glVertexStream3sATI = NULL;
PFNGLVERTEXSTREAM3SVATIPROC glad_glVertexStream3svATI = NULL;
PFNGLVERTEXSTREAM4DATIPROC glad_glVertexStream4dATI = NULL;
PFNGLVERTEXSTREAM4DVATIPROC glad_glVertexStream4dvATI = NULL;
PFNGLVERTEXSTREAM4FATIPROC glad_glVertexStream4fATI = NULL;
PFNGLVERTEXSTREAM4FVATIPROC glad_glVertexStream4fvATI = NULL;
PFNGLVERTEXSTREAM4IATIPROC glad_glVertexStream4iATI = NULL;
PFNGLVERTEXSTREAM4IVATIPROC glad_glVertexStream4ivATI = NULL;
PFNGLVERTEXSTREAM4SATIPROC glad_glVertexStream4sATI = NULL;
PFNGLVERTEXSTREAM4SVATIPROC glad_glVertexStream4svATI = NULL;
PFNGLVERTEXWEIGHTPOINTEREXTPROC glad_glVertexWeightPointerEXT = NULL;
PFNGLVERTEXWEIGHTFEXTPROC glad_glVertexWeightfEXT = NULL;
PFNGLVERTEXWEIGHTFVEXTPROC glad_glVertexWeightfvEXT = NULL;
PFNGLVERTEXWEIGHTHNVPROC glad_glVertexWeighthNV = NULL;
PFNGLVERTEXWEIGHTHVNVPROC glad_glVertexWeighthvNV = NULL;
PFNGLVIDEOCAPTURENVPROC glad_glVideoCaptureNV = NULL;
PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC glad_glVideoCaptureStreamParameterdvNV = NULL;
PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC glad_glVideoCaptureStreamParameterfvNV = NULL;
PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC glad_glVideoCaptureStreamParameterivNV = NULL;
PFNGLVIEWPORTPROC glad_glViewport = NULL;
PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv = NULL;
PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf = NULL;
PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv = NULL;
PFNGLVIEWPORTPOSITIONWSCALENVPROC glad_glViewportPositionWScaleNV = NULL;
PFNGLVIEWPORTSWIZZLENVPROC glad_glViewportSwizzleNV = NULL;
PFNGLWAITSEMAPHOREEXTPROC glad_glWaitSemaphoreEXT = NULL;
PFNGLWAITSYNCPROC glad_glWaitSync = NULL;
PFNGLWAITVKSEMAPHORENVPROC glad_glWaitVkSemaphoreNV = NULL;
PFNGLWEIGHTPATHSNVPROC glad_glWeightPathsNV = NULL;
PFNGLWEIGHTPOINTERARBPROC glad_glWeightPointerARB = NULL;
PFNGLWEIGHTBVARBPROC glad_glWeightbvARB = NULL;
PFNGLWEIGHTDVARBPROC glad_glWeightdvARB = NULL;
PFNGLWEIGHTFVARBPROC glad_glWeightfvARB = NULL;
PFNGLWEIGHTIVARBPROC glad_glWeightivARB = NULL;
PFNGLWEIGHTSVARBPROC glad_glWeightsvARB = NULL;
PFNGLWEIGHTUBVARBPROC glad_glWeightubvARB = NULL;
PFNGLWEIGHTUIVARBPROC glad_glWeightuivARB = NULL;
PFNGLWEIGHTUSVARBPROC glad_glWeightusvARB = NULL;
PFNGLWINDOWPOS2DPROC glad_glWindowPos2d = NULL;
PFNGLWINDOWPOS2DARBPROC glad_glWindowPos2dARB = NULL;
PFNGLWINDOWPOS2DMESAPROC glad_glWindowPos2dMESA = NULL;
PFNGLWINDOWPOS2DVPROC glad_glWindowPos2dv = NULL;
PFNGLWINDOWPOS2DVARBPROC glad_glWindowPos2dvARB = NULL;
PFNGLWINDOWPOS2DVMESAPROC glad_glWindowPos2dvMESA = NULL;
PFNGLWINDOWPOS2FPROC glad_glWindowPos2f = NULL;
PFNGLWINDOWPOS2FARBPROC glad_glWindowPos2fARB = NULL;
PFNGLWINDOWPOS2FMESAPROC glad_glWindowPos2fMESA = NULL;
PFNGLWINDOWPOS2FVPROC glad_glWindowPos2fv = NULL;
PFNGLWINDOWPOS2FVARBPROC glad_glWindowPos2fvARB = NULL;
PFNGLWINDOWPOS2FVMESAPROC glad_glWindowPos2fvMESA = NULL;
PFNGLWINDOWPOS2IPROC glad_glWindowPos2i = NULL;
PFNGLWINDOWPOS2IARBPROC glad_glWindowPos2iARB = NULL;
PFNGLWINDOWPOS2IMESAPROC glad_glWindowPos2iMESA = NULL;
PFNGLWINDOWPOS2IVPROC glad_glWindowPos2iv = NULL;
PFNGLWINDOWPOS2IVARBPROC glad_glWindowPos2ivARB = NULL;
PFNGLWINDOWPOS2IVMESAPROC glad_glWindowPos2ivMESA = NULL;
PFNGLWINDOWPOS2SPROC glad_glWindowPos2s = NULL;
PFNGLWINDOWPOS2SARBPROC glad_glWindowPos2sARB = NULL;
PFNGLWINDOWPOS2SMESAPROC glad_glWindowPos2sMESA = NULL;
PFNGLWINDOWPOS2SVPROC glad_glWindowPos2sv = NULL;
PFNGLWINDOWPOS2SVARBPROC glad_glWindowPos2svARB = NULL;
PFNGLWINDOWPOS2SVMESAPROC glad_glWindowPos2svMESA = NULL;
PFNGLWINDOWPOS3DPROC glad_glWindowPos3d = NULL;
PFNGLWINDOWPOS3DARBPROC glad_glWindowPos3dARB = NULL;
PFNGLWINDOWPOS3DMESAPROC glad_glWindowPos3dMESA = NULL;
PFNGLWINDOWPOS3DVPROC glad_glWindowPos3dv = NULL;
PFNGLWINDOWPOS3DVARBPROC glad_glWindowPos3dvARB = NULL;
PFNGLWINDOWPOS3DVMESAPROC glad_glWindowPos3dvMESA = NULL;
PFNGLWINDOWPOS3FPROC glad_glWindowPos3f = NULL;
PFNGLWINDOWPOS3FARBPROC glad_glWindowPos3fARB = NULL;
PFNGLWINDOWPOS3FMESAPROC glad_glWindowPos3fMESA = NULL;
PFNGLWINDOWPOS3FVPROC glad_glWindowPos3fv = NULL;
PFNGLWINDOWPOS3FVARBPROC glad_glWindowPos3fvARB = NULL;
PFNGLWINDOWPOS3FVMESAPROC glad_glWindowPos3fvMESA = NULL;
PFNGLWINDOWPOS3IPROC glad_glWindowPos3i = NULL;
PFNGLWINDOWPOS3IARBPROC glad_glWindowPos3iARB = NULL;
PFNGLWINDOWPOS3IMESAPROC glad_glWindowPos3iMESA = NULL;
PFNGLWINDOWPOS3IVPROC glad_glWindowPos3iv = NULL;
PFNGLWINDOWPOS3IVARBPROC glad_glWindowPos3ivARB = NULL;
PFNGLWINDOWPOS3IVMESAPROC glad_glWindowPos3ivMESA = NULL;
PFNGLWINDOWPOS3SPROC glad_glWindowPos3s = NULL;
PFNGLWINDOWPOS3SARBPROC glad_glWindowPos3sARB = NULL;
PFNGLWINDOWPOS3SMESAPROC glad_glWindowPos3sMESA = NULL;
PFNGLWINDOWPOS3SVPROC glad_glWindowPos3sv = NULL;
PFNGLWINDOWPOS3SVARBPROC glad_glWindowPos3svARB = NULL;
PFNGLWINDOWPOS3SVMESAPROC glad_glWindowPos3svMESA = NULL;
PFNGLWINDOWPOS4DMESAPROC glad_glWindowPos4dMESA = NULL;
PFNGLWINDOWPOS4DVMESAPROC glad_glWindowPos4dvMESA = NULL;
PFNGLWINDOWPOS4FMESAPROC glad_glWindowPos4fMESA = NULL;
PFNGLWINDOWPOS4FVMESAPROC glad_glWindowPos4fvMESA = NULL;
PFNGLWINDOWPOS4IMESAPROC glad_glWindowPos4iMESA = NULL;
PFNGLWINDOWPOS4IVMESAPROC glad_glWindowPos4ivMESA = NULL;
PFNGLWINDOWPOS4SMESAPROC glad_glWindowPos4sMESA = NULL;
PFNGLWINDOWPOS4SVMESAPROC glad_glWindowPos4svMESA = NULL;
PFNGLWINDOWRECTANGLESEXTPROC glad_glWindowRectanglesEXT = NULL;
PFNGLWRITEMASKEXTPROC glad_glWriteMaskEXT = NULL;


static void glad_gl_load_GL_VERSION_1_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_0) return;
    glad_glBlendFunc = (PFNGLBLENDFUNCPROC) load(userptr, "glBlendFunc");
    glad_glClear = (PFNGLCLEARPROC) load(userptr, "glClear");
    glad_glClearColor = (PFNGLCLEARCOLORPROC) load(userptr, "glClearColor");
    glad_glClearDepth = (PFNGLCLEARDEPTHPROC) load(userptr, "glClearDepth");
    glad_glClearStencil = (PFNGLCLEARSTENCILPROC) load(userptr, "glClearStencil");
    glad_glColorMask = (PFNGLCOLORMASKPROC) load(userptr, "glColorMask");
    glad_glCullFace = (PFNGLCULLFACEPROC) load(userptr, "glCullFace");
    glad_glDepthFunc = (PFNGLDEPTHFUNCPROC) load(userptr, "glDepthFunc");
    glad_glDepthMask = (PFNGLDEPTHMASKPROC) load(userptr, "glDepthMask");
    glad_glDepthRange = (PFNGLDEPTHRANGEPROC) load(userptr, "glDepthRange");
    glad_glDisable = (PFNGLDISABLEPROC) load(userptr, "glDisable");
    glad_glDrawBuffer = (PFNGLDRAWBUFFERPROC) load(userptr, "glDrawBuffer");
    glad_glEnable = (PFNGLENABLEPROC) load(userptr, "glEnable");
    glad_glFinish = (PFNGLFINISHPROC) load(userptr, "glFinish");
    glad_glFlush = (PFNGLFLUSHPROC) load(userptr, "glFlush");
    glad_glFrontFace = (PFNGLFRONTFACEPROC) load(userptr, "glFrontFace");
    glad_glGetBooleanv = (PFNGLGETBOOLEANVPROC) load(userptr, "glGetBooleanv");
    glad_glGetDoublev = (PFNGLGETDOUBLEVPROC) load(userptr, "glGetDoublev");
    glad_glGetError = (PFNGLGETERRORPROC) load(userptr, "glGetError");
    glad_glGetFloatv = (PFNGLGETFLOATVPROC) load(userptr, "glGetFloatv");
    glad_glGetIntegerv = (PFNGLGETINTEGERVPROC) load(userptr, "glGetIntegerv");
    glad_glGetString = (PFNGLGETSTRINGPROC) load(userptr, "glGetString");
    glad_glGetTexImage = (PFNGLGETTEXIMAGEPROC) load(userptr, "glGetTexImage");
    glad_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC) load(userptr, "glGetTexLevelParameterfv");
    glad_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC) load(userptr, "glGetTexLevelParameteriv");
    glad_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC) load(userptr, "glGetTexParameterfv");
    glad_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC) load(userptr, "glGetTexParameteriv");
    glad_glHint = (PFNGLHINTPROC) load(userptr, "glHint");
    glad_glIsEnabled = (PFNGLISENABLEDPROC) load(userptr, "glIsEnabled");
    glad_glLineWidth = (PFNGLLINEWIDTHPROC) load(userptr, "glLineWidth");
    glad_glLogicOp = (PFNGLLOGICOPPROC) load(userptr, "glLogicOp");
    glad_glPixelStoref = (PFNGLPIXELSTOREFPROC) load(userptr, "glPixelStoref");
    glad_glPixelStorei = (PFNGLPIXELSTOREIPROC) load(userptr, "glPixelStorei");
    glad_glPointSize = (PFNGLPOINTSIZEPROC) load(userptr, "glPointSize");
    glad_glPolygonMode = (PFNGLPOLYGONMODEPROC) load(userptr, "glPolygonMode");
    glad_glReadBuffer = (PFNGLREADBUFFERPROC) load(userptr, "glReadBuffer");
    glad_glReadPixels = (PFNGLREADPIXELSPROC) load(userptr, "glReadPixels");
    glad_glScissor = (PFNGLSCISSORPROC) load(userptr, "glScissor");
    glad_glStencilFunc = (PFNGLSTENCILFUNCPROC) load(userptr, "glStencilFunc");
    glad_glStencilMask = (PFNGLSTENCILMASKPROC) load(userptr, "glStencilMask");
    glad_glStencilOp = (PFNGLSTENCILOPPROC) load(userptr, "glStencilOp");
    glad_glTexImage1D = (PFNGLTEXIMAGE1DPROC) load(userptr, "glTexImage1D");
    glad_glTexImage2D = (PFNGLTEXIMAGE2DPROC) load(userptr, "glTexImage2D");
    glad_glTexParameterf = (PFNGLTEXPARAMETERFPROC) load(userptr, "glTexParameterf");
    glad_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC) load(userptr, "glTexParameterfv");
    glad_glTexParameteri = (PFNGLTEXPARAMETERIPROC) load(userptr, "glTexParameteri");
    glad_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC) load(userptr, "glTexParameteriv");
    glad_glViewport = (PFNGLVIEWPORTPROC) load(userptr, "glViewport");
}
static void glad_gl_load_GL_VERSION_1_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_1) return;
    glad_glArrayElement = (PFNGLARRAYELEMENTPROC) load(userptr, "glArrayElement");
    glad_glBindTexture = (PFNGLBINDTEXTUREPROC) load(userptr, "glBindTexture");
    glad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC) load(userptr, "glCopyTexImage1D");
    glad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC) load(userptr, "glCopyTexImage2D");
    glad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC) load(userptr, "glCopyTexSubImage1D");
    glad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC) load(userptr, "glCopyTexSubImage2D");
    glad_glDeleteTextures = (PFNGLDELETETEXTURESPROC) load(userptr, "glDeleteTextures");
    glad_glDrawArrays = (PFNGLDRAWARRAYSPROC) load(userptr, "glDrawArrays");
    glad_glDrawElements = (PFNGLDRAWELEMENTSPROC) load(userptr, "glDrawElements");
    glad_glGenTextures = (PFNGLGENTEXTURESPROC) load(userptr, "glGenTextures");
    glad_glGetPointerv = (PFNGLGETPOINTERVPROC) load(userptr, "glGetPointerv");
    glad_glIsTexture = (PFNGLISTEXTUREPROC) load(userptr, "glIsTexture");
    glad_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC) load(userptr, "glPolygonOffset");
    glad_glPrioritizeTextures = (PFNGLPRIORITIZETEXTURESPROC) load(userptr, "glPrioritizeTextures");
    glad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC) load(userptr, "glTexSubImage1D");
    glad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC) load(userptr, "glTexSubImage2D");
}
static void glad_gl_load_GL_VERSION_1_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_2) return;
    glad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC) load(userptr, "glCopyTexSubImage3D");
    glad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC) load(userptr, "glDrawRangeElements");
    glad_glTexImage3D = (PFNGLTEXIMAGE3DPROC) load(userptr, "glTexImage3D");
    glad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC) load(userptr, "glTexSubImage3D");
}
static void glad_gl_load_GL_VERSION_1_3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_3) return;
    glad_glActiveTexture = (PFNGLACTIVETEXTUREPROC) load(userptr, "glActiveTexture");
    glad_glClientActiveTexture = (PFNGLCLIENTACTIVETEXTUREPROC) load(userptr, "glClientActiveTexture");
    glad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC) load(userptr, "glCompressedTexImage1D");
    glad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC) load(userptr, "glCompressedTexImage2D");
    glad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC) load(userptr, "glCompressedTexImage3D");
    glad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) load(userptr, "glCompressedTexSubImage1D");
    glad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) load(userptr, "glCompressedTexSubImage2D");
    glad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) load(userptr, "glCompressedTexSubImage3D");
    glad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC) load(userptr, "glGetCompressedTexImage");
    glad_glLoadTransposeMatrixd = (PFNGLLOADTRANSPOSEMATRIXDPROC) load(userptr, "glLoadTransposeMatrixd");
    glad_glLoadTransposeMatrixf = (PFNGLLOADTRANSPOSEMATRIXFPROC) load(userptr, "glLoadTransposeMatrixf");
    glad_glMultTransposeMatrixd = (PFNGLMULTTRANSPOSEMATRIXDPROC) load(userptr, "glMultTransposeMatrixd");
    glad_glMultTransposeMatrixf = (PFNGLMULTTRANSPOSEMATRIXFPROC) load(userptr, "glMultTransposeMatrixf");
    glad_glMultiTexCoord1d = (PFNGLMULTITEXCOORD1DPROC) load(userptr, "glMultiTexCoord1d");
    glad_glMultiTexCoord1dv = (PFNGLMULTITEXCOORD1DVPROC) load(userptr, "glMultiTexCoord1dv");
    glad_glMultiTexCoord1f = (PFNGLMULTITEXCOORD1FPROC) load(userptr, "glMultiTexCoord1f");
    glad_glMultiTexCoord1fv = (PFNGLMULTITEXCOORD1FVPROC) load(userptr, "glMultiTexCoord1fv");
    glad_glMultiTexCoord1i = (PFNGLMULTITEXCOORD1IPROC) load(userptr, "glMultiTexCoord1i");
    glad_glMultiTexCoord1iv = (PFNGLMULTITEXCOORD1IVPROC) load(userptr, "glMultiTexCoord1iv");
    glad_glMultiTexCoord1s = (PFNGLMULTITEXCOORD1SPROC) load(userptr, "glMultiTexCoord1s");
    glad_glMultiTexCoord1sv = (PFNGLMULTITEXCOORD1SVPROC) load(userptr, "glMultiTexCoord1sv");
    glad_glMultiTexCoord2d = (PFNGLMULTITEXCOORD2DPROC) load(userptr, "glMultiTexCoord2d");
    glad_glMultiTexCoord2dv = (PFNGLMULTITEXCOORD2DVPROC) load(userptr, "glMultiTexCoord2dv");
    glad_glMultiTexCoord2f = (PFNGLMULTITEXCOORD2FPROC) load(userptr, "glMultiTexCoord2f");
    glad_glMultiTexCoord2fv = (PFNGLMULTITEXCOORD2FVPROC) load(userptr, "glMultiTexCoord2fv");
    glad_glMultiTexCoord2i = (PFNGLMULTITEXCOORD2IPROC) load(userptr, "glMultiTexCoord2i");
    glad_glMultiTexCoord2iv = (PFNGLMULTITEXCOORD2IVPROC) load(userptr, "glMultiTexCoord2iv");
    glad_glMultiTexCoord2s = (PFNGLMULTITEXCOORD2SPROC) load(userptr, "glMultiTexCoord2s");
    glad_glMultiTexCoord2sv = (PFNGLMULTITEXCOORD2SVPROC) load(userptr, "glMultiTexCoord2sv");
    glad_glMultiTexCoord3d = (PFNGLMULTITEXCOORD3DPROC) load(userptr, "glMultiTexCoord3d");
    glad_glMultiTexCoord3dv = (PFNGLMULTITEXCOORD3DVPROC) load(userptr, "glMultiTexCoord3dv");
    glad_glMultiTexCoord3f = (PFNGLMULTITEXCOORD3FPROC) load(userptr, "glMultiTexCoord3f");
    glad_glMultiTexCoord3fv = (PFNGLMULTITEXCOORD3FVPROC) load(userptr, "glMultiTexCoord3fv");
    glad_glMultiTexCoord3i = (PFNGLMULTITEXCOORD3IPROC) load(userptr, "glMultiTexCoord3i");
    glad_glMultiTexCoord3iv = (PFNGLMULTITEXCOORD3IVPROC) load(userptr, "glMultiTexCoord3iv");
    glad_glMultiTexCoord3s = (PFNGLMULTITEXCOORD3SPROC) load(userptr, "glMultiTexCoord3s");
    glad_glMultiTexCoord3sv = (PFNGLMULTITEXCOORD3SVPROC) load(userptr, "glMultiTexCoord3sv");
    glad_glMultiTexCoord4d = (PFNGLMULTITEXCOORD4DPROC) load(userptr, "glMultiTexCoord4d");
    glad_glMultiTexCoord4dv = (PFNGLMULTITEXCOORD4DVPROC) load(userptr, "glMultiTexCoord4dv");
    glad_glMultiTexCoord4f = (PFNGLMULTITEXCOORD4FPROC) load(userptr, "glMultiTexCoord4f");
    glad_glMultiTexCoord4fv = (PFNGLMULTITEXCOORD4FVPROC) load(userptr, "glMultiTexCoord4fv");
    glad_glMultiTexCoord4i = (PFNGLMULTITEXCOORD4IPROC) load(userptr, "glMultiTexCoord4i");
    glad_glMultiTexCoord4iv = (PFNGLMULTITEXCOORD4IVPROC) load(userptr, "glMultiTexCoord4iv");
    glad_glMultiTexCoord4s = (PFNGLMULTITEXCOORD4SPROC) load(userptr, "glMultiTexCoord4s");
    glad_glMultiTexCoord4sv = (PFNGLMULTITEXCOORD4SVPROC) load(userptr, "glMultiTexCoord4sv");
    glad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC) load(userptr, "glSampleCoverage");
}
static void glad_gl_load_GL_VERSION_1_4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_4) return;
    glad_glBlendColor = (PFNGLBLENDCOLORPROC) load(userptr, "glBlendColor");
    glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC) load(userptr, "glBlendEquation");
    glad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC) load(userptr, "glBlendFuncSeparate");
    glad_glFogCoordPointer = (PFNGLFOGCOORDPOINTERPROC) load(userptr, "glFogCoordPointer");
    glad_glFogCoordd = (PFNGLFOGCOORDDPROC) load(userptr, "glFogCoordd");
    glad_glFogCoorddv = (PFNGLFOGCOORDDVPROC) load(userptr, "glFogCoorddv");
    glad_glFogCoordf = (PFNGLFOGCOORDFPROC) load(userptr, "glFogCoordf");
    glad_glFogCoordfv = (PFNGLFOGCOORDFVPROC) load(userptr, "glFogCoordfv");
    glad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC) load(userptr, "glMultiDrawArrays");
    glad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC) load(userptr, "glMultiDrawElements");
    glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC) load(userptr, "glPointParameterf");
    glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC) load(userptr, "glPointParameterfv");
    glad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC) load(userptr, "glPointParameteri");
    glad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC) load(userptr, "glPointParameteriv");
    glad_glSecondaryColor3b = (PFNGLSECONDARYCOLOR3BPROC) load(userptr, "glSecondaryColor3b");
    glad_glSecondaryColor3bv = (PFNGLSECONDARYCOLOR3BVPROC) load(userptr, "glSecondaryColor3bv");
    glad_glSecondaryColor3d = (PFNGLSECONDARYCOLOR3DPROC) load(userptr, "glSecondaryColor3d");
    glad_glSecondaryColor3dv = (PFNGLSECONDARYCOLOR3DVPROC) load(userptr, "glSecondaryColor3dv");
    glad_glSecondaryColor3f = (PFNGLSECONDARYCOLOR3FPROC) load(userptr, "glSecondaryColor3f");
    glad_glSecondaryColor3fv = (PFNGLSECONDARYCOLOR3FVPROC) load(userptr, "glSecondaryColor3fv");
    glad_glSecondaryColor3i = (PFNGLSECONDARYCOLOR3IPROC) load(userptr, "glSecondaryColor3i");
    glad_glSecondaryColor3iv = (PFNGLSECONDARYCOLOR3IVPROC) load(userptr, "glSecondaryColor3iv");
    glad_glSecondaryColor3s = (PFNGLSECONDARYCOLOR3SPROC) load(userptr, "glSecondaryColor3s");
    glad_glSecondaryColor3sv = (PFNGLSECONDARYCOLOR3SVPROC) load(userptr, "glSecondaryColor3sv");
    glad_glSecondaryColor3ub = (PFNGLSECONDARYCOLOR3UBPROC) load(userptr, "glSecondaryColor3ub");
    glad_glSecondaryColor3ubv = (PFNGLSECONDARYCOLOR3UBVPROC) load(userptr, "glSecondaryColor3ubv");
    glad_glSecondaryColor3ui = (PFNGLSECONDARYCOLOR3UIPROC) load(userptr, "glSecondaryColor3ui");
    glad_glSecondaryColor3uiv = (PFNGLSECONDARYCOLOR3UIVPROC) load(userptr, "glSecondaryColor3uiv");
    glad_glSecondaryColor3us = (PFNGLSECONDARYCOLOR3USPROC) load(userptr, "glSecondaryColor3us");
    glad_glSecondaryColor3usv = (PFNGLSECONDARYCOLOR3USVPROC) load(userptr, "glSecondaryColor3usv");
    glad_glSecondaryColorPointer = (PFNGLSECONDARYCOLORPOINTERPROC) load(userptr, "glSecondaryColorPointer");
    glad_glWindowPos2d = (PFNGLWINDOWPOS2DPROC) load(userptr, "glWindowPos2d");
    glad_glWindowPos2dv = (PFNGLWINDOWPOS2DVPROC) load(userptr, "glWindowPos2dv");
    glad_glWindowPos2f = (PFNGLWINDOWPOS2FPROC) load(userptr, "glWindowPos2f");
    glad_glWindowPos2fv = (PFNGLWINDOWPOS2FVPROC) load(userptr, "glWindowPos2fv");
    glad_glWindowPos2i = (PFNGLWINDOWPOS2IPROC) load(userptr, "glWindowPos2i");
    glad_glWindowPos2iv = (PFNGLWINDOWPOS2IVPROC) load(userptr, "glWindowPos2iv");
    glad_glWindowPos2s = (PFNGLWINDOWPOS2SPROC) load(userptr, "glWindowPos2s");
    glad_glWindowPos2sv = (PFNGLWINDOWPOS2SVPROC) load(userptr, "glWindowPos2sv");
    glad_glWindowPos3d = (PFNGLWINDOWPOS3DPROC) load(userptr, "glWindowPos3d");
    glad_glWindowPos3dv = (PFNGLWINDOWPOS3DVPROC) load(userptr, "glWindowPos3dv");
    glad_glWindowPos3f = (PFNGLWINDOWPOS3FPROC) load(userptr, "glWindowPos3f");
    glad_glWindowPos3fv = (PFNGLWINDOWPOS3FVPROC) load(userptr, "glWindowPos3fv");
    glad_glWindowPos3i = (PFNGLWINDOWPOS3IPROC) load(userptr, "glWindowPos3i");
    glad_glWindowPos3iv = (PFNGLWINDOWPOS3IVPROC) load(userptr, "glWindowPos3iv");
    glad_glWindowPos3s = (PFNGLWINDOWPOS3SPROC) load(userptr, "glWindowPos3s");
    glad_glWindowPos3sv = (PFNGLWINDOWPOS3SVPROC) load(userptr, "glWindowPos3sv");
}
static void glad_gl_load_GL_VERSION_1_5( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_1_5) return;
    glad_glBeginQuery = (PFNGLBEGINQUERYPROC) load(userptr, "glBeginQuery");
    glad_glBindBuffer = (PFNGLBINDBUFFERPROC) load(userptr, "glBindBuffer");
    glad_glBufferData = (PFNGLBUFFERDATAPROC) load(userptr, "glBufferData");
    glad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC) load(userptr, "glBufferSubData");
    glad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC) load(userptr, "glDeleteBuffers");
    glad_glDeleteQueries = (PFNGLDELETEQUERIESPROC) load(userptr, "glDeleteQueries");
    glad_glEndQuery = (PFNGLENDQUERYPROC) load(userptr, "glEndQuery");
    glad_glGenBuffers = (PFNGLGENBUFFERSPROC) load(userptr, "glGenBuffers");
    glad_glGenQueries = (PFNGLGENQUERIESPROC) load(userptr, "glGenQueries");
    glad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC) load(userptr, "glGetBufferParameteriv");
    glad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC) load(userptr, "glGetBufferPointerv");
    glad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC) load(userptr, "glGetBufferSubData");
    glad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC) load(userptr, "glGetQueryObjectiv");
    glad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC) load(userptr, "glGetQueryObjectuiv");
    glad_glGetQueryiv = (PFNGLGETQUERYIVPROC) load(userptr, "glGetQueryiv");
    glad_glIsBuffer = (PFNGLISBUFFERPROC) load(userptr, "glIsBuffer");
    glad_glIsQuery = (PFNGLISQUERYPROC) load(userptr, "glIsQuery");
    glad_glMapBuffer = (PFNGLMAPBUFFERPROC) load(userptr, "glMapBuffer");
    glad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC) load(userptr, "glUnmapBuffer");
}
static void glad_gl_load_GL_VERSION_2_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_2_0) return;
    glad_glAttachShader = (PFNGLATTACHSHADERPROC) load(userptr, "glAttachShader");
    glad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC) load(userptr, "glBindAttribLocation");
    glad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC) load(userptr, "glBlendEquationSeparate");
    glad_glCompileShader = (PFNGLCOMPILESHADERPROC) load(userptr, "glCompileShader");
    glad_glCreateProgram = (PFNGLCREATEPROGRAMPROC) load(userptr, "glCreateProgram");
    glad_glCreateShader = (PFNGLCREATESHADERPROC) load(userptr, "glCreateShader");
    glad_glDeleteProgram = (PFNGLDELETEPROGRAMPROC) load(userptr, "glDeleteProgram");
    glad_glDeleteShader = (PFNGLDELETESHADERPROC) load(userptr, "glDeleteShader");
    glad_glDetachShader = (PFNGLDETACHSHADERPROC) load(userptr, "glDetachShader");
    glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC) load(userptr, "glDisableVertexAttribArray");
    glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC) load(userptr, "glDrawBuffers");
    glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC) load(userptr, "glEnableVertexAttribArray");
    glad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC) load(userptr, "glGetActiveAttrib");
    glad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC) load(userptr, "glGetActiveUniform");
    glad_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC) load(userptr, "glGetAttachedShaders");
    glad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC) load(userptr, "glGetAttribLocation");
    glad_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC) load(userptr, "glGetProgramInfoLog");
    glad_glGetProgramiv = (PFNGLGETPROGRAMIVPROC) load(userptr, "glGetProgramiv");
    glad_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC) load(userptr, "glGetShaderInfoLog");
    glad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC) load(userptr, "glGetShaderSource");
    glad_glGetShaderiv = (PFNGLGETSHADERIVPROC) load(userptr, "glGetShaderiv");
    glad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) load(userptr, "glGetUniformLocation");
    glad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC) load(userptr, "glGetUniformfv");
    glad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC) load(userptr, "glGetUniformiv");
    glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC) load(userptr, "glGetVertexAttribPointerv");
    glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC) load(userptr, "glGetVertexAttribdv");
    glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC) load(userptr, "glGetVertexAttribfv");
    glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC) load(userptr, "glGetVertexAttribiv");
    glad_glIsProgram = (PFNGLISPROGRAMPROC) load(userptr, "glIsProgram");
    glad_glIsShader = (PFNGLISSHADERPROC) load(userptr, "glIsShader");
    glad_glLinkProgram = (PFNGLLINKPROGRAMPROC) load(userptr, "glLinkProgram");
    glad_glShaderSource = (PFNGLSHADERSOURCEPROC) load(userptr, "glShaderSource");
    glad_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC) load(userptr, "glStencilFuncSeparate");
    glad_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC) load(userptr, "glStencilMaskSeparate");
    glad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC) load(userptr, "glStencilOpSeparate");
    glad_glUniform1f = (PFNGLUNIFORM1FPROC) load(userptr, "glUniform1f");
    glad_glUniform1fv = (PFNGLUNIFORM1FVPROC) load(userptr, "glUniform1fv");
    glad_glUniform1i = (PFNGLUNIFORM1IPROC) load(userptr, "glUniform1i");
    glad_glUniform1iv = (PFNGLUNIFORM1IVPROC) load(userptr, "glUniform1iv");
    glad_glUniform2f = (PFNGLUNIFORM2FPROC) load(userptr, "glUniform2f");
    glad_glUniform2fv = (PFNGLUNIFORM2FVPROC) load(userptr, "glUniform2fv");
    glad_glUniform2i = (PFNGLUNIFORM2IPROC) load(userptr, "glUniform2i");
    glad_glUniform2iv = (PFNGLUNIFORM2IVPROC) load(userptr, "glUniform2iv");
    glad_glUniform3f = (PFNGLUNIFORM3FPROC) load(userptr, "glUniform3f");
    glad_glUniform3fv = (PFNGLUNIFORM3FVPROC) load(userptr, "glUniform3fv");
    glad_glUniform3i = (PFNGLUNIFORM3IPROC) load(userptr, "glUniform3i");
    glad_glUniform3iv = (PFNGLUNIFORM3IVPROC) load(userptr, "glUniform3iv");
    glad_glUniform4f = (PFNGLUNIFORM4FPROC) load(userptr, "glUniform4f");
    glad_glUniform4fv = (PFNGLUNIFORM4FVPROC) load(userptr, "glUniform4fv");
    glad_glUniform4i = (PFNGLUNIFORM4IPROC) load(userptr, "glUniform4i");
    glad_glUniform4iv = (PFNGLUNIFORM4IVPROC) load(userptr, "glUniform4iv");
    glad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC) load(userptr, "glUniformMatrix2fv");
    glad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC) load(userptr, "glUniformMatrix3fv");
    glad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC) load(userptr, "glUniformMatrix4fv");
    glad_glUseProgram = (PFNGLUSEPROGRAMPROC) load(userptr, "glUseProgram");
    glad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC) load(userptr, "glValidateProgram");
    glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC) load(userptr, "glVertexAttrib1d");
    glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC) load(userptr, "glVertexAttrib1dv");
    glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC) load(userptr, "glVertexAttrib1f");
    glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC) load(userptr, "glVertexAttrib1fv");
    glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC) load(userptr, "glVertexAttrib1s");
    glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC) load(userptr, "glVertexAttrib1sv");
    glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC) load(userptr, "glVertexAttrib2d");
    glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC) load(userptr, "glVertexAttrib2dv");
    glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC) load(userptr, "glVertexAttrib2f");
    glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC) load(userptr, "glVertexAttrib2fv");
    glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC) load(userptr, "glVertexAttrib2s");
    glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC) load(userptr, "glVertexAttrib2sv");
    glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC) load(userptr, "glVertexAttrib3d");
    glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC) load(userptr, "glVertexAttrib3dv");
    glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC) load(userptr, "glVertexAttrib3f");
    glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC) load(userptr, "glVertexAttrib3fv");
    glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC) load(userptr, "glVertexAttrib3s");
    glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC) load(userptr, "glVertexAttrib3sv");
    glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC) load(userptr, "glVertexAttrib4Nbv");
    glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC) load(userptr, "glVertexAttrib4Niv");
    glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC) load(userptr, "glVertexAttrib4Nsv");
    glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC) load(userptr, "glVertexAttrib4Nub");
    glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC) load(userptr, "glVertexAttrib4Nubv");
    glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC) load(userptr, "glVertexAttrib4Nuiv");
    glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC) load(userptr, "glVertexAttrib4Nusv");
    glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC) load(userptr, "glVertexAttrib4bv");
    glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC) load(userptr, "glVertexAttrib4d");
    glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC) load(userptr, "glVertexAttrib4dv");
    glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC) load(userptr, "glVertexAttrib4f");
    glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC) load(userptr, "glVertexAttrib4fv");
    glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC) load(userptr, "glVertexAttrib4iv");
    glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC) load(userptr, "glVertexAttrib4s");
    glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC) load(userptr, "glVertexAttrib4sv");
    glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC) load(userptr, "glVertexAttrib4ubv");
    glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC) load(userptr, "glVertexAttrib4uiv");
    glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC) load(userptr, "glVertexAttrib4usv");
    glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC) load(userptr, "glVertexAttribPointer");
}
static void glad_gl_load_GL_VERSION_2_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_2_1) return;
    glad_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC) load(userptr, "glUniformMatrix2x3fv");
    glad_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC) load(userptr, "glUniformMatrix2x4fv");
    glad_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC) load(userptr, "glUniformMatrix3x2fv");
    glad_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC) load(userptr, "glUniformMatrix3x4fv");
    glad_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC) load(userptr, "glUniformMatrix4x2fv");
    glad_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC) load(userptr, "glUniformMatrix4x3fv");
}
static void glad_gl_load_GL_VERSION_3_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_0) return;
    glad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC) load(userptr, "glBeginConditionalRender");
    glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC) load(userptr, "glBeginTransformFeedback");
    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
    glad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC) load(userptr, "glBindFragDataLocation");
    glad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC) load(userptr, "glBindFramebuffer");
    glad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC) load(userptr, "glBindRenderbuffer");
    glad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC) load(userptr, "glBindVertexArray");
    glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) load(userptr, "glBlitFramebuffer");
    glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckFramebufferStatus");
    glad_glClampColor = (PFNGLCLAMPCOLORPROC) load(userptr, "glClampColor");
    glad_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC) load(userptr, "glClearBufferfi");
    glad_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC) load(userptr, "glClearBufferfv");
    glad_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC) load(userptr, "glClearBufferiv");
    glad_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC) load(userptr, "glClearBufferuiv");
    glad_glColorMaski = (PFNGLCOLORMASKIPROC) load(userptr, "glColorMaski");
    glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) load(userptr, "glDeleteFramebuffers");
    glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) load(userptr, "glDeleteRenderbuffers");
    glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC) load(userptr, "glDeleteVertexArrays");
    glad_glDisablei = (PFNGLDISABLEIPROC) load(userptr, "glDisablei");
    glad_glEnablei = (PFNGLENABLEIPROC) load(userptr, "glEnablei");
    glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC) load(userptr, "glEndConditionalRender");
    glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC) load(userptr, "glEndTransformFeedback");
    glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC) load(userptr, "glFlushMappedBufferRange");
    glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glFramebufferRenderbuffer");
    glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC) load(userptr, "glFramebufferTexture1D");
    glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) load(userptr, "glFramebufferTexture2D");
    glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC) load(userptr, "glFramebufferTexture3D");
    glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glFramebufferTextureLayer");
    glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) load(userptr, "glGenFramebuffers");
    glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) load(userptr, "glGenRenderbuffers");
    glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC) load(userptr, "glGenVertexArrays");
    glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC) load(userptr, "glGenerateMipmap");
    glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC) load(userptr, "glGetBooleani_v");
    glad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC) load(userptr, "glGetFragDataLocation");
    glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetFramebufferAttachmentParameteriv");
    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
    glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetRenderbufferParameteriv");
    glad_glGetStringi = (PFNGLGETSTRINGIPROC) load(userptr, "glGetStringi");
    glad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC) load(userptr, "glGetTexParameterIiv");
    glad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC) load(userptr, "glGetTexParameterIuiv");
    glad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) load(userptr, "glGetTransformFeedbackVarying");
    glad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC) load(userptr, "glGetUniformuiv");
    glad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC) load(userptr, "glGetVertexAttribIiv");
    glad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC) load(userptr, "glGetVertexAttribIuiv");
    glad_glIsEnabledi = (PFNGLISENABLEDIPROC) load(userptr, "glIsEnabledi");
    glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC) load(userptr, "glIsFramebuffer");
    glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC) load(userptr, "glIsRenderbuffer");
    glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC) load(userptr, "glIsVertexArray");
    glad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC) load(userptr, "glMapBufferRange");
    glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) load(userptr, "glRenderbufferStorage");
    glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glRenderbufferStorageMultisample");
    glad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC) load(userptr, "glTexParameterIiv");
    glad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC) load(userptr, "glTexParameterIuiv");
    glad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC) load(userptr, "glTransformFeedbackVaryings");
    glad_glUniform1ui = (PFNGLUNIFORM1UIPROC) load(userptr, "glUniform1ui");
    glad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC) load(userptr, "glUniform1uiv");
    glad_glUniform2ui = (PFNGLUNIFORM2UIPROC) load(userptr, "glUniform2ui");
    glad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC) load(userptr, "glUniform2uiv");
    glad_glUniform3ui = (PFNGLUNIFORM3UIPROC) load(userptr, "glUniform3ui");
    glad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC) load(userptr, "glUniform3uiv");
    glad_glUniform4ui = (PFNGLUNIFORM4UIPROC) load(userptr, "glUniform4ui");
    glad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC) load(userptr, "glUniform4uiv");
    glad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC) load(userptr, "glVertexAttribI1i");
    glad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC) load(userptr, "glVertexAttribI1iv");
    glad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC) load(userptr, "glVertexAttribI1ui");
    glad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC) load(userptr, "glVertexAttribI1uiv");
    glad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC) load(userptr, "glVertexAttribI2i");
    glad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC) load(userptr, "glVertexAttribI2iv");
    glad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC) load(userptr, "glVertexAttribI2ui");
    glad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC) load(userptr, "glVertexAttribI2uiv");
    glad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC) load(userptr, "glVertexAttribI3i");
    glad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC) load(userptr, "glVertexAttribI3iv");
    glad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC) load(userptr, "glVertexAttribI3ui");
    glad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC) load(userptr, "glVertexAttribI3uiv");
    glad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC) load(userptr, "glVertexAttribI4bv");
    glad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC) load(userptr, "glVertexAttribI4i");
    glad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC) load(userptr, "glVertexAttribI4iv");
    glad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC) load(userptr, "glVertexAttribI4sv");
    glad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC) load(userptr, "glVertexAttribI4ubv");
    glad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC) load(userptr, "glVertexAttribI4ui");
    glad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC) load(userptr, "glVertexAttribI4uiv");
    glad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC) load(userptr, "glVertexAttribI4usv");
    glad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC) load(userptr, "glVertexAttribIPointer");
}
static void glad_gl_load_GL_VERSION_3_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_1) return;
    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
    glad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) load(userptr, "glCopyBufferSubData");
    glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) load(userptr, "glDrawArraysInstanced");
    glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) load(userptr, "glDrawElementsInstanced");
    glad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) load(userptr, "glGetActiveUniformBlockName");
    glad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) load(userptr, "glGetActiveUniformBlockiv");
    glad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC) load(userptr, "glGetActiveUniformName");
    glad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) load(userptr, "glGetActiveUniformsiv");
    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
    glad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) load(userptr, "glGetUniformBlockIndex");
    glad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) load(userptr, "glGetUniformIndices");
    glad_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC) load(userptr, "glPrimitiveRestartIndex");
    glad_glTexBuffer = (PFNGLTEXBUFFERPROC) load(userptr, "glTexBuffer");
    glad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) load(userptr, "glUniformBlockBinding");
}
static void glad_gl_load_GL_VERSION_3_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_2) return;
    glad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) load(userptr, "glClientWaitSync");
    glad_glDeleteSync = (PFNGLDELETESYNCPROC) load(userptr, "glDeleteSync");
    glad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glDrawElementsBaseVertex");
    glad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) load(userptr, "glDrawElementsInstancedBaseVertex");
    glad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) load(userptr, "glDrawRangeElementsBaseVertex");
    glad_glFenceSync = (PFNGLFENCESYNCPROC) load(userptr, "glFenceSync");
    glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) load(userptr, "glFramebufferTexture");
    glad_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC) load(userptr, "glGetBufferParameteri64v");
    glad_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC) load(userptr, "glGetInteger64i_v");
    glad_glGetInteger64v = (PFNGLGETINTEGER64VPROC) load(userptr, "glGetInteger64v");
    glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) load(userptr, "glGetMultisamplefv");
    glad_glGetSynciv = (PFNGLGETSYNCIVPROC) load(userptr, "glGetSynciv");
    glad_glIsSync = (PFNGLISSYNCPROC) load(userptr, "glIsSync");
    glad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glMultiDrawElementsBaseVertex");
    glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) load(userptr, "glProvokingVertex");
    glad_glSampleMaski = (PFNGLSAMPLEMASKIPROC) load(userptr, "glSampleMaski");
    glad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC) load(userptr, "glTexImage2DMultisample");
    glad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC) load(userptr, "glTexImage3DMultisample");
    glad_glWaitSync = (PFNGLWAITSYNCPROC) load(userptr, "glWaitSync");
}
static void glad_gl_load_GL_VERSION_3_3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_3_3) return;
    glad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) load(userptr, "glBindFragDataLocationIndexed");
    glad_glBindSampler = (PFNGLBINDSAMPLERPROC) load(userptr, "glBindSampler");
    glad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC) load(userptr, "glDeleteSamplers");
    glad_glGenSamplers = (PFNGLGENSAMPLERSPROC) load(userptr, "glGenSamplers");
    glad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC) load(userptr, "glGetFragDataIndex");
    glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC) load(userptr, "glGetQueryObjecti64v");
    glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC) load(userptr, "glGetQueryObjectui64v");
    glad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC) load(userptr, "glGetSamplerParameterIiv");
    glad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC) load(userptr, "glGetSamplerParameterIuiv");
    glad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC) load(userptr, "glGetSamplerParameterfv");
    glad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC) load(userptr, "glGetSamplerParameteriv");
    glad_glIsSampler = (PFNGLISSAMPLERPROC) load(userptr, "glIsSampler");
    glad_glQueryCounter = (PFNGLQUERYCOUNTERPROC) load(userptr, "glQueryCounter");
    glad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC) load(userptr, "glSamplerParameterIiv");
    glad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC) load(userptr, "glSamplerParameterIuiv");
    glad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC) load(userptr, "glSamplerParameterf");
    glad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC) load(userptr, "glSamplerParameterfv");
    glad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC) load(userptr, "glSamplerParameteri");
    glad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC) load(userptr, "glSamplerParameteriv");
    glad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC) load(userptr, "glVertexAttribDivisor");
    glad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC) load(userptr, "glVertexAttribP1ui");
    glad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC) load(userptr, "glVertexAttribP1uiv");
    glad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC) load(userptr, "glVertexAttribP2ui");
    glad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC) load(userptr, "glVertexAttribP2uiv");
    glad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC) load(userptr, "glVertexAttribP3ui");
    glad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC) load(userptr, "glVertexAttribP3uiv");
    glad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC) load(userptr, "glVertexAttribP4ui");
    glad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC) load(userptr, "glVertexAttribP4uiv");
}
static void glad_gl_load_GL_VERSION_4_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_0) return;
    glad_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC) load(userptr, "glBeginQueryIndexed");
    glad_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) load(userptr, "glBindTransformFeedback");
    glad_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) load(userptr, "glBlendEquationSeparatei");
    glad_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC) load(userptr, "glBlendEquationi");
    glad_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) load(userptr, "glBlendFuncSeparatei");
    glad_glBlendFunci = (PFNGLBLENDFUNCIPROC) load(userptr, "glBlendFunci");
    glad_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) load(userptr, "glDeleteTransformFeedbacks");
    glad_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) load(userptr, "glDrawArraysIndirect");
    glad_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) load(userptr, "glDrawElementsIndirect");
    glad_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) load(userptr, "glDrawTransformFeedback");
    glad_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) load(userptr, "glDrawTransformFeedbackStream");
    glad_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC) load(userptr, "glEndQueryIndexed");
    glad_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) load(userptr, "glGenTransformFeedbacks");
    glad_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC) load(userptr, "glGetActiveSubroutineName");
    glad_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) load(userptr, "glGetActiveSubroutineUniformName");
    glad_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) load(userptr, "glGetActiveSubroutineUniformiv");
    glad_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC) load(userptr, "glGetProgramStageiv");
    glad_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC) load(userptr, "glGetQueryIndexediv");
    glad_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC) load(userptr, "glGetSubroutineIndex");
    glad_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) load(userptr, "glGetSubroutineUniformLocation");
    glad_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC) load(userptr, "glGetUniformSubroutineuiv");
    glad_glGetUniformdv = (PFNGLGETUNIFORMDVPROC) load(userptr, "glGetUniformdv");
    glad_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) load(userptr, "glIsTransformFeedback");
    glad_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC) load(userptr, "glMinSampleShading");
    glad_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC) load(userptr, "glPatchParameterfv");
    glad_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC) load(userptr, "glPatchParameteri");
    glad_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) load(userptr, "glPauseTransformFeedback");
    glad_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) load(userptr, "glResumeTransformFeedback");
    glad_glUniform1d = (PFNGLUNIFORM1DPROC) load(userptr, "glUniform1d");
    glad_glUniform1dv = (PFNGLUNIFORM1DVPROC) load(userptr, "glUniform1dv");
    glad_glUniform2d = (PFNGLUNIFORM2DPROC) load(userptr, "glUniform2d");
    glad_glUniform2dv = (PFNGLUNIFORM2DVPROC) load(userptr, "glUniform2dv");
    glad_glUniform3d = (PFNGLUNIFORM3DPROC) load(userptr, "glUniform3d");
    glad_glUniform3dv = (PFNGLUNIFORM3DVPROC) load(userptr, "glUniform3dv");
    glad_glUniform4d = (PFNGLUNIFORM4DPROC) load(userptr, "glUniform4d");
    glad_glUniform4dv = (PFNGLUNIFORM4DVPROC) load(userptr, "glUniform4dv");
    glad_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC) load(userptr, "glUniformMatrix2dv");
    glad_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC) load(userptr, "glUniformMatrix2x3dv");
    glad_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC) load(userptr, "glUniformMatrix2x4dv");
    glad_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC) load(userptr, "glUniformMatrix3dv");
    glad_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC) load(userptr, "glUniformMatrix3x2dv");
    glad_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC) load(userptr, "glUniformMatrix3x4dv");
    glad_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC) load(userptr, "glUniformMatrix4dv");
    glad_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC) load(userptr, "glUniformMatrix4x2dv");
    glad_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC) load(userptr, "glUniformMatrix4x3dv");
    glad_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC) load(userptr, "glUniformSubroutinesuiv");
}
static void glad_gl_load_GL_VERSION_4_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_1) return;
    glad_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC) load(userptr, "glActiveShaderProgram");
    glad_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC) load(userptr, "glBindProgramPipeline");
    glad_glClearDepthf = (PFNGLCLEARDEPTHFPROC) load(userptr, "glClearDepthf");
    glad_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC) load(userptr, "glCreateShaderProgramv");
    glad_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC) load(userptr, "glDeleteProgramPipelines");
    glad_glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC) load(userptr, "glDepthRangeArrayv");
    glad_glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC) load(userptr, "glDepthRangeIndexed");
    glad_glDepthRangef = (PFNGLDEPTHRANGEFPROC) load(userptr, "glDepthRangef");
    glad_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC) load(userptr, "glGenProgramPipelines");
    glad_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC) load(userptr, "glGetDoublei_v");
    glad_glGetFloati_v = (PFNGLGETFLOATI_VPROC) load(userptr, "glGetFloati_v");
    glad_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC) load(userptr, "glGetProgramBinary");
    glad_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC) load(userptr, "glGetProgramPipelineInfoLog");
    glad_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC) load(userptr, "glGetProgramPipelineiv");
    glad_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC) load(userptr, "glGetShaderPrecisionFormat");
    glad_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC) load(userptr, "glGetVertexAttribLdv");
    glad_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC) load(userptr, "glIsProgramPipeline");
    glad_glProgramBinary = (PFNGLPROGRAMBINARYPROC) load(userptr, "glProgramBinary");
    glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) load(userptr, "glProgramParameteri");
    glad_glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC) load(userptr, "glProgramUniform1d");
    glad_glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC) load(userptr, "glProgramUniform1dv");
    glad_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC) load(userptr, "glProgramUniform1f");
    glad_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC) load(userptr, "glProgramUniform1fv");
    glad_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC) load(userptr, "glProgramUniform1i");
    glad_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC) load(userptr, "glProgramUniform1iv");
    glad_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC) load(userptr, "glProgramUniform1ui");
    glad_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC) load(userptr, "glProgramUniform1uiv");
    glad_glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC) load(userptr, "glProgramUniform2d");
    glad_glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC) load(userptr, "glProgramUniform2dv");
    glad_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC) load(userptr, "glProgramUniform2f");
    glad_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC) load(userptr, "glProgramUniform2fv");
    glad_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC) load(userptr, "glProgramUniform2i");
    glad_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC) load(userptr, "glProgramUniform2iv");
    glad_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC) load(userptr, "glProgramUniform2ui");
    glad_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC) load(userptr, "glProgramUniform2uiv");
    glad_glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC) load(userptr, "glProgramUniform3d");
    glad_glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC) load(userptr, "glProgramUniform3dv");
    glad_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC) load(userptr, "glProgramUniform3f");
    glad_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC) load(userptr, "glProgramUniform3fv");
    glad_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC) load(userptr, "glProgramUniform3i");
    glad_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC) load(userptr, "glProgramUniform3iv");
    glad_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC) load(userptr, "glProgramUniform3ui");
    glad_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC) load(userptr, "glProgramUniform3uiv");
    glad_glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC) load(userptr, "glProgramUniform4d");
    glad_glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC) load(userptr, "glProgramUniform4dv");
    glad_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC) load(userptr, "glProgramUniform4f");
    glad_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC) load(userptr, "glProgramUniform4fv");
    glad_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC) load(userptr, "glProgramUniform4i");
    glad_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC) load(userptr, "glProgramUniform4iv");
    glad_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC) load(userptr, "glProgramUniform4ui");
    glad_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC) load(userptr, "glProgramUniform4uiv");
    glad_glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC) load(userptr, "glProgramUniformMatrix2dv");
    glad_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC) load(userptr, "glProgramUniformMatrix2fv");
    glad_glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) load(userptr, "glProgramUniformMatrix2x3dv");
    glad_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) load(userptr, "glProgramUniformMatrix2x3fv");
    glad_glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) load(userptr, "glProgramUniformMatrix2x4dv");
    glad_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) load(userptr, "glProgramUniformMatrix2x4fv");
    glad_glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC) load(userptr, "glProgramUniformMatrix3dv");
    glad_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC) load(userptr, "glProgramUniformMatrix3fv");
    glad_glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) load(userptr, "glProgramUniformMatrix3x2dv");
    glad_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) load(userptr, "glProgramUniformMatrix3x2fv");
    glad_glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) load(userptr, "glProgramUniformMatrix3x4dv");
    glad_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) load(userptr, "glProgramUniformMatrix3x4fv");
    glad_glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC) load(userptr, "glProgramUniformMatrix4dv");
    glad_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC) load(userptr, "glProgramUniformMatrix4fv");
    glad_glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) load(userptr, "glProgramUniformMatrix4x2dv");
    glad_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) load(userptr, "glProgramUniformMatrix4x2fv");
    glad_glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) load(userptr, "glProgramUniformMatrix4x3dv");
    glad_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) load(userptr, "glProgramUniformMatrix4x3fv");
    glad_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC) load(userptr, "glReleaseShaderCompiler");
    glad_glScissorArrayv = (PFNGLSCISSORARRAYVPROC) load(userptr, "glScissorArrayv");
    glad_glScissorIndexed = (PFNGLSCISSORINDEXEDPROC) load(userptr, "glScissorIndexed");
    glad_glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC) load(userptr, "glScissorIndexedv");
    glad_glShaderBinary = (PFNGLSHADERBINARYPROC) load(userptr, "glShaderBinary");
    glad_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC) load(userptr, "glUseProgramStages");
    glad_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC) load(userptr, "glValidateProgramPipeline");
    glad_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC) load(userptr, "glVertexAttribL1d");
    glad_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC) load(userptr, "glVertexAttribL1dv");
    glad_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC) load(userptr, "glVertexAttribL2d");
    glad_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC) load(userptr, "glVertexAttribL2dv");
    glad_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC) load(userptr, "glVertexAttribL3d");
    glad_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC) load(userptr, "glVertexAttribL3dv");
    glad_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC) load(userptr, "glVertexAttribL4d");
    glad_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC) load(userptr, "glVertexAttribL4dv");
    glad_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC) load(userptr, "glVertexAttribLPointer");
    glad_glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC) load(userptr, "glViewportArrayv");
    glad_glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC) load(userptr, "glViewportIndexedf");
    glad_glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC) load(userptr, "glViewportIndexedfv");
}
static void glad_gl_load_GL_VERSION_4_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_2) return;
    glad_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC) load(userptr, "glBindImageTexture");
    glad_glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) load(userptr, "glDrawArraysInstancedBaseInstance");
    glad_glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) load(userptr, "glDrawElementsInstancedBaseInstance");
    glad_glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) load(userptr, "glDrawElementsInstancedBaseVertexBaseInstance");
    glad_glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) load(userptr, "glDrawTransformFeedbackInstanced");
    glad_glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) load(userptr, "glDrawTransformFeedbackStreamInstanced");
    glad_glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) load(userptr, "glGetActiveAtomicCounterBufferiv");
    glad_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC) load(userptr, "glGetInternalformativ");
    glad_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC) load(userptr, "glMemoryBarrier");
    glad_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC) load(userptr, "glTexStorage1D");
    glad_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC) load(userptr, "glTexStorage2D");
    glad_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC) load(userptr, "glTexStorage3D");
}
static void glad_gl_load_GL_VERSION_4_3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_3) return;
    glad_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC) load(userptr, "glBindVertexBuffer");
    glad_glClearBufferData = (PFNGLCLEARBUFFERDATAPROC) load(userptr, "glClearBufferData");
    glad_glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC) load(userptr, "glClearBufferSubData");
    glad_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC) load(userptr, "glCopyImageSubData");
    glad_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC) load(userptr, "glDebugMessageCallback");
    glad_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC) load(userptr, "glDebugMessageControl");
    glad_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC) load(userptr, "glDebugMessageInsert");
    glad_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC) load(userptr, "glDispatchCompute");
    glad_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC) load(userptr, "glDispatchComputeIndirect");
    glad_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC) load(userptr, "glFramebufferParameteri");
    glad_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC) load(userptr, "glGetDebugMessageLog");
    glad_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC) load(userptr, "glGetFramebufferParameteriv");
    glad_glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC) load(userptr, "glGetInternalformati64v");
    glad_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC) load(userptr, "glGetObjectLabel");
    glad_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC) load(userptr, "glGetObjectPtrLabel");
    glad_glGetPointerv = (PFNGLGETPOINTERVPROC) load(userptr, "glGetPointerv");
    glad_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC) load(userptr, "glGetProgramInterfaceiv");
    glad_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC) load(userptr, "glGetProgramResourceIndex");
    glad_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC) load(userptr, "glGetProgramResourceLocation");
    glad_glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) load(userptr, "glGetProgramResourceLocationIndex");
    glad_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC) load(userptr, "glGetProgramResourceName");
    glad_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC) load(userptr, "glGetProgramResourceiv");
    glad_glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC) load(userptr, "glInvalidateBufferData");
    glad_glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC) load(userptr, "glInvalidateBufferSubData");
    glad_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC) load(userptr, "glInvalidateFramebuffer");
    glad_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC) load(userptr, "glInvalidateSubFramebuffer");
    glad_glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC) load(userptr, "glInvalidateTexImage");
    glad_glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC) load(userptr, "glInvalidateTexSubImage");
    glad_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC) load(userptr, "glMultiDrawArraysIndirect");
    glad_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC) load(userptr, "glMultiDrawElementsIndirect");
    glad_glObjectLabel = (PFNGLOBJECTLABELPROC) load(userptr, "glObjectLabel");
    glad_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC) load(userptr, "glObjectPtrLabel");
    glad_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC) load(userptr, "glPopDebugGroup");
    glad_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC) load(userptr, "glPushDebugGroup");
    glad_glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC) load(userptr, "glShaderStorageBlockBinding");
    glad_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC) load(userptr, "glTexBufferRange");
    glad_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC) load(userptr, "glTexStorage2DMultisample");
    glad_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC) load(userptr, "glTexStorage3DMultisample");
    glad_glTextureView = (PFNGLTEXTUREVIEWPROC) load(userptr, "glTextureView");
    glad_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC) load(userptr, "glVertexAttribBinding");
    glad_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC) load(userptr, "glVertexAttribFormat");
    glad_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC) load(userptr, "glVertexAttribIFormat");
    glad_glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC) load(userptr, "glVertexAttribLFormat");
    glad_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC) load(userptr, "glVertexBindingDivisor");
}
static void glad_gl_load_GL_VERSION_4_4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_4) return;
    glad_glBindBuffersBase = (PFNGLBINDBUFFERSBASEPROC) load(userptr, "glBindBuffersBase");
    glad_glBindBuffersRange = (PFNGLBINDBUFFERSRANGEPROC) load(userptr, "glBindBuffersRange");
    glad_glBindImageTextures = (PFNGLBINDIMAGETEXTURESPROC) load(userptr, "glBindImageTextures");
    glad_glBindSamplers = (PFNGLBINDSAMPLERSPROC) load(userptr, "glBindSamplers");
    glad_glBindTextures = (PFNGLBINDTEXTURESPROC) load(userptr, "glBindTextures");
    glad_glBindVertexBuffers = (PFNGLBINDVERTEXBUFFERSPROC) load(userptr, "glBindVertexBuffers");
    glad_glBufferStorage = (PFNGLBUFFERSTORAGEPROC) load(userptr, "glBufferStorage");
    glad_glClearTexImage = (PFNGLCLEARTEXIMAGEPROC) load(userptr, "glClearTexImage");
    glad_glClearTexSubImage = (PFNGLCLEARTEXSUBIMAGEPROC) load(userptr, "glClearTexSubImage");
}
static void glad_gl_load_GL_VERSION_4_5( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_5) return;
    glad_glBindTextureUnit = (PFNGLBINDTEXTUREUNITPROC) load(userptr, "glBindTextureUnit");
    glad_glBlitNamedFramebuffer = (PFNGLBLITNAMEDFRAMEBUFFERPROC) load(userptr, "glBlitNamedFramebuffer");
    glad_glCheckNamedFramebufferStatus = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckNamedFramebufferStatus");
    glad_glClearNamedBufferData = (PFNGLCLEARNAMEDBUFFERDATAPROC) load(userptr, "glClearNamedBufferData");
    glad_glClearNamedBufferSubData = (PFNGLCLEARNAMEDBUFFERSUBDATAPROC) load(userptr, "glClearNamedBufferSubData");
    glad_glClearNamedFramebufferfi = (PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) load(userptr, "glClearNamedFramebufferfi");
    glad_glClearNamedFramebufferfv = (PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) load(userptr, "glClearNamedFramebufferfv");
    glad_glClearNamedFramebufferiv = (PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) load(userptr, "glClearNamedFramebufferiv");
    glad_glClearNamedFramebufferuiv = (PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) load(userptr, "glClearNamedFramebufferuiv");
    glad_glClipControl = (PFNGLCLIPCONTROLPROC) load(userptr, "glClipControl");
    glad_glCompressedTextureSubImage1D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) load(userptr, "glCompressedTextureSubImage1D");
    glad_glCompressedTextureSubImage2D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) load(userptr, "glCompressedTextureSubImage2D");
    glad_glCompressedTextureSubImage3D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) load(userptr, "glCompressedTextureSubImage3D");
    glad_glCopyNamedBufferSubData = (PFNGLCOPYNAMEDBUFFERSUBDATAPROC) load(userptr, "glCopyNamedBufferSubData");
    glad_glCopyTextureSubImage1D = (PFNGLCOPYTEXTURESUBIMAGE1DPROC) load(userptr, "glCopyTextureSubImage1D");
    glad_glCopyTextureSubImage2D = (PFNGLCOPYTEXTURESUBIMAGE2DPROC) load(userptr, "glCopyTextureSubImage2D");
    glad_glCopyTextureSubImage3D = (PFNGLCOPYTEXTURESUBIMAGE3DPROC) load(userptr, "glCopyTextureSubImage3D");
    glad_glCreateBuffers = (PFNGLCREATEBUFFERSPROC) load(userptr, "glCreateBuffers");
    glad_glCreateFramebuffers = (PFNGLCREATEFRAMEBUFFERSPROC) load(userptr, "glCreateFramebuffers");
    glad_glCreateProgramPipelines = (PFNGLCREATEPROGRAMPIPELINESPROC) load(userptr, "glCreateProgramPipelines");
    glad_glCreateQueries = (PFNGLCREATEQUERIESPROC) load(userptr, "glCreateQueries");
    glad_glCreateRenderbuffers = (PFNGLCREATERENDERBUFFERSPROC) load(userptr, "glCreateRenderbuffers");
    glad_glCreateSamplers = (PFNGLCREATESAMPLERSPROC) load(userptr, "glCreateSamplers");
    glad_glCreateTextures = (PFNGLCREATETEXTURESPROC) load(userptr, "glCreateTextures");
    glad_glCreateTransformFeedbacks = (PFNGLCREATETRANSFORMFEEDBACKSPROC) load(userptr, "glCreateTransformFeedbacks");
    glad_glCreateVertexArrays = (PFNGLCREATEVERTEXARRAYSPROC) load(userptr, "glCreateVertexArrays");
    glad_glDisableVertexArrayAttrib = (PFNGLDISABLEVERTEXARRAYATTRIBPROC) load(userptr, "glDisableVertexArrayAttrib");
    glad_glEnableVertexArrayAttrib = (PFNGLENABLEVERTEXARRAYATTRIBPROC) load(userptr, "glEnableVertexArrayAttrib");
    glad_glFlushMappedNamedBufferRange = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) load(userptr, "glFlushMappedNamedBufferRange");
    glad_glGenerateTextureMipmap = (PFNGLGENERATETEXTUREMIPMAPPROC) load(userptr, "glGenerateTextureMipmap");
    glad_glGetCompressedTextureImage = (PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) load(userptr, "glGetCompressedTextureImage");
    glad_glGetCompressedTextureSubImage = (PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) load(userptr, "glGetCompressedTextureSubImage");
    glad_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC) load(userptr, "glGetGraphicsResetStatus");
    glad_glGetNamedBufferParameteri64v = (PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) load(userptr, "glGetNamedBufferParameteri64v");
    glad_glGetNamedBufferParameteriv = (PFNGLGETNAMEDBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedBufferParameteriv");
    glad_glGetNamedBufferPointerv = (PFNGLGETNAMEDBUFFERPOINTERVPROC) load(userptr, "glGetNamedBufferPointerv");
    glad_glGetNamedBufferSubData = (PFNGLGETNAMEDBUFFERSUBDATAPROC) load(userptr, "glGetNamedBufferSubData");
    glad_glGetNamedFramebufferAttachmentParameteriv = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetNamedFramebufferAttachmentParameteriv");
    glad_glGetNamedFramebufferParameteriv = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedFramebufferParameteriv");
    glad_glGetNamedRenderbufferParameteriv = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedRenderbufferParameteriv");
    glad_glGetQueryBufferObjecti64v = (PFNGLGETQUERYBUFFEROBJECTI64VPROC) load(userptr, "glGetQueryBufferObjecti64v");
    glad_glGetQueryBufferObjectiv = (PFNGLGETQUERYBUFFEROBJECTIVPROC) load(userptr, "glGetQueryBufferObjectiv");
    glad_glGetQueryBufferObjectui64v = (PFNGLGETQUERYBUFFEROBJECTUI64VPROC) load(userptr, "glGetQueryBufferObjectui64v");
    glad_glGetQueryBufferObjectuiv = (PFNGLGETQUERYBUFFEROBJECTUIVPROC) load(userptr, "glGetQueryBufferObjectuiv");
    glad_glGetTextureImage = (PFNGLGETTEXTUREIMAGEPROC) load(userptr, "glGetTextureImage");
    glad_glGetTextureLevelParameterfv = (PFNGLGETTEXTURELEVELPARAMETERFVPROC) load(userptr, "glGetTextureLevelParameterfv");
    glad_glGetTextureLevelParameteriv = (PFNGLGETTEXTURELEVELPARAMETERIVPROC) load(userptr, "glGetTextureLevelParameteriv");
    glad_glGetTextureParameterIiv = (PFNGLGETTEXTUREPARAMETERIIVPROC) load(userptr, "glGetTextureParameterIiv");
    glad_glGetTextureParameterIuiv = (PFNGLGETTEXTUREPARAMETERIUIVPROC) load(userptr, "glGetTextureParameterIuiv");
    glad_glGetTextureParameterfv = (PFNGLGETTEXTUREPARAMETERFVPROC) load(userptr, "glGetTextureParameterfv");
    glad_glGetTextureParameteriv = (PFNGLGETTEXTUREPARAMETERIVPROC) load(userptr, "glGetTextureParameteriv");
    glad_glGetTextureSubImage = (PFNGLGETTEXTURESUBIMAGEPROC) load(userptr, "glGetTextureSubImage");
    glad_glGetTransformFeedbacki64_v = (PFNGLGETTRANSFORMFEEDBACKI64_VPROC) load(userptr, "glGetTransformFeedbacki64_v");
    glad_glGetTransformFeedbacki_v = (PFNGLGETTRANSFORMFEEDBACKI_VPROC) load(userptr, "glGetTransformFeedbacki_v");
    glad_glGetTransformFeedbackiv = (PFNGLGETTRANSFORMFEEDBACKIVPROC) load(userptr, "glGetTransformFeedbackiv");
    glad_glGetVertexArrayIndexed64iv = (PFNGLGETVERTEXARRAYINDEXED64IVPROC) load(userptr, "glGetVertexArrayIndexed64iv");
    glad_glGetVertexArrayIndexediv = (PFNGLGETVERTEXARRAYINDEXEDIVPROC) load(userptr, "glGetVertexArrayIndexediv");
    glad_glGetVertexArrayiv = (PFNGLGETVERTEXARRAYIVPROC) load(userptr, "glGetVertexArrayiv");
    glad_glGetnCompressedTexImage = (PFNGLGETNCOMPRESSEDTEXIMAGEPROC) load(userptr, "glGetnCompressedTexImage");
    glad_glGetnTexImage = (PFNGLGETNTEXIMAGEPROC) load(userptr, "glGetnTexImage");
    glad_glGetnUniformdv = (PFNGLGETNUNIFORMDVPROC) load(userptr, "glGetnUniformdv");
    glad_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC) load(userptr, "glGetnUniformfv");
    glad_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC) load(userptr, "glGetnUniformiv");
    glad_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC) load(userptr, "glGetnUniformuiv");
    glad_glInvalidateNamedFramebufferData = (PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) load(userptr, "glInvalidateNamedFramebufferData");
    glad_glInvalidateNamedFramebufferSubData = (PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) load(userptr, "glInvalidateNamedFramebufferSubData");
    glad_glMapNamedBuffer = (PFNGLMAPNAMEDBUFFERPROC) load(userptr, "glMapNamedBuffer");
    glad_glMapNamedBufferRange = (PFNGLMAPNAMEDBUFFERRANGEPROC) load(userptr, "glMapNamedBufferRange");
    glad_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC) load(userptr, "glMemoryBarrierByRegion");
    glad_glNamedBufferData = (PFNGLNAMEDBUFFERDATAPROC) load(userptr, "glNamedBufferData");
    glad_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC) load(userptr, "glNamedBufferStorage");
    glad_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC) load(userptr, "glNamedBufferSubData");
    glad_glNamedFramebufferDrawBuffer = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) load(userptr, "glNamedFramebufferDrawBuffer");
    glad_glNamedFramebufferDrawBuffers = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) load(userptr, "glNamedFramebufferDrawBuffers");
    glad_glNamedFramebufferParameteri = (PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) load(userptr, "glNamedFramebufferParameteri");
    glad_glNamedFramebufferReadBuffer = (PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) load(userptr, "glNamedFramebufferReadBuffer");
    glad_glNamedFramebufferRenderbuffer = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glNamedFramebufferRenderbuffer");
    glad_glNamedFramebufferTexture = (PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) load(userptr, "glNamedFramebufferTexture");
    glad_glNamedFramebufferTextureLayer = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glNamedFramebufferTextureLayer");
    glad_glNamedRenderbufferStorage = (PFNGLNAMEDRENDERBUFFERSTORAGEPROC) load(userptr, "glNamedRenderbufferStorage");
    glad_glNamedRenderbufferStorageMultisample = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glNamedRenderbufferStorageMultisample");
    glad_glReadnPixels = (PFNGLREADNPIXELSPROC) load(userptr, "glReadnPixels");
    glad_glTextureBarrier = (PFNGLTEXTUREBARRIERPROC) load(userptr, "glTextureBarrier");
    glad_glTextureBuffer = (PFNGLTEXTUREBUFFERPROC) load(userptr, "glTextureBuffer");
    glad_glTextureBufferRange = (PFNGLTEXTUREBUFFERRANGEPROC) load(userptr, "glTextureBufferRange");
    glad_glTextureParameterIiv = (PFNGLTEXTUREPARAMETERIIVPROC) load(userptr, "glTextureParameterIiv");
    glad_glTextureParameterIuiv = (PFNGLTEXTUREPARAMETERIUIVPROC) load(userptr, "glTextureParameterIuiv");
    glad_glTextureParameterf = (PFNGLTEXTUREPARAMETERFPROC) load(userptr, "glTextureParameterf");
    glad_glTextureParameterfv = (PFNGLTEXTUREPARAMETERFVPROC) load(userptr, "glTextureParameterfv");
    glad_glTextureParameteri = (PFNGLTEXTUREPARAMETERIPROC) load(userptr, "glTextureParameteri");
    glad_glTextureParameteriv = (PFNGLTEXTUREPARAMETERIVPROC) load(userptr, "glTextureParameteriv");
    glad_glTextureStorage1D = (PFNGLTEXTURESTORAGE1DPROC) load(userptr, "glTextureStorage1D");
    glad_glTextureStorage2D = (PFNGLTEXTURESTORAGE2DPROC) load(userptr, "glTextureStorage2D");
    glad_glTextureStorage2DMultisample = (PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) load(userptr, "glTextureStorage2DMultisample");
    glad_glTextureStorage3D = (PFNGLTEXTURESTORAGE3DPROC) load(userptr, "glTextureStorage3D");
    glad_glTextureStorage3DMultisample = (PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) load(userptr, "glTextureStorage3DMultisample");
    glad_glTextureSubImage1D = (PFNGLTEXTURESUBIMAGE1DPROC) load(userptr, "glTextureSubImage1D");
    glad_glTextureSubImage2D = (PFNGLTEXTURESUBIMAGE2DPROC) load(userptr, "glTextureSubImage2D");
    glad_glTextureSubImage3D = (PFNGLTEXTURESUBIMAGE3DPROC) load(userptr, "glTextureSubImage3D");
    glad_glTransformFeedbackBufferBase = (PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) load(userptr, "glTransformFeedbackBufferBase");
    glad_glTransformFeedbackBufferRange = (PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) load(userptr, "glTransformFeedbackBufferRange");
    glad_glUnmapNamedBuffer = (PFNGLUNMAPNAMEDBUFFERPROC) load(userptr, "glUnmapNamedBuffer");
    glad_glVertexArrayAttribBinding = (PFNGLVERTEXARRAYATTRIBBINDINGPROC) load(userptr, "glVertexArrayAttribBinding");
    glad_glVertexArrayAttribFormat = (PFNGLVERTEXARRAYATTRIBFORMATPROC) load(userptr, "glVertexArrayAttribFormat");
    glad_glVertexArrayAttribIFormat = (PFNGLVERTEXARRAYATTRIBIFORMATPROC) load(userptr, "glVertexArrayAttribIFormat");
    glad_glVertexArrayAttribLFormat = (PFNGLVERTEXARRAYATTRIBLFORMATPROC) load(userptr, "glVertexArrayAttribLFormat");
    glad_glVertexArrayBindingDivisor = (PFNGLVERTEXARRAYBINDINGDIVISORPROC) load(userptr, "glVertexArrayBindingDivisor");
    glad_glVertexArrayElementBuffer = (PFNGLVERTEXARRAYELEMENTBUFFERPROC) load(userptr, "glVertexArrayElementBuffer");
    glad_glVertexArrayVertexBuffer = (PFNGLVERTEXARRAYVERTEXBUFFERPROC) load(userptr, "glVertexArrayVertexBuffer");
    glad_glVertexArrayVertexBuffers = (PFNGLVERTEXARRAYVERTEXBUFFERSPROC) load(userptr, "glVertexArrayVertexBuffers");
}
static void glad_gl_load_GL_VERSION_4_6( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_VERSION_4_6) return;
    glad_glMultiDrawArraysIndirectCount = (PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) load(userptr, "glMultiDrawArraysIndirectCount");
    glad_glMultiDrawElementsIndirectCount = (PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) load(userptr, "glMultiDrawElementsIndirectCount");
    glad_glPolygonOffsetClamp = (PFNGLPOLYGONOFFSETCLAMPPROC) load(userptr, "glPolygonOffsetClamp");
    glad_glSpecializeShader = (PFNGLSPECIALIZESHADERPROC) load(userptr, "glSpecializeShader");
}
static void glad_gl_load_GL_AMD_debug_output( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_debug_output) return;
    glad_glDebugMessageCallbackAMD = (PFNGLDEBUGMESSAGECALLBACKAMDPROC) load(userptr, "glDebugMessageCallbackAMD");
    glad_glDebugMessageEnableAMD = (PFNGLDEBUGMESSAGEENABLEAMDPROC) load(userptr, "glDebugMessageEnableAMD");
    glad_glDebugMessageInsertAMD = (PFNGLDEBUGMESSAGEINSERTAMDPROC) load(userptr, "glDebugMessageInsertAMD");
    glad_glGetDebugMessageLogAMD = (PFNGLGETDEBUGMESSAGELOGAMDPROC) load(userptr, "glGetDebugMessageLogAMD");
}
static void glad_gl_load_GL_AMD_draw_buffers_blend( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_draw_buffers_blend) return;
    glad_glBlendEquationIndexedAMD = (PFNGLBLENDEQUATIONINDEXEDAMDPROC) load(userptr, "glBlendEquationIndexedAMD");
    glad_glBlendEquationSeparateIndexedAMD = (PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) load(userptr, "glBlendEquationSeparateIndexedAMD");
    glad_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) load(userptr, "glBlendEquationSeparatei");
    glad_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC) load(userptr, "glBlendEquationi");
    glad_glBlendFuncIndexedAMD = (PFNGLBLENDFUNCINDEXEDAMDPROC) load(userptr, "glBlendFuncIndexedAMD");
    glad_glBlendFuncSeparateIndexedAMD = (PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) load(userptr, "glBlendFuncSeparateIndexedAMD");
    glad_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) load(userptr, "glBlendFuncSeparatei");
    glad_glBlendFunci = (PFNGLBLENDFUNCIPROC) load(userptr, "glBlendFunci");
}
static void glad_gl_load_GL_AMD_framebuffer_sample_positions( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_framebuffer_sample_positions) return;
    glad_glFramebufferSamplePositionsfvAMD = (PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) load(userptr, "glFramebufferSamplePositionsfvAMD");
    glad_glGetFramebufferParameterfvAMD = (PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC) load(userptr, "glGetFramebufferParameterfvAMD");
    glad_glGetNamedFramebufferParameterfvAMD = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC) load(userptr, "glGetNamedFramebufferParameterfvAMD");
    glad_glNamedFramebufferSamplePositionsfvAMD = (PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) load(userptr, "glNamedFramebufferSamplePositionsfvAMD");
}
static void glad_gl_load_GL_AMD_gpu_shader_int64( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_gpu_shader_int64) return;
    glad_glGetUniformi64vNV = (PFNGLGETUNIFORMI64VNVPROC) load(userptr, "glGetUniformi64vNV");
    glad_glGetUniformui64vNV = (PFNGLGETUNIFORMUI64VNVPROC) load(userptr, "glGetUniformui64vNV");
    glad_glProgramUniform1i64NV = (PFNGLPROGRAMUNIFORM1I64NVPROC) load(userptr, "glProgramUniform1i64NV");
    glad_glProgramUniform1i64vNV = (PFNGLPROGRAMUNIFORM1I64VNVPROC) load(userptr, "glProgramUniform1i64vNV");
    glad_glProgramUniform1ui64NV = (PFNGLPROGRAMUNIFORM1UI64NVPROC) load(userptr, "glProgramUniform1ui64NV");
    glad_glProgramUniform1ui64vNV = (PFNGLPROGRAMUNIFORM1UI64VNVPROC) load(userptr, "glProgramUniform1ui64vNV");
    glad_glProgramUniform2i64NV = (PFNGLPROGRAMUNIFORM2I64NVPROC) load(userptr, "glProgramUniform2i64NV");
    glad_glProgramUniform2i64vNV = (PFNGLPROGRAMUNIFORM2I64VNVPROC) load(userptr, "glProgramUniform2i64vNV");
    glad_glProgramUniform2ui64NV = (PFNGLPROGRAMUNIFORM2UI64NVPROC) load(userptr, "glProgramUniform2ui64NV");
    glad_glProgramUniform2ui64vNV = (PFNGLPROGRAMUNIFORM2UI64VNVPROC) load(userptr, "glProgramUniform2ui64vNV");
    glad_glProgramUniform3i64NV = (PFNGLPROGRAMUNIFORM3I64NVPROC) load(userptr, "glProgramUniform3i64NV");
    glad_glProgramUniform3i64vNV = (PFNGLPROGRAMUNIFORM3I64VNVPROC) load(userptr, "glProgramUniform3i64vNV");
    glad_glProgramUniform3ui64NV = (PFNGLPROGRAMUNIFORM3UI64NVPROC) load(userptr, "glProgramUniform3ui64NV");
    glad_glProgramUniform3ui64vNV = (PFNGLPROGRAMUNIFORM3UI64VNVPROC) load(userptr, "glProgramUniform3ui64vNV");
    glad_glProgramUniform4i64NV = (PFNGLPROGRAMUNIFORM4I64NVPROC) load(userptr, "glProgramUniform4i64NV");
    glad_glProgramUniform4i64vNV = (PFNGLPROGRAMUNIFORM4I64VNVPROC) load(userptr, "glProgramUniform4i64vNV");
    glad_glProgramUniform4ui64NV = (PFNGLPROGRAMUNIFORM4UI64NVPROC) load(userptr, "glProgramUniform4ui64NV");
    glad_glProgramUniform4ui64vNV = (PFNGLPROGRAMUNIFORM4UI64VNVPROC) load(userptr, "glProgramUniform4ui64vNV");
    glad_glUniform1i64NV = (PFNGLUNIFORM1I64NVPROC) load(userptr, "glUniform1i64NV");
    glad_glUniform1i64vNV = (PFNGLUNIFORM1I64VNVPROC) load(userptr, "glUniform1i64vNV");
    glad_glUniform1ui64NV = (PFNGLUNIFORM1UI64NVPROC) load(userptr, "glUniform1ui64NV");
    glad_glUniform1ui64vNV = (PFNGLUNIFORM1UI64VNVPROC) load(userptr, "glUniform1ui64vNV");
    glad_glUniform2i64NV = (PFNGLUNIFORM2I64NVPROC) load(userptr, "glUniform2i64NV");
    glad_glUniform2i64vNV = (PFNGLUNIFORM2I64VNVPROC) load(userptr, "glUniform2i64vNV");
    glad_glUniform2ui64NV = (PFNGLUNIFORM2UI64NVPROC) load(userptr, "glUniform2ui64NV");
    glad_glUniform2ui64vNV = (PFNGLUNIFORM2UI64VNVPROC) load(userptr, "glUniform2ui64vNV");
    glad_glUniform3i64NV = (PFNGLUNIFORM3I64NVPROC) load(userptr, "glUniform3i64NV");
    glad_glUniform3i64vNV = (PFNGLUNIFORM3I64VNVPROC) load(userptr, "glUniform3i64vNV");
    glad_glUniform3ui64NV = (PFNGLUNIFORM3UI64NVPROC) load(userptr, "glUniform3ui64NV");
    glad_glUniform3ui64vNV = (PFNGLUNIFORM3UI64VNVPROC) load(userptr, "glUniform3ui64vNV");
    glad_glUniform4i64NV = (PFNGLUNIFORM4I64NVPROC) load(userptr, "glUniform4i64NV");
    glad_glUniform4i64vNV = (PFNGLUNIFORM4I64VNVPROC) load(userptr, "glUniform4i64vNV");
    glad_glUniform4ui64NV = (PFNGLUNIFORM4UI64NVPROC) load(userptr, "glUniform4ui64NV");
    glad_glUniform4ui64vNV = (PFNGLUNIFORM4UI64VNVPROC) load(userptr, "glUniform4ui64vNV");
}
static void glad_gl_load_GL_AMD_interleaved_elements( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_interleaved_elements) return;
    glad_glVertexAttribParameteriAMD = (PFNGLVERTEXATTRIBPARAMETERIAMDPROC) load(userptr, "glVertexAttribParameteriAMD");
}
static void glad_gl_load_GL_AMD_multi_draw_indirect( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_multi_draw_indirect) return;
    glad_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC) load(userptr, "glMultiDrawArraysIndirect");
    glad_glMultiDrawArraysIndirectAMD = (PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) load(userptr, "glMultiDrawArraysIndirectAMD");
    glad_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC) load(userptr, "glMultiDrawElementsIndirect");
    glad_glMultiDrawElementsIndirectAMD = (PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) load(userptr, "glMultiDrawElementsIndirectAMD");
}
static void glad_gl_load_GL_AMD_name_gen_delete( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_name_gen_delete) return;
    glad_glDeleteNamesAMD = (PFNGLDELETENAMESAMDPROC) load(userptr, "glDeleteNamesAMD");
    glad_glGenNamesAMD = (PFNGLGENNAMESAMDPROC) load(userptr, "glGenNamesAMD");
    glad_glIsNameAMD = (PFNGLISNAMEAMDPROC) load(userptr, "glIsNameAMD");
}
static void glad_gl_load_GL_AMD_occlusion_query_event( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_occlusion_query_event) return;
    glad_glQueryObjectParameteruiAMD = (PFNGLQUERYOBJECTPARAMETERUIAMDPROC) load(userptr, "glQueryObjectParameteruiAMD");
}
static void glad_gl_load_GL_AMD_performance_monitor( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_performance_monitor) return;
    glad_glBeginPerfMonitorAMD = (PFNGLBEGINPERFMONITORAMDPROC) load(userptr, "glBeginPerfMonitorAMD");
    glad_glDeletePerfMonitorsAMD = (PFNGLDELETEPERFMONITORSAMDPROC) load(userptr, "glDeletePerfMonitorsAMD");
    glad_glEndPerfMonitorAMD = (PFNGLENDPERFMONITORAMDPROC) load(userptr, "glEndPerfMonitorAMD");
    glad_glGenPerfMonitorsAMD = (PFNGLGENPERFMONITORSAMDPROC) load(userptr, "glGenPerfMonitorsAMD");
    glad_glGetPerfMonitorCounterDataAMD = (PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) load(userptr, "glGetPerfMonitorCounterDataAMD");
    glad_glGetPerfMonitorCounterInfoAMD = (PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) load(userptr, "glGetPerfMonitorCounterInfoAMD");
    glad_glGetPerfMonitorCounterStringAMD = (PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) load(userptr, "glGetPerfMonitorCounterStringAMD");
    glad_glGetPerfMonitorCountersAMD = (PFNGLGETPERFMONITORCOUNTERSAMDPROC) load(userptr, "glGetPerfMonitorCountersAMD");
    glad_glGetPerfMonitorGroupStringAMD = (PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) load(userptr, "glGetPerfMonitorGroupStringAMD");
    glad_glGetPerfMonitorGroupsAMD = (PFNGLGETPERFMONITORGROUPSAMDPROC) load(userptr, "glGetPerfMonitorGroupsAMD");
    glad_glSelectPerfMonitorCountersAMD = (PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) load(userptr, "glSelectPerfMonitorCountersAMD");
}
static void glad_gl_load_GL_AMD_sample_positions( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_sample_positions) return;
    glad_glSetMultisamplefvAMD = (PFNGLSETMULTISAMPLEFVAMDPROC) load(userptr, "glSetMultisamplefvAMD");
}
static void glad_gl_load_GL_AMD_sparse_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_sparse_texture) return;
    glad_glTexStorageSparseAMD = (PFNGLTEXSTORAGESPARSEAMDPROC) load(userptr, "glTexStorageSparseAMD");
    glad_glTextureStorageSparseAMD = (PFNGLTEXTURESTORAGESPARSEAMDPROC) load(userptr, "glTextureStorageSparseAMD");
}
static void glad_gl_load_GL_AMD_stencil_operation_extended( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_stencil_operation_extended) return;
    glad_glStencilOpValueAMD = (PFNGLSTENCILOPVALUEAMDPROC) load(userptr, "glStencilOpValueAMD");
}
static void glad_gl_load_GL_AMD_vertex_shader_tessellator( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_AMD_vertex_shader_tessellator) return;
    glad_glTessellationFactorAMD = (PFNGLTESSELLATIONFACTORAMDPROC) load(userptr, "glTessellationFactorAMD");
    glad_glTessellationModeAMD = (PFNGLTESSELLATIONMODEAMDPROC) load(userptr, "glTessellationModeAMD");
}
static void glad_gl_load_GL_APPLE_element_array( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_APPLE_element_array) return;
    glad_glDrawElementArrayAPPLE = (PFNGLDRAWELEMENTARRAYAPPLEPROC) load(userptr, "glDrawElementArrayAPPLE");
    glad_glDrawRangeElementArrayAPPLE = (PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) load(userptr, "glDrawRangeElementArrayAPPLE");
    glad_glElementPointerAPPLE = (PFNGLELEMENTPOINTERAPPLEPROC) load(userptr, "glElementPointerAPPLE");
    glad_glMultiDrawElementArrayAPPLE = (PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) load(userptr, "glMultiDrawElementArrayAPPLE");
    glad_glMultiDrawRangeElementArrayAPPLE = (PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) load(userptr, "glMultiDrawRangeElementArrayAPPLE");
}
static void glad_gl_load_GL_APPLE_fence( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_APPLE_fence) return;
    glad_glDeleteFencesAPPLE = (PFNGLDELETEFENCESAPPLEPROC) load(userptr, "glDeleteFencesAPPLE");
    glad_glFinishFenceAPPLE = (PFNGLFINISHFENCEAPPLEPROC) load(userptr, "glFinishFenceAPPLE");
    glad_glFinishObjectAPPLE = (PFNGLFINISHOBJECTAPPLEPROC) load(userptr, "glFinishObjectAPPLE");
    glad_glGenFencesAPPLE = (PFNGLGENFENCESAPPLEPROC) load(userptr, "glGenFencesAPPLE");
    glad_glIsFenceAPPLE = (PFNGLISFENCEAPPLEPROC) load(userptr, "glIsFenceAPPLE");
    glad_glSetFenceAPPLE = (PFNGLSETFENCEAPPLEPROC) load(userptr, "glSetFenceAPPLE");
    glad_glTestFenceAPPLE = (PFNGLTESTFENCEAPPLEPROC) load(userptr, "glTestFenceAPPLE");
    glad_glTestObjectAPPLE = (PFNGLTESTOBJECTAPPLEPROC) load(userptr, "glTestObjectAPPLE");
}
static void glad_gl_load_GL_APPLE_flush_buffer_range( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_APPLE_flush_buffer_range) return;
    glad_glBufferParameteriAPPLE = (PFNGLBUFFERPARAMETERIAPPLEPROC) load(userptr, "glBufferParameteriAPPLE");
    glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC) load(userptr, "glFlushMappedBufferRange");
    glad_glFlushMappedBufferRangeAPPLE = (PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) load(userptr, "glFlushMappedBufferRangeAPPLE");
}
static void glad_gl_load_GL_APPLE_object_purgeable( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_APPLE_object_purgeable) return;
    glad_glGetObjectParameterivAPPLE = (PFNGLGETOBJECTPARAMETERIVAPPLEPROC) load(userptr, "glGetObjectParameterivAPPLE");
    glad_glObjectPurgeableAPPLE = (PFNGLOBJECTPURGEABLEAPPLEPROC) load(userptr, "glObjectPurgeableAPPLE");
    glad_glObjectUnpurgeableAPPLE = (PFNGLOBJECTUNPURGEABLEAPPLEPROC) load(userptr, "glObjectUnpurgeableAPPLE");
}
static void glad_gl_load_GL_APPLE_texture_range( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_APPLE_texture_range) return;
    glad_glGetTexParameterPointervAPPLE = (PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) load(userptr, "glGetTexParameterPointervAPPLE");
    glad_glTextureRangeAPPLE = (PFNGLTEXTURERANGEAPPLEPROC) load(userptr, "glTextureRangeAPPLE");
}
static void glad_gl_load_GL_APPLE_vertex_array_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_APPLE_vertex_array_object) return;
    glad_glBindVertexArrayAPPLE = (PFNGLBINDVERTEXARRAYAPPLEPROC) load(userptr, "glBindVertexArrayAPPLE");
    glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC) load(userptr, "glDeleteVertexArrays");
    glad_glDeleteVertexArraysAPPLE = (PFNGLDELETEVERTEXARRAYSAPPLEPROC) load(userptr, "glDeleteVertexArraysAPPLE");
    glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC) load(userptr, "glGenVertexArrays");
    glad_glGenVertexArraysAPPLE = (PFNGLGENVERTEXARRAYSAPPLEPROC) load(userptr, "glGenVertexArraysAPPLE");
    glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC) load(userptr, "glIsVertexArray");
    glad_glIsVertexArrayAPPLE = (PFNGLISVERTEXARRAYAPPLEPROC) load(userptr, "glIsVertexArrayAPPLE");
}
static void glad_gl_load_GL_APPLE_vertex_array_range( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_APPLE_vertex_array_range) return;
    glad_glFlushVertexArrayRangeAPPLE = (PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) load(userptr, "glFlushVertexArrayRangeAPPLE");
    glad_glVertexArrayParameteriAPPLE = (PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) load(userptr, "glVertexArrayParameteriAPPLE");
    glad_glVertexArrayRangeAPPLE = (PFNGLVERTEXARRAYRANGEAPPLEPROC) load(userptr, "glVertexArrayRangeAPPLE");
}
static void glad_gl_load_GL_APPLE_vertex_program_evaluators( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_APPLE_vertex_program_evaluators) return;
    glad_glDisableVertexAttribAPPLE = (PFNGLDISABLEVERTEXATTRIBAPPLEPROC) load(userptr, "glDisableVertexAttribAPPLE");
    glad_glEnableVertexAttribAPPLE = (PFNGLENABLEVERTEXATTRIBAPPLEPROC) load(userptr, "glEnableVertexAttribAPPLE");
    glad_glIsVertexAttribEnabledAPPLE = (PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) load(userptr, "glIsVertexAttribEnabledAPPLE");
    glad_glMapVertexAttrib1dAPPLE = (PFNGLMAPVERTEXATTRIB1DAPPLEPROC) load(userptr, "glMapVertexAttrib1dAPPLE");
    glad_glMapVertexAttrib1fAPPLE = (PFNGLMAPVERTEXATTRIB1FAPPLEPROC) load(userptr, "glMapVertexAttrib1fAPPLE");
    glad_glMapVertexAttrib2dAPPLE = (PFNGLMAPVERTEXATTRIB2DAPPLEPROC) load(userptr, "glMapVertexAttrib2dAPPLE");
    glad_glMapVertexAttrib2fAPPLE = (PFNGLMAPVERTEXATTRIB2FAPPLEPROC) load(userptr, "glMapVertexAttrib2fAPPLE");
}
static void glad_gl_load_GL_ARB_ES2_compatibility( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_ES2_compatibility) return;
    glad_glClearDepthf = (PFNGLCLEARDEPTHFPROC) load(userptr, "glClearDepthf");
    glad_glDepthRangef = (PFNGLDEPTHRANGEFPROC) load(userptr, "glDepthRangef");
    glad_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC) load(userptr, "glGetShaderPrecisionFormat");
    glad_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC) load(userptr, "glReleaseShaderCompiler");
    glad_glShaderBinary = (PFNGLSHADERBINARYPROC) load(userptr, "glShaderBinary");
}
static void glad_gl_load_GL_ARB_ES3_1_compatibility( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_ES3_1_compatibility) return;
    glad_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC) load(userptr, "glMemoryBarrierByRegion");
}
static void glad_gl_load_GL_ARB_ES3_2_compatibility( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_ES3_2_compatibility) return;
    glad_glPrimitiveBoundingBox = (PFNGLPRIMITIVEBOUNDINGBOXPROC) load(userptr, "glPrimitiveBoundingBox");
    glad_glPrimitiveBoundingBoxARB = (PFNGLPRIMITIVEBOUNDINGBOXARBPROC) load(userptr, "glPrimitiveBoundingBoxARB");
}
static void glad_gl_load_GL_ARB_base_instance( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_base_instance) return;
    glad_glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) load(userptr, "glDrawArraysInstancedBaseInstance");
    glad_glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) load(userptr, "glDrawElementsInstancedBaseInstance");
    glad_glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) load(userptr, "glDrawElementsInstancedBaseVertexBaseInstance");
}
static void glad_gl_load_GL_ARB_bindless_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_bindless_texture) return;
    glad_glGetImageHandleARB = (PFNGLGETIMAGEHANDLEARBPROC) load(userptr, "glGetImageHandleARB");
    glad_glGetTextureHandleARB = (PFNGLGETTEXTUREHANDLEARBPROC) load(userptr, "glGetTextureHandleARB");
    glad_glGetTextureSamplerHandleARB = (PFNGLGETTEXTURESAMPLERHANDLEARBPROC) load(userptr, "glGetTextureSamplerHandleARB");
    glad_glGetVertexAttribLui64vARB = (PFNGLGETVERTEXATTRIBLUI64VARBPROC) load(userptr, "glGetVertexAttribLui64vARB");
    glad_glIsImageHandleResidentARB = (PFNGLISIMAGEHANDLERESIDENTARBPROC) load(userptr, "glIsImageHandleResidentARB");
    glad_glIsTextureHandleResidentARB = (PFNGLISTEXTUREHANDLERESIDENTARBPROC) load(userptr, "glIsTextureHandleResidentARB");
    glad_glMakeImageHandleNonResidentARB = (PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) load(userptr, "glMakeImageHandleNonResidentARB");
    glad_glMakeImageHandleResidentARB = (PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) load(userptr, "glMakeImageHandleResidentARB");
    glad_glMakeTextureHandleNonResidentARB = (PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) load(userptr, "glMakeTextureHandleNonResidentARB");
    glad_glMakeTextureHandleResidentARB = (PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) load(userptr, "glMakeTextureHandleResidentARB");
    glad_glProgramUniformHandleui64ARB = (PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) load(userptr, "glProgramUniformHandleui64ARB");
    glad_glProgramUniformHandleui64vARB = (PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) load(userptr, "glProgramUniformHandleui64vARB");
    glad_glUniformHandleui64ARB = (PFNGLUNIFORMHANDLEUI64ARBPROC) load(userptr, "glUniformHandleui64ARB");
    glad_glUniformHandleui64vARB = (PFNGLUNIFORMHANDLEUI64VARBPROC) load(userptr, "glUniformHandleui64vARB");
    glad_glVertexAttribL1ui64ARB = (PFNGLVERTEXATTRIBL1UI64ARBPROC) load(userptr, "glVertexAttribL1ui64ARB");
    glad_glVertexAttribL1ui64vARB = (PFNGLVERTEXATTRIBL1UI64VARBPROC) load(userptr, "glVertexAttribL1ui64vARB");
}
static void glad_gl_load_GL_ARB_blend_func_extended( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_blend_func_extended) return;
    glad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) load(userptr, "glBindFragDataLocationIndexed");
    glad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC) load(userptr, "glGetFragDataIndex");
}
static void glad_gl_load_GL_ARB_buffer_storage( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_buffer_storage) return;
    glad_glBufferStorage = (PFNGLBUFFERSTORAGEPROC) load(userptr, "glBufferStorage");
}
static void glad_gl_load_GL_ARB_cl_event( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_cl_event) return;
    glad_glCreateSyncFromCLeventARB = (PFNGLCREATESYNCFROMCLEVENTARBPROC) load(userptr, "glCreateSyncFromCLeventARB");
}
static void glad_gl_load_GL_ARB_clear_buffer_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_clear_buffer_object) return;
    glad_glClearBufferData = (PFNGLCLEARBUFFERDATAPROC) load(userptr, "glClearBufferData");
    glad_glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC) load(userptr, "glClearBufferSubData");
}
static void glad_gl_load_GL_ARB_clear_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_clear_texture) return;
    glad_glClearTexImage = (PFNGLCLEARTEXIMAGEPROC) load(userptr, "glClearTexImage");
    glad_glClearTexSubImage = (PFNGLCLEARTEXSUBIMAGEPROC) load(userptr, "glClearTexSubImage");
}
static void glad_gl_load_GL_ARB_clip_control( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_clip_control) return;
    glad_glClipControl = (PFNGLCLIPCONTROLPROC) load(userptr, "glClipControl");
}
static void glad_gl_load_GL_ARB_color_buffer_float( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_color_buffer_float) return;
    glad_glClampColor = (PFNGLCLAMPCOLORPROC) load(userptr, "glClampColor");
    glad_glClampColorARB = (PFNGLCLAMPCOLORARBPROC) load(userptr, "glClampColorARB");
}
static void glad_gl_load_GL_ARB_compute_shader( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_compute_shader) return;
    glad_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC) load(userptr, "glDispatchCompute");
    glad_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC) load(userptr, "glDispatchComputeIndirect");
}
static void glad_gl_load_GL_ARB_compute_variable_group_size( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_compute_variable_group_size) return;
    glad_glDispatchComputeGroupSizeARB = (PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) load(userptr, "glDispatchComputeGroupSizeARB");
}
static void glad_gl_load_GL_ARB_copy_buffer( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_copy_buffer) return;
    glad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) load(userptr, "glCopyBufferSubData");
}
static void glad_gl_load_GL_ARB_copy_image( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_copy_image) return;
    glad_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC) load(userptr, "glCopyImageSubData");
}
static void glad_gl_load_GL_ARB_debug_output( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_debug_output) return;
    glad_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC) load(userptr, "glDebugMessageCallback");
    glad_glDebugMessageCallbackARB = (PFNGLDEBUGMESSAGECALLBACKARBPROC) load(userptr, "glDebugMessageCallbackARB");
    glad_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC) load(userptr, "glDebugMessageControl");
    glad_glDebugMessageControlARB = (PFNGLDEBUGMESSAGECONTROLARBPROC) load(userptr, "glDebugMessageControlARB");
    glad_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC) load(userptr, "glDebugMessageInsert");
    glad_glDebugMessageInsertARB = (PFNGLDEBUGMESSAGEINSERTARBPROC) load(userptr, "glDebugMessageInsertARB");
    glad_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC) load(userptr, "glGetDebugMessageLog");
    glad_glGetDebugMessageLogARB = (PFNGLGETDEBUGMESSAGELOGARBPROC) load(userptr, "glGetDebugMessageLogARB");
}
static void glad_gl_load_GL_ARB_direct_state_access( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_direct_state_access) return;
    glad_glBindTextureUnit = (PFNGLBINDTEXTUREUNITPROC) load(userptr, "glBindTextureUnit");
    glad_glBlitNamedFramebuffer = (PFNGLBLITNAMEDFRAMEBUFFERPROC) load(userptr, "glBlitNamedFramebuffer");
    glad_glCheckNamedFramebufferStatus = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckNamedFramebufferStatus");
    glad_glClearNamedBufferData = (PFNGLCLEARNAMEDBUFFERDATAPROC) load(userptr, "glClearNamedBufferData");
    glad_glClearNamedBufferSubData = (PFNGLCLEARNAMEDBUFFERSUBDATAPROC) load(userptr, "glClearNamedBufferSubData");
    glad_glClearNamedFramebufferfi = (PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) load(userptr, "glClearNamedFramebufferfi");
    glad_glClearNamedFramebufferfv = (PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) load(userptr, "glClearNamedFramebufferfv");
    glad_glClearNamedFramebufferiv = (PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) load(userptr, "glClearNamedFramebufferiv");
    glad_glClearNamedFramebufferuiv = (PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) load(userptr, "glClearNamedFramebufferuiv");
    glad_glCompressedTextureSubImage1D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) load(userptr, "glCompressedTextureSubImage1D");
    glad_glCompressedTextureSubImage2D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) load(userptr, "glCompressedTextureSubImage2D");
    glad_glCompressedTextureSubImage3D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) load(userptr, "glCompressedTextureSubImage3D");
    glad_glCopyNamedBufferSubData = (PFNGLCOPYNAMEDBUFFERSUBDATAPROC) load(userptr, "glCopyNamedBufferSubData");
    glad_glCopyTextureSubImage1D = (PFNGLCOPYTEXTURESUBIMAGE1DPROC) load(userptr, "glCopyTextureSubImage1D");
    glad_glCopyTextureSubImage2D = (PFNGLCOPYTEXTURESUBIMAGE2DPROC) load(userptr, "glCopyTextureSubImage2D");
    glad_glCopyTextureSubImage3D = (PFNGLCOPYTEXTURESUBIMAGE3DPROC) load(userptr, "glCopyTextureSubImage3D");
    glad_glCreateBuffers = (PFNGLCREATEBUFFERSPROC) load(userptr, "glCreateBuffers");
    glad_glCreateFramebuffers = (PFNGLCREATEFRAMEBUFFERSPROC) load(userptr, "glCreateFramebuffers");
    glad_glCreateProgramPipelines = (PFNGLCREATEPROGRAMPIPELINESPROC) load(userptr, "glCreateProgramPipelines");
    glad_glCreateQueries = (PFNGLCREATEQUERIESPROC) load(userptr, "glCreateQueries");
    glad_glCreateRenderbuffers = (PFNGLCREATERENDERBUFFERSPROC) load(userptr, "glCreateRenderbuffers");
    glad_glCreateSamplers = (PFNGLCREATESAMPLERSPROC) load(userptr, "glCreateSamplers");
    glad_glCreateTextures = (PFNGLCREATETEXTURESPROC) load(userptr, "glCreateTextures");
    glad_glCreateTransformFeedbacks = (PFNGLCREATETRANSFORMFEEDBACKSPROC) load(userptr, "glCreateTransformFeedbacks");
    glad_glCreateVertexArrays = (PFNGLCREATEVERTEXARRAYSPROC) load(userptr, "glCreateVertexArrays");
    glad_glDisableVertexArrayAttrib = (PFNGLDISABLEVERTEXARRAYATTRIBPROC) load(userptr, "glDisableVertexArrayAttrib");
    glad_glEnableVertexArrayAttrib = (PFNGLENABLEVERTEXARRAYATTRIBPROC) load(userptr, "glEnableVertexArrayAttrib");
    glad_glFlushMappedNamedBufferRange = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) load(userptr, "glFlushMappedNamedBufferRange");
    glad_glGenerateTextureMipmap = (PFNGLGENERATETEXTUREMIPMAPPROC) load(userptr, "glGenerateTextureMipmap");
    glad_glGetCompressedTextureImage = (PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) load(userptr, "glGetCompressedTextureImage");
    glad_glGetNamedBufferParameteri64v = (PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) load(userptr, "glGetNamedBufferParameteri64v");
    glad_glGetNamedBufferParameteriv = (PFNGLGETNAMEDBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedBufferParameteriv");
    glad_glGetNamedBufferPointerv = (PFNGLGETNAMEDBUFFERPOINTERVPROC) load(userptr, "glGetNamedBufferPointerv");
    glad_glGetNamedBufferSubData = (PFNGLGETNAMEDBUFFERSUBDATAPROC) load(userptr, "glGetNamedBufferSubData");
    glad_glGetNamedFramebufferAttachmentParameteriv = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetNamedFramebufferAttachmentParameteriv");
    glad_glGetNamedFramebufferParameteriv = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedFramebufferParameteriv");
    glad_glGetNamedRenderbufferParameteriv = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetNamedRenderbufferParameteriv");
    glad_glGetQueryBufferObjecti64v = (PFNGLGETQUERYBUFFEROBJECTI64VPROC) load(userptr, "glGetQueryBufferObjecti64v");
    glad_glGetQueryBufferObjectiv = (PFNGLGETQUERYBUFFEROBJECTIVPROC) load(userptr, "glGetQueryBufferObjectiv");
    glad_glGetQueryBufferObjectui64v = (PFNGLGETQUERYBUFFEROBJECTUI64VPROC) load(userptr, "glGetQueryBufferObjectui64v");
    glad_glGetQueryBufferObjectuiv = (PFNGLGETQUERYBUFFEROBJECTUIVPROC) load(userptr, "glGetQueryBufferObjectuiv");
    glad_glGetTextureImage = (PFNGLGETTEXTUREIMAGEPROC) load(userptr, "glGetTextureImage");
    glad_glGetTextureLevelParameterfv = (PFNGLGETTEXTURELEVELPARAMETERFVPROC) load(userptr, "glGetTextureLevelParameterfv");
    glad_glGetTextureLevelParameteriv = (PFNGLGETTEXTURELEVELPARAMETERIVPROC) load(userptr, "glGetTextureLevelParameteriv");
    glad_glGetTextureParameterIiv = (PFNGLGETTEXTUREPARAMETERIIVPROC) load(userptr, "glGetTextureParameterIiv");
    glad_glGetTextureParameterIuiv = (PFNGLGETTEXTUREPARAMETERIUIVPROC) load(userptr, "glGetTextureParameterIuiv");
    glad_glGetTextureParameterfv = (PFNGLGETTEXTUREPARAMETERFVPROC) load(userptr, "glGetTextureParameterfv");
    glad_glGetTextureParameteriv = (PFNGLGETTEXTUREPARAMETERIVPROC) load(userptr, "glGetTextureParameteriv");
    glad_glGetTransformFeedbacki64_v = (PFNGLGETTRANSFORMFEEDBACKI64_VPROC) load(userptr, "glGetTransformFeedbacki64_v");
    glad_glGetTransformFeedbacki_v = (PFNGLGETTRANSFORMFEEDBACKI_VPROC) load(userptr, "glGetTransformFeedbacki_v");
    glad_glGetTransformFeedbackiv = (PFNGLGETTRANSFORMFEEDBACKIVPROC) load(userptr, "glGetTransformFeedbackiv");
    glad_glGetVertexArrayIndexed64iv = (PFNGLGETVERTEXARRAYINDEXED64IVPROC) load(userptr, "glGetVertexArrayIndexed64iv");
    glad_glGetVertexArrayIndexediv = (PFNGLGETVERTEXARRAYINDEXEDIVPROC) load(userptr, "glGetVertexArrayIndexediv");
    glad_glGetVertexArrayiv = (PFNGLGETVERTEXARRAYIVPROC) load(userptr, "glGetVertexArrayiv");
    glad_glInvalidateNamedFramebufferData = (PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) load(userptr, "glInvalidateNamedFramebufferData");
    glad_glInvalidateNamedFramebufferSubData = (PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) load(userptr, "glInvalidateNamedFramebufferSubData");
    glad_glMapNamedBuffer = (PFNGLMAPNAMEDBUFFERPROC) load(userptr, "glMapNamedBuffer");
    glad_glMapNamedBufferRange = (PFNGLMAPNAMEDBUFFERRANGEPROC) load(userptr, "glMapNamedBufferRange");
    glad_glNamedBufferData = (PFNGLNAMEDBUFFERDATAPROC) load(userptr, "glNamedBufferData");
    glad_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC) load(userptr, "glNamedBufferStorage");
    glad_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC) load(userptr, "glNamedBufferSubData");
    glad_glNamedFramebufferDrawBuffer = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) load(userptr, "glNamedFramebufferDrawBuffer");
    glad_glNamedFramebufferDrawBuffers = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) load(userptr, "glNamedFramebufferDrawBuffers");
    glad_glNamedFramebufferParameteri = (PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) load(userptr, "glNamedFramebufferParameteri");
    glad_glNamedFramebufferReadBuffer = (PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) load(userptr, "glNamedFramebufferReadBuffer");
    glad_glNamedFramebufferRenderbuffer = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glNamedFramebufferRenderbuffer");
    glad_glNamedFramebufferTexture = (PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) load(userptr, "glNamedFramebufferTexture");
    glad_glNamedFramebufferTextureLayer = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glNamedFramebufferTextureLayer");
    glad_glNamedRenderbufferStorage = (PFNGLNAMEDRENDERBUFFERSTORAGEPROC) load(userptr, "glNamedRenderbufferStorage");
    glad_glNamedRenderbufferStorageMultisample = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glNamedRenderbufferStorageMultisample");
    glad_glTextureBuffer = (PFNGLTEXTUREBUFFERPROC) load(userptr, "glTextureBuffer");
    glad_glTextureBufferRange = (PFNGLTEXTUREBUFFERRANGEPROC) load(userptr, "glTextureBufferRange");
    glad_glTextureParameterIiv = (PFNGLTEXTUREPARAMETERIIVPROC) load(userptr, "glTextureParameterIiv");
    glad_glTextureParameterIuiv = (PFNGLTEXTUREPARAMETERIUIVPROC) load(userptr, "glTextureParameterIuiv");
    glad_glTextureParameterf = (PFNGLTEXTUREPARAMETERFPROC) load(userptr, "glTextureParameterf");
    glad_glTextureParameterfv = (PFNGLTEXTUREPARAMETERFVPROC) load(userptr, "glTextureParameterfv");
    glad_glTextureParameteri = (PFNGLTEXTUREPARAMETERIPROC) load(userptr, "glTextureParameteri");
    glad_glTextureParameteriv = (PFNGLTEXTUREPARAMETERIVPROC) load(userptr, "glTextureParameteriv");
    glad_glTextureStorage1D = (PFNGLTEXTURESTORAGE1DPROC) load(userptr, "glTextureStorage1D");
    glad_glTextureStorage2D = (PFNGLTEXTURESTORAGE2DPROC) load(userptr, "glTextureStorage2D");
    glad_glTextureStorage2DMultisample = (PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) load(userptr, "glTextureStorage2DMultisample");
    glad_glTextureStorage3D = (PFNGLTEXTURESTORAGE3DPROC) load(userptr, "glTextureStorage3D");
    glad_glTextureStorage3DMultisample = (PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) load(userptr, "glTextureStorage3DMultisample");
    glad_glTextureSubImage1D = (PFNGLTEXTURESUBIMAGE1DPROC) load(userptr, "glTextureSubImage1D");
    glad_glTextureSubImage2D = (PFNGLTEXTURESUBIMAGE2DPROC) load(userptr, "glTextureSubImage2D");
    glad_glTextureSubImage3D = (PFNGLTEXTURESUBIMAGE3DPROC) load(userptr, "glTextureSubImage3D");
    glad_glTransformFeedbackBufferBase = (PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) load(userptr, "glTransformFeedbackBufferBase");
    glad_glTransformFeedbackBufferRange = (PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) load(userptr, "glTransformFeedbackBufferRange");
    glad_glUnmapNamedBuffer = (PFNGLUNMAPNAMEDBUFFERPROC) load(userptr, "glUnmapNamedBuffer");
    glad_glVertexArrayAttribBinding = (PFNGLVERTEXARRAYATTRIBBINDINGPROC) load(userptr, "glVertexArrayAttribBinding");
    glad_glVertexArrayAttribFormat = (PFNGLVERTEXARRAYATTRIBFORMATPROC) load(userptr, "glVertexArrayAttribFormat");
    glad_glVertexArrayAttribIFormat = (PFNGLVERTEXARRAYATTRIBIFORMATPROC) load(userptr, "glVertexArrayAttribIFormat");
    glad_glVertexArrayAttribLFormat = (PFNGLVERTEXARRAYATTRIBLFORMATPROC) load(userptr, "glVertexArrayAttribLFormat");
    glad_glVertexArrayBindingDivisor = (PFNGLVERTEXARRAYBINDINGDIVISORPROC) load(userptr, "glVertexArrayBindingDivisor");
    glad_glVertexArrayElementBuffer = (PFNGLVERTEXARRAYELEMENTBUFFERPROC) load(userptr, "glVertexArrayElementBuffer");
    glad_glVertexArrayVertexBuffer = (PFNGLVERTEXARRAYVERTEXBUFFERPROC) load(userptr, "glVertexArrayVertexBuffer");
    glad_glVertexArrayVertexBuffers = (PFNGLVERTEXARRAYVERTEXBUFFERSPROC) load(userptr, "glVertexArrayVertexBuffers");
}
static void glad_gl_load_GL_ARB_draw_buffers( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_draw_buffers) return;
    glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC) load(userptr, "glDrawBuffers");
    glad_glDrawBuffersARB = (PFNGLDRAWBUFFERSARBPROC) load(userptr, "glDrawBuffersARB");
}
static void glad_gl_load_GL_ARB_draw_buffers_blend( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_draw_buffers_blend) return;
    glad_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) load(userptr, "glBlendEquationSeparatei");
    glad_glBlendEquationSeparateiARB = (PFNGLBLENDEQUATIONSEPARATEIARBPROC) load(userptr, "glBlendEquationSeparateiARB");
    glad_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC) load(userptr, "glBlendEquationi");
    glad_glBlendEquationiARB = (PFNGLBLENDEQUATIONIARBPROC) load(userptr, "glBlendEquationiARB");
    glad_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) load(userptr, "glBlendFuncSeparatei");
    glad_glBlendFuncSeparateiARB = (PFNGLBLENDFUNCSEPARATEIARBPROC) load(userptr, "glBlendFuncSeparateiARB");
    glad_glBlendFunci = (PFNGLBLENDFUNCIPROC) load(userptr, "glBlendFunci");
    glad_glBlendFunciARB = (PFNGLBLENDFUNCIARBPROC) load(userptr, "glBlendFunciARB");
}
static void glad_gl_load_GL_ARB_draw_elements_base_vertex( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_draw_elements_base_vertex) return;
    glad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glDrawElementsBaseVertex");
    glad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) load(userptr, "glDrawElementsInstancedBaseVertex");
    glad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) load(userptr, "glDrawRangeElementsBaseVertex");
    glad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) load(userptr, "glMultiDrawElementsBaseVertex");
}
static void glad_gl_load_GL_ARB_draw_indirect( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_draw_indirect) return;
    glad_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) load(userptr, "glDrawArraysIndirect");
    glad_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) load(userptr, "glDrawElementsIndirect");
}
static void glad_gl_load_GL_ARB_draw_instanced( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_draw_instanced) return;
    glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) load(userptr, "glDrawArraysInstanced");
    glad_glDrawArraysInstancedARB = (PFNGLDRAWARRAYSINSTANCEDARBPROC) load(userptr, "glDrawArraysInstancedARB");
    glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) load(userptr, "glDrawElementsInstanced");
    glad_glDrawElementsInstancedARB = (PFNGLDRAWELEMENTSINSTANCEDARBPROC) load(userptr, "glDrawElementsInstancedARB");
}
static void glad_gl_load_GL_ARB_fragment_program( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_fragment_program) return;
    glad_glBindProgramARB = (PFNGLBINDPROGRAMARBPROC) load(userptr, "glBindProgramARB");
    glad_glDeleteProgramsARB = (PFNGLDELETEPROGRAMSARBPROC) load(userptr, "glDeleteProgramsARB");
    glad_glGenProgramsARB = (PFNGLGENPROGRAMSARBPROC) load(userptr, "glGenProgramsARB");
    glad_glGetProgramEnvParameterdvARB = (PFNGLGETPROGRAMENVPARAMETERDVARBPROC) load(userptr, "glGetProgramEnvParameterdvARB");
    glad_glGetProgramEnvParameterfvARB = (PFNGLGETPROGRAMENVPARAMETERFVARBPROC) load(userptr, "glGetProgramEnvParameterfvARB");
    glad_glGetProgramLocalParameterdvARB = (PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) load(userptr, "glGetProgramLocalParameterdvARB");
    glad_glGetProgramLocalParameterfvARB = (PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) load(userptr, "glGetProgramLocalParameterfvARB");
    glad_glGetProgramStringARB = (PFNGLGETPROGRAMSTRINGARBPROC) load(userptr, "glGetProgramStringARB");
    glad_glGetProgramivARB = (PFNGLGETPROGRAMIVARBPROC) load(userptr, "glGetProgramivARB");
    glad_glIsProgramARB = (PFNGLISPROGRAMARBPROC) load(userptr, "glIsProgramARB");
    glad_glProgramEnvParameter4dARB = (PFNGLPROGRAMENVPARAMETER4DARBPROC) load(userptr, "glProgramEnvParameter4dARB");
    glad_glProgramEnvParameter4dvARB = (PFNGLPROGRAMENVPARAMETER4DVARBPROC) load(userptr, "glProgramEnvParameter4dvARB");
    glad_glProgramEnvParameter4fARB = (PFNGLPROGRAMENVPARAMETER4FARBPROC) load(userptr, "glProgramEnvParameter4fARB");
    glad_glProgramEnvParameter4fvARB = (PFNGLPROGRAMENVPARAMETER4FVARBPROC) load(userptr, "glProgramEnvParameter4fvARB");
    glad_glProgramLocalParameter4dARB = (PFNGLPROGRAMLOCALPARAMETER4DARBPROC) load(userptr, "glProgramLocalParameter4dARB");
    glad_glProgramLocalParameter4dvARB = (PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) load(userptr, "glProgramLocalParameter4dvARB");
    glad_glProgramLocalParameter4fARB = (PFNGLPROGRAMLOCALPARAMETER4FARBPROC) load(userptr, "glProgramLocalParameter4fARB");
    glad_glProgramLocalParameter4fvARB = (PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) load(userptr, "glProgramLocalParameter4fvARB");
    glad_glProgramStringARB = (PFNGLPROGRAMSTRINGARBPROC) load(userptr, "glProgramStringARB");
}
static void glad_gl_load_GL_ARB_framebuffer_no_attachments( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_framebuffer_no_attachments) return;
    glad_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC) load(userptr, "glFramebufferParameteri");
    glad_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC) load(userptr, "glGetFramebufferParameteriv");
}
static void glad_gl_load_GL_ARB_framebuffer_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_framebuffer_object) return;
    glad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC) load(userptr, "glBindFramebuffer");
    glad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC) load(userptr, "glBindRenderbuffer");
    glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) load(userptr, "glBlitFramebuffer");
    glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckFramebufferStatus");
    glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) load(userptr, "glDeleteFramebuffers");
    glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) load(userptr, "glDeleteRenderbuffers");
    glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glFramebufferRenderbuffer");
    glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC) load(userptr, "glFramebufferTexture1D");
    glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) load(userptr, "glFramebufferTexture2D");
    glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC) load(userptr, "glFramebufferTexture3D");
    glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glFramebufferTextureLayer");
    glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) load(userptr, "glGenFramebuffers");
    glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) load(userptr, "glGenRenderbuffers");
    glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC) load(userptr, "glGenerateMipmap");
    glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetFramebufferAttachmentParameteriv");
    glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetRenderbufferParameteriv");
    glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC) load(userptr, "glIsFramebuffer");
    glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC) load(userptr, "glIsRenderbuffer");
    glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) load(userptr, "glRenderbufferStorage");
    glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glRenderbufferStorageMultisample");
}
static void glad_gl_load_GL_ARB_geometry_shader4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_geometry_shader4) return;
    glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) load(userptr, "glFramebufferTexture");
    glad_glFramebufferTextureARB = (PFNGLFRAMEBUFFERTEXTUREARBPROC) load(userptr, "glFramebufferTextureARB");
    glad_glFramebufferTextureFaceARB = (PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) load(userptr, "glFramebufferTextureFaceARB");
    glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glFramebufferTextureLayer");
    glad_glFramebufferTextureLayerARB = (PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) load(userptr, "glFramebufferTextureLayerARB");
    glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) load(userptr, "glProgramParameteri");
    glad_glProgramParameteriARB = (PFNGLPROGRAMPARAMETERIARBPROC) load(userptr, "glProgramParameteriARB");
}
static void glad_gl_load_GL_ARB_get_program_binary( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_get_program_binary) return;
    glad_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC) load(userptr, "glGetProgramBinary");
    glad_glProgramBinary = (PFNGLPROGRAMBINARYPROC) load(userptr, "glProgramBinary");
    glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) load(userptr, "glProgramParameteri");
}
static void glad_gl_load_GL_ARB_get_texture_sub_image( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_get_texture_sub_image) return;
    glad_glGetCompressedTextureSubImage = (PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) load(userptr, "glGetCompressedTextureSubImage");
    glad_glGetTextureSubImage = (PFNGLGETTEXTURESUBIMAGEPROC) load(userptr, "glGetTextureSubImage");
}
static void glad_gl_load_GL_ARB_gl_spirv( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_gl_spirv) return;
    glad_glSpecializeShader = (PFNGLSPECIALIZESHADERPROC) load(userptr, "glSpecializeShader");
    glad_glSpecializeShaderARB = (PFNGLSPECIALIZESHADERARBPROC) load(userptr, "glSpecializeShaderARB");
}
static void glad_gl_load_GL_ARB_gpu_shader_fp64( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_gpu_shader_fp64) return;
    glad_glGetUniformdv = (PFNGLGETUNIFORMDVPROC) load(userptr, "glGetUniformdv");
    glad_glUniform1d = (PFNGLUNIFORM1DPROC) load(userptr, "glUniform1d");
    glad_glUniform1dv = (PFNGLUNIFORM1DVPROC) load(userptr, "glUniform1dv");
    glad_glUniform2d = (PFNGLUNIFORM2DPROC) load(userptr, "glUniform2d");
    glad_glUniform2dv = (PFNGLUNIFORM2DVPROC) load(userptr, "glUniform2dv");
    glad_glUniform3d = (PFNGLUNIFORM3DPROC) load(userptr, "glUniform3d");
    glad_glUniform3dv = (PFNGLUNIFORM3DVPROC) load(userptr, "glUniform3dv");
    glad_glUniform4d = (PFNGLUNIFORM4DPROC) load(userptr, "glUniform4d");
    glad_glUniform4dv = (PFNGLUNIFORM4DVPROC) load(userptr, "glUniform4dv");
    glad_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC) load(userptr, "glUniformMatrix2dv");
    glad_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC) load(userptr, "glUniformMatrix2x3dv");
    glad_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC) load(userptr, "glUniformMatrix2x4dv");
    glad_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC) load(userptr, "glUniformMatrix3dv");
    glad_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC) load(userptr, "glUniformMatrix3x2dv");
    glad_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC) load(userptr, "glUniformMatrix3x4dv");
    glad_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC) load(userptr, "glUniformMatrix4dv");
    glad_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC) load(userptr, "glUniformMatrix4x2dv");
    glad_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC) load(userptr, "glUniformMatrix4x3dv");
}
static void glad_gl_load_GL_ARB_gpu_shader_int64( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_gpu_shader_int64) return;
    glad_glGetUniformi64vARB = (PFNGLGETUNIFORMI64VARBPROC) load(userptr, "glGetUniformi64vARB");
    glad_glGetUniformui64vARB = (PFNGLGETUNIFORMUI64VARBPROC) load(userptr, "glGetUniformui64vARB");
    glad_glGetnUniformi64vARB = (PFNGLGETNUNIFORMI64VARBPROC) load(userptr, "glGetnUniformi64vARB");
    glad_glGetnUniformui64vARB = (PFNGLGETNUNIFORMUI64VARBPROC) load(userptr, "glGetnUniformui64vARB");
    glad_glProgramUniform1i64ARB = (PFNGLPROGRAMUNIFORM1I64ARBPROC) load(userptr, "glProgramUniform1i64ARB");
    glad_glProgramUniform1i64vARB = (PFNGLPROGRAMUNIFORM1I64VARBPROC) load(userptr, "glProgramUniform1i64vARB");
    glad_glProgramUniform1ui64ARB = (PFNGLPROGRAMUNIFORM1UI64ARBPROC) load(userptr, "glProgramUniform1ui64ARB");
    glad_glProgramUniform1ui64vARB = (PFNGLPROGRAMUNIFORM1UI64VARBPROC) load(userptr, "glProgramUniform1ui64vARB");
    glad_glProgramUniform2i64ARB = (PFNGLPROGRAMUNIFORM2I64ARBPROC) load(userptr, "glProgramUniform2i64ARB");
    glad_glProgramUniform2i64vARB = (PFNGLPROGRAMUNIFORM2I64VARBPROC) load(userptr, "glProgramUniform2i64vARB");
    glad_glProgramUniform2ui64ARB = (PFNGLPROGRAMUNIFORM2UI64ARBPROC) load(userptr, "glProgramUniform2ui64ARB");
    glad_glProgramUniform2ui64vARB = (PFNGLPROGRAMUNIFORM2UI64VARBPROC) load(userptr, "glProgramUniform2ui64vARB");
    glad_glProgramUniform3i64ARB = (PFNGLPROGRAMUNIFORM3I64ARBPROC) load(userptr, "glProgramUniform3i64ARB");
    glad_glProgramUniform3i64vARB = (PFNGLPROGRAMUNIFORM3I64VARBPROC) load(userptr, "glProgramUniform3i64vARB");
    glad_glProgramUniform3ui64ARB = (PFNGLPROGRAMUNIFORM3UI64ARBPROC) load(userptr, "glProgramUniform3ui64ARB");
    glad_glProgramUniform3ui64vARB = (PFNGLPROGRAMUNIFORM3UI64VARBPROC) load(userptr, "glProgramUniform3ui64vARB");
    glad_glProgramUniform4i64ARB = (PFNGLPROGRAMUNIFORM4I64ARBPROC) load(userptr, "glProgramUniform4i64ARB");
    glad_glProgramUniform4i64vARB = (PFNGLPROGRAMUNIFORM4I64VARBPROC) load(userptr, "glProgramUniform4i64vARB");
    glad_glProgramUniform4ui64ARB = (PFNGLPROGRAMUNIFORM4UI64ARBPROC) load(userptr, "glProgramUniform4ui64ARB");
    glad_glProgramUniform4ui64vARB = (PFNGLPROGRAMUNIFORM4UI64VARBPROC) load(userptr, "glProgramUniform4ui64vARB");
    glad_glUniform1i64ARB = (PFNGLUNIFORM1I64ARBPROC) load(userptr, "glUniform1i64ARB");
    glad_glUniform1i64vARB = (PFNGLUNIFORM1I64VARBPROC) load(userptr, "glUniform1i64vARB");
    glad_glUniform1ui64ARB = (PFNGLUNIFORM1UI64ARBPROC) load(userptr, "glUniform1ui64ARB");
    glad_glUniform1ui64vARB = (PFNGLUNIFORM1UI64VARBPROC) load(userptr, "glUniform1ui64vARB");
    glad_glUniform2i64ARB = (PFNGLUNIFORM2I64ARBPROC) load(userptr, "glUniform2i64ARB");
    glad_glUniform2i64vARB = (PFNGLUNIFORM2I64VARBPROC) load(userptr, "glUniform2i64vARB");
    glad_glUniform2ui64ARB = (PFNGLUNIFORM2UI64ARBPROC) load(userptr, "glUniform2ui64ARB");
    glad_glUniform2ui64vARB = (PFNGLUNIFORM2UI64VARBPROC) load(userptr, "glUniform2ui64vARB");
    glad_glUniform3i64ARB = (PFNGLUNIFORM3I64ARBPROC) load(userptr, "glUniform3i64ARB");
    glad_glUniform3i64vARB = (PFNGLUNIFORM3I64VARBPROC) load(userptr, "glUniform3i64vARB");
    glad_glUniform3ui64ARB = (PFNGLUNIFORM3UI64ARBPROC) load(userptr, "glUniform3ui64ARB");
    glad_glUniform3ui64vARB = (PFNGLUNIFORM3UI64VARBPROC) load(userptr, "glUniform3ui64vARB");
    glad_glUniform4i64ARB = (PFNGLUNIFORM4I64ARBPROC) load(userptr, "glUniform4i64ARB");
    glad_glUniform4i64vARB = (PFNGLUNIFORM4I64VARBPROC) load(userptr, "glUniform4i64vARB");
    glad_glUniform4ui64ARB = (PFNGLUNIFORM4UI64ARBPROC) load(userptr, "glUniform4ui64ARB");
    glad_glUniform4ui64vARB = (PFNGLUNIFORM4UI64VARBPROC) load(userptr, "glUniform4ui64vARB");
}
static void glad_gl_load_GL_ARB_imaging( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_imaging) return;
    glad_glBlendColor = (PFNGLBLENDCOLORPROC) load(userptr, "glBlendColor");
    glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC) load(userptr, "glBlendEquation");
}
static void glad_gl_load_GL_ARB_indirect_parameters( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_indirect_parameters) return;
    glad_glMultiDrawArraysIndirectCount = (PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) load(userptr, "glMultiDrawArraysIndirectCount");
    glad_glMultiDrawArraysIndirectCountARB = (PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) load(userptr, "glMultiDrawArraysIndirectCountARB");
    glad_glMultiDrawElementsIndirectCount = (PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) load(userptr, "glMultiDrawElementsIndirectCount");
    glad_glMultiDrawElementsIndirectCountARB = (PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) load(userptr, "glMultiDrawElementsIndirectCountARB");
}
static void glad_gl_load_GL_ARB_instanced_arrays( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_instanced_arrays) return;
    glad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC) load(userptr, "glVertexAttribDivisor");
    glad_glVertexAttribDivisorARB = (PFNGLVERTEXATTRIBDIVISORARBPROC) load(userptr, "glVertexAttribDivisorARB");
}
static void glad_gl_load_GL_ARB_internalformat_query( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_internalformat_query) return;
    glad_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC) load(userptr, "glGetInternalformativ");
}
static void glad_gl_load_GL_ARB_internalformat_query2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_internalformat_query2) return;
    glad_glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC) load(userptr, "glGetInternalformati64v");
}
static void glad_gl_load_GL_ARB_invalidate_subdata( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_invalidate_subdata) return;
    glad_glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC) load(userptr, "glInvalidateBufferData");
    glad_glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC) load(userptr, "glInvalidateBufferSubData");
    glad_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC) load(userptr, "glInvalidateFramebuffer");
    glad_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC) load(userptr, "glInvalidateSubFramebuffer");
    glad_glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC) load(userptr, "glInvalidateTexImage");
    glad_glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC) load(userptr, "glInvalidateTexSubImage");
}
static void glad_gl_load_GL_ARB_map_buffer_range( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_map_buffer_range) return;
    glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC) load(userptr, "glFlushMappedBufferRange");
    glad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC) load(userptr, "glMapBufferRange");
}
static void glad_gl_load_GL_ARB_matrix_palette( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_matrix_palette) return;
    glad_glCurrentPaletteMatrixARB = (PFNGLCURRENTPALETTEMATRIXARBPROC) load(userptr, "glCurrentPaletteMatrixARB");
    glad_glMatrixIndexPointerARB = (PFNGLMATRIXINDEXPOINTERARBPROC) load(userptr, "glMatrixIndexPointerARB");
    glad_glMatrixIndexubvARB = (PFNGLMATRIXINDEXUBVARBPROC) load(userptr, "glMatrixIndexubvARB");
    glad_glMatrixIndexuivARB = (PFNGLMATRIXINDEXUIVARBPROC) load(userptr, "glMatrixIndexuivARB");
    glad_glMatrixIndexusvARB = (PFNGLMATRIXINDEXUSVARBPROC) load(userptr, "glMatrixIndexusvARB");
}
static void glad_gl_load_GL_ARB_multi_bind( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_multi_bind) return;
    glad_glBindBuffersBase = (PFNGLBINDBUFFERSBASEPROC) load(userptr, "glBindBuffersBase");
    glad_glBindBuffersRange = (PFNGLBINDBUFFERSRANGEPROC) load(userptr, "glBindBuffersRange");
    glad_glBindImageTextures = (PFNGLBINDIMAGETEXTURESPROC) load(userptr, "glBindImageTextures");
    glad_glBindSamplers = (PFNGLBINDSAMPLERSPROC) load(userptr, "glBindSamplers");
    glad_glBindTextures = (PFNGLBINDTEXTURESPROC) load(userptr, "glBindTextures");
    glad_glBindVertexBuffers = (PFNGLBINDVERTEXBUFFERSPROC) load(userptr, "glBindVertexBuffers");
}
static void glad_gl_load_GL_ARB_multi_draw_indirect( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_multi_draw_indirect) return;
    glad_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC) load(userptr, "glMultiDrawArraysIndirect");
    glad_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC) load(userptr, "glMultiDrawElementsIndirect");
}
static void glad_gl_load_GL_ARB_multisample( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_multisample) return;
    glad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC) load(userptr, "glSampleCoverage");
    glad_glSampleCoverageARB = (PFNGLSAMPLECOVERAGEARBPROC) load(userptr, "glSampleCoverageARB");
}
static void glad_gl_load_GL_ARB_multitexture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_multitexture) return;
    glad_glActiveTexture = (PFNGLACTIVETEXTUREPROC) load(userptr, "glActiveTexture");
    glad_glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC) load(userptr, "glActiveTextureARB");
    glad_glClientActiveTexture = (PFNGLCLIENTACTIVETEXTUREPROC) load(userptr, "glClientActiveTexture");
    glad_glClientActiveTextureARB = (PFNGLCLIENTACTIVETEXTUREARBPROC) load(userptr, "glClientActiveTextureARB");
    glad_glMultiTexCoord1d = (PFNGLMULTITEXCOORD1DPROC) load(userptr, "glMultiTexCoord1d");
    glad_glMultiTexCoord1dARB = (PFNGLMULTITEXCOORD1DARBPROC) load(userptr, "glMultiTexCoord1dARB");
    glad_glMultiTexCoord1dv = (PFNGLMULTITEXCOORD1DVPROC) load(userptr, "glMultiTexCoord1dv");
    glad_glMultiTexCoord1dvARB = (PFNGLMULTITEXCOORD1DVARBPROC) load(userptr, "glMultiTexCoord1dvARB");
    glad_glMultiTexCoord1f = (PFNGLMULTITEXCOORD1FPROC) load(userptr, "glMultiTexCoord1f");
    glad_glMultiTexCoord1fARB = (PFNGLMULTITEXCOORD1FARBPROC) load(userptr, "glMultiTexCoord1fARB");
    glad_glMultiTexCoord1fv = (PFNGLMULTITEXCOORD1FVPROC) load(userptr, "glMultiTexCoord1fv");
    glad_glMultiTexCoord1fvARB = (PFNGLMULTITEXCOORD1FVARBPROC) load(userptr, "glMultiTexCoord1fvARB");
    glad_glMultiTexCoord1i = (PFNGLMULTITEXCOORD1IPROC) load(userptr, "glMultiTexCoord1i");
    glad_glMultiTexCoord1iARB = (PFNGLMULTITEXCOORD1IARBPROC) load(userptr, "glMultiTexCoord1iARB");
    glad_glMultiTexCoord1iv = (PFNGLMULTITEXCOORD1IVPROC) load(userptr, "glMultiTexCoord1iv");
    glad_glMultiTexCoord1ivARB = (PFNGLMULTITEXCOORD1IVARBPROC) load(userptr, "glMultiTexCoord1ivARB");
    glad_glMultiTexCoord1s = (PFNGLMULTITEXCOORD1SPROC) load(userptr, "glMultiTexCoord1s");
    glad_glMultiTexCoord1sARB = (PFNGLMULTITEXCOORD1SARBPROC) load(userptr, "glMultiTexCoord1sARB");
    glad_glMultiTexCoord1sv = (PFNGLMULTITEXCOORD1SVPROC) load(userptr, "glMultiTexCoord1sv");
    glad_glMultiTexCoord1svARB = (PFNGLMULTITEXCOORD1SVARBPROC) load(userptr, "glMultiTexCoord1svARB");
    glad_glMultiTexCoord2d = (PFNGLMULTITEXCOORD2DPROC) load(userptr, "glMultiTexCoord2d");
    glad_glMultiTexCoord2dARB = (PFNGLMULTITEXCOORD2DARBPROC) load(userptr, "glMultiTexCoord2dARB");
    glad_glMultiTexCoord2dv = (PFNGLMULTITEXCOORD2DVPROC) load(userptr, "glMultiTexCoord2dv");
    glad_glMultiTexCoord2dvARB = (PFNGLMULTITEXCOORD2DVARBPROC) load(userptr, "glMultiTexCoord2dvARB");
    glad_glMultiTexCoord2f = (PFNGLMULTITEXCOORD2FPROC) load(userptr, "glMultiTexCoord2f");
    glad_glMultiTexCoord2fARB = (PFNGLMULTITEXCOORD2FARBPROC) load(userptr, "glMultiTexCoord2fARB");
    glad_glMultiTexCoord2fv = (PFNGLMULTITEXCOORD2FVPROC) load(userptr, "glMultiTexCoord2fv");
    glad_glMultiTexCoord2fvARB = (PFNGLMULTITEXCOORD2FVARBPROC) load(userptr, "glMultiTexCoord2fvARB");
    glad_glMultiTexCoord2i = (PFNGLMULTITEXCOORD2IPROC) load(userptr, "glMultiTexCoord2i");
    glad_glMultiTexCoord2iARB = (PFNGLMULTITEXCOORD2IARBPROC) load(userptr, "glMultiTexCoord2iARB");
    glad_glMultiTexCoord2iv = (PFNGLMULTITEXCOORD2IVPROC) load(userptr, "glMultiTexCoord2iv");
    glad_glMultiTexCoord2ivARB = (PFNGLMULTITEXCOORD2IVARBPROC) load(userptr, "glMultiTexCoord2ivARB");
    glad_glMultiTexCoord2s = (PFNGLMULTITEXCOORD2SPROC) load(userptr, "glMultiTexCoord2s");
    glad_glMultiTexCoord2sARB = (PFNGLMULTITEXCOORD2SARBPROC) load(userptr, "glMultiTexCoord2sARB");
    glad_glMultiTexCoord2sv = (PFNGLMULTITEXCOORD2SVPROC) load(userptr, "glMultiTexCoord2sv");
    glad_glMultiTexCoord2svARB = (PFNGLMULTITEXCOORD2SVARBPROC) load(userptr, "glMultiTexCoord2svARB");
    glad_glMultiTexCoord3d = (PFNGLMULTITEXCOORD3DPROC) load(userptr, "glMultiTexCoord3d");
    glad_glMultiTexCoord3dARB = (PFNGLMULTITEXCOORD3DARBPROC) load(userptr, "glMultiTexCoord3dARB");
    glad_glMultiTexCoord3dv = (PFNGLMULTITEXCOORD3DVPROC) load(userptr, "glMultiTexCoord3dv");
    glad_glMultiTexCoord3dvARB = (PFNGLMULTITEXCOORD3DVARBPROC) load(userptr, "glMultiTexCoord3dvARB");
    glad_glMultiTexCoord3f = (PFNGLMULTITEXCOORD3FPROC) load(userptr, "glMultiTexCoord3f");
    glad_glMultiTexCoord3fARB = (PFNGLMULTITEXCOORD3FARBPROC) load(userptr, "glMultiTexCoord3fARB");
    glad_glMultiTexCoord3fv = (PFNGLMULTITEXCOORD3FVPROC) load(userptr, "glMultiTexCoord3fv");
    glad_glMultiTexCoord3fvARB = (PFNGLMULTITEXCOORD3FVARBPROC) load(userptr, "glMultiTexCoord3fvARB");
    glad_glMultiTexCoord3i = (PFNGLMULTITEXCOORD3IPROC) load(userptr, "glMultiTexCoord3i");
    glad_glMultiTexCoord3iARB = (PFNGLMULTITEXCOORD3IARBPROC) load(userptr, "glMultiTexCoord3iARB");
    glad_glMultiTexCoord3iv = (PFNGLMULTITEXCOORD3IVPROC) load(userptr, "glMultiTexCoord3iv");
    glad_glMultiTexCoord3ivARB = (PFNGLMULTITEXCOORD3IVARBPROC) load(userptr, "glMultiTexCoord3ivARB");
    glad_glMultiTexCoord3s = (PFNGLMULTITEXCOORD3SPROC) load(userptr, "glMultiTexCoord3s");
    glad_glMultiTexCoord3sARB = (PFNGLMULTITEXCOORD3SARBPROC) load(userptr, "glMultiTexCoord3sARB");
    glad_glMultiTexCoord3sv = (PFNGLMULTITEXCOORD3SVPROC) load(userptr, "glMultiTexCoord3sv");
    glad_glMultiTexCoord3svARB = (PFNGLMULTITEXCOORD3SVARBPROC) load(userptr, "glMultiTexCoord3svARB");
    glad_glMultiTexCoord4d = (PFNGLMULTITEXCOORD4DPROC) load(userptr, "glMultiTexCoord4d");
    glad_glMultiTexCoord4dARB = (PFNGLMULTITEXCOORD4DARBPROC) load(userptr, "glMultiTexCoord4dARB");
    glad_glMultiTexCoord4dv = (PFNGLMULTITEXCOORD4DVPROC) load(userptr, "glMultiTexCoord4dv");
    glad_glMultiTexCoord4dvARB = (PFNGLMULTITEXCOORD4DVARBPROC) load(userptr, "glMultiTexCoord4dvARB");
    glad_glMultiTexCoord4f = (PFNGLMULTITEXCOORD4FPROC) load(userptr, "glMultiTexCoord4f");
    glad_glMultiTexCoord4fARB = (PFNGLMULTITEXCOORD4FARBPROC) load(userptr, "glMultiTexCoord4fARB");
    glad_glMultiTexCoord4fv = (PFNGLMULTITEXCOORD4FVPROC) load(userptr, "glMultiTexCoord4fv");
    glad_glMultiTexCoord4fvARB = (PFNGLMULTITEXCOORD4FVARBPROC) load(userptr, "glMultiTexCoord4fvARB");
    glad_glMultiTexCoord4i = (PFNGLMULTITEXCOORD4IPROC) load(userptr, "glMultiTexCoord4i");
    glad_glMultiTexCoord4iARB = (PFNGLMULTITEXCOORD4IARBPROC) load(userptr, "glMultiTexCoord4iARB");
    glad_glMultiTexCoord4iv = (PFNGLMULTITEXCOORD4IVPROC) load(userptr, "glMultiTexCoord4iv");
    glad_glMultiTexCoord4ivARB = (PFNGLMULTITEXCOORD4IVARBPROC) load(userptr, "glMultiTexCoord4ivARB");
    glad_glMultiTexCoord4s = (PFNGLMULTITEXCOORD4SPROC) load(userptr, "glMultiTexCoord4s");
    glad_glMultiTexCoord4sARB = (PFNGLMULTITEXCOORD4SARBPROC) load(userptr, "glMultiTexCoord4sARB");
    glad_glMultiTexCoord4sv = (PFNGLMULTITEXCOORD4SVPROC) load(userptr, "glMultiTexCoord4sv");
    glad_glMultiTexCoord4svARB = (PFNGLMULTITEXCOORD4SVARBPROC) load(userptr, "glMultiTexCoord4svARB");
}
static void glad_gl_load_GL_ARB_occlusion_query( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_occlusion_query) return;
    glad_glBeginQuery = (PFNGLBEGINQUERYPROC) load(userptr, "glBeginQuery");
    glad_glBeginQueryARB = (PFNGLBEGINQUERYARBPROC) load(userptr, "glBeginQueryARB");
    glad_glDeleteQueries = (PFNGLDELETEQUERIESPROC) load(userptr, "glDeleteQueries");
    glad_glDeleteQueriesARB = (PFNGLDELETEQUERIESARBPROC) load(userptr, "glDeleteQueriesARB");
    glad_glEndQuery = (PFNGLENDQUERYPROC) load(userptr, "glEndQuery");
    glad_glEndQueryARB = (PFNGLENDQUERYARBPROC) load(userptr, "glEndQueryARB");
    glad_glGenQueries = (PFNGLGENQUERIESPROC) load(userptr, "glGenQueries");
    glad_glGenQueriesARB = (PFNGLGENQUERIESARBPROC) load(userptr, "glGenQueriesARB");
    glad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC) load(userptr, "glGetQueryObjectiv");
    glad_glGetQueryObjectivARB = (PFNGLGETQUERYOBJECTIVARBPROC) load(userptr, "glGetQueryObjectivARB");
    glad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC) load(userptr, "glGetQueryObjectuiv");
    glad_glGetQueryObjectuivARB = (PFNGLGETQUERYOBJECTUIVARBPROC) load(userptr, "glGetQueryObjectuivARB");
    glad_glGetQueryiv = (PFNGLGETQUERYIVPROC) load(userptr, "glGetQueryiv");
    glad_glGetQueryivARB = (PFNGLGETQUERYIVARBPROC) load(userptr, "glGetQueryivARB");
    glad_glIsQuery = (PFNGLISQUERYPROC) load(userptr, "glIsQuery");
    glad_glIsQueryARB = (PFNGLISQUERYARBPROC) load(userptr, "glIsQueryARB");
}
static void glad_gl_load_GL_ARB_parallel_shader_compile( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_parallel_shader_compile) return;
    glad_glMaxShaderCompilerThreadsARB = (PFNGLMAXSHADERCOMPILERTHREADSARBPROC) load(userptr, "glMaxShaderCompilerThreadsARB");
    glad_glMaxShaderCompilerThreadsKHR = (PFNGLMAXSHADERCOMPILERTHREADSKHRPROC) load(userptr, "glMaxShaderCompilerThreadsKHR");
}
static void glad_gl_load_GL_ARB_point_parameters( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_point_parameters) return;
    glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC) load(userptr, "glPointParameterf");
    glad_glPointParameterfARB = (PFNGLPOINTPARAMETERFARBPROC) load(userptr, "glPointParameterfARB");
    glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC) load(userptr, "glPointParameterfv");
    glad_glPointParameterfvARB = (PFNGLPOINTPARAMETERFVARBPROC) load(userptr, "glPointParameterfvARB");
}
static void glad_gl_load_GL_ARB_polygon_offset_clamp( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_polygon_offset_clamp) return;
    glad_glPolygonOffsetClamp = (PFNGLPOLYGONOFFSETCLAMPPROC) load(userptr, "glPolygonOffsetClamp");
}
static void glad_gl_load_GL_ARB_program_interface_query( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_program_interface_query) return;
    glad_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC) load(userptr, "glGetProgramInterfaceiv");
    glad_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC) load(userptr, "glGetProgramResourceIndex");
    glad_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC) load(userptr, "glGetProgramResourceLocation");
    glad_glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) load(userptr, "glGetProgramResourceLocationIndex");
    glad_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC) load(userptr, "glGetProgramResourceName");
    glad_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC) load(userptr, "glGetProgramResourceiv");
}
static void glad_gl_load_GL_ARB_provoking_vertex( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_provoking_vertex) return;
    glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) load(userptr, "glProvokingVertex");
}
static void glad_gl_load_GL_ARB_robustness( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_robustness) return;
    glad_glGetGraphicsResetStatusARB = (PFNGLGETGRAPHICSRESETSTATUSARBPROC) load(userptr, "glGetGraphicsResetStatusARB");
    glad_glGetnCompressedTexImageARB = (PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) load(userptr, "glGetnCompressedTexImageARB");
    glad_glGetnTexImageARB = (PFNGLGETNTEXIMAGEARBPROC) load(userptr, "glGetnTexImageARB");
    glad_glGetnUniformdvARB = (PFNGLGETNUNIFORMDVARBPROC) load(userptr, "glGetnUniformdvARB");
    glad_glGetnUniformfvARB = (PFNGLGETNUNIFORMFVARBPROC) load(userptr, "glGetnUniformfvARB");
    glad_glGetnUniformivARB = (PFNGLGETNUNIFORMIVARBPROC) load(userptr, "glGetnUniformivARB");
    glad_glGetnUniformuivARB = (PFNGLGETNUNIFORMUIVARBPROC) load(userptr, "glGetnUniformuivARB");
    glad_glReadnPixels = (PFNGLREADNPIXELSPROC) load(userptr, "glReadnPixels");
    glad_glReadnPixelsARB = (PFNGLREADNPIXELSARBPROC) load(userptr, "glReadnPixelsARB");
}
static void glad_gl_load_GL_ARB_sample_locations( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_sample_locations) return;
    glad_glEvaluateDepthValuesARB = (PFNGLEVALUATEDEPTHVALUESARBPROC) load(userptr, "glEvaluateDepthValuesARB");
    glad_glFramebufferSampleLocationsfvARB = (PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) load(userptr, "glFramebufferSampleLocationsfvARB");
    glad_glNamedFramebufferSampleLocationsfvARB = (PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) load(userptr, "glNamedFramebufferSampleLocationsfvARB");
}
static void glad_gl_load_GL_ARB_sample_shading( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_sample_shading) return;
    glad_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC) load(userptr, "glMinSampleShading");
    glad_glMinSampleShadingARB = (PFNGLMINSAMPLESHADINGARBPROC) load(userptr, "glMinSampleShadingARB");
}
static void glad_gl_load_GL_ARB_sampler_objects( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_sampler_objects) return;
    glad_glBindSampler = (PFNGLBINDSAMPLERPROC) load(userptr, "glBindSampler");
    glad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC) load(userptr, "glDeleteSamplers");
    glad_glGenSamplers = (PFNGLGENSAMPLERSPROC) load(userptr, "glGenSamplers");
    glad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC) load(userptr, "glGetSamplerParameterIiv");
    glad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC) load(userptr, "glGetSamplerParameterIuiv");
    glad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC) load(userptr, "glGetSamplerParameterfv");
    glad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC) load(userptr, "glGetSamplerParameteriv");
    glad_glIsSampler = (PFNGLISSAMPLERPROC) load(userptr, "glIsSampler");
    glad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC) load(userptr, "glSamplerParameterIiv");
    glad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC) load(userptr, "glSamplerParameterIuiv");
    glad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC) load(userptr, "glSamplerParameterf");
    glad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC) load(userptr, "glSamplerParameterfv");
    glad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC) load(userptr, "glSamplerParameteri");
    glad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC) load(userptr, "glSamplerParameteriv");
}
static void glad_gl_load_GL_ARB_separate_shader_objects( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_separate_shader_objects) return;
    glad_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC) load(userptr, "glActiveShaderProgram");
    glad_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC) load(userptr, "glBindProgramPipeline");
    glad_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC) load(userptr, "glCreateShaderProgramv");
    glad_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC) load(userptr, "glDeleteProgramPipelines");
    glad_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC) load(userptr, "glGenProgramPipelines");
    glad_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC) load(userptr, "glGetProgramPipelineInfoLog");
    glad_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC) load(userptr, "glGetProgramPipelineiv");
    glad_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC) load(userptr, "glIsProgramPipeline");
    glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) load(userptr, "glProgramParameteri");
    glad_glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC) load(userptr, "glProgramUniform1d");
    glad_glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC) load(userptr, "glProgramUniform1dv");
    glad_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC) load(userptr, "glProgramUniform1f");
    glad_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC) load(userptr, "glProgramUniform1fv");
    glad_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC) load(userptr, "glProgramUniform1i");
    glad_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC) load(userptr, "glProgramUniform1iv");
    glad_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC) load(userptr, "glProgramUniform1ui");
    glad_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC) load(userptr, "glProgramUniform1uiv");
    glad_glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC) load(userptr, "glProgramUniform2d");
    glad_glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC) load(userptr, "glProgramUniform2dv");
    glad_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC) load(userptr, "glProgramUniform2f");
    glad_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC) load(userptr, "glProgramUniform2fv");
    glad_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC) load(userptr, "glProgramUniform2i");
    glad_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC) load(userptr, "glProgramUniform2iv");
    glad_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC) load(userptr, "glProgramUniform2ui");
    glad_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC) load(userptr, "glProgramUniform2uiv");
    glad_glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC) load(userptr, "glProgramUniform3d");
    glad_glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC) load(userptr, "glProgramUniform3dv");
    glad_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC) load(userptr, "glProgramUniform3f");
    glad_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC) load(userptr, "glProgramUniform3fv");
    glad_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC) load(userptr, "glProgramUniform3i");
    glad_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC) load(userptr, "glProgramUniform3iv");
    glad_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC) load(userptr, "glProgramUniform3ui");
    glad_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC) load(userptr, "glProgramUniform3uiv");
    glad_glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC) load(userptr, "glProgramUniform4d");
    glad_glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC) load(userptr, "glProgramUniform4dv");
    glad_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC) load(userptr, "glProgramUniform4f");
    glad_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC) load(userptr, "glProgramUniform4fv");
    glad_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC) load(userptr, "glProgramUniform4i");
    glad_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC) load(userptr, "glProgramUniform4iv");
    glad_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC) load(userptr, "glProgramUniform4ui");
    glad_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC) load(userptr, "glProgramUniform4uiv");
    glad_glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC) load(userptr, "glProgramUniformMatrix2dv");
    glad_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC) load(userptr, "glProgramUniformMatrix2fv");
    glad_glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) load(userptr, "glProgramUniformMatrix2x3dv");
    glad_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) load(userptr, "glProgramUniformMatrix2x3fv");
    glad_glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) load(userptr, "glProgramUniformMatrix2x4dv");
    glad_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) load(userptr, "glProgramUniformMatrix2x4fv");
    glad_glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC) load(userptr, "glProgramUniformMatrix3dv");
    glad_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC) load(userptr, "glProgramUniformMatrix3fv");
    glad_glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) load(userptr, "glProgramUniformMatrix3x2dv");
    glad_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) load(userptr, "glProgramUniformMatrix3x2fv");
    glad_glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) load(userptr, "glProgramUniformMatrix3x4dv");
    glad_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) load(userptr, "glProgramUniformMatrix3x4fv");
    glad_glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC) load(userptr, "glProgramUniformMatrix4dv");
    glad_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC) load(userptr, "glProgramUniformMatrix4fv");
    glad_glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) load(userptr, "glProgramUniformMatrix4x2dv");
    glad_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) load(userptr, "glProgramUniformMatrix4x2fv");
    glad_glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) load(userptr, "glProgramUniformMatrix4x3dv");
    glad_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) load(userptr, "glProgramUniformMatrix4x3fv");
    glad_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC) load(userptr, "glUseProgramStages");
    glad_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC) load(userptr, "glValidateProgramPipeline");
}
static void glad_gl_load_GL_ARB_shader_atomic_counters( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_shader_atomic_counters) return;
    glad_glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) load(userptr, "glGetActiveAtomicCounterBufferiv");
}
static void glad_gl_load_GL_ARB_shader_image_load_store( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_shader_image_load_store) return;
    glad_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC) load(userptr, "glBindImageTexture");
    glad_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC) load(userptr, "glMemoryBarrier");
}
static void glad_gl_load_GL_ARB_shader_objects( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_shader_objects) return;
    glad_glAttachObjectARB = (PFNGLATTACHOBJECTARBPROC) load(userptr, "glAttachObjectARB");
    glad_glAttachShader = (PFNGLATTACHSHADERPROC) load(userptr, "glAttachShader");
    glad_glCompileShader = (PFNGLCOMPILESHADERPROC) load(userptr, "glCompileShader");
    glad_glCompileShaderARB = (PFNGLCOMPILESHADERARBPROC) load(userptr, "glCompileShaderARB");
    glad_glCreateProgram = (PFNGLCREATEPROGRAMPROC) load(userptr, "glCreateProgram");
    glad_glCreateProgramObjectARB = (PFNGLCREATEPROGRAMOBJECTARBPROC) load(userptr, "glCreateProgramObjectARB");
    glad_glCreateShader = (PFNGLCREATESHADERPROC) load(userptr, "glCreateShader");
    glad_glCreateShaderObjectARB = (PFNGLCREATESHADEROBJECTARBPROC) load(userptr, "glCreateShaderObjectARB");
    glad_glDeleteObjectARB = (PFNGLDELETEOBJECTARBPROC) load(userptr, "glDeleteObjectARB");
    glad_glDetachObjectARB = (PFNGLDETACHOBJECTARBPROC) load(userptr, "glDetachObjectARB");
    glad_glDetachShader = (PFNGLDETACHSHADERPROC) load(userptr, "glDetachShader");
    glad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC) load(userptr, "glGetActiveUniform");
    glad_glGetActiveUniformARB = (PFNGLGETACTIVEUNIFORMARBPROC) load(userptr, "glGetActiveUniformARB");
    glad_glGetAttachedObjectsARB = (PFNGLGETATTACHEDOBJECTSARBPROC) load(userptr, "glGetAttachedObjectsARB");
    glad_glGetHandleARB = (PFNGLGETHANDLEARBPROC) load(userptr, "glGetHandleARB");
    glad_glGetInfoLogARB = (PFNGLGETINFOLOGARBPROC) load(userptr, "glGetInfoLogARB");
    glad_glGetObjectParameterfvARB = (PFNGLGETOBJECTPARAMETERFVARBPROC) load(userptr, "glGetObjectParameterfvARB");
    glad_glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC) load(userptr, "glGetObjectParameterivARB");
    glad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC) load(userptr, "glGetShaderSource");
    glad_glGetShaderSourceARB = (PFNGLGETSHADERSOURCEARBPROC) load(userptr, "glGetShaderSourceARB");
    glad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) load(userptr, "glGetUniformLocation");
    glad_glGetUniformLocationARB = (PFNGLGETUNIFORMLOCATIONARBPROC) load(userptr, "glGetUniformLocationARB");
    glad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC) load(userptr, "glGetUniformfv");
    glad_glGetUniformfvARB = (PFNGLGETUNIFORMFVARBPROC) load(userptr, "glGetUniformfvARB");
    glad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC) load(userptr, "glGetUniformiv");
    glad_glGetUniformivARB = (PFNGLGETUNIFORMIVARBPROC) load(userptr, "glGetUniformivARB");
    glad_glLinkProgram = (PFNGLLINKPROGRAMPROC) load(userptr, "glLinkProgram");
    glad_glLinkProgramARB = (PFNGLLINKPROGRAMARBPROC) load(userptr, "glLinkProgramARB");
    glad_glShaderSource = (PFNGLSHADERSOURCEPROC) load(userptr, "glShaderSource");
    glad_glShaderSourceARB = (PFNGLSHADERSOURCEARBPROC) load(userptr, "glShaderSourceARB");
    glad_glUniform1f = (PFNGLUNIFORM1FPROC) load(userptr, "glUniform1f");
    glad_glUniform1fARB = (PFNGLUNIFORM1FARBPROC) load(userptr, "glUniform1fARB");
    glad_glUniform1fv = (PFNGLUNIFORM1FVPROC) load(userptr, "glUniform1fv");
    glad_glUniform1fvARB = (PFNGLUNIFORM1FVARBPROC) load(userptr, "glUniform1fvARB");
    glad_glUniform1i = (PFNGLUNIFORM1IPROC) load(userptr, "glUniform1i");
    glad_glUniform1iARB = (PFNGLUNIFORM1IARBPROC) load(userptr, "glUniform1iARB");
    glad_glUniform1iv = (PFNGLUNIFORM1IVPROC) load(userptr, "glUniform1iv");
    glad_glUniform1ivARB = (PFNGLUNIFORM1IVARBPROC) load(userptr, "glUniform1ivARB");
    glad_glUniform2f = (PFNGLUNIFORM2FPROC) load(userptr, "glUniform2f");
    glad_glUniform2fARB = (PFNGLUNIFORM2FARBPROC) load(userptr, "glUniform2fARB");
    glad_glUniform2fv = (PFNGLUNIFORM2FVPROC) load(userptr, "glUniform2fv");
    glad_glUniform2fvARB = (PFNGLUNIFORM2FVARBPROC) load(userptr, "glUniform2fvARB");
    glad_glUniform2i = (PFNGLUNIFORM2IPROC) load(userptr, "glUniform2i");
    glad_glUniform2iARB = (PFNGLUNIFORM2IARBPROC) load(userptr, "glUniform2iARB");
    glad_glUniform2iv = (PFNGLUNIFORM2IVPROC) load(userptr, "glUniform2iv");
    glad_glUniform2ivARB = (PFNGLUNIFORM2IVARBPROC) load(userptr, "glUniform2ivARB");
    glad_glUniform3f = (PFNGLUNIFORM3FPROC) load(userptr, "glUniform3f");
    glad_glUniform3fARB = (PFNGLUNIFORM3FARBPROC) load(userptr, "glUniform3fARB");
    glad_glUniform3fv = (PFNGLUNIFORM3FVPROC) load(userptr, "glUniform3fv");
    glad_glUniform3fvARB = (PFNGLUNIFORM3FVARBPROC) load(userptr, "glUniform3fvARB");
    glad_glUniform3i = (PFNGLUNIFORM3IPROC) load(userptr, "glUniform3i");
    glad_glUniform3iARB = (PFNGLUNIFORM3IARBPROC) load(userptr, "glUniform3iARB");
    glad_glUniform3iv = (PFNGLUNIFORM3IVPROC) load(userptr, "glUniform3iv");
    glad_glUniform3ivARB = (PFNGLUNIFORM3IVARBPROC) load(userptr, "glUniform3ivARB");
    glad_glUniform4f = (PFNGLUNIFORM4FPROC) load(userptr, "glUniform4f");
    glad_glUniform4fARB = (PFNGLUNIFORM4FARBPROC) load(userptr, "glUniform4fARB");
    glad_glUniform4fv = (PFNGLUNIFORM4FVPROC) load(userptr, "glUniform4fv");
    glad_glUniform4fvARB = (PFNGLUNIFORM4FVARBPROC) load(userptr, "glUniform4fvARB");
    glad_glUniform4i = (PFNGLUNIFORM4IPROC) load(userptr, "glUniform4i");
    glad_glUniform4iARB = (PFNGLUNIFORM4IARBPROC) load(userptr, "glUniform4iARB");
    glad_glUniform4iv = (PFNGLUNIFORM4IVPROC) load(userptr, "glUniform4iv");
    glad_glUniform4ivARB = (PFNGLUNIFORM4IVARBPROC) load(userptr, "glUniform4ivARB");
    glad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC) load(userptr, "glUniformMatrix2fv");
    glad_glUniformMatrix2fvARB = (PFNGLUNIFORMMATRIX2FVARBPROC) load(userptr, "glUniformMatrix2fvARB");
    glad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC) load(userptr, "glUniformMatrix3fv");
    glad_glUniformMatrix3fvARB = (PFNGLUNIFORMMATRIX3FVARBPROC) load(userptr, "glUniformMatrix3fvARB");
    glad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC) load(userptr, "glUniformMatrix4fv");
    glad_glUniformMatrix4fvARB = (PFNGLUNIFORMMATRIX4FVARBPROC) load(userptr, "glUniformMatrix4fvARB");
    glad_glUseProgram = (PFNGLUSEPROGRAMPROC) load(userptr, "glUseProgram");
    glad_glUseProgramObjectARB = (PFNGLUSEPROGRAMOBJECTARBPROC) load(userptr, "glUseProgramObjectARB");
    glad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC) load(userptr, "glValidateProgram");
    glad_glValidateProgramARB = (PFNGLVALIDATEPROGRAMARBPROC) load(userptr, "glValidateProgramARB");
}
static void glad_gl_load_GL_ARB_shader_storage_buffer_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_shader_storage_buffer_object) return;
    glad_glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC) load(userptr, "glShaderStorageBlockBinding");
}
static void glad_gl_load_GL_ARB_shader_subroutine( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_shader_subroutine) return;
    glad_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC) load(userptr, "glGetActiveSubroutineName");
    glad_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) load(userptr, "glGetActiveSubroutineUniformName");
    glad_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) load(userptr, "glGetActiveSubroutineUniformiv");
    glad_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC) load(userptr, "glGetProgramStageiv");
    glad_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC) load(userptr, "glGetSubroutineIndex");
    glad_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) load(userptr, "glGetSubroutineUniformLocation");
    glad_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC) load(userptr, "glGetUniformSubroutineuiv");
    glad_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC) load(userptr, "glUniformSubroutinesuiv");
}
static void glad_gl_load_GL_ARB_shading_language_include( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_shading_language_include) return;
    glad_glCompileShaderIncludeARB = (PFNGLCOMPILESHADERINCLUDEARBPROC) load(userptr, "glCompileShaderIncludeARB");
    glad_glDeleteNamedStringARB = (PFNGLDELETENAMEDSTRINGARBPROC) load(userptr, "glDeleteNamedStringARB");
    glad_glGetNamedStringARB = (PFNGLGETNAMEDSTRINGARBPROC) load(userptr, "glGetNamedStringARB");
    glad_glGetNamedStringivARB = (PFNGLGETNAMEDSTRINGIVARBPROC) load(userptr, "glGetNamedStringivARB");
    glad_glIsNamedStringARB = (PFNGLISNAMEDSTRINGARBPROC) load(userptr, "glIsNamedStringARB");
    glad_glNamedStringARB = (PFNGLNAMEDSTRINGARBPROC) load(userptr, "glNamedStringARB");
}
static void glad_gl_load_GL_ARB_sparse_buffer( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_sparse_buffer) return;
    glad_glBufferPageCommitmentARB = (PFNGLBUFFERPAGECOMMITMENTARBPROC) load(userptr, "glBufferPageCommitmentARB");
    glad_glNamedBufferPageCommitmentARB = (PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC) load(userptr, "glNamedBufferPageCommitmentARB");
    glad_glNamedBufferPageCommitmentEXT = (PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC) load(userptr, "glNamedBufferPageCommitmentEXT");
}
static void glad_gl_load_GL_ARB_sparse_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_sparse_texture) return;
    glad_glTexPageCommitmentARB = (PFNGLTEXPAGECOMMITMENTARBPROC) load(userptr, "glTexPageCommitmentARB");
}
static void glad_gl_load_GL_ARB_sync( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_sync) return;
    glad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) load(userptr, "glClientWaitSync");
    glad_glDeleteSync = (PFNGLDELETESYNCPROC) load(userptr, "glDeleteSync");
    glad_glFenceSync = (PFNGLFENCESYNCPROC) load(userptr, "glFenceSync");
    glad_glGetInteger64v = (PFNGLGETINTEGER64VPROC) load(userptr, "glGetInteger64v");
    glad_glGetSynciv = (PFNGLGETSYNCIVPROC) load(userptr, "glGetSynciv");
    glad_glIsSync = (PFNGLISSYNCPROC) load(userptr, "glIsSync");
    glad_glWaitSync = (PFNGLWAITSYNCPROC) load(userptr, "glWaitSync");
}
static void glad_gl_load_GL_ARB_tessellation_shader( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_tessellation_shader) return;
    glad_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC) load(userptr, "glPatchParameterfv");
    glad_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC) load(userptr, "glPatchParameteri");
}
static void glad_gl_load_GL_ARB_texture_barrier( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_texture_barrier) return;
    glad_glTextureBarrier = (PFNGLTEXTUREBARRIERPROC) load(userptr, "glTextureBarrier");
}
static void glad_gl_load_GL_ARB_texture_buffer_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_texture_buffer_object) return;
    glad_glTexBuffer = (PFNGLTEXBUFFERPROC) load(userptr, "glTexBuffer");
    glad_glTexBufferARB = (PFNGLTEXBUFFERARBPROC) load(userptr, "glTexBufferARB");
}
static void glad_gl_load_GL_ARB_texture_buffer_range( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_texture_buffer_range) return;
    glad_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC) load(userptr, "glTexBufferRange");
}
static void glad_gl_load_GL_ARB_texture_compression( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_texture_compression) return;
    glad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC) load(userptr, "glCompressedTexImage1D");
    glad_glCompressedTexImage1DARB = (PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) load(userptr, "glCompressedTexImage1DARB");
    glad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC) load(userptr, "glCompressedTexImage2D");
    glad_glCompressedTexImage2DARB = (PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) load(userptr, "glCompressedTexImage2DARB");
    glad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC) load(userptr, "glCompressedTexImage3D");
    glad_glCompressedTexImage3DARB = (PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) load(userptr, "glCompressedTexImage3DARB");
    glad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) load(userptr, "glCompressedTexSubImage1D");
    glad_glCompressedTexSubImage1DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) load(userptr, "glCompressedTexSubImage1DARB");
    glad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) load(userptr, "glCompressedTexSubImage2D");
    glad_glCompressedTexSubImage2DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) load(userptr, "glCompressedTexSubImage2DARB");
    glad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) load(userptr, "glCompressedTexSubImage3D");
    glad_glCompressedTexSubImage3DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) load(userptr, "glCompressedTexSubImage3DARB");
    glad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC) load(userptr, "glGetCompressedTexImage");
    glad_glGetCompressedTexImageARB = (PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) load(userptr, "glGetCompressedTexImageARB");
}
static void glad_gl_load_GL_ARB_texture_multisample( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_texture_multisample) return;
    glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) load(userptr, "glGetMultisamplefv");
    glad_glSampleMaski = (PFNGLSAMPLEMASKIPROC) load(userptr, "glSampleMaski");
    glad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC) load(userptr, "glTexImage2DMultisample");
    glad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC) load(userptr, "glTexImage3DMultisample");
}
static void glad_gl_load_GL_ARB_texture_storage( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_texture_storage) return;
    glad_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC) load(userptr, "glTexStorage1D");
    glad_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC) load(userptr, "glTexStorage2D");
    glad_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC) load(userptr, "glTexStorage3D");
}
static void glad_gl_load_GL_ARB_texture_storage_multisample( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_texture_storage_multisample) return;
    glad_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC) load(userptr, "glTexStorage2DMultisample");
    glad_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC) load(userptr, "glTexStorage3DMultisample");
}
static void glad_gl_load_GL_ARB_texture_view( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_texture_view) return;
    glad_glTextureView = (PFNGLTEXTUREVIEWPROC) load(userptr, "glTextureView");
}
static void glad_gl_load_GL_ARB_timer_query( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_timer_query) return;
    glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC) load(userptr, "glGetQueryObjecti64v");
    glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC) load(userptr, "glGetQueryObjectui64v");
    glad_glQueryCounter = (PFNGLQUERYCOUNTERPROC) load(userptr, "glQueryCounter");
}
static void glad_gl_load_GL_ARB_transform_feedback2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_transform_feedback2) return;
    glad_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) load(userptr, "glBindTransformFeedback");
    glad_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) load(userptr, "glDeleteTransformFeedbacks");
    glad_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) load(userptr, "glDrawTransformFeedback");
    glad_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) load(userptr, "glGenTransformFeedbacks");
    glad_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) load(userptr, "glIsTransformFeedback");
    glad_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) load(userptr, "glPauseTransformFeedback");
    glad_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) load(userptr, "glResumeTransformFeedback");
}
static void glad_gl_load_GL_ARB_transform_feedback3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_transform_feedback3) return;
    glad_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC) load(userptr, "glBeginQueryIndexed");
    glad_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) load(userptr, "glDrawTransformFeedbackStream");
    glad_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC) load(userptr, "glEndQueryIndexed");
    glad_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC) load(userptr, "glGetQueryIndexediv");
}
static void glad_gl_load_GL_ARB_transform_feedback_instanced( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_transform_feedback_instanced) return;
    glad_glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) load(userptr, "glDrawTransformFeedbackInstanced");
    glad_glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) load(userptr, "glDrawTransformFeedbackStreamInstanced");
}
static void glad_gl_load_GL_ARB_transpose_matrix( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_transpose_matrix) return;
    glad_glLoadTransposeMatrixd = (PFNGLLOADTRANSPOSEMATRIXDPROC) load(userptr, "glLoadTransposeMatrixd");
    glad_glLoadTransposeMatrixdARB = (PFNGLLOADTRANSPOSEMATRIXDARBPROC) load(userptr, "glLoadTransposeMatrixdARB");
    glad_glLoadTransposeMatrixf = (PFNGLLOADTRANSPOSEMATRIXFPROC) load(userptr, "glLoadTransposeMatrixf");
    glad_glLoadTransposeMatrixfARB = (PFNGLLOADTRANSPOSEMATRIXFARBPROC) load(userptr, "glLoadTransposeMatrixfARB");
    glad_glMultTransposeMatrixd = (PFNGLMULTTRANSPOSEMATRIXDPROC) load(userptr, "glMultTransposeMatrixd");
    glad_glMultTransposeMatrixdARB = (PFNGLMULTTRANSPOSEMATRIXDARBPROC) load(userptr, "glMultTransposeMatrixdARB");
    glad_glMultTransposeMatrixf = (PFNGLMULTTRANSPOSEMATRIXFPROC) load(userptr, "glMultTransposeMatrixf");
    glad_glMultTransposeMatrixfARB = (PFNGLMULTTRANSPOSEMATRIXFARBPROC) load(userptr, "glMultTransposeMatrixfARB");
}
static void glad_gl_load_GL_ARB_uniform_buffer_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_uniform_buffer_object) return;
    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
    glad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) load(userptr, "glGetActiveUniformBlockName");
    glad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) load(userptr, "glGetActiveUniformBlockiv");
    glad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC) load(userptr, "glGetActiveUniformName");
    glad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) load(userptr, "glGetActiveUniformsiv");
    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
    glad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) load(userptr, "glGetUniformBlockIndex");
    glad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) load(userptr, "glGetUniformIndices");
    glad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) load(userptr, "glUniformBlockBinding");
}
static void glad_gl_load_GL_ARB_vertex_array_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_vertex_array_object) return;
    glad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC) load(userptr, "glBindVertexArray");
    glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC) load(userptr, "glDeleteVertexArrays");
    glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC) load(userptr, "glGenVertexArrays");
    glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC) load(userptr, "glIsVertexArray");
}
static void glad_gl_load_GL_ARB_vertex_attrib_64bit( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_vertex_attrib_64bit) return;
    glad_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC) load(userptr, "glGetVertexAttribLdv");
    glad_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC) load(userptr, "glVertexAttribL1d");
    glad_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC) load(userptr, "glVertexAttribL1dv");
    glad_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC) load(userptr, "glVertexAttribL2d");
    glad_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC) load(userptr, "glVertexAttribL2dv");
    glad_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC) load(userptr, "glVertexAttribL3d");
    glad_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC) load(userptr, "glVertexAttribL3dv");
    glad_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC) load(userptr, "glVertexAttribL4d");
    glad_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC) load(userptr, "glVertexAttribL4dv");
    glad_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC) load(userptr, "glVertexAttribLPointer");
}
static void glad_gl_load_GL_ARB_vertex_attrib_binding( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_vertex_attrib_binding) return;
    glad_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC) load(userptr, "glBindVertexBuffer");
    glad_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC) load(userptr, "glVertexAttribBinding");
    glad_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC) load(userptr, "glVertexAttribFormat");
    glad_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC) load(userptr, "glVertexAttribIFormat");
    glad_glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC) load(userptr, "glVertexAttribLFormat");
    glad_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC) load(userptr, "glVertexBindingDivisor");
}
static void glad_gl_load_GL_ARB_vertex_blend( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_vertex_blend) return;
    glad_glVertexBlendARB = (PFNGLVERTEXBLENDARBPROC) load(userptr, "glVertexBlendARB");
    glad_glWeightPointerARB = (PFNGLWEIGHTPOINTERARBPROC) load(userptr, "glWeightPointerARB");
    glad_glWeightbvARB = (PFNGLWEIGHTBVARBPROC) load(userptr, "glWeightbvARB");
    glad_glWeightdvARB = (PFNGLWEIGHTDVARBPROC) load(userptr, "glWeightdvARB");
    glad_glWeightfvARB = (PFNGLWEIGHTFVARBPROC) load(userptr, "glWeightfvARB");
    glad_glWeightivARB = (PFNGLWEIGHTIVARBPROC) load(userptr, "glWeightivARB");
    glad_glWeightsvARB = (PFNGLWEIGHTSVARBPROC) load(userptr, "glWeightsvARB");
    glad_glWeightubvARB = (PFNGLWEIGHTUBVARBPROC) load(userptr, "glWeightubvARB");
    glad_glWeightuivARB = (PFNGLWEIGHTUIVARBPROC) load(userptr, "glWeightuivARB");
    glad_glWeightusvARB = (PFNGLWEIGHTUSVARBPROC) load(userptr, "glWeightusvARB");
}
static void glad_gl_load_GL_ARB_vertex_buffer_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_vertex_buffer_object) return;
    glad_glBindBuffer = (PFNGLBINDBUFFERPROC) load(userptr, "glBindBuffer");
    glad_glBindBufferARB = (PFNGLBINDBUFFERARBPROC) load(userptr, "glBindBufferARB");
    glad_glBufferData = (PFNGLBUFFERDATAPROC) load(userptr, "glBufferData");
    glad_glBufferDataARB = (PFNGLBUFFERDATAARBPROC) load(userptr, "glBufferDataARB");
    glad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC) load(userptr, "glBufferSubData");
    glad_glBufferSubDataARB = (PFNGLBUFFERSUBDATAARBPROC) load(userptr, "glBufferSubDataARB");
    glad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC) load(userptr, "glDeleteBuffers");
    glad_glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC) load(userptr, "glDeleteBuffersARB");
    glad_glGenBuffers = (PFNGLGENBUFFERSPROC) load(userptr, "glGenBuffers");
    glad_glGenBuffersARB = (PFNGLGENBUFFERSARBPROC) load(userptr, "glGenBuffersARB");
    glad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC) load(userptr, "glGetBufferParameteriv");
    glad_glGetBufferParameterivARB = (PFNGLGETBUFFERPARAMETERIVARBPROC) load(userptr, "glGetBufferParameterivARB");
    glad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC) load(userptr, "glGetBufferPointerv");
    glad_glGetBufferPointervARB = (PFNGLGETBUFFERPOINTERVARBPROC) load(userptr, "glGetBufferPointervARB");
    glad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC) load(userptr, "glGetBufferSubData");
    glad_glGetBufferSubDataARB = (PFNGLGETBUFFERSUBDATAARBPROC) load(userptr, "glGetBufferSubDataARB");
    glad_glIsBuffer = (PFNGLISBUFFERPROC) load(userptr, "glIsBuffer");
    glad_glIsBufferARB = (PFNGLISBUFFERARBPROC) load(userptr, "glIsBufferARB");
    glad_glMapBuffer = (PFNGLMAPBUFFERPROC) load(userptr, "glMapBuffer");
    glad_glMapBufferARB = (PFNGLMAPBUFFERARBPROC) load(userptr, "glMapBufferARB");
    glad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC) load(userptr, "glUnmapBuffer");
    glad_glUnmapBufferARB = (PFNGLUNMAPBUFFERARBPROC) load(userptr, "glUnmapBufferARB");
}
static void glad_gl_load_GL_ARB_vertex_program( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_vertex_program) return;
    glad_glBindProgramARB = (PFNGLBINDPROGRAMARBPROC) load(userptr, "glBindProgramARB");
    glad_glDeleteProgramsARB = (PFNGLDELETEPROGRAMSARBPROC) load(userptr, "glDeleteProgramsARB");
    glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC) load(userptr, "glDisableVertexAttribArray");
    glad_glDisableVertexAttribArrayARB = (PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) load(userptr, "glDisableVertexAttribArrayARB");
    glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC) load(userptr, "glEnableVertexAttribArray");
    glad_glEnableVertexAttribArrayARB = (PFNGLENABLEVERTEXATTRIBARRAYARBPROC) load(userptr, "glEnableVertexAttribArrayARB");
    glad_glGenProgramsARB = (PFNGLGENPROGRAMSARBPROC) load(userptr, "glGenProgramsARB");
    glad_glGetProgramEnvParameterdvARB = (PFNGLGETPROGRAMENVPARAMETERDVARBPROC) load(userptr, "glGetProgramEnvParameterdvARB");
    glad_glGetProgramEnvParameterfvARB = (PFNGLGETPROGRAMENVPARAMETERFVARBPROC) load(userptr, "glGetProgramEnvParameterfvARB");
    glad_glGetProgramLocalParameterdvARB = (PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) load(userptr, "glGetProgramLocalParameterdvARB");
    glad_glGetProgramLocalParameterfvARB = (PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) load(userptr, "glGetProgramLocalParameterfvARB");
    glad_glGetProgramStringARB = (PFNGLGETPROGRAMSTRINGARBPROC) load(userptr, "glGetProgramStringARB");
    glad_glGetProgramivARB = (PFNGLGETPROGRAMIVARBPROC) load(userptr, "glGetProgramivARB");
    glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC) load(userptr, "glGetVertexAttribPointerv");
    glad_glGetVertexAttribPointervARB = (PFNGLGETVERTEXATTRIBPOINTERVARBPROC) load(userptr, "glGetVertexAttribPointervARB");
    glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC) load(userptr, "glGetVertexAttribdv");
    glad_glGetVertexAttribdvARB = (PFNGLGETVERTEXATTRIBDVARBPROC) load(userptr, "glGetVertexAttribdvARB");
    glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC) load(userptr, "glGetVertexAttribfv");
    glad_glGetVertexAttribfvARB = (PFNGLGETVERTEXATTRIBFVARBPROC) load(userptr, "glGetVertexAttribfvARB");
    glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC) load(userptr, "glGetVertexAttribiv");
    glad_glGetVertexAttribivARB = (PFNGLGETVERTEXATTRIBIVARBPROC) load(userptr, "glGetVertexAttribivARB");
    glad_glIsProgramARB = (PFNGLISPROGRAMARBPROC) load(userptr, "glIsProgramARB");
    glad_glProgramEnvParameter4dARB = (PFNGLPROGRAMENVPARAMETER4DARBPROC) load(userptr, "glProgramEnvParameter4dARB");
    glad_glProgramEnvParameter4dvARB = (PFNGLPROGRAMENVPARAMETER4DVARBPROC) load(userptr, "glProgramEnvParameter4dvARB");
    glad_glProgramEnvParameter4fARB = (PFNGLPROGRAMENVPARAMETER4FARBPROC) load(userptr, "glProgramEnvParameter4fARB");
    glad_glProgramEnvParameter4fvARB = (PFNGLPROGRAMENVPARAMETER4FVARBPROC) load(userptr, "glProgramEnvParameter4fvARB");
    glad_glProgramLocalParameter4dARB = (PFNGLPROGRAMLOCALPARAMETER4DARBPROC) load(userptr, "glProgramLocalParameter4dARB");
    glad_glProgramLocalParameter4dvARB = (PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) load(userptr, "glProgramLocalParameter4dvARB");
    glad_glProgramLocalParameter4fARB = (PFNGLPROGRAMLOCALPARAMETER4FARBPROC) load(userptr, "glProgramLocalParameter4fARB");
    glad_glProgramLocalParameter4fvARB = (PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) load(userptr, "glProgramLocalParameter4fvARB");
    glad_glProgramStringARB = (PFNGLPROGRAMSTRINGARBPROC) load(userptr, "glProgramStringARB");
    glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC) load(userptr, "glVertexAttrib1d");
    glad_glVertexAttrib1dARB = (PFNGLVERTEXATTRIB1DARBPROC) load(userptr, "glVertexAttrib1dARB");
    glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC) load(userptr, "glVertexAttrib1dv");
    glad_glVertexAttrib1dvARB = (PFNGLVERTEXATTRIB1DVARBPROC) load(userptr, "glVertexAttrib1dvARB");
    glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC) load(userptr, "glVertexAttrib1f");
    glad_glVertexAttrib1fARB = (PFNGLVERTEXATTRIB1FARBPROC) load(userptr, "glVertexAttrib1fARB");
    glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC) load(userptr, "glVertexAttrib1fv");
    glad_glVertexAttrib1fvARB = (PFNGLVERTEXATTRIB1FVARBPROC) load(userptr, "glVertexAttrib1fvARB");
    glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC) load(userptr, "glVertexAttrib1s");
    glad_glVertexAttrib1sARB = (PFNGLVERTEXATTRIB1SARBPROC) load(userptr, "glVertexAttrib1sARB");
    glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC) load(userptr, "glVertexAttrib1sv");
    glad_glVertexAttrib1svARB = (PFNGLVERTEXATTRIB1SVARBPROC) load(userptr, "glVertexAttrib1svARB");
    glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC) load(userptr, "glVertexAttrib2d");
    glad_glVertexAttrib2dARB = (PFNGLVERTEXATTRIB2DARBPROC) load(userptr, "glVertexAttrib2dARB");
    glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC) load(userptr, "glVertexAttrib2dv");
    glad_glVertexAttrib2dvARB = (PFNGLVERTEXATTRIB2DVARBPROC) load(userptr, "glVertexAttrib2dvARB");
    glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC) load(userptr, "glVertexAttrib2f");
    glad_glVertexAttrib2fARB = (PFNGLVERTEXATTRIB2FARBPROC) load(userptr, "glVertexAttrib2fARB");
    glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC) load(userptr, "glVertexAttrib2fv");
    glad_glVertexAttrib2fvARB = (PFNGLVERTEXATTRIB2FVARBPROC) load(userptr, "glVertexAttrib2fvARB");
    glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC) load(userptr, "glVertexAttrib2s");
    glad_glVertexAttrib2sARB = (PFNGLVERTEXATTRIB2SARBPROC) load(userptr, "glVertexAttrib2sARB");
    glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC) load(userptr, "glVertexAttrib2sv");
    glad_glVertexAttrib2svARB = (PFNGLVERTEXATTRIB2SVARBPROC) load(userptr, "glVertexAttrib2svARB");
    glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC) load(userptr, "glVertexAttrib3d");
    glad_glVertexAttrib3dARB = (PFNGLVERTEXATTRIB3DARBPROC) load(userptr, "glVertexAttrib3dARB");
    glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC) load(userptr, "glVertexAttrib3dv");
    glad_glVertexAttrib3dvARB = (PFNGLVERTEXATTRIB3DVARBPROC) load(userptr, "glVertexAttrib3dvARB");
    glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC) load(userptr, "glVertexAttrib3f");
    glad_glVertexAttrib3fARB = (PFNGLVERTEXATTRIB3FARBPROC) load(userptr, "glVertexAttrib3fARB");
    glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC) load(userptr, "glVertexAttrib3fv");
    glad_glVertexAttrib3fvARB = (PFNGLVERTEXATTRIB3FVARBPROC) load(userptr, "glVertexAttrib3fvARB");
    glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC) load(userptr, "glVertexAttrib3s");
    glad_glVertexAttrib3sARB = (PFNGLVERTEXATTRIB3SARBPROC) load(userptr, "glVertexAttrib3sARB");
    glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC) load(userptr, "glVertexAttrib3sv");
    glad_glVertexAttrib3svARB = (PFNGLVERTEXATTRIB3SVARBPROC) load(userptr, "glVertexAttrib3svARB");
    glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC) load(userptr, "glVertexAttrib4Nbv");
    glad_glVertexAttrib4NbvARB = (PFNGLVERTEXATTRIB4NBVARBPROC) load(userptr, "glVertexAttrib4NbvARB");
    glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC) load(userptr, "glVertexAttrib4Niv");
    glad_glVertexAttrib4NivARB = (PFNGLVERTEXATTRIB4NIVARBPROC) load(userptr, "glVertexAttrib4NivARB");
    glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC) load(userptr, "glVertexAttrib4Nsv");
    glad_glVertexAttrib4NsvARB = (PFNGLVERTEXATTRIB4NSVARBPROC) load(userptr, "glVertexAttrib4NsvARB");
    glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC) load(userptr, "glVertexAttrib4Nub");
    glad_glVertexAttrib4NubARB = (PFNGLVERTEXATTRIB4NUBARBPROC) load(userptr, "glVertexAttrib4NubARB");
    glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC) load(userptr, "glVertexAttrib4Nubv");
    glad_glVertexAttrib4NubvARB = (PFNGLVERTEXATTRIB4NUBVARBPROC) load(userptr, "glVertexAttrib4NubvARB");
    glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC) load(userptr, "glVertexAttrib4Nuiv");
    glad_glVertexAttrib4NuivARB = (PFNGLVERTEXATTRIB4NUIVARBPROC) load(userptr, "glVertexAttrib4NuivARB");
    glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC) load(userptr, "glVertexAttrib4Nusv");
    glad_glVertexAttrib4NusvARB = (PFNGLVERTEXATTRIB4NUSVARBPROC) load(userptr, "glVertexAttrib4NusvARB");
    glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC) load(userptr, "glVertexAttrib4bv");
    glad_glVertexAttrib4bvARB = (PFNGLVERTEXATTRIB4BVARBPROC) load(userptr, "glVertexAttrib4bvARB");
    glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC) load(userptr, "glVertexAttrib4d");
    glad_glVertexAttrib4dARB = (PFNGLVERTEXATTRIB4DARBPROC) load(userptr, "glVertexAttrib4dARB");
    glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC) load(userptr, "glVertexAttrib4dv");
    glad_glVertexAttrib4dvARB = (PFNGLVERTEXATTRIB4DVARBPROC) load(userptr, "glVertexAttrib4dvARB");
    glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC) load(userptr, "glVertexAttrib4f");
    glad_glVertexAttrib4fARB = (PFNGLVERTEXATTRIB4FARBPROC) load(userptr, "glVertexAttrib4fARB");
    glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC) load(userptr, "glVertexAttrib4fv");
    glad_glVertexAttrib4fvARB = (PFNGLVERTEXATTRIB4FVARBPROC) load(userptr, "glVertexAttrib4fvARB");
    glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC) load(userptr, "glVertexAttrib4iv");
    glad_glVertexAttrib4ivARB = (PFNGLVERTEXATTRIB4IVARBPROC) load(userptr, "glVertexAttrib4ivARB");
    glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC) load(userptr, "glVertexAttrib4s");
    glad_glVertexAttrib4sARB = (PFNGLVERTEXATTRIB4SARBPROC) load(userptr, "glVertexAttrib4sARB");
    glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC) load(userptr, "glVertexAttrib4sv");
    glad_glVertexAttrib4svARB = (PFNGLVERTEXATTRIB4SVARBPROC) load(userptr, "glVertexAttrib4svARB");
    glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC) load(userptr, "glVertexAttrib4ubv");
    glad_glVertexAttrib4ubvARB = (PFNGLVERTEXATTRIB4UBVARBPROC) load(userptr, "glVertexAttrib4ubvARB");
    glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC) load(userptr, "glVertexAttrib4uiv");
    glad_glVertexAttrib4uivARB = (PFNGLVERTEXATTRIB4UIVARBPROC) load(userptr, "glVertexAttrib4uivARB");
    glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC) load(userptr, "glVertexAttrib4usv");
    glad_glVertexAttrib4usvARB = (PFNGLVERTEXATTRIB4USVARBPROC) load(userptr, "glVertexAttrib4usvARB");
    glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC) load(userptr, "glVertexAttribPointer");
    glad_glVertexAttribPointerARB = (PFNGLVERTEXATTRIBPOINTERARBPROC) load(userptr, "glVertexAttribPointerARB");
}
static void glad_gl_load_GL_ARB_vertex_shader( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_vertex_shader) return;
    glad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC) load(userptr, "glBindAttribLocation");
    glad_glBindAttribLocationARB = (PFNGLBINDATTRIBLOCATIONARBPROC) load(userptr, "glBindAttribLocationARB");
    glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC) load(userptr, "glDisableVertexAttribArray");
    glad_glDisableVertexAttribArrayARB = (PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) load(userptr, "glDisableVertexAttribArrayARB");
    glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC) load(userptr, "glEnableVertexAttribArray");
    glad_glEnableVertexAttribArrayARB = (PFNGLENABLEVERTEXATTRIBARRAYARBPROC) load(userptr, "glEnableVertexAttribArrayARB");
    glad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC) load(userptr, "glGetActiveAttrib");
    glad_glGetActiveAttribARB = (PFNGLGETACTIVEATTRIBARBPROC) load(userptr, "glGetActiveAttribARB");
    glad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC) load(userptr, "glGetAttribLocation");
    glad_glGetAttribLocationARB = (PFNGLGETATTRIBLOCATIONARBPROC) load(userptr, "glGetAttribLocationARB");
    glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC) load(userptr, "glGetVertexAttribPointerv");
    glad_glGetVertexAttribPointervARB = (PFNGLGETVERTEXATTRIBPOINTERVARBPROC) load(userptr, "glGetVertexAttribPointervARB");
    glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC) load(userptr, "glGetVertexAttribdv");
    glad_glGetVertexAttribdvARB = (PFNGLGETVERTEXATTRIBDVARBPROC) load(userptr, "glGetVertexAttribdvARB");
    glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC) load(userptr, "glGetVertexAttribfv");
    glad_glGetVertexAttribfvARB = (PFNGLGETVERTEXATTRIBFVARBPROC) load(userptr, "glGetVertexAttribfvARB");
    glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC) load(userptr, "glGetVertexAttribiv");
    glad_glGetVertexAttribivARB = (PFNGLGETVERTEXATTRIBIVARBPROC) load(userptr, "glGetVertexAttribivARB");
    glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC) load(userptr, "glVertexAttrib1d");
    glad_glVertexAttrib1dARB = (PFNGLVERTEXATTRIB1DARBPROC) load(userptr, "glVertexAttrib1dARB");
    glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC) load(userptr, "glVertexAttrib1dv");
    glad_glVertexAttrib1dvARB = (PFNGLVERTEXATTRIB1DVARBPROC) load(userptr, "glVertexAttrib1dvARB");
    glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC) load(userptr, "glVertexAttrib1f");
    glad_glVertexAttrib1fARB = (PFNGLVERTEXATTRIB1FARBPROC) load(userptr, "glVertexAttrib1fARB");
    glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC) load(userptr, "glVertexAttrib1fv");
    glad_glVertexAttrib1fvARB = (PFNGLVERTEXATTRIB1FVARBPROC) load(userptr, "glVertexAttrib1fvARB");
    glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC) load(userptr, "glVertexAttrib1s");
    glad_glVertexAttrib1sARB = (PFNGLVERTEXATTRIB1SARBPROC) load(userptr, "glVertexAttrib1sARB");
    glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC) load(userptr, "glVertexAttrib1sv");
    glad_glVertexAttrib1svARB = (PFNGLVERTEXATTRIB1SVARBPROC) load(userptr, "glVertexAttrib1svARB");
    glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC) load(userptr, "glVertexAttrib2d");
    glad_glVertexAttrib2dARB = (PFNGLVERTEXATTRIB2DARBPROC) load(userptr, "glVertexAttrib2dARB");
    glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC) load(userptr, "glVertexAttrib2dv");
    glad_glVertexAttrib2dvARB = (PFNGLVERTEXATTRIB2DVARBPROC) load(userptr, "glVertexAttrib2dvARB");
    glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC) load(userptr, "glVertexAttrib2f");
    glad_glVertexAttrib2fARB = (PFNGLVERTEXATTRIB2FARBPROC) load(userptr, "glVertexAttrib2fARB");
    glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC) load(userptr, "glVertexAttrib2fv");
    glad_glVertexAttrib2fvARB = (PFNGLVERTEXATTRIB2FVARBPROC) load(userptr, "glVertexAttrib2fvARB");
    glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC) load(userptr, "glVertexAttrib2s");
    glad_glVertexAttrib2sARB = (PFNGLVERTEXATTRIB2SARBPROC) load(userptr, "glVertexAttrib2sARB");
    glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC) load(userptr, "glVertexAttrib2sv");
    glad_glVertexAttrib2svARB = (PFNGLVERTEXATTRIB2SVARBPROC) load(userptr, "glVertexAttrib2svARB");
    glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC) load(userptr, "glVertexAttrib3d");
    glad_glVertexAttrib3dARB = (PFNGLVERTEXATTRIB3DARBPROC) load(userptr, "glVertexAttrib3dARB");
    glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC) load(userptr, "glVertexAttrib3dv");
    glad_glVertexAttrib3dvARB = (PFNGLVERTEXATTRIB3DVARBPROC) load(userptr, "glVertexAttrib3dvARB");
    glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC) load(userptr, "glVertexAttrib3f");
    glad_glVertexAttrib3fARB = (PFNGLVERTEXATTRIB3FARBPROC) load(userptr, "glVertexAttrib3fARB");
    glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC) load(userptr, "glVertexAttrib3fv");
    glad_glVertexAttrib3fvARB = (PFNGLVERTEXATTRIB3FVARBPROC) load(userptr, "glVertexAttrib3fvARB");
    glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC) load(userptr, "glVertexAttrib3s");
    glad_glVertexAttrib3sARB = (PFNGLVERTEXATTRIB3SARBPROC) load(userptr, "glVertexAttrib3sARB");
    glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC) load(userptr, "glVertexAttrib3sv");
    glad_glVertexAttrib3svARB = (PFNGLVERTEXATTRIB3SVARBPROC) load(userptr, "glVertexAttrib3svARB");
    glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC) load(userptr, "glVertexAttrib4Nbv");
    glad_glVertexAttrib4NbvARB = (PFNGLVERTEXATTRIB4NBVARBPROC) load(userptr, "glVertexAttrib4NbvARB");
    glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC) load(userptr, "glVertexAttrib4Niv");
    glad_glVertexAttrib4NivARB = (PFNGLVERTEXATTRIB4NIVARBPROC) load(userptr, "glVertexAttrib4NivARB");
    glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC) load(userptr, "glVertexAttrib4Nsv");
    glad_glVertexAttrib4NsvARB = (PFNGLVERTEXATTRIB4NSVARBPROC) load(userptr, "glVertexAttrib4NsvARB");
    glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC) load(userptr, "glVertexAttrib4Nub");
    glad_glVertexAttrib4NubARB = (PFNGLVERTEXATTRIB4NUBARBPROC) load(userptr, "glVertexAttrib4NubARB");
    glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC) load(userptr, "glVertexAttrib4Nubv");
    glad_glVertexAttrib4NubvARB = (PFNGLVERTEXATTRIB4NUBVARBPROC) load(userptr, "glVertexAttrib4NubvARB");
    glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC) load(userptr, "glVertexAttrib4Nuiv");
    glad_glVertexAttrib4NuivARB = (PFNGLVERTEXATTRIB4NUIVARBPROC) load(userptr, "glVertexAttrib4NuivARB");
    glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC) load(userptr, "glVertexAttrib4Nusv");
    glad_glVertexAttrib4NusvARB = (PFNGLVERTEXATTRIB4NUSVARBPROC) load(userptr, "glVertexAttrib4NusvARB");
    glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC) load(userptr, "glVertexAttrib4bv");
    glad_glVertexAttrib4bvARB = (PFNGLVERTEXATTRIB4BVARBPROC) load(userptr, "glVertexAttrib4bvARB");
    glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC) load(userptr, "glVertexAttrib4d");
    glad_glVertexAttrib4dARB = (PFNGLVERTEXATTRIB4DARBPROC) load(userptr, "glVertexAttrib4dARB");
    glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC) load(userptr, "glVertexAttrib4dv");
    glad_glVertexAttrib4dvARB = (PFNGLVERTEXATTRIB4DVARBPROC) load(userptr, "glVertexAttrib4dvARB");
    glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC) load(userptr, "glVertexAttrib4f");
    glad_glVertexAttrib4fARB = (PFNGLVERTEXATTRIB4FARBPROC) load(userptr, "glVertexAttrib4fARB");
    glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC) load(userptr, "glVertexAttrib4fv");
    glad_glVertexAttrib4fvARB = (PFNGLVERTEXATTRIB4FVARBPROC) load(userptr, "glVertexAttrib4fvARB");
    glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC) load(userptr, "glVertexAttrib4iv");
    glad_glVertexAttrib4ivARB = (PFNGLVERTEXATTRIB4IVARBPROC) load(userptr, "glVertexAttrib4ivARB");
    glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC) load(userptr, "glVertexAttrib4s");
    glad_glVertexAttrib4sARB = (PFNGLVERTEXATTRIB4SARBPROC) load(userptr, "glVertexAttrib4sARB");
    glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC) load(userptr, "glVertexAttrib4sv");
    glad_glVertexAttrib4svARB = (PFNGLVERTEXATTRIB4SVARBPROC) load(userptr, "glVertexAttrib4svARB");
    glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC) load(userptr, "glVertexAttrib4ubv");
    glad_glVertexAttrib4ubvARB = (PFNGLVERTEXATTRIB4UBVARBPROC) load(userptr, "glVertexAttrib4ubvARB");
    glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC) load(userptr, "glVertexAttrib4uiv");
    glad_glVertexAttrib4uivARB = (PFNGLVERTEXATTRIB4UIVARBPROC) load(userptr, "glVertexAttrib4uivARB");
    glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC) load(userptr, "glVertexAttrib4usv");
    glad_glVertexAttrib4usvARB = (PFNGLVERTEXATTRIB4USVARBPROC) load(userptr, "glVertexAttrib4usvARB");
    glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC) load(userptr, "glVertexAttribPointer");
    glad_glVertexAttribPointerARB = (PFNGLVERTEXATTRIBPOINTERARBPROC) load(userptr, "glVertexAttribPointerARB");
}
static void glad_gl_load_GL_ARB_vertex_type_2_10_10_10_rev( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_vertex_type_2_10_10_10_rev) return;
    glad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC) load(userptr, "glVertexAttribP1ui");
    glad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC) load(userptr, "glVertexAttribP1uiv");
    glad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC) load(userptr, "glVertexAttribP2ui");
    glad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC) load(userptr, "glVertexAttribP2uiv");
    glad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC) load(userptr, "glVertexAttribP3ui");
    glad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC) load(userptr, "glVertexAttribP3uiv");
    glad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC) load(userptr, "glVertexAttribP4ui");
    glad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC) load(userptr, "glVertexAttribP4uiv");
}
static void glad_gl_load_GL_ARB_viewport_array( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_viewport_array) return;
    glad_glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC) load(userptr, "glDepthRangeArrayv");
    glad_glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC) load(userptr, "glDepthRangeIndexed");
    glad_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC) load(userptr, "glGetDoublei_v");
    glad_glGetFloati_v = (PFNGLGETFLOATI_VPROC) load(userptr, "glGetFloati_v");
    glad_glScissorArrayv = (PFNGLSCISSORARRAYVPROC) load(userptr, "glScissorArrayv");
    glad_glScissorIndexed = (PFNGLSCISSORINDEXEDPROC) load(userptr, "glScissorIndexed");
    glad_glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC) load(userptr, "glScissorIndexedv");
    glad_glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC) load(userptr, "glViewportArrayv");
    glad_glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC) load(userptr, "glViewportIndexedf");
    glad_glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC) load(userptr, "glViewportIndexedfv");
}
static void glad_gl_load_GL_ARB_window_pos( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ARB_window_pos) return;
    glad_glWindowPos2d = (PFNGLWINDOWPOS2DPROC) load(userptr, "glWindowPos2d");
    glad_glWindowPos2dARB = (PFNGLWINDOWPOS2DARBPROC) load(userptr, "glWindowPos2dARB");
    glad_glWindowPos2dv = (PFNGLWINDOWPOS2DVPROC) load(userptr, "glWindowPos2dv");
    glad_glWindowPos2dvARB = (PFNGLWINDOWPOS2DVARBPROC) load(userptr, "glWindowPos2dvARB");
    glad_glWindowPos2f = (PFNGLWINDOWPOS2FPROC) load(userptr, "glWindowPos2f");
    glad_glWindowPos2fARB = (PFNGLWINDOWPOS2FARBPROC) load(userptr, "glWindowPos2fARB");
    glad_glWindowPos2fv = (PFNGLWINDOWPOS2FVPROC) load(userptr, "glWindowPos2fv");
    glad_glWindowPos2fvARB = (PFNGLWINDOWPOS2FVARBPROC) load(userptr, "glWindowPos2fvARB");
    glad_glWindowPos2i = (PFNGLWINDOWPOS2IPROC) load(userptr, "glWindowPos2i");
    glad_glWindowPos2iARB = (PFNGLWINDOWPOS2IARBPROC) load(userptr, "glWindowPos2iARB");
    glad_glWindowPos2iv = (PFNGLWINDOWPOS2IVPROC) load(userptr, "glWindowPos2iv");
    glad_glWindowPos2ivARB = (PFNGLWINDOWPOS2IVARBPROC) load(userptr, "glWindowPos2ivARB");
    glad_glWindowPos2s = (PFNGLWINDOWPOS2SPROC) load(userptr, "glWindowPos2s");
    glad_glWindowPos2sARB = (PFNGLWINDOWPOS2SARBPROC) load(userptr, "glWindowPos2sARB");
    glad_glWindowPos2sv = (PFNGLWINDOWPOS2SVPROC) load(userptr, "glWindowPos2sv");
    glad_glWindowPos2svARB = (PFNGLWINDOWPOS2SVARBPROC) load(userptr, "glWindowPos2svARB");
    glad_glWindowPos3d = (PFNGLWINDOWPOS3DPROC) load(userptr, "glWindowPos3d");
    glad_glWindowPos3dARB = (PFNGLWINDOWPOS3DARBPROC) load(userptr, "glWindowPos3dARB");
    glad_glWindowPos3dv = (PFNGLWINDOWPOS3DVPROC) load(userptr, "glWindowPos3dv");
    glad_glWindowPos3dvARB = (PFNGLWINDOWPOS3DVARBPROC) load(userptr, "glWindowPos3dvARB");
    glad_glWindowPos3f = (PFNGLWINDOWPOS3FPROC) load(userptr, "glWindowPos3f");
    glad_glWindowPos3fARB = (PFNGLWINDOWPOS3FARBPROC) load(userptr, "glWindowPos3fARB");
    glad_glWindowPos3fv = (PFNGLWINDOWPOS3FVPROC) load(userptr, "glWindowPos3fv");
    glad_glWindowPos3fvARB = (PFNGLWINDOWPOS3FVARBPROC) load(userptr, "glWindowPos3fvARB");
    glad_glWindowPos3i = (PFNGLWINDOWPOS3IPROC) load(userptr, "glWindowPos3i");
    glad_glWindowPos3iARB = (PFNGLWINDOWPOS3IARBPROC) load(userptr, "glWindowPos3iARB");
    glad_glWindowPos3iv = (PFNGLWINDOWPOS3IVPROC) load(userptr, "glWindowPos3iv");
    glad_glWindowPos3ivARB = (PFNGLWINDOWPOS3IVARBPROC) load(userptr, "glWindowPos3ivARB");
    glad_glWindowPos3s = (PFNGLWINDOWPOS3SPROC) load(userptr, "glWindowPos3s");
    glad_glWindowPos3sARB = (PFNGLWINDOWPOS3SARBPROC) load(userptr, "glWindowPos3sARB");
    glad_glWindowPos3sv = (PFNGLWINDOWPOS3SVPROC) load(userptr, "glWindowPos3sv");
    glad_glWindowPos3svARB = (PFNGLWINDOWPOS3SVARBPROC) load(userptr, "glWindowPos3svARB");
}
static void glad_gl_load_GL_ATI_draw_buffers( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_draw_buffers) return;
    glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC) load(userptr, "glDrawBuffers");
    glad_glDrawBuffersATI = (PFNGLDRAWBUFFERSATIPROC) load(userptr, "glDrawBuffersATI");
}
static void glad_gl_load_GL_ATI_element_array( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_element_array) return;
    glad_glDrawElementArrayATI = (PFNGLDRAWELEMENTARRAYATIPROC) load(userptr, "glDrawElementArrayATI");
    glad_glDrawRangeElementArrayATI = (PFNGLDRAWRANGEELEMENTARRAYATIPROC) load(userptr, "glDrawRangeElementArrayATI");
    glad_glElementPointerATI = (PFNGLELEMENTPOINTERATIPROC) load(userptr, "glElementPointerATI");
}
static void glad_gl_load_GL_ATI_envmap_bumpmap( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_envmap_bumpmap) return;
    glad_glGetTexBumpParameterfvATI = (PFNGLGETTEXBUMPPARAMETERFVATIPROC) load(userptr, "glGetTexBumpParameterfvATI");
    glad_glGetTexBumpParameterivATI = (PFNGLGETTEXBUMPPARAMETERIVATIPROC) load(userptr, "glGetTexBumpParameterivATI");
    glad_glTexBumpParameterfvATI = (PFNGLTEXBUMPPARAMETERFVATIPROC) load(userptr, "glTexBumpParameterfvATI");
    glad_glTexBumpParameterivATI = (PFNGLTEXBUMPPARAMETERIVATIPROC) load(userptr, "glTexBumpParameterivATI");
}
static void glad_gl_load_GL_ATI_fragment_shader( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_fragment_shader) return;
    glad_glAlphaFragmentOp1ATI = (PFNGLALPHAFRAGMENTOP1ATIPROC) load(userptr, "glAlphaFragmentOp1ATI");
    glad_glAlphaFragmentOp2ATI = (PFNGLALPHAFRAGMENTOP2ATIPROC) load(userptr, "glAlphaFragmentOp2ATI");
    glad_glAlphaFragmentOp3ATI = (PFNGLALPHAFRAGMENTOP3ATIPROC) load(userptr, "glAlphaFragmentOp3ATI");
    glad_glBeginFragmentShaderATI = (PFNGLBEGINFRAGMENTSHADERATIPROC) load(userptr, "glBeginFragmentShaderATI");
    glad_glBindFragmentShaderATI = (PFNGLBINDFRAGMENTSHADERATIPROC) load(userptr, "glBindFragmentShaderATI");
    glad_glColorFragmentOp1ATI = (PFNGLCOLORFRAGMENTOP1ATIPROC) load(userptr, "glColorFragmentOp1ATI");
    glad_glColorFragmentOp2ATI = (PFNGLCOLORFRAGMENTOP2ATIPROC) load(userptr, "glColorFragmentOp2ATI");
    glad_glColorFragmentOp3ATI = (PFNGLCOLORFRAGMENTOP3ATIPROC) load(userptr, "glColorFragmentOp3ATI");
    glad_glDeleteFragmentShaderATI = (PFNGLDELETEFRAGMENTSHADERATIPROC) load(userptr, "glDeleteFragmentShaderATI");
    glad_glEndFragmentShaderATI = (PFNGLENDFRAGMENTSHADERATIPROC) load(userptr, "glEndFragmentShaderATI");
    glad_glGenFragmentShadersATI = (PFNGLGENFRAGMENTSHADERSATIPROC) load(userptr, "glGenFragmentShadersATI");
    glad_glPassTexCoordATI = (PFNGLPASSTEXCOORDATIPROC) load(userptr, "glPassTexCoordATI");
    glad_glSampleMapATI = (PFNGLSAMPLEMAPATIPROC) load(userptr, "glSampleMapATI");
    glad_glSetFragmentShaderConstantATI = (PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) load(userptr, "glSetFragmentShaderConstantATI");
}
static void glad_gl_load_GL_ATI_map_object_buffer( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_map_object_buffer) return;
    glad_glMapObjectBufferATI = (PFNGLMAPOBJECTBUFFERATIPROC) load(userptr, "glMapObjectBufferATI");
    glad_glUnmapObjectBufferATI = (PFNGLUNMAPOBJECTBUFFERATIPROC) load(userptr, "glUnmapObjectBufferATI");
}
static void glad_gl_load_GL_ATI_pn_triangles( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_pn_triangles) return;
    glad_glPNTrianglesfATI = (PFNGLPNTRIANGLESFATIPROC) load(userptr, "glPNTrianglesfATI");
    glad_glPNTrianglesiATI = (PFNGLPNTRIANGLESIATIPROC) load(userptr, "glPNTrianglesiATI");
}
static void glad_gl_load_GL_ATI_separate_stencil( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_separate_stencil) return;
    glad_glStencilFuncSeparateATI = (PFNGLSTENCILFUNCSEPARATEATIPROC) load(userptr, "glStencilFuncSeparateATI");
    glad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC) load(userptr, "glStencilOpSeparate");
    glad_glStencilOpSeparateATI = (PFNGLSTENCILOPSEPARATEATIPROC) load(userptr, "glStencilOpSeparateATI");
}
static void glad_gl_load_GL_ATI_vertex_array_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_vertex_array_object) return;
    glad_glArrayObjectATI = (PFNGLARRAYOBJECTATIPROC) load(userptr, "glArrayObjectATI");
    glad_glFreeObjectBufferATI = (PFNGLFREEOBJECTBUFFERATIPROC) load(userptr, "glFreeObjectBufferATI");
    glad_glGetArrayObjectfvATI = (PFNGLGETARRAYOBJECTFVATIPROC) load(userptr, "glGetArrayObjectfvATI");
    glad_glGetArrayObjectivATI = (PFNGLGETARRAYOBJECTIVATIPROC) load(userptr, "glGetArrayObjectivATI");
    glad_glGetObjectBufferfvATI = (PFNGLGETOBJECTBUFFERFVATIPROC) load(userptr, "glGetObjectBufferfvATI");
    glad_glGetObjectBufferivATI = (PFNGLGETOBJECTBUFFERIVATIPROC) load(userptr, "glGetObjectBufferivATI");
    glad_glGetVariantArrayObjectfvATI = (PFNGLGETVARIANTARRAYOBJECTFVATIPROC) load(userptr, "glGetVariantArrayObjectfvATI");
    glad_glGetVariantArrayObjectivATI = (PFNGLGETVARIANTARRAYOBJECTIVATIPROC) load(userptr, "glGetVariantArrayObjectivATI");
    glad_glIsObjectBufferATI = (PFNGLISOBJECTBUFFERATIPROC) load(userptr, "glIsObjectBufferATI");
    glad_glNewObjectBufferATI = (PFNGLNEWOBJECTBUFFERATIPROC) load(userptr, "glNewObjectBufferATI");
    glad_glUpdateObjectBufferATI = (PFNGLUPDATEOBJECTBUFFERATIPROC) load(userptr, "glUpdateObjectBufferATI");
    glad_glVariantArrayObjectATI = (PFNGLVARIANTARRAYOBJECTATIPROC) load(userptr, "glVariantArrayObjectATI");
}
static void glad_gl_load_GL_ATI_vertex_attrib_array_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_vertex_attrib_array_object) return;
    glad_glGetVertexAttribArrayObjectfvATI = (PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) load(userptr, "glGetVertexAttribArrayObjectfvATI");
    glad_glGetVertexAttribArrayObjectivATI = (PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) load(userptr, "glGetVertexAttribArrayObjectivATI");
    glad_glVertexAttribArrayObjectATI = (PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) load(userptr, "glVertexAttribArrayObjectATI");
}
static void glad_gl_load_GL_ATI_vertex_streams( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_ATI_vertex_streams) return;
    glad_glClientActiveVertexStreamATI = (PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) load(userptr, "glClientActiveVertexStreamATI");
    glad_glNormalStream3bATI = (PFNGLNORMALSTREAM3BATIPROC) load(userptr, "glNormalStream3bATI");
    glad_glNormalStream3bvATI = (PFNGLNORMALSTREAM3BVATIPROC) load(userptr, "glNormalStream3bvATI");
    glad_glNormalStream3dATI = (PFNGLNORMALSTREAM3DATIPROC) load(userptr, "glNormalStream3dATI");
    glad_glNormalStream3dvATI = (PFNGLNORMALSTREAM3DVATIPROC) load(userptr, "glNormalStream3dvATI");
    glad_glNormalStream3fATI = (PFNGLNORMALSTREAM3FATIPROC) load(userptr, "glNormalStream3fATI");
    glad_glNormalStream3fvATI = (PFNGLNORMALSTREAM3FVATIPROC) load(userptr, "glNormalStream3fvATI");
    glad_glNormalStream3iATI = (PFNGLNORMALSTREAM3IATIPROC) load(userptr, "glNormalStream3iATI");
    glad_glNormalStream3ivATI = (PFNGLNORMALSTREAM3IVATIPROC) load(userptr, "glNormalStream3ivATI");
    glad_glNormalStream3sATI = (PFNGLNORMALSTREAM3SATIPROC) load(userptr, "glNormalStream3sATI");
    glad_glNormalStream3svATI = (PFNGLNORMALSTREAM3SVATIPROC) load(userptr, "glNormalStream3svATI");
    glad_glVertexBlendEnvfATI = (PFNGLVERTEXBLENDENVFATIPROC) load(userptr, "glVertexBlendEnvfATI");
    glad_glVertexBlendEnviATI = (PFNGLVERTEXBLENDENVIATIPROC) load(userptr, "glVertexBlendEnviATI");
    glad_glVertexStream1dATI = (PFNGLVERTEXSTREAM1DATIPROC) load(userptr, "glVertexStream1dATI");
    glad_glVertexStream1dvATI = (PFNGLVERTEXSTREAM1DVATIPROC) load(userptr, "glVertexStream1dvATI");
    glad_glVertexStream1fATI = (PFNGLVERTEXSTREAM1FATIPROC) load(userptr, "glVertexStream1fATI");
    glad_glVertexStream1fvATI = (PFNGLVERTEXSTREAM1FVATIPROC) load(userptr, "glVertexStream1fvATI");
    glad_glVertexStream1iATI = (PFNGLVERTEXSTREAM1IATIPROC) load(userptr, "glVertexStream1iATI");
    glad_glVertexStream1ivATI = (PFNGLVERTEXSTREAM1IVATIPROC) load(userptr, "glVertexStream1ivATI");
    glad_glVertexStream1sATI = (PFNGLVERTEXSTREAM1SATIPROC) load(userptr, "glVertexStream1sATI");
    glad_glVertexStream1svATI = (PFNGLVERTEXSTREAM1SVATIPROC) load(userptr, "glVertexStream1svATI");
    glad_glVertexStream2dATI = (PFNGLVERTEXSTREAM2DATIPROC) load(userptr, "glVertexStream2dATI");
    glad_glVertexStream2dvATI = (PFNGLVERTEXSTREAM2DVATIPROC) load(userptr, "glVertexStream2dvATI");
    glad_glVertexStream2fATI = (PFNGLVERTEXSTREAM2FATIPROC) load(userptr, "glVertexStream2fATI");
    glad_glVertexStream2fvATI = (PFNGLVERTEXSTREAM2FVATIPROC) load(userptr, "glVertexStream2fvATI");
    glad_glVertexStream2iATI = (PFNGLVERTEXSTREAM2IATIPROC) load(userptr, "glVertexStream2iATI");
    glad_glVertexStream2ivATI = (PFNGLVERTEXSTREAM2IVATIPROC) load(userptr, "glVertexStream2ivATI");
    glad_glVertexStream2sATI = (PFNGLVERTEXSTREAM2SATIPROC) load(userptr, "glVertexStream2sATI");
    glad_glVertexStream2svATI = (PFNGLVERTEXSTREAM2SVATIPROC) load(userptr, "glVertexStream2svATI");
    glad_glVertexStream3dATI = (PFNGLVERTEXSTREAM3DATIPROC) load(userptr, "glVertexStream3dATI");
    glad_glVertexStream3dvATI = (PFNGLVERTEXSTREAM3DVATIPROC) load(userptr, "glVertexStream3dvATI");
    glad_glVertexStream3fATI = (PFNGLVERTEXSTREAM3FATIPROC) load(userptr, "glVertexStream3fATI");
    glad_glVertexStream3fvATI = (PFNGLVERTEXSTREAM3FVATIPROC) load(userptr, "glVertexStream3fvATI");
    glad_glVertexStream3iATI = (PFNGLVERTEXSTREAM3IATIPROC) load(userptr, "glVertexStream3iATI");
    glad_glVertexStream3ivATI = (PFNGLVERTEXSTREAM3IVATIPROC) load(userptr, "glVertexStream3ivATI");
    glad_glVertexStream3sATI = (PFNGLVERTEXSTREAM3SATIPROC) load(userptr, "glVertexStream3sATI");
    glad_glVertexStream3svATI = (PFNGLVERTEXSTREAM3SVATIPROC) load(userptr, "glVertexStream3svATI");
    glad_glVertexStream4dATI = (PFNGLVERTEXSTREAM4DATIPROC) load(userptr, "glVertexStream4dATI");
    glad_glVertexStream4dvATI = (PFNGLVERTEXSTREAM4DVATIPROC) load(userptr, "glVertexStream4dvATI");
    glad_glVertexStream4fATI = (PFNGLVERTEXSTREAM4FATIPROC) load(userptr, "glVertexStream4fATI");
    glad_glVertexStream4fvATI = (PFNGLVERTEXSTREAM4FVATIPROC) load(userptr, "glVertexStream4fvATI");
    glad_glVertexStream4iATI = (PFNGLVERTEXSTREAM4IATIPROC) load(userptr, "glVertexStream4iATI");
    glad_glVertexStream4ivATI = (PFNGLVERTEXSTREAM4IVATIPROC) load(userptr, "glVertexStream4ivATI");
    glad_glVertexStream4sATI = (PFNGLVERTEXSTREAM4SATIPROC) load(userptr, "glVertexStream4sATI");
    glad_glVertexStream4svATI = (PFNGLVERTEXSTREAM4SVATIPROC) load(userptr, "glVertexStream4svATI");
}
static void glad_gl_load_GL_EXT_bindable_uniform( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_bindable_uniform) return;
    glad_glGetUniformBufferSizeEXT = (PFNGLGETUNIFORMBUFFERSIZEEXTPROC) load(userptr, "glGetUniformBufferSizeEXT");
    glad_glGetUniformOffsetEXT = (PFNGLGETUNIFORMOFFSETEXTPROC) load(userptr, "glGetUniformOffsetEXT");
    glad_glUniformBufferEXT = (PFNGLUNIFORMBUFFEREXTPROC) load(userptr, "glUniformBufferEXT");
}
static void glad_gl_load_GL_EXT_blend_color( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_blend_color) return;
    glad_glBlendColor = (PFNGLBLENDCOLORPROC) load(userptr, "glBlendColor");
    glad_glBlendColorEXT = (PFNGLBLENDCOLOREXTPROC) load(userptr, "glBlendColorEXT");
}
static void glad_gl_load_GL_EXT_blend_equation_separate( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_blend_equation_separate) return;
    glad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC) load(userptr, "glBlendEquationSeparate");
    glad_glBlendEquationSeparateEXT = (PFNGLBLENDEQUATIONSEPARATEEXTPROC) load(userptr, "glBlendEquationSeparateEXT");
}
static void glad_gl_load_GL_EXT_blend_func_separate( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_blend_func_separate) return;
    glad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC) load(userptr, "glBlendFuncSeparate");
    glad_glBlendFuncSeparateEXT = (PFNGLBLENDFUNCSEPARATEEXTPROC) load(userptr, "glBlendFuncSeparateEXT");
}
static void glad_gl_load_GL_EXT_blend_minmax( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_blend_minmax) return;
    glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC) load(userptr, "glBlendEquation");
    glad_glBlendEquationEXT = (PFNGLBLENDEQUATIONEXTPROC) load(userptr, "glBlendEquationEXT");
}
static void glad_gl_load_GL_EXT_color_subtable( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_color_subtable) return;
    glad_glColorSubTable = (PFNGLCOLORSUBTABLEPROC) load(userptr, "glColorSubTable");
    glad_glColorSubTableEXT = (PFNGLCOLORSUBTABLEEXTPROC) load(userptr, "glColorSubTableEXT");
    glad_glCopyColorSubTable = (PFNGLCOPYCOLORSUBTABLEPROC) load(userptr, "glCopyColorSubTable");
    glad_glCopyColorSubTableEXT = (PFNGLCOPYCOLORSUBTABLEEXTPROC) load(userptr, "glCopyColorSubTableEXT");
}
static void glad_gl_load_GL_EXT_compiled_vertex_array( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_compiled_vertex_array) return;
    glad_glLockArraysEXT = (PFNGLLOCKARRAYSEXTPROC) load(userptr, "glLockArraysEXT");
    glad_glUnlockArraysEXT = (PFNGLUNLOCKARRAYSEXTPROC) load(userptr, "glUnlockArraysEXT");
}
static void glad_gl_load_GL_EXT_convolution( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_convolution) return;
    glad_glConvolutionFilter1D = (PFNGLCONVOLUTIONFILTER1DPROC) load(userptr, "glConvolutionFilter1D");
    glad_glConvolutionFilter1DEXT = (PFNGLCONVOLUTIONFILTER1DEXTPROC) load(userptr, "glConvolutionFilter1DEXT");
    glad_glConvolutionFilter2D = (PFNGLCONVOLUTIONFILTER2DPROC) load(userptr, "glConvolutionFilter2D");
    glad_glConvolutionFilter2DEXT = (PFNGLCONVOLUTIONFILTER2DEXTPROC) load(userptr, "glConvolutionFilter2DEXT");
    glad_glConvolutionParameterf = (PFNGLCONVOLUTIONPARAMETERFPROC) load(userptr, "glConvolutionParameterf");
    glad_glConvolutionParameterfEXT = (PFNGLCONVOLUTIONPARAMETERFEXTPROC) load(userptr, "glConvolutionParameterfEXT");
    glad_glConvolutionParameterfv = (PFNGLCONVOLUTIONPARAMETERFVPROC) load(userptr, "glConvolutionParameterfv");
    glad_glConvolutionParameterfvEXT = (PFNGLCONVOLUTIONPARAMETERFVEXTPROC) load(userptr, "glConvolutionParameterfvEXT");
    glad_glConvolutionParameteri = (PFNGLCONVOLUTIONPARAMETERIPROC) load(userptr, "glConvolutionParameteri");
    glad_glConvolutionParameteriEXT = (PFNGLCONVOLUTIONPARAMETERIEXTPROC) load(userptr, "glConvolutionParameteriEXT");
    glad_glConvolutionParameteriv = (PFNGLCONVOLUTIONPARAMETERIVPROC) load(userptr, "glConvolutionParameteriv");
    glad_glConvolutionParameterivEXT = (PFNGLCONVOLUTIONPARAMETERIVEXTPROC) load(userptr, "glConvolutionParameterivEXT");
    glad_glCopyConvolutionFilter1D = (PFNGLCOPYCONVOLUTIONFILTER1DPROC) load(userptr, "glCopyConvolutionFilter1D");
    glad_glCopyConvolutionFilter1DEXT = (PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) load(userptr, "glCopyConvolutionFilter1DEXT");
    glad_glCopyConvolutionFilter2D = (PFNGLCOPYCONVOLUTIONFILTER2DPROC) load(userptr, "glCopyConvolutionFilter2D");
    glad_glCopyConvolutionFilter2DEXT = (PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) load(userptr, "glCopyConvolutionFilter2DEXT");
    glad_glGetConvolutionFilterEXT = (PFNGLGETCONVOLUTIONFILTEREXTPROC) load(userptr, "glGetConvolutionFilterEXT");
    glad_glGetConvolutionParameterfvEXT = (PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) load(userptr, "glGetConvolutionParameterfvEXT");
    glad_glGetConvolutionParameterivEXT = (PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) load(userptr, "glGetConvolutionParameterivEXT");
    glad_glGetSeparableFilterEXT = (PFNGLGETSEPARABLEFILTEREXTPROC) load(userptr, "glGetSeparableFilterEXT");
    glad_glSeparableFilter2D = (PFNGLSEPARABLEFILTER2DPROC) load(userptr, "glSeparableFilter2D");
    glad_glSeparableFilter2DEXT = (PFNGLSEPARABLEFILTER2DEXTPROC) load(userptr, "glSeparableFilter2DEXT");
}
static void glad_gl_load_GL_EXT_coordinate_frame( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_coordinate_frame) return;
    glad_glBinormal3bEXT = (PFNGLBINORMAL3BEXTPROC) load(userptr, "glBinormal3bEXT");
    glad_glBinormal3bvEXT = (PFNGLBINORMAL3BVEXTPROC) load(userptr, "glBinormal3bvEXT");
    glad_glBinormal3dEXT = (PFNGLBINORMAL3DEXTPROC) load(userptr, "glBinormal3dEXT");
    glad_glBinormal3dvEXT = (PFNGLBINORMAL3DVEXTPROC) load(userptr, "glBinormal3dvEXT");
    glad_glBinormal3fEXT = (PFNGLBINORMAL3FEXTPROC) load(userptr, "glBinormal3fEXT");
    glad_glBinormal3fvEXT = (PFNGLBINORMAL3FVEXTPROC) load(userptr, "glBinormal3fvEXT");
    glad_glBinormal3iEXT = (PFNGLBINORMAL3IEXTPROC) load(userptr, "glBinormal3iEXT");
    glad_glBinormal3ivEXT = (PFNGLBINORMAL3IVEXTPROC) load(userptr, "glBinormal3ivEXT");
    glad_glBinormal3sEXT = (PFNGLBINORMAL3SEXTPROC) load(userptr, "glBinormal3sEXT");
    glad_glBinormal3svEXT = (PFNGLBINORMAL3SVEXTPROC) load(userptr, "glBinormal3svEXT");
    glad_glBinormalPointerEXT = (PFNGLBINORMALPOINTEREXTPROC) load(userptr, "glBinormalPointerEXT");
    glad_glTangent3bEXT = (PFNGLTANGENT3BEXTPROC) load(userptr, "glTangent3bEXT");
    glad_glTangent3bvEXT = (PFNGLTANGENT3BVEXTPROC) load(userptr, "glTangent3bvEXT");
    glad_glTangent3dEXT = (PFNGLTANGENT3DEXTPROC) load(userptr, "glTangent3dEXT");
    glad_glTangent3dvEXT = (PFNGLTANGENT3DVEXTPROC) load(userptr, "glTangent3dvEXT");
    glad_glTangent3fEXT = (PFNGLTANGENT3FEXTPROC) load(userptr, "glTangent3fEXT");
    glad_glTangent3fvEXT = (PFNGLTANGENT3FVEXTPROC) load(userptr, "glTangent3fvEXT");
    glad_glTangent3iEXT = (PFNGLTANGENT3IEXTPROC) load(userptr, "glTangent3iEXT");
    glad_glTangent3ivEXT = (PFNGLTANGENT3IVEXTPROC) load(userptr, "glTangent3ivEXT");
    glad_glTangent3sEXT = (PFNGLTANGENT3SEXTPROC) load(userptr, "glTangent3sEXT");
    glad_glTangent3svEXT = (PFNGLTANGENT3SVEXTPROC) load(userptr, "glTangent3svEXT");
    glad_glTangentPointerEXT = (PFNGLTANGENTPOINTEREXTPROC) load(userptr, "glTangentPointerEXT");
}
static void glad_gl_load_GL_EXT_copy_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_copy_texture) return;
    glad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC) load(userptr, "glCopyTexImage1D");
    glad_glCopyTexImage1DEXT = (PFNGLCOPYTEXIMAGE1DEXTPROC) load(userptr, "glCopyTexImage1DEXT");
    glad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC) load(userptr, "glCopyTexImage2D");
    glad_glCopyTexImage2DEXT = (PFNGLCOPYTEXIMAGE2DEXTPROC) load(userptr, "glCopyTexImage2DEXT");
    glad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC) load(userptr, "glCopyTexSubImage1D");
    glad_glCopyTexSubImage1DEXT = (PFNGLCOPYTEXSUBIMAGE1DEXTPROC) load(userptr, "glCopyTexSubImage1DEXT");
    glad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC) load(userptr, "glCopyTexSubImage2D");
    glad_glCopyTexSubImage2DEXT = (PFNGLCOPYTEXSUBIMAGE2DEXTPROC) load(userptr, "glCopyTexSubImage2DEXT");
    glad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC) load(userptr, "glCopyTexSubImage3D");
    glad_glCopyTexSubImage3DEXT = (PFNGLCOPYTEXSUBIMAGE3DEXTPROC) load(userptr, "glCopyTexSubImage3DEXT");
}
static void glad_gl_load_GL_EXT_cull_vertex( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_cull_vertex) return;
    glad_glCullParameterdvEXT = (PFNGLCULLPARAMETERDVEXTPROC) load(userptr, "glCullParameterdvEXT");
    glad_glCullParameterfvEXT = (PFNGLCULLPARAMETERFVEXTPROC) load(userptr, "glCullParameterfvEXT");
}
static void glad_gl_load_GL_EXT_debug_label( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_debug_label) return;
    glad_glGetObjectLabelEXT = (PFNGLGETOBJECTLABELEXTPROC) load(userptr, "glGetObjectLabelEXT");
    glad_glLabelObjectEXT = (PFNGLLABELOBJECTEXTPROC) load(userptr, "glLabelObjectEXT");
}
static void glad_gl_load_GL_EXT_debug_marker( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_debug_marker) return;
    glad_glInsertEventMarkerEXT = (PFNGLINSERTEVENTMARKEREXTPROC) load(userptr, "glInsertEventMarkerEXT");
    glad_glPopGroupMarkerEXT = (PFNGLPOPGROUPMARKEREXTPROC) load(userptr, "glPopGroupMarkerEXT");
    glad_glPushGroupMarkerEXT = (PFNGLPUSHGROUPMARKEREXTPROC) load(userptr, "glPushGroupMarkerEXT");
}
static void glad_gl_load_GL_EXT_depth_bounds_test( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_depth_bounds_test) return;
    glad_glDepthBoundsEXT = (PFNGLDEPTHBOUNDSEXTPROC) load(userptr, "glDepthBoundsEXT");
}
static void glad_gl_load_GL_EXT_direct_state_access( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_direct_state_access) return;
    glad_glBindMultiTextureEXT = (PFNGLBINDMULTITEXTUREEXTPROC) load(userptr, "glBindMultiTextureEXT");
    glad_glCheckNamedFramebufferStatusEXT = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) load(userptr, "glCheckNamedFramebufferStatusEXT");
    glad_glClearNamedBufferDataEXT = (PFNGLCLEARNAMEDBUFFERDATAEXTPROC) load(userptr, "glClearNamedBufferDataEXT");
    glad_glClearNamedBufferSubDataEXT = (PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) load(userptr, "glClearNamedBufferSubDataEXT");
    glad_glClientAttribDefaultEXT = (PFNGLCLIENTATTRIBDEFAULTEXTPROC) load(userptr, "glClientAttribDefaultEXT");
    glad_glCompressedMultiTexImage1DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) load(userptr, "glCompressedMultiTexImage1DEXT");
    glad_glCompressedMultiTexImage2DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) load(userptr, "glCompressedMultiTexImage2DEXT");
    glad_glCompressedMultiTexImage3DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) load(userptr, "glCompressedMultiTexImage3DEXT");
    glad_glCompressedMultiTexSubImage1DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) load(userptr, "glCompressedMultiTexSubImage1DEXT");
    glad_glCompressedMultiTexSubImage2DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) load(userptr, "glCompressedMultiTexSubImage2DEXT");
    glad_glCompressedMultiTexSubImage3DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) load(userptr, "glCompressedMultiTexSubImage3DEXT");
    glad_glCompressedTextureImage1DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) load(userptr, "glCompressedTextureImage1DEXT");
    glad_glCompressedTextureImage2DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) load(userptr, "glCompressedTextureImage2DEXT");
    glad_glCompressedTextureImage3DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) load(userptr, "glCompressedTextureImage3DEXT");
    glad_glCompressedTextureSubImage1DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) load(userptr, "glCompressedTextureSubImage1DEXT");
    glad_glCompressedTextureSubImage2DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) load(userptr, "glCompressedTextureSubImage2DEXT");
    glad_glCompressedTextureSubImage3DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) load(userptr, "glCompressedTextureSubImage3DEXT");
    glad_glCopyMultiTexImage1DEXT = (PFNGLCOPYMULTITEXIMAGE1DEXTPROC) load(userptr, "glCopyMultiTexImage1DEXT");
    glad_glCopyMultiTexImage2DEXT = (PFNGLCOPYMULTITEXIMAGE2DEXTPROC) load(userptr, "glCopyMultiTexImage2DEXT");
    glad_glCopyMultiTexSubImage1DEXT = (PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) load(userptr, "glCopyMultiTexSubImage1DEXT");
    glad_glCopyMultiTexSubImage2DEXT = (PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) load(userptr, "glCopyMultiTexSubImage2DEXT");
    glad_glCopyMultiTexSubImage3DEXT = (PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) load(userptr, "glCopyMultiTexSubImage3DEXT");
    glad_glCopyTextureImage1DEXT = (PFNGLCOPYTEXTUREIMAGE1DEXTPROC) load(userptr, "glCopyTextureImage1DEXT");
    glad_glCopyTextureImage2DEXT = (PFNGLCOPYTEXTUREIMAGE2DEXTPROC) load(userptr, "glCopyTextureImage2DEXT");
    glad_glCopyTextureSubImage1DEXT = (PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) load(userptr, "glCopyTextureSubImage1DEXT");
    glad_glCopyTextureSubImage2DEXT = (PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) load(userptr, "glCopyTextureSubImage2DEXT");
    glad_glCopyTextureSubImage3DEXT = (PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) load(userptr, "glCopyTextureSubImage3DEXT");
    glad_glDisableClientStateIndexedEXT = (PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) load(userptr, "glDisableClientStateIndexedEXT");
    glad_glDisableClientStateiEXT = (PFNGLDISABLECLIENTSTATEIEXTPROC) load(userptr, "glDisableClientStateiEXT");
    glad_glDisableIndexedEXT = (PFNGLDISABLEINDEXEDEXTPROC) load(userptr, "glDisableIndexedEXT");
    glad_glDisableVertexArrayAttribEXT = (PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) load(userptr, "glDisableVertexArrayAttribEXT");
    glad_glDisableVertexArrayEXT = (PFNGLDISABLEVERTEXARRAYEXTPROC) load(userptr, "glDisableVertexArrayEXT");
    glad_glDisablei = (PFNGLDISABLEIPROC) load(userptr, "glDisablei");
    glad_glEnableClientStateIndexedEXT = (PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) load(userptr, "glEnableClientStateIndexedEXT");
    glad_glEnableClientStateiEXT = (PFNGLENABLECLIENTSTATEIEXTPROC) load(userptr, "glEnableClientStateiEXT");
    glad_glEnableIndexedEXT = (PFNGLENABLEINDEXEDEXTPROC) load(userptr, "glEnableIndexedEXT");
    glad_glEnableVertexArrayAttribEXT = (PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) load(userptr, "glEnableVertexArrayAttribEXT");
    glad_glEnableVertexArrayEXT = (PFNGLENABLEVERTEXARRAYEXTPROC) load(userptr, "glEnableVertexArrayEXT");
    glad_glEnablei = (PFNGLENABLEIPROC) load(userptr, "glEnablei");
    glad_glFlushMappedNamedBufferRangeEXT = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) load(userptr, "glFlushMappedNamedBufferRangeEXT");
    glad_glFramebufferDrawBufferEXT = (PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) load(userptr, "glFramebufferDrawBufferEXT");
    glad_glFramebufferDrawBuffersEXT = (PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) load(userptr, "glFramebufferDrawBuffersEXT");
    glad_glFramebufferReadBufferEXT = (PFNGLFRAMEBUFFERREADBUFFEREXTPROC) load(userptr, "glFramebufferReadBufferEXT");
    glad_glGenerateMultiTexMipmapEXT = (PFNGLGENERATEMULTITEXMIPMAPEXTPROC) load(userptr, "glGenerateMultiTexMipmapEXT");
    glad_glGenerateTextureMipmapEXT = (PFNGLGENERATETEXTUREMIPMAPEXTPROC) load(userptr, "glGenerateTextureMipmapEXT");
    glad_glGetBooleanIndexedvEXT = (PFNGLGETBOOLEANINDEXEDVEXTPROC) load(userptr, "glGetBooleanIndexedvEXT");
    glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC) load(userptr, "glGetBooleani_v");
    glad_glGetCompressedMultiTexImageEXT = (PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) load(userptr, "glGetCompressedMultiTexImageEXT");
    glad_glGetCompressedTextureImageEXT = (PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) load(userptr, "glGetCompressedTextureImageEXT");
    glad_glGetDoubleIndexedvEXT = (PFNGLGETDOUBLEINDEXEDVEXTPROC) load(userptr, "glGetDoubleIndexedvEXT");
    glad_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC) load(userptr, "glGetDoublei_v");
    glad_glGetDoublei_vEXT = (PFNGLGETDOUBLEI_VEXTPROC) load(userptr, "glGetDoublei_vEXT");
    glad_glGetFloatIndexedvEXT = (PFNGLGETFLOATINDEXEDVEXTPROC) load(userptr, "glGetFloatIndexedvEXT");
    glad_glGetFloati_v = (PFNGLGETFLOATI_VPROC) load(userptr, "glGetFloati_v");
    glad_glGetFloati_vEXT = (PFNGLGETFLOATI_VEXTPROC) load(userptr, "glGetFloati_vEXT");
    glad_glGetFramebufferParameterivEXT = (PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) load(userptr, "glGetFramebufferParameterivEXT");
    glad_glGetIntegerIndexedvEXT = (PFNGLGETINTEGERINDEXEDVEXTPROC) load(userptr, "glGetIntegerIndexedvEXT");
    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
    glad_glGetMultiTexEnvfvEXT = (PFNGLGETMULTITEXENVFVEXTPROC) load(userptr, "glGetMultiTexEnvfvEXT");
    glad_glGetMultiTexEnvivEXT = (PFNGLGETMULTITEXENVIVEXTPROC) load(userptr, "glGetMultiTexEnvivEXT");
    glad_glGetMultiTexGendvEXT = (PFNGLGETMULTITEXGENDVEXTPROC) load(userptr, "glGetMultiTexGendvEXT");
    glad_glGetMultiTexGenfvEXT = (PFNGLGETMULTITEXGENFVEXTPROC) load(userptr, "glGetMultiTexGenfvEXT");
    glad_glGetMultiTexGenivEXT = (PFNGLGETMULTITEXGENIVEXTPROC) load(userptr, "glGetMultiTexGenivEXT");
    glad_glGetMultiTexImageEXT = (PFNGLGETMULTITEXIMAGEEXTPROC) load(userptr, "glGetMultiTexImageEXT");
    glad_glGetMultiTexLevelParameterfvEXT = (PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) load(userptr, "glGetMultiTexLevelParameterfvEXT");
    glad_glGetMultiTexLevelParameterivEXT = (PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) load(userptr, "glGetMultiTexLevelParameterivEXT");
    glad_glGetMultiTexParameterIivEXT = (PFNGLGETMULTITEXPARAMETERIIVEXTPROC) load(userptr, "glGetMultiTexParameterIivEXT");
    glad_glGetMultiTexParameterIuivEXT = (PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) load(userptr, "glGetMultiTexParameterIuivEXT");
    glad_glGetMultiTexParameterfvEXT = (PFNGLGETMULTITEXPARAMETERFVEXTPROC) load(userptr, "glGetMultiTexParameterfvEXT");
    glad_glGetMultiTexParameterivEXT = (PFNGLGETMULTITEXPARAMETERIVEXTPROC) load(userptr, "glGetMultiTexParameterivEXT");
    glad_glGetNamedBufferParameterivEXT = (PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) load(userptr, "glGetNamedBufferParameterivEXT");
    glad_glGetNamedBufferPointervEXT = (PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) load(userptr, "glGetNamedBufferPointervEXT");
    glad_glGetNamedBufferSubDataEXT = (PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) load(userptr, "glGetNamedBufferSubDataEXT");
    glad_glGetNamedFramebufferAttachmentParameterivEXT = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) load(userptr, "glGetNamedFramebufferAttachmentParameterivEXT");
    glad_glGetNamedFramebufferParameterivEXT = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) load(userptr, "glGetNamedFramebufferParameterivEXT");
    glad_glGetNamedProgramLocalParameterIivEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) load(userptr, "glGetNamedProgramLocalParameterIivEXT");
    glad_glGetNamedProgramLocalParameterIuivEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) load(userptr, "glGetNamedProgramLocalParameterIuivEXT");
    glad_glGetNamedProgramLocalParameterdvEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) load(userptr, "glGetNamedProgramLocalParameterdvEXT");
    glad_glGetNamedProgramLocalParameterfvEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) load(userptr, "glGetNamedProgramLocalParameterfvEXT");
    glad_glGetNamedProgramStringEXT = (PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) load(userptr, "glGetNamedProgramStringEXT");
    glad_glGetNamedProgramivEXT = (PFNGLGETNAMEDPROGRAMIVEXTPROC) load(userptr, "glGetNamedProgramivEXT");
    glad_glGetNamedRenderbufferParameterivEXT = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) load(userptr, "glGetNamedRenderbufferParameterivEXT");
    glad_glGetPointerIndexedvEXT = (PFNGLGETPOINTERINDEXEDVEXTPROC) load(userptr, "glGetPointerIndexedvEXT");
    glad_glGetPointeri_vEXT = (PFNGLGETPOINTERI_VEXTPROC) load(userptr, "glGetPointeri_vEXT");
    glad_glGetTextureImageEXT = (PFNGLGETTEXTUREIMAGEEXTPROC) load(userptr, "glGetTextureImageEXT");
    glad_glGetTextureLevelParameterfvEXT = (PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) load(userptr, "glGetTextureLevelParameterfvEXT");
    glad_glGetTextureLevelParameterivEXT = (PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) load(userptr, "glGetTextureLevelParameterivEXT");
    glad_glGetTextureParameterIivEXT = (PFNGLGETTEXTUREPARAMETERIIVEXTPROC) load(userptr, "glGetTextureParameterIivEXT");
    glad_glGetTextureParameterIuivEXT = (PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) load(userptr, "glGetTextureParameterIuivEXT");
    glad_glGetTextureParameterfvEXT = (PFNGLGETTEXTUREPARAMETERFVEXTPROC) load(userptr, "glGetTextureParameterfvEXT");
    glad_glGetTextureParameterivEXT = (PFNGLGETTEXTUREPARAMETERIVEXTPROC) load(userptr, "glGetTextureParameterivEXT");
    glad_glGetVertexArrayIntegeri_vEXT = (PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) load(userptr, "glGetVertexArrayIntegeri_vEXT");
    glad_glGetVertexArrayIntegervEXT = (PFNGLGETVERTEXARRAYINTEGERVEXTPROC) load(userptr, "glGetVertexArrayIntegervEXT");
    glad_glGetVertexArrayPointeri_vEXT = (PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) load(userptr, "glGetVertexArrayPointeri_vEXT");
    glad_glGetVertexArrayPointervEXT = (PFNGLGETVERTEXARRAYPOINTERVEXTPROC) load(userptr, "glGetVertexArrayPointervEXT");
    glad_glIsEnabledIndexedEXT = (PFNGLISENABLEDINDEXEDEXTPROC) load(userptr, "glIsEnabledIndexedEXT");
    glad_glIsEnabledi = (PFNGLISENABLEDIPROC) load(userptr, "glIsEnabledi");
    glad_glMapNamedBufferEXT = (PFNGLMAPNAMEDBUFFEREXTPROC) load(userptr, "glMapNamedBufferEXT");
    glad_glMapNamedBufferRangeEXT = (PFNGLMAPNAMEDBUFFERRANGEEXTPROC) load(userptr, "glMapNamedBufferRangeEXT");
    glad_glMatrixFrustumEXT = (PFNGLMATRIXFRUSTUMEXTPROC) load(userptr, "glMatrixFrustumEXT");
    glad_glMatrixLoadIdentityEXT = (PFNGLMATRIXLOADIDENTITYEXTPROC) load(userptr, "glMatrixLoadIdentityEXT");
    glad_glMatrixLoadTransposedEXT = (PFNGLMATRIXLOADTRANSPOSEDEXTPROC) load(userptr, "glMatrixLoadTransposedEXT");
    glad_glMatrixLoadTransposefEXT = (PFNGLMATRIXLOADTRANSPOSEFEXTPROC) load(userptr, "glMatrixLoadTransposefEXT");
    glad_glMatrixLoaddEXT = (PFNGLMATRIXLOADDEXTPROC) load(userptr, "glMatrixLoaddEXT");
    glad_glMatrixLoadfEXT = (PFNGLMATRIXLOADFEXTPROC) load(userptr, "glMatrixLoadfEXT");
    glad_glMatrixMultTransposedEXT = (PFNGLMATRIXMULTTRANSPOSEDEXTPROC) load(userptr, "glMatrixMultTransposedEXT");
    glad_glMatrixMultTransposefEXT = (PFNGLMATRIXMULTTRANSPOSEFEXTPROC) load(userptr, "glMatrixMultTransposefEXT");
    glad_glMatrixMultdEXT = (PFNGLMATRIXMULTDEXTPROC) load(userptr, "glMatrixMultdEXT");
    glad_glMatrixMultfEXT = (PFNGLMATRIXMULTFEXTPROC) load(userptr, "glMatrixMultfEXT");
    glad_glMatrixOrthoEXT = (PFNGLMATRIXORTHOEXTPROC) load(userptr, "glMatrixOrthoEXT");
    glad_glMatrixPopEXT = (PFNGLMATRIXPOPEXTPROC) load(userptr, "glMatrixPopEXT");
    glad_glMatrixPushEXT = (PFNGLMATRIXPUSHEXTPROC) load(userptr, "glMatrixPushEXT");
    glad_glMatrixRotatedEXT = (PFNGLMATRIXROTATEDEXTPROC) load(userptr, "glMatrixRotatedEXT");
    glad_glMatrixRotatefEXT = (PFNGLMATRIXROTATEFEXTPROC) load(userptr, "glMatrixRotatefEXT");
    glad_glMatrixScaledEXT = (PFNGLMATRIXSCALEDEXTPROC) load(userptr, "glMatrixScaledEXT");
    glad_glMatrixScalefEXT = (PFNGLMATRIXSCALEFEXTPROC) load(userptr, "glMatrixScalefEXT");
    glad_glMatrixTranslatedEXT = (PFNGLMATRIXTRANSLATEDEXTPROC) load(userptr, "glMatrixTranslatedEXT");
    glad_glMatrixTranslatefEXT = (PFNGLMATRIXTRANSLATEFEXTPROC) load(userptr, "glMatrixTranslatefEXT");
    glad_glMultiTexBufferEXT = (PFNGLMULTITEXBUFFEREXTPROC) load(userptr, "glMultiTexBufferEXT");
    glad_glMultiTexCoordPointerEXT = (PFNGLMULTITEXCOORDPOINTEREXTPROC) load(userptr, "glMultiTexCoordPointerEXT");
    glad_glMultiTexEnvfEXT = (PFNGLMULTITEXENVFEXTPROC) load(userptr, "glMultiTexEnvfEXT");
    glad_glMultiTexEnvfvEXT = (PFNGLMULTITEXENVFVEXTPROC) load(userptr, "glMultiTexEnvfvEXT");
    glad_glMultiTexEnviEXT = (PFNGLMULTITEXENVIEXTPROC) load(userptr, "glMultiTexEnviEXT");
    glad_glMultiTexEnvivEXT = (PFNGLMULTITEXENVIVEXTPROC) load(userptr, "glMultiTexEnvivEXT");
    glad_glMultiTexGendEXT = (PFNGLMULTITEXGENDEXTPROC) load(userptr, "glMultiTexGendEXT");
    glad_glMultiTexGendvEXT = (PFNGLMULTITEXGENDVEXTPROC) load(userptr, "glMultiTexGendvEXT");
    glad_glMultiTexGenfEXT = (PFNGLMULTITEXGENFEXTPROC) load(userptr, "glMultiTexGenfEXT");
    glad_glMultiTexGenfvEXT = (PFNGLMULTITEXGENFVEXTPROC) load(userptr, "glMultiTexGenfvEXT");
    glad_glMultiTexGeniEXT = (PFNGLMULTITEXGENIEXTPROC) load(userptr, "glMultiTexGeniEXT");
    glad_glMultiTexGenivEXT = (PFNGLMULTITEXGENIVEXTPROC) load(userptr, "glMultiTexGenivEXT");
    glad_glMultiTexImage1DEXT = (PFNGLMULTITEXIMAGE1DEXTPROC) load(userptr, "glMultiTexImage1DEXT");
    glad_glMultiTexImage2DEXT = (PFNGLMULTITEXIMAGE2DEXTPROC) load(userptr, "glMultiTexImage2DEXT");
    glad_glMultiTexImage3DEXT = (PFNGLMULTITEXIMAGE3DEXTPROC) load(userptr, "glMultiTexImage3DEXT");
    glad_glMultiTexParameterIivEXT = (PFNGLMULTITEXPARAMETERIIVEXTPROC) load(userptr, "glMultiTexParameterIivEXT");
    glad_glMultiTexParameterIuivEXT = (PFNGLMULTITEXPARAMETERIUIVEXTPROC) load(userptr, "glMultiTexParameterIuivEXT");
    glad_glMultiTexParameterfEXT = (PFNGLMULTITEXPARAMETERFEXTPROC) load(userptr, "glMultiTexParameterfEXT");
    glad_glMultiTexParameterfvEXT = (PFNGLMULTITEXPARAMETERFVEXTPROC) load(userptr, "glMultiTexParameterfvEXT");
    glad_glMultiTexParameteriEXT = (PFNGLMULTITEXPARAMETERIEXTPROC) load(userptr, "glMultiTexParameteriEXT");
    glad_glMultiTexParameterivEXT = (PFNGLMULTITEXPARAMETERIVEXTPROC) load(userptr, "glMultiTexParameterivEXT");
    glad_glMultiTexRenderbufferEXT = (PFNGLMULTITEXRENDERBUFFEREXTPROC) load(userptr, "glMultiTexRenderbufferEXT");
    glad_glMultiTexSubImage1DEXT = (PFNGLMULTITEXSUBIMAGE1DEXTPROC) load(userptr, "glMultiTexSubImage1DEXT");
    glad_glMultiTexSubImage2DEXT = (PFNGLMULTITEXSUBIMAGE2DEXTPROC) load(userptr, "glMultiTexSubImage2DEXT");
    glad_glMultiTexSubImage3DEXT = (PFNGLMULTITEXSUBIMAGE3DEXTPROC) load(userptr, "glMultiTexSubImage3DEXT");
    glad_glNamedBufferDataEXT = (PFNGLNAMEDBUFFERDATAEXTPROC) load(userptr, "glNamedBufferDataEXT");
    glad_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC) load(userptr, "glNamedBufferStorage");
    glad_glNamedBufferStorageEXT = (PFNGLNAMEDBUFFERSTORAGEEXTPROC) load(userptr, "glNamedBufferStorageEXT");
    glad_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC) load(userptr, "glNamedBufferSubData");
    glad_glNamedBufferSubDataEXT = (PFNGLNAMEDBUFFERSUBDATAEXTPROC) load(userptr, "glNamedBufferSubDataEXT");
    glad_glNamedCopyBufferSubDataEXT = (PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) load(userptr, "glNamedCopyBufferSubDataEXT");
    glad_glNamedFramebufferParameteriEXT = (PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) load(userptr, "glNamedFramebufferParameteriEXT");
    glad_glNamedFramebufferRenderbufferEXT = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) load(userptr, "glNamedFramebufferRenderbufferEXT");
    glad_glNamedFramebufferTexture1DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) load(userptr, "glNamedFramebufferTexture1DEXT");
    glad_glNamedFramebufferTexture2DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) load(userptr, "glNamedFramebufferTexture2DEXT");
    glad_glNamedFramebufferTexture3DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) load(userptr, "glNamedFramebufferTexture3DEXT");
    glad_glNamedFramebufferTextureEXT = (PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) load(userptr, "glNamedFramebufferTextureEXT");
    glad_glNamedFramebufferTextureFaceEXT = (PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) load(userptr, "glNamedFramebufferTextureFaceEXT");
    glad_glNamedFramebufferTextureLayerEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) load(userptr, "glNamedFramebufferTextureLayerEXT");
    glad_glNamedProgramLocalParameter4dEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) load(userptr, "glNamedProgramLocalParameter4dEXT");
    glad_glNamedProgramLocalParameter4dvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) load(userptr, "glNamedProgramLocalParameter4dvEXT");
    glad_glNamedProgramLocalParameter4fEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) load(userptr, "glNamedProgramLocalParameter4fEXT");
    glad_glNamedProgramLocalParameter4fvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) load(userptr, "glNamedProgramLocalParameter4fvEXT");
    glad_glNamedProgramLocalParameterI4iEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) load(userptr, "glNamedProgramLocalParameterI4iEXT");
    glad_glNamedProgramLocalParameterI4ivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) load(userptr, "glNamedProgramLocalParameterI4ivEXT");
    glad_glNamedProgramLocalParameterI4uiEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) load(userptr, "glNamedProgramLocalParameterI4uiEXT");
    glad_glNamedProgramLocalParameterI4uivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) load(userptr, "glNamedProgramLocalParameterI4uivEXT");
    glad_glNamedProgramLocalParameters4fvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) load(userptr, "glNamedProgramLocalParameters4fvEXT");
    glad_glNamedProgramLocalParametersI4ivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) load(userptr, "glNamedProgramLocalParametersI4ivEXT");
    glad_glNamedProgramLocalParametersI4uivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) load(userptr, "glNamedProgramLocalParametersI4uivEXT");
    glad_glNamedProgramStringEXT = (PFNGLNAMEDPROGRAMSTRINGEXTPROC) load(userptr, "glNamedProgramStringEXT");
    glad_glNamedRenderbufferStorageEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) load(userptr, "glNamedRenderbufferStorageEXT");
    glad_glNamedRenderbufferStorageMultisampleCoverageEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) load(userptr, "glNamedRenderbufferStorageMultisampleCoverageEXT");
    glad_glNamedRenderbufferStorageMultisampleEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) load(userptr, "glNamedRenderbufferStorageMultisampleEXT");
    glad_glProgramUniform1dEXT = (PFNGLPROGRAMUNIFORM1DEXTPROC) load(userptr, "glProgramUniform1dEXT");
    glad_glProgramUniform1dvEXT = (PFNGLPROGRAMUNIFORM1DVEXTPROC) load(userptr, "glProgramUniform1dvEXT");
    glad_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC) load(userptr, "glProgramUniform1f");
    glad_glProgramUniform1fEXT = (PFNGLPROGRAMUNIFORM1FEXTPROC) load(userptr, "glProgramUniform1fEXT");
    glad_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC) load(userptr, "glProgramUniform1fv");
    glad_glProgramUniform1fvEXT = (PFNGLPROGRAMUNIFORM1FVEXTPROC) load(userptr, "glProgramUniform1fvEXT");
    glad_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC) load(userptr, "glProgramUniform1i");
    glad_glProgramUniform1iEXT = (PFNGLPROGRAMUNIFORM1IEXTPROC) load(userptr, "glProgramUniform1iEXT");
    glad_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC) load(userptr, "glProgramUniform1iv");
    glad_glProgramUniform1ivEXT = (PFNGLPROGRAMUNIFORM1IVEXTPROC) load(userptr, "glProgramUniform1ivEXT");
    glad_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC) load(userptr, "glProgramUniform1ui");
    glad_glProgramUniform1uiEXT = (PFNGLPROGRAMUNIFORM1UIEXTPROC) load(userptr, "glProgramUniform1uiEXT");
    glad_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC) load(userptr, "glProgramUniform1uiv");
    glad_glProgramUniform1uivEXT = (PFNGLPROGRAMUNIFORM1UIVEXTPROC) load(userptr, "glProgramUniform1uivEXT");
    glad_glProgramUniform2dEXT = (PFNGLPROGRAMUNIFORM2DEXTPROC) load(userptr, "glProgramUniform2dEXT");
    glad_glProgramUniform2dvEXT = (PFNGLPROGRAMUNIFORM2DVEXTPROC) load(userptr, "glProgramUniform2dvEXT");
    glad_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC) load(userptr, "glProgramUniform2f");
    glad_glProgramUniform2fEXT = (PFNGLPROGRAMUNIFORM2FEXTPROC) load(userptr, "glProgramUniform2fEXT");
    glad_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC) load(userptr, "glProgramUniform2fv");
    glad_glProgramUniform2fvEXT = (PFNGLPROGRAMUNIFORM2FVEXTPROC) load(userptr, "glProgramUniform2fvEXT");
    glad_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC) load(userptr, "glProgramUniform2i");
    glad_glProgramUniform2iEXT = (PFNGLPROGRAMUNIFORM2IEXTPROC) load(userptr, "glProgramUniform2iEXT");
    glad_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC) load(userptr, "glProgramUniform2iv");
    glad_glProgramUniform2ivEXT = (PFNGLPROGRAMUNIFORM2IVEXTPROC) load(userptr, "glProgramUniform2ivEXT");
    glad_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC) load(userptr, "glProgramUniform2ui");
    glad_glProgramUniform2uiEXT = (PFNGLPROGRAMUNIFORM2UIEXTPROC) load(userptr, "glProgramUniform2uiEXT");
    glad_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC) load(userptr, "glProgramUniform2uiv");
    glad_glProgramUniform2uivEXT = (PFNGLPROGRAMUNIFORM2UIVEXTPROC) load(userptr, "glProgramUniform2uivEXT");
    glad_glProgramUniform3dEXT = (PFNGLPROGRAMUNIFORM3DEXTPROC) load(userptr, "glProgramUniform3dEXT");
    glad_glProgramUniform3dvEXT = (PFNGLPROGRAMUNIFORM3DVEXTPROC) load(userptr, "glProgramUniform3dvEXT");
    glad_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC) load(userptr, "glProgramUniform3f");
    glad_glProgramUniform3fEXT = (PFNGLPROGRAMUNIFORM3FEXTPROC) load(userptr, "glProgramUniform3fEXT");
    glad_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC) load(userptr, "glProgramUniform3fv");
    glad_glProgramUniform3fvEXT = (PFNGLPROGRAMUNIFORM3FVEXTPROC) load(userptr, "glProgramUniform3fvEXT");
    glad_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC) load(userptr, "glProgramUniform3i");
    glad_glProgramUniform3iEXT = (PFNGLPROGRAMUNIFORM3IEXTPROC) load(userptr, "glProgramUniform3iEXT");
    glad_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC) load(userptr, "glProgramUniform3iv");
    glad_glProgramUniform3ivEXT = (PFNGLPROGRAMUNIFORM3IVEXTPROC) load(userptr, "glProgramUniform3ivEXT");
    glad_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC) load(userptr, "glProgramUniform3ui");
    glad_glProgramUniform3uiEXT = (PFNGLPROGRAMUNIFORM3UIEXTPROC) load(userptr, "glProgramUniform3uiEXT");
    glad_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC) load(userptr, "glProgramUniform3uiv");
    glad_glProgramUniform3uivEXT = (PFNGLPROGRAMUNIFORM3UIVEXTPROC) load(userptr, "glProgramUniform3uivEXT");
    glad_glProgramUniform4dEXT = (PFNGLPROGRAMUNIFORM4DEXTPROC) load(userptr, "glProgramUniform4dEXT");
    glad_glProgramUniform4dvEXT = (PFNGLPROGRAMUNIFORM4DVEXTPROC) load(userptr, "glProgramUniform4dvEXT");
    glad_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC) load(userptr, "glProgramUniform4f");
    glad_glProgramUniform4fEXT = (PFNGLPROGRAMUNIFORM4FEXTPROC) load(userptr, "glProgramUniform4fEXT");
    glad_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC) load(userptr, "glProgramUniform4fv");
    glad_glProgramUniform4fvEXT = (PFNGLPROGRAMUNIFORM4FVEXTPROC) load(userptr, "glProgramUniform4fvEXT");
    glad_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC) load(userptr, "glProgramUniform4i");
    glad_glProgramUniform4iEXT = (PFNGLPROGRAMUNIFORM4IEXTPROC) load(userptr, "glProgramUniform4iEXT");
    glad_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC) load(userptr, "glProgramUniform4iv");
    glad_glProgramUniform4ivEXT = (PFNGLPROGRAMUNIFORM4IVEXTPROC) load(userptr, "glProgramUniform4ivEXT");
    glad_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC) load(userptr, "glProgramUniform4ui");
    glad_glProgramUniform4uiEXT = (PFNGLPROGRAMUNIFORM4UIEXTPROC) load(userptr, "glProgramUniform4uiEXT");
    glad_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC) load(userptr, "glProgramUniform4uiv");
    glad_glProgramUniform4uivEXT = (PFNGLPROGRAMUNIFORM4UIVEXTPROC) load(userptr, "glProgramUniform4uivEXT");
    glad_glProgramUniformMatrix2dvEXT = (PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC) load(userptr, "glProgramUniformMatrix2dvEXT");
    glad_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC) load(userptr, "glProgramUniformMatrix2fv");
    glad_glProgramUniformMatrix2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) load(userptr, "glProgramUniformMatrix2fvEXT");
    glad_glProgramUniformMatrix2x3dvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC) load(userptr, "glProgramUniformMatrix2x3dvEXT");
    glad_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) load(userptr, "glProgramUniformMatrix2x3fv");
    glad_glProgramUniformMatrix2x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) load(userptr, "glProgramUniformMatrix2x3fvEXT");
    glad_glProgramUniformMatrix2x4dvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC) load(userptr, "glProgramUniformMatrix2x4dvEXT");
    glad_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) load(userptr, "glProgramUniformMatrix2x4fv");
    glad_glProgramUniformMatrix2x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) load(userptr, "glProgramUniformMatrix2x4fvEXT");
    glad_glProgramUniformMatrix3dvEXT = (PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC) load(userptr, "glProgramUniformMatrix3dvEXT");
    glad_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC) load(userptr, "glProgramUniformMatrix3fv");
    glad_glProgramUniformMatrix3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) load(userptr, "glProgramUniformMatrix3fvEXT");
    glad_glProgramUniformMatrix3x2dvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC) load(userptr, "glProgramUniformMatrix3x2dvEXT");
    glad_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) load(userptr, "glProgramUniformMatrix3x2fv");
    glad_glProgramUniformMatrix3x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) load(userptr, "glProgramUniformMatrix3x2fvEXT");
    glad_glProgramUniformMatrix3x4dvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC) load(userptr, "glProgramUniformMatrix3x4dvEXT");
    glad_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) load(userptr, "glProgramUniformMatrix3x4fv");
    glad_glProgramUniformMatrix3x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) load(userptr, "glProgramUniformMatrix3x4fvEXT");
    glad_glProgramUniformMatrix4dvEXT = (PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC) load(userptr, "glProgramUniformMatrix4dvEXT");
    glad_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC) load(userptr, "glProgramUniformMatrix4fv");
    glad_glProgramUniformMatrix4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) load(userptr, "glProgramUniformMatrix4fvEXT");
    glad_glProgramUniformMatrix4x2dvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC) load(userptr, "glProgramUniformMatrix4x2dvEXT");
    glad_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) load(userptr, "glProgramUniformMatrix4x2fv");
    glad_glProgramUniformMatrix4x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) load(userptr, "glProgramUniformMatrix4x2fvEXT");
    glad_glProgramUniformMatrix4x3dvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC) load(userptr, "glProgramUniformMatrix4x3dvEXT");
    glad_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) load(userptr, "glProgramUniformMatrix4x3fv");
    glad_glProgramUniformMatrix4x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) load(userptr, "glProgramUniformMatrix4x3fvEXT");
    glad_glPushClientAttribDefaultEXT = (PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) load(userptr, "glPushClientAttribDefaultEXT");
    glad_glTextureBufferEXT = (PFNGLTEXTUREBUFFEREXTPROC) load(userptr, "glTextureBufferEXT");
    glad_glTextureBufferRangeEXT = (PFNGLTEXTUREBUFFERRANGEEXTPROC) load(userptr, "glTextureBufferRangeEXT");
    glad_glTextureImage1DEXT = (PFNGLTEXTUREIMAGE1DEXTPROC) load(userptr, "glTextureImage1DEXT");
    glad_glTextureImage2DEXT = (PFNGLTEXTUREIMAGE2DEXTPROC) load(userptr, "glTextureImage2DEXT");
    glad_glTextureImage3DEXT = (PFNGLTEXTUREIMAGE3DEXTPROC) load(userptr, "glTextureImage3DEXT");
    glad_glTexturePageCommitmentEXT = (PFNGLTEXTUREPAGECOMMITMENTEXTPROC) load(userptr, "glTexturePageCommitmentEXT");
    glad_glTextureParameterIivEXT = (PFNGLTEXTUREPARAMETERIIVEXTPROC) load(userptr, "glTextureParameterIivEXT");
    glad_glTextureParameterIuivEXT = (PFNGLTEXTUREPARAMETERIUIVEXTPROC) load(userptr, "glTextureParameterIuivEXT");
    glad_glTextureParameterfEXT = (PFNGLTEXTUREPARAMETERFEXTPROC) load(userptr, "glTextureParameterfEXT");
    glad_glTextureParameterfvEXT = (PFNGLTEXTUREPARAMETERFVEXTPROC) load(userptr, "glTextureParameterfvEXT");
    glad_glTextureParameteriEXT = (PFNGLTEXTUREPARAMETERIEXTPROC) load(userptr, "glTextureParameteriEXT");
    glad_glTextureParameterivEXT = (PFNGLTEXTUREPARAMETERIVEXTPROC) load(userptr, "glTextureParameterivEXT");
    glad_glTextureRenderbufferEXT = (PFNGLTEXTURERENDERBUFFEREXTPROC) load(userptr, "glTextureRenderbufferEXT");
    glad_glTextureStorage1DEXT = (PFNGLTEXTURESTORAGE1DEXTPROC) load(userptr, "glTextureStorage1DEXT");
    glad_glTextureStorage2DEXT = (PFNGLTEXTURESTORAGE2DEXTPROC) load(userptr, "glTextureStorage2DEXT");
    glad_glTextureStorage2DMultisampleEXT = (PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) load(userptr, "glTextureStorage2DMultisampleEXT");
    glad_glTextureStorage3DEXT = (PFNGLTEXTURESTORAGE3DEXTPROC) load(userptr, "glTextureStorage3DEXT");
    glad_glTextureStorage3DMultisampleEXT = (PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) load(userptr, "glTextureStorage3DMultisampleEXT");
    glad_glTextureSubImage1DEXT = (PFNGLTEXTURESUBIMAGE1DEXTPROC) load(userptr, "glTextureSubImage1DEXT");
    glad_glTextureSubImage2DEXT = (PFNGLTEXTURESUBIMAGE2DEXTPROC) load(userptr, "glTextureSubImage2DEXT");
    glad_glTextureSubImage3DEXT = (PFNGLTEXTURESUBIMAGE3DEXTPROC) load(userptr, "glTextureSubImage3DEXT");
    glad_glUnmapNamedBufferEXT = (PFNGLUNMAPNAMEDBUFFEREXTPROC) load(userptr, "glUnmapNamedBufferEXT");
    glad_glVertexArrayBindVertexBufferEXT = (PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) load(userptr, "glVertexArrayBindVertexBufferEXT");
    glad_glVertexArrayColorOffsetEXT = (PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) load(userptr, "glVertexArrayColorOffsetEXT");
    glad_glVertexArrayEdgeFlagOffsetEXT = (PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) load(userptr, "glVertexArrayEdgeFlagOffsetEXT");
    glad_glVertexArrayFogCoordOffsetEXT = (PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) load(userptr, "glVertexArrayFogCoordOffsetEXT");
    glad_glVertexArrayIndexOffsetEXT = (PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) load(userptr, "glVertexArrayIndexOffsetEXT");
    glad_glVertexArrayMultiTexCoordOffsetEXT = (PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) load(userptr, "glVertexArrayMultiTexCoordOffsetEXT");
    glad_glVertexArrayNormalOffsetEXT = (PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) load(userptr, "glVertexArrayNormalOffsetEXT");
    glad_glVertexArraySecondaryColorOffsetEXT = (PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) load(userptr, "glVertexArraySecondaryColorOffsetEXT");
    glad_glVertexArrayTexCoordOffsetEXT = (PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) load(userptr, "glVertexArrayTexCoordOffsetEXT");
    glad_glVertexArrayVertexAttribBindingEXT = (PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) load(userptr, "glVertexArrayVertexAttribBindingEXT");
    glad_glVertexArrayVertexAttribDivisorEXT = (PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) load(userptr, "glVertexArrayVertexAttribDivisorEXT");
    glad_glVertexArrayVertexAttribFormatEXT = (PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) load(userptr, "glVertexArrayVertexAttribFormatEXT");
    glad_glVertexArrayVertexAttribIFormatEXT = (PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) load(userptr, "glVertexArrayVertexAttribIFormatEXT");
    glad_glVertexArrayVertexAttribIOffsetEXT = (PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) load(userptr, "glVertexArrayVertexAttribIOffsetEXT");
    glad_glVertexArrayVertexAttribLFormatEXT = (PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) load(userptr, "glVertexArrayVertexAttribLFormatEXT");
    glad_glVertexArrayVertexAttribLOffsetEXT = (PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) load(userptr, "glVertexArrayVertexAttribLOffsetEXT");
    glad_glVertexArrayVertexAttribOffsetEXT = (PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) load(userptr, "glVertexArrayVertexAttribOffsetEXT");
    glad_glVertexArrayVertexBindingDivisorEXT = (PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) load(userptr, "glVertexArrayVertexBindingDivisorEXT");
    glad_glVertexArrayVertexOffsetEXT = (PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) load(userptr, "glVertexArrayVertexOffsetEXT");
}
static void glad_gl_load_GL_EXT_draw_buffers2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_draw_buffers2) return;
    glad_glColorMaskIndexedEXT = (PFNGLCOLORMASKINDEXEDEXTPROC) load(userptr, "glColorMaskIndexedEXT");
    glad_glColorMaski = (PFNGLCOLORMASKIPROC) load(userptr, "glColorMaski");
    glad_glDisableIndexedEXT = (PFNGLDISABLEINDEXEDEXTPROC) load(userptr, "glDisableIndexedEXT");
    glad_glDisablei = (PFNGLDISABLEIPROC) load(userptr, "glDisablei");
    glad_glEnableIndexedEXT = (PFNGLENABLEINDEXEDEXTPROC) load(userptr, "glEnableIndexedEXT");
    glad_glEnablei = (PFNGLENABLEIPROC) load(userptr, "glEnablei");
    glad_glGetBooleanIndexedvEXT = (PFNGLGETBOOLEANINDEXEDVEXTPROC) load(userptr, "glGetBooleanIndexedvEXT");
    glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC) load(userptr, "glGetBooleani_v");
    glad_glGetIntegerIndexedvEXT = (PFNGLGETINTEGERINDEXEDVEXTPROC) load(userptr, "glGetIntegerIndexedvEXT");
    glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) load(userptr, "glGetIntegeri_v");
    glad_glIsEnabledIndexedEXT = (PFNGLISENABLEDINDEXEDEXTPROC) load(userptr, "glIsEnabledIndexedEXT");
    glad_glIsEnabledi = (PFNGLISENABLEDIPROC) load(userptr, "glIsEnabledi");
}
static void glad_gl_load_GL_EXT_draw_instanced( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_draw_instanced) return;
    glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) load(userptr, "glDrawArraysInstanced");
    glad_glDrawArraysInstancedEXT = (PFNGLDRAWARRAYSINSTANCEDEXTPROC) load(userptr, "glDrawArraysInstancedEXT");
    glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) load(userptr, "glDrawElementsInstanced");
    glad_glDrawElementsInstancedEXT = (PFNGLDRAWELEMENTSINSTANCEDEXTPROC) load(userptr, "glDrawElementsInstancedEXT");
}
static void glad_gl_load_GL_EXT_draw_range_elements( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_draw_range_elements) return;
    glad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC) load(userptr, "glDrawRangeElements");
    glad_glDrawRangeElementsEXT = (PFNGLDRAWRANGEELEMENTSEXTPROC) load(userptr, "glDrawRangeElementsEXT");
}
static void glad_gl_load_GL_EXT_external_buffer( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_external_buffer) return;
    glad_glBufferStorageExternalEXT = (PFNGLBUFFERSTORAGEEXTERNALEXTPROC) load(userptr, "glBufferStorageExternalEXT");
    glad_glNamedBufferStorageExternalEXT = (PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC) load(userptr, "glNamedBufferStorageExternalEXT");
}
static void glad_gl_load_GL_EXT_fog_coord( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_fog_coord) return;
    glad_glFogCoordPointer = (PFNGLFOGCOORDPOINTERPROC) load(userptr, "glFogCoordPointer");
    glad_glFogCoordPointerEXT = (PFNGLFOGCOORDPOINTEREXTPROC) load(userptr, "glFogCoordPointerEXT");
    glad_glFogCoordd = (PFNGLFOGCOORDDPROC) load(userptr, "glFogCoordd");
    glad_glFogCoorddEXT = (PFNGLFOGCOORDDEXTPROC) load(userptr, "glFogCoorddEXT");
    glad_glFogCoorddv = (PFNGLFOGCOORDDVPROC) load(userptr, "glFogCoorddv");
    glad_glFogCoorddvEXT = (PFNGLFOGCOORDDVEXTPROC) load(userptr, "glFogCoorddvEXT");
    glad_glFogCoordf = (PFNGLFOGCOORDFPROC) load(userptr, "glFogCoordf");
    glad_glFogCoordfEXT = (PFNGLFOGCOORDFEXTPROC) load(userptr, "glFogCoordfEXT");
    glad_glFogCoordfv = (PFNGLFOGCOORDFVPROC) load(userptr, "glFogCoordfv");
    glad_glFogCoordfvEXT = (PFNGLFOGCOORDFVEXTPROC) load(userptr, "glFogCoordfvEXT");
}
static void glad_gl_load_GL_EXT_framebuffer_blit( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_framebuffer_blit) return;
    glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) load(userptr, "glBlitFramebuffer");
    glad_glBlitFramebufferEXT = (PFNGLBLITFRAMEBUFFEREXTPROC) load(userptr, "glBlitFramebufferEXT");
}
static void glad_gl_load_GL_EXT_framebuffer_multisample( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_framebuffer_multisample) return;
    glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) load(userptr, "glRenderbufferStorageMultisample");
    glad_glRenderbufferStorageMultisampleEXT = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) load(userptr, "glRenderbufferStorageMultisampleEXT");
}
static void glad_gl_load_GL_EXT_framebuffer_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_framebuffer_object) return;
    glad_glBindFramebufferEXT = (PFNGLBINDFRAMEBUFFEREXTPROC) load(userptr, "glBindFramebufferEXT");
    glad_glBindRenderbufferEXT = (PFNGLBINDRENDERBUFFEREXTPROC) load(userptr, "glBindRenderbufferEXT");
    glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC) load(userptr, "glCheckFramebufferStatus");
    glad_glCheckFramebufferStatusEXT = (PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) load(userptr, "glCheckFramebufferStatusEXT");
    glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) load(userptr, "glDeleteFramebuffers");
    glad_glDeleteFramebuffersEXT = (PFNGLDELETEFRAMEBUFFERSEXTPROC) load(userptr, "glDeleteFramebuffersEXT");
    glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) load(userptr, "glDeleteRenderbuffers");
    glad_glDeleteRenderbuffersEXT = (PFNGLDELETERENDERBUFFERSEXTPROC) load(userptr, "glDeleteRenderbuffersEXT");
    glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) load(userptr, "glFramebufferRenderbuffer");
    glad_glFramebufferRenderbufferEXT = (PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) load(userptr, "glFramebufferRenderbufferEXT");
    glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC) load(userptr, "glFramebufferTexture1D");
    glad_glFramebufferTexture1DEXT = (PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) load(userptr, "glFramebufferTexture1DEXT");
    glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) load(userptr, "glFramebufferTexture2D");
    glad_glFramebufferTexture2DEXT = (PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) load(userptr, "glFramebufferTexture2DEXT");
    glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC) load(userptr, "glFramebufferTexture3D");
    glad_glFramebufferTexture3DEXT = (PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) load(userptr, "glFramebufferTexture3DEXT");
    glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) load(userptr, "glGenFramebuffers");
    glad_glGenFramebuffersEXT = (PFNGLGENFRAMEBUFFERSEXTPROC) load(userptr, "glGenFramebuffersEXT");
    glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) load(userptr, "glGenRenderbuffers");
    glad_glGenRenderbuffersEXT = (PFNGLGENRENDERBUFFERSEXTPROC) load(userptr, "glGenRenderbuffersEXT");
    glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC) load(userptr, "glGenerateMipmap");
    glad_glGenerateMipmapEXT = (PFNGLGENERATEMIPMAPEXTPROC) load(userptr, "glGenerateMipmapEXT");
    glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) load(userptr, "glGetFramebufferAttachmentParameteriv");
    glad_glGetFramebufferAttachmentParameterivEXT = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) load(userptr, "glGetFramebufferAttachmentParameterivEXT");
    glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC) load(userptr, "glGetRenderbufferParameteriv");
    glad_glGetRenderbufferParameterivEXT = (PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) load(userptr, "glGetRenderbufferParameterivEXT");
    glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC) load(userptr, "glIsFramebuffer");
    glad_glIsFramebufferEXT = (PFNGLISFRAMEBUFFEREXTPROC) load(userptr, "glIsFramebufferEXT");
    glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC) load(userptr, "glIsRenderbuffer");
    glad_glIsRenderbufferEXT = (PFNGLISRENDERBUFFEREXTPROC) load(userptr, "glIsRenderbufferEXT");
    glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) load(userptr, "glRenderbufferStorage");
    glad_glRenderbufferStorageEXT = (PFNGLRENDERBUFFERSTORAGEEXTPROC) load(userptr, "glRenderbufferStorageEXT");
}
static void glad_gl_load_GL_EXT_geometry_shader4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_geometry_shader4) return;
    glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) load(userptr, "glProgramParameteri");
    glad_glProgramParameteriEXT = (PFNGLPROGRAMPARAMETERIEXTPROC) load(userptr, "glProgramParameteriEXT");
}
static void glad_gl_load_GL_EXT_gpu_program_parameters( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_gpu_program_parameters) return;
    glad_glProgramEnvParameters4fvEXT = (PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) load(userptr, "glProgramEnvParameters4fvEXT");
    glad_glProgramLocalParameters4fvEXT = (PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) load(userptr, "glProgramLocalParameters4fvEXT");
}
static void glad_gl_load_GL_EXT_gpu_shader4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_gpu_shader4) return;
    glad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC) load(userptr, "glBindFragDataLocation");
    glad_glBindFragDataLocationEXT = (PFNGLBINDFRAGDATALOCATIONEXTPROC) load(userptr, "glBindFragDataLocationEXT");
    glad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC) load(userptr, "glGetFragDataLocation");
    glad_glGetFragDataLocationEXT = (PFNGLGETFRAGDATALOCATIONEXTPROC) load(userptr, "glGetFragDataLocationEXT");
    glad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC) load(userptr, "glGetUniformuiv");
    glad_glGetUniformuivEXT = (PFNGLGETUNIFORMUIVEXTPROC) load(userptr, "glGetUniformuivEXT");
    glad_glUniform1ui = (PFNGLUNIFORM1UIPROC) load(userptr, "glUniform1ui");
    glad_glUniform1uiEXT = (PFNGLUNIFORM1UIEXTPROC) load(userptr, "glUniform1uiEXT");
    glad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC) load(userptr, "glUniform1uiv");
    glad_glUniform1uivEXT = (PFNGLUNIFORM1UIVEXTPROC) load(userptr, "glUniform1uivEXT");
    glad_glUniform2ui = (PFNGLUNIFORM2UIPROC) load(userptr, "glUniform2ui");
    glad_glUniform2uiEXT = (PFNGLUNIFORM2UIEXTPROC) load(userptr, "glUniform2uiEXT");
    glad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC) load(userptr, "glUniform2uiv");
    glad_glUniform2uivEXT = (PFNGLUNIFORM2UIVEXTPROC) load(userptr, "glUniform2uivEXT");
    glad_glUniform3ui = (PFNGLUNIFORM3UIPROC) load(userptr, "glUniform3ui");
    glad_glUniform3uiEXT = (PFNGLUNIFORM3UIEXTPROC) load(userptr, "glUniform3uiEXT");
    glad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC) load(userptr, "glUniform3uiv");
    glad_glUniform3uivEXT = (PFNGLUNIFORM3UIVEXTPROC) load(userptr, "glUniform3uivEXT");
    glad_glUniform4ui = (PFNGLUNIFORM4UIPROC) load(userptr, "glUniform4ui");
    glad_glUniform4uiEXT = (PFNGLUNIFORM4UIEXTPROC) load(userptr, "glUniform4uiEXT");
    glad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC) load(userptr, "glUniform4uiv");
    glad_glUniform4uivEXT = (PFNGLUNIFORM4UIVEXTPROC) load(userptr, "glUniform4uivEXT");
}
static void glad_gl_load_GL_EXT_histogram( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_histogram) return;
    glad_glGetHistogramEXT = (PFNGLGETHISTOGRAMEXTPROC) load(userptr, "glGetHistogramEXT");
    glad_glGetHistogramParameterfvEXT = (PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) load(userptr, "glGetHistogramParameterfvEXT");
    glad_glGetHistogramParameterivEXT = (PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) load(userptr, "glGetHistogramParameterivEXT");
    glad_glGetMinmaxEXT = (PFNGLGETMINMAXEXTPROC) load(userptr, "glGetMinmaxEXT");
    glad_glGetMinmaxParameterfvEXT = (PFNGLGETMINMAXPARAMETERFVEXTPROC) load(userptr, "glGetMinmaxParameterfvEXT");
    glad_glGetMinmaxParameterivEXT = (PFNGLGETMINMAXPARAMETERIVEXTPROC) load(userptr, "glGetMinmaxParameterivEXT");
    glad_glHistogram = (PFNGLHISTOGRAMPROC) load(userptr, "glHistogram");
    glad_glHistogramEXT = (PFNGLHISTOGRAMEXTPROC) load(userptr, "glHistogramEXT");
    glad_glMinmax = (PFNGLMINMAXPROC) load(userptr, "glMinmax");
    glad_glMinmaxEXT = (PFNGLMINMAXEXTPROC) load(userptr, "glMinmaxEXT");
    glad_glResetHistogram = (PFNGLRESETHISTOGRAMPROC) load(userptr, "glResetHistogram");
    glad_glResetHistogramEXT = (PFNGLRESETHISTOGRAMEXTPROC) load(userptr, "glResetHistogramEXT");
    glad_glResetMinmax = (PFNGLRESETMINMAXPROC) load(userptr, "glResetMinmax");
    glad_glResetMinmaxEXT = (PFNGLRESETMINMAXEXTPROC) load(userptr, "glResetMinmaxEXT");
}
static void glad_gl_load_GL_EXT_index_func( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_index_func) return;
    glad_glIndexFuncEXT = (PFNGLINDEXFUNCEXTPROC) load(userptr, "glIndexFuncEXT");
}
static void glad_gl_load_GL_EXT_index_material( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_index_material) return;
    glad_glIndexMaterialEXT = (PFNGLINDEXMATERIALEXTPROC) load(userptr, "glIndexMaterialEXT");
}
static void glad_gl_load_GL_EXT_light_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_light_texture) return;
    glad_glApplyTextureEXT = (PFNGLAPPLYTEXTUREEXTPROC) load(userptr, "glApplyTextureEXT");
    glad_glTextureLightEXT = (PFNGLTEXTURELIGHTEXTPROC) load(userptr, "glTextureLightEXT");
    glad_glTextureMaterialEXT = (PFNGLTEXTUREMATERIALEXTPROC) load(userptr, "glTextureMaterialEXT");
}
static void glad_gl_load_GL_EXT_memory_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_memory_object) return;
    glad_glBufferStorageMemEXT = (PFNGLBUFFERSTORAGEMEMEXTPROC) load(userptr, "glBufferStorageMemEXT");
    glad_glCreateMemoryObjectsEXT = (PFNGLCREATEMEMORYOBJECTSEXTPROC) load(userptr, "glCreateMemoryObjectsEXT");
    glad_glDeleteMemoryObjectsEXT = (PFNGLDELETEMEMORYOBJECTSEXTPROC) load(userptr, "glDeleteMemoryObjectsEXT");
    glad_glGetMemoryObjectParameterivEXT = (PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC) load(userptr, "glGetMemoryObjectParameterivEXT");
    glad_glGetUnsignedBytei_vEXT = (PFNGLGETUNSIGNEDBYTEI_VEXTPROC) load(userptr, "glGetUnsignedBytei_vEXT");
    glad_glGetUnsignedBytevEXT = (PFNGLGETUNSIGNEDBYTEVEXTPROC) load(userptr, "glGetUnsignedBytevEXT");
    glad_glIsMemoryObjectEXT = (PFNGLISMEMORYOBJECTEXTPROC) load(userptr, "glIsMemoryObjectEXT");
    glad_glMemoryObjectParameterivEXT = (PFNGLMEMORYOBJECTPARAMETERIVEXTPROC) load(userptr, "glMemoryObjectParameterivEXT");
    glad_glNamedBufferStorageMemEXT = (PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC) load(userptr, "glNamedBufferStorageMemEXT");
    glad_glTexStorageMem1DEXT = (PFNGLTEXSTORAGEMEM1DEXTPROC) load(userptr, "glTexStorageMem1DEXT");
    glad_glTexStorageMem2DEXT = (PFNGLTEXSTORAGEMEM2DEXTPROC) load(userptr, "glTexStorageMem2DEXT");
    glad_glTexStorageMem2DMultisampleEXT = (PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC) load(userptr, "glTexStorageMem2DMultisampleEXT");
    glad_glTexStorageMem3DEXT = (PFNGLTEXSTORAGEMEM3DEXTPROC) load(userptr, "glTexStorageMem3DEXT");
    glad_glTexStorageMem3DMultisampleEXT = (PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC) load(userptr, "glTexStorageMem3DMultisampleEXT");
    glad_glTextureStorageMem1DEXT = (PFNGLTEXTURESTORAGEMEM1DEXTPROC) load(userptr, "glTextureStorageMem1DEXT");
    glad_glTextureStorageMem2DEXT = (PFNGLTEXTURESTORAGEMEM2DEXTPROC) load(userptr, "glTextureStorageMem2DEXT");
    glad_glTextureStorageMem2DMultisampleEXT = (PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC) load(userptr, "glTextureStorageMem2DMultisampleEXT");
    glad_glTextureStorageMem3DEXT = (PFNGLTEXTURESTORAGEMEM3DEXTPROC) load(userptr, "glTextureStorageMem3DEXT");
    glad_glTextureStorageMem3DMultisampleEXT = (PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC) load(userptr, "glTextureStorageMem3DMultisampleEXT");
}
static void glad_gl_load_GL_EXT_memory_object_fd( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_memory_object_fd) return;
    glad_glImportMemoryFdEXT = (PFNGLIMPORTMEMORYFDEXTPROC) load(userptr, "glImportMemoryFdEXT");
}
static void glad_gl_load_GL_EXT_memory_object_win32( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_memory_object_win32) return;
    glad_glImportMemoryWin32HandleEXT = (PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC) load(userptr, "glImportMemoryWin32HandleEXT");
    glad_glImportMemoryWin32NameEXT = (PFNGLIMPORTMEMORYWIN32NAMEEXTPROC) load(userptr, "glImportMemoryWin32NameEXT");
}
static void glad_gl_load_GL_EXT_multi_draw_arrays( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_multi_draw_arrays) return;
    glad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC) load(userptr, "glMultiDrawArrays");
    glad_glMultiDrawArraysEXT = (PFNGLMULTIDRAWARRAYSEXTPROC) load(userptr, "glMultiDrawArraysEXT");
    glad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC) load(userptr, "glMultiDrawElements");
    glad_glMultiDrawElementsEXT = (PFNGLMULTIDRAWELEMENTSEXTPROC) load(userptr, "glMultiDrawElementsEXT");
}
static void glad_gl_load_GL_EXT_multisample( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_multisample) return;
    glad_glSampleMaskEXT = (PFNGLSAMPLEMASKEXTPROC) load(userptr, "glSampleMaskEXT");
    glad_glSamplePatternEXT = (PFNGLSAMPLEPATTERNEXTPROC) load(userptr, "glSamplePatternEXT");
}
static void glad_gl_load_GL_EXT_paletted_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_paletted_texture) return;
    glad_glColorTable = (PFNGLCOLORTABLEPROC) load(userptr, "glColorTable");
    glad_glColorTableEXT = (PFNGLCOLORTABLEEXTPROC) load(userptr, "glColorTableEXT");
    glad_glGetColorTable = (PFNGLGETCOLORTABLEPROC) load(userptr, "glGetColorTable");
    glad_glGetColorTableEXT = (PFNGLGETCOLORTABLEEXTPROC) load(userptr, "glGetColorTableEXT");
    glad_glGetColorTableParameterfv = (PFNGLGETCOLORTABLEPARAMETERFVPROC) load(userptr, "glGetColorTableParameterfv");
    glad_glGetColorTableParameterfvEXT = (PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) load(userptr, "glGetColorTableParameterfvEXT");
    glad_glGetColorTableParameteriv = (PFNGLGETCOLORTABLEPARAMETERIVPROC) load(userptr, "glGetColorTableParameteriv");
    glad_glGetColorTableParameterivEXT = (PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) load(userptr, "glGetColorTableParameterivEXT");
}
static void glad_gl_load_GL_EXT_pixel_transform( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_pixel_transform) return;
    glad_glGetPixelTransformParameterfvEXT = (PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) load(userptr, "glGetPixelTransformParameterfvEXT");
    glad_glGetPixelTransformParameterivEXT = (PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) load(userptr, "glGetPixelTransformParameterivEXT");
    glad_glPixelTransformParameterfEXT = (PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) load(userptr, "glPixelTransformParameterfEXT");
    glad_glPixelTransformParameterfvEXT = (PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) load(userptr, "glPixelTransformParameterfvEXT");
    glad_glPixelTransformParameteriEXT = (PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) load(userptr, "glPixelTransformParameteriEXT");
    glad_glPixelTransformParameterivEXT = (PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) load(userptr, "glPixelTransformParameterivEXT");
}
static void glad_gl_load_GL_EXT_point_parameters( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_point_parameters) return;
    glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC) load(userptr, "glPointParameterf");
    glad_glPointParameterfEXT = (PFNGLPOINTPARAMETERFEXTPROC) load(userptr, "glPointParameterfEXT");
    glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC) load(userptr, "glPointParameterfv");
    glad_glPointParameterfvEXT = (PFNGLPOINTPARAMETERFVEXTPROC) load(userptr, "glPointParameterfvEXT");
}
static void glad_gl_load_GL_EXT_polygon_offset( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_polygon_offset) return;
    glad_glPolygonOffsetEXT = (PFNGLPOLYGONOFFSETEXTPROC) load(userptr, "glPolygonOffsetEXT");
}
static void glad_gl_load_GL_EXT_polygon_offset_clamp( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_polygon_offset_clamp) return;
    glad_glPolygonOffsetClamp = (PFNGLPOLYGONOFFSETCLAMPPROC) load(userptr, "glPolygonOffsetClamp");
    glad_glPolygonOffsetClampEXT = (PFNGLPOLYGONOFFSETCLAMPEXTPROC) load(userptr, "glPolygonOffsetClampEXT");
}
static void glad_gl_load_GL_EXT_provoking_vertex( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_provoking_vertex) return;
    glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) load(userptr, "glProvokingVertex");
    glad_glProvokingVertexEXT = (PFNGLPROVOKINGVERTEXEXTPROC) load(userptr, "glProvokingVertexEXT");
}
static void glad_gl_load_GL_EXT_raster_multisample( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_raster_multisample) return;
    glad_glRasterSamplesEXT = (PFNGLRASTERSAMPLESEXTPROC) load(userptr, "glRasterSamplesEXT");
}
static void glad_gl_load_GL_EXT_secondary_color( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_secondary_color) return;
    glad_glSecondaryColor3b = (PFNGLSECONDARYCOLOR3BPROC) load(userptr, "glSecondaryColor3b");
    glad_glSecondaryColor3bEXT = (PFNGLSECONDARYCOLOR3BEXTPROC) load(userptr, "glSecondaryColor3bEXT");
    glad_glSecondaryColor3bv = (PFNGLSECONDARYCOLOR3BVPROC) load(userptr, "glSecondaryColor3bv");
    glad_glSecondaryColor3bvEXT = (PFNGLSECONDARYCOLOR3BVEXTPROC) load(userptr, "glSecondaryColor3bvEXT");
    glad_glSecondaryColor3d = (PFNGLSECONDARYCOLOR3DPROC) load(userptr, "glSecondaryColor3d");
    glad_glSecondaryColor3dEXT = (PFNGLSECONDARYCOLOR3DEXTPROC) load(userptr, "glSecondaryColor3dEXT");
    glad_glSecondaryColor3dv = (PFNGLSECONDARYCOLOR3DVPROC) load(userptr, "glSecondaryColor3dv");
    glad_glSecondaryColor3dvEXT = (PFNGLSECONDARYCOLOR3DVEXTPROC) load(userptr, "glSecondaryColor3dvEXT");
    glad_glSecondaryColor3f = (PFNGLSECONDARYCOLOR3FPROC) load(userptr, "glSecondaryColor3f");
    glad_glSecondaryColor3fEXT = (PFNGLSECONDARYCOLOR3FEXTPROC) load(userptr, "glSecondaryColor3fEXT");
    glad_glSecondaryColor3fv = (PFNGLSECONDARYCOLOR3FVPROC) load(userptr, "glSecondaryColor3fv");
    glad_glSecondaryColor3fvEXT = (PFNGLSECONDARYCOLOR3FVEXTPROC) load(userptr, "glSecondaryColor3fvEXT");
    glad_glSecondaryColor3i = (PFNGLSECONDARYCOLOR3IPROC) load(userptr, "glSecondaryColor3i");
    glad_glSecondaryColor3iEXT = (PFNGLSECONDARYCOLOR3IEXTPROC) load(userptr, "glSecondaryColor3iEXT");
    glad_glSecondaryColor3iv = (PFNGLSECONDARYCOLOR3IVPROC) load(userptr, "glSecondaryColor3iv");
    glad_glSecondaryColor3ivEXT = (PFNGLSECONDARYCOLOR3IVEXTPROC) load(userptr, "glSecondaryColor3ivEXT");
    glad_glSecondaryColor3s = (PFNGLSECONDARYCOLOR3SPROC) load(userptr, "glSecondaryColor3s");
    glad_glSecondaryColor3sEXT = (PFNGLSECONDARYCOLOR3SEXTPROC) load(userptr, "glSecondaryColor3sEXT");
    glad_glSecondaryColor3sv = (PFNGLSECONDARYCOLOR3SVPROC) load(userptr, "glSecondaryColor3sv");
    glad_glSecondaryColor3svEXT = (PFNGLSECONDARYCOLOR3SVEXTPROC) load(userptr, "glSecondaryColor3svEXT");
    glad_glSecondaryColor3ub = (PFNGLSECONDARYCOLOR3UBPROC) load(userptr, "glSecondaryColor3ub");
    glad_glSecondaryColor3ubEXT = (PFNGLSECONDARYCOLOR3UBEXTPROC) load(userptr, "glSecondaryColor3ubEXT");
    glad_glSecondaryColor3ubv = (PFNGLSECONDARYCOLOR3UBVPROC) load(userptr, "glSecondaryColor3ubv");
    glad_glSecondaryColor3ubvEXT = (PFNGLSECONDARYCOLOR3UBVEXTPROC) load(userptr, "glSecondaryColor3ubvEXT");
    glad_glSecondaryColor3ui = (PFNGLSECONDARYCOLOR3UIPROC) load(userptr, "glSecondaryColor3ui");
    glad_glSecondaryColor3uiEXT = (PFNGLSECONDARYCOLOR3UIEXTPROC) load(userptr, "glSecondaryColor3uiEXT");
    glad_glSecondaryColor3uiv = (PFNGLSECONDARYCOLOR3UIVPROC) load(userptr, "glSecondaryColor3uiv");
    glad_glSecondaryColor3uivEXT = (PFNGLSECONDARYCOLOR3UIVEXTPROC) load(userptr, "glSecondaryColor3uivEXT");
    glad_glSecondaryColor3us = (PFNGLSECONDARYCOLOR3USPROC) load(userptr, "glSecondaryColor3us");
    glad_glSecondaryColor3usEXT = (PFNGLSECONDARYCOLOR3USEXTPROC) load(userptr, "glSecondaryColor3usEXT");
    glad_glSecondaryColor3usv = (PFNGLSECONDARYCOLOR3USVPROC) load(userptr, "glSecondaryColor3usv");
    glad_glSecondaryColor3usvEXT = (PFNGLSECONDARYCOLOR3USVEXTPROC) load(userptr, "glSecondaryColor3usvEXT");
    glad_glSecondaryColorPointer = (PFNGLSECONDARYCOLORPOINTERPROC) load(userptr, "glSecondaryColorPointer");
    glad_glSecondaryColorPointerEXT = (PFNGLSECONDARYCOLORPOINTEREXTPROC) load(userptr, "glSecondaryColorPointerEXT");
}
static void glad_gl_load_GL_EXT_semaphore( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_semaphore) return;
    glad_glDeleteSemaphoresEXT = (PFNGLDELETESEMAPHORESEXTPROC) load(userptr, "glDeleteSemaphoresEXT");
    glad_glGenSemaphoresEXT = (PFNGLGENSEMAPHORESEXTPROC) load(userptr, "glGenSemaphoresEXT");
    glad_glGetSemaphoreParameterui64vEXT = (PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC) load(userptr, "glGetSemaphoreParameterui64vEXT");
    glad_glGetUnsignedBytei_vEXT = (PFNGLGETUNSIGNEDBYTEI_VEXTPROC) load(userptr, "glGetUnsignedBytei_vEXT");
    glad_glGetUnsignedBytevEXT = (PFNGLGETUNSIGNEDBYTEVEXTPROC) load(userptr, "glGetUnsignedBytevEXT");
    glad_glIsSemaphoreEXT = (PFNGLISSEMAPHOREEXTPROC) load(userptr, "glIsSemaphoreEXT");
    glad_glSemaphoreParameterui64vEXT = (PFNGLSEMAPHOREPARAMETERUI64VEXTPROC) load(userptr, "glSemaphoreParameterui64vEXT");
    glad_glSignalSemaphoreEXT = (PFNGLSIGNALSEMAPHOREEXTPROC) load(userptr, "glSignalSemaphoreEXT");
    glad_glWaitSemaphoreEXT = (PFNGLWAITSEMAPHOREEXTPROC) load(userptr, "glWaitSemaphoreEXT");
}
static void glad_gl_load_GL_EXT_semaphore_fd( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_semaphore_fd) return;
    glad_glImportSemaphoreFdEXT = (PFNGLIMPORTSEMAPHOREFDEXTPROC) load(userptr, "glImportSemaphoreFdEXT");
}
static void glad_gl_load_GL_EXT_semaphore_win32( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_semaphore_win32) return;
    glad_glImportSemaphoreWin32HandleEXT = (PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC) load(userptr, "glImportSemaphoreWin32HandleEXT");
    glad_glImportSemaphoreWin32NameEXT = (PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC) load(userptr, "glImportSemaphoreWin32NameEXT");
}
static void glad_gl_load_GL_EXT_separate_shader_objects( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_separate_shader_objects) return;
    glad_glActiveProgramEXT = (PFNGLACTIVEPROGRAMEXTPROC) load(userptr, "glActiveProgramEXT");
    glad_glCreateShaderProgramEXT = (PFNGLCREATESHADERPROGRAMEXTPROC) load(userptr, "glCreateShaderProgramEXT");
    glad_glUseShaderProgramEXT = (PFNGLUSESHADERPROGRAMEXTPROC) load(userptr, "glUseShaderProgramEXT");
}
static void glad_gl_load_GL_EXT_shader_image_load_store( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_shader_image_load_store) return;
    glad_glBindImageTextureEXT = (PFNGLBINDIMAGETEXTUREEXTPROC) load(userptr, "glBindImageTextureEXT");
    glad_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC) load(userptr, "glMemoryBarrier");
    glad_glMemoryBarrierEXT = (PFNGLMEMORYBARRIEREXTPROC) load(userptr, "glMemoryBarrierEXT");
}
static void glad_gl_load_GL_EXT_stencil_clear_tag( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_stencil_clear_tag) return;
    glad_glStencilClearTagEXT = (PFNGLSTENCILCLEARTAGEXTPROC) load(userptr, "glStencilClearTagEXT");
}
static void glad_gl_load_GL_EXT_stencil_two_side( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_stencil_two_side) return;
    glad_glActiveStencilFaceEXT = (PFNGLACTIVESTENCILFACEEXTPROC) load(userptr, "glActiveStencilFaceEXT");
}
static void glad_gl_load_GL_EXT_subtexture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_subtexture) return;
    glad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC) load(userptr, "glTexSubImage1D");
    glad_glTexSubImage1DEXT = (PFNGLTEXSUBIMAGE1DEXTPROC) load(userptr, "glTexSubImage1DEXT");
    glad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC) load(userptr, "glTexSubImage2D");
    glad_glTexSubImage2DEXT = (PFNGLTEXSUBIMAGE2DEXTPROC) load(userptr, "glTexSubImage2DEXT");
}
static void glad_gl_load_GL_EXT_texture3D( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_texture3D) return;
    glad_glTexImage3D = (PFNGLTEXIMAGE3DPROC) load(userptr, "glTexImage3D");
    glad_glTexImage3DEXT = (PFNGLTEXIMAGE3DEXTPROC) load(userptr, "glTexImage3DEXT");
    glad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC) load(userptr, "glTexSubImage3D");
    glad_glTexSubImage3DEXT = (PFNGLTEXSUBIMAGE3DEXTPROC) load(userptr, "glTexSubImage3DEXT");
}
static void glad_gl_load_GL_EXT_texture_array( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_texture_array) return;
    glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glFramebufferTextureLayer");
    glad_glFramebufferTextureLayerEXT = (PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) load(userptr, "glFramebufferTextureLayerEXT");
}
static void glad_gl_load_GL_EXT_texture_buffer_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_texture_buffer_object) return;
    glad_glTexBuffer = (PFNGLTEXBUFFERPROC) load(userptr, "glTexBuffer");
    glad_glTexBufferEXT = (PFNGLTEXBUFFEREXTPROC) load(userptr, "glTexBufferEXT");
}
static void glad_gl_load_GL_EXT_texture_integer( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_texture_integer) return;
    glad_glClearColorIiEXT = (PFNGLCLEARCOLORIIEXTPROC) load(userptr, "glClearColorIiEXT");
    glad_glClearColorIuiEXT = (PFNGLCLEARCOLORIUIEXTPROC) load(userptr, "glClearColorIuiEXT");
    glad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC) load(userptr, "glGetTexParameterIiv");
    glad_glGetTexParameterIivEXT = (PFNGLGETTEXPARAMETERIIVEXTPROC) load(userptr, "glGetTexParameterIivEXT");
    glad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC) load(userptr, "glGetTexParameterIuiv");
    glad_glGetTexParameterIuivEXT = (PFNGLGETTEXPARAMETERIUIVEXTPROC) load(userptr, "glGetTexParameterIuivEXT");
    glad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC) load(userptr, "glTexParameterIiv");
    glad_glTexParameterIivEXT = (PFNGLTEXPARAMETERIIVEXTPROC) load(userptr, "glTexParameterIivEXT");
    glad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC) load(userptr, "glTexParameterIuiv");
    glad_glTexParameterIuivEXT = (PFNGLTEXPARAMETERIUIVEXTPROC) load(userptr, "glTexParameterIuivEXT");
}
static void glad_gl_load_GL_EXT_texture_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_texture_object) return;
    glad_glAreTexturesResidentEXT = (PFNGLARETEXTURESRESIDENTEXTPROC) load(userptr, "glAreTexturesResidentEXT");
    glad_glBindTexture = (PFNGLBINDTEXTUREPROC) load(userptr, "glBindTexture");
    glad_glBindTextureEXT = (PFNGLBINDTEXTUREEXTPROC) load(userptr, "glBindTextureEXT");
    glad_glDeleteTexturesEXT = (PFNGLDELETETEXTURESEXTPROC) load(userptr, "glDeleteTexturesEXT");
    glad_glGenTexturesEXT = (PFNGLGENTEXTURESEXTPROC) load(userptr, "glGenTexturesEXT");
    glad_glIsTextureEXT = (PFNGLISTEXTUREEXTPROC) load(userptr, "glIsTextureEXT");
    glad_glPrioritizeTextures = (PFNGLPRIORITIZETEXTURESPROC) load(userptr, "glPrioritizeTextures");
    glad_glPrioritizeTexturesEXT = (PFNGLPRIORITIZETEXTURESEXTPROC) load(userptr, "glPrioritizeTexturesEXT");
}
static void glad_gl_load_GL_EXT_texture_perturb_normal( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_texture_perturb_normal) return;
    glad_glTextureNormalEXT = (PFNGLTEXTURENORMALEXTPROC) load(userptr, "glTextureNormalEXT");
}
static void glad_gl_load_GL_EXT_timer_query( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_timer_query) return;
    glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC) load(userptr, "glGetQueryObjecti64v");
    glad_glGetQueryObjecti64vEXT = (PFNGLGETQUERYOBJECTI64VEXTPROC) load(userptr, "glGetQueryObjecti64vEXT");
    glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC) load(userptr, "glGetQueryObjectui64v");
    glad_glGetQueryObjectui64vEXT = (PFNGLGETQUERYOBJECTUI64VEXTPROC) load(userptr, "glGetQueryObjectui64vEXT");
}
static void glad_gl_load_GL_EXT_transform_feedback( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_transform_feedback) return;
    glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC) load(userptr, "glBeginTransformFeedback");
    glad_glBeginTransformFeedbackEXT = (PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) load(userptr, "glBeginTransformFeedbackEXT");
    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
    glad_glBindBufferBaseEXT = (PFNGLBINDBUFFERBASEEXTPROC) load(userptr, "glBindBufferBaseEXT");
    glad_glBindBufferOffsetEXT = (PFNGLBINDBUFFEROFFSETEXTPROC) load(userptr, "glBindBufferOffsetEXT");
    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
    glad_glBindBufferRangeEXT = (PFNGLBINDBUFFERRANGEEXTPROC) load(userptr, "glBindBufferRangeEXT");
    glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC) load(userptr, "glEndTransformFeedback");
    glad_glEndTransformFeedbackEXT = (PFNGLENDTRANSFORMFEEDBACKEXTPROC) load(userptr, "glEndTransformFeedbackEXT");
    glad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) load(userptr, "glGetTransformFeedbackVarying");
    glad_glGetTransformFeedbackVaryingEXT = (PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) load(userptr, "glGetTransformFeedbackVaryingEXT");
    glad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC) load(userptr, "glTransformFeedbackVaryings");
    glad_glTransformFeedbackVaryingsEXT = (PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) load(userptr, "glTransformFeedbackVaryingsEXT");
}
static void glad_gl_load_GL_EXT_vertex_array( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_vertex_array) return;
    glad_glArrayElement = (PFNGLARRAYELEMENTPROC) load(userptr, "glArrayElement");
    glad_glArrayElementEXT = (PFNGLARRAYELEMENTEXTPROC) load(userptr, "glArrayElementEXT");
    glad_glColorPointerEXT = (PFNGLCOLORPOINTEREXTPROC) load(userptr, "glColorPointerEXT");
    glad_glDrawArrays = (PFNGLDRAWARRAYSPROC) load(userptr, "glDrawArrays");
    glad_glDrawArraysEXT = (PFNGLDRAWARRAYSEXTPROC) load(userptr, "glDrawArraysEXT");
    glad_glEdgeFlagPointerEXT = (PFNGLEDGEFLAGPOINTEREXTPROC) load(userptr, "glEdgeFlagPointerEXT");
    glad_glGetPointerv = (PFNGLGETPOINTERVPROC) load(userptr, "glGetPointerv");
    glad_glGetPointervEXT = (PFNGLGETPOINTERVEXTPROC) load(userptr, "glGetPointervEXT");
    glad_glIndexPointerEXT = (PFNGLINDEXPOINTEREXTPROC) load(userptr, "glIndexPointerEXT");
    glad_glNormalPointerEXT = (PFNGLNORMALPOINTEREXTPROC) load(userptr, "glNormalPointerEXT");
    glad_glTexCoordPointerEXT = (PFNGLTEXCOORDPOINTEREXTPROC) load(userptr, "glTexCoordPointerEXT");
    glad_glVertexPointerEXT = (PFNGLVERTEXPOINTEREXTPROC) load(userptr, "glVertexPointerEXT");
}
static void glad_gl_load_GL_EXT_vertex_attrib_64bit( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_vertex_attrib_64bit) return;
    glad_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC) load(userptr, "glGetVertexAttribLdv");
    glad_glGetVertexAttribLdvEXT = (PFNGLGETVERTEXATTRIBLDVEXTPROC) load(userptr, "glGetVertexAttribLdvEXT");
    glad_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC) load(userptr, "glVertexAttribL1d");
    glad_glVertexAttribL1dEXT = (PFNGLVERTEXATTRIBL1DEXTPROC) load(userptr, "glVertexAttribL1dEXT");
    glad_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC) load(userptr, "glVertexAttribL1dv");
    glad_glVertexAttribL1dvEXT = (PFNGLVERTEXATTRIBL1DVEXTPROC) load(userptr, "glVertexAttribL1dvEXT");
    glad_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC) load(userptr, "glVertexAttribL2d");
    glad_glVertexAttribL2dEXT = (PFNGLVERTEXATTRIBL2DEXTPROC) load(userptr, "glVertexAttribL2dEXT");
    glad_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC) load(userptr, "glVertexAttribL2dv");
    glad_glVertexAttribL2dvEXT = (PFNGLVERTEXATTRIBL2DVEXTPROC) load(userptr, "glVertexAttribL2dvEXT");
    glad_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC) load(userptr, "glVertexAttribL3d");
    glad_glVertexAttribL3dEXT = (PFNGLVERTEXATTRIBL3DEXTPROC) load(userptr, "glVertexAttribL3dEXT");
    glad_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC) load(userptr, "glVertexAttribL3dv");
    glad_glVertexAttribL3dvEXT = (PFNGLVERTEXATTRIBL3DVEXTPROC) load(userptr, "glVertexAttribL3dvEXT");
    glad_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC) load(userptr, "glVertexAttribL4d");
    glad_glVertexAttribL4dEXT = (PFNGLVERTEXATTRIBL4DEXTPROC) load(userptr, "glVertexAttribL4dEXT");
    glad_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC) load(userptr, "glVertexAttribL4dv");
    glad_glVertexAttribL4dvEXT = (PFNGLVERTEXATTRIBL4DVEXTPROC) load(userptr, "glVertexAttribL4dvEXT");
    glad_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC) load(userptr, "glVertexAttribLPointer");
    glad_glVertexAttribLPointerEXT = (PFNGLVERTEXATTRIBLPOINTEREXTPROC) load(userptr, "glVertexAttribLPointerEXT");
}
static void glad_gl_load_GL_EXT_vertex_shader( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_vertex_shader) return;
    glad_glBeginVertexShaderEXT = (PFNGLBEGINVERTEXSHADEREXTPROC) load(userptr, "glBeginVertexShaderEXT");
    glad_glBindLightParameterEXT = (PFNGLBINDLIGHTPARAMETEREXTPROC) load(userptr, "glBindLightParameterEXT");
    glad_glBindMaterialParameterEXT = (PFNGLBINDMATERIALPARAMETEREXTPROC) load(userptr, "glBindMaterialParameterEXT");
    glad_glBindParameterEXT = (PFNGLBINDPARAMETEREXTPROC) load(userptr, "glBindParameterEXT");
    glad_glBindTexGenParameterEXT = (PFNGLBINDTEXGENPARAMETEREXTPROC) load(userptr, "glBindTexGenParameterEXT");
    glad_glBindTextureUnitParameterEXT = (PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) load(userptr, "glBindTextureUnitParameterEXT");
    glad_glBindVertexShaderEXT = (PFNGLBINDVERTEXSHADEREXTPROC) load(userptr, "glBindVertexShaderEXT");
    glad_glDeleteVertexShaderEXT = (PFNGLDELETEVERTEXSHADEREXTPROC) load(userptr, "glDeleteVertexShaderEXT");
    glad_glDisableVariantClientStateEXT = (PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) load(userptr, "glDisableVariantClientStateEXT");
    glad_glEnableVariantClientStateEXT = (PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) load(userptr, "glEnableVariantClientStateEXT");
    glad_glEndVertexShaderEXT = (PFNGLENDVERTEXSHADEREXTPROC) load(userptr, "glEndVertexShaderEXT");
    glad_glExtractComponentEXT = (PFNGLEXTRACTCOMPONENTEXTPROC) load(userptr, "glExtractComponentEXT");
    glad_glGenSymbolsEXT = (PFNGLGENSYMBOLSEXTPROC) load(userptr, "glGenSymbolsEXT");
    glad_glGenVertexShadersEXT = (PFNGLGENVERTEXSHADERSEXTPROC) load(userptr, "glGenVertexShadersEXT");
    glad_glGetInvariantBooleanvEXT = (PFNGLGETINVARIANTBOOLEANVEXTPROC) load(userptr, "glGetInvariantBooleanvEXT");
    glad_glGetInvariantFloatvEXT = (PFNGLGETINVARIANTFLOATVEXTPROC) load(userptr, "glGetInvariantFloatvEXT");
    glad_glGetInvariantIntegervEXT = (PFNGLGETINVARIANTINTEGERVEXTPROC) load(userptr, "glGetInvariantIntegervEXT");
    glad_glGetLocalConstantBooleanvEXT = (PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) load(userptr, "glGetLocalConstantBooleanvEXT");
    glad_glGetLocalConstantFloatvEXT = (PFNGLGETLOCALCONSTANTFLOATVEXTPROC) load(userptr, "glGetLocalConstantFloatvEXT");
    glad_glGetLocalConstantIntegervEXT = (PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) load(userptr, "glGetLocalConstantIntegervEXT");
    glad_glGetVariantBooleanvEXT = (PFNGLGETVARIANTBOOLEANVEXTPROC) load(userptr, "glGetVariantBooleanvEXT");
    glad_glGetVariantFloatvEXT = (PFNGLGETVARIANTFLOATVEXTPROC) load(userptr, "glGetVariantFloatvEXT");
    glad_glGetVariantIntegervEXT = (PFNGLGETVARIANTINTEGERVEXTPROC) load(userptr, "glGetVariantIntegervEXT");
    glad_glGetVariantPointervEXT = (PFNGLGETVARIANTPOINTERVEXTPROC) load(userptr, "glGetVariantPointervEXT");
    glad_glInsertComponentEXT = (PFNGLINSERTCOMPONENTEXTPROC) load(userptr, "glInsertComponentEXT");
    glad_glIsVariantEnabledEXT = (PFNGLISVARIANTENABLEDEXTPROC) load(userptr, "glIsVariantEnabledEXT");
    glad_glSetInvariantEXT = (PFNGLSETINVARIANTEXTPROC) load(userptr, "glSetInvariantEXT");
    glad_glSetLocalConstantEXT = (PFNGLSETLOCALCONSTANTEXTPROC) load(userptr, "glSetLocalConstantEXT");
    glad_glShaderOp1EXT = (PFNGLSHADEROP1EXTPROC) load(userptr, "glShaderOp1EXT");
    glad_glShaderOp2EXT = (PFNGLSHADEROP2EXTPROC) load(userptr, "glShaderOp2EXT");
    glad_glShaderOp3EXT = (PFNGLSHADEROP3EXTPROC) load(userptr, "glShaderOp3EXT");
    glad_glSwizzleEXT = (PFNGLSWIZZLEEXTPROC) load(userptr, "glSwizzleEXT");
    glad_glVariantPointerEXT = (PFNGLVARIANTPOINTEREXTPROC) load(userptr, "glVariantPointerEXT");
    glad_glVariantbvEXT = (PFNGLVARIANTBVEXTPROC) load(userptr, "glVariantbvEXT");
    glad_glVariantdvEXT = (PFNGLVARIANTDVEXTPROC) load(userptr, "glVariantdvEXT");
    glad_glVariantfvEXT = (PFNGLVARIANTFVEXTPROC) load(userptr, "glVariantfvEXT");
    glad_glVariantivEXT = (PFNGLVARIANTIVEXTPROC) load(userptr, "glVariantivEXT");
    glad_glVariantsvEXT = (PFNGLVARIANTSVEXTPROC) load(userptr, "glVariantsvEXT");
    glad_glVariantubvEXT = (PFNGLVARIANTUBVEXTPROC) load(userptr, "glVariantubvEXT");
    glad_glVariantuivEXT = (PFNGLVARIANTUIVEXTPROC) load(userptr, "glVariantuivEXT");
    glad_glVariantusvEXT = (PFNGLVARIANTUSVEXTPROC) load(userptr, "glVariantusvEXT");
    glad_glWriteMaskEXT = (PFNGLWRITEMASKEXTPROC) load(userptr, "glWriteMaskEXT");
}
static void glad_gl_load_GL_EXT_vertex_weighting( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_vertex_weighting) return;
    glad_glVertexWeightPointerEXT = (PFNGLVERTEXWEIGHTPOINTEREXTPROC) load(userptr, "glVertexWeightPointerEXT");
    glad_glVertexWeightfEXT = (PFNGLVERTEXWEIGHTFEXTPROC) load(userptr, "glVertexWeightfEXT");
    glad_glVertexWeightfvEXT = (PFNGLVERTEXWEIGHTFVEXTPROC) load(userptr, "glVertexWeightfvEXT");
}
static void glad_gl_load_GL_EXT_win32_keyed_mutex( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_win32_keyed_mutex) return;
    glad_glAcquireKeyedMutexWin32EXT = (PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC) load(userptr, "glAcquireKeyedMutexWin32EXT");
    glad_glReleaseKeyedMutexWin32EXT = (PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC) load(userptr, "glReleaseKeyedMutexWin32EXT");
}
static void glad_gl_load_GL_EXT_window_rectangles( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_window_rectangles) return;
    glad_glWindowRectanglesEXT = (PFNGLWINDOWRECTANGLESEXTPROC) load(userptr, "glWindowRectanglesEXT");
}
static void glad_gl_load_GL_EXT_x11_sync_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_EXT_x11_sync_object) return;
    glad_glImportSyncEXT = (PFNGLIMPORTSYNCEXTPROC) load(userptr, "glImportSyncEXT");
}
static void glad_gl_load_GL_INTEL_framebuffer_CMAA( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_INTEL_framebuffer_CMAA) return;
    glad_glApplyFramebufferAttachmentCMAAINTEL = (PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC) load(userptr, "glApplyFramebufferAttachmentCMAAINTEL");
}
static void glad_gl_load_GL_INTEL_map_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_INTEL_map_texture) return;
    glad_glMapTexture2DINTEL = (PFNGLMAPTEXTURE2DINTELPROC) load(userptr, "glMapTexture2DINTEL");
    glad_glSyncTextureINTEL = (PFNGLSYNCTEXTUREINTELPROC) load(userptr, "glSyncTextureINTEL");
    glad_glUnmapTexture2DINTEL = (PFNGLUNMAPTEXTURE2DINTELPROC) load(userptr, "glUnmapTexture2DINTEL");
}
static void glad_gl_load_GL_INTEL_parallel_arrays( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_INTEL_parallel_arrays) return;
    glad_glColorPointervINTEL = (PFNGLCOLORPOINTERVINTELPROC) load(userptr, "glColorPointervINTEL");
    glad_glNormalPointervINTEL = (PFNGLNORMALPOINTERVINTELPROC) load(userptr, "glNormalPointervINTEL");
    glad_glTexCoordPointervINTEL = (PFNGLTEXCOORDPOINTERVINTELPROC) load(userptr, "glTexCoordPointervINTEL");
    glad_glVertexPointervINTEL = (PFNGLVERTEXPOINTERVINTELPROC) load(userptr, "glVertexPointervINTEL");
}
static void glad_gl_load_GL_INTEL_performance_query( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_INTEL_performance_query) return;
    glad_glBeginPerfQueryINTEL = (PFNGLBEGINPERFQUERYINTELPROC) load(userptr, "glBeginPerfQueryINTEL");
    glad_glCreatePerfQueryINTEL = (PFNGLCREATEPERFQUERYINTELPROC) load(userptr, "glCreatePerfQueryINTEL");
    glad_glDeletePerfQueryINTEL = (PFNGLDELETEPERFQUERYINTELPROC) load(userptr, "glDeletePerfQueryINTEL");
    glad_glEndPerfQueryINTEL = (PFNGLENDPERFQUERYINTELPROC) load(userptr, "glEndPerfQueryINTEL");
    glad_glGetFirstPerfQueryIdINTEL = (PFNGLGETFIRSTPERFQUERYIDINTELPROC) load(userptr, "glGetFirstPerfQueryIdINTEL");
    glad_glGetNextPerfQueryIdINTEL = (PFNGLGETNEXTPERFQUERYIDINTELPROC) load(userptr, "glGetNextPerfQueryIdINTEL");
    glad_glGetPerfCounterInfoINTEL = (PFNGLGETPERFCOUNTERINFOINTELPROC) load(userptr, "glGetPerfCounterInfoINTEL");
    glad_glGetPerfQueryDataINTEL = (PFNGLGETPERFQUERYDATAINTELPROC) load(userptr, "glGetPerfQueryDataINTEL");
    glad_glGetPerfQueryIdByNameINTEL = (PFNGLGETPERFQUERYIDBYNAMEINTELPROC) load(userptr, "glGetPerfQueryIdByNameINTEL");
    glad_glGetPerfQueryInfoINTEL = (PFNGLGETPERFQUERYINFOINTELPROC) load(userptr, "glGetPerfQueryInfoINTEL");
}
static void glad_gl_load_GL_KHR_blend_equation_advanced( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_KHR_blend_equation_advanced) return;
    glad_glBlendBarrier = (PFNGLBLENDBARRIERPROC) load(userptr, "glBlendBarrier");
    glad_glBlendBarrierKHR = (PFNGLBLENDBARRIERKHRPROC) load(userptr, "glBlendBarrierKHR");
}
static void glad_gl_load_GL_KHR_debug( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_KHR_debug) return;
    glad_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC) load(userptr, "glDebugMessageCallback");
    glad_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC) load(userptr, "glDebugMessageControl");
    glad_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC) load(userptr, "glDebugMessageInsert");
    glad_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC) load(userptr, "glGetDebugMessageLog");
    glad_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC) load(userptr, "glGetObjectLabel");
    glad_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC) load(userptr, "glGetObjectPtrLabel");
    glad_glGetPointerv = (PFNGLGETPOINTERVPROC) load(userptr, "glGetPointerv");
    glad_glObjectLabel = (PFNGLOBJECTLABELPROC) load(userptr, "glObjectLabel");
    glad_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC) load(userptr, "glObjectPtrLabel");
    glad_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC) load(userptr, "glPopDebugGroup");
    glad_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC) load(userptr, "glPushDebugGroup");
}
static void glad_gl_load_GL_KHR_parallel_shader_compile( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_KHR_parallel_shader_compile) return;
    glad_glMaxShaderCompilerThreadsKHR = (PFNGLMAXSHADERCOMPILERTHREADSKHRPROC) load(userptr, "glMaxShaderCompilerThreadsKHR");
}
static void glad_gl_load_GL_KHR_robustness( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_KHR_robustness) return;
    glad_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC) load(userptr, "glGetGraphicsResetStatus");
    glad_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC) load(userptr, "glGetnUniformfv");
    glad_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC) load(userptr, "glGetnUniformiv");
    glad_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC) load(userptr, "glGetnUniformuiv");
    glad_glReadnPixels = (PFNGLREADNPIXELSPROC) load(userptr, "glReadnPixels");
}
static void glad_gl_load_GL_MESA_resize_buffers( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_MESA_resize_buffers) return;
    glad_glResizeBuffersMESA = (PFNGLRESIZEBUFFERSMESAPROC) load(userptr, "glResizeBuffersMESA");
}
static void glad_gl_load_GL_MESA_window_pos( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_MESA_window_pos) return;
    glad_glWindowPos2d = (PFNGLWINDOWPOS2DPROC) load(userptr, "glWindowPos2d");
    glad_glWindowPos2dMESA = (PFNGLWINDOWPOS2DMESAPROC) load(userptr, "glWindowPos2dMESA");
    glad_glWindowPos2dv = (PFNGLWINDOWPOS2DVPROC) load(userptr, "glWindowPos2dv");
    glad_glWindowPos2dvMESA = (PFNGLWINDOWPOS2DVMESAPROC) load(userptr, "glWindowPos2dvMESA");
    glad_glWindowPos2f = (PFNGLWINDOWPOS2FPROC) load(userptr, "glWindowPos2f");
    glad_glWindowPos2fMESA = (PFNGLWINDOWPOS2FMESAPROC) load(userptr, "glWindowPos2fMESA");
    glad_glWindowPos2fv = (PFNGLWINDOWPOS2FVPROC) load(userptr, "glWindowPos2fv");
    glad_glWindowPos2fvMESA = (PFNGLWINDOWPOS2FVMESAPROC) load(userptr, "glWindowPos2fvMESA");
    glad_glWindowPos2i = (PFNGLWINDOWPOS2IPROC) load(userptr, "glWindowPos2i");
    glad_glWindowPos2iMESA = (PFNGLWINDOWPOS2IMESAPROC) load(userptr, "glWindowPos2iMESA");
    glad_glWindowPos2iv = (PFNGLWINDOWPOS2IVPROC) load(userptr, "glWindowPos2iv");
    glad_glWindowPos2ivMESA = (PFNGLWINDOWPOS2IVMESAPROC) load(userptr, "glWindowPos2ivMESA");
    glad_glWindowPos2s = (PFNGLWINDOWPOS2SPROC) load(userptr, "glWindowPos2s");
    glad_glWindowPos2sMESA = (PFNGLWINDOWPOS2SMESAPROC) load(userptr, "glWindowPos2sMESA");
    glad_glWindowPos2sv = (PFNGLWINDOWPOS2SVPROC) load(userptr, "glWindowPos2sv");
    glad_glWindowPos2svMESA = (PFNGLWINDOWPOS2SVMESAPROC) load(userptr, "glWindowPos2svMESA");
    glad_glWindowPos3d = (PFNGLWINDOWPOS3DPROC) load(userptr, "glWindowPos3d");
    glad_glWindowPos3dMESA = (PFNGLWINDOWPOS3DMESAPROC) load(userptr, "glWindowPos3dMESA");
    glad_glWindowPos3dv = (PFNGLWINDOWPOS3DVPROC) load(userptr, "glWindowPos3dv");
    glad_glWindowPos3dvMESA = (PFNGLWINDOWPOS3DVMESAPROC) load(userptr, "glWindowPos3dvMESA");
    glad_glWindowPos3f = (PFNGLWINDOWPOS3FPROC) load(userptr, "glWindowPos3f");
    glad_glWindowPos3fMESA = (PFNGLWINDOWPOS3FMESAPROC) load(userptr, "glWindowPos3fMESA");
    glad_glWindowPos3fv = (PFNGLWINDOWPOS3FVPROC) load(userptr, "glWindowPos3fv");
    glad_glWindowPos3fvMESA = (PFNGLWINDOWPOS3FVMESAPROC) load(userptr, "glWindowPos3fvMESA");
    glad_glWindowPos3i = (PFNGLWINDOWPOS3IPROC) load(userptr, "glWindowPos3i");
    glad_glWindowPos3iMESA = (PFNGLWINDOWPOS3IMESAPROC) load(userptr, "glWindowPos3iMESA");
    glad_glWindowPos3iv = (PFNGLWINDOWPOS3IVPROC) load(userptr, "glWindowPos3iv");
    glad_glWindowPos3ivMESA = (PFNGLWINDOWPOS3IVMESAPROC) load(userptr, "glWindowPos3ivMESA");
    glad_glWindowPos3s = (PFNGLWINDOWPOS3SPROC) load(userptr, "glWindowPos3s");
    glad_glWindowPos3sMESA = (PFNGLWINDOWPOS3SMESAPROC) load(userptr, "glWindowPos3sMESA");
    glad_glWindowPos3sv = (PFNGLWINDOWPOS3SVPROC) load(userptr, "glWindowPos3sv");
    glad_glWindowPos3svMESA = (PFNGLWINDOWPOS3SVMESAPROC) load(userptr, "glWindowPos3svMESA");
    glad_glWindowPos4dMESA = (PFNGLWINDOWPOS4DMESAPROC) load(userptr, "glWindowPos4dMESA");
    glad_glWindowPos4dvMESA = (PFNGLWINDOWPOS4DVMESAPROC) load(userptr, "glWindowPos4dvMESA");
    glad_glWindowPos4fMESA = (PFNGLWINDOWPOS4FMESAPROC) load(userptr, "glWindowPos4fMESA");
    glad_glWindowPos4fvMESA = (PFNGLWINDOWPOS4FVMESAPROC) load(userptr, "glWindowPos4fvMESA");
    glad_glWindowPos4iMESA = (PFNGLWINDOWPOS4IMESAPROC) load(userptr, "glWindowPos4iMESA");
    glad_glWindowPos4ivMESA = (PFNGLWINDOWPOS4IVMESAPROC) load(userptr, "glWindowPos4ivMESA");
    glad_glWindowPos4sMESA = (PFNGLWINDOWPOS4SMESAPROC) load(userptr, "glWindowPos4sMESA");
    glad_glWindowPos4svMESA = (PFNGLWINDOWPOS4SVMESAPROC) load(userptr, "glWindowPos4svMESA");
}
static void glad_gl_load_GL_NVX_conditional_render( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NVX_conditional_render) return;
    glad_glBeginConditionalRenderNVX = (PFNGLBEGINCONDITIONALRENDERNVXPROC) load(userptr, "glBeginConditionalRenderNVX");
    glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC) load(userptr, "glEndConditionalRender");
    glad_glEndConditionalRenderNVX = (PFNGLENDCONDITIONALRENDERNVXPROC) load(userptr, "glEndConditionalRenderNVX");
}
static void glad_gl_load_GL_NVX_linked_gpu_multicast( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NVX_linked_gpu_multicast) return;
    glad_glLGPUCopyImageSubDataNVX = (PFNGLLGPUCOPYIMAGESUBDATANVXPROC) load(userptr, "glLGPUCopyImageSubDataNVX");
    glad_glLGPUInterlockNVX = (PFNGLLGPUINTERLOCKNVXPROC) load(userptr, "glLGPUInterlockNVX");
    glad_glLGPUNamedBufferSubDataNVX = (PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC) load(userptr, "glLGPUNamedBufferSubDataNVX");
}
static void glad_gl_load_GL_NV_alpha_to_coverage_dither_control( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_alpha_to_coverage_dither_control) return;
    glad_glAlphaToCoverageDitherControlNV = (PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC) load(userptr, "glAlphaToCoverageDitherControlNV");
}
static void glad_gl_load_GL_NV_bindless_multi_draw_indirect( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_bindless_multi_draw_indirect) return;
    glad_glMultiDrawArraysIndirectBindlessNV = (PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) load(userptr, "glMultiDrawArraysIndirectBindlessNV");
    glad_glMultiDrawElementsIndirectBindlessNV = (PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) load(userptr, "glMultiDrawElementsIndirectBindlessNV");
}
static void glad_gl_load_GL_NV_bindless_multi_draw_indirect_count( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_bindless_multi_draw_indirect_count) return;
    glad_glMultiDrawArraysIndirectBindlessCountNV = (PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC) load(userptr, "glMultiDrawArraysIndirectBindlessCountNV");
    glad_glMultiDrawElementsIndirectBindlessCountNV = (PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC) load(userptr, "glMultiDrawElementsIndirectBindlessCountNV");
}
static void glad_gl_load_GL_NV_bindless_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_bindless_texture) return;
    glad_glGetImageHandleNV = (PFNGLGETIMAGEHANDLENVPROC) load(userptr, "glGetImageHandleNV");
    glad_glGetTextureHandleNV = (PFNGLGETTEXTUREHANDLENVPROC) load(userptr, "glGetTextureHandleNV");
    glad_glGetTextureSamplerHandleNV = (PFNGLGETTEXTURESAMPLERHANDLENVPROC) load(userptr, "glGetTextureSamplerHandleNV");
    glad_glIsImageHandleResidentNV = (PFNGLISIMAGEHANDLERESIDENTNVPROC) load(userptr, "glIsImageHandleResidentNV");
    glad_glIsTextureHandleResidentNV = (PFNGLISTEXTUREHANDLERESIDENTNVPROC) load(userptr, "glIsTextureHandleResidentNV");
    glad_glMakeImageHandleNonResidentNV = (PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) load(userptr, "glMakeImageHandleNonResidentNV");
    glad_glMakeImageHandleResidentNV = (PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) load(userptr, "glMakeImageHandleResidentNV");
    glad_glMakeTextureHandleNonResidentNV = (PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) load(userptr, "glMakeTextureHandleNonResidentNV");
    glad_glMakeTextureHandleResidentNV = (PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) load(userptr, "glMakeTextureHandleResidentNV");
    glad_glProgramUniformHandleui64NV = (PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) load(userptr, "glProgramUniformHandleui64NV");
    glad_glProgramUniformHandleui64vNV = (PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) load(userptr, "glProgramUniformHandleui64vNV");
    glad_glUniformHandleui64NV = (PFNGLUNIFORMHANDLEUI64NVPROC) load(userptr, "glUniformHandleui64NV");
    glad_glUniformHandleui64vNV = (PFNGLUNIFORMHANDLEUI64VNVPROC) load(userptr, "glUniformHandleui64vNV");
}
static void glad_gl_load_GL_NV_blend_equation_advanced( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_blend_equation_advanced) return;
    glad_glBlendBarrier = (PFNGLBLENDBARRIERPROC) load(userptr, "glBlendBarrier");
    glad_glBlendBarrierNV = (PFNGLBLENDBARRIERNVPROC) load(userptr, "glBlendBarrierNV");
    glad_glBlendParameteriNV = (PFNGLBLENDPARAMETERINVPROC) load(userptr, "glBlendParameteriNV");
}
static void glad_gl_load_GL_NV_clip_space_w_scaling( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_clip_space_w_scaling) return;
    glad_glViewportPositionWScaleNV = (PFNGLVIEWPORTPOSITIONWSCALENVPROC) load(userptr, "glViewportPositionWScaleNV");
}
static void glad_gl_load_GL_NV_command_list( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_command_list) return;
    glad_glCallCommandListNV = (PFNGLCALLCOMMANDLISTNVPROC) load(userptr, "glCallCommandListNV");
    glad_glCommandListSegmentsNV = (PFNGLCOMMANDLISTSEGMENTSNVPROC) load(userptr, "glCommandListSegmentsNV");
    glad_glCompileCommandListNV = (PFNGLCOMPILECOMMANDLISTNVPROC) load(userptr, "glCompileCommandListNV");
    glad_glCreateCommandListsNV = (PFNGLCREATECOMMANDLISTSNVPROC) load(userptr, "glCreateCommandListsNV");
    glad_glCreateStatesNV = (PFNGLCREATESTATESNVPROC) load(userptr, "glCreateStatesNV");
    glad_glDeleteCommandListsNV = (PFNGLDELETECOMMANDLISTSNVPROC) load(userptr, "glDeleteCommandListsNV");
    glad_glDeleteStatesNV = (PFNGLDELETESTATESNVPROC) load(userptr, "glDeleteStatesNV");
    glad_glDrawCommandsAddressNV = (PFNGLDRAWCOMMANDSADDRESSNVPROC) load(userptr, "glDrawCommandsAddressNV");
    glad_glDrawCommandsNV = (PFNGLDRAWCOMMANDSNVPROC) load(userptr, "glDrawCommandsNV");
    glad_glDrawCommandsStatesAddressNV = (PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC) load(userptr, "glDrawCommandsStatesAddressNV");
    glad_glDrawCommandsStatesNV = (PFNGLDRAWCOMMANDSSTATESNVPROC) load(userptr, "glDrawCommandsStatesNV");
    glad_glGetCommandHeaderNV = (PFNGLGETCOMMANDHEADERNVPROC) load(userptr, "glGetCommandHeaderNV");
    glad_glGetStageIndexNV = (PFNGLGETSTAGEINDEXNVPROC) load(userptr, "glGetStageIndexNV");
    glad_glIsCommandListNV = (PFNGLISCOMMANDLISTNVPROC) load(userptr, "glIsCommandListNV");
    glad_glIsStateNV = (PFNGLISSTATENVPROC) load(userptr, "glIsStateNV");
    glad_glListDrawCommandsStatesClientNV = (PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC) load(userptr, "glListDrawCommandsStatesClientNV");
    glad_glStateCaptureNV = (PFNGLSTATECAPTURENVPROC) load(userptr, "glStateCaptureNV");
}
static void glad_gl_load_GL_NV_conditional_render( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_conditional_render) return;
    glad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC) load(userptr, "glBeginConditionalRender");
    glad_glBeginConditionalRenderNV = (PFNGLBEGINCONDITIONALRENDERNVPROC) load(userptr, "glBeginConditionalRenderNV");
    glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC) load(userptr, "glEndConditionalRender");
    glad_glEndConditionalRenderNV = (PFNGLENDCONDITIONALRENDERNVPROC) load(userptr, "glEndConditionalRenderNV");
}
static void glad_gl_load_GL_NV_conservative_raster( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_conservative_raster) return;
    glad_glSubpixelPrecisionBiasNV = (PFNGLSUBPIXELPRECISIONBIASNVPROC) load(userptr, "glSubpixelPrecisionBiasNV");
}
static void glad_gl_load_GL_NV_conservative_raster_dilate( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_conservative_raster_dilate) return;
    glad_glConservativeRasterParameterfNV = (PFNGLCONSERVATIVERASTERPARAMETERFNVPROC) load(userptr, "glConservativeRasterParameterfNV");
}
static void glad_gl_load_GL_NV_conservative_raster_pre_snap_triangles( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_conservative_raster_pre_snap_triangles) return;
    glad_glConservativeRasterParameteriNV = (PFNGLCONSERVATIVERASTERPARAMETERINVPROC) load(userptr, "glConservativeRasterParameteriNV");
}
static void glad_gl_load_GL_NV_copy_image( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_copy_image) return;
    glad_glCopyImageSubDataNV = (PFNGLCOPYIMAGESUBDATANVPROC) load(userptr, "glCopyImageSubDataNV");
}
static void glad_gl_load_GL_NV_depth_buffer_float( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_depth_buffer_float) return;
    glad_glClearDepthdNV = (PFNGLCLEARDEPTHDNVPROC) load(userptr, "glClearDepthdNV");
    glad_glDepthBoundsdNV = (PFNGLDEPTHBOUNDSDNVPROC) load(userptr, "glDepthBoundsdNV");
    glad_glDepthRangedNV = (PFNGLDEPTHRANGEDNVPROC) load(userptr, "glDepthRangedNV");
}
static void glad_gl_load_GL_NV_draw_texture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_draw_texture) return;
    glad_glDrawTextureNV = (PFNGLDRAWTEXTURENVPROC) load(userptr, "glDrawTextureNV");
}
static void glad_gl_load_GL_NV_draw_vulkan_image( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_draw_vulkan_image) return;
    glad_glDrawVkImageNV = (PFNGLDRAWVKIMAGENVPROC) load(userptr, "glDrawVkImageNV");
    glad_glGetVkProcAddrNV = (PFNGLGETVKPROCADDRNVPROC) load(userptr, "glGetVkProcAddrNV");
    glad_glSignalVkFenceNV = (PFNGLSIGNALVKFENCENVPROC) load(userptr, "glSignalVkFenceNV");
    glad_glSignalVkSemaphoreNV = (PFNGLSIGNALVKSEMAPHORENVPROC) load(userptr, "glSignalVkSemaphoreNV");
    glad_glWaitVkSemaphoreNV = (PFNGLWAITVKSEMAPHORENVPROC) load(userptr, "glWaitVkSemaphoreNV");
}
static void glad_gl_load_GL_NV_evaluators( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_evaluators) return;
    glad_glEvalMapsNV = (PFNGLEVALMAPSNVPROC) load(userptr, "glEvalMapsNV");
    glad_glGetMapAttribParameterfvNV = (PFNGLGETMAPATTRIBPARAMETERFVNVPROC) load(userptr, "glGetMapAttribParameterfvNV");
    glad_glGetMapAttribParameterivNV = (PFNGLGETMAPATTRIBPARAMETERIVNVPROC) load(userptr, "glGetMapAttribParameterivNV");
    glad_glGetMapControlPointsNV = (PFNGLGETMAPCONTROLPOINTSNVPROC) load(userptr, "glGetMapControlPointsNV");
    glad_glGetMapParameterfvNV = (PFNGLGETMAPPARAMETERFVNVPROC) load(userptr, "glGetMapParameterfvNV");
    glad_glGetMapParameterivNV = (PFNGLGETMAPPARAMETERIVNVPROC) load(userptr, "glGetMapParameterivNV");
    glad_glMapControlPointsNV = (PFNGLMAPCONTROLPOINTSNVPROC) load(userptr, "glMapControlPointsNV");
    glad_glMapParameterfvNV = (PFNGLMAPPARAMETERFVNVPROC) load(userptr, "glMapParameterfvNV");
    glad_glMapParameterivNV = (PFNGLMAPPARAMETERIVNVPROC) load(userptr, "glMapParameterivNV");
}
static void glad_gl_load_GL_NV_explicit_multisample( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_explicit_multisample) return;
    glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) load(userptr, "glGetMultisamplefv");
    glad_glGetMultisamplefvNV = (PFNGLGETMULTISAMPLEFVNVPROC) load(userptr, "glGetMultisamplefvNV");
    glad_glSampleMaskIndexedNV = (PFNGLSAMPLEMASKINDEXEDNVPROC) load(userptr, "glSampleMaskIndexedNV");
    glad_glTexRenderbufferNV = (PFNGLTEXRENDERBUFFERNVPROC) load(userptr, "glTexRenderbufferNV");
}
static void glad_gl_load_GL_NV_fence( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_fence) return;
    glad_glDeleteFencesNV = (PFNGLDELETEFENCESNVPROC) load(userptr, "glDeleteFencesNV");
    glad_glFinishFenceNV = (PFNGLFINISHFENCENVPROC) load(userptr, "glFinishFenceNV");
    glad_glGenFencesNV = (PFNGLGENFENCESNVPROC) load(userptr, "glGenFencesNV");
    glad_glGetFenceivNV = (PFNGLGETFENCEIVNVPROC) load(userptr, "glGetFenceivNV");
    glad_glIsFenceNV = (PFNGLISFENCENVPROC) load(userptr, "glIsFenceNV");
    glad_glSetFenceNV = (PFNGLSETFENCENVPROC) load(userptr, "glSetFenceNV");
    glad_glTestFenceNV = (PFNGLTESTFENCENVPROC) load(userptr, "glTestFenceNV");
}
static void glad_gl_load_GL_NV_fragment_coverage_to_color( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_fragment_coverage_to_color) return;
    glad_glFragmentCoverageColorNV = (PFNGLFRAGMENTCOVERAGECOLORNVPROC) load(userptr, "glFragmentCoverageColorNV");
}
static void glad_gl_load_GL_NV_fragment_program( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_fragment_program) return;
    glad_glGetProgramNamedParameterdvNV = (PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) load(userptr, "glGetProgramNamedParameterdvNV");
    glad_glGetProgramNamedParameterfvNV = (PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) load(userptr, "glGetProgramNamedParameterfvNV");
    glad_glProgramNamedParameter4dNV = (PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) load(userptr, "glProgramNamedParameter4dNV");
    glad_glProgramNamedParameter4dvNV = (PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) load(userptr, "glProgramNamedParameter4dvNV");
    glad_glProgramNamedParameter4fNV = (PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) load(userptr, "glProgramNamedParameter4fNV");
    glad_glProgramNamedParameter4fvNV = (PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) load(userptr, "glProgramNamedParameter4fvNV");
}
static void glad_gl_load_GL_NV_framebuffer_mixed_samples( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_framebuffer_mixed_samples) return;
    glad_glCoverageModulationNV = (PFNGLCOVERAGEMODULATIONNVPROC) load(userptr, "glCoverageModulationNV");
    glad_glCoverageModulationTableNV = (PFNGLCOVERAGEMODULATIONTABLENVPROC) load(userptr, "glCoverageModulationTableNV");
    glad_glGetCoverageModulationTableNV = (PFNGLGETCOVERAGEMODULATIONTABLENVPROC) load(userptr, "glGetCoverageModulationTableNV");
    glad_glRasterSamplesEXT = (PFNGLRASTERSAMPLESEXTPROC) load(userptr, "glRasterSamplesEXT");
}
static void glad_gl_load_GL_NV_framebuffer_multisample_coverage( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_framebuffer_multisample_coverage) return;
    glad_glRenderbufferStorageMultisampleCoverageNV = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) load(userptr, "glRenderbufferStorageMultisampleCoverageNV");
}
static void glad_gl_load_GL_NV_geometry_program4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_geometry_program4) return;
    glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) load(userptr, "glFramebufferTexture");
    glad_glFramebufferTextureEXT = (PFNGLFRAMEBUFFERTEXTUREEXTPROC) load(userptr, "glFramebufferTextureEXT");
    glad_glFramebufferTextureFaceARB = (PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) load(userptr, "glFramebufferTextureFaceARB");
    glad_glFramebufferTextureFaceEXT = (PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) load(userptr, "glFramebufferTextureFaceEXT");
    glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) load(userptr, "glFramebufferTextureLayer");
    glad_glFramebufferTextureLayerEXT = (PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) load(userptr, "glFramebufferTextureLayerEXT");
    glad_glProgramVertexLimitNV = (PFNGLPROGRAMVERTEXLIMITNVPROC) load(userptr, "glProgramVertexLimitNV");
}
static void glad_gl_load_GL_NV_gpu_multicast( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_gpu_multicast) return;
    glad_glMulticastBarrierNV = (PFNGLMULTICASTBARRIERNVPROC) load(userptr, "glMulticastBarrierNV");
    glad_glMulticastBlitFramebufferNV = (PFNGLMULTICASTBLITFRAMEBUFFERNVPROC) load(userptr, "glMulticastBlitFramebufferNV");
    glad_glMulticastBufferSubDataNV = (PFNGLMULTICASTBUFFERSUBDATANVPROC) load(userptr, "glMulticastBufferSubDataNV");
    glad_glMulticastCopyBufferSubDataNV = (PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC) load(userptr, "glMulticastCopyBufferSubDataNV");
    glad_glMulticastCopyImageSubDataNV = (PFNGLMULTICASTCOPYIMAGESUBDATANVPROC) load(userptr, "glMulticastCopyImageSubDataNV");
    glad_glMulticastFramebufferSampleLocationsfvNV = (PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) load(userptr, "glMulticastFramebufferSampleLocationsfvNV");
    glad_glMulticastGetQueryObjecti64vNV = (PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC) load(userptr, "glMulticastGetQueryObjecti64vNV");
    glad_glMulticastGetQueryObjectivNV = (PFNGLMULTICASTGETQUERYOBJECTIVNVPROC) load(userptr, "glMulticastGetQueryObjectivNV");
    glad_glMulticastGetQueryObjectui64vNV = (PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC) load(userptr, "glMulticastGetQueryObjectui64vNV");
    glad_glMulticastGetQueryObjectuivNV = (PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC) load(userptr, "glMulticastGetQueryObjectuivNV");
    glad_glMulticastWaitSyncNV = (PFNGLMULTICASTWAITSYNCNVPROC) load(userptr, "glMulticastWaitSyncNV");
    glad_glRenderGpuMaskNV = (PFNGLRENDERGPUMASKNVPROC) load(userptr, "glRenderGpuMaskNV");
}
static void glad_gl_load_GL_NV_gpu_program4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_gpu_program4) return;
    glad_glGetProgramEnvParameterIivNV = (PFNGLGETPROGRAMENVPARAMETERIIVNVPROC) load(userptr, "glGetProgramEnvParameterIivNV");
    glad_glGetProgramEnvParameterIuivNV = (PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC) load(userptr, "glGetProgramEnvParameterIuivNV");
    glad_glGetProgramLocalParameterIivNV = (PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC) load(userptr, "glGetProgramLocalParameterIivNV");
    glad_glGetProgramLocalParameterIuivNV = (PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC) load(userptr, "glGetProgramLocalParameterIuivNV");
    glad_glProgramEnvParameterI4iNV = (PFNGLPROGRAMENVPARAMETERI4INVPROC) load(userptr, "glProgramEnvParameterI4iNV");
    glad_glProgramEnvParameterI4ivNV = (PFNGLPROGRAMENVPARAMETERI4IVNVPROC) load(userptr, "glProgramEnvParameterI4ivNV");
    glad_glProgramEnvParameterI4uiNV = (PFNGLPROGRAMENVPARAMETERI4UINVPROC) load(userptr, "glProgramEnvParameterI4uiNV");
    glad_glProgramEnvParameterI4uivNV = (PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) load(userptr, "glProgramEnvParameterI4uivNV");
    glad_glProgramEnvParametersI4ivNV = (PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) load(userptr, "glProgramEnvParametersI4ivNV");
    glad_glProgramEnvParametersI4uivNV = (PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) load(userptr, "glProgramEnvParametersI4uivNV");
    glad_glProgramLocalParameterI4iNV = (PFNGLPROGRAMLOCALPARAMETERI4INVPROC) load(userptr, "glProgramLocalParameterI4iNV");
    glad_glProgramLocalParameterI4ivNV = (PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) load(userptr, "glProgramLocalParameterI4ivNV");
    glad_glProgramLocalParameterI4uiNV = (PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) load(userptr, "glProgramLocalParameterI4uiNV");
    glad_glProgramLocalParameterI4uivNV = (PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) load(userptr, "glProgramLocalParameterI4uivNV");
    glad_glProgramLocalParametersI4ivNV = (PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) load(userptr, "glProgramLocalParametersI4ivNV");
    glad_glProgramLocalParametersI4uivNV = (PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) load(userptr, "glProgramLocalParametersI4uivNV");
}
static void glad_gl_load_GL_NV_gpu_program5( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_gpu_program5) return;
    glad_glGetProgramSubroutineParameteruivNV = (PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC) load(userptr, "glGetProgramSubroutineParameteruivNV");
    glad_glProgramSubroutineParametersuivNV = (PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC) load(userptr, "glProgramSubroutineParametersuivNV");
}
static void glad_gl_load_GL_NV_gpu_shader5( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_gpu_shader5) return;
    glad_glGetUniformi64vNV = (PFNGLGETUNIFORMI64VNVPROC) load(userptr, "glGetUniformi64vNV");
    glad_glProgramUniform1i64NV = (PFNGLPROGRAMUNIFORM1I64NVPROC) load(userptr, "glProgramUniform1i64NV");
    glad_glProgramUniform1i64vNV = (PFNGLPROGRAMUNIFORM1I64VNVPROC) load(userptr, "glProgramUniform1i64vNV");
    glad_glProgramUniform1ui64NV = (PFNGLPROGRAMUNIFORM1UI64NVPROC) load(userptr, "glProgramUniform1ui64NV");
    glad_glProgramUniform1ui64vNV = (PFNGLPROGRAMUNIFORM1UI64VNVPROC) load(userptr, "glProgramUniform1ui64vNV");
    glad_glProgramUniform2i64NV = (PFNGLPROGRAMUNIFORM2I64NVPROC) load(userptr, "glProgramUniform2i64NV");
    glad_glProgramUniform2i64vNV = (PFNGLPROGRAMUNIFORM2I64VNVPROC) load(userptr, "glProgramUniform2i64vNV");
    glad_glProgramUniform2ui64NV = (PFNGLPROGRAMUNIFORM2UI64NVPROC) load(userptr, "glProgramUniform2ui64NV");
    glad_glProgramUniform2ui64vNV = (PFNGLPROGRAMUNIFORM2UI64VNVPROC) load(userptr, "glProgramUniform2ui64vNV");
    glad_glProgramUniform3i64NV = (PFNGLPROGRAMUNIFORM3I64NVPROC) load(userptr, "glProgramUniform3i64NV");
    glad_glProgramUniform3i64vNV = (PFNGLPROGRAMUNIFORM3I64VNVPROC) load(userptr, "glProgramUniform3i64vNV");
    glad_glProgramUniform3ui64NV = (PFNGLPROGRAMUNIFORM3UI64NVPROC) load(userptr, "glProgramUniform3ui64NV");
    glad_glProgramUniform3ui64vNV = (PFNGLPROGRAMUNIFORM3UI64VNVPROC) load(userptr, "glProgramUniform3ui64vNV");
    glad_glProgramUniform4i64NV = (PFNGLPROGRAMUNIFORM4I64NVPROC) load(userptr, "glProgramUniform4i64NV");
    glad_glProgramUniform4i64vNV = (PFNGLPROGRAMUNIFORM4I64VNVPROC) load(userptr, "glProgramUniform4i64vNV");
    glad_glProgramUniform4ui64NV = (PFNGLPROGRAMUNIFORM4UI64NVPROC) load(userptr, "glProgramUniform4ui64NV");
    glad_glProgramUniform4ui64vNV = (PFNGLPROGRAMUNIFORM4UI64VNVPROC) load(userptr, "glProgramUniform4ui64vNV");
    glad_glUniform1i64NV = (PFNGLUNIFORM1I64NVPROC) load(userptr, "glUniform1i64NV");
    glad_glUniform1i64vNV = (PFNGLUNIFORM1I64VNVPROC) load(userptr, "glUniform1i64vNV");
    glad_glUniform1ui64NV = (PFNGLUNIFORM1UI64NVPROC) load(userptr, "glUniform1ui64NV");
    glad_glUniform1ui64vNV = (PFNGLUNIFORM1UI64VNVPROC) load(userptr, "glUniform1ui64vNV");
    glad_glUniform2i64NV = (PFNGLUNIFORM2I64NVPROC) load(userptr, "glUniform2i64NV");
    glad_glUniform2i64vNV = (PFNGLUNIFORM2I64VNVPROC) load(userptr, "glUniform2i64vNV");
    glad_glUniform2ui64NV = (PFNGLUNIFORM2UI64NVPROC) load(userptr, "glUniform2ui64NV");
    glad_glUniform2ui64vNV = (PFNGLUNIFORM2UI64VNVPROC) load(userptr, "glUniform2ui64vNV");
    glad_glUniform3i64NV = (PFNGLUNIFORM3I64NVPROC) load(userptr, "glUniform3i64NV");
    glad_glUniform3i64vNV = (PFNGLUNIFORM3I64VNVPROC) load(userptr, "glUniform3i64vNV");
    glad_glUniform3ui64NV = (PFNGLUNIFORM3UI64NVPROC) load(userptr, "glUniform3ui64NV");
    glad_glUniform3ui64vNV = (PFNGLUNIFORM3UI64VNVPROC) load(userptr, "glUniform3ui64vNV");
    glad_glUniform4i64NV = (PFNGLUNIFORM4I64NVPROC) load(userptr, "glUniform4i64NV");
    glad_glUniform4i64vNV = (PFNGLUNIFORM4I64VNVPROC) load(userptr, "glUniform4i64vNV");
    glad_glUniform4ui64NV = (PFNGLUNIFORM4UI64NVPROC) load(userptr, "glUniform4ui64NV");
    glad_glUniform4ui64vNV = (PFNGLUNIFORM4UI64VNVPROC) load(userptr, "glUniform4ui64vNV");
}
static void glad_gl_load_GL_NV_half_float( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_half_float) return;
    glad_glColor3hNV = (PFNGLCOLOR3HNVPROC) load(userptr, "glColor3hNV");
    glad_glColor3hvNV = (PFNGLCOLOR3HVNVPROC) load(userptr, "glColor3hvNV");
    glad_glColor4hNV = (PFNGLCOLOR4HNVPROC) load(userptr, "glColor4hNV");
    glad_glColor4hvNV = (PFNGLCOLOR4HVNVPROC) load(userptr, "glColor4hvNV");
    glad_glFogCoordhNV = (PFNGLFOGCOORDHNVPROC) load(userptr, "glFogCoordhNV");
    glad_glFogCoordhvNV = (PFNGLFOGCOORDHVNVPROC) load(userptr, "glFogCoordhvNV");
    glad_glMultiTexCoord1hNV = (PFNGLMULTITEXCOORD1HNVPROC) load(userptr, "glMultiTexCoord1hNV");
    glad_glMultiTexCoord1hvNV = (PFNGLMULTITEXCOORD1HVNVPROC) load(userptr, "glMultiTexCoord1hvNV");
    glad_glMultiTexCoord2hNV = (PFNGLMULTITEXCOORD2HNVPROC) load(userptr, "glMultiTexCoord2hNV");
    glad_glMultiTexCoord2hvNV = (PFNGLMULTITEXCOORD2HVNVPROC) load(userptr, "glMultiTexCoord2hvNV");
    glad_glMultiTexCoord3hNV = (PFNGLMULTITEXCOORD3HNVPROC) load(userptr, "glMultiTexCoord3hNV");
    glad_glMultiTexCoord3hvNV = (PFNGLMULTITEXCOORD3HVNVPROC) load(userptr, "glMultiTexCoord3hvNV");
    glad_glMultiTexCoord4hNV = (PFNGLMULTITEXCOORD4HNVPROC) load(userptr, "glMultiTexCoord4hNV");
    glad_glMultiTexCoord4hvNV = (PFNGLMULTITEXCOORD4HVNVPROC) load(userptr, "glMultiTexCoord4hvNV");
    glad_glNormal3hNV = (PFNGLNORMAL3HNVPROC) load(userptr, "glNormal3hNV");
    glad_glNormal3hvNV = (PFNGLNORMAL3HVNVPROC) load(userptr, "glNormal3hvNV");
    glad_glSecondaryColor3hNV = (PFNGLSECONDARYCOLOR3HNVPROC) load(userptr, "glSecondaryColor3hNV");
    glad_glSecondaryColor3hvNV = (PFNGLSECONDARYCOLOR3HVNVPROC) load(userptr, "glSecondaryColor3hvNV");
    glad_glTexCoord1hNV = (PFNGLTEXCOORD1HNVPROC) load(userptr, "glTexCoord1hNV");
    glad_glTexCoord1hvNV = (PFNGLTEXCOORD1HVNVPROC) load(userptr, "glTexCoord1hvNV");
    glad_glTexCoord2hNV = (PFNGLTEXCOORD2HNVPROC) load(userptr, "glTexCoord2hNV");
    glad_glTexCoord2hvNV = (PFNGLTEXCOORD2HVNVPROC) load(userptr, "glTexCoord2hvNV");
    glad_glTexCoord3hNV = (PFNGLTEXCOORD3HNVPROC) load(userptr, "glTexCoord3hNV");
    glad_glTexCoord3hvNV = (PFNGLTEXCOORD3HVNVPROC) load(userptr, "glTexCoord3hvNV");
    glad_glTexCoord4hNV = (PFNGLTEXCOORD4HNVPROC) load(userptr, "glTexCoord4hNV");
    glad_glTexCoord4hvNV = (PFNGLTEXCOORD4HVNVPROC) load(userptr, "glTexCoord4hvNV");
    glad_glVertex2hNV = (PFNGLVERTEX2HNVPROC) load(userptr, "glVertex2hNV");
    glad_glVertex2hvNV = (PFNGLVERTEX2HVNVPROC) load(userptr, "glVertex2hvNV");
    glad_glVertex3hNV = (PFNGLVERTEX3HNVPROC) load(userptr, "glVertex3hNV");
    glad_glVertex3hvNV = (PFNGLVERTEX3HVNVPROC) load(userptr, "glVertex3hvNV");
    glad_glVertex4hNV = (PFNGLVERTEX4HNVPROC) load(userptr, "glVertex4hNV");
    glad_glVertex4hvNV = (PFNGLVERTEX4HVNVPROC) load(userptr, "glVertex4hvNV");
    glad_glVertexAttrib1hNV = (PFNGLVERTEXATTRIB1HNVPROC) load(userptr, "glVertexAttrib1hNV");
    glad_glVertexAttrib1hvNV = (PFNGLVERTEXATTRIB1HVNVPROC) load(userptr, "glVertexAttrib1hvNV");
    glad_glVertexAttrib2hNV = (PFNGLVERTEXATTRIB2HNVPROC) load(userptr, "glVertexAttrib2hNV");
    glad_glVertexAttrib2hvNV = (PFNGLVERTEXATTRIB2HVNVPROC) load(userptr, "glVertexAttrib2hvNV");
    glad_glVertexAttrib3hNV = (PFNGLVERTEXATTRIB3HNVPROC) load(userptr, "glVertexAttrib3hNV");
    glad_glVertexAttrib3hvNV = (PFNGLVERTEXATTRIB3HVNVPROC) load(userptr, "glVertexAttrib3hvNV");
    glad_glVertexAttrib4hNV = (PFNGLVERTEXATTRIB4HNVPROC) load(userptr, "glVertexAttrib4hNV");
    glad_glVertexAttrib4hvNV = (PFNGLVERTEXATTRIB4HVNVPROC) load(userptr, "glVertexAttrib4hvNV");
    glad_glVertexAttribs1hvNV = (PFNGLVERTEXATTRIBS1HVNVPROC) load(userptr, "glVertexAttribs1hvNV");
    glad_glVertexAttribs2hvNV = (PFNGLVERTEXATTRIBS2HVNVPROC) load(userptr, "glVertexAttribs2hvNV");
    glad_glVertexAttribs3hvNV = (PFNGLVERTEXATTRIBS3HVNVPROC) load(userptr, "glVertexAttribs3hvNV");
    glad_glVertexAttribs4hvNV = (PFNGLVERTEXATTRIBS4HVNVPROC) load(userptr, "glVertexAttribs4hvNV");
    glad_glVertexWeighthNV = (PFNGLVERTEXWEIGHTHNVPROC) load(userptr, "glVertexWeighthNV");
    glad_glVertexWeighthvNV = (PFNGLVERTEXWEIGHTHVNVPROC) load(userptr, "glVertexWeighthvNV");
}
static void glad_gl_load_GL_NV_internalformat_sample_query( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_internalformat_sample_query) return;
    glad_glGetInternalformatSampleivNV = (PFNGLGETINTERNALFORMATSAMPLEIVNVPROC) load(userptr, "glGetInternalformatSampleivNV");
}
static void glad_gl_load_GL_NV_occlusion_query( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_occlusion_query) return;
    glad_glBeginOcclusionQueryNV = (PFNGLBEGINOCCLUSIONQUERYNVPROC) load(userptr, "glBeginOcclusionQueryNV");
    glad_glDeleteOcclusionQueriesNV = (PFNGLDELETEOCCLUSIONQUERIESNVPROC) load(userptr, "glDeleteOcclusionQueriesNV");
    glad_glEndOcclusionQueryNV = (PFNGLENDOCCLUSIONQUERYNVPROC) load(userptr, "glEndOcclusionQueryNV");
    glad_glGenOcclusionQueriesNV = (PFNGLGENOCCLUSIONQUERIESNVPROC) load(userptr, "glGenOcclusionQueriesNV");
    glad_glGetOcclusionQueryivNV = (PFNGLGETOCCLUSIONQUERYIVNVPROC) load(userptr, "glGetOcclusionQueryivNV");
    glad_glGetOcclusionQueryuivNV = (PFNGLGETOCCLUSIONQUERYUIVNVPROC) load(userptr, "glGetOcclusionQueryuivNV");
    glad_glIsOcclusionQueryNV = (PFNGLISOCCLUSIONQUERYNVPROC) load(userptr, "glIsOcclusionQueryNV");
}
static void glad_gl_load_GL_NV_parameter_buffer_object( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_parameter_buffer_object) return;
    glad_glProgramBufferParametersIivNV = (PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) load(userptr, "glProgramBufferParametersIivNV");
    glad_glProgramBufferParametersIuivNV = (PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) load(userptr, "glProgramBufferParametersIuivNV");
    glad_glProgramBufferParametersfvNV = (PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) load(userptr, "glProgramBufferParametersfvNV");
}
static void glad_gl_load_GL_NV_path_rendering( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_path_rendering) return;
    glad_glCopyPathNV = (PFNGLCOPYPATHNVPROC) load(userptr, "glCopyPathNV");
    glad_glCoverFillPathInstancedNV = (PFNGLCOVERFILLPATHINSTANCEDNVPROC) load(userptr, "glCoverFillPathInstancedNV");
    glad_glCoverFillPathNV = (PFNGLCOVERFILLPATHNVPROC) load(userptr, "glCoverFillPathNV");
    glad_glCoverStrokePathInstancedNV = (PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) load(userptr, "glCoverStrokePathInstancedNV");
    glad_glCoverStrokePathNV = (PFNGLCOVERSTROKEPATHNVPROC) load(userptr, "glCoverStrokePathNV");
    glad_glDeletePathsNV = (PFNGLDELETEPATHSNVPROC) load(userptr, "glDeletePathsNV");
    glad_glGenPathsNV = (PFNGLGENPATHSNVPROC) load(userptr, "glGenPathsNV");
    glad_glGetPathCommandsNV = (PFNGLGETPATHCOMMANDSNVPROC) load(userptr, "glGetPathCommandsNV");
    glad_glGetPathCoordsNV = (PFNGLGETPATHCOORDSNVPROC) load(userptr, "glGetPathCoordsNV");
    glad_glGetPathDashArrayNV = (PFNGLGETPATHDASHARRAYNVPROC) load(userptr, "glGetPathDashArrayNV");
    glad_glGetPathLengthNV = (PFNGLGETPATHLENGTHNVPROC) load(userptr, "glGetPathLengthNV");
    glad_glGetPathMetricRangeNV = (PFNGLGETPATHMETRICRANGENVPROC) load(userptr, "glGetPathMetricRangeNV");
    glad_glGetPathMetricsNV = (PFNGLGETPATHMETRICSNVPROC) load(userptr, "glGetPathMetricsNV");
    glad_glGetPathParameterfvNV = (PFNGLGETPATHPARAMETERFVNVPROC) load(userptr, "glGetPathParameterfvNV");
    glad_glGetPathParameterivNV = (PFNGLGETPATHPARAMETERIVNVPROC) load(userptr, "glGetPathParameterivNV");
    glad_glGetPathSpacingNV = (PFNGLGETPATHSPACINGNVPROC) load(userptr, "glGetPathSpacingNV");
    glad_glGetProgramResourcefvNV = (PFNGLGETPROGRAMRESOURCEFVNVPROC) load(userptr, "glGetProgramResourcefvNV");
    glad_glInterpolatePathsNV = (PFNGLINTERPOLATEPATHSNVPROC) load(userptr, "glInterpolatePathsNV");
    glad_glIsPathNV = (PFNGLISPATHNVPROC) load(userptr, "glIsPathNV");
    glad_glIsPointInFillPathNV = (PFNGLISPOINTINFILLPATHNVPROC) load(userptr, "glIsPointInFillPathNV");
    glad_glIsPointInStrokePathNV = (PFNGLISPOINTINSTROKEPATHNVPROC) load(userptr, "glIsPointInStrokePathNV");
    glad_glMatrixFrustumEXT = (PFNGLMATRIXFRUSTUMEXTPROC) load(userptr, "glMatrixFrustumEXT");
    glad_glMatrixLoad3x2fNV = (PFNGLMATRIXLOAD3X2FNVPROC) load(userptr, "glMatrixLoad3x2fNV");
    glad_glMatrixLoad3x3fNV = (PFNGLMATRIXLOAD3X3FNVPROC) load(userptr, "glMatrixLoad3x3fNV");
    glad_glMatrixLoadIdentityEXT = (PFNGLMATRIXLOADIDENTITYEXTPROC) load(userptr, "glMatrixLoadIdentityEXT");
    glad_glMatrixLoadTranspose3x3fNV = (PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC) load(userptr, "glMatrixLoadTranspose3x3fNV");
    glad_glMatrixLoadTransposedEXT = (PFNGLMATRIXLOADTRANSPOSEDEXTPROC) load(userptr, "glMatrixLoadTransposedEXT");
    glad_glMatrixLoadTransposefEXT = (PFNGLMATRIXLOADTRANSPOSEFEXTPROC) load(userptr, "glMatrixLoadTransposefEXT");
    glad_glMatrixLoaddEXT = (PFNGLMATRIXLOADDEXTPROC) load(userptr, "glMatrixLoaddEXT");
    glad_glMatrixLoadfEXT = (PFNGLMATRIXLOADFEXTPROC) load(userptr, "glMatrixLoadfEXT");
    glad_glMatrixMult3x2fNV = (PFNGLMATRIXMULT3X2FNVPROC) load(userptr, "glMatrixMult3x2fNV");
    glad_glMatrixMult3x3fNV = (PFNGLMATRIXMULT3X3FNVPROC) load(userptr, "glMatrixMult3x3fNV");
    glad_glMatrixMultTranspose3x3fNV = (PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC) load(userptr, "glMatrixMultTranspose3x3fNV");
    glad_glMatrixMultTransposedEXT = (PFNGLMATRIXMULTTRANSPOSEDEXTPROC) load(userptr, "glMatrixMultTransposedEXT");
    glad_glMatrixMultTransposefEXT = (PFNGLMATRIXMULTTRANSPOSEFEXTPROC) load(userptr, "glMatrixMultTransposefEXT");
    glad_glMatrixMultdEXT = (PFNGLMATRIXMULTDEXTPROC) load(userptr, "glMatrixMultdEXT");
    glad_glMatrixMultfEXT = (PFNGLMATRIXMULTFEXTPROC) load(userptr, "glMatrixMultfEXT");
    glad_glMatrixOrthoEXT = (PFNGLMATRIXORTHOEXTPROC) load(userptr, "glMatrixOrthoEXT");
    glad_glMatrixPopEXT = (PFNGLMATRIXPOPEXTPROC) load(userptr, "glMatrixPopEXT");
    glad_glMatrixPushEXT = (PFNGLMATRIXPUSHEXTPROC) load(userptr, "glMatrixPushEXT");
    glad_glMatrixRotatedEXT = (PFNGLMATRIXROTATEDEXTPROC) load(userptr, "glMatrixRotatedEXT");
    glad_glMatrixRotatefEXT = (PFNGLMATRIXROTATEFEXTPROC) load(userptr, "glMatrixRotatefEXT");
    glad_glMatrixScaledEXT = (PFNGLMATRIXSCALEDEXTPROC) load(userptr, "glMatrixScaledEXT");
    glad_glMatrixScalefEXT = (PFNGLMATRIXSCALEFEXTPROC) load(userptr, "glMatrixScalefEXT");
    glad_glMatrixTranslatedEXT = (PFNGLMATRIXTRANSLATEDEXTPROC) load(userptr, "glMatrixTranslatedEXT");
    glad_glMatrixTranslatefEXT = (PFNGLMATRIXTRANSLATEFEXTPROC) load(userptr, "glMatrixTranslatefEXT");
    glad_glPathCommandsNV = (PFNGLPATHCOMMANDSNVPROC) load(userptr, "glPathCommandsNV");
    glad_glPathCoordsNV = (PFNGLPATHCOORDSNVPROC) load(userptr, "glPathCoordsNV");
    glad_glPathCoverDepthFuncNV = (PFNGLPATHCOVERDEPTHFUNCNVPROC) load(userptr, "glPathCoverDepthFuncNV");
    glad_glPathDashArrayNV = (PFNGLPATHDASHARRAYNVPROC) load(userptr, "glPathDashArrayNV");
    glad_glPathGlyphIndexArrayNV = (PFNGLPATHGLYPHINDEXARRAYNVPROC) load(userptr, "glPathGlyphIndexArrayNV");
    glad_glPathGlyphIndexRangeNV = (PFNGLPATHGLYPHINDEXRANGENVPROC) load(userptr, "glPathGlyphIndexRangeNV");
    glad_glPathGlyphRangeNV = (PFNGLPATHGLYPHRANGENVPROC) load(userptr, "glPathGlyphRangeNV");
    glad_glPathGlyphsNV = (PFNGLPATHGLYPHSNVPROC) load(userptr, "glPathGlyphsNV");
    glad_glPathMemoryGlyphIndexArrayNV = (PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC) load(userptr, "glPathMemoryGlyphIndexArrayNV");
    glad_glPathParameterfNV = (PFNGLPATHPARAMETERFNVPROC) load(userptr, "glPathParameterfNV");
    glad_glPathParameterfvNV = (PFNGLPATHPARAMETERFVNVPROC) load(userptr, "glPathParameterfvNV");
    glad_glPathParameteriNV = (PFNGLPATHPARAMETERINVPROC) load(userptr, "glPathParameteriNV");
    glad_glPathParameterivNV = (PFNGLPATHPARAMETERIVNVPROC) load(userptr, "glPathParameterivNV");
    glad_glPathStencilDepthOffsetNV = (PFNGLPATHSTENCILDEPTHOFFSETNVPROC) load(userptr, "glPathStencilDepthOffsetNV");
    glad_glPathStencilFuncNV = (PFNGLPATHSTENCILFUNCNVPROC) load(userptr, "glPathStencilFuncNV");
    glad_glPathStringNV = (PFNGLPATHSTRINGNVPROC) load(userptr, "glPathStringNV");
    glad_glPathSubCommandsNV = (PFNGLPATHSUBCOMMANDSNVPROC) load(userptr, "glPathSubCommandsNV");
    glad_glPathSubCoordsNV = (PFNGLPATHSUBCOORDSNVPROC) load(userptr, "glPathSubCoordsNV");
    glad_glPointAlongPathNV = (PFNGLPOINTALONGPATHNVPROC) load(userptr, "glPointAlongPathNV");
    glad_glProgramPathFragmentInputGenNV = (PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC) load(userptr, "glProgramPathFragmentInputGenNV");
    glad_glStencilFillPathInstancedNV = (PFNGLSTENCILFILLPATHINSTANCEDNVPROC) load(userptr, "glStencilFillPathInstancedNV");
    glad_glStencilFillPathNV = (PFNGLSTENCILFILLPATHNVPROC) load(userptr, "glStencilFillPathNV");
    glad_glStencilStrokePathInstancedNV = (PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) load(userptr, "glStencilStrokePathInstancedNV");
    glad_glStencilStrokePathNV = (PFNGLSTENCILSTROKEPATHNVPROC) load(userptr, "glStencilStrokePathNV");
    glad_glStencilThenCoverFillPathInstancedNV = (PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC) load(userptr, "glStencilThenCoverFillPathInstancedNV");
    glad_glStencilThenCoverFillPathNV = (PFNGLSTENCILTHENCOVERFILLPATHNVPROC) load(userptr, "glStencilThenCoverFillPathNV");
    glad_glStencilThenCoverStrokePathInstancedNV = (PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC) load(userptr, "glStencilThenCoverStrokePathInstancedNV");
    glad_glStencilThenCoverStrokePathNV = (PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC) load(userptr, "glStencilThenCoverStrokePathNV");
    glad_glTransformPathNV = (PFNGLTRANSFORMPATHNVPROC) load(userptr, "glTransformPathNV");
    glad_glWeightPathsNV = (PFNGLWEIGHTPATHSNVPROC) load(userptr, "glWeightPathsNV");
}
static void glad_gl_load_GL_NV_pixel_data_range( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_pixel_data_range) return;
    glad_glFlushPixelDataRangeNV = (PFNGLFLUSHPIXELDATARANGENVPROC) load(userptr, "glFlushPixelDataRangeNV");
    glad_glPixelDataRangeNV = (PFNGLPIXELDATARANGENVPROC) load(userptr, "glPixelDataRangeNV");
}
static void glad_gl_load_GL_NV_point_sprite( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_point_sprite) return;
    glad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC) load(userptr, "glPointParameteri");
    glad_glPointParameteriNV = (PFNGLPOINTPARAMETERINVPROC) load(userptr, "glPointParameteriNV");
    glad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC) load(userptr, "glPointParameteriv");
    glad_glPointParameterivNV = (PFNGLPOINTPARAMETERIVNVPROC) load(userptr, "glPointParameterivNV");
}
static void glad_gl_load_GL_NV_present_video( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_present_video) return;
    glad_glGetVideoi64vNV = (PFNGLGETVIDEOI64VNVPROC) load(userptr, "glGetVideoi64vNV");
    glad_glGetVideoivNV = (PFNGLGETVIDEOIVNVPROC) load(userptr, "glGetVideoivNV");
    glad_glGetVideoui64vNV = (PFNGLGETVIDEOUI64VNVPROC) load(userptr, "glGetVideoui64vNV");
    glad_glGetVideouivNV = (PFNGLGETVIDEOUIVNVPROC) load(userptr, "glGetVideouivNV");
    glad_glPresentFrameDualFillNV = (PFNGLPRESENTFRAMEDUALFILLNVPROC) load(userptr, "glPresentFrameDualFillNV");
    glad_glPresentFrameKeyedNV = (PFNGLPRESENTFRAMEKEYEDNVPROC) load(userptr, "glPresentFrameKeyedNV");
}
static void glad_gl_load_GL_NV_primitive_restart( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_primitive_restart) return;
    glad_glPrimitiveRestartIndexNV = (PFNGLPRIMITIVERESTARTINDEXNVPROC) load(userptr, "glPrimitiveRestartIndexNV");
    glad_glPrimitiveRestartNV = (PFNGLPRIMITIVERESTARTNVPROC) load(userptr, "glPrimitiveRestartNV");
}
static void glad_gl_load_GL_NV_query_resource( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_query_resource) return;
    glad_glQueryResourceNV = (PFNGLQUERYRESOURCENVPROC) load(userptr, "glQueryResourceNV");
}
static void glad_gl_load_GL_NV_query_resource_tag( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_query_resource_tag) return;
    glad_glDeleteQueryResourceTagNV = (PFNGLDELETEQUERYRESOURCETAGNVPROC) load(userptr, "glDeleteQueryResourceTagNV");
    glad_glGenQueryResourceTagNV = (PFNGLGENQUERYRESOURCETAGNVPROC) load(userptr, "glGenQueryResourceTagNV");
    glad_glQueryResourceTagNV = (PFNGLQUERYRESOURCETAGNVPROC) load(userptr, "glQueryResourceTagNV");
}
static void glad_gl_load_GL_NV_register_combiners( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_register_combiners) return;
    glad_glCombinerInputNV = (PFNGLCOMBINERINPUTNVPROC) load(userptr, "glCombinerInputNV");
    glad_glCombinerOutputNV = (PFNGLCOMBINEROUTPUTNVPROC) load(userptr, "glCombinerOutputNV");
    glad_glCombinerParameterfNV = (PFNGLCOMBINERPARAMETERFNVPROC) load(userptr, "glCombinerParameterfNV");
    glad_glCombinerParameterfvNV = (PFNGLCOMBINERPARAMETERFVNVPROC) load(userptr, "glCombinerParameterfvNV");
    glad_glCombinerParameteriNV = (PFNGLCOMBINERPARAMETERINVPROC) load(userptr, "glCombinerParameteriNV");
    glad_glCombinerParameterivNV = (PFNGLCOMBINERPARAMETERIVNVPROC) load(userptr, "glCombinerParameterivNV");
    glad_glFinalCombinerInputNV = (PFNGLFINALCOMBINERINPUTNVPROC) load(userptr, "glFinalCombinerInputNV");
    glad_glGetCombinerInputParameterfvNV = (PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) load(userptr, "glGetCombinerInputParameterfvNV");
    glad_glGetCombinerInputParameterivNV = (PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) load(userptr, "glGetCombinerInputParameterivNV");
    glad_glGetCombinerOutputParameterfvNV = (PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) load(userptr, "glGetCombinerOutputParameterfvNV");
    glad_glGetCombinerOutputParameterivNV = (PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) load(userptr, "glGetCombinerOutputParameterivNV");
    glad_glGetFinalCombinerInputParameterfvNV = (PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) load(userptr, "glGetFinalCombinerInputParameterfvNV");
    glad_glGetFinalCombinerInputParameterivNV = (PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) load(userptr, "glGetFinalCombinerInputParameterivNV");
}
static void glad_gl_load_GL_NV_register_combiners2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_register_combiners2) return;
    glad_glCombinerStageParameterfvNV = (PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) load(userptr, "glCombinerStageParameterfvNV");
    glad_glGetCombinerStageParameterfvNV = (PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) load(userptr, "glGetCombinerStageParameterfvNV");
}
static void glad_gl_load_GL_NV_sample_locations( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_sample_locations) return;
    glad_glFramebufferSampleLocationsfvNV = (PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) load(userptr, "glFramebufferSampleLocationsfvNV");
    glad_glNamedFramebufferSampleLocationsfvNV = (PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) load(userptr, "glNamedFramebufferSampleLocationsfvNV");
    glad_glResolveDepthValuesNV = (PFNGLRESOLVEDEPTHVALUESNVPROC) load(userptr, "glResolveDepthValuesNV");
}
static void glad_gl_load_GL_NV_shader_buffer_load( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_shader_buffer_load) return;
    glad_glGetBufferParameterui64vNV = (PFNGLGETBUFFERPARAMETERUI64VNVPROC) load(userptr, "glGetBufferParameterui64vNV");
    glad_glGetIntegerui64vNV = (PFNGLGETINTEGERUI64VNVPROC) load(userptr, "glGetIntegerui64vNV");
    glad_glGetNamedBufferParameterui64vNV = (PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) load(userptr, "glGetNamedBufferParameterui64vNV");
    glad_glGetUniformui64vNV = (PFNGLGETUNIFORMUI64VNVPROC) load(userptr, "glGetUniformui64vNV");
    glad_glIsBufferResidentNV = (PFNGLISBUFFERRESIDENTNVPROC) load(userptr, "glIsBufferResidentNV");
    glad_glIsNamedBufferResidentNV = (PFNGLISNAMEDBUFFERRESIDENTNVPROC) load(userptr, "glIsNamedBufferResidentNV");
    glad_glMakeBufferNonResidentNV = (PFNGLMAKEBUFFERNONRESIDENTNVPROC) load(userptr, "glMakeBufferNonResidentNV");
    glad_glMakeBufferResidentNV = (PFNGLMAKEBUFFERRESIDENTNVPROC) load(userptr, "glMakeBufferResidentNV");
    glad_glMakeNamedBufferNonResidentNV = (PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) load(userptr, "glMakeNamedBufferNonResidentNV");
    glad_glMakeNamedBufferResidentNV = (PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) load(userptr, "glMakeNamedBufferResidentNV");
    glad_glProgramUniformui64NV = (PFNGLPROGRAMUNIFORMUI64NVPROC) load(userptr, "glProgramUniformui64NV");
    glad_glProgramUniformui64vNV = (PFNGLPROGRAMUNIFORMUI64VNVPROC) load(userptr, "glProgramUniformui64vNV");
    glad_glUniformui64NV = (PFNGLUNIFORMUI64NVPROC) load(userptr, "glUniformui64NV");
    glad_glUniformui64vNV = (PFNGLUNIFORMUI64VNVPROC) load(userptr, "glUniformui64vNV");
}
static void glad_gl_load_GL_NV_texture_barrier( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_texture_barrier) return;
    glad_glTextureBarrierNV = (PFNGLTEXTUREBARRIERNVPROC) load(userptr, "glTextureBarrierNV");
}
static void glad_gl_load_GL_NV_texture_multisample( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_texture_multisample) return;
    glad_glTexImage2DMultisampleCoverageNV = (PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) load(userptr, "glTexImage2DMultisampleCoverageNV");
    glad_glTexImage3DMultisampleCoverageNV = (PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) load(userptr, "glTexImage3DMultisampleCoverageNV");
    glad_glTextureImage2DMultisampleCoverageNV = (PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) load(userptr, "glTextureImage2DMultisampleCoverageNV");
    glad_glTextureImage2DMultisampleNV = (PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) load(userptr, "glTextureImage2DMultisampleNV");
    glad_glTextureImage3DMultisampleCoverageNV = (PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) load(userptr, "glTextureImage3DMultisampleCoverageNV");
    glad_glTextureImage3DMultisampleNV = (PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) load(userptr, "glTextureImage3DMultisampleNV");
}
static void glad_gl_load_GL_NV_transform_feedback( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_transform_feedback) return;
    glad_glActiveVaryingNV = (PFNGLACTIVEVARYINGNVPROC) load(userptr, "glActiveVaryingNV");
    glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC) load(userptr, "glBeginTransformFeedback");
    glad_glBeginTransformFeedbackNV = (PFNGLBEGINTRANSFORMFEEDBACKNVPROC) load(userptr, "glBeginTransformFeedbackNV");
    glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) load(userptr, "glBindBufferBase");
    glad_glBindBufferBaseNV = (PFNGLBINDBUFFERBASENVPROC) load(userptr, "glBindBufferBaseNV");
    glad_glBindBufferOffsetEXT = (PFNGLBINDBUFFEROFFSETEXTPROC) load(userptr, "glBindBufferOffsetEXT");
    glad_glBindBufferOffsetNV = (PFNGLBINDBUFFEROFFSETNVPROC) load(userptr, "glBindBufferOffsetNV");
    glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) load(userptr, "glBindBufferRange");
    glad_glBindBufferRangeNV = (PFNGLBINDBUFFERRANGENVPROC) load(userptr, "glBindBufferRangeNV");
    glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC) load(userptr, "glEndTransformFeedback");
    glad_glEndTransformFeedbackNV = (PFNGLENDTRANSFORMFEEDBACKNVPROC) load(userptr, "glEndTransformFeedbackNV");
    glad_glGetActiveVaryingNV = (PFNGLGETACTIVEVARYINGNVPROC) load(userptr, "glGetActiveVaryingNV");
    glad_glGetTransformFeedbackVaryingNV = (PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) load(userptr, "glGetTransformFeedbackVaryingNV");
    glad_glGetVaryingLocationNV = (PFNGLGETVARYINGLOCATIONNVPROC) load(userptr, "glGetVaryingLocationNV");
    glad_glTransformFeedbackAttribsNV = (PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) load(userptr, "glTransformFeedbackAttribsNV");
    glad_glTransformFeedbackStreamAttribsNV = (PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC) load(userptr, "glTransformFeedbackStreamAttribsNV");
    glad_glTransformFeedbackVaryingsNV = (PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) load(userptr, "glTransformFeedbackVaryingsNV");
}
static void glad_gl_load_GL_NV_transform_feedback2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_transform_feedback2) return;
    glad_glBindTransformFeedbackNV = (PFNGLBINDTRANSFORMFEEDBACKNVPROC) load(userptr, "glBindTransformFeedbackNV");
    glad_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) load(userptr, "glDeleteTransformFeedbacks");
    glad_glDeleteTransformFeedbacksNV = (PFNGLDELETETRANSFORMFEEDBACKSNVPROC) load(userptr, "glDeleteTransformFeedbacksNV");
    glad_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) load(userptr, "glDrawTransformFeedback");
    glad_glDrawTransformFeedbackNV = (PFNGLDRAWTRANSFORMFEEDBACKNVPROC) load(userptr, "glDrawTransformFeedbackNV");
    glad_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) load(userptr, "glGenTransformFeedbacks");
    glad_glGenTransformFeedbacksNV = (PFNGLGENTRANSFORMFEEDBACKSNVPROC) load(userptr, "glGenTransformFeedbacksNV");
    glad_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) load(userptr, "glIsTransformFeedback");
    glad_glIsTransformFeedbackNV = (PFNGLISTRANSFORMFEEDBACKNVPROC) load(userptr, "glIsTransformFeedbackNV");
    glad_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) load(userptr, "glPauseTransformFeedback");
    glad_glPauseTransformFeedbackNV = (PFNGLPAUSETRANSFORMFEEDBACKNVPROC) load(userptr, "glPauseTransformFeedbackNV");
    glad_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) load(userptr, "glResumeTransformFeedback");
    glad_glResumeTransformFeedbackNV = (PFNGLRESUMETRANSFORMFEEDBACKNVPROC) load(userptr, "glResumeTransformFeedbackNV");
}
static void glad_gl_load_GL_NV_vdpau_interop( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_vdpau_interop) return;
    glad_glVDPAUFiniNV = (PFNGLVDPAUFININVPROC) load(userptr, "glVDPAUFiniNV");
    glad_glVDPAUGetSurfaceivNV = (PFNGLVDPAUGETSURFACEIVNVPROC) load(userptr, "glVDPAUGetSurfaceivNV");
    glad_glVDPAUInitNV = (PFNGLVDPAUINITNVPROC) load(userptr, "glVDPAUInitNV");
    glad_glVDPAUIsSurfaceNV = (PFNGLVDPAUISSURFACENVPROC) load(userptr, "glVDPAUIsSurfaceNV");
    glad_glVDPAUMapSurfacesNV = (PFNGLVDPAUMAPSURFACESNVPROC) load(userptr, "glVDPAUMapSurfacesNV");
    glad_glVDPAURegisterOutputSurfaceNV = (PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) load(userptr, "glVDPAURegisterOutputSurfaceNV");
    glad_glVDPAURegisterVideoSurfaceNV = (PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) load(userptr, "glVDPAURegisterVideoSurfaceNV");
    glad_glVDPAUSurfaceAccessNV = (PFNGLVDPAUSURFACEACCESSNVPROC) load(userptr, "glVDPAUSurfaceAccessNV");
    glad_glVDPAUUnmapSurfacesNV = (PFNGLVDPAUUNMAPSURFACESNVPROC) load(userptr, "glVDPAUUnmapSurfacesNV");
    glad_glVDPAUUnregisterSurfaceNV = (PFNGLVDPAUUNREGISTERSURFACENVPROC) load(userptr, "glVDPAUUnregisterSurfaceNV");
}
static void glad_gl_load_GL_NV_vertex_array_range( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_vertex_array_range) return;
    glad_glFlushVertexArrayRangeNV = (PFNGLFLUSHVERTEXARRAYRANGENVPROC) load(userptr, "glFlushVertexArrayRangeNV");
    glad_glVertexArrayRangeNV = (PFNGLVERTEXARRAYRANGENVPROC) load(userptr, "glVertexArrayRangeNV");
}
static void glad_gl_load_GL_NV_vertex_attrib_integer_64bit( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_vertex_attrib_integer_64bit) return;
    glad_glGetVertexAttribLi64vNV = (PFNGLGETVERTEXATTRIBLI64VNVPROC) load(userptr, "glGetVertexAttribLi64vNV");
    glad_glGetVertexAttribLui64vNV = (PFNGLGETVERTEXATTRIBLUI64VNVPROC) load(userptr, "glGetVertexAttribLui64vNV");
    glad_glVertexAttribL1i64NV = (PFNGLVERTEXATTRIBL1I64NVPROC) load(userptr, "glVertexAttribL1i64NV");
    glad_glVertexAttribL1i64vNV = (PFNGLVERTEXATTRIBL1I64VNVPROC) load(userptr, "glVertexAttribL1i64vNV");
    glad_glVertexAttribL1ui64NV = (PFNGLVERTEXATTRIBL1UI64NVPROC) load(userptr, "glVertexAttribL1ui64NV");
    glad_glVertexAttribL1ui64vNV = (PFNGLVERTEXATTRIBL1UI64VNVPROC) load(userptr, "glVertexAttribL1ui64vNV");
    glad_glVertexAttribL2i64NV = (PFNGLVERTEXATTRIBL2I64NVPROC) load(userptr, "glVertexAttribL2i64NV");
    glad_glVertexAttribL2i64vNV = (PFNGLVERTEXATTRIBL2I64VNVPROC) load(userptr, "glVertexAttribL2i64vNV");
    glad_glVertexAttribL2ui64NV = (PFNGLVERTEXATTRIBL2UI64NVPROC) load(userptr, "glVertexAttribL2ui64NV");
    glad_glVertexAttribL2ui64vNV = (PFNGLVERTEXATTRIBL2UI64VNVPROC) load(userptr, "glVertexAttribL2ui64vNV");
    glad_glVertexAttribL3i64NV = (PFNGLVERTEXATTRIBL3I64NVPROC) load(userptr, "glVertexAttribL3i64NV");
    glad_glVertexAttribL3i64vNV = (PFNGLVERTEXATTRIBL3I64VNVPROC) load(userptr, "glVertexAttribL3i64vNV");
    glad_glVertexAttribL3ui64NV = (PFNGLVERTEXATTRIBL3UI64NVPROC) load(userptr, "glVertexAttribL3ui64NV");
    glad_glVertexAttribL3ui64vNV = (PFNGLVERTEXATTRIBL3UI64VNVPROC) load(userptr, "glVertexAttribL3ui64vNV");
    glad_glVertexAttribL4i64NV = (PFNGLVERTEXATTRIBL4I64NVPROC) load(userptr, "glVertexAttribL4i64NV");
    glad_glVertexAttribL4i64vNV = (PFNGLVERTEXATTRIBL4I64VNVPROC) load(userptr, "glVertexAttribL4i64vNV");
    glad_glVertexAttribL4ui64NV = (PFNGLVERTEXATTRIBL4UI64NVPROC) load(userptr, "glVertexAttribL4ui64NV");
    glad_glVertexAttribL4ui64vNV = (PFNGLVERTEXATTRIBL4UI64VNVPROC) load(userptr, "glVertexAttribL4ui64vNV");
    glad_glVertexAttribLFormatNV = (PFNGLVERTEXATTRIBLFORMATNVPROC) load(userptr, "glVertexAttribLFormatNV");
}
static void glad_gl_load_GL_NV_vertex_buffer_unified_memory( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_vertex_buffer_unified_memory) return;
    glad_glBufferAddressRangeNV = (PFNGLBUFFERADDRESSRANGENVPROC) load(userptr, "glBufferAddressRangeNV");
    glad_glColorFormatNV = (PFNGLCOLORFORMATNVPROC) load(userptr, "glColorFormatNV");
    glad_glEdgeFlagFormatNV = (PFNGLEDGEFLAGFORMATNVPROC) load(userptr, "glEdgeFlagFormatNV");
    glad_glFogCoordFormatNV = (PFNGLFOGCOORDFORMATNVPROC) load(userptr, "glFogCoordFormatNV");
    glad_glGetIntegerui64i_vNV = (PFNGLGETINTEGERUI64I_VNVPROC) load(userptr, "glGetIntegerui64i_vNV");
    glad_glIndexFormatNV = (PFNGLINDEXFORMATNVPROC) load(userptr, "glIndexFormatNV");
    glad_glNormalFormatNV = (PFNGLNORMALFORMATNVPROC) load(userptr, "glNormalFormatNV");
    glad_glSecondaryColorFormatNV = (PFNGLSECONDARYCOLORFORMATNVPROC) load(userptr, "glSecondaryColorFormatNV");
    glad_glTexCoordFormatNV = (PFNGLTEXCOORDFORMATNVPROC) load(userptr, "glTexCoordFormatNV");
    glad_glVertexAttribFormatNV = (PFNGLVERTEXATTRIBFORMATNVPROC) load(userptr, "glVertexAttribFormatNV");
    glad_glVertexAttribIFormatNV = (PFNGLVERTEXATTRIBIFORMATNVPROC) load(userptr, "glVertexAttribIFormatNV");
    glad_glVertexFormatNV = (PFNGLVERTEXFORMATNVPROC) load(userptr, "glVertexFormatNV");
}
static void glad_gl_load_GL_NV_vertex_program( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_vertex_program) return;
    glad_glAreProgramsResidentNV = (PFNGLAREPROGRAMSRESIDENTNVPROC) load(userptr, "glAreProgramsResidentNV");
    glad_glBindProgramARB = (PFNGLBINDPROGRAMARBPROC) load(userptr, "glBindProgramARB");
    glad_glBindProgramNV = (PFNGLBINDPROGRAMNVPROC) load(userptr, "glBindProgramNV");
    glad_glDeleteProgramsARB = (PFNGLDELETEPROGRAMSARBPROC) load(userptr, "glDeleteProgramsARB");
    glad_glDeleteProgramsNV = (PFNGLDELETEPROGRAMSNVPROC) load(userptr, "glDeleteProgramsNV");
    glad_glExecuteProgramNV = (PFNGLEXECUTEPROGRAMNVPROC) load(userptr, "glExecuteProgramNV");
    glad_glGenProgramsARB = (PFNGLGENPROGRAMSARBPROC) load(userptr, "glGenProgramsARB");
    glad_glGenProgramsNV = (PFNGLGENPROGRAMSNVPROC) load(userptr, "glGenProgramsNV");
    glad_glGetProgramParameterdvNV = (PFNGLGETPROGRAMPARAMETERDVNVPROC) load(userptr, "glGetProgramParameterdvNV");
    glad_glGetProgramParameterfvNV = (PFNGLGETPROGRAMPARAMETERFVNVPROC) load(userptr, "glGetProgramParameterfvNV");
    glad_glGetProgramStringNV = (PFNGLGETPROGRAMSTRINGNVPROC) load(userptr, "glGetProgramStringNV");
    glad_glGetProgramivNV = (PFNGLGETPROGRAMIVNVPROC) load(userptr, "glGetProgramivNV");
    glad_glGetTrackMatrixivNV = (PFNGLGETTRACKMATRIXIVNVPROC) load(userptr, "glGetTrackMatrixivNV");
    glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC) load(userptr, "glGetVertexAttribPointerv");
    glad_glGetVertexAttribPointervNV = (PFNGLGETVERTEXATTRIBPOINTERVNVPROC) load(userptr, "glGetVertexAttribPointervNV");
    glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC) load(userptr, "glGetVertexAttribdv");
    glad_glGetVertexAttribdvNV = (PFNGLGETVERTEXATTRIBDVNVPROC) load(userptr, "glGetVertexAttribdvNV");
    glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC) load(userptr, "glGetVertexAttribfv");
    glad_glGetVertexAttribfvNV = (PFNGLGETVERTEXATTRIBFVNVPROC) load(userptr, "glGetVertexAttribfvNV");
    glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC) load(userptr, "glGetVertexAttribiv");
    glad_glGetVertexAttribivNV = (PFNGLGETVERTEXATTRIBIVNVPROC) load(userptr, "glGetVertexAttribivNV");
    glad_glIsProgramARB = (PFNGLISPROGRAMARBPROC) load(userptr, "glIsProgramARB");
    glad_glIsProgramNV = (PFNGLISPROGRAMNVPROC) load(userptr, "glIsProgramNV");
    glad_glLoadProgramNV = (PFNGLLOADPROGRAMNVPROC) load(userptr, "glLoadProgramNV");
    glad_glProgramParameter4dNV = (PFNGLPROGRAMPARAMETER4DNVPROC) load(userptr, "glProgramParameter4dNV");
    glad_glProgramParameter4dvNV = (PFNGLPROGRAMPARAMETER4DVNVPROC) load(userptr, "glProgramParameter4dvNV");
    glad_glProgramParameter4fNV = (PFNGLPROGRAMPARAMETER4FNVPROC) load(userptr, "glProgramParameter4fNV");
    glad_glProgramParameter4fvNV = (PFNGLPROGRAMPARAMETER4FVNVPROC) load(userptr, "glProgramParameter4fvNV");
    glad_glProgramParameters4dvNV = (PFNGLPROGRAMPARAMETERS4DVNVPROC) load(userptr, "glProgramParameters4dvNV");
    glad_glProgramParameters4fvNV = (PFNGLPROGRAMPARAMETERS4FVNVPROC) load(userptr, "glProgramParameters4fvNV");
    glad_glRequestResidentProgramsNV = (PFNGLREQUESTRESIDENTPROGRAMSNVPROC) load(userptr, "glRequestResidentProgramsNV");
    glad_glTrackMatrixNV = (PFNGLTRACKMATRIXNVPROC) load(userptr, "glTrackMatrixNV");
    glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC) load(userptr, "glVertexAttrib1d");
    glad_glVertexAttrib1dNV = (PFNGLVERTEXATTRIB1DNVPROC) load(userptr, "glVertexAttrib1dNV");
    glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC) load(userptr, "glVertexAttrib1dv");
    glad_glVertexAttrib1dvNV = (PFNGLVERTEXATTRIB1DVNVPROC) load(userptr, "glVertexAttrib1dvNV");
    glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC) load(userptr, "glVertexAttrib1f");
    glad_glVertexAttrib1fNV = (PFNGLVERTEXATTRIB1FNVPROC) load(userptr, "glVertexAttrib1fNV");
    glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC) load(userptr, "glVertexAttrib1fv");
    glad_glVertexAttrib1fvNV = (PFNGLVERTEXATTRIB1FVNVPROC) load(userptr, "glVertexAttrib1fvNV");
    glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC) load(userptr, "glVertexAttrib1s");
    glad_glVertexAttrib1sNV = (PFNGLVERTEXATTRIB1SNVPROC) load(userptr, "glVertexAttrib1sNV");
    glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC) load(userptr, "glVertexAttrib1sv");
    glad_glVertexAttrib1svNV = (PFNGLVERTEXATTRIB1SVNVPROC) load(userptr, "glVertexAttrib1svNV");
    glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC) load(userptr, "glVertexAttrib2d");
    glad_glVertexAttrib2dNV = (PFNGLVERTEXATTRIB2DNVPROC) load(userptr, "glVertexAttrib2dNV");
    glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC) load(userptr, "glVertexAttrib2dv");
    glad_glVertexAttrib2dvNV = (PFNGLVERTEXATTRIB2DVNVPROC) load(userptr, "glVertexAttrib2dvNV");
    glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC) load(userptr, "glVertexAttrib2f");
    glad_glVertexAttrib2fNV = (PFNGLVERTEXATTRIB2FNVPROC) load(userptr, "glVertexAttrib2fNV");
    glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC) load(userptr, "glVertexAttrib2fv");
    glad_glVertexAttrib2fvNV = (PFNGLVERTEXATTRIB2FVNVPROC) load(userptr, "glVertexAttrib2fvNV");
    glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC) load(userptr, "glVertexAttrib2s");
    glad_glVertexAttrib2sNV = (PFNGLVERTEXATTRIB2SNVPROC) load(userptr, "glVertexAttrib2sNV");
    glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC) load(userptr, "glVertexAttrib2sv");
    glad_glVertexAttrib2svNV = (PFNGLVERTEXATTRIB2SVNVPROC) load(userptr, "glVertexAttrib2svNV");
    glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC) load(userptr, "glVertexAttrib3d");
    glad_glVertexAttrib3dNV = (PFNGLVERTEXATTRIB3DNVPROC) load(userptr, "glVertexAttrib3dNV");
    glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC) load(userptr, "glVertexAttrib3dv");
    glad_glVertexAttrib3dvNV = (PFNGLVERTEXATTRIB3DVNVPROC) load(userptr, "glVertexAttrib3dvNV");
    glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC) load(userptr, "glVertexAttrib3f");
    glad_glVertexAttrib3fNV = (PFNGLVERTEXATTRIB3FNVPROC) load(userptr, "glVertexAttrib3fNV");
    glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC) load(userptr, "glVertexAttrib3fv");
    glad_glVertexAttrib3fvNV = (PFNGLVERTEXATTRIB3FVNVPROC) load(userptr, "glVertexAttrib3fvNV");
    glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC) load(userptr, "glVertexAttrib3s");
    glad_glVertexAttrib3sNV = (PFNGLVERTEXATTRIB3SNVPROC) load(userptr, "glVertexAttrib3sNV");
    glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC) load(userptr, "glVertexAttrib3sv");
    glad_glVertexAttrib3svNV = (PFNGLVERTEXATTRIB3SVNVPROC) load(userptr, "glVertexAttrib3svNV");
    glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC) load(userptr, "glVertexAttrib4Nub");
    glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC) load(userptr, "glVertexAttrib4Nubv");
    glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC) load(userptr, "glVertexAttrib4d");
    glad_glVertexAttrib4dNV = (PFNGLVERTEXATTRIB4DNVPROC) load(userptr, "glVertexAttrib4dNV");
    glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC) load(userptr, "glVertexAttrib4dv");
    glad_glVertexAttrib4dvNV = (PFNGLVERTEXATTRIB4DVNVPROC) load(userptr, "glVertexAttrib4dvNV");
    glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC) load(userptr, "glVertexAttrib4f");
    glad_glVertexAttrib4fNV = (PFNGLVERTEXATTRIB4FNVPROC) load(userptr, "glVertexAttrib4fNV");
    glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC) load(userptr, "glVertexAttrib4fv");
    glad_glVertexAttrib4fvNV = (PFNGLVERTEXATTRIB4FVNVPROC) load(userptr, "glVertexAttrib4fvNV");
    glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC) load(userptr, "glVertexAttrib4s");
    glad_glVertexAttrib4sNV = (PFNGLVERTEXATTRIB4SNVPROC) load(userptr, "glVertexAttrib4sNV");
    glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC) load(userptr, "glVertexAttrib4sv");
    glad_glVertexAttrib4svNV = (PFNGLVERTEXATTRIB4SVNVPROC) load(userptr, "glVertexAttrib4svNV");
    glad_glVertexAttrib4ubNV = (PFNGLVERTEXATTRIB4UBNVPROC) load(userptr, "glVertexAttrib4ubNV");
    glad_glVertexAttrib4ubvNV = (PFNGLVERTEXATTRIB4UBVNVPROC) load(userptr, "glVertexAttrib4ubvNV");
    glad_glVertexAttribPointerNV = (PFNGLVERTEXATTRIBPOINTERNVPROC) load(userptr, "glVertexAttribPointerNV");
    glad_glVertexAttribs1dvNV = (PFNGLVERTEXATTRIBS1DVNVPROC) load(userptr, "glVertexAttribs1dvNV");
    glad_glVertexAttribs1fvNV = (PFNGLVERTEXATTRIBS1FVNVPROC) load(userptr, "glVertexAttribs1fvNV");
    glad_glVertexAttribs1svNV = (PFNGLVERTEXATTRIBS1SVNVPROC) load(userptr, "glVertexAttribs1svNV");
    glad_glVertexAttribs2dvNV = (PFNGLVERTEXATTRIBS2DVNVPROC) load(userptr, "glVertexAttribs2dvNV");
    glad_glVertexAttribs2fvNV = (PFNGLVERTEXATTRIBS2FVNVPROC) load(userptr, "glVertexAttribs2fvNV");
    glad_glVertexAttribs2svNV = (PFNGLVERTEXATTRIBS2SVNVPROC) load(userptr, "glVertexAttribs2svNV");
    glad_glVertexAttribs3dvNV = (PFNGLVERTEXATTRIBS3DVNVPROC) load(userptr, "glVertexAttribs3dvNV");
    glad_glVertexAttribs3fvNV = (PFNGLVERTEXATTRIBS3FVNVPROC) load(userptr, "glVertexAttribs3fvNV");
    glad_glVertexAttribs3svNV = (PFNGLVERTEXATTRIBS3SVNVPROC) load(userptr, "glVertexAttribs3svNV");
    glad_glVertexAttribs4dvNV = (PFNGLVERTEXATTRIBS4DVNVPROC) load(userptr, "glVertexAttribs4dvNV");
    glad_glVertexAttribs4fvNV = (PFNGLVERTEXATTRIBS4FVNVPROC) load(userptr, "glVertexAttribs4fvNV");
    glad_glVertexAttribs4svNV = (PFNGLVERTEXATTRIBS4SVNVPROC) load(userptr, "glVertexAttribs4svNV");
    glad_glVertexAttribs4ubvNV = (PFNGLVERTEXATTRIBS4UBVNVPROC) load(userptr, "glVertexAttribs4ubvNV");
}
static void glad_gl_load_GL_NV_vertex_program4( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_vertex_program4) return;
    glad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC) load(userptr, "glGetVertexAttribIiv");
    glad_glGetVertexAttribIivEXT = (PFNGLGETVERTEXATTRIBIIVEXTPROC) load(userptr, "glGetVertexAttribIivEXT");
    glad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC) load(userptr, "glGetVertexAttribIuiv");
    glad_glGetVertexAttribIuivEXT = (PFNGLGETVERTEXATTRIBIUIVEXTPROC) load(userptr, "glGetVertexAttribIuivEXT");
    glad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC) load(userptr, "glVertexAttribI1i");
    glad_glVertexAttribI1iEXT = (PFNGLVERTEXATTRIBI1IEXTPROC) load(userptr, "glVertexAttribI1iEXT");
    glad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC) load(userptr, "glVertexAttribI1iv");
    glad_glVertexAttribI1ivEXT = (PFNGLVERTEXATTRIBI1IVEXTPROC) load(userptr, "glVertexAttribI1ivEXT");
    glad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC) load(userptr, "glVertexAttribI1ui");
    glad_glVertexAttribI1uiEXT = (PFNGLVERTEXATTRIBI1UIEXTPROC) load(userptr, "glVertexAttribI1uiEXT");
    glad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC) load(userptr, "glVertexAttribI1uiv");
    glad_glVertexAttribI1uivEXT = (PFNGLVERTEXATTRIBI1UIVEXTPROC) load(userptr, "glVertexAttribI1uivEXT");
    glad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC) load(userptr, "glVertexAttribI2i");
    glad_glVertexAttribI2iEXT = (PFNGLVERTEXATTRIBI2IEXTPROC) load(userptr, "glVertexAttribI2iEXT");
    glad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC) load(userptr, "glVertexAttribI2iv");
    glad_glVertexAttribI2ivEXT = (PFNGLVERTEXATTRIBI2IVEXTPROC) load(userptr, "glVertexAttribI2ivEXT");
    glad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC) load(userptr, "glVertexAttribI2ui");
    glad_glVertexAttribI2uiEXT = (PFNGLVERTEXATTRIBI2UIEXTPROC) load(userptr, "glVertexAttribI2uiEXT");
    glad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC) load(userptr, "glVertexAttribI2uiv");
    glad_glVertexAttribI2uivEXT = (PFNGLVERTEXATTRIBI2UIVEXTPROC) load(userptr, "glVertexAttribI2uivEXT");
    glad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC) load(userptr, "glVertexAttribI3i");
    glad_glVertexAttribI3iEXT = (PFNGLVERTEXATTRIBI3IEXTPROC) load(userptr, "glVertexAttribI3iEXT");
    glad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC) load(userptr, "glVertexAttribI3iv");
    glad_glVertexAttribI3ivEXT = (PFNGLVERTEXATTRIBI3IVEXTPROC) load(userptr, "glVertexAttribI3ivEXT");
    glad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC) load(userptr, "glVertexAttribI3ui");
    glad_glVertexAttribI3uiEXT = (PFNGLVERTEXATTRIBI3UIEXTPROC) load(userptr, "glVertexAttribI3uiEXT");
    glad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC) load(userptr, "glVertexAttribI3uiv");
    glad_glVertexAttribI3uivEXT = (PFNGLVERTEXATTRIBI3UIVEXTPROC) load(userptr, "glVertexAttribI3uivEXT");
    glad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC) load(userptr, "glVertexAttribI4bv");
    glad_glVertexAttribI4bvEXT = (PFNGLVERTEXATTRIBI4BVEXTPROC) load(userptr, "glVertexAttribI4bvEXT");
    glad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC) load(userptr, "glVertexAttribI4i");
    glad_glVertexAttribI4iEXT = (PFNGLVERTEXATTRIBI4IEXTPROC) load(userptr, "glVertexAttribI4iEXT");
    glad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC) load(userptr, "glVertexAttribI4iv");
    glad_glVertexAttribI4ivEXT = (PFNGLVERTEXATTRIBI4IVEXTPROC) load(userptr, "glVertexAttribI4ivEXT");
    glad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC) load(userptr, "glVertexAttribI4sv");
    glad_glVertexAttribI4svEXT = (PFNGLVERTEXATTRIBI4SVEXTPROC) load(userptr, "glVertexAttribI4svEXT");
    glad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC) load(userptr, "glVertexAttribI4ubv");
    glad_glVertexAttribI4ubvEXT = (PFNGLVERTEXATTRIBI4UBVEXTPROC) load(userptr, "glVertexAttribI4ubvEXT");
    glad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC) load(userptr, "glVertexAttribI4ui");
    glad_glVertexAttribI4uiEXT = (PFNGLVERTEXATTRIBI4UIEXTPROC) load(userptr, "glVertexAttribI4uiEXT");
    glad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC) load(userptr, "glVertexAttribI4uiv");
    glad_glVertexAttribI4uivEXT = (PFNGLVERTEXATTRIBI4UIVEXTPROC) load(userptr, "glVertexAttribI4uivEXT");
    glad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC) load(userptr, "glVertexAttribI4usv");
    glad_glVertexAttribI4usvEXT = (PFNGLVERTEXATTRIBI4USVEXTPROC) load(userptr, "glVertexAttribI4usvEXT");
    glad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC) load(userptr, "glVertexAttribIPointer");
    glad_glVertexAttribIPointerEXT = (PFNGLVERTEXATTRIBIPOINTEREXTPROC) load(userptr, "glVertexAttribIPointerEXT");
}
static void glad_gl_load_GL_NV_video_capture( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_video_capture) return;
    glad_glBeginVideoCaptureNV = (PFNGLBEGINVIDEOCAPTURENVPROC) load(userptr, "glBeginVideoCaptureNV");
    glad_glBindVideoCaptureStreamBufferNV = (PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) load(userptr, "glBindVideoCaptureStreamBufferNV");
    glad_glBindVideoCaptureStreamTextureNV = (PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) load(userptr, "glBindVideoCaptureStreamTextureNV");
    glad_glEndVideoCaptureNV = (PFNGLENDVIDEOCAPTURENVPROC) load(userptr, "glEndVideoCaptureNV");
    glad_glGetVideoCaptureStreamdvNV = (PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) load(userptr, "glGetVideoCaptureStreamdvNV");
    glad_glGetVideoCaptureStreamfvNV = (PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) load(userptr, "glGetVideoCaptureStreamfvNV");
    glad_glGetVideoCaptureStreamivNV = (PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) load(userptr, "glGetVideoCaptureStreamivNV");
    glad_glGetVideoCaptureivNV = (PFNGLGETVIDEOCAPTUREIVNVPROC) load(userptr, "glGetVideoCaptureivNV");
    glad_glVideoCaptureNV = (PFNGLVIDEOCAPTURENVPROC) load(userptr, "glVideoCaptureNV");
    glad_glVideoCaptureStreamParameterdvNV = (PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) load(userptr, "glVideoCaptureStreamParameterdvNV");
    glad_glVideoCaptureStreamParameterfvNV = (PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) load(userptr, "glVideoCaptureStreamParameterfvNV");
    glad_glVideoCaptureStreamParameterivNV = (PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) load(userptr, "glVideoCaptureStreamParameterivNV");
}
static void glad_gl_load_GL_NV_viewport_swizzle( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_GL_NV_viewport_swizzle) return;
    glad_glViewportSwizzleNV = (PFNGLVIEWPORTSWIZZLENVPROC) load(userptr, "glViewportSwizzleNV");
}



#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
#define GLAD_GL_IS_SOME_NEW_VERSION 1
#else
#define GLAD_GL_IS_SOME_NEW_VERSION 0
#endif

static int glad_gl_get_extensions( int version, const char **out_exts, unsigned int *out_num_exts_i, char ***out_exts_i) {
#if GLAD_GL_IS_SOME_NEW_VERSION
    if(GLAD_VERSION_MAJOR(version) < 3) {
#else
    (void) version;
    (void) out_num_exts_i;
    (void) out_exts_i;
#endif
        if (glad_glGetString == NULL) {
            return 0;
        }
        *out_exts = (const char *)glad_glGetString(GL_EXTENSIONS);
#if GLAD_GL_IS_SOME_NEW_VERSION
    } else {
        unsigned int index = 0;
        unsigned int num_exts_i = 0;
        char **exts_i = NULL;
        if (glad_glGetStringi == NULL || glad_glGetIntegerv == NULL) {
            return 0;
        }
        glad_glGetIntegerv(GL_NUM_EXTENSIONS, (int*) &num_exts_i);
        if (num_exts_i > 0) {
            exts_i = (char **) malloc(num_exts_i * (sizeof *exts_i));
        }
        if (exts_i == NULL) {
            return 0;
        }
        for(index = 0; index < num_exts_i; index++) {
            const char *gl_str_tmp = (const char*) glad_glGetStringi(GL_EXTENSIONS, index);
            size_t len = strlen(gl_str_tmp) + 1;

            char *local_str = (char*) malloc(len * sizeof(char));
            if(local_str != NULL) {
                memcpy(local_str, gl_str_tmp, len * sizeof(char));
            }

            exts_i[index] = local_str;
        }

        *out_num_exts_i = num_exts_i;
        *out_exts_i = exts_i;
    }
#endif
    return 1;
}
static void glad_gl_free_extensions(char **exts_i, unsigned int num_exts_i) {
    if (exts_i != NULL) {
        unsigned int index;
        for(index = 0; index < num_exts_i; index++) {
            free((void *) (exts_i[index]));
        }
        free((void *)exts_i);
        exts_i = NULL;
    }
}
static int glad_gl_has_extension(int version, const char *exts, unsigned int num_exts_i, char **exts_i, const char *ext) {
    if(GLAD_VERSION_MAJOR(version) < 3 || !GLAD_GL_IS_SOME_NEW_VERSION) {
        const char *extensions;
        const char *loc;
        const char *terminator;
        extensions = exts;
        if(extensions == NULL || ext == NULL) {
            return 0;
        }
        while(1) {
            loc = strstr(extensions, ext);
            if(loc == NULL) {
                return 0;
            }
            terminator = loc + strlen(ext);
            if((loc == extensions || *(loc - 1) == ' ') &&
                (*terminator == ' ' || *terminator == '\0')) {
                return 1;
            }
            extensions = terminator;
        }
    } else {
        unsigned int index;
        for(index = 0; index < num_exts_i; index++) {
            const char *e = exts_i[index];
            if(strcmp(e, ext) == 0) {
                return 1;
            }
        }
    }
    return 0;
}

static GLADapiproc glad_gl_get_proc_from_userptr(void *userptr, const char* name) {
    return (GLAD_GNUC_EXTENSION (GLADapiproc (*)(const char *name)) userptr)(name);
}

static int glad_gl_find_extensions_gl( int version) {
    const char *exts = NULL;
    unsigned int num_exts_i = 0;
    char **exts_i = NULL;
    if (!glad_gl_get_extensions(version, &exts, &num_exts_i, &exts_i)) return 0;

    GLAD_GL_AMD_blend_minmax_factor = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_blend_minmax_factor");
    GLAD_GL_AMD_conservative_depth = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_conservative_depth");
    GLAD_GL_AMD_debug_output = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_debug_output");
    GLAD_GL_AMD_depth_clamp_separate = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_depth_clamp_separate");
    GLAD_GL_AMD_draw_buffers_blend = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_draw_buffers_blend");
    GLAD_GL_AMD_framebuffer_sample_positions = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_framebuffer_sample_positions");
    GLAD_GL_AMD_gcn_shader = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_gcn_shader");
    GLAD_GL_AMD_gpu_shader_half_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_gpu_shader_half_float");
    GLAD_GL_AMD_gpu_shader_int16 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_gpu_shader_int16");
    GLAD_GL_AMD_gpu_shader_int64 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_gpu_shader_int64");
    GLAD_GL_AMD_interleaved_elements = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_interleaved_elements");
    GLAD_GL_AMD_multi_draw_indirect = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_multi_draw_indirect");
    GLAD_GL_AMD_name_gen_delete = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_name_gen_delete");
    GLAD_GL_AMD_occlusion_query_event = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_occlusion_query_event");
    GLAD_GL_AMD_performance_monitor = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_performance_monitor");
    GLAD_GL_AMD_pinned_memory = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_pinned_memory");
    GLAD_GL_AMD_query_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_query_buffer_object");
    GLAD_GL_AMD_sample_positions = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_sample_positions");
    GLAD_GL_AMD_seamless_cubemap_per_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_seamless_cubemap_per_texture");
    GLAD_GL_AMD_shader_atomic_counter_ops = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_shader_atomic_counter_ops");
    GLAD_GL_AMD_shader_ballot = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_shader_ballot");
    GLAD_GL_AMD_shader_explicit_vertex_parameter = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_shader_explicit_vertex_parameter");
    GLAD_GL_AMD_shader_stencil_export = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_shader_stencil_export");
    GLAD_GL_AMD_shader_trinary_minmax = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_shader_trinary_minmax");
    GLAD_GL_AMD_sparse_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_sparse_texture");
    GLAD_GL_AMD_stencil_operation_extended = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_stencil_operation_extended");
    GLAD_GL_AMD_texture_gather_bias_lod = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_texture_gather_bias_lod");
    GLAD_GL_AMD_texture_texture4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_texture_texture4");
    GLAD_GL_AMD_transform_feedback3_lines_triangles = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_transform_feedback3_lines_triangles");
    GLAD_GL_AMD_transform_feedback4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_transform_feedback4");
    GLAD_GL_AMD_vertex_shader_layer = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_vertex_shader_layer");
    GLAD_GL_AMD_vertex_shader_tessellator = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_vertex_shader_tessellator");
    GLAD_GL_AMD_vertex_shader_viewport_index = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_AMD_vertex_shader_viewport_index");
    GLAD_GL_APPLE_aux_depth_stencil = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_aux_depth_stencil");
    GLAD_GL_APPLE_client_storage = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_client_storage");
    GLAD_GL_APPLE_element_array = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_element_array");
    GLAD_GL_APPLE_fence = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_fence");
    GLAD_GL_APPLE_float_pixels = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_float_pixels");
    GLAD_GL_APPLE_flush_buffer_range = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_flush_buffer_range");
    GLAD_GL_APPLE_object_purgeable = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_object_purgeable");
    GLAD_GL_APPLE_rgb_422 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_rgb_422");
    GLAD_GL_APPLE_row_bytes = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_row_bytes");
    GLAD_GL_APPLE_specular_vector = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_specular_vector");
    GLAD_GL_APPLE_texture_range = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_texture_range");
    GLAD_GL_APPLE_transform_hint = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_transform_hint");
    GLAD_GL_APPLE_vertex_array_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_vertex_array_object");
    GLAD_GL_APPLE_vertex_array_range = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_vertex_array_range");
    GLAD_GL_APPLE_vertex_program_evaluators = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_vertex_program_evaluators");
    GLAD_GL_APPLE_ycbcr_422 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_APPLE_ycbcr_422");
    GLAD_GL_ARB_ES2_compatibility = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_ES2_compatibility");
    GLAD_GL_ARB_ES3_1_compatibility = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_ES3_1_compatibility");
    GLAD_GL_ARB_ES3_2_compatibility = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_ES3_2_compatibility");
    GLAD_GL_ARB_ES3_compatibility = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_ES3_compatibility");
    GLAD_GL_ARB_arrays_of_arrays = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_arrays_of_arrays");
    GLAD_GL_ARB_base_instance = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_base_instance");
    GLAD_GL_ARB_bindless_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_bindless_texture");
    GLAD_GL_ARB_blend_func_extended = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_blend_func_extended");
    GLAD_GL_ARB_buffer_storage = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_buffer_storage");
    GLAD_GL_ARB_cl_event = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_cl_event");
    GLAD_GL_ARB_clear_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_clear_buffer_object");
    GLAD_GL_ARB_clear_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_clear_texture");
    GLAD_GL_ARB_clip_control = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_clip_control");
    GLAD_GL_ARB_color_buffer_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_color_buffer_float");
    GLAD_GL_ARB_compatibility = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_compatibility");
    GLAD_GL_ARB_compressed_texture_pixel_storage = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_compressed_texture_pixel_storage");
    GLAD_GL_ARB_compute_shader = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_compute_shader");
    GLAD_GL_ARB_compute_variable_group_size = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_compute_variable_group_size");
    GLAD_GL_ARB_conditional_render_inverted = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_conditional_render_inverted");
    GLAD_GL_ARB_conservative_depth = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_conservative_depth");
    GLAD_GL_ARB_copy_buffer = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_copy_buffer");
    GLAD_GL_ARB_copy_image = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_copy_image");
    GLAD_GL_ARB_cull_distance = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_cull_distance");
    GLAD_GL_ARB_debug_output = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_debug_output");
    GLAD_GL_ARB_depth_buffer_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_depth_buffer_float");
    GLAD_GL_ARB_depth_clamp = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_depth_clamp");
    GLAD_GL_ARB_depth_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_depth_texture");
    GLAD_GL_ARB_derivative_control = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_derivative_control");
    GLAD_GL_ARB_direct_state_access = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_direct_state_access");
    GLAD_GL_ARB_draw_buffers = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_draw_buffers");
    GLAD_GL_ARB_draw_buffers_blend = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_draw_buffers_blend");
    GLAD_GL_ARB_draw_elements_base_vertex = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_draw_elements_base_vertex");
    GLAD_GL_ARB_draw_indirect = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_draw_indirect");
    GLAD_GL_ARB_draw_instanced = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_draw_instanced");
    GLAD_GL_ARB_enhanced_layouts = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_enhanced_layouts");
    GLAD_GL_ARB_explicit_attrib_location = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_explicit_attrib_location");
    GLAD_GL_ARB_explicit_uniform_location = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_explicit_uniform_location");
    GLAD_GL_ARB_fragment_coord_conventions = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_fragment_coord_conventions");
    GLAD_GL_ARB_fragment_layer_viewport = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_fragment_layer_viewport");
    GLAD_GL_ARB_fragment_program = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_fragment_program");
    GLAD_GL_ARB_fragment_program_shadow = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_fragment_program_shadow");
    GLAD_GL_ARB_fragment_shader = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_fragment_shader");
    GLAD_GL_ARB_fragment_shader_interlock = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_fragment_shader_interlock");
    GLAD_GL_ARB_framebuffer_no_attachments = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_framebuffer_no_attachments");
    GLAD_GL_ARB_framebuffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_framebuffer_object");
    GLAD_GL_ARB_framebuffer_sRGB = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_framebuffer_sRGB");
    GLAD_GL_ARB_geometry_shader4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_geometry_shader4");
    GLAD_GL_ARB_get_program_binary = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_get_program_binary");
    GLAD_GL_ARB_get_texture_sub_image = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_get_texture_sub_image");
    GLAD_GL_ARB_gl_spirv = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_gl_spirv");
    GLAD_GL_ARB_gpu_shader5 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_gpu_shader5");
    GLAD_GL_ARB_gpu_shader_fp64 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_gpu_shader_fp64");
    GLAD_GL_ARB_gpu_shader_int64 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_gpu_shader_int64");
    GLAD_GL_ARB_half_float_pixel = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_half_float_pixel");
    GLAD_GL_ARB_half_float_vertex = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_half_float_vertex");
    GLAD_GL_ARB_imaging = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_imaging");
    GLAD_GL_ARB_indirect_parameters = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_indirect_parameters");
    GLAD_GL_ARB_instanced_arrays = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_instanced_arrays");
    GLAD_GL_ARB_internalformat_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_internalformat_query");
    GLAD_GL_ARB_internalformat_query2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_internalformat_query2");
    GLAD_GL_ARB_invalidate_subdata = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_invalidate_subdata");
    GLAD_GL_ARB_map_buffer_alignment = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_map_buffer_alignment");
    GLAD_GL_ARB_map_buffer_range = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_map_buffer_range");
    GLAD_GL_ARB_matrix_palette = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_matrix_palette");
    GLAD_GL_ARB_multi_bind = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_multi_bind");
    GLAD_GL_ARB_multi_draw_indirect = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_multi_draw_indirect");
    GLAD_GL_ARB_multisample = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_multisample");
    GLAD_GL_ARB_multitexture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_multitexture");
    GLAD_GL_ARB_occlusion_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_occlusion_query");
    GLAD_GL_ARB_occlusion_query2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_occlusion_query2");
    GLAD_GL_ARB_parallel_shader_compile = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_parallel_shader_compile");
    GLAD_GL_ARB_pipeline_statistics_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_pipeline_statistics_query");
    GLAD_GL_ARB_pixel_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_pixel_buffer_object");
    GLAD_GL_ARB_point_parameters = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_point_parameters");
    GLAD_GL_ARB_point_sprite = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_point_sprite");
    GLAD_GL_ARB_polygon_offset_clamp = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_polygon_offset_clamp");
    GLAD_GL_ARB_post_depth_coverage = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_post_depth_coverage");
    GLAD_GL_ARB_program_interface_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_program_interface_query");
    GLAD_GL_ARB_provoking_vertex = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_provoking_vertex");
    GLAD_GL_ARB_query_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_query_buffer_object");
    GLAD_GL_ARB_robust_buffer_access_behavior = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_robust_buffer_access_behavior");
    GLAD_GL_ARB_robustness = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_robustness");
    GLAD_GL_ARB_robustness_isolation = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_robustness_isolation");
    GLAD_GL_ARB_sample_locations = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_sample_locations");
    GLAD_GL_ARB_sample_shading = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_sample_shading");
    GLAD_GL_ARB_sampler_objects = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_sampler_objects");
    GLAD_GL_ARB_seamless_cube_map = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_seamless_cube_map");
    GLAD_GL_ARB_seamless_cubemap_per_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_seamless_cubemap_per_texture");
    GLAD_GL_ARB_separate_shader_objects = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_separate_shader_objects");
    GLAD_GL_ARB_shader_atomic_counter_ops = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_atomic_counter_ops");
    GLAD_GL_ARB_shader_atomic_counters = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_atomic_counters");
    GLAD_GL_ARB_shader_ballot = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_ballot");
    GLAD_GL_ARB_shader_bit_encoding = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_bit_encoding");
    GLAD_GL_ARB_shader_clock = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_clock");
    GLAD_GL_ARB_shader_draw_parameters = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_draw_parameters");
    GLAD_GL_ARB_shader_group_vote = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_group_vote");
    GLAD_GL_ARB_shader_image_load_store = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_image_load_store");
    GLAD_GL_ARB_shader_image_size = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_image_size");
    GLAD_GL_ARB_shader_objects = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_objects");
    GLAD_GL_ARB_shader_precision = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_precision");
    GLAD_GL_ARB_shader_stencil_export = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_stencil_export");
    GLAD_GL_ARB_shader_storage_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_storage_buffer_object");
    GLAD_GL_ARB_shader_subroutine = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_subroutine");
    GLAD_GL_ARB_shader_texture_image_samples = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_texture_image_samples");
    GLAD_GL_ARB_shader_texture_lod = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_texture_lod");
    GLAD_GL_ARB_shader_viewport_layer_array = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shader_viewport_layer_array");
    GLAD_GL_ARB_shading_language_100 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shading_language_100");
    GLAD_GL_ARB_shading_language_420pack = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shading_language_420pack");
    GLAD_GL_ARB_shading_language_include = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shading_language_include");
    GLAD_GL_ARB_shading_language_packing = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shading_language_packing");
    GLAD_GL_ARB_shadow = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shadow");
    GLAD_GL_ARB_shadow_ambient = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_shadow_ambient");
    GLAD_GL_ARB_sparse_buffer = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_sparse_buffer");
    GLAD_GL_ARB_sparse_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_sparse_texture");
    GLAD_GL_ARB_sparse_texture2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_sparse_texture2");
    GLAD_GL_ARB_sparse_texture_clamp = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_sparse_texture_clamp");
    GLAD_GL_ARB_spirv_extensions = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_spirv_extensions");
    GLAD_GL_ARB_stencil_texturing = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_stencil_texturing");
    GLAD_GL_ARB_sync = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_sync");
    GLAD_GL_ARB_tessellation_shader = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_tessellation_shader");
    GLAD_GL_ARB_texture_barrier = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_barrier");
    GLAD_GL_ARB_texture_border_clamp = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_border_clamp");
    GLAD_GL_ARB_texture_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_buffer_object");
    GLAD_GL_ARB_texture_buffer_object_rgb32 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_buffer_object_rgb32");
    GLAD_GL_ARB_texture_buffer_range = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_buffer_range");
    GLAD_GL_ARB_texture_compression = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_compression");
    GLAD_GL_ARB_texture_compression_bptc = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_compression_bptc");
    GLAD_GL_ARB_texture_compression_rgtc = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_compression_rgtc");
    GLAD_GL_ARB_texture_cube_map = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_cube_map");
    GLAD_GL_ARB_texture_cube_map_array = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_cube_map_array");
    GLAD_GL_ARB_texture_env_add = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_env_add");
    GLAD_GL_ARB_texture_env_combine = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_env_combine");
    GLAD_GL_ARB_texture_env_crossbar = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_env_crossbar");
    GLAD_GL_ARB_texture_env_dot3 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_env_dot3");
    GLAD_GL_ARB_texture_filter_anisotropic = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_filter_anisotropic");
    GLAD_GL_ARB_texture_filter_minmax = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_filter_minmax");
    GLAD_GL_ARB_texture_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_float");
    GLAD_GL_ARB_texture_gather = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_gather");
    GLAD_GL_ARB_texture_mirror_clamp_to_edge = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_mirror_clamp_to_edge");
    GLAD_GL_ARB_texture_mirrored_repeat = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_mirrored_repeat");
    GLAD_GL_ARB_texture_multisample = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_multisample");
    GLAD_GL_ARB_texture_non_power_of_two = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_non_power_of_two");
    GLAD_GL_ARB_texture_query_levels = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_query_levels");
    GLAD_GL_ARB_texture_query_lod = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_query_lod");
    GLAD_GL_ARB_texture_rectangle = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_rectangle");
    GLAD_GL_ARB_texture_rg = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_rg");
    GLAD_GL_ARB_texture_rgb10_a2ui = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_rgb10_a2ui");
    GLAD_GL_ARB_texture_stencil8 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_stencil8");
    GLAD_GL_ARB_texture_storage = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_storage");
    GLAD_GL_ARB_texture_storage_multisample = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_storage_multisample");
    GLAD_GL_ARB_texture_swizzle = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_swizzle");
    GLAD_GL_ARB_texture_view = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_texture_view");
    GLAD_GL_ARB_timer_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_timer_query");
    GLAD_GL_ARB_transform_feedback2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_transform_feedback2");
    GLAD_GL_ARB_transform_feedback3 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_transform_feedback3");
    GLAD_GL_ARB_transform_feedback_instanced = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_transform_feedback_instanced");
    GLAD_GL_ARB_transform_feedback_overflow_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_transform_feedback_overflow_query");
    GLAD_GL_ARB_transpose_matrix = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_transpose_matrix");
    GLAD_GL_ARB_uniform_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_uniform_buffer_object");
    GLAD_GL_ARB_vertex_array_bgra = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_array_bgra");
    GLAD_GL_ARB_vertex_array_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_array_object");
    GLAD_GL_ARB_vertex_attrib_64bit = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_attrib_64bit");
    GLAD_GL_ARB_vertex_attrib_binding = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_attrib_binding");
    GLAD_GL_ARB_vertex_blend = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_blend");
    GLAD_GL_ARB_vertex_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_buffer_object");
    GLAD_GL_ARB_vertex_program = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_program");
    GLAD_GL_ARB_vertex_shader = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_shader");
    GLAD_GL_ARB_vertex_type_10f_11f_11f_rev = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_type_10f_11f_11f_rev");
    GLAD_GL_ARB_vertex_type_2_10_10_10_rev = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_vertex_type_2_10_10_10_rev");
    GLAD_GL_ARB_viewport_array = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_viewport_array");
    GLAD_GL_ARB_window_pos = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ARB_window_pos");
    GLAD_GL_ATI_draw_buffers = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_draw_buffers");
    GLAD_GL_ATI_element_array = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_element_array");
    GLAD_GL_ATI_envmap_bumpmap = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_envmap_bumpmap");
    GLAD_GL_ATI_fragment_shader = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_fragment_shader");
    GLAD_GL_ATI_map_object_buffer = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_map_object_buffer");
    GLAD_GL_ATI_meminfo = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_meminfo");
    GLAD_GL_ATI_pixel_format_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_pixel_format_float");
    GLAD_GL_ATI_pn_triangles = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_pn_triangles");
    GLAD_GL_ATI_separate_stencil = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_separate_stencil");
    GLAD_GL_ATI_text_fragment_shader = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_text_fragment_shader");
    GLAD_GL_ATI_texture_env_combine3 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_texture_env_combine3");
    GLAD_GL_ATI_texture_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_texture_float");
    GLAD_GL_ATI_texture_mirror_once = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_texture_mirror_once");
    GLAD_GL_ATI_vertex_array_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_vertex_array_object");
    GLAD_GL_ATI_vertex_attrib_array_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_vertex_attrib_array_object");
    GLAD_GL_ATI_vertex_streams = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_ATI_vertex_streams");
    GLAD_GL_EXT_422_pixels = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_422_pixels");
    GLAD_GL_EXT_abgr = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_abgr");
    GLAD_GL_EXT_bgra = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_bgra");
    GLAD_GL_EXT_bindable_uniform = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_bindable_uniform");
    GLAD_GL_EXT_blend_color = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_blend_color");
    GLAD_GL_EXT_blend_equation_separate = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_blend_equation_separate");
    GLAD_GL_EXT_blend_func_separate = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_blend_func_separate");
    GLAD_GL_EXT_blend_logic_op = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_blend_logic_op");
    GLAD_GL_EXT_blend_minmax = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_blend_minmax");
    GLAD_GL_EXT_blend_subtract = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_blend_subtract");
    GLAD_GL_EXT_clip_volume_hint = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_clip_volume_hint");
    GLAD_GL_EXT_cmyka = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_cmyka");
    GLAD_GL_EXT_color_subtable = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_color_subtable");
    GLAD_GL_EXT_compiled_vertex_array = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_compiled_vertex_array");
    GLAD_GL_EXT_convolution = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_convolution");
    GLAD_GL_EXT_coordinate_frame = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_coordinate_frame");
    GLAD_GL_EXT_copy_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_copy_texture");
    GLAD_GL_EXT_cull_vertex = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_cull_vertex");
    GLAD_GL_EXT_debug_label = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_debug_label");
    GLAD_GL_EXT_debug_marker = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_debug_marker");
    GLAD_GL_EXT_depth_bounds_test = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_depth_bounds_test");
    GLAD_GL_EXT_direct_state_access = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_direct_state_access");
    GLAD_GL_EXT_draw_buffers2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_draw_buffers2");
    GLAD_GL_EXT_draw_instanced = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_draw_instanced");
    GLAD_GL_EXT_draw_range_elements = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_draw_range_elements");
    GLAD_GL_EXT_external_buffer = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_external_buffer");
    GLAD_GL_EXT_fog_coord = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_fog_coord");
    GLAD_GL_EXT_framebuffer_blit = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_framebuffer_blit");
    GLAD_GL_EXT_framebuffer_multisample = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_framebuffer_multisample");
    GLAD_GL_EXT_framebuffer_multisample_blit_scaled = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_framebuffer_multisample_blit_scaled");
    GLAD_GL_EXT_framebuffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_framebuffer_object");
    GLAD_GL_EXT_framebuffer_sRGB = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_framebuffer_sRGB");
    GLAD_GL_EXT_geometry_shader4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_geometry_shader4");
    GLAD_GL_EXT_gpu_program_parameters = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_gpu_program_parameters");
    GLAD_GL_EXT_gpu_shader4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_gpu_shader4");
    GLAD_GL_EXT_histogram = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_histogram");
    GLAD_GL_EXT_index_array_formats = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_index_array_formats");
    GLAD_GL_EXT_index_func = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_index_func");
    GLAD_GL_EXT_index_material = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_index_material");
    GLAD_GL_EXT_index_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_index_texture");
    GLAD_GL_EXT_light_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_light_texture");
    GLAD_GL_EXT_memory_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_memory_object");
    GLAD_GL_EXT_memory_object_fd = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_memory_object_fd");
    GLAD_GL_EXT_memory_object_win32 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_memory_object_win32");
    GLAD_GL_EXT_misc_attribute = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_misc_attribute");
    GLAD_GL_EXT_multi_draw_arrays = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_multi_draw_arrays");
    GLAD_GL_EXT_multisample = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_multisample");
    GLAD_GL_EXT_packed_depth_stencil = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_packed_depth_stencil");
    GLAD_GL_EXT_packed_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_packed_float");
    GLAD_GL_EXT_packed_pixels = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_packed_pixels");
    GLAD_GL_EXT_paletted_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_paletted_texture");
    GLAD_GL_EXT_pixel_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_pixel_buffer_object");
    GLAD_GL_EXT_pixel_transform = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_pixel_transform");
    GLAD_GL_EXT_pixel_transform_color_table = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_pixel_transform_color_table");
    GLAD_GL_EXT_point_parameters = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_point_parameters");
    GLAD_GL_EXT_polygon_offset = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_polygon_offset");
    GLAD_GL_EXT_polygon_offset_clamp = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_polygon_offset_clamp");
    GLAD_GL_EXT_post_depth_coverage = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_post_depth_coverage");
    GLAD_GL_EXT_provoking_vertex = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_provoking_vertex");
    GLAD_GL_EXT_raster_multisample = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_raster_multisample");
    GLAD_GL_EXT_rescale_normal = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_rescale_normal");
    GLAD_GL_EXT_secondary_color = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_secondary_color");
    GLAD_GL_EXT_semaphore = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_semaphore");
    GLAD_GL_EXT_semaphore_fd = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_semaphore_fd");
    GLAD_GL_EXT_semaphore_win32 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_semaphore_win32");
    GLAD_GL_EXT_separate_shader_objects = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_separate_shader_objects");
    GLAD_GL_EXT_separate_specular_color = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_separate_specular_color");
    GLAD_GL_EXT_shader_image_load_formatted = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_shader_image_load_formatted");
    GLAD_GL_EXT_shader_image_load_store = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_shader_image_load_store");
    GLAD_GL_EXT_shader_integer_mix = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_shader_integer_mix");
    GLAD_GL_EXT_shadow_funcs = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_shadow_funcs");
    GLAD_GL_EXT_shared_texture_palette = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_shared_texture_palette");
    GLAD_GL_EXT_sparse_texture2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_sparse_texture2");
    GLAD_GL_EXT_stencil_clear_tag = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_stencil_clear_tag");
    GLAD_GL_EXT_stencil_two_side = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_stencil_two_side");
    GLAD_GL_EXT_stencil_wrap = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_stencil_wrap");
    GLAD_GL_EXT_subtexture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_subtexture");
    GLAD_GL_EXT_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture");
    GLAD_GL_EXT_texture3D = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture3D");
    GLAD_GL_EXT_texture_array = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_array");
    GLAD_GL_EXT_texture_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_buffer_object");
    GLAD_GL_EXT_texture_compression_latc = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_compression_latc");
    GLAD_GL_EXT_texture_compression_rgtc = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_compression_rgtc");
    GLAD_GL_EXT_texture_compression_s3tc = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_compression_s3tc");
    GLAD_GL_EXT_texture_cube_map = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_cube_map");
    GLAD_GL_EXT_texture_env_add = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_env_add");
    GLAD_GL_EXT_texture_env_combine = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_env_combine");
    GLAD_GL_EXT_texture_env_dot3 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_env_dot3");
    GLAD_GL_EXT_texture_filter_anisotropic = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_filter_anisotropic");
    GLAD_GL_EXT_texture_filter_minmax = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_filter_minmax");
    GLAD_GL_EXT_texture_integer = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_integer");
    GLAD_GL_EXT_texture_lod_bias = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_lod_bias");
    GLAD_GL_EXT_texture_mirror_clamp = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_mirror_clamp");
    GLAD_GL_EXT_texture_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_object");
    GLAD_GL_EXT_texture_perturb_normal = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_perturb_normal");
    GLAD_GL_EXT_texture_sRGB = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_sRGB");
    GLAD_GL_EXT_texture_sRGB_decode = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_sRGB_decode");
    GLAD_GL_EXT_texture_shared_exponent = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_shared_exponent");
    GLAD_GL_EXT_texture_snorm = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_snorm");
    GLAD_GL_EXT_texture_swizzle = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_texture_swizzle");
    GLAD_GL_EXT_timer_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_timer_query");
    GLAD_GL_EXT_transform_feedback = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_transform_feedback");
    GLAD_GL_EXT_vertex_array = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_vertex_array");
    GLAD_GL_EXT_vertex_array_bgra = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_vertex_array_bgra");
    GLAD_GL_EXT_vertex_attrib_64bit = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_vertex_attrib_64bit");
    GLAD_GL_EXT_vertex_shader = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_vertex_shader");
    GLAD_GL_EXT_vertex_weighting = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_vertex_weighting");
    GLAD_GL_EXT_win32_keyed_mutex = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_win32_keyed_mutex");
    GLAD_GL_EXT_window_rectangles = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_window_rectangles");
    GLAD_GL_EXT_x11_sync_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_EXT_x11_sync_object");
    GLAD_GL_INTEL_conservative_rasterization = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_INTEL_conservative_rasterization");
    GLAD_GL_INTEL_fragment_shader_ordering = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_INTEL_fragment_shader_ordering");
    GLAD_GL_INTEL_framebuffer_CMAA = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_INTEL_framebuffer_CMAA");
    GLAD_GL_INTEL_map_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_INTEL_map_texture");
    GLAD_GL_INTEL_parallel_arrays = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_INTEL_parallel_arrays");
    GLAD_GL_INTEL_performance_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_INTEL_performance_query");
    GLAD_GL_KHR_blend_equation_advanced = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_blend_equation_advanced");
    GLAD_GL_KHR_blend_equation_advanced_coherent = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_blend_equation_advanced_coherent");
    GLAD_GL_KHR_context_flush_control = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_context_flush_control");
    GLAD_GL_KHR_debug = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_debug");
    GLAD_GL_KHR_no_error = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_no_error");
    GLAD_GL_KHR_parallel_shader_compile = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_parallel_shader_compile");
    GLAD_GL_KHR_robust_buffer_access_behavior = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_robust_buffer_access_behavior");
    GLAD_GL_KHR_robustness = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_robustness");
    GLAD_GL_KHR_texture_compression_astc_hdr = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_texture_compression_astc_hdr");
    GLAD_GL_KHR_texture_compression_astc_ldr = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_texture_compression_astc_ldr");
    GLAD_GL_KHR_texture_compression_astc_sliced_3d = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_KHR_texture_compression_astc_sliced_3d");
    GLAD_GL_MESAX_texture_stack = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_MESAX_texture_stack");
    GLAD_GL_MESA_pack_invert = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_MESA_pack_invert");
    GLAD_GL_MESA_resize_buffers = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_MESA_resize_buffers");
    GLAD_GL_MESA_shader_integer_functions = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_MESA_shader_integer_functions");
    GLAD_GL_MESA_window_pos = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_MESA_window_pos");
    GLAD_GL_MESA_ycbcr_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_MESA_ycbcr_texture");
    GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NVX_blend_equation_advanced_multi_draw_buffers");
    GLAD_GL_NVX_conditional_render = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NVX_conditional_render");
    GLAD_GL_NVX_gpu_memory_info = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NVX_gpu_memory_info");
    GLAD_GL_NVX_linked_gpu_multicast = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NVX_linked_gpu_multicast");
    GLAD_GL_NV_alpha_to_coverage_dither_control = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_alpha_to_coverage_dither_control");
    GLAD_GL_NV_bindless_multi_draw_indirect = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_bindless_multi_draw_indirect");
    GLAD_GL_NV_bindless_multi_draw_indirect_count = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_bindless_multi_draw_indirect_count");
    GLAD_GL_NV_bindless_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_bindless_texture");
    GLAD_GL_NV_blend_equation_advanced = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_blend_equation_advanced");
    GLAD_GL_NV_blend_equation_advanced_coherent = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_blend_equation_advanced_coherent");
    GLAD_GL_NV_blend_minmax_factor = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_blend_minmax_factor");
    GLAD_GL_NV_blend_square = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_blend_square");
    GLAD_GL_NV_clip_space_w_scaling = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_clip_space_w_scaling");
    GLAD_GL_NV_command_list = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_command_list");
    GLAD_GL_NV_compute_program5 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_compute_program5");
    GLAD_GL_NV_conditional_render = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_conditional_render");
    GLAD_GL_NV_conservative_raster = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_conservative_raster");
    GLAD_GL_NV_conservative_raster_dilate = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_conservative_raster_dilate");
    GLAD_GL_NV_conservative_raster_pre_snap_triangles = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_conservative_raster_pre_snap_triangles");
    GLAD_GL_NV_copy_depth_to_color = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_copy_depth_to_color");
    GLAD_GL_NV_copy_image = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_copy_image");
    GLAD_GL_NV_deep_texture3D = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_deep_texture3D");
    GLAD_GL_NV_depth_buffer_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_depth_buffer_float");
    GLAD_GL_NV_depth_clamp = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_depth_clamp");
    GLAD_GL_NV_draw_texture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_draw_texture");
    GLAD_GL_NV_draw_vulkan_image = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_draw_vulkan_image");
    GLAD_GL_NV_evaluators = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_evaluators");
    GLAD_GL_NV_explicit_multisample = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_explicit_multisample");
    GLAD_GL_NV_fence = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_fence");
    GLAD_GL_NV_fill_rectangle = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_fill_rectangle");
    GLAD_GL_NV_float_buffer = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_float_buffer");
    GLAD_GL_NV_fog_distance = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_fog_distance");
    GLAD_GL_NV_fragment_coverage_to_color = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_fragment_coverage_to_color");
    GLAD_GL_NV_fragment_program = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_fragment_program");
    GLAD_GL_NV_fragment_program2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_fragment_program2");
    GLAD_GL_NV_fragment_program4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_fragment_program4");
    GLAD_GL_NV_fragment_program_option = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_fragment_program_option");
    GLAD_GL_NV_fragment_shader_interlock = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_fragment_shader_interlock");
    GLAD_GL_NV_framebuffer_mixed_samples = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_framebuffer_mixed_samples");
    GLAD_GL_NV_framebuffer_multisample_coverage = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_framebuffer_multisample_coverage");
    GLAD_GL_NV_geometry_program4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_geometry_program4");
    GLAD_GL_NV_geometry_shader4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_geometry_shader4");
    GLAD_GL_NV_geometry_shader_passthrough = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_geometry_shader_passthrough");
    GLAD_GL_NV_gpu_multicast = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_gpu_multicast");
    GLAD_GL_NV_gpu_program4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_gpu_program4");
    GLAD_GL_NV_gpu_program5 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_gpu_program5");
    GLAD_GL_NV_gpu_program5_mem_extended = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_gpu_program5_mem_extended");
    GLAD_GL_NV_gpu_shader5 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_gpu_shader5");
    GLAD_GL_NV_half_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_half_float");
    GLAD_GL_NV_internalformat_sample_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_internalformat_sample_query");
    GLAD_GL_NV_light_max_exponent = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_light_max_exponent");
    GLAD_GL_NV_multisample_coverage = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_multisample_coverage");
    GLAD_GL_NV_multisample_filter_hint = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_multisample_filter_hint");
    GLAD_GL_NV_occlusion_query = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_occlusion_query");
    GLAD_GL_NV_packed_depth_stencil = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_packed_depth_stencil");
    GLAD_GL_NV_parameter_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_parameter_buffer_object");
    GLAD_GL_NV_parameter_buffer_object2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_parameter_buffer_object2");
    GLAD_GL_NV_path_rendering = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_path_rendering");
    GLAD_GL_NV_path_rendering_shared_edge = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_path_rendering_shared_edge");
    GLAD_GL_NV_pixel_data_range = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_pixel_data_range");
    GLAD_GL_NV_point_sprite = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_point_sprite");
    GLAD_GL_NV_present_video = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_present_video");
    GLAD_GL_NV_primitive_restart = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_primitive_restart");
    GLAD_GL_NV_query_resource = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_query_resource");
    GLAD_GL_NV_query_resource_tag = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_query_resource_tag");
    GLAD_GL_NV_register_combiners = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_register_combiners");
    GLAD_GL_NV_register_combiners2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_register_combiners2");
    GLAD_GL_NV_robustness_video_memory_purge = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_robustness_video_memory_purge");
    GLAD_GL_NV_sample_locations = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_sample_locations");
    GLAD_GL_NV_sample_mask_override_coverage = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_sample_mask_override_coverage");
    GLAD_GL_NV_shader_atomic_counters = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_atomic_counters");
    GLAD_GL_NV_shader_atomic_float = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_atomic_float");
    GLAD_GL_NV_shader_atomic_float64 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_atomic_float64");
    GLAD_GL_NV_shader_atomic_fp16_vector = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_atomic_fp16_vector");
    GLAD_GL_NV_shader_atomic_int64 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_atomic_int64");
    GLAD_GL_NV_shader_buffer_load = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_buffer_load");
    GLAD_GL_NV_shader_buffer_store = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_buffer_store");
    GLAD_GL_NV_shader_storage_buffer_object = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_storage_buffer_object");
    GLAD_GL_NV_shader_thread_group = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_thread_group");
    GLAD_GL_NV_shader_thread_shuffle = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_shader_thread_shuffle");
    GLAD_GL_NV_stereo_view_rendering = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_stereo_view_rendering");
    GLAD_GL_NV_tessellation_program5 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_tessellation_program5");
    GLAD_GL_NV_texgen_emboss = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texgen_emboss");
    GLAD_GL_NV_texgen_reflection = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texgen_reflection");
    GLAD_GL_NV_texture_barrier = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_barrier");
    GLAD_GL_NV_texture_compression_vtc = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_compression_vtc");
    GLAD_GL_NV_texture_env_combine4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_env_combine4");
    GLAD_GL_NV_texture_expand_normal = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_expand_normal");
    GLAD_GL_NV_texture_multisample = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_multisample");
    GLAD_GL_NV_texture_rectangle = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_rectangle");
    GLAD_GL_NV_texture_rectangle_compressed = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_rectangle_compressed");
    GLAD_GL_NV_texture_shader = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_shader");
    GLAD_GL_NV_texture_shader2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_shader2");
    GLAD_GL_NV_texture_shader3 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_texture_shader3");
    GLAD_GL_NV_transform_feedback = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_transform_feedback");
    GLAD_GL_NV_transform_feedback2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_transform_feedback2");
    GLAD_GL_NV_uniform_buffer_unified_memory = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_uniform_buffer_unified_memory");
    GLAD_GL_NV_vdpau_interop = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vdpau_interop");
    GLAD_GL_NV_vertex_array_range = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_array_range");
    GLAD_GL_NV_vertex_array_range2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_array_range2");
    GLAD_GL_NV_vertex_attrib_integer_64bit = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_attrib_integer_64bit");
    GLAD_GL_NV_vertex_buffer_unified_memory = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_buffer_unified_memory");
    GLAD_GL_NV_vertex_program = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_program");
    GLAD_GL_NV_vertex_program1_1 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_program1_1");
    GLAD_GL_NV_vertex_program2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_program2");
    GLAD_GL_NV_vertex_program2_option = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_program2_option");
    GLAD_GL_NV_vertex_program3 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_program3");
    GLAD_GL_NV_vertex_program4 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_vertex_program4");
    GLAD_GL_NV_video_capture = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_video_capture");
    GLAD_GL_NV_viewport_array2 = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_viewport_array2");
    GLAD_GL_NV_viewport_swizzle = glad_gl_has_extension(version, exts, num_exts_i, exts_i, "GL_NV_viewport_swizzle");

    glad_gl_free_extensions(exts_i, num_exts_i);

    return 1;
}

static int glad_gl_find_core_gl(void) {
    int i, major, minor;
    const char* version;
    const char* prefixes[] = {
        "OpenGL ES-CM ",
        "OpenGL ES-CL ",
        "OpenGL ES ",
        NULL
    };
    version = (const char*) glad_glGetString(GL_VERSION);
    if (!version) return 0;
    for (i = 0;  prefixes[i];  i++) {
        const size_t length = strlen(prefixes[i]);
        if (strncmp(version, prefixes[i], length) == 0) {
            version += length;
            break;
        }
    }

    GLAD_IMPL_UTIL_SSCANF(version, "%d.%d", &major, &minor);

    GLAD_GL_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;
    GLAD_GL_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;
    GLAD_GL_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;
    GLAD_GL_VERSION_1_3 = (major == 1 && minor >= 3) || major > 1;
    GLAD_GL_VERSION_1_4 = (major == 1 && minor >= 4) || major > 1;
    GLAD_GL_VERSION_1_5 = (major == 1 && minor >= 5) || major > 1;
    GLAD_GL_VERSION_2_0 = (major == 2 && minor >= 0) || major > 2;
    GLAD_GL_VERSION_2_1 = (major == 2 && minor >= 1) || major > 2;
    GLAD_GL_VERSION_3_0 = (major == 3 && minor >= 0) || major > 3;
    GLAD_GL_VERSION_3_1 = (major == 3 && minor >= 1) || major > 3;
    GLAD_GL_VERSION_3_2 = (major == 3 && minor >= 2) || major > 3;
    GLAD_GL_VERSION_3_3 = (major == 3 && minor >= 3) || major > 3;
    GLAD_GL_VERSION_4_0 = (major == 4 && minor >= 0) || major > 4;
    GLAD_GL_VERSION_4_1 = (major == 4 && minor >= 1) || major > 4;
    GLAD_GL_VERSION_4_2 = (major == 4 && minor >= 2) || major > 4;
    GLAD_GL_VERSION_4_3 = (major == 4 && minor >= 3) || major > 4;
    GLAD_GL_VERSION_4_4 = (major == 4 && minor >= 4) || major > 4;
    GLAD_GL_VERSION_4_5 = (major == 4 && minor >= 5) || major > 4;
    GLAD_GL_VERSION_4_6 = (major == 4 && minor >= 6) || major > 4;

    return GLAD_MAKE_VERSION(major, minor);
}

int gladLoadGLUserPtr( GLADuserptrloadfunc load, void *userptr) {
    int version;

    glad_glGetString = (PFNGLGETSTRINGPROC) load(userptr, "glGetString");
    if(glad_glGetString == NULL) return 0;
    if(glad_glGetString(GL_VERSION) == NULL) return 0;
    version = glad_gl_find_core_gl();

    glad_gl_load_GL_VERSION_1_0(load, userptr);
    glad_gl_load_GL_VERSION_1_1(load, userptr);
    glad_gl_load_GL_VERSION_1_2(load, userptr);
    glad_gl_load_GL_VERSION_1_3(load, userptr);
    glad_gl_load_GL_VERSION_1_4(load, userptr);
    glad_gl_load_GL_VERSION_1_5(load, userptr);
    glad_gl_load_GL_VERSION_2_0(load, userptr);
    glad_gl_load_GL_VERSION_2_1(load, userptr);
    glad_gl_load_GL_VERSION_3_0(load, userptr);
    glad_gl_load_GL_VERSION_3_1(load, userptr);
    glad_gl_load_GL_VERSION_3_2(load, userptr);
    glad_gl_load_GL_VERSION_3_3(load, userptr);
    glad_gl_load_GL_VERSION_4_0(load, userptr);
    glad_gl_load_GL_VERSION_4_1(load, userptr);
    glad_gl_load_GL_VERSION_4_2(load, userptr);
    glad_gl_load_GL_VERSION_4_3(load, userptr);
    glad_gl_load_GL_VERSION_4_4(load, userptr);
    glad_gl_load_GL_VERSION_4_5(load, userptr);
    glad_gl_load_GL_VERSION_4_6(load, userptr);

    if (!glad_gl_find_extensions_gl(version)) return 0;
    glad_gl_load_GL_AMD_debug_output(load, userptr);
    glad_gl_load_GL_AMD_draw_buffers_blend(load, userptr);
    glad_gl_load_GL_AMD_framebuffer_sample_positions(load, userptr);
    glad_gl_load_GL_AMD_gpu_shader_int64(load, userptr);
    glad_gl_load_GL_AMD_interleaved_elements(load, userptr);
    glad_gl_load_GL_AMD_multi_draw_indirect(load, userptr);
    glad_gl_load_GL_AMD_name_gen_delete(load, userptr);
    glad_gl_load_GL_AMD_occlusion_query_event(load, userptr);
    glad_gl_load_GL_AMD_performance_monitor(load, userptr);
    glad_gl_load_GL_AMD_sample_positions(load, userptr);
    glad_gl_load_GL_AMD_sparse_texture(load, userptr);
    glad_gl_load_GL_AMD_stencil_operation_extended(load, userptr);
    glad_gl_load_GL_AMD_vertex_shader_tessellator(load, userptr);
    glad_gl_load_GL_APPLE_element_array(load, userptr);
    glad_gl_load_GL_APPLE_fence(load, userptr);
    glad_gl_load_GL_APPLE_flush_buffer_range(load, userptr);
    glad_gl_load_GL_APPLE_object_purgeable(load, userptr);
    glad_gl_load_GL_APPLE_texture_range(load, userptr);
    glad_gl_load_GL_APPLE_vertex_array_object(load, userptr);
    glad_gl_load_GL_APPLE_vertex_array_range(load, userptr);
    glad_gl_load_GL_APPLE_vertex_program_evaluators(load, userptr);
    glad_gl_load_GL_ARB_ES2_compatibility(load, userptr);
    glad_gl_load_GL_ARB_ES3_1_compatibility(load, userptr);
    glad_gl_load_GL_ARB_ES3_2_compatibility(load, userptr);
    glad_gl_load_GL_ARB_base_instance(load, userptr);
    glad_gl_load_GL_ARB_bindless_texture(load, userptr);
    glad_gl_load_GL_ARB_blend_func_extended(load, userptr);
    glad_gl_load_GL_ARB_buffer_storage(load, userptr);
    glad_gl_load_GL_ARB_cl_event(load, userptr);
    glad_gl_load_GL_ARB_clear_buffer_object(load, userptr);
    glad_gl_load_GL_ARB_clear_texture(load, userptr);
    glad_gl_load_GL_ARB_clip_control(load, userptr);
    glad_gl_load_GL_ARB_color_buffer_float(load, userptr);
    glad_gl_load_GL_ARB_compute_shader(load, userptr);
    glad_gl_load_GL_ARB_compute_variable_group_size(load, userptr);
    glad_gl_load_GL_ARB_copy_buffer(load, userptr);
    glad_gl_load_GL_ARB_copy_image(load, userptr);
    glad_gl_load_GL_ARB_debug_output(load, userptr);
    glad_gl_load_GL_ARB_direct_state_access(load, userptr);
    glad_gl_load_GL_ARB_draw_buffers(load, userptr);
    glad_gl_load_GL_ARB_draw_buffers_blend(load, userptr);
    glad_gl_load_GL_ARB_draw_elements_base_vertex(load, userptr);
    glad_gl_load_GL_ARB_draw_indirect(load, userptr);
    glad_gl_load_GL_ARB_draw_instanced(load, userptr);
    glad_gl_load_GL_ARB_fragment_program(load, userptr);
    glad_gl_load_GL_ARB_framebuffer_no_attachments(load, userptr);
    glad_gl_load_GL_ARB_framebuffer_object(load, userptr);
    glad_gl_load_GL_ARB_geometry_shader4(load, userptr);
    glad_gl_load_GL_ARB_get_program_binary(load, userptr);
    glad_gl_load_GL_ARB_get_texture_sub_image(load, userptr);
    glad_gl_load_GL_ARB_gl_spirv(load, userptr);
    glad_gl_load_GL_ARB_gpu_shader_fp64(load, userptr);
    glad_gl_load_GL_ARB_gpu_shader_int64(load, userptr);
    glad_gl_load_GL_ARB_imaging(load, userptr);
    glad_gl_load_GL_ARB_indirect_parameters(load, userptr);
    glad_gl_load_GL_ARB_instanced_arrays(load, userptr);
    glad_gl_load_GL_ARB_internalformat_query(load, userptr);
    glad_gl_load_GL_ARB_internalformat_query2(load, userptr);
    glad_gl_load_GL_ARB_invalidate_subdata(load, userptr);
    glad_gl_load_GL_ARB_map_buffer_range(load, userptr);
    glad_gl_load_GL_ARB_matrix_palette(load, userptr);
    glad_gl_load_GL_ARB_multi_bind(load, userptr);
    glad_gl_load_GL_ARB_multi_draw_indirect(load, userptr);
    glad_gl_load_GL_ARB_multisample(load, userptr);
    glad_gl_load_GL_ARB_multitexture(load, userptr);
    glad_gl_load_GL_ARB_occlusion_query(load, userptr);
    glad_gl_load_GL_ARB_parallel_shader_compile(load, userptr);
    glad_gl_load_GL_ARB_point_parameters(load, userptr);
    glad_gl_load_GL_ARB_polygon_offset_clamp(load, userptr);
    glad_gl_load_GL_ARB_program_interface_query(load, userptr);
    glad_gl_load_GL_ARB_provoking_vertex(load, userptr);
    glad_gl_load_GL_ARB_robustness(load, userptr);
    glad_gl_load_GL_ARB_sample_locations(load, userptr);
    glad_gl_load_GL_ARB_sample_shading(load, userptr);
    glad_gl_load_GL_ARB_sampler_objects(load, userptr);
    glad_gl_load_GL_ARB_separate_shader_objects(load, userptr);
    glad_gl_load_GL_ARB_shader_atomic_counters(load, userptr);
    glad_gl_load_GL_ARB_shader_image_load_store(load, userptr);
    glad_gl_load_GL_ARB_shader_objects(load, userptr);
    glad_gl_load_GL_ARB_shader_storage_buffer_object(load, userptr);
    glad_gl_load_GL_ARB_shader_subroutine(load, userptr);
    glad_gl_load_GL_ARB_shading_language_include(load, userptr);
    glad_gl_load_GL_ARB_sparse_buffer(load, userptr);
    glad_gl_load_GL_ARB_sparse_texture(load, userptr);
    glad_gl_load_GL_ARB_sync(load, userptr);
    glad_gl_load_GL_ARB_tessellation_shader(load, userptr);
    glad_gl_load_GL_ARB_texture_barrier(load, userptr);
    glad_gl_load_GL_ARB_texture_buffer_object(load, userptr);
    glad_gl_load_GL_ARB_texture_buffer_range(load, userptr);
    glad_gl_load_GL_ARB_texture_compression(load, userptr);
    glad_gl_load_GL_ARB_texture_multisample(load, userptr);
    glad_gl_load_GL_ARB_texture_storage(load, userptr);
    glad_gl_load_GL_ARB_texture_storage_multisample(load, userptr);
    glad_gl_load_GL_ARB_texture_view(load, userptr);
    glad_gl_load_GL_ARB_timer_query(load, userptr);
    glad_gl_load_GL_ARB_transform_feedback2(load, userptr);
    glad_gl_load_GL_ARB_transform_feedback3(load, userptr);
    glad_gl_load_GL_ARB_transform_feedback_instanced(load, userptr);
    glad_gl_load_GL_ARB_transpose_matrix(load, userptr);
    glad_gl_load_GL_ARB_uniform_buffer_object(load, userptr);
    glad_gl_load_GL_ARB_vertex_array_object(load, userptr);
    glad_gl_load_GL_ARB_vertex_attrib_64bit(load, userptr);
    glad_gl_load_GL_ARB_vertex_attrib_binding(load, userptr);
    glad_gl_load_GL_ARB_vertex_blend(load, userptr);
    glad_gl_load_GL_ARB_vertex_buffer_object(load, userptr);
    glad_gl_load_GL_ARB_vertex_program(load, userptr);
    glad_gl_load_GL_ARB_vertex_shader(load, userptr);
    glad_gl_load_GL_ARB_vertex_type_2_10_10_10_rev(load, userptr);
    glad_gl_load_GL_ARB_viewport_array(load, userptr);
    glad_gl_load_GL_ARB_window_pos(load, userptr);
    glad_gl_load_GL_ATI_draw_buffers(load, userptr);
    glad_gl_load_GL_ATI_element_array(load, userptr);
    glad_gl_load_GL_ATI_envmap_bumpmap(load, userptr);
    glad_gl_load_GL_ATI_fragment_shader(load, userptr);
    glad_gl_load_GL_ATI_map_object_buffer(load, userptr);
    glad_gl_load_GL_ATI_pn_triangles(load, userptr);
    glad_gl_load_GL_ATI_separate_stencil(load, userptr);
    glad_gl_load_GL_ATI_vertex_array_object(load, userptr);
    glad_gl_load_GL_ATI_vertex_attrib_array_object(load, userptr);
    glad_gl_load_GL_ATI_vertex_streams(load, userptr);
    glad_gl_load_GL_EXT_bindable_uniform(load, userptr);
    glad_gl_load_GL_EXT_blend_color(load, userptr);
    glad_gl_load_GL_EXT_blend_equation_separate(load, userptr);
    glad_gl_load_GL_EXT_blend_func_separate(load, userptr);
    glad_gl_load_GL_EXT_blend_minmax(load, userptr);
    glad_gl_load_GL_EXT_color_subtable(load, userptr);
    glad_gl_load_GL_EXT_compiled_vertex_array(load, userptr);
    glad_gl_load_GL_EXT_convolution(load, userptr);
    glad_gl_load_GL_EXT_coordinate_frame(load, userptr);
    glad_gl_load_GL_EXT_copy_texture(load, userptr);
    glad_gl_load_GL_EXT_cull_vertex(load, userptr);
    glad_gl_load_GL_EXT_debug_label(load, userptr);
    glad_gl_load_GL_EXT_debug_marker(load, userptr);
    glad_gl_load_GL_EXT_depth_bounds_test(load, userptr);
    glad_gl_load_GL_EXT_direct_state_access(load, userptr);
    glad_gl_load_GL_EXT_draw_buffers2(load, userptr);
    glad_gl_load_GL_EXT_draw_instanced(load, userptr);
    glad_gl_load_GL_EXT_draw_range_elements(load, userptr);
    glad_gl_load_GL_EXT_external_buffer(load, userptr);
    glad_gl_load_GL_EXT_fog_coord(load, userptr);
    glad_gl_load_GL_EXT_framebuffer_blit(load, userptr);
    glad_gl_load_GL_EXT_framebuffer_multisample(load, userptr);
    glad_gl_load_GL_EXT_framebuffer_object(load, userptr);
    glad_gl_load_GL_EXT_geometry_shader4(load, userptr);
    glad_gl_load_GL_EXT_gpu_program_parameters(load, userptr);
    glad_gl_load_GL_EXT_gpu_shader4(load, userptr);
    glad_gl_load_GL_EXT_histogram(load, userptr);
    glad_gl_load_GL_EXT_index_func(load, userptr);
    glad_gl_load_GL_EXT_index_material(load, userptr);
    glad_gl_load_GL_EXT_light_texture(load, userptr);
    glad_gl_load_GL_EXT_memory_object(load, userptr);
    glad_gl_load_GL_EXT_memory_object_fd(load, userptr);
    glad_gl_load_GL_EXT_memory_object_win32(load, userptr);
    glad_gl_load_GL_EXT_multi_draw_arrays(load, userptr);
    glad_gl_load_GL_EXT_multisample(load, userptr);
    glad_gl_load_GL_EXT_paletted_texture(load, userptr);
    glad_gl_load_GL_EXT_pixel_transform(load, userptr);
    glad_gl_load_GL_EXT_point_parameters(load, userptr);
    glad_gl_load_GL_EXT_polygon_offset(load, userptr);
    glad_gl_load_GL_EXT_polygon_offset_clamp(load, userptr);
    glad_gl_load_GL_EXT_provoking_vertex(load, userptr);
    glad_gl_load_GL_EXT_raster_multisample(load, userptr);
    glad_gl_load_GL_EXT_secondary_color(load, userptr);
    glad_gl_load_GL_EXT_semaphore(load, userptr);
    glad_gl_load_GL_EXT_semaphore_fd(load, userptr);
    glad_gl_load_GL_EXT_semaphore_win32(load, userptr);
    glad_gl_load_GL_EXT_separate_shader_objects(load, userptr);
    glad_gl_load_GL_EXT_shader_image_load_store(load, userptr);
    glad_gl_load_GL_EXT_stencil_clear_tag(load, userptr);
    glad_gl_load_GL_EXT_stencil_two_side(load, userptr);
    glad_gl_load_GL_EXT_subtexture(load, userptr);
    glad_gl_load_GL_EXT_texture3D(load, userptr);
    glad_gl_load_GL_EXT_texture_array(load, userptr);
    glad_gl_load_GL_EXT_texture_buffer_object(load, userptr);
    glad_gl_load_GL_EXT_texture_integer(load, userptr);
    glad_gl_load_GL_EXT_texture_object(load, userptr);
    glad_gl_load_GL_EXT_texture_perturb_normal(load, userptr);
    glad_gl_load_GL_EXT_timer_query(load, userptr);
    glad_gl_load_GL_EXT_transform_feedback(load, userptr);
    glad_gl_load_GL_EXT_vertex_array(load, userptr);
    glad_gl_load_GL_EXT_vertex_attrib_64bit(load, userptr);
    glad_gl_load_GL_EXT_vertex_shader(load, userptr);
    glad_gl_load_GL_EXT_vertex_weighting(load, userptr);
    glad_gl_load_GL_EXT_win32_keyed_mutex(load, userptr);
    glad_gl_load_GL_EXT_window_rectangles(load, userptr);
    glad_gl_load_GL_EXT_x11_sync_object(load, userptr);
    glad_gl_load_GL_INTEL_framebuffer_CMAA(load, userptr);
    glad_gl_load_GL_INTEL_map_texture(load, userptr);
    glad_gl_load_GL_INTEL_parallel_arrays(load, userptr);
    glad_gl_load_GL_INTEL_performance_query(load, userptr);
    glad_gl_load_GL_KHR_blend_equation_advanced(load, userptr);
    glad_gl_load_GL_KHR_debug(load, userptr);
    glad_gl_load_GL_KHR_parallel_shader_compile(load, userptr);
    glad_gl_load_GL_KHR_robustness(load, userptr);
    glad_gl_load_GL_MESA_resize_buffers(load, userptr);
    glad_gl_load_GL_MESA_window_pos(load, userptr);
    glad_gl_load_GL_NVX_conditional_render(load, userptr);
    glad_gl_load_GL_NVX_linked_gpu_multicast(load, userptr);
    glad_gl_load_GL_NV_alpha_to_coverage_dither_control(load, userptr);
    glad_gl_load_GL_NV_bindless_multi_draw_indirect(load, userptr);
    glad_gl_load_GL_NV_bindless_multi_draw_indirect_count(load, userptr);
    glad_gl_load_GL_NV_bindless_texture(load, userptr);
    glad_gl_load_GL_NV_blend_equation_advanced(load, userptr);
    glad_gl_load_GL_NV_clip_space_w_scaling(load, userptr);
    glad_gl_load_GL_NV_command_list(load, userptr);
    glad_gl_load_GL_NV_conditional_render(load, userptr);
    glad_gl_load_GL_NV_conservative_raster(load, userptr);
    glad_gl_load_GL_NV_conservative_raster_dilate(load, userptr);
    glad_gl_load_GL_NV_conservative_raster_pre_snap_triangles(load, userptr);
    glad_gl_load_GL_NV_copy_image(load, userptr);
    glad_gl_load_GL_NV_depth_buffer_float(load, userptr);
    glad_gl_load_GL_NV_draw_texture(load, userptr);
    glad_gl_load_GL_NV_draw_vulkan_image(load, userptr);
    glad_gl_load_GL_NV_evaluators(load, userptr);
    glad_gl_load_GL_NV_explicit_multisample(load, userptr);
    glad_gl_load_GL_NV_fence(load, userptr);
    glad_gl_load_GL_NV_fragment_coverage_to_color(load, userptr);
    glad_gl_load_GL_NV_fragment_program(load, userptr);
    glad_gl_load_GL_NV_framebuffer_mixed_samples(load, userptr);
    glad_gl_load_GL_NV_framebuffer_multisample_coverage(load, userptr);
    glad_gl_load_GL_NV_geometry_program4(load, userptr);
    glad_gl_load_GL_NV_gpu_multicast(load, userptr);
    glad_gl_load_GL_NV_gpu_program4(load, userptr);
    glad_gl_load_GL_NV_gpu_program5(load, userptr);
    glad_gl_load_GL_NV_gpu_shader5(load, userptr);
    glad_gl_load_GL_NV_half_float(load, userptr);
    glad_gl_load_GL_NV_internalformat_sample_query(load, userptr);
    glad_gl_load_GL_NV_occlusion_query(load, userptr);
    glad_gl_load_GL_NV_parameter_buffer_object(load, userptr);
    glad_gl_load_GL_NV_path_rendering(load, userptr);
    glad_gl_load_GL_NV_pixel_data_range(load, userptr);
    glad_gl_load_GL_NV_point_sprite(load, userptr);
    glad_gl_load_GL_NV_present_video(load, userptr);
    glad_gl_load_GL_NV_primitive_restart(load, userptr);
    glad_gl_load_GL_NV_query_resource(load, userptr);
    glad_gl_load_GL_NV_query_resource_tag(load, userptr);
    glad_gl_load_GL_NV_register_combiners(load, userptr);
    glad_gl_load_GL_NV_register_combiners2(load, userptr);
    glad_gl_load_GL_NV_sample_locations(load, userptr);
    glad_gl_load_GL_NV_shader_buffer_load(load, userptr);
    glad_gl_load_GL_NV_texture_barrier(load, userptr);
    glad_gl_load_GL_NV_texture_multisample(load, userptr);
    glad_gl_load_GL_NV_transform_feedback(load, userptr);
    glad_gl_load_GL_NV_transform_feedback2(load, userptr);
    glad_gl_load_GL_NV_vdpau_interop(load, userptr);
    glad_gl_load_GL_NV_vertex_array_range(load, userptr);
    glad_gl_load_GL_NV_vertex_attrib_integer_64bit(load, userptr);
    glad_gl_load_GL_NV_vertex_buffer_unified_memory(load, userptr);
    glad_gl_load_GL_NV_vertex_program(load, userptr);
    glad_gl_load_GL_NV_vertex_program4(load, userptr);
    glad_gl_load_GL_NV_video_capture(load, userptr);
    glad_gl_load_GL_NV_viewport_swizzle(load, userptr);



    return version;
}


int gladLoadGL( GLADloadfunc load) {
    return gladLoadGLUserPtr( glad_gl_get_proc_from_userptr, GLAD_GNUC_EXTENSION (void*) load);
}



 

#ifdef GLAD_GL

#ifndef GLAD_LOADER_LIBRARY_C_
#define GLAD_LOADER_LIBRARY_C_

#include <stddef.h>
#include <stdlib.h>

#if GLAD_PLATFORM_WIN32
#include <windows.h>
#else
#include <dlfcn.h>
#endif


static void* glad_get_dlopen_handle(const char *lib_names[], int length) {
    void *handle = NULL;
    int i;

    for (i = 0; i < length; ++i) {
#if GLAD_PLATFORM_WIN32
  #if GLAD_PLATFORM_UWP
        size_t buffer_size = (strlen(lib_names[i]) + 1) * sizeof(WCHAR);
        LPWSTR buffer = (LPWSTR) malloc(buffer_size);
        if (buffer != NULL) {
            int ret = MultiByteToWideChar(CP_ACP, 0, lib_names[i], -1, buffer, buffer_size);
            if (ret != 0) {
                handle = (void*) LoadPackagedLibrary(buffer, 0);
            }
            free((void*) buffer);
        }
  #else
        handle = (void*) LoadLibraryA(lib_names[i]);
  #endif
#else
        handle = dlopen(lib_names[i], RTLD_LAZY | RTLD_LOCAL);
#endif
        if (handle != NULL) {
            return handle;
        }
    }

    return NULL;
}

static void glad_close_dlopen_handle(void* handle) {
    if (handle != NULL) {
#if GLAD_PLATFORM_WIN32
        FreeLibrary((HMODULE) handle);
#else
        dlclose(handle);
#endif
    }
}

static GLADapiproc glad_dlsym_handle(void* handle, const char *name) {
    if (handle == NULL) {
        return NULL;
    }

#if GLAD_PLATFORM_WIN32
    return (GLADapiproc) GetProcAddress((HMODULE) handle, name);
#else
    return GLAD_GNUC_EXTENSION (GLADapiproc) dlsym(handle, name);
#endif
}

#endif /* GLAD_LOADER_LIBRARY_C_ */

typedef void* (GLAD_API_PTR *GLADglprocaddrfunc)(const char*);
struct _glad_gl_userptr {
    void *handle;
    GLADglprocaddrfunc gl_get_proc_address_ptr;
};

static GLADapiproc glad_gl_get_proc(void *vuserptr, const char *name) {
    struct _glad_gl_userptr userptr = *(struct _glad_gl_userptr*) vuserptr;
    GLADapiproc result = NULL;

    if(userptr.gl_get_proc_address_ptr != NULL) {
        result = GLAD_GNUC_EXTENSION (GLADapiproc) userptr.gl_get_proc_address_ptr(name);
    }
    if(result == NULL) {
        result = glad_dlsym_handle(userptr.handle, name);
    }

    return result;
}

static void* _gl_handle = NULL;

static void* glad_gl_dlopen_handle(void) {
#if GLAD_PLATFORM_APPLE
    static const char *NAMES[] = {
        "../Frameworks/OpenGL.framework/OpenGL",
        "/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL"
    };
#elif GLAD_PLATFORM_WIN32
    static const char *NAMES[] = {"opengl32.dll"};
#else
    static const char *NAMES[] = {
  #if defined(__CYGWIN__)
        "libGL-1.so",
  #endif
        "libGL.so.1",
        "libGL.so"
    };
#endif

    if (_gl_handle == NULL) {
        _gl_handle = glad_get_dlopen_handle(NAMES, sizeof(NAMES) / sizeof(NAMES[0]));
    }

    return _gl_handle;
}

static struct _glad_gl_userptr glad_gl_build_userptr(void *handle) {
    struct _glad_gl_userptr userptr;

    userptr.handle = handle;
#if GLAD_PLATFORM_APPLE || defined(__HAIKU__)
    userptr.gl_get_proc_address_ptr = NULL;
#elif GLAD_PLATFORM_WIN32
    userptr.gl_get_proc_address_ptr =
        (GLADglprocaddrfunc) glad_dlsym_handle(handle, "wglGetProcAddress");
#else
    userptr.gl_get_proc_address_ptr =
        (GLADglprocaddrfunc) glad_dlsym_handle(handle, "glXGetProcAddressARB");
#endif

    return userptr;
}

int gladLoaderLoadGL(void) {
    int version = 0;
    void *handle;
    int did_load = 0;
    struct _glad_gl_userptr userptr;

    did_load = _gl_handle == NULL;
    handle = glad_gl_dlopen_handle();
    if (handle) {
        userptr = glad_gl_build_userptr(handle);

        version = gladLoadGLUserPtr(glad_gl_get_proc, &userptr);

        if (did_load) {
            gladLoaderUnloadGL();
        }
    }

    return version;
}



void gladLoaderUnloadGL(void) {
    if (_gl_handle != NULL) {
        glad_close_dlopen_handle(_gl_handle);
        _gl_handle = NULL;
    }
}

#endif /* GLAD_GL */

```

`Modules/OpenGL/Public/KHR/khrplatform.h`:

```h
#ifndef __khrplatform_h_
#define __khrplatform_h_

/*
** Copyright (c) 2008-2018 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* Khronos platform-specific types and definitions.
 *
 * The master copy of khrplatform.h is maintained in the Khronos EGL
 * Registry repository at https://github.com/KhronosGroup/EGL-Registry
 * The last semantic modification to khrplatform.h was at commit ID:
 *      67a3e0864c2d75ea5287b9f3d2eb74a745936692
 *
 * Adopters may modify this file to suit their platform. Adopters are
 * encouraged to submit platform specific modifications to the Khronos
 * group so that they can be included in future versions of this file.
 * Please submit changes by filing pull requests or issues on
 * the EGL Registry repository linked above.
 *
 *
 * See the Implementer's Guidelines for information about where this file
 * should be located on your system and for more details of its use:
 *    http://www.khronos.org/registry/implementers_guide.pdf
 *
 * This file should be included as
 *        #include <KHR/khrplatform.h>
 * by Khronos client API header files that use its types and defines.
 *
 * The types in khrplatform.h should only be used to define API-specific types.
 *
 * Types defined in khrplatform.h:
 *    khronos_int8_t              signed   8  bit
 *    khronos_uint8_t             unsigned 8  bit
 *    khronos_int16_t             signed   16 bit
 *    khronos_uint16_t            unsigned 16 bit
 *    khronos_int32_t             signed   32 bit
 *    khronos_uint32_t            unsigned 32 bit
 *    khronos_int64_t             signed   64 bit
 *    khronos_uint64_t            unsigned 64 bit
 *    khronos_intptr_t            signed   same number of bits as a pointer
 *    khronos_uintptr_t           unsigned same number of bits as a pointer
 *    khronos_ssize_t             signed   size
 *    khronos_usize_t             unsigned size
 *    khronos_float_t             signed   32 bit floating point
 *    khronos_time_ns_t           unsigned 64 bit time in nanoseconds
 *    khronos_utime_nanoseconds_t unsigned time interval or absolute time in
 *                                         nanoseconds
 *    khronos_stime_nanoseconds_t signed time interval in nanoseconds
 *    khronos_boolean_enum_t      enumerated boolean type. This should
 *      only be used as a base type when a client API's boolean type is
 *      an enum. Client APIs which use an integer or other type for
 *      booleans cannot use this as the base type for their boolean.
 *
 * Tokens defined in khrplatform.h:
 *
 *    KHRONOS_FALSE, KHRONOS_TRUE Enumerated boolean false/true values.
 *
 *    KHRONOS_SUPPORT_INT64 is 1 if 64 bit integers are supported; otherwise 0.
 *    KHRONOS_SUPPORT_FLOAT is 1 if floats are supported; otherwise 0.
 *
 * Calling convention macros defined in this file:
 *    KHRONOS_APICALL
 *    KHRONOS_APIENTRY
 *    KHRONOS_APIATTRIBUTES
 *
 * These may be used in function prototypes as:
 *
 *      KHRONOS_APICALL void KHRONOS_APIENTRY funcname(
 *                                  int arg1,
 *                                  int arg2) KHRONOS_APIATTRIBUTES;
 */

#if defined(__SCITECH_SNAP__) && !defined(KHRONOS_STATIC)
#   define KHRONOS_STATIC 1
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APICALL
 *-------------------------------------------------------------------------
 * This precedes the return type of the function in the function prototype.
 */
#if defined(KHRONOS_STATIC)
    /* If the preprocessor constant KHRONOS_STATIC is defined, make the
     * header compatible with static linking. */
#   define KHRONOS_APICALL
#elif defined(_WIN32)
#   define KHRONOS_APICALL __declspec(dllimport)
#elif defined (__SYMBIAN32__)
#   define KHRONOS_APICALL IMPORT_C
#elif defined(__ANDROID__)
#   define KHRONOS_APICALL __attribute__((visibility("default")))
#else
#   define KHRONOS_APICALL
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIENTRY
 *-------------------------------------------------------------------------
 * This follows the return type of the function  and precedes the function
 * name in the function prototype.
 */
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(KHRONOS_STATIC)
    /* Win32 but not WinCE */
#   define KHRONOS_APIENTRY __stdcall
#else
#   define KHRONOS_APIENTRY
#endif

/*-------------------------------------------------------------------------
 * Definition of KHRONOS_APIATTRIBUTES
 *-------------------------------------------------------------------------
 * This follows the closing parenthesis of the function prototype arguments.
 */
#if defined (__ARMCC_2__)
#define KHRONOS_APIATTRIBUTES __softfp
#else
#define KHRONOS_APIATTRIBUTES
#endif

/*-------------------------------------------------------------------------
 * basic type definitions
 *-----------------------------------------------------------------------*/
#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__GNUC__) || defined(__SCO__) || defined(__USLC__)


/*
 * Using <stdint.h>
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__VMS ) || defined(__sgi)

/*
 * Using <inttypes.h>
 */
#include <inttypes.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(_WIN32) && !defined(__SCITECH_SNAP__)

/*
 * Win32
 */
typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif defined(__sun__) || defined(__digital__)

/*
 * Sun or Digital
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#if defined(__arch64__) || defined(_LP64)
typedef long int                khronos_int64_t;
typedef unsigned long int       khronos_uint64_t;
#else
typedef long long int           khronos_int64_t;
typedef unsigned long long int  khronos_uint64_t;
#endif /* __arch64__ */
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#elif 0

/*
 * Hypothetical platform with no float or int64 support
 */
typedef int                     khronos_int32_t;
typedef unsigned int            khronos_uint32_t;
#define KHRONOS_SUPPORT_INT64   0
#define KHRONOS_SUPPORT_FLOAT   0

#else

/*
 * Generic fallback
 */
#include <stdint.h>
typedef int32_t                 khronos_int32_t;
typedef uint32_t                khronos_uint32_t;
typedef int64_t                 khronos_int64_t;
typedef uint64_t                khronos_uint64_t;
#define KHRONOS_SUPPORT_INT64   1
#define KHRONOS_SUPPORT_FLOAT   1

#endif


/*
 * Types that are (so far) the same on all platforms
 */
typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;

/*
 * Types that differ between LLP64 and LP64 architectures - in LLP64,
 * pointers are 64 bits, but 'long' is still 32 bits. Win64 appears
 * to be the only LLP64 architecture in current use.
 */
#ifdef _WIN64
typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;
typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;
#else
typedef signed   long  int     khronos_intptr_t;
typedef unsigned long  int     khronos_uintptr_t;
typedef signed   long  int     khronos_ssize_t;
typedef unsigned long  int     khronos_usize_t;
#endif

#if KHRONOS_SUPPORT_FLOAT
/*
 * Float type
 */
typedef          float         khronos_float_t;
#endif

#if KHRONOS_SUPPORT_INT64
/* Time types
 *
 * These types can be used to represent a time interval in nanoseconds or
 * an absolute Unadjusted System Time.  Unadjusted System Time is the number
 * of nanoseconds since some arbitrary system event (e.g. since the last
 * time the system booted).  The Unadjusted System Time is an unsigned
 * 64 bit value that wraps back to 0 every 584 years.  Time intervals
 * may be either signed or unsigned.
 */
typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#endif

/*
 * Dummy value used to pad enum types to 32 bits.
 */
#ifndef KHRONOS_MAX_ENUM
#define KHRONOS_MAX_ENUM 0x7FFFFFFF
#endif

/*
 * Enumerated boolean type
 *
 * Values other than zero should be considered to be true.  Therefore
 * comparisons should not be made against KHRONOS_TRUE.
 */
typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE  = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = KHRONOS_MAX_ENUM
} khronos_boolean_enum_t;

#endif /* __khrplatform_h_ */

```

`Modules/OpenGL/Public/Toon/OpenGL/OpenGLBuffer.hpp`:

```hpp
#ifndef TOON_OPENGL_BUFFER_HPP
#define TOON_OPENGL_BUFFER_HPP

#include <Toon/OpenGL/OpenGLConfig.hpp>
#include <Toon/Buffer.hpp>

namespace Toon::OpenGL {

#define TOON_OPENGL_BUFFER(x) (dynamic_cast<Toon::OpenGL::OpenGLBuffer *>(x))

class TOON_OPENGL_API OpenGLBuffer : public Buffer
{
public:

    DISALLOW_COPY_AND_ASSIGN(OpenGLBuffer)

    OpenGLBuffer() = default;

    virtual inline ~OpenGLBuffer() {
        Terminate();
    }

    bool Initialize(size_t size, uint8_t * data, BufferUsage bufferUsage, MemoryUsage memoryUsage) override;

    void Terminate() override;

    void Bind();

    GLuint GetGLID() const {
        return _glID;
    }

private:

    GLuint _glID = 0;

    GLenum _glTarget;

    size_t _size;

}; // class OpenGLBuffer

inline GLenum GetGLBufferUsage(BufferUsage bufferUsage)
{
    switch (bufferUsage) {
    case BufferUsage::Index:
        return GL_ELEMENT_ARRAY_BUFFER;
    case BufferUsage::Vertex:
        return GL_ARRAY_BUFFER;
    case BufferUsage::Constant:
        return GL_UNIFORM_BUFFER;
    }

    return GL_INVALID_ENUM;
}

inline GLbitfield GetGLMemoryUsage(MemoryUsage memoryUsage)
{
    switch (memoryUsage) {
    case MemoryUsage::GPU:
        return 0;
    case MemoryUsage::UploadOnce:
    case MemoryUsage::UploadOften:
        return GL_MAP_WRITE_BIT | GL_MAP_COHERENT_BIT | GL_MAP_PERSISTENT_BIT;
    case MemoryUsage::Download:
        return GL_MAP_READ_BIT | GL_MAP_COHERENT_BIT | GL_MAP_PERSISTENT_BIT;
    }

    return 0;
}

} // namespace Toon::OpenGL

#endif // TOON_OPENGL_BUFFER_HPP
```

`Modules/OpenGL/Public/Toon/OpenGL/OpenGLConfig.hpp`:

```hpp
#ifndef TOON_OPENGL_CONFIG_HPP
#define TOON_OPENGL_CONFIG_HPP

#include <Toon/Config.hpp>

#if defined(TOON_OPENGL_EXPORT)
    #define TOON_OPENGL_API TOON_API_EXPORT
#else
    #define TOON_OPENGL_API TOON_API_IMPORT
#endif

#include <glad/gl.h>

#include <Toon/SDL2/SDL2Config.hpp>
#include <SDL_opengl.h>

#endif // TOON_OPENGL_CONFIG_HPP
```

`Modules/OpenGL/Public/Toon/OpenGL/OpenGLGraphicsDriver.hpp`:

```hpp
#ifndef TOON_OPENGL_GRAPHICS_DRIVER_HPP
#define TOON_OPENGL_GRAPHICS_DRIVER_HPP

#include <Toon/OpenGL/OpenGLConfig.hpp>

#include <Toon/SDL2/SDL2GraphicsDriver.hpp>
#include <Toon/OpenGL/OpenGLPipeline.hpp>
#include <Toon/OpenGL/OpenGLTexture.hpp>
#include <Toon/OpenGL/OpenGLShader.hpp>
#include <Toon/OpenGL/OpenGLMesh.hpp>
#include <Toon/OpenGL/OpenGLMaterial.hpp>
#include <Toon/OpenGL/OpenGLPrimitive.hpp>
#include <Toon/OpenGL/OpenGLBuffer.hpp>

#include <SDL.h>

namespace Toon::OpenGL {

#define TOON_OPENGL_GRAPHICS_DRIVER(x) (dynamic_cast<Toon::OpenGL::OpenGLGraphicsDriver *>(x))

class TOON_OPENGL_API OpenGLGraphicsDriver : public SDL2::SDL2GraphicsDriver
{
public:

    DISALLOW_COPY_AND_ASSIGN(OpenGLGraphicsDriver)

    OpenGLGraphicsDriver() = default;

    virtual ~OpenGLGraphicsDriver() = default;

    bool Initialize() override;

    void Terminate() override;

    void Render() override;

    std::shared_ptr<Buffer> CreateBuffer() override;

    std::shared_ptr<Pipeline> CreatePipeline(std::shared_ptr<Shader> shader) override;

    std::shared_ptr<Texture> CreateTexture() override;

    std::shared_ptr<Shader> CreateShader() override;

    std::shared_ptr<Mesh> CreateMesh() override;

    std::shared_ptr<Material> CreateMaterial() override;

    std::shared_ptr<Primitive> CreatePrimitive() override;

private:

    void BindUniformBufferObjects();

    void InitDebugMessageCallback();

    SDL_GLContext _glContext = nullptr;

    std::vector<std::weak_ptr<Shader>> _shaderList;
}; // class OpenGLGraphicsDriver

} // namespace Toon::OpenGL

#endif // TOON_OPENGL_GRAPHICS_DRIVER_HPP
```

`Modules/OpenGL/Public/Toon/OpenGL/OpenGLMaterial.hpp`:

```hpp
#ifndef TOON_OPENGL_MATERIAL_HPP
#define TOON_OPENGL_MATERIAL_HPP

#include <Toon/OpenGL/OpenGLConfig.hpp>

#include <Toon/Material.hpp>

namespace Toon::OpenGL {

#define TOON_OPENGL_MATERIAL(x) (dynamic_cast<Toon::OpenGL::OpenGLMaterial *>(x))

class TOON_OPENGL_API OpenGLMaterial : public Material
{
public:

    DISALLOW_COPY_AND_ASSIGN(OpenGLMaterial)

    OpenGLMaterial() = default;

    virtual ~OpenGLMaterial() = default;

    void Bind();

private:

}; // class OpenGLMaterial

} // namespace Toon::OpenGL

#endif // TOON_OPENGL_MATERIAL_HPP
```

`Modules/OpenGL/Public/Toon/OpenGL/OpenGLMesh.hpp`:

```hpp
#ifndef TOON_OPENGL_MESH_HPP
#define TOON_OPENGL_MESH_HPP

#include <Toon/OpenGL/OpenGLConfig.hpp>

#include <Toon/Mesh.hpp>

namespace Toon::OpenGL {

class TOON_OPENGL_API OpenGLMesh : public Mesh
{
public:
    DISALLOW_COPY_AND_ASSIGN(OpenGLMesh)

    OpenGLMesh() = default;
    
    virtual ~OpenGLMesh() = default;

    void Render(RenderContext * ctx) override;

private:

}; // class OpenGLMesh

} // namespace Toon::OpenGL

#endif // TOON_OPENGL_MESH_HPP
```

`Modules/OpenGL/Public/Toon/OpenGL/OpenGLPipeline.hpp`:

```hpp
#ifndef TOON_OPENGL_PIPELINE_HPP
#define TOON_OPENGL_PIPELINE_HPP

#include <Toon/OpenGL/OpenGLConfig.hpp>

#include <Toon/Pipeline.hpp>

namespace Toon::OpenGL {

#define TOON_OPENGL_PIPELINE(x) (dynamic_cast<Toon::OpenGL::OpenGLPipeline *>(x))

class TOON_OPENGL_API OpenGLPipeline : public Pipeline
{
public:

    DISALLOW_COPY_AND_ASSIGN(OpenGLPipeline)

    OpenGLPipeline() = default;

    virtual ~OpenGLPipeline() = default;

    bool Bind();

private:

}; // class OpenGLPipeline

inline GLenum GetGLFrontFace(FrontFace frontFace)
{
    switch (frontFace) {
    case FrontFace::Clockwise:
        return GL_CW;
    case FrontFace::CounterClockwise:
        return GL_CCW;
    default: ;
    }

    return GL_INVALID_ENUM;
}

inline GLenum GetGLCullMode(CullMode cullMode)
{
    switch (cullMode) {
    case CullMode::Front:
        return GL_FRONT;
    case CullMode::Back:
        return GL_BACK;
    default: ;
    }
    
    return GL_INVALID_ENUM;
}

inline GLenum GetGLFillMode(FillMode fillMode)
{
    switch (fillMode) {
    case FillMode::Fill:
        return GL_FILL;
    case FillMode::Line:
        return GL_LINE;
    default: ;
    }
    
    return GL_INVALID_ENUM;
}

inline GLenum GetGLBlendFactor(BlendFactor factor)
{
    switch (factor) {
    case BlendFactor::Zero:
        return GL_ZERO;
    case BlendFactor::One:
        return GL_ONE;
    case BlendFactor::SrcColor:
        return GL_SRC_COLOR;
    case BlendFactor::OneMinusSrcColor:
        return GL_ONE_MINUS_SRC_COLOR;
    case BlendFactor::SrcAlpha:
        return GL_SRC_ALPHA;
    case BlendFactor::OneMinusSrcAlpha:
        return GL_ONE_MINUS_SRC_ALPHA;
    case BlendFactor::DstColor:
        return GL_DST_COLOR;
    case BlendFactor::OneMinusDstColor:
        return GL_ONE_MINUS_DST_COLOR;
    case BlendFactor::DstAlpha:
        return GL_DST_ALPHA;
    case BlendFactor::OneMinusDstAlpha:
        return GL_ONE_MINUS_DST_ALPHA;
    case BlendFactor::ConstantColor:
        return GL_CONSTANT_COLOR;
    case BlendFactor::OneMinusConstantColor:
        return GL_ONE_MINUS_CONSTANT_COLOR;
    case BlendFactor::ConstantAlpha:
        return GL_CONSTANT_ALPHA;
    case BlendFactor::OneMinusConstantAlpha:
        return GL_ONE_MINUS_CONSTANT_ALPHA;
    case BlendFactor::SrcAlphaSaturated:
        return GL_SRC_ALPHA_SATURATE;
    }
    
    return GL_INVALID_ENUM;
}

inline GLenum GetGLBlendOperation(BlendOperation op)
{
    switch (op) {
    case BlendOperation::Add:
        return GL_FUNC_ADD;
    case BlendOperation::Subtract:
        return GL_FUNC_SUBTRACT;
    case BlendOperation::ReverseSubtract:
        return GL_FUNC_REVERSE_SUBTRACT;
    case BlendOperation::Min:
        return GL_MIN;
    case BlendOperation::Max:
        return GL_MAX;
    }
    
    return GL_INVALID_ENUM;
}

inline GLenum GetGLCompareOperation(CompareOperation op)
{
    switch (op) {
    case CompareOperation::Never:
        return GL_NEVER;
    case CompareOperation::Less:
        return GL_LESS;
    case CompareOperation::Equal:
        return GL_EQUAL;
    case CompareOperation::LessOrEqual:
        return GL_LEQUAL;
    case CompareOperation::Greater:
        return GL_GREATER;
    case CompareOperation::NotEqual:
        return GL_NOTEQUAL;
    case CompareOperation::GreaterOrEqual:
        return GL_GEQUAL;
    case CompareOperation::Always:
        return GL_ALWAYS;
    }

    return GL_INVALID_ENUM;
}

} // namespace Toon::OpenGL

#endif // TOON_OPENGL_PIPELINE_HPP
```

`Modules/OpenGL/Public/Toon/OpenGL/OpenGLPrimitive.hpp`:

```hpp
#ifndef TOON_OPENGL_PRIMITIVE_HPP
#define TOON_OPENGL_PRIMITIVE_HPP

#include <Toon/OpenGL/OpenGLConfig.hpp>

#include <Toon/Primitive.hpp>
#include <Toon/PrimitiveData.hpp>

namespace Toon::OpenGL {

#define TOON_OPENGL_PRIMITIVE(x) (dynamic_cast<Toon::OpenGL::OpenGLPrimitive *>(x))

class TOON_OPENGL_API OpenGLPrimitive : public Primitive
{
public:

    DISALLOW_COPY_AND_ASSIGN(OpenGLPrimitive)

    OpenGLPrimitive() = default;

    virtual ~OpenGLPrimitive() = default;

    void Render();

    bool Load(const std::unique_ptr<PrimitiveData>& data) override;

private:

    GLuint _glVAO;

    GLenum _glMode;

    GLsizei _glCount;

    bool _indexed;
}; // class OpenGLPrimitive

inline GLenum GetGLPrimitiveTopology(PrimitiveTopology primitiveTopology)
{
    switch (primitiveTopology) {
    case PrimitiveTopology::PointList:
        return GL_POINTS;
    case PrimitiveTopology::LineList:
        return GL_LINES;
    case PrimitiveTopology::LineStrip:
        return GL_LINE_STRIP;
    case PrimitiveTopology::TriangleList:
        return GL_TRIANGLES;
    case PrimitiveTopology::TriangleStrip:
        return GL_TRIANGLE_STRIP;
    default: ;
    }

    return GL_INVALID_ENUM;
}

} // namespace Toon::OpenGL

#endif // TOON_OPENGL_PRIMITIVE_HPP
```

`Modules/OpenGL/Public/Toon/OpenGL/OpenGLShader.hpp`:

```hpp
#ifndef TOON_OPENGL_SHADER_HPP
#define TOON_OPENGL_SHADER_HPP

#include <Toon/OpenGL/OpenGLConfig.hpp>
#include <Toon/Shader.hpp>

namespace Toon::OpenGL {

#define TOON_OPENGL_SHADER(x) (dynamic_cast<Toon::OpenGL::OpenGLShader *>(x))

class TOON_OPENGL_API OpenGLShader : public Shader 
{
public:
    DISALLOW_COPY_AND_ASSIGN(OpenGLShader)

    OpenGLShader() = default;

    bool LoadFromFiles(const std::vector<std::string>& filenames, bool useAssetPath = true) override;

    void Bind();

    GLuint GetID();

private:
    GLuint LoadSPV(const std::string& filename, bool useAssetPath);

    GLuint LoadGLSL(const std::string& filename, bool useAssetPath);

    GLenum GetGLShaderType(const std::string& filename);

    GLuint _glID = 0;

}; // class OpenGLShader

} // namespace Toon::OpenGL

#endif // TOON_OPENGL_SHADER_HPP
```

`Modules/OpenGL/Public/Toon/OpenGL/OpenGLTexture.hpp`:

```hpp
#ifndef TOON_OPENGL_TEXTURE_HPP
#define TOON_OPENGL_TEXTURE_HPP

#include <Toon/OpenGL/OpenGLConfig.hpp>
#include <Toon/Texture.hpp>

namespace Toon::OpenGL {

#define TOON_OPENGL_TEXTURE(x) (dynamic_cast<Toon::OpenGL::OpenGLTexture *>(x))

class TOON_OPENGL_API OpenGLTexture : public Texture
{
public:

    DISALLOW_COPY_AND_ASSIGN(OpenGLTexture)

    OpenGLTexture() = default;

    virtual ~OpenGLTexture();

    bool Load(const std::unique_ptr<TextureData>& data, Options opts = Options()) override;

    inline GLuint GetGLID() {
        return _glID;
    }

private:
    
    GLenum GetGLDataType(const TextureDataType& type);

    GLenum GetGLWrapType(const TextureWrapType& type);

    GLenum GetGLFilterType(const TextureFilterType& type);

    GLuint _glID = 0;
    
}; // class OpenGLTexture

} // namespace Toon::OpenGL

#endif // TOON_OPENGL_TEXTURE_HPP
```

`Modules/OpenGL/Public/glad/gl.h`:

```h
/**
 * Loader generated by glad 2.0.0-beta on Tue Dec  3 21:09:22 2019
 *
 * Generator: C/C++
 * Specification: gl
 * Extensions: 480
 *
 * APIs:
 *  - gl:core=4.6
 *
 * Options:
 *  - MX_GLOBAL = False
 *  - ON_DEMAND = False
 *  - LOADER = True
 *  - ALIAS = False
 *  - HEADER_ONLY = False
 *  - DEBUG = False
 *  - MX = False
 *
 * Commandline:
 *    --api='gl:core=4.6' --extensions='GL_AMD_blend_minmax_factor,GL_AMD_conservative_depth,GL_AMD_debug_output,GL_AMD_depth_clamp_separate,GL_AMD_draw_buffers_blend,GL_AMD_framebuffer_sample_positions,GL_AMD_gcn_shader,GL_AMD_gpu_shader_half_float,GL_AMD_gpu_shader_int16,GL_AMD_gpu_shader_int64,GL_AMD_interleaved_elements,GL_AMD_multi_draw_indirect,GL_AMD_name_gen_delete,GL_AMD_occlusion_query_event,GL_AMD_performance_monitor,GL_AMD_pinned_memory,GL_AMD_query_buffer_object,GL_AMD_sample_positions,GL_AMD_seamless_cubemap_per_texture,GL_AMD_shader_atomic_counter_ops,GL_AMD_shader_ballot,GL_AMD_shader_explicit_vertex_parameter,GL_AMD_shader_stencil_export,GL_AMD_shader_trinary_minmax,GL_AMD_sparse_texture,GL_AMD_stencil_operation_extended,GL_AMD_texture_gather_bias_lod,GL_AMD_texture_texture4,GL_AMD_transform_feedback3_lines_triangles,GL_AMD_transform_feedback4,GL_AMD_vertex_shader_layer,GL_AMD_vertex_shader_tessellator,GL_AMD_vertex_shader_viewport_index,GL_APPLE_aux_depth_stencil,GL_APPLE_client_storage,GL_APPLE_element_array,GL_APPLE_fence,GL_APPLE_float_pixels,GL_APPLE_flush_buffer_range,GL_APPLE_object_purgeable,GL_APPLE_rgb_422,GL_APPLE_row_bytes,GL_APPLE_specular_vector,GL_APPLE_texture_range,GL_APPLE_transform_hint,GL_APPLE_vertex_array_object,GL_APPLE_vertex_array_range,GL_APPLE_vertex_program_evaluators,GL_APPLE_ycbcr_422,GL_ARB_ES2_compatibility,GL_ARB_ES3_1_compatibility,GL_ARB_ES3_2_compatibility,GL_ARB_ES3_compatibility,GL_ARB_arrays_of_arrays,GL_ARB_base_instance,GL_ARB_bindless_texture,GL_ARB_blend_func_extended,GL_ARB_buffer_storage,GL_ARB_cl_event,GL_ARB_clear_buffer_object,GL_ARB_clear_texture,GL_ARB_clip_control,GL_ARB_color_buffer_float,GL_ARB_compatibility,GL_ARB_compressed_texture_pixel_storage,GL_ARB_compute_shader,GL_ARB_compute_variable_group_size,GL_ARB_conditional_render_inverted,GL_ARB_conservative_depth,GL_ARB_copy_buffer,GL_ARB_copy_image,GL_ARB_cull_distance,GL_ARB_debug_output,GL_ARB_depth_buffer_float,GL_ARB_depth_clamp,GL_ARB_depth_texture,GL_ARB_derivative_control,GL_ARB_direct_state_access,GL_ARB_draw_buffers,GL_ARB_draw_buffers_blend,GL_ARB_draw_elements_base_vertex,GL_ARB_draw_indirect,GL_ARB_draw_instanced,GL_ARB_enhanced_layouts,GL_ARB_explicit_attrib_location,GL_ARB_explicit_uniform_location,GL_ARB_fragment_coord_conventions,GL_ARB_fragment_layer_viewport,GL_ARB_fragment_program,GL_ARB_fragment_program_shadow,GL_ARB_fragment_shader,GL_ARB_fragment_shader_interlock,GL_ARB_framebuffer_no_attachments,GL_ARB_framebuffer_object,GL_ARB_framebuffer_sRGB,GL_ARB_geometry_shader4,GL_ARB_get_program_binary,GL_ARB_get_texture_sub_image,GL_ARB_gl_spirv,GL_ARB_gpu_shader5,GL_ARB_gpu_shader_fp64,GL_ARB_gpu_shader_int64,GL_ARB_half_float_pixel,GL_ARB_half_float_vertex,GL_ARB_imaging,GL_ARB_indirect_parameters,GL_ARB_instanced_arrays,GL_ARB_internalformat_query,GL_ARB_internalformat_query2,GL_ARB_invalidate_subdata,GL_ARB_map_buffer_alignment,GL_ARB_map_buffer_range,GL_ARB_matrix_palette,GL_ARB_multi_bind,GL_ARB_multi_draw_indirect,GL_ARB_multisample,GL_ARB_multitexture,GL_ARB_occlusion_query,GL_ARB_occlusion_query2,GL_ARB_parallel_shader_compile,GL_ARB_pipeline_statistics_query,GL_ARB_pixel_buffer_object,GL_ARB_point_parameters,GL_ARB_point_sprite,GL_ARB_polygon_offset_clamp,GL_ARB_post_depth_coverage,GL_ARB_program_interface_query,GL_ARB_provoking_vertex,GL_ARB_query_buffer_object,GL_ARB_robust_buffer_access_behavior,GL_ARB_robustness,GL_ARB_robustness_isolation,GL_ARB_sample_locations,GL_ARB_sample_shading,GL_ARB_sampler_objects,GL_ARB_seamless_cube_map,GL_ARB_seamless_cubemap_per_texture,GL_ARB_separate_shader_objects,GL_ARB_shader_atomic_counter_ops,GL_ARB_shader_atomic_counters,GL_ARB_shader_ballot,GL_ARB_shader_bit_encoding,GL_ARB_shader_clock,GL_ARB_shader_draw_parameters,GL_ARB_shader_group_vote,GL_ARB_shader_image_load_store,GL_ARB_shader_image_size,GL_ARB_shader_objects,GL_ARB_shader_precision,GL_ARB_shader_stencil_export,GL_ARB_shader_storage_buffer_object,GL_ARB_shader_subroutine,GL_ARB_shader_texture_image_samples,GL_ARB_shader_texture_lod,GL_ARB_shader_viewport_layer_array,GL_ARB_shading_language_100,GL_ARB_shading_language_420pack,GL_ARB_shading_language_include,GL_ARB_shading_language_packing,GL_ARB_shadow,GL_ARB_shadow_ambient,GL_ARB_sparse_buffer,GL_ARB_sparse_texture,GL_ARB_sparse_texture2,GL_ARB_sparse_texture_clamp,GL_ARB_spirv_extensions,GL_ARB_stencil_texturing,GL_ARB_sync,GL_ARB_tessellation_shader,GL_ARB_texture_barrier,GL_ARB_texture_border_clamp,GL_ARB_texture_buffer_object,GL_ARB_texture_buffer_object_rgb32,GL_ARB_texture_buffer_range,GL_ARB_texture_compression,GL_ARB_texture_compression_bptc,GL_ARB_texture_compression_rgtc,GL_ARB_texture_cube_map,GL_ARB_texture_cube_map_array,GL_ARB_texture_env_add,GL_ARB_texture_env_combine,GL_ARB_texture_env_crossbar,GL_ARB_texture_env_dot3,GL_ARB_texture_filter_anisotropic,GL_ARB_texture_filter_minmax,GL_ARB_texture_float,GL_ARB_texture_gather,GL_ARB_texture_mirror_clamp_to_edge,GL_ARB_texture_mirrored_repeat,GL_ARB_texture_multisample,GL_ARB_texture_non_power_of_two,GL_ARB_texture_query_levels,GL_ARB_texture_query_lod,GL_ARB_texture_rectangle,GL_ARB_texture_rg,GL_ARB_texture_rgb10_a2ui,GL_ARB_texture_stencil8,GL_ARB_texture_storage,GL_ARB_texture_storage_multisample,GL_ARB_texture_swizzle,GL_ARB_texture_view,GL_ARB_timer_query,GL_ARB_transform_feedback2,GL_ARB_transform_feedback3,GL_ARB_transform_feedback_instanced,GL_ARB_transform_feedback_overflow_query,GL_ARB_transpose_matrix,GL_ARB_uniform_buffer_object,GL_ARB_vertex_array_bgra,GL_ARB_vertex_array_object,GL_ARB_vertex_attrib_64bit,GL_ARB_vertex_attrib_binding,GL_ARB_vertex_blend,GL_ARB_vertex_buffer_object,GL_ARB_vertex_program,GL_ARB_vertex_shader,GL_ARB_vertex_type_10f_11f_11f_rev,GL_ARB_vertex_type_2_10_10_10_rev,GL_ARB_viewport_array,GL_ARB_window_pos,GL_ATI_draw_buffers,GL_ATI_element_array,GL_ATI_envmap_bumpmap,GL_ATI_fragment_shader,GL_ATI_map_object_buffer,GL_ATI_meminfo,GL_ATI_pixel_format_float,GL_ATI_pn_triangles,GL_ATI_separate_stencil,GL_ATI_text_fragment_shader,GL_ATI_texture_env_combine3,GL_ATI_texture_float,GL_ATI_texture_mirror_once,GL_ATI_vertex_array_object,GL_ATI_vertex_attrib_array_object,GL_ATI_vertex_streams,GL_EXT_422_pixels,GL_EXT_abgr,GL_EXT_bgra,GL_EXT_bindable_uniform,GL_EXT_blend_color,GL_EXT_blend_equation_separate,GL_EXT_blend_func_separate,GL_EXT_blend_logic_op,GL_EXT_blend_minmax,GL_EXT_blend_subtract,GL_EXT_clip_volume_hint,GL_EXT_cmyka,GL_EXT_color_subtable,GL_EXT_compiled_vertex_array,GL_EXT_convolution,GL_EXT_coordinate_frame,GL_EXT_copy_texture,GL_EXT_cull_vertex,GL_EXT_debug_label,GL_EXT_debug_marker,GL_EXT_depth_bounds_test,GL_EXT_direct_state_access,GL_EXT_draw_buffers2,GL_EXT_draw_instanced,GL_EXT_draw_range_elements,GL_EXT_external_buffer,GL_EXT_fog_coord,GL_EXT_framebuffer_blit,GL_EXT_framebuffer_multisample,GL_EXT_framebuffer_multisample_blit_scaled,GL_EXT_framebuffer_object,GL_EXT_framebuffer_sRGB,GL_EXT_geometry_shader4,GL_EXT_gpu_program_parameters,GL_EXT_gpu_shader4,GL_EXT_histogram,GL_EXT_index_array_formats,GL_EXT_index_func,GL_EXT_index_material,GL_EXT_index_texture,GL_EXT_light_texture,GL_EXT_memory_object,GL_EXT_memory_object_fd,GL_EXT_memory_object_win32,GL_EXT_misc_attribute,GL_EXT_multi_draw_arrays,GL_EXT_multisample,GL_EXT_packed_depth_stencil,GL_EXT_packed_float,GL_EXT_packed_pixels,GL_EXT_paletted_texture,GL_EXT_pixel_buffer_object,GL_EXT_pixel_transform,GL_EXT_pixel_transform_color_table,GL_EXT_point_parameters,GL_EXT_polygon_offset,GL_EXT_polygon_offset_clamp,GL_EXT_post_depth_coverage,GL_EXT_provoking_vertex,GL_EXT_raster_multisample,GL_EXT_rescale_normal,GL_EXT_secondary_color,GL_EXT_semaphore,GL_EXT_semaphore_fd,GL_EXT_semaphore_win32,GL_EXT_separate_shader_objects,GL_EXT_separate_specular_color,GL_EXT_shader_image_load_formatted,GL_EXT_shader_image_load_store,GL_EXT_shader_integer_mix,GL_EXT_shadow_funcs,GL_EXT_shared_texture_palette,GL_EXT_sparse_texture2,GL_EXT_stencil_clear_tag,GL_EXT_stencil_two_side,GL_EXT_stencil_wrap,GL_EXT_subtexture,GL_EXT_texture,GL_EXT_texture3D,GL_EXT_texture_array,GL_EXT_texture_buffer_object,GL_EXT_texture_compression_latc,GL_EXT_texture_compression_rgtc,GL_EXT_texture_compression_s3tc,GL_EXT_texture_cube_map,GL_EXT_texture_env_add,GL_EXT_texture_env_combine,GL_EXT_texture_env_dot3,GL_EXT_texture_filter_anisotropic,GL_EXT_texture_filter_minmax,GL_EXT_texture_integer,GL_EXT_texture_lod_bias,GL_EXT_texture_mirror_clamp,GL_EXT_texture_object,GL_EXT_texture_perturb_normal,GL_EXT_texture_sRGB,GL_EXT_texture_sRGB_decode,GL_EXT_texture_shared_exponent,GL_EXT_texture_snorm,GL_EXT_texture_swizzle,GL_EXT_timer_query,GL_EXT_transform_feedback,GL_EXT_vertex_array,GL_EXT_vertex_array_bgra,GL_EXT_vertex_attrib_64bit,GL_EXT_vertex_shader,GL_EXT_vertex_weighting,GL_EXT_win32_keyed_mutex,GL_EXT_window_rectangles,GL_EXT_x11_sync_object,GL_INTEL_conservative_rasterization,GL_INTEL_fragment_shader_ordering,GL_INTEL_framebuffer_CMAA,GL_INTEL_map_texture,GL_INTEL_parallel_arrays,GL_INTEL_performance_query,GL_KHR_blend_equation_advanced,GL_KHR_blend_equation_advanced_coherent,GL_KHR_context_flush_control,GL_KHR_debug,GL_KHR_no_error,GL_KHR_parallel_shader_compile,GL_KHR_robust_buffer_access_behavior,GL_KHR_robustness,GL_KHR_texture_compression_astc_hdr,GL_KHR_texture_compression_astc_ldr,GL_KHR_texture_compression_astc_sliced_3d,GL_MESAX_texture_stack,GL_MESA_pack_invert,GL_MESA_resize_buffers,GL_MESA_shader_integer_functions,GL_MESA_window_pos,GL_MESA_ycbcr_texture,GL_NVX_blend_equation_advanced_multi_draw_buffers,GL_NVX_conditional_render,GL_NVX_gpu_memory_info,GL_NVX_linked_gpu_multicast,GL_NV_alpha_to_coverage_dither_control,GL_NV_bindless_multi_draw_indirect,GL_NV_bindless_multi_draw_indirect_count,GL_NV_bindless_texture,GL_NV_blend_equation_advanced,GL_NV_blend_equation_advanced_coherent,GL_NV_blend_minmax_factor,GL_NV_blend_square,GL_NV_clip_space_w_scaling,GL_NV_command_list,GL_NV_compute_program5,GL_NV_conditional_render,GL_NV_conservative_raster,GL_NV_conservative_raster_dilate,GL_NV_conservative_raster_pre_snap_triangles,GL_NV_copy_depth_to_color,GL_NV_copy_image,GL_NV_deep_texture3D,GL_NV_depth_buffer_float,GL_NV_depth_clamp,GL_NV_draw_texture,GL_NV_draw_vulkan_image,GL_NV_evaluators,GL_NV_explicit_multisample,GL_NV_fence,GL_NV_fill_rectangle,GL_NV_float_buffer,GL_NV_fog_distance,GL_NV_fragment_coverage_to_color,GL_NV_fragment_program,GL_NV_fragment_program2,GL_NV_fragment_program4,GL_NV_fragment_program_option,GL_NV_fragment_shader_interlock,GL_NV_framebuffer_mixed_samples,GL_NV_framebuffer_multisample_coverage,GL_NV_geometry_program4,GL_NV_geometry_shader4,GL_NV_geometry_shader_passthrough,GL_NV_gpu_multicast,GL_NV_gpu_program4,GL_NV_gpu_program5,GL_NV_gpu_program5_mem_extended,GL_NV_gpu_shader5,GL_NV_half_float,GL_NV_internalformat_sample_query,GL_NV_light_max_exponent,GL_NV_multisample_coverage,GL_NV_multisample_filter_hint,GL_NV_occlusion_query,GL_NV_packed_depth_stencil,GL_NV_parameter_buffer_object,GL_NV_parameter_buffer_object2,GL_NV_path_rendering,GL_NV_path_rendering_shared_edge,GL_NV_pixel_data_range,GL_NV_point_sprite,GL_NV_present_video,GL_NV_primitive_restart,GL_NV_query_resource,GL_NV_query_resource_tag,GL_NV_register_combiners,GL_NV_register_combiners2,GL_NV_robustness_video_memory_purge,GL_NV_sample_locations,GL_NV_sample_mask_override_coverage,GL_NV_shader_atomic_counters,GL_NV_shader_atomic_float,GL_NV_shader_atomic_float64,GL_NV_shader_atomic_fp16_vector,GL_NV_shader_atomic_int64,GL_NV_shader_buffer_load,GL_NV_shader_buffer_store,GL_NV_shader_storage_buffer_object,GL_NV_shader_thread_group,GL_NV_shader_thread_shuffle,GL_NV_stereo_view_rendering,GL_NV_tessellation_program5,GL_NV_texgen_emboss,GL_NV_texgen_reflection,GL_NV_texture_barrier,GL_NV_texture_compression_vtc,GL_NV_texture_env_combine4,GL_NV_texture_expand_normal,GL_NV_texture_multisample,GL_NV_texture_rectangle,GL_NV_texture_rectangle_compressed,GL_NV_texture_shader,GL_NV_texture_shader2,GL_NV_texture_shader3,GL_NV_transform_feedback,GL_NV_transform_feedback2,GL_NV_uniform_buffer_unified_memory,GL_NV_vdpau_interop,GL_NV_vertex_array_range,GL_NV_vertex_array_range2,GL_NV_vertex_attrib_integer_64bit,GL_NV_vertex_buffer_unified_memory,GL_NV_vertex_program,GL_NV_vertex_program1_1,GL_NV_vertex_program2,GL_NV_vertex_program2_option,GL_NV_vertex_program3,GL_NV_vertex_program4,GL_NV_video_capture,GL_NV_viewport_array2,GL_NV_viewport_swizzle' c --loader
 *
 * Online:
 *    http://glad.sh/#api=gl%3Acore%3D4.6&generator=c&options=LOADER
 *
 */

#ifndef GLAD_GL_H_
#define GLAD_GL_H_

#ifdef __gl_h_
    #error OpenGL header already included (API: gl), remove previous include!
#endif
#define __gl_h_ 1


#define GLAD_GL
#define GLAD_OPTION_GL_LOADER

#ifdef __cplusplus
extern "C" {
#endif

#ifndef GLAD_PLATFORM_H_
#define GLAD_PLATFORM_H_

#ifndef GLAD_PLATFORM_WIN32
  #if defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__MINGW32__)
    #define GLAD_PLATFORM_WIN32 1
  #else
    #define GLAD_PLATFORM_WIN32 0
  #endif
#endif

#ifndef GLAD_PLATFORM_APPLE
  #ifdef __APPLE__
    #define GLAD_PLATFORM_APPLE 1
  #else
    #define GLAD_PLATFORM_APPLE 0
  #endif
#endif

#ifndef GLAD_PLATFORM_EMSCRIPTEN
  #ifdef __EMSCRIPTEN__
    #define GLAD_PLATFORM_EMSCRIPTEN 1
  #else
    #define GLAD_PLATFORM_EMSCRIPTEN 0
  #endif
#endif

#ifndef GLAD_PLATFORM_UWP
  #if defined(_MSC_VER) && !defined(GLAD_INTERNAL_HAVE_WINAPIFAMILY)
    #ifdef __has_include
      #if __has_include(<winapifamily.h>)
        #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
      #endif
    #elif _MSC_VER >= 1700 && !_USING_V110_SDK71_
      #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
    #endif
  #endif

  #ifdef GLAD_INTERNAL_HAVE_WINAPIFAMILY
    #include <winapifamily.h>
    #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
      #define GLAD_PLATFORM_UWP 1
    #endif
  #endif

  #ifndef GLAD_PLATFORM_UWP
    #define GLAD_PLATFORM_UWP 0
  #endif
#endif

#ifdef __GNUC__
  #define GLAD_GNUC_EXTENSION __extension__
#else
  #define GLAD_GNUC_EXTENSION
#endif

#ifndef GLAD_API_CALL
  #if defined(GLAD_API_CALL_EXPORT)
    #if GLAD_PLATFORM_WIN32 || defined(__CYGWIN__)
      #if defined(GLAD_API_CALL_EXPORT_BUILD)
        #if defined(__GNUC__)
          #define GLAD_API_CALL __attribute__ ((dllexport)) extern
        #else
          #define GLAD_API_CALL __declspec(dllexport) extern
        #endif
      #else
        #if defined(__GNUC__)
          #define GLAD_API_CALL __attribute__ ((dllimport)) extern
        #else
          #define GLAD_API_CALL __declspec(dllimport) extern
        #endif
      #endif
    #elif defined(__GNUC__) && defined(GLAD_API_CALL_EXPORT_BUILD)
      #define GLAD_API_CALL __attribute__ ((visibility ("default"))) extern
    #else
      #define GLAD_API_CALL extern
    #endif
  #else
    #define GLAD_API_CALL extern
  #endif
#endif

#ifdef APIENTRY
  #define GLAD_API_PTR APIENTRY
#elif GLAD_PLATFORM_WIN32
  #define GLAD_API_PTR __stdcall
#else
  #define GLAD_API_PTR
#endif

#ifndef GLAPI
#define GLAPI GLAD_API_CALL
#endif

#ifndef GLAPIENTRY
#define GLAPIENTRY GLAD_API_PTR
#endif

#define GLAD_MAKE_VERSION(major, minor) (major * 10000 + minor)
#define GLAD_VERSION_MAJOR(version) (version / 10000)
#define GLAD_VERSION_MINOR(version) (version % 10000)

#define GLAD_GENERATOR_VERSION "2.0.0-beta"

typedef void (*GLADapiproc)(void);

typedef GLADapiproc (*GLADloadfunc)(const char *name);
typedef GLADapiproc (*GLADuserptrloadfunc)(void *userptr, const char *name);

typedef void (*GLADprecallback)(const char *name, GLADapiproc apiproc, int len_args, ...);
typedef void (*GLADpostcallback)(void *ret, const char *name, GLADapiproc apiproc, int len_args, ...);

#endif /* GLAD_PLATFORM_H_ */

#define GL_1PASS_EXT 0x80A1
#define GL_2PASS_0_EXT 0x80A2
#define GL_2PASS_1_EXT 0x80A3
#define GL_2X_BIT_ATI 0x00000001
#define GL_422_AVERAGE_EXT 0x80CE
#define GL_422_EXT 0x80CC
#define GL_422_REV_AVERAGE_EXT 0x80CF
#define GL_422_REV_EXT 0x80CD
#define GL_4PASS_0_EXT 0x80A4
#define GL_4PASS_1_EXT 0x80A5
#define GL_4PASS_2_EXT 0x80A6
#define GL_4PASS_3_EXT 0x80A7
#define GL_4X_BIT_ATI 0x00000002
#define GL_8X_BIT_ATI 0x00000004
#define GL_ABGR_EXT 0x8000
#define GL_ACCUM_ADJACENT_PAIRS_NV 0x90AD
#define GL_ACTIVE_ATOMIC_COUNTER_BUFFERS 0x92D9
#define GL_ACTIVE_ATTRIBUTES 0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
#define GL_ACTIVE_PROGRAM 0x8259
#define GL_ACTIVE_PROGRAM_EXT 0x8B8D
#define GL_ACTIVE_RESOURCES 0x92F5
#define GL_ACTIVE_STENCIL_FACE_EXT 0x8911
#define GL_ACTIVE_SUBROUTINES 0x8DE5
#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH 0x8E48
#define GL_ACTIVE_SUBROUTINE_UNIFORMS 0x8DE6
#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS 0x8E47
#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH 0x8E49
#define GL_ACTIVE_TEXTURE 0x84E0
#define GL_ACTIVE_TEXTURE_ARB 0x84E0
#define GL_ACTIVE_UNIFORMS 0x8B86
#define GL_ACTIVE_UNIFORM_BLOCKS 0x8A36
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_ACTIVE_UNIFORM_MAX_LENGTH 0x8B87
#define GL_ACTIVE_VARIABLES 0x9305
#define GL_ACTIVE_VARYINGS_NV 0x8C81
#define GL_ACTIVE_VARYING_MAX_LENGTH_NV 0x8C82
#define GL_ACTIVE_VERTEX_UNITS_ARB 0x86A5
#define GL_ADD_ATI 0x8963
#define GL_ADD_SIGNED_ARB 0x8574
#define GL_ADD_SIGNED_EXT 0x8574
#define GL_ADJACENT_PAIRS_NV 0x90AE
#define GL_AFFINE_2D_NV 0x9092
#define GL_AFFINE_3D_NV 0x9094
#define GL_ALIASED_LINE_WIDTH_RANGE 0x846E
#define GL_ALL_BARRIER_BITS 0xFFFFFFFF
#define GL_ALL_BARRIER_BITS_EXT 0xFFFFFFFF
#define GL_ALL_COMPLETED_NV 0x84F2
#define GL_ALL_PIXELS_AMD 0xFFFFFFFF
#define GL_ALL_SHADER_BITS 0xFFFFFFFF
#define GL_ALPHA 0x1906
#define GL_ALPHA12_EXT 0x803D
#define GL_ALPHA16F_ARB 0x881C
#define GL_ALPHA16I_EXT 0x8D8A
#define GL_ALPHA16UI_EXT 0x8D78
#define GL_ALPHA16_EXT 0x803E
#define GL_ALPHA16_SNORM 0x9018
#define GL_ALPHA32F_ARB 0x8816
#define GL_ALPHA32I_EXT 0x8D84
#define GL_ALPHA32UI_EXT 0x8D72
#define GL_ALPHA4_EXT 0x803B
#define GL_ALPHA8I_EXT 0x8D90
#define GL_ALPHA8UI_EXT 0x8D7E
#define GL_ALPHA8_EXT 0x803C
#define GL_ALPHA8_SNORM 0x9014
#define GL_ALPHA_FLOAT16_APPLE 0x881C
#define GL_ALPHA_FLOAT16_ATI 0x881C
#define GL_ALPHA_FLOAT32_APPLE 0x8816
#define GL_ALPHA_FLOAT32_ATI 0x8816
#define GL_ALPHA_INTEGER_EXT 0x8D97
#define GL_ALPHA_REF_COMMAND_NV 0x000F
#define GL_ALPHA_SNORM 0x9010
#define GL_ALPHA_TO_COVERAGE_DITHER_DEFAULT_NV 0x934D
#define GL_ALPHA_TO_COVERAGE_DITHER_DISABLE_NV 0x934F
#define GL_ALPHA_TO_COVERAGE_DITHER_ENABLE_NV 0x934E
#define GL_ALPHA_TO_COVERAGE_DITHER_MODE_NV 0x92BF
#define GL_ALREADY_SIGNALED 0x911A
#define GL_ALWAYS 0x0207
#define GL_AND 0x1501
#define GL_AND_INVERTED 0x1504
#define GL_AND_REVERSE 0x1502
#define GL_ANY_SAMPLES_PASSED 0x8C2F
#define GL_ANY_SAMPLES_PASSED_CONSERVATIVE 0x8D6A
#define GL_ARC_TO_NV 0xFE
#define GL_ARRAY_BUFFER 0x8892
#define GL_ARRAY_BUFFER_ARB 0x8892
#define GL_ARRAY_BUFFER_BINDING 0x8894
#define GL_ARRAY_BUFFER_BINDING_ARB 0x8894
#define GL_ARRAY_ELEMENT_LOCK_COUNT_EXT 0x81A9
#define GL_ARRAY_ELEMENT_LOCK_FIRST_EXT 0x81A8
#define GL_ARRAY_OBJECT_BUFFER_ATI 0x8766
#define GL_ARRAY_OBJECT_OFFSET_ATI 0x8767
#define GL_ARRAY_SIZE 0x92FB
#define GL_ARRAY_STRIDE 0x92FE
#define GL_ATOMIC_COUNTER_BARRIER_BIT 0x00001000
#define GL_ATOMIC_COUNTER_BARRIER_BIT_EXT 0x00001000
#define GL_ATOMIC_COUNTER_BUFFER 0x92C0
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS 0x92C5
#define GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES 0x92C6
#define GL_ATOMIC_COUNTER_BUFFER_BINDING 0x92C1
#define GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE 0x92C4
#define GL_ATOMIC_COUNTER_BUFFER_INDEX 0x9301
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER 0x90ED
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER 0x92CB
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER 0x92CA
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER 0x92C8
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER 0x92C9
#define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER 0x92C7
#define GL_ATOMIC_COUNTER_BUFFER_SIZE 0x92C3
#define GL_ATOMIC_COUNTER_BUFFER_START 0x92C2
#define GL_ATTACHED_SHADERS 0x8B85
#define GL_ATTENUATION_EXT 0x834D
#define GL_ATTRIBUTE_ADDRESS_COMMAND_NV 0x0009
#define GL_ATTRIB_ARRAY_POINTER_NV 0x8645
#define GL_ATTRIB_ARRAY_SIZE_NV 0x8623
#define GL_ATTRIB_ARRAY_STRIDE_NV 0x8624
#define GL_ATTRIB_ARRAY_TYPE_NV 0x8625
#define GL_AUTO_GENERATE_MIPMAP 0x8295
#define GL_AUX_DEPTH_STENCIL_APPLE 0x8A14
#define GL_AVERAGE_EXT 0x8335
#define GL_BACK 0x0405
#define GL_BACK_LEFT 0x0402
#define GL_BACK_PRIMARY_COLOR_NV 0x8C77
#define GL_BACK_RIGHT 0x0403
#define GL_BACK_SECONDARY_COLOR_NV 0x8C78
#define GL_BEVEL_NV 0x90A6
#define GL_BGR 0x80E0
#define GL_BGRA 0x80E1
#define GL_BGRA_EXT 0x80E1
#define GL_BGRA_INTEGER 0x8D9B
#define GL_BGRA_INTEGER_EXT 0x8D9B
#define GL_BGR_EXT 0x80E0
#define GL_BGR_INTEGER 0x8D9A
#define GL_BGR_INTEGER_EXT 0x8D9A
#define GL_BIAS_BIT_ATI 0x00000008
#define GL_BIAS_BY_NEGATIVE_ONE_HALF_NV 0x8541
#define GL_BINORMAL_ARRAY_EXT 0x843A
#define GL_BINORMAL_ARRAY_POINTER_EXT 0x8443
#define GL_BINORMAL_ARRAY_STRIDE_EXT 0x8441
#define GL_BINORMAL_ARRAY_TYPE_EXT 0x8440
#define GL_BLEND 0x0BE2
#define GL_BLEND_ADVANCED_COHERENT_KHR 0x9285
#define GL_BLEND_ADVANCED_COHERENT_NV 0x9285
#define GL_BLEND_COLOR 0x8005
#define GL_BLEND_COLOR_COMMAND_NV 0x000B
#define GL_BLEND_COLOR_EXT 0x8005
#define GL_BLEND_DST 0x0BE0
#define GL_BLEND_DST_ALPHA 0x80CA
#define GL_BLEND_DST_ALPHA_EXT 0x80CA
#define GL_BLEND_DST_RGB 0x80C8
#define GL_BLEND_DST_RGB_EXT 0x80C8
#define GL_BLEND_EQUATION 0x8009
#define GL_BLEND_EQUATION_ALPHA 0x883D
#define GL_BLEND_EQUATION_ALPHA_EXT 0x883D
#define GL_BLEND_EQUATION_EXT 0x8009
#define GL_BLEND_EQUATION_RGB 0x8009
#define GL_BLEND_EQUATION_RGB_EXT 0x8009
#define GL_BLEND_OVERLAP_NV 0x9281
#define GL_BLEND_PREMULTIPLIED_SRC_NV 0x9280
#define GL_BLEND_SRC 0x0BE1
#define GL_BLEND_SRC_ALPHA 0x80CB
#define GL_BLEND_SRC_ALPHA_EXT 0x80CB
#define GL_BLEND_SRC_RGB 0x80C9
#define GL_BLEND_SRC_RGB_EXT 0x80C9
#define GL_BLOCK_INDEX 0x92FD
#define GL_BLUE 0x1905
#define GL_BLUE_BIT_ATI 0x00000004
#define GL_BLUE_INTEGER 0x8D96
#define GL_BLUE_INTEGER_EXT 0x8D96
#define GL_BLUE_NV 0x1905
#define GL_BOLD_BIT_NV 0x01
#define GL_BOOL 0x8B56
#define GL_BOOL_ARB 0x8B56
#define GL_BOOL_VEC2 0x8B57
#define GL_BOOL_VEC2_ARB 0x8B57
#define GL_BOOL_VEC3 0x8B58
#define GL_BOOL_VEC3_ARB 0x8B58
#define GL_BOOL_VEC4 0x8B59
#define GL_BOOL_VEC4_ARB 0x8B59
#define GL_BOUNDING_BOX_NV 0x908D
#define GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV 0x909C
#define GL_BUFFER 0x82E0
#define GL_BUFFER_ACCESS 0x88BB
#define GL_BUFFER_ACCESS_ARB 0x88BB
#define GL_BUFFER_ACCESS_FLAGS 0x911F
#define GL_BUFFER_BINDING 0x9302
#define GL_BUFFER_DATA_SIZE 0x9303
#define GL_BUFFER_FLUSHING_UNMAP_APPLE 0x8A13
#define GL_BUFFER_GPU_ADDRESS_NV 0x8F1D
#define GL_BUFFER_IMMUTABLE_STORAGE 0x821F
#define GL_BUFFER_MAPPED 0x88BC
#define GL_BUFFER_MAPPED_ARB 0x88BC
#define GL_BUFFER_MAP_LENGTH 0x9120
#define GL_BUFFER_MAP_OFFSET 0x9121
#define GL_BUFFER_MAP_POINTER 0x88BD
#define GL_BUFFER_MAP_POINTER_ARB 0x88BD
#define GL_BUFFER_OBJECT_APPLE 0x85B3
#define GL_BUFFER_OBJECT_EXT 0x9151
#define GL_BUFFER_SERIALIZED_MODIFY_APPLE 0x8A12
#define GL_BUFFER_SIZE 0x8764
#define GL_BUFFER_SIZE_ARB 0x8764
#define GL_BUFFER_STORAGE_FLAGS 0x8220
#define GL_BUFFER_UPDATE_BARRIER_BIT 0x00000200
#define GL_BUFFER_UPDATE_BARRIER_BIT_EXT 0x00000200
#define GL_BUFFER_USAGE 0x8765
#define GL_BUFFER_USAGE_ARB 0x8765
#define GL_BUFFER_VARIABLE 0x92E5
#define GL_BUMP_ENVMAP_ATI 0x877B
#define GL_BUMP_NUM_TEX_UNITS_ATI 0x8777
#define GL_BUMP_ROT_MATRIX_ATI 0x8775
#define GL_BUMP_ROT_MATRIX_SIZE_ATI 0x8776
#define GL_BUMP_TARGET_ATI 0x877C
#define GL_BUMP_TEX_UNITS_ATI 0x8778
#define GL_BYTE 0x1400
#define GL_CAVEAT_SUPPORT 0x82B8
#define GL_CCW 0x0901
#define GL_CIRCULAR_CCW_ARC_TO_NV 0xF8
#define GL_CIRCULAR_CW_ARC_TO_NV 0xFA
#define GL_CIRCULAR_TANGENT_ARC_TO_NV 0xFC
#define GL_CLAMP_FRAGMENT_COLOR_ARB 0x891B
#define GL_CLAMP_READ_COLOR 0x891C
#define GL_CLAMP_READ_COLOR_ARB 0x891C
#define GL_CLAMP_TO_BORDER 0x812D
#define GL_CLAMP_TO_BORDER_ARB 0x812D
#define GL_CLAMP_TO_EDGE 0x812F
#define GL_CLAMP_VERTEX_COLOR_ARB 0x891A
#define GL_CLEAR 0x1500
#define GL_CLEAR_BUFFER 0x82B4
#define GL_CLEAR_TEXTURE 0x9365
#define GL_CLIENT_ACTIVE_TEXTURE_ARB 0x84E1
#define GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT 0x00004000
#define GL_CLIENT_STORAGE_BIT 0x0200
#define GL_CLIPPING_INPUT_PRIMITIVES 0x82F6
#define GL_CLIPPING_INPUT_PRIMITIVES_ARB 0x82F6
#define GL_CLIPPING_OUTPUT_PRIMITIVES 0x82F7
#define GL_CLIPPING_OUTPUT_PRIMITIVES_ARB 0x82F7
#define GL_CLIP_DEPTH_MODE 0x935D
#define GL_CLIP_DISTANCE0 0x3000
#define GL_CLIP_DISTANCE1 0x3001
#define GL_CLIP_DISTANCE2 0x3002
#define GL_CLIP_DISTANCE3 0x3003
#define GL_CLIP_DISTANCE4 0x3004
#define GL_CLIP_DISTANCE5 0x3005
#define GL_CLIP_DISTANCE6 0x3006
#define GL_CLIP_DISTANCE7 0x3007
#define GL_CLIP_DISTANCE_NV 0x8C7A
#define GL_CLIP_ORIGIN 0x935C
#define GL_CLIP_VOLUME_CLIPPING_HINT_EXT 0x80F0
#define GL_CLOSE_PATH_NV 0x00
#define GL_CMYKA_EXT 0x800D
#define GL_CMYK_EXT 0x800C
#define GL_CND0_ATI 0x896B
#define GL_CND_ATI 0x896A
#define GL_COLOR 0x1800
#define GL_COLORBURN_KHR 0x929A
#define GL_COLORBURN_NV 0x929A
#define GL_COLORDODGE_KHR 0x9299
#define GL_COLORDODGE_NV 0x9299
#define GL_COLOR_ALPHA_PAIRING_ATI 0x8975
#define GL_COLOR_ARRAY_ADDRESS_NV 0x8F23
#define GL_COLOR_ARRAY_BUFFER_BINDING_ARB 0x8898
#define GL_COLOR_ARRAY_COUNT_EXT 0x8084
#define GL_COLOR_ARRAY_EXT 0x8076
#define GL_COLOR_ARRAY_LENGTH_NV 0x8F2D
#define GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL 0x83F7
#define GL_COLOR_ARRAY_POINTER_EXT 0x8090
#define GL_COLOR_ARRAY_SIZE_EXT 0x8081
#define GL_COLOR_ARRAY_STRIDE_EXT 0x8083
#define GL_COLOR_ARRAY_TYPE_EXT 0x8082
#define GL_COLOR_ATTACHMENT0 0x8CE0
#define GL_COLOR_ATTACHMENT0_EXT 0x8CE0
#define GL_COLOR_ATTACHMENT1 0x8CE1
#define GL_COLOR_ATTACHMENT10 0x8CEA
#define GL_COLOR_ATTACHMENT10_EXT 0x8CEA
#define GL_COLOR_ATTACHMENT11 0x8CEB
#define GL_COLOR_ATTACHMENT11_EXT 0x8CEB
#define GL_COLOR_ATTACHMENT12 0x8CEC
#define GL_COLOR_ATTACHMENT12_EXT 0x8CEC
#define GL_COLOR_ATTACHMENT13 0x8CED
#define GL_COLOR_ATTACHMENT13_EXT 0x8CED
#define GL_COLOR_ATTACHMENT14 0x8CEE
#define GL_COLOR_ATTACHMENT14_EXT 0x8CEE
#define GL_COLOR_ATTACHMENT15 0x8CEF
#define GL_COLOR_ATTACHMENT15_EXT 0x8CEF
#define GL_COLOR_ATTACHMENT16 0x8CF0
#define GL_COLOR_ATTACHMENT17 0x8CF1
#define GL_COLOR_ATTACHMENT18 0x8CF2
#define GL_COLOR_ATTACHMENT19 0x8CF3
#define GL_COLOR_ATTACHMENT1_EXT 0x8CE1
#define GL_COLOR_ATTACHMENT2 0x8CE2
#define GL_COLOR_ATTACHMENT20 0x8CF4
#define GL_COLOR_ATTACHMENT21 0x8CF5
#define GL_COLOR_ATTACHMENT22 0x8CF6
#define GL_COLOR_ATTACHMENT23 0x8CF7
#define GL_COLOR_ATTACHMENT24 0x8CF8
#define GL_COLOR_ATTACHMENT25 0x8CF9
#define GL_COLOR_ATTACHMENT26 0x8CFA
#define GL_COLOR_ATTACHMENT27 0x8CFB
#define GL_COLOR_ATTACHMENT28 0x8CFC
#define GL_COLOR_ATTACHMENT29 0x8CFD
#define GL_COLOR_ATTACHMENT2_EXT 0x8CE2
#define GL_COLOR_ATTACHMENT3 0x8CE3
#define GL_COLOR_ATTACHMENT30 0x8CFE
#define GL_COLOR_ATTACHMENT31 0x8CFF
#define GL_COLOR_ATTACHMENT3_EXT 0x8CE3
#define GL_COLOR_ATTACHMENT4 0x8CE4
#define GL_COLOR_ATTACHMENT4_EXT 0x8CE4
#define GL_COLOR_ATTACHMENT5 0x8CE5
#define GL_COLOR_ATTACHMENT5_EXT 0x8CE5
#define GL_COLOR_ATTACHMENT6 0x8CE6
#define GL_COLOR_ATTACHMENT6_EXT 0x8CE6
#define GL_COLOR_ATTACHMENT7 0x8CE7
#define GL_COLOR_ATTACHMENT7_EXT 0x8CE7
#define GL_COLOR_ATTACHMENT8 0x8CE8
#define GL_COLOR_ATTACHMENT8_EXT 0x8CE8
#define GL_COLOR_ATTACHMENT9 0x8CE9
#define GL_COLOR_ATTACHMENT9_EXT 0x8CE9
#define GL_COLOR_BUFFER_BIT 0x00004000
#define GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI 0x8835
#define GL_COLOR_CLEAR_VALUE 0x0C22
#define GL_COLOR_COMPONENTS 0x8283
#define GL_COLOR_ENCODING 0x8296
#define GL_COLOR_FLOAT_APPLE 0x8A0F
#define GL_COLOR_INDEX12_EXT 0x80E6
#define GL_COLOR_INDEX16_EXT 0x80E7
#define GL_COLOR_INDEX1_EXT 0x80E2
#define GL_COLOR_INDEX2_EXT 0x80E3
#define GL_COLOR_INDEX4_EXT 0x80E4
#define GL_COLOR_INDEX8_EXT 0x80E5
#define GL_COLOR_LOGIC_OP 0x0BF2
#define GL_COLOR_RENDERABLE 0x8286
#define GL_COLOR_SAMPLES_NV 0x8E20
#define GL_COLOR_SUM_ARB 0x8458
#define GL_COLOR_SUM_CLAMP_NV 0x854F
#define GL_COLOR_SUM_EXT 0x8458
#define GL_COLOR_WRITEMASK 0x0C23
#define GL_COMBINE4_NV 0x8503
#define GL_COMBINER0_NV 0x8550
#define GL_COMBINER1_NV 0x8551
#define GL_COMBINER2_NV 0x8552
#define GL_COMBINER3_NV 0x8553
#define GL_COMBINER4_NV 0x8554
#define GL_COMBINER5_NV 0x8555
#define GL_COMBINER6_NV 0x8556
#define GL_COMBINER7_NV 0x8557
#define GL_COMBINER_AB_DOT_PRODUCT_NV 0x8545
#define GL_COMBINER_AB_OUTPUT_NV 0x854A
#define GL_COMBINER_BIAS_NV 0x8549
#define GL_COMBINER_CD_DOT_PRODUCT_NV 0x8546
#define GL_COMBINER_CD_OUTPUT_NV 0x854B
#define GL_COMBINER_COMPONENT_USAGE_NV 0x8544
#define GL_COMBINER_INPUT_NV 0x8542
#define GL_COMBINER_MAPPING_NV 0x8543
#define GL_COMBINER_MUX_SUM_NV 0x8547
#define GL_COMBINER_SCALE_NV 0x8548
#define GL_COMBINER_SUM_OUTPUT_NV 0x854C
#define GL_COMBINE_ALPHA_ARB 0x8572
#define GL_COMBINE_ALPHA_EXT 0x8572
#define GL_COMBINE_ARB 0x8570
#define GL_COMBINE_EXT 0x8570
#define GL_COMBINE_RGB_ARB 0x8571
#define GL_COMBINE_RGB_EXT 0x8571
#define GL_COMMAND_BARRIER_BIT 0x00000040
#define GL_COMMAND_BARRIER_BIT_EXT 0x00000040
#define GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT 0x884E
#define GL_COMPARE_REF_TO_TEXTURE 0x884E
#define GL_COMPARE_R_TO_TEXTURE_ARB 0x884E
#define GL_COMPATIBLE_SUBROUTINES 0x8E4B
#define GL_COMPILE_STATUS 0x8B81
#define GL_COMPLETION_STATUS_ARB 0x91B1
#define GL_COMPLETION_STATUS_KHR 0x91B1
#define GL_COMPRESSED_ALPHA_ARB 0x84E9
#define GL_COMPRESSED_INTENSITY_ARB 0x84EC
#define GL_COMPRESSED_LUMINANCE_ALPHA_ARB 0x84EB
#define GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT 0x8C72
#define GL_COMPRESSED_LUMINANCE_ARB 0x84EA
#define GL_COMPRESSED_LUMINANCE_LATC1_EXT 0x8C70
#define GL_COMPRESSED_R11_EAC 0x9270
#define GL_COMPRESSED_RED 0x8225
#define GL_COMPRESSED_RED_GREEN_RGTC2_EXT 0x8DBD
#define GL_COMPRESSED_RED_RGTC1 0x8DBB
#define GL_COMPRESSED_RED_RGTC1_EXT 0x8DBB
#define GL_COMPRESSED_RG 0x8226
#define GL_COMPRESSED_RG11_EAC 0x9272
#define GL_COMPRESSED_RGB 0x84ED
#define GL_COMPRESSED_RGB8_ETC2 0x9274
#define GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9276
#define GL_COMPRESSED_RGBA 0x84EE
#define GL_COMPRESSED_RGBA8_ETC2_EAC 0x9278
#define GL_COMPRESSED_RGBA_ARB 0x84EE
#define GL_COMPRESSED_RGBA_ASTC_10x10_KHR 0x93BB
#define GL_COMPRESSED_RGBA_ASTC_10x5_KHR 0x93B8
#define GL_COMPRESSED_RGBA_ASTC_10x6_KHR 0x93B9
#define GL_COMPRESSED_RGBA_ASTC_10x8_KHR 0x93BA
#define GL_COMPRESSED_RGBA_ASTC_12x10_KHR 0x93BC
#define GL_COMPRESSED_RGBA_ASTC_12x12_KHR 0x93BD
#define GL_COMPRESSED_RGBA_ASTC_4x4_KHR 0x93B0
#define GL_COMPRESSED_RGBA_ASTC_5x4_KHR 0x93B1
#define GL_COMPRESSED_RGBA_ASTC_5x5_KHR 0x93B2
#define GL_COMPRESSED_RGBA_ASTC_6x5_KHR 0x93B3
#define GL_COMPRESSED_RGBA_ASTC_6x6_KHR 0x93B4
#define GL_COMPRESSED_RGBA_ASTC_8x5_KHR 0x93B5
#define GL_COMPRESSED_RGBA_ASTC_8x6_KHR 0x93B6
#define GL_COMPRESSED_RGBA_ASTC_8x8_KHR 0x93B7
#define GL_COMPRESSED_RGBA_BPTC_UNORM 0x8E8C
#define GL_COMPRESSED_RGBA_BPTC_UNORM_ARB 0x8E8C
#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT 0x83F1
#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT 0x83F2
#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT 0x83F3
#define GL_COMPRESSED_RGB_ARB 0x84ED
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT 0x8E8E
#define GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB 0x8E8E
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT 0x8E8F
#define GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB 0x8E8F
#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT 0x83F0
#define GL_COMPRESSED_RG_RGTC2 0x8DBD
#define GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT 0x8C73
#define GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT 0x8C71
#define GL_COMPRESSED_SIGNED_R11_EAC 0x9271
#define GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT 0x8DBE
#define GL_COMPRESSED_SIGNED_RED_RGTC1 0x8DBC
#define GL_COMPRESSED_SIGNED_RED_RGTC1_EXT 0x8DBC
#define GL_COMPRESSED_SIGNED_RG11_EAC 0x9273
#define GL_COMPRESSED_SIGNED_RG_RGTC2 0x8DBE
#define GL_COMPRESSED_SLUMINANCE_ALPHA_EXT 0x8C4B
#define GL_COMPRESSED_SLUMINANCE_EXT 0x8C4A
#define GL_COMPRESSED_SRGB 0x8C48
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR 0x93DB
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR 0x93D8
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR 0x93D9
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR 0x93DA
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR 0x93DC
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR 0x93DD
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR 0x93D0
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR 0x93D1
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR 0x93D2
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR 0x93D3
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR 0x93D4
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR 0x93D5
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR 0x93D6
#define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR 0x93D7
#define GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC 0x9279
#define GL_COMPRESSED_SRGB8_ETC2 0x9275
#define GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 0x9277
#define GL_COMPRESSED_SRGB_ALPHA 0x8C49
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM 0x8E8D
#define GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB 0x8E8D
#define GL_COMPRESSED_SRGB_ALPHA_EXT 0x8C49
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT 0x8C4D
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT 0x8C4E
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT 0x8C4F
#define GL_COMPRESSED_SRGB_EXT 0x8C48
#define GL_COMPRESSED_SRGB_S3TC_DXT1_EXT 0x8C4C
#define GL_COMPRESSED_TEXTURE_FORMATS 0x86A3
#define GL_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A3
#define GL_COMPUTE_PROGRAM_NV 0x90FB
#define GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV 0x90FC
#define GL_COMPUTE_SHADER 0x91B9
#define GL_COMPUTE_SHADER_BIT 0x00000020
#define GL_COMPUTE_SHADER_INVOCATIONS 0x82F5
#define GL_COMPUTE_SHADER_INVOCATIONS_ARB 0x82F5
#define GL_COMPUTE_SUBROUTINE 0x92ED
#define GL_COMPUTE_SUBROUTINE_UNIFORM 0x92F3
#define GL_COMPUTE_TEXTURE 0x82A0
#define GL_COMPUTE_WORK_GROUP_SIZE 0x8267
#define GL_COMP_BIT_ATI 0x00000002
#define GL_CONDITION_SATISFIED 0x911C
#define GL_CONFORMANT_NV 0x9374
#define GL_CONIC_CURVE_TO_NV 0x1A
#define GL_CONJOINT_NV 0x9284
#define GL_CONSERVATIVE_RASTERIZATION_INTEL 0x83FE
#define GL_CONSERVATIVE_RASTERIZATION_NV 0x9346
#define GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV 0x937B
#define GL_CONSERVATIVE_RASTER_DILATE_NV 0x9379
#define GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV 0x937A
#define GL_CONSERVATIVE_RASTER_MODE_NV 0x954D
#define GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV 0x954E
#define GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV 0x954F
#define GL_CONSTANT_ALPHA 0x8003
#define GL_CONSTANT_ALPHA_EXT 0x8003
#define GL_CONSTANT_ARB 0x8576
#define GL_CONSTANT_COLOR 0x8001
#define GL_CONSTANT_COLOR0_NV 0x852A
#define GL_CONSTANT_COLOR1_NV 0x852B
#define GL_CONSTANT_COLOR_EXT 0x8001
#define GL_CONSTANT_EXT 0x8576
#define GL_CONST_EYE_NV 0x86E5
#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
#define GL_CONTEXT_CORE_PROFILE_BIT 0x00000001
#define GL_CONTEXT_FLAGS 0x821E
#define GL_CONTEXT_FLAG_DEBUG_BIT 0x00000002
#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x00000001
#define GL_CONTEXT_FLAG_NO_ERROR_BIT 0x00000008
#define GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR 0x00000008
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT 0x00000004
#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB 0x00000004
#define GL_CONTEXT_LOST 0x0507
#define GL_CONTEXT_PROFILE_MASK 0x9126
#define GL_CONTEXT_RELEASE_BEHAVIOR 0x82FB
#define GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH 0x82FC
#define GL_CONTEXT_ROBUST_ACCESS 0x90F3
#define GL_CONTINUOUS_AMD 0x9007
#define GL_CONTRAST_NV 0x92A1
#define GL_CONVEX_HULL_NV 0x908B
#define GL_CONVOLUTION_1D_EXT 0x8010
#define GL_CONVOLUTION_2D_EXT 0x8011
#define GL_CONVOLUTION_BORDER_MODE_EXT 0x8013
#define GL_CONVOLUTION_FILTER_BIAS_EXT 0x8015
#define GL_CONVOLUTION_FILTER_SCALE_EXT 0x8014
#define GL_CONVOLUTION_FORMAT_EXT 0x8017
#define GL_CONVOLUTION_HEIGHT_EXT 0x8019
#define GL_CONVOLUTION_WIDTH_EXT 0x8018
#define GL_CON_0_ATI 0x8941
#define GL_CON_10_ATI 0x894B
#define GL_CON_11_ATI 0x894C
#define GL_CON_12_ATI 0x894D
#define GL_CON_13_ATI 0x894E
#define GL_CON_14_ATI 0x894F
#define GL_CON_15_ATI 0x8950
#define GL_CON_16_ATI 0x8951
#define GL_CON_17_ATI 0x8952
#define GL_CON_18_ATI 0x8953
#define GL_CON_19_ATI 0x8954
#define GL_CON_1_ATI 0x8942
#define GL_CON_20_ATI 0x8955
#define GL_CON_21_ATI 0x8956
#define GL_CON_22_ATI 0x8957
#define GL_CON_23_ATI 0x8958
#define GL_CON_24_ATI 0x8959
#define GL_CON_25_ATI 0x895A
#define GL_CON_26_ATI 0x895B
#define GL_CON_27_ATI 0x895C
#define GL_CON_28_ATI 0x895D
#define GL_CON_29_ATI 0x895E
#define GL_CON_2_ATI 0x8943
#define GL_CON_30_ATI 0x895F
#define GL_CON_31_ATI 0x8960
#define GL_CON_3_ATI 0x8944
#define GL_CON_4_ATI 0x8945
#define GL_CON_5_ATI 0x8946
#define GL_CON_6_ATI 0x8947
#define GL_CON_7_ATI 0x8948
#define GL_CON_8_ATI 0x8949
#define GL_CON_9_ATI 0x894A
#define GL_COORD_REPLACE_ARB 0x8862
#define GL_COORD_REPLACE_NV 0x8862
#define GL_COPY 0x1503
#define GL_COPY_INVERTED 0x150C
#define GL_COPY_READ_BUFFER 0x8F36
#define GL_COPY_READ_BUFFER_BINDING 0x8F36
#define GL_COPY_WRITE_BUFFER 0x8F37
#define GL_COPY_WRITE_BUFFER_BINDING 0x8F37
#define GL_COUNTER_RANGE_AMD 0x8BC1
#define GL_COUNTER_TYPE_AMD 0x8BC0
#define GL_COUNT_DOWN_NV 0x9089
#define GL_COUNT_UP_NV 0x9088
#define GL_COVERAGE_MODULATION_NV 0x9332
#define GL_COVERAGE_MODULATION_TABLE_NV 0x9331
#define GL_COVERAGE_MODULATION_TABLE_SIZE_NV 0x9333
#define GL_CUBIC_CURVE_TO_NV 0x0C
#define GL_CUBIC_EXT 0x8334
#define GL_CULL_FACE 0x0B44
#define GL_CULL_FACE_MODE 0x0B45
#define GL_CULL_FRAGMENT_NV 0x86E7
#define GL_CULL_MODES_NV 0x86E0
#define GL_CULL_VERTEX_EXT 0x81AA
#define GL_CULL_VERTEX_EYE_POSITION_EXT 0x81AB
#define GL_CULL_VERTEX_OBJECT_POSITION_EXT 0x81AC
#define GL_CURRENT_ATTRIB_NV 0x8626
#define GL_CURRENT_BINORMAL_EXT 0x843C
#define GL_CURRENT_FOG_COORDINATE_EXT 0x8453
#define GL_CURRENT_MATRIX_ARB 0x8641
#define GL_CURRENT_MATRIX_INDEX_ARB 0x8845
#define GL_CURRENT_MATRIX_NV 0x8641
#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB 0x8640
#define GL_CURRENT_MATRIX_STACK_DEPTH_NV 0x8640
#define GL_CURRENT_OCCLUSION_QUERY_ID_NV 0x8865
#define GL_CURRENT_PALETTE_MATRIX_ARB 0x8843
#define GL_CURRENT_PROGRAM 0x8B8D
#define GL_CURRENT_QUERY 0x8865
#define GL_CURRENT_QUERY_ARB 0x8865
#define GL_CURRENT_SECONDARY_COLOR_EXT 0x8459
#define GL_CURRENT_TANGENT_EXT 0x843B
#define GL_CURRENT_TIME_NV 0x8E28
#define GL_CURRENT_VERTEX_ATTRIB 0x8626
#define GL_CURRENT_VERTEX_ATTRIB_ARB 0x8626
#define GL_CURRENT_VERTEX_EXT 0x87E2
#define GL_CURRENT_VERTEX_WEIGHT_EXT 0x850B
#define GL_CURRENT_WEIGHT_ARB 0x86A8
#define GL_CW 0x0900
#define GL_D3D12_FENCE_VALUE_EXT 0x9595
#define GL_DARKEN_KHR 0x9297
#define GL_DARKEN_NV 0x9297
#define GL_DATA_BUFFER_AMD 0x9151
#define GL_DEBUG_CALLBACK_FUNCTION 0x8244
#define GL_DEBUG_CALLBACK_FUNCTION_ARB 0x8244
#define GL_DEBUG_CALLBACK_USER_PARAM 0x8245
#define GL_DEBUG_CALLBACK_USER_PARAM_ARB 0x8245
#define GL_DEBUG_CATEGORY_API_ERROR_AMD 0x9149
#define GL_DEBUG_CATEGORY_APPLICATION_AMD 0x914F
#define GL_DEBUG_CATEGORY_DEPRECATION_AMD 0x914B
#define GL_DEBUG_CATEGORY_OTHER_AMD 0x9150
#define GL_DEBUG_CATEGORY_PERFORMANCE_AMD 0x914D
#define GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD 0x914E
#define GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD 0x914C
#define GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD 0x914A
#define GL_DEBUG_GROUP_STACK_DEPTH 0x826D
#define GL_DEBUG_LOGGED_MESSAGES 0x9145
#define GL_DEBUG_LOGGED_MESSAGES_AMD 0x9145
#define GL_DEBUG_LOGGED_MESSAGES_ARB 0x9145
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH 0x8243
#define GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB 0x8243
#define GL_DEBUG_OUTPUT 0x92E0
#define GL_DEBUG_OUTPUT_SYNCHRONOUS 0x8242
#define GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB 0x8242
#define GL_DEBUG_SEVERITY_HIGH 0x9146
#define GL_DEBUG_SEVERITY_HIGH_AMD 0x9146
#define GL_DEBUG_SEVERITY_HIGH_ARB 0x9146
#define GL_DEBUG_SEVERITY_LOW 0x9148
#define GL_DEBUG_SEVERITY_LOW_AMD 0x9148
#define GL_DEBUG_SEVERITY_LOW_ARB 0x9148
#define GL_DEBUG_SEVERITY_MEDIUM 0x9147
#define GL_DEBUG_SEVERITY_MEDIUM_AMD 0x9147
#define GL_DEBUG_SEVERITY_MEDIUM_ARB 0x9147
#define GL_DEBUG_SEVERITY_NOTIFICATION 0x826B
#define GL_DEBUG_SOURCE_API 0x8246
#define GL_DEBUG_SOURCE_API_ARB 0x8246
#define GL_DEBUG_SOURCE_APPLICATION 0x824A
#define GL_DEBUG_SOURCE_APPLICATION_ARB 0x824A
#define GL_DEBUG_SOURCE_OTHER 0x824B
#define GL_DEBUG_SOURCE_OTHER_ARB 0x824B
#define GL_DEBUG_SOURCE_SHADER_COMPILER 0x8248
#define GL_DEBUG_SOURCE_SHADER_COMPILER_ARB 0x8248
#define GL_DEBUG_SOURCE_THIRD_PARTY 0x8249
#define GL_DEBUG_SOURCE_THIRD_PARTY_ARB 0x8249
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM 0x8247
#define GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB 0x8247
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR 0x824D
#define GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB 0x824D
#define GL_DEBUG_TYPE_ERROR 0x824C
#define GL_DEBUG_TYPE_ERROR_ARB 0x824C
#define GL_DEBUG_TYPE_MARKER 0x8268
#define GL_DEBUG_TYPE_OTHER 0x8251
#define GL_DEBUG_TYPE_OTHER_ARB 0x8251
#define GL_DEBUG_TYPE_PERFORMANCE 0x8250
#define GL_DEBUG_TYPE_PERFORMANCE_ARB 0x8250
#define GL_DEBUG_TYPE_POP_GROUP 0x826A
#define GL_DEBUG_TYPE_PORTABILITY 0x824F
#define GL_DEBUG_TYPE_PORTABILITY_ARB 0x824F
#define GL_DEBUG_TYPE_PUSH_GROUP 0x8269
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR 0x824E
#define GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB 0x824E
#define GL_DECODE_EXT 0x8A49
#define GL_DECR 0x1E03
#define GL_DECR_WRAP 0x8508
#define GL_DECR_WRAP_EXT 0x8508
#define GL_DEDICATED_MEMORY_OBJECT_EXT 0x9581
#define GL_DELETE_STATUS 0x8B80
#define GL_DEPENDENT_AR_TEXTURE_2D_NV 0x86E9
#define GL_DEPENDENT_GB_TEXTURE_2D_NV 0x86EA
#define GL_DEPENDENT_HILO_TEXTURE_2D_NV 0x8858
#define GL_DEPENDENT_RGB_TEXTURE_3D_NV 0x8859
#define GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV 0x885A
#define GL_DEPTH 0x1801
#define GL_DEPTH24_STENCIL8 0x88F0
#define GL_DEPTH24_STENCIL8_EXT 0x88F0
#define GL_DEPTH32F_STENCIL8 0x8CAD
#define GL_DEPTH32F_STENCIL8_NV 0x8DAC
#define GL_DEPTH_ATTACHMENT 0x8D00
#define GL_DEPTH_ATTACHMENT_EXT 0x8D00
#define GL_DEPTH_BOUNDS_EXT 0x8891
#define GL_DEPTH_BOUNDS_TEST_EXT 0x8890
#define GL_DEPTH_BUFFER_BIT 0x00000100
#define GL_DEPTH_BUFFER_FLOAT_MODE_NV 0x8DAF
#define GL_DEPTH_CLAMP 0x864F
#define GL_DEPTH_CLAMP_FAR_AMD 0x901F
#define GL_DEPTH_CLAMP_NEAR_AMD 0x901E
#define GL_DEPTH_CLAMP_NV 0x864F
#define GL_DEPTH_CLEAR_VALUE 0x0B73
#define GL_DEPTH_COMPONENT 0x1902
#define GL_DEPTH_COMPONENT16 0x81A5
#define GL_DEPTH_COMPONENT16_ARB 0x81A5
#define GL_DEPTH_COMPONENT24 0x81A6
#define GL_DEPTH_COMPONENT24_ARB 0x81A6
#define GL_DEPTH_COMPONENT32 0x81A7
#define GL_DEPTH_COMPONENT32F 0x8CAC
#define GL_DEPTH_COMPONENT32F_NV 0x8DAB
#define GL_DEPTH_COMPONENT32_ARB 0x81A7
#define GL_DEPTH_COMPONENTS 0x8284
#define GL_DEPTH_FUNC 0x0B74
#define GL_DEPTH_RANGE 0x0B70
#define GL_DEPTH_RENDERABLE 0x8287
#define GL_DEPTH_SAMPLES_NV 0x932D
#define GL_DEPTH_STENCIL 0x84F9
#define GL_DEPTH_STENCIL_ATTACHMENT 0x821A
#define GL_DEPTH_STENCIL_EXT 0x84F9
#define GL_DEPTH_STENCIL_NV 0x84F9
#define GL_DEPTH_STENCIL_TEXTURE_MODE 0x90EA
#define GL_DEPTH_STENCIL_TO_BGRA_NV 0x886F
#define GL_DEPTH_STENCIL_TO_RGBA_NV 0x886E
#define GL_DEPTH_TEST 0x0B71
#define GL_DEPTH_TEXTURE_MODE_ARB 0x884B
#define GL_DEPTH_WRITEMASK 0x0B72
#define GL_DEVICE_LUID_EXT 0x9599
#define GL_DEVICE_NODE_MASK_EXT 0x959A
#define GL_DEVICE_UUID_EXT 0x9597
#define GL_DIFFERENCE_KHR 0x929E
#define GL_DIFFERENCE_NV 0x929E
#define GL_DISCARD_ATI 0x8763
#define GL_DISCARD_NV 0x8530
#define GL_DISCRETE_AMD 0x9006
#define GL_DISJOINT_NV 0x9283
#define GL_DISPATCH_INDIRECT_BUFFER 0x90EE
#define GL_DISPATCH_INDIRECT_BUFFER_BINDING 0x90EF
#define GL_DISTANCE_ATTENUATION_EXT 0x8129
#define GL_DITHER 0x0BD0
#define GL_DONT_CARE 0x1100
#define GL_DOT2_ADD_ATI 0x896C
#define GL_DOT3_ATI 0x8966
#define GL_DOT3_RGBA_ARB 0x86AF
#define GL_DOT3_RGBA_EXT 0x8741
#define GL_DOT3_RGB_ARB 0x86AE
#define GL_DOT3_RGB_EXT 0x8740
#define GL_DOT4_ATI 0x8967
#define GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV 0x885D
#define GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV 0x86F3
#define GL_DOT_PRODUCT_DEPTH_REPLACE_NV 0x86ED
#define GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV 0x86F1
#define GL_DOT_PRODUCT_NV 0x86EC
#define GL_DOT_PRODUCT_PASS_THROUGH_NV 0x885B
#define GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV 0x86F2
#define GL_DOT_PRODUCT_TEXTURE_1D_NV 0x885C
#define GL_DOT_PRODUCT_TEXTURE_2D_NV 0x86EE
#define GL_DOT_PRODUCT_TEXTURE_3D_NV 0x86EF
#define GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV 0x86F0
#define GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV 0x864E
#define GL_DOUBLE 0x140A
#define GL_DOUBLEBUFFER 0x0C32
#define GL_DOUBLE_MAT2 0x8F46
#define GL_DOUBLE_MAT2_EXT 0x8F46
#define GL_DOUBLE_MAT2x3 0x8F49
#define GL_DOUBLE_MAT2x3_EXT 0x8F49
#define GL_DOUBLE_MAT2x4 0x8F4A
#define GL_DOUBLE_MAT2x4_EXT 0x8F4A
#define GL_DOUBLE_MAT3 0x8F47
#define GL_DOUBLE_MAT3_EXT 0x8F47
#define GL_DOUBLE_MAT3x2 0x8F4B
#define GL_DOUBLE_MAT3x2_EXT 0x8F4B
#define GL_DOUBLE_MAT3x4 0x8F4C
#define GL_DOUBLE_MAT3x4_EXT 0x8F4C
#define GL_DOUBLE_MAT4 0x8F48
#define GL_DOUBLE_MAT4_EXT 0x8F48
#define GL_DOUBLE_MAT4x2 0x8F4D
#define GL_DOUBLE_MAT4x2_EXT 0x8F4D
#define GL_DOUBLE_MAT4x3 0x8F4E
#define GL_DOUBLE_MAT4x3_EXT 0x8F4E
#define GL_DOUBLE_VEC2 0x8FFC
#define GL_DOUBLE_VEC2_EXT 0x8FFC
#define GL_DOUBLE_VEC3 0x8FFD
#define GL_DOUBLE_VEC3_EXT 0x8FFD
#define GL_DOUBLE_VEC4 0x8FFE
#define GL_DOUBLE_VEC4_EXT 0x8FFE
#define GL_DRAW_ARRAYS_COMMAND_NV 0x0003
#define GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV 0x0007
#define GL_DRAW_ARRAYS_STRIP_COMMAND_NV 0x0005
#define GL_DRAW_BUFFER 0x0C01
#define GL_DRAW_BUFFER0 0x8825
#define GL_DRAW_BUFFER0_ARB 0x8825
#define GL_DRAW_BUFFER0_ATI 0x8825
#define GL_DRAW_BUFFER1 0x8826
#define GL_DRAW_BUFFER10 0x882F
#define GL_DRAW_BUFFER10_ARB 0x882F
#define GL_DRAW_BUFFER10_ATI 0x882F
#define GL_DRAW_BUFFER11 0x8830
#define GL_DRAW_BUFFER11_ARB 0x8830
#define GL_DRAW_BUFFER11_ATI 0x8830
#define GL_DRAW_BUFFER12 0x8831
#define GL_DRAW_BUFFER12_ARB 0x8831
#define GL_DRAW_BUFFER12_ATI 0x8831
#define GL_DRAW_BUFFER13 0x8832
#define GL_DRAW_BUFFER13_ARB 0x8832
#define GL_DRAW_BUFFER13_ATI 0x8832
#define GL_DRAW_BUFFER14 0x8833
#define GL_DRAW_BUFFER14_ARB 0x8833
#define GL_DRAW_BUFFER14_ATI 0x8833
#define GL_DRAW_BUFFER15 0x8834
#define GL_DRAW_BUFFER15_ARB 0x8834
#define GL_DRAW_BUFFER15_ATI 0x8834
#define GL_DRAW_BUFFER1_ARB 0x8826
#define GL_DRAW_BUFFER1_ATI 0x8826
#define GL_DRAW_BUFFER2 0x8827
#define GL_DRAW_BUFFER2_ARB 0x8827
#define GL_DRAW_BUFFER2_ATI 0x8827
#define GL_DRAW_BUFFER3 0x8828
#define GL_DRAW_BUFFER3_ARB 0x8828
#define GL_DRAW_BUFFER3_ATI 0x8828
#define GL_DRAW_BUFFER4 0x8829
#define GL_DRAW_BUFFER4_ARB 0x8829
#define GL_DRAW_BUFFER4_ATI 0x8829
#define GL_DRAW_BUFFER5 0x882A
#define GL_DRAW_BUFFER5_ARB 0x882A
#define GL_DRAW_BUFFER5_ATI 0x882A
#define GL_DRAW_BUFFER6 0x882B
#define GL_DRAW_BUFFER6_ARB 0x882B
#define GL_DRAW_BUFFER6_ATI 0x882B
#define GL_DRAW_BUFFER7 0x882C
#define GL_DRAW_BUFFER7_ARB 0x882C
#define GL_DRAW_BUFFER7_ATI 0x882C
#define GL_DRAW_BUFFER8 0x882D
#define GL_DRAW_BUFFER8_ARB 0x882D
#define GL_DRAW_BUFFER8_ATI 0x882D
#define GL_DRAW_BUFFER9 0x882E
#define GL_DRAW_BUFFER9_ARB 0x882E
#define GL_DRAW_BUFFER9_ATI 0x882E
#define GL_DRAW_ELEMENTS_COMMAND_NV 0x0002
#define GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV 0x0006
#define GL_DRAW_ELEMENTS_STRIP_COMMAND_NV 0x0004
#define GL_DRAW_FRAMEBUFFER 0x8CA9
#define GL_DRAW_FRAMEBUFFER_BINDING 0x8CA6
#define GL_DRAW_FRAMEBUFFER_BINDING_EXT 0x8CA6
#define GL_DRAW_FRAMEBUFFER_EXT 0x8CA9
#define GL_DRAW_INDIRECT_ADDRESS_NV 0x8F41
#define GL_DRAW_INDIRECT_BUFFER 0x8F3F
#define GL_DRAW_INDIRECT_BUFFER_BINDING 0x8F43
#define GL_DRAW_INDIRECT_LENGTH_NV 0x8F42
#define GL_DRAW_INDIRECT_UNIFIED_NV 0x8F40
#define GL_DRAW_PIXELS_APPLE 0x8A0A
#define GL_DRIVER_UUID_EXT 0x9598
#define GL_DSDT8_MAG8_INTENSITY8_NV 0x870B
#define GL_DSDT8_MAG8_NV 0x870A
#define GL_DSDT8_NV 0x8709
#define GL_DSDT_MAG_INTENSITY_NV 0x86DC
#define GL_DSDT_MAG_NV 0x86F6
#define GL_DSDT_MAG_VIB_NV 0x86F7
#define GL_DSDT_NV 0x86F5
#define GL_DST_ALPHA 0x0304
#define GL_DST_ATOP_NV 0x928F
#define GL_DST_COLOR 0x0306
#define GL_DST_IN_NV 0x928B
#define GL_DST_NV 0x9287
#define GL_DST_OUT_NV 0x928D
#define GL_DST_OVER_NV 0x9289
#define GL_DS_BIAS_NV 0x8716
#define GL_DS_SCALE_NV 0x8710
#define GL_DT_BIAS_NV 0x8717
#define GL_DT_SCALE_NV 0x8711
#define GL_DU8DV8_ATI 0x877A
#define GL_DUDV_ATI 0x8779
#define GL_DUP_FIRST_CUBIC_CURVE_TO_NV 0xF2
#define GL_DUP_LAST_CUBIC_CURVE_TO_NV 0xF4
#define GL_DYNAMIC_ATI 0x8761
#define GL_DYNAMIC_COPY 0x88EA
#define GL_DYNAMIC_COPY_ARB 0x88EA
#define GL_DYNAMIC_DRAW 0x88E8
#define GL_DYNAMIC_DRAW_ARB 0x88E8
#define GL_DYNAMIC_READ 0x88E9
#define GL_DYNAMIC_READ_ARB 0x88E9
#define GL_DYNAMIC_STORAGE_BIT 0x0100
#define GL_EDGE_FLAG_ARRAY_ADDRESS_NV 0x8F26
#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB 0x889B
#define GL_EDGE_FLAG_ARRAY_COUNT_EXT 0x808D
#define GL_EDGE_FLAG_ARRAY_EXT 0x8079
#define GL_EDGE_FLAG_ARRAY_LENGTH_NV 0x8F30
#define GL_EDGE_FLAG_ARRAY_POINTER_EXT 0x8093
#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT 0x808C
#define GL_EFFECTIVE_RASTER_SAMPLES_EXT 0x932C
#define GL_EIGHTH_BIT_ATI 0x00000020
#define GL_ELEMENT_ADDRESS_COMMAND_NV 0x0008
#define GL_ELEMENT_ARRAY_ADDRESS_NV 0x8F29
#define GL_ELEMENT_ARRAY_APPLE 0x8A0C
#define GL_ELEMENT_ARRAY_ATI 0x8768
#define GL_ELEMENT_ARRAY_BARRIER_BIT 0x00000002
#define GL_ELEMENT_ARRAY_BARRIER_BIT_EXT 0x00000002
#define GL_ELEMENT_ARRAY_BUFFER 0x8893
#define GL_ELEMENT_ARRAY_BUFFER_ARB 0x8893
#define GL_ELEMENT_ARRAY_BUFFER_BINDING 0x8895
#define GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB 0x8895
#define GL_ELEMENT_ARRAY_LENGTH_NV 0x8F33
#define GL_ELEMENT_ARRAY_POINTER_APPLE 0x8A0E
#define GL_ELEMENT_ARRAY_POINTER_ATI 0x876A
#define GL_ELEMENT_ARRAY_TYPE_APPLE 0x8A0D
#define GL_ELEMENT_ARRAY_TYPE_ATI 0x8769
#define GL_ELEMENT_ARRAY_UNIFIED_NV 0x8F1F
#define GL_EMBOSS_CONSTANT_NV 0x855E
#define GL_EMBOSS_LIGHT_NV 0x855D
#define GL_EMBOSS_MAP_NV 0x855F
#define GL_EQUAL 0x0202
#define GL_EQUIV 0x1509
#define GL_EVAL_2D_NV 0x86C0
#define GL_EVAL_FRACTIONAL_TESSELLATION_NV 0x86C5
#define GL_EVAL_TRIANGULAR_2D_NV 0x86C1
#define GL_EVAL_VERTEX_ATTRIB0_NV 0x86C6
#define GL_EVAL_VERTEX_ATTRIB10_NV 0x86D0
#define GL_EVAL_VERTEX_ATTRIB11_NV 0x86D1
#define GL_EVAL_VERTEX_ATTRIB12_NV 0x86D2
#define GL_EVAL_VERTEX_ATTRIB13_NV 0x86D3
#define GL_EVAL_VERTEX_ATTRIB14_NV 0x86D4
#define GL_EVAL_VERTEX_ATTRIB15_NV 0x86D5
#define GL_EVAL_VERTEX_ATTRIB1_NV 0x86C7
#define GL_EVAL_VERTEX_ATTRIB2_NV 0x86C8
#define GL_EVAL_VERTEX_ATTRIB3_NV 0x86C9
#define GL_EVAL_VERTEX_ATTRIB4_NV 0x86CA
#define GL_EVAL_VERTEX_ATTRIB5_NV 0x86CB
#define GL_EVAL_VERTEX_ATTRIB6_NV 0x86CC
#define GL_EVAL_VERTEX_ATTRIB7_NV 0x86CD
#define GL_EVAL_VERTEX_ATTRIB8_NV 0x86CE
#define GL_EVAL_VERTEX_ATTRIB9_NV 0x86CF
#define GL_EXCLUSION_KHR 0x92A0
#define GL_EXCLUSION_NV 0x92A0
#define GL_EXCLUSIVE_EXT 0x8F11
#define GL_EXPAND_NEGATE_NV 0x8539
#define GL_EXPAND_NORMAL_NV 0x8538
#define GL_EXTENSIONS 0x1F03
#define GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD 0x9160
#define GL_EYE_PLANE 0x2502
#define GL_EYE_PLANE_ABSOLUTE_NV 0x855C
#define GL_EYE_RADIAL_NV 0x855B
#define GL_E_TIMES_F_NV 0x8531
#define GL_FACTOR_MAX_AMD 0x901D
#define GL_FACTOR_MIN_AMD 0x901C
#define GL_FAILURE_NV 0x9030
#define GL_FALSE 0
#define GL_FASTEST 0x1101
#define GL_FENCE_APPLE 0x8A0B
#define GL_FENCE_CONDITION_NV 0x84F4
#define GL_FENCE_STATUS_NV 0x84F3
#define GL_FIELDS_NV 0x8E27
#define GL_FIELD_LOWER_NV 0x9023
#define GL_FIELD_UPPER_NV 0x9022
#define GL_FILE_NAME_NV 0x9074
#define GL_FILL 0x1B02
#define GL_FILL_RECTANGLE_NV 0x933C
#define GL_FILTER 0x829A
#define GL_FIRST_TO_REST_NV 0x90AF
#define GL_FIRST_VERTEX_CONVENTION 0x8E4D
#define GL_FIRST_VERTEX_CONVENTION_EXT 0x8E4D
#define GL_FIXED 0x140C
#define GL_FIXED_ONLY 0x891D
#define GL_FIXED_ONLY_ARB 0x891D
#define GL_FLOAT 0x1406
#define GL_FLOAT16_MAT2_AMD 0x91C5
#define GL_FLOAT16_MAT2x3_AMD 0x91C8
#define GL_FLOAT16_MAT2x4_AMD 0x91C9
#define GL_FLOAT16_MAT3_AMD 0x91C6
#define GL_FLOAT16_MAT3x2_AMD 0x91CA
#define GL_FLOAT16_MAT3x4_AMD 0x91CB
#define GL_FLOAT16_MAT4_AMD 0x91C7
#define GL_FLOAT16_MAT4x2_AMD 0x91CC
#define GL_FLOAT16_MAT4x3_AMD 0x91CD
#define GL_FLOAT16_NV 0x8FF8
#define GL_FLOAT16_VEC2_NV 0x8FF9
#define GL_FLOAT16_VEC3_NV 0x8FFA
#define GL_FLOAT16_VEC4_NV 0x8FFB
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV 0x8DAD
#define GL_FLOAT_CLEAR_COLOR_VALUE_NV 0x888D
#define GL_FLOAT_MAT2 0x8B5A
#define GL_FLOAT_MAT2_ARB 0x8B5A
#define GL_FLOAT_MAT2x3 0x8B65
#define GL_FLOAT_MAT2x4 0x8B66
#define GL_FLOAT_MAT3 0x8B5B
#define GL_FLOAT_MAT3_ARB 0x8B5B
#define GL_FLOAT_MAT3x2 0x8B67
#define GL_FLOAT_MAT3x4 0x8B68
#define GL_FLOAT_MAT4 0x8B5C
#define GL_FLOAT_MAT4_ARB 0x8B5C
#define GL_FLOAT_MAT4x2 0x8B69
#define GL_FLOAT_MAT4x3 0x8B6A
#define GL_FLOAT_R16_NV 0x8884
#define GL_FLOAT_R32_NV 0x8885
#define GL_FLOAT_RG16_NV 0x8886
#define GL_FLOAT_RG32_NV 0x8887
#define GL_FLOAT_RGB16_NV 0x8888
#define GL_FLOAT_RGB32_NV 0x8889
#define GL_FLOAT_RGBA16_NV 0x888A
#define GL_FLOAT_RGBA32_NV 0x888B
#define GL_FLOAT_RGBA_MODE_NV 0x888E
#define GL_FLOAT_RGBA_NV 0x8883
#define GL_FLOAT_RGB_NV 0x8882
#define GL_FLOAT_RG_NV 0x8881
#define GL_FLOAT_R_NV 0x8880
#define GL_FLOAT_VEC2 0x8B50
#define GL_FLOAT_VEC2_ARB 0x8B50
#define GL_FLOAT_VEC3 0x8B51
#define GL_FLOAT_VEC3_ARB 0x8B51
#define GL_FLOAT_VEC4 0x8B52
#define GL_FLOAT_VEC4_ARB 0x8B52
#define GL_FOG 0x0B60
#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB 0x889D
#define GL_FOG_COORDINATE_ARRAY_EXT 0x8457
#define GL_FOG_COORDINATE_ARRAY_POINTER_EXT 0x8456
#define GL_FOG_COORDINATE_ARRAY_STRIDE_EXT 0x8455
#define GL_FOG_COORDINATE_ARRAY_TYPE_EXT 0x8454
#define GL_FOG_COORDINATE_EXT 0x8451
#define GL_FOG_COORDINATE_SOURCE_EXT 0x8450
#define GL_FOG_COORD_ARRAY_ADDRESS_NV 0x8F28
#define GL_FOG_COORD_ARRAY_LENGTH_NV 0x8F32
#define GL_FOG_DISTANCE_MODE_NV 0x855A
#define GL_FONT_ASCENDER_BIT_NV 0x00200000
#define GL_FONT_DESCENDER_BIT_NV 0x00400000
#define GL_FONT_GLYPHS_AVAILABLE_NV 0x9368
#define GL_FONT_HAS_KERNING_BIT_NV 0x10000000
#define GL_FONT_HEIGHT_BIT_NV 0x00800000
#define GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV 0x02000000
#define GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV 0x01000000
#define GL_FONT_NUM_GLYPH_INDICES_BIT_NV 0x20000000
#define GL_FONT_TARGET_UNAVAILABLE_NV 0x9369
#define GL_FONT_UNAVAILABLE_NV 0x936A
#define GL_FONT_UNDERLINE_POSITION_BIT_NV 0x04000000
#define GL_FONT_UNDERLINE_THICKNESS_BIT_NV 0x08000000
#define GL_FONT_UNINTELLIGIBLE_NV 0x936B
#define GL_FONT_UNITS_PER_EM_BIT_NV 0x00100000
#define GL_FONT_X_MAX_BOUNDS_BIT_NV 0x00040000
#define GL_FONT_X_MIN_BOUNDS_BIT_NV 0x00010000
#define GL_FONT_Y_MAX_BOUNDS_BIT_NV 0x00080000
#define GL_FONT_Y_MIN_BOUNDS_BIT_NV 0x00020000
#define GL_FORCE_BLUE_TO_ONE_NV 0x8860
#define GL_FRACTIONAL_EVEN 0x8E7C
#define GL_FRACTIONAL_ODD 0x8E7B
#define GL_FRAGMENT_COLOR_EXT 0x834C
#define GL_FRAGMENT_COVERAGE_COLOR_NV 0x92DE
#define GL_FRAGMENT_COVERAGE_TO_COLOR_NV 0x92DD
#define GL_FRAGMENT_DEPTH_EXT 0x8452
#define GL_FRAGMENT_INPUT_NV 0x936D
#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
#define GL_FRAGMENT_MATERIAL_EXT 0x8349
#define GL_FRAGMENT_NORMAL_EXT 0x834A
#define GL_FRAGMENT_PROGRAM_ARB 0x8804
#define GL_FRAGMENT_PROGRAM_BINDING_NV 0x8873
#define GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV 0x8E5D
#define GL_FRAGMENT_PROGRAM_NV 0x8870
#define GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV 0x8DA4
#define GL_FRAGMENT_SHADER 0x8B30
#define GL_FRAGMENT_SHADER_ARB 0x8B30
#define GL_FRAGMENT_SHADER_ATI 0x8920
#define GL_FRAGMENT_SHADER_BIT 0x00000002
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB 0x8B8B
#define GL_FRAGMENT_SHADER_INVOCATIONS 0x82F4
#define GL_FRAGMENT_SHADER_INVOCATIONS_ARB 0x82F4
#define GL_FRAGMENT_SUBROUTINE 0x92EC
#define GL_FRAGMENT_SUBROUTINE_UNIFORM 0x92F2
#define GL_FRAGMENT_TEXTURE 0x829F
#define GL_FRAMEBUFFER 0x8D40
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB 0x8DA7
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT 0x8DA7
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT 0x8CD4
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT 0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT 0x8CD4
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT 0x8CD2
#define GL_FRAMEBUFFER_BARRIER_BIT 0x00000400
#define GL_FRAMEBUFFER_BARRIER_BIT_EXT 0x00000400
#define GL_FRAMEBUFFER_BINDING 0x8CA6
#define GL_FRAMEBUFFER_BINDING_EXT 0x8CA6
#define GL_FRAMEBUFFER_BLEND 0x828B
#define GL_FRAMEBUFFER_COMPLETE 0x8CD5
#define GL_FRAMEBUFFER_COMPLETE_EXT 0x8CD5
#define GL_FRAMEBUFFER_DEFAULT 0x8218
#define GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS 0x9314
#define GL_FRAMEBUFFER_DEFAULT_HEIGHT 0x9311
#define GL_FRAMEBUFFER_DEFAULT_LAYERS 0x9312
#define GL_FRAMEBUFFER_DEFAULT_SAMPLES 0x9313
#define GL_FRAMEBUFFER_DEFAULT_WIDTH 0x9310
#define GL_FRAMEBUFFER_EXT 0x8D40
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT 0x8CD9
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT 0x8CDA
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB 0x8DA9
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT 0x8DA9
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB 0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT 0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT 0x8D56
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT 0x8CDC
#define GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB 0x9342
#define GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV 0x9342
#define GL_FRAMEBUFFER_RENDERABLE 0x8289
#define GL_FRAMEBUFFER_RENDERABLE_LAYERED 0x828A
#define GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB 0x9343
#define GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV 0x9343
#define GL_FRAMEBUFFER_SRGB 0x8DB9
#define GL_FRAMEBUFFER_SRGB_CAPABLE_EXT 0x8DBA
#define GL_FRAMEBUFFER_SRGB_EXT 0x8DB9
#define GL_FRAMEBUFFER_UNDEFINED 0x8219
#define GL_FRAMEBUFFER_UNSUPPORTED 0x8CDD
#define GL_FRAMEBUFFER_UNSUPPORTED_EXT 0x8CDD
#define GL_FRAME_NV 0x8E26
#define GL_FRONT 0x0404
#define GL_FRONT_AND_BACK 0x0408
#define GL_FRONT_FACE 0x0B46
#define GL_FRONT_FACE_COMMAND_NV 0x0012
#define GL_FRONT_LEFT 0x0400
#define GL_FRONT_RIGHT 0x0401
#define GL_FULL_RANGE_EXT 0x87E1
#define GL_FULL_SUPPORT 0x82B7
#define GL_FUNC_ADD 0x8006
#define GL_FUNC_ADD_EXT 0x8006
#define GL_FUNC_REVERSE_SUBTRACT 0x800B
#define GL_FUNC_REVERSE_SUBTRACT_EXT 0x800B
#define GL_FUNC_SUBTRACT 0x800A
#define GL_FUNC_SUBTRACT_EXT 0x800A
#define GL_GENERIC_ATTRIB_NV 0x8C7D
#define GL_GEOMETRY_INPUT_TYPE 0x8917
#define GL_GEOMETRY_INPUT_TYPE_ARB 0x8DDB
#define GL_GEOMETRY_INPUT_TYPE_EXT 0x8DDB
#define GL_GEOMETRY_OUTPUT_TYPE 0x8918
#define GL_GEOMETRY_OUTPUT_TYPE_ARB 0x8DDC
#define GL_GEOMETRY_OUTPUT_TYPE_EXT 0x8DDC
#define GL_GEOMETRY_PROGRAM_NV 0x8C26
#define GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV 0x8DA3
#define GL_GEOMETRY_SHADER 0x8DD9
#define GL_GEOMETRY_SHADER_ARB 0x8DD9
#define GL_GEOMETRY_SHADER_BIT 0x00000004
#define GL_GEOMETRY_SHADER_EXT 0x8DD9
#define GL_GEOMETRY_SHADER_INVOCATIONS 0x887F
#define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED 0x82F3
#define GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB 0x82F3
#define GL_GEOMETRY_SUBROUTINE 0x92EB
#define GL_GEOMETRY_SUBROUTINE_UNIFORM 0x92F1
#define GL_GEOMETRY_TEXTURE 0x829E
#define GL_GEOMETRY_VERTICES_OUT 0x8916
#define GL_GEOMETRY_VERTICES_OUT_ARB 0x8DDA
#define GL_GEOMETRY_VERTICES_OUT_EXT 0x8DDA
#define GL_GEQUAL 0x0206
#define GL_GET_TEXTURE_IMAGE_FORMAT 0x8291
#define GL_GET_TEXTURE_IMAGE_TYPE 0x8292
#define GL_GLYPH_HAS_KERNING_BIT_NV 0x100
#define GL_GLYPH_HEIGHT_BIT_NV 0x02
#define GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV 0x10
#define GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV 0x04
#define GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV 0x08
#define GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV 0x80
#define GL_GLYPH_VERTICAL_BEARING_X_BIT_NV 0x20
#define GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV 0x40
#define GL_GLYPH_WIDTH_BIT_NV 0x01
#define GL_GPU_ADDRESS_NV 0x8F34
#define GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX 0x9049
#define GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX 0x9047
#define GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX 0x904B
#define GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX 0x904A
#define GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX 0x9048
#define GL_GREATER 0x0204
#define GL_GREEN 0x1904
#define GL_GREEN_BIT_ATI 0x00000002
#define GL_GREEN_INTEGER 0x8D95
#define GL_GREEN_INTEGER_EXT 0x8D95
#define GL_GREEN_NV 0x1904
#define GL_GUILTY_CONTEXT_RESET 0x8253
#define GL_GUILTY_CONTEXT_RESET_ARB 0x8253
#define GL_HALF_APPLE 0x140B
#define GL_HALF_BIAS_NEGATE_NV 0x853B
#define GL_HALF_BIAS_NORMAL_NV 0x853A
#define GL_HALF_BIT_ATI 0x00000008
#define GL_HALF_FLOAT 0x140B
#define GL_HALF_FLOAT_ARB 0x140B
#define GL_HALF_FLOAT_NV 0x140B
#define GL_HANDLE_TYPE_D3D11_IMAGE_EXT 0x958B
#define GL_HANDLE_TYPE_D3D11_IMAGE_KMT_EXT 0x958C
#define GL_HANDLE_TYPE_D3D12_FENCE_EXT 0x9594
#define GL_HANDLE_TYPE_D3D12_RESOURCE_EXT 0x958A
#define GL_HANDLE_TYPE_D3D12_TILEPOOL_EXT 0x9589
#define GL_HANDLE_TYPE_OPAQUE_FD_EXT 0x9586
#define GL_HANDLE_TYPE_OPAQUE_WIN32_EXT 0x9587
#define GL_HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT 0x9588
#define GL_HARDLIGHT_KHR 0x929B
#define GL_HARDLIGHT_NV 0x929B
#define GL_HARDMIX_NV 0x92A9
#define GL_HIGH_FLOAT 0x8DF2
#define GL_HIGH_INT 0x8DF5
#define GL_HILO16_NV 0x86F8
#define GL_HILO8_NV 0x885E
#define GL_HILO_NV 0x86F4
#define GL_HISTOGRAM_ALPHA_SIZE_EXT 0x802B
#define GL_HISTOGRAM_BLUE_SIZE_EXT 0x802A
#define GL_HISTOGRAM_EXT 0x8024
#define GL_HISTOGRAM_FORMAT_EXT 0x8027
#define GL_HISTOGRAM_GREEN_SIZE_EXT 0x8029
#define GL_HISTOGRAM_LUMINANCE_SIZE_EXT 0x802C
#define GL_HISTOGRAM_RED_SIZE_EXT 0x8028
#define GL_HISTOGRAM_SINK_EXT 0x802D
#define GL_HISTOGRAM_WIDTH_EXT 0x8026
#define GL_HI_BIAS_NV 0x8714
#define GL_HI_SCALE_NV 0x870E
#define GL_HORIZONTAL_LINE_TO_NV 0x06
#define GL_HSL_COLOR_KHR 0x92AF
#define GL_HSL_COLOR_NV 0x92AF
#define GL_HSL_HUE_KHR 0x92AD
#define GL_HSL_HUE_NV 0x92AD
#define GL_HSL_LUMINOSITY_KHR 0x92B0
#define GL_HSL_LUMINOSITY_NV 0x92B0
#define GL_HSL_SATURATION_KHR 0x92AE
#define GL_HSL_SATURATION_NV 0x92AE
#define GL_IDENTITY_NV 0x862A
#define GL_IMAGE_1D 0x904C
#define GL_IMAGE_1D_ARRAY 0x9052
#define GL_IMAGE_1D_ARRAY_EXT 0x9052
#define GL_IMAGE_1D_EXT 0x904C
#define GL_IMAGE_2D 0x904D
#define GL_IMAGE_2D_ARRAY 0x9053
#define GL_IMAGE_2D_ARRAY_EXT 0x9053
#define GL_IMAGE_2D_EXT 0x904D
#define GL_IMAGE_2D_MULTISAMPLE 0x9055
#define GL_IMAGE_2D_MULTISAMPLE_ARRAY 0x9056
#define GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT 0x9056
#define GL_IMAGE_2D_MULTISAMPLE_EXT 0x9055
#define GL_IMAGE_2D_RECT 0x904F
#define GL_IMAGE_2D_RECT_EXT 0x904F
#define GL_IMAGE_3D 0x904E
#define GL_IMAGE_3D_EXT 0x904E
#define GL_IMAGE_BINDING_ACCESS 0x8F3E
#define GL_IMAGE_BINDING_ACCESS_EXT 0x8F3E
#define GL_IMAGE_BINDING_FORMAT 0x906E
#define GL_IMAGE_BINDING_FORMAT_EXT 0x906E
#define GL_IMAGE_BINDING_LAYER 0x8F3D
#define GL_IMAGE_BINDING_LAYERED 0x8F3C
#define GL_IMAGE_BINDING_LAYERED_EXT 0x8F3C
#define GL_IMAGE_BINDING_LAYER_EXT 0x8F3D
#define GL_IMAGE_BINDING_LEVEL 0x8F3B
#define GL_IMAGE_BINDING_LEVEL_EXT 0x8F3B
#define GL_IMAGE_BINDING_NAME 0x8F3A
#define GL_IMAGE_BINDING_NAME_EXT 0x8F3A
#define GL_IMAGE_BUFFER 0x9051
#define GL_IMAGE_BUFFER_EXT 0x9051
#define GL_IMAGE_CLASS_10_10_10_2 0x82C3
#define GL_IMAGE_CLASS_11_11_10 0x82C2
#define GL_IMAGE_CLASS_1_X_16 0x82BE
#define GL_IMAGE_CLASS_1_X_32 0x82BB
#define GL_IMAGE_CLASS_1_X_8 0x82C1
#define GL_IMAGE_CLASS_2_X_16 0x82BD
#define GL_IMAGE_CLASS_2_X_32 0x82BA
#define GL_IMAGE_CLASS_2_X_8 0x82C0
#define GL_IMAGE_CLASS_4_X_16 0x82BC
#define GL_IMAGE_CLASS_4_X_32 0x82B9
#define GL_IMAGE_CLASS_4_X_8 0x82BF
#define GL_IMAGE_COMPATIBILITY_CLASS 0x82A8
#define GL_IMAGE_CUBE 0x9050
#define GL_IMAGE_CUBE_EXT 0x9050
#define GL_IMAGE_CUBE_MAP_ARRAY 0x9054
#define GL_IMAGE_CUBE_MAP_ARRAY_EXT 0x9054
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS 0x90C9
#define GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE 0x90C8
#define GL_IMAGE_FORMAT_COMPATIBILITY_TYPE 0x90C7
#define GL_IMAGE_PIXEL_FORMAT 0x82A9
#define GL_IMAGE_PIXEL_TYPE 0x82AA
#define GL_IMAGE_TEXEL_SIZE 0x82A7
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#define GL_IMPLEMENTATION_COLOR_READ_TYPE 0x8B9A
#define GL_INCLUSIVE_EXT 0x8F10
#define GL_INCR 0x1E02
#define GL_INCR_WRAP 0x8507
#define GL_INCR_WRAP_EXT 0x8507
#define GL_INDEX_ARRAY_ADDRESS_NV 0x8F24
#define GL_INDEX_ARRAY_BUFFER_BINDING_ARB 0x8899
#define GL_INDEX_ARRAY_COUNT_EXT 0x8087
#define GL_INDEX_ARRAY_EXT 0x8077
#define GL_INDEX_ARRAY_LENGTH_NV 0x8F2E
#define GL_INDEX_ARRAY_POINTER_EXT 0x8091
#define GL_INDEX_ARRAY_STRIDE_EXT 0x8086
#define GL_INDEX_ARRAY_TYPE_EXT 0x8085
#define GL_INDEX_MATERIAL_EXT 0x81B8
#define GL_INDEX_MATERIAL_FACE_EXT 0x81BA
#define GL_INDEX_MATERIAL_PARAMETER_EXT 0x81B9
#define GL_INDEX_TEST_EXT 0x81B5
#define GL_INDEX_TEST_FUNC_EXT 0x81B6
#define GL_INDEX_TEST_REF_EXT 0x81B7
#define GL_INFO_LOG_LENGTH 0x8B84
#define GL_INNOCENT_CONTEXT_RESET 0x8254
#define GL_INNOCENT_CONTEXT_RESET_ARB 0x8254
#define GL_INT 0x1404
#define GL_INT16_NV 0x8FE4
#define GL_INT16_VEC2_NV 0x8FE5
#define GL_INT16_VEC3_NV 0x8FE6
#define GL_INT16_VEC4_NV 0x8FE7
#define GL_INT64_ARB 0x140E
#define GL_INT64_NV 0x140E
#define GL_INT64_VEC2_ARB 0x8FE9
#define GL_INT64_VEC2_NV 0x8FE9
#define GL_INT64_VEC3_ARB 0x8FEA
#define GL_INT64_VEC3_NV 0x8FEA
#define GL_INT64_VEC4_ARB 0x8FEB
#define GL_INT64_VEC4_NV 0x8FEB
#define GL_INT8_NV 0x8FE0
#define GL_INT8_VEC2_NV 0x8FE1
#define GL_INT8_VEC3_NV 0x8FE2
#define GL_INT8_VEC4_NV 0x8FE3
#define GL_INTENSITY12_EXT 0x804C
#define GL_INTENSITY16F_ARB 0x881D
#define GL_INTENSITY16I_EXT 0x8D8B
#define GL_INTENSITY16UI_EXT 0x8D79
#define GL_INTENSITY16_EXT 0x804D
#define GL_INTENSITY16_SNORM 0x901B
#define GL_INTENSITY32F_ARB 0x8817
#define GL_INTENSITY32I_EXT 0x8D85
#define GL_INTENSITY32UI_EXT 0x8D73
#define GL_INTENSITY4_EXT 0x804A
#define GL_INTENSITY8I_EXT 0x8D91
#define GL_INTENSITY8UI_EXT 0x8D7F
#define GL_INTENSITY8_EXT 0x804B
#define GL_INTENSITY8_SNORM 0x9017
#define GL_INTENSITY_EXT 0x8049
#define GL_INTENSITY_FLOAT16_APPLE 0x881D
#define GL_INTENSITY_FLOAT16_ATI 0x881D
#define GL_INTENSITY_FLOAT32_APPLE 0x8817
#define GL_INTENSITY_FLOAT32_ATI 0x8817
#define GL_INTENSITY_SNORM 0x9013
#define GL_INTERLEAVED_ATTRIBS 0x8C8C
#define GL_INTERLEAVED_ATTRIBS_EXT 0x8C8C
#define GL_INTERLEAVED_ATTRIBS_NV 0x8C8C
#define GL_INTERNALFORMAT_ALPHA_SIZE 0x8274
#define GL_INTERNALFORMAT_ALPHA_TYPE 0x827B
#define GL_INTERNALFORMAT_BLUE_SIZE 0x8273
#define GL_INTERNALFORMAT_BLUE_TYPE 0x827A
#define GL_INTERNALFORMAT_DEPTH_SIZE 0x8275
#define GL_INTERNALFORMAT_DEPTH_TYPE 0x827C
#define GL_INTERNALFORMAT_GREEN_SIZE 0x8272
#define GL_INTERNALFORMAT_GREEN_TYPE 0x8279
#define GL_INTERNALFORMAT_PREFERRED 0x8270
#define GL_INTERNALFORMAT_RED_SIZE 0x8271
#define GL_INTERNALFORMAT_RED_TYPE 0x8278
#define GL_INTERNALFORMAT_SHARED_SIZE 0x8277
#define GL_INTERNALFORMAT_STENCIL_SIZE 0x8276
#define GL_INTERNALFORMAT_STENCIL_TYPE 0x827D
#define GL_INTERNALFORMAT_SUPPORTED 0x826F
#define GL_INTERPOLATE_ARB 0x8575
#define GL_INTERPOLATE_EXT 0x8575
#define GL_INT_2_10_10_10_REV 0x8D9F
#define GL_INT_IMAGE_1D 0x9057
#define GL_INT_IMAGE_1D_ARRAY 0x905D
#define GL_INT_IMAGE_1D_ARRAY_EXT 0x905D
#define GL_INT_IMAGE_1D_EXT 0x9057
#define GL_INT_IMAGE_2D 0x9058
#define GL_INT_IMAGE_2D_ARRAY 0x905E
#define GL_INT_IMAGE_2D_ARRAY_EXT 0x905E
#define GL_INT_IMAGE_2D_EXT 0x9058
#define GL_INT_IMAGE_2D_MULTISAMPLE 0x9060
#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x9061
#define GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT 0x9061
#define GL_INT_IMAGE_2D_MULTISAMPLE_EXT 0x9060
#define GL_INT_IMAGE_2D_RECT 0x905A
#define GL_INT_IMAGE_2D_RECT_EXT 0x905A
#define GL_INT_IMAGE_3D 0x9059
#define GL_INT_IMAGE_3D_EXT 0x9059
#define GL_INT_IMAGE_BUFFER 0x905C
#define GL_INT_IMAGE_BUFFER_EXT 0x905C
#define GL_INT_IMAGE_CUBE 0x905B
#define GL_INT_IMAGE_CUBE_EXT 0x905B
#define GL_INT_IMAGE_CUBE_MAP_ARRAY 0x905F
#define GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT 0x905F
#define GL_INT_SAMPLER_1D 0x8DC9
#define GL_INT_SAMPLER_1D_ARRAY 0x8DCE
#define GL_INT_SAMPLER_1D_ARRAY_EXT 0x8DCE
#define GL_INT_SAMPLER_1D_EXT 0x8DC9
#define GL_INT_SAMPLER_2D 0x8DCA
#define GL_INT_SAMPLER_2D_ARRAY 0x8DCF
#define GL_INT_SAMPLER_2D_ARRAY_EXT 0x8DCF
#define GL_INT_SAMPLER_2D_EXT 0x8DCA
#define GL_INT_SAMPLER_2D_MULTISAMPLE 0x9109
#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
#define GL_INT_SAMPLER_2D_RECT 0x8DCD
#define GL_INT_SAMPLER_2D_RECT_EXT 0x8DCD
#define GL_INT_SAMPLER_3D 0x8DCB
#define GL_INT_SAMPLER_3D_EXT 0x8DCB
#define GL_INT_SAMPLER_BUFFER 0x8DD0
#define GL_INT_SAMPLER_BUFFER_AMD 0x9002
#define GL_INT_SAMPLER_BUFFER_EXT 0x8DD0
#define GL_INT_SAMPLER_CUBE 0x8DCC
#define GL_INT_SAMPLER_CUBE_EXT 0x8DCC
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY 0x900E
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900E
#define GL_INT_SAMPLER_RENDERBUFFER_NV 0x8E57
#define GL_INT_VEC2 0x8B53
#define GL_INT_VEC2_ARB 0x8B53
#define GL_INT_VEC3 0x8B54
#define GL_INT_VEC3_ARB 0x8B54
#define GL_INT_VEC4 0x8B55
#define GL_INT_VEC4_ARB 0x8B55
#define GL_INVALID_ENUM 0x0500
#define GL_INVALID_FRAMEBUFFER_OPERATION 0x0506
#define GL_INVALID_FRAMEBUFFER_OPERATION_EXT 0x0506
#define GL_INVALID_INDEX 0xFFFFFFFF
#define GL_INVALID_OPERATION 0x0502
#define GL_INVALID_VALUE 0x0501
#define GL_INVARIANT_DATATYPE_EXT 0x87EB
#define GL_INVARIANT_EXT 0x87C2
#define GL_INVARIANT_VALUE_EXT 0x87EA
#define GL_INVERSE_NV 0x862B
#define GL_INVERSE_TRANSPOSE_NV 0x862D
#define GL_INVERT 0x150A
#define GL_INVERT_OVG_NV 0x92B4
#define GL_INVERT_RGB_NV 0x92A3
#define GL_ISOLINES 0x8E7A
#define GL_IS_PER_PATCH 0x92E7
#define GL_IS_ROW_MAJOR 0x9300
#define GL_ITALIC_BIT_NV 0x02
#define GL_IUI_N3F_V2F_EXT 0x81AF
#define GL_IUI_N3F_V3F_EXT 0x81B0
#define GL_IUI_V2F_EXT 0x81AD
#define GL_IUI_V3F_EXT 0x81AE
#define GL_KEEP 0x1E00
#define GL_LARGE_CCW_ARC_TO_NV 0x16
#define GL_LARGE_CW_ARC_TO_NV 0x18
#define GL_LAST_VERTEX_CONVENTION 0x8E4E
#define GL_LAST_VERTEX_CONVENTION_EXT 0x8E4E
#define GL_LAST_VIDEO_CAPTURE_STATUS_NV 0x9027
#define GL_LAYER_NV 0x8DAA
#define GL_LAYER_PROVOKING_VERTEX 0x825E
#define GL_LAYOUT_COLOR_ATTACHMENT_EXT 0x958E
#define GL_LAYOUT_DEFAULT_INTEL 0
#define GL_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT 0x9531
#define GL_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT 0x9530
#define GL_LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT 0x958F
#define GL_LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT 0x9590
#define GL_LAYOUT_GENERAL_EXT 0x958D
#define GL_LAYOUT_LINEAR_CPU_CACHED_INTEL 2
#define GL_LAYOUT_LINEAR_INTEL 1
#define GL_LAYOUT_SHADER_READ_ONLY_EXT 0x9591
#define GL_LAYOUT_TRANSFER_DST_EXT 0x9593
#define GL_LAYOUT_TRANSFER_SRC_EXT 0x9592
#define GL_LEFT 0x0406
#define GL_LEQUAL 0x0203
#define GL_LERP_ATI 0x8969
#define GL_LESS 0x0201
#define GL_LGPU_SEPARATE_STORAGE_BIT_NVX 0x0800
#define GL_LIGHTEN_KHR 0x9298
#define GL_LIGHTEN_NV 0x9298
#define GL_LIGHT_MODEL_COLOR_CONTROL_EXT 0x81F8
#define GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE 0x85B0
#define GL_LINE 0x1B01
#define GL_LINEAR 0x2601
#define GL_LINEARBURN_NV 0x92A5
#define GL_LINEARDODGE_NV 0x92A4
#define GL_LINEARLIGHT_NV 0x92A7
#define GL_LINEAR_MIPMAP_LINEAR 0x2703
#define GL_LINEAR_MIPMAP_NEAREST 0x2701
#define GL_LINEAR_TILING_EXT 0x9585
#define GL_LINES 0x0001
#define GL_LINES_ADJACENCY 0x000A
#define GL_LINES_ADJACENCY_ARB 0x000A
#define GL_LINES_ADJACENCY_EXT 0x000A
#define GL_LINE_LOOP 0x0002
#define GL_LINE_SMOOTH 0x0B20
#define GL_LINE_SMOOTH_HINT 0x0C52
#define GL_LINE_STRIP 0x0003
#define GL_LINE_STRIP_ADJACENCY 0x000B
#define GL_LINE_STRIP_ADJACENCY_ARB 0x000B
#define GL_LINE_STRIP_ADJACENCY_EXT 0x000B
#define GL_LINE_TO_NV 0x04
#define GL_LINE_WIDTH 0x0B21
#define GL_LINE_WIDTH_COMMAND_NV 0x000D
#define GL_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_LINE_WIDTH_RANGE 0x0B22
#define GL_LINK_STATUS 0x8B82
#define GL_LOCAL_CONSTANT_DATATYPE_EXT 0x87ED
#define GL_LOCAL_CONSTANT_EXT 0x87C3
#define GL_LOCAL_CONSTANT_VALUE_EXT 0x87EC
#define GL_LOCAL_EXT 0x87C4
#define GL_LOCATION 0x930E
#define GL_LOCATION_COMPONENT 0x934A
#define GL_LOCATION_INDEX 0x930F
#define GL_LOGIC_OP_MODE 0x0BF0
#define GL_LOSE_CONTEXT_ON_RESET 0x8252
#define GL_LOSE_CONTEXT_ON_RESET_ARB 0x8252
#define GL_LOWER_LEFT 0x8CA1
#define GL_LOW_FLOAT 0x8DF0
#define GL_LOW_INT 0x8DF3
#define GL_LO_BIAS_NV 0x8715
#define GL_LO_SCALE_NV 0x870F
#define GL_LUID_SIZE_EXT 8
#define GL_LUMINANCE12_ALPHA12_EXT 0x8047
#define GL_LUMINANCE12_ALPHA4_EXT 0x8046
#define GL_LUMINANCE12_EXT 0x8041
#define GL_LUMINANCE16F_ARB 0x881E
#define GL_LUMINANCE16I_EXT 0x8D8C
#define GL_LUMINANCE16UI_EXT 0x8D7A
#define GL_LUMINANCE16_ALPHA16_EXT 0x8048
#define GL_LUMINANCE16_ALPHA16_SNORM 0x901A
#define GL_LUMINANCE16_EXT 0x8042
#define GL_LUMINANCE16_SNORM 0x9019
#define GL_LUMINANCE32F_ARB 0x8818
#define GL_LUMINANCE32I_EXT 0x8D86
#define GL_LUMINANCE32UI_EXT 0x8D74
#define GL_LUMINANCE4_ALPHA4_EXT 0x8043
#define GL_LUMINANCE4_EXT 0x803F
#define GL_LUMINANCE6_ALPHA2_EXT 0x8044
#define GL_LUMINANCE8I_EXT 0x8D92
#define GL_LUMINANCE8UI_EXT 0x8D80
#define GL_LUMINANCE8_ALPHA8_EXT 0x8045
#define GL_LUMINANCE8_ALPHA8_SNORM 0x9016
#define GL_LUMINANCE8_EXT 0x8040
#define GL_LUMINANCE8_SNORM 0x9015
#define GL_LUMINANCE_ALPHA16F_ARB 0x881F
#define GL_LUMINANCE_ALPHA16I_EXT 0x8D8D
#define GL_LUMINANCE_ALPHA16UI_EXT 0x8D7B
#define GL_LUMINANCE_ALPHA32F_ARB 0x8819
#define GL_LUMINANCE_ALPHA32I_EXT 0x8D87
#define GL_LUMINANCE_ALPHA32UI_EXT 0x8D75
#define GL_LUMINANCE_ALPHA8I_EXT 0x8D93
#define GL_LUMINANCE_ALPHA8UI_EXT 0x8D81
#define GL_LUMINANCE_ALPHA_FLOAT16_APPLE 0x881F
#define GL_LUMINANCE_ALPHA_FLOAT16_ATI 0x881F
#define GL_LUMINANCE_ALPHA_FLOAT32_APPLE 0x8819
#define GL_LUMINANCE_ALPHA_FLOAT32_ATI 0x8819
#define GL_LUMINANCE_ALPHA_INTEGER_EXT 0x8D9D
#define GL_LUMINANCE_ALPHA_SNORM 0x9012
#define GL_LUMINANCE_FLOAT16_APPLE 0x881E
#define GL_LUMINANCE_FLOAT16_ATI 0x881E
#define GL_LUMINANCE_FLOAT32_APPLE 0x8818
#define GL_LUMINANCE_FLOAT32_ATI 0x8818
#define GL_LUMINANCE_INTEGER_EXT 0x8D9C
#define GL_LUMINANCE_SNORM 0x9011
#define GL_MAD_ATI 0x8968
#define GL_MAGNITUDE_BIAS_NV 0x8718
#define GL_MAGNITUDE_SCALE_NV 0x8712
#define GL_MAJOR_VERSION 0x821B
#define GL_MANUAL_GENERATE_MIPMAP 0x8294
#define GL_MAP1_BINORMAL_EXT 0x8446
#define GL_MAP1_TANGENT_EXT 0x8444
#define GL_MAP1_VERTEX_ATTRIB0_4_NV 0x8660
#define GL_MAP1_VERTEX_ATTRIB10_4_NV 0x866A
#define GL_MAP1_VERTEX_ATTRIB11_4_NV 0x866B
#define GL_MAP1_VERTEX_ATTRIB12_4_NV 0x866C
#define GL_MAP1_VERTEX_ATTRIB13_4_NV 0x866D
#define GL_MAP1_VERTEX_ATTRIB14_4_NV 0x866E
#define GL_MAP1_VERTEX_ATTRIB15_4_NV 0x866F
#define GL_MAP1_VERTEX_ATTRIB1_4_NV 0x8661
#define GL_MAP1_VERTEX_ATTRIB2_4_NV 0x8662
#define GL_MAP1_VERTEX_ATTRIB3_4_NV 0x8663
#define GL_MAP1_VERTEX_ATTRIB4_4_NV 0x8664
#define GL_MAP1_VERTEX_ATTRIB5_4_NV 0x8665
#define GL_MAP1_VERTEX_ATTRIB6_4_NV 0x8666
#define GL_MAP1_VERTEX_ATTRIB7_4_NV 0x8667
#define GL_MAP1_VERTEX_ATTRIB8_4_NV 0x8668
#define GL_MAP1_VERTEX_ATTRIB9_4_NV 0x8669
#define GL_MAP2_BINORMAL_EXT 0x8447
#define GL_MAP2_TANGENT_EXT 0x8445
#define GL_MAP2_VERTEX_ATTRIB0_4_NV 0x8670
#define GL_MAP2_VERTEX_ATTRIB10_4_NV 0x867A
#define GL_MAP2_VERTEX_ATTRIB11_4_NV 0x867B
#define GL_MAP2_VERTEX_ATTRIB12_4_NV 0x867C
#define GL_MAP2_VERTEX_ATTRIB13_4_NV 0x867D
#define GL_MAP2_VERTEX_ATTRIB14_4_NV 0x867E
#define GL_MAP2_VERTEX_ATTRIB15_4_NV 0x867F
#define GL_MAP2_VERTEX_ATTRIB1_4_NV 0x8671
#define GL_MAP2_VERTEX_ATTRIB2_4_NV 0x8672
#define GL_MAP2_VERTEX_ATTRIB3_4_NV 0x8673
#define GL_MAP2_VERTEX_ATTRIB4_4_NV 0x8674
#define GL_MAP2_VERTEX_ATTRIB5_4_NV 0x8675
#define GL_MAP2_VERTEX_ATTRIB6_4_NV 0x8676
#define GL_MAP2_VERTEX_ATTRIB7_4_NV 0x8677
#define GL_MAP2_VERTEX_ATTRIB8_4_NV 0x8678
#define GL_MAP2_VERTEX_ATTRIB9_4_NV 0x8679
#define GL_MAP_ATTRIB_U_ORDER_NV 0x86C3
#define GL_MAP_ATTRIB_V_ORDER_NV 0x86C4
#define GL_MAP_COHERENT_BIT 0x0080
#define GL_MAP_FLUSH_EXPLICIT_BIT 0x0010
#define GL_MAP_INVALIDATE_BUFFER_BIT 0x0008
#define GL_MAP_INVALIDATE_RANGE_BIT 0x0004
#define GL_MAP_PERSISTENT_BIT 0x0040
#define GL_MAP_READ_BIT 0x0001
#define GL_MAP_TESSELLATION_NV 0x86C2
#define GL_MAP_UNSYNCHRONIZED_BIT 0x0020
#define GL_MAP_WRITE_BIT 0x0002
#define GL_MATRIX0_ARB 0x88C0
#define GL_MATRIX0_NV 0x8630
#define GL_MATRIX10_ARB 0x88CA
#define GL_MATRIX11_ARB 0x88CB
#define GL_MATRIX12_ARB 0x88CC
#define GL_MATRIX13_ARB 0x88CD
#define GL_MATRIX14_ARB 0x88CE
#define GL_MATRIX15_ARB 0x88CF
#define GL_MATRIX16_ARB 0x88D0
#define GL_MATRIX17_ARB 0x88D1
#define GL_MATRIX18_ARB 0x88D2
#define GL_MATRIX19_ARB 0x88D3
#define GL_MATRIX1_ARB 0x88C1
#define GL_MATRIX1_NV 0x8631
#define GL_MATRIX20_ARB 0x88D4
#define GL_MATRIX21_ARB 0x88D5
#define GL_MATRIX22_ARB 0x88D6
#define GL_MATRIX23_ARB 0x88D7
#define GL_MATRIX24_ARB 0x88D8
#define GL_MATRIX25_ARB 0x88D9
#define GL_MATRIX26_ARB 0x88DA
#define GL_MATRIX27_ARB 0x88DB
#define GL_MATRIX28_ARB 0x88DC
#define GL_MATRIX29_ARB 0x88DD
#define GL_MATRIX2_ARB 0x88C2
#define GL_MATRIX2_NV 0x8632
#define GL_MATRIX30_ARB 0x88DE
#define GL_MATRIX31_ARB 0x88DF
#define GL_MATRIX3_ARB 0x88C3
#define GL_MATRIX3_NV 0x8633
#define GL_MATRIX4_ARB 0x88C4
#define GL_MATRIX4_NV 0x8634
#define GL_MATRIX5_ARB 0x88C5
#define GL_MATRIX5_NV 0x8635
#define GL_MATRIX6_ARB 0x88C6
#define GL_MATRIX6_NV 0x8636
#define GL_MATRIX7_ARB 0x88C7
#define GL_MATRIX7_NV 0x8637
#define GL_MATRIX8_ARB 0x88C8
#define GL_MATRIX9_ARB 0x88C9
#define GL_MATRIX_EXT 0x87C0
#define GL_MATRIX_INDEX_ARRAY_ARB 0x8844
#define GL_MATRIX_INDEX_ARRAY_POINTER_ARB 0x8849
#define GL_MATRIX_INDEX_ARRAY_SIZE_ARB 0x8846
#define GL_MATRIX_INDEX_ARRAY_STRIDE_ARB 0x8848
#define GL_MATRIX_INDEX_ARRAY_TYPE_ARB 0x8847
#define GL_MATRIX_PALETTE_ARB 0x8840
#define GL_MATRIX_STRIDE 0x92FF
#define GL_MAX 0x8008
#define GL_MAX_3D_TEXTURE_SIZE 0x8073
#define GL_MAX_3D_TEXTURE_SIZE_EXT 0x8073
#define GL_MAX_ARRAY_TEXTURE_LAYERS 0x88FF
#define GL_MAX_ARRAY_TEXTURE_LAYERS_EXT 0x88FF
#define GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS 0x92DC
#define GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE 0x92D8
#define GL_MAX_BINDABLE_UNIFORM_SIZE_EXT 0x8DED
#define GL_MAX_CLIP_DISTANCES 0x0D32
#define GL_MAX_COLOR_ATTACHMENTS 0x8CDF
#define GL_MAX_COLOR_ATTACHMENTS_EXT 0x8CDF
#define GL_MAX_COLOR_TEXTURE_SAMPLES 0x910E
#define GL_MAX_COMBINED_ATOMIC_COUNTERS 0x92D7
#define GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS 0x92D1
#define GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES 0x82FA
#define GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 0x8266
#define GL_MAX_COMBINED_DIMENSIONS 0x8282
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 0x8A32
#define GL_MAX_COMBINED_IMAGE_UNIFORMS 0x90CF
#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS 0x8F39
#define GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT 0x8F39
#define GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES 0x8F39
#define GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS 0x90DC
#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E1E
#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E1F
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB 0x8B4D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS 0x8A2E
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_COMPUTE_ATOMIC_COUNTERS 0x8265
#define GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 0x8264
#define GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB 0x90EB
#define GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB 0x91BF
#define GL_MAX_COMPUTE_IMAGE_UNIFORMS 0x91BD
#define GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS 0x90DB
#define GL_MAX_COMPUTE_SHARED_MEMORY_SIZE 0x8262
#define GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS 0x91BC
#define GL_MAX_COMPUTE_UNIFORM_BLOCKS 0x91BB
#define GL_MAX_COMPUTE_UNIFORM_COMPONENTS 0x8263
#define GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB 0x9344
#define GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB 0x9345
#define GL_MAX_COMPUTE_WORK_GROUP_COUNT 0x91BE
#define GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS 0x90EB
#define GL_MAX_COMPUTE_WORK_GROUP_SIZE 0x91BF
#define GL_MAX_CONVOLUTION_HEIGHT_EXT 0x801B
#define GL_MAX_CONVOLUTION_WIDTH_EXT 0x801A
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB 0x851C
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT 0x851C
#define GL_MAX_CULL_DISTANCES 0x82F9
#define GL_MAX_DEBUG_GROUP_STACK_DEPTH 0x826C
#define GL_MAX_DEBUG_LOGGED_MESSAGES 0x9144
#define GL_MAX_DEBUG_LOGGED_MESSAGES_AMD 0x9144
#define GL_MAX_DEBUG_LOGGED_MESSAGES_ARB 0x9144
#define GL_MAX_DEBUG_MESSAGE_LENGTH 0x9143
#define GL_MAX_DEBUG_MESSAGE_LENGTH_AMD 0x9143
#define GL_MAX_DEBUG_MESSAGE_LENGTH_ARB 0x9143
#define GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV 0x90D1
#define GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV 0x90D0
#define GL_MAX_DEPTH 0x8280
#define GL_MAX_DEPTH_TEXTURE_SAMPLES 0x910F
#define GL_MAX_DRAW_BUFFERS 0x8824
#define GL_MAX_DRAW_BUFFERS_ARB 0x8824
#define GL_MAX_DRAW_BUFFERS_ATI 0x8824
#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS 0x88FC
#define GL_MAX_ELEMENTS_INDICES 0x80E9
#define GL_MAX_ELEMENTS_INDICES_EXT 0x80E9
#define GL_MAX_ELEMENTS_VERTICES 0x80E8
#define GL_MAX_ELEMENTS_VERTICES_EXT 0x80E8
#define GL_MAX_ELEMENT_INDEX 0x8D6B
#define GL_MAX_EXT 0x8008
#define GL_MAX_FRAGMENT_ATOMIC_COUNTERS 0x92D6
#define GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS 0x92D0
#define GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT 0x8DE3
#define GL_MAX_FRAGMENT_IMAGE_UNIFORMS 0x90CE
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS 0x9125
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV 0x8E5C
#define GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV 0x8868
#define GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS 0x90DA
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS 0x8A2D
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB 0x8B49
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS 0x8DFD
#define GL_MAX_FRAMEBUFFER_HEIGHT 0x9316
#define GL_MAX_FRAMEBUFFER_LAYERS 0x9317
#define GL_MAX_FRAMEBUFFER_SAMPLES 0x9318
#define GL_MAX_FRAMEBUFFER_WIDTH 0x9315
#define GL_MAX_GENERAL_COMBINERS_NV 0x854D
#define GL_MAX_GEOMETRY_ATOMIC_COUNTERS 0x92D5
#define GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS 0x92CF
#define GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT 0x8DE4
#define GL_MAX_GEOMETRY_IMAGE_UNIFORMS 0x90CD
#define GL_MAX_GEOMETRY_INPUT_COMPONENTS 0x9123
#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES 0x8DE0
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB 0x8DE0
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT 0x8DE0
#define GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV 0x8E5A
#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
#define GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS 0x90D7
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB 0x8C29
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT 0x8C29
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB 0x8DE1
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT 0x8DE1
#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS 0x8A2C
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB 0x8DDF
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT 0x8DDF
#define GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB 0x8DDD
#define GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT 0x8DDD
#define GL_MAX_HEIGHT 0x827F
#define GL_MAX_IMAGE_SAMPLES 0x906D
#define GL_MAX_IMAGE_SAMPLES_EXT 0x906D
#define GL_MAX_IMAGE_UNITS 0x8F38
#define GL_MAX_IMAGE_UNITS_EXT 0x8F38
#define GL_MAX_INTEGER_SAMPLES 0x9110
#define GL_MAX_LABEL_LENGTH 0x82E8
#define GL_MAX_LAYERS 0x8281
#define GL_MAX_LGPU_GPUS_NVX 0x92BA
#define GL_MAX_MAP_TESSELLATION_NV 0x86D6
#define GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB 0x8841
#define GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV 0x8E11
#define GL_MAX_NAME_LENGTH 0x92F6
#define GL_MAX_NUM_ACTIVE_VARIABLES 0x92F7
#define GL_MAX_NUM_COMPATIBLE_SUBROUTINES 0x92F8
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CA
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT 0x87CD
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT 0x87CE
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87CC
#define GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT 0x87CB
#define GL_MAX_PALETTE_MATRICES_ARB 0x8842
#define GL_MAX_PATCH_VERTICES 0x8E7D
#define GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8337
#define GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F1
#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B1
#define GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB 0x880B
#define GL_MAX_PROGRAM_ATTRIBS_ARB 0x88AD
#define GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV 0x8908
#define GL_MAX_PROGRAM_CALL_DEPTH_NV 0x88F5
#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB 0x88B5
#define GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV 0x88F4
#define GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV 0x8DA5
#define GL_MAX_PROGRAM_GENERIC_RESULTS_NV 0x8DA6
#define GL_MAX_PROGRAM_IF_DEPTH_NV 0x88F6
#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB 0x88A1
#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB 0x88B4
#define GL_MAX_PROGRAM_LOOP_COUNT_NV 0x88F8
#define GL_MAX_PROGRAM_LOOP_DEPTH_NV 0x88F7
#define GL_MAX_PROGRAM_MATRICES_ARB 0x862F
#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB 0x862E
#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B3
#define GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x880E
#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AF
#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A3
#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AB
#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A7
#define GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x8810
#define GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x880F
#define GL_MAX_PROGRAM_OUTPUT_VERTICES_NV 0x8C27
#define GL_MAX_PROGRAM_PARAMETERS_ARB 0x88A9
#define GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV 0x8DA0
#define GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV 0x8DA1
#define GL_MAX_PROGRAM_PATCH_ATTRIBS_NV 0x86D8
#define GL_MAX_PROGRAM_RESULT_COMPONENTS_NV 0x8909
#define GL_MAX_PROGRAM_SUBROUTINE_NUM_NV 0x8F45
#define GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV 0x8F44
#define GL_MAX_PROGRAM_TEMPORARIES_ARB 0x88A5
#define GL_MAX_PROGRAM_TEXEL_OFFSET 0x8905
#define GL_MAX_PROGRAM_TEXEL_OFFSET_EXT 0x8905
#define GL_MAX_PROGRAM_TEXEL_OFFSET_NV 0x8905
#define GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB 0x8F9F
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5F
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV 0x8E5F
#define GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB 0x880D
#define GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB 0x880C
#define GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV 0x8C28
#define GL_MAX_RASTER_SAMPLES_EXT 0x9329
#define GL_MAX_RATIONAL_EVAL_ORDER_NV 0x86D7
#define GL_MAX_RECTANGLE_TEXTURE_SIZE 0x84F8
#define GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB 0x84F8
#define GL_MAX_RECTANGLE_TEXTURE_SIZE_NV 0x84F8
#define GL_MAX_RENDERBUFFER_SIZE 0x84E8
#define GL_MAX_RENDERBUFFER_SIZE_EXT 0x84E8
#define GL_MAX_SAMPLES 0x8D57
#define GL_MAX_SAMPLES_EXT 0x8D57
#define GL_MAX_SAMPLE_MASK_WORDS 0x8E59
#define GL_MAX_SAMPLE_MASK_WORDS_NV 0x8E59
#define GL_MAX_SERVER_WAIT_TIMEOUT 0x9111
#define GL_MAX_SHADER_BUFFER_ADDRESS_NV 0x8F35
#define GL_MAX_SHADER_COMPILER_THREADS_ARB 0x91B0
#define GL_MAX_SHADER_COMPILER_THREADS_KHR 0x91B0
#define GL_MAX_SHADER_STORAGE_BLOCK_SIZE 0x90DE
#define GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS 0x90DD
#define GL_MAX_SHININESS_NV 0x8504
#define GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD 0x9199
#define GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB 0x9199
#define GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS 0x919A
#define GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB 0x919A
#define GL_MAX_SPARSE_TEXTURE_SIZE_AMD 0x9198
#define GL_MAX_SPARSE_TEXTURE_SIZE_ARB 0x9198
#define GL_MAX_SPOT_EXPONENT_NV 0x8505
#define GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV 0x9349
#define GL_MAX_SUBROUTINES 0x8DE7
#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS 0x8DE8
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS 0x92D3
#define GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS 0x92CD
#define GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS 0x90CB
#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS 0x886C
#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS 0x8E83
#define GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS 0x90D8
#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 0x8E81
#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 0x8E85
#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS 0x8E89
#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E7F
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS 0x92D4
#define GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS 0x92CE
#define GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS 0x90CC
#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS 0x886D
#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 0x8E86
#define GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS 0x90D9
#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 0x8E82
#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS 0x8E8A
#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E80
#define GL_MAX_TESS_GEN_LEVEL 0x8E7E
#define GL_MAX_TESS_PATCH_COMPONENTS 0x8E84
#define GL_MAX_TEXTURE_BUFFER_SIZE 0x8C2B
#define GL_MAX_TEXTURE_BUFFER_SIZE_ARB 0x8C2B
#define GL_MAX_TEXTURE_BUFFER_SIZE_EXT 0x8C2B
#define GL_MAX_TEXTURE_COORDS_ARB 0x8871
#define GL_MAX_TEXTURE_COORDS_NV 0x8871
#define GL_MAX_TEXTURE_IMAGE_UNITS 0x8872
#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB 0x8872
#define GL_MAX_TEXTURE_IMAGE_UNITS_NV 0x8872
#define GL_MAX_TEXTURE_LOD_BIAS 0x84FD
#define GL_MAX_TEXTURE_LOD_BIAS_EXT 0x84FD
#define GL_MAX_TEXTURE_MAX_ANISOTROPY 0x84FF
#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
#define GL_MAX_TEXTURE_SIZE 0x0D33
#define GL_MAX_TEXTURE_UNITS_ARB 0x84E2
#define GL_MAX_TRACK_MATRICES_NV 0x862F
#define GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV 0x862E
#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS 0x8E70
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT 0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV 0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT 0x8C80
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV 0x8C80
#define GL_MAX_UNIFORM_BLOCK_SIZE 0x8A30
#define GL_MAX_UNIFORM_BUFFER_BINDINGS 0x8A2F
#define GL_MAX_UNIFORM_LOCATIONS 0x826E
#define GL_MAX_VARYING_COMPONENTS 0x8B4B
#define GL_MAX_VARYING_COMPONENTS_EXT 0x8B4B
#define GL_MAX_VARYING_FLOATS 0x8B4B
#define GL_MAX_VARYING_FLOATS_ARB 0x8B4B
#define GL_MAX_VARYING_VECTORS 0x8DFC
#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV 0x8520
#define GL_MAX_VERTEX_ATOMIC_COUNTERS 0x92D2
#define GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS 0x92CC
#define GL_MAX_VERTEX_ATTRIBS 0x8869
#define GL_MAX_VERTEX_ATTRIBS_ARB 0x8869
#define GL_MAX_VERTEX_ATTRIB_BINDINGS 0x82DA
#define GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D9
#define GL_MAX_VERTEX_ATTRIB_STRIDE 0x82E5
#define GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT 0x8DE2
#define GL_MAX_VERTEX_IMAGE_UNIFORMS 0x90CA
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS 0x9122
#define GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87C5
#define GL_MAX_VERTEX_SHADER_INVARIANTS_EXT 0x87C7
#define GL_MAX_VERTEX_SHADER_LOCALS_EXT 0x87C9
#define GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87C8
#define GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS 0x90D6
#define GL_MAX_VERTEX_SHADER_VARIANTS_EXT 0x87C6
#define GL_MAX_VERTEX_STREAMS 0x8E71
#define GL_MAX_VERTEX_STREAMS_ATI 0x876B
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB 0x8B4C
#define GL_MAX_VERTEX_UNIFORM_BLOCKS 0x8A2B
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS 0x8B4A
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB 0x8B4A
#define GL_MAX_VERTEX_UNIFORM_VECTORS 0x8DFB
#define GL_MAX_VERTEX_UNITS_ARB 0x86A4
#define GL_MAX_VERTEX_VARYING_COMPONENTS_ARB 0x8DDE
#define GL_MAX_VERTEX_VARYING_COMPONENTS_EXT 0x8DDE
#define GL_MAX_VIEWPORTS 0x825B
#define GL_MAX_VIEWPORT_DIMS 0x0D3A
#define GL_MAX_WIDTH 0x827E
#define GL_MAX_WINDOW_RECTANGLES_EXT 0x8F14
#define GL_MEDIUM_FLOAT 0x8DF1
#define GL_MEDIUM_INT 0x8DF4
#define GL_MIN 0x8007
#define GL_MINMAX_EXT 0x802E
#define GL_MINMAX_FORMAT_EXT 0x802F
#define GL_MINMAX_SINK_EXT 0x8030
#define GL_MINOR_VERSION 0x821C
#define GL_MINUS_CLAMPED_NV 0x92B3
#define GL_MINUS_NV 0x929F
#define GL_MIN_EXT 0x8007
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV 0x8E5B
#define GL_MIN_LOD_WARNING_AMD 0x919C
#define GL_MIN_MAP_BUFFER_ALIGNMENT 0x90BC
#define GL_MIN_PROGRAM_TEXEL_OFFSET 0x8904
#define GL_MIN_PROGRAM_TEXEL_OFFSET_EXT 0x8904
#define GL_MIN_PROGRAM_TEXEL_OFFSET_NV 0x8904
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5E
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV 0x8E5E
#define GL_MIN_SAMPLE_SHADING_VALUE 0x8C37
#define GL_MIN_SAMPLE_SHADING_VALUE_ARB 0x8C37
#define GL_MIN_SPARSE_LEVEL_AMD 0x919B
#define GL_MIPMAP 0x8293
#define GL_MIRRORED_REPEAT 0x8370
#define GL_MIRRORED_REPEAT_ARB 0x8370
#define GL_MIRROR_CLAMP_ATI 0x8742
#define GL_MIRROR_CLAMP_EXT 0x8742
#define GL_MIRROR_CLAMP_TO_BORDER_EXT 0x8912
#define GL_MIRROR_CLAMP_TO_EDGE 0x8743
#define GL_MIRROR_CLAMP_TO_EDGE_ATI 0x8743
#define GL_MIRROR_CLAMP_TO_EDGE_EXT 0x8743
#define GL_MITER_REVERT_NV 0x90A7
#define GL_MITER_TRUNCATE_NV 0x90A8
#define GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV 0x932F
#define GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV 0x9330
#define GL_MODELVIEW0_ARB 0x1700
#define GL_MODELVIEW0_EXT 0x1700
#define GL_MODELVIEW0_MATRIX_EXT 0x0BA6
#define GL_MODELVIEW0_STACK_DEPTH_EXT 0x0BA3
#define GL_MODELVIEW10_ARB 0x872A
#define GL_MODELVIEW11_ARB 0x872B
#define GL_MODELVIEW12_ARB 0x872C
#define GL_MODELVIEW13_ARB 0x872D
#define GL_MODELVIEW14_ARB 0x872E
#define GL_MODELVIEW15_ARB 0x872F
#define GL_MODELVIEW16_ARB 0x8730
#define GL_MODELVIEW17_ARB 0x8731
#define GL_MODELVIEW18_ARB 0x8732
#define GL_MODELVIEW19_ARB 0x8733
#define GL_MODELVIEW1_ARB 0x850A
#define GL_MODELVIEW1_EXT 0x850A
#define GL_MODELVIEW1_MATRIX_EXT 0x8506
#define GL_MODELVIEW1_STACK_DEPTH_EXT 0x8502
#define GL_MODELVIEW20_ARB 0x8734
#define GL_MODELVIEW21_ARB 0x8735
#define GL_MODELVIEW22_ARB 0x8736
#define GL_MODELVIEW23_ARB 0x8737
#define GL_MODELVIEW24_ARB 0x8738
#define GL_MODELVIEW25_ARB 0x8739
#define GL_MODELVIEW26_ARB 0x873A
#define GL_MODELVIEW27_ARB 0x873B
#define GL_MODELVIEW28_ARB 0x873C
#define GL_MODELVIEW29_ARB 0x873D
#define GL_MODELVIEW2_ARB 0x8722
#define GL_MODELVIEW30_ARB 0x873E
#define GL_MODELVIEW31_ARB 0x873F
#define GL_MODELVIEW3_ARB 0x8723
#define GL_MODELVIEW4_ARB 0x8724
#define GL_MODELVIEW5_ARB 0x8725
#define GL_MODELVIEW6_ARB 0x8726
#define GL_MODELVIEW7_ARB 0x8727
#define GL_MODELVIEW8_ARB 0x8728
#define GL_MODELVIEW9_ARB 0x8729
#define GL_MODELVIEW_PROJECTION_NV 0x8629
#define GL_MODULATE_ADD_ATI 0x8744
#define GL_MODULATE_SIGNED_ADD_ATI 0x8745
#define GL_MODULATE_SUBTRACT_ATI 0x8746
#define GL_MOVE_TO_CONTINUES_NV 0x90B6
#define GL_MOVE_TO_NV 0x02
#define GL_MOVE_TO_RESETS_NV 0x90B5
#define GL_MOV_ATI 0x8961
#define GL_MULTICAST_GPUS_NV 0x92BA
#define GL_MULTICAST_PROGRAMMABLE_SAMPLE_LOCATION_NV 0x9549
#define GL_MULTIPLY_KHR 0x9294
#define GL_MULTIPLY_NV 0x9294
#define GL_MULTISAMPLE 0x809D
#define GL_MULTISAMPLES_NV 0x9371
#define GL_MULTISAMPLE_ARB 0x809D
#define GL_MULTISAMPLE_BIT_ARB 0x20000000
#define GL_MULTISAMPLE_BIT_EXT 0x20000000
#define GL_MULTISAMPLE_COVERAGE_MODES_NV 0x8E12
#define GL_MULTISAMPLE_EXT 0x809D
#define GL_MULTISAMPLE_FILTER_HINT_NV 0x8534
#define GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB 0x9382
#define GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB 0x9381
#define GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT 0x932B
#define GL_MUL_ATI 0x8964
#define GL_MVP_MATRIX_EXT 0x87E3
#define GL_NAMED_STRING_LENGTH_ARB 0x8DE9
#define GL_NAMED_STRING_TYPE_ARB 0x8DEA
#define GL_NAME_LENGTH 0x92F9
#define GL_NAND 0x150E
#define GL_NEAREST 0x2600
#define GL_NEAREST_MIPMAP_LINEAR 0x2702
#define GL_NEAREST_MIPMAP_NEAREST 0x2700
#define GL_NEGATE_BIT_ATI 0x00000004
#define GL_NEGATIVE_ONE_EXT 0x87DF
#define GL_NEGATIVE_ONE_TO_ONE 0x935E
#define GL_NEGATIVE_W_EXT 0x87DC
#define GL_NEGATIVE_X_EXT 0x87D9
#define GL_NEGATIVE_Y_EXT 0x87DA
#define GL_NEGATIVE_Z_EXT 0x87DB
#define GL_NEVER 0x0200
#define GL_NEXT_BUFFER_NV -2
#define GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV 0x9025
#define GL_NICEST 0x1102
#define GL_NONE 0
#define GL_NOOP 0x1505
#define GL_NOP_COMMAND_NV 0x0001
#define GL_NOR 0x1508
#define GL_NORMALIZED_RANGE_EXT 0x87E0
#define GL_NORMAL_ARRAY_ADDRESS_NV 0x8F22
#define GL_NORMAL_ARRAY_BUFFER_BINDING_ARB 0x8897
#define GL_NORMAL_ARRAY_COUNT_EXT 0x8080
#define GL_NORMAL_ARRAY_EXT 0x8075
#define GL_NORMAL_ARRAY_LENGTH_NV 0x8F2C
#define GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL 0x83F6
#define GL_NORMAL_ARRAY_POINTER_EXT 0x808F
#define GL_NORMAL_ARRAY_STRIDE_EXT 0x807F
#define GL_NORMAL_ARRAY_TYPE_EXT 0x807E
#define GL_NORMAL_MAP_ARB 0x8511
#define GL_NORMAL_MAP_EXT 0x8511
#define GL_NORMAL_MAP_NV 0x8511
#define GL_NOTEQUAL 0x0205
#define GL_NO_ERROR 0
#define GL_NO_RESET_NOTIFICATION 0x8261
#define GL_NO_RESET_NOTIFICATION_ARB 0x8261
#define GL_NUM_ACTIVE_VARIABLES 0x9304
#define GL_NUM_COMPATIBLE_SUBROUTINES 0x8E4A
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A2
#define GL_NUM_DEVICE_UUIDS_EXT 0x9596
#define GL_NUM_EXTENSIONS 0x821D
#define GL_NUM_FILL_STREAMS_NV 0x8E29
#define GL_NUM_FRAGMENT_CONSTANTS_ATI 0x896F
#define GL_NUM_FRAGMENT_REGISTERS_ATI 0x896E
#define GL_NUM_GENERAL_COMBINERS_NV 0x854E
#define GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI 0x8973
#define GL_NUM_INSTRUCTIONS_PER_PASS_ATI 0x8971
#define GL_NUM_INSTRUCTIONS_TOTAL_ATI 0x8972
#define GL_NUM_LOOPBACK_COMPONENTS_ATI 0x8974
#define GL_NUM_PASSES_ATI 0x8970
#define GL_NUM_PROGRAM_BINARY_FORMATS 0x87FE
#define GL_NUM_SAMPLE_COUNTS 0x9380
#define GL_NUM_SHADER_BINARY_FORMATS 0x8DF9
#define GL_NUM_SHADING_LANGUAGE_VERSIONS 0x82E9
#define GL_NUM_SPARSE_LEVELS_ARB 0x91AA
#define GL_NUM_SPIR_V_EXTENSIONS 0x9554
#define GL_NUM_TILING_TYPES_EXT 0x9582
#define GL_NUM_VIDEO_CAPTURE_STREAMS_NV 0x9024
#define GL_NUM_VIRTUAL_PAGE_SIZES_ARB 0x91A8
#define GL_NUM_WINDOW_RECTANGLES_EXT 0x8F15
#define GL_OBJECT_ACTIVE_ATTRIBUTES_ARB 0x8B89
#define GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB 0x8B8A
#define GL_OBJECT_ACTIVE_UNIFORMS_ARB 0x8B86
#define GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB 0x8B87
#define GL_OBJECT_ATTACHED_OBJECTS_ARB 0x8B85
#define GL_OBJECT_BUFFER_SIZE_ATI 0x8764
#define GL_OBJECT_BUFFER_USAGE_ATI 0x8765
#define GL_OBJECT_COMPILE_STATUS_ARB 0x8B81
#define GL_OBJECT_DELETE_STATUS_ARB 0x8B80
#define GL_OBJECT_INFO_LOG_LENGTH_ARB 0x8B84
#define GL_OBJECT_LINK_STATUS_ARB 0x8B82
#define GL_OBJECT_SHADER_SOURCE_LENGTH_ARB 0x8B88
#define GL_OBJECT_SUBTYPE_ARB 0x8B4F
#define GL_OBJECT_TYPE 0x9112
#define GL_OBJECT_TYPE_ARB 0x8B4E
#define GL_OBJECT_VALIDATE_STATUS_ARB 0x8B83
#define GL_OCCLUSION_QUERY_EVENT_MASK_AMD 0x874F
#define GL_OFFSET 0x92FC
#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV 0x8856
#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8857
#define GL_OFFSET_HILO_TEXTURE_2D_NV 0x8854
#define GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV 0x8855
#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV 0x8850
#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV 0x8851
#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8852
#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV 0x8853
#define GL_OFFSET_TEXTURE_2D_BIAS_NV 0x86E3
#define GL_OFFSET_TEXTURE_2D_MATRIX_NV 0x86E1
#define GL_OFFSET_TEXTURE_2D_NV 0x86E8
#define GL_OFFSET_TEXTURE_2D_SCALE_NV 0x86E2
#define GL_OFFSET_TEXTURE_BIAS_NV 0x86E3
#define GL_OFFSET_TEXTURE_MATRIX_NV 0x86E1
#define GL_OFFSET_TEXTURE_RECTANGLE_NV 0x864C
#define GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV 0x864D
#define GL_OFFSET_TEXTURE_SCALE_NV 0x86E2
#define GL_ONE 1
#define GL_ONE_EXT 0x87DE
#define GL_ONE_MINUS_CONSTANT_ALPHA 0x8004
#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT 0x8004
#define GL_ONE_MINUS_CONSTANT_COLOR 0x8002
#define GL_ONE_MINUS_CONSTANT_COLOR_EXT 0x8002
#define GL_ONE_MINUS_DST_ALPHA 0x0305
#define GL_ONE_MINUS_DST_COLOR 0x0307
#define GL_ONE_MINUS_SRC1_ALPHA 0x88FB
#define GL_ONE_MINUS_SRC1_COLOR 0x88FA
#define GL_ONE_MINUS_SRC_ALPHA 0x0303
#define GL_ONE_MINUS_SRC_COLOR 0x0301
#define GL_OPERAND0_ALPHA_ARB 0x8598
#define GL_OPERAND0_ALPHA_EXT 0x8598
#define GL_OPERAND0_RGB_ARB 0x8590
#define GL_OPERAND0_RGB_EXT 0x8590
#define GL_OPERAND1_ALPHA_ARB 0x8599
#define GL_OPERAND1_ALPHA_EXT 0x8599
#define GL_OPERAND1_RGB_ARB 0x8591
#define GL_OPERAND1_RGB_EXT 0x8591
#define GL_OPERAND2_ALPHA_ARB 0x859A
#define GL_OPERAND2_ALPHA_EXT 0x859A
#define GL_OPERAND2_RGB_ARB 0x8592
#define GL_OPERAND2_RGB_EXT 0x8592
#define GL_OPERAND3_ALPHA_NV 0x859B
#define GL_OPERAND3_RGB_NV 0x8593
#define GL_OPTIMAL_TILING_EXT 0x9584
#define GL_OP_ADD_EXT 0x8787
#define GL_OP_CLAMP_EXT 0x878E
#define GL_OP_CROSS_PRODUCT_EXT 0x8797
#define GL_OP_DOT3_EXT 0x8784
#define GL_OP_DOT4_EXT 0x8785
#define GL_OP_EXP_BASE_2_EXT 0x8791
#define GL_OP_FLOOR_EXT 0x878F
#define GL_OP_FRAC_EXT 0x8789
#define GL_OP_INDEX_EXT 0x8782
#define GL_OP_LOG_BASE_2_EXT 0x8792
#define GL_OP_MADD_EXT 0x8788
#define GL_OP_MAX_EXT 0x878A
#define GL_OP_MIN_EXT 0x878B
#define GL_OP_MOV_EXT 0x8799
#define GL_OP_MULTIPLY_MATRIX_EXT 0x8798
#define GL_OP_MUL_EXT 0x8786
#define GL_OP_NEGATE_EXT 0x8783
#define GL_OP_POWER_EXT 0x8793
#define GL_OP_RECIP_EXT 0x8794
#define GL_OP_RECIP_SQRT_EXT 0x8795
#define GL_OP_ROUND_EXT 0x8790
#define GL_OP_SET_GE_EXT 0x878C
#define GL_OP_SET_LT_EXT 0x878D
#define GL_OP_SUB_EXT 0x8796
#define GL_OR 0x1507
#define GL_OR_INVERTED 0x150D
#define GL_OR_REVERSE 0x150B
#define GL_OUTPUT_COLOR0_EXT 0x879B
#define GL_OUTPUT_COLOR1_EXT 0x879C
#define GL_OUTPUT_FOG_EXT 0x87BD
#define GL_OUTPUT_TEXTURE_COORD0_EXT 0x879D
#define GL_OUTPUT_TEXTURE_COORD10_EXT 0x87A7
#define GL_OUTPUT_TEXTURE_COORD11_EXT 0x87A8
#define GL_OUTPUT_TEXTURE_COORD12_EXT 0x87A9
#define GL_OUTPUT_TEXTURE_COORD13_EXT 0x87AA
#define GL_OUTPUT_TEXTURE_COORD14_EXT 0x87AB
#define GL_OUTPUT_TEXTURE_COORD15_EXT 0x87AC
#define GL_OUTPUT_TEXTURE_COORD16_EXT 0x87AD
#define GL_OUTPUT_TEXTURE_COORD17_EXT 0x87AE
#define GL_OUTPUT_TEXTURE_COORD18_EXT 0x87AF
#define GL_OUTPUT_TEXTURE_COORD19_EXT 0x87B0
#define GL_OUTPUT_TEXTURE_COORD1_EXT 0x879E
#define GL_OUTPUT_TEXTURE_COORD20_EXT 0x87B1
#define GL_OUTPUT_TEXTURE_COORD21_EXT 0x87B2
#define GL_OUTPUT_TEXTURE_COORD22_EXT 0x87B3
#define GL_OUTPUT_TEXTURE_COORD23_EXT 0x87B4
#define GL_OUTPUT_TEXTURE_COORD24_EXT 0x87B5
#define GL_OUTPUT_TEXTURE_COORD25_EXT 0x87B6
#define GL_OUTPUT_TEXTURE_COORD26_EXT 0x87B7
#define GL_OUTPUT_TEXTURE_COORD27_EXT 0x87B8
#define GL_OUTPUT_TEXTURE_COORD28_EXT 0x87B9
#define GL_OUTPUT_TEXTURE_COORD29_EXT 0x87BA
#define GL_OUTPUT_TEXTURE_COORD2_EXT 0x879F
#define GL_OUTPUT_TEXTURE_COORD30_EXT 0x87BB
#define GL_OUTPUT_TEXTURE_COORD31_EXT 0x87BC
#define GL_OUTPUT_TEXTURE_COORD3_EXT 0x87A0
#define GL_OUTPUT_TEXTURE_COORD4_EXT 0x87A1
#define GL_OUTPUT_TEXTURE_COORD5_EXT 0x87A2
#define GL_OUTPUT_TEXTURE_COORD6_EXT 0x87A3
#define GL_OUTPUT_TEXTURE_COORD7_EXT 0x87A4
#define GL_OUTPUT_TEXTURE_COORD8_EXT 0x87A5
#define GL_OUTPUT_TEXTURE_COORD9_EXT 0x87A6
#define GL_OUTPUT_VERTEX_EXT 0x879A
#define GL_OUT_OF_MEMORY 0x0505
#define GL_OVERLAY_KHR 0x9296
#define GL_OVERLAY_NV 0x9296
#define GL_PACK_ALIGNMENT 0x0D05
#define GL_PACK_CMYK_HINT_EXT 0x800E
#define GL_PACK_COMPRESSED_BLOCK_DEPTH 0x912D
#define GL_PACK_COMPRESSED_BLOCK_HEIGHT 0x912C
#define GL_PACK_COMPRESSED_BLOCK_SIZE 0x912E
#define GL_PACK_COMPRESSED_BLOCK_WIDTH 0x912B
#define GL_PACK_IMAGE_HEIGHT 0x806C
#define GL_PACK_IMAGE_HEIGHT_EXT 0x806C
#define GL_PACK_INVERT_MESA 0x8758
#define GL_PACK_LSB_FIRST 0x0D01
#define GL_PACK_ROW_BYTES_APPLE 0x8A15
#define GL_PACK_ROW_LENGTH 0x0D02
#define GL_PACK_SKIP_IMAGES 0x806B
#define GL_PACK_SKIP_IMAGES_EXT 0x806B
#define GL_PACK_SKIP_PIXELS 0x0D04
#define GL_PACK_SKIP_ROWS 0x0D03
#define GL_PACK_SWAP_BYTES 0x0D00
#define GL_PARALLEL_ARRAYS_INTEL 0x83F4
#define GL_PARAMETER_BUFFER 0x80EE
#define GL_PARAMETER_BUFFER_ARB 0x80EE
#define GL_PARAMETER_BUFFER_BINDING 0x80EF
#define GL_PARAMETER_BUFFER_BINDING_ARB 0x80EF
#define GL_PARTIAL_SUCCESS_NV 0x902E
#define GL_PASS_THROUGH_NV 0x86E6
#define GL_PATCHES 0x000E
#define GL_PATCH_DEFAULT_INNER_LEVEL 0x8E73
#define GL_PATCH_DEFAULT_OUTER_LEVEL 0x8E74
#define GL_PATCH_VERTICES 0x8E72
#define GL_PATH_CLIENT_LENGTH_NV 0x907F
#define GL_PATH_COMMAND_COUNT_NV 0x909D
#define GL_PATH_COMPUTED_LENGTH_NV 0x90A0
#define GL_PATH_COORD_COUNT_NV 0x909E
#define GL_PATH_COVER_DEPTH_FUNC_NV 0x90BF
#define GL_PATH_DASH_ARRAY_COUNT_NV 0x909F
#define GL_PATH_DASH_CAPS_NV 0x907B
#define GL_PATH_DASH_OFFSET_NV 0x907E
#define GL_PATH_DASH_OFFSET_RESET_NV 0x90B4
#define GL_PATH_END_CAPS_NV 0x9076
#define GL_PATH_ERROR_POSITION_NV 0x90AB
#define GL_PATH_FILL_BOUNDING_BOX_NV 0x90A1
#define GL_PATH_FILL_COVER_MODE_NV 0x9082
#define GL_PATH_FILL_MASK_NV 0x9081
#define GL_PATH_FILL_MODE_NV 0x9080
#define GL_PATH_FORMAT_PS_NV 0x9071
#define GL_PATH_FORMAT_SVG_NV 0x9070
#define GL_PATH_GEN_COEFF_NV 0x90B1
#define GL_PATH_GEN_COMPONENTS_NV 0x90B3
#define GL_PATH_GEN_MODE_NV 0x90B0
#define GL_PATH_INITIAL_DASH_CAP_NV 0x907C
#define GL_PATH_INITIAL_END_CAP_NV 0x9077
#define GL_PATH_JOIN_STYLE_NV 0x9079
#define GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV 0x0D36
#define GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV 0x0D38
#define GL_PATH_MITER_LIMIT_NV 0x907A
#define GL_PATH_MODELVIEW_MATRIX_NV 0x0BA6
#define GL_PATH_MODELVIEW_NV 0x1700
#define GL_PATH_MODELVIEW_STACK_DEPTH_NV 0x0BA3
#define GL_PATH_OBJECT_BOUNDING_BOX_NV 0x908A
#define GL_PATH_PROJECTION_MATRIX_NV 0x0BA7
#define GL_PATH_PROJECTION_NV 0x1701
#define GL_PATH_PROJECTION_STACK_DEPTH_NV 0x0BA4
#define GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV 0x90BD
#define GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV 0x90BE
#define GL_PATH_STENCIL_FUNC_NV 0x90B7
#define GL_PATH_STENCIL_REF_NV 0x90B8
#define GL_PATH_STENCIL_VALUE_MASK_NV 0x90B9
#define GL_PATH_STROKE_BOUNDING_BOX_NV 0x90A2
#define GL_PATH_STROKE_COVER_MODE_NV 0x9083
#define GL_PATH_STROKE_MASK_NV 0x9084
#define GL_PATH_STROKE_WIDTH_NV 0x9075
#define GL_PATH_TERMINAL_DASH_CAP_NV 0x907D
#define GL_PATH_TERMINAL_END_CAP_NV 0x9078
#define GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV 0x84E3
#define GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV 0x84E4
#define GL_PERCENTAGE_AMD 0x8BC3
#define GL_PERFMON_RESULT_AMD 0x8BC6
#define GL_PERFMON_RESULT_AVAILABLE_AMD 0x8BC4
#define GL_PERFMON_RESULT_SIZE_AMD 0x8BC5
#define GL_PERFORMANCE_MONITOR_AMD 0x9152
#define GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL 0x94FC
#define GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL 0x94FB
#define GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL 0x94FA
#define GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL 0x94F8
#define GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL 0x94F9
#define GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL 0x94FF
#define GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL 0x94F1
#define GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL 0x94F2
#define GL_PERFQUERY_COUNTER_EVENT_INTEL 0x94F0
#define GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL 0x94FE
#define GL_PERFQUERY_COUNTER_RAW_INTEL 0x94F4
#define GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL 0x94F3
#define GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL 0x94F5
#define GL_PERFQUERY_DONOT_FLUSH_INTEL 0x83F9
#define GL_PERFQUERY_FLUSH_INTEL 0x83FA
#define GL_PERFQUERY_GLOBAL_CONTEXT_INTEL 0x00000001
#define GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL 0x9500
#define GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL 0x94FD
#define GL_PERFQUERY_SINGLE_CONTEXT_INTEL 0x00000000
#define GL_PERFQUERY_WAIT_INTEL 0x83FB
#define GL_PERTURB_EXT 0x85AE
#define GL_PER_GPU_STORAGE_BIT_NV 0x0800
#define GL_PER_GPU_STORAGE_NV 0x9548
#define GL_PER_STAGE_CONSTANTS_NV 0x8535
#define GL_PINLIGHT_NV 0x92A8
#define GL_PIXELS_PER_SAMPLE_PATTERN_X_AMD 0x91AE
#define GL_PIXELS_PER_SAMPLE_PATTERN_Y_AMD 0x91AF
#define GL_PIXEL_BUFFER_BARRIER_BIT 0x00000080
#define GL_PIXEL_BUFFER_BARRIER_BIT_EXT 0x00000080
#define GL_PIXEL_COUNTER_BITS_NV 0x8864
#define GL_PIXEL_COUNT_AVAILABLE_NV 0x8867
#define GL_PIXEL_COUNT_NV 0x8866
#define GL_PIXEL_CUBIC_WEIGHT_EXT 0x8333
#define GL_PIXEL_MAG_FILTER_EXT 0x8331
#define GL_PIXEL_MIN_FILTER_EXT 0x8332
#define GL_PIXEL_PACK_BUFFER 0x88EB
#define GL_PIXEL_PACK_BUFFER_ARB 0x88EB
#define GL_PIXEL_PACK_BUFFER_BINDING 0x88ED
#define GL_PIXEL_PACK_BUFFER_BINDING_ARB 0x88ED
#define GL_PIXEL_PACK_BUFFER_BINDING_EXT 0x88ED
#define GL_PIXEL_PACK_BUFFER_EXT 0x88EB
#define GL_PIXEL_TRANSFORM_2D_EXT 0x8330
#define GL_PIXEL_TRANSFORM_2D_MATRIX_EXT 0x8338
#define GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8336
#define GL_PIXEL_UNPACK_BUFFER 0x88EC
#define GL_PIXEL_UNPACK_BUFFER_ARB 0x88EC
#define GL_PIXEL_UNPACK_BUFFER_BINDING 0x88EF
#define GL_PIXEL_UNPACK_BUFFER_BINDING_ARB 0x88EF
#define GL_PIXEL_UNPACK_BUFFER_BINDING_EXT 0x88EF
#define GL_PIXEL_UNPACK_BUFFER_EXT 0x88EC
#define GL_PLUS_CLAMPED_ALPHA_NV 0x92B2
#define GL_PLUS_CLAMPED_NV 0x92B1
#define GL_PLUS_DARKER_NV 0x9292
#define GL_PLUS_NV 0x9291
#define GL_PN_TRIANGLES_ATI 0x87F0
#define GL_PN_TRIANGLES_NORMAL_MODE_ATI 0x87F3
#define GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI 0x87F7
#define GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI 0x87F8
#define GL_PN_TRIANGLES_POINT_MODE_ATI 0x87F2
#define GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI 0x87F6
#define GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI 0x87F5
#define GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F4
#define GL_POINT 0x1B00
#define GL_POINTS 0x0000
#define GL_POINT_DISTANCE_ATTENUATION_ARB 0x8129
#define GL_POINT_FADE_THRESHOLD_SIZE 0x8128
#define GL_POINT_FADE_THRESHOLD_SIZE_ARB 0x8128
#define GL_POINT_FADE_THRESHOLD_SIZE_EXT 0x8128
#define GL_POINT_SIZE 0x0B11
#define GL_POINT_SIZE_GRANULARITY 0x0B13
#define GL_POINT_SIZE_MAX_ARB 0x8127
#define GL_POINT_SIZE_MAX_EXT 0x8127
#define GL_POINT_SIZE_MIN_ARB 0x8126
#define GL_POINT_SIZE_MIN_EXT 0x8126
#define GL_POINT_SIZE_RANGE 0x0B12
#define GL_POINT_SPRITE_ARB 0x8861
#define GL_POINT_SPRITE_COORD_ORIGIN 0x8CA0
#define GL_POINT_SPRITE_NV 0x8861
#define GL_POINT_SPRITE_R_MODE_NV 0x8863
#define GL_POLYGON_MODE 0x0B40
#define GL_POLYGON_OFFSET_BIAS_EXT 0x8039
#define GL_POLYGON_OFFSET_CLAMP 0x8E1B
#define GL_POLYGON_OFFSET_CLAMP_EXT 0x8E1B
#define GL_POLYGON_OFFSET_COMMAND_NV 0x000E
#define GL_POLYGON_OFFSET_EXT 0x8037
#define GL_POLYGON_OFFSET_FACTOR 0x8038
#define GL_POLYGON_OFFSET_FACTOR_EXT 0x8038
#define GL_POLYGON_OFFSET_FILL 0x8037
#define GL_POLYGON_OFFSET_LINE 0x2A02
#define GL_POLYGON_OFFSET_POINT 0x2A01
#define GL_POLYGON_OFFSET_UNITS 0x2A00
#define GL_POLYGON_SMOOTH 0x0B41
#define GL_POLYGON_SMOOTH_HINT 0x0C53
#define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT 0x8023
#define GL_POST_CONVOLUTION_ALPHA_SCALE_EXT 0x801F
#define GL_POST_CONVOLUTION_BLUE_BIAS_EXT 0x8022
#define GL_POST_CONVOLUTION_BLUE_SCALE_EXT 0x801E
#define GL_POST_CONVOLUTION_GREEN_BIAS_EXT 0x8021
#define GL_POST_CONVOLUTION_GREEN_SCALE_EXT 0x801D
#define GL_POST_CONVOLUTION_RED_BIAS_EXT 0x8020
#define GL_POST_CONVOLUTION_RED_SCALE_EXT 0x801C
#define GL_PRESENT_DURATION_NV 0x8E2B
#define GL_PRESENT_TIME_NV 0x8E2A
#define GL_PRESERVE_ATI 0x8762
#define GL_PREVIOUS_ARB 0x8578
#define GL_PREVIOUS_EXT 0x8578
#define GL_PREVIOUS_TEXTURE_INPUT_NV 0x86E4
#define GL_PRIMARY_COLOR_ARB 0x8577
#define GL_PRIMARY_COLOR_EXT 0x8577
#define GL_PRIMARY_COLOR_NV 0x852C
#define GL_PRIMITIVES_GENERATED 0x8C87
#define GL_PRIMITIVES_GENERATED_EXT 0x8C87
#define GL_PRIMITIVES_GENERATED_NV 0x8C87
#define GL_PRIMITIVES_SUBMITTED 0x82EF
#define GL_PRIMITIVES_SUBMITTED_ARB 0x82EF
#define GL_PRIMITIVE_BOUNDING_BOX_ARB 0x92BE
#define GL_PRIMITIVE_ID_NV 0x8C7C
#define GL_PRIMITIVE_RESTART 0x8F9D
#define GL_PRIMITIVE_RESTART_FIXED_INDEX 0x8D69
#define GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED 0x8221
#define GL_PRIMITIVE_RESTART_INDEX 0x8F9E
#define GL_PRIMITIVE_RESTART_INDEX_NV 0x8559
#define GL_PRIMITIVE_RESTART_NV 0x8558
#define GL_PROGRAM 0x82E2
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB 0x9341
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_NV 0x9341
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB 0x9340
#define GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV 0x9340
#define GL_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B0
#define GL_PROGRAM_ALU_INSTRUCTIONS_ARB 0x8805
#define GL_PROGRAM_ATTRIBS_ARB 0x88AC
#define GL_PROGRAM_ATTRIB_COMPONENTS_NV 0x8906
#define GL_PROGRAM_BINARY_FORMATS 0x87FF
#define GL_PROGRAM_BINARY_LENGTH 0x8741
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT 0x8257
#define GL_PROGRAM_BINDING_ARB 0x8677
#define GL_PROGRAM_ERROR_POSITION_ARB 0x864B
#define GL_PROGRAM_ERROR_POSITION_NV 0x864B
#define GL_PROGRAM_ERROR_STRING_ARB 0x8874
#define GL_PROGRAM_ERROR_STRING_NV 0x8874
#define GL_PROGRAM_FORMAT_ARB 0x8876
#define GL_PROGRAM_FORMAT_ASCII_ARB 0x8875
#define GL_PROGRAM_INPUT 0x92E3
#define GL_PROGRAM_INSTRUCTIONS_ARB 0x88A0
#define GL_PROGRAM_LENGTH_ARB 0x8627
#define GL_PROGRAM_LENGTH_NV 0x8627
#define GL_PROGRAM_MATRIX_EXT 0x8E2D
#define GL_PROGRAM_MATRIX_STACK_DEPTH_EXT 0x8E2F
#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B2
#define GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x8808
#define GL_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AE
#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A2
#define GL_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AA
#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A6
#define GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x880A
#define GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x8809
#define GL_PROGRAM_OBJECT_ARB 0x8B40
#define GL_PROGRAM_OBJECT_EXT 0x8B40
#define GL_PROGRAM_OUTPUT 0x92E4
#define GL_PROGRAM_PARAMETERS_ARB 0x88A8
#define GL_PROGRAM_PARAMETER_NV 0x8644
#define GL_PROGRAM_PIPELINE 0x82E4
#define GL_PROGRAM_PIPELINE_BINDING 0x825A
#define GL_PROGRAM_PIPELINE_OBJECT_EXT 0x8A4F
#define GL_PROGRAM_POINT_SIZE 0x8642
#define GL_PROGRAM_POINT_SIZE_ARB 0x8642
#define GL_PROGRAM_POINT_SIZE_EXT 0x8642
#define GL_PROGRAM_RESIDENT_NV 0x8647
#define GL_PROGRAM_RESULT_COMPONENTS_NV 0x8907
#define GL_PROGRAM_SEPARABLE 0x8258
#define GL_PROGRAM_STRING_ARB 0x8628
#define GL_PROGRAM_STRING_NV 0x8628
#define GL_PROGRAM_TARGET_NV 0x8646
#define GL_PROGRAM_TEMPORARIES_ARB 0x88A4
#define GL_PROGRAM_TEX_INDIRECTIONS_ARB 0x8807
#define GL_PROGRAM_TEX_INSTRUCTIONS_ARB 0x8806
#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB 0x88B6
#define GL_PROTECTED_MEMORY_OBJECT_EXT 0x959B
#define GL_PROVOKING_VERTEX 0x8E4F
#define GL_PROVOKING_VERTEX_EXT 0x8E4F
#define GL_PROXY_HISTOGRAM_EXT 0x8025
#define GL_PROXY_TEXTURE_1D 0x8063
#define GL_PROXY_TEXTURE_1D_ARRAY 0x8C19
#define GL_PROXY_TEXTURE_1D_ARRAY_EXT 0x8C19
#define GL_PROXY_TEXTURE_1D_EXT 0x8063
#define GL_PROXY_TEXTURE_1D_STACK_MESAX 0x875B
#define GL_PROXY_TEXTURE_2D 0x8064
#define GL_PROXY_TEXTURE_2D_ARRAY 0x8C1B
#define GL_PROXY_TEXTURE_2D_ARRAY_EXT 0x8C1B
#define GL_PROXY_TEXTURE_2D_EXT 0x8064
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE 0x9101
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
#define GL_PROXY_TEXTURE_2D_STACK_MESAX 0x875C
#define GL_PROXY_TEXTURE_3D 0x8070
#define GL_PROXY_TEXTURE_3D_EXT 0x8070
#define GL_PROXY_TEXTURE_CUBE_MAP 0x851B
#define GL_PROXY_TEXTURE_CUBE_MAP_ARB 0x851B
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY 0x900B
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB 0x900B
#define GL_PROXY_TEXTURE_CUBE_MAP_EXT 0x851B
#define GL_PROXY_TEXTURE_RECTANGLE 0x84F7
#define GL_PROXY_TEXTURE_RECTANGLE_ARB 0x84F7
#define GL_PROXY_TEXTURE_RECTANGLE_NV 0x84F7
#define GL_PURGEABLE_APPLE 0x8A1D
#define GL_PURGED_CONTEXT_RESET_NV 0x92BB
#define GL_QUADRATIC_CURVE_TO_NV 0x0A
#define GL_QUADS 0x0007
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION 0x8E4C
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT 0x8E4C
#define GL_QUARTER_BIT_ATI 0x00000010
#define GL_QUERY 0x82E3
#define GL_QUERY_ALL_EVENT_BITS_AMD 0xFFFFFFFF
#define GL_QUERY_BUFFER 0x9192
#define GL_QUERY_BUFFER_AMD 0x9192
#define GL_QUERY_BUFFER_BARRIER_BIT 0x00008000
#define GL_QUERY_BUFFER_BINDING 0x9193
#define GL_QUERY_BUFFER_BINDING_AMD 0x9193
#define GL_QUERY_BY_REGION_NO_WAIT 0x8E16
#define GL_QUERY_BY_REGION_NO_WAIT_INVERTED 0x8E1A
#define GL_QUERY_BY_REGION_NO_WAIT_NV 0x8E16
#define GL_QUERY_BY_REGION_WAIT 0x8E15
#define GL_QUERY_BY_REGION_WAIT_INVERTED 0x8E19
#define GL_QUERY_BY_REGION_WAIT_NV 0x8E15
#define GL_QUERY_COUNTER_BITS 0x8864
#define GL_QUERY_COUNTER_BITS_ARB 0x8864
#define GL_QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD 0x00000008
#define GL_QUERY_DEPTH_FAIL_EVENT_BIT_AMD 0x00000002
#define GL_QUERY_DEPTH_PASS_EVENT_BIT_AMD 0x00000001
#define GL_QUERY_NO_WAIT 0x8E14
#define GL_QUERY_NO_WAIT_INVERTED 0x8E18
#define GL_QUERY_NO_WAIT_NV 0x8E14
#define GL_QUERY_OBJECT_AMD 0x9153
#define GL_QUERY_OBJECT_EXT 0x9153
#define GL_QUERY_RESOURCE_BUFFEROBJECT_NV 0x9547
#define GL_QUERY_RESOURCE_MEMTYPE_VIDMEM_NV 0x9542
#define GL_QUERY_RESOURCE_RENDERBUFFER_NV 0x9546
#define GL_QUERY_RESOURCE_SYS_RESERVED_NV 0x9544
#define GL_QUERY_RESOURCE_TEXTURE_NV 0x9545
#define GL_QUERY_RESOURCE_TYPE_VIDMEM_ALLOC_NV 0x9540
#define GL_QUERY_RESULT 0x8866
#define GL_QUERY_RESULT_ARB 0x8866
#define GL_QUERY_RESULT_AVAILABLE 0x8867
#define GL_QUERY_RESULT_AVAILABLE_ARB 0x8867
#define GL_QUERY_RESULT_NO_WAIT 0x9194
#define GL_QUERY_RESULT_NO_WAIT_AMD 0x9194
#define GL_QUERY_STENCIL_FAIL_EVENT_BIT_AMD 0x00000004
#define GL_QUERY_TARGET 0x82EA
#define GL_QUERY_WAIT 0x8E13
#define GL_QUERY_WAIT_INVERTED 0x8E17
#define GL_QUERY_WAIT_NV 0x8E13
#define GL_R11F_G11F_B10F 0x8C3A
#define GL_R11F_G11F_B10F_EXT 0x8C3A
#define GL_R16 0x822A
#define GL_R16F 0x822D
#define GL_R16I 0x8233
#define GL_R16UI 0x8234
#define GL_R16_SNORM 0x8F98
#define GL_R32F 0x822E
#define GL_R32I 0x8235
#define GL_R32UI 0x8236
#define GL_R3_G3_B2 0x2A10
#define GL_R8 0x8229
#define GL_R8I 0x8231
#define GL_R8UI 0x8232
#define GL_R8_SNORM 0x8F94
#define GL_RASTERIZER_DISCARD 0x8C89
#define GL_RASTERIZER_DISCARD_EXT 0x8C89
#define GL_RASTERIZER_DISCARD_NV 0x8C89
#define GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT 0x932A
#define GL_RASTER_MULTISAMPLE_EXT 0x9327
#define GL_RASTER_SAMPLES_EXT 0x9328
#define GL_READ_BUFFER 0x0C02
#define GL_READ_FRAMEBUFFER 0x8CA8
#define GL_READ_FRAMEBUFFER_BINDING 0x8CAA
#define GL_READ_FRAMEBUFFER_BINDING_EXT 0x8CAA
#define GL_READ_FRAMEBUFFER_EXT 0x8CA8
#define GL_READ_ONLY 0x88B8
#define GL_READ_ONLY_ARB 0x88B8
#define GL_READ_PIXELS 0x828C
#define GL_READ_PIXELS_FORMAT 0x828D
#define GL_READ_PIXELS_TYPE 0x828E
#define GL_READ_PIXEL_DATA_RANGE_LENGTH_NV 0x887B
#define GL_READ_PIXEL_DATA_RANGE_NV 0x8879
#define GL_READ_PIXEL_DATA_RANGE_POINTER_NV 0x887D
#define GL_READ_WRITE 0x88BA
#define GL_READ_WRITE_ARB 0x88BA
#define GL_RECT_NV 0xF6
#define GL_RED 0x1903
#define GL_REDUCE_EXT 0x8016
#define GL_RED_BIT_ATI 0x00000001
#define GL_RED_INTEGER 0x8D94
#define GL_RED_INTEGER_EXT 0x8D94
#define GL_RED_NV 0x1903
#define GL_RED_SNORM 0x8F90
#define GL_REFERENCED_BY_COMPUTE_SHADER 0x930B
#define GL_REFERENCED_BY_FRAGMENT_SHADER 0x930A
#define GL_REFERENCED_BY_GEOMETRY_SHADER 0x9309
#define GL_REFERENCED_BY_TESS_CONTROL_SHADER 0x9307
#define GL_REFERENCED_BY_TESS_EVALUATION_SHADER 0x9308
#define GL_REFERENCED_BY_VERTEX_SHADER 0x9306
#define GL_REFLECTION_MAP_ARB 0x8512
#define GL_REFLECTION_MAP_EXT 0x8512
#define GL_REFLECTION_MAP_NV 0x8512
#define GL_REGISTER_COMBINERS_NV 0x8522
#define GL_REG_0_ATI 0x8921
#define GL_REG_10_ATI 0x892B
#define GL_REG_11_ATI 0x892C
#define GL_REG_12_ATI 0x892D
#define GL_REG_13_ATI 0x892E
#define GL_REG_14_ATI 0x892F
#define GL_REG_15_ATI 0x8930
#define GL_REG_16_ATI 0x8931
#define GL_REG_17_ATI 0x8932
#define GL_REG_18_ATI 0x8933
#define GL_REG_19_ATI 0x8934
#define GL_REG_1_ATI 0x8922
#define GL_REG_20_ATI 0x8935
#define GL_REG_21_ATI 0x8936
#define GL_REG_22_ATI 0x8937
#define GL_REG_23_ATI 0x8938
#define GL_REG_24_ATI 0x8939
#define GL_REG_25_ATI 0x893A
#define GL_REG_26_ATI 0x893B
#define GL_REG_27_ATI 0x893C
#define GL_REG_28_ATI 0x893D
#define GL_REG_29_ATI 0x893E
#define GL_REG_2_ATI 0x8923
#define GL_REG_30_ATI 0x893F
#define GL_REG_31_ATI 0x8940
#define GL_REG_3_ATI 0x8924
#define GL_REG_4_ATI 0x8925
#define GL_REG_5_ATI 0x8926
#define GL_REG_6_ATI 0x8927
#define GL_REG_7_ATI 0x8928
#define GL_REG_8_ATI 0x8929
#define GL_REG_9_ATI 0x892A
#define GL_RELATIVE_ARC_TO_NV 0xFF
#define GL_RELATIVE_CONIC_CURVE_TO_NV 0x1B
#define GL_RELATIVE_CUBIC_CURVE_TO_NV 0x0D
#define GL_RELATIVE_HORIZONTAL_LINE_TO_NV 0x07
#define GL_RELATIVE_LARGE_CCW_ARC_TO_NV 0x17
#define GL_RELATIVE_LARGE_CW_ARC_TO_NV 0x19
#define GL_RELATIVE_LINE_TO_NV 0x05
#define GL_RELATIVE_MOVE_TO_NV 0x03
#define GL_RELATIVE_QUADRATIC_CURVE_TO_NV 0x0B
#define GL_RELATIVE_RECT_NV 0xF7
#define GL_RELATIVE_ROUNDED_RECT2_NV 0xEB
#define GL_RELATIVE_ROUNDED_RECT4_NV 0xED
#define GL_RELATIVE_ROUNDED_RECT8_NV 0xEF
#define GL_RELATIVE_ROUNDED_RECT_NV 0xE9
#define GL_RELATIVE_SMALL_CCW_ARC_TO_NV 0x13
#define GL_RELATIVE_SMALL_CW_ARC_TO_NV 0x15
#define GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV 0x11
#define GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV 0x0F
#define GL_RELATIVE_VERTICAL_LINE_TO_NV 0x09
#define GL_RELEASED_APPLE 0x8A19
#define GL_RENDERBUFFER 0x8D41
#define GL_RENDERBUFFER_ALPHA_SIZE 0x8D53
#define GL_RENDERBUFFER_ALPHA_SIZE_EXT 0x8D53
#define GL_RENDERBUFFER_BINDING 0x8CA7
#define GL_RENDERBUFFER_BINDING_EXT 0x8CA7
#define GL_RENDERBUFFER_BLUE_SIZE 0x8D52
#define GL_RENDERBUFFER_BLUE_SIZE_EXT 0x8D52
#define GL_RENDERBUFFER_COLOR_SAMPLES_NV 0x8E10
#define GL_RENDERBUFFER_COVERAGE_SAMPLES_NV 0x8CAB
#define GL_RENDERBUFFER_DEPTH_SIZE 0x8D54
#define GL_RENDERBUFFER_DEPTH_SIZE_EXT 0x8D54
#define GL_RENDERBUFFER_EXT 0x8D41
#define GL_RENDERBUFFER_FREE_MEMORY_ATI 0x87FD
#define GL_RENDERBUFFER_GREEN_SIZE 0x8D51
#define GL_RENDERBUFFER_GREEN_SIZE_EXT 0x8D51
#define GL_RENDERBUFFER_HEIGHT 0x8D43
#define GL_RENDERBUFFER_HEIGHT_EXT 0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT 0x8D44
#define GL_RENDERBUFFER_INTERNAL_FORMAT_EXT 0x8D44
#define GL_RENDERBUFFER_RED_SIZE 0x8D50
#define GL_RENDERBUFFER_RED_SIZE_EXT 0x8D50
#define GL_RENDERBUFFER_SAMPLES 0x8CAB
#define GL_RENDERBUFFER_SAMPLES_EXT 0x8CAB
#define GL_RENDERBUFFER_STENCIL_SIZE 0x8D55
#define GL_RENDERBUFFER_STENCIL_SIZE_EXT 0x8D55
#define GL_RENDERBUFFER_WIDTH 0x8D42
#define GL_RENDERBUFFER_WIDTH_EXT 0x8D42
#define GL_RENDERER 0x1F01
#define GL_RENDER_GPU_MASK_NV 0x9558
#define GL_REPEAT 0x2901
#define GL_REPLACE 0x1E01
#define GL_REPLACE_EXT 0x8062
#define GL_REPLACE_VALUE_AMD 0x874B
#define GL_RESCALE_NORMAL_EXT 0x803A
#define GL_RESET_NOTIFICATION_STRATEGY 0x8256
#define GL_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
#define GL_RESTART_PATH_NV 0xF0
#define GL_RETAINED_APPLE 0x8A1B
#define GL_RG 0x8227
#define GL_RG16 0x822C
#define GL_RG16F 0x822F
#define GL_RG16I 0x8239
#define GL_RG16UI 0x823A
#define GL_RG16_SNORM 0x8F99
#define GL_RG32F 0x8230
#define GL_RG32I 0x823B
#define GL_RG32UI 0x823C
#define GL_RG8 0x822B
#define GL_RG8I 0x8237
#define GL_RG8UI 0x8238
#define GL_RG8_SNORM 0x8F95
#define GL_RGB 0x1907
#define GL_RGB10 0x8052
#define GL_RGB10_A2 0x8059
#define GL_RGB10_A2UI 0x906F
#define GL_RGB10_A2_EXT 0x8059
#define GL_RGB10_EXT 0x8052
#define GL_RGB12 0x8053
#define GL_RGB12_EXT 0x8053
#define GL_RGB16 0x8054
#define GL_RGB16F 0x881B
#define GL_RGB16F_ARB 0x881B
#define GL_RGB16I 0x8D89
#define GL_RGB16I_EXT 0x8D89
#define GL_RGB16UI 0x8D77
#define GL_RGB16UI_EXT 0x8D77
#define GL_RGB16_EXT 0x8054
#define GL_RGB16_SNORM 0x8F9A
#define GL_RGB2_EXT 0x804E
#define GL_RGB32F 0x8815
#define GL_RGB32F_ARB 0x8815
#define GL_RGB32I 0x8D83
#define GL_RGB32I_EXT 0x8D83
#define GL_RGB32UI 0x8D71
#define GL_RGB32UI_EXT 0x8D71
#define GL_RGB4 0x804F
#define GL_RGB4_EXT 0x804F
#define GL_RGB5 0x8050
#define GL_RGB565 0x8D62
#define GL_RGB5_A1 0x8057
#define GL_RGB5_A1_EXT 0x8057
#define GL_RGB5_EXT 0x8050
#define GL_RGB8 0x8051
#define GL_RGB8I 0x8D8F
#define GL_RGB8I_EXT 0x8D8F
#define GL_RGB8UI 0x8D7D
#define GL_RGB8UI_EXT 0x8D7D
#define GL_RGB8_EXT 0x8051
#define GL_RGB8_SNORM 0x8F96
#define GL_RGB9_E5 0x8C3D
#define GL_RGB9_E5_EXT 0x8C3D
#define GL_RGBA 0x1908
#define GL_RGBA12 0x805A
#define GL_RGBA12_EXT 0x805A
#define GL_RGBA16 0x805B
#define GL_RGBA16F 0x881A
#define GL_RGBA16F_ARB 0x881A
#define GL_RGBA16I 0x8D88
#define GL_RGBA16I_EXT 0x8D88
#define GL_RGBA16UI 0x8D76
#define GL_RGBA16UI_EXT 0x8D76
#define GL_RGBA16_EXT 0x805B
#define GL_RGBA16_SNORM 0x8F9B
#define GL_RGBA2 0x8055
#define GL_RGBA2_EXT 0x8055
#define GL_RGBA32F 0x8814
#define GL_RGBA32F_ARB 0x8814
#define GL_RGBA32I 0x8D82
#define GL_RGBA32I_EXT 0x8D82
#define GL_RGBA32UI 0x8D70
#define GL_RGBA32UI_EXT 0x8D70
#define GL_RGBA4 0x8056
#define GL_RGBA4_EXT 0x8056
#define GL_RGBA8 0x8058
#define GL_RGBA8I 0x8D8E
#define GL_RGBA8I_EXT 0x8D8E
#define GL_RGBA8UI 0x8D7C
#define GL_RGBA8UI_EXT 0x8D7C
#define GL_RGBA8_EXT 0x8058
#define GL_RGBA8_SNORM 0x8F97
#define GL_RGBA_FLOAT16_APPLE 0x881A
#define GL_RGBA_FLOAT16_ATI 0x881A
#define GL_RGBA_FLOAT32_APPLE 0x8814
#define GL_RGBA_FLOAT32_ATI 0x8814
#define GL_RGBA_FLOAT_MODE_ARB 0x8820
#define GL_RGBA_FLOAT_MODE_ATI 0x8820
#define GL_RGBA_INTEGER 0x8D99
#define GL_RGBA_INTEGER_EXT 0x8D99
#define GL_RGBA_INTEGER_MODE_EXT 0x8D9E
#define GL_RGBA_SIGNED_COMPONENTS_EXT 0x8C3C
#define GL_RGBA_SNORM 0x8F93
#define GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV 0x86D9
#define GL_RGB_422_APPLE 0x8A1F
#define GL_RGB_FLOAT16_APPLE 0x881B
#define GL_RGB_FLOAT16_ATI 0x881B
#define GL_RGB_FLOAT32_APPLE 0x8815
#define GL_RGB_FLOAT32_ATI 0x8815
#define GL_RGB_INTEGER 0x8D98
#define GL_RGB_INTEGER_EXT 0x8D98
#define GL_RGB_RAW_422_APPLE 0x8A51
#define GL_RGB_SCALE_ARB 0x8573
#define GL_RGB_SCALE_EXT 0x8573
#define GL_RGB_SNORM 0x8F92
#define GL_RG_INTEGER 0x8228
#define GL_RG_SNORM 0x8F91
#define GL_RIGHT 0x0407
#define GL_ROUNDED_RECT2_NV 0xEA
#define GL_ROUNDED_RECT4_NV 0xEC
#define GL_ROUNDED_RECT8_NV 0xEE
#define GL_ROUNDED_RECT_NV 0xE8
#define GL_ROUND_NV 0x90A4
#define GL_SAMPLER 0x82E6
#define GL_SAMPLER_1D 0x8B5D
#define GL_SAMPLER_1D_ARB 0x8B5D
#define GL_SAMPLER_1D_ARRAY 0x8DC0
#define GL_SAMPLER_1D_ARRAY_EXT 0x8DC0
#define GL_SAMPLER_1D_ARRAY_SHADOW 0x8DC3
#define GL_SAMPLER_1D_ARRAY_SHADOW_EXT 0x8DC3
#define GL_SAMPLER_1D_SHADOW 0x8B61
#define GL_SAMPLER_1D_SHADOW_ARB 0x8B61
#define GL_SAMPLER_2D 0x8B5E
#define GL_SAMPLER_2D_ARB 0x8B5E
#define GL_SAMPLER_2D_ARRAY 0x8DC1
#define GL_SAMPLER_2D_ARRAY_EXT 0x8DC1
#define GL_SAMPLER_2D_ARRAY_SHADOW 0x8DC4
#define GL_SAMPLER_2D_ARRAY_SHADOW_EXT 0x8DC4
#define GL_SAMPLER_2D_MULTISAMPLE 0x9108
#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910B
#define GL_SAMPLER_2D_RECT 0x8B63
#define GL_SAMPLER_2D_RECT_ARB 0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW 0x8B64
#define GL_SAMPLER_2D_RECT_SHADOW_ARB 0x8B64
#define GL_SAMPLER_2D_SHADOW 0x8B62
#define GL_SAMPLER_2D_SHADOW_ARB 0x8B62
#define GL_SAMPLER_3D 0x8B5F
#define GL_SAMPLER_3D_ARB 0x8B5F
#define GL_SAMPLER_BINDING 0x8919
#define GL_SAMPLER_BUFFER 0x8DC2
#define GL_SAMPLER_BUFFER_AMD 0x9001
#define GL_SAMPLER_BUFFER_EXT 0x8DC2
#define GL_SAMPLER_CUBE 0x8B60
#define GL_SAMPLER_CUBE_ARB 0x8B60
#define GL_SAMPLER_CUBE_MAP_ARRAY 0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW 0x900D
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB 0x900D
#define GL_SAMPLER_CUBE_SHADOW 0x8DC5
#define GL_SAMPLER_CUBE_SHADOW_EXT 0x8DC5
#define GL_SAMPLER_OBJECT_AMD 0x9155
#define GL_SAMPLER_RENDERBUFFER_NV 0x8E56
#define GL_SAMPLES 0x80A9
#define GL_SAMPLES_ARB 0x80A9
#define GL_SAMPLES_EXT 0x80A9
#define GL_SAMPLES_PASSED 0x8914
#define GL_SAMPLES_PASSED_ARB 0x8914
#define GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E
#define GL_SAMPLE_ALPHA_TO_COVERAGE_ARB 0x809E
#define GL_SAMPLE_ALPHA_TO_MASK_EXT 0x809E
#define GL_SAMPLE_ALPHA_TO_ONE 0x809F
#define GL_SAMPLE_ALPHA_TO_ONE_ARB 0x809F
#define GL_SAMPLE_ALPHA_TO_ONE_EXT 0x809F
#define GL_SAMPLE_BUFFERS 0x80A8
#define GL_SAMPLE_BUFFERS_ARB 0x80A8
#define GL_SAMPLE_BUFFERS_EXT 0x80A8
#define GL_SAMPLE_COVERAGE 0x80A0
#define GL_SAMPLE_COVERAGE_ARB 0x80A0
#define GL_SAMPLE_COVERAGE_INVERT 0x80AB
#define GL_SAMPLE_COVERAGE_INVERT_ARB 0x80AB
#define GL_SAMPLE_COVERAGE_VALUE 0x80AA
#define GL_SAMPLE_COVERAGE_VALUE_ARB 0x80AA
#define GL_SAMPLE_LOCATION_ARB 0x8E50
#define GL_SAMPLE_LOCATION_NV 0x8E50
#define GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB 0x933F
#define GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV 0x933F
#define GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB 0x933E
#define GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV 0x933E
#define GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB 0x933D
#define GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV 0x933D
#define GL_SAMPLE_MASK 0x8E51
#define GL_SAMPLE_MASK_EXT 0x80A0
#define GL_SAMPLE_MASK_INVERT_EXT 0x80AB
#define GL_SAMPLE_MASK_NV 0x8E51
#define GL_SAMPLE_MASK_VALUE 0x8E52
#define GL_SAMPLE_MASK_VALUE_EXT 0x80AA
#define GL_SAMPLE_MASK_VALUE_NV 0x8E52
#define GL_SAMPLE_PATTERN_EXT 0x80AC
#define GL_SAMPLE_POSITION 0x8E50
#define GL_SAMPLE_POSITION_NV 0x8E50
#define GL_SAMPLE_SHADING 0x8C36
#define GL_SAMPLE_SHADING_ARB 0x8C36
#define GL_SATURATE_BIT_ATI 0x00000040
#define GL_SCALAR_EXT 0x87BE
#define GL_SCALED_RESOLVE_FASTEST_EXT 0x90BA
#define GL_SCALED_RESOLVE_NICEST_EXT 0x90BB
#define GL_SCALE_BY_FOUR_NV 0x853F
#define GL_SCALE_BY_ONE_HALF_NV 0x8540
#define GL_SCALE_BY_TWO_NV 0x853E
#define GL_SCISSOR_BOX 0x0C10
#define GL_SCISSOR_COMMAND_NV 0x0011
#define GL_SCISSOR_TEST 0x0C11
#define GL_SCREEN_KHR 0x9295
#define GL_SCREEN_NV 0x9295
#define GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV 0x8F27
#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB 0x889C
#define GL_SECONDARY_COLOR_ARRAY_EXT 0x845E
#define GL_SECONDARY_COLOR_ARRAY_LENGTH_NV 0x8F31
#define GL_SECONDARY_COLOR_ARRAY_POINTER_EXT 0x845D
#define GL_SECONDARY_COLOR_ARRAY_SIZE_EXT 0x845A
#define GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT 0x845C
#define GL_SECONDARY_COLOR_ARRAY_TYPE_EXT 0x845B
#define GL_SECONDARY_COLOR_NV 0x852D
#define GL_SECONDARY_INTERPOLATOR_ATI 0x896D
#define GL_SEPARABLE_2D_EXT 0x8012
#define GL_SEPARATE_ATTRIBS 0x8C8D
#define GL_SEPARATE_ATTRIBS_EXT 0x8C8D
#define GL_SEPARATE_ATTRIBS_NV 0x8C8D
#define GL_SEPARATE_SPECULAR_COLOR_EXT 0x81FA
#define GL_SET 0x150F
#define GL_SET_AMD 0x874A
#define GL_SHADER 0x82E1
#define GL_SHADER_BINARY_FORMATS 0x8DF8
#define GL_SHADER_BINARY_FORMAT_SPIR_V 0x9551
#define GL_SHADER_BINARY_FORMAT_SPIR_V_ARB 0x9551
#define GL_SHADER_COMPILER 0x8DFA
#define GL_SHADER_CONSISTENT_NV 0x86DD
#define GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV 0x00000010
#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT 0x00000020
#define GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT 0x00000020
#define GL_SHADER_IMAGE_ATOMIC 0x82A6
#define GL_SHADER_IMAGE_LOAD 0x82A4
#define GL_SHADER_IMAGE_STORE 0x82A5
#define GL_SHADER_INCLUDE_ARB 0x8DAE
#define GL_SHADER_OBJECT_ARB 0x8B48
#define GL_SHADER_OBJECT_EXT 0x8B48
#define GL_SHADER_OPERATION_NV 0x86DF
#define GL_SHADER_SOURCE_LENGTH 0x8B88
#define GL_SHADER_STORAGE_BARRIER_BIT 0x00002000
#define GL_SHADER_STORAGE_BLOCK 0x92E6
#define GL_SHADER_STORAGE_BUFFER 0x90D2
#define GL_SHADER_STORAGE_BUFFER_BINDING 0x90D3
#define GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT 0x90DF
#define GL_SHADER_STORAGE_BUFFER_SIZE 0x90D5
#define GL_SHADER_STORAGE_BUFFER_START 0x90D4
#define GL_SHADER_TYPE 0x8B4F
#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
#define GL_SHADING_LANGUAGE_VERSION_ARB 0x8B8C
#define GL_SHADOW_ATTENUATION_EXT 0x834E
#define GL_SHARED_EDGE_NV 0xC0
#define GL_SHARED_TEXTURE_PALETTE_EXT 0x81FB
#define GL_SHORT 0x1402
#define GL_SIGNALED 0x9119
#define GL_SIGNED_ALPHA8_NV 0x8706
#define GL_SIGNED_ALPHA_NV 0x8705
#define GL_SIGNED_HILO16_NV 0x86FA
#define GL_SIGNED_HILO8_NV 0x885F
#define GL_SIGNED_HILO_NV 0x86F9
#define GL_SIGNED_IDENTITY_NV 0x853C
#define GL_SIGNED_INTENSITY8_NV 0x8708
#define GL_SIGNED_INTENSITY_NV 0x8707
#define GL_SIGNED_LUMINANCE8_ALPHA8_NV 0x8704
#define GL_SIGNED_LUMINANCE8_NV 0x8702
#define GL_SIGNED_LUMINANCE_ALPHA_NV 0x8703
#define GL_SIGNED_LUMINANCE_NV 0x8701
#define GL_SIGNED_NEGATE_NV 0x853D
#define GL_SIGNED_NORMALIZED 0x8F9C
#define GL_SIGNED_RGB8_NV 0x86FF
#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
#define GL_SIGNED_RGBA8_NV 0x86FC
#define GL_SIGNED_RGBA_NV 0x86FB
#define GL_SIGNED_RGB_NV 0x86FE
#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV 0x870C
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST 0x82AC
#define GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE 0x82AE
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST 0x82AD
#define GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE 0x82AF
#define GL_SINGLE_COLOR_EXT 0x81F9
#define GL_SKIP_COMPONENTS1_NV -6
#define GL_SKIP_COMPONENTS2_NV -5
#define GL_SKIP_COMPONENTS3_NV -4
#define GL_SKIP_COMPONENTS4_NV -3
#define GL_SKIP_DECODE_EXT 0x8A4A
#define GL_SKIP_MISSING_GLYPH_NV 0x90A9
#define GL_SLUMINANCE8_ALPHA8_EXT 0x8C45
#define GL_SLUMINANCE8_EXT 0x8C47
#define GL_SLUMINANCE_ALPHA_EXT 0x8C44
#define GL_SLUMINANCE_EXT 0x8C46
#define GL_SMALL_CCW_ARC_TO_NV 0x12
#define GL_SMALL_CW_ARC_TO_NV 0x14
#define GL_SMOOTH_CUBIC_CURVE_TO_NV 0x10
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_SMOOTH_LINE_WIDTH_RANGE 0x0B22
#define GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
#define GL_SMOOTH_POINT_SIZE_RANGE 0x0B12
#define GL_SMOOTH_QUADRATIC_CURVE_TO_NV 0x0E
#define GL_SM_COUNT_NV 0x933B
#define GL_SOFTLIGHT_KHR 0x929C
#define GL_SOFTLIGHT_NV 0x929C
#define GL_SOURCE0_ALPHA_ARB 0x8588
#define GL_SOURCE0_ALPHA_EXT 0x8588
#define GL_SOURCE0_RGB_ARB 0x8580
#define GL_SOURCE0_RGB_EXT 0x8580
#define GL_SOURCE1_ALPHA 0x8589
#define GL_SOURCE1_ALPHA_ARB 0x8589
#define GL_SOURCE1_ALPHA_EXT 0x8589
#define GL_SOURCE1_RGB_ARB 0x8581
#define GL_SOURCE1_RGB_EXT 0x8581
#define GL_SOURCE2_ALPHA_ARB 0x858A
#define GL_SOURCE2_ALPHA_EXT 0x858A
#define GL_SOURCE2_RGB_ARB 0x8582
#define GL_SOURCE2_RGB_EXT 0x8582
#define GL_SOURCE3_ALPHA_NV 0x858B
#define GL_SOURCE3_RGB_NV 0x8583
#define GL_SPARE0_NV 0x852E
#define GL_SPARE0_PLUS_SECONDARY_COLOR_NV 0x8532
#define GL_SPARE1_NV 0x852F
#define GL_SPARSE_BUFFER_PAGE_SIZE_ARB 0x82F8
#define GL_SPARSE_STORAGE_BIT_ARB 0x0400
#define GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB 0x91A9
#define GL_SPIR_V_BINARY 0x9552
#define GL_SPIR_V_BINARY_ARB 0x9552
#define GL_SPIR_V_EXTENSIONS 0x9553
#define GL_SQUARE_NV 0x90A3
#define GL_SRC1_ALPHA 0x8589
#define GL_SRC1_COLOR 0x88F9
#define GL_SRC_ALPHA 0x0302
#define GL_SRC_ALPHA_SATURATE 0x0308
#define GL_SRC_ATOP_NV 0x928E
#define GL_SRC_COLOR 0x0300
#define GL_SRC_IN_NV 0x928A
#define GL_SRC_NV 0x9286
#define GL_SRC_OUT_NV 0x928C
#define GL_SRC_OVER_NV 0x9288
#define GL_SRGB 0x8C40
#define GL_SRGB8 0x8C41
#define GL_SRGB8_ALPHA8 0x8C43
#define GL_SRGB8_ALPHA8_EXT 0x8C43
#define GL_SRGB8_EXT 0x8C41
#define GL_SRGB_ALPHA 0x8C42
#define GL_SRGB_ALPHA_EXT 0x8C42
#define GL_SRGB_DECODE_ARB 0x8299
#define GL_SRGB_EXT 0x8C40
#define GL_SRGB_READ 0x8297
#define GL_SRGB_WRITE 0x8298
#define GL_STACK_OVERFLOW 0x0503
#define GL_STACK_UNDERFLOW 0x0504
#define GL_STANDARD_FONT_FORMAT_NV 0x936C
#define GL_STANDARD_FONT_NAME_NV 0x9072
#define GL_STATIC_ATI 0x8760
#define GL_STATIC_COPY 0x88E6
#define GL_STATIC_COPY_ARB 0x88E6
#define GL_STATIC_DRAW 0x88E4
#define GL_STATIC_DRAW_ARB 0x88E4
#define GL_STATIC_READ 0x88E5
#define GL_STATIC_READ_ARB 0x88E5
#define GL_STENCIL 0x1802
#define GL_STENCIL_ATTACHMENT 0x8D20
#define GL_STENCIL_ATTACHMENT_EXT 0x8D20
#define GL_STENCIL_BACK_FAIL 0x8801
#define GL_STENCIL_BACK_FAIL_ATI 0x8801
#define GL_STENCIL_BACK_FUNC 0x8800
#define GL_STENCIL_BACK_FUNC_ATI 0x8800
#define GL_STENCIL_BACK_OP_VALUE_AMD 0x874D
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL 0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI 0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS 0x8803
#define GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI 0x8803
#define GL_STENCIL_BACK_REF 0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK 0x8CA4
#define GL_STENCIL_BACK_WRITEMASK 0x8CA5
#define GL_STENCIL_BUFFER_BIT 0x00000400
#define GL_STENCIL_CLEAR_TAG_VALUE_EXT 0x88F3
#define GL_STENCIL_CLEAR_VALUE 0x0B91
#define GL_STENCIL_COMPONENTS 0x8285
#define GL_STENCIL_FAIL 0x0B94
#define GL_STENCIL_FUNC 0x0B92
#define GL_STENCIL_INDEX 0x1901
#define GL_STENCIL_INDEX1 0x8D46
#define GL_STENCIL_INDEX16 0x8D49
#define GL_STENCIL_INDEX16_EXT 0x8D49
#define GL_STENCIL_INDEX1_EXT 0x8D46
#define GL_STENCIL_INDEX4 0x8D47
#define GL_STENCIL_INDEX4_EXT 0x8D47
#define GL_STENCIL_INDEX8 0x8D48
#define GL_STENCIL_INDEX8_EXT 0x8D48
#define GL_STENCIL_OP_VALUE_AMD 0x874C
#define GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS 0x0B96
#define GL_STENCIL_REF 0x0B97
#define GL_STENCIL_REF_COMMAND_NV 0x000C
#define GL_STENCIL_RENDERABLE 0x8288
#define GL_STENCIL_SAMPLES_NV 0x932E
#define GL_STENCIL_TAG_BITS_EXT 0x88F2
#define GL_STENCIL_TEST 0x0B90
#define GL_STENCIL_TEST_TWO_SIDE_EXT 0x8910
#define GL_STENCIL_VALUE_MASK 0x0B93
#define GL_STENCIL_WRITEMASK 0x0B98
#define GL_STEREO 0x0C33
#define GL_STORAGE_CACHED_APPLE 0x85BE
#define GL_STORAGE_CLIENT_APPLE 0x85B4
#define GL_STORAGE_PRIVATE_APPLE 0x85BD
#define GL_STORAGE_SHARED_APPLE 0x85BF
#define GL_STREAM_COPY 0x88E2
#define GL_STREAM_COPY_ARB 0x88E2
#define GL_STREAM_DRAW 0x88E0
#define GL_STREAM_DRAW_ARB 0x88E0
#define GL_STREAM_RASTERIZATION_AMD 0x91A0
#define GL_STREAM_READ 0x88E1
#define GL_STREAM_READ_ARB 0x88E1
#define GL_SUBPIXEL_BITS 0x0D50
#define GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV 0x9347
#define GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV 0x9348
#define GL_SUBSAMPLE_DISTANCE_AMD 0x883F
#define GL_SUBTRACT_ARB 0x84E7
#define GL_SUB_ATI 0x8965
#define GL_SUCCESS_NV 0x902F
#define GL_SUPERSAMPLE_SCALE_X_NV 0x9372
#define GL_SUPERSAMPLE_SCALE_Y_NV 0x9373
#define GL_SURFACE_MAPPED_NV 0x8700
#define GL_SURFACE_REGISTERED_NV 0x86FD
#define GL_SURFACE_STATE_NV 0x86EB
#define GL_SWIZZLE_STQ_ATI 0x8977
#define GL_SWIZZLE_STQ_DQ_ATI 0x8979
#define GL_SWIZZLE_STRQ_ATI 0x897A
#define GL_SWIZZLE_STRQ_DQ_ATI 0x897B
#define GL_SWIZZLE_STR_ATI 0x8976
#define GL_SWIZZLE_STR_DR_ATI 0x8978
#define GL_SYNC_CL_EVENT_ARB 0x8240
#define GL_SYNC_CL_EVENT_COMPLETE_ARB 0x8241
#define GL_SYNC_CONDITION 0x9113
#define GL_SYNC_FENCE 0x9116
#define GL_SYNC_FLAGS 0x9115
#define GL_SYNC_FLUSH_COMMANDS_BIT 0x00000001
#define GL_SYNC_GPU_COMMANDS_COMPLETE 0x9117
#define GL_SYNC_STATUS 0x9114
#define GL_SYNC_X11_FENCE_EXT 0x90E1
#define GL_SYSTEM_FONT_NAME_NV 0x9073
#define GL_T2F_IUI_N3F_V2F_EXT 0x81B3
#define GL_T2F_IUI_N3F_V3F_EXT 0x81B4
#define GL_T2F_IUI_V2F_EXT 0x81B1
#define GL_T2F_IUI_V3F_EXT 0x81B2
#define GL_TABLE_TOO_LARGE_EXT 0x8031
#define GL_TANGENT_ARRAY_EXT 0x8439
#define GL_TANGENT_ARRAY_POINTER_EXT 0x8442
#define GL_TANGENT_ARRAY_STRIDE_EXT 0x843F
#define GL_TANGENT_ARRAY_TYPE_EXT 0x843E
#define GL_TERMINATE_SEQUENCE_COMMAND_NV 0x0000
#define GL_TESSELLATION_FACTOR_AMD 0x9005
#define GL_TESSELLATION_MODE_AMD 0x9004
#define GL_TESS_CONTROL_OUTPUT_VERTICES 0x8E75
#define GL_TESS_CONTROL_PROGRAM_NV 0x891E
#define GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV 0x8C74
#define GL_TESS_CONTROL_SHADER 0x8E88
#define GL_TESS_CONTROL_SHADER_BIT 0x00000008
#define GL_TESS_CONTROL_SHADER_PATCHES 0x82F1
#define GL_TESS_CONTROL_SHADER_PATCHES_ARB 0x82F1
#define GL_TESS_CONTROL_SUBROUTINE 0x92E9
#define GL_TESS_CONTROL_SUBROUTINE_UNIFORM 0x92EF
#define GL_TESS_CONTROL_TEXTURE 0x829C
#define GL_TESS_EVALUATION_PROGRAM_NV 0x891F
#define GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV 0x8C75
#define GL_TESS_EVALUATION_SHADER 0x8E87
#define GL_TESS_EVALUATION_SHADER_BIT 0x00000010
#define GL_TESS_EVALUATION_SHADER_INVOCATIONS 0x82F2
#define GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB 0x82F2
#define GL_TESS_EVALUATION_SUBROUTINE 0x92EA
#define GL_TESS_EVALUATION_SUBROUTINE_UNIFORM 0x92F0
#define GL_TESS_EVALUATION_TEXTURE 0x829D
#define GL_TESS_GEN_MODE 0x8E76
#define GL_TESS_GEN_POINT_MODE 0x8E79
#define GL_TESS_GEN_SPACING 0x8E77
#define GL_TESS_GEN_VERTEX_ORDER 0x8E78
#define GL_TEXTURE 0x1702
#define GL_TEXTURE0 0x84C0
#define GL_TEXTURE0_ARB 0x84C0
#define GL_TEXTURE1 0x84C1
#define GL_TEXTURE10 0x84CA
#define GL_TEXTURE10_ARB 0x84CA
#define GL_TEXTURE11 0x84CB
#define GL_TEXTURE11_ARB 0x84CB
#define GL_TEXTURE12 0x84CC
#define GL_TEXTURE12_ARB 0x84CC
#define GL_TEXTURE13 0x84CD
#define GL_TEXTURE13_ARB 0x84CD
#define GL_TEXTURE14 0x84CE
#define GL_TEXTURE14_ARB 0x84CE
#define GL_TEXTURE15 0x84CF
#define GL_TEXTURE15_ARB 0x84CF
#define GL_TEXTURE16 0x84D0
#define GL_TEXTURE16_ARB 0x84D0
#define GL_TEXTURE17 0x84D1
#define GL_TEXTURE17_ARB 0x84D1
#define GL_TEXTURE18 0x84D2
#define GL_TEXTURE18_ARB 0x84D2
#define GL_TEXTURE19 0x84D3
#define GL_TEXTURE19_ARB 0x84D3
#define GL_TEXTURE1_ARB 0x84C1
#define GL_TEXTURE2 0x84C2
#define GL_TEXTURE20 0x84D4
#define GL_TEXTURE20_ARB 0x84D4
#define GL_TEXTURE21 0x84D5
#define GL_TEXTURE21_ARB 0x84D5
#define GL_TEXTURE22 0x84D6
#define GL_TEXTURE22_ARB 0x84D6
#define GL_TEXTURE23 0x84D7
#define GL_TEXTURE23_ARB 0x84D7
#define GL_TEXTURE24 0x84D8
#define GL_TEXTURE24_ARB 0x84D8
#define GL_TEXTURE25 0x84D9
#define GL_TEXTURE25_ARB 0x84D9
#define GL_TEXTURE26 0x84DA
#define GL_TEXTURE26_ARB 0x84DA
#define GL_TEXTURE27 0x84DB
#define GL_TEXTURE27_ARB 0x84DB
#define GL_TEXTURE28 0x84DC
#define GL_TEXTURE28_ARB 0x84DC
#define GL_TEXTURE29 0x84DD
#define GL_TEXTURE29_ARB 0x84DD
#define GL_TEXTURE2_ARB 0x84C2
#define GL_TEXTURE3 0x84C3
#define GL_TEXTURE30 0x84DE
#define GL_TEXTURE30_ARB 0x84DE
#define GL_TEXTURE31 0x84DF
#define GL_TEXTURE31_ARB 0x84DF
#define GL_TEXTURE3_ARB 0x84C3
#define GL_TEXTURE4 0x84C4
#define GL_TEXTURE4_ARB 0x84C4
#define GL_TEXTURE5 0x84C5
#define GL_TEXTURE5_ARB 0x84C5
#define GL_TEXTURE6 0x84C6
#define GL_TEXTURE6_ARB 0x84C6
#define GL_TEXTURE7 0x84C7
#define GL_TEXTURE7_ARB 0x84C7
#define GL_TEXTURE8 0x84C8
#define GL_TEXTURE8_ARB 0x84C8
#define GL_TEXTURE9 0x84C9
#define GL_TEXTURE9_ARB 0x84C9
#define GL_TEXTURE_1D 0x0DE0
#define GL_TEXTURE_1D_ARRAY 0x8C18
#define GL_TEXTURE_1D_ARRAY_EXT 0x8C18
#define GL_TEXTURE_1D_BINDING_EXT 0x8068
#define GL_TEXTURE_1D_STACK_BINDING_MESAX 0x875D
#define GL_TEXTURE_1D_STACK_MESAX 0x8759
#define GL_TEXTURE_2D 0x0DE1
#define GL_TEXTURE_2D_ARRAY 0x8C1A
#define GL_TEXTURE_2D_ARRAY_EXT 0x8C1A
#define GL_TEXTURE_2D_BINDING_EXT 0x8069
#define GL_TEXTURE_2D_MULTISAMPLE 0x9100
#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9102
#define GL_TEXTURE_2D_STACK_BINDING_MESAX 0x875E
#define GL_TEXTURE_2D_STACK_MESAX 0x875A
#define GL_TEXTURE_3D 0x806F
#define GL_TEXTURE_3D_BINDING_EXT 0x806A
#define GL_TEXTURE_3D_EXT 0x806F
#define GL_TEXTURE_ALPHA_SIZE 0x805F
#define GL_TEXTURE_ALPHA_SIZE_EXT 0x805F
#define GL_TEXTURE_ALPHA_TYPE 0x8C13
#define GL_TEXTURE_ALPHA_TYPE_ARB 0x8C13
#define GL_TEXTURE_APPLICATION_MODE_EXT 0x834F
#define GL_TEXTURE_BASE_LEVEL 0x813C
#define GL_TEXTURE_BINDING_1D 0x8068
#define GL_TEXTURE_BINDING_1D_ARRAY 0x8C1C
#define GL_TEXTURE_BINDING_1D_ARRAY_EXT 0x8C1C
#define GL_TEXTURE_BINDING_2D 0x8069
#define GL_TEXTURE_BINDING_2D_ARRAY 0x8C1D
#define GL_TEXTURE_BINDING_2D_ARRAY_EXT 0x8C1D
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
#define GL_TEXTURE_BINDING_3D 0x806A
#define GL_TEXTURE_BINDING_BUFFER 0x8C2C
#define GL_TEXTURE_BINDING_BUFFER_ARB 0x8C2C
#define GL_TEXTURE_BINDING_BUFFER_EXT 0x8C2C
#define GL_TEXTURE_BINDING_CUBE_MAP 0x8514
#define GL_TEXTURE_BINDING_CUBE_MAP_ARB 0x8514
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB 0x900A
#define GL_TEXTURE_BINDING_CUBE_MAP_EXT 0x8514
#define GL_TEXTURE_BINDING_RECTANGLE 0x84F6
#define GL_TEXTURE_BINDING_RECTANGLE_ARB 0x84F6
#define GL_TEXTURE_BINDING_RECTANGLE_NV 0x84F6
#define GL_TEXTURE_BINDING_RENDERBUFFER_NV 0x8E53
#define GL_TEXTURE_BLUE_SIZE 0x805E
#define GL_TEXTURE_BLUE_SIZE_EXT 0x805E
#define GL_TEXTURE_BLUE_TYPE 0x8C12
#define GL_TEXTURE_BLUE_TYPE_ARB 0x8C12
#define GL_TEXTURE_BORDER_COLOR 0x1004
#define GL_TEXTURE_BORDER_VALUES_NV 0x871A
#define GL_TEXTURE_BUFFER 0x8C2A
#define GL_TEXTURE_BUFFER_ARB 0x8C2A
#define GL_TEXTURE_BUFFER_BINDING 0x8C2A
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB 0x8C2D
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT 0x8C2D
#define GL_TEXTURE_BUFFER_EXT 0x8C2A
#define GL_TEXTURE_BUFFER_FORMAT_ARB 0x8C2E
#define GL_TEXTURE_BUFFER_FORMAT_EXT 0x8C2E
#define GL_TEXTURE_BUFFER_OFFSET 0x919D
#define GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT 0x919F
#define GL_TEXTURE_BUFFER_SIZE 0x919E
#define GL_TEXTURE_COLOR_SAMPLES_NV 0x9046
#define GL_TEXTURE_COMPARE_FAIL_VALUE_ARB 0x80BF
#define GL_TEXTURE_COMPARE_FUNC 0x884D
#define GL_TEXTURE_COMPARE_FUNC_ARB 0x884D
#define GL_TEXTURE_COMPARE_MODE 0x884C
#define GL_TEXTURE_COMPARE_MODE_ARB 0x884C
#define GL_TEXTURE_COMPRESSED 0x86A1
#define GL_TEXTURE_COMPRESSED_ARB 0x86A1
#define GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT 0x82B2
#define GL_TEXTURE_COMPRESSED_BLOCK_SIZE 0x82B3
#define GL_TEXTURE_COMPRESSED_BLOCK_WIDTH 0x82B1
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE 0x86A0
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB 0x86A0
#define GL_TEXTURE_COMPRESSION_HINT 0x84EF
#define GL_TEXTURE_COMPRESSION_HINT_ARB 0x84EF
#define GL_TEXTURE_COORD_ARRAY_ADDRESS_NV 0x8F25
#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB 0x889A
#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT 0x808B
#define GL_TEXTURE_COORD_ARRAY_EXT 0x8078
#define GL_TEXTURE_COORD_ARRAY_LENGTH_NV 0x8F2F
#define GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL 0x83F8
#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT 0x8088
#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT 0x8089
#define GL_TEXTURE_COORD_NV 0x8C79
#define GL_TEXTURE_COVERAGE_SAMPLES_NV 0x9045
#define GL_TEXTURE_CUBE_MAP 0x8513
#define GL_TEXTURE_CUBE_MAP_ARB 0x8513
#define GL_TEXTURE_CUBE_MAP_ARRAY 0x9009
#define GL_TEXTURE_CUBE_MAP_ARRAY_ARB 0x9009
#define GL_TEXTURE_CUBE_MAP_EXT 0x8513
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x8516
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT 0x8516
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x8518
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT 0x8518
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x851A
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT 0x851A
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x8515
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT 0x8515
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x8517
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT 0x8517
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x8519
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT 0x8519
#define GL_TEXTURE_CUBE_MAP_SEAMLESS 0x884F
#define GL_TEXTURE_DEPTH 0x8071
#define GL_TEXTURE_DEPTH_EXT 0x8071
#define GL_TEXTURE_DEPTH_SIZE 0x884A
#define GL_TEXTURE_DEPTH_SIZE_ARB 0x884A
#define GL_TEXTURE_DEPTH_TYPE 0x8C16
#define GL_TEXTURE_DEPTH_TYPE_ARB 0x8C16
#define GL_TEXTURE_DS_SIZE_NV 0x871D
#define GL_TEXTURE_DT_SIZE_NV 0x871E
#define GL_TEXTURE_FETCH_BARRIER_BIT 0x00000008
#define GL_TEXTURE_FETCH_BARRIER_BIT_EXT 0x00000008
#define GL_TEXTURE_FILTER_CONTROL_EXT 0x8500
#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
#define GL_TEXTURE_FLOAT_COMPONENTS_NV 0x888C
#define GL_TEXTURE_FREE_MEMORY_ATI 0x87FC
#define GL_TEXTURE_GATHER 0x82A2
#define GL_TEXTURE_GATHER_SHADOW 0x82A3
#define GL_TEXTURE_GREEN_SIZE 0x805D
#define GL_TEXTURE_GREEN_SIZE_EXT 0x805D
#define GL_TEXTURE_GREEN_TYPE 0x8C11
#define GL_TEXTURE_GREEN_TYPE_ARB 0x8C11
#define GL_TEXTURE_HEIGHT 0x1001
#define GL_TEXTURE_HI_SIZE_NV 0x871B
#define GL_TEXTURE_IMAGE_FORMAT 0x828F
#define GL_TEXTURE_IMAGE_TYPE 0x8290
#define GL_TEXTURE_IMMUTABLE_FORMAT 0x912F
#define GL_TEXTURE_IMMUTABLE_LEVELS 0x82DF
#define GL_TEXTURE_INDEX_SIZE_EXT 0x80ED
#define GL_TEXTURE_INTENSITY_SIZE_EXT 0x8061
#define GL_TEXTURE_INTENSITY_TYPE_ARB 0x8C15
#define GL_TEXTURE_INTERNAL_FORMAT 0x1003
#define GL_TEXTURE_LIGHT_EXT 0x8350
#define GL_TEXTURE_LOD_BIAS 0x8501
#define GL_TEXTURE_LOD_BIAS_EXT 0x8501
#define GL_TEXTURE_LO_SIZE_NV 0x871C
#define GL_TEXTURE_LUMINANCE_SIZE_EXT 0x8060
#define GL_TEXTURE_LUMINANCE_TYPE_ARB 0x8C14
#define GL_TEXTURE_MAG_FILTER 0x2800
#define GL_TEXTURE_MAG_SIZE_NV 0x871F
#define GL_TEXTURE_MATERIAL_FACE_EXT 0x8351
#define GL_TEXTURE_MATERIAL_PARAMETER_EXT 0x8352
#define GL_TEXTURE_MAX_ANISOTROPY 0x84FE
#define GL_TEXTURE_MAX_ANISOTROPY_EXT 0x84FE
#define GL_TEXTURE_MAX_LEVEL 0x813D
#define GL_TEXTURE_MAX_LOD 0x813B
#define GL_TEXTURE_MEMORY_LAYOUT_INTEL 0x83FF
#define GL_TEXTURE_MIN_FILTER 0x2801
#define GL_TEXTURE_MIN_LOD 0x813A
#define GL_TEXTURE_NORMAL_EXT 0x85AF
#define GL_TEXTURE_PRIORITY_EXT 0x8066
#define GL_TEXTURE_RANGE_LENGTH_APPLE 0x85B7
#define GL_TEXTURE_RANGE_POINTER_APPLE 0x85B8
#define GL_TEXTURE_RECTANGLE 0x84F5
#define GL_TEXTURE_RECTANGLE_ARB 0x84F5
#define GL_TEXTURE_RECTANGLE_NV 0x84F5
#define GL_TEXTURE_REDUCTION_MODE_ARB 0x9366
#define GL_TEXTURE_REDUCTION_MODE_EXT 0x9366
#define GL_TEXTURE_RED_SIZE 0x805C
#define GL_TEXTURE_RED_SIZE_EXT 0x805C
#define GL_TEXTURE_RED_TYPE 0x8C10
#define GL_TEXTURE_RED_TYPE_ARB 0x8C10
#define GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV 0x8E54
#define GL_TEXTURE_RENDERBUFFER_NV 0x8E55
#define GL_TEXTURE_RESIDENT_EXT 0x8067
#define GL_TEXTURE_SAMPLES 0x9106
#define GL_TEXTURE_SHADER_NV 0x86DE
#define GL_TEXTURE_SHADOW 0x82A1
#define GL_TEXTURE_SHARED_SIZE 0x8C3F
#define GL_TEXTURE_SHARED_SIZE_EXT 0x8C3F
#define GL_TEXTURE_SPARSE_ARB 0x91A6
#define GL_TEXTURE_SRGB_DECODE_EXT 0x8A48
#define GL_TEXTURE_STENCIL_SIZE 0x88F1
#define GL_TEXTURE_STENCIL_SIZE_EXT 0x88F1
#define GL_TEXTURE_STORAGE_HINT_APPLE 0x85BC
#define GL_TEXTURE_STORAGE_SPARSE_BIT_AMD 0x00000001
#define GL_TEXTURE_SWIZZLE_A 0x8E45
#define GL_TEXTURE_SWIZZLE_A_EXT 0x8E45
#define GL_TEXTURE_SWIZZLE_B 0x8E44
#define GL_TEXTURE_SWIZZLE_B_EXT 0x8E44
#define GL_TEXTURE_SWIZZLE_G 0x8E43
#define GL_TEXTURE_SWIZZLE_G_EXT 0x8E43
#define GL_TEXTURE_SWIZZLE_R 0x8E42
#define GL_TEXTURE_SWIZZLE_RGBA 0x8E46
#define GL_TEXTURE_SWIZZLE_RGBA_EXT 0x8E46
#define GL_TEXTURE_SWIZZLE_R_EXT 0x8E42
#define GL_TEXTURE_TARGET 0x1006
#define GL_TEXTURE_TILING_EXT 0x9580
#define GL_TEXTURE_TOO_LARGE_EXT 0x8065
#define GL_TEXTURE_UNSIGNED_REMAP_MODE_NV 0x888F
#define GL_TEXTURE_UPDATE_BARRIER_BIT 0x00000100
#define GL_TEXTURE_UPDATE_BARRIER_BIT_EXT 0x00000100
#define GL_TEXTURE_VIEW 0x82B5
#define GL_TEXTURE_VIEW_MIN_LAYER 0x82DD
#define GL_TEXTURE_VIEW_MIN_LEVEL 0x82DB
#define GL_TEXTURE_VIEW_NUM_LAYERS 0x82DE
#define GL_TEXTURE_VIEW_NUM_LEVELS 0x82DC
#define GL_TEXTURE_WIDTH 0x1000
#define GL_TEXTURE_WRAP_R 0x8072
#define GL_TEXTURE_WRAP_R_EXT 0x8072
#define GL_TEXTURE_WRAP_S 0x2802
#define GL_TEXTURE_WRAP_T 0x2803
#define GL_TEXT_FRAGMENT_SHADER_ATI 0x8200
#define GL_TILING_TYPES_EXT 0x9583
#define GL_TIMEOUT_EXPIRED 0x911B
#define GL_TIMEOUT_IGNORED 0xFFFFFFFFFFFFFFFF
#define GL_TIMESTAMP 0x8E28
#define GL_TIME_ELAPSED 0x88BF
#define GL_TIME_ELAPSED_EXT 0x88BF
#define GL_TOP_LEVEL_ARRAY_SIZE 0x930C
#define GL_TOP_LEVEL_ARRAY_STRIDE 0x930D
#define GL_TRACK_MATRIX_NV 0x8648
#define GL_TRACK_MATRIX_TRANSFORM_NV 0x8649
#define GL_TRANSFORM_FEEDBACK 0x8E22
#define GL_TRANSFORM_FEEDBACK_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_ATTRIBS_NV 0x8C7E
#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT 0x00000800
#define GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT 0x00000800
#define GL_TRANSFORM_FEEDBACK_BINDING 0x8E25
#define GL_TRANSFORM_FEEDBACK_BINDING_NV 0x8E25
#define GL_TRANSFORM_FEEDBACK_BUFFER 0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV 0x8E24
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT 0x8C8F
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV 0x8C8F
#define GL_TRANSFORM_FEEDBACK_BUFFER_EXT 0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_INDEX 0x934B
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT 0x8C7F
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV 0x8C7F
#define GL_TRANSFORM_FEEDBACK_BUFFER_NV 0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED 0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV 0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT 0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV 0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_START_NV 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE 0x934C
#define GL_TRANSFORM_FEEDBACK_NV 0x8E22
#define GL_TRANSFORM_FEEDBACK_OVERFLOW 0x82EC
#define GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB 0x82EC
#define GL_TRANSFORM_FEEDBACK_PAUSED 0x8E23
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT 0x8C88
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV 0x8C88
#define GL_TRANSFORM_FEEDBACK_RECORD_NV 0x8C86
#define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW 0x82ED
#define GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB 0x82ED
#define GL_TRANSFORM_FEEDBACK_VARYING 0x92F4
#define GL_TRANSFORM_FEEDBACK_VARYINGS 0x8C83
#define GL_TRANSFORM_FEEDBACK_VARYINGS_EXT 0x8C83
#define GL_TRANSFORM_FEEDBACK_VARYINGS_NV 0x8C83
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT 0x8C76
#define GL_TRANSFORM_HINT_APPLE 0x85B1
#define GL_TRANSLATE_2D_NV 0x9090
#define GL_TRANSLATE_3D_NV 0x9091
#define GL_TRANSLATE_X_NV 0x908E
#define GL_TRANSLATE_Y_NV 0x908F
#define GL_TRANSPOSE_AFFINE_2D_NV 0x9096
#define GL_TRANSPOSE_AFFINE_3D_NV 0x9098
#define GL_TRANSPOSE_COLOR_MATRIX_ARB 0x84E6
#define GL_TRANSPOSE_CURRENT_MATRIX_ARB 0x88B7
#define GL_TRANSPOSE_MODELVIEW_MATRIX_ARB 0x84E3
#define GL_TRANSPOSE_NV 0x862C
#define GL_TRANSPOSE_PROGRAM_MATRIX_EXT 0x8E2E
#define GL_TRANSPOSE_PROJECTION_MATRIX_ARB 0x84E4
#define GL_TRANSPOSE_TEXTURE_MATRIX_ARB 0x84E5
#define GL_TRIANGLES 0x0004
#define GL_TRIANGLES_ADJACENCY 0x000C
#define GL_TRIANGLES_ADJACENCY_ARB 0x000C
#define GL_TRIANGLES_ADJACENCY_EXT 0x000C
#define GL_TRIANGLE_FAN 0x0006
#define GL_TRIANGLE_STRIP 0x0005
#define GL_TRIANGLE_STRIP_ADJACENCY 0x000D
#define GL_TRIANGLE_STRIP_ADJACENCY_ARB 0x000D
#define GL_TRIANGLE_STRIP_ADJACENCY_EXT 0x000D
#define GL_TRIANGULAR_NV 0x90A5
#define GL_TRUE 1
#define GL_TYPE 0x92FA
#define GL_UNCORRELATED_NV 0x9282
#define GL_UNDEFINED_APPLE 0x8A1C
#define GL_UNDEFINED_VERTEX 0x8260
#define GL_UNIFORM 0x92E1
#define GL_UNIFORM_ADDRESS_COMMAND_NV 0x000A
#define GL_UNIFORM_ARRAY_STRIDE 0x8A3C
#define GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX 0x92DA
#define GL_UNIFORM_BARRIER_BIT 0x00000004
#define GL_UNIFORM_BARRIER_BIT_EXT 0x00000004
#define GL_UNIFORM_BLOCK 0x92E2
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS 0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_BINDING 0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE 0x8A40
#define GL_UNIFORM_BLOCK_INDEX 0x8A3A
#define GL_UNIFORM_BLOCK_NAME_LENGTH 0x8A41
#define GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER 0x90EC
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER 0x84F0
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BUFFER 0x8A11
#define GL_UNIFORM_BUFFER_ADDRESS_NV 0x936F
#define GL_UNIFORM_BUFFER_BINDING 0x8A28
#define GL_UNIFORM_BUFFER_BINDING_EXT 0x8DEF
#define GL_UNIFORM_BUFFER_EXT 0x8DEE
#define GL_UNIFORM_BUFFER_LENGTH_NV 0x9370
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_UNIFORM_BUFFER_SIZE 0x8A2A
#define GL_UNIFORM_BUFFER_START 0x8A29
#define GL_UNIFORM_BUFFER_UNIFIED_NV 0x936E
#define GL_UNIFORM_IS_ROW_MAJOR 0x8A3E
#define GL_UNIFORM_MATRIX_STRIDE 0x8A3D
#define GL_UNIFORM_NAME_LENGTH 0x8A39
#define GL_UNIFORM_OFFSET 0x8A3B
#define GL_UNIFORM_SIZE 0x8A38
#define GL_UNIFORM_TYPE 0x8A37
#define GL_UNKNOWN_CONTEXT_RESET 0x8255
#define GL_UNKNOWN_CONTEXT_RESET_ARB 0x8255
#define GL_UNPACK_ALIGNMENT 0x0CF5
#define GL_UNPACK_CLIENT_STORAGE_APPLE 0x85B2
#define GL_UNPACK_CMYK_HINT_EXT 0x800F
#define GL_UNPACK_COMPRESSED_BLOCK_DEPTH 0x9129
#define GL_UNPACK_COMPRESSED_BLOCK_HEIGHT 0x9128
#define GL_UNPACK_COMPRESSED_BLOCK_SIZE 0x912A
#define GL_UNPACK_COMPRESSED_BLOCK_WIDTH 0x9127
#define GL_UNPACK_IMAGE_HEIGHT 0x806E
#define GL_UNPACK_IMAGE_HEIGHT_EXT 0x806E
#define GL_UNPACK_LSB_FIRST 0x0CF1
#define GL_UNPACK_ROW_BYTES_APPLE 0x8A16
#define GL_UNPACK_ROW_LENGTH 0x0CF2
#define GL_UNPACK_SKIP_IMAGES 0x806D
#define GL_UNPACK_SKIP_IMAGES_EXT 0x806D
#define GL_UNPACK_SKIP_PIXELS 0x0CF4
#define GL_UNPACK_SKIP_ROWS 0x0CF3
#define GL_UNPACK_SWAP_BYTES 0x0CF0
#define GL_UNSIGNALED 0x9118
#define GL_UNSIGNED_BYTE 0x1401
#define GL_UNSIGNED_BYTE_2_3_3_REV 0x8362
#define GL_UNSIGNED_BYTE_3_3_2 0x8032
#define GL_UNSIGNED_BYTE_3_3_2_EXT 0x8032
#define GL_UNSIGNED_IDENTITY_NV 0x8536
#define GL_UNSIGNED_INT 0x1405
#define GL_UNSIGNED_INT16_NV 0x8FF0
#define GL_UNSIGNED_INT16_VEC2_NV 0x8FF1
#define GL_UNSIGNED_INT16_VEC3_NV 0x8FF2
#define GL_UNSIGNED_INT16_VEC4_NV 0x8FF3
#define GL_UNSIGNED_INT64_AMD 0x8BC2
#define GL_UNSIGNED_INT64_ARB 0x140F
#define GL_UNSIGNED_INT64_NV 0x140F
#define GL_UNSIGNED_INT64_VEC2_ARB 0x8FF5
#define GL_UNSIGNED_INT64_VEC2_NV 0x8FF5
#define GL_UNSIGNED_INT64_VEC3_ARB 0x8FF6
#define GL_UNSIGNED_INT64_VEC3_NV 0x8FF6
#define GL_UNSIGNED_INT64_VEC4_ARB 0x8FF7
#define GL_UNSIGNED_INT64_VEC4_NV 0x8FF7
#define GL_UNSIGNED_INT8_NV 0x8FEC
#define GL_UNSIGNED_INT8_VEC2_NV 0x8FED
#define GL_UNSIGNED_INT8_VEC3_NV 0x8FEE
#define GL_UNSIGNED_INT8_VEC4_NV 0x8FEF
#define GL_UNSIGNED_INT_10F_11F_11F_REV 0x8C3B
#define GL_UNSIGNED_INT_10F_11F_11F_REV_EXT 0x8C3B
#define GL_UNSIGNED_INT_10_10_10_2 0x8036
#define GL_UNSIGNED_INT_10_10_10_2_EXT 0x8036
#define GL_UNSIGNED_INT_24_8 0x84FA
#define GL_UNSIGNED_INT_24_8_EXT 0x84FA
#define GL_UNSIGNED_INT_24_8_NV 0x84FA
#define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
#define GL_UNSIGNED_INT_5_9_9_9_REV 0x8C3E
#define GL_UNSIGNED_INT_5_9_9_9_REV_EXT 0x8C3E
#define GL_UNSIGNED_INT_8_8_8_8 0x8035
#define GL_UNSIGNED_INT_8_8_8_8_EXT 0x8035
#define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV 0x86DB
#define GL_UNSIGNED_INT_ATOMIC_COUNTER 0x92DB
#define GL_UNSIGNED_INT_IMAGE_1D 0x9062
#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY 0x9068
#define GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT 0x9068
#define GL_UNSIGNED_INT_IMAGE_1D_EXT 0x9062
#define GL_UNSIGNED_INT_IMAGE_2D 0x9063
#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY 0x9069
#define GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT 0x9069
#define GL_UNSIGNED_INT_IMAGE_2D_EXT 0x9063
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE 0x906B
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY 0x906C
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT 0x906C
#define GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT 0x906B
#define GL_UNSIGNED_INT_IMAGE_2D_RECT 0x9065
#define GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT 0x9065
#define GL_UNSIGNED_INT_IMAGE_3D 0x9064
#define GL_UNSIGNED_INT_IMAGE_3D_EXT 0x9064
#define GL_UNSIGNED_INT_IMAGE_BUFFER 0x9067
#define GL_UNSIGNED_INT_IMAGE_BUFFER_EXT 0x9067
#define GL_UNSIGNED_INT_IMAGE_CUBE 0x9066
#define GL_UNSIGNED_INT_IMAGE_CUBE_EXT 0x9066
#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY 0x906A
#define GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT 0x906A
#define GL_UNSIGNED_INT_S8_S8_8_8_NV 0x86DA
#define GL_UNSIGNED_INT_SAMPLER_1D 0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY 0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT 0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_1D_EXT 0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_2D 0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY 0x8DD7
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT 0x8DD7
#define GL_UNSIGNED_INT_SAMPLER_2D_EXT 0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT 0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT 0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_3D 0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_3D_EXT 0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_BUFFER 0x8DD8
#define GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD 0x9003
#define GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT 0x8DD8
#define GL_UNSIGNED_INT_SAMPLER_CUBE 0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_CUBE_EXT 0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900F
#define GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV 0x8E58
#define GL_UNSIGNED_INT_VEC2 0x8DC6
#define GL_UNSIGNED_INT_VEC2_EXT 0x8DC6
#define GL_UNSIGNED_INT_VEC3 0x8DC7
#define GL_UNSIGNED_INT_VEC3_EXT 0x8DC7
#define GL_UNSIGNED_INT_VEC4 0x8DC8
#define GL_UNSIGNED_INT_VEC4_EXT 0x8DC8
#define GL_UNSIGNED_INVERT_NV 0x8537
#define GL_UNSIGNED_NORMALIZED 0x8C17
#define GL_UNSIGNED_NORMALIZED_ARB 0x8C17
#define GL_UNSIGNED_SHORT 0x1403
#define GL_UNSIGNED_SHORT_1_5_5_5_REV 0x8366
#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
#define GL_UNSIGNED_SHORT_4_4_4_4_EXT 0x8033
#define GL_UNSIGNED_SHORT_4_4_4_4_REV 0x8365
#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
#define GL_UNSIGNED_SHORT_5_5_5_1_EXT 0x8034
#define GL_UNSIGNED_SHORT_5_6_5 0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV 0x8364
#define GL_UNSIGNED_SHORT_8_8_APPLE 0x85BA
#define GL_UNSIGNED_SHORT_8_8_MESA 0x85BA
#define GL_UNSIGNED_SHORT_8_8_REV_APPLE 0x85BB
#define GL_UNSIGNED_SHORT_8_8_REV_MESA 0x85BB
#define GL_UPPER_LEFT 0x8CA2
#define GL_USE_MISSING_GLYPH_NV 0x90AA
#define GL_UTF16_NV 0x909B
#define GL_UTF8_NV 0x909A
#define GL_UUID_SIZE_EXT 16
#define GL_VALIDATE_STATUS 0x8B83
#define GL_VARIABLE_A_NV 0x8523
#define GL_VARIABLE_B_NV 0x8524
#define GL_VARIABLE_C_NV 0x8525
#define GL_VARIABLE_D_NV 0x8526
#define GL_VARIABLE_E_NV 0x8527
#define GL_VARIABLE_F_NV 0x8528
#define GL_VARIABLE_G_NV 0x8529
#define GL_VARIANT_ARRAY_EXT 0x87E8
#define GL_VARIANT_ARRAY_POINTER_EXT 0x87E9
#define GL_VARIANT_ARRAY_STRIDE_EXT 0x87E6
#define GL_VARIANT_ARRAY_TYPE_EXT 0x87E7
#define GL_VARIANT_DATATYPE_EXT 0x87E5
#define GL_VARIANT_EXT 0x87C1
#define GL_VARIANT_VALUE_EXT 0x87E4
#define GL_VBO_FREE_MEMORY_ATI 0x87FB
#define GL_VECTOR_EXT 0x87BF
#define GL_VENDOR 0x1F00
#define GL_VERSION 0x1F02
#define GL_VERTEX_ARRAY 0x8074
#define GL_VERTEX_ARRAY_ADDRESS_NV 0x8F21
#define GL_VERTEX_ARRAY_BINDING 0x85B5
#define GL_VERTEX_ARRAY_BINDING_APPLE 0x85B5
#define GL_VERTEX_ARRAY_BUFFER_BINDING_ARB 0x8896
#define GL_VERTEX_ARRAY_COUNT_EXT 0x807D
#define GL_VERTEX_ARRAY_EXT 0x8074
#define GL_VERTEX_ARRAY_LENGTH_NV 0x8F2B
#define GL_VERTEX_ARRAY_OBJECT_AMD 0x9154
#define GL_VERTEX_ARRAY_OBJECT_EXT 0x9154
#define GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL 0x83F5
#define GL_VERTEX_ARRAY_POINTER_EXT 0x808E
#define GL_VERTEX_ARRAY_RANGE_APPLE 0x851D
#define GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE 0x851E
#define GL_VERTEX_ARRAY_RANGE_LENGTH_NV 0x851E
#define GL_VERTEX_ARRAY_RANGE_NV 0x851D
#define GL_VERTEX_ARRAY_RANGE_POINTER_APPLE 0x8521
#define GL_VERTEX_ARRAY_RANGE_POINTER_NV 0x8521
#define GL_VERTEX_ARRAY_RANGE_VALID_NV 0x851F
#define GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV 0x8533
#define GL_VERTEX_ARRAY_SIZE_EXT 0x807A
#define GL_VERTEX_ARRAY_STORAGE_HINT_APPLE 0x851F
#define GL_VERTEX_ARRAY_STRIDE_EXT 0x807C
#define GL_VERTEX_ARRAY_TYPE_EXT 0x807B
#define GL_VERTEX_ATTRIB_ARRAY0_NV 0x8650
#define GL_VERTEX_ATTRIB_ARRAY10_NV 0x865A
#define GL_VERTEX_ATTRIB_ARRAY11_NV 0x865B
#define GL_VERTEX_ATTRIB_ARRAY12_NV 0x865C
#define GL_VERTEX_ATTRIB_ARRAY13_NV 0x865D
#define GL_VERTEX_ATTRIB_ARRAY14_NV 0x865E
#define GL_VERTEX_ATTRIB_ARRAY15_NV 0x865F
#define GL_VERTEX_ATTRIB_ARRAY1_NV 0x8651
#define GL_VERTEX_ATTRIB_ARRAY2_NV 0x8652
#define GL_VERTEX_ATTRIB_ARRAY3_NV 0x8653
#define GL_VERTEX_ATTRIB_ARRAY4_NV 0x8654
#define GL_VERTEX_ATTRIB_ARRAY5_NV 0x8655
#define GL_VERTEX_ATTRIB_ARRAY6_NV 0x8656
#define GL_VERTEX_ATTRIB_ARRAY7_NV 0x8657
#define GL_VERTEX_ATTRIB_ARRAY8_NV 0x8658
#define GL_VERTEX_ATTRIB_ARRAY9_NV 0x8659
#define GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV 0x8F20
#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT 0x00000001
#define GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT 0x00000001
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB 0x889F
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR 0x88FE
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB 0x88FE
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED 0x8622
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB 0x8622
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER 0x88FD
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT 0x88FD
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV 0x88FD
#define GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV 0x8F2A
#define GL_VERTEX_ATTRIB_ARRAY_LONG 0x874E
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB 0x886A
#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB 0x8645
#define GL_VERTEX_ATTRIB_ARRAY_SIZE 0x8623
#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB 0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE 0x8624
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB 0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE 0x8625
#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB 0x8625
#define GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV 0x8F1E
#define GL_VERTEX_ATTRIB_BINDING 0x82D4
#define GL_VERTEX_ATTRIB_MAP1_APPLE 0x8A00
#define GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE 0x8A03
#define GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE 0x8A05
#define GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE 0x8A04
#define GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE 0x8A02
#define GL_VERTEX_ATTRIB_MAP2_APPLE 0x8A01
#define GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE 0x8A07
#define GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE 0x8A09
#define GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE 0x8A08
#define GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE 0x8A06
#define GL_VERTEX_ATTRIB_RELATIVE_OFFSET 0x82D5
#define GL_VERTEX_BINDING_BUFFER 0x8F4F
#define GL_VERTEX_BINDING_DIVISOR 0x82D6
#define GL_VERTEX_BINDING_OFFSET 0x82D7
#define GL_VERTEX_BINDING_STRIDE 0x82D8
#define GL_VERTEX_BLEND_ARB 0x86A7
#define GL_VERTEX_ELEMENT_SWIZZLE_AMD 0x91A4
#define GL_VERTEX_ID_NV 0x8C7B
#define GL_VERTEX_ID_SWIZZLE_AMD 0x91A5
#define GL_VERTEX_PROGRAM_ARB 0x8620
#define GL_VERTEX_PROGRAM_BINDING_NV 0x864A
#define GL_VERTEX_PROGRAM_NV 0x8620
#define GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV 0x8DA2
#define GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB 0x8642
#define GL_VERTEX_PROGRAM_POINT_SIZE_NV 0x8642
#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB 0x8643
#define GL_VERTEX_PROGRAM_TWO_SIDE_NV 0x8643
#define GL_VERTEX_SHADER 0x8B31
#define GL_VERTEX_SHADER_ARB 0x8B31
#define GL_VERTEX_SHADER_BINDING_EXT 0x8781
#define GL_VERTEX_SHADER_BIT 0x00000001
#define GL_VERTEX_SHADER_EXT 0x8780
#define GL_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CF
#define GL_VERTEX_SHADER_INVARIANTS_EXT 0x87D1
#define GL_VERTEX_SHADER_INVOCATIONS 0x82F0
#define GL_VERTEX_SHADER_INVOCATIONS_ARB 0x82F0
#define GL_VERTEX_SHADER_LOCALS_EXT 0x87D3
#define GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87D2
#define GL_VERTEX_SHADER_OPTIMIZED_EXT 0x87D4
#define GL_VERTEX_SHADER_VARIANTS_EXT 0x87D0
#define GL_VERTEX_SOURCE_ATI 0x8774
#define GL_VERTEX_STATE_PROGRAM_NV 0x8621
#define GL_VERTEX_STREAM0_ATI 0x876C
#define GL_VERTEX_STREAM1_ATI 0x876D
#define GL_VERTEX_STREAM2_ATI 0x876E
#define GL_VERTEX_STREAM3_ATI 0x876F
#define GL_VERTEX_STREAM4_ATI 0x8770
#define GL_VERTEX_STREAM5_ATI 0x8771
#define GL_VERTEX_STREAM6_ATI 0x8772
#define GL_VERTEX_STREAM7_ATI 0x8773
#define GL_VERTEX_SUBROUTINE 0x92E8
#define GL_VERTEX_SUBROUTINE_UNIFORM 0x92EE
#define GL_VERTEX_TEXTURE 0x829B
#define GL_VERTEX_WEIGHTING_EXT 0x8509
#define GL_VERTEX_WEIGHT_ARRAY_EXT 0x850C
#define GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT 0x8510
#define GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT 0x850D
#define GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT 0x850F
#define GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT 0x850E
#define GL_VERTICAL_LINE_TO_NV 0x08
#define GL_VERTICES_SUBMITTED 0x82EE
#define GL_VERTICES_SUBMITTED_ARB 0x82EE
#define GL_VIBRANCE_BIAS_NV 0x8719
#define GL_VIBRANCE_SCALE_NV 0x8713
#define GL_VIDEO_BUFFER_BINDING_NV 0x9021
#define GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV 0x902D
#define GL_VIDEO_BUFFER_NV 0x9020
#define GL_VIDEO_BUFFER_PITCH_NV 0x9028
#define GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV 0x903B
#define GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV 0x903A
#define GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV 0x9039
#define GL_VIDEO_CAPTURE_FRAME_WIDTH_NV 0x9038
#define GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV 0x903C
#define GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV 0x9026
#define GL_VIDEO_COLOR_CONVERSION_MATRIX_NV 0x9029
#define GL_VIDEO_COLOR_CONVERSION_MAX_NV 0x902A
#define GL_VIDEO_COLOR_CONVERSION_MIN_NV 0x902B
#define GL_VIDEO_COLOR_CONVERSION_OFFSET_NV 0x902C
#define GL_VIEWPORT 0x0BA2
#define GL_VIEWPORT_BOUNDS_RANGE 0x825D
#define GL_VIEWPORT_COMMAND_NV 0x0010
#define GL_VIEWPORT_INDEX_PROVOKING_VERTEX 0x825F
#define GL_VIEWPORT_POSITION_W_SCALE_NV 0x937C
#define GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV 0x937D
#define GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV 0x937E
#define GL_VIEWPORT_SUBPIXEL_BITS 0x825C
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV 0x9357
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV 0x9351
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV 0x9353
#define GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV 0x9355
#define GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV 0x9356
#define GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV 0x9350
#define GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV 0x9352
#define GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV 0x9354
#define GL_VIEWPORT_SWIZZLE_W_NV 0x935B
#define GL_VIEWPORT_SWIZZLE_X_NV 0x9358
#define GL_VIEWPORT_SWIZZLE_Y_NV 0x9359
#define GL_VIEWPORT_SWIZZLE_Z_NV 0x935A
#define GL_VIEW_CLASS_128_BITS 0x82C4
#define GL_VIEW_CLASS_16_BITS 0x82CA
#define GL_VIEW_CLASS_24_BITS 0x82C9
#define GL_VIEW_CLASS_32_BITS 0x82C8
#define GL_VIEW_CLASS_48_BITS 0x82C7
#define GL_VIEW_CLASS_64_BITS 0x82C6
#define GL_VIEW_CLASS_8_BITS 0x82CB
#define GL_VIEW_CLASS_96_BITS 0x82C5
#define GL_VIEW_CLASS_ASTC_10x10_RGBA 0x9393
#define GL_VIEW_CLASS_ASTC_10x5_RGBA 0x9390
#define GL_VIEW_CLASS_ASTC_10x6_RGBA 0x9391
#define GL_VIEW_CLASS_ASTC_10x8_RGBA 0x9392
#define GL_VIEW_CLASS_ASTC_12x10_RGBA 0x9394
#define GL_VIEW_CLASS_ASTC_12x12_RGBA 0x9395
#define GL_VIEW_CLASS_ASTC_4x4_RGBA 0x9388
#define GL_VIEW_CLASS_ASTC_5x4_RGBA 0x9389
#define GL_VIEW_CLASS_ASTC_5x5_RGBA 0x938A
#define GL_VIEW_CLASS_ASTC_6x5_RGBA 0x938B
#define GL_VIEW_CLASS_ASTC_6x6_RGBA 0x938C
#define GL_VIEW_CLASS_ASTC_8x5_RGBA 0x938D
#define GL_VIEW_CLASS_ASTC_8x6_RGBA 0x938E
#define GL_VIEW_CLASS_ASTC_8x8_RGBA 0x938F
#define GL_VIEW_CLASS_BPTC_FLOAT 0x82D3
#define GL_VIEW_CLASS_BPTC_UNORM 0x82D2
#define GL_VIEW_CLASS_EAC_R11 0x9383
#define GL_VIEW_CLASS_EAC_RG11 0x9384
#define GL_VIEW_CLASS_ETC2_EAC_RGBA 0x9387
#define GL_VIEW_CLASS_ETC2_RGB 0x9385
#define GL_VIEW_CLASS_ETC2_RGBA 0x9386
#define GL_VIEW_CLASS_RGTC1_RED 0x82D0
#define GL_VIEW_CLASS_RGTC2_RG 0x82D1
#define GL_VIEW_CLASS_S3TC_DXT1_RGB 0x82CC
#define GL_VIEW_CLASS_S3TC_DXT1_RGBA 0x82CD
#define GL_VIEW_CLASS_S3TC_DXT3_RGBA 0x82CE
#define GL_VIEW_CLASS_S3TC_DXT5_RGBA 0x82CF
#define GL_VIEW_COMPATIBILITY_CLASS 0x82B6
#define GL_VIRTUAL_PAGE_SIZE_INDEX_ARB 0x91A7
#define GL_VIRTUAL_PAGE_SIZE_X_AMD 0x9195
#define GL_VIRTUAL_PAGE_SIZE_X_ARB 0x9195
#define GL_VIRTUAL_PAGE_SIZE_Y_AMD 0x9196
#define GL_VIRTUAL_PAGE_SIZE_Y_ARB 0x9196
#define GL_VIRTUAL_PAGE_SIZE_Z_AMD 0x9197
#define GL_VIRTUAL_PAGE_SIZE_Z_ARB 0x9197
#define GL_VIVIDLIGHT_NV 0x92A6
#define GL_VOLATILE_APPLE 0x8A1A
#define GL_WAIT_FAILED 0x911D
#define GL_WARPS_PER_SM_NV 0x933A
#define GL_WARP_SIZE_NV 0x9339
#define GL_WEIGHTED_AVERAGE_ARB 0x9367
#define GL_WEIGHTED_AVERAGE_EXT 0x9367
#define GL_WEIGHT_ARRAY_ARB 0x86AD
#define GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB 0x889E
#define GL_WEIGHT_ARRAY_POINTER_ARB 0x86AC
#define GL_WEIGHT_ARRAY_SIZE_ARB 0x86AB
#define GL_WEIGHT_ARRAY_STRIDE_ARB 0x86AA
#define GL_WEIGHT_ARRAY_TYPE_ARB 0x86A9
#define GL_WEIGHT_SUM_UNITY_ARB 0x86A6
#define GL_WINDOW_RECTANGLE_EXT 0x8F12
#define GL_WINDOW_RECTANGLE_MODE_EXT 0x8F13
#define GL_WRITE_DISCARD_NV 0x88BE
#define GL_WRITE_ONLY 0x88B9
#define GL_WRITE_ONLY_ARB 0x88B9
#define GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV 0x887A
#define GL_WRITE_PIXEL_DATA_RANGE_NV 0x8878
#define GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV 0x887C
#define GL_W_EXT 0x87D8
#define GL_XOR 0x1506
#define GL_XOR_NV 0x1506
#define GL_X_EXT 0x87D5
#define GL_YCBAYCR8A_4224_NV 0x9032
#define GL_YCBCR_422_APPLE 0x85B9
#define GL_YCBCR_MESA 0x8757
#define GL_YCBYCR8_422_NV 0x9031
#define GL_Y_EXT 0x87D6
#define GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV 0x9036
#define GL_Z4Y12Z4CB12Z4CR12_444_NV 0x9037
#define GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV 0x9035
#define GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV 0x9034
#define GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV 0x9033
#define GL_ZERO 0
#define GL_ZERO_EXT 0x87DD
#define GL_ZERO_TO_ONE 0x935F
#define GL_Z_EXT 0x87D7


#include <KHR/khrplatform.h>
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef khronos_int8_t GLbyte;
typedef khronos_uint8_t GLubyte;
typedef khronos_int16_t GLshort;
typedef khronos_uint16_t GLushort;
typedef int GLint;
typedef unsigned int GLuint;
typedef khronos_int32_t GLclampx;
typedef int GLsizei;
typedef khronos_float_t GLfloat;
typedef khronos_float_t GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void *GLeglClientBufferEXT;
typedef void *GLeglImageOES;
typedef char GLchar;
typedef char GLcharARB;
#ifdef __APPLE__
typedef void *GLhandleARB;
#else
typedef unsigned int GLhandleARB;
#endif
typedef khronos_uint16_t GLhalf;
typedef khronos_uint16_t GLhalfARB;
typedef khronos_int32_t GLfixed;
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_intptr_t GLintptr;
#else
typedef khronos_intptr_t GLintptr;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_intptr_t GLintptrARB;
#else
typedef khronos_intptr_t GLintptrARB;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_ssize_t GLsizeiptr;
#else
typedef khronos_ssize_t GLsizeiptr;
#endif
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1060)
typedef khronos_ssize_t GLsizeiptrARB;
#else
typedef khronos_ssize_t GLsizeiptrARB;
#endif
typedef khronos_int64_t GLint64;
typedef khronos_int64_t GLint64EXT;
typedef khronos_uint64_t GLuint64;
typedef khronos_uint64_t GLuint64EXT;
typedef struct __GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void ( *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void ( *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void ( *GLDEBUGPROCKHR)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void ( *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
typedef unsigned short GLhalfNV;
typedef GLintptr GLvdpauSurfaceNV;
typedef void ( *GLVULKANPROCNV)(void);


#define GL_VERSION_1_0 1
GLAD_API_CALL int GLAD_GL_VERSION_1_0;
#define GL_VERSION_1_1 1
GLAD_API_CALL int GLAD_GL_VERSION_1_1;
#define GL_VERSION_1_2 1
GLAD_API_CALL int GLAD_GL_VERSION_1_2;
#define GL_VERSION_1_3 1
GLAD_API_CALL int GLAD_GL_VERSION_1_3;
#define GL_VERSION_1_4 1
GLAD_API_CALL int GLAD_GL_VERSION_1_4;
#define GL_VERSION_1_5 1
GLAD_API_CALL int GLAD_GL_VERSION_1_5;
#define GL_VERSION_2_0 1
GLAD_API_CALL int GLAD_GL_VERSION_2_0;
#define GL_VERSION_2_1 1
GLAD_API_CALL int GLAD_GL_VERSION_2_1;
#define GL_VERSION_3_0 1
GLAD_API_CALL int GLAD_GL_VERSION_3_0;
#define GL_VERSION_3_1 1
GLAD_API_CALL int GLAD_GL_VERSION_3_1;
#define GL_VERSION_3_2 1
GLAD_API_CALL int GLAD_GL_VERSION_3_2;
#define GL_VERSION_3_3 1
GLAD_API_CALL int GLAD_GL_VERSION_3_3;
#define GL_VERSION_4_0 1
GLAD_API_CALL int GLAD_GL_VERSION_4_0;
#define GL_VERSION_4_1 1
GLAD_API_CALL int GLAD_GL_VERSION_4_1;
#define GL_VERSION_4_2 1
GLAD_API_CALL int GLAD_GL_VERSION_4_2;
#define GL_VERSION_4_3 1
GLAD_API_CALL int GLAD_GL_VERSION_4_3;
#define GL_VERSION_4_4 1
GLAD_API_CALL int GLAD_GL_VERSION_4_4;
#define GL_VERSION_4_5 1
GLAD_API_CALL int GLAD_GL_VERSION_4_5;
#define GL_VERSION_4_6 1
GLAD_API_CALL int GLAD_GL_VERSION_4_6;
#define GL_AMD_blend_minmax_factor 1
GLAD_API_CALL int GLAD_GL_AMD_blend_minmax_factor;
#define GL_AMD_conservative_depth 1
GLAD_API_CALL int GLAD_GL_AMD_conservative_depth;
#define GL_AMD_debug_output 1
GLAD_API_CALL int GLAD_GL_AMD_debug_output;
#define GL_AMD_depth_clamp_separate 1
GLAD_API_CALL int GLAD_GL_AMD_depth_clamp_separate;
#define GL_AMD_draw_buffers_blend 1
GLAD_API_CALL int GLAD_GL_AMD_draw_buffers_blend;
#define GL_AMD_framebuffer_sample_positions 1
GLAD_API_CALL int GLAD_GL_AMD_framebuffer_sample_positions;
#define GL_AMD_gcn_shader 1
GLAD_API_CALL int GLAD_GL_AMD_gcn_shader;
#define GL_AMD_gpu_shader_half_float 1
GLAD_API_CALL int GLAD_GL_AMD_gpu_shader_half_float;
#define GL_AMD_gpu_shader_int16 1
GLAD_API_CALL int GLAD_GL_AMD_gpu_shader_int16;
#define GL_AMD_gpu_shader_int64 1
GLAD_API_CALL int GLAD_GL_AMD_gpu_shader_int64;
#define GL_AMD_interleaved_elements 1
GLAD_API_CALL int GLAD_GL_AMD_interleaved_elements;
#define GL_AMD_multi_draw_indirect 1
GLAD_API_CALL int GLAD_GL_AMD_multi_draw_indirect;
#define GL_AMD_name_gen_delete 1
GLAD_API_CALL int GLAD_GL_AMD_name_gen_delete;
#define GL_AMD_occlusion_query_event 1
GLAD_API_CALL int GLAD_GL_AMD_occlusion_query_event;
#define GL_AMD_performance_monitor 1
GLAD_API_CALL int GLAD_GL_AMD_performance_monitor;
#define GL_AMD_pinned_memory 1
GLAD_API_CALL int GLAD_GL_AMD_pinned_memory;
#define GL_AMD_query_buffer_object 1
GLAD_API_CALL int GLAD_GL_AMD_query_buffer_object;
#define GL_AMD_sample_positions 1
GLAD_API_CALL int GLAD_GL_AMD_sample_positions;
#define GL_AMD_seamless_cubemap_per_texture 1
GLAD_API_CALL int GLAD_GL_AMD_seamless_cubemap_per_texture;
#define GL_AMD_shader_atomic_counter_ops 1
GLAD_API_CALL int GLAD_GL_AMD_shader_atomic_counter_ops;
#define GL_AMD_shader_ballot 1
GLAD_API_CALL int GLAD_GL_AMD_shader_ballot;
#define GL_AMD_shader_explicit_vertex_parameter 1
GLAD_API_CALL int GLAD_GL_AMD_shader_explicit_vertex_parameter;
#define GL_AMD_shader_stencil_export 1
GLAD_API_CALL int GLAD_GL_AMD_shader_stencil_export;
#define GL_AMD_shader_trinary_minmax 1
GLAD_API_CALL int GLAD_GL_AMD_shader_trinary_minmax;
#define GL_AMD_sparse_texture 1
GLAD_API_CALL int GLAD_GL_AMD_sparse_texture;
#define GL_AMD_stencil_operation_extended 1
GLAD_API_CALL int GLAD_GL_AMD_stencil_operation_extended;
#define GL_AMD_texture_gather_bias_lod 1
GLAD_API_CALL int GLAD_GL_AMD_texture_gather_bias_lod;
#define GL_AMD_texture_texture4 1
GLAD_API_CALL int GLAD_GL_AMD_texture_texture4;
#define GL_AMD_transform_feedback3_lines_triangles 1
GLAD_API_CALL int GLAD_GL_AMD_transform_feedback3_lines_triangles;
#define GL_AMD_transform_feedback4 1
GLAD_API_CALL int GLAD_GL_AMD_transform_feedback4;
#define GL_AMD_vertex_shader_layer 1
GLAD_API_CALL int GLAD_GL_AMD_vertex_shader_layer;
#define GL_AMD_vertex_shader_tessellator 1
GLAD_API_CALL int GLAD_GL_AMD_vertex_shader_tessellator;
#define GL_AMD_vertex_shader_viewport_index 1
GLAD_API_CALL int GLAD_GL_AMD_vertex_shader_viewport_index;
#define GL_APPLE_aux_depth_stencil 1
GLAD_API_CALL int GLAD_GL_APPLE_aux_depth_stencil;
#define GL_APPLE_client_storage 1
GLAD_API_CALL int GLAD_GL_APPLE_client_storage;
#define GL_APPLE_element_array 1
GLAD_API_CALL int GLAD_GL_APPLE_element_array;
#define GL_APPLE_fence 1
GLAD_API_CALL int GLAD_GL_APPLE_fence;
#define GL_APPLE_float_pixels 1
GLAD_API_CALL int GLAD_GL_APPLE_float_pixels;
#define GL_APPLE_flush_buffer_range 1
GLAD_API_CALL int GLAD_GL_APPLE_flush_buffer_range;
#define GL_APPLE_object_purgeable 1
GLAD_API_CALL int GLAD_GL_APPLE_object_purgeable;
#define GL_APPLE_rgb_422 1
GLAD_API_CALL int GLAD_GL_APPLE_rgb_422;
#define GL_APPLE_row_bytes 1
GLAD_API_CALL int GLAD_GL_APPLE_row_bytes;
#define GL_APPLE_specular_vector 1
GLAD_API_CALL int GLAD_GL_APPLE_specular_vector;
#define GL_APPLE_texture_range 1
GLAD_API_CALL int GLAD_GL_APPLE_texture_range;
#define GL_APPLE_transform_hint 1
GLAD_API_CALL int GLAD_GL_APPLE_transform_hint;
#define GL_APPLE_vertex_array_object 1
GLAD_API_CALL int GLAD_GL_APPLE_vertex_array_object;
#define GL_APPLE_vertex_array_range 1
GLAD_API_CALL int GLAD_GL_APPLE_vertex_array_range;
#define GL_APPLE_vertex_program_evaluators 1
GLAD_API_CALL int GLAD_GL_APPLE_vertex_program_evaluators;
#define GL_APPLE_ycbcr_422 1
GLAD_API_CALL int GLAD_GL_APPLE_ycbcr_422;
#define GL_ARB_ES2_compatibility 1
GLAD_API_CALL int GLAD_GL_ARB_ES2_compatibility;
#define GL_ARB_ES3_1_compatibility 1
GLAD_API_CALL int GLAD_GL_ARB_ES3_1_compatibility;
#define GL_ARB_ES3_2_compatibility 1
GLAD_API_CALL int GLAD_GL_ARB_ES3_2_compatibility;
#define GL_ARB_ES3_compatibility 1
GLAD_API_CALL int GLAD_GL_ARB_ES3_compatibility;
#define GL_ARB_arrays_of_arrays 1
GLAD_API_CALL int GLAD_GL_ARB_arrays_of_arrays;
#define GL_ARB_base_instance 1
GLAD_API_CALL int GLAD_GL_ARB_base_instance;
#define GL_ARB_bindless_texture 1
GLAD_API_CALL int GLAD_GL_ARB_bindless_texture;
#define GL_ARB_blend_func_extended 1
GLAD_API_CALL int GLAD_GL_ARB_blend_func_extended;
#define GL_ARB_buffer_storage 1
GLAD_API_CALL int GLAD_GL_ARB_buffer_storage;
#define GL_ARB_cl_event 1
GLAD_API_CALL int GLAD_GL_ARB_cl_event;
#define GL_ARB_clear_buffer_object 1
GLAD_API_CALL int GLAD_GL_ARB_clear_buffer_object;
#define GL_ARB_clear_texture 1
GLAD_API_CALL int GLAD_GL_ARB_clear_texture;
#define GL_ARB_clip_control 1
GLAD_API_CALL int GLAD_GL_ARB_clip_control;
#define GL_ARB_color_buffer_float 1
GLAD_API_CALL int GLAD_GL_ARB_color_buffer_float;
#define GL_ARB_compatibility 1
GLAD_API_CALL int GLAD_GL_ARB_compatibility;
#define GL_ARB_compressed_texture_pixel_storage 1
GLAD_API_CALL int GLAD_GL_ARB_compressed_texture_pixel_storage;
#define GL_ARB_compute_shader 1
GLAD_API_CALL int GLAD_GL_ARB_compute_shader;
#define GL_ARB_compute_variable_group_size 1
GLAD_API_CALL int GLAD_GL_ARB_compute_variable_group_size;
#define GL_ARB_conditional_render_inverted 1
GLAD_API_CALL int GLAD_GL_ARB_conditional_render_inverted;
#define GL_ARB_conservative_depth 1
GLAD_API_CALL int GLAD_GL_ARB_conservative_depth;
#define GL_ARB_copy_buffer 1
GLAD_API_CALL int GLAD_GL_ARB_copy_buffer;
#define GL_ARB_copy_image 1
GLAD_API_CALL int GLAD_GL_ARB_copy_image;
#define GL_ARB_cull_distance 1
GLAD_API_CALL int GLAD_GL_ARB_cull_distance;
#define GL_ARB_debug_output 1
GLAD_API_CALL int GLAD_GL_ARB_debug_output;
#define GL_ARB_depth_buffer_float 1
GLAD_API_CALL int GLAD_GL_ARB_depth_buffer_float;
#define GL_ARB_depth_clamp 1
GLAD_API_CALL int GLAD_GL_ARB_depth_clamp;
#define GL_ARB_depth_texture 1
GLAD_API_CALL int GLAD_GL_ARB_depth_texture;
#define GL_ARB_derivative_control 1
GLAD_API_CALL int GLAD_GL_ARB_derivative_control;
#define GL_ARB_direct_state_access 1
GLAD_API_CALL int GLAD_GL_ARB_direct_state_access;
#define GL_ARB_draw_buffers 1
GLAD_API_CALL int GLAD_GL_ARB_draw_buffers;
#define GL_ARB_draw_buffers_blend 1
GLAD_API_CALL int GLAD_GL_ARB_draw_buffers_blend;
#define GL_ARB_draw_elements_base_vertex 1
GLAD_API_CALL int GLAD_GL_ARB_draw_elements_base_vertex;
#define GL_ARB_draw_indirect 1
GLAD_API_CALL int GLAD_GL_ARB_draw_indirect;
#define GL_ARB_draw_instanced 1
GLAD_API_CALL int GLAD_GL_ARB_draw_instanced;
#define GL_ARB_enhanced_layouts 1
GLAD_API_CALL int GLAD_GL_ARB_enhanced_layouts;
#define GL_ARB_explicit_attrib_location 1
GLAD_API_CALL int GLAD_GL_ARB_explicit_attrib_location;
#define GL_ARB_explicit_uniform_location 1
GLAD_API_CALL int GLAD_GL_ARB_explicit_uniform_location;
#define GL_ARB_fragment_coord_conventions 1
GLAD_API_CALL int GLAD_GL_ARB_fragment_coord_conventions;
#define GL_ARB_fragment_layer_viewport 1
GLAD_API_CALL int GLAD_GL_ARB_fragment_layer_viewport;
#define GL_ARB_fragment_program 1
GLAD_API_CALL int GLAD_GL_ARB_fragment_program;
#define GL_ARB_fragment_program_shadow 1
GLAD_API_CALL int GLAD_GL_ARB_fragment_program_shadow;
#define GL_ARB_fragment_shader 1
GLAD_API_CALL int GLAD_GL_ARB_fragment_shader;
#define GL_ARB_fragment_shader_interlock 1
GLAD_API_CALL int GLAD_GL_ARB_fragment_shader_interlock;
#define GL_ARB_framebuffer_no_attachments 1
GLAD_API_CALL int GLAD_GL_ARB_framebuffer_no_attachments;
#define GL_ARB_framebuffer_object 1
GLAD_API_CALL int GLAD_GL_ARB_framebuffer_object;
#define GL_ARB_framebuffer_sRGB 1
GLAD_API_CALL int GLAD_GL_ARB_framebuffer_sRGB;
#define GL_ARB_geometry_shader4 1
GLAD_API_CALL int GLAD_GL_ARB_geometry_shader4;
#define GL_ARB_get_program_binary 1
GLAD_API_CALL int GLAD_GL_ARB_get_program_binary;
#define GL_ARB_get_texture_sub_image 1
GLAD_API_CALL int GLAD_GL_ARB_get_texture_sub_image;
#define GL_ARB_gl_spirv 1
GLAD_API_CALL int GLAD_GL_ARB_gl_spirv;
#define GL_ARB_gpu_shader5 1
GLAD_API_CALL int GLAD_GL_ARB_gpu_shader5;
#define GL_ARB_gpu_shader_fp64 1
GLAD_API_CALL int GLAD_GL_ARB_gpu_shader_fp64;
#define GL_ARB_gpu_shader_int64 1
GLAD_API_CALL int GLAD_GL_ARB_gpu_shader_int64;
#define GL_ARB_half_float_pixel 1
GLAD_API_CALL int GLAD_GL_ARB_half_float_pixel;
#define GL_ARB_half_float_vertex 1
GLAD_API_CALL int GLAD_GL_ARB_half_float_vertex;
#define GL_ARB_imaging 1
GLAD_API_CALL int GLAD_GL_ARB_imaging;
#define GL_ARB_indirect_parameters 1
GLAD_API_CALL int GLAD_GL_ARB_indirect_parameters;
#define GL_ARB_instanced_arrays 1
GLAD_API_CALL int GLAD_GL_ARB_instanced_arrays;
#define GL_ARB_internalformat_query 1
GLAD_API_CALL int GLAD_GL_ARB_internalformat_query;
#define GL_ARB_internalformat_query2 1
GLAD_API_CALL int GLAD_GL_ARB_internalformat_query2;
#define GL_ARB_invalidate_subdata 1
GLAD_API_CALL int GLAD_GL_ARB_invalidate_subdata;
#define GL_ARB_map_buffer_alignment 1
GLAD_API_CALL int GLAD_GL_ARB_map_buffer_alignment;
#define GL_ARB_map_buffer_range 1
GLAD_API_CALL int GLAD_GL_ARB_map_buffer_range;
#define GL_ARB_matrix_palette 1
GLAD_API_CALL int GLAD_GL_ARB_matrix_palette;
#define GL_ARB_multi_bind 1
GLAD_API_CALL int GLAD_GL_ARB_multi_bind;
#define GL_ARB_multi_draw_indirect 1
GLAD_API_CALL int GLAD_GL_ARB_multi_draw_indirect;
#define GL_ARB_multisample 1
GLAD_API_CALL int GLAD_GL_ARB_multisample;
#define GL_ARB_multitexture 1
GLAD_API_CALL int GLAD_GL_ARB_multitexture;
#define GL_ARB_occlusion_query 1
GLAD_API_CALL int GLAD_GL_ARB_occlusion_query;
#define GL_ARB_occlusion_query2 1
GLAD_API_CALL int GLAD_GL_ARB_occlusion_query2;
#define GL_ARB_parallel_shader_compile 1
GLAD_API_CALL int GLAD_GL_ARB_parallel_shader_compile;
#define GL_ARB_pipeline_statistics_query 1
GLAD_API_CALL int GLAD_GL_ARB_pipeline_statistics_query;
#define GL_ARB_pixel_buffer_object 1
GLAD_API_CALL int GLAD_GL_ARB_pixel_buffer_object;
#define GL_ARB_point_parameters 1
GLAD_API_CALL int GLAD_GL_ARB_point_parameters;
#define GL_ARB_point_sprite 1
GLAD_API_CALL int GLAD_GL_ARB_point_sprite;
#define GL_ARB_polygon_offset_clamp 1
GLAD_API_CALL int GLAD_GL_ARB_polygon_offset_clamp;
#define GL_ARB_post_depth_coverage 1
GLAD_API_CALL int GLAD_GL_ARB_post_depth_coverage;
#define GL_ARB_program_interface_query 1
GLAD_API_CALL int GLAD_GL_ARB_program_interface_query;
#define GL_ARB_provoking_vertex 1
GLAD_API_CALL int GLAD_GL_ARB_provoking_vertex;
#define GL_ARB_query_buffer_object 1
GLAD_API_CALL int GLAD_GL_ARB_query_buffer_object;
#define GL_ARB_robust_buffer_access_behavior 1
GLAD_API_CALL int GLAD_GL_ARB_robust_buffer_access_behavior;
#define GL_ARB_robustness 1
GLAD_API_CALL int GLAD_GL_ARB_robustness;
#define GL_ARB_robustness_isolation 1
GLAD_API_CALL int GLAD_GL_ARB_robustness_isolation;
#define GL_ARB_sample_locations 1
GLAD_API_CALL int GLAD_GL_ARB_sample_locations;
#define GL_ARB_sample_shading 1
GLAD_API_CALL int GLAD_GL_ARB_sample_shading;
#define GL_ARB_sampler_objects 1
GLAD_API_CALL int GLAD_GL_ARB_sampler_objects;
#define GL_ARB_seamless_cube_map 1
GLAD_API_CALL int GLAD_GL_ARB_seamless_cube_map;
#define GL_ARB_seamless_cubemap_per_texture 1
GLAD_API_CALL int GLAD_GL_ARB_seamless_cubemap_per_texture;
#define GL_ARB_separate_shader_objects 1
GLAD_API_CALL int GLAD_GL_ARB_separate_shader_objects;
#define GL_ARB_shader_atomic_counter_ops 1
GLAD_API_CALL int GLAD_GL_ARB_shader_atomic_counter_ops;
#define GL_ARB_shader_atomic_counters 1
GLAD_API_CALL int GLAD_GL_ARB_shader_atomic_counters;
#define GL_ARB_shader_ballot 1
GLAD_API_CALL int GLAD_GL_ARB_shader_ballot;
#define GL_ARB_shader_bit_encoding 1
GLAD_API_CALL int GLAD_GL_ARB_shader_bit_encoding;
#define GL_ARB_shader_clock 1
GLAD_API_CALL int GLAD_GL_ARB_shader_clock;
#define GL_ARB_shader_draw_parameters 1
GLAD_API_CALL int GLAD_GL_ARB_shader_draw_parameters;
#define GL_ARB_shader_group_vote 1
GLAD_API_CALL int GLAD_GL_ARB_shader_group_vote;
#define GL_ARB_shader_image_load_store 1
GLAD_API_CALL int GLAD_GL_ARB_shader_image_load_store;
#define GL_ARB_shader_image_size 1
GLAD_API_CALL int GLAD_GL_ARB_shader_image_size;
#define GL_ARB_shader_objects 1
GLAD_API_CALL int GLAD_GL_ARB_shader_objects;
#define GL_ARB_shader_precision 1
GLAD_API_CALL int GLAD_GL_ARB_shader_precision;
#define GL_ARB_shader_stencil_export 1
GLAD_API_CALL int GLAD_GL_ARB_shader_stencil_export;
#define GL_ARB_shader_storage_buffer_object 1
GLAD_API_CALL int GLAD_GL_ARB_shader_storage_buffer_object;
#define GL_ARB_shader_subroutine 1
GLAD_API_CALL int GLAD_GL_ARB_shader_subroutine;
#define GL_ARB_shader_texture_image_samples 1
GLAD_API_CALL int GLAD_GL_ARB_shader_texture_image_samples;
#define GL_ARB_shader_texture_lod 1
GLAD_API_CALL int GLAD_GL_ARB_shader_texture_lod;
#define GL_ARB_shader_viewport_layer_array 1
GLAD_API_CALL int GLAD_GL_ARB_shader_viewport_layer_array;
#define GL_ARB_shading_language_100 1
GLAD_API_CALL int GLAD_GL_ARB_shading_language_100;
#define GL_ARB_shading_language_420pack 1
GLAD_API_CALL int GLAD_GL_ARB_shading_language_420pack;
#define GL_ARB_shading_language_include 1
GLAD_API_CALL int GLAD_GL_ARB_shading_language_include;
#define GL_ARB_shading_language_packing 1
GLAD_API_CALL int GLAD_GL_ARB_shading_language_packing;
#define GL_ARB_shadow 1
GLAD_API_CALL int GLAD_GL_ARB_shadow;
#define GL_ARB_shadow_ambient 1
GLAD_API_CALL int GLAD_GL_ARB_shadow_ambient;
#define GL_ARB_sparse_buffer 1
GLAD_API_CALL int GLAD_GL_ARB_sparse_buffer;
#define GL_ARB_sparse_texture 1
GLAD_API_CALL int GLAD_GL_ARB_sparse_texture;
#define GL_ARB_sparse_texture2 1
GLAD_API_CALL int GLAD_GL_ARB_sparse_texture2;
#define GL_ARB_sparse_texture_clamp 1
GLAD_API_CALL int GLAD_GL_ARB_sparse_texture_clamp;
#define GL_ARB_spirv_extensions 1
GLAD_API_CALL int GLAD_GL_ARB_spirv_extensions;
#define GL_ARB_stencil_texturing 1
GLAD_API_CALL int GLAD_GL_ARB_stencil_texturing;
#define GL_ARB_sync 1
GLAD_API_CALL int GLAD_GL_ARB_sync;
#define GL_ARB_tessellation_shader 1
GLAD_API_CALL int GLAD_GL_ARB_tessellation_shader;
#define GL_ARB_texture_barrier 1
GLAD_API_CALL int GLAD_GL_ARB_texture_barrier;
#define GL_ARB_texture_border_clamp 1
GLAD_API_CALL int GLAD_GL_ARB_texture_border_clamp;
#define GL_ARB_texture_buffer_object 1
GLAD_API_CALL int GLAD_GL_ARB_texture_buffer_object;
#define GL_ARB_texture_buffer_object_rgb32 1
GLAD_API_CALL int GLAD_GL_ARB_texture_buffer_object_rgb32;
#define GL_ARB_texture_buffer_range 1
GLAD_API_CALL int GLAD_GL_ARB_texture_buffer_range;
#define GL_ARB_texture_compression 1
GLAD_API_CALL int GLAD_GL_ARB_texture_compression;
#define GL_ARB_texture_compression_bptc 1
GLAD_API_CALL int GLAD_GL_ARB_texture_compression_bptc;
#define GL_ARB_texture_compression_rgtc 1
GLAD_API_CALL int GLAD_GL_ARB_texture_compression_rgtc;
#define GL_ARB_texture_cube_map 1
GLAD_API_CALL int GLAD_GL_ARB_texture_cube_map;
#define GL_ARB_texture_cube_map_array 1
GLAD_API_CALL int GLAD_GL_ARB_texture_cube_map_array;
#define GL_ARB_texture_env_add 1
GLAD_API_CALL int GLAD_GL_ARB_texture_env_add;
#define GL_ARB_texture_env_combine 1
GLAD_API_CALL int GLAD_GL_ARB_texture_env_combine;
#define GL_ARB_texture_env_crossbar 1
GLAD_API_CALL int GLAD_GL_ARB_texture_env_crossbar;
#define GL_ARB_texture_env_dot3 1
GLAD_API_CALL int GLAD_GL_ARB_texture_env_dot3;
#define GL_ARB_texture_filter_anisotropic 1
GLAD_API_CALL int GLAD_GL_ARB_texture_filter_anisotropic;
#define GL_ARB_texture_filter_minmax 1
GLAD_API_CALL int GLAD_GL_ARB_texture_filter_minmax;
#define GL_ARB_texture_float 1
GLAD_API_CALL int GLAD_GL_ARB_texture_float;
#define GL_ARB_texture_gather 1
GLAD_API_CALL int GLAD_GL_ARB_texture_gather;
#define GL_ARB_texture_mirror_clamp_to_edge 1
GLAD_API_CALL int GLAD_GL_ARB_texture_mirror_clamp_to_edge;
#define GL_ARB_texture_mirrored_repeat 1
GLAD_API_CALL int GLAD_GL_ARB_texture_mirrored_repeat;
#define GL_ARB_texture_multisample 1
GLAD_API_CALL int GLAD_GL_ARB_texture_multisample;
#define GL_ARB_texture_non_power_of_two 1
GLAD_API_CALL int GLAD_GL_ARB_texture_non_power_of_two;
#define GL_ARB_texture_query_levels 1
GLAD_API_CALL int GLAD_GL_ARB_texture_query_levels;
#define GL_ARB_texture_query_lod 1
GLAD_API_CALL int GLAD_GL_ARB_texture_query_lod;
#define GL_ARB_texture_rectangle 1
GLAD_API_CALL int GLAD_GL_ARB_texture_rectangle;
#define GL_ARB_texture_rg 1
GLAD_API_CALL int GLAD_GL_ARB_texture_rg;
#define GL_ARB_texture_rgb10_a2ui 1
GLAD_API_CALL int GLAD_GL_ARB_texture_rgb10_a2ui;
#define GL_ARB_texture_stencil8 1
GLAD_API_CALL int GLAD_GL_ARB_texture_stencil8;
#define GL_ARB_texture_storage 1
GLAD_API_CALL int GLAD_GL_ARB_texture_storage;
#define GL_ARB_texture_storage_multisample 1
GLAD_API_CALL int GLAD_GL_ARB_texture_storage_multisample;
#define GL_ARB_texture_swizzle 1
GLAD_API_CALL int GLAD_GL_ARB_texture_swizzle;
#define GL_ARB_texture_view 1
GLAD_API_CALL int GLAD_GL_ARB_texture_view;
#define GL_ARB_timer_query 1
GLAD_API_CALL int GLAD_GL_ARB_timer_query;
#define GL_ARB_transform_feedback2 1
GLAD_API_CALL int GLAD_GL_ARB_transform_feedback2;
#define GL_ARB_transform_feedback3 1
GLAD_API_CALL int GLAD_GL_ARB_transform_feedback3;
#define GL_ARB_transform_feedback_instanced 1
GLAD_API_CALL int GLAD_GL_ARB_transform_feedback_instanced;
#define GL_ARB_transform_feedback_overflow_query 1
GLAD_API_CALL int GLAD_GL_ARB_transform_feedback_overflow_query;
#define GL_ARB_transpose_matrix 1
GLAD_API_CALL int GLAD_GL_ARB_transpose_matrix;
#define GL_ARB_uniform_buffer_object 1
GLAD_API_CALL int GLAD_GL_ARB_uniform_buffer_object;
#define GL_ARB_vertex_array_bgra 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_array_bgra;
#define GL_ARB_vertex_array_object 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_array_object;
#define GL_ARB_vertex_attrib_64bit 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_attrib_64bit;
#define GL_ARB_vertex_attrib_binding 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_attrib_binding;
#define GL_ARB_vertex_blend 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_blend;
#define GL_ARB_vertex_buffer_object 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_buffer_object;
#define GL_ARB_vertex_program 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_program;
#define GL_ARB_vertex_shader 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_shader;
#define GL_ARB_vertex_type_10f_11f_11f_rev 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_type_10f_11f_11f_rev;
#define GL_ARB_vertex_type_2_10_10_10_rev 1
GLAD_API_CALL int GLAD_GL_ARB_vertex_type_2_10_10_10_rev;
#define GL_ARB_viewport_array 1
GLAD_API_CALL int GLAD_GL_ARB_viewport_array;
#define GL_ARB_window_pos 1
GLAD_API_CALL int GLAD_GL_ARB_window_pos;
#define GL_ATI_draw_buffers 1
GLAD_API_CALL int GLAD_GL_ATI_draw_buffers;
#define GL_ATI_element_array 1
GLAD_API_CALL int GLAD_GL_ATI_element_array;
#define GL_ATI_envmap_bumpmap 1
GLAD_API_CALL int GLAD_GL_ATI_envmap_bumpmap;
#define GL_ATI_fragment_shader 1
GLAD_API_CALL int GLAD_GL_ATI_fragment_shader;
#define GL_ATI_map_object_buffer 1
GLAD_API_CALL int GLAD_GL_ATI_map_object_buffer;
#define GL_ATI_meminfo 1
GLAD_API_CALL int GLAD_GL_ATI_meminfo;
#define GL_ATI_pixel_format_float 1
GLAD_API_CALL int GLAD_GL_ATI_pixel_format_float;
#define GL_ATI_pn_triangles 1
GLAD_API_CALL int GLAD_GL_ATI_pn_triangles;
#define GL_ATI_separate_stencil 1
GLAD_API_CALL int GLAD_GL_ATI_separate_stencil;
#define GL_ATI_text_fragment_shader 1
GLAD_API_CALL int GLAD_GL_ATI_text_fragment_shader;
#define GL_ATI_texture_env_combine3 1
GLAD_API_CALL int GLAD_GL_ATI_texture_env_combine3;
#define GL_ATI_texture_float 1
GLAD_API_CALL int GLAD_GL_ATI_texture_float;
#define GL_ATI_texture_mirror_once 1
GLAD_API_CALL int GLAD_GL_ATI_texture_mirror_once;
#define GL_ATI_vertex_array_object 1
GLAD_API_CALL int GLAD_GL_ATI_vertex_array_object;
#define GL_ATI_vertex_attrib_array_object 1
GLAD_API_CALL int GLAD_GL_ATI_vertex_attrib_array_object;
#define GL_ATI_vertex_streams 1
GLAD_API_CALL int GLAD_GL_ATI_vertex_streams;
#define GL_EXT_422_pixels 1
GLAD_API_CALL int GLAD_GL_EXT_422_pixels;
#define GL_EXT_abgr 1
GLAD_API_CALL int GLAD_GL_EXT_abgr;
#define GL_EXT_bgra 1
GLAD_API_CALL int GLAD_GL_EXT_bgra;
#define GL_EXT_bindable_uniform 1
GLAD_API_CALL int GLAD_GL_EXT_bindable_uniform;
#define GL_EXT_blend_color 1
GLAD_API_CALL int GLAD_GL_EXT_blend_color;
#define GL_EXT_blend_equation_separate 1
GLAD_API_CALL int GLAD_GL_EXT_blend_equation_separate;
#define GL_EXT_blend_func_separate 1
GLAD_API_CALL int GLAD_GL_EXT_blend_func_separate;
#define GL_EXT_blend_logic_op 1
GLAD_API_CALL int GLAD_GL_EXT_blend_logic_op;
#define GL_EXT_blend_minmax 1
GLAD_API_CALL int GLAD_GL_EXT_blend_minmax;
#define GL_EXT_blend_subtract 1
GLAD_API_CALL int GLAD_GL_EXT_blend_subtract;
#define GL_EXT_clip_volume_hint 1
GLAD_API_CALL int GLAD_GL_EXT_clip_volume_hint;
#define GL_EXT_cmyka 1
GLAD_API_CALL int GLAD_GL_EXT_cmyka;
#define GL_EXT_color_subtable 1
GLAD_API_CALL int GLAD_GL_EXT_color_subtable;
#define GL_EXT_compiled_vertex_array 1
GLAD_API_CALL int GLAD_GL_EXT_compiled_vertex_array;
#define GL_EXT_convolution 1
GLAD_API_CALL int GLAD_GL_EXT_convolution;
#define GL_EXT_coordinate_frame 1
GLAD_API_CALL int GLAD_GL_EXT_coordinate_frame;
#define GL_EXT_copy_texture 1
GLAD_API_CALL int GLAD_GL_EXT_copy_texture;
#define GL_EXT_cull_vertex 1
GLAD_API_CALL int GLAD_GL_EXT_cull_vertex;
#define GL_EXT_debug_label 1
GLAD_API_CALL int GLAD_GL_EXT_debug_label;
#define GL_EXT_debug_marker 1
GLAD_API_CALL int GLAD_GL_EXT_debug_marker;
#define GL_EXT_depth_bounds_test 1
GLAD_API_CALL int GLAD_GL_EXT_depth_bounds_test;
#define GL_EXT_direct_state_access 1
GLAD_API_CALL int GLAD_GL_EXT_direct_state_access;
#define GL_EXT_draw_buffers2 1
GLAD_API_CALL int GLAD_GL_EXT_draw_buffers2;
#define GL_EXT_draw_instanced 1
GLAD_API_CALL int GLAD_GL_EXT_draw_instanced;
#define GL_EXT_draw_range_elements 1
GLAD_API_CALL int GLAD_GL_EXT_draw_range_elements;
#define GL_EXT_external_buffer 1
GLAD_API_CALL int GLAD_GL_EXT_external_buffer;
#define GL_EXT_fog_coord 1
GLAD_API_CALL int GLAD_GL_EXT_fog_coord;
#define GL_EXT_framebuffer_blit 1
GLAD_API_CALL int GLAD_GL_EXT_framebuffer_blit;
#define GL_EXT_framebuffer_multisample 1
GLAD_API_CALL int GLAD_GL_EXT_framebuffer_multisample;
#define GL_EXT_framebuffer_multisample_blit_scaled 1
GLAD_API_CALL int GLAD_GL_EXT_framebuffer_multisample_blit_scaled;
#define GL_EXT_framebuffer_object 1
GLAD_API_CALL int GLAD_GL_EXT_framebuffer_object;
#define GL_EXT_framebuffer_sRGB 1
GLAD_API_CALL int GLAD_GL_EXT_framebuffer_sRGB;
#define GL_EXT_geometry_shader4 1
GLAD_API_CALL int GLAD_GL_EXT_geometry_shader4;
#define GL_EXT_gpu_program_parameters 1
GLAD_API_CALL int GLAD_GL_EXT_gpu_program_parameters;
#define GL_EXT_gpu_shader4 1
GLAD_API_CALL int GLAD_GL_EXT_gpu_shader4;
#define GL_EXT_histogram 1
GLAD_API_CALL int GLAD_GL_EXT_histogram;
#define GL_EXT_index_array_formats 1
GLAD_API_CALL int GLAD_GL_EXT_index_array_formats;
#define GL_EXT_index_func 1
GLAD_API_CALL int GLAD_GL_EXT_index_func;
#define GL_EXT_index_material 1
GLAD_API_CALL int GLAD_GL_EXT_index_material;
#define GL_EXT_index_texture 1
GLAD_API_CALL int GLAD_GL_EXT_index_texture;
#define GL_EXT_light_texture 1
GLAD_API_CALL int GLAD_GL_EXT_light_texture;
#define GL_EXT_memory_object 1
GLAD_API_CALL int GLAD_GL_EXT_memory_object;
#define GL_EXT_memory_object_fd 1
GLAD_API_CALL int GLAD_GL_EXT_memory_object_fd;
#define GL_EXT_memory_object_win32 1
GLAD_API_CALL int GLAD_GL_EXT_memory_object_win32;
#define GL_EXT_misc_attribute 1
GLAD_API_CALL int GLAD_GL_EXT_misc_attribute;
#define GL_EXT_multi_draw_arrays 1
GLAD_API_CALL int GLAD_GL_EXT_multi_draw_arrays;
#define GL_EXT_multisample 1
GLAD_API_CALL int GLAD_GL_EXT_multisample;
#define GL_EXT_packed_depth_stencil 1
GLAD_API_CALL int GLAD_GL_EXT_packed_depth_stencil;
#define GL_EXT_packed_float 1
GLAD_API_CALL int GLAD_GL_EXT_packed_float;
#define GL_EXT_packed_pixels 1
GLAD_API_CALL int GLAD_GL_EXT_packed_pixels;
#define GL_EXT_paletted_texture 1
GLAD_API_CALL int GLAD_GL_EXT_paletted_texture;
#define GL_EXT_pixel_buffer_object 1
GLAD_API_CALL int GLAD_GL_EXT_pixel_buffer_object;
#define GL_EXT_pixel_transform 1
GLAD_API_CALL int GLAD_GL_EXT_pixel_transform;
#define GL_EXT_pixel_transform_color_table 1
GLAD_API_CALL int GLAD_GL_EXT_pixel_transform_color_table;
#define GL_EXT_point_parameters 1
GLAD_API_CALL int GLAD_GL_EXT_point_parameters;
#define GL_EXT_polygon_offset 1
GLAD_API_CALL int GLAD_GL_EXT_polygon_offset;
#define GL_EXT_polygon_offset_clamp 1
GLAD_API_CALL int GLAD_GL_EXT_polygon_offset_clamp;
#define GL_EXT_post_depth_coverage 1
GLAD_API_CALL int GLAD_GL_EXT_post_depth_coverage;
#define GL_EXT_provoking_vertex 1
GLAD_API_CALL int GLAD_GL_EXT_provoking_vertex;
#define GL_EXT_raster_multisample 1
GLAD_API_CALL int GLAD_GL_EXT_raster_multisample;
#define GL_EXT_rescale_normal 1
GLAD_API_CALL int GLAD_GL_EXT_rescale_normal;
#define GL_EXT_secondary_color 1
GLAD_API_CALL int GLAD_GL_EXT_secondary_color;
#define GL_EXT_semaphore 1
GLAD_API_CALL int GLAD_GL_EXT_semaphore;
#define GL_EXT_semaphore_fd 1
GLAD_API_CALL int GLAD_GL_EXT_semaphore_fd;
#define GL_EXT_semaphore_win32 1
GLAD_API_CALL int GLAD_GL_EXT_semaphore_win32;
#define GL_EXT_separate_shader_objects 1
GLAD_API_CALL int GLAD_GL_EXT_separate_shader_objects;
#define GL_EXT_separate_specular_color 1
GLAD_API_CALL int GLAD_GL_EXT_separate_specular_color;
#define GL_EXT_shader_image_load_formatted 1
GLAD_API_CALL int GLAD_GL_EXT_shader_image_load_formatted;
#define GL_EXT_shader_image_load_store 1
GLAD_API_CALL int GLAD_GL_EXT_shader_image_load_store;
#define GL_EXT_shader_integer_mix 1
GLAD_API_CALL int GLAD_GL_EXT_shader_integer_mix;
#define GL_EXT_shadow_funcs 1
GLAD_API_CALL int GLAD_GL_EXT_shadow_funcs;
#define GL_EXT_shared_texture_palette 1
GLAD_API_CALL int GLAD_GL_EXT_shared_texture_palette;
#define GL_EXT_sparse_texture2 1
GLAD_API_CALL int GLAD_GL_EXT_sparse_texture2;
#define GL_EXT_stencil_clear_tag 1
GLAD_API_CALL int GLAD_GL_EXT_stencil_clear_tag;
#define GL_EXT_stencil_two_side 1
GLAD_API_CALL int GLAD_GL_EXT_stencil_two_side;
#define GL_EXT_stencil_wrap 1
GLAD_API_CALL int GLAD_GL_EXT_stencil_wrap;
#define GL_EXT_subtexture 1
GLAD_API_CALL int GLAD_GL_EXT_subtexture;
#define GL_EXT_texture 1
GLAD_API_CALL int GLAD_GL_EXT_texture;
#define GL_EXT_texture3D 1
GLAD_API_CALL int GLAD_GL_EXT_texture3D;
#define GL_EXT_texture_array 1
GLAD_API_CALL int GLAD_GL_EXT_texture_array;
#define GL_EXT_texture_buffer_object 1
GLAD_API_CALL int GLAD_GL_EXT_texture_buffer_object;
#define GL_EXT_texture_compression_latc 1
GLAD_API_CALL int GLAD_GL_EXT_texture_compression_latc;
#define GL_EXT_texture_compression_rgtc 1
GLAD_API_CALL int GLAD_GL_EXT_texture_compression_rgtc;
#define GL_EXT_texture_compression_s3tc 1
GLAD_API_CALL int GLAD_GL_EXT_texture_compression_s3tc;
#define GL_EXT_texture_cube_map 1
GLAD_API_CALL int GLAD_GL_EXT_texture_cube_map;
#define GL_EXT_texture_env_add 1
GLAD_API_CALL int GLAD_GL_EXT_texture_env_add;
#define GL_EXT_texture_env_combine 1
GLAD_API_CALL int GLAD_GL_EXT_texture_env_combine;
#define GL_EXT_texture_env_dot3 1
GLAD_API_CALL int GLAD_GL_EXT_texture_env_dot3;
#define GL_EXT_texture_filter_anisotropic 1
GLAD_API_CALL int GLAD_GL_EXT_texture_filter_anisotropic;
#define GL_EXT_texture_filter_minmax 1
GLAD_API_CALL int GLAD_GL_EXT_texture_filter_minmax;
#define GL_EXT_texture_integer 1
GLAD_API_CALL int GLAD_GL_EXT_texture_integer;
#define GL_EXT_texture_lod_bias 1
GLAD_API_CALL int GLAD_GL_EXT_texture_lod_bias;
#define GL_EXT_texture_mirror_clamp 1
GLAD_API_CALL int GLAD_GL_EXT_texture_mirror_clamp;
#define GL_EXT_texture_object 1
GLAD_API_CALL int GLAD_GL_EXT_texture_object;
#define GL_EXT_texture_perturb_normal 1
GLAD_API_CALL int GLAD_GL_EXT_texture_perturb_normal;
#define GL_EXT_texture_sRGB 1
GLAD_API_CALL int GLAD_GL_EXT_texture_sRGB;
#define GL_EXT_texture_sRGB_decode 1
GLAD_API_CALL int GLAD_GL_EXT_texture_sRGB_decode;
#define GL_EXT_texture_shared_exponent 1
GLAD_API_CALL int GLAD_GL_EXT_texture_shared_exponent;
#define GL_EXT_texture_snorm 1
GLAD_API_CALL int GLAD_GL_EXT_texture_snorm;
#define GL_EXT_texture_swizzle 1
GLAD_API_CALL int GLAD_GL_EXT_texture_swizzle;
#define GL_EXT_timer_query 1
GLAD_API_CALL int GLAD_GL_EXT_timer_query;
#define GL_EXT_transform_feedback 1
GLAD_API_CALL int GLAD_GL_EXT_transform_feedback;
#define GL_EXT_vertex_array 1
GLAD_API_CALL int GLAD_GL_EXT_vertex_array;
#define GL_EXT_vertex_array_bgra 1
GLAD_API_CALL int GLAD_GL_EXT_vertex_array_bgra;
#define GL_EXT_vertex_attrib_64bit 1
GLAD_API_CALL int GLAD_GL_EXT_vertex_attrib_64bit;
#define GL_EXT_vertex_shader 1
GLAD_API_CALL int GLAD_GL_EXT_vertex_shader;
#define GL_EXT_vertex_weighting 1
GLAD_API_CALL int GLAD_GL_EXT_vertex_weighting;
#define GL_EXT_win32_keyed_mutex 1
GLAD_API_CALL int GLAD_GL_EXT_win32_keyed_mutex;
#define GL_EXT_window_rectangles 1
GLAD_API_CALL int GLAD_GL_EXT_window_rectangles;
#define GL_EXT_x11_sync_object 1
GLAD_API_CALL int GLAD_GL_EXT_x11_sync_object;
#define GL_INTEL_conservative_rasterization 1
GLAD_API_CALL int GLAD_GL_INTEL_conservative_rasterization;
#define GL_INTEL_fragment_shader_ordering 1
GLAD_API_CALL int GLAD_GL_INTEL_fragment_shader_ordering;
#define GL_INTEL_framebuffer_CMAA 1
GLAD_API_CALL int GLAD_GL_INTEL_framebuffer_CMAA;
#define GL_INTEL_map_texture 1
GLAD_API_CALL int GLAD_GL_INTEL_map_texture;
#define GL_INTEL_parallel_arrays 1
GLAD_API_CALL int GLAD_GL_INTEL_parallel_arrays;
#define GL_INTEL_performance_query 1
GLAD_API_CALL int GLAD_GL_INTEL_performance_query;
#define GL_KHR_blend_equation_advanced 1
GLAD_API_CALL int GLAD_GL_KHR_blend_equation_advanced;
#define GL_KHR_blend_equation_advanced_coherent 1
GLAD_API_CALL int GLAD_GL_KHR_blend_equation_advanced_coherent;
#define GL_KHR_context_flush_control 1
GLAD_API_CALL int GLAD_GL_KHR_context_flush_control;
#define GL_KHR_debug 1
GLAD_API_CALL int GLAD_GL_KHR_debug;
#define GL_KHR_no_error 1
GLAD_API_CALL int GLAD_GL_KHR_no_error;
#define GL_KHR_parallel_shader_compile 1
GLAD_API_CALL int GLAD_GL_KHR_parallel_shader_compile;
#define GL_KHR_robust_buffer_access_behavior 1
GLAD_API_CALL int GLAD_GL_KHR_robust_buffer_access_behavior;
#define GL_KHR_robustness 1
GLAD_API_CALL int GLAD_GL_KHR_robustness;
#define GL_KHR_texture_compression_astc_hdr 1
GLAD_API_CALL int GLAD_GL_KHR_texture_compression_astc_hdr;
#define GL_KHR_texture_compression_astc_ldr 1
GLAD_API_CALL int GLAD_GL_KHR_texture_compression_astc_ldr;
#define GL_KHR_texture_compression_astc_sliced_3d 1
GLAD_API_CALL int GLAD_GL_KHR_texture_compression_astc_sliced_3d;
#define GL_MESAX_texture_stack 1
GLAD_API_CALL int GLAD_GL_MESAX_texture_stack;
#define GL_MESA_pack_invert 1
GLAD_API_CALL int GLAD_GL_MESA_pack_invert;
#define GL_MESA_resize_buffers 1
GLAD_API_CALL int GLAD_GL_MESA_resize_buffers;
#define GL_MESA_shader_integer_functions 1
GLAD_API_CALL int GLAD_GL_MESA_shader_integer_functions;
#define GL_MESA_window_pos 1
GLAD_API_CALL int GLAD_GL_MESA_window_pos;
#define GL_MESA_ycbcr_texture 1
GLAD_API_CALL int GLAD_GL_MESA_ycbcr_texture;
#define GL_NVX_blend_equation_advanced_multi_draw_buffers 1
GLAD_API_CALL int GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers;
#define GL_NVX_conditional_render 1
GLAD_API_CALL int GLAD_GL_NVX_conditional_render;
#define GL_NVX_gpu_memory_info 1
GLAD_API_CALL int GLAD_GL_NVX_gpu_memory_info;
#define GL_NVX_linked_gpu_multicast 1
GLAD_API_CALL int GLAD_GL_NVX_linked_gpu_multicast;
#define GL_NV_alpha_to_coverage_dither_control 1
GLAD_API_CALL int GLAD_GL_NV_alpha_to_coverage_dither_control;
#define GL_NV_bindless_multi_draw_indirect 1
GLAD_API_CALL int GLAD_GL_NV_bindless_multi_draw_indirect;
#define GL_NV_bindless_multi_draw_indirect_count 1
GLAD_API_CALL int GLAD_GL_NV_bindless_multi_draw_indirect_count;
#define GL_NV_bindless_texture 1
GLAD_API_CALL int GLAD_GL_NV_bindless_texture;
#define GL_NV_blend_equation_advanced 1
GLAD_API_CALL int GLAD_GL_NV_blend_equation_advanced;
#define GL_NV_blend_equation_advanced_coherent 1
GLAD_API_CALL int GLAD_GL_NV_blend_equation_advanced_coherent;
#define GL_NV_blend_minmax_factor 1
GLAD_API_CALL int GLAD_GL_NV_blend_minmax_factor;
#define GL_NV_blend_square 1
GLAD_API_CALL int GLAD_GL_NV_blend_square;
#define GL_NV_clip_space_w_scaling 1
GLAD_API_CALL int GLAD_GL_NV_clip_space_w_scaling;
#define GL_NV_command_list 1
GLAD_API_CALL int GLAD_GL_NV_command_list;
#define GL_NV_compute_program5 1
GLAD_API_CALL int GLAD_GL_NV_compute_program5;
#define GL_NV_conditional_render 1
GLAD_API_CALL int GLAD_GL_NV_conditional_render;
#define GL_NV_conservative_raster 1
GLAD_API_CALL int GLAD_GL_NV_conservative_raster;
#define GL_NV_conservative_raster_dilate 1
GLAD_API_CALL int GLAD_GL_NV_conservative_raster_dilate;
#define GL_NV_conservative_raster_pre_snap_triangles 1
GLAD_API_CALL int GLAD_GL_NV_conservative_raster_pre_snap_triangles;
#define GL_NV_copy_depth_to_color 1
GLAD_API_CALL int GLAD_GL_NV_copy_depth_to_color;
#define GL_NV_copy_image 1
GLAD_API_CALL int GLAD_GL_NV_copy_image;
#define GL_NV_deep_texture3D 1
GLAD_API_CALL int GLAD_GL_NV_deep_texture3D;
#define GL_NV_depth_buffer_float 1
GLAD_API_CALL int GLAD_GL_NV_depth_buffer_float;
#define GL_NV_depth_clamp 1
GLAD_API_CALL int GLAD_GL_NV_depth_clamp;
#define GL_NV_draw_texture 1
GLAD_API_CALL int GLAD_GL_NV_draw_texture;
#define GL_NV_draw_vulkan_image 1
GLAD_API_CALL int GLAD_GL_NV_draw_vulkan_image;
#define GL_NV_evaluators 1
GLAD_API_CALL int GLAD_GL_NV_evaluators;
#define GL_NV_explicit_multisample 1
GLAD_API_CALL int GLAD_GL_NV_explicit_multisample;
#define GL_NV_fence 1
GLAD_API_CALL int GLAD_GL_NV_fence;
#define GL_NV_fill_rectangle 1
GLAD_API_CALL int GLAD_GL_NV_fill_rectangle;
#define GL_NV_float_buffer 1
GLAD_API_CALL int GLAD_GL_NV_float_buffer;
#define GL_NV_fog_distance 1
GLAD_API_CALL int GLAD_GL_NV_fog_distance;
#define GL_NV_fragment_coverage_to_color 1
GLAD_API_CALL int GLAD_GL_NV_fragment_coverage_to_color;
#define GL_NV_fragment_program 1
GLAD_API_CALL int GLAD_GL_NV_fragment_program;
#define GL_NV_fragment_program2 1
GLAD_API_CALL int GLAD_GL_NV_fragment_program2;
#define GL_NV_fragment_program4 1
GLAD_API_CALL int GLAD_GL_NV_fragment_program4;
#define GL_NV_fragment_program_option 1
GLAD_API_CALL int GLAD_GL_NV_fragment_program_option;
#define GL_NV_fragment_shader_interlock 1
GLAD_API_CALL int GLAD_GL_NV_fragment_shader_interlock;
#define GL_NV_framebuffer_mixed_samples 1
GLAD_API_CALL int GLAD_GL_NV_framebuffer_mixed_samples;
#define GL_NV_framebuffer_multisample_coverage 1
GLAD_API_CALL int GLAD_GL_NV_framebuffer_multisample_coverage;
#define GL_NV_geometry_program4 1
GLAD_API_CALL int GLAD_GL_NV_geometry_program4;
#define GL_NV_geometry_shader4 1
GLAD_API_CALL int GLAD_GL_NV_geometry_shader4;
#define GL_NV_geometry_shader_passthrough 1
GLAD_API_CALL int GLAD_GL_NV_geometry_shader_passthrough;
#define GL_NV_gpu_multicast 1
GLAD_API_CALL int GLAD_GL_NV_gpu_multicast;
#define GL_NV_gpu_program4 1
GLAD_API_CALL int GLAD_GL_NV_gpu_program4;
#define GL_NV_gpu_program5 1
GLAD_API_CALL int GLAD_GL_NV_gpu_program5;
#define GL_NV_gpu_program5_mem_extended 1
GLAD_API_CALL int GLAD_GL_NV_gpu_program5_mem_extended;
#define GL_NV_gpu_shader5 1
GLAD_API_CALL int GLAD_GL_NV_gpu_shader5;
#define GL_NV_half_float 1
GLAD_API_CALL int GLAD_GL_NV_half_float;
#define GL_NV_internalformat_sample_query 1
GLAD_API_CALL int GLAD_GL_NV_internalformat_sample_query;
#define GL_NV_light_max_exponent 1
GLAD_API_CALL int GLAD_GL_NV_light_max_exponent;
#define GL_NV_multisample_coverage 1
GLAD_API_CALL int GLAD_GL_NV_multisample_coverage;
#define GL_NV_multisample_filter_hint 1
GLAD_API_CALL int GLAD_GL_NV_multisample_filter_hint;
#define GL_NV_occlusion_query 1
GLAD_API_CALL int GLAD_GL_NV_occlusion_query;
#define GL_NV_packed_depth_stencil 1
GLAD_API_CALL int GLAD_GL_NV_packed_depth_stencil;
#define GL_NV_parameter_buffer_object 1
GLAD_API_CALL int GLAD_GL_NV_parameter_buffer_object;
#define GL_NV_parameter_buffer_object2 1
GLAD_API_CALL int GLAD_GL_NV_parameter_buffer_object2;
#define GL_NV_path_rendering 1
GLAD_API_CALL int GLAD_GL_NV_path_rendering;
#define GL_NV_path_rendering_shared_edge 1
GLAD_API_CALL int GLAD_GL_NV_path_rendering_shared_edge;
#define GL_NV_pixel_data_range 1
GLAD_API_CALL int GLAD_GL_NV_pixel_data_range;
#define GL_NV_point_sprite 1
GLAD_API_CALL int GLAD_GL_NV_point_sprite;
#define GL_NV_present_video 1
GLAD_API_CALL int GLAD_GL_NV_present_video;
#define GL_NV_primitive_restart 1
GLAD_API_CALL int GLAD_GL_NV_primitive_restart;
#define GL_NV_query_resource 1
GLAD_API_CALL int GLAD_GL_NV_query_resource;
#define GL_NV_query_resource_tag 1
GLAD_API_CALL int GLAD_GL_NV_query_resource_tag;
#define GL_NV_register_combiners 1
GLAD_API_CALL int GLAD_GL_NV_register_combiners;
#define GL_NV_register_combiners2 1
GLAD_API_CALL int GLAD_GL_NV_register_combiners2;
#define GL_NV_robustness_video_memory_purge 1
GLAD_API_CALL int GLAD_GL_NV_robustness_video_memory_purge;
#define GL_NV_sample_locations 1
GLAD_API_CALL int GLAD_GL_NV_sample_locations;
#define GL_NV_sample_mask_override_coverage 1
GLAD_API_CALL int GLAD_GL_NV_sample_mask_override_coverage;
#define GL_NV_shader_atomic_counters 1
GLAD_API_CALL int GLAD_GL_NV_shader_atomic_counters;
#define GL_NV_shader_atomic_float 1
GLAD_API_CALL int GLAD_GL_NV_shader_atomic_float;
#define GL_NV_shader_atomic_float64 1
GLAD_API_CALL int GLAD_GL_NV_shader_atomic_float64;
#define GL_NV_shader_atomic_fp16_vector 1
GLAD_API_CALL int GLAD_GL_NV_shader_atomic_fp16_vector;
#define GL_NV_shader_atomic_int64 1
GLAD_API_CALL int GLAD_GL_NV_shader_atomic_int64;
#define GL_NV_shader_buffer_load 1
GLAD_API_CALL int GLAD_GL_NV_shader_buffer_load;
#define GL_NV_shader_buffer_store 1
GLAD_API_CALL int GLAD_GL_NV_shader_buffer_store;
#define GL_NV_shader_storage_buffer_object 1
GLAD_API_CALL int GLAD_GL_NV_shader_storage_buffer_object;
#define GL_NV_shader_thread_group 1
GLAD_API_CALL int GLAD_GL_NV_shader_thread_group;
#define GL_NV_shader_thread_shuffle 1
GLAD_API_CALL int GLAD_GL_NV_shader_thread_shuffle;
#define GL_NV_stereo_view_rendering 1
GLAD_API_CALL int GLAD_GL_NV_stereo_view_rendering;
#define GL_NV_tessellation_program5 1
GLAD_API_CALL int GLAD_GL_NV_tessellation_program5;
#define GL_NV_texgen_emboss 1
GLAD_API_CALL int GLAD_GL_NV_texgen_emboss;
#define GL_NV_texgen_reflection 1
GLAD_API_CALL int GLAD_GL_NV_texgen_reflection;
#define GL_NV_texture_barrier 1
GLAD_API_CALL int GLAD_GL_NV_texture_barrier;
#define GL_NV_texture_compression_vtc 1
GLAD_API_CALL int GLAD_GL_NV_texture_compression_vtc;
#define GL_NV_texture_env_combine4 1
GLAD_API_CALL int GLAD_GL_NV_texture_env_combine4;
#define GL_NV_texture_expand_normal 1
GLAD_API_CALL int GLAD_GL_NV_texture_expand_normal;
#define GL_NV_texture_multisample 1
GLAD_API_CALL int GLAD_GL_NV_texture_multisample;
#define GL_NV_texture_rectangle 1
GLAD_API_CALL int GLAD_GL_NV_texture_rectangle;
#define GL_NV_texture_rectangle_compressed 1
GLAD_API_CALL int GLAD_GL_NV_texture_rectangle_compressed;
#define GL_NV_texture_shader 1
GLAD_API_CALL int GLAD_GL_NV_texture_shader;
#define GL_NV_texture_shader2 1
GLAD_API_CALL int GLAD_GL_NV_texture_shader2;
#define GL_NV_texture_shader3 1
GLAD_API_CALL int GLAD_GL_NV_texture_shader3;
#define GL_NV_transform_feedback 1
GLAD_API_CALL int GLAD_GL_NV_transform_feedback;
#define GL_NV_transform_feedback2 1
GLAD_API_CALL int GLAD_GL_NV_transform_feedback2;
#define GL_NV_uniform_buffer_unified_memory 1
GLAD_API_CALL int GLAD_GL_NV_uniform_buffer_unified_memory;
#define GL_NV_vdpau_interop 1
GLAD_API_CALL int GLAD_GL_NV_vdpau_interop;
#define GL_NV_vertex_array_range 1
GLAD_API_CALL int GLAD_GL_NV_vertex_array_range;
#define GL_NV_vertex_array_range2 1
GLAD_API_CALL int GLAD_GL_NV_vertex_array_range2;
#define GL_NV_vertex_attrib_integer_64bit 1
GLAD_API_CALL int GLAD_GL_NV_vertex_attrib_integer_64bit;
#define GL_NV_vertex_buffer_unified_memory 1
GLAD_API_CALL int GLAD_GL_NV_vertex_buffer_unified_memory;
#define GL_NV_vertex_program 1
GLAD_API_CALL int GLAD_GL_NV_vertex_program;
#define GL_NV_vertex_program1_1 1
GLAD_API_CALL int GLAD_GL_NV_vertex_program1_1;
#define GL_NV_vertex_program2 1
GLAD_API_CALL int GLAD_GL_NV_vertex_program2;
#define GL_NV_vertex_program2_option 1
GLAD_API_CALL int GLAD_GL_NV_vertex_program2_option;
#define GL_NV_vertex_program3 1
GLAD_API_CALL int GLAD_GL_NV_vertex_program3;
#define GL_NV_vertex_program4 1
GLAD_API_CALL int GLAD_GL_NV_vertex_program4;
#define GL_NV_video_capture 1
GLAD_API_CALL int GLAD_GL_NV_video_capture;
#define GL_NV_viewport_array2 1
GLAD_API_CALL int GLAD_GL_NV_viewport_array2;
#define GL_NV_viewport_swizzle 1
GLAD_API_CALL int GLAD_GL_NV_viewport_swizzle;


typedef GLboolean (GLAD_API_PTR *PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC)(GLuint memory, GLuint64 key, GLuint timeout);
typedef void (GLAD_API_PTR *PFNGLACTIVEPROGRAMEXTPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLACTIVESHADERPROGRAMPROC)(GLuint pipeline, GLuint program);
typedef void (GLAD_API_PTR *PFNGLACTIVESTENCILFACEEXTPROC)(GLenum face);
typedef void (GLAD_API_PTR *PFNGLACTIVETEXTUREPROC)(GLenum texture);
typedef void (GLAD_API_PTR *PFNGLACTIVETEXTUREARBPROC)(GLenum texture);
typedef void (GLAD_API_PTR *PFNGLACTIVEVARYINGNVPROC)(GLuint program, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLALPHAFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (GLAD_API_PTR *PFNGLALPHAFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (GLAD_API_PTR *PFNGLALPHAFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (GLAD_API_PTR *PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC)(void);
typedef void (GLAD_API_PTR *PFNGLAPPLYTEXTUREEXTPROC)(GLenum mode);
typedef GLboolean (GLAD_API_PTR *PFNGLAREPROGRAMSRESIDENTNVPROC)(GLsizei n, const GLuint * programs, GLboolean * residences);
typedef GLboolean (GLAD_API_PTR *PFNGLARETEXTURESRESIDENTEXTPROC)(GLsizei n, const GLuint * textures, GLboolean * residences);
typedef void (GLAD_API_PTR *PFNGLARRAYELEMENTPROC)(GLint i);
typedef void (GLAD_API_PTR *PFNGLARRAYELEMENTEXTPROC)(GLint i);
typedef void (GLAD_API_PTR *PFNGLARRAYOBJECTATIPROC)(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void (GLAD_API_PTR *PFNGLATTACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB obj);
typedef void (GLAD_API_PTR *PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
typedef void (GLAD_API_PTR *PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBEGINCONDITIONALRENDERNVPROC)(GLuint id, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBEGINCONDITIONALRENDERNVXPROC)(GLuint id);
typedef void (GLAD_API_PTR *PFNGLBEGINFRAGMENTSHADERATIPROC)(void);
typedef void (GLAD_API_PTR *PFNGLBEGINOCCLUSIONQUERYNVPROC)(GLuint id);
typedef void (GLAD_API_PTR *PFNGLBEGINPERFMONITORAMDPROC)(GLuint monitor);
typedef void (GLAD_API_PTR *PFNGLBEGINPERFQUERYINTELPROC)(GLuint queryHandle);
typedef void (GLAD_API_PTR *PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBEGINQUERYARBPROC)(GLenum target, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
typedef void (GLAD_API_PTR *PFNGLBEGINTRANSFORMFEEDBACKEXTPROC)(GLenum primitiveMode);
typedef void (GLAD_API_PTR *PFNGLBEGINTRANSFORMFEEDBACKNVPROC)(GLenum primitiveMode);
typedef void (GLAD_API_PTR *PFNGLBEGINVERTEXSHADEREXTPROC)(void);
typedef void (GLAD_API_PTR *PFNGLBEGINVIDEOCAPTURENVPROC)(GLuint video_capture_slot);
typedef void (GLAD_API_PTR *PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDATTRIBLOCATIONARBPROC)(GLhandleARB programObj, GLuint index, const GLcharARB * name);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERARBPROC)(GLenum target, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERBASEEXTPROC)(GLenum target, GLuint index, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERBASENVPROC)(GLenum target, GLuint index, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFEROFFSETEXTPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFEROFFSETNVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERRANGEEXTPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERRANGENVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERSBASEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLBINDBUFFERSRANGEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizeiptr * sizes);
typedef void (GLAD_API_PTR *PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDFRAGDATALOCATIONEXTPROC)(GLuint program, GLuint color, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLBINDFRAGMENTSHADERATIPROC)(GLuint id);
typedef void (GLAD_API_PTR *PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
typedef void (GLAD_API_PTR *PFNGLBINDFRAMEBUFFEREXTPROC)(GLenum target, GLuint framebuffer);
typedef void (GLAD_API_PTR *PFNGLBINDIMAGETEXTUREPROC)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void (GLAD_API_PTR *PFNGLBINDIMAGETEXTUREEXTPROC)(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void (GLAD_API_PTR *PFNGLBINDIMAGETEXTURESPROC)(GLuint first, GLsizei count, const GLuint * textures);
typedef GLuint (GLAD_API_PTR *PFNGLBINDLIGHTPARAMETEREXTPROC)(GLenum light, GLenum value);
typedef GLuint (GLAD_API_PTR *PFNGLBINDMATERIALPARAMETEREXTPROC)(GLenum face, GLenum value);
typedef void (GLAD_API_PTR *PFNGLBINDMULTITEXTUREEXTPROC)(GLenum texunit, GLenum target, GLuint texture);
typedef GLuint (GLAD_API_PTR *PFNGLBINDPARAMETEREXTPROC)(GLenum value);
typedef void (GLAD_API_PTR *PFNGLBINDPROGRAMARBPROC)(GLenum target, GLuint program);
typedef void (GLAD_API_PTR *PFNGLBINDPROGRAMNVPROC)(GLenum target, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBINDPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef void (GLAD_API_PTR *PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLBINDRENDERBUFFEREXTPROC)(GLenum target, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
typedef void (GLAD_API_PTR *PFNGLBINDSAMPLERSPROC)(GLuint first, GLsizei count, const GLuint * samplers);
typedef GLuint (GLAD_API_PTR *PFNGLBINDTEXGENPARAMETEREXTPROC)(GLenum unit, GLenum coord, GLenum value);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTUREEXTPROC)(GLenum target, GLuint texture);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTUREUNITPROC)(GLuint unit, GLuint texture);
typedef GLuint (GLAD_API_PTR *PFNGLBINDTEXTUREUNITPARAMETEREXTPROC)(GLenum unit, GLenum value);
typedef void (GLAD_API_PTR *PFNGLBINDTEXTURESPROC)(GLuint first, GLsizei count, const GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBINDTRANSFORMFEEDBACKNVPROC)(GLenum target, GLuint id);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXARRAYPROC)(GLuint array);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXARRAYAPPLEPROC)(GLuint array);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXBUFFERPROC)(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXBUFFERSPROC)(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);
typedef void (GLAD_API_PTR *PFNGLBINDVERTEXSHADEREXTPROC)(GLuint id);
typedef void (GLAD_API_PTR *PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void (GLAD_API_PTR *PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC)(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3BEXTPROC)(GLbyte bx, GLbyte by, GLbyte bz);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3BVEXTPROC)(const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3DEXTPROC)(GLdouble bx, GLdouble by, GLdouble bz);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3DVEXTPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3FEXTPROC)(GLfloat bx, GLfloat by, GLfloat bz);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3FVEXTPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3IEXTPROC)(GLint bx, GLint by, GLint bz);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3IVEXTPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3SEXTPROC)(GLshort bx, GLshort by, GLshort bz);
typedef void (GLAD_API_PTR *PFNGLBINORMAL3SVEXTPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLBINORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLBLENDBARRIERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLBLENDBARRIERKHRPROC)(void);
typedef void (GLAD_API_PTR *PFNGLBLENDBARRIERNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GLAD_API_PTR *PFNGLBLENDCOLOREXTPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONEXTPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONINDEXEDAMDPROC)(GLuint buf, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEEXTPROC)(GLenum modeRGB, GLenum modeAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEIPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONSEPARATEIARBPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONIPROC)(GLuint buf, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBLENDEQUATIONIARBPROC)(GLuint buf, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCINDEXEDAMDPROC)(GLuint buf, GLenum src, GLenum dst);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEEXTPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEIPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCSEPARATEIARBPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCIPROC)(GLuint buf, GLenum src, GLenum dst);
typedef void (GLAD_API_PTR *PFNGLBLENDFUNCIARBPROC)(GLuint buf, GLenum src, GLenum dst);
typedef void (GLAD_API_PTR *PFNGLBLENDPARAMETERINVPROC)(GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GLAD_API_PTR *PFNGLBLITFRAMEBUFFEREXTPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GLAD_API_PTR *PFNGLBLITNAMEDFRAMEBUFFERPROC)(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GLAD_API_PTR *PFNGLBUFFERADDRESSRANGENVPROC)(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const void * data, GLenum usage);
typedef void (GLAD_API_PTR *PFNGLBUFFERDATAARBPROC)(GLenum target, GLsizeiptrARB size, const void * data, GLenum usage);
typedef void (GLAD_API_PTR *PFNGLBUFFERPAGECOMMITMENTARBPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);
typedef void (GLAD_API_PTR *PFNGLBUFFERPARAMETERIAPPLEPROC)(GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLBUFFERSTORAGEPROC)(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLBUFFERSTORAGEEXTERNALEXTPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLBUFFERSTORAGEMEMEXTPROC)(GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (GLAD_API_PTR *PFNGLBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void * data);
typedef void (GLAD_API_PTR *PFNGLCALLCOMMANDLISTNVPROC)(GLuint list);
typedef GLenum (GLAD_API_PTR *PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
typedef GLenum (GLAD_API_PTR *PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)(GLenum target);
typedef GLenum (GLAD_API_PTR *PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)(GLuint framebuffer, GLenum target);
typedef GLenum (GLAD_API_PTR *PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC)(GLuint framebuffer, GLenum target);
typedef void (GLAD_API_PTR *PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
typedef void (GLAD_API_PTR *PFNGLCLAMPCOLORARBPROC)(GLenum target, GLenum clamp);
typedef void (GLAD_API_PTR *PFNGLCLEARPROC)(GLbitfield mask);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERDATAPROC)(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERSUBDATAPROC)(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (GLAD_API_PTR *PFNGLCLEARCOLORIIEXTPROC)(GLint red, GLint green, GLint blue, GLint alpha);
typedef void (GLAD_API_PTR *PFNGLCLEARCOLORIUIEXTPROC)(GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void (GLAD_API_PTR *PFNGLCLEARDEPTHPROC)(GLdouble depth);
typedef void (GLAD_API_PTR *PFNGLCLEARDEPTHDNVPROC)(GLdouble depth);
typedef void (GLAD_API_PTR *PFNGLCLEARDEPTHFPROC)(GLfloat d);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDBUFFERDATAPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDBUFFERDATAEXTPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLCLEARSTENCILPROC)(GLint s);
typedef void (GLAD_API_PTR *PFNGLCLEARTEXIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLEARTEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCLIENTACTIVETEXTUREPROC)(GLenum texture);
typedef void (GLAD_API_PTR *PFNGLCLIENTACTIVETEXTUREARBPROC)(GLenum texture);
typedef void (GLAD_API_PTR *PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC)(GLenum stream);
typedef void (GLAD_API_PTR *PFNGLCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
typedef GLenum (GLAD_API_PTR *PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (GLAD_API_PTR *PFNGLCLIPCONTROLPROC)(GLenum origin, GLenum depth);
typedef void (GLAD_API_PTR *PFNGLCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void (GLAD_API_PTR *PFNGLCOLOR3HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLCOLOR4HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
typedef void (GLAD_API_PTR *PFNGLCOLOR4HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLCOLORFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLCOLORFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (GLAD_API_PTR *PFNGLCOLORFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (GLAD_API_PTR *PFNGLCOLORFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (GLAD_API_PTR *PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (GLAD_API_PTR *PFNGLCOLORMASKINDEXEDEXTPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (GLAD_API_PTR *PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (GLAD_API_PTR *PFNGLCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLCOLORPOINTERVINTELPROC)(GLint size, GLenum type, const void ** pointer);
typedef void (GLAD_API_PTR *PFNGLCOLORSUBTABLEPROC)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOLORTABLEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * table);
typedef void (GLAD_API_PTR *PFNGLCOLORTABLEEXTPROC)(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void * table);
typedef void (GLAD_API_PTR *PFNGLCOMBINERINPUTNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (GLAD_API_PTR *PFNGLCOMBINEROUTPUTNVPROC)(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void (GLAD_API_PTR *PFNGLCOMBINERPARAMETERFNVPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLCOMBINERPARAMETERFVNVPROC)(GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLCOMBINERPARAMETERINVPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLCOMBINERPARAMETERIVNVPROC)(GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLCOMMANDLISTSEGMENTSNVPROC)(GLuint list, GLuint segments);
typedef void (GLAD_API_PTR *PFNGLCOMPILECOMMANDLISTNVPROC)(GLuint list);
typedef void (GLAD_API_PTR *PFNGLCOMPILESHADERPROC)(GLuint shader);
typedef void (GLAD_API_PTR *PFNGLCOMPILESHADERARBPROC)(GLhandleARB shaderObj);
typedef void (GLAD_API_PTR *PFNGLCOMPILESHADERINCLUDEARBPROC)(GLuint shader, GLsizei count, const GLchar *const* path, const GLint * length);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE1DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE2DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXIMAGE3DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (GLAD_API_PTR *PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * bits);
typedef void (GLAD_API_PTR *PFNGLCONSERVATIVERASTERPARAMETERFNVPROC)(GLenum pname, GLfloat value);
typedef void (GLAD_API_PTR *PFNGLCONSERVATIVERASTERPARAMETERINVPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONFILTER1DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * image);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * image);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONFILTER2DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * image);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * image);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat params);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONPARAMETERFEXTPROC)(GLenum target, GLenum pname, GLfloat params);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONPARAMETERIPROC)(GLenum target, GLenum pname, GLint params);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONPARAMETERIEXTPROC)(GLenum target, GLenum pname, GLint params);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLCOPYCOLORSUBTABLEPROC)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYCONVOLUTIONFILTER1DPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYCONVOLUTIONFILTER2DPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYIMAGESUBDATAPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void (GLAD_API_PTR *PFNGLCOPYIMAGESUBDATANVPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GLAD_API_PTR *PFNGLCOPYMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYNAMEDBUFFERSUBDATAPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLCOPYPATHNVPROC)(GLuint resultPath, GLuint srcPath);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE1DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXIMAGE2DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLCOVERFILLPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);
typedef void (GLAD_API_PTR *PFNGLCOVERFILLPATHNVPROC)(GLuint path, GLenum coverMode);
typedef void (GLAD_API_PTR *PFNGLCOVERSTROKEPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);
typedef void (GLAD_API_PTR *PFNGLCOVERSTROKEPATHNVPROC)(GLuint path, GLenum coverMode);
typedef void (GLAD_API_PTR *PFNGLCOVERAGEMODULATIONNVPROC)(GLenum components);
typedef void (GLAD_API_PTR *PFNGLCOVERAGEMODULATIONTABLENVPROC)(GLsizei n, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLCREATEBUFFERSPROC)(GLsizei n, GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLCREATECOMMANDLISTSNVPROC)(GLsizei n, GLuint * lists);
typedef void (GLAD_API_PTR *PFNGLCREATEFRAMEBUFFERSPROC)(GLsizei n, GLuint * framebuffers);
typedef void (GLAD_API_PTR *PFNGLCREATEMEMORYOBJECTSEXTPROC)(GLsizei n, GLuint * memoryObjects);
typedef void (GLAD_API_PTR *PFNGLCREATEPERFQUERYINTELPROC)(GLuint queryId, GLuint * queryHandle);
typedef GLuint (GLAD_API_PTR *PFNGLCREATEPROGRAMPROC)(void);
typedef GLhandleARB (GLAD_API_PTR *PFNGLCREATEPROGRAMOBJECTARBPROC)(void);
typedef void (GLAD_API_PTR *PFNGLCREATEPROGRAMPIPELINESPROC)(GLsizei n, GLuint * pipelines);
typedef void (GLAD_API_PTR *PFNGLCREATEQUERIESPROC)(GLenum target, GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLCREATERENDERBUFFERSPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLCREATESAMPLERSPROC)(GLsizei n, GLuint * samplers);
typedef GLuint (GLAD_API_PTR *PFNGLCREATESHADERPROC)(GLenum type);
typedef GLhandleARB (GLAD_API_PTR *PFNGLCREATESHADEROBJECTARBPROC)(GLenum shaderType);
typedef GLuint (GLAD_API_PTR *PFNGLCREATESHADERPROGRAMEXTPROC)(GLenum type, const GLchar * string);
typedef GLuint (GLAD_API_PTR *PFNGLCREATESHADERPROGRAMVPROC)(GLenum type, GLsizei count, const GLchar *const* strings);
typedef void (GLAD_API_PTR *PFNGLCREATESTATESNVPROC)(GLsizei n, GLuint * states);
typedef GLsync (GLAD_API_PTR *PFNGLCREATESYNCFROMCLEVENTARBPROC)(struct _cl_context * context, struct _cl_event * event, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLCREATETEXTURESPROC)(GLenum target, GLsizei n, GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLCREATETRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLCREATEVERTEXARRAYSPROC)(GLsizei n, GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLCULLFACEPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLCULLPARAMETERDVEXTPROC)(GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLCULLPARAMETERFVEXTPROC)(GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLCURRENTPALETTEMATRIXARBPROC)(GLint index);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGECALLBACKPROC)(GLDEBUGPROC callback, const void * userParam);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGECALLBACKAMDPROC)(GLDEBUGPROCAMD callback, void * userParam);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGECALLBACKARBPROC)(GLDEBUGPROCARB callback, const void * userParam);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGECONTROLPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGECONTROLARBPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGEENABLEAMDPROC)(GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGEINSERTPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGEINSERTAMDPROC)(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf);
typedef void (GLAD_API_PTR *PFNGLDEBUGMESSAGEINSERTARBPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);
typedef void (GLAD_API_PTR *PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLDELETEBUFFERSARBPROC)(GLsizei n, const GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLDELETECOMMANDLISTSNVPROC)(GLsizei n, const GLuint * lists);
typedef void (GLAD_API_PTR *PFNGLDELETEFENCESAPPLEPROC)(GLsizei n, const GLuint * fences);
typedef void (GLAD_API_PTR *PFNGLDELETEFENCESNVPROC)(GLsizei n, const GLuint * fences);
typedef void (GLAD_API_PTR *PFNGLDELETEFRAGMENTSHADERATIPROC)(GLuint id);
typedef void (GLAD_API_PTR *PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint * framebuffers);
typedef void (GLAD_API_PTR *PFNGLDELETEFRAMEBUFFERSEXTPROC)(GLsizei n, const GLuint * framebuffers);
typedef void (GLAD_API_PTR *PFNGLDELETEMEMORYOBJECTSEXTPROC)(GLsizei n, const GLuint * memoryObjects);
typedef void (GLAD_API_PTR *PFNGLDELETENAMEDSTRINGARBPROC)(GLint namelen, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLDELETENAMESAMDPROC)(GLenum identifier, GLuint num, const GLuint * names);
typedef void (GLAD_API_PTR *PFNGLDELETEOBJECTARBPROC)(GLhandleARB obj);
typedef void (GLAD_API_PTR *PFNGLDELETEOCCLUSIONQUERIESNVPROC)(GLsizei n, const GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLDELETEPATHSNVPROC)(GLuint path, GLsizei range);
typedef void (GLAD_API_PTR *PFNGLDELETEPERFMONITORSAMDPROC)(GLsizei n, GLuint * monitors);
typedef void (GLAD_API_PTR *PFNGLDELETEPERFQUERYINTELPROC)(GLuint queryHandle);
typedef void (GLAD_API_PTR *PFNGLDELETEPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLDELETEPROGRAMPIPELINESPROC)(GLsizei n, const GLuint * pipelines);
typedef void (GLAD_API_PTR *PFNGLDELETEPROGRAMSARBPROC)(GLsizei n, const GLuint * programs);
typedef void (GLAD_API_PTR *PFNGLDELETEPROGRAMSNVPROC)(GLsizei n, const GLuint * programs);
typedef void (GLAD_API_PTR *PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLDELETEQUERIESARBPROC)(GLsizei n, const GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLDELETEQUERYRESOURCETAGNVPROC)(GLsizei n, const GLint * tagIds);
typedef void (GLAD_API_PTR *PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLDELETERENDERBUFFERSEXTPROC)(GLsizei n, const GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint * samplers);
typedef void (GLAD_API_PTR *PFNGLDELETESEMAPHORESEXTPROC)(GLsizei n, const GLuint * semaphores);
typedef void (GLAD_API_PTR *PFNGLDELETESHADERPROC)(GLuint shader);
typedef void (GLAD_API_PTR *PFNGLDELETESTATESNVPROC)(GLsizei n, const GLuint * states);
typedef void (GLAD_API_PTR *PFNGLDELETESYNCPROC)(GLsync sync);
typedef void (GLAD_API_PTR *PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLDELETETEXTURESEXTPROC)(GLsizei n, const GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLDELETETRANSFORMFEEDBACKSNVPROC)(GLsizei n, const GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLDELETEVERTEXARRAYSAPPLEPROC)(GLsizei n, const GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLDELETEVERTEXSHADEREXTPROC)(GLuint id);
typedef void (GLAD_API_PTR *PFNGLDEPTHBOUNDSEXTPROC)(GLclampd zmin, GLclampd zmax);
typedef void (GLAD_API_PTR *PFNGLDEPTHBOUNDSDNVPROC)(GLdouble zmin, GLdouble zmax);
typedef void (GLAD_API_PTR *PFNGLDEPTHFUNCPROC)(GLenum func);
typedef void (GLAD_API_PTR *PFNGLDEPTHMASKPROC)(GLboolean flag);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEPROC)(GLdouble n, GLdouble f);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEARRAYVPROC)(GLuint first, GLsizei count, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEINDEXEDPROC)(GLuint index, GLdouble n, GLdouble f);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEDNVPROC)(GLdouble zNear, GLdouble zFar);
typedef void (GLAD_API_PTR *PFNGLDEPTHRANGEFPROC)(GLfloat n, GLfloat f);
typedef void (GLAD_API_PTR *PFNGLDETACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void (GLAD_API_PTR *PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
typedef void (GLAD_API_PTR *PFNGLDISABLEPROC)(GLenum cap);
typedef void (GLAD_API_PTR *PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISABLEIPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLDISPATCHCOMPUTEPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void (GLAD_API_PTR *PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
typedef void (GLAD_API_PTR *PFNGLDISPATCHCOMPUTEINDIRECTPROC)(GLintptr indirect);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSEXTPROC)(GLenum mode, GLint first, GLsizei count);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void * indirect);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINSTANCEDARBPROC)(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
typedef void (GLAD_API_PTR *PFNGLDRAWARRAYSINSTANCEDEXTPROC)(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERPROC)(GLenum buf);
typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum * bufs);
typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERSARBPROC)(GLsizei n, const GLenum * bufs);
typedef void (GLAD_API_PTR *PFNGLDRAWBUFFERSATIPROC)(GLsizei n, const GLenum * bufs);
typedef void (GLAD_API_PTR *PFNGLDRAWCOMMANDSADDRESSNVPROC)(GLenum primitiveMode, const GLuint64 * indirects, const GLsizei * sizes, GLuint count);
typedef void (GLAD_API_PTR *PFNGLDRAWCOMMANDSNVPROC)(GLenum primitiveMode, GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, GLuint count);
typedef void (GLAD_API_PTR *PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC)(const GLuint64 * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);
typedef void (GLAD_API_PTR *PFNGLDRAWCOMMANDSSTATESNVPROC)(GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, GLint first, GLsizei count);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTARRAYATIPROC)(GLenum mode, GLsizei count);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void * indirect);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDARBPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
typedef void (GLAD_API_PTR *PFNGLDRAWELEMENTSINSTANCEDEXTPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);
typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTARRAYATIPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);
typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex);
typedef void (GLAD_API_PTR *PFNGLDRAWRANGEELEMENTSEXTPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);
typedef void (GLAD_API_PTR *PFNGLDRAWTEXTURENVPROC)(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)(GLenum mode, GLuint id, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKNVPROC)(GLenum mode, GLuint id);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id, GLuint stream);
typedef void (GLAD_API_PTR *PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
typedef void (GLAD_API_PTR *PFNGLDRAWVKIMAGENVPROC)(GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
typedef void (GLAD_API_PTR *PFNGLEDGEFLAGFORMATNVPROC)(GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLEDGEFLAGPOINTEREXTPROC)(GLsizei stride, GLsizei count, const GLboolean * pointer);
typedef void (GLAD_API_PTR *PFNGLELEMENTPOINTERAPPLEPROC)(GLenum type, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLELEMENTPOINTERATIPROC)(GLenum type, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLENABLEPROC)(GLenum cap);
typedef void (GLAD_API_PTR *PFNGLENABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLENABLEIPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENDCONDITIONALRENDERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDCONDITIONALRENDERNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDCONDITIONALRENDERNVXPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDFRAGMENTSHADERATIPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDOCCLUSIONQUERYNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDPERFMONITORAMDPROC)(GLuint monitor);
typedef void (GLAD_API_PTR *PFNGLENDPERFQUERYINTELPROC)(GLuint queryHandle);
typedef void (GLAD_API_PTR *PFNGLENDQUERYPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLENDQUERYARBPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
typedef void (GLAD_API_PTR *PFNGLENDTRANSFORMFEEDBACKPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDTRANSFORMFEEDBACKEXTPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDTRANSFORMFEEDBACKNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDVERTEXSHADEREXTPROC)(void);
typedef void (GLAD_API_PTR *PFNGLENDVIDEOCAPTURENVPROC)(GLuint video_capture_slot);
typedef void (GLAD_API_PTR *PFNGLEVALMAPSNVPROC)(GLenum target, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLEVALUATEDEPTHVALUESARBPROC)(void);
typedef void (GLAD_API_PTR *PFNGLEXECUTEPROGRAMNVPROC)(GLenum target, GLuint id, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLEXTRACTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
typedef GLsync (GLAD_API_PTR *PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLFINALCOMBINERINPUTNVPROC)(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (GLAD_API_PTR *PFNGLFINISHPROC)(void);
typedef void (GLAD_API_PTR *PFNGLFINISHFENCEAPPLEPROC)(GLuint fence);
typedef void (GLAD_API_PTR *PFNGLFINISHFENCENVPROC)(GLuint fence);
typedef void (GLAD_API_PTR *PFNGLFINISHOBJECTAPPLEPROC)(GLenum object, GLint name);
typedef void (GLAD_API_PTR *PFNGLFLUSHPROC)(void);
typedef void (GLAD_API_PTR *PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC)(GLenum target, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLFLUSHPIXELDATARANGENVPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void * pointer);
typedef void (GLAD_API_PTR *PFNGLFLUSHVERTEXARRAYRANGENVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDFORMATNVPROC)(GLenum type, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDPOINTERPROC)(GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDPOINTEREXTPROC)(GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDDPROC)(GLdouble coord);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDDEXTPROC)(GLdouble coord);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDDVPROC)(const GLdouble * coord);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDDVEXTPROC)(const GLdouble * coord);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDFPROC)(GLfloat coord);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDFEXTPROC)(GLfloat coord);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDFVPROC)(const GLfloat * coord);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDFVEXTPROC)(const GLfloat * coord);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDHNVPROC)(GLhalfNV fog);
typedef void (GLAD_API_PTR *PFNGLFOGCOORDHVNVPROC)(const GLhalfNV * fog);
typedef void (GLAD_API_PTR *PFNGLFRAGMENTCOVERAGECOLORNVPROC)(GLuint color);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC)(GLuint framebuffer, GLsizei n, const GLenum * bufs);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERREADBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC)(GLenum target, GLuint start, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(GLenum target, GLuint start, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC)(GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat * values);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTUREARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTUREEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTUREFACEARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURELAYERARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (GLAD_API_PTR *PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (GLAD_API_PTR *PFNGLFREEOBJECTBUFFERATIPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLFRONTFACEPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLGENBUFFERSPROC)(GLsizei n, GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLGENBUFFERSARBPROC)(GLsizei n, GLuint * buffers);
typedef void (GLAD_API_PTR *PFNGLGENFENCESAPPLEPROC)(GLsizei n, GLuint * fences);
typedef void (GLAD_API_PTR *PFNGLGENFENCESNVPROC)(GLsizei n, GLuint * fences);
typedef GLuint (GLAD_API_PTR *PFNGLGENFRAGMENTSHADERSATIPROC)(GLuint range);
typedef void (GLAD_API_PTR *PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint * framebuffers);
typedef void (GLAD_API_PTR *PFNGLGENFRAMEBUFFERSEXTPROC)(GLsizei n, GLuint * framebuffers);
typedef void (GLAD_API_PTR *PFNGLGENNAMESAMDPROC)(GLenum identifier, GLuint num, GLuint * names);
typedef void (GLAD_API_PTR *PFNGLGENOCCLUSIONQUERIESNVPROC)(GLsizei n, GLuint * ids);
typedef GLuint (GLAD_API_PTR *PFNGLGENPATHSNVPROC)(GLsizei range);
typedef void (GLAD_API_PTR *PFNGLGENPERFMONITORSAMDPROC)(GLsizei n, GLuint * monitors);
typedef void (GLAD_API_PTR *PFNGLGENPROGRAMPIPELINESPROC)(GLsizei n, GLuint * pipelines);
typedef void (GLAD_API_PTR *PFNGLGENPROGRAMSARBPROC)(GLsizei n, GLuint * programs);
typedef void (GLAD_API_PTR *PFNGLGENPROGRAMSNVPROC)(GLsizei n, GLuint * programs);
typedef void (GLAD_API_PTR *PFNGLGENQUERIESPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLGENQUERIESARBPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLGENQUERYRESOURCETAGNVPROC)(GLsizei n, GLint * tagIds);
typedef void (GLAD_API_PTR *PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLGENRENDERBUFFERSEXTPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (GLAD_API_PTR *PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint * samplers);
typedef void (GLAD_API_PTR *PFNGLGENSEMAPHORESEXTPROC)(GLsizei n, GLuint * semaphores);
typedef GLuint (GLAD_API_PTR *PFNGLGENSYMBOLSEXTPROC)(GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
typedef void (GLAD_API_PTR *PFNGLGENTEXTURESPROC)(GLsizei n, GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLGENTEXTURESEXTPROC)(GLsizei n, GLuint * textures);
typedef void (GLAD_API_PTR *PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLGENTRANSFORMFEEDBACKSNVPROC)(GLsizei n, GLuint * ids);
typedef void (GLAD_API_PTR *PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint * arrays);
typedef void (GLAD_API_PTR *PFNGLGENVERTEXARRAYSAPPLEPROC)(GLsizei n, GLuint * arrays);
typedef GLuint (GLAD_API_PTR *PFNGLGENVERTEXSHADERSEXTPROC)(GLuint range);
typedef void (GLAD_API_PTR *PFNGLGENERATEMIPMAPPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLGENERATEMIPMAPEXTPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLGENERATEMULTITEXMIPMAPEXTPROC)(GLenum texunit, GLenum target);
typedef void (GLAD_API_PTR *PFNGLGENERATETEXTUREMIPMAPPROC)(GLuint texture);
typedef void (GLAD_API_PTR *PFNGLGENERATETEXTUREMIPMAPEXTPROC)(GLuint texture, GLenum target);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEATTRIBARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETACTIVEVARYINGNVPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETARRAYOBJECTFVATIPROC)(GLenum array, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETARRAYOBJECTIVATIPROC)(GLenum array, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETATTACHEDOBJECTSARBPROC)(GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj);
typedef void (GLAD_API_PTR *PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders);
typedef GLint (GLAD_API_PTR *PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETATTRIBLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB * name);
typedef void (GLAD_API_PTR *PFNGLGETBOOLEANINDEXEDVEXTPROC)(GLenum target, GLuint index, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERIVARBPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPARAMETERUI64VNVPROC)(GLenum target, GLenum pname, GLuint64EXT * params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERPOINTERVARBPROC)(GLenum target, GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, void * data);
typedef void (GLAD_API_PTR *PFNGLGETBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data);
typedef void (GLAD_API_PTR *PFNGLGETCOLORTABLEPROC)(GLenum target, GLenum format, GLenum type, void * table);
typedef void (GLAD_API_PTR *PFNGLGETCOLORTABLEEXTPROC)(GLenum target, GLenum format, GLenum type, void * data);
typedef void (GLAD_API_PTR *PFNGLGETCOLORTABLEPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETCOLORTABLEPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, GLfloat * params);
typedef GLuint (GLAD_API_PTR *PFNGLGETCOMMANDHEADERNVPROC)(GLenum tokenID, GLuint size);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC)(GLenum texunit, GLenum target, GLint lod, void * img);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, void * img);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint level, void * img);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC)(GLuint texture, GLenum target, GLint lod, void * img);
typedef void (GLAD_API_PTR *PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETCONVOLUTIONFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, void * image);
typedef void (GLAD_API_PTR *PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETCOVERAGEMODULATIONTABLENVPROC)(GLsizei bufSize, GLfloat * v);
typedef GLuint (GLAD_API_PTR *PFNGLGETDEBUGMESSAGELOGPROC)(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
typedef GLuint (GLAD_API_PTR *PFNGLGETDEBUGMESSAGELOGAMDPROC)(GLuint count, GLsizei bufSize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message);
typedef GLuint (GLAD_API_PTR *PFNGLGETDEBUGMESSAGELOGARBPROC)(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
typedef void (GLAD_API_PTR *PFNGLGETDOUBLEINDEXEDVEXTPROC)(GLenum target, GLuint index, GLdouble * data);
typedef void (GLAD_API_PTR *PFNGLGETDOUBLEI_VPROC)(GLenum target, GLuint index, GLdouble * data);
typedef void (GLAD_API_PTR *PFNGLGETDOUBLEI_VEXTPROC)(GLenum pname, GLuint index, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble * data);
typedef GLenum (GLAD_API_PTR *PFNGLGETERRORPROC)(void);
typedef void (GLAD_API_PTR *PFNGLGETFENCEIVNVPROC)(GLuint fence, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC)(GLenum variable, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC)(GLenum variable, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETFIRSTPERFQUERYIDINTELPROC)(GLuint * queryId);
typedef void (GLAD_API_PTR *PFNGLGETFLOATINDEXEDVEXTPROC)(GLenum target, GLuint index, GLfloat * data);
typedef void (GLAD_API_PTR *PFNGLGETFLOATI_VPROC)(GLenum target, GLuint index, GLfloat * data);
typedef void (GLAD_API_PTR *PFNGLGETFLOATI_VEXTPROC)(GLenum pname, GLuint index, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETFLOATVPROC)(GLenum pname, GLfloat * data);
typedef GLint (GLAD_API_PTR *PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETFRAGDATALOCATIONEXTPROC)(GLuint program, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC)(GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values);
typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum pname, GLint * params);
typedef GLenum (GLAD_API_PTR *PFNGLGETGRAPHICSRESETSTATUSPROC)(void);
typedef GLenum (GLAD_API_PTR *PFNGLGETGRAPHICSRESETSTATUSARBPROC)(void);
typedef GLhandleARB (GLAD_API_PTR *PFNGLGETHANDLEARBPROC)(GLenum pname);
typedef void (GLAD_API_PTR *PFNGLGETHISTOGRAMEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);
typedef void (GLAD_API_PTR *PFNGLGETHISTOGRAMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETHISTOGRAMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef GLuint64 (GLAD_API_PTR *PFNGLGETIMAGEHANDLEARBPROC)(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (GLAD_API_PTR *PFNGLGETIMAGEHANDLENVPROC)(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef void (GLAD_API_PTR *PFNGLGETINFOLOGARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64 * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGERINDEXEDVEXTPROC)(GLenum target, GLuint index, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETINTEGERUI64I_VNVPROC)(GLenum value, GLuint index, GLuint64EXT * result);
typedef void (GLAD_API_PTR *PFNGLGETINTEGERUI64VNVPROC)(GLenum value, GLuint64EXT * result);
typedef void (GLAD_API_PTR *PFNGLGETINTEGERVPROC)(GLenum pname, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETINTERNALFORMATSAMPLEIVNVPROC)(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETINTERNALFORMATI64VPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETINTERNALFORMATIVPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETINVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETINVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat * data);
typedef void (GLAD_API_PTR *PFNGLGETINVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETLOCALCONSTANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat * data);
typedef void (GLAD_API_PTR *PFNGLGETLOCALCONSTANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETMAPATTRIBPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETMAPATTRIBPARAMETERIVNVPROC)(GLenum target, GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void * points);
typedef void (GLAD_API_PTR *PFNGLGETMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC)(GLuint memoryObject, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMINMAXEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);
typedef void (GLAD_API_PTR *PFNGLGETMINMAXPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETMINMAXPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXIMAGEEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXPARAMETERIUIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat * val);
typedef void (GLAD_API_PTR *PFNGLGETMULTISAMPLEFVNVPROC)(GLenum pname, GLuint index, GLfloat * val);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)(GLuint buffer, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPARAMETERIVPROC)(GLuint buffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC)(GLuint buffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC)(GLuint buffer, GLenum pname, GLuint64EXT * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPOINTERVPROC)(GLuint buffer, GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERPOINTERVEXTPROC)(GLuint buffer, GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC)(GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)(GLuint framebuffer, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC)(GLuint program, GLenum target, GLuint index, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC)(GLuint program, GLenum target, GLuint index, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDPROGRAMSTRINGEXTPROC)(GLuint program, GLenum target, GLenum pname, void * string);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDPROGRAMIVEXTPROC)(GLuint program, GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)(GLuint renderbuffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC)(GLuint renderbuffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDSTRINGARBPROC)(GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string);
typedef void (GLAD_API_PTR *PFNGLGETNAMEDSTRINGIVARBPROC)(GLint namelen, const GLchar * name, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNEXTPERFQUERYIDINTELPROC)(GLuint queryId, GLuint * nextQueryId);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTBUFFERFVATIPROC)(GLuint buffer, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTBUFFERIVATIPROC)(GLuint buffer, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTLABELEXTPROC)(GLenum type, GLuint object, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTPARAMETERFVARBPROC)(GLhandleARB obj, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTPARAMETERIVAPPLEPROC)(GLenum objectType, GLuint name, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTPARAMETERIVARBPROC)(GLhandleARB obj, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETOBJECTPTRLABELPROC)(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (GLAD_API_PTR *PFNGLGETOCCLUSIONQUERYIVNVPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETOCCLUSIONQUERYUIVNVPROC)(GLuint id, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETPATHCOMMANDSNVPROC)(GLuint path, GLubyte * commands);
typedef void (GLAD_API_PTR *PFNGLGETPATHCOORDSNVPROC)(GLuint path, GLfloat * coords);
typedef void (GLAD_API_PTR *PFNGLGETPATHDASHARRAYNVPROC)(GLuint path, GLfloat * dashArray);
typedef GLfloat (GLAD_API_PTR *PFNGLGETPATHLENGTHNVPROC)(GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void (GLAD_API_PTR *PFNGLGETPATHMETRICRANGENVPROC)(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics);
typedef void (GLAD_API_PTR *PFNGLGETPATHMETRICSNVPROC)(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics);
typedef void (GLAD_API_PTR *PFNGLGETPATHPARAMETERFVNVPROC)(GLuint path, GLenum pname, GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLGETPATHPARAMETERIVNVPROC)(GLuint path, GLenum pname, GLint * value);
typedef void (GLAD_API_PTR *PFNGLGETPATHSPACINGNVPROC)(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing);
typedef void (GLAD_API_PTR *PFNGLGETPERFCOUNTERINFOINTELPROC)(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar * counterName, GLuint counterDescLength, GLchar * counterDesc, GLuint * counterOffset, GLuint * counterDataSize, GLuint * counterTypeEnum, GLuint * counterDataTypeEnum, GLuint64 * rawCounterMaxValue);
typedef void (GLAD_API_PTR *PFNGLGETPERFMONITORCOUNTERDATAAMDPROC)(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten);
typedef void (GLAD_API_PTR *PFNGLGETPERFMONITORCOUNTERINFOAMDPROC)(GLuint group, GLuint counter, GLenum pname, void * data);
typedef void (GLAD_API_PTR *PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC)(GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString);
typedef void (GLAD_API_PTR *PFNGLGETPERFMONITORCOUNTERSAMDPROC)(GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters);
typedef void (GLAD_API_PTR *PFNGLGETPERFMONITORGROUPSTRINGAMDPROC)(GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString);
typedef void (GLAD_API_PTR *PFNGLGETPERFMONITORGROUPSAMDPROC)(GLint * numGroups, GLsizei groupsSize, GLuint * groups);
typedef void (GLAD_API_PTR *PFNGLGETPERFQUERYDATAINTELPROC)(GLuint queryHandle, GLuint flags, GLsizei dataSize, void * data, GLuint * bytesWritten);
typedef void (GLAD_API_PTR *PFNGLGETPERFQUERYIDBYNAMEINTELPROC)(GLchar * queryName, GLuint * queryId);
typedef void (GLAD_API_PTR *PFNGLGETPERFQUERYINFOINTELPROC)(GLuint queryId, GLuint queryNameLength, GLchar * queryName, GLuint * dataSize, GLuint * noCounters, GLuint * noInstances, GLuint * capsMask);
typedef void (GLAD_API_PTR *PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPOINTERINDEXEDVEXTPROC)(GLenum target, GLuint index, void ** data);
typedef void (GLAD_API_PTR *PFNGLGETPOINTERI_VEXTPROC)(GLenum pname, GLuint index, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETPOINTERVPROC)(GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETPOINTERVEXTPROC)(GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMBINARYPROC)(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMENVPARAMETERIIVNVPROC)(GLenum target, GLuint index, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC)(GLenum target, GLuint index, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMENVPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMENVPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMINTERFACEIVPROC)(GLuint program, GLenum programInterface, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC)(GLenum target, GLuint index, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC)(GLenum target, GLuint index, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC)(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC)(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMPARAMETERDVNVPROC)(GLenum target, GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMPIPELINEINFOLOGPROC)(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMPIPELINEIVPROC)(GLuint pipeline, GLenum pname, GLint * params);
typedef GLuint (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCEINDEXPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCELOCATIONPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCENAMEPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCEFVNVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMRESOURCEIVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype, GLenum pname, GLint * values);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMSTRINGARBPROC)(GLenum target, GLenum pname, void * string);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMSTRINGNVPROC)(GLuint id, GLenum pname, GLubyte * program);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC)(GLenum target, GLuint index, GLuint * param);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMIVARBPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETPROGRAMIVNVPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTUI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYBUFFEROBJECTUIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTI64VEXTPROC)(GLuint id, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTIVARBPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUI64VEXTPROC)(GLuint id, GLenum pname, GLuint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYOBJECTUIVARBPROC)(GLuint id, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETQUERYIVARBPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC)(GLuint semaphore, GLenum pname, GLuint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETSEPARABLEFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, void * row, void * column, void * span);
typedef void (GLAD_API_PTR *PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (GLAD_API_PTR *PFNGLGETSHADERPRECISIONFORMATPROC)(GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision);
typedef void (GLAD_API_PTR *PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);
typedef void (GLAD_API_PTR *PFNGLGETSHADERSOURCEARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * source);
typedef void (GLAD_API_PTR *PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint * params);
typedef GLushort (GLAD_API_PTR *PFNGLGETSTAGEINDEXNVPROC)(GLenum shadertype);
typedef const GLubyte * (GLAD_API_PTR *PFNGLGETSTRINGPROC)(GLenum name);
typedef const GLubyte * (GLAD_API_PTR *PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
typedef GLuint (GLAD_API_PTR *PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(GLuint program, GLenum shadertype, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei count, GLsizei * length, GLint * values);
typedef void (GLAD_API_PTR *PFNGLGETTEXBUMPPARAMETERFVATIPROC)(GLenum pname, GLfloat * param);
typedef void (GLAD_API_PTR *PFNGLGETTEXBUMPPARAMETERIVATIPROC)(GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC)(GLenum target, GLenum pname, void ** params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef GLuint64 (GLAD_API_PTR *PFNGLGETTEXTUREHANDLEARBPROC)(GLuint texture);
typedef GLuint64 (GLAD_API_PTR *PFNGLGETTEXTUREHANDLENVPROC)(GLuint texture);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREIMAGEEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURELEVELPARAMETERFVPROC)(GLuint texture, GLint level, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURELEVELPARAMETERIVPROC)(GLuint texture, GLint level, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIUIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint * params);
typedef GLuint64 (GLAD_API_PTR *PFNGLGETTEXTURESAMPLERHANDLEARBPROC)(GLuint texture, GLuint sampler);
typedef GLuint64 (GLAD_API_PTR *PFNGLGETTEXTURESAMPLERHANDLENVPROC)(GLuint texture, GLuint sampler);
typedef void (GLAD_API_PTR *PFNGLGETTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETTRACKMATRIXIVNVPROC)(GLenum target, GLuint address, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC)(GLuint program, GLuint index, GLint * location);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKI64_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint64 * param);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKI_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETTRANSFORMFEEDBACKIVPROC)(GLuint xfb, GLenum pname, GLint * param);
typedef GLuint (GLAD_API_PTR *PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const GLchar * uniformBlockName);
typedef GLint (GLAD_API_PTR *PFNGLGETUNIFORMBUFFERSIZEEXTPROC)(GLuint program, GLint location);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices);
typedef GLint (GLAD_API_PTR *PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar * name);
typedef GLint (GLAD_API_PTR *PFNGLGETUNIFORMLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB * name);
typedef GLintptr (GLAD_API_PTR *PFNGLGETUNIFORMOFFSETEXTPROC)(GLuint program, GLint location);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMDVPROC)(GLuint program, GLint location, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMFVARBPROC)(GLhandleARB programObj, GLint location, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMI64VARBPROC)(GLuint program, GLint location, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMI64VNVPROC)(GLuint program, GLint location, GLint64EXT * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMIVARBPROC)(GLhandleARB programObj, GLint location, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMUI64VARBPROC)(GLuint program, GLint location, GLuint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMUI64VNVPROC)(GLuint program, GLint location, GLuint64EXT * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETUNIFORMUIVEXTPROC)(GLuint program, GLint location, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETUNSIGNEDBYTEI_VEXTPROC)(GLenum target, GLuint index, GLubyte * data);
typedef void (GLAD_API_PTR *PFNGLGETUNSIGNEDBYTEVEXTPROC)(GLenum pname, GLubyte * data);
typedef void (GLAD_API_PTR *PFNGLGETVARIANTARRAYOBJECTFVATIPROC)(GLuint id, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETVARIANTARRAYOBJECTIVATIPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean * data);
typedef void (GLAD_API_PTR *PFNGLGETVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat * data);
typedef void (GLAD_API_PTR *PFNGLGETVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint * data);
typedef void (GLAD_API_PTR *PFNGLGETVARIANTPOINTERVEXTPROC)(GLuint id, GLenum value, void ** data);
typedef GLint (GLAD_API_PTR *PFNGLGETVARYINGLOCATIONNVPROC)(GLuint program, const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYINDEXED64IVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint64 * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYINDEXEDIVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYINTEGERVEXTPROC)(GLuint vaobj, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC)(GLuint vaobj, GLuint index, GLenum pname, void ** param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYPOINTERVEXTPROC)(GLuint vaobj, GLenum pname, void ** param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXARRAYIVPROC)(GLuint vaobj, GLenum pname, GLint * param);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIIVEXTPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIUIVEXTPROC)(GLuint index, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBLDVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBLDVEXTPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBLI64VNVPROC)(GLuint index, GLenum pname, GLint64EXT * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBLUI64VARBPROC)(GLuint index, GLenum pname, GLuint64EXT * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBLUI64VNVPROC)(GLuint index, GLenum pname, GLuint64EXT * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, void ** pointer);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBPOINTERVARBPROC)(GLuint index, GLenum pname, void ** pointer);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBPOINTERVNVPROC)(GLuint index, GLenum pname, void ** pointer);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBDVARBPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBDVNVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBFVARBPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBFVNVPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIVARBPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVERTEXATTRIBIVNVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVIDEOCAPTURESTREAMDVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETVIDEOCAPTURESTREAMFVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETVIDEOCAPTURESTREAMIVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVIDEOCAPTUREIVNVPROC)(GLuint video_capture_slot, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVIDEOI64VNVPROC)(GLuint video_slot, GLenum pname, GLint64EXT * params);
typedef void (GLAD_API_PTR *PFNGLGETVIDEOIVNVPROC)(GLuint video_slot, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETVIDEOUI64VNVPROC)(GLuint video_slot, GLenum pname, GLuint64EXT * params);
typedef void (GLAD_API_PTR *PFNGLGETVIDEOUIVNVPROC)(GLuint video_slot, GLenum pname, GLuint * params);
typedef GLVULKANPROCNV (GLAD_API_PTR *PFNGLGETVKPROCADDRNVPROC)(const GLchar * name);
typedef void (GLAD_API_PTR *PFNGLGETNCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint lod, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint lod, GLsizei bufSize, void * img);
typedef void (GLAD_API_PTR *PFNGLGETNTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (GLAD_API_PTR *PFNGLGETNTEXIMAGEARBPROC)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * img);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMDVPROC)(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMDVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMFVPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMFVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMI64VARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMIVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLint * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMUI64VARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint64 * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMUIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLGETNUNIFORMUIVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLHINTPROC)(GLenum target, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLHISTOGRAMPROC)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (GLAD_API_PTR *PFNGLHISTOGRAMEXTPROC)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (GLAD_API_PTR *PFNGLIMPORTMEMORYFDEXTPROC)(GLuint memory, GLuint64 size, GLenum handleType, GLint fd);
typedef void (GLAD_API_PTR *PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC)(GLuint memory, GLuint64 size, GLenum handleType, void * handle);
typedef void (GLAD_API_PTR *PFNGLIMPORTMEMORYWIN32NAMEEXTPROC)(GLuint memory, GLuint64 size, GLenum handleType, const void * name);
typedef void (GLAD_API_PTR *PFNGLIMPORTSEMAPHOREFDEXTPROC)(GLuint semaphore, GLenum handleType, GLint fd);
typedef void (GLAD_API_PTR *PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC)(GLuint semaphore, GLenum handleType, void * handle);
typedef void (GLAD_API_PTR *PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC)(GLuint semaphore, GLenum handleType, const void * name);
typedef GLsync (GLAD_API_PTR *PFNGLIMPORTSYNCEXTPROC)(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLINDEXFORMATNVPROC)(GLenum type, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLINDEXFUNCEXTPROC)(GLenum func, GLclampf ref);
typedef void (GLAD_API_PTR *PFNGLINDEXMATERIALEXTPROC)(GLenum face, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLINDEXPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLINSERTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
typedef void (GLAD_API_PTR *PFNGLINSERTEVENTMARKEREXTPROC)(GLsizei length, const GLchar * marker);
typedef void (GLAD_API_PTR *PFNGLINTERPOLATEPATHSNVPROC)(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef void (GLAD_API_PTR *PFNGLINVALIDATEBUFFERDATAPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLINVALIDATEBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (GLAD_API_PTR *PFNGLINVALIDATEFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum * attachments);
typedef void (GLAD_API_PTR *PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments);
typedef void (GLAD_API_PTR *PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLINVALIDATESUBFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLINVALIDATETEXIMAGEPROC)(GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLINVALIDATETEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
typedef GLboolean (GLAD_API_PTR *PFNGLISBUFFERPROC)(GLuint buffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISBUFFERARBPROC)(GLuint buffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISBUFFERRESIDENTNVPROC)(GLenum target);
typedef GLboolean (GLAD_API_PTR *PFNGLISCOMMANDLISTNVPROC)(GLuint list);
typedef GLboolean (GLAD_API_PTR *PFNGLISENABLEDPROC)(GLenum cap);
typedef GLboolean (GLAD_API_PTR *PFNGLISENABLEDINDEXEDEXTPROC)(GLenum target, GLuint index);
typedef GLboolean (GLAD_API_PTR *PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
typedef GLboolean (GLAD_API_PTR *PFNGLISFENCEAPPLEPROC)(GLuint fence);
typedef GLboolean (GLAD_API_PTR *PFNGLISFENCENVPROC)(GLuint fence);
typedef GLboolean (GLAD_API_PTR *PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISFRAMEBUFFEREXTPROC)(GLuint framebuffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISIMAGEHANDLERESIDENTARBPROC)(GLuint64 handle);
typedef GLboolean (GLAD_API_PTR *PFNGLISIMAGEHANDLERESIDENTNVPROC)(GLuint64 handle);
typedef GLboolean (GLAD_API_PTR *PFNGLISMEMORYOBJECTEXTPROC)(GLuint memoryObject);
typedef GLboolean (GLAD_API_PTR *PFNGLISNAMEAMDPROC)(GLenum identifier, GLuint name);
typedef GLboolean (GLAD_API_PTR *PFNGLISNAMEDBUFFERRESIDENTNVPROC)(GLuint buffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISNAMEDSTRINGARBPROC)(GLint namelen, const GLchar * name);
typedef GLboolean (GLAD_API_PTR *PFNGLISOBJECTBUFFERATIPROC)(GLuint buffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISOCCLUSIONQUERYNVPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISPATHNVPROC)(GLuint path);
typedef GLboolean (GLAD_API_PTR *PFNGLISPOINTINFILLPATHNVPROC)(GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean (GLAD_API_PTR *PFNGLISPOINTINSTROKEPATHNVPROC)(GLuint path, GLfloat x, GLfloat y);
typedef GLboolean (GLAD_API_PTR *PFNGLISPROGRAMPROC)(GLuint program);
typedef GLboolean (GLAD_API_PTR *PFNGLISPROGRAMARBPROC)(GLuint program);
typedef GLboolean (GLAD_API_PTR *PFNGLISPROGRAMNVPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef GLboolean (GLAD_API_PTR *PFNGLISQUERYPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISQUERYARBPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISRENDERBUFFEREXTPROC)(GLuint renderbuffer);
typedef GLboolean (GLAD_API_PTR *PFNGLISSAMPLERPROC)(GLuint sampler);
typedef GLboolean (GLAD_API_PTR *PFNGLISSEMAPHOREEXTPROC)(GLuint semaphore);
typedef GLboolean (GLAD_API_PTR *PFNGLISSHADERPROC)(GLuint shader);
typedef GLboolean (GLAD_API_PTR *PFNGLISSTATENVPROC)(GLuint state);
typedef GLboolean (GLAD_API_PTR *PFNGLISSYNCPROC)(GLsync sync);
typedef GLboolean (GLAD_API_PTR *PFNGLISTEXTUREPROC)(GLuint texture);
typedef GLboolean (GLAD_API_PTR *PFNGLISTEXTUREEXTPROC)(GLuint texture);
typedef GLboolean (GLAD_API_PTR *PFNGLISTEXTUREHANDLERESIDENTARBPROC)(GLuint64 handle);
typedef GLboolean (GLAD_API_PTR *PFNGLISTEXTUREHANDLERESIDENTNVPROC)(GLuint64 handle);
typedef GLboolean (GLAD_API_PTR *PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISTRANSFORMFEEDBACKNVPROC)(GLuint id);
typedef GLboolean (GLAD_API_PTR *PFNGLISVARIANTENABLEDEXTPROC)(GLuint id, GLenum cap);
typedef GLboolean (GLAD_API_PTR *PFNGLISVERTEXARRAYPROC)(GLuint array);
typedef GLboolean (GLAD_API_PTR *PFNGLISVERTEXARRAYAPPLEPROC)(GLuint array);
typedef GLboolean (GLAD_API_PTR *PFNGLISVERTEXATTRIBENABLEDAPPLEPROC)(GLuint index, GLenum pname);
typedef void (GLAD_API_PTR *PFNGLLGPUCOPYIMAGESUBDATANVXPROC)(GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GLAD_API_PTR *PFNGLLGPUINTERLOCKNVXPROC)(void);
typedef void (GLAD_API_PTR *PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC)(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (GLAD_API_PTR *PFNGLLABELOBJECTEXTPROC)(GLenum type, GLuint object, GLsizei length, const GLchar * label);
typedef void (GLAD_API_PTR *PFNGLLINEWIDTHPROC)(GLfloat width);
typedef void (GLAD_API_PTR *PFNGLLINKPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLLINKPROGRAMARBPROC)(GLhandleARB programObj);
typedef void (GLAD_API_PTR *PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC)(GLuint list, GLuint segment, const void ** indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);
typedef void (GLAD_API_PTR *PFNGLLOADPROGRAMNVPROC)(GLenum target, GLuint id, GLsizei len, const GLubyte * program);
typedef void (GLAD_API_PTR *PFNGLLOADTRANSPOSEMATRIXDPROC)(const GLdouble * m);
typedef void (GLAD_API_PTR *PFNGLLOADTRANSPOSEMATRIXDARBPROC)(const GLdouble * m);
typedef void (GLAD_API_PTR *PFNGLLOADTRANSPOSEMATRIXFPROC)(const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLLOADTRANSPOSEMATRIXFARBPROC)(const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLLOCKARRAYSEXTPROC)(GLint first, GLsizei count);
typedef void (GLAD_API_PTR *PFNGLLOGICOPPROC)(GLenum opcode);
typedef void (GLAD_API_PTR *PFNGLMAKEBUFFERNONRESIDENTNVPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLMAKEBUFFERRESIDENTNVPROC)(GLenum target, GLenum access);
typedef void (GLAD_API_PTR *PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC)(GLuint64 handle);
typedef void (GLAD_API_PTR *PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC)(GLuint64 handle);
typedef void (GLAD_API_PTR *PFNGLMAKEIMAGEHANDLERESIDENTARBPROC)(GLuint64 handle, GLenum access);
typedef void (GLAD_API_PTR *PFNGLMAKEIMAGEHANDLERESIDENTNVPROC)(GLuint64 handle, GLenum access);
typedef void (GLAD_API_PTR *PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLMAKENAMEDBUFFERRESIDENTNVPROC)(GLuint buffer, GLenum access);
typedef void (GLAD_API_PTR *PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC)(GLuint64 handle);
typedef void (GLAD_API_PTR *PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC)(GLuint64 handle);
typedef void (GLAD_API_PTR *PFNGLMAKETEXTUREHANDLERESIDENTARBPROC)(GLuint64 handle);
typedef void (GLAD_API_PTR *PFNGLMAKETEXTUREHANDLERESIDENTNVPROC)(GLuint64 handle);
typedef void * (GLAD_API_PTR *PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
typedef void * (GLAD_API_PTR *PFNGLMAPBUFFERARBPROC)(GLenum target, GLenum access);
typedef void * (GLAD_API_PTR *PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (GLAD_API_PTR *PFNGLMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void * points);
typedef void * (GLAD_API_PTR *PFNGLMAPNAMEDBUFFERPROC)(GLuint buffer, GLenum access);
typedef void * (GLAD_API_PTR *PFNGLMAPNAMEDBUFFEREXTPROC)(GLuint buffer, GLenum access);
typedef void * (GLAD_API_PTR *PFNGLMAPNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void * (GLAD_API_PTR *PFNGLMAPNAMEDBUFFERRANGEEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void * (GLAD_API_PTR *PFNGLMAPOBJECTBUFFERATIPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void * (GLAD_API_PTR *PFNGLMAPTEXTURE2DINTELPROC)(GLuint texture, GLint level, GLbitfield access, GLint * stride, GLenum * layout);
typedef void (GLAD_API_PTR *PFNGLMAPVERTEXATTRIB1DAPPLEPROC)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);
typedef void (GLAD_API_PTR *PFNGLMAPVERTEXATTRIB1FAPPLEPROC)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);
typedef void (GLAD_API_PTR *PFNGLMAPVERTEXATTRIB2DAPPLEPROC)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);
typedef void (GLAD_API_PTR *PFNGLMAPVERTEXATTRIB2FAPPLEPROC)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);
typedef void (GLAD_API_PTR *PFNGLMATRIXFRUSTUMEXTPROC)(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
typedef void (GLAD_API_PTR *PFNGLMATRIXINDEXPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLMATRIXINDEXUBVARBPROC)(GLint size, const GLubyte * indices);
typedef void (GLAD_API_PTR *PFNGLMATRIXINDEXUIVARBPROC)(GLint size, const GLuint * indices);
typedef void (GLAD_API_PTR *PFNGLMATRIXINDEXUSVARBPROC)(GLint size, const GLushort * indices);
typedef void (GLAD_API_PTR *PFNGLMATRIXLOAD3X2FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXLOAD3X3FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXLOADIDENTITYEXTPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXLOADTRANSPOSEDEXTPROC)(GLenum mode, const GLdouble * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXLOADTRANSPOSEFEXTPROC)(GLenum mode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXLOADDEXTPROC)(GLenum mode, const GLdouble * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXLOADFEXTPROC)(GLenum mode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXMULT3X2FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXMULT3X3FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXMULTTRANSPOSEDEXTPROC)(GLenum mode, const GLdouble * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXMULTTRANSPOSEFEXTPROC)(GLenum mode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXMULTDEXTPROC)(GLenum mode, const GLdouble * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXMULTFEXTPROC)(GLenum mode, const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMATRIXORTHOEXTPROC)(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
typedef void (GLAD_API_PTR *PFNGLMATRIXPOPEXTPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLMATRIXPUSHEXTPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLMATRIXROTATEDEXTPROC)(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLMATRIXROTATEFEXTPROC)(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLMATRIXSCALEDEXTPROC)(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLMATRIXSCALEFEXTPROC)(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLMATRIXTRANSLATEDEXTPROC)(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLMATRIXTRANSLATEFEXTPROC)(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLMAXSHADERCOMPILERTHREADSARBPROC)(GLuint count);
typedef void (GLAD_API_PTR *PFNGLMAXSHADERCOMPILERTHREADSKHRPROC)(GLuint count);
typedef void (GLAD_API_PTR *PFNGLMEMORYBARRIERPROC)(GLbitfield barriers);
typedef void (GLAD_API_PTR *PFNGLMEMORYBARRIERBYREGIONPROC)(GLbitfield barriers);
typedef void (GLAD_API_PTR *PFNGLMEMORYBARRIEREXTPROC)(GLbitfield barriers);
typedef void (GLAD_API_PTR *PFNGLMEMORYOBJECTPARAMETERIVEXTPROC)(GLuint memoryObject, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLMINSAMPLESHADINGPROC)(GLfloat value);
typedef void (GLAD_API_PTR *PFNGLMINSAMPLESHADINGARBPROC)(GLfloat value);
typedef void (GLAD_API_PTR *PFNGLMINMAXPROC)(GLenum target, GLenum internalformat, GLboolean sink);
typedef void (GLAD_API_PTR *PFNGLMINMAXEXTPROC)(GLenum target, GLenum internalformat, GLboolean sink);
typedef void (GLAD_API_PTR *PFNGLMULTTRANSPOSEMATRIXDPROC)(const GLdouble * m);
typedef void (GLAD_API_PTR *PFNGLMULTTRANSPOSEMATRIXDARBPROC)(const GLdouble * m);
typedef void (GLAD_API_PTR *PFNGLMULTTRANSPOSEMATRIXFPROC)(const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMULTTRANSPOSEMATRIXFARBPROC)(const GLfloat * m);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSEXTPROC)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTPROC)(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC)(GLenum mode, const void * indirect, GLsizei primcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC)(GLenum mode, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC)(GLenum mode, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC)(GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC)(GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSEXTPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei primcount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei primcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC)(GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC)(GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount);
typedef void (GLAD_API_PTR *PFNGLMULTITEXBUFFEREXTPROC)(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1DPROC)(GLenum target, GLdouble s);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1DARBPROC)(GLenum target, GLdouble s);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1DVPROC)(GLenum target, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1DVARBPROC)(GLenum target, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1FPROC)(GLenum target, GLfloat s);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1FARBPROC)(GLenum target, GLfloat s);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1FVPROC)(GLenum target, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1FVARBPROC)(GLenum target, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1HNVPROC)(GLenum target, GLhalfNV s);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1HVNVPROC)(GLenum target, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1IPROC)(GLenum target, GLint s);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1IARBPROC)(GLenum target, GLint s);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1IVPROC)(GLenum target, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1IVARBPROC)(GLenum target, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1SPROC)(GLenum target, GLshort s);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1SARBPROC)(GLenum target, GLshort s);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1SVPROC)(GLenum target, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD1SVARBPROC)(GLenum target, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2DPROC)(GLenum target, GLdouble s, GLdouble t);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2DARBPROC)(GLenum target, GLdouble s, GLdouble t);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2DVPROC)(GLenum target, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2DVARBPROC)(GLenum target, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2FPROC)(GLenum target, GLfloat s, GLfloat t);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2FARBPROC)(GLenum target, GLfloat s, GLfloat t);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2FVPROC)(GLenum target, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2FVARBPROC)(GLenum target, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2HVNVPROC)(GLenum target, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2IPROC)(GLenum target, GLint s, GLint t);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2IARBPROC)(GLenum target, GLint s, GLint t);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2IVPROC)(GLenum target, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2IVARBPROC)(GLenum target, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2SPROC)(GLenum target, GLshort s, GLshort t);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2SARBPROC)(GLenum target, GLshort s, GLshort t);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2SVPROC)(GLenum target, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD2SVARBPROC)(GLenum target, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3DPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3DVPROC)(GLenum target, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3DVARBPROC)(GLenum target, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3FPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3FVPROC)(GLenum target, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3FVARBPROC)(GLenum target, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3HVNVPROC)(GLenum target, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3IPROC)(GLenum target, GLint s, GLint t, GLint r);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3IARBPROC)(GLenum target, GLint s, GLint t, GLint r);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3IVPROC)(GLenum target, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3IVARBPROC)(GLenum target, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3SPROC)(GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3SVPROC)(GLenum target, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD3SVARBPROC)(GLenum target, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4DPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4DVPROC)(GLenum target, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4DVARBPROC)(GLenum target, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4FPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4FVPROC)(GLenum target, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4FVARBPROC)(GLenum target, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4HVNVPROC)(GLenum target, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4IPROC)(GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4IARBPROC)(GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4IVPROC)(GLenum target, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4IVARBPROC)(GLenum target, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4SPROC)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4SVPROC)(GLenum target, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORD4SVARBPROC)(GLenum target, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLMULTITEXCOORDPOINTEREXTPROC)(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLMULTITEXENVFEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLMULTITEXENVIEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLMULTITEXGENDEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void (GLAD_API_PTR *PFNGLMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLMULTITEXGENFEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLMULTITEXGENIEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLMULTITEXIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLMULTITEXPARAMETERIUIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLMULTITEXPARAMETERFEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLMULTITEXPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLMULTITEXPARAMETERIEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLMULTITEXRENDERBUFFEREXTPROC)(GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLMULTICASTBARRIERNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLMULTICASTBLITFRAMEBUFFERNVPROC)(GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (GLAD_API_PTR *PFNGLMULTICASTBUFFERSUBDATANVPROC)(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (GLAD_API_PTR *PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC)(GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLMULTICASTCOPYIMAGESUBDATANVPROC)(GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void (GLAD_API_PTR *PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLint64 * params);
typedef void (GLAD_API_PTR *PFNGLMULTICASTGETQUERYOBJECTIVNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLint * params);
typedef void (GLAD_API_PTR *PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLuint64 * params);
typedef void (GLAD_API_PTR *PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLuint * params);
typedef void (GLAD_API_PTR *PFNGLMULTICASTWAITSYNCNVPROC)(GLuint signalGpu, GLbitfield waitGpuMask);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERDATAPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERDATAEXTPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSTORAGEPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSTORAGEEXTPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC)(GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (GLAD_API_PTR *PFNGLNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (GLAD_API_PTR *PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)(GLuint framebuffer, GLenum buf);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)(GLuint framebuffer, GLsizei n, const GLenum * bufs);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)(GLuint framebuffer, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC)(GLuint framebuffer, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)(GLuint framebuffer, GLenum src);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC)(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC)(GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat * values);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (GLAD_API_PTR *PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC)(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC)(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC)(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC)(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLNAMEDPROGRAMSTRINGEXTPROC)(GLuint program, GLenum target, GLenum format, GLsizei len, const void * string);
typedef void (GLAD_API_PTR *PFNGLNAMEDRENDERBUFFERSTORAGEPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC)(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLNAMEDSTRINGARBPROC)(GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string);
typedef GLuint (GLAD_API_PTR *PFNGLNEWOBJECTBUFFERATIPROC)(GLsizei size, const void * pointer, GLenum usage);
typedef void (GLAD_API_PTR *PFNGLNORMAL3HNVPROC)(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
typedef void (GLAD_API_PTR *PFNGLNORMAL3HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLNORMALFORMATNVPROC)(GLenum type, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLNORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLNORMALPOINTERVINTELPROC)(GLenum type, const void ** pointer);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3BATIPROC)(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3BVATIPROC)(GLenum stream, const GLbyte * coords);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3DATIPROC)(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3FATIPROC)(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3IATIPROC)(GLenum stream, GLint nx, GLint ny, GLint nz);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3SATIPROC)(GLenum stream, GLshort nx, GLshort ny, GLshort nz);
typedef void (GLAD_API_PTR *PFNGLNORMALSTREAM3SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (GLAD_API_PTR *PFNGLOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei length, const GLchar * label);
typedef void (GLAD_API_PTR *PFNGLOBJECTPTRLABELPROC)(const void * ptr, GLsizei length, const GLchar * label);
typedef GLenum (GLAD_API_PTR *PFNGLOBJECTPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name, GLenum option);
typedef GLenum (GLAD_API_PTR *PFNGLOBJECTUNPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name, GLenum option);
typedef void (GLAD_API_PTR *PFNGLPNTRIANGLESFATIPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPNTRIANGLESIATIPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLPASSTEXCOORDATIPROC)(GLuint dst, GLuint coord, GLenum swizzle);
typedef void (GLAD_API_PTR *PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat * values);
typedef void (GLAD_API_PTR *PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLPATHCOMMANDSNVPROC)(GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords);
typedef void (GLAD_API_PTR *PFNGLPATHCOORDSNVPROC)(GLuint path, GLsizei numCoords, GLenum coordType, const void * coords);
typedef void (GLAD_API_PTR *PFNGLPATHCOVERDEPTHFUNCNVPROC)(GLenum func);
typedef void (GLAD_API_PTR *PFNGLPATHDASHARRAYNVPROC)(GLuint path, GLsizei dashCount, const GLfloat * dashArray);
typedef GLenum (GLAD_API_PTR *PFNGLPATHGLYPHINDEXARRAYNVPROC)(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum (GLAD_API_PTR *PFNGLPATHGLYPHINDEXRANGENVPROC)(GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount [2]);
typedef void (GLAD_API_PTR *PFNGLPATHGLYPHRANGENVPROC)(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (GLAD_API_PTR *PFNGLPATHGLYPHSNVPROC)(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum (GLAD_API_PTR *PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC)(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void * fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (GLAD_API_PTR *PFNGLPATHPARAMETERFNVPROC)(GLuint path, GLenum pname, GLfloat value);
typedef void (GLAD_API_PTR *PFNGLPATHPARAMETERFVNVPROC)(GLuint path, GLenum pname, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPATHPARAMETERINVPROC)(GLuint path, GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLPATHPARAMETERIVNVPROC)(GLuint path, GLenum pname, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPATHSTENCILDEPTHOFFSETNVPROC)(GLfloat factor, GLfloat units);
typedef void (GLAD_API_PTR *PFNGLPATHSTENCILFUNCNVPROC)(GLenum func, GLint ref, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLPATHSTRINGNVPROC)(GLuint path, GLenum format, GLsizei length, const void * pathString);
typedef void (GLAD_API_PTR *PFNGLPATHSUBCOMMANDSNVPROC)(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords);
typedef void (GLAD_API_PTR *PFNGLPATHSUBCOORDSNVPROC)(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void * coords);
typedef void (GLAD_API_PTR *PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
typedef void (GLAD_API_PTR *PFNGLPAUSETRANSFORMFEEDBACKNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLPIXELDATARANGENVPROC)(GLenum target, GLsizei length, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLPIXELTRANSFORMPARAMETERFEXTPROC)(GLenum target, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPIXELTRANSFORMPARAMETERIEXTPROC)(GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint * params);
typedef GLboolean (GLAD_API_PTR *PFNGLPOINTALONGPATHNVPROC)(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFARBPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFEXTPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFVARBPROC)(GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERFVEXTPROC)(GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERINVPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLPOINTPARAMETERIVNVPROC)(GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLPOINTSIZEPROC)(GLfloat size);
typedef void (GLAD_API_PTR *PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
typedef void (GLAD_API_PTR *PFNGLPOLYGONOFFSETCLAMPPROC)(GLfloat factor, GLfloat units, GLfloat clamp);
typedef void (GLAD_API_PTR *PFNGLPOLYGONOFFSETCLAMPEXTPROC)(GLfloat factor, GLfloat units, GLfloat clamp);
typedef void (GLAD_API_PTR *PFNGLPOLYGONOFFSETEXTPROC)(GLfloat factor, GLfloat bias);
typedef void (GLAD_API_PTR *PFNGLPOPDEBUGGROUPPROC)(void);
typedef void (GLAD_API_PTR *PFNGLPOPGROUPMARKEREXTPROC)(void);
typedef void (GLAD_API_PTR *PFNGLPRESENTFRAMEDUALFILLNVPROC)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void (GLAD_API_PTR *PFNGLPRESENTFRAMEKEYEDNVPROC)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
typedef void (GLAD_API_PTR *PFNGLPRIMITIVEBOUNDINGBOXPROC)(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
typedef void (GLAD_API_PTR *PFNGLPRIMITIVEBOUNDINGBOXARBPROC)(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
typedef void (GLAD_API_PTR *PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLPRIMITIVERESTARTINDEXNVPROC)(GLuint index);
typedef void (GLAD_API_PTR *PFNGLPRIMITIVERESTARTNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLPRIORITIZETEXTURESPROC)(GLsizei n, const GLuint * textures, const GLfloat * priorities);
typedef void (GLAD_API_PTR *PFNGLPRIORITIZETEXTURESEXTPROC)(GLsizei n, const GLuint * textures, const GLclampf * priorities);
typedef void (GLAD_API_PTR *PFNGLPROGRAMBINARYPROC)(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length);
typedef void (GLAD_API_PTR *PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC)(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC)(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC)(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETERS4FVEXTPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMNAMEDPARAMETER4DNVPROC)(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC)(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLPROGRAMNAMEDPARAMETER4FNVPROC)(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC)(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETER4DNVPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETER4DVNVPROC)(GLenum target, GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETER4FNVPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETER4FVNVPROC)(GLenum target, GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETERIPROC)(GLuint program, GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETERIARBPROC)(GLuint program, GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETERIEXTPROC)(GLuint program, GLenum pname, GLint value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETERS4DVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPARAMETERS4FVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC)(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat * coeffs);
typedef void (GLAD_API_PTR *PFNGLPROGRAMSTRINGARBPROC)(GLenum target, GLenum format, GLsizei len, const void * string);
typedef void (GLAD_API_PTR *PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC)(GLenum target, GLsizei count, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1DPROC)(GLuint program, GLint location, GLdouble v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1DEXTPROC)(GLuint program, GLint location, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1FPROC)(GLuint program, GLint location, GLfloat v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1FEXTPROC)(GLuint program, GLint location, GLfloat v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1IPROC)(GLuint program, GLint location, GLint v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1I64ARBPROC)(GLuint program, GLint location, GLint64 x);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1I64NVPROC)(GLuint program, GLint location, GLint64EXT x);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1IEXTPROC)(GLuint program, GLint location, GLint v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UIPROC)(GLuint program, GLint location, GLuint v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UI64ARBPROC)(GLuint program, GLint location, GLuint64 x);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UIEXTPROC)(GLuint program, GLint location, GLuint v0);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM1UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2DEXTPROC)(GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2IPROC)(GLuint program, GLint location, GLint v0, GLint v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2I64ARBPROC)(GLuint program, GLint location, GLint64 x, GLint64 y);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UI64ARBPROC)(GLuint program, GLint location, GLuint64 x, GLuint64 y);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM2UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3DEXTPROC)(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3I64ARBPROC)(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UI64ARBPROC)(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM3UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4DEXTPROC)(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4I64ARBPROC)(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UI64ARBPROC)(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORM4UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC)(GLuint program, GLint location, GLuint64 value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC)(GLuint program, GLint location, GLuint64 value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * values);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * values);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMUI64NVPROC)(GLuint program, GLint location, GLuint64EXT value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMUNIFORMUI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLPROGRAMVERTEXLIMITNVPROC)(GLenum target, GLint limit);
typedef void (GLAD_API_PTR *PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLPROVOKINGVERTEXEXTPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
typedef void (GLAD_API_PTR *PFNGLPUSHDEBUGGROUPPROC)(GLenum source, GLuint id, GLsizei length, const GLchar * message);
typedef void (GLAD_API_PTR *PFNGLPUSHGROUPMARKEREXTPROC)(GLsizei length, const GLchar * marker);
typedef void (GLAD_API_PTR *PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
typedef void (GLAD_API_PTR *PFNGLQUERYOBJECTPARAMETERUIAMDPROC)(GLenum target, GLuint id, GLenum pname, GLuint param);
typedef GLint (GLAD_API_PTR *PFNGLQUERYRESOURCENVPROC)(GLenum queryType, GLint tagId, GLuint count, GLint * buffer);
typedef void (GLAD_API_PTR *PFNGLQUERYRESOURCETAGNVPROC)(GLint tagId, const GLchar * tagString);
typedef void (GLAD_API_PTR *PFNGLRASTERSAMPLESEXTPROC)(GLuint samples, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLREADBUFFERPROC)(GLenum src);
typedef void (GLAD_API_PTR *PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels);
typedef void (GLAD_API_PTR *PFNGLREADNPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);
typedef void (GLAD_API_PTR *PFNGLREADNPIXELSARBPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);
typedef GLboolean (GLAD_API_PTR *PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC)(GLuint memory, GLuint64 key);
typedef void (GLAD_API_PTR *PFNGLRELEASESHADERCOMPILERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLRENDERGPUMASKNVPROC)(GLbitfield mask);
typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLREQUESTRESIDENTPROGRAMSNVPROC)(GLsizei n, const GLuint * programs);
typedef void (GLAD_API_PTR *PFNGLRESETHISTOGRAMPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLRESETHISTOGRAMEXTPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLRESETMINMAXPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLRESETMINMAXEXTPROC)(GLenum target);
typedef void (GLAD_API_PTR *PFNGLRESIZEBUFFERSMESAPROC)(void);
typedef void (GLAD_API_PTR *PFNGLRESOLVEDEPTHVALUESNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
typedef void (GLAD_API_PTR *PFNGLRESUMETRANSFORMFEEDBACKNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
typedef void (GLAD_API_PTR *PFNGLSAMPLECOVERAGEARBPROC)(GLfloat value, GLboolean invert);
typedef void (GLAD_API_PTR *PFNGLSAMPLEMAPATIPROC)(GLuint dst, GLuint interp, GLenum swizzle);
typedef void (GLAD_API_PTR *PFNGLSAMPLEMASKEXTPROC)(GLclampf value, GLboolean invert);
typedef void (GLAD_API_PTR *PFNGLSAMPLEMASKINDEXEDNVPROC)(GLuint index, GLbitfield mask);
typedef void (GLAD_API_PTR *PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
typedef void (GLAD_API_PTR *PFNGLSAMPLEPATTERNEXTPROC)(GLenum pattern);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, const GLuint * param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, const GLfloat * param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLSCISSORARRAYVPROC)(GLuint first, GLsizei count, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLSCISSORINDEXEDPROC)(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLSCISSORINDEXEDVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3BPROC)(GLbyte red, GLbyte green, GLbyte blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3BEXTPROC)(GLbyte red, GLbyte green, GLbyte blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3BVPROC)(const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3BVEXTPROC)(const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3DPROC)(GLdouble red, GLdouble green, GLdouble blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3DEXTPROC)(GLdouble red, GLdouble green, GLdouble blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3DVPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3DVEXTPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3FPROC)(GLfloat red, GLfloat green, GLfloat blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3FEXTPROC)(GLfloat red, GLfloat green, GLfloat blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3FVPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3FVEXTPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3IPROC)(GLint red, GLint green, GLint blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3IEXTPROC)(GLint red, GLint green, GLint blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3IVPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3IVEXTPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3SPROC)(GLshort red, GLshort green, GLshort blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3SEXTPROC)(GLshort red, GLshort green, GLshort blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3SVPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3SVEXTPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3UBPROC)(GLubyte red, GLubyte green, GLubyte blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3UBEXTPROC)(GLubyte red, GLubyte green, GLubyte blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3UBVPROC)(const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3UBVEXTPROC)(const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3UIPROC)(GLuint red, GLuint green, GLuint blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3UIEXTPROC)(GLuint red, GLuint green, GLuint blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3UIVPROC)(const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3UIVEXTPROC)(const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3USPROC)(GLushort red, GLushort green, GLushort blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3USEXTPROC)(GLushort red, GLushort green, GLushort blue);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3USVPROC)(const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLOR3USVEXTPROC)(const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLORFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLORPOINTERPROC)(GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLSECONDARYCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLSELECTPERFMONITORCOUNTERSAMDPROC)(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList);
typedef void (GLAD_API_PTR *PFNGLSEMAPHOREPARAMETERUI64VEXTPROC)(GLuint semaphore, GLenum pname, const GLuint64 * params);
typedef void (GLAD_API_PTR *PFNGLSEPARABLEFILTER2DPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column);
typedef void (GLAD_API_PTR *PFNGLSEPARABLEFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column);
typedef void (GLAD_API_PTR *PFNGLSETFENCEAPPLEPROC)(GLuint fence);
typedef void (GLAD_API_PTR *PFNGLSETFENCENVPROC)(GLuint fence, GLenum condition);
typedef void (GLAD_API_PTR *PFNGLSETFRAGMENTSHADERCONSTANTATIPROC)(GLuint dst, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLSETINVARIANTEXTPROC)(GLuint id, GLenum type, const void * addr);
typedef void (GLAD_API_PTR *PFNGLSETLOCALCONSTANTEXTPROC)(GLuint id, GLenum type, const void * addr);
typedef void (GLAD_API_PTR *PFNGLSETMULTISAMPLEFVAMDPROC)(GLenum pname, GLuint index, const GLfloat * val);
typedef void (GLAD_API_PTR *PFNGLSHADERBINARYPROC)(GLsizei count, const GLuint * shaders, GLenum binaryformat, const void * binary, GLsizei length);
typedef void (GLAD_API_PTR *PFNGLSHADEROP1EXTPROC)(GLenum op, GLuint res, GLuint arg1);
typedef void (GLAD_API_PTR *PFNGLSHADEROP2EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void (GLAD_API_PTR *PFNGLSHADEROP3EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void (GLAD_API_PTR *PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length);
typedef void (GLAD_API_PTR *PFNGLSHADERSOURCEARBPROC)(GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint * length);
typedef void (GLAD_API_PTR *PFNGLSHADERSTORAGEBLOCKBINDINGPROC)(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
typedef void (GLAD_API_PTR *PFNGLSIGNALSEMAPHOREEXTPROC)(GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * dstLayouts);
typedef void (GLAD_API_PTR *PFNGLSIGNALVKFENCENVPROC)(GLuint64 vkFence);
typedef void (GLAD_API_PTR *PFNGLSIGNALVKSEMAPHORENVPROC)(GLuint64 vkSemaphore);
typedef void (GLAD_API_PTR *PFNGLSPECIALIZESHADERPROC)(GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue);
typedef void (GLAD_API_PTR *PFNGLSPECIALIZESHADERARBPROC)(GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue);
typedef void (GLAD_API_PTR *PFNGLSTATECAPTURENVPROC)(GLuint state, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLSTENCILCLEARTAGEXTPROC)(GLsizei stencilTagBits, GLuint stencilClearTag);
typedef void (GLAD_API_PTR *PFNGLSTENCILFILLPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues);
typedef void (GLAD_API_PTR *PFNGLSTENCILFILLPATHNVPROC)(GLuint path, GLenum fillMode, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILFUNCSEPARATEATIPROC)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILMASKPROC)(GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
typedef void (GLAD_API_PTR *PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (GLAD_API_PTR *PFNGLSTENCILOPSEPARATEATIPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (GLAD_API_PTR *PFNGLSTENCILOPVALUEAMDPROC)(GLenum face, GLuint value);
typedef void (GLAD_API_PTR *PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues);
typedef void (GLAD_API_PTR *PFNGLSTENCILSTROKEPATHNVPROC)(GLuint path, GLint reference, GLuint mask);
typedef void (GLAD_API_PTR *PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);
typedef void (GLAD_API_PTR *PFNGLSTENCILTHENCOVERFILLPATHNVPROC)(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
typedef void (GLAD_API_PTR *PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);
typedef void (GLAD_API_PTR *PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC)(GLuint path, GLint reference, GLuint mask, GLenum coverMode);
typedef void (GLAD_API_PTR *PFNGLSUBPIXELPRECISIONBIASNVPROC)(GLuint xbits, GLuint ybits);
typedef void (GLAD_API_PTR *PFNGLSWIZZLEEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void (GLAD_API_PTR *PFNGLSYNCTEXTUREINTELPROC)(GLuint texture);
typedef void (GLAD_API_PTR *PFNGLTANGENT3BEXTPROC)(GLbyte tx, GLbyte ty, GLbyte tz);
typedef void (GLAD_API_PTR *PFNGLTANGENT3BVEXTPROC)(const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLTANGENT3DEXTPROC)(GLdouble tx, GLdouble ty, GLdouble tz);
typedef void (GLAD_API_PTR *PFNGLTANGENT3DVEXTPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLTANGENT3FEXTPROC)(GLfloat tx, GLfloat ty, GLfloat tz);
typedef void (GLAD_API_PTR *PFNGLTANGENT3FVEXTPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLTANGENT3IEXTPROC)(GLint tx, GLint ty, GLint tz);
typedef void (GLAD_API_PTR *PFNGLTANGENT3IVEXTPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLTANGENT3SEXTPROC)(GLshort tx, GLshort ty, GLshort tz);
typedef void (GLAD_API_PTR *PFNGLTANGENT3SVEXTPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLTANGENTPOINTEREXTPROC)(GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLTESSELLATIONFACTORAMDPROC)(GLfloat factor);
typedef void (GLAD_API_PTR *PFNGLTESSELLATIONMODEAMDPROC)(GLenum mode);
typedef GLboolean (GLAD_API_PTR *PFNGLTESTFENCEAPPLEPROC)(GLuint fence);
typedef GLboolean (GLAD_API_PTR *PFNGLTESTFENCENVPROC)(GLuint fence);
typedef GLboolean (GLAD_API_PTR *PFNGLTESTOBJECTAPPLEPROC)(GLenum object, GLuint name);
typedef void (GLAD_API_PTR *PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTEXBUFFERARBPROC)(GLenum target, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTEXBUFFEREXTPROC)(GLenum target, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTEXBUFFERRANGEPROC)(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTEXBUMPPARAMETERFVATIPROC)(GLenum pname, const GLfloat * param);
typedef void (GLAD_API_PTR *PFNGLTEXBUMPPARAMETERIVATIPROC)(GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLTEXCOORD1HNVPROC)(GLhalfNV s);
typedef void (GLAD_API_PTR *PFNGLTEXCOORD1HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLTEXCOORD2HNVPROC)(GLhalfNV s, GLhalfNV t);
typedef void (GLAD_API_PTR *PFNGLTEXCOORD2HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLTEXCOORD3HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void (GLAD_API_PTR *PFNGLTEXCOORD3HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLTEXCOORD4HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void (GLAD_API_PTR *PFNGLTEXCOORD4HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLTEXCOORDFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLTEXCOORDPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLTEXCOORDPOINTERVINTELPROC)(GLint size, GLenum type, const void ** pointer);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE1DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE2DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (GLAD_API_PTR *PFNGLTEXPAGECOMMITMENTARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXRENDERBUFFERNVPROC)(GLenum target, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE1DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE2DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE3DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGEMEM1DEXTPROC)(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGEMEM2DEXTPROC)(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGEMEM3DEXTPROC)(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXSTORAGESPARSEAMDPROC)(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBARRIERPROC)(void);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBARRIERNVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBUFFERPROC)(GLuint texture, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBUFFEREXTPROC)(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBUFFERRANGEPROC)(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTEXTUREBUFFERRANGEEXTPROC)(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (GLAD_API_PTR *PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (GLAD_API_PTR *PFNGLTEXTUREIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (GLAD_API_PTR *PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (GLAD_API_PTR *PFNGLTEXTURELIGHTEXTPROC)(GLenum pname);
typedef void (GLAD_API_PTR *PFNGLTEXTUREMATERIALEXTPROC)(GLenum face, GLenum mode);
typedef void (GLAD_API_PTR *PFNGLTEXTURENORMALEXTPROC)(GLenum mode);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPAGECOMMITMENTEXTPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIUIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLuint * params);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERFPROC)(GLuint texture, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERFEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, const GLfloat * param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIPROC)(GLuint texture, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, const GLint * param);
typedef void (GLAD_API_PTR *PFNGLTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLTEXTURERANGEAPPLEPROC)(GLenum target, GLsizei length, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLTEXTURERENDERBUFFEREXTPROC)(GLuint texture, GLenum target, GLuint renderbuffer);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE1DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE1DEXTPROC)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE2DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE2DEXTPROC)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC)(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE3DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE3DEXTPROC)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC)(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGEMEM1DEXTPROC)(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGEMEM2DEXTPROC)(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC)(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGEMEM3DEXTPROC)(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC)(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (GLAD_API_PTR *PFNGLTEXTURESTORAGESPARSEAMDPROC)(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (GLAD_API_PTR *PFNGLTEXTUREVIEWPROC)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
typedef void (GLAD_API_PTR *PFNGLTRACKMATRIXNVPROC)(GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC)(GLsizei count, const GLint * attribs, GLenum bufferMode);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)(GLuint xfb, GLuint index, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC)(GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC)(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC)(GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode);
typedef void (GLAD_API_PTR *PFNGLTRANSFORMPATHNVPROC)(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1DPROC)(GLint location, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1FARBPROC)(GLint location, GLfloat v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1FVARBPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1I64ARBPROC)(GLint location, GLint64 x);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1I64NVPROC)(GLint location, GLint64EXT x);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1I64VARBPROC)(GLint location, GLsizei count, const GLint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1IARBPROC)(GLint location, GLint v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1IVARBPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UI64ARBPROC)(GLint location, GLuint64 x);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UI64NVPROC)(GLint location, GLuint64EXT x);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIEXTPROC)(GLint location, GLuint v0);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM1UIVEXTPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2DPROC)(GLint location, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2FARBPROC)(GLint location, GLfloat v0, GLfloat v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2FVARBPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2I64ARBPROC)(GLint location, GLint64 x, GLint64 y);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2I64VARBPROC)(GLint location, GLsizei count, const GLint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2IARBPROC)(GLint location, GLint v0, GLint v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2IVARBPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIEXTPROC)(GLint location, GLuint v0, GLuint v1);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM2UIVEXTPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3FVARBPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3I64ARBPROC)(GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3I64VARBPROC)(GLint location, GLsizei count, const GLint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3IVARBPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM3UIVEXTPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4FVARBPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4I64ARBPROC)(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4I64VARBPROC)(GLint location, GLsizei count, const GLint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4IVARBPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORM4UIVEXTPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
typedef void (GLAD_API_PTR *PFNGLUNIFORMBUFFEREXTPROC)(GLuint program, GLint location, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLUNIFORMHANDLEUI64ARBPROC)(GLint location, GLuint64 value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMHANDLEUI64NVPROC)(GLint location, GLuint64 value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMHANDLEUI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMHANDLEUI64VNVPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count, const GLuint * indices);
typedef void (GLAD_API_PTR *PFNGLUNIFORMUI64NVPROC)(GLint location, GLuint64EXT value);
typedef void (GLAD_API_PTR *PFNGLUNIFORMUI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (GLAD_API_PTR *PFNGLUNLOCKARRAYSEXTPROC)(void);
typedef GLboolean (GLAD_API_PTR *PFNGLUNMAPBUFFERPROC)(GLenum target);
typedef GLboolean (GLAD_API_PTR *PFNGLUNMAPBUFFERARBPROC)(GLenum target);
typedef GLboolean (GLAD_API_PTR *PFNGLUNMAPNAMEDBUFFERPROC)(GLuint buffer);
typedef GLboolean (GLAD_API_PTR *PFNGLUNMAPNAMEDBUFFEREXTPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLUNMAPOBJECTBUFFERATIPROC)(GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLUNMAPTEXTURE2DINTELPROC)(GLuint texture, GLint level);
typedef void (GLAD_API_PTR *PFNGLUPDATEOBJECTBUFFERATIPROC)(GLuint buffer, GLuint offset, GLsizei size, const void * pointer, GLenum preserve);
typedef void (GLAD_API_PTR *PFNGLUSEPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLUSEPROGRAMOBJECTARBPROC)(GLhandleARB programObj);
typedef void (GLAD_API_PTR *PFNGLUSEPROGRAMSTAGESPROC)(GLuint pipeline, GLbitfield stages, GLuint program);
typedef void (GLAD_API_PTR *PFNGLUSESHADERPROGRAMEXTPROC)(GLenum type, GLuint program);
typedef void (GLAD_API_PTR *PFNGLVDPAUFININVPROC)(void);
typedef void (GLAD_API_PTR *PFNGLVDPAUGETSURFACEIVNVPROC)(GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei * length, GLint * values);
typedef void (GLAD_API_PTR *PFNGLVDPAUINITNVPROC)(const void * vdpDevice, const void * getProcAddress);
typedef GLboolean (GLAD_API_PTR *PFNGLVDPAUISSURFACENVPROC)(GLvdpauSurfaceNV surface);
typedef void (GLAD_API_PTR *PFNGLVDPAUMAPSURFACESNVPROC)(GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces);
typedef GLvdpauSurfaceNV (GLAD_API_PTR *PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC)(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames);
typedef GLvdpauSurfaceNV (GLAD_API_PTR *PFNGLVDPAUREGISTERVIDEOSURFACENVPROC)(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames);
typedef void (GLAD_API_PTR *PFNGLVDPAUSURFACEACCESSNVPROC)(GLvdpauSurfaceNV surface, GLenum access);
typedef void (GLAD_API_PTR *PFNGLVDPAUUNMAPSURFACESNVPROC)(GLsizei numSurface, const GLvdpauSurfaceNV * surfaces);
typedef void (GLAD_API_PTR *PFNGLVDPAUUNREGISTERSURFACENVPROC)(GLvdpauSurfaceNV surface);
typedef void (GLAD_API_PTR *PFNGLVALIDATEPROGRAMPROC)(GLuint program);
typedef void (GLAD_API_PTR *PFNGLVALIDATEPROGRAMARBPROC)(GLhandleARB programObj);
typedef void (GLAD_API_PTR *PFNGLVALIDATEPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef void (GLAD_API_PTR *PFNGLVARIANTARRAYOBJECTATIPROC)(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void (GLAD_API_PTR *PFNGLVARIANTPOINTEREXTPROC)(GLuint id, GLenum type, GLuint stride, const void * addr);
typedef void (GLAD_API_PTR *PFNGLVARIANTBVEXTPROC)(GLuint id, const GLbyte * addr);
typedef void (GLAD_API_PTR *PFNGLVARIANTDVEXTPROC)(GLuint id, const GLdouble * addr);
typedef void (GLAD_API_PTR *PFNGLVARIANTFVEXTPROC)(GLuint id, const GLfloat * addr);
typedef void (GLAD_API_PTR *PFNGLVARIANTIVEXTPROC)(GLuint id, const GLint * addr);
typedef void (GLAD_API_PTR *PFNGLVARIANTSVEXTPROC)(GLuint id, const GLshort * addr);
typedef void (GLAD_API_PTR *PFNGLVARIANTUBVEXTPROC)(GLuint id, const GLubyte * addr);
typedef void (GLAD_API_PTR *PFNGLVARIANTUIVEXTPROC)(GLuint id, const GLuint * addr);
typedef void (GLAD_API_PTR *PFNGLVARIANTUSVEXTPROC)(GLuint id, const GLushort * addr);
typedef void (GLAD_API_PTR *PFNGLVERTEX2HNVPROC)(GLhalfNV x, GLhalfNV y);
typedef void (GLAD_API_PTR *PFNGLVERTEX2HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEX3HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void (GLAD_API_PTR *PFNGLVERTEX3HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEX4HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void (GLAD_API_PTR *PFNGLVERTEX4HVNVPROC)(const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBBINDINGPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBIFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYATTRIBLFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYBINDINGDIVISORPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYCOLOROFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYELEMENTBUFFERPROC)(GLuint vaobj, GLuint buffer);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYINDEXOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYNORMALOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYPARAMETERIAPPLEPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYRANGENVPROC)(GLsizei length, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC)(GLuint vaobj, GLuint index, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXBUFFERPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXBUFFERSPROC)(GLuint vaobj, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);
typedef void (GLAD_API_PTR *PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DARBPROC)(GLuint index, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DNVPROC)(GLuint index, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DVARBPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1DVNVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FARBPROC)(GLuint index, GLfloat x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FNVPROC)(GLuint index, GLfloat x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FVARBPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1FVNVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1HNVPROC)(GLuint index, GLhalfNV x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1HVNVPROC)(GLuint index, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SARBPROC)(GLuint index, GLshort x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SNVPROC)(GLuint index, GLshort x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SVARBPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB1SVNVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DARBPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DNVPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DVARBPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2DVNVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FARBPROC)(GLuint index, GLfloat x, GLfloat y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FNVPROC)(GLuint index, GLfloat x, GLfloat y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FVARBPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2FVNVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2HVNVPROC)(GLuint index, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SARBPROC)(GLuint index, GLshort x, GLshort y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SNVPROC)(GLuint index, GLshort x, GLshort y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SVARBPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB2SVNVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DVARBPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3DVNVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FVARBPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3FVNVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3HVNVPROC)(GLuint index, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SVARBPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB3SVNVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NBVARBPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NIVARBPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NSVARBPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBARBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUBVARBPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUIVARBPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4NUSVARBPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4BVARBPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DVARBPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4DVNVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FVARBPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4FVNVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4HVNVPROC)(GLuint index, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4IVARBPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SVARBPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4SVNVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UBNVPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UBVARBPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UBVNVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4UIVARBPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIB4USVARBPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBARRAYOBJECTATIPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBBINDINGPROC)(GLuint attribindex, GLuint bindingindex);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBDIVISORARBPROC)(GLuint index, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IEXTPROC)(GLuint index, GLint x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1IVEXTPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIEXTPROC)(GLuint index, GLuint x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI1UIVEXTPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IEXTPROC)(GLuint index, GLint x, GLint y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2IVEXTPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIEXTPROC)(GLuint index, GLuint x, GLuint y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI2UIVEXTPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IEXTPROC)(GLuint index, GLint x, GLint y, GLint z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3IVEXTPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI3UIVEXTPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4BVEXTPROC)(GLuint index, const GLbyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IEXTPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4IVEXTPROC)(GLuint index, const GLint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4SVEXTPROC)(GLuint index, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UBVEXTPROC)(GLuint index, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4UIVEXTPROC)(GLuint index, const GLuint * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBI4USVEXTPROC)(GLuint index, const GLushort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBIFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBIFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBIPOINTEREXTPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1DPROC)(GLuint index, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1DEXTPROC)(GLuint index, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1DVEXTPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1I64NVPROC)(GLuint index, GLint64EXT x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1I64VNVPROC)(GLuint index, const GLint64EXT * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1UI64ARBPROC)(GLuint index, GLuint64EXT x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1UI64NVPROC)(GLuint index, GLuint64EXT x);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1UI64VARBPROC)(GLuint index, const GLuint64EXT * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL1UI64VNVPROC)(GLuint index, const GLuint64EXT * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2DPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2DEXTPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2DVEXTPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2I64VNVPROC)(GLuint index, const GLint64EXT * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL2UI64VNVPROC)(GLuint index, const GLuint64EXT * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3DEXTPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3DVEXTPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3I64VNVPROC)(GLuint index, const GLint64EXT * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL3UI64VNVPROC)(GLuint index, const GLuint64EXT * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4DEXTPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4DVPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4DVEXTPROC)(GLuint index, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4I64VNVPROC)(GLuint index, const GLint64EXT * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBL4UI64VNVPROC)(GLuint index, const GLuint64EXT * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBLFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBLFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBLPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBLPOINTEREXTPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBPARAMETERIAMDPROC)(GLuint index, GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBPOINTERARBPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBPOINTERNVPROC)(GLuint index, GLint fsize, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS1DVNVPROC)(GLuint index, GLsizei count, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS1FVNVPROC)(GLuint index, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS1HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS1SVNVPROC)(GLuint index, GLsizei count, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS2DVNVPROC)(GLuint index, GLsizei count, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS2FVNVPROC)(GLuint index, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS2HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS2SVNVPROC)(GLuint index, GLsizei count, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS3DVNVPROC)(GLuint index, GLsizei count, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS3FVNVPROC)(GLuint index, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS3HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS3SVNVPROC)(GLuint index, GLsizei count, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS4DVNVPROC)(GLuint index, GLsizei count, const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS4FVNVPROC)(GLuint index, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS4HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS4SVNVPROC)(GLuint index, GLsizei count, const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXATTRIBS4UBVNVPROC)(GLuint index, GLsizei count, const GLubyte * v);
typedef void (GLAD_API_PTR *PFNGLVERTEXBINDINGDIVISORPROC)(GLuint bindingindex, GLuint divisor);
typedef void (GLAD_API_PTR *PFNGLVERTEXBLENDARBPROC)(GLint count);
typedef void (GLAD_API_PTR *PFNGLVERTEXBLENDENVFATIPROC)(GLenum pname, GLfloat param);
typedef void (GLAD_API_PTR *PFNGLVERTEXBLENDENVIATIPROC)(GLenum pname, GLint param);
typedef void (GLAD_API_PTR *PFNGLVERTEXFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
typedef void (GLAD_API_PTR *PFNGLVERTEXPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXPOINTERVINTELPROC)(GLint size, GLenum type, const void ** pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM1DATIPROC)(GLenum stream, GLdouble x);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM1DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM1FATIPROC)(GLenum stream, GLfloat x);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM1FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM1IATIPROC)(GLenum stream, GLint x);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM1IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM1SATIPROC)(GLenum stream, GLshort x);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM1SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM2DATIPROC)(GLenum stream, GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM2DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM2FATIPROC)(GLenum stream, GLfloat x, GLfloat y);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM2FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM2IATIPROC)(GLenum stream, GLint x, GLint y);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM2IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM2SATIPROC)(GLenum stream, GLshort x, GLshort y);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM2SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM3DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM3DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM3FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM3FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM3IATIPROC)(GLenum stream, GLint x, GLint y, GLint z);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM3IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM3SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM3SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM4DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM4DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM4FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM4FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM4IATIPROC)(GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM4IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM4SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (GLAD_API_PTR *PFNGLVERTEXSTREAM4SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (GLAD_API_PTR *PFNGLVERTEXWEIGHTPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLVERTEXWEIGHTFEXTPROC)(GLfloat weight);
typedef void (GLAD_API_PTR *PFNGLVERTEXWEIGHTFVEXTPROC)(const GLfloat * weight);
typedef void (GLAD_API_PTR *PFNGLVERTEXWEIGHTHNVPROC)(GLhalfNV weight);
typedef void (GLAD_API_PTR *PFNGLVERTEXWEIGHTHVNVPROC)(const GLhalfNV * weight);
typedef GLenum (GLAD_API_PTR *PFNGLVIDEOCAPTURENVPROC)(GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time);
typedef void (GLAD_API_PTR *PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params);
typedef void (GLAD_API_PTR *PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params);
typedef void (GLAD_API_PTR *PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTARRAYVPROC)(GLuint first, GLsizei count, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTINDEXEDFPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTINDEXEDFVPROC)(GLuint index, const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTPOSITIONWSCALENVPROC)(GLuint index, GLfloat xcoeff, GLfloat ycoeff);
typedef void (GLAD_API_PTR *PFNGLVIEWPORTSWIZZLENVPROC)(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);
typedef void (GLAD_API_PTR *PFNGLWAITSEMAPHOREEXTPROC)(GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * srcLayouts);
typedef void (GLAD_API_PTR *PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (GLAD_API_PTR *PFNGLWAITVKSEMAPHORENVPROC)(GLuint64 vkSemaphore);
typedef void (GLAD_API_PTR *PFNGLWEIGHTPATHSNVPROC)(GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights);
typedef void (GLAD_API_PTR *PFNGLWEIGHTPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (GLAD_API_PTR *PFNGLWEIGHTBVARBPROC)(GLint size, const GLbyte * weights);
typedef void (GLAD_API_PTR *PFNGLWEIGHTDVARBPROC)(GLint size, const GLdouble * weights);
typedef void (GLAD_API_PTR *PFNGLWEIGHTFVARBPROC)(GLint size, const GLfloat * weights);
typedef void (GLAD_API_PTR *PFNGLWEIGHTIVARBPROC)(GLint size, const GLint * weights);
typedef void (GLAD_API_PTR *PFNGLWEIGHTSVARBPROC)(GLint size, const GLshort * weights);
typedef void (GLAD_API_PTR *PFNGLWEIGHTUBVARBPROC)(GLint size, const GLubyte * weights);
typedef void (GLAD_API_PTR *PFNGLWEIGHTUIVARBPROC)(GLint size, const GLuint * weights);
typedef void (GLAD_API_PTR *PFNGLWEIGHTUSVARBPROC)(GLint size, const GLushort * weights);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2DPROC)(GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2DARBPROC)(GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2DMESAPROC)(GLdouble x, GLdouble y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2DVPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2DVARBPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2DVMESAPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2FPROC)(GLfloat x, GLfloat y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2FARBPROC)(GLfloat x, GLfloat y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2FMESAPROC)(GLfloat x, GLfloat y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2FVPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2FVARBPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2FVMESAPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2IPROC)(GLint x, GLint y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2IARBPROC)(GLint x, GLint y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2IMESAPROC)(GLint x, GLint y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2IVPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2IVARBPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2IVMESAPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2SPROC)(GLshort x, GLshort y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2SARBPROC)(GLshort x, GLshort y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2SMESAPROC)(GLshort x, GLshort y);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2SVPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2SVARBPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS2SVMESAPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3DPROC)(GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3DARBPROC)(GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3DMESAPROC)(GLdouble x, GLdouble y, GLdouble z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3DVPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3DVARBPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3DVMESAPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3FPROC)(GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3FARBPROC)(GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3FMESAPROC)(GLfloat x, GLfloat y, GLfloat z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3FVPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3FVARBPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3FVMESAPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3IPROC)(GLint x, GLint y, GLint z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3IARBPROC)(GLint x, GLint y, GLint z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3IMESAPROC)(GLint x, GLint y, GLint z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3IVPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3IVARBPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3IVMESAPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3SPROC)(GLshort x, GLshort y, GLshort z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3SARBPROC)(GLshort x, GLshort y, GLshort z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3SMESAPROC)(GLshort x, GLshort y, GLshort z);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3SVPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3SVARBPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS3SVMESAPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS4DMESAPROC)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS4DVMESAPROC)(const GLdouble * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS4FMESAPROC)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS4FVMESAPROC)(const GLfloat * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS4IMESAPROC)(GLint x, GLint y, GLint z, GLint w);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS4IVMESAPROC)(const GLint * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS4SMESAPROC)(GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (GLAD_API_PTR *PFNGLWINDOWPOS4SVMESAPROC)(const GLshort * v);
typedef void (GLAD_API_PTR *PFNGLWINDOWRECTANGLESEXTPROC)(GLenum mode, GLsizei count, const GLint * box);
typedef void (GLAD_API_PTR *PFNGLWRITEMASKEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);

GLAD_API_CALL PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC glad_glAcquireKeyedMutexWin32EXT;
#define glAcquireKeyedMutexWin32EXT glad_glAcquireKeyedMutexWin32EXT
GLAD_API_CALL PFNGLACTIVEPROGRAMEXTPROC glad_glActiveProgramEXT;
#define glActiveProgramEXT glad_glActiveProgramEXT
GLAD_API_CALL PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram;
#define glActiveShaderProgram glad_glActiveShaderProgram
GLAD_API_CALL PFNGLACTIVESTENCILFACEEXTPROC glad_glActiveStencilFaceEXT;
#define glActiveStencilFaceEXT glad_glActiveStencilFaceEXT
GLAD_API_CALL PFNGLACTIVETEXTUREPROC glad_glActiveTexture;
#define glActiveTexture glad_glActiveTexture
GLAD_API_CALL PFNGLACTIVETEXTUREARBPROC glad_glActiveTextureARB;
#define glActiveTextureARB glad_glActiveTextureARB
GLAD_API_CALL PFNGLACTIVEVARYINGNVPROC glad_glActiveVaryingNV;
#define glActiveVaryingNV glad_glActiveVaryingNV
GLAD_API_CALL PFNGLALPHAFRAGMENTOP1ATIPROC glad_glAlphaFragmentOp1ATI;
#define glAlphaFragmentOp1ATI glad_glAlphaFragmentOp1ATI
GLAD_API_CALL PFNGLALPHAFRAGMENTOP2ATIPROC glad_glAlphaFragmentOp2ATI;
#define glAlphaFragmentOp2ATI glad_glAlphaFragmentOp2ATI
GLAD_API_CALL PFNGLALPHAFRAGMENTOP3ATIPROC glad_glAlphaFragmentOp3ATI;
#define glAlphaFragmentOp3ATI glad_glAlphaFragmentOp3ATI
GLAD_API_CALL PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC glad_glAlphaToCoverageDitherControlNV;
#define glAlphaToCoverageDitherControlNV glad_glAlphaToCoverageDitherControlNV
GLAD_API_CALL PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC glad_glApplyFramebufferAttachmentCMAAINTEL;
#define glApplyFramebufferAttachmentCMAAINTEL glad_glApplyFramebufferAttachmentCMAAINTEL
GLAD_API_CALL PFNGLAPPLYTEXTUREEXTPROC glad_glApplyTextureEXT;
#define glApplyTextureEXT glad_glApplyTextureEXT
GLAD_API_CALL PFNGLAREPROGRAMSRESIDENTNVPROC glad_glAreProgramsResidentNV;
#define glAreProgramsResidentNV glad_glAreProgramsResidentNV
GLAD_API_CALL PFNGLARETEXTURESRESIDENTEXTPROC glad_glAreTexturesResidentEXT;
#define glAreTexturesResidentEXT glad_glAreTexturesResidentEXT
GLAD_API_CALL PFNGLARRAYELEMENTPROC glad_glArrayElement;
#define glArrayElement glad_glArrayElement
GLAD_API_CALL PFNGLARRAYELEMENTEXTPROC glad_glArrayElementEXT;
#define glArrayElementEXT glad_glArrayElementEXT
GLAD_API_CALL PFNGLARRAYOBJECTATIPROC glad_glArrayObjectATI;
#define glArrayObjectATI glad_glArrayObjectATI
GLAD_API_CALL PFNGLATTACHOBJECTARBPROC glad_glAttachObjectARB;
#define glAttachObjectARB glad_glAttachObjectARB
GLAD_API_CALL PFNGLATTACHSHADERPROC glad_glAttachShader;
#define glAttachShader glad_glAttachShader
GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;
#define glBeginConditionalRender glad_glBeginConditionalRender
GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERNVPROC glad_glBeginConditionalRenderNV;
#define glBeginConditionalRenderNV glad_glBeginConditionalRenderNV
GLAD_API_CALL PFNGLBEGINCONDITIONALRENDERNVXPROC glad_glBeginConditionalRenderNVX;
#define glBeginConditionalRenderNVX glad_glBeginConditionalRenderNVX
GLAD_API_CALL PFNGLBEGINFRAGMENTSHADERATIPROC glad_glBeginFragmentShaderATI;
#define glBeginFragmentShaderATI glad_glBeginFragmentShaderATI
GLAD_API_CALL PFNGLBEGINOCCLUSIONQUERYNVPROC glad_glBeginOcclusionQueryNV;
#define glBeginOcclusionQueryNV glad_glBeginOcclusionQueryNV
GLAD_API_CALL PFNGLBEGINPERFMONITORAMDPROC glad_glBeginPerfMonitorAMD;
#define glBeginPerfMonitorAMD glad_glBeginPerfMonitorAMD
GLAD_API_CALL PFNGLBEGINPERFQUERYINTELPROC glad_glBeginPerfQueryINTEL;
#define glBeginPerfQueryINTEL glad_glBeginPerfQueryINTEL
GLAD_API_CALL PFNGLBEGINQUERYPROC glad_glBeginQuery;
#define glBeginQuery glad_glBeginQuery
GLAD_API_CALL PFNGLBEGINQUERYARBPROC glad_glBeginQueryARB;
#define glBeginQueryARB glad_glBeginQueryARB
GLAD_API_CALL PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed;
#define glBeginQueryIndexed glad_glBeginQueryIndexed
GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;
#define glBeginTransformFeedback glad_glBeginTransformFeedback
GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKEXTPROC glad_glBeginTransformFeedbackEXT;
#define glBeginTransformFeedbackEXT glad_glBeginTransformFeedbackEXT
GLAD_API_CALL PFNGLBEGINTRANSFORMFEEDBACKNVPROC glad_glBeginTransformFeedbackNV;
#define glBeginTransformFeedbackNV glad_glBeginTransformFeedbackNV
GLAD_API_CALL PFNGLBEGINVERTEXSHADEREXTPROC glad_glBeginVertexShaderEXT;
#define glBeginVertexShaderEXT glad_glBeginVertexShaderEXT
GLAD_API_CALL PFNGLBEGINVIDEOCAPTURENVPROC glad_glBeginVideoCaptureNV;
#define glBeginVideoCaptureNV glad_glBeginVideoCaptureNV
GLAD_API_CALL PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;
#define glBindAttribLocation glad_glBindAttribLocation
GLAD_API_CALL PFNGLBINDATTRIBLOCATIONARBPROC glad_glBindAttribLocationARB;
#define glBindAttribLocationARB glad_glBindAttribLocationARB
GLAD_API_CALL PFNGLBINDBUFFERPROC glad_glBindBuffer;
#define glBindBuffer glad_glBindBuffer
GLAD_API_CALL PFNGLBINDBUFFERARBPROC glad_glBindBufferARB;
#define glBindBufferARB glad_glBindBufferARB
GLAD_API_CALL PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;
#define glBindBufferBase glad_glBindBufferBase
GLAD_API_CALL PFNGLBINDBUFFERBASEEXTPROC glad_glBindBufferBaseEXT;
#define glBindBufferBaseEXT glad_glBindBufferBaseEXT
GLAD_API_CALL PFNGLBINDBUFFERBASENVPROC glad_glBindBufferBaseNV;
#define glBindBufferBaseNV glad_glBindBufferBaseNV
GLAD_API_CALL PFNGLBINDBUFFEROFFSETEXTPROC glad_glBindBufferOffsetEXT;
#define glBindBufferOffsetEXT glad_glBindBufferOffsetEXT
GLAD_API_CALL PFNGLBINDBUFFEROFFSETNVPROC glad_glBindBufferOffsetNV;
#define glBindBufferOffsetNV glad_glBindBufferOffsetNV
GLAD_API_CALL PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;
#define glBindBufferRange glad_glBindBufferRange
GLAD_API_CALL PFNGLBINDBUFFERRANGEEXTPROC glad_glBindBufferRangeEXT;
#define glBindBufferRangeEXT glad_glBindBufferRangeEXT
GLAD_API_CALL PFNGLBINDBUFFERRANGENVPROC glad_glBindBufferRangeNV;
#define glBindBufferRangeNV glad_glBindBufferRangeNV
GLAD_API_CALL PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase;
#define glBindBuffersBase glad_glBindBuffersBase
GLAD_API_CALL PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange;
#define glBindBuffersRange glad_glBindBuffersRange
GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;
#define glBindFragDataLocation glad_glBindFragDataLocation
GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONEXTPROC glad_glBindFragDataLocationEXT;
#define glBindFragDataLocationEXT glad_glBindFragDataLocationEXT
GLAD_API_CALL PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;
#define glBindFragDataLocationIndexed glad_glBindFragDataLocationIndexed
GLAD_API_CALL PFNGLBINDFRAGMENTSHADERATIPROC glad_glBindFragmentShaderATI;
#define glBindFragmentShaderATI glad_glBindFragmentShaderATI
GLAD_API_CALL PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;
#define glBindFramebuffer glad_glBindFramebuffer
GLAD_API_CALL PFNGLBINDFRAMEBUFFEREXTPROC glad_glBindFramebufferEXT;
#define glBindFramebufferEXT glad_glBindFramebufferEXT
GLAD_API_CALL PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture;
#define glBindImageTexture glad_glBindImageTexture
GLAD_API_CALL PFNGLBINDIMAGETEXTUREEXTPROC glad_glBindImageTextureEXT;
#define glBindImageTextureEXT glad_glBindImageTextureEXT
GLAD_API_CALL PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures;
#define glBindImageTextures glad_glBindImageTextures
GLAD_API_CALL PFNGLBINDLIGHTPARAMETEREXTPROC glad_glBindLightParameterEXT;
#define glBindLightParameterEXT glad_glBindLightParameterEXT
GLAD_API_CALL PFNGLBINDMATERIALPARAMETEREXTPROC glad_glBindMaterialParameterEXT;
#define glBindMaterialParameterEXT glad_glBindMaterialParameterEXT
GLAD_API_CALL PFNGLBINDMULTITEXTUREEXTPROC glad_glBindMultiTextureEXT;
#define glBindMultiTextureEXT glad_glBindMultiTextureEXT
GLAD_API_CALL PFNGLBINDPARAMETEREXTPROC glad_glBindParameterEXT;
#define glBindParameterEXT glad_glBindParameterEXT
GLAD_API_CALL PFNGLBINDPROGRAMARBPROC glad_glBindProgramARB;
#define glBindProgramARB glad_glBindProgramARB
GLAD_API_CALL PFNGLBINDPROGRAMNVPROC glad_glBindProgramNV;
#define glBindProgramNV glad_glBindProgramNV
GLAD_API_CALL PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline;
#define glBindProgramPipeline glad_glBindProgramPipeline
GLAD_API_CALL PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;
#define glBindRenderbuffer glad_glBindRenderbuffer
GLAD_API_CALL PFNGLBINDRENDERBUFFEREXTPROC glad_glBindRenderbufferEXT;
#define glBindRenderbufferEXT glad_glBindRenderbufferEXT
GLAD_API_CALL PFNGLBINDSAMPLERPROC glad_glBindSampler;
#define glBindSampler glad_glBindSampler
GLAD_API_CALL PFNGLBINDSAMPLERSPROC glad_glBindSamplers;
#define glBindSamplers glad_glBindSamplers
GLAD_API_CALL PFNGLBINDTEXGENPARAMETEREXTPROC glad_glBindTexGenParameterEXT;
#define glBindTexGenParameterEXT glad_glBindTexGenParameterEXT
GLAD_API_CALL PFNGLBINDTEXTUREPROC glad_glBindTexture;
#define glBindTexture glad_glBindTexture
GLAD_API_CALL PFNGLBINDTEXTUREEXTPROC glad_glBindTextureEXT;
#define glBindTextureEXT glad_glBindTextureEXT
GLAD_API_CALL PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit;
#define glBindTextureUnit glad_glBindTextureUnit
GLAD_API_CALL PFNGLBINDTEXTUREUNITPARAMETEREXTPROC glad_glBindTextureUnitParameterEXT;
#define glBindTextureUnitParameterEXT glad_glBindTextureUnitParameterEXT
GLAD_API_CALL PFNGLBINDTEXTURESPROC glad_glBindTextures;
#define glBindTextures glad_glBindTextures
GLAD_API_CALL PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback;
#define glBindTransformFeedback glad_glBindTransformFeedback
GLAD_API_CALL PFNGLBINDTRANSFORMFEEDBACKNVPROC glad_glBindTransformFeedbackNV;
#define glBindTransformFeedbackNV glad_glBindTransformFeedbackNV
GLAD_API_CALL PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;
#define glBindVertexArray glad_glBindVertexArray
GLAD_API_CALL PFNGLBINDVERTEXARRAYAPPLEPROC glad_glBindVertexArrayAPPLE;
#define glBindVertexArrayAPPLE glad_glBindVertexArrayAPPLE
GLAD_API_CALL PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer;
#define glBindVertexBuffer glad_glBindVertexBuffer
GLAD_API_CALL PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers;
#define glBindVertexBuffers glad_glBindVertexBuffers
GLAD_API_CALL PFNGLBINDVERTEXSHADEREXTPROC glad_glBindVertexShaderEXT;
#define glBindVertexShaderEXT glad_glBindVertexShaderEXT
GLAD_API_CALL PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC glad_glBindVideoCaptureStreamBufferNV;
#define glBindVideoCaptureStreamBufferNV glad_glBindVideoCaptureStreamBufferNV
GLAD_API_CALL PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC glad_glBindVideoCaptureStreamTextureNV;
#define glBindVideoCaptureStreamTextureNV glad_glBindVideoCaptureStreamTextureNV
GLAD_API_CALL PFNGLBINORMAL3BEXTPROC glad_glBinormal3bEXT;
#define glBinormal3bEXT glad_glBinormal3bEXT
GLAD_API_CALL PFNGLBINORMAL3BVEXTPROC glad_glBinormal3bvEXT;
#define glBinormal3bvEXT glad_glBinormal3bvEXT
GLAD_API_CALL PFNGLBINORMAL3DEXTPROC glad_glBinormal3dEXT;
#define glBinormal3dEXT glad_glBinormal3dEXT
GLAD_API_CALL PFNGLBINORMAL3DVEXTPROC glad_glBinormal3dvEXT;
#define glBinormal3dvEXT glad_glBinormal3dvEXT
GLAD_API_CALL PFNGLBINORMAL3FEXTPROC glad_glBinormal3fEXT;
#define glBinormal3fEXT glad_glBinormal3fEXT
GLAD_API_CALL PFNGLBINORMAL3FVEXTPROC glad_glBinormal3fvEXT;
#define glBinormal3fvEXT glad_glBinormal3fvEXT
GLAD_API_CALL PFNGLBINORMAL3IEXTPROC glad_glBinormal3iEXT;
#define glBinormal3iEXT glad_glBinormal3iEXT
GLAD_API_CALL PFNGLBINORMAL3IVEXTPROC glad_glBinormal3ivEXT;
#define glBinormal3ivEXT glad_glBinormal3ivEXT
GLAD_API_CALL PFNGLBINORMAL3SEXTPROC glad_glBinormal3sEXT;
#define glBinormal3sEXT glad_glBinormal3sEXT
GLAD_API_CALL PFNGLBINORMAL3SVEXTPROC glad_glBinormal3svEXT;
#define glBinormal3svEXT glad_glBinormal3svEXT
GLAD_API_CALL PFNGLBINORMALPOINTEREXTPROC glad_glBinormalPointerEXT;
#define glBinormalPointerEXT glad_glBinormalPointerEXT
GLAD_API_CALL PFNGLBLENDBARRIERPROC glad_glBlendBarrier;
#define glBlendBarrier glad_glBlendBarrier
GLAD_API_CALL PFNGLBLENDBARRIERKHRPROC glad_glBlendBarrierKHR;
#define glBlendBarrierKHR glad_glBlendBarrierKHR
GLAD_API_CALL PFNGLBLENDBARRIERNVPROC glad_glBlendBarrierNV;
#define glBlendBarrierNV glad_glBlendBarrierNV
GLAD_API_CALL PFNGLBLENDCOLORPROC glad_glBlendColor;
#define glBlendColor glad_glBlendColor
GLAD_API_CALL PFNGLBLENDCOLOREXTPROC glad_glBlendColorEXT;
#define glBlendColorEXT glad_glBlendColorEXT
GLAD_API_CALL PFNGLBLENDEQUATIONPROC glad_glBlendEquation;
#define glBlendEquation glad_glBlendEquation
GLAD_API_CALL PFNGLBLENDEQUATIONEXTPROC glad_glBlendEquationEXT;
#define glBlendEquationEXT glad_glBlendEquationEXT
GLAD_API_CALL PFNGLBLENDEQUATIONINDEXEDAMDPROC glad_glBlendEquationIndexedAMD;
#define glBlendEquationIndexedAMD glad_glBlendEquationIndexedAMD
GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;
#define glBlendEquationSeparate glad_glBlendEquationSeparate
GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEEXTPROC glad_glBlendEquationSeparateEXT;
#define glBlendEquationSeparateEXT glad_glBlendEquationSeparateEXT
GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC glad_glBlendEquationSeparateIndexedAMD;
#define glBlendEquationSeparateIndexedAMD glad_glBlendEquationSeparateIndexedAMD
GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei;
#define glBlendEquationSeparatei glad_glBlendEquationSeparatei
GLAD_API_CALL PFNGLBLENDEQUATIONSEPARATEIARBPROC glad_glBlendEquationSeparateiARB;
#define glBlendEquationSeparateiARB glad_glBlendEquationSeparateiARB
GLAD_API_CALL PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi;
#define glBlendEquationi glad_glBlendEquationi
GLAD_API_CALL PFNGLBLENDEQUATIONIARBPROC glad_glBlendEquationiARB;
#define glBlendEquationiARB glad_glBlendEquationiARB
GLAD_API_CALL PFNGLBLENDFUNCPROC glad_glBlendFunc;
#define glBlendFunc glad_glBlendFunc
GLAD_API_CALL PFNGLBLENDFUNCINDEXEDAMDPROC glad_glBlendFuncIndexedAMD;
#define glBlendFuncIndexedAMD glad_glBlendFuncIndexedAMD
GLAD_API_CALL PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;
#define glBlendFuncSeparate glad_glBlendFuncSeparate
GLAD_API_CALL PFNGLBLENDFUNCSEPARATEEXTPROC glad_glBlendFuncSeparateEXT;
#define glBlendFuncSeparateEXT glad_glBlendFuncSeparateEXT
GLAD_API_CALL PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC glad_glBlendFuncSeparateIndexedAMD;
#define glBlendFuncSeparateIndexedAMD glad_glBlendFuncSeparateIndexedAMD
GLAD_API_CALL PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei;
#define glBlendFuncSeparatei glad_glBlendFuncSeparatei
GLAD_API_CALL PFNGLBLENDFUNCSEPARATEIARBPROC glad_glBlendFuncSeparateiARB;
#define glBlendFuncSeparateiARB glad_glBlendFuncSeparateiARB
GLAD_API_CALL PFNGLBLENDFUNCIPROC glad_glBlendFunci;
#define glBlendFunci glad_glBlendFunci
GLAD_API_CALL PFNGLBLENDFUNCIARBPROC glad_glBlendFunciARB;
#define glBlendFunciARB glad_glBlendFunciARB
GLAD_API_CALL PFNGLBLENDPARAMETERINVPROC glad_glBlendParameteriNV;
#define glBlendParameteriNV glad_glBlendParameteriNV
GLAD_API_CALL PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;
#define glBlitFramebuffer glad_glBlitFramebuffer
GLAD_API_CALL PFNGLBLITFRAMEBUFFEREXTPROC glad_glBlitFramebufferEXT;
#define glBlitFramebufferEXT glad_glBlitFramebufferEXT
GLAD_API_CALL PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer;
#define glBlitNamedFramebuffer glad_glBlitNamedFramebuffer
GLAD_API_CALL PFNGLBUFFERADDRESSRANGENVPROC glad_glBufferAddressRangeNV;
#define glBufferAddressRangeNV glad_glBufferAddressRangeNV
GLAD_API_CALL PFNGLBUFFERDATAPROC glad_glBufferData;
#define glBufferData glad_glBufferData
GLAD_API_CALL PFNGLBUFFERDATAARBPROC glad_glBufferDataARB;
#define glBufferDataARB glad_glBufferDataARB
GLAD_API_CALL PFNGLBUFFERPAGECOMMITMENTARBPROC glad_glBufferPageCommitmentARB;
#define glBufferPageCommitmentARB glad_glBufferPageCommitmentARB
GLAD_API_CALL PFNGLBUFFERPARAMETERIAPPLEPROC glad_glBufferParameteriAPPLE;
#define glBufferParameteriAPPLE glad_glBufferParameteriAPPLE
GLAD_API_CALL PFNGLBUFFERSTORAGEPROC glad_glBufferStorage;
#define glBufferStorage glad_glBufferStorage
GLAD_API_CALL PFNGLBUFFERSTORAGEEXTERNALEXTPROC glad_glBufferStorageExternalEXT;
#define glBufferStorageExternalEXT glad_glBufferStorageExternalEXT
GLAD_API_CALL PFNGLBUFFERSTORAGEMEMEXTPROC glad_glBufferStorageMemEXT;
#define glBufferStorageMemEXT glad_glBufferStorageMemEXT
GLAD_API_CALL PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;
#define glBufferSubData glad_glBufferSubData
GLAD_API_CALL PFNGLBUFFERSUBDATAARBPROC glad_glBufferSubDataARB;
#define glBufferSubDataARB glad_glBufferSubDataARB
GLAD_API_CALL PFNGLCALLCOMMANDLISTNVPROC glad_glCallCommandListNV;
#define glCallCommandListNV glad_glCallCommandListNV
GLAD_API_CALL PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;
#define glCheckFramebufferStatus glad_glCheckFramebufferStatus
GLAD_API_CALL PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC glad_glCheckFramebufferStatusEXT;
#define glCheckFramebufferStatusEXT glad_glCheckFramebufferStatusEXT
GLAD_API_CALL PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus;
#define glCheckNamedFramebufferStatus glad_glCheckNamedFramebufferStatus
GLAD_API_CALL PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC glad_glCheckNamedFramebufferStatusEXT;
#define glCheckNamedFramebufferStatusEXT glad_glCheckNamedFramebufferStatusEXT
GLAD_API_CALL PFNGLCLAMPCOLORPROC glad_glClampColor;
#define glClampColor glad_glClampColor
GLAD_API_CALL PFNGLCLAMPCOLORARBPROC glad_glClampColorARB;
#define glClampColorARB glad_glClampColorARB
GLAD_API_CALL PFNGLCLEARPROC glad_glClear;
#define glClear glad_glClear
GLAD_API_CALL PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData;
#define glClearBufferData glad_glClearBufferData
GLAD_API_CALL PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData;
#define glClearBufferSubData glad_glClearBufferSubData
GLAD_API_CALL PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;
#define glClearBufferfi glad_glClearBufferfi
GLAD_API_CALL PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;
#define glClearBufferfv glad_glClearBufferfv
GLAD_API_CALL PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;
#define glClearBufferiv glad_glClearBufferiv
GLAD_API_CALL PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;
#define glClearBufferuiv glad_glClearBufferuiv
GLAD_API_CALL PFNGLCLEARCOLORPROC glad_glClearColor;
#define glClearColor glad_glClearColor
GLAD_API_CALL PFNGLCLEARCOLORIIEXTPROC glad_glClearColorIiEXT;
#define glClearColorIiEXT glad_glClearColorIiEXT
GLAD_API_CALL PFNGLCLEARCOLORIUIEXTPROC glad_glClearColorIuiEXT;
#define glClearColorIuiEXT glad_glClearColorIuiEXT
GLAD_API_CALL PFNGLCLEARDEPTHPROC glad_glClearDepth;
#define glClearDepth glad_glClearDepth
GLAD_API_CALL PFNGLCLEARDEPTHDNVPROC glad_glClearDepthdNV;
#define glClearDepthdNV glad_glClearDepthdNV
GLAD_API_CALL PFNGLCLEARDEPTHFPROC glad_glClearDepthf;
#define glClearDepthf glad_glClearDepthf
GLAD_API_CALL PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData;
#define glClearNamedBufferData glad_glClearNamedBufferData
GLAD_API_CALL PFNGLCLEARNAMEDBUFFERDATAEXTPROC glad_glClearNamedBufferDataEXT;
#define glClearNamedBufferDataEXT glad_glClearNamedBufferDataEXT
GLAD_API_CALL PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData;
#define glClearNamedBufferSubData glad_glClearNamedBufferSubData
GLAD_API_CALL PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC glad_glClearNamedBufferSubDataEXT;
#define glClearNamedBufferSubDataEXT glad_glClearNamedBufferSubDataEXT
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi;
#define glClearNamedFramebufferfi glad_glClearNamedFramebufferfi
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv;
#define glClearNamedFramebufferfv glad_glClearNamedFramebufferfv
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv;
#define glClearNamedFramebufferiv glad_glClearNamedFramebufferiv
GLAD_API_CALL PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv;
#define glClearNamedFramebufferuiv glad_glClearNamedFramebufferuiv
GLAD_API_CALL PFNGLCLEARSTENCILPROC glad_glClearStencil;
#define glClearStencil glad_glClearStencil
GLAD_API_CALL PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage;
#define glClearTexImage glad_glClearTexImage
GLAD_API_CALL PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage;
#define glClearTexSubImage glad_glClearTexSubImage
GLAD_API_CALL PFNGLCLIENTACTIVETEXTUREPROC glad_glClientActiveTexture;
#define glClientActiveTexture glad_glClientActiveTexture
GLAD_API_CALL PFNGLCLIENTACTIVETEXTUREARBPROC glad_glClientActiveTextureARB;
#define glClientActiveTextureARB glad_glClientActiveTextureARB
GLAD_API_CALL PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC glad_glClientActiveVertexStreamATI;
#define glClientActiveVertexStreamATI glad_glClientActiveVertexStreamATI
GLAD_API_CALL PFNGLCLIENTATTRIBDEFAULTEXTPROC glad_glClientAttribDefaultEXT;
#define glClientAttribDefaultEXT glad_glClientAttribDefaultEXT
GLAD_API_CALL PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;
#define glClientWaitSync glad_glClientWaitSync
GLAD_API_CALL PFNGLCLIPCONTROLPROC glad_glClipControl;
#define glClipControl glad_glClipControl
GLAD_API_CALL PFNGLCOLOR3HNVPROC glad_glColor3hNV;
#define glColor3hNV glad_glColor3hNV
GLAD_API_CALL PFNGLCOLOR3HVNVPROC glad_glColor3hvNV;
#define glColor3hvNV glad_glColor3hvNV
GLAD_API_CALL PFNGLCOLOR4HNVPROC glad_glColor4hNV;
#define glColor4hNV glad_glColor4hNV
GLAD_API_CALL PFNGLCOLOR4HVNVPROC glad_glColor4hvNV;
#define glColor4hvNV glad_glColor4hvNV
GLAD_API_CALL PFNGLCOLORFORMATNVPROC glad_glColorFormatNV;
#define glColorFormatNV glad_glColorFormatNV
GLAD_API_CALL PFNGLCOLORFRAGMENTOP1ATIPROC glad_glColorFragmentOp1ATI;
#define glColorFragmentOp1ATI glad_glColorFragmentOp1ATI
GLAD_API_CALL PFNGLCOLORFRAGMENTOP2ATIPROC glad_glColorFragmentOp2ATI;
#define glColorFragmentOp2ATI glad_glColorFragmentOp2ATI
GLAD_API_CALL PFNGLCOLORFRAGMENTOP3ATIPROC glad_glColorFragmentOp3ATI;
#define glColorFragmentOp3ATI glad_glColorFragmentOp3ATI
GLAD_API_CALL PFNGLCOLORMASKPROC glad_glColorMask;
#define glColorMask glad_glColorMask
GLAD_API_CALL PFNGLCOLORMASKINDEXEDEXTPROC glad_glColorMaskIndexedEXT;
#define glColorMaskIndexedEXT glad_glColorMaskIndexedEXT
GLAD_API_CALL PFNGLCOLORMASKIPROC glad_glColorMaski;
#define glColorMaski glad_glColorMaski
GLAD_API_CALL PFNGLCOLORPOINTEREXTPROC glad_glColorPointerEXT;
#define glColorPointerEXT glad_glColorPointerEXT
GLAD_API_CALL PFNGLCOLORPOINTERVINTELPROC glad_glColorPointervINTEL;
#define glColorPointervINTEL glad_glColorPointervINTEL
GLAD_API_CALL PFNGLCOLORSUBTABLEPROC glad_glColorSubTable;
#define glColorSubTable glad_glColorSubTable
GLAD_API_CALL PFNGLCOLORSUBTABLEEXTPROC glad_glColorSubTableEXT;
#define glColorSubTableEXT glad_glColorSubTableEXT
GLAD_API_CALL PFNGLCOLORTABLEPROC glad_glColorTable;
#define glColorTable glad_glColorTable
GLAD_API_CALL PFNGLCOLORTABLEEXTPROC glad_glColorTableEXT;
#define glColorTableEXT glad_glColorTableEXT
GLAD_API_CALL PFNGLCOMBINERINPUTNVPROC glad_glCombinerInputNV;
#define glCombinerInputNV glad_glCombinerInputNV
GLAD_API_CALL PFNGLCOMBINEROUTPUTNVPROC glad_glCombinerOutputNV;
#define glCombinerOutputNV glad_glCombinerOutputNV
GLAD_API_CALL PFNGLCOMBINERPARAMETERFNVPROC glad_glCombinerParameterfNV;
#define glCombinerParameterfNV glad_glCombinerParameterfNV
GLAD_API_CALL PFNGLCOMBINERPARAMETERFVNVPROC glad_glCombinerParameterfvNV;
#define glCombinerParameterfvNV glad_glCombinerParameterfvNV
GLAD_API_CALL PFNGLCOMBINERPARAMETERINVPROC glad_glCombinerParameteriNV;
#define glCombinerParameteriNV glad_glCombinerParameteriNV
GLAD_API_CALL PFNGLCOMBINERPARAMETERIVNVPROC glad_glCombinerParameterivNV;
#define glCombinerParameterivNV glad_glCombinerParameterivNV
GLAD_API_CALL PFNGLCOMBINERSTAGEPARAMETERFVNVPROC glad_glCombinerStageParameterfvNV;
#define glCombinerStageParameterfvNV glad_glCombinerStageParameterfvNV
GLAD_API_CALL PFNGLCOMMANDLISTSEGMENTSNVPROC glad_glCommandListSegmentsNV;
#define glCommandListSegmentsNV glad_glCommandListSegmentsNV
GLAD_API_CALL PFNGLCOMPILECOMMANDLISTNVPROC glad_glCompileCommandListNV;
#define glCompileCommandListNV glad_glCompileCommandListNV
GLAD_API_CALL PFNGLCOMPILESHADERPROC glad_glCompileShader;
#define glCompileShader glad_glCompileShader
GLAD_API_CALL PFNGLCOMPILESHADERARBPROC glad_glCompileShaderARB;
#define glCompileShaderARB glad_glCompileShaderARB
GLAD_API_CALL PFNGLCOMPILESHADERINCLUDEARBPROC glad_glCompileShaderIncludeARB;
#define glCompileShaderIncludeARB glad_glCompileShaderIncludeARB
GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC glad_glCompressedMultiTexImage1DEXT;
#define glCompressedMultiTexImage1DEXT glad_glCompressedMultiTexImage1DEXT
GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC glad_glCompressedMultiTexImage2DEXT;
#define glCompressedMultiTexImage2DEXT glad_glCompressedMultiTexImage2DEXT
GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC glad_glCompressedMultiTexImage3DEXT;
#define glCompressedMultiTexImage3DEXT glad_glCompressedMultiTexImage3DEXT
GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC glad_glCompressedMultiTexSubImage1DEXT;
#define glCompressedMultiTexSubImage1DEXT glad_glCompressedMultiTexSubImage1DEXT
GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC glad_glCompressedMultiTexSubImage2DEXT;
#define glCompressedMultiTexSubImage2DEXT glad_glCompressedMultiTexSubImage2DEXT
GLAD_API_CALL PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC glad_glCompressedMultiTexSubImage3DEXT;
#define glCompressedMultiTexSubImage3DEXT glad_glCompressedMultiTexSubImage3DEXT
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;
#define glCompressedTexImage1D glad_glCompressedTexImage1D
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE1DARBPROC glad_glCompressedTexImage1DARB;
#define glCompressedTexImage1DARB glad_glCompressedTexImage1DARB
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;
#define glCompressedTexImage2D glad_glCompressedTexImage2D
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE2DARBPROC glad_glCompressedTexImage2DARB;
#define glCompressedTexImage2DARB glad_glCompressedTexImage2DARB
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;
#define glCompressedTexImage3D glad_glCompressedTexImage3D
GLAD_API_CALL PFNGLCOMPRESSEDTEXIMAGE3DARBPROC glad_glCompressedTexImage3DARB;
#define glCompressedTexImage3DARB glad_glCompressedTexImage3DARB
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;
#define glCompressedTexSubImage1D glad_glCompressedTexSubImage1D
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC glad_glCompressedTexSubImage1DARB;
#define glCompressedTexSubImage1DARB glad_glCompressedTexSubImage1DARB
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;
#define glCompressedTexSubImage2D glad_glCompressedTexSubImage2D
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC glad_glCompressedTexSubImage2DARB;
#define glCompressedTexSubImage2DARB glad_glCompressedTexSubImage2DARB
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;
#define glCompressedTexSubImage3D glad_glCompressedTexSubImage3D
GLAD_API_CALL PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC glad_glCompressedTexSubImage3DARB;
#define glCompressedTexSubImage3DARB glad_glCompressedTexSubImage3DARB
GLAD_API_CALL PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC glad_glCompressedTextureImage1DEXT;
#define glCompressedTextureImage1DEXT glad_glCompressedTextureImage1DEXT
GLAD_API_CALL PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC glad_glCompressedTextureImage2DEXT;
#define glCompressedTextureImage2DEXT glad_glCompressedTextureImage2DEXT
GLAD_API_CALL PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC glad_glCompressedTextureImage3DEXT;
#define glCompressedTextureImage3DEXT glad_glCompressedTextureImage3DEXT
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D;
#define glCompressedTextureSubImage1D glad_glCompressedTextureSubImage1D
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC glad_glCompressedTextureSubImage1DEXT;
#define glCompressedTextureSubImage1DEXT glad_glCompressedTextureSubImage1DEXT
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D;
#define glCompressedTextureSubImage2D glad_glCompressedTextureSubImage2D
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC glad_glCompressedTextureSubImage2DEXT;
#define glCompressedTextureSubImage2DEXT glad_glCompressedTextureSubImage2DEXT
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D;
#define glCompressedTextureSubImage3D glad_glCompressedTextureSubImage3D
GLAD_API_CALL PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC glad_glCompressedTextureSubImage3DEXT;
#define glCompressedTextureSubImage3DEXT glad_glCompressedTextureSubImage3DEXT
GLAD_API_CALL PFNGLCONSERVATIVERASTERPARAMETERFNVPROC glad_glConservativeRasterParameterfNV;
#define glConservativeRasterParameterfNV glad_glConservativeRasterParameterfNV
GLAD_API_CALL PFNGLCONSERVATIVERASTERPARAMETERINVPROC glad_glConservativeRasterParameteriNV;
#define glConservativeRasterParameteriNV glad_glConservativeRasterParameteriNV
GLAD_API_CALL PFNGLCONVOLUTIONFILTER1DPROC glad_glConvolutionFilter1D;
#define glConvolutionFilter1D glad_glConvolutionFilter1D
GLAD_API_CALL PFNGLCONVOLUTIONFILTER1DEXTPROC glad_glConvolutionFilter1DEXT;
#define glConvolutionFilter1DEXT glad_glConvolutionFilter1DEXT
GLAD_API_CALL PFNGLCONVOLUTIONFILTER2DPROC glad_glConvolutionFilter2D;
#define glConvolutionFilter2D glad_glConvolutionFilter2D
GLAD_API_CALL PFNGLCONVOLUTIONFILTER2DEXTPROC glad_glConvolutionFilter2DEXT;
#define glConvolutionFilter2DEXT glad_glConvolutionFilter2DEXT
GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERFPROC glad_glConvolutionParameterf;
#define glConvolutionParameterf glad_glConvolutionParameterf
GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERFEXTPROC glad_glConvolutionParameterfEXT;
#define glConvolutionParameterfEXT glad_glConvolutionParameterfEXT
GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERFVPROC glad_glConvolutionParameterfv;
#define glConvolutionParameterfv glad_glConvolutionParameterfv
GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERFVEXTPROC glad_glConvolutionParameterfvEXT;
#define glConvolutionParameterfvEXT glad_glConvolutionParameterfvEXT
GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERIPROC glad_glConvolutionParameteri;
#define glConvolutionParameteri glad_glConvolutionParameteri
GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERIEXTPROC glad_glConvolutionParameteriEXT;
#define glConvolutionParameteriEXT glad_glConvolutionParameteriEXT
GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERIVPROC glad_glConvolutionParameteriv;
#define glConvolutionParameteriv glad_glConvolutionParameteriv
GLAD_API_CALL PFNGLCONVOLUTIONPARAMETERIVEXTPROC glad_glConvolutionParameterivEXT;
#define glConvolutionParameterivEXT glad_glConvolutionParameterivEXT
GLAD_API_CALL PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;
#define glCopyBufferSubData glad_glCopyBufferSubData
GLAD_API_CALL PFNGLCOPYCOLORSUBTABLEPROC glad_glCopyColorSubTable;
#define glCopyColorSubTable glad_glCopyColorSubTable
GLAD_API_CALL PFNGLCOPYCOLORSUBTABLEEXTPROC glad_glCopyColorSubTableEXT;
#define glCopyColorSubTableEXT glad_glCopyColorSubTableEXT
GLAD_API_CALL PFNGLCOPYCONVOLUTIONFILTER1DPROC glad_glCopyConvolutionFilter1D;
#define glCopyConvolutionFilter1D glad_glCopyConvolutionFilter1D
GLAD_API_CALL PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC glad_glCopyConvolutionFilter1DEXT;
#define glCopyConvolutionFilter1DEXT glad_glCopyConvolutionFilter1DEXT
GLAD_API_CALL PFNGLCOPYCONVOLUTIONFILTER2DPROC glad_glCopyConvolutionFilter2D;
#define glCopyConvolutionFilter2D glad_glCopyConvolutionFilter2D
GLAD_API_CALL PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC glad_glCopyConvolutionFilter2DEXT;
#define glCopyConvolutionFilter2DEXT glad_glCopyConvolutionFilter2DEXT
GLAD_API_CALL PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData;
#define glCopyImageSubData glad_glCopyImageSubData
GLAD_API_CALL PFNGLCOPYIMAGESUBDATANVPROC glad_glCopyImageSubDataNV;
#define glCopyImageSubDataNV glad_glCopyImageSubDataNV
GLAD_API_CALL PFNGLCOPYMULTITEXIMAGE1DEXTPROC glad_glCopyMultiTexImage1DEXT;
#define glCopyMultiTexImage1DEXT glad_glCopyMultiTexImage1DEXT
GLAD_API_CALL PFNGLCOPYMULTITEXIMAGE2DEXTPROC glad_glCopyMultiTexImage2DEXT;
#define glCopyMultiTexImage2DEXT glad_glCopyMultiTexImage2DEXT
GLAD_API_CALL PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC glad_glCopyMultiTexSubImage1DEXT;
#define glCopyMultiTexSubImage1DEXT glad_glCopyMultiTexSubImage1DEXT
GLAD_API_CALL PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC glad_glCopyMultiTexSubImage2DEXT;
#define glCopyMultiTexSubImage2DEXT glad_glCopyMultiTexSubImage2DEXT
GLAD_API_CALL PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC glad_glCopyMultiTexSubImage3DEXT;
#define glCopyMultiTexSubImage3DEXT glad_glCopyMultiTexSubImage3DEXT
GLAD_API_CALL PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData;
#define glCopyNamedBufferSubData glad_glCopyNamedBufferSubData
GLAD_API_CALL PFNGLCOPYPATHNVPROC glad_glCopyPathNV;
#define glCopyPathNV glad_glCopyPathNV
GLAD_API_CALL PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;
#define glCopyTexImage1D glad_glCopyTexImage1D
GLAD_API_CALL PFNGLCOPYTEXIMAGE1DEXTPROC glad_glCopyTexImage1DEXT;
#define glCopyTexImage1DEXT glad_glCopyTexImage1DEXT
GLAD_API_CALL PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;
#define glCopyTexImage2D glad_glCopyTexImage2D
GLAD_API_CALL PFNGLCOPYTEXIMAGE2DEXTPROC glad_glCopyTexImage2DEXT;
#define glCopyTexImage2DEXT glad_glCopyTexImage2DEXT
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;
#define glCopyTexSubImage1D glad_glCopyTexSubImage1D
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE1DEXTPROC glad_glCopyTexSubImage1DEXT;
#define glCopyTexSubImage1DEXT glad_glCopyTexSubImage1DEXT
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;
#define glCopyTexSubImage2D glad_glCopyTexSubImage2D
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE2DEXTPROC glad_glCopyTexSubImage2DEXT;
#define glCopyTexSubImage2DEXT glad_glCopyTexSubImage2DEXT
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;
#define glCopyTexSubImage3D glad_glCopyTexSubImage3D
GLAD_API_CALL PFNGLCOPYTEXSUBIMAGE3DEXTPROC glad_glCopyTexSubImage3DEXT;
#define glCopyTexSubImage3DEXT glad_glCopyTexSubImage3DEXT
GLAD_API_CALL PFNGLCOPYTEXTUREIMAGE1DEXTPROC glad_glCopyTextureImage1DEXT;
#define glCopyTextureImage1DEXT glad_glCopyTextureImage1DEXT
GLAD_API_CALL PFNGLCOPYTEXTUREIMAGE2DEXTPROC glad_glCopyTextureImage2DEXT;
#define glCopyTextureImage2DEXT glad_glCopyTextureImage2DEXT
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D;
#define glCopyTextureSubImage1D glad_glCopyTextureSubImage1D
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC glad_glCopyTextureSubImage1DEXT;
#define glCopyTextureSubImage1DEXT glad_glCopyTextureSubImage1DEXT
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D;
#define glCopyTextureSubImage2D glad_glCopyTextureSubImage2D
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC glad_glCopyTextureSubImage2DEXT;
#define glCopyTextureSubImage2DEXT glad_glCopyTextureSubImage2DEXT
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D;
#define glCopyTextureSubImage3D glad_glCopyTextureSubImage3D
GLAD_API_CALL PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC glad_glCopyTextureSubImage3DEXT;
#define glCopyTextureSubImage3DEXT glad_glCopyTextureSubImage3DEXT
GLAD_API_CALL PFNGLCOVERFILLPATHINSTANCEDNVPROC glad_glCoverFillPathInstancedNV;
#define glCoverFillPathInstancedNV glad_glCoverFillPathInstancedNV
GLAD_API_CALL PFNGLCOVERFILLPATHNVPROC glad_glCoverFillPathNV;
#define glCoverFillPathNV glad_glCoverFillPathNV
GLAD_API_CALL PFNGLCOVERSTROKEPATHINSTANCEDNVPROC glad_glCoverStrokePathInstancedNV;
#define glCoverStrokePathInstancedNV glad_glCoverStrokePathInstancedNV
GLAD_API_CALL PFNGLCOVERSTROKEPATHNVPROC glad_glCoverStrokePathNV;
#define glCoverStrokePathNV glad_glCoverStrokePathNV
GLAD_API_CALL PFNGLCOVERAGEMODULATIONNVPROC glad_glCoverageModulationNV;
#define glCoverageModulationNV glad_glCoverageModulationNV
GLAD_API_CALL PFNGLCOVERAGEMODULATIONTABLENVPROC glad_glCoverageModulationTableNV;
#define glCoverageModulationTableNV glad_glCoverageModulationTableNV
GLAD_API_CALL PFNGLCREATEBUFFERSPROC glad_glCreateBuffers;
#define glCreateBuffers glad_glCreateBuffers
GLAD_API_CALL PFNGLCREATECOMMANDLISTSNVPROC glad_glCreateCommandListsNV;
#define glCreateCommandListsNV glad_glCreateCommandListsNV
GLAD_API_CALL PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers;
#define glCreateFramebuffers glad_glCreateFramebuffers
GLAD_API_CALL PFNGLCREATEMEMORYOBJECTSEXTPROC glad_glCreateMemoryObjectsEXT;
#define glCreateMemoryObjectsEXT glad_glCreateMemoryObjectsEXT
GLAD_API_CALL PFNGLCREATEPERFQUERYINTELPROC glad_glCreatePerfQueryINTEL;
#define glCreatePerfQueryINTEL glad_glCreatePerfQueryINTEL
GLAD_API_CALL PFNGLCREATEPROGRAMPROC glad_glCreateProgram;
#define glCreateProgram glad_glCreateProgram
GLAD_API_CALL PFNGLCREATEPROGRAMOBJECTARBPROC glad_glCreateProgramObjectARB;
#define glCreateProgramObjectARB glad_glCreateProgramObjectARB
GLAD_API_CALL PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines;
#define glCreateProgramPipelines glad_glCreateProgramPipelines
GLAD_API_CALL PFNGLCREATEQUERIESPROC glad_glCreateQueries;
#define glCreateQueries glad_glCreateQueries
GLAD_API_CALL PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers;
#define glCreateRenderbuffers glad_glCreateRenderbuffers
GLAD_API_CALL PFNGLCREATESAMPLERSPROC glad_glCreateSamplers;
#define glCreateSamplers glad_glCreateSamplers
GLAD_API_CALL PFNGLCREATESHADERPROC glad_glCreateShader;
#define glCreateShader glad_glCreateShader
GLAD_API_CALL PFNGLCREATESHADEROBJECTARBPROC glad_glCreateShaderObjectARB;
#define glCreateShaderObjectARB glad_glCreateShaderObjectARB
GLAD_API_CALL PFNGLCREATESHADERPROGRAMEXTPROC glad_glCreateShaderProgramEXT;
#define glCreateShaderProgramEXT glad_glCreateShaderProgramEXT
GLAD_API_CALL PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv;
#define glCreateShaderProgramv glad_glCreateShaderProgramv
GLAD_API_CALL PFNGLCREATESTATESNVPROC glad_glCreateStatesNV;
#define glCreateStatesNV glad_glCreateStatesNV
GLAD_API_CALL PFNGLCREATESYNCFROMCLEVENTARBPROC glad_glCreateSyncFromCLeventARB;
#define glCreateSyncFromCLeventARB glad_glCreateSyncFromCLeventARB
GLAD_API_CALL PFNGLCREATETEXTURESPROC glad_glCreateTextures;
#define glCreateTextures glad_glCreateTextures
GLAD_API_CALL PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks;
#define glCreateTransformFeedbacks glad_glCreateTransformFeedbacks
GLAD_API_CALL PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays;
#define glCreateVertexArrays glad_glCreateVertexArrays
GLAD_API_CALL PFNGLCULLFACEPROC glad_glCullFace;
#define glCullFace glad_glCullFace
GLAD_API_CALL PFNGLCULLPARAMETERDVEXTPROC glad_glCullParameterdvEXT;
#define glCullParameterdvEXT glad_glCullParameterdvEXT
GLAD_API_CALL PFNGLCULLPARAMETERFVEXTPROC glad_glCullParameterfvEXT;
#define glCullParameterfvEXT glad_glCullParameterfvEXT
GLAD_API_CALL PFNGLCURRENTPALETTEMATRIXARBPROC glad_glCurrentPaletteMatrixARB;
#define glCurrentPaletteMatrixARB glad_glCurrentPaletteMatrixARB
GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback;
#define glDebugMessageCallback glad_glDebugMessageCallback
GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKAMDPROC glad_glDebugMessageCallbackAMD;
#define glDebugMessageCallbackAMD glad_glDebugMessageCallbackAMD
GLAD_API_CALL PFNGLDEBUGMESSAGECALLBACKARBPROC glad_glDebugMessageCallbackARB;
#define glDebugMessageCallbackARB glad_glDebugMessageCallbackARB
GLAD_API_CALL PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl;
#define glDebugMessageControl glad_glDebugMessageControl
GLAD_API_CALL PFNGLDEBUGMESSAGECONTROLARBPROC glad_glDebugMessageControlARB;
#define glDebugMessageControlARB glad_glDebugMessageControlARB
GLAD_API_CALL PFNGLDEBUGMESSAGEENABLEAMDPROC glad_glDebugMessageEnableAMD;
#define glDebugMessageEnableAMD glad_glDebugMessageEnableAMD
GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert;
#define glDebugMessageInsert glad_glDebugMessageInsert
GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTAMDPROC glad_glDebugMessageInsertAMD;
#define glDebugMessageInsertAMD glad_glDebugMessageInsertAMD
GLAD_API_CALL PFNGLDEBUGMESSAGEINSERTARBPROC glad_glDebugMessageInsertARB;
#define glDebugMessageInsertARB glad_glDebugMessageInsertARB
GLAD_API_CALL PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;
#define glDeleteBuffers glad_glDeleteBuffers
GLAD_API_CALL PFNGLDELETEBUFFERSARBPROC glad_glDeleteBuffersARB;
#define glDeleteBuffersARB glad_glDeleteBuffersARB
GLAD_API_CALL PFNGLDELETECOMMANDLISTSNVPROC glad_glDeleteCommandListsNV;
#define glDeleteCommandListsNV glad_glDeleteCommandListsNV
GLAD_API_CALL PFNGLDELETEFENCESAPPLEPROC glad_glDeleteFencesAPPLE;
#define glDeleteFencesAPPLE glad_glDeleteFencesAPPLE
GLAD_API_CALL PFNGLDELETEFENCESNVPROC glad_glDeleteFencesNV;
#define glDeleteFencesNV glad_glDeleteFencesNV
GLAD_API_CALL PFNGLDELETEFRAGMENTSHADERATIPROC glad_glDeleteFragmentShaderATI;
#define glDeleteFragmentShaderATI glad_glDeleteFragmentShaderATI
GLAD_API_CALL PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;
#define glDeleteFramebuffers glad_glDeleteFramebuffers
GLAD_API_CALL PFNGLDELETEFRAMEBUFFERSEXTPROC glad_glDeleteFramebuffersEXT;
#define glDeleteFramebuffersEXT glad_glDeleteFramebuffersEXT
GLAD_API_CALL PFNGLDELETEMEMORYOBJECTSEXTPROC glad_glDeleteMemoryObjectsEXT;
#define glDeleteMemoryObjectsEXT glad_glDeleteMemoryObjectsEXT
GLAD_API_CALL PFNGLDELETENAMEDSTRINGARBPROC glad_glDeleteNamedStringARB;
#define glDeleteNamedStringARB glad_glDeleteNamedStringARB
GLAD_API_CALL PFNGLDELETENAMESAMDPROC glad_glDeleteNamesAMD;
#define glDeleteNamesAMD glad_glDeleteNamesAMD
GLAD_API_CALL PFNGLDELETEOBJECTARBPROC glad_glDeleteObjectARB;
#define glDeleteObjectARB glad_glDeleteObjectARB
GLAD_API_CALL PFNGLDELETEOCCLUSIONQUERIESNVPROC glad_glDeleteOcclusionQueriesNV;
#define glDeleteOcclusionQueriesNV glad_glDeleteOcclusionQueriesNV
GLAD_API_CALL PFNGLDELETEPATHSNVPROC glad_glDeletePathsNV;
#define glDeletePathsNV glad_glDeletePathsNV
GLAD_API_CALL PFNGLDELETEPERFMONITORSAMDPROC glad_glDeletePerfMonitorsAMD;
#define glDeletePerfMonitorsAMD glad_glDeletePerfMonitorsAMD
GLAD_API_CALL PFNGLDELETEPERFQUERYINTELPROC glad_glDeletePerfQueryINTEL;
#define glDeletePerfQueryINTEL glad_glDeletePerfQueryINTEL
GLAD_API_CALL PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;
#define glDeleteProgram glad_glDeleteProgram
GLAD_API_CALL PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines;
#define glDeleteProgramPipelines glad_glDeleteProgramPipelines
GLAD_API_CALL PFNGLDELETEPROGRAMSARBPROC glad_glDeleteProgramsARB;
#define glDeleteProgramsARB glad_glDeleteProgramsARB
GLAD_API_CALL PFNGLDELETEPROGRAMSNVPROC glad_glDeleteProgramsNV;
#define glDeleteProgramsNV glad_glDeleteProgramsNV
GLAD_API_CALL PFNGLDELETEQUERIESPROC glad_glDeleteQueries;
#define glDeleteQueries glad_glDeleteQueries
GLAD_API_CALL PFNGLDELETEQUERIESARBPROC glad_glDeleteQueriesARB;
#define glDeleteQueriesARB glad_glDeleteQueriesARB
GLAD_API_CALL PFNGLDELETEQUERYRESOURCETAGNVPROC glad_glDeleteQueryResourceTagNV;
#define glDeleteQueryResourceTagNV glad_glDeleteQueryResourceTagNV
GLAD_API_CALL PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;
#define glDeleteRenderbuffers glad_glDeleteRenderbuffers
GLAD_API_CALL PFNGLDELETERENDERBUFFERSEXTPROC glad_glDeleteRenderbuffersEXT;
#define glDeleteRenderbuffersEXT glad_glDeleteRenderbuffersEXT
GLAD_API_CALL PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;
#define glDeleteSamplers glad_glDeleteSamplers
GLAD_API_CALL PFNGLDELETESEMAPHORESEXTPROC glad_glDeleteSemaphoresEXT;
#define glDeleteSemaphoresEXT glad_glDeleteSemaphoresEXT
GLAD_API_CALL PFNGLDELETESHADERPROC glad_glDeleteShader;
#define glDeleteShader glad_glDeleteShader
GLAD_API_CALL PFNGLDELETESTATESNVPROC glad_glDeleteStatesNV;
#define glDeleteStatesNV glad_glDeleteStatesNV
GLAD_API_CALL PFNGLDELETESYNCPROC glad_glDeleteSync;
#define glDeleteSync glad_glDeleteSync
GLAD_API_CALL PFNGLDELETETEXTURESPROC glad_glDeleteTextures;
#define glDeleteTextures glad_glDeleteTextures
GLAD_API_CALL PFNGLDELETETEXTURESEXTPROC glad_glDeleteTexturesEXT;
#define glDeleteTexturesEXT glad_glDeleteTexturesEXT
GLAD_API_CALL PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks;
#define glDeleteTransformFeedbacks glad_glDeleteTransformFeedbacks
GLAD_API_CALL PFNGLDELETETRANSFORMFEEDBACKSNVPROC glad_glDeleteTransformFeedbacksNV;
#define glDeleteTransformFeedbacksNV glad_glDeleteTransformFeedbacksNV
GLAD_API_CALL PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;
#define glDeleteVertexArrays glad_glDeleteVertexArrays
GLAD_API_CALL PFNGLDELETEVERTEXARRAYSAPPLEPROC glad_glDeleteVertexArraysAPPLE;
#define glDeleteVertexArraysAPPLE glad_glDeleteVertexArraysAPPLE
GLAD_API_CALL PFNGLDELETEVERTEXSHADEREXTPROC glad_glDeleteVertexShaderEXT;
#define glDeleteVertexShaderEXT glad_glDeleteVertexShaderEXT
GLAD_API_CALL PFNGLDEPTHBOUNDSEXTPROC glad_glDepthBoundsEXT;
#define glDepthBoundsEXT glad_glDepthBoundsEXT
GLAD_API_CALL PFNGLDEPTHBOUNDSDNVPROC glad_glDepthBoundsdNV;
#define glDepthBoundsdNV glad_glDepthBoundsdNV
GLAD_API_CALL PFNGLDEPTHFUNCPROC glad_glDepthFunc;
#define glDepthFunc glad_glDepthFunc
GLAD_API_CALL PFNGLDEPTHMASKPROC glad_glDepthMask;
#define glDepthMask glad_glDepthMask
GLAD_API_CALL PFNGLDEPTHRANGEPROC glad_glDepthRange;
#define glDepthRange glad_glDepthRange
GLAD_API_CALL PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv;
#define glDepthRangeArrayv glad_glDepthRangeArrayv
GLAD_API_CALL PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed;
#define glDepthRangeIndexed glad_glDepthRangeIndexed
GLAD_API_CALL PFNGLDEPTHRANGEDNVPROC glad_glDepthRangedNV;
#define glDepthRangedNV glad_glDepthRangedNV
GLAD_API_CALL PFNGLDEPTHRANGEFPROC glad_glDepthRangef;
#define glDepthRangef glad_glDepthRangef
GLAD_API_CALL PFNGLDETACHOBJECTARBPROC glad_glDetachObjectARB;
#define glDetachObjectARB glad_glDetachObjectARB
GLAD_API_CALL PFNGLDETACHSHADERPROC glad_glDetachShader;
#define glDetachShader glad_glDetachShader
GLAD_API_CALL PFNGLDISABLEPROC glad_glDisable;
#define glDisable glad_glDisable
GLAD_API_CALL PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC glad_glDisableClientStateIndexedEXT;
#define glDisableClientStateIndexedEXT glad_glDisableClientStateIndexedEXT
GLAD_API_CALL PFNGLDISABLECLIENTSTATEIEXTPROC glad_glDisableClientStateiEXT;
#define glDisableClientStateiEXT glad_glDisableClientStateiEXT
GLAD_API_CALL PFNGLDISABLEINDEXEDEXTPROC glad_glDisableIndexedEXT;
#define glDisableIndexedEXT glad_glDisableIndexedEXT
GLAD_API_CALL PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC glad_glDisableVariantClientStateEXT;
#define glDisableVariantClientStateEXT glad_glDisableVariantClientStateEXT
GLAD_API_CALL PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib;
#define glDisableVertexArrayAttrib glad_glDisableVertexArrayAttrib
GLAD_API_CALL PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC glad_glDisableVertexArrayAttribEXT;
#define glDisableVertexArrayAttribEXT glad_glDisableVertexArrayAttribEXT
GLAD_API_CALL PFNGLDISABLEVERTEXARRAYEXTPROC glad_glDisableVertexArrayEXT;
#define glDisableVertexArrayEXT glad_glDisableVertexArrayEXT
GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBAPPLEPROC glad_glDisableVertexAttribAPPLE;
#define glDisableVertexAttribAPPLE glad_glDisableVertexAttribAPPLE
GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;
#define glDisableVertexAttribArray glad_glDisableVertexAttribArray
GLAD_API_CALL PFNGLDISABLEVERTEXATTRIBARRAYARBPROC glad_glDisableVertexAttribArrayARB;
#define glDisableVertexAttribArrayARB glad_glDisableVertexAttribArrayARB
GLAD_API_CALL PFNGLDISABLEIPROC glad_glDisablei;
#define glDisablei glad_glDisablei
GLAD_API_CALL PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute;
#define glDispatchCompute glad_glDispatchCompute
GLAD_API_CALL PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC glad_glDispatchComputeGroupSizeARB;
#define glDispatchComputeGroupSizeARB glad_glDispatchComputeGroupSizeARB
GLAD_API_CALL PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect;
#define glDispatchComputeIndirect glad_glDispatchComputeIndirect
GLAD_API_CALL PFNGLDRAWARRAYSPROC glad_glDrawArrays;
#define glDrawArrays glad_glDrawArrays
GLAD_API_CALL PFNGLDRAWARRAYSEXTPROC glad_glDrawArraysEXT;
#define glDrawArraysEXT glad_glDrawArraysEXT
GLAD_API_CALL PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect;
#define glDrawArraysIndirect glad_glDrawArraysIndirect
GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;
#define glDrawArraysInstanced glad_glDrawArraysInstanced
GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDARBPROC glad_glDrawArraysInstancedARB;
#define glDrawArraysInstancedARB glad_glDrawArraysInstancedARB
GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance;
#define glDrawArraysInstancedBaseInstance glad_glDrawArraysInstancedBaseInstance
GLAD_API_CALL PFNGLDRAWARRAYSINSTANCEDEXTPROC glad_glDrawArraysInstancedEXT;
#define glDrawArraysInstancedEXT glad_glDrawArraysInstancedEXT
GLAD_API_CALL PFNGLDRAWBUFFERPROC glad_glDrawBuffer;
#define glDrawBuffer glad_glDrawBuffer
GLAD_API_CALL PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;
#define glDrawBuffers glad_glDrawBuffers
GLAD_API_CALL PFNGLDRAWBUFFERSARBPROC glad_glDrawBuffersARB;
#define glDrawBuffersARB glad_glDrawBuffersARB
GLAD_API_CALL PFNGLDRAWBUFFERSATIPROC glad_glDrawBuffersATI;
#define glDrawBuffersATI glad_glDrawBuffersATI
GLAD_API_CALL PFNGLDRAWCOMMANDSADDRESSNVPROC glad_glDrawCommandsAddressNV;
#define glDrawCommandsAddressNV glad_glDrawCommandsAddressNV
GLAD_API_CALL PFNGLDRAWCOMMANDSNVPROC glad_glDrawCommandsNV;
#define glDrawCommandsNV glad_glDrawCommandsNV
GLAD_API_CALL PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC glad_glDrawCommandsStatesAddressNV;
#define glDrawCommandsStatesAddressNV glad_glDrawCommandsStatesAddressNV
GLAD_API_CALL PFNGLDRAWCOMMANDSSTATESNVPROC glad_glDrawCommandsStatesNV;
#define glDrawCommandsStatesNV glad_glDrawCommandsStatesNV
GLAD_API_CALL PFNGLDRAWELEMENTARRAYAPPLEPROC glad_glDrawElementArrayAPPLE;
#define glDrawElementArrayAPPLE glad_glDrawElementArrayAPPLE
GLAD_API_CALL PFNGLDRAWELEMENTARRAYATIPROC glad_glDrawElementArrayATI;
#define glDrawElementArrayATI glad_glDrawElementArrayATI
GLAD_API_CALL PFNGLDRAWELEMENTSPROC glad_glDrawElements;
#define glDrawElements glad_glDrawElements
GLAD_API_CALL PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;
#define glDrawElementsBaseVertex glad_glDrawElementsBaseVertex
GLAD_API_CALL PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect;
#define glDrawElementsIndirect glad_glDrawElementsIndirect
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;
#define glDrawElementsInstanced glad_glDrawElementsInstanced
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDARBPROC glad_glDrawElementsInstancedARB;
#define glDrawElementsInstancedARB glad_glDrawElementsInstancedARB
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance;
#define glDrawElementsInstancedBaseInstance glad_glDrawElementsInstancedBaseInstance
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;
#define glDrawElementsInstancedBaseVertex glad_glDrawElementsInstancedBaseVertex
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance;
#define glDrawElementsInstancedBaseVertexBaseInstance glad_glDrawElementsInstancedBaseVertexBaseInstance
GLAD_API_CALL PFNGLDRAWELEMENTSINSTANCEDEXTPROC glad_glDrawElementsInstancedEXT;
#define glDrawElementsInstancedEXT glad_glDrawElementsInstancedEXT
GLAD_API_CALL PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC glad_glDrawRangeElementArrayAPPLE;
#define glDrawRangeElementArrayAPPLE glad_glDrawRangeElementArrayAPPLE
GLAD_API_CALL PFNGLDRAWRANGEELEMENTARRAYATIPROC glad_glDrawRangeElementArrayATI;
#define glDrawRangeElementArrayATI glad_glDrawRangeElementArrayATI
GLAD_API_CALL PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;
#define glDrawRangeElements glad_glDrawRangeElements
GLAD_API_CALL PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;
#define glDrawRangeElementsBaseVertex glad_glDrawRangeElementsBaseVertex
GLAD_API_CALL PFNGLDRAWRANGEELEMENTSEXTPROC glad_glDrawRangeElementsEXT;
#define glDrawRangeElementsEXT glad_glDrawRangeElementsEXT
GLAD_API_CALL PFNGLDRAWTEXTURENVPROC glad_glDrawTextureNV;
#define glDrawTextureNV glad_glDrawTextureNV
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback;
#define glDrawTransformFeedback glad_glDrawTransformFeedback
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced;
#define glDrawTransformFeedbackInstanced glad_glDrawTransformFeedbackInstanced
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKNVPROC glad_glDrawTransformFeedbackNV;
#define glDrawTransformFeedbackNV glad_glDrawTransformFeedbackNV
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream;
#define glDrawTransformFeedbackStream glad_glDrawTransformFeedbackStream
GLAD_API_CALL PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced;
#define glDrawTransformFeedbackStreamInstanced glad_glDrawTransformFeedbackStreamInstanced
GLAD_API_CALL PFNGLDRAWVKIMAGENVPROC glad_glDrawVkImageNV;
#define glDrawVkImageNV glad_glDrawVkImageNV
GLAD_API_CALL PFNGLEDGEFLAGFORMATNVPROC glad_glEdgeFlagFormatNV;
#define glEdgeFlagFormatNV glad_glEdgeFlagFormatNV
GLAD_API_CALL PFNGLEDGEFLAGPOINTEREXTPROC glad_glEdgeFlagPointerEXT;
#define glEdgeFlagPointerEXT glad_glEdgeFlagPointerEXT
GLAD_API_CALL PFNGLELEMENTPOINTERAPPLEPROC glad_glElementPointerAPPLE;
#define glElementPointerAPPLE glad_glElementPointerAPPLE
GLAD_API_CALL PFNGLELEMENTPOINTERATIPROC glad_glElementPointerATI;
#define glElementPointerATI glad_glElementPointerATI
GLAD_API_CALL PFNGLENABLEPROC glad_glEnable;
#define glEnable glad_glEnable
GLAD_API_CALL PFNGLENABLECLIENTSTATEINDEXEDEXTPROC glad_glEnableClientStateIndexedEXT;
#define glEnableClientStateIndexedEXT glad_glEnableClientStateIndexedEXT
GLAD_API_CALL PFNGLENABLECLIENTSTATEIEXTPROC glad_glEnableClientStateiEXT;
#define glEnableClientStateiEXT glad_glEnableClientStateiEXT
GLAD_API_CALL PFNGLENABLEINDEXEDEXTPROC glad_glEnableIndexedEXT;
#define glEnableIndexedEXT glad_glEnableIndexedEXT
GLAD_API_CALL PFNGLENABLEVARIANTCLIENTSTATEEXTPROC glad_glEnableVariantClientStateEXT;
#define glEnableVariantClientStateEXT glad_glEnableVariantClientStateEXT
GLAD_API_CALL PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib;
#define glEnableVertexArrayAttrib glad_glEnableVertexArrayAttrib
GLAD_API_CALL PFNGLENABLEVERTEXARRAYATTRIBEXTPROC glad_glEnableVertexArrayAttribEXT;
#define glEnableVertexArrayAttribEXT glad_glEnableVertexArrayAttribEXT
GLAD_API_CALL PFNGLENABLEVERTEXARRAYEXTPROC glad_glEnableVertexArrayEXT;
#define glEnableVertexArrayEXT glad_glEnableVertexArrayEXT
GLAD_API_CALL PFNGLENABLEVERTEXATTRIBAPPLEPROC glad_glEnableVertexAttribAPPLE;
#define glEnableVertexAttribAPPLE glad_glEnableVertexAttribAPPLE
GLAD_API_CALL PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;
#define glEnableVertexAttribArray glad_glEnableVertexAttribArray
GLAD_API_CALL PFNGLENABLEVERTEXATTRIBARRAYARBPROC glad_glEnableVertexAttribArrayARB;
#define glEnableVertexAttribArrayARB glad_glEnableVertexAttribArrayARB
GLAD_API_CALL PFNGLENABLEIPROC glad_glEnablei;
#define glEnablei glad_glEnablei
GLAD_API_CALL PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;
#define glEndConditionalRender glad_glEndConditionalRender
GLAD_API_CALL PFNGLENDCONDITIONALRENDERNVPROC glad_glEndConditionalRenderNV;
#define glEndConditionalRenderNV glad_glEndConditionalRenderNV
GLAD_API_CALL PFNGLENDCONDITIONALRENDERNVXPROC glad_glEndConditionalRenderNVX;
#define glEndConditionalRenderNVX glad_glEndConditionalRenderNVX
GLAD_API_CALL PFNGLENDFRAGMENTSHADERATIPROC glad_glEndFragmentShaderATI;
#define glEndFragmentShaderATI glad_glEndFragmentShaderATI
GLAD_API_CALL PFNGLENDOCCLUSIONQUERYNVPROC glad_glEndOcclusionQueryNV;
#define glEndOcclusionQueryNV glad_glEndOcclusionQueryNV
GLAD_API_CALL PFNGLENDPERFMONITORAMDPROC glad_glEndPerfMonitorAMD;
#define glEndPerfMonitorAMD glad_glEndPerfMonitorAMD
GLAD_API_CALL PFNGLENDPERFQUERYINTELPROC glad_glEndPerfQueryINTEL;
#define glEndPerfQueryINTEL glad_glEndPerfQueryINTEL
GLAD_API_CALL PFNGLENDQUERYPROC glad_glEndQuery;
#define glEndQuery glad_glEndQuery
GLAD_API_CALL PFNGLENDQUERYARBPROC glad_glEndQueryARB;
#define glEndQueryARB glad_glEndQueryARB
GLAD_API_CALL PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed;
#define glEndQueryIndexed glad_glEndQueryIndexed
GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;
#define glEndTransformFeedback glad_glEndTransformFeedback
GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKEXTPROC glad_glEndTransformFeedbackEXT;
#define glEndTransformFeedbackEXT glad_glEndTransformFeedbackEXT
GLAD_API_CALL PFNGLENDTRANSFORMFEEDBACKNVPROC glad_glEndTransformFeedbackNV;
#define glEndTransformFeedbackNV glad_glEndTransformFeedbackNV
GLAD_API_CALL PFNGLENDVERTEXSHADEREXTPROC glad_glEndVertexShaderEXT;
#define glEndVertexShaderEXT glad_glEndVertexShaderEXT
GLAD_API_CALL PFNGLENDVIDEOCAPTURENVPROC glad_glEndVideoCaptureNV;
#define glEndVideoCaptureNV glad_glEndVideoCaptureNV
GLAD_API_CALL PFNGLEVALMAPSNVPROC glad_glEvalMapsNV;
#define glEvalMapsNV glad_glEvalMapsNV
GLAD_API_CALL PFNGLEVALUATEDEPTHVALUESARBPROC glad_glEvaluateDepthValuesARB;
#define glEvaluateDepthValuesARB glad_glEvaluateDepthValuesARB
GLAD_API_CALL PFNGLEXECUTEPROGRAMNVPROC glad_glExecuteProgramNV;
#define glExecuteProgramNV glad_glExecuteProgramNV
GLAD_API_CALL PFNGLEXTRACTCOMPONENTEXTPROC glad_glExtractComponentEXT;
#define glExtractComponentEXT glad_glExtractComponentEXT
GLAD_API_CALL PFNGLFENCESYNCPROC glad_glFenceSync;
#define glFenceSync glad_glFenceSync
GLAD_API_CALL PFNGLFINALCOMBINERINPUTNVPROC glad_glFinalCombinerInputNV;
#define glFinalCombinerInputNV glad_glFinalCombinerInputNV
GLAD_API_CALL PFNGLFINISHPROC glad_glFinish;
#define glFinish glad_glFinish
GLAD_API_CALL PFNGLFINISHFENCEAPPLEPROC glad_glFinishFenceAPPLE;
#define glFinishFenceAPPLE glad_glFinishFenceAPPLE
GLAD_API_CALL PFNGLFINISHFENCENVPROC glad_glFinishFenceNV;
#define glFinishFenceNV glad_glFinishFenceNV
GLAD_API_CALL PFNGLFINISHOBJECTAPPLEPROC glad_glFinishObjectAPPLE;
#define glFinishObjectAPPLE glad_glFinishObjectAPPLE
GLAD_API_CALL PFNGLFLUSHPROC glad_glFlush;
#define glFlush glad_glFlush
GLAD_API_CALL PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;
#define glFlushMappedBufferRange glad_glFlushMappedBufferRange
GLAD_API_CALL PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC glad_glFlushMappedBufferRangeAPPLE;
#define glFlushMappedBufferRangeAPPLE glad_glFlushMappedBufferRangeAPPLE
GLAD_API_CALL PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange;
#define glFlushMappedNamedBufferRange glad_glFlushMappedNamedBufferRange
GLAD_API_CALL PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC glad_glFlushMappedNamedBufferRangeEXT;
#define glFlushMappedNamedBufferRangeEXT glad_glFlushMappedNamedBufferRangeEXT
GLAD_API_CALL PFNGLFLUSHPIXELDATARANGENVPROC glad_glFlushPixelDataRangeNV;
#define glFlushPixelDataRangeNV glad_glFlushPixelDataRangeNV
GLAD_API_CALL PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC glad_glFlushVertexArrayRangeAPPLE;
#define glFlushVertexArrayRangeAPPLE glad_glFlushVertexArrayRangeAPPLE
GLAD_API_CALL PFNGLFLUSHVERTEXARRAYRANGENVPROC glad_glFlushVertexArrayRangeNV;
#define glFlushVertexArrayRangeNV glad_glFlushVertexArrayRangeNV
GLAD_API_CALL PFNGLFOGCOORDFORMATNVPROC glad_glFogCoordFormatNV;
#define glFogCoordFormatNV glad_glFogCoordFormatNV
GLAD_API_CALL PFNGLFOGCOORDPOINTERPROC glad_glFogCoordPointer;
#define glFogCoordPointer glad_glFogCoordPointer
GLAD_API_CALL PFNGLFOGCOORDPOINTEREXTPROC glad_glFogCoordPointerEXT;
#define glFogCoordPointerEXT glad_glFogCoordPointerEXT
GLAD_API_CALL PFNGLFOGCOORDDPROC glad_glFogCoordd;
#define glFogCoordd glad_glFogCoordd
GLAD_API_CALL PFNGLFOGCOORDDEXTPROC glad_glFogCoorddEXT;
#define glFogCoorddEXT glad_glFogCoorddEXT
GLAD_API_CALL PFNGLFOGCOORDDVPROC glad_glFogCoorddv;
#define glFogCoorddv glad_glFogCoorddv
GLAD_API_CALL PFNGLFOGCOORDDVEXTPROC glad_glFogCoorddvEXT;
#define glFogCoorddvEXT glad_glFogCoorddvEXT
GLAD_API_CALL PFNGLFOGCOORDFPROC glad_glFogCoordf;
#define glFogCoordf glad_glFogCoordf
GLAD_API_CALL PFNGLFOGCOORDFEXTPROC glad_glFogCoordfEXT;
#define glFogCoordfEXT glad_glFogCoordfEXT
GLAD_API_CALL PFNGLFOGCOORDFVPROC glad_glFogCoordfv;
#define glFogCoordfv glad_glFogCoordfv
GLAD_API_CALL PFNGLFOGCOORDFVEXTPROC glad_glFogCoordfvEXT;
#define glFogCoordfvEXT glad_glFogCoordfvEXT
GLAD_API_CALL PFNGLFOGCOORDHNVPROC glad_glFogCoordhNV;
#define glFogCoordhNV glad_glFogCoordhNV
GLAD_API_CALL PFNGLFOGCOORDHVNVPROC glad_glFogCoordhvNV;
#define glFogCoordhvNV glad_glFogCoordhvNV
GLAD_API_CALL PFNGLFRAGMENTCOVERAGECOLORNVPROC glad_glFragmentCoverageColorNV;
#define glFragmentCoverageColorNV glad_glFragmentCoverageColorNV
GLAD_API_CALL PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC glad_glFramebufferDrawBufferEXT;
#define glFramebufferDrawBufferEXT glad_glFramebufferDrawBufferEXT
GLAD_API_CALL PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC glad_glFramebufferDrawBuffersEXT;
#define glFramebufferDrawBuffersEXT glad_glFramebufferDrawBuffersEXT
GLAD_API_CALL PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri;
#define glFramebufferParameteri glad_glFramebufferParameteri
GLAD_API_CALL PFNGLFRAMEBUFFERREADBUFFEREXTPROC glad_glFramebufferReadBufferEXT;
#define glFramebufferReadBufferEXT glad_glFramebufferReadBufferEXT
GLAD_API_CALL PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;
#define glFramebufferRenderbuffer glad_glFramebufferRenderbuffer
GLAD_API_CALL PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC glad_glFramebufferRenderbufferEXT;
#define glFramebufferRenderbufferEXT glad_glFramebufferRenderbufferEXT
GLAD_API_CALL PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glad_glFramebufferSampleLocationsfvARB;
#define glFramebufferSampleLocationsfvARB glad_glFramebufferSampleLocationsfvARB
GLAD_API_CALL PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glFramebufferSampleLocationsfvNV;
#define glFramebufferSampleLocationsfvNV glad_glFramebufferSampleLocationsfvNV
GLAD_API_CALL PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC glad_glFramebufferSamplePositionsfvAMD;
#define glFramebufferSamplePositionsfvAMD glad_glFramebufferSamplePositionsfvAMD
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;
#define glFramebufferTexture glad_glFramebufferTexture
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;
#define glFramebufferTexture1D glad_glFramebufferTexture1D
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE1DEXTPROC glad_glFramebufferTexture1DEXT;
#define glFramebufferTexture1DEXT glad_glFramebufferTexture1DEXT
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;
#define glFramebufferTexture2D glad_glFramebufferTexture2D
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE2DEXTPROC glad_glFramebufferTexture2DEXT;
#define glFramebufferTexture2DEXT glad_glFramebufferTexture2DEXT
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;
#define glFramebufferTexture3D glad_glFramebufferTexture3D
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURE3DEXTPROC glad_glFramebufferTexture3DEXT;
#define glFramebufferTexture3DEXT glad_glFramebufferTexture3DEXT
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREARBPROC glad_glFramebufferTextureARB;
#define glFramebufferTextureARB glad_glFramebufferTextureARB
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREEXTPROC glad_glFramebufferTextureEXT;
#define glFramebufferTextureEXT glad_glFramebufferTextureEXT
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREFACEARBPROC glad_glFramebufferTextureFaceARB;
#define glFramebufferTextureFaceARB glad_glFramebufferTextureFaceARB
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC glad_glFramebufferTextureFaceEXT;
#define glFramebufferTextureFaceEXT glad_glFramebufferTextureFaceEXT
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;
#define glFramebufferTextureLayer glad_glFramebufferTextureLayer
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYERARBPROC glad_glFramebufferTextureLayerARB;
#define glFramebufferTextureLayerARB glad_glFramebufferTextureLayerARB
GLAD_API_CALL PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC glad_glFramebufferTextureLayerEXT;
#define glFramebufferTextureLayerEXT glad_glFramebufferTextureLayerEXT
GLAD_API_CALL PFNGLFREEOBJECTBUFFERATIPROC glad_glFreeObjectBufferATI;
#define glFreeObjectBufferATI glad_glFreeObjectBufferATI
GLAD_API_CALL PFNGLFRONTFACEPROC glad_glFrontFace;
#define glFrontFace glad_glFrontFace
GLAD_API_CALL PFNGLGENBUFFERSPROC glad_glGenBuffers;
#define glGenBuffers glad_glGenBuffers
GLAD_API_CALL PFNGLGENBUFFERSARBPROC glad_glGenBuffersARB;
#define glGenBuffersARB glad_glGenBuffersARB
GLAD_API_CALL PFNGLGENFENCESAPPLEPROC glad_glGenFencesAPPLE;
#define glGenFencesAPPLE glad_glGenFencesAPPLE
GLAD_API_CALL PFNGLGENFENCESNVPROC glad_glGenFencesNV;
#define glGenFencesNV glad_glGenFencesNV
GLAD_API_CALL PFNGLGENFRAGMENTSHADERSATIPROC glad_glGenFragmentShadersATI;
#define glGenFragmentShadersATI glad_glGenFragmentShadersATI
GLAD_API_CALL PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;
#define glGenFramebuffers glad_glGenFramebuffers
GLAD_API_CALL PFNGLGENFRAMEBUFFERSEXTPROC glad_glGenFramebuffersEXT;
#define glGenFramebuffersEXT glad_glGenFramebuffersEXT
GLAD_API_CALL PFNGLGENNAMESAMDPROC glad_glGenNamesAMD;
#define glGenNamesAMD glad_glGenNamesAMD
GLAD_API_CALL PFNGLGENOCCLUSIONQUERIESNVPROC glad_glGenOcclusionQueriesNV;
#define glGenOcclusionQueriesNV glad_glGenOcclusionQueriesNV
GLAD_API_CALL PFNGLGENPATHSNVPROC glad_glGenPathsNV;
#define glGenPathsNV glad_glGenPathsNV
GLAD_API_CALL PFNGLGENPERFMONITORSAMDPROC glad_glGenPerfMonitorsAMD;
#define glGenPerfMonitorsAMD glad_glGenPerfMonitorsAMD
GLAD_API_CALL PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines;
#define glGenProgramPipelines glad_glGenProgramPipelines
GLAD_API_CALL PFNGLGENPROGRAMSARBPROC glad_glGenProgramsARB;
#define glGenProgramsARB glad_glGenProgramsARB
GLAD_API_CALL PFNGLGENPROGRAMSNVPROC glad_glGenProgramsNV;
#define glGenProgramsNV glad_glGenProgramsNV
GLAD_API_CALL PFNGLGENQUERIESPROC glad_glGenQueries;
#define glGenQueries glad_glGenQueries
GLAD_API_CALL PFNGLGENQUERIESARBPROC glad_glGenQueriesARB;
#define glGenQueriesARB glad_glGenQueriesARB
GLAD_API_CALL PFNGLGENQUERYRESOURCETAGNVPROC glad_glGenQueryResourceTagNV;
#define glGenQueryResourceTagNV glad_glGenQueryResourceTagNV
GLAD_API_CALL PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;
#define glGenRenderbuffers glad_glGenRenderbuffers
GLAD_API_CALL PFNGLGENRENDERBUFFERSEXTPROC glad_glGenRenderbuffersEXT;
#define glGenRenderbuffersEXT glad_glGenRenderbuffersEXT
GLAD_API_CALL PFNGLGENSAMPLERSPROC glad_glGenSamplers;
#define glGenSamplers glad_glGenSamplers
GLAD_API_CALL PFNGLGENSEMAPHORESEXTPROC glad_glGenSemaphoresEXT;
#define glGenSemaphoresEXT glad_glGenSemaphoresEXT
GLAD_API_CALL PFNGLGENSYMBOLSEXTPROC glad_glGenSymbolsEXT;
#define glGenSymbolsEXT glad_glGenSymbolsEXT
GLAD_API_CALL PFNGLGENTEXTURESPROC glad_glGenTextures;
#define glGenTextures glad_glGenTextures
GLAD_API_CALL PFNGLGENTEXTURESEXTPROC glad_glGenTexturesEXT;
#define glGenTexturesEXT glad_glGenTexturesEXT
GLAD_API_CALL PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks;
#define glGenTransformFeedbacks glad_glGenTransformFeedbacks
GLAD_API_CALL PFNGLGENTRANSFORMFEEDBACKSNVPROC glad_glGenTransformFeedbacksNV;
#define glGenTransformFeedbacksNV glad_glGenTransformFeedbacksNV
GLAD_API_CALL PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;
#define glGenVertexArrays glad_glGenVertexArrays
GLAD_API_CALL PFNGLGENVERTEXARRAYSAPPLEPROC glad_glGenVertexArraysAPPLE;
#define glGenVertexArraysAPPLE glad_glGenVertexArraysAPPLE
GLAD_API_CALL PFNGLGENVERTEXSHADERSEXTPROC glad_glGenVertexShadersEXT;
#define glGenVertexShadersEXT glad_glGenVertexShadersEXT
GLAD_API_CALL PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;
#define glGenerateMipmap glad_glGenerateMipmap
GLAD_API_CALL PFNGLGENERATEMIPMAPEXTPROC glad_glGenerateMipmapEXT;
#define glGenerateMipmapEXT glad_glGenerateMipmapEXT
GLAD_API_CALL PFNGLGENERATEMULTITEXMIPMAPEXTPROC glad_glGenerateMultiTexMipmapEXT;
#define glGenerateMultiTexMipmapEXT glad_glGenerateMultiTexMipmapEXT
GLAD_API_CALL PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap;
#define glGenerateTextureMipmap glad_glGenerateTextureMipmap
GLAD_API_CALL PFNGLGENERATETEXTUREMIPMAPEXTPROC glad_glGenerateTextureMipmapEXT;
#define glGenerateTextureMipmapEXT glad_glGenerateTextureMipmapEXT
GLAD_API_CALL PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv;
#define glGetActiveAtomicCounterBufferiv glad_glGetActiveAtomicCounterBufferiv
GLAD_API_CALL PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;
#define glGetActiveAttrib glad_glGetActiveAttrib
GLAD_API_CALL PFNGLGETACTIVEATTRIBARBPROC glad_glGetActiveAttribARB;
#define glGetActiveAttribARB glad_glGetActiveAttribARB
GLAD_API_CALL PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName;
#define glGetActiveSubroutineName glad_glGetActiveSubroutineName
GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName;
#define glGetActiveSubroutineUniformName glad_glGetActiveSubroutineUniformName
GLAD_API_CALL PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv;
#define glGetActiveSubroutineUniformiv glad_glGetActiveSubroutineUniformiv
GLAD_API_CALL PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;
#define glGetActiveUniform glad_glGetActiveUniform
GLAD_API_CALL PFNGLGETACTIVEUNIFORMARBPROC glad_glGetActiveUniformARB;
#define glGetActiveUniformARB glad_glGetActiveUniformARB
GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;
#define glGetActiveUniformBlockName glad_glGetActiveUniformBlockName
GLAD_API_CALL PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;
#define glGetActiveUniformBlockiv glad_glGetActiveUniformBlockiv
GLAD_API_CALL PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;
#define glGetActiveUniformName glad_glGetActiveUniformName
GLAD_API_CALL PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;
#define glGetActiveUniformsiv glad_glGetActiveUniformsiv
GLAD_API_CALL PFNGLGETACTIVEVARYINGNVPROC glad_glGetActiveVaryingNV;
#define glGetActiveVaryingNV glad_glGetActiveVaryingNV
GLAD_API_CALL PFNGLGETARRAYOBJECTFVATIPROC glad_glGetArrayObjectfvATI;
#define glGetArrayObjectfvATI glad_glGetArrayObjectfvATI
GLAD_API_CALL PFNGLGETARRAYOBJECTIVATIPROC glad_glGetArrayObjectivATI;
#define glGetArrayObjectivATI glad_glGetArrayObjectivATI
GLAD_API_CALL PFNGLGETATTACHEDOBJECTSARBPROC glad_glGetAttachedObjectsARB;
#define glGetAttachedObjectsARB glad_glGetAttachedObjectsARB
GLAD_API_CALL PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;
#define glGetAttachedShaders glad_glGetAttachedShaders
GLAD_API_CALL PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;
#define glGetAttribLocation glad_glGetAttribLocation
GLAD_API_CALL PFNGLGETATTRIBLOCATIONARBPROC glad_glGetAttribLocationARB;
#define glGetAttribLocationARB glad_glGetAttribLocationARB
GLAD_API_CALL PFNGLGETBOOLEANINDEXEDVEXTPROC glad_glGetBooleanIndexedvEXT;
#define glGetBooleanIndexedvEXT glad_glGetBooleanIndexedvEXT
GLAD_API_CALL PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;
#define glGetBooleani_v glad_glGetBooleani_v
GLAD_API_CALL PFNGLGETBOOLEANVPROC glad_glGetBooleanv;
#define glGetBooleanv glad_glGetBooleanv
GLAD_API_CALL PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;
#define glGetBufferParameteri64v glad_glGetBufferParameteri64v
GLAD_API_CALL PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;
#define glGetBufferParameteriv glad_glGetBufferParameteriv
GLAD_API_CALL PFNGLGETBUFFERPARAMETERIVARBPROC glad_glGetBufferParameterivARB;
#define glGetBufferParameterivARB glad_glGetBufferParameterivARB
GLAD_API_CALL PFNGLGETBUFFERPARAMETERUI64VNVPROC glad_glGetBufferParameterui64vNV;
#define glGetBufferParameterui64vNV glad_glGetBufferParameterui64vNV
GLAD_API_CALL PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;
#define glGetBufferPointerv glad_glGetBufferPointerv
GLAD_API_CALL PFNGLGETBUFFERPOINTERVARBPROC glad_glGetBufferPointervARB;
#define glGetBufferPointervARB glad_glGetBufferPointervARB
GLAD_API_CALL PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;
#define glGetBufferSubData glad_glGetBufferSubData
GLAD_API_CALL PFNGLGETBUFFERSUBDATAARBPROC glad_glGetBufferSubDataARB;
#define glGetBufferSubDataARB glad_glGetBufferSubDataARB
GLAD_API_CALL PFNGLGETCOLORTABLEPROC glad_glGetColorTable;
#define glGetColorTable glad_glGetColorTable
GLAD_API_CALL PFNGLGETCOLORTABLEEXTPROC glad_glGetColorTableEXT;
#define glGetColorTableEXT glad_glGetColorTableEXT
GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERFVPROC glad_glGetColorTableParameterfv;
#define glGetColorTableParameterfv glad_glGetColorTableParameterfv
GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERFVEXTPROC glad_glGetColorTableParameterfvEXT;
#define glGetColorTableParameterfvEXT glad_glGetColorTableParameterfvEXT
GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERIVPROC glad_glGetColorTableParameteriv;
#define glGetColorTableParameteriv glad_glGetColorTableParameteriv
GLAD_API_CALL PFNGLGETCOLORTABLEPARAMETERIVEXTPROC glad_glGetColorTableParameterivEXT;
#define glGetColorTableParameterivEXT glad_glGetColorTableParameterivEXT
GLAD_API_CALL PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC glad_glGetCombinerInputParameterfvNV;
#define glGetCombinerInputParameterfvNV glad_glGetCombinerInputParameterfvNV
GLAD_API_CALL PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC glad_glGetCombinerInputParameterivNV;
#define glGetCombinerInputParameterivNV glad_glGetCombinerInputParameterivNV
GLAD_API_CALL PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC glad_glGetCombinerOutputParameterfvNV;
#define glGetCombinerOutputParameterfvNV glad_glGetCombinerOutputParameterfvNV
GLAD_API_CALL PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC glad_glGetCombinerOutputParameterivNV;
#define glGetCombinerOutputParameterivNV glad_glGetCombinerOutputParameterivNV
GLAD_API_CALL PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC glad_glGetCombinerStageParameterfvNV;
#define glGetCombinerStageParameterfvNV glad_glGetCombinerStageParameterfvNV
GLAD_API_CALL PFNGLGETCOMMANDHEADERNVPROC glad_glGetCommandHeaderNV;
#define glGetCommandHeaderNV glad_glGetCommandHeaderNV
GLAD_API_CALL PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC glad_glGetCompressedMultiTexImageEXT;
#define glGetCompressedMultiTexImageEXT glad_glGetCompressedMultiTexImageEXT
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;
#define glGetCompressedTexImage glad_glGetCompressedTexImage
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXIMAGEARBPROC glad_glGetCompressedTexImageARB;
#define glGetCompressedTexImageARB glad_glGetCompressedTexImageARB
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage;
#define glGetCompressedTextureImage glad_glGetCompressedTextureImage
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC glad_glGetCompressedTextureImageEXT;
#define glGetCompressedTextureImageEXT glad_glGetCompressedTextureImageEXT
GLAD_API_CALL PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage;
#define glGetCompressedTextureSubImage glad_glGetCompressedTextureSubImage
GLAD_API_CALL PFNGLGETCONVOLUTIONFILTEREXTPROC glad_glGetConvolutionFilterEXT;
#define glGetConvolutionFilterEXT glad_glGetConvolutionFilterEXT
GLAD_API_CALL PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC glad_glGetConvolutionParameterfvEXT;
#define glGetConvolutionParameterfvEXT glad_glGetConvolutionParameterfvEXT
GLAD_API_CALL PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC glad_glGetConvolutionParameterivEXT;
#define glGetConvolutionParameterivEXT glad_glGetConvolutionParameterivEXT
GLAD_API_CALL PFNGLGETCOVERAGEMODULATIONTABLENVPROC glad_glGetCoverageModulationTableNV;
#define glGetCoverageModulationTableNV glad_glGetCoverageModulationTableNV
GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog;
#define glGetDebugMessageLog glad_glGetDebugMessageLog
GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGAMDPROC glad_glGetDebugMessageLogAMD;
#define glGetDebugMessageLogAMD glad_glGetDebugMessageLogAMD
GLAD_API_CALL PFNGLGETDEBUGMESSAGELOGARBPROC glad_glGetDebugMessageLogARB;
#define glGetDebugMessageLogARB glad_glGetDebugMessageLogARB
GLAD_API_CALL PFNGLGETDOUBLEINDEXEDVEXTPROC glad_glGetDoubleIndexedvEXT;
#define glGetDoubleIndexedvEXT glad_glGetDoubleIndexedvEXT
GLAD_API_CALL PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v;
#define glGetDoublei_v glad_glGetDoublei_v
GLAD_API_CALL PFNGLGETDOUBLEI_VEXTPROC glad_glGetDoublei_vEXT;
#define glGetDoublei_vEXT glad_glGetDoublei_vEXT
GLAD_API_CALL PFNGLGETDOUBLEVPROC glad_glGetDoublev;
#define glGetDoublev glad_glGetDoublev
GLAD_API_CALL PFNGLGETERRORPROC glad_glGetError;
#define glGetError glad_glGetError
GLAD_API_CALL PFNGLGETFENCEIVNVPROC glad_glGetFenceivNV;
#define glGetFenceivNV glad_glGetFenceivNV
GLAD_API_CALL PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC glad_glGetFinalCombinerInputParameterfvNV;
#define glGetFinalCombinerInputParameterfvNV glad_glGetFinalCombinerInputParameterfvNV
GLAD_API_CALL PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC glad_glGetFinalCombinerInputParameterivNV;
#define glGetFinalCombinerInputParameterivNV glad_glGetFinalCombinerInputParameterivNV
GLAD_API_CALL PFNGLGETFIRSTPERFQUERYIDINTELPROC glad_glGetFirstPerfQueryIdINTEL;
#define glGetFirstPerfQueryIdINTEL glad_glGetFirstPerfQueryIdINTEL
GLAD_API_CALL PFNGLGETFLOATINDEXEDVEXTPROC glad_glGetFloatIndexedvEXT;
#define glGetFloatIndexedvEXT glad_glGetFloatIndexedvEXT
GLAD_API_CALL PFNGLGETFLOATI_VPROC glad_glGetFloati_v;
#define glGetFloati_v glad_glGetFloati_v
GLAD_API_CALL PFNGLGETFLOATI_VEXTPROC glad_glGetFloati_vEXT;
#define glGetFloati_vEXT glad_glGetFloati_vEXT
GLAD_API_CALL PFNGLGETFLOATVPROC glad_glGetFloatv;
#define glGetFloatv glad_glGetFloatv
GLAD_API_CALL PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;
#define glGetFragDataIndex glad_glGetFragDataIndex
GLAD_API_CALL PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;
#define glGetFragDataLocation glad_glGetFragDataLocation
GLAD_API_CALL PFNGLGETFRAGDATALOCATIONEXTPROC glad_glGetFragDataLocationEXT;
#define glGetFragDataLocationEXT glad_glGetFragDataLocationEXT
GLAD_API_CALL PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;
#define glGetFramebufferAttachmentParameteriv glad_glGetFramebufferAttachmentParameteriv
GLAD_API_CALL PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC glad_glGetFramebufferAttachmentParameterivEXT;
#define glGetFramebufferAttachmentParameterivEXT glad_glGetFramebufferAttachmentParameterivEXT
GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC glad_glGetFramebufferParameterfvAMD;
#define glGetFramebufferParameterfvAMD glad_glGetFramebufferParameterfvAMD
GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv;
#define glGetFramebufferParameteriv glad_glGetFramebufferParameteriv
GLAD_API_CALL PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC glad_glGetFramebufferParameterivEXT;
#define glGetFramebufferParameterivEXT glad_glGetFramebufferParameterivEXT
GLAD_API_CALL PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus;
#define glGetGraphicsResetStatus glad_glGetGraphicsResetStatus
GLAD_API_CALL PFNGLGETGRAPHICSRESETSTATUSARBPROC glad_glGetGraphicsResetStatusARB;
#define glGetGraphicsResetStatusARB glad_glGetGraphicsResetStatusARB
GLAD_API_CALL PFNGLGETHANDLEARBPROC glad_glGetHandleARB;
#define glGetHandleARB glad_glGetHandleARB
GLAD_API_CALL PFNGLGETHISTOGRAMEXTPROC glad_glGetHistogramEXT;
#define glGetHistogramEXT glad_glGetHistogramEXT
GLAD_API_CALL PFNGLGETHISTOGRAMPARAMETERFVEXTPROC glad_glGetHistogramParameterfvEXT;
#define glGetHistogramParameterfvEXT glad_glGetHistogramParameterfvEXT
GLAD_API_CALL PFNGLGETHISTOGRAMPARAMETERIVEXTPROC glad_glGetHistogramParameterivEXT;
#define glGetHistogramParameterivEXT glad_glGetHistogramParameterivEXT
GLAD_API_CALL PFNGLGETIMAGEHANDLEARBPROC glad_glGetImageHandleARB;
#define glGetImageHandleARB glad_glGetImageHandleARB
GLAD_API_CALL PFNGLGETIMAGEHANDLENVPROC glad_glGetImageHandleNV;
#define glGetImageHandleNV glad_glGetImageHandleNV
GLAD_API_CALL PFNGLGETINFOLOGARBPROC glad_glGetInfoLogARB;
#define glGetInfoLogARB glad_glGetInfoLogARB
GLAD_API_CALL PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;
#define glGetInteger64i_v glad_glGetInteger64i_v
GLAD_API_CALL PFNGLGETINTEGER64VPROC glad_glGetInteger64v;
#define glGetInteger64v glad_glGetInteger64v
GLAD_API_CALL PFNGLGETINTEGERINDEXEDVEXTPROC glad_glGetIntegerIndexedvEXT;
#define glGetIntegerIndexedvEXT glad_glGetIntegerIndexedvEXT
GLAD_API_CALL PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;
#define glGetIntegeri_v glad_glGetIntegeri_v
GLAD_API_CALL PFNGLGETINTEGERUI64I_VNVPROC glad_glGetIntegerui64i_vNV;
#define glGetIntegerui64i_vNV glad_glGetIntegerui64i_vNV
GLAD_API_CALL PFNGLGETINTEGERUI64VNVPROC glad_glGetIntegerui64vNV;
#define glGetIntegerui64vNV glad_glGetIntegerui64vNV
GLAD_API_CALL PFNGLGETINTEGERVPROC glad_glGetIntegerv;
#define glGetIntegerv glad_glGetIntegerv
GLAD_API_CALL PFNGLGETINTERNALFORMATSAMPLEIVNVPROC glad_glGetInternalformatSampleivNV;
#define glGetInternalformatSampleivNV glad_glGetInternalformatSampleivNV
GLAD_API_CALL PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v;
#define glGetInternalformati64v glad_glGetInternalformati64v
GLAD_API_CALL PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ;
#define glGetInternalformativ glad_glGetInternalformativ
GLAD_API_CALL PFNGLGETINVARIANTBOOLEANVEXTPROC glad_glGetInvariantBooleanvEXT;
#define glGetInvariantBooleanvEXT glad_glGetInvariantBooleanvEXT
GLAD_API_CALL PFNGLGETINVARIANTFLOATVEXTPROC glad_glGetInvariantFloatvEXT;
#define glGetInvariantFloatvEXT glad_glGetInvariantFloatvEXT
GLAD_API_CALL PFNGLGETINVARIANTINTEGERVEXTPROC glad_glGetInvariantIntegervEXT;
#define glGetInvariantIntegervEXT glad_glGetInvariantIntegervEXT
GLAD_API_CALL PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC glad_glGetLocalConstantBooleanvEXT;
#define glGetLocalConstantBooleanvEXT glad_glGetLocalConstantBooleanvEXT
GLAD_API_CALL PFNGLGETLOCALCONSTANTFLOATVEXTPROC glad_glGetLocalConstantFloatvEXT;
#define glGetLocalConstantFloatvEXT glad_glGetLocalConstantFloatvEXT
GLAD_API_CALL PFNGLGETLOCALCONSTANTINTEGERVEXTPROC glad_glGetLocalConstantIntegervEXT;
#define glGetLocalConstantIntegervEXT glad_glGetLocalConstantIntegervEXT
GLAD_API_CALL PFNGLGETMAPATTRIBPARAMETERFVNVPROC glad_glGetMapAttribParameterfvNV;
#define glGetMapAttribParameterfvNV glad_glGetMapAttribParameterfvNV
GLAD_API_CALL PFNGLGETMAPATTRIBPARAMETERIVNVPROC glad_glGetMapAttribParameterivNV;
#define glGetMapAttribParameterivNV glad_glGetMapAttribParameterivNV
GLAD_API_CALL PFNGLGETMAPCONTROLPOINTSNVPROC glad_glGetMapControlPointsNV;
#define glGetMapControlPointsNV glad_glGetMapControlPointsNV
GLAD_API_CALL PFNGLGETMAPPARAMETERFVNVPROC glad_glGetMapParameterfvNV;
#define glGetMapParameterfvNV glad_glGetMapParameterfvNV
GLAD_API_CALL PFNGLGETMAPPARAMETERIVNVPROC glad_glGetMapParameterivNV;
#define glGetMapParameterivNV glad_glGetMapParameterivNV
GLAD_API_CALL PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC glad_glGetMemoryObjectParameterivEXT;
#define glGetMemoryObjectParameterivEXT glad_glGetMemoryObjectParameterivEXT
GLAD_API_CALL PFNGLGETMINMAXEXTPROC glad_glGetMinmaxEXT;
#define glGetMinmaxEXT glad_glGetMinmaxEXT
GLAD_API_CALL PFNGLGETMINMAXPARAMETERFVEXTPROC glad_glGetMinmaxParameterfvEXT;
#define glGetMinmaxParameterfvEXT glad_glGetMinmaxParameterfvEXT
GLAD_API_CALL PFNGLGETMINMAXPARAMETERIVEXTPROC glad_glGetMinmaxParameterivEXT;
#define glGetMinmaxParameterivEXT glad_glGetMinmaxParameterivEXT
GLAD_API_CALL PFNGLGETMULTITEXENVFVEXTPROC glad_glGetMultiTexEnvfvEXT;
#define glGetMultiTexEnvfvEXT glad_glGetMultiTexEnvfvEXT
GLAD_API_CALL PFNGLGETMULTITEXENVIVEXTPROC glad_glGetMultiTexEnvivEXT;
#define glGetMultiTexEnvivEXT glad_glGetMultiTexEnvivEXT
GLAD_API_CALL PFNGLGETMULTITEXGENDVEXTPROC glad_glGetMultiTexGendvEXT;
#define glGetMultiTexGendvEXT glad_glGetMultiTexGendvEXT
GLAD_API_CALL PFNGLGETMULTITEXGENFVEXTPROC glad_glGetMultiTexGenfvEXT;
#define glGetMultiTexGenfvEXT glad_glGetMultiTexGenfvEXT
GLAD_API_CALL PFNGLGETMULTITEXGENIVEXTPROC glad_glGetMultiTexGenivEXT;
#define glGetMultiTexGenivEXT glad_glGetMultiTexGenivEXT
GLAD_API_CALL PFNGLGETMULTITEXIMAGEEXTPROC glad_glGetMultiTexImageEXT;
#define glGetMultiTexImageEXT glad_glGetMultiTexImageEXT
GLAD_API_CALL PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC glad_glGetMultiTexLevelParameterfvEXT;
#define glGetMultiTexLevelParameterfvEXT glad_glGetMultiTexLevelParameterfvEXT
GLAD_API_CALL PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC glad_glGetMultiTexLevelParameterivEXT;
#define glGetMultiTexLevelParameterivEXT glad_glGetMultiTexLevelParameterivEXT
GLAD_API_CALL PFNGLGETMULTITEXPARAMETERIIVEXTPROC glad_glGetMultiTexParameterIivEXT;
#define glGetMultiTexParameterIivEXT glad_glGetMultiTexParameterIivEXT
GLAD_API_CALL PFNGLGETMULTITEXPARAMETERIUIVEXTPROC glad_glGetMultiTexParameterIuivEXT;
#define glGetMultiTexParameterIuivEXT glad_glGetMultiTexParameterIuivEXT
GLAD_API_CALL PFNGLGETMULTITEXPARAMETERFVEXTPROC glad_glGetMultiTexParameterfvEXT;
#define glGetMultiTexParameterfvEXT glad_glGetMultiTexParameterfvEXT
GLAD_API_CALL PFNGLGETMULTITEXPARAMETERIVEXTPROC glad_glGetMultiTexParameterivEXT;
#define glGetMultiTexParameterivEXT glad_glGetMultiTexParameterivEXT
GLAD_API_CALL PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;
#define glGetMultisamplefv glad_glGetMultisamplefv
GLAD_API_CALL PFNGLGETMULTISAMPLEFVNVPROC glad_glGetMultisamplefvNV;
#define glGetMultisamplefvNV glad_glGetMultisamplefvNV
GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v;
#define glGetNamedBufferParameteri64v glad_glGetNamedBufferParameteri64v
GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv;
#define glGetNamedBufferParameteriv glad_glGetNamedBufferParameteriv
GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC glad_glGetNamedBufferParameterivEXT;
#define glGetNamedBufferParameterivEXT glad_glGetNamedBufferParameterivEXT
GLAD_API_CALL PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC glad_glGetNamedBufferParameterui64vNV;
#define glGetNamedBufferParameterui64vNV glad_glGetNamedBufferParameterui64vNV
GLAD_API_CALL PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv;
#define glGetNamedBufferPointerv glad_glGetNamedBufferPointerv
GLAD_API_CALL PFNGLGETNAMEDBUFFERPOINTERVEXTPROC glad_glGetNamedBufferPointervEXT;
#define glGetNamedBufferPointervEXT glad_glGetNamedBufferPointervEXT
GLAD_API_CALL PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData;
#define glGetNamedBufferSubData glad_glGetNamedBufferSubData
GLAD_API_CALL PFNGLGETNAMEDBUFFERSUBDATAEXTPROC glad_glGetNamedBufferSubDataEXT;
#define glGetNamedBufferSubDataEXT glad_glGetNamedBufferSubDataEXT
GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv;
#define glGetNamedFramebufferAttachmentParameteriv glad_glGetNamedFramebufferAttachmentParameteriv
GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC glad_glGetNamedFramebufferAttachmentParameterivEXT;
#define glGetNamedFramebufferAttachmentParameterivEXT glad_glGetNamedFramebufferAttachmentParameterivEXT
GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC glad_glGetNamedFramebufferParameterfvAMD;
#define glGetNamedFramebufferParameterfvAMD glad_glGetNamedFramebufferParameterfvAMD
GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv;
#define glGetNamedFramebufferParameteriv glad_glGetNamedFramebufferParameteriv
GLAD_API_CALL PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC glad_glGetNamedFramebufferParameterivEXT;
#define glGetNamedFramebufferParameterivEXT glad_glGetNamedFramebufferParameterivEXT
GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC glad_glGetNamedProgramLocalParameterIivEXT;
#define glGetNamedProgramLocalParameterIivEXT glad_glGetNamedProgramLocalParameterIivEXT
GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC glad_glGetNamedProgramLocalParameterIuivEXT;
#define glGetNamedProgramLocalParameterIuivEXT glad_glGetNamedProgramLocalParameterIuivEXT
GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC glad_glGetNamedProgramLocalParameterdvEXT;
#define glGetNamedProgramLocalParameterdvEXT glad_glGetNamedProgramLocalParameterdvEXT
GLAD_API_CALL PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC glad_glGetNamedProgramLocalParameterfvEXT;
#define glGetNamedProgramLocalParameterfvEXT glad_glGetNamedProgramLocalParameterfvEXT
GLAD_API_CALL PFNGLGETNAMEDPROGRAMSTRINGEXTPROC glad_glGetNamedProgramStringEXT;
#define glGetNamedProgramStringEXT glad_glGetNamedProgramStringEXT
GLAD_API_CALL PFNGLGETNAMEDPROGRAMIVEXTPROC glad_glGetNamedProgramivEXT;
#define glGetNamedProgramivEXT glad_glGetNamedProgramivEXT
GLAD_API_CALL PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv;
#define glGetNamedRenderbufferParameteriv glad_glGetNamedRenderbufferParameteriv
GLAD_API_CALL PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC glad_glGetNamedRenderbufferParameterivEXT;
#define glGetNamedRenderbufferParameterivEXT glad_glGetNamedRenderbufferParameterivEXT
GLAD_API_CALL PFNGLGETNAMEDSTRINGARBPROC glad_glGetNamedStringARB;
#define glGetNamedStringARB glad_glGetNamedStringARB
GLAD_API_CALL PFNGLGETNAMEDSTRINGIVARBPROC glad_glGetNamedStringivARB;
#define glGetNamedStringivARB glad_glGetNamedStringivARB
GLAD_API_CALL PFNGLGETNEXTPERFQUERYIDINTELPROC glad_glGetNextPerfQueryIdINTEL;
#define glGetNextPerfQueryIdINTEL glad_glGetNextPerfQueryIdINTEL
GLAD_API_CALL PFNGLGETOBJECTBUFFERFVATIPROC glad_glGetObjectBufferfvATI;
#define glGetObjectBufferfvATI glad_glGetObjectBufferfvATI
GLAD_API_CALL PFNGLGETOBJECTBUFFERIVATIPROC glad_glGetObjectBufferivATI;
#define glGetObjectBufferivATI glad_glGetObjectBufferivATI
GLAD_API_CALL PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel;
#define glGetObjectLabel glad_glGetObjectLabel
GLAD_API_CALL PFNGLGETOBJECTLABELEXTPROC glad_glGetObjectLabelEXT;
#define glGetObjectLabelEXT glad_glGetObjectLabelEXT
GLAD_API_CALL PFNGLGETOBJECTPARAMETERFVARBPROC glad_glGetObjectParameterfvARB;
#define glGetObjectParameterfvARB glad_glGetObjectParameterfvARB
GLAD_API_CALL PFNGLGETOBJECTPARAMETERIVAPPLEPROC glad_glGetObjectParameterivAPPLE;
#define glGetObjectParameterivAPPLE glad_glGetObjectParameterivAPPLE
GLAD_API_CALL PFNGLGETOBJECTPARAMETERIVARBPROC glad_glGetObjectParameterivARB;
#define glGetObjectParameterivARB glad_glGetObjectParameterivARB
GLAD_API_CALL PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel;
#define glGetObjectPtrLabel glad_glGetObjectPtrLabel
GLAD_API_CALL PFNGLGETOCCLUSIONQUERYIVNVPROC glad_glGetOcclusionQueryivNV;
#define glGetOcclusionQueryivNV glad_glGetOcclusionQueryivNV
GLAD_API_CALL PFNGLGETOCCLUSIONQUERYUIVNVPROC glad_glGetOcclusionQueryuivNV;
#define glGetOcclusionQueryuivNV glad_glGetOcclusionQueryuivNV
GLAD_API_CALL PFNGLGETPATHCOMMANDSNVPROC glad_glGetPathCommandsNV;
#define glGetPathCommandsNV glad_glGetPathCommandsNV
GLAD_API_CALL PFNGLGETPATHCOORDSNVPROC glad_glGetPathCoordsNV;
#define glGetPathCoordsNV glad_glGetPathCoordsNV
GLAD_API_CALL PFNGLGETPATHDASHARRAYNVPROC glad_glGetPathDashArrayNV;
#define glGetPathDashArrayNV glad_glGetPathDashArrayNV
GLAD_API_CALL PFNGLGETPATHLENGTHNVPROC glad_glGetPathLengthNV;
#define glGetPathLengthNV glad_glGetPathLengthNV
GLAD_API_CALL PFNGLGETPATHMETRICRANGENVPROC glad_glGetPathMetricRangeNV;
#define glGetPathMetricRangeNV glad_glGetPathMetricRangeNV
GLAD_API_CALL PFNGLGETPATHMETRICSNVPROC glad_glGetPathMetricsNV;
#define glGetPathMetricsNV glad_glGetPathMetricsNV
GLAD_API_CALL PFNGLGETPATHPARAMETERFVNVPROC glad_glGetPathParameterfvNV;
#define glGetPathParameterfvNV glad_glGetPathParameterfvNV
GLAD_API_CALL PFNGLGETPATHPARAMETERIVNVPROC glad_glGetPathParameterivNV;
#define glGetPathParameterivNV glad_glGetPathParameterivNV
GLAD_API_CALL PFNGLGETPATHSPACINGNVPROC glad_glGetPathSpacingNV;
#define glGetPathSpacingNV glad_glGetPathSpacingNV
GLAD_API_CALL PFNGLGETPERFCOUNTERINFOINTELPROC glad_glGetPerfCounterInfoINTEL;
#define glGetPerfCounterInfoINTEL glad_glGetPerfCounterInfoINTEL
GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERDATAAMDPROC glad_glGetPerfMonitorCounterDataAMD;
#define glGetPerfMonitorCounterDataAMD glad_glGetPerfMonitorCounterDataAMD
GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERINFOAMDPROC glad_glGetPerfMonitorCounterInfoAMD;
#define glGetPerfMonitorCounterInfoAMD glad_glGetPerfMonitorCounterInfoAMD
GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC glad_glGetPerfMonitorCounterStringAMD;
#define glGetPerfMonitorCounterStringAMD glad_glGetPerfMonitorCounterStringAMD
GLAD_API_CALL PFNGLGETPERFMONITORCOUNTERSAMDPROC glad_glGetPerfMonitorCountersAMD;
#define glGetPerfMonitorCountersAMD glad_glGetPerfMonitorCountersAMD
GLAD_API_CALL PFNGLGETPERFMONITORGROUPSTRINGAMDPROC glad_glGetPerfMonitorGroupStringAMD;
#define glGetPerfMonitorGroupStringAMD glad_glGetPerfMonitorGroupStringAMD
GLAD_API_CALL PFNGLGETPERFMONITORGROUPSAMDPROC glad_glGetPerfMonitorGroupsAMD;
#define glGetPerfMonitorGroupsAMD glad_glGetPerfMonitorGroupsAMD
GLAD_API_CALL PFNGLGETPERFQUERYDATAINTELPROC glad_glGetPerfQueryDataINTEL;
#define glGetPerfQueryDataINTEL glad_glGetPerfQueryDataINTEL
GLAD_API_CALL PFNGLGETPERFQUERYIDBYNAMEINTELPROC glad_glGetPerfQueryIdByNameINTEL;
#define glGetPerfQueryIdByNameINTEL glad_glGetPerfQueryIdByNameINTEL
GLAD_API_CALL PFNGLGETPERFQUERYINFOINTELPROC glad_glGetPerfQueryInfoINTEL;
#define glGetPerfQueryInfoINTEL glad_glGetPerfQueryInfoINTEL
GLAD_API_CALL PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC glad_glGetPixelTransformParameterfvEXT;
#define glGetPixelTransformParameterfvEXT glad_glGetPixelTransformParameterfvEXT
GLAD_API_CALL PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC glad_glGetPixelTransformParameterivEXT;
#define glGetPixelTransformParameterivEXT glad_glGetPixelTransformParameterivEXT
GLAD_API_CALL PFNGLGETPOINTERINDEXEDVEXTPROC glad_glGetPointerIndexedvEXT;
#define glGetPointerIndexedvEXT glad_glGetPointerIndexedvEXT
GLAD_API_CALL PFNGLGETPOINTERI_VEXTPROC glad_glGetPointeri_vEXT;
#define glGetPointeri_vEXT glad_glGetPointeri_vEXT
GLAD_API_CALL PFNGLGETPOINTERVPROC glad_glGetPointerv;
#define glGetPointerv glad_glGetPointerv
GLAD_API_CALL PFNGLGETPOINTERVEXTPROC glad_glGetPointervEXT;
#define glGetPointervEXT glad_glGetPointervEXT
GLAD_API_CALL PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary;
#define glGetProgramBinary glad_glGetProgramBinary
GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERIIVNVPROC glad_glGetProgramEnvParameterIivNV;
#define glGetProgramEnvParameterIivNV glad_glGetProgramEnvParameterIivNV
GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC glad_glGetProgramEnvParameterIuivNV;
#define glGetProgramEnvParameterIuivNV glad_glGetProgramEnvParameterIuivNV
GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERDVARBPROC glad_glGetProgramEnvParameterdvARB;
#define glGetProgramEnvParameterdvARB glad_glGetProgramEnvParameterdvARB
GLAD_API_CALL PFNGLGETPROGRAMENVPARAMETERFVARBPROC glad_glGetProgramEnvParameterfvARB;
#define glGetProgramEnvParameterfvARB glad_glGetProgramEnvParameterfvARB
GLAD_API_CALL PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;
#define glGetProgramInfoLog glad_glGetProgramInfoLog
GLAD_API_CALL PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv;
#define glGetProgramInterfaceiv glad_glGetProgramInterfaceiv
GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC glad_glGetProgramLocalParameterIivNV;
#define glGetProgramLocalParameterIivNV glad_glGetProgramLocalParameterIivNV
GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC glad_glGetProgramLocalParameterIuivNV;
#define glGetProgramLocalParameterIuivNV glad_glGetProgramLocalParameterIuivNV
GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC glad_glGetProgramLocalParameterdvARB;
#define glGetProgramLocalParameterdvARB glad_glGetProgramLocalParameterdvARB
GLAD_API_CALL PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC glad_glGetProgramLocalParameterfvARB;
#define glGetProgramLocalParameterfvARB glad_glGetProgramLocalParameterfvARB
GLAD_API_CALL PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC glad_glGetProgramNamedParameterdvNV;
#define glGetProgramNamedParameterdvNV glad_glGetProgramNamedParameterdvNV
GLAD_API_CALL PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC glad_glGetProgramNamedParameterfvNV;
#define glGetProgramNamedParameterfvNV glad_glGetProgramNamedParameterfvNV
GLAD_API_CALL PFNGLGETPROGRAMPARAMETERDVNVPROC glad_glGetProgramParameterdvNV;
#define glGetProgramParameterdvNV glad_glGetProgramParameterdvNV
GLAD_API_CALL PFNGLGETPROGRAMPARAMETERFVNVPROC glad_glGetProgramParameterfvNV;
#define glGetProgramParameterfvNV glad_glGetProgramParameterfvNV
GLAD_API_CALL PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog;
#define glGetProgramPipelineInfoLog glad_glGetProgramPipelineInfoLog
GLAD_API_CALL PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv;
#define glGetProgramPipelineiv glad_glGetProgramPipelineiv
GLAD_API_CALL PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex;
#define glGetProgramResourceIndex glad_glGetProgramResourceIndex
GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation;
#define glGetProgramResourceLocation glad_glGetProgramResourceLocation
GLAD_API_CALL PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex;
#define glGetProgramResourceLocationIndex glad_glGetProgramResourceLocationIndex
GLAD_API_CALL PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName;
#define glGetProgramResourceName glad_glGetProgramResourceName
GLAD_API_CALL PFNGLGETPROGRAMRESOURCEFVNVPROC glad_glGetProgramResourcefvNV;
#define glGetProgramResourcefvNV glad_glGetProgramResourcefvNV
GLAD_API_CALL PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv;
#define glGetProgramResourceiv glad_glGetProgramResourceiv
GLAD_API_CALL PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv;
#define glGetProgramStageiv glad_glGetProgramStageiv
GLAD_API_CALL PFNGLGETPROGRAMSTRINGARBPROC glad_glGetProgramStringARB;
#define glGetProgramStringARB glad_glGetProgramStringARB
GLAD_API_CALL PFNGLGETPROGRAMSTRINGNVPROC glad_glGetProgramStringNV;
#define glGetProgramStringNV glad_glGetProgramStringNV
GLAD_API_CALL PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC glad_glGetProgramSubroutineParameteruivNV;
#define glGetProgramSubroutineParameteruivNV glad_glGetProgramSubroutineParameteruivNV
GLAD_API_CALL PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;
#define glGetProgramiv glad_glGetProgramiv
GLAD_API_CALL PFNGLGETPROGRAMIVARBPROC glad_glGetProgramivARB;
#define glGetProgramivARB glad_glGetProgramivARB
GLAD_API_CALL PFNGLGETPROGRAMIVNVPROC glad_glGetProgramivNV;
#define glGetProgramivNV glad_glGetProgramivNV
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v;
#define glGetQueryBufferObjecti64v glad_glGetQueryBufferObjecti64v
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv;
#define glGetQueryBufferObjectiv glad_glGetQueryBufferObjectiv
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v;
#define glGetQueryBufferObjectui64v glad_glGetQueryBufferObjectui64v
GLAD_API_CALL PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv;
#define glGetQueryBufferObjectuiv glad_glGetQueryBufferObjectuiv
GLAD_API_CALL PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv;
#define glGetQueryIndexediv glad_glGetQueryIndexediv
GLAD_API_CALL PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;
#define glGetQueryObjecti64v glad_glGetQueryObjecti64v
GLAD_API_CALL PFNGLGETQUERYOBJECTI64VEXTPROC glad_glGetQueryObjecti64vEXT;
#define glGetQueryObjecti64vEXT glad_glGetQueryObjecti64vEXT
GLAD_API_CALL PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;
#define glGetQueryObjectiv glad_glGetQueryObjectiv
GLAD_API_CALL PFNGLGETQUERYOBJECTIVARBPROC glad_glGetQueryObjectivARB;
#define glGetQueryObjectivARB glad_glGetQueryObjectivARB
GLAD_API_CALL PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;
#define glGetQueryObjectui64v glad_glGetQueryObjectui64v
GLAD_API_CALL PFNGLGETQUERYOBJECTUI64VEXTPROC glad_glGetQueryObjectui64vEXT;
#define glGetQueryObjectui64vEXT glad_glGetQueryObjectui64vEXT
GLAD_API_CALL PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;
#define glGetQueryObjectuiv glad_glGetQueryObjectuiv
GLAD_API_CALL PFNGLGETQUERYOBJECTUIVARBPROC glad_glGetQueryObjectuivARB;
#define glGetQueryObjectuivARB glad_glGetQueryObjectuivARB
GLAD_API_CALL PFNGLGETQUERYIVPROC glad_glGetQueryiv;
#define glGetQueryiv glad_glGetQueryiv
GLAD_API_CALL PFNGLGETQUERYIVARBPROC glad_glGetQueryivARB;
#define glGetQueryivARB glad_glGetQueryivARB
GLAD_API_CALL PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;
#define glGetRenderbufferParameteriv glad_glGetRenderbufferParameteriv
GLAD_API_CALL PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC glad_glGetRenderbufferParameterivEXT;
#define glGetRenderbufferParameterivEXT glad_glGetRenderbufferParameterivEXT
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;
#define glGetSamplerParameterIiv glad_glGetSamplerParameterIiv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;
#define glGetSamplerParameterIuiv glad_glGetSamplerParameterIuiv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;
#define glGetSamplerParameterfv glad_glGetSamplerParameterfv
GLAD_API_CALL PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;
#define glGetSamplerParameteriv glad_glGetSamplerParameteriv
GLAD_API_CALL PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC glad_glGetSemaphoreParameterui64vEXT;
#define glGetSemaphoreParameterui64vEXT glad_glGetSemaphoreParameterui64vEXT
GLAD_API_CALL PFNGLGETSEPARABLEFILTEREXTPROC glad_glGetSeparableFilterEXT;
#define glGetSeparableFilterEXT glad_glGetSeparableFilterEXT
GLAD_API_CALL PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;
#define glGetShaderInfoLog glad_glGetShaderInfoLog
GLAD_API_CALL PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat;
#define glGetShaderPrecisionFormat glad_glGetShaderPrecisionFormat
GLAD_API_CALL PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;
#define glGetShaderSource glad_glGetShaderSource
GLAD_API_CALL PFNGLGETSHADERSOURCEARBPROC glad_glGetShaderSourceARB;
#define glGetShaderSourceARB glad_glGetShaderSourceARB
GLAD_API_CALL PFNGLGETSHADERIVPROC glad_glGetShaderiv;
#define glGetShaderiv glad_glGetShaderiv
GLAD_API_CALL PFNGLGETSTAGEINDEXNVPROC glad_glGetStageIndexNV;
#define glGetStageIndexNV glad_glGetStageIndexNV
GLAD_API_CALL PFNGLGETSTRINGPROC glad_glGetString;
#define glGetString glad_glGetString
GLAD_API_CALL PFNGLGETSTRINGIPROC glad_glGetStringi;
#define glGetStringi glad_glGetStringi
GLAD_API_CALL PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex;
#define glGetSubroutineIndex glad_glGetSubroutineIndex
GLAD_API_CALL PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation;
#define glGetSubroutineUniformLocation glad_glGetSubroutineUniformLocation
GLAD_API_CALL PFNGLGETSYNCIVPROC glad_glGetSynciv;
#define glGetSynciv glad_glGetSynciv
GLAD_API_CALL PFNGLGETTEXBUMPPARAMETERFVATIPROC glad_glGetTexBumpParameterfvATI;
#define glGetTexBumpParameterfvATI glad_glGetTexBumpParameterfvATI
GLAD_API_CALL PFNGLGETTEXBUMPPARAMETERIVATIPROC glad_glGetTexBumpParameterivATI;
#define glGetTexBumpParameterivATI glad_glGetTexBumpParameterivATI
GLAD_API_CALL PFNGLGETTEXIMAGEPROC glad_glGetTexImage;
#define glGetTexImage glad_glGetTexImage
GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;
#define glGetTexLevelParameterfv glad_glGetTexLevelParameterfv
GLAD_API_CALL PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;
#define glGetTexLevelParameteriv glad_glGetTexLevelParameteriv
GLAD_API_CALL PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;
#define glGetTexParameterIiv glad_glGetTexParameterIiv
GLAD_API_CALL PFNGLGETTEXPARAMETERIIVEXTPROC glad_glGetTexParameterIivEXT;
#define glGetTexParameterIivEXT glad_glGetTexParameterIivEXT
GLAD_API_CALL PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;
#define glGetTexParameterIuiv glad_glGetTexParameterIuiv
GLAD_API_CALL PFNGLGETTEXPARAMETERIUIVEXTPROC glad_glGetTexParameterIuivEXT;
#define glGetTexParameterIuivEXT glad_glGetTexParameterIuivEXT
GLAD_API_CALL PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC glad_glGetTexParameterPointervAPPLE;
#define glGetTexParameterPointervAPPLE glad_glGetTexParameterPointervAPPLE
GLAD_API_CALL PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;
#define glGetTexParameterfv glad_glGetTexParameterfv
GLAD_API_CALL PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;
#define glGetTexParameteriv glad_glGetTexParameteriv
GLAD_API_CALL PFNGLGETTEXTUREHANDLEARBPROC glad_glGetTextureHandleARB;
#define glGetTextureHandleARB glad_glGetTextureHandleARB
GLAD_API_CALL PFNGLGETTEXTUREHANDLENVPROC glad_glGetTextureHandleNV;
#define glGetTextureHandleNV glad_glGetTextureHandleNV
GLAD_API_CALL PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage;
#define glGetTextureImage glad_glGetTextureImage
GLAD_API_CALL PFNGLGETTEXTUREIMAGEEXTPROC glad_glGetTextureImageEXT;
#define glGetTextureImageEXT glad_glGetTextureImageEXT
GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv;
#define glGetTextureLevelParameterfv glad_glGetTextureLevelParameterfv
GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC glad_glGetTextureLevelParameterfvEXT;
#define glGetTextureLevelParameterfvEXT glad_glGetTextureLevelParameterfvEXT
GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv;
#define glGetTextureLevelParameteriv glad_glGetTextureLevelParameteriv
GLAD_API_CALL PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC glad_glGetTextureLevelParameterivEXT;
#define glGetTextureLevelParameterivEXT glad_glGetTextureLevelParameterivEXT
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv;
#define glGetTextureParameterIiv glad_glGetTextureParameterIiv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIIVEXTPROC glad_glGetTextureParameterIivEXT;
#define glGetTextureParameterIivEXT glad_glGetTextureParameterIivEXT
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv;
#define glGetTextureParameterIuiv glad_glGetTextureParameterIuiv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIUIVEXTPROC glad_glGetTextureParameterIuivEXT;
#define glGetTextureParameterIuivEXT glad_glGetTextureParameterIuivEXT
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv;
#define glGetTextureParameterfv glad_glGetTextureParameterfv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERFVEXTPROC glad_glGetTextureParameterfvEXT;
#define glGetTextureParameterfvEXT glad_glGetTextureParameterfvEXT
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv;
#define glGetTextureParameteriv glad_glGetTextureParameteriv
GLAD_API_CALL PFNGLGETTEXTUREPARAMETERIVEXTPROC glad_glGetTextureParameterivEXT;
#define glGetTextureParameterivEXT glad_glGetTextureParameterivEXT
GLAD_API_CALL PFNGLGETTEXTURESAMPLERHANDLEARBPROC glad_glGetTextureSamplerHandleARB;
#define glGetTextureSamplerHandleARB glad_glGetTextureSamplerHandleARB
GLAD_API_CALL PFNGLGETTEXTURESAMPLERHANDLENVPROC glad_glGetTextureSamplerHandleNV;
#define glGetTextureSamplerHandleNV glad_glGetTextureSamplerHandleNV
GLAD_API_CALL PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage;
#define glGetTextureSubImage glad_glGetTextureSubImage
GLAD_API_CALL PFNGLGETTRACKMATRIXIVNVPROC glad_glGetTrackMatrixivNV;
#define glGetTrackMatrixivNV glad_glGetTrackMatrixivNV
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;
#define glGetTransformFeedbackVarying glad_glGetTransformFeedbackVarying
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC glad_glGetTransformFeedbackVaryingEXT;
#define glGetTransformFeedbackVaryingEXT glad_glGetTransformFeedbackVaryingEXT
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC glad_glGetTransformFeedbackVaryingNV;
#define glGetTransformFeedbackVaryingNV glad_glGetTransformFeedbackVaryingNV
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v;
#define glGetTransformFeedbacki64_v glad_glGetTransformFeedbacki64_v
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v;
#define glGetTransformFeedbacki_v glad_glGetTransformFeedbacki_v
GLAD_API_CALL PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv;
#define glGetTransformFeedbackiv glad_glGetTransformFeedbackiv
GLAD_API_CALL PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;
#define glGetUniformBlockIndex glad_glGetUniformBlockIndex
GLAD_API_CALL PFNGLGETUNIFORMBUFFERSIZEEXTPROC glad_glGetUniformBufferSizeEXT;
#define glGetUniformBufferSizeEXT glad_glGetUniformBufferSizeEXT
GLAD_API_CALL PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;
#define glGetUniformIndices glad_glGetUniformIndices
GLAD_API_CALL PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;
#define glGetUniformLocation glad_glGetUniformLocation
GLAD_API_CALL PFNGLGETUNIFORMLOCATIONARBPROC glad_glGetUniformLocationARB;
#define glGetUniformLocationARB glad_glGetUniformLocationARB
GLAD_API_CALL PFNGLGETUNIFORMOFFSETEXTPROC glad_glGetUniformOffsetEXT;
#define glGetUniformOffsetEXT glad_glGetUniformOffsetEXT
GLAD_API_CALL PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv;
#define glGetUniformSubroutineuiv glad_glGetUniformSubroutineuiv
GLAD_API_CALL PFNGLGETUNIFORMDVPROC glad_glGetUniformdv;
#define glGetUniformdv glad_glGetUniformdv
GLAD_API_CALL PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;
#define glGetUniformfv glad_glGetUniformfv
GLAD_API_CALL PFNGLGETUNIFORMFVARBPROC glad_glGetUniformfvARB;
#define glGetUniformfvARB glad_glGetUniformfvARB
GLAD_API_CALL PFNGLGETUNIFORMI64VARBPROC glad_glGetUniformi64vARB;
#define glGetUniformi64vARB glad_glGetUniformi64vARB
GLAD_API_CALL PFNGLGETUNIFORMI64VNVPROC glad_glGetUniformi64vNV;
#define glGetUniformi64vNV glad_glGetUniformi64vNV
GLAD_API_CALL PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;
#define glGetUniformiv glad_glGetUniformiv
GLAD_API_CALL PFNGLGETUNIFORMIVARBPROC glad_glGetUniformivARB;
#define glGetUniformivARB glad_glGetUniformivARB
GLAD_API_CALL PFNGLGETUNIFORMUI64VARBPROC glad_glGetUniformui64vARB;
#define glGetUniformui64vARB glad_glGetUniformui64vARB
GLAD_API_CALL PFNGLGETUNIFORMUI64VNVPROC glad_glGetUniformui64vNV;
#define glGetUniformui64vNV glad_glGetUniformui64vNV
GLAD_API_CALL PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;
#define glGetUniformuiv glad_glGetUniformuiv
GLAD_API_CALL PFNGLGETUNIFORMUIVEXTPROC glad_glGetUniformuivEXT;
#define glGetUniformuivEXT glad_glGetUniformuivEXT
GLAD_API_CALL PFNGLGETUNSIGNEDBYTEI_VEXTPROC glad_glGetUnsignedBytei_vEXT;
#define glGetUnsignedBytei_vEXT glad_glGetUnsignedBytei_vEXT
GLAD_API_CALL PFNGLGETUNSIGNEDBYTEVEXTPROC glad_glGetUnsignedBytevEXT;
#define glGetUnsignedBytevEXT glad_glGetUnsignedBytevEXT
GLAD_API_CALL PFNGLGETVARIANTARRAYOBJECTFVATIPROC glad_glGetVariantArrayObjectfvATI;
#define glGetVariantArrayObjectfvATI glad_glGetVariantArrayObjectfvATI
GLAD_API_CALL PFNGLGETVARIANTARRAYOBJECTIVATIPROC glad_glGetVariantArrayObjectivATI;
#define glGetVariantArrayObjectivATI glad_glGetVariantArrayObjectivATI
GLAD_API_CALL PFNGLGETVARIANTBOOLEANVEXTPROC glad_glGetVariantBooleanvEXT;
#define glGetVariantBooleanvEXT glad_glGetVariantBooleanvEXT
GLAD_API_CALL PFNGLGETVARIANTFLOATVEXTPROC glad_glGetVariantFloatvEXT;
#define glGetVariantFloatvEXT glad_glGetVariantFloatvEXT
GLAD_API_CALL PFNGLGETVARIANTINTEGERVEXTPROC glad_glGetVariantIntegervEXT;
#define glGetVariantIntegervEXT glad_glGetVariantIntegervEXT
GLAD_API_CALL PFNGLGETVARIANTPOINTERVEXTPROC glad_glGetVariantPointervEXT;
#define glGetVariantPointervEXT glad_glGetVariantPointervEXT
GLAD_API_CALL PFNGLGETVARYINGLOCATIONNVPROC glad_glGetVaryingLocationNV;
#define glGetVaryingLocationNV glad_glGetVaryingLocationNV
GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv;
#define glGetVertexArrayIndexed64iv glad_glGetVertexArrayIndexed64iv
GLAD_API_CALL PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv;
#define glGetVertexArrayIndexediv glad_glGetVertexArrayIndexediv
GLAD_API_CALL PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC glad_glGetVertexArrayIntegeri_vEXT;
#define glGetVertexArrayIntegeri_vEXT glad_glGetVertexArrayIntegeri_vEXT
GLAD_API_CALL PFNGLGETVERTEXARRAYINTEGERVEXTPROC glad_glGetVertexArrayIntegervEXT;
#define glGetVertexArrayIntegervEXT glad_glGetVertexArrayIntegervEXT
GLAD_API_CALL PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC glad_glGetVertexArrayPointeri_vEXT;
#define glGetVertexArrayPointeri_vEXT glad_glGetVertexArrayPointeri_vEXT
GLAD_API_CALL PFNGLGETVERTEXARRAYPOINTERVEXTPROC glad_glGetVertexArrayPointervEXT;
#define glGetVertexArrayPointervEXT glad_glGetVertexArrayPointervEXT
GLAD_API_CALL PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv;
#define glGetVertexArrayiv glad_glGetVertexArrayiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC glad_glGetVertexAttribArrayObjectfvATI;
#define glGetVertexAttribArrayObjectfvATI glad_glGetVertexAttribArrayObjectfvATI
GLAD_API_CALL PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC glad_glGetVertexAttribArrayObjectivATI;
#define glGetVertexAttribArrayObjectivATI glad_glGetVertexAttribArrayObjectivATI
GLAD_API_CALL PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;
#define glGetVertexAttribIiv glad_glGetVertexAttribIiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBIIVEXTPROC glad_glGetVertexAttribIivEXT;
#define glGetVertexAttribIivEXT glad_glGetVertexAttribIivEXT
GLAD_API_CALL PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;
#define glGetVertexAttribIuiv glad_glGetVertexAttribIuiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBIUIVEXTPROC glad_glGetVertexAttribIuivEXT;
#define glGetVertexAttribIuivEXT glad_glGetVertexAttribIuivEXT
GLAD_API_CALL PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv;
#define glGetVertexAttribLdv glad_glGetVertexAttribLdv
GLAD_API_CALL PFNGLGETVERTEXATTRIBLDVEXTPROC glad_glGetVertexAttribLdvEXT;
#define glGetVertexAttribLdvEXT glad_glGetVertexAttribLdvEXT
GLAD_API_CALL PFNGLGETVERTEXATTRIBLI64VNVPROC glad_glGetVertexAttribLi64vNV;
#define glGetVertexAttribLi64vNV glad_glGetVertexAttribLi64vNV
GLAD_API_CALL PFNGLGETVERTEXATTRIBLUI64VARBPROC glad_glGetVertexAttribLui64vARB;
#define glGetVertexAttribLui64vARB glad_glGetVertexAttribLui64vARB
GLAD_API_CALL PFNGLGETVERTEXATTRIBLUI64VNVPROC glad_glGetVertexAttribLui64vNV;
#define glGetVertexAttribLui64vNV glad_glGetVertexAttribLui64vNV
GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;
#define glGetVertexAttribPointerv glad_glGetVertexAttribPointerv
GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVARBPROC glad_glGetVertexAttribPointervARB;
#define glGetVertexAttribPointervARB glad_glGetVertexAttribPointervARB
GLAD_API_CALL PFNGLGETVERTEXATTRIBPOINTERVNVPROC glad_glGetVertexAttribPointervNV;
#define glGetVertexAttribPointervNV glad_glGetVertexAttribPointervNV
GLAD_API_CALL PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;
#define glGetVertexAttribdv glad_glGetVertexAttribdv
GLAD_API_CALL PFNGLGETVERTEXATTRIBDVARBPROC glad_glGetVertexAttribdvARB;
#define glGetVertexAttribdvARB glad_glGetVertexAttribdvARB
GLAD_API_CALL PFNGLGETVERTEXATTRIBDVNVPROC glad_glGetVertexAttribdvNV;
#define glGetVertexAttribdvNV glad_glGetVertexAttribdvNV
GLAD_API_CALL PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;
#define glGetVertexAttribfv glad_glGetVertexAttribfv
GLAD_API_CALL PFNGLGETVERTEXATTRIBFVARBPROC glad_glGetVertexAttribfvARB;
#define glGetVertexAttribfvARB glad_glGetVertexAttribfvARB
GLAD_API_CALL PFNGLGETVERTEXATTRIBFVNVPROC glad_glGetVertexAttribfvNV;
#define glGetVertexAttribfvNV glad_glGetVertexAttribfvNV
GLAD_API_CALL PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;
#define glGetVertexAttribiv glad_glGetVertexAttribiv
GLAD_API_CALL PFNGLGETVERTEXATTRIBIVARBPROC glad_glGetVertexAttribivARB;
#define glGetVertexAttribivARB glad_glGetVertexAttribivARB
GLAD_API_CALL PFNGLGETVERTEXATTRIBIVNVPROC glad_glGetVertexAttribivNV;
#define glGetVertexAttribivNV glad_glGetVertexAttribivNV
GLAD_API_CALL PFNGLGETVIDEOCAPTURESTREAMDVNVPROC glad_glGetVideoCaptureStreamdvNV;
#define glGetVideoCaptureStreamdvNV glad_glGetVideoCaptureStreamdvNV
GLAD_API_CALL PFNGLGETVIDEOCAPTURESTREAMFVNVPROC glad_glGetVideoCaptureStreamfvNV;
#define glGetVideoCaptureStreamfvNV glad_glGetVideoCaptureStreamfvNV
GLAD_API_CALL PFNGLGETVIDEOCAPTURESTREAMIVNVPROC glad_glGetVideoCaptureStreamivNV;
#define glGetVideoCaptureStreamivNV glad_glGetVideoCaptureStreamivNV
GLAD_API_CALL PFNGLGETVIDEOCAPTUREIVNVPROC glad_glGetVideoCaptureivNV;
#define glGetVideoCaptureivNV glad_glGetVideoCaptureivNV
GLAD_API_CALL PFNGLGETVIDEOI64VNVPROC glad_glGetVideoi64vNV;
#define glGetVideoi64vNV glad_glGetVideoi64vNV
GLAD_API_CALL PFNGLGETVIDEOIVNVPROC glad_glGetVideoivNV;
#define glGetVideoivNV glad_glGetVideoivNV
GLAD_API_CALL PFNGLGETVIDEOUI64VNVPROC glad_glGetVideoui64vNV;
#define glGetVideoui64vNV glad_glGetVideoui64vNV
GLAD_API_CALL PFNGLGETVIDEOUIVNVPROC glad_glGetVideouivNV;
#define glGetVideouivNV glad_glGetVideouivNV
GLAD_API_CALL PFNGLGETVKPROCADDRNVPROC glad_glGetVkProcAddrNV;
#define glGetVkProcAddrNV glad_glGetVkProcAddrNV
GLAD_API_CALL PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage;
#define glGetnCompressedTexImage glad_glGetnCompressedTexImage
GLAD_API_CALL PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC glad_glGetnCompressedTexImageARB;
#define glGetnCompressedTexImageARB glad_glGetnCompressedTexImageARB
GLAD_API_CALL PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage;
#define glGetnTexImage glad_glGetnTexImage
GLAD_API_CALL PFNGLGETNTEXIMAGEARBPROC glad_glGetnTexImageARB;
#define glGetnTexImageARB glad_glGetnTexImageARB
GLAD_API_CALL PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv;
#define glGetnUniformdv glad_glGetnUniformdv
GLAD_API_CALL PFNGLGETNUNIFORMDVARBPROC glad_glGetnUniformdvARB;
#define glGetnUniformdvARB glad_glGetnUniformdvARB
GLAD_API_CALL PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv;
#define glGetnUniformfv glad_glGetnUniformfv
GLAD_API_CALL PFNGLGETNUNIFORMFVARBPROC glad_glGetnUniformfvARB;
#define glGetnUniformfvARB glad_glGetnUniformfvARB
GLAD_API_CALL PFNGLGETNUNIFORMI64VARBPROC glad_glGetnUniformi64vARB;
#define glGetnUniformi64vARB glad_glGetnUniformi64vARB
GLAD_API_CALL PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv;
#define glGetnUniformiv glad_glGetnUniformiv
GLAD_API_CALL PFNGLGETNUNIFORMIVARBPROC glad_glGetnUniformivARB;
#define glGetnUniformivARB glad_glGetnUniformivARB
GLAD_API_CALL PFNGLGETNUNIFORMUI64VARBPROC glad_glGetnUniformui64vARB;
#define glGetnUniformui64vARB glad_glGetnUniformui64vARB
GLAD_API_CALL PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv;
#define glGetnUniformuiv glad_glGetnUniformuiv
GLAD_API_CALL PFNGLGETNUNIFORMUIVARBPROC glad_glGetnUniformuivARB;
#define glGetnUniformuivARB glad_glGetnUniformuivARB
GLAD_API_CALL PFNGLHINTPROC glad_glHint;
#define glHint glad_glHint
GLAD_API_CALL PFNGLHISTOGRAMPROC glad_glHistogram;
#define glHistogram glad_glHistogram
GLAD_API_CALL PFNGLHISTOGRAMEXTPROC glad_glHistogramEXT;
#define glHistogramEXT glad_glHistogramEXT
GLAD_API_CALL PFNGLIMPORTMEMORYFDEXTPROC glad_glImportMemoryFdEXT;
#define glImportMemoryFdEXT glad_glImportMemoryFdEXT
GLAD_API_CALL PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC glad_glImportMemoryWin32HandleEXT;
#define glImportMemoryWin32HandleEXT glad_glImportMemoryWin32HandleEXT
GLAD_API_CALL PFNGLIMPORTMEMORYWIN32NAMEEXTPROC glad_glImportMemoryWin32NameEXT;
#define glImportMemoryWin32NameEXT glad_glImportMemoryWin32NameEXT
GLAD_API_CALL PFNGLIMPORTSEMAPHOREFDEXTPROC glad_glImportSemaphoreFdEXT;
#define glImportSemaphoreFdEXT glad_glImportSemaphoreFdEXT
GLAD_API_CALL PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC glad_glImportSemaphoreWin32HandleEXT;
#define glImportSemaphoreWin32HandleEXT glad_glImportSemaphoreWin32HandleEXT
GLAD_API_CALL PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC glad_glImportSemaphoreWin32NameEXT;
#define glImportSemaphoreWin32NameEXT glad_glImportSemaphoreWin32NameEXT
GLAD_API_CALL PFNGLIMPORTSYNCEXTPROC glad_glImportSyncEXT;
#define glImportSyncEXT glad_glImportSyncEXT
GLAD_API_CALL PFNGLINDEXFORMATNVPROC glad_glIndexFormatNV;
#define glIndexFormatNV glad_glIndexFormatNV
GLAD_API_CALL PFNGLINDEXFUNCEXTPROC glad_glIndexFuncEXT;
#define glIndexFuncEXT glad_glIndexFuncEXT
GLAD_API_CALL PFNGLINDEXMATERIALEXTPROC glad_glIndexMaterialEXT;
#define glIndexMaterialEXT glad_glIndexMaterialEXT
GLAD_API_CALL PFNGLINDEXPOINTEREXTPROC glad_glIndexPointerEXT;
#define glIndexPointerEXT glad_glIndexPointerEXT
GLAD_API_CALL PFNGLINSERTCOMPONENTEXTPROC glad_glInsertComponentEXT;
#define glInsertComponentEXT glad_glInsertComponentEXT
GLAD_API_CALL PFNGLINSERTEVENTMARKEREXTPROC glad_glInsertEventMarkerEXT;
#define glInsertEventMarkerEXT glad_glInsertEventMarkerEXT
GLAD_API_CALL PFNGLINTERPOLATEPATHSNVPROC glad_glInterpolatePathsNV;
#define glInterpolatePathsNV glad_glInterpolatePathsNV
GLAD_API_CALL PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData;
#define glInvalidateBufferData glad_glInvalidateBufferData
GLAD_API_CALL PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData;
#define glInvalidateBufferSubData glad_glInvalidateBufferSubData
GLAD_API_CALL PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer;
#define glInvalidateFramebuffer glad_glInvalidateFramebuffer
GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData;
#define glInvalidateNamedFramebufferData glad_glInvalidateNamedFramebufferData
GLAD_API_CALL PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData;
#define glInvalidateNamedFramebufferSubData glad_glInvalidateNamedFramebufferSubData
GLAD_API_CALL PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer;
#define glInvalidateSubFramebuffer glad_glInvalidateSubFramebuffer
GLAD_API_CALL PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage;
#define glInvalidateTexImage glad_glInvalidateTexImage
GLAD_API_CALL PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage;
#define glInvalidateTexSubImage glad_glInvalidateTexSubImage
GLAD_API_CALL PFNGLISBUFFERPROC glad_glIsBuffer;
#define glIsBuffer glad_glIsBuffer
GLAD_API_CALL PFNGLISBUFFERARBPROC glad_glIsBufferARB;
#define glIsBufferARB glad_glIsBufferARB
GLAD_API_CALL PFNGLISBUFFERRESIDENTNVPROC glad_glIsBufferResidentNV;
#define glIsBufferResidentNV glad_glIsBufferResidentNV
GLAD_API_CALL PFNGLISCOMMANDLISTNVPROC glad_glIsCommandListNV;
#define glIsCommandListNV glad_glIsCommandListNV
GLAD_API_CALL PFNGLISENABLEDPROC glad_glIsEnabled;
#define glIsEnabled glad_glIsEnabled
GLAD_API_CALL PFNGLISENABLEDINDEXEDEXTPROC glad_glIsEnabledIndexedEXT;
#define glIsEnabledIndexedEXT glad_glIsEnabledIndexedEXT
GLAD_API_CALL PFNGLISENABLEDIPROC glad_glIsEnabledi;
#define glIsEnabledi glad_glIsEnabledi
GLAD_API_CALL PFNGLISFENCEAPPLEPROC glad_glIsFenceAPPLE;
#define glIsFenceAPPLE glad_glIsFenceAPPLE
GLAD_API_CALL PFNGLISFENCENVPROC glad_glIsFenceNV;
#define glIsFenceNV glad_glIsFenceNV
GLAD_API_CALL PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;
#define glIsFramebuffer glad_glIsFramebuffer
GLAD_API_CALL PFNGLISFRAMEBUFFEREXTPROC glad_glIsFramebufferEXT;
#define glIsFramebufferEXT glad_glIsFramebufferEXT
GLAD_API_CALL PFNGLISIMAGEHANDLERESIDENTARBPROC glad_glIsImageHandleResidentARB;
#define glIsImageHandleResidentARB glad_glIsImageHandleResidentARB
GLAD_API_CALL PFNGLISIMAGEHANDLERESIDENTNVPROC glad_glIsImageHandleResidentNV;
#define glIsImageHandleResidentNV glad_glIsImageHandleResidentNV
GLAD_API_CALL PFNGLISMEMORYOBJECTEXTPROC glad_glIsMemoryObjectEXT;
#define glIsMemoryObjectEXT glad_glIsMemoryObjectEXT
GLAD_API_CALL PFNGLISNAMEAMDPROC glad_glIsNameAMD;
#define glIsNameAMD glad_glIsNameAMD
GLAD_API_CALL PFNGLISNAMEDBUFFERRESIDENTNVPROC glad_glIsNamedBufferResidentNV;
#define glIsNamedBufferResidentNV glad_glIsNamedBufferResidentNV
GLAD_API_CALL PFNGLISNAMEDSTRINGARBPROC glad_glIsNamedStringARB;
#define glIsNamedStringARB glad_glIsNamedStringARB
GLAD_API_CALL PFNGLISOBJECTBUFFERATIPROC glad_glIsObjectBufferATI;
#define glIsObjectBufferATI glad_glIsObjectBufferATI
GLAD_API_CALL PFNGLISOCCLUSIONQUERYNVPROC glad_glIsOcclusionQueryNV;
#define glIsOcclusionQueryNV glad_glIsOcclusionQueryNV
GLAD_API_CALL PFNGLISPATHNVPROC glad_glIsPathNV;
#define glIsPathNV glad_glIsPathNV
GLAD_API_CALL PFNGLISPOINTINFILLPATHNVPROC glad_glIsPointInFillPathNV;
#define glIsPointInFillPathNV glad_glIsPointInFillPathNV
GLAD_API_CALL PFNGLISPOINTINSTROKEPATHNVPROC glad_glIsPointInStrokePathNV;
#define glIsPointInStrokePathNV glad_glIsPointInStrokePathNV
GLAD_API_CALL PFNGLISPROGRAMPROC glad_glIsProgram;
#define glIsProgram glad_glIsProgram
GLAD_API_CALL PFNGLISPROGRAMARBPROC glad_glIsProgramARB;
#define glIsProgramARB glad_glIsProgramARB
GLAD_API_CALL PFNGLISPROGRAMNVPROC glad_glIsProgramNV;
#define glIsProgramNV glad_glIsProgramNV
GLAD_API_CALL PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline;
#define glIsProgramPipeline glad_glIsProgramPipeline
GLAD_API_CALL PFNGLISQUERYPROC glad_glIsQuery;
#define glIsQuery glad_glIsQuery
GLAD_API_CALL PFNGLISQUERYARBPROC glad_glIsQueryARB;
#define glIsQueryARB glad_glIsQueryARB
GLAD_API_CALL PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;
#define glIsRenderbuffer glad_glIsRenderbuffer
GLAD_API_CALL PFNGLISRENDERBUFFEREXTPROC glad_glIsRenderbufferEXT;
#define glIsRenderbufferEXT glad_glIsRenderbufferEXT
GLAD_API_CALL PFNGLISSAMPLERPROC glad_glIsSampler;
#define glIsSampler glad_glIsSampler
GLAD_API_CALL PFNGLISSEMAPHOREEXTPROC glad_glIsSemaphoreEXT;
#define glIsSemaphoreEXT glad_glIsSemaphoreEXT
GLAD_API_CALL PFNGLISSHADERPROC glad_glIsShader;
#define glIsShader glad_glIsShader
GLAD_API_CALL PFNGLISSTATENVPROC glad_glIsStateNV;
#define glIsStateNV glad_glIsStateNV
GLAD_API_CALL PFNGLISSYNCPROC glad_glIsSync;
#define glIsSync glad_glIsSync
GLAD_API_CALL PFNGLISTEXTUREPROC glad_glIsTexture;
#define glIsTexture glad_glIsTexture
GLAD_API_CALL PFNGLISTEXTUREEXTPROC glad_glIsTextureEXT;
#define glIsTextureEXT glad_glIsTextureEXT
GLAD_API_CALL PFNGLISTEXTUREHANDLERESIDENTARBPROC glad_glIsTextureHandleResidentARB;
#define glIsTextureHandleResidentARB glad_glIsTextureHandleResidentARB
GLAD_API_CALL PFNGLISTEXTUREHANDLERESIDENTNVPROC glad_glIsTextureHandleResidentNV;
#define glIsTextureHandleResidentNV glad_glIsTextureHandleResidentNV
GLAD_API_CALL PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback;
#define glIsTransformFeedback glad_glIsTransformFeedback
GLAD_API_CALL PFNGLISTRANSFORMFEEDBACKNVPROC glad_glIsTransformFeedbackNV;
#define glIsTransformFeedbackNV glad_glIsTransformFeedbackNV
GLAD_API_CALL PFNGLISVARIANTENABLEDEXTPROC glad_glIsVariantEnabledEXT;
#define glIsVariantEnabledEXT glad_glIsVariantEnabledEXT
GLAD_API_CALL PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;
#define glIsVertexArray glad_glIsVertexArray
GLAD_API_CALL PFNGLISVERTEXARRAYAPPLEPROC glad_glIsVertexArrayAPPLE;
#define glIsVertexArrayAPPLE glad_glIsVertexArrayAPPLE
GLAD_API_CALL PFNGLISVERTEXATTRIBENABLEDAPPLEPROC glad_glIsVertexAttribEnabledAPPLE;
#define glIsVertexAttribEnabledAPPLE glad_glIsVertexAttribEnabledAPPLE
GLAD_API_CALL PFNGLLGPUCOPYIMAGESUBDATANVXPROC glad_glLGPUCopyImageSubDataNVX;
#define glLGPUCopyImageSubDataNVX glad_glLGPUCopyImageSubDataNVX
GLAD_API_CALL PFNGLLGPUINTERLOCKNVXPROC glad_glLGPUInterlockNVX;
#define glLGPUInterlockNVX glad_glLGPUInterlockNVX
GLAD_API_CALL PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC glad_glLGPUNamedBufferSubDataNVX;
#define glLGPUNamedBufferSubDataNVX glad_glLGPUNamedBufferSubDataNVX
GLAD_API_CALL PFNGLLABELOBJECTEXTPROC glad_glLabelObjectEXT;
#define glLabelObjectEXT glad_glLabelObjectEXT
GLAD_API_CALL PFNGLLINEWIDTHPROC glad_glLineWidth;
#define glLineWidth glad_glLineWidth
GLAD_API_CALL PFNGLLINKPROGRAMPROC glad_glLinkProgram;
#define glLinkProgram glad_glLinkProgram
GLAD_API_CALL PFNGLLINKPROGRAMARBPROC glad_glLinkProgramARB;
#define glLinkProgramARB glad_glLinkProgramARB
GLAD_API_CALL PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC glad_glListDrawCommandsStatesClientNV;
#define glListDrawCommandsStatesClientNV glad_glListDrawCommandsStatesClientNV
GLAD_API_CALL PFNGLLOADPROGRAMNVPROC glad_glLoadProgramNV;
#define glLoadProgramNV glad_glLoadProgramNV
GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXDPROC glad_glLoadTransposeMatrixd;
#define glLoadTransposeMatrixd glad_glLoadTransposeMatrixd
GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXDARBPROC glad_glLoadTransposeMatrixdARB;
#define glLoadTransposeMatrixdARB glad_glLoadTransposeMatrixdARB
GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXFPROC glad_glLoadTransposeMatrixf;
#define glLoadTransposeMatrixf glad_glLoadTransposeMatrixf
GLAD_API_CALL PFNGLLOADTRANSPOSEMATRIXFARBPROC glad_glLoadTransposeMatrixfARB;
#define glLoadTransposeMatrixfARB glad_glLoadTransposeMatrixfARB
GLAD_API_CALL PFNGLLOCKARRAYSEXTPROC glad_glLockArraysEXT;
#define glLockArraysEXT glad_glLockArraysEXT
GLAD_API_CALL PFNGLLOGICOPPROC glad_glLogicOp;
#define glLogicOp glad_glLogicOp
GLAD_API_CALL PFNGLMAKEBUFFERNONRESIDENTNVPROC glad_glMakeBufferNonResidentNV;
#define glMakeBufferNonResidentNV glad_glMakeBufferNonResidentNV
GLAD_API_CALL PFNGLMAKEBUFFERRESIDENTNVPROC glad_glMakeBufferResidentNV;
#define glMakeBufferResidentNV glad_glMakeBufferResidentNV
GLAD_API_CALL PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC glad_glMakeImageHandleNonResidentARB;
#define glMakeImageHandleNonResidentARB glad_glMakeImageHandleNonResidentARB
GLAD_API_CALL PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC glad_glMakeImageHandleNonResidentNV;
#define glMakeImageHandleNonResidentNV glad_glMakeImageHandleNonResidentNV
GLAD_API_CALL PFNGLMAKEIMAGEHANDLERESIDENTARBPROC glad_glMakeImageHandleResidentARB;
#define glMakeImageHandleResidentARB glad_glMakeImageHandleResidentARB
GLAD_API_CALL PFNGLMAKEIMAGEHANDLERESIDENTNVPROC glad_glMakeImageHandleResidentNV;
#define glMakeImageHandleResidentNV glad_glMakeImageHandleResidentNV
GLAD_API_CALL PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC glad_glMakeNamedBufferNonResidentNV;
#define glMakeNamedBufferNonResidentNV glad_glMakeNamedBufferNonResidentNV
GLAD_API_CALL PFNGLMAKENAMEDBUFFERRESIDENTNVPROC glad_glMakeNamedBufferResidentNV;
#define glMakeNamedBufferResidentNV glad_glMakeNamedBufferResidentNV
GLAD_API_CALL PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC glad_glMakeTextureHandleNonResidentARB;
#define glMakeTextureHandleNonResidentARB glad_glMakeTextureHandleNonResidentARB
GLAD_API_CALL PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC glad_glMakeTextureHandleNonResidentNV;
#define glMakeTextureHandleNonResidentNV glad_glMakeTextureHandleNonResidentNV
GLAD_API_CALL PFNGLMAKETEXTUREHANDLERESIDENTARBPROC glad_glMakeTextureHandleResidentARB;
#define glMakeTextureHandleResidentARB glad_glMakeTextureHandleResidentARB
GLAD_API_CALL PFNGLMAKETEXTUREHANDLERESIDENTNVPROC glad_glMakeTextureHandleResidentNV;
#define glMakeTextureHandleResidentNV glad_glMakeTextureHandleResidentNV
GLAD_API_CALL PFNGLMAPBUFFERPROC glad_glMapBuffer;
#define glMapBuffer glad_glMapBuffer
GLAD_API_CALL PFNGLMAPBUFFERARBPROC glad_glMapBufferARB;
#define glMapBufferARB glad_glMapBufferARB
GLAD_API_CALL PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;
#define glMapBufferRange glad_glMapBufferRange
GLAD_API_CALL PFNGLMAPCONTROLPOINTSNVPROC glad_glMapControlPointsNV;
#define glMapControlPointsNV glad_glMapControlPointsNV
GLAD_API_CALL PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer;
#define glMapNamedBuffer glad_glMapNamedBuffer
GLAD_API_CALL PFNGLMAPNAMEDBUFFEREXTPROC glad_glMapNamedBufferEXT;
#define glMapNamedBufferEXT glad_glMapNamedBufferEXT
GLAD_API_CALL PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange;
#define glMapNamedBufferRange glad_glMapNamedBufferRange
GLAD_API_CALL PFNGLMAPNAMEDBUFFERRANGEEXTPROC glad_glMapNamedBufferRangeEXT;
#define glMapNamedBufferRangeEXT glad_glMapNamedBufferRangeEXT
GLAD_API_CALL PFNGLMAPOBJECTBUFFERATIPROC glad_glMapObjectBufferATI;
#define glMapObjectBufferATI glad_glMapObjectBufferATI
GLAD_API_CALL PFNGLMAPPARAMETERFVNVPROC glad_glMapParameterfvNV;
#define glMapParameterfvNV glad_glMapParameterfvNV
GLAD_API_CALL PFNGLMAPPARAMETERIVNVPROC glad_glMapParameterivNV;
#define glMapParameterivNV glad_glMapParameterivNV
GLAD_API_CALL PFNGLMAPTEXTURE2DINTELPROC glad_glMapTexture2DINTEL;
#define glMapTexture2DINTEL glad_glMapTexture2DINTEL
GLAD_API_CALL PFNGLMAPVERTEXATTRIB1DAPPLEPROC glad_glMapVertexAttrib1dAPPLE;
#define glMapVertexAttrib1dAPPLE glad_glMapVertexAttrib1dAPPLE
GLAD_API_CALL PFNGLMAPVERTEXATTRIB1FAPPLEPROC glad_glMapVertexAttrib1fAPPLE;
#define glMapVertexAttrib1fAPPLE glad_glMapVertexAttrib1fAPPLE
GLAD_API_CALL PFNGLMAPVERTEXATTRIB2DAPPLEPROC glad_glMapVertexAttrib2dAPPLE;
#define glMapVertexAttrib2dAPPLE glad_glMapVertexAttrib2dAPPLE
GLAD_API_CALL PFNGLMAPVERTEXATTRIB2FAPPLEPROC glad_glMapVertexAttrib2fAPPLE;
#define glMapVertexAttrib2fAPPLE glad_glMapVertexAttrib2fAPPLE
GLAD_API_CALL PFNGLMATRIXFRUSTUMEXTPROC glad_glMatrixFrustumEXT;
#define glMatrixFrustumEXT glad_glMatrixFrustumEXT
GLAD_API_CALL PFNGLMATRIXINDEXPOINTERARBPROC glad_glMatrixIndexPointerARB;
#define glMatrixIndexPointerARB glad_glMatrixIndexPointerARB
GLAD_API_CALL PFNGLMATRIXINDEXUBVARBPROC glad_glMatrixIndexubvARB;
#define glMatrixIndexubvARB glad_glMatrixIndexubvARB
GLAD_API_CALL PFNGLMATRIXINDEXUIVARBPROC glad_glMatrixIndexuivARB;
#define glMatrixIndexuivARB glad_glMatrixIndexuivARB
GLAD_API_CALL PFNGLMATRIXINDEXUSVARBPROC glad_glMatrixIndexusvARB;
#define glMatrixIndexusvARB glad_glMatrixIndexusvARB
GLAD_API_CALL PFNGLMATRIXLOAD3X2FNVPROC glad_glMatrixLoad3x2fNV;
#define glMatrixLoad3x2fNV glad_glMatrixLoad3x2fNV
GLAD_API_CALL PFNGLMATRIXLOAD3X3FNVPROC glad_glMatrixLoad3x3fNV;
#define glMatrixLoad3x3fNV glad_glMatrixLoad3x3fNV
GLAD_API_CALL PFNGLMATRIXLOADIDENTITYEXTPROC glad_glMatrixLoadIdentityEXT;
#define glMatrixLoadIdentityEXT glad_glMatrixLoadIdentityEXT
GLAD_API_CALL PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC glad_glMatrixLoadTranspose3x3fNV;
#define glMatrixLoadTranspose3x3fNV glad_glMatrixLoadTranspose3x3fNV
GLAD_API_CALL PFNGLMATRIXLOADTRANSPOSEDEXTPROC glad_glMatrixLoadTransposedEXT;
#define glMatrixLoadTransposedEXT glad_glMatrixLoadTransposedEXT
GLAD_API_CALL PFNGLMATRIXLOADTRANSPOSEFEXTPROC glad_glMatrixLoadTransposefEXT;
#define glMatrixLoadTransposefEXT glad_glMatrixLoadTransposefEXT
GLAD_API_CALL PFNGLMATRIXLOADDEXTPROC glad_glMatrixLoaddEXT;
#define glMatrixLoaddEXT glad_glMatrixLoaddEXT
GLAD_API_CALL PFNGLMATRIXLOADFEXTPROC glad_glMatrixLoadfEXT;
#define glMatrixLoadfEXT glad_glMatrixLoadfEXT
GLAD_API_CALL PFNGLMATRIXMULT3X2FNVPROC glad_glMatrixMult3x2fNV;
#define glMatrixMult3x2fNV glad_glMatrixMult3x2fNV
GLAD_API_CALL PFNGLMATRIXMULT3X3FNVPROC glad_glMatrixMult3x3fNV;
#define glMatrixMult3x3fNV glad_glMatrixMult3x3fNV
GLAD_API_CALL PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC glad_glMatrixMultTranspose3x3fNV;
#define glMatrixMultTranspose3x3fNV glad_glMatrixMultTranspose3x3fNV
GLAD_API_CALL PFNGLMATRIXMULTTRANSPOSEDEXTPROC glad_glMatrixMultTransposedEXT;
#define glMatrixMultTransposedEXT glad_glMatrixMultTransposedEXT
GLAD_API_CALL PFNGLMATRIXMULTTRANSPOSEFEXTPROC glad_glMatrixMultTransposefEXT;
#define glMatrixMultTransposefEXT glad_glMatrixMultTransposefEXT
GLAD_API_CALL PFNGLMATRIXMULTDEXTPROC glad_glMatrixMultdEXT;
#define glMatrixMultdEXT glad_glMatrixMultdEXT
GLAD_API_CALL PFNGLMATRIXMULTFEXTPROC glad_glMatrixMultfEXT;
#define glMatrixMultfEXT glad_glMatrixMultfEXT
GLAD_API_CALL PFNGLMATRIXORTHOEXTPROC glad_glMatrixOrthoEXT;
#define glMatrixOrthoEXT glad_glMatrixOrthoEXT
GLAD_API_CALL PFNGLMATRIXPOPEXTPROC glad_glMatrixPopEXT;
#define glMatrixPopEXT glad_glMatrixPopEXT
GLAD_API_CALL PFNGLMATRIXPUSHEXTPROC glad_glMatrixPushEXT;
#define glMatrixPushEXT glad_glMatrixPushEXT
GLAD_API_CALL PFNGLMATRIXROTATEDEXTPROC glad_glMatrixRotatedEXT;
#define glMatrixRotatedEXT glad_glMatrixRotatedEXT
GLAD_API_CALL PFNGLMATRIXROTATEFEXTPROC glad_glMatrixRotatefEXT;
#define glMatrixRotatefEXT glad_glMatrixRotatefEXT
GLAD_API_CALL PFNGLMATRIXSCALEDEXTPROC glad_glMatrixScaledEXT;
#define glMatrixScaledEXT glad_glMatrixScaledEXT
GLAD_API_CALL PFNGLMATRIXSCALEFEXTPROC glad_glMatrixScalefEXT;
#define glMatrixScalefEXT glad_glMatrixScalefEXT
GLAD_API_CALL PFNGLMATRIXTRANSLATEDEXTPROC glad_glMatrixTranslatedEXT;
#define glMatrixTranslatedEXT glad_glMatrixTranslatedEXT
GLAD_API_CALL PFNGLMATRIXTRANSLATEFEXTPROC glad_glMatrixTranslatefEXT;
#define glMatrixTranslatefEXT glad_glMatrixTranslatefEXT
GLAD_API_CALL PFNGLMAXSHADERCOMPILERTHREADSARBPROC glad_glMaxShaderCompilerThreadsARB;
#define glMaxShaderCompilerThreadsARB glad_glMaxShaderCompilerThreadsARB
GLAD_API_CALL PFNGLMAXSHADERCOMPILERTHREADSKHRPROC glad_glMaxShaderCompilerThreadsKHR;
#define glMaxShaderCompilerThreadsKHR glad_glMaxShaderCompilerThreadsKHR
GLAD_API_CALL PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier;
#define glMemoryBarrier glad_glMemoryBarrier
GLAD_API_CALL PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion;
#define glMemoryBarrierByRegion glad_glMemoryBarrierByRegion
GLAD_API_CALL PFNGLMEMORYBARRIEREXTPROC glad_glMemoryBarrierEXT;
#define glMemoryBarrierEXT glad_glMemoryBarrierEXT
GLAD_API_CALL PFNGLMEMORYOBJECTPARAMETERIVEXTPROC glad_glMemoryObjectParameterivEXT;
#define glMemoryObjectParameterivEXT glad_glMemoryObjectParameterivEXT
GLAD_API_CALL PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading;
#define glMinSampleShading glad_glMinSampleShading
GLAD_API_CALL PFNGLMINSAMPLESHADINGARBPROC glad_glMinSampleShadingARB;
#define glMinSampleShadingARB glad_glMinSampleShadingARB
GLAD_API_CALL PFNGLMINMAXPROC glad_glMinmax;
#define glMinmax glad_glMinmax
GLAD_API_CALL PFNGLMINMAXEXTPROC glad_glMinmaxEXT;
#define glMinmaxEXT glad_glMinmaxEXT
GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXDPROC glad_glMultTransposeMatrixd;
#define glMultTransposeMatrixd glad_glMultTransposeMatrixd
GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXDARBPROC glad_glMultTransposeMatrixdARB;
#define glMultTransposeMatrixdARB glad_glMultTransposeMatrixdARB
GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXFPROC glad_glMultTransposeMatrixf;
#define glMultTransposeMatrixf glad_glMultTransposeMatrixf
GLAD_API_CALL PFNGLMULTTRANSPOSEMATRIXFARBPROC glad_glMultTransposeMatrixfARB;
#define glMultTransposeMatrixfARB glad_glMultTransposeMatrixfARB
GLAD_API_CALL PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;
#define glMultiDrawArrays glad_glMultiDrawArrays
GLAD_API_CALL PFNGLMULTIDRAWARRAYSEXTPROC glad_glMultiDrawArraysEXT;
#define glMultiDrawArraysEXT glad_glMultiDrawArraysEXT
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect;
#define glMultiDrawArraysIndirect glad_glMultiDrawArraysIndirect
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC glad_glMultiDrawArraysIndirectAMD;
#define glMultiDrawArraysIndirectAMD glad_glMultiDrawArraysIndirectAMD
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC glad_glMultiDrawArraysIndirectBindlessCountNV;
#define glMultiDrawArraysIndirectBindlessCountNV glad_glMultiDrawArraysIndirectBindlessCountNV
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC glad_glMultiDrawArraysIndirectBindlessNV;
#define glMultiDrawArraysIndirectBindlessNV glad_glMultiDrawArraysIndirectBindlessNV
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount;
#define glMultiDrawArraysIndirectCount glad_glMultiDrawArraysIndirectCount
GLAD_API_CALL PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC glad_glMultiDrawArraysIndirectCountARB;
#define glMultiDrawArraysIndirectCountARB glad_glMultiDrawArraysIndirectCountARB
GLAD_API_CALL PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC glad_glMultiDrawElementArrayAPPLE;
#define glMultiDrawElementArrayAPPLE glad_glMultiDrawElementArrayAPPLE
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;
#define glMultiDrawElements glad_glMultiDrawElements
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;
#define glMultiDrawElementsBaseVertex glad_glMultiDrawElementsBaseVertex
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSEXTPROC glad_glMultiDrawElementsEXT;
#define glMultiDrawElementsEXT glad_glMultiDrawElementsEXT
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect;
#define glMultiDrawElementsIndirect glad_glMultiDrawElementsIndirect
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC glad_glMultiDrawElementsIndirectAMD;
#define glMultiDrawElementsIndirectAMD glad_glMultiDrawElementsIndirectAMD
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC glad_glMultiDrawElementsIndirectBindlessCountNV;
#define glMultiDrawElementsIndirectBindlessCountNV glad_glMultiDrawElementsIndirectBindlessCountNV
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC glad_glMultiDrawElementsIndirectBindlessNV;
#define glMultiDrawElementsIndirectBindlessNV glad_glMultiDrawElementsIndirectBindlessNV
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount;
#define glMultiDrawElementsIndirectCount glad_glMultiDrawElementsIndirectCount
GLAD_API_CALL PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC glad_glMultiDrawElementsIndirectCountARB;
#define glMultiDrawElementsIndirectCountARB glad_glMultiDrawElementsIndirectCountARB
GLAD_API_CALL PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC glad_glMultiDrawRangeElementArrayAPPLE;
#define glMultiDrawRangeElementArrayAPPLE glad_glMultiDrawRangeElementArrayAPPLE
GLAD_API_CALL PFNGLMULTITEXBUFFEREXTPROC glad_glMultiTexBufferEXT;
#define glMultiTexBufferEXT glad_glMultiTexBufferEXT
GLAD_API_CALL PFNGLMULTITEXCOORD1DPROC glad_glMultiTexCoord1d;
#define glMultiTexCoord1d glad_glMultiTexCoord1d
GLAD_API_CALL PFNGLMULTITEXCOORD1DARBPROC glad_glMultiTexCoord1dARB;
#define glMultiTexCoord1dARB glad_glMultiTexCoord1dARB
GLAD_API_CALL PFNGLMULTITEXCOORD1DVPROC glad_glMultiTexCoord1dv;
#define glMultiTexCoord1dv glad_glMultiTexCoord1dv
GLAD_API_CALL PFNGLMULTITEXCOORD1DVARBPROC glad_glMultiTexCoord1dvARB;
#define glMultiTexCoord1dvARB glad_glMultiTexCoord1dvARB
GLAD_API_CALL PFNGLMULTITEXCOORD1FPROC glad_glMultiTexCoord1f;
#define glMultiTexCoord1f glad_glMultiTexCoord1f
GLAD_API_CALL PFNGLMULTITEXCOORD1FARBPROC glad_glMultiTexCoord1fARB;
#define glMultiTexCoord1fARB glad_glMultiTexCoord1fARB
GLAD_API_CALL PFNGLMULTITEXCOORD1FVPROC glad_glMultiTexCoord1fv;
#define glMultiTexCoord1fv glad_glMultiTexCoord1fv
GLAD_API_CALL PFNGLMULTITEXCOORD1FVARBPROC glad_glMultiTexCoord1fvARB;
#define glMultiTexCoord1fvARB glad_glMultiTexCoord1fvARB
GLAD_API_CALL PFNGLMULTITEXCOORD1HNVPROC glad_glMultiTexCoord1hNV;
#define glMultiTexCoord1hNV glad_glMultiTexCoord1hNV
GLAD_API_CALL PFNGLMULTITEXCOORD1HVNVPROC glad_glMultiTexCoord1hvNV;
#define glMultiTexCoord1hvNV glad_glMultiTexCoord1hvNV
GLAD_API_CALL PFNGLMULTITEXCOORD1IPROC glad_glMultiTexCoord1i;
#define glMultiTexCoord1i glad_glMultiTexCoord1i
GLAD_API_CALL PFNGLMULTITEXCOORD1IARBPROC glad_glMultiTexCoord1iARB;
#define glMultiTexCoord1iARB glad_glMultiTexCoord1iARB
GLAD_API_CALL PFNGLMULTITEXCOORD1IVPROC glad_glMultiTexCoord1iv;
#define glMultiTexCoord1iv glad_glMultiTexCoord1iv
GLAD_API_CALL PFNGLMULTITEXCOORD1IVARBPROC glad_glMultiTexCoord1ivARB;
#define glMultiTexCoord1ivARB glad_glMultiTexCoord1ivARB
GLAD_API_CALL PFNGLMULTITEXCOORD1SPROC glad_glMultiTexCoord1s;
#define glMultiTexCoord1s glad_glMultiTexCoord1s
GLAD_API_CALL PFNGLMULTITEXCOORD1SARBPROC glad_glMultiTexCoord1sARB;
#define glMultiTexCoord1sARB glad_glMultiTexCoord1sARB
GLAD_API_CALL PFNGLMULTITEXCOORD1SVPROC glad_glMultiTexCoord1sv;
#define glMultiTexCoord1sv glad_glMultiTexCoord1sv
GLAD_API_CALL PFNGLMULTITEXCOORD1SVARBPROC glad_glMultiTexCoord1svARB;
#define glMultiTexCoord1svARB glad_glMultiTexCoord1svARB
GLAD_API_CALL PFNGLMULTITEXCOORD2DPROC glad_glMultiTexCoord2d;
#define glMultiTexCoord2d glad_glMultiTexCoord2d
GLAD_API_CALL PFNGLMULTITEXCOORD2DARBPROC glad_glMultiTexCoord2dARB;
#define glMultiTexCoord2dARB glad_glMultiTexCoord2dARB
GLAD_API_CALL PFNGLMULTITEXCOORD2DVPROC glad_glMultiTexCoord2dv;
#define glMultiTexCoord2dv glad_glMultiTexCoord2dv
GLAD_API_CALL PFNGLMULTITEXCOORD2DVARBPROC glad_glMultiTexCoord2dvARB;
#define glMultiTexCoord2dvARB glad_glMultiTexCoord2dvARB
GLAD_API_CALL PFNGLMULTITEXCOORD2FPROC glad_glMultiTexCoord2f;
#define glMultiTexCoord2f glad_glMultiTexCoord2f
GLAD_API_CALL PFNGLMULTITEXCOORD2FARBPROC glad_glMultiTexCoord2fARB;
#define glMultiTexCoord2fARB glad_glMultiTexCoord2fARB
GLAD_API_CALL PFNGLMULTITEXCOORD2FVPROC glad_glMultiTexCoord2fv;
#define glMultiTexCoord2fv glad_glMultiTexCoord2fv
GLAD_API_CALL PFNGLMULTITEXCOORD2FVARBPROC glad_glMultiTexCoord2fvARB;
#define glMultiTexCoord2fvARB glad_glMultiTexCoord2fvARB
GLAD_API_CALL PFNGLMULTITEXCOORD2HNVPROC glad_glMultiTexCoord2hNV;
#define glMultiTexCoord2hNV glad_glMultiTexCoord2hNV
GLAD_API_CALL PFNGLMULTITEXCOORD2HVNVPROC glad_glMultiTexCoord2hvNV;
#define glMultiTexCoord2hvNV glad_glMultiTexCoord2hvNV
GLAD_API_CALL PFNGLMULTITEXCOORD2IPROC glad_glMultiTexCoord2i;
#define glMultiTexCoord2i glad_glMultiTexCoord2i
GLAD_API_CALL PFNGLMULTITEXCOORD2IARBPROC glad_glMultiTexCoord2iARB;
#define glMultiTexCoord2iARB glad_glMultiTexCoord2iARB
GLAD_API_CALL PFNGLMULTITEXCOORD2IVPROC glad_glMultiTexCoord2iv;
#define glMultiTexCoord2iv glad_glMultiTexCoord2iv
GLAD_API_CALL PFNGLMULTITEXCOORD2IVARBPROC glad_glMultiTexCoord2ivARB;
#define glMultiTexCoord2ivARB glad_glMultiTexCoord2ivARB
GLAD_API_CALL PFNGLMULTITEXCOORD2SPROC glad_glMultiTexCoord2s;
#define glMultiTexCoord2s glad_glMultiTexCoord2s
GLAD_API_CALL PFNGLMULTITEXCOORD2SARBPROC glad_glMultiTexCoord2sARB;
#define glMultiTexCoord2sARB glad_glMultiTexCoord2sARB
GLAD_API_CALL PFNGLMULTITEXCOORD2SVPROC glad_glMultiTexCoord2sv;
#define glMultiTexCoord2sv glad_glMultiTexCoord2sv
GLAD_API_CALL PFNGLMULTITEXCOORD2SVARBPROC glad_glMultiTexCoord2svARB;
#define glMultiTexCoord2svARB glad_glMultiTexCoord2svARB
GLAD_API_CALL PFNGLMULTITEXCOORD3DPROC glad_glMultiTexCoord3d;
#define glMultiTexCoord3d glad_glMultiTexCoord3d
GLAD_API_CALL PFNGLMULTITEXCOORD3DARBPROC glad_glMultiTexCoord3dARB;
#define glMultiTexCoord3dARB glad_glMultiTexCoord3dARB
GLAD_API_CALL PFNGLMULTITEXCOORD3DVPROC glad_glMultiTexCoord3dv;
#define glMultiTexCoord3dv glad_glMultiTexCoord3dv
GLAD_API_CALL PFNGLMULTITEXCOORD3DVARBPROC glad_glMultiTexCoord3dvARB;
#define glMultiTexCoord3dvARB glad_glMultiTexCoord3dvARB
GLAD_API_CALL PFNGLMULTITEXCOORD3FPROC glad_glMultiTexCoord3f;
#define glMultiTexCoord3f glad_glMultiTexCoord3f
GLAD_API_CALL PFNGLMULTITEXCOORD3FARBPROC glad_glMultiTexCoord3fARB;
#define glMultiTexCoord3fARB glad_glMultiTexCoord3fARB
GLAD_API_CALL PFNGLMULTITEXCOORD3FVPROC glad_glMultiTexCoord3fv;
#define glMultiTexCoord3fv glad_glMultiTexCoord3fv
GLAD_API_CALL PFNGLMULTITEXCOORD3FVARBPROC glad_glMultiTexCoord3fvARB;
#define glMultiTexCoord3fvARB glad_glMultiTexCoord3fvARB
GLAD_API_CALL PFNGLMULTITEXCOORD3HNVPROC glad_glMultiTexCoord3hNV;
#define glMultiTexCoord3hNV glad_glMultiTexCoord3hNV
GLAD_API_CALL PFNGLMULTITEXCOORD3HVNVPROC glad_glMultiTexCoord3hvNV;
#define glMultiTexCoord3hvNV glad_glMultiTexCoord3hvNV
GLAD_API_CALL PFNGLMULTITEXCOORD3IPROC glad_glMultiTexCoord3i;
#define glMultiTexCoord3i glad_glMultiTexCoord3i
GLAD_API_CALL PFNGLMULTITEXCOORD3IARBPROC glad_glMultiTexCoord3iARB;
#define glMultiTexCoord3iARB glad_glMultiTexCoord3iARB
GLAD_API_CALL PFNGLMULTITEXCOORD3IVPROC glad_glMultiTexCoord3iv;
#define glMultiTexCoord3iv glad_glMultiTexCoord3iv
GLAD_API_CALL PFNGLMULTITEXCOORD3IVARBPROC glad_glMultiTexCoord3ivARB;
#define glMultiTexCoord3ivARB glad_glMultiTexCoord3ivARB
GLAD_API_CALL PFNGLMULTITEXCOORD3SPROC glad_glMultiTexCoord3s;
#define glMultiTexCoord3s glad_glMultiTexCoord3s
GLAD_API_CALL PFNGLMULTITEXCOORD3SARBPROC glad_glMultiTexCoord3sARB;
#define glMultiTexCoord3sARB glad_glMultiTexCoord3sARB
GLAD_API_CALL PFNGLMULTITEXCOORD3SVPROC glad_glMultiTexCoord3sv;
#define glMultiTexCoord3sv glad_glMultiTexCoord3sv
GLAD_API_CALL PFNGLMULTITEXCOORD3SVARBPROC glad_glMultiTexCoord3svARB;
#define glMultiTexCoord3svARB glad_glMultiTexCoord3svARB
GLAD_API_CALL PFNGLMULTITEXCOORD4DPROC glad_glMultiTexCoord4d;
#define glMultiTexCoord4d glad_glMultiTexCoord4d
GLAD_API_CALL PFNGLMULTITEXCOORD4DARBPROC glad_glMultiTexCoord4dARB;
#define glMultiTexCoord4dARB glad_glMultiTexCoord4dARB
GLAD_API_CALL PFNGLMULTITEXCOORD4DVPROC glad_glMultiTexCoord4dv;
#define glMultiTexCoord4dv glad_glMultiTexCoord4dv
GLAD_API_CALL PFNGLMULTITEXCOORD4DVARBPROC glad_glMultiTexCoord4dvARB;
#define glMultiTexCoord4dvARB glad_glMultiTexCoord4dvARB
GLAD_API_CALL PFNGLMULTITEXCOORD4FPROC glad_glMultiTexCoord4f;
#define glMultiTexCoord4f glad_glMultiTexCoord4f
GLAD_API_CALL PFNGLMULTITEXCOORD4FARBPROC glad_glMultiTexCoord4fARB;
#define glMultiTexCoord4fARB glad_glMultiTexCoord4fARB
GLAD_API_CALL PFNGLMULTITEXCOORD4FVPROC glad_glMultiTexCoord4fv;
#define glMultiTexCoord4fv glad_glMultiTexCoord4fv
GLAD_API_CALL PFNGLMULTITEXCOORD4FVARBPROC glad_glMultiTexCoord4fvARB;
#define glMultiTexCoord4fvARB glad_glMultiTexCoord4fvARB
GLAD_API_CALL PFNGLMULTITEXCOORD4HNVPROC glad_glMultiTexCoord4hNV;
#define glMultiTexCoord4hNV glad_glMultiTexCoord4hNV
GLAD_API_CALL PFNGLMULTITEXCOORD4HVNVPROC glad_glMultiTexCoord4hvNV;
#define glMultiTexCoord4hvNV glad_glMultiTexCoord4hvNV
GLAD_API_CALL PFNGLMULTITEXCOORD4IPROC glad_glMultiTexCoord4i;
#define glMultiTexCoord4i glad_glMultiTexCoord4i
GLAD_API_CALL PFNGLMULTITEXCOORD4IARBPROC glad_glMultiTexCoord4iARB;
#define glMultiTexCoord4iARB glad_glMultiTexCoord4iARB
GLAD_API_CALL PFNGLMULTITEXCOORD4IVPROC glad_glMultiTexCoord4iv;
#define glMultiTexCoord4iv glad_glMultiTexCoord4iv
GLAD_API_CALL PFNGLMULTITEXCOORD4IVARBPROC glad_glMultiTexCoord4ivARB;
#define glMultiTexCoord4ivARB glad_glMultiTexCoord4ivARB
GLAD_API_CALL PFNGLMULTITEXCOORD4SPROC glad_glMultiTexCoord4s;
#define glMultiTexCoord4s glad_glMultiTexCoord4s
GLAD_API_CALL PFNGLMULTITEXCOORD4SARBPROC glad_glMultiTexCoord4sARB;
#define glMultiTexCoord4sARB glad_glMultiTexCoord4sARB
GLAD_API_CALL PFNGLMULTITEXCOORD4SVPROC glad_glMultiTexCoord4sv;
#define glMultiTexCoord4sv glad_glMultiTexCoord4sv
GLAD_API_CALL PFNGLMULTITEXCOORD4SVARBPROC glad_glMultiTexCoord4svARB;
#define glMultiTexCoord4svARB glad_glMultiTexCoord4svARB
GLAD_API_CALL PFNGLMULTITEXCOORDPOINTEREXTPROC glad_glMultiTexCoordPointerEXT;
#define glMultiTexCoordPointerEXT glad_glMultiTexCoordPointerEXT
GLAD_API_CALL PFNGLMULTITEXENVFEXTPROC glad_glMultiTexEnvfEXT;
#define glMultiTexEnvfEXT glad_glMultiTexEnvfEXT
GLAD_API_CALL PFNGLMULTITEXENVFVEXTPROC glad_glMultiTexEnvfvEXT;
#define glMultiTexEnvfvEXT glad_glMultiTexEnvfvEXT
GLAD_API_CALL PFNGLMULTITEXENVIEXTPROC glad_glMultiTexEnviEXT;
#define glMultiTexEnviEXT glad_glMultiTexEnviEXT
GLAD_API_CALL PFNGLMULTITEXENVIVEXTPROC glad_glMultiTexEnvivEXT;
#define glMultiTexEnvivEXT glad_glMultiTexEnvivEXT
GLAD_API_CALL PFNGLMULTITEXGENDEXTPROC glad_glMultiTexGendEXT;
#define glMultiTexGendEXT glad_glMultiTexGendEXT
GLAD_API_CALL PFNGLMULTITEXGENDVEXTPROC glad_glMultiTexGendvEXT;
#define glMultiTexGendvEXT glad_glMultiTexGendvEXT
GLAD_API_CALL PFNGLMULTITEXGENFEXTPROC glad_glMultiTexGenfEXT;
#define glMultiTexGenfEXT glad_glMultiTexGenfEXT
GLAD_API_CALL PFNGLMULTITEXGENFVEXTPROC glad_glMultiTexGenfvEXT;
#define glMultiTexGenfvEXT glad_glMultiTexGenfvEXT
GLAD_API_CALL PFNGLMULTITEXGENIEXTPROC glad_glMultiTexGeniEXT;
#define glMultiTexGeniEXT glad_glMultiTexGeniEXT
GLAD_API_CALL PFNGLMULTITEXGENIVEXTPROC glad_glMultiTexGenivEXT;
#define glMultiTexGenivEXT glad_glMultiTexGenivEXT
GLAD_API_CALL PFNGLMULTITEXIMAGE1DEXTPROC glad_glMultiTexImage1DEXT;
#define glMultiTexImage1DEXT glad_glMultiTexImage1DEXT
GLAD_API_CALL PFNGLMULTITEXIMAGE2DEXTPROC glad_glMultiTexImage2DEXT;
#define glMultiTexImage2DEXT glad_glMultiTexImage2DEXT
GLAD_API_CALL PFNGLMULTITEXIMAGE3DEXTPROC glad_glMultiTexImage3DEXT;
#define glMultiTexImage3DEXT glad_glMultiTexImage3DEXT
GLAD_API_CALL PFNGLMULTITEXPARAMETERIIVEXTPROC glad_glMultiTexParameterIivEXT;
#define glMultiTexParameterIivEXT glad_glMultiTexParameterIivEXT
GLAD_API_CALL PFNGLMULTITEXPARAMETERIUIVEXTPROC glad_glMultiTexParameterIuivEXT;
#define glMultiTexParameterIuivEXT glad_glMultiTexParameterIuivEXT
GLAD_API_CALL PFNGLMULTITEXPARAMETERFEXTPROC glad_glMultiTexParameterfEXT;
#define glMultiTexParameterfEXT glad_glMultiTexParameterfEXT
GLAD_API_CALL PFNGLMULTITEXPARAMETERFVEXTPROC glad_glMultiTexParameterfvEXT;
#define glMultiTexParameterfvEXT glad_glMultiTexParameterfvEXT
GLAD_API_CALL PFNGLMULTITEXPARAMETERIEXTPROC glad_glMultiTexParameteriEXT;
#define glMultiTexParameteriEXT glad_glMultiTexParameteriEXT
GLAD_API_CALL PFNGLMULTITEXPARAMETERIVEXTPROC glad_glMultiTexParameterivEXT;
#define glMultiTexParameterivEXT glad_glMultiTexParameterivEXT
GLAD_API_CALL PFNGLMULTITEXRENDERBUFFEREXTPROC glad_glMultiTexRenderbufferEXT;
#define glMultiTexRenderbufferEXT glad_glMultiTexRenderbufferEXT
GLAD_API_CALL PFNGLMULTITEXSUBIMAGE1DEXTPROC glad_glMultiTexSubImage1DEXT;
#define glMultiTexSubImage1DEXT glad_glMultiTexSubImage1DEXT
GLAD_API_CALL PFNGLMULTITEXSUBIMAGE2DEXTPROC glad_glMultiTexSubImage2DEXT;
#define glMultiTexSubImage2DEXT glad_glMultiTexSubImage2DEXT
GLAD_API_CALL PFNGLMULTITEXSUBIMAGE3DEXTPROC glad_glMultiTexSubImage3DEXT;
#define glMultiTexSubImage3DEXT glad_glMultiTexSubImage3DEXT
GLAD_API_CALL PFNGLMULTICASTBARRIERNVPROC glad_glMulticastBarrierNV;
#define glMulticastBarrierNV glad_glMulticastBarrierNV
GLAD_API_CALL PFNGLMULTICASTBLITFRAMEBUFFERNVPROC glad_glMulticastBlitFramebufferNV;
#define glMulticastBlitFramebufferNV glad_glMulticastBlitFramebufferNV
GLAD_API_CALL PFNGLMULTICASTBUFFERSUBDATANVPROC glad_glMulticastBufferSubDataNV;
#define glMulticastBufferSubDataNV glad_glMulticastBufferSubDataNV
GLAD_API_CALL PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC glad_glMulticastCopyBufferSubDataNV;
#define glMulticastCopyBufferSubDataNV glad_glMulticastCopyBufferSubDataNV
GLAD_API_CALL PFNGLMULTICASTCOPYIMAGESUBDATANVPROC glad_glMulticastCopyImageSubDataNV;
#define glMulticastCopyImageSubDataNV glad_glMulticastCopyImageSubDataNV
GLAD_API_CALL PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glMulticastFramebufferSampleLocationsfvNV;
#define glMulticastFramebufferSampleLocationsfvNV glad_glMulticastFramebufferSampleLocationsfvNV
GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC glad_glMulticastGetQueryObjecti64vNV;
#define glMulticastGetQueryObjecti64vNV glad_glMulticastGetQueryObjecti64vNV
GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTIVNVPROC glad_glMulticastGetQueryObjectivNV;
#define glMulticastGetQueryObjectivNV glad_glMulticastGetQueryObjectivNV
GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC glad_glMulticastGetQueryObjectui64vNV;
#define glMulticastGetQueryObjectui64vNV glad_glMulticastGetQueryObjectui64vNV
GLAD_API_CALL PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC glad_glMulticastGetQueryObjectuivNV;
#define glMulticastGetQueryObjectuivNV glad_glMulticastGetQueryObjectuivNV
GLAD_API_CALL PFNGLMULTICASTWAITSYNCNVPROC glad_glMulticastWaitSyncNV;
#define glMulticastWaitSyncNV glad_glMulticastWaitSyncNV
GLAD_API_CALL PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData;
#define glNamedBufferData glad_glNamedBufferData
GLAD_API_CALL PFNGLNAMEDBUFFERDATAEXTPROC glad_glNamedBufferDataEXT;
#define glNamedBufferDataEXT glad_glNamedBufferDataEXT
GLAD_API_CALL PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC glad_glNamedBufferPageCommitmentARB;
#define glNamedBufferPageCommitmentARB glad_glNamedBufferPageCommitmentARB
GLAD_API_CALL PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC glad_glNamedBufferPageCommitmentEXT;
#define glNamedBufferPageCommitmentEXT glad_glNamedBufferPageCommitmentEXT
GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage;
#define glNamedBufferStorage glad_glNamedBufferStorage
GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEEXTPROC glad_glNamedBufferStorageEXT;
#define glNamedBufferStorageEXT glad_glNamedBufferStorageEXT
GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC glad_glNamedBufferStorageExternalEXT;
#define glNamedBufferStorageExternalEXT glad_glNamedBufferStorageExternalEXT
GLAD_API_CALL PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC glad_glNamedBufferStorageMemEXT;
#define glNamedBufferStorageMemEXT glad_glNamedBufferStorageMemEXT
GLAD_API_CALL PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData;
#define glNamedBufferSubData glad_glNamedBufferSubData
GLAD_API_CALL PFNGLNAMEDBUFFERSUBDATAEXTPROC glad_glNamedBufferSubDataEXT;
#define glNamedBufferSubDataEXT glad_glNamedBufferSubDataEXT
GLAD_API_CALL PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC glad_glNamedCopyBufferSubDataEXT;
#define glNamedCopyBufferSubDataEXT glad_glNamedCopyBufferSubDataEXT
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer;
#define glNamedFramebufferDrawBuffer glad_glNamedFramebufferDrawBuffer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers;
#define glNamedFramebufferDrawBuffers glad_glNamedFramebufferDrawBuffers
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri;
#define glNamedFramebufferParameteri glad_glNamedFramebufferParameteri
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC glad_glNamedFramebufferParameteriEXT;
#define glNamedFramebufferParameteriEXT glad_glNamedFramebufferParameteriEXT
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer;
#define glNamedFramebufferReadBuffer glad_glNamedFramebufferReadBuffer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer;
#define glNamedFramebufferRenderbuffer glad_glNamedFramebufferRenderbuffer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC glad_glNamedFramebufferRenderbufferEXT;
#define glNamedFramebufferRenderbufferEXT glad_glNamedFramebufferRenderbufferEXT
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glad_glNamedFramebufferSampleLocationsfvARB;
#define glNamedFramebufferSampleLocationsfvARB glad_glNamedFramebufferSampleLocationsfvARB
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glNamedFramebufferSampleLocationsfvNV;
#define glNamedFramebufferSampleLocationsfvNV glad_glNamedFramebufferSampleLocationsfvNV
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC glad_glNamedFramebufferSamplePositionsfvAMD;
#define glNamedFramebufferSamplePositionsfvAMD glad_glNamedFramebufferSamplePositionsfvAMD
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture;
#define glNamedFramebufferTexture glad_glNamedFramebufferTexture
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC glad_glNamedFramebufferTexture1DEXT;
#define glNamedFramebufferTexture1DEXT glad_glNamedFramebufferTexture1DEXT
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC glad_glNamedFramebufferTexture2DEXT;
#define glNamedFramebufferTexture2DEXT glad_glNamedFramebufferTexture2DEXT
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC glad_glNamedFramebufferTexture3DEXT;
#define glNamedFramebufferTexture3DEXT glad_glNamedFramebufferTexture3DEXT
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC glad_glNamedFramebufferTextureEXT;
#define glNamedFramebufferTextureEXT glad_glNamedFramebufferTextureEXT
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC glad_glNamedFramebufferTextureFaceEXT;
#define glNamedFramebufferTextureFaceEXT glad_glNamedFramebufferTextureFaceEXT
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer;
#define glNamedFramebufferTextureLayer glad_glNamedFramebufferTextureLayer
GLAD_API_CALL PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC glad_glNamedFramebufferTextureLayerEXT;
#define glNamedFramebufferTextureLayerEXT glad_glNamedFramebufferTextureLayerEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC glad_glNamedProgramLocalParameter4dEXT;
#define glNamedProgramLocalParameter4dEXT glad_glNamedProgramLocalParameter4dEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC glad_glNamedProgramLocalParameter4dvEXT;
#define glNamedProgramLocalParameter4dvEXT glad_glNamedProgramLocalParameter4dvEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC glad_glNamedProgramLocalParameter4fEXT;
#define glNamedProgramLocalParameter4fEXT glad_glNamedProgramLocalParameter4fEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC glad_glNamedProgramLocalParameter4fvEXT;
#define glNamedProgramLocalParameter4fvEXT glad_glNamedProgramLocalParameter4fvEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC glad_glNamedProgramLocalParameterI4iEXT;
#define glNamedProgramLocalParameterI4iEXT glad_glNamedProgramLocalParameterI4iEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC glad_glNamedProgramLocalParameterI4ivEXT;
#define glNamedProgramLocalParameterI4ivEXT glad_glNamedProgramLocalParameterI4ivEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC glad_glNamedProgramLocalParameterI4uiEXT;
#define glNamedProgramLocalParameterI4uiEXT glad_glNamedProgramLocalParameterI4uiEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC glad_glNamedProgramLocalParameterI4uivEXT;
#define glNamedProgramLocalParameterI4uivEXT glad_glNamedProgramLocalParameterI4uivEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC glad_glNamedProgramLocalParameters4fvEXT;
#define glNamedProgramLocalParameters4fvEXT glad_glNamedProgramLocalParameters4fvEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC glad_glNamedProgramLocalParametersI4ivEXT;
#define glNamedProgramLocalParametersI4ivEXT glad_glNamedProgramLocalParametersI4ivEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC glad_glNamedProgramLocalParametersI4uivEXT;
#define glNamedProgramLocalParametersI4uivEXT glad_glNamedProgramLocalParametersI4uivEXT
GLAD_API_CALL PFNGLNAMEDPROGRAMSTRINGEXTPROC glad_glNamedProgramStringEXT;
#define glNamedProgramStringEXT glad_glNamedProgramStringEXT
GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage;
#define glNamedRenderbufferStorage glad_glNamedRenderbufferStorage
GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC glad_glNamedRenderbufferStorageEXT;
#define glNamedRenderbufferStorageEXT glad_glNamedRenderbufferStorageEXT
GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample;
#define glNamedRenderbufferStorageMultisample glad_glNamedRenderbufferStorageMultisample
GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC glad_glNamedRenderbufferStorageMultisampleCoverageEXT;
#define glNamedRenderbufferStorageMultisampleCoverageEXT glad_glNamedRenderbufferStorageMultisampleCoverageEXT
GLAD_API_CALL PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC glad_glNamedRenderbufferStorageMultisampleEXT;
#define glNamedRenderbufferStorageMultisampleEXT glad_glNamedRenderbufferStorageMultisampleEXT
GLAD_API_CALL PFNGLNAMEDSTRINGARBPROC glad_glNamedStringARB;
#define glNamedStringARB glad_glNamedStringARB
GLAD_API_CALL PFNGLNEWOBJECTBUFFERATIPROC glad_glNewObjectBufferATI;
#define glNewObjectBufferATI glad_glNewObjectBufferATI
GLAD_API_CALL PFNGLNORMAL3HNVPROC glad_glNormal3hNV;
#define glNormal3hNV glad_glNormal3hNV
GLAD_API_CALL PFNGLNORMAL3HVNVPROC glad_glNormal3hvNV;
#define glNormal3hvNV glad_glNormal3hvNV
GLAD_API_CALL PFNGLNORMALFORMATNVPROC glad_glNormalFormatNV;
#define glNormalFormatNV glad_glNormalFormatNV
GLAD_API_CALL PFNGLNORMALPOINTEREXTPROC glad_glNormalPointerEXT;
#define glNormalPointerEXT glad_glNormalPointerEXT
GLAD_API_CALL PFNGLNORMALPOINTERVINTELPROC glad_glNormalPointervINTEL;
#define glNormalPointervINTEL glad_glNormalPointervINTEL
GLAD_API_CALL PFNGLNORMALSTREAM3BATIPROC glad_glNormalStream3bATI;
#define glNormalStream3bATI glad_glNormalStream3bATI
GLAD_API_CALL PFNGLNORMALSTREAM3BVATIPROC glad_glNormalStream3bvATI;
#define glNormalStream3bvATI glad_glNormalStream3bvATI
GLAD_API_CALL PFNGLNORMALSTREAM3DATIPROC glad_glNormalStream3dATI;
#define glNormalStream3dATI glad_glNormalStream3dATI
GLAD_API_CALL PFNGLNORMALSTREAM3DVATIPROC glad_glNormalStream3dvATI;
#define glNormalStream3dvATI glad_glNormalStream3dvATI
GLAD_API_CALL PFNGLNORMALSTREAM3FATIPROC glad_glNormalStream3fATI;
#define glNormalStream3fATI glad_glNormalStream3fATI
GLAD_API_CALL PFNGLNORMALSTREAM3FVATIPROC glad_glNormalStream3fvATI;
#define glNormalStream3fvATI glad_glNormalStream3fvATI
GLAD_API_CALL PFNGLNORMALSTREAM3IATIPROC glad_glNormalStream3iATI;
#define glNormalStream3iATI glad_glNormalStream3iATI
GLAD_API_CALL PFNGLNORMALSTREAM3IVATIPROC glad_glNormalStream3ivATI;
#define glNormalStream3ivATI glad_glNormalStream3ivATI
GLAD_API_CALL PFNGLNORMALSTREAM3SATIPROC glad_glNormalStream3sATI;
#define glNormalStream3sATI glad_glNormalStream3sATI
GLAD_API_CALL PFNGLNORMALSTREAM3SVATIPROC glad_glNormalStream3svATI;
#define glNormalStream3svATI glad_glNormalStream3svATI
GLAD_API_CALL PFNGLOBJECTLABELPROC glad_glObjectLabel;
#define glObjectLabel glad_glObjectLabel
GLAD_API_CALL PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel;
#define glObjectPtrLabel glad_glObjectPtrLabel
GLAD_API_CALL PFNGLOBJECTPURGEABLEAPPLEPROC glad_glObjectPurgeableAPPLE;
#define glObjectPurgeableAPPLE glad_glObjectPurgeableAPPLE
GLAD_API_CALL PFNGLOBJECTUNPURGEABLEAPPLEPROC glad_glObjectUnpurgeableAPPLE;
#define glObjectUnpurgeableAPPLE glad_glObjectUnpurgeableAPPLE
GLAD_API_CALL PFNGLPNTRIANGLESFATIPROC glad_glPNTrianglesfATI;
#define glPNTrianglesfATI glad_glPNTrianglesfATI
GLAD_API_CALL PFNGLPNTRIANGLESIATIPROC glad_glPNTrianglesiATI;
#define glPNTrianglesiATI glad_glPNTrianglesiATI
GLAD_API_CALL PFNGLPASSTEXCOORDATIPROC glad_glPassTexCoordATI;
#define glPassTexCoordATI glad_glPassTexCoordATI
GLAD_API_CALL PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv;
#define glPatchParameterfv glad_glPatchParameterfv
GLAD_API_CALL PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri;
#define glPatchParameteri glad_glPatchParameteri
GLAD_API_CALL PFNGLPATHCOMMANDSNVPROC glad_glPathCommandsNV;
#define glPathCommandsNV glad_glPathCommandsNV
GLAD_API_CALL PFNGLPATHCOORDSNVPROC glad_glPathCoordsNV;
#define glPathCoordsNV glad_glPathCoordsNV
GLAD_API_CALL PFNGLPATHCOVERDEPTHFUNCNVPROC glad_glPathCoverDepthFuncNV;
#define glPathCoverDepthFuncNV glad_glPathCoverDepthFuncNV
GLAD_API_CALL PFNGLPATHDASHARRAYNVPROC glad_glPathDashArrayNV;
#define glPathDashArrayNV glad_glPathDashArrayNV
GLAD_API_CALL PFNGLPATHGLYPHINDEXARRAYNVPROC glad_glPathGlyphIndexArrayNV;
#define glPathGlyphIndexArrayNV glad_glPathGlyphIndexArrayNV
GLAD_API_CALL PFNGLPATHGLYPHINDEXRANGENVPROC glad_glPathGlyphIndexRangeNV;
#define glPathGlyphIndexRangeNV glad_glPathGlyphIndexRangeNV
GLAD_API_CALL PFNGLPATHGLYPHRANGENVPROC glad_glPathGlyphRangeNV;
#define glPathGlyphRangeNV glad_glPathGlyphRangeNV
GLAD_API_CALL PFNGLPATHGLYPHSNVPROC glad_glPathGlyphsNV;
#define glPathGlyphsNV glad_glPathGlyphsNV
GLAD_API_CALL PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC glad_glPathMemoryGlyphIndexArrayNV;
#define glPathMemoryGlyphIndexArrayNV glad_glPathMemoryGlyphIndexArrayNV
GLAD_API_CALL PFNGLPATHPARAMETERFNVPROC glad_glPathParameterfNV;
#define glPathParameterfNV glad_glPathParameterfNV
GLAD_API_CALL PFNGLPATHPARAMETERFVNVPROC glad_glPathParameterfvNV;
#define glPathParameterfvNV glad_glPathParameterfvNV
GLAD_API_CALL PFNGLPATHPARAMETERINVPROC glad_glPathParameteriNV;
#define glPathParameteriNV glad_glPathParameteriNV
GLAD_API_CALL PFNGLPATHPARAMETERIVNVPROC glad_glPathParameterivNV;
#define glPathParameterivNV glad_glPathParameterivNV
GLAD_API_CALL PFNGLPATHSTENCILDEPTHOFFSETNVPROC glad_glPathStencilDepthOffsetNV;
#define glPathStencilDepthOffsetNV glad_glPathStencilDepthOffsetNV
GLAD_API_CALL PFNGLPATHSTENCILFUNCNVPROC glad_glPathStencilFuncNV;
#define glPathStencilFuncNV glad_glPathStencilFuncNV
GLAD_API_CALL PFNGLPATHSTRINGNVPROC glad_glPathStringNV;
#define glPathStringNV glad_glPathStringNV
GLAD_API_CALL PFNGLPATHSUBCOMMANDSNVPROC glad_glPathSubCommandsNV;
#define glPathSubCommandsNV glad_glPathSubCommandsNV
GLAD_API_CALL PFNGLPATHSUBCOORDSNVPROC glad_glPathSubCoordsNV;
#define glPathSubCoordsNV glad_glPathSubCoordsNV
GLAD_API_CALL PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback;
#define glPauseTransformFeedback glad_glPauseTransformFeedback
GLAD_API_CALL PFNGLPAUSETRANSFORMFEEDBACKNVPROC glad_glPauseTransformFeedbackNV;
#define glPauseTransformFeedbackNV glad_glPauseTransformFeedbackNV
GLAD_API_CALL PFNGLPIXELDATARANGENVPROC glad_glPixelDataRangeNV;
#define glPixelDataRangeNV glad_glPixelDataRangeNV
GLAD_API_CALL PFNGLPIXELSTOREFPROC glad_glPixelStoref;
#define glPixelStoref glad_glPixelStoref
GLAD_API_CALL PFNGLPIXELSTOREIPROC glad_glPixelStorei;
#define glPixelStorei glad_glPixelStorei
GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERFEXTPROC glad_glPixelTransformParameterfEXT;
#define glPixelTransformParameterfEXT glad_glPixelTransformParameterfEXT
GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC glad_glPixelTransformParameterfvEXT;
#define glPixelTransformParameterfvEXT glad_glPixelTransformParameterfvEXT
GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERIEXTPROC glad_glPixelTransformParameteriEXT;
#define glPixelTransformParameteriEXT glad_glPixelTransformParameteriEXT
GLAD_API_CALL PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC glad_glPixelTransformParameterivEXT;
#define glPixelTransformParameterivEXT glad_glPixelTransformParameterivEXT
GLAD_API_CALL PFNGLPOINTALONGPATHNVPROC glad_glPointAlongPathNV;
#define glPointAlongPathNV glad_glPointAlongPathNV
GLAD_API_CALL PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;
#define glPointParameterf glad_glPointParameterf
GLAD_API_CALL PFNGLPOINTPARAMETERFARBPROC glad_glPointParameterfARB;
#define glPointParameterfARB glad_glPointParameterfARB
GLAD_API_CALL PFNGLPOINTPARAMETERFEXTPROC glad_glPointParameterfEXT;
#define glPointParameterfEXT glad_glPointParameterfEXT
GLAD_API_CALL PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;
#define glPointParameterfv glad_glPointParameterfv
GLAD_API_CALL PFNGLPOINTPARAMETERFVARBPROC glad_glPointParameterfvARB;
#define glPointParameterfvARB glad_glPointParameterfvARB
GLAD_API_CALL PFNGLPOINTPARAMETERFVEXTPROC glad_glPointParameterfvEXT;
#define glPointParameterfvEXT glad_glPointParameterfvEXT
GLAD_API_CALL PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;
#define glPointParameteri glad_glPointParameteri
GLAD_API_CALL PFNGLPOINTPARAMETERINVPROC glad_glPointParameteriNV;
#define glPointParameteriNV glad_glPointParameteriNV
GLAD_API_CALL PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;
#define glPointParameteriv glad_glPointParameteriv
GLAD_API_CALL PFNGLPOINTPARAMETERIVNVPROC glad_glPointParameterivNV;
#define glPointParameterivNV glad_glPointParameterivNV
GLAD_API_CALL PFNGLPOINTSIZEPROC glad_glPointSize;
#define glPointSize glad_glPointSize
GLAD_API_CALL PFNGLPOLYGONMODEPROC glad_glPolygonMode;
#define glPolygonMode glad_glPolygonMode
GLAD_API_CALL PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;
#define glPolygonOffset glad_glPolygonOffset
GLAD_API_CALL PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp;
#define glPolygonOffsetClamp glad_glPolygonOffsetClamp
GLAD_API_CALL PFNGLPOLYGONOFFSETCLAMPEXTPROC glad_glPolygonOffsetClampEXT;
#define glPolygonOffsetClampEXT glad_glPolygonOffsetClampEXT
GLAD_API_CALL PFNGLPOLYGONOFFSETEXTPROC glad_glPolygonOffsetEXT;
#define glPolygonOffsetEXT glad_glPolygonOffsetEXT
GLAD_API_CALL PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup;
#define glPopDebugGroup glad_glPopDebugGroup
GLAD_API_CALL PFNGLPOPGROUPMARKEREXTPROC glad_glPopGroupMarkerEXT;
#define glPopGroupMarkerEXT glad_glPopGroupMarkerEXT
GLAD_API_CALL PFNGLPRESENTFRAMEDUALFILLNVPROC glad_glPresentFrameDualFillNV;
#define glPresentFrameDualFillNV glad_glPresentFrameDualFillNV
GLAD_API_CALL PFNGLPRESENTFRAMEKEYEDNVPROC glad_glPresentFrameKeyedNV;
#define glPresentFrameKeyedNV glad_glPresentFrameKeyedNV
GLAD_API_CALL PFNGLPRIMITIVEBOUNDINGBOXPROC glad_glPrimitiveBoundingBox;
#define glPrimitiveBoundingBox glad_glPrimitiveBoundingBox
GLAD_API_CALL PFNGLPRIMITIVEBOUNDINGBOXARBPROC glad_glPrimitiveBoundingBoxARB;
#define glPrimitiveBoundingBoxARB glad_glPrimitiveBoundingBoxARB
GLAD_API_CALL PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;
#define glPrimitiveRestartIndex glad_glPrimitiveRestartIndex
GLAD_API_CALL PFNGLPRIMITIVERESTARTINDEXNVPROC glad_glPrimitiveRestartIndexNV;
#define glPrimitiveRestartIndexNV glad_glPrimitiveRestartIndexNV
GLAD_API_CALL PFNGLPRIMITIVERESTARTNVPROC glad_glPrimitiveRestartNV;
#define glPrimitiveRestartNV glad_glPrimitiveRestartNV
GLAD_API_CALL PFNGLPRIORITIZETEXTURESPROC glad_glPrioritizeTextures;
#define glPrioritizeTextures glad_glPrioritizeTextures
GLAD_API_CALL PFNGLPRIORITIZETEXTURESEXTPROC glad_glPrioritizeTexturesEXT;
#define glPrioritizeTexturesEXT glad_glPrioritizeTexturesEXT
GLAD_API_CALL PFNGLPROGRAMBINARYPROC glad_glProgramBinary;
#define glProgramBinary glad_glProgramBinary
GLAD_API_CALL PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC glad_glProgramBufferParametersIivNV;
#define glProgramBufferParametersIivNV glad_glProgramBufferParametersIivNV
GLAD_API_CALL PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC glad_glProgramBufferParametersIuivNV;
#define glProgramBufferParametersIuivNV glad_glProgramBufferParametersIuivNV
GLAD_API_CALL PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC glad_glProgramBufferParametersfvNV;
#define glProgramBufferParametersfvNV glad_glProgramBufferParametersfvNV
GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4DARBPROC glad_glProgramEnvParameter4dARB;
#define glProgramEnvParameter4dARB glad_glProgramEnvParameter4dARB
GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4DVARBPROC glad_glProgramEnvParameter4dvARB;
#define glProgramEnvParameter4dvARB glad_glProgramEnvParameter4dvARB
GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4FARBPROC glad_glProgramEnvParameter4fARB;
#define glProgramEnvParameter4fARB glad_glProgramEnvParameter4fARB
GLAD_API_CALL PFNGLPROGRAMENVPARAMETER4FVARBPROC glad_glProgramEnvParameter4fvARB;
#define glProgramEnvParameter4fvARB glad_glProgramEnvParameter4fvARB
GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4INVPROC glad_glProgramEnvParameterI4iNV;
#define glProgramEnvParameterI4iNV glad_glProgramEnvParameterI4iNV
GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4IVNVPROC glad_glProgramEnvParameterI4ivNV;
#define glProgramEnvParameterI4ivNV glad_glProgramEnvParameterI4ivNV
GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4UINVPROC glad_glProgramEnvParameterI4uiNV;
#define glProgramEnvParameterI4uiNV glad_glProgramEnvParameterI4uiNV
GLAD_API_CALL PFNGLPROGRAMENVPARAMETERI4UIVNVPROC glad_glProgramEnvParameterI4uivNV;
#define glProgramEnvParameterI4uivNV glad_glProgramEnvParameterI4uivNV
GLAD_API_CALL PFNGLPROGRAMENVPARAMETERS4FVEXTPROC glad_glProgramEnvParameters4fvEXT;
#define glProgramEnvParameters4fvEXT glad_glProgramEnvParameters4fvEXT
GLAD_API_CALL PFNGLPROGRAMENVPARAMETERSI4IVNVPROC glad_glProgramEnvParametersI4ivNV;
#define glProgramEnvParametersI4ivNV glad_glProgramEnvParametersI4ivNV
GLAD_API_CALL PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC glad_glProgramEnvParametersI4uivNV;
#define glProgramEnvParametersI4uivNV glad_glProgramEnvParametersI4uivNV
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4DARBPROC glad_glProgramLocalParameter4dARB;
#define glProgramLocalParameter4dARB glad_glProgramLocalParameter4dARB
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4DVARBPROC glad_glProgramLocalParameter4dvARB;
#define glProgramLocalParameter4dvARB glad_glProgramLocalParameter4dvARB
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4FARBPROC glad_glProgramLocalParameter4fARB;
#define glProgramLocalParameter4fARB glad_glProgramLocalParameter4fARB
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETER4FVARBPROC glad_glProgramLocalParameter4fvARB;
#define glProgramLocalParameter4fvARB glad_glProgramLocalParameter4fvARB
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4INVPROC glad_glProgramLocalParameterI4iNV;
#define glProgramLocalParameterI4iNV glad_glProgramLocalParameterI4iNV
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC glad_glProgramLocalParameterI4ivNV;
#define glProgramLocalParameterI4ivNV glad_glProgramLocalParameterI4ivNV
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4UINVPROC glad_glProgramLocalParameterI4uiNV;
#define glProgramLocalParameterI4uiNV glad_glProgramLocalParameterI4uiNV
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC glad_glProgramLocalParameterI4uivNV;
#define glProgramLocalParameterI4uivNV glad_glProgramLocalParameterI4uivNV
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC glad_glProgramLocalParameters4fvEXT;
#define glProgramLocalParameters4fvEXT glad_glProgramLocalParameters4fvEXT
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC glad_glProgramLocalParametersI4ivNV;
#define glProgramLocalParametersI4ivNV glad_glProgramLocalParametersI4ivNV
GLAD_API_CALL PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC glad_glProgramLocalParametersI4uivNV;
#define glProgramLocalParametersI4uivNV glad_glProgramLocalParametersI4uivNV
GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4DNVPROC glad_glProgramNamedParameter4dNV;
#define glProgramNamedParameter4dNV glad_glProgramNamedParameter4dNV
GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC glad_glProgramNamedParameter4dvNV;
#define glProgramNamedParameter4dvNV glad_glProgramNamedParameter4dvNV
GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4FNVPROC glad_glProgramNamedParameter4fNV;
#define glProgramNamedParameter4fNV glad_glProgramNamedParameter4fNV
GLAD_API_CALL PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC glad_glProgramNamedParameter4fvNV;
#define glProgramNamedParameter4fvNV glad_glProgramNamedParameter4fvNV
GLAD_API_CALL PFNGLPROGRAMPARAMETER4DNVPROC glad_glProgramParameter4dNV;
#define glProgramParameter4dNV glad_glProgramParameter4dNV
GLAD_API_CALL PFNGLPROGRAMPARAMETER4DVNVPROC glad_glProgramParameter4dvNV;
#define glProgramParameter4dvNV glad_glProgramParameter4dvNV
GLAD_API_CALL PFNGLPROGRAMPARAMETER4FNVPROC glad_glProgramParameter4fNV;
#define glProgramParameter4fNV glad_glProgramParameter4fNV
GLAD_API_CALL PFNGLPROGRAMPARAMETER4FVNVPROC glad_glProgramParameter4fvNV;
#define glProgramParameter4fvNV glad_glProgramParameter4fvNV
GLAD_API_CALL PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri;
#define glProgramParameteri glad_glProgramParameteri
GLAD_API_CALL PFNGLPROGRAMPARAMETERIARBPROC glad_glProgramParameteriARB;
#define glProgramParameteriARB glad_glProgramParameteriARB
GLAD_API_CALL PFNGLPROGRAMPARAMETERIEXTPROC glad_glProgramParameteriEXT;
#define glProgramParameteriEXT glad_glProgramParameteriEXT
GLAD_API_CALL PFNGLPROGRAMPARAMETERS4DVNVPROC glad_glProgramParameters4dvNV;
#define glProgramParameters4dvNV glad_glProgramParameters4dvNV
GLAD_API_CALL PFNGLPROGRAMPARAMETERS4FVNVPROC glad_glProgramParameters4fvNV;
#define glProgramParameters4fvNV glad_glProgramParameters4fvNV
GLAD_API_CALL PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC glad_glProgramPathFragmentInputGenNV;
#define glProgramPathFragmentInputGenNV glad_glProgramPathFragmentInputGenNV
GLAD_API_CALL PFNGLPROGRAMSTRINGARBPROC glad_glProgramStringARB;
#define glProgramStringARB glad_glProgramStringARB
GLAD_API_CALL PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC glad_glProgramSubroutineParametersuivNV;
#define glProgramSubroutineParametersuivNV glad_glProgramSubroutineParametersuivNV
GLAD_API_CALL PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d;
#define glProgramUniform1d glad_glProgramUniform1d
GLAD_API_CALL PFNGLPROGRAMUNIFORM1DEXTPROC glad_glProgramUniform1dEXT;
#define glProgramUniform1dEXT glad_glProgramUniform1dEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv;
#define glProgramUniform1dv glad_glProgramUniform1dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1DVEXTPROC glad_glProgramUniform1dvEXT;
#define glProgramUniform1dvEXT glad_glProgramUniform1dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f;
#define glProgramUniform1f glad_glProgramUniform1f
GLAD_API_CALL PFNGLPROGRAMUNIFORM1FEXTPROC glad_glProgramUniform1fEXT;
#define glProgramUniform1fEXT glad_glProgramUniform1fEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv;
#define glProgramUniform1fv glad_glProgramUniform1fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1FVEXTPROC glad_glProgramUniform1fvEXT;
#define glProgramUniform1fvEXT glad_glProgramUniform1fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i;
#define glProgramUniform1i glad_glProgramUniform1i
GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64ARBPROC glad_glProgramUniform1i64ARB;
#define glProgramUniform1i64ARB glad_glProgramUniform1i64ARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64NVPROC glad_glProgramUniform1i64NV;
#define glProgramUniform1i64NV glad_glProgramUniform1i64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64VARBPROC glad_glProgramUniform1i64vARB;
#define glProgramUniform1i64vARB glad_glProgramUniform1i64vARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM1I64VNVPROC glad_glProgramUniform1i64vNV;
#define glProgramUniform1i64vNV glad_glProgramUniform1i64vNV
GLAD_API_CALL PFNGLPROGRAMUNIFORM1IEXTPROC glad_glProgramUniform1iEXT;
#define glProgramUniform1iEXT glad_glProgramUniform1iEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv;
#define glProgramUniform1iv glad_glProgramUniform1iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1IVEXTPROC glad_glProgramUniform1ivEXT;
#define glProgramUniform1ivEXT glad_glProgramUniform1ivEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui;
#define glProgramUniform1ui glad_glProgramUniform1ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64ARBPROC glad_glProgramUniform1ui64ARB;
#define glProgramUniform1ui64ARB glad_glProgramUniform1ui64ARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64NVPROC glad_glProgramUniform1ui64NV;
#define glProgramUniform1ui64NV glad_glProgramUniform1ui64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64VARBPROC glad_glProgramUniform1ui64vARB;
#define glProgramUniform1ui64vARB glad_glProgramUniform1ui64vARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UI64VNVPROC glad_glProgramUniform1ui64vNV;
#define glProgramUniform1ui64vNV glad_glProgramUniform1ui64vNV
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIEXTPROC glad_glProgramUniform1uiEXT;
#define glProgramUniform1uiEXT glad_glProgramUniform1uiEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv;
#define glProgramUniform1uiv glad_glProgramUniform1uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM1UIVEXTPROC glad_glProgramUniform1uivEXT;
#define glProgramUniform1uivEXT glad_glProgramUniform1uivEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d;
#define glProgramUniform2d glad_glProgramUniform2d
GLAD_API_CALL PFNGLPROGRAMUNIFORM2DEXTPROC glad_glProgramUniform2dEXT;
#define glProgramUniform2dEXT glad_glProgramUniform2dEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv;
#define glProgramUniform2dv glad_glProgramUniform2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2DVEXTPROC glad_glProgramUniform2dvEXT;
#define glProgramUniform2dvEXT glad_glProgramUniform2dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f;
#define glProgramUniform2f glad_glProgramUniform2f
GLAD_API_CALL PFNGLPROGRAMUNIFORM2FEXTPROC glad_glProgramUniform2fEXT;
#define glProgramUniform2fEXT glad_glProgramUniform2fEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv;
#define glProgramUniform2fv glad_glProgramUniform2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2FVEXTPROC glad_glProgramUniform2fvEXT;
#define glProgramUniform2fvEXT glad_glProgramUniform2fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i;
#define glProgramUniform2i glad_glProgramUniform2i
GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64ARBPROC glad_glProgramUniform2i64ARB;
#define glProgramUniform2i64ARB glad_glProgramUniform2i64ARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64NVPROC glad_glProgramUniform2i64NV;
#define glProgramUniform2i64NV glad_glProgramUniform2i64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64VARBPROC glad_glProgramUniform2i64vARB;
#define glProgramUniform2i64vARB glad_glProgramUniform2i64vARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM2I64VNVPROC glad_glProgramUniform2i64vNV;
#define glProgramUniform2i64vNV glad_glProgramUniform2i64vNV
GLAD_API_CALL PFNGLPROGRAMUNIFORM2IEXTPROC glad_glProgramUniform2iEXT;
#define glProgramUniform2iEXT glad_glProgramUniform2iEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv;
#define glProgramUniform2iv glad_glProgramUniform2iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2IVEXTPROC glad_glProgramUniform2ivEXT;
#define glProgramUniform2ivEXT glad_glProgramUniform2ivEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui;
#define glProgramUniform2ui glad_glProgramUniform2ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64ARBPROC glad_glProgramUniform2ui64ARB;
#define glProgramUniform2ui64ARB glad_glProgramUniform2ui64ARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64NVPROC glad_glProgramUniform2ui64NV;
#define glProgramUniform2ui64NV glad_glProgramUniform2ui64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64VARBPROC glad_glProgramUniform2ui64vARB;
#define glProgramUniform2ui64vARB glad_glProgramUniform2ui64vARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UI64VNVPROC glad_glProgramUniform2ui64vNV;
#define glProgramUniform2ui64vNV glad_glProgramUniform2ui64vNV
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIEXTPROC glad_glProgramUniform2uiEXT;
#define glProgramUniform2uiEXT glad_glProgramUniform2uiEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv;
#define glProgramUniform2uiv glad_glProgramUniform2uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM2UIVEXTPROC glad_glProgramUniform2uivEXT;
#define glProgramUniform2uivEXT glad_glProgramUniform2uivEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d;
#define glProgramUniform3d glad_glProgramUniform3d
GLAD_API_CALL PFNGLPROGRAMUNIFORM3DEXTPROC glad_glProgramUniform3dEXT;
#define glProgramUniform3dEXT glad_glProgramUniform3dEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv;
#define glProgramUniform3dv glad_glProgramUniform3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3DVEXTPROC glad_glProgramUniform3dvEXT;
#define glProgramUniform3dvEXT glad_glProgramUniform3dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f;
#define glProgramUniform3f glad_glProgramUniform3f
GLAD_API_CALL PFNGLPROGRAMUNIFORM3FEXTPROC glad_glProgramUniform3fEXT;
#define glProgramUniform3fEXT glad_glProgramUniform3fEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv;
#define glProgramUniform3fv glad_glProgramUniform3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3FVEXTPROC glad_glProgramUniform3fvEXT;
#define glProgramUniform3fvEXT glad_glProgramUniform3fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i;
#define glProgramUniform3i glad_glProgramUniform3i
GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64ARBPROC glad_glProgramUniform3i64ARB;
#define glProgramUniform3i64ARB glad_glProgramUniform3i64ARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64NVPROC glad_glProgramUniform3i64NV;
#define glProgramUniform3i64NV glad_glProgramUniform3i64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64VARBPROC glad_glProgramUniform3i64vARB;
#define glProgramUniform3i64vARB glad_glProgramUniform3i64vARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM3I64VNVPROC glad_glProgramUniform3i64vNV;
#define glProgramUniform3i64vNV glad_glProgramUniform3i64vNV
GLAD_API_CALL PFNGLPROGRAMUNIFORM3IEXTPROC glad_glProgramUniform3iEXT;
#define glProgramUniform3iEXT glad_glProgramUniform3iEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv;
#define glProgramUniform3iv glad_glProgramUniform3iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3IVEXTPROC glad_glProgramUniform3ivEXT;
#define glProgramUniform3ivEXT glad_glProgramUniform3ivEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui;
#define glProgramUniform3ui glad_glProgramUniform3ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64ARBPROC glad_glProgramUniform3ui64ARB;
#define glProgramUniform3ui64ARB glad_glProgramUniform3ui64ARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64NVPROC glad_glProgramUniform3ui64NV;
#define glProgramUniform3ui64NV glad_glProgramUniform3ui64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64VARBPROC glad_glProgramUniform3ui64vARB;
#define glProgramUniform3ui64vARB glad_glProgramUniform3ui64vARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UI64VNVPROC glad_glProgramUniform3ui64vNV;
#define glProgramUniform3ui64vNV glad_glProgramUniform3ui64vNV
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIEXTPROC glad_glProgramUniform3uiEXT;
#define glProgramUniform3uiEXT glad_glProgramUniform3uiEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv;
#define glProgramUniform3uiv glad_glProgramUniform3uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM3UIVEXTPROC glad_glProgramUniform3uivEXT;
#define glProgramUniform3uivEXT glad_glProgramUniform3uivEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d;
#define glProgramUniform4d glad_glProgramUniform4d
GLAD_API_CALL PFNGLPROGRAMUNIFORM4DEXTPROC glad_glProgramUniform4dEXT;
#define glProgramUniform4dEXT glad_glProgramUniform4dEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv;
#define glProgramUniform4dv glad_glProgramUniform4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4DVEXTPROC glad_glProgramUniform4dvEXT;
#define glProgramUniform4dvEXT glad_glProgramUniform4dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f;
#define glProgramUniform4f glad_glProgramUniform4f
GLAD_API_CALL PFNGLPROGRAMUNIFORM4FEXTPROC glad_glProgramUniform4fEXT;
#define glProgramUniform4fEXT glad_glProgramUniform4fEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv;
#define glProgramUniform4fv glad_glProgramUniform4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4FVEXTPROC glad_glProgramUniform4fvEXT;
#define glProgramUniform4fvEXT glad_glProgramUniform4fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i;
#define glProgramUniform4i glad_glProgramUniform4i
GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64ARBPROC glad_glProgramUniform4i64ARB;
#define glProgramUniform4i64ARB glad_glProgramUniform4i64ARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64NVPROC glad_glProgramUniform4i64NV;
#define glProgramUniform4i64NV glad_glProgramUniform4i64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64VARBPROC glad_glProgramUniform4i64vARB;
#define glProgramUniform4i64vARB glad_glProgramUniform4i64vARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM4I64VNVPROC glad_glProgramUniform4i64vNV;
#define glProgramUniform4i64vNV glad_glProgramUniform4i64vNV
GLAD_API_CALL PFNGLPROGRAMUNIFORM4IEXTPROC glad_glProgramUniform4iEXT;
#define glProgramUniform4iEXT glad_glProgramUniform4iEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv;
#define glProgramUniform4iv glad_glProgramUniform4iv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4IVEXTPROC glad_glProgramUniform4ivEXT;
#define glProgramUniform4ivEXT glad_glProgramUniform4ivEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui;
#define glProgramUniform4ui glad_glProgramUniform4ui
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64ARBPROC glad_glProgramUniform4ui64ARB;
#define glProgramUniform4ui64ARB glad_glProgramUniform4ui64ARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64NVPROC glad_glProgramUniform4ui64NV;
#define glProgramUniform4ui64NV glad_glProgramUniform4ui64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64VARBPROC glad_glProgramUniform4ui64vARB;
#define glProgramUniform4ui64vARB glad_glProgramUniform4ui64vARB
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UI64VNVPROC glad_glProgramUniform4ui64vNV;
#define glProgramUniform4ui64vNV glad_glProgramUniform4ui64vNV
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIEXTPROC glad_glProgramUniform4uiEXT;
#define glProgramUniform4uiEXT glad_glProgramUniform4uiEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv;
#define glProgramUniform4uiv glad_glProgramUniform4uiv
GLAD_API_CALL PFNGLPROGRAMUNIFORM4UIVEXTPROC glad_glProgramUniform4uivEXT;
#define glProgramUniform4uivEXT glad_glProgramUniform4uivEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC glad_glProgramUniformHandleui64ARB;
#define glProgramUniformHandleui64ARB glad_glProgramUniformHandleui64ARB
GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC glad_glProgramUniformHandleui64NV;
#define glProgramUniformHandleui64NV glad_glProgramUniformHandleui64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC glad_glProgramUniformHandleui64vARB;
#define glProgramUniformHandleui64vARB glad_glProgramUniformHandleui64vARB
GLAD_API_CALL PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC glad_glProgramUniformHandleui64vNV;
#define glProgramUniformHandleui64vNV glad_glProgramUniformHandleui64vNV
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv;
#define glProgramUniformMatrix2dv glad_glProgramUniformMatrix2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC glad_glProgramUniformMatrix2dvEXT;
#define glProgramUniformMatrix2dvEXT glad_glProgramUniformMatrix2dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv;
#define glProgramUniformMatrix2fv glad_glProgramUniformMatrix2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC glad_glProgramUniformMatrix2fvEXT;
#define glProgramUniformMatrix2fvEXT glad_glProgramUniformMatrix2fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv;
#define glProgramUniformMatrix2x3dv glad_glProgramUniformMatrix2x3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC glad_glProgramUniformMatrix2x3dvEXT;
#define glProgramUniformMatrix2x3dvEXT glad_glProgramUniformMatrix2x3dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv;
#define glProgramUniformMatrix2x3fv glad_glProgramUniformMatrix2x3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC glad_glProgramUniformMatrix2x3fvEXT;
#define glProgramUniformMatrix2x3fvEXT glad_glProgramUniformMatrix2x3fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv;
#define glProgramUniformMatrix2x4dv glad_glProgramUniformMatrix2x4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC glad_glProgramUniformMatrix2x4dvEXT;
#define glProgramUniformMatrix2x4dvEXT glad_glProgramUniformMatrix2x4dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv;
#define glProgramUniformMatrix2x4fv glad_glProgramUniformMatrix2x4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC glad_glProgramUniformMatrix2x4fvEXT;
#define glProgramUniformMatrix2x4fvEXT glad_glProgramUniformMatrix2x4fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv;
#define glProgramUniformMatrix3dv glad_glProgramUniformMatrix3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC glad_glProgramUniformMatrix3dvEXT;
#define glProgramUniformMatrix3dvEXT glad_glProgramUniformMatrix3dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv;
#define glProgramUniformMatrix3fv glad_glProgramUniformMatrix3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC glad_glProgramUniformMatrix3fvEXT;
#define glProgramUniformMatrix3fvEXT glad_glProgramUniformMatrix3fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv;
#define glProgramUniformMatrix3x2dv glad_glProgramUniformMatrix3x2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC glad_glProgramUniformMatrix3x2dvEXT;
#define glProgramUniformMatrix3x2dvEXT glad_glProgramUniformMatrix3x2dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv;
#define glProgramUniformMatrix3x2fv glad_glProgramUniformMatrix3x2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC glad_glProgramUniformMatrix3x2fvEXT;
#define glProgramUniformMatrix3x2fvEXT glad_glProgramUniformMatrix3x2fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv;
#define glProgramUniformMatrix3x4dv glad_glProgramUniformMatrix3x4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC glad_glProgramUniformMatrix3x4dvEXT;
#define glProgramUniformMatrix3x4dvEXT glad_glProgramUniformMatrix3x4dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv;
#define glProgramUniformMatrix3x4fv glad_glProgramUniformMatrix3x4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC glad_glProgramUniformMatrix3x4fvEXT;
#define glProgramUniformMatrix3x4fvEXT glad_glProgramUniformMatrix3x4fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv;
#define glProgramUniformMatrix4dv glad_glProgramUniformMatrix4dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC glad_glProgramUniformMatrix4dvEXT;
#define glProgramUniformMatrix4dvEXT glad_glProgramUniformMatrix4dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv;
#define glProgramUniformMatrix4fv glad_glProgramUniformMatrix4fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC glad_glProgramUniformMatrix4fvEXT;
#define glProgramUniformMatrix4fvEXT glad_glProgramUniformMatrix4fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv;
#define glProgramUniformMatrix4x2dv glad_glProgramUniformMatrix4x2dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC glad_glProgramUniformMatrix4x2dvEXT;
#define glProgramUniformMatrix4x2dvEXT glad_glProgramUniformMatrix4x2dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv;
#define glProgramUniformMatrix4x2fv glad_glProgramUniformMatrix4x2fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC glad_glProgramUniformMatrix4x2fvEXT;
#define glProgramUniformMatrix4x2fvEXT glad_glProgramUniformMatrix4x2fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv;
#define glProgramUniformMatrix4x3dv glad_glProgramUniformMatrix4x3dv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC glad_glProgramUniformMatrix4x3dvEXT;
#define glProgramUniformMatrix4x3dvEXT glad_glProgramUniformMatrix4x3dvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv;
#define glProgramUniformMatrix4x3fv glad_glProgramUniformMatrix4x3fv
GLAD_API_CALL PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC glad_glProgramUniformMatrix4x3fvEXT;
#define glProgramUniformMatrix4x3fvEXT glad_glProgramUniformMatrix4x3fvEXT
GLAD_API_CALL PFNGLPROGRAMUNIFORMUI64NVPROC glad_glProgramUniformui64NV;
#define glProgramUniformui64NV glad_glProgramUniformui64NV
GLAD_API_CALL PFNGLPROGRAMUNIFORMUI64VNVPROC glad_glProgramUniformui64vNV;
#define glProgramUniformui64vNV glad_glProgramUniformui64vNV
GLAD_API_CALL PFNGLPROGRAMVERTEXLIMITNVPROC glad_glProgramVertexLimitNV;
#define glProgramVertexLimitNV glad_glProgramVertexLimitNV
GLAD_API_CALL PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;
#define glProvokingVertex glad_glProvokingVertex
GLAD_API_CALL PFNGLPROVOKINGVERTEXEXTPROC glad_glProvokingVertexEXT;
#define glProvokingVertexEXT glad_glProvokingVertexEXT
GLAD_API_CALL PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC glad_glPushClientAttribDefaultEXT;
#define glPushClientAttribDefaultEXT glad_glPushClientAttribDefaultEXT
GLAD_API_CALL PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup;
#define glPushDebugGroup glad_glPushDebugGroup
GLAD_API_CALL PFNGLPUSHGROUPMARKEREXTPROC glad_glPushGroupMarkerEXT;
#define glPushGroupMarkerEXT glad_glPushGroupMarkerEXT
GLAD_API_CALL PFNGLQUERYCOUNTERPROC glad_glQueryCounter;
#define glQueryCounter glad_glQueryCounter
GLAD_API_CALL PFNGLQUERYOBJECTPARAMETERUIAMDPROC glad_glQueryObjectParameteruiAMD;
#define glQueryObjectParameteruiAMD glad_glQueryObjectParameteruiAMD
GLAD_API_CALL PFNGLQUERYRESOURCENVPROC glad_glQueryResourceNV;
#define glQueryResourceNV glad_glQueryResourceNV
GLAD_API_CALL PFNGLQUERYRESOURCETAGNVPROC glad_glQueryResourceTagNV;
#define glQueryResourceTagNV glad_glQueryResourceTagNV
GLAD_API_CALL PFNGLRASTERSAMPLESEXTPROC glad_glRasterSamplesEXT;
#define glRasterSamplesEXT glad_glRasterSamplesEXT
GLAD_API_CALL PFNGLREADBUFFERPROC glad_glReadBuffer;
#define glReadBuffer glad_glReadBuffer
GLAD_API_CALL PFNGLREADPIXELSPROC glad_glReadPixels;
#define glReadPixels glad_glReadPixels
GLAD_API_CALL PFNGLREADNPIXELSPROC glad_glReadnPixels;
#define glReadnPixels glad_glReadnPixels
GLAD_API_CALL PFNGLREADNPIXELSARBPROC glad_glReadnPixelsARB;
#define glReadnPixelsARB glad_glReadnPixelsARB
GLAD_API_CALL PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC glad_glReleaseKeyedMutexWin32EXT;
#define glReleaseKeyedMutexWin32EXT glad_glReleaseKeyedMutexWin32EXT
GLAD_API_CALL PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler;
#define glReleaseShaderCompiler glad_glReleaseShaderCompiler
GLAD_API_CALL PFNGLRENDERGPUMASKNVPROC glad_glRenderGpuMaskNV;
#define glRenderGpuMaskNV glad_glRenderGpuMaskNV
GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;
#define glRenderbufferStorage glad_glRenderbufferStorage
GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEEXTPROC glad_glRenderbufferStorageEXT;
#define glRenderbufferStorageEXT glad_glRenderbufferStorageEXT
GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;
#define glRenderbufferStorageMultisample glad_glRenderbufferStorageMultisample
GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC glad_glRenderbufferStorageMultisampleCoverageNV;
#define glRenderbufferStorageMultisampleCoverageNV glad_glRenderbufferStorageMultisampleCoverageNV
GLAD_API_CALL PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC glad_glRenderbufferStorageMultisampleEXT;
#define glRenderbufferStorageMultisampleEXT glad_glRenderbufferStorageMultisampleEXT
GLAD_API_CALL PFNGLREQUESTRESIDENTPROGRAMSNVPROC glad_glRequestResidentProgramsNV;
#define glRequestResidentProgramsNV glad_glRequestResidentProgramsNV
GLAD_API_CALL PFNGLRESETHISTOGRAMPROC glad_glResetHistogram;
#define glResetHistogram glad_glResetHistogram
GLAD_API_CALL PFNGLRESETHISTOGRAMEXTPROC glad_glResetHistogramEXT;
#define glResetHistogramEXT glad_glResetHistogramEXT
GLAD_API_CALL PFNGLRESETMINMAXPROC glad_glResetMinmax;
#define glResetMinmax glad_glResetMinmax
GLAD_API_CALL PFNGLRESETMINMAXEXTPROC glad_glResetMinmaxEXT;
#define glResetMinmaxEXT glad_glResetMinmaxEXT
GLAD_API_CALL PFNGLRESIZEBUFFERSMESAPROC glad_glResizeBuffersMESA;
#define glResizeBuffersMESA glad_glResizeBuffersMESA
GLAD_API_CALL PFNGLRESOLVEDEPTHVALUESNVPROC glad_glResolveDepthValuesNV;
#define glResolveDepthValuesNV glad_glResolveDepthValuesNV
GLAD_API_CALL PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback;
#define glResumeTransformFeedback glad_glResumeTransformFeedback
GLAD_API_CALL PFNGLRESUMETRANSFORMFEEDBACKNVPROC glad_glResumeTransformFeedbackNV;
#define glResumeTransformFeedbackNV glad_glResumeTransformFeedbackNV
GLAD_API_CALL PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;
#define glSampleCoverage glad_glSampleCoverage
GLAD_API_CALL PFNGLSAMPLECOVERAGEARBPROC glad_glSampleCoverageARB;
#define glSampleCoverageARB glad_glSampleCoverageARB
GLAD_API_CALL PFNGLSAMPLEMAPATIPROC glad_glSampleMapATI;
#define glSampleMapATI glad_glSampleMapATI
GLAD_API_CALL PFNGLSAMPLEMASKEXTPROC glad_glSampleMaskEXT;
#define glSampleMaskEXT glad_glSampleMaskEXT
GLAD_API_CALL PFNGLSAMPLEMASKINDEXEDNVPROC glad_glSampleMaskIndexedNV;
#define glSampleMaskIndexedNV glad_glSampleMaskIndexedNV
GLAD_API_CALL PFNGLSAMPLEMASKIPROC glad_glSampleMaski;
#define glSampleMaski glad_glSampleMaski
GLAD_API_CALL PFNGLSAMPLEPATTERNEXTPROC glad_glSamplePatternEXT;
#define glSamplePatternEXT glad_glSamplePatternEXT
GLAD_API_CALL PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;
#define glSamplerParameterIiv glad_glSamplerParameterIiv
GLAD_API_CALL PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;
#define glSamplerParameterIuiv glad_glSamplerParameterIuiv
GLAD_API_CALL PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;
#define glSamplerParameterf glad_glSamplerParameterf
GLAD_API_CALL PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;
#define glSamplerParameterfv glad_glSamplerParameterfv
GLAD_API_CALL PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;
#define glSamplerParameteri glad_glSamplerParameteri
GLAD_API_CALL PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;
#define glSamplerParameteriv glad_glSamplerParameteriv
GLAD_API_CALL PFNGLSCISSORPROC glad_glScissor;
#define glScissor glad_glScissor
GLAD_API_CALL PFNGLSCISSORARRAYVPROC glad_glScissorArrayv;
#define glScissorArrayv glad_glScissorArrayv
GLAD_API_CALL PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed;
#define glScissorIndexed glad_glScissorIndexed
GLAD_API_CALL PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv;
#define glScissorIndexedv glad_glScissorIndexedv
GLAD_API_CALL PFNGLSECONDARYCOLOR3BPROC glad_glSecondaryColor3b;
#define glSecondaryColor3b glad_glSecondaryColor3b
GLAD_API_CALL PFNGLSECONDARYCOLOR3BEXTPROC glad_glSecondaryColor3bEXT;
#define glSecondaryColor3bEXT glad_glSecondaryColor3bEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3BVPROC glad_glSecondaryColor3bv;
#define glSecondaryColor3bv glad_glSecondaryColor3bv
GLAD_API_CALL PFNGLSECONDARYCOLOR3BVEXTPROC glad_glSecondaryColor3bvEXT;
#define glSecondaryColor3bvEXT glad_glSecondaryColor3bvEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3DPROC glad_glSecondaryColor3d;
#define glSecondaryColor3d glad_glSecondaryColor3d
GLAD_API_CALL PFNGLSECONDARYCOLOR3DEXTPROC glad_glSecondaryColor3dEXT;
#define glSecondaryColor3dEXT glad_glSecondaryColor3dEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3DVPROC glad_glSecondaryColor3dv;
#define glSecondaryColor3dv glad_glSecondaryColor3dv
GLAD_API_CALL PFNGLSECONDARYCOLOR3DVEXTPROC glad_glSecondaryColor3dvEXT;
#define glSecondaryColor3dvEXT glad_glSecondaryColor3dvEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3FPROC glad_glSecondaryColor3f;
#define glSecondaryColor3f glad_glSecondaryColor3f
GLAD_API_CALL PFNGLSECONDARYCOLOR3FEXTPROC glad_glSecondaryColor3fEXT;
#define glSecondaryColor3fEXT glad_glSecondaryColor3fEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3FVPROC glad_glSecondaryColor3fv;
#define glSecondaryColor3fv glad_glSecondaryColor3fv
GLAD_API_CALL PFNGLSECONDARYCOLOR3FVEXTPROC glad_glSecondaryColor3fvEXT;
#define glSecondaryColor3fvEXT glad_glSecondaryColor3fvEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3HNVPROC glad_glSecondaryColor3hNV;
#define glSecondaryColor3hNV glad_glSecondaryColor3hNV
GLAD_API_CALL PFNGLSECONDARYCOLOR3HVNVPROC glad_glSecondaryColor3hvNV;
#define glSecondaryColor3hvNV glad_glSecondaryColor3hvNV
GLAD_API_CALL PFNGLSECONDARYCOLOR3IPROC glad_glSecondaryColor3i;
#define glSecondaryColor3i glad_glSecondaryColor3i
GLAD_API_CALL PFNGLSECONDARYCOLOR3IEXTPROC glad_glSecondaryColor3iEXT;
#define glSecondaryColor3iEXT glad_glSecondaryColor3iEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3IVPROC glad_glSecondaryColor3iv;
#define glSecondaryColor3iv glad_glSecondaryColor3iv
GLAD_API_CALL PFNGLSECONDARYCOLOR3IVEXTPROC glad_glSecondaryColor3ivEXT;
#define glSecondaryColor3ivEXT glad_glSecondaryColor3ivEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3SPROC glad_glSecondaryColor3s;
#define glSecondaryColor3s glad_glSecondaryColor3s
GLAD_API_CALL PFNGLSECONDARYCOLOR3SEXTPROC glad_glSecondaryColor3sEXT;
#define glSecondaryColor3sEXT glad_glSecondaryColor3sEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3SVPROC glad_glSecondaryColor3sv;
#define glSecondaryColor3sv glad_glSecondaryColor3sv
GLAD_API_CALL PFNGLSECONDARYCOLOR3SVEXTPROC glad_glSecondaryColor3svEXT;
#define glSecondaryColor3svEXT glad_glSecondaryColor3svEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3UBPROC glad_glSecondaryColor3ub;
#define glSecondaryColor3ub glad_glSecondaryColor3ub
GLAD_API_CALL PFNGLSECONDARYCOLOR3UBEXTPROC glad_glSecondaryColor3ubEXT;
#define glSecondaryColor3ubEXT glad_glSecondaryColor3ubEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3UBVPROC glad_glSecondaryColor3ubv;
#define glSecondaryColor3ubv glad_glSecondaryColor3ubv
GLAD_API_CALL PFNGLSECONDARYCOLOR3UBVEXTPROC glad_glSecondaryColor3ubvEXT;
#define glSecondaryColor3ubvEXT glad_glSecondaryColor3ubvEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3UIPROC glad_glSecondaryColor3ui;
#define glSecondaryColor3ui glad_glSecondaryColor3ui
GLAD_API_CALL PFNGLSECONDARYCOLOR3UIEXTPROC glad_glSecondaryColor3uiEXT;
#define glSecondaryColor3uiEXT glad_glSecondaryColor3uiEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3UIVPROC glad_glSecondaryColor3uiv;
#define glSecondaryColor3uiv glad_glSecondaryColor3uiv
GLAD_API_CALL PFNGLSECONDARYCOLOR3UIVEXTPROC glad_glSecondaryColor3uivEXT;
#define glSecondaryColor3uivEXT glad_glSecondaryColor3uivEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3USPROC glad_glSecondaryColor3us;
#define glSecondaryColor3us glad_glSecondaryColor3us
GLAD_API_CALL PFNGLSECONDARYCOLOR3USEXTPROC glad_glSecondaryColor3usEXT;
#define glSecondaryColor3usEXT glad_glSecondaryColor3usEXT
GLAD_API_CALL PFNGLSECONDARYCOLOR3USVPROC glad_glSecondaryColor3usv;
#define glSecondaryColor3usv glad_glSecondaryColor3usv
GLAD_API_CALL PFNGLSECONDARYCOLOR3USVEXTPROC glad_glSecondaryColor3usvEXT;
#define glSecondaryColor3usvEXT glad_glSecondaryColor3usvEXT
GLAD_API_CALL PFNGLSECONDARYCOLORFORMATNVPROC glad_glSecondaryColorFormatNV;
#define glSecondaryColorFormatNV glad_glSecondaryColorFormatNV
GLAD_API_CALL PFNGLSECONDARYCOLORPOINTERPROC glad_glSecondaryColorPointer;
#define glSecondaryColorPointer glad_glSecondaryColorPointer
GLAD_API_CALL PFNGLSECONDARYCOLORPOINTEREXTPROC glad_glSecondaryColorPointerEXT;
#define glSecondaryColorPointerEXT glad_glSecondaryColorPointerEXT
GLAD_API_CALL PFNGLSELECTPERFMONITORCOUNTERSAMDPROC glad_glSelectPerfMonitorCountersAMD;
#define glSelectPerfMonitorCountersAMD glad_glSelectPerfMonitorCountersAMD
GLAD_API_CALL PFNGLSEMAPHOREPARAMETERUI64VEXTPROC glad_glSemaphoreParameterui64vEXT;
#define glSemaphoreParameterui64vEXT glad_glSemaphoreParameterui64vEXT
GLAD_API_CALL PFNGLSEPARABLEFILTER2DPROC glad_glSeparableFilter2D;
#define glSeparableFilter2D glad_glSeparableFilter2D
GLAD_API_CALL PFNGLSEPARABLEFILTER2DEXTPROC glad_glSeparableFilter2DEXT;
#define glSeparableFilter2DEXT glad_glSeparableFilter2DEXT
GLAD_API_CALL PFNGLSETFENCEAPPLEPROC glad_glSetFenceAPPLE;
#define glSetFenceAPPLE glad_glSetFenceAPPLE
GLAD_API_CALL PFNGLSETFENCENVPROC glad_glSetFenceNV;
#define glSetFenceNV glad_glSetFenceNV
GLAD_API_CALL PFNGLSETFRAGMENTSHADERCONSTANTATIPROC glad_glSetFragmentShaderConstantATI;
#define glSetFragmentShaderConstantATI glad_glSetFragmentShaderConstantATI
GLAD_API_CALL PFNGLSETINVARIANTEXTPROC glad_glSetInvariantEXT;
#define glSetInvariantEXT glad_glSetInvariantEXT
GLAD_API_CALL PFNGLSETLOCALCONSTANTEXTPROC glad_glSetLocalConstantEXT;
#define glSetLocalConstantEXT glad_glSetLocalConstantEXT
GLAD_API_CALL PFNGLSETMULTISAMPLEFVAMDPROC glad_glSetMultisamplefvAMD;
#define glSetMultisamplefvAMD glad_glSetMultisamplefvAMD
GLAD_API_CALL PFNGLSHADERBINARYPROC glad_glShaderBinary;
#define glShaderBinary glad_glShaderBinary
GLAD_API_CALL PFNGLSHADEROP1EXTPROC glad_glShaderOp1EXT;
#define glShaderOp1EXT glad_glShaderOp1EXT
GLAD_API_CALL PFNGLSHADEROP2EXTPROC glad_glShaderOp2EXT;
#define glShaderOp2EXT glad_glShaderOp2EXT
GLAD_API_CALL PFNGLSHADEROP3EXTPROC glad_glShaderOp3EXT;
#define glShaderOp3EXT glad_glShaderOp3EXT
GLAD_API_CALL PFNGLSHADERSOURCEPROC glad_glShaderSource;
#define glShaderSource glad_glShaderSource
GLAD_API_CALL PFNGLSHADERSOURCEARBPROC glad_glShaderSourceARB;
#define glShaderSourceARB glad_glShaderSourceARB
GLAD_API_CALL PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding;
#define glShaderStorageBlockBinding glad_glShaderStorageBlockBinding
GLAD_API_CALL PFNGLSIGNALSEMAPHOREEXTPROC glad_glSignalSemaphoreEXT;
#define glSignalSemaphoreEXT glad_glSignalSemaphoreEXT
GLAD_API_CALL PFNGLSIGNALVKFENCENVPROC glad_glSignalVkFenceNV;
#define glSignalVkFenceNV glad_glSignalVkFenceNV
GLAD_API_CALL PFNGLSIGNALVKSEMAPHORENVPROC glad_glSignalVkSemaphoreNV;
#define glSignalVkSemaphoreNV glad_glSignalVkSemaphoreNV
GLAD_API_CALL PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader;
#define glSpecializeShader glad_glSpecializeShader
GLAD_API_CALL PFNGLSPECIALIZESHADERARBPROC glad_glSpecializeShaderARB;
#define glSpecializeShaderARB glad_glSpecializeShaderARB
GLAD_API_CALL PFNGLSTATECAPTURENVPROC glad_glStateCaptureNV;
#define glStateCaptureNV glad_glStateCaptureNV
GLAD_API_CALL PFNGLSTENCILCLEARTAGEXTPROC glad_glStencilClearTagEXT;
#define glStencilClearTagEXT glad_glStencilClearTagEXT
GLAD_API_CALL PFNGLSTENCILFILLPATHINSTANCEDNVPROC glad_glStencilFillPathInstancedNV;
#define glStencilFillPathInstancedNV glad_glStencilFillPathInstancedNV
GLAD_API_CALL PFNGLSTENCILFILLPATHNVPROC glad_glStencilFillPathNV;
#define glStencilFillPathNV glad_glStencilFillPathNV
GLAD_API_CALL PFNGLSTENCILFUNCPROC glad_glStencilFunc;
#define glStencilFunc glad_glStencilFunc
GLAD_API_CALL PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;
#define glStencilFuncSeparate glad_glStencilFuncSeparate
GLAD_API_CALL PFNGLSTENCILFUNCSEPARATEATIPROC glad_glStencilFuncSeparateATI;
#define glStencilFuncSeparateATI glad_glStencilFuncSeparateATI
GLAD_API_CALL PFNGLSTENCILMASKPROC glad_glStencilMask;
#define glStencilMask glad_glStencilMask
GLAD_API_CALL PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;
#define glStencilMaskSeparate glad_glStencilMaskSeparate
GLAD_API_CALL PFNGLSTENCILOPPROC glad_glStencilOp;
#define glStencilOp glad_glStencilOp
GLAD_API_CALL PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;
#define glStencilOpSeparate glad_glStencilOpSeparate
GLAD_API_CALL PFNGLSTENCILOPSEPARATEATIPROC glad_glStencilOpSeparateATI;
#define glStencilOpSeparateATI glad_glStencilOpSeparateATI
GLAD_API_CALL PFNGLSTENCILOPVALUEAMDPROC glad_glStencilOpValueAMD;
#define glStencilOpValueAMD glad_glStencilOpValueAMD
GLAD_API_CALL PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC glad_glStencilStrokePathInstancedNV;
#define glStencilStrokePathInstancedNV glad_glStencilStrokePathInstancedNV
GLAD_API_CALL PFNGLSTENCILSTROKEPATHNVPROC glad_glStencilStrokePathNV;
#define glStencilStrokePathNV glad_glStencilStrokePathNV
GLAD_API_CALL PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC glad_glStencilThenCoverFillPathInstancedNV;
#define glStencilThenCoverFillPathInstancedNV glad_glStencilThenCoverFillPathInstancedNV
GLAD_API_CALL PFNGLSTENCILTHENCOVERFILLPATHNVPROC glad_glStencilThenCoverFillPathNV;
#define glStencilThenCoverFillPathNV glad_glStencilThenCoverFillPathNV
GLAD_API_CALL PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC glad_glStencilThenCoverStrokePathInstancedNV;
#define glStencilThenCoverStrokePathInstancedNV glad_glStencilThenCoverStrokePathInstancedNV
GLAD_API_CALL PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC glad_glStencilThenCoverStrokePathNV;
#define glStencilThenCoverStrokePathNV glad_glStencilThenCoverStrokePathNV
GLAD_API_CALL PFNGLSUBPIXELPRECISIONBIASNVPROC glad_glSubpixelPrecisionBiasNV;
#define glSubpixelPrecisionBiasNV glad_glSubpixelPrecisionBiasNV
GLAD_API_CALL PFNGLSWIZZLEEXTPROC glad_glSwizzleEXT;
#define glSwizzleEXT glad_glSwizzleEXT
GLAD_API_CALL PFNGLSYNCTEXTUREINTELPROC glad_glSyncTextureINTEL;
#define glSyncTextureINTEL glad_glSyncTextureINTEL
GLAD_API_CALL PFNGLTANGENT3BEXTPROC glad_glTangent3bEXT;
#define glTangent3bEXT glad_glTangent3bEXT
GLAD_API_CALL PFNGLTANGENT3BVEXTPROC glad_glTangent3bvEXT;
#define glTangent3bvEXT glad_glTangent3bvEXT
GLAD_API_CALL PFNGLTANGENT3DEXTPROC glad_glTangent3dEXT;
#define glTangent3dEXT glad_glTangent3dEXT
GLAD_API_CALL PFNGLTANGENT3DVEXTPROC glad_glTangent3dvEXT;
#define glTangent3dvEXT glad_glTangent3dvEXT
GLAD_API_CALL PFNGLTANGENT3FEXTPROC glad_glTangent3fEXT;
#define glTangent3fEXT glad_glTangent3fEXT
GLAD_API_CALL PFNGLTANGENT3FVEXTPROC glad_glTangent3fvEXT;
#define glTangent3fvEXT glad_glTangent3fvEXT
GLAD_API_CALL PFNGLTANGENT3IEXTPROC glad_glTangent3iEXT;
#define glTangent3iEXT glad_glTangent3iEXT
GLAD_API_CALL PFNGLTANGENT3IVEXTPROC glad_glTangent3ivEXT;
#define glTangent3ivEXT glad_glTangent3ivEXT
GLAD_API_CALL PFNGLTANGENT3SEXTPROC glad_glTangent3sEXT;
#define glTangent3sEXT glad_glTangent3sEXT
GLAD_API_CALL PFNGLTANGENT3SVEXTPROC glad_glTangent3svEXT;
#define glTangent3svEXT glad_glTangent3svEXT
GLAD_API_CALL PFNGLTANGENTPOINTEREXTPROC glad_glTangentPointerEXT;
#define glTangentPointerEXT glad_glTangentPointerEXT
GLAD_API_CALL PFNGLTESSELLATIONFACTORAMDPROC glad_glTessellationFactorAMD;
#define glTessellationFactorAMD glad_glTessellationFactorAMD
GLAD_API_CALL PFNGLTESSELLATIONMODEAMDPROC glad_glTessellationModeAMD;
#define glTessellationModeAMD glad_glTessellationModeAMD
GLAD_API_CALL PFNGLTESTFENCEAPPLEPROC glad_glTestFenceAPPLE;
#define glTestFenceAPPLE glad_glTestFenceAPPLE
GLAD_API_CALL PFNGLTESTFENCENVPROC glad_glTestFenceNV;
#define glTestFenceNV glad_glTestFenceNV
GLAD_API_CALL PFNGLTESTOBJECTAPPLEPROC glad_glTestObjectAPPLE;
#define glTestObjectAPPLE glad_glTestObjectAPPLE
GLAD_API_CALL PFNGLTEXBUFFERPROC glad_glTexBuffer;
#define glTexBuffer glad_glTexBuffer
GLAD_API_CALL PFNGLTEXBUFFERARBPROC glad_glTexBufferARB;
#define glTexBufferARB glad_glTexBufferARB
GLAD_API_CALL PFNGLTEXBUFFEREXTPROC glad_glTexBufferEXT;
#define glTexBufferEXT glad_glTexBufferEXT
GLAD_API_CALL PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange;
#define glTexBufferRange glad_glTexBufferRange
GLAD_API_CALL PFNGLTEXBUMPPARAMETERFVATIPROC glad_glTexBumpParameterfvATI;
#define glTexBumpParameterfvATI glad_glTexBumpParameterfvATI
GLAD_API_CALL PFNGLTEXBUMPPARAMETERIVATIPROC glad_glTexBumpParameterivATI;
#define glTexBumpParameterivATI glad_glTexBumpParameterivATI
GLAD_API_CALL PFNGLTEXCOORD1HNVPROC glad_glTexCoord1hNV;
#define glTexCoord1hNV glad_glTexCoord1hNV
GLAD_API_CALL PFNGLTEXCOORD1HVNVPROC glad_glTexCoord1hvNV;
#define glTexCoord1hvNV glad_glTexCoord1hvNV
GLAD_API_CALL PFNGLTEXCOORD2HNVPROC glad_glTexCoord2hNV;
#define glTexCoord2hNV glad_glTexCoord2hNV
GLAD_API_CALL PFNGLTEXCOORD2HVNVPROC glad_glTexCoord2hvNV;
#define glTexCoord2hvNV glad_glTexCoord2hvNV
GLAD_API_CALL PFNGLTEXCOORD3HNVPROC glad_glTexCoord3hNV;
#define glTexCoord3hNV glad_glTexCoord3hNV
GLAD_API_CALL PFNGLTEXCOORD3HVNVPROC glad_glTexCoord3hvNV;
#define glTexCoord3hvNV glad_glTexCoord3hvNV
GLAD_API_CALL PFNGLTEXCOORD4HNVPROC glad_glTexCoord4hNV;
#define glTexCoord4hNV glad_glTexCoord4hNV
GLAD_API_CALL PFNGLTEXCOORD4HVNVPROC glad_glTexCoord4hvNV;
#define glTexCoord4hvNV glad_glTexCoord4hvNV
GLAD_API_CALL PFNGLTEXCOORDFORMATNVPROC glad_glTexCoordFormatNV;
#define glTexCoordFormatNV glad_glTexCoordFormatNV
GLAD_API_CALL PFNGLTEXCOORDPOINTEREXTPROC glad_glTexCoordPointerEXT;
#define glTexCoordPointerEXT glad_glTexCoordPointerEXT
GLAD_API_CALL PFNGLTEXCOORDPOINTERVINTELPROC glad_glTexCoordPointervINTEL;
#define glTexCoordPointervINTEL glad_glTexCoordPointervINTEL
GLAD_API_CALL PFNGLTEXIMAGE1DPROC glad_glTexImage1D;
#define glTexImage1D glad_glTexImage1D
GLAD_API_CALL PFNGLTEXIMAGE2DPROC glad_glTexImage2D;
#define glTexImage2D glad_glTexImage2D
GLAD_API_CALL PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;
#define glTexImage2DMultisample glad_glTexImage2DMultisample
GLAD_API_CALL PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC glad_glTexImage2DMultisampleCoverageNV;
#define glTexImage2DMultisampleCoverageNV glad_glTexImage2DMultisampleCoverageNV
GLAD_API_CALL PFNGLTEXIMAGE3DPROC glad_glTexImage3D;
#define glTexImage3D glad_glTexImage3D
GLAD_API_CALL PFNGLTEXIMAGE3DEXTPROC glad_glTexImage3DEXT;
#define glTexImage3DEXT glad_glTexImage3DEXT
GLAD_API_CALL PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;
#define glTexImage3DMultisample glad_glTexImage3DMultisample
GLAD_API_CALL PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC glad_glTexImage3DMultisampleCoverageNV;
#define glTexImage3DMultisampleCoverageNV glad_glTexImage3DMultisampleCoverageNV
GLAD_API_CALL PFNGLTEXPAGECOMMITMENTARBPROC glad_glTexPageCommitmentARB;
#define glTexPageCommitmentARB glad_glTexPageCommitmentARB
GLAD_API_CALL PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;
#define glTexParameterIiv glad_glTexParameterIiv
GLAD_API_CALL PFNGLTEXPARAMETERIIVEXTPROC glad_glTexParameterIivEXT;
#define glTexParameterIivEXT glad_glTexParameterIivEXT
GLAD_API_CALL PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;
#define glTexParameterIuiv glad_glTexParameterIuiv
GLAD_API_CALL PFNGLTEXPARAMETERIUIVEXTPROC glad_glTexParameterIuivEXT;
#define glTexParameterIuivEXT glad_glTexParameterIuivEXT
GLAD_API_CALL PFNGLTEXPARAMETERFPROC glad_glTexParameterf;
#define glTexParameterf glad_glTexParameterf
GLAD_API_CALL PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;
#define glTexParameterfv glad_glTexParameterfv
GLAD_API_CALL PFNGLTEXPARAMETERIPROC glad_glTexParameteri;
#define glTexParameteri glad_glTexParameteri
GLAD_API_CALL PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;
#define glTexParameteriv glad_glTexParameteriv
GLAD_API_CALL PFNGLTEXRENDERBUFFERNVPROC glad_glTexRenderbufferNV;
#define glTexRenderbufferNV glad_glTexRenderbufferNV
GLAD_API_CALL PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D;
#define glTexStorage1D glad_glTexStorage1D
GLAD_API_CALL PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D;
#define glTexStorage2D glad_glTexStorage2D
GLAD_API_CALL PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample;
#define glTexStorage2DMultisample glad_glTexStorage2DMultisample
GLAD_API_CALL PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D;
#define glTexStorage3D glad_glTexStorage3D
GLAD_API_CALL PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample;
#define glTexStorage3DMultisample glad_glTexStorage3DMultisample
GLAD_API_CALL PFNGLTEXSTORAGEMEM1DEXTPROC glad_glTexStorageMem1DEXT;
#define glTexStorageMem1DEXT glad_glTexStorageMem1DEXT
GLAD_API_CALL PFNGLTEXSTORAGEMEM2DEXTPROC glad_glTexStorageMem2DEXT;
#define glTexStorageMem2DEXT glad_glTexStorageMem2DEXT
GLAD_API_CALL PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC glad_glTexStorageMem2DMultisampleEXT;
#define glTexStorageMem2DMultisampleEXT glad_glTexStorageMem2DMultisampleEXT
GLAD_API_CALL PFNGLTEXSTORAGEMEM3DEXTPROC glad_glTexStorageMem3DEXT;
#define glTexStorageMem3DEXT glad_glTexStorageMem3DEXT
GLAD_API_CALL PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC glad_glTexStorageMem3DMultisampleEXT;
#define glTexStorageMem3DMultisampleEXT glad_glTexStorageMem3DMultisampleEXT
GLAD_API_CALL PFNGLTEXSTORAGESPARSEAMDPROC glad_glTexStorageSparseAMD;
#define glTexStorageSparseAMD glad_glTexStorageSparseAMD
GLAD_API_CALL PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;
#define glTexSubImage1D glad_glTexSubImage1D
GLAD_API_CALL PFNGLTEXSUBIMAGE1DEXTPROC glad_glTexSubImage1DEXT;
#define glTexSubImage1DEXT glad_glTexSubImage1DEXT
GLAD_API_CALL PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;
#define glTexSubImage2D glad_glTexSubImage2D
GLAD_API_CALL PFNGLTEXSUBIMAGE2DEXTPROC glad_glTexSubImage2DEXT;
#define glTexSubImage2DEXT glad_glTexSubImage2DEXT
GLAD_API_CALL PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;
#define glTexSubImage3D glad_glTexSubImage3D
GLAD_API_CALL PFNGLTEXSUBIMAGE3DEXTPROC glad_glTexSubImage3DEXT;
#define glTexSubImage3DEXT glad_glTexSubImage3DEXT
GLAD_API_CALL PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier;
#define glTextureBarrier glad_glTextureBarrier
GLAD_API_CALL PFNGLTEXTUREBARRIERNVPROC glad_glTextureBarrierNV;
#define glTextureBarrierNV glad_glTextureBarrierNV
GLAD_API_CALL PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer;
#define glTextureBuffer glad_glTextureBuffer
GLAD_API_CALL PFNGLTEXTUREBUFFEREXTPROC glad_glTextureBufferEXT;
#define glTextureBufferEXT glad_glTextureBufferEXT
GLAD_API_CALL PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange;
#define glTextureBufferRange glad_glTextureBufferRange
GLAD_API_CALL PFNGLTEXTUREBUFFERRANGEEXTPROC glad_glTextureBufferRangeEXT;
#define glTextureBufferRangeEXT glad_glTextureBufferRangeEXT
GLAD_API_CALL PFNGLTEXTUREIMAGE1DEXTPROC glad_glTextureImage1DEXT;
#define glTextureImage1DEXT glad_glTextureImage1DEXT
GLAD_API_CALL PFNGLTEXTUREIMAGE2DEXTPROC glad_glTextureImage2DEXT;
#define glTextureImage2DEXT glad_glTextureImage2DEXT
GLAD_API_CALL PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC glad_glTextureImage2DMultisampleCoverageNV;
#define glTextureImage2DMultisampleCoverageNV glad_glTextureImage2DMultisampleCoverageNV
GLAD_API_CALL PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC glad_glTextureImage2DMultisampleNV;
#define glTextureImage2DMultisampleNV glad_glTextureImage2DMultisampleNV
GLAD_API_CALL PFNGLTEXTUREIMAGE3DEXTPROC glad_glTextureImage3DEXT;
#define glTextureImage3DEXT glad_glTextureImage3DEXT
GLAD_API_CALL PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC glad_glTextureImage3DMultisampleCoverageNV;
#define glTextureImage3DMultisampleCoverageNV glad_glTextureImage3DMultisampleCoverageNV
GLAD_API_CALL PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC glad_glTextureImage3DMultisampleNV;
#define glTextureImage3DMultisampleNV glad_glTextureImage3DMultisampleNV
GLAD_API_CALL PFNGLTEXTURELIGHTEXTPROC glad_glTextureLightEXT;
#define glTextureLightEXT glad_glTextureLightEXT
GLAD_API_CALL PFNGLTEXTUREMATERIALEXTPROC glad_glTextureMaterialEXT;
#define glTextureMaterialEXT glad_glTextureMaterialEXT
GLAD_API_CALL PFNGLTEXTURENORMALEXTPROC glad_glTextureNormalEXT;
#define glTextureNormalEXT glad_glTextureNormalEXT
GLAD_API_CALL PFNGLTEXTUREPAGECOMMITMENTEXTPROC glad_glTexturePageCommitmentEXT;
#define glTexturePageCommitmentEXT glad_glTexturePageCommitmentEXT
GLAD_API_CALL PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv;
#define glTextureParameterIiv glad_glTextureParameterIiv
GLAD_API_CALL PFNGLTEXTUREPARAMETERIIVEXTPROC glad_glTextureParameterIivEXT;
#define glTextureParameterIivEXT glad_glTextureParameterIivEXT
GLAD_API_CALL PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv;
#define glTextureParameterIuiv glad_glTextureParameterIuiv
GLAD_API_CALL PFNGLTEXTUREPARAMETERIUIVEXTPROC glad_glTextureParameterIuivEXT;
#define glTextureParameterIuivEXT glad_glTextureParameterIuivEXT
GLAD_API_CALL PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf;
#define glTextureParameterf glad_glTextureParameterf
GLAD_API_CALL PFNGLTEXTUREPARAMETERFEXTPROC glad_glTextureParameterfEXT;
#define glTextureParameterfEXT glad_glTextureParameterfEXT
GLAD_API_CALL PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv;
#define glTextureParameterfv glad_glTextureParameterfv
GLAD_API_CALL PFNGLTEXTUREPARAMETERFVEXTPROC glad_glTextureParameterfvEXT;
#define glTextureParameterfvEXT glad_glTextureParameterfvEXT
GLAD_API_CALL PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri;
#define glTextureParameteri glad_glTextureParameteri
GLAD_API_CALL PFNGLTEXTUREPARAMETERIEXTPROC glad_glTextureParameteriEXT;
#define glTextureParameteriEXT glad_glTextureParameteriEXT
GLAD_API_CALL PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv;
#define glTextureParameteriv glad_glTextureParameteriv
GLAD_API_CALL PFNGLTEXTUREPARAMETERIVEXTPROC glad_glTextureParameterivEXT;
#define glTextureParameterivEXT glad_glTextureParameterivEXT
GLAD_API_CALL PFNGLTEXTURERANGEAPPLEPROC glad_glTextureRangeAPPLE;
#define glTextureRangeAPPLE glad_glTextureRangeAPPLE
GLAD_API_CALL PFNGLTEXTURERENDERBUFFEREXTPROC glad_glTextureRenderbufferEXT;
#define glTextureRenderbufferEXT glad_glTextureRenderbufferEXT
GLAD_API_CALL PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D;
#define glTextureStorage1D glad_glTextureStorage1D
GLAD_API_CALL PFNGLTEXTURESTORAGE1DEXTPROC glad_glTextureStorage1DEXT;
#define glTextureStorage1DEXT glad_glTextureStorage1DEXT
GLAD_API_CALL PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D;
#define glTextureStorage2D glad_glTextureStorage2D
GLAD_API_CALL PFNGLTEXTURESTORAGE2DEXTPROC glad_glTextureStorage2DEXT;
#define glTextureStorage2DEXT glad_glTextureStorage2DEXT
GLAD_API_CALL PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample;
#define glTextureStorage2DMultisample glad_glTextureStorage2DMultisample
GLAD_API_CALL PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC glad_glTextureStorage2DMultisampleEXT;
#define glTextureStorage2DMultisampleEXT glad_glTextureStorage2DMultisampleEXT
GLAD_API_CALL PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D;
#define glTextureStorage3D glad_glTextureStorage3D
GLAD_API_CALL PFNGLTEXTURESTORAGE3DEXTPROC glad_glTextureStorage3DEXT;
#define glTextureStorage3DEXT glad_glTextureStorage3DEXT
GLAD_API_CALL PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample;
#define glTextureStorage3DMultisample glad_glTextureStorage3DMultisample
GLAD_API_CALL PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC glad_glTextureStorage3DMultisampleEXT;
#define glTextureStorage3DMultisampleEXT glad_glTextureStorage3DMultisampleEXT
GLAD_API_CALL PFNGLTEXTURESTORAGEMEM1DEXTPROC glad_glTextureStorageMem1DEXT;
#define glTextureStorageMem1DEXT glad_glTextureStorageMem1DEXT
GLAD_API_CALL PFNGLTEXTURESTORAGEMEM2DEXTPROC glad_glTextureStorageMem2DEXT;
#define glTextureStorageMem2DEXT glad_glTextureStorageMem2DEXT
GLAD_API_CALL PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC glad_glTextureStorageMem2DMultisampleEXT;
#define glTextureStorageMem2DMultisampleEXT glad_glTextureStorageMem2DMultisampleEXT
GLAD_API_CALL PFNGLTEXTURESTORAGEMEM3DEXTPROC glad_glTextureStorageMem3DEXT;
#define glTextureStorageMem3DEXT glad_glTextureStorageMem3DEXT
GLAD_API_CALL PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC glad_glTextureStorageMem3DMultisampleEXT;
#define glTextureStorageMem3DMultisampleEXT glad_glTextureStorageMem3DMultisampleEXT
GLAD_API_CALL PFNGLTEXTURESTORAGESPARSEAMDPROC glad_glTextureStorageSparseAMD;
#define glTextureStorageSparseAMD glad_glTextureStorageSparseAMD
GLAD_API_CALL PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D;
#define glTextureSubImage1D glad_glTextureSubImage1D
GLAD_API_CALL PFNGLTEXTURESUBIMAGE1DEXTPROC glad_glTextureSubImage1DEXT;
#define glTextureSubImage1DEXT glad_glTextureSubImage1DEXT
GLAD_API_CALL PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D;
#define glTextureSubImage2D glad_glTextureSubImage2D
GLAD_API_CALL PFNGLTEXTURESUBIMAGE2DEXTPROC glad_glTextureSubImage2DEXT;
#define glTextureSubImage2DEXT glad_glTextureSubImage2DEXT
GLAD_API_CALL PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D;
#define glTextureSubImage3D glad_glTextureSubImage3D
GLAD_API_CALL PFNGLTEXTURESUBIMAGE3DEXTPROC glad_glTextureSubImage3DEXT;
#define glTextureSubImage3DEXT glad_glTextureSubImage3DEXT
GLAD_API_CALL PFNGLTEXTUREVIEWPROC glad_glTextureView;
#define glTextureView glad_glTextureView
GLAD_API_CALL PFNGLTRACKMATRIXNVPROC glad_glTrackMatrixNV;
#define glTrackMatrixNV glad_glTrackMatrixNV
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC glad_glTransformFeedbackAttribsNV;
#define glTransformFeedbackAttribsNV glad_glTransformFeedbackAttribsNV
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase;
#define glTransformFeedbackBufferBase glad_glTransformFeedbackBufferBase
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange;
#define glTransformFeedbackBufferRange glad_glTransformFeedbackBufferRange
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC glad_glTransformFeedbackStreamAttribsNV;
#define glTransformFeedbackStreamAttribsNV glad_glTransformFeedbackStreamAttribsNV
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;
#define glTransformFeedbackVaryings glad_glTransformFeedbackVaryings
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC glad_glTransformFeedbackVaryingsEXT;
#define glTransformFeedbackVaryingsEXT glad_glTransformFeedbackVaryingsEXT
GLAD_API_CALL PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC glad_glTransformFeedbackVaryingsNV;
#define glTransformFeedbackVaryingsNV glad_glTransformFeedbackVaryingsNV
GLAD_API_CALL PFNGLTRANSFORMPATHNVPROC glad_glTransformPathNV;
#define glTransformPathNV glad_glTransformPathNV
GLAD_API_CALL PFNGLUNIFORM1DPROC glad_glUniform1d;
#define glUniform1d glad_glUniform1d
GLAD_API_CALL PFNGLUNIFORM1DVPROC glad_glUniform1dv;
#define glUniform1dv glad_glUniform1dv
GLAD_API_CALL PFNGLUNIFORM1FPROC glad_glUniform1f;
#define glUniform1f glad_glUniform1f
GLAD_API_CALL PFNGLUNIFORM1FARBPROC glad_glUniform1fARB;
#define glUniform1fARB glad_glUniform1fARB
GLAD_API_CALL PFNGLUNIFORM1FVPROC glad_glUniform1fv;
#define glUniform1fv glad_glUniform1fv
GLAD_API_CALL PFNGLUNIFORM1FVARBPROC glad_glUniform1fvARB;
#define glUniform1fvARB glad_glUniform1fvARB
GLAD_API_CALL PFNGLUNIFORM1IPROC glad_glUniform1i;
#define glUniform1i glad_glUniform1i
GLAD_API_CALL PFNGLUNIFORM1I64ARBPROC glad_glUniform1i64ARB;
#define glUniform1i64ARB glad_glUniform1i64ARB
GLAD_API_CALL PFNGLUNIFORM1I64NVPROC glad_glUniform1i64NV;
#define glUniform1i64NV glad_glUniform1i64NV
GLAD_API_CALL PFNGLUNIFORM1I64VARBPROC glad_glUniform1i64vARB;
#define glUniform1i64vARB glad_glUniform1i64vARB
GLAD_API_CALL PFNGLUNIFORM1I64VNVPROC glad_glUniform1i64vNV;
#define glUniform1i64vNV glad_glUniform1i64vNV
GLAD_API_CALL PFNGLUNIFORM1IARBPROC glad_glUniform1iARB;
#define glUniform1iARB glad_glUniform1iARB
GLAD_API_CALL PFNGLUNIFORM1IVPROC glad_glUniform1iv;
#define glUniform1iv glad_glUniform1iv
GLAD_API_CALL PFNGLUNIFORM1IVARBPROC glad_glUniform1ivARB;
#define glUniform1ivARB glad_glUniform1ivARB
GLAD_API_CALL PFNGLUNIFORM1UIPROC glad_glUniform1ui;
#define glUniform1ui glad_glUniform1ui
GLAD_API_CALL PFNGLUNIFORM1UI64ARBPROC glad_glUniform1ui64ARB;
#define glUniform1ui64ARB glad_glUniform1ui64ARB
GLAD_API_CALL PFNGLUNIFORM1UI64NVPROC glad_glUniform1ui64NV;
#define glUniform1ui64NV glad_glUniform1ui64NV
GLAD_API_CALL PFNGLUNIFORM1UI64VARBPROC glad_glUniform1ui64vARB;
#define glUniform1ui64vARB glad_glUniform1ui64vARB
GLAD_API_CALL PFNGLUNIFORM1UI64VNVPROC glad_glUniform1ui64vNV;
#define glUniform1ui64vNV glad_glUniform1ui64vNV
GLAD_API_CALL PFNGLUNIFORM1UIEXTPROC glad_glUniform1uiEXT;
#define glUniform1uiEXT glad_glUniform1uiEXT
GLAD_API_CALL PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;
#define glUniform1uiv glad_glUniform1uiv
GLAD_API_CALL PFNGLUNIFORM1UIVEXTPROC glad_glUniform1uivEXT;
#define glUniform1uivEXT glad_glUniform1uivEXT
GLAD_API_CALL PFNGLUNIFORM2DPROC glad_glUniform2d;
#define glUniform2d glad_glUniform2d
GLAD_API_CALL PFNGLUNIFORM2DVPROC glad_glUniform2dv;
#define glUniform2dv glad_glUniform2dv
GLAD_API_CALL PFNGLUNIFORM2FPROC glad_glUniform2f;
#define glUniform2f glad_glUniform2f
GLAD_API_CALL PFNGLUNIFORM2FARBPROC glad_glUniform2fARB;
#define glUniform2fARB glad_glUniform2fARB
GLAD_API_CALL PFNGLUNIFORM2FVPROC glad_glUniform2fv;
#define glUniform2fv glad_glUniform2fv
GLAD_API_CALL PFNGLUNIFORM2FVARBPROC glad_glUniform2fvARB;
#define glUniform2fvARB glad_glUniform2fvARB
GLAD_API_CALL PFNGLUNIFORM2IPROC glad_glUniform2i;
#define glUniform2i glad_glUniform2i
GLAD_API_CALL PFNGLUNIFORM2I64ARBPROC glad_glUniform2i64ARB;
#define glUniform2i64ARB glad_glUniform2i64ARB
GLAD_API_CALL PFNGLUNIFORM2I64NVPROC glad_glUniform2i64NV;
#define glUniform2i64NV glad_glUniform2i64NV
GLAD_API_CALL PFNGLUNIFORM2I64VARBPROC glad_glUniform2i64vARB;
#define glUniform2i64vARB glad_glUniform2i64vARB
GLAD_API_CALL PFNGLUNIFORM2I64VNVPROC glad_glUniform2i64vNV;
#define glUniform2i64vNV glad_glUniform2i64vNV
GLAD_API_CALL PFNGLUNIFORM2IARBPROC glad_glUniform2iARB;
#define glUniform2iARB glad_glUniform2iARB
GLAD_API_CALL PFNGLUNIFORM2IVPROC glad_glUniform2iv;
#define glUniform2iv glad_glUniform2iv
GLAD_API_CALL PFNGLUNIFORM2IVARBPROC glad_glUniform2ivARB;
#define glUniform2ivARB glad_glUniform2ivARB
GLAD_API_CALL PFNGLUNIFORM2UIPROC glad_glUniform2ui;
#define glUniform2ui glad_glUniform2ui
GLAD_API_CALL PFNGLUNIFORM2UI64ARBPROC glad_glUniform2ui64ARB;
#define glUniform2ui64ARB glad_glUniform2ui64ARB
GLAD_API_CALL PFNGLUNIFORM2UI64NVPROC glad_glUniform2ui64NV;
#define glUniform2ui64NV glad_glUniform2ui64NV
GLAD_API_CALL PFNGLUNIFORM2UI64VARBPROC glad_glUniform2ui64vARB;
#define glUniform2ui64vARB glad_glUniform2ui64vARB
GLAD_API_CALL PFNGLUNIFORM2UI64VNVPROC glad_glUniform2ui64vNV;
#define glUniform2ui64vNV glad_glUniform2ui64vNV
GLAD_API_CALL PFNGLUNIFORM2UIEXTPROC glad_glUniform2uiEXT;
#define glUniform2uiEXT glad_glUniform2uiEXT
GLAD_API_CALL PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;
#define glUniform2uiv glad_glUniform2uiv
GLAD_API_CALL PFNGLUNIFORM2UIVEXTPROC glad_glUniform2uivEXT;
#define glUniform2uivEXT glad_glUniform2uivEXT
GLAD_API_CALL PFNGLUNIFORM3DPROC glad_glUniform3d;
#define glUniform3d glad_glUniform3d
GLAD_API_CALL PFNGLUNIFORM3DVPROC glad_glUniform3dv;
#define glUniform3dv glad_glUniform3dv
GLAD_API_CALL PFNGLUNIFORM3FPROC glad_glUniform3f;
#define glUniform3f glad_glUniform3f
GLAD_API_CALL PFNGLUNIFORM3FARBPROC glad_glUniform3fARB;
#define glUniform3fARB glad_glUniform3fARB
GLAD_API_CALL PFNGLUNIFORM3FVPROC glad_glUniform3fv;
#define glUniform3fv glad_glUniform3fv
GLAD_API_CALL PFNGLUNIFORM3FVARBPROC glad_glUniform3fvARB;
#define glUniform3fvARB glad_glUniform3fvARB
GLAD_API_CALL PFNGLUNIFORM3IPROC glad_glUniform3i;
#define glUniform3i glad_glUniform3i
GLAD_API_CALL PFNGLUNIFORM3I64ARBPROC glad_glUniform3i64ARB;
#define glUniform3i64ARB glad_glUniform3i64ARB
GLAD_API_CALL PFNGLUNIFORM3I64NVPROC glad_glUniform3i64NV;
#define glUniform3i64NV glad_glUniform3i64NV
GLAD_API_CALL PFNGLUNIFORM3I64VARBPROC glad_glUniform3i64vARB;
#define glUniform3i64vARB glad_glUniform3i64vARB
GLAD_API_CALL PFNGLUNIFORM3I64VNVPROC glad_glUniform3i64vNV;
#define glUniform3i64vNV glad_glUniform3i64vNV
GLAD_API_CALL PFNGLUNIFORM3IARBPROC glad_glUniform3iARB;
#define glUniform3iARB glad_glUniform3iARB
GLAD_API_CALL PFNGLUNIFORM3IVPROC glad_glUniform3iv;
#define glUniform3iv glad_glUniform3iv
GLAD_API_CALL PFNGLUNIFORM3IVARBPROC glad_glUniform3ivARB;
#define glUniform3ivARB glad_glUniform3ivARB
GLAD_API_CALL PFNGLUNIFORM3UIPROC glad_glUniform3ui;
#define glUniform3ui glad_glUniform3ui
GLAD_API_CALL PFNGLUNIFORM3UI64ARBPROC glad_glUniform3ui64ARB;
#define glUniform3ui64ARB glad_glUniform3ui64ARB
GLAD_API_CALL PFNGLUNIFORM3UI64NVPROC glad_glUniform3ui64NV;
#define glUniform3ui64NV glad_glUniform3ui64NV
GLAD_API_CALL PFNGLUNIFORM3UI64VARBPROC glad_glUniform3ui64vARB;
#define glUniform3ui64vARB glad_glUniform3ui64vARB
GLAD_API_CALL PFNGLUNIFORM3UI64VNVPROC glad_glUniform3ui64vNV;
#define glUniform3ui64vNV glad_glUniform3ui64vNV
GLAD_API_CALL PFNGLUNIFORM3UIEXTPROC glad_glUniform3uiEXT;
#define glUniform3uiEXT glad_glUniform3uiEXT
GLAD_API_CALL PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;
#define glUniform3uiv glad_glUniform3uiv
GLAD_API_CALL PFNGLUNIFORM3UIVEXTPROC glad_glUniform3uivEXT;
#define glUniform3uivEXT glad_glUniform3uivEXT
GLAD_API_CALL PFNGLUNIFORM4DPROC glad_glUniform4d;
#define glUniform4d glad_glUniform4d
GLAD_API_CALL PFNGLUNIFORM4DVPROC glad_glUniform4dv;
#define glUniform4dv glad_glUniform4dv
GLAD_API_CALL PFNGLUNIFORM4FPROC glad_glUniform4f;
#define glUniform4f glad_glUniform4f
GLAD_API_CALL PFNGLUNIFORM4FARBPROC glad_glUniform4fARB;
#define glUniform4fARB glad_glUniform4fARB
GLAD_API_CALL PFNGLUNIFORM4FVPROC glad_glUniform4fv;
#define glUniform4fv glad_glUniform4fv
GLAD_API_CALL PFNGLUNIFORM4FVARBPROC glad_glUniform4fvARB;
#define glUniform4fvARB glad_glUniform4fvARB
GLAD_API_CALL PFNGLUNIFORM4IPROC glad_glUniform4i;
#define glUniform4i glad_glUniform4i
GLAD_API_CALL PFNGLUNIFORM4I64ARBPROC glad_glUniform4i64ARB;
#define glUniform4i64ARB glad_glUniform4i64ARB
GLAD_API_CALL PFNGLUNIFORM4I64NVPROC glad_glUniform4i64NV;
#define glUniform4i64NV glad_glUniform4i64NV
GLAD_API_CALL PFNGLUNIFORM4I64VARBPROC glad_glUniform4i64vARB;
#define glUniform4i64vARB glad_glUniform4i64vARB
GLAD_API_CALL PFNGLUNIFORM4I64VNVPROC glad_glUniform4i64vNV;
#define glUniform4i64vNV glad_glUniform4i64vNV
GLAD_API_CALL PFNGLUNIFORM4IARBPROC glad_glUniform4iARB;
#define glUniform4iARB glad_glUniform4iARB
GLAD_API_CALL PFNGLUNIFORM4IVPROC glad_glUniform4iv;
#define glUniform4iv glad_glUniform4iv
GLAD_API_CALL PFNGLUNIFORM4IVARBPROC glad_glUniform4ivARB;
#define glUniform4ivARB glad_glUniform4ivARB
GLAD_API_CALL PFNGLUNIFORM4UIPROC glad_glUniform4ui;
#define glUniform4ui glad_glUniform4ui
GLAD_API_CALL PFNGLUNIFORM4UI64ARBPROC glad_glUniform4ui64ARB;
#define glUniform4ui64ARB glad_glUniform4ui64ARB
GLAD_API_CALL PFNGLUNIFORM4UI64NVPROC glad_glUniform4ui64NV;
#define glUniform4ui64NV glad_glUniform4ui64NV
GLAD_API_CALL PFNGLUNIFORM4UI64VARBPROC glad_glUniform4ui64vARB;
#define glUniform4ui64vARB glad_glUniform4ui64vARB
GLAD_API_CALL PFNGLUNIFORM4UI64VNVPROC glad_glUniform4ui64vNV;
#define glUniform4ui64vNV glad_glUniform4ui64vNV
GLAD_API_CALL PFNGLUNIFORM4UIEXTPROC glad_glUniform4uiEXT;
#define glUniform4uiEXT glad_glUniform4uiEXT
GLAD_API_CALL PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;
#define glUniform4uiv glad_glUniform4uiv
GLAD_API_CALL PFNGLUNIFORM4UIVEXTPROC glad_glUniform4uivEXT;
#define glUniform4uivEXT glad_glUniform4uivEXT
GLAD_API_CALL PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;
#define glUniformBlockBinding glad_glUniformBlockBinding
GLAD_API_CALL PFNGLUNIFORMBUFFEREXTPROC glad_glUniformBufferEXT;
#define glUniformBufferEXT glad_glUniformBufferEXT
GLAD_API_CALL PFNGLUNIFORMHANDLEUI64ARBPROC glad_glUniformHandleui64ARB;
#define glUniformHandleui64ARB glad_glUniformHandleui64ARB
GLAD_API_CALL PFNGLUNIFORMHANDLEUI64NVPROC glad_glUniformHandleui64NV;
#define glUniformHandleui64NV glad_glUniformHandleui64NV
GLAD_API_CALL PFNGLUNIFORMHANDLEUI64VARBPROC glad_glUniformHandleui64vARB;
#define glUniformHandleui64vARB glad_glUniformHandleui64vARB
GLAD_API_CALL PFNGLUNIFORMHANDLEUI64VNVPROC glad_glUniformHandleui64vNV;
#define glUniformHandleui64vNV glad_glUniformHandleui64vNV
GLAD_API_CALL PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv;
#define glUniformMatrix2dv glad_glUniformMatrix2dv
GLAD_API_CALL PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;
#define glUniformMatrix2fv glad_glUniformMatrix2fv
GLAD_API_CALL PFNGLUNIFORMMATRIX2FVARBPROC glad_glUniformMatrix2fvARB;
#define glUniformMatrix2fvARB glad_glUniformMatrix2fvARB
GLAD_API_CALL PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv;
#define glUniformMatrix2x3dv glad_glUniformMatrix2x3dv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;
#define glUniformMatrix2x3fv glad_glUniformMatrix2x3fv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv;
#define glUniformMatrix2x4dv glad_glUniformMatrix2x4dv
GLAD_API_CALL PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;
#define glUniformMatrix2x4fv glad_glUniformMatrix2x4fv
GLAD_API_CALL PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv;
#define glUniformMatrix3dv glad_glUniformMatrix3dv
GLAD_API_CALL PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;
#define glUniformMatrix3fv glad_glUniformMatrix3fv
GLAD_API_CALL PFNGLUNIFORMMATRIX3FVARBPROC glad_glUniformMatrix3fvARB;
#define glUniformMatrix3fvARB glad_glUniformMatrix3fvARB
GLAD_API_CALL PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv;
#define glUniformMatrix3x2dv glad_glUniformMatrix3x2dv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;
#define glUniformMatrix3x2fv glad_glUniformMatrix3x2fv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv;
#define glUniformMatrix3x4dv glad_glUniformMatrix3x4dv
GLAD_API_CALL PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;
#define glUniformMatrix3x4fv glad_glUniformMatrix3x4fv
GLAD_API_CALL PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv;
#define glUniformMatrix4dv glad_glUniformMatrix4dv
GLAD_API_CALL PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;
#define glUniformMatrix4fv glad_glUniformMatrix4fv
GLAD_API_CALL PFNGLUNIFORMMATRIX4FVARBPROC glad_glUniformMatrix4fvARB;
#define glUniformMatrix4fvARB glad_glUniformMatrix4fvARB
GLAD_API_CALL PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv;
#define glUniformMatrix4x2dv glad_glUniformMatrix4x2dv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;
#define glUniformMatrix4x2fv glad_glUniformMatrix4x2fv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv;
#define glUniformMatrix4x3dv glad_glUniformMatrix4x3dv
GLAD_API_CALL PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;
#define glUniformMatrix4x3fv glad_glUniformMatrix4x3fv
GLAD_API_CALL PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv;
#define glUniformSubroutinesuiv glad_glUniformSubroutinesuiv
GLAD_API_CALL PFNGLUNIFORMUI64NVPROC glad_glUniformui64NV;
#define glUniformui64NV glad_glUniformui64NV
GLAD_API_CALL PFNGLUNIFORMUI64VNVPROC glad_glUniformui64vNV;
#define glUniformui64vNV glad_glUniformui64vNV
GLAD_API_CALL PFNGLUNLOCKARRAYSEXTPROC glad_glUnlockArraysEXT;
#define glUnlockArraysEXT glad_glUnlockArraysEXT
GLAD_API_CALL PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;
#define glUnmapBuffer glad_glUnmapBuffer
GLAD_API_CALL PFNGLUNMAPBUFFERARBPROC glad_glUnmapBufferARB;
#define glUnmapBufferARB glad_glUnmapBufferARB
GLAD_API_CALL PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer;
#define glUnmapNamedBuffer glad_glUnmapNamedBuffer
GLAD_API_CALL PFNGLUNMAPNAMEDBUFFEREXTPROC glad_glUnmapNamedBufferEXT;
#define glUnmapNamedBufferEXT glad_glUnmapNamedBufferEXT
GLAD_API_CALL PFNGLUNMAPOBJECTBUFFERATIPROC glad_glUnmapObjectBufferATI;
#define glUnmapObjectBufferATI glad_glUnmapObjectBufferATI
GLAD_API_CALL PFNGLUNMAPTEXTURE2DINTELPROC glad_glUnmapTexture2DINTEL;
#define glUnmapTexture2DINTEL glad_glUnmapTexture2DINTEL
GLAD_API_CALL PFNGLUPDATEOBJECTBUFFERATIPROC glad_glUpdateObjectBufferATI;
#define glUpdateObjectBufferATI glad_glUpdateObjectBufferATI
GLAD_API_CALL PFNGLUSEPROGRAMPROC glad_glUseProgram;
#define glUseProgram glad_glUseProgram
GLAD_API_CALL PFNGLUSEPROGRAMOBJECTARBPROC glad_glUseProgramObjectARB;
#define glUseProgramObjectARB glad_glUseProgramObjectARB
GLAD_API_CALL PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages;
#define glUseProgramStages glad_glUseProgramStages
GLAD_API_CALL PFNGLUSESHADERPROGRAMEXTPROC glad_glUseShaderProgramEXT;
#define glUseShaderProgramEXT glad_glUseShaderProgramEXT
GLAD_API_CALL PFNGLVDPAUFININVPROC glad_glVDPAUFiniNV;
#define glVDPAUFiniNV glad_glVDPAUFiniNV
GLAD_API_CALL PFNGLVDPAUGETSURFACEIVNVPROC glad_glVDPAUGetSurfaceivNV;
#define glVDPAUGetSurfaceivNV glad_glVDPAUGetSurfaceivNV
GLAD_API_CALL PFNGLVDPAUINITNVPROC glad_glVDPAUInitNV;
#define glVDPAUInitNV glad_glVDPAUInitNV
GLAD_API_CALL PFNGLVDPAUISSURFACENVPROC glad_glVDPAUIsSurfaceNV;
#define glVDPAUIsSurfaceNV glad_glVDPAUIsSurfaceNV
GLAD_API_CALL PFNGLVDPAUMAPSURFACESNVPROC glad_glVDPAUMapSurfacesNV;
#define glVDPAUMapSurfacesNV glad_glVDPAUMapSurfacesNV
GLAD_API_CALL PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC glad_glVDPAURegisterOutputSurfaceNV;
#define glVDPAURegisterOutputSurfaceNV glad_glVDPAURegisterOutputSurfaceNV
GLAD_API_CALL PFNGLVDPAUREGISTERVIDEOSURFACENVPROC glad_glVDPAURegisterVideoSurfaceNV;
#define glVDPAURegisterVideoSurfaceNV glad_glVDPAURegisterVideoSurfaceNV
GLAD_API_CALL PFNGLVDPAUSURFACEACCESSNVPROC glad_glVDPAUSurfaceAccessNV;
#define glVDPAUSurfaceAccessNV glad_glVDPAUSurfaceAccessNV
GLAD_API_CALL PFNGLVDPAUUNMAPSURFACESNVPROC glad_glVDPAUUnmapSurfacesNV;
#define glVDPAUUnmapSurfacesNV glad_glVDPAUUnmapSurfacesNV
GLAD_API_CALL PFNGLVDPAUUNREGISTERSURFACENVPROC glad_glVDPAUUnregisterSurfaceNV;
#define glVDPAUUnregisterSurfaceNV glad_glVDPAUUnregisterSurfaceNV
GLAD_API_CALL PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;
#define glValidateProgram glad_glValidateProgram
GLAD_API_CALL PFNGLVALIDATEPROGRAMARBPROC glad_glValidateProgramARB;
#define glValidateProgramARB glad_glValidateProgramARB
GLAD_API_CALL PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline;
#define glValidateProgramPipeline glad_glValidateProgramPipeline
GLAD_API_CALL PFNGLVARIANTARRAYOBJECTATIPROC glad_glVariantArrayObjectATI;
#define glVariantArrayObjectATI glad_glVariantArrayObjectATI
GLAD_API_CALL PFNGLVARIANTPOINTEREXTPROC glad_glVariantPointerEXT;
#define glVariantPointerEXT glad_glVariantPointerEXT
GLAD_API_CALL PFNGLVARIANTBVEXTPROC glad_glVariantbvEXT;
#define glVariantbvEXT glad_glVariantbvEXT
GLAD_API_CALL PFNGLVARIANTDVEXTPROC glad_glVariantdvEXT;
#define glVariantdvEXT glad_glVariantdvEXT
GLAD_API_CALL PFNGLVARIANTFVEXTPROC glad_glVariantfvEXT;
#define glVariantfvEXT glad_glVariantfvEXT
GLAD_API_CALL PFNGLVARIANTIVEXTPROC glad_glVariantivEXT;
#define glVariantivEXT glad_glVariantivEXT
GLAD_API_CALL PFNGLVARIANTSVEXTPROC glad_glVariantsvEXT;
#define glVariantsvEXT glad_glVariantsvEXT
GLAD_API_CALL PFNGLVARIANTUBVEXTPROC glad_glVariantubvEXT;
#define glVariantubvEXT glad_glVariantubvEXT
GLAD_API_CALL PFNGLVARIANTUIVEXTPROC glad_glVariantuivEXT;
#define glVariantuivEXT glad_glVariantuivEXT
GLAD_API_CALL PFNGLVARIANTUSVEXTPROC glad_glVariantusvEXT;
#define glVariantusvEXT glad_glVariantusvEXT
GLAD_API_CALL PFNGLVERTEX2HNVPROC glad_glVertex2hNV;
#define glVertex2hNV glad_glVertex2hNV
GLAD_API_CALL PFNGLVERTEX2HVNVPROC glad_glVertex2hvNV;
#define glVertex2hvNV glad_glVertex2hvNV
GLAD_API_CALL PFNGLVERTEX3HNVPROC glad_glVertex3hNV;
#define glVertex3hNV glad_glVertex3hNV
GLAD_API_CALL PFNGLVERTEX3HVNVPROC glad_glVertex3hvNV;
#define glVertex3hvNV glad_glVertex3hvNV
GLAD_API_CALL PFNGLVERTEX4HNVPROC glad_glVertex4hNV;
#define glVertex4hNV glad_glVertex4hNV
GLAD_API_CALL PFNGLVERTEX4HVNVPROC glad_glVertex4hvNV;
#define glVertex4hvNV glad_glVertex4hvNV
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding;
#define glVertexArrayAttribBinding glad_glVertexArrayAttribBinding
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat;
#define glVertexArrayAttribFormat glad_glVertexArrayAttribFormat
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat;
#define glVertexArrayAttribIFormat glad_glVertexArrayAttribIFormat
GLAD_API_CALL PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat;
#define glVertexArrayAttribLFormat glad_glVertexArrayAttribLFormat
GLAD_API_CALL PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC glad_glVertexArrayBindVertexBufferEXT;
#define glVertexArrayBindVertexBufferEXT glad_glVertexArrayBindVertexBufferEXT
GLAD_API_CALL PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor;
#define glVertexArrayBindingDivisor glad_glVertexArrayBindingDivisor
GLAD_API_CALL PFNGLVERTEXARRAYCOLOROFFSETEXTPROC glad_glVertexArrayColorOffsetEXT;
#define glVertexArrayColorOffsetEXT glad_glVertexArrayColorOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC glad_glVertexArrayEdgeFlagOffsetEXT;
#define glVertexArrayEdgeFlagOffsetEXT glad_glVertexArrayEdgeFlagOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer;
#define glVertexArrayElementBuffer glad_glVertexArrayElementBuffer
GLAD_API_CALL PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC glad_glVertexArrayFogCoordOffsetEXT;
#define glVertexArrayFogCoordOffsetEXT glad_glVertexArrayFogCoordOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYINDEXOFFSETEXTPROC glad_glVertexArrayIndexOffsetEXT;
#define glVertexArrayIndexOffsetEXT glad_glVertexArrayIndexOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC glad_glVertexArrayMultiTexCoordOffsetEXT;
#define glVertexArrayMultiTexCoordOffsetEXT glad_glVertexArrayMultiTexCoordOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYNORMALOFFSETEXTPROC glad_glVertexArrayNormalOffsetEXT;
#define glVertexArrayNormalOffsetEXT glad_glVertexArrayNormalOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYPARAMETERIAPPLEPROC glad_glVertexArrayParameteriAPPLE;
#define glVertexArrayParameteriAPPLE glad_glVertexArrayParameteriAPPLE
GLAD_API_CALL PFNGLVERTEXARRAYRANGEAPPLEPROC glad_glVertexArrayRangeAPPLE;
#define glVertexArrayRangeAPPLE glad_glVertexArrayRangeAPPLE
GLAD_API_CALL PFNGLVERTEXARRAYRANGENVPROC glad_glVertexArrayRangeNV;
#define glVertexArrayRangeNV glad_glVertexArrayRangeNV
GLAD_API_CALL PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC glad_glVertexArraySecondaryColorOffsetEXT;
#define glVertexArraySecondaryColorOffsetEXT glad_glVertexArraySecondaryColorOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC glad_glVertexArrayTexCoordOffsetEXT;
#define glVertexArrayTexCoordOffsetEXT glad_glVertexArrayTexCoordOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC glad_glVertexArrayVertexAttribBindingEXT;
#define glVertexArrayVertexAttribBindingEXT glad_glVertexArrayVertexAttribBindingEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC glad_glVertexArrayVertexAttribDivisorEXT;
#define glVertexArrayVertexAttribDivisorEXT glad_glVertexArrayVertexAttribDivisorEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC glad_glVertexArrayVertexAttribFormatEXT;
#define glVertexArrayVertexAttribFormatEXT glad_glVertexArrayVertexAttribFormatEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC glad_glVertexArrayVertexAttribIFormatEXT;
#define glVertexArrayVertexAttribIFormatEXT glad_glVertexArrayVertexAttribIFormatEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC glad_glVertexArrayVertexAttribIOffsetEXT;
#define glVertexArrayVertexAttribIOffsetEXT glad_glVertexArrayVertexAttribIOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC glad_glVertexArrayVertexAttribLFormatEXT;
#define glVertexArrayVertexAttribLFormatEXT glad_glVertexArrayVertexAttribLFormatEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC glad_glVertexArrayVertexAttribLOffsetEXT;
#define glVertexArrayVertexAttribLOffsetEXT glad_glVertexArrayVertexAttribLOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC glad_glVertexArrayVertexAttribOffsetEXT;
#define glVertexArrayVertexAttribOffsetEXT glad_glVertexArrayVertexAttribOffsetEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC glad_glVertexArrayVertexBindingDivisorEXT;
#define glVertexArrayVertexBindingDivisorEXT glad_glVertexArrayVertexBindingDivisorEXT
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer;
#define glVertexArrayVertexBuffer glad_glVertexArrayVertexBuffer
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers;
#define glVertexArrayVertexBuffers glad_glVertexArrayVertexBuffers
GLAD_API_CALL PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC glad_glVertexArrayVertexOffsetEXT;
#define glVertexArrayVertexOffsetEXT glad_glVertexArrayVertexOffsetEXT
GLAD_API_CALL PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;
#define glVertexAttrib1d glad_glVertexAttrib1d
GLAD_API_CALL PFNGLVERTEXATTRIB1DARBPROC glad_glVertexAttrib1dARB;
#define glVertexAttrib1dARB glad_glVertexAttrib1dARB
GLAD_API_CALL PFNGLVERTEXATTRIB1DNVPROC glad_glVertexAttrib1dNV;
#define glVertexAttrib1dNV glad_glVertexAttrib1dNV
GLAD_API_CALL PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;
#define glVertexAttrib1dv glad_glVertexAttrib1dv
GLAD_API_CALL PFNGLVERTEXATTRIB1DVARBPROC glad_glVertexAttrib1dvARB;
#define glVertexAttrib1dvARB glad_glVertexAttrib1dvARB
GLAD_API_CALL PFNGLVERTEXATTRIB1DVNVPROC glad_glVertexAttrib1dvNV;
#define glVertexAttrib1dvNV glad_glVertexAttrib1dvNV
GLAD_API_CALL PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;
#define glVertexAttrib1f glad_glVertexAttrib1f
GLAD_API_CALL PFNGLVERTEXATTRIB1FARBPROC glad_glVertexAttrib1fARB;
#define glVertexAttrib1fARB glad_glVertexAttrib1fARB
GLAD_API_CALL PFNGLVERTEXATTRIB1FNVPROC glad_glVertexAttrib1fNV;
#define glVertexAttrib1fNV glad_glVertexAttrib1fNV
GLAD_API_CALL PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;
#define glVertexAttrib1fv glad_glVertexAttrib1fv
GLAD_API_CALL PFNGLVERTEXATTRIB1FVARBPROC glad_glVertexAttrib1fvARB;
#define glVertexAttrib1fvARB glad_glVertexAttrib1fvARB
GLAD_API_CALL PFNGLVERTEXATTRIB1FVNVPROC glad_glVertexAttrib1fvNV;
#define glVertexAttrib1fvNV glad_glVertexAttrib1fvNV
GLAD_API_CALL PFNGLVERTEXATTRIB1HNVPROC glad_glVertexAttrib1hNV;
#define glVertexAttrib1hNV glad_glVertexAttrib1hNV
GLAD_API_CALL PFNGLVERTEXATTRIB1HVNVPROC glad_glVertexAttrib1hvNV;
#define glVertexAttrib1hvNV glad_glVertexAttrib1hvNV
GLAD_API_CALL PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;
#define glVertexAttrib1s glad_glVertexAttrib1s
GLAD_API_CALL PFNGLVERTEXATTRIB1SARBPROC glad_glVertexAttrib1sARB;
#define glVertexAttrib1sARB glad_glVertexAttrib1sARB
GLAD_API_CALL PFNGLVERTEXATTRIB1SNVPROC glad_glVertexAttrib1sNV;
#define glVertexAttrib1sNV glad_glVertexAttrib1sNV
GLAD_API_CALL PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;
#define glVertexAttrib1sv glad_glVertexAttrib1sv
GLAD_API_CALL PFNGLVERTEXATTRIB1SVARBPROC glad_glVertexAttrib1svARB;
#define glVertexAttrib1svARB glad_glVertexAttrib1svARB
GLAD_API_CALL PFNGLVERTEXATTRIB1SVNVPROC glad_glVertexAttrib1svNV;
#define glVertexAttrib1svNV glad_glVertexAttrib1svNV
GLAD_API_CALL PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;
#define glVertexAttrib2d glad_glVertexAttrib2d
GLAD_API_CALL PFNGLVERTEXATTRIB2DARBPROC glad_glVertexAttrib2dARB;
#define glVertexAttrib2dARB glad_glVertexAttrib2dARB
GLAD_API_CALL PFNGLVERTEXATTRIB2DNVPROC glad_glVertexAttrib2dNV;
#define glVertexAttrib2dNV glad_glVertexAttrib2dNV
GLAD_API_CALL PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;
#define glVertexAttrib2dv glad_glVertexAttrib2dv
GLAD_API_CALL PFNGLVERTEXATTRIB2DVARBPROC glad_glVertexAttrib2dvARB;
#define glVertexAttrib2dvARB glad_glVertexAttrib2dvARB
GLAD_API_CALL PFNGLVERTEXATTRIB2DVNVPROC glad_glVertexAttrib2dvNV;
#define glVertexAttrib2dvNV glad_glVertexAttrib2dvNV
GLAD_API_CALL PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;
#define glVertexAttrib2f glad_glVertexAttrib2f
GLAD_API_CALL PFNGLVERTEXATTRIB2FARBPROC glad_glVertexAttrib2fARB;
#define glVertexAttrib2fARB glad_glVertexAttrib2fARB
GLAD_API_CALL PFNGLVERTEXATTRIB2FNVPROC glad_glVertexAttrib2fNV;
#define glVertexAttrib2fNV glad_glVertexAttrib2fNV
GLAD_API_CALL PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;
#define glVertexAttrib2fv glad_glVertexAttrib2fv
GLAD_API_CALL PFNGLVERTEXATTRIB2FVARBPROC glad_glVertexAttrib2fvARB;
#define glVertexAttrib2fvARB glad_glVertexAttrib2fvARB
GLAD_API_CALL PFNGLVERTEXATTRIB2FVNVPROC glad_glVertexAttrib2fvNV;
#define glVertexAttrib2fvNV glad_glVertexAttrib2fvNV
GLAD_API_CALL PFNGLVERTEXATTRIB2HNVPROC glad_glVertexAttrib2hNV;
#define glVertexAttrib2hNV glad_glVertexAttrib2hNV
GLAD_API_CALL PFNGLVERTEXATTRIB2HVNVPROC glad_glVertexAttrib2hvNV;
#define glVertexAttrib2hvNV glad_glVertexAttrib2hvNV
GLAD_API_CALL PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;
#define glVertexAttrib2s glad_glVertexAttrib2s
GLAD_API_CALL PFNGLVERTEXATTRIB2SARBPROC glad_glVertexAttrib2sARB;
#define glVertexAttrib2sARB glad_glVertexAttrib2sARB
GLAD_API_CALL PFNGLVERTEXATTRIB2SNVPROC glad_glVertexAttrib2sNV;
#define glVertexAttrib2sNV glad_glVertexAttrib2sNV
GLAD_API_CALL PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;
#define glVertexAttrib2sv glad_glVertexAttrib2sv
GLAD_API_CALL PFNGLVERTEXATTRIB2SVARBPROC glad_glVertexAttrib2svARB;
#define glVertexAttrib2svARB glad_glVertexAttrib2svARB
GLAD_API_CALL PFNGLVERTEXATTRIB2SVNVPROC glad_glVertexAttrib2svNV;
#define glVertexAttrib2svNV glad_glVertexAttrib2svNV
GLAD_API_CALL PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;
#define glVertexAttrib3d glad_glVertexAttrib3d
GLAD_API_CALL PFNGLVERTEXATTRIB3DARBPROC glad_glVertexAttrib3dARB;
#define glVertexAttrib3dARB glad_glVertexAttrib3dARB
GLAD_API_CALL PFNGLVERTEXATTRIB3DNVPROC glad_glVertexAttrib3dNV;
#define glVertexAttrib3dNV glad_glVertexAttrib3dNV
GLAD_API_CALL PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;
#define glVertexAttrib3dv glad_glVertexAttrib3dv
GLAD_API_CALL PFNGLVERTEXATTRIB3DVARBPROC glad_glVertexAttrib3dvARB;
#define glVertexAttrib3dvARB glad_glVertexAttrib3dvARB
GLAD_API_CALL PFNGLVERTEXATTRIB3DVNVPROC glad_glVertexAttrib3dvNV;
#define glVertexAttrib3dvNV glad_glVertexAttrib3dvNV
GLAD_API_CALL PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;
#define glVertexAttrib3f glad_glVertexAttrib3f
GLAD_API_CALL PFNGLVERTEXATTRIB3FARBPROC glad_glVertexAttrib3fARB;
#define glVertexAttrib3fARB glad_glVertexAttrib3fARB
GLAD_API_CALL PFNGLVERTEXATTRIB3FNVPROC glad_glVertexAttrib3fNV;
#define glVertexAttrib3fNV glad_glVertexAttrib3fNV
GLAD_API_CALL PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;
#define glVertexAttrib3fv glad_glVertexAttrib3fv
GLAD_API_CALL PFNGLVERTEXATTRIB3FVARBPROC glad_glVertexAttrib3fvARB;
#define glVertexAttrib3fvARB glad_glVertexAttrib3fvARB
GLAD_API_CALL PFNGLVERTEXATTRIB3FVNVPROC glad_glVertexAttrib3fvNV;
#define glVertexAttrib3fvNV glad_glVertexAttrib3fvNV
GLAD_API_CALL PFNGLVERTEXATTRIB3HNVPROC glad_glVertexAttrib3hNV;
#define glVertexAttrib3hNV glad_glVertexAttrib3hNV
GLAD_API_CALL PFNGLVERTEXATTRIB3HVNVPROC glad_glVertexAttrib3hvNV;
#define glVertexAttrib3hvNV glad_glVertexAttrib3hvNV
GLAD_API_CALL PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;
#define glVertexAttrib3s glad_glVertexAttrib3s
GLAD_API_CALL PFNGLVERTEXATTRIB3SARBPROC glad_glVertexAttrib3sARB;
#define glVertexAttrib3sARB glad_glVertexAttrib3sARB
GLAD_API_CALL PFNGLVERTEXATTRIB3SNVPROC glad_glVertexAttrib3sNV;
#define glVertexAttrib3sNV glad_glVertexAttrib3sNV
GLAD_API_CALL PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;
#define glVertexAttrib3sv glad_glVertexAttrib3sv
GLAD_API_CALL PFNGLVERTEXATTRIB3SVARBPROC glad_glVertexAttrib3svARB;
#define glVertexAttrib3svARB glad_glVertexAttrib3svARB
GLAD_API_CALL PFNGLVERTEXATTRIB3SVNVPROC glad_glVertexAttrib3svNV;
#define glVertexAttrib3svNV glad_glVertexAttrib3svNV
GLAD_API_CALL PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;
#define glVertexAttrib4Nbv glad_glVertexAttrib4Nbv
GLAD_API_CALL PFNGLVERTEXATTRIB4NBVARBPROC glad_glVertexAttrib4NbvARB;
#define glVertexAttrib4NbvARB glad_glVertexAttrib4NbvARB
GLAD_API_CALL PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;
#define glVertexAttrib4Niv glad_glVertexAttrib4Niv
GLAD_API_CALL PFNGLVERTEXATTRIB4NIVARBPROC glad_glVertexAttrib4NivARB;
#define glVertexAttrib4NivARB glad_glVertexAttrib4NivARB
GLAD_API_CALL PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;
#define glVertexAttrib4Nsv glad_glVertexAttrib4Nsv
GLAD_API_CALL PFNGLVERTEXATTRIB4NSVARBPROC glad_glVertexAttrib4NsvARB;
#define glVertexAttrib4NsvARB glad_glVertexAttrib4NsvARB
GLAD_API_CALL PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;
#define glVertexAttrib4Nub glad_glVertexAttrib4Nub
GLAD_API_CALL PFNGLVERTEXATTRIB4NUBARBPROC glad_glVertexAttrib4NubARB;
#define glVertexAttrib4NubARB glad_glVertexAttrib4NubARB
GLAD_API_CALL PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;
#define glVertexAttrib4Nubv glad_glVertexAttrib4Nubv
GLAD_API_CALL PFNGLVERTEXATTRIB4NUBVARBPROC glad_glVertexAttrib4NubvARB;
#define glVertexAttrib4NubvARB glad_glVertexAttrib4NubvARB
GLAD_API_CALL PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;
#define glVertexAttrib4Nuiv glad_glVertexAttrib4Nuiv
GLAD_API_CALL PFNGLVERTEXATTRIB4NUIVARBPROC glad_glVertexAttrib4NuivARB;
#define glVertexAttrib4NuivARB glad_glVertexAttrib4NuivARB
GLAD_API_CALL PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;
#define glVertexAttrib4Nusv glad_glVertexAttrib4Nusv
GLAD_API_CALL PFNGLVERTEXATTRIB4NUSVARBPROC glad_glVertexAttrib4NusvARB;
#define glVertexAttrib4NusvARB glad_glVertexAttrib4NusvARB
GLAD_API_CALL PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;
#define glVertexAttrib4bv glad_glVertexAttrib4bv
GLAD_API_CALL PFNGLVERTEXATTRIB4BVARBPROC glad_glVertexAttrib4bvARB;
#define glVertexAttrib4bvARB glad_glVertexAttrib4bvARB
GLAD_API_CALL PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;
#define glVertexAttrib4d glad_glVertexAttrib4d
GLAD_API_CALL PFNGLVERTEXATTRIB4DARBPROC glad_glVertexAttrib4dARB;
#define glVertexAttrib4dARB glad_glVertexAttrib4dARB
GLAD_API_CALL PFNGLVERTEXATTRIB4DNVPROC glad_glVertexAttrib4dNV;
#define glVertexAttrib4dNV glad_glVertexAttrib4dNV
GLAD_API_CALL PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;
#define glVertexAttrib4dv glad_glVertexAttrib4dv
GLAD_API_CALL PFNGLVERTEXATTRIB4DVARBPROC glad_glVertexAttrib4dvARB;
#define glVertexAttrib4dvARB glad_glVertexAttrib4dvARB
GLAD_API_CALL PFNGLVERTEXATTRIB4DVNVPROC glad_glVertexAttrib4dvNV;
#define glVertexAttrib4dvNV glad_glVertexAttrib4dvNV
GLAD_API_CALL PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;
#define glVertexAttrib4f glad_glVertexAttrib4f
GLAD_API_CALL PFNGLVERTEXATTRIB4FARBPROC glad_glVertexAttrib4fARB;
#define glVertexAttrib4fARB glad_glVertexAttrib4fARB
GLAD_API_CALL PFNGLVERTEXATTRIB4FNVPROC glad_glVertexAttrib4fNV;
#define glVertexAttrib4fNV glad_glVertexAttrib4fNV
GLAD_API_CALL PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;
#define glVertexAttrib4fv glad_glVertexAttrib4fv
GLAD_API_CALL PFNGLVERTEXATTRIB4FVARBPROC glad_glVertexAttrib4fvARB;
#define glVertexAttrib4fvARB glad_glVertexAttrib4fvARB
GLAD_API_CALL PFNGLVERTEXATTRIB4FVNVPROC glad_glVertexAttrib4fvNV;
#define glVertexAttrib4fvNV glad_glVertexAttrib4fvNV
GLAD_API_CALL PFNGLVERTEXATTRIB4HNVPROC glad_glVertexAttrib4hNV;
#define glVertexAttrib4hNV glad_glVertexAttrib4hNV
GLAD_API_CALL PFNGLVERTEXATTRIB4HVNVPROC glad_glVertexAttrib4hvNV;
#define glVertexAttrib4hvNV glad_glVertexAttrib4hvNV
GLAD_API_CALL PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;
#define glVertexAttrib4iv glad_glVertexAttrib4iv
GLAD_API_CALL PFNGLVERTEXATTRIB4IVARBPROC glad_glVertexAttrib4ivARB;
#define glVertexAttrib4ivARB glad_glVertexAttrib4ivARB
GLAD_API_CALL PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;
#define glVertexAttrib4s glad_glVertexAttrib4s
GLAD_API_CALL PFNGLVERTEXATTRIB4SARBPROC glad_glVertexAttrib4sARB;
#define glVertexAttrib4sARB glad_glVertexAttrib4sARB
GLAD_API_CALL PFNGLVERTEXATTRIB4SNVPROC glad_glVertexAttrib4sNV;
#define glVertexAttrib4sNV glad_glVertexAttrib4sNV
GLAD_API_CALL PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;
#define glVertexAttrib4sv glad_glVertexAttrib4sv
GLAD_API_CALL PFNGLVERTEXATTRIB4SVARBPROC glad_glVertexAttrib4svARB;
#define glVertexAttrib4svARB glad_glVertexAttrib4svARB
GLAD_API_CALL PFNGLVERTEXATTRIB4SVNVPROC glad_glVertexAttrib4svNV;
#define glVertexAttrib4svNV glad_glVertexAttrib4svNV
GLAD_API_CALL PFNGLVERTEXATTRIB4UBNVPROC glad_glVertexAttrib4ubNV;
#define glVertexAttrib4ubNV glad_glVertexAttrib4ubNV
GLAD_API_CALL PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;
#define glVertexAttrib4ubv glad_glVertexAttrib4ubv
GLAD_API_CALL PFNGLVERTEXATTRIB4UBVARBPROC glad_glVertexAttrib4ubvARB;
#define glVertexAttrib4ubvARB glad_glVertexAttrib4ubvARB
GLAD_API_CALL PFNGLVERTEXATTRIB4UBVNVPROC glad_glVertexAttrib4ubvNV;
#define glVertexAttrib4ubvNV glad_glVertexAttrib4ubvNV
GLAD_API_CALL PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;
#define glVertexAttrib4uiv glad_glVertexAttrib4uiv
GLAD_API_CALL PFNGLVERTEXATTRIB4UIVARBPROC glad_glVertexAttrib4uivARB;
#define glVertexAttrib4uivARB glad_glVertexAttrib4uivARB
GLAD_API_CALL PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;
#define glVertexAttrib4usv glad_glVertexAttrib4usv
GLAD_API_CALL PFNGLVERTEXATTRIB4USVARBPROC glad_glVertexAttrib4usvARB;
#define glVertexAttrib4usvARB glad_glVertexAttrib4usvARB
GLAD_API_CALL PFNGLVERTEXATTRIBARRAYOBJECTATIPROC glad_glVertexAttribArrayObjectATI;
#define glVertexAttribArrayObjectATI glad_glVertexAttribArrayObjectATI
GLAD_API_CALL PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding;
#define glVertexAttribBinding glad_glVertexAttribBinding
GLAD_API_CALL PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;
#define glVertexAttribDivisor glad_glVertexAttribDivisor
GLAD_API_CALL PFNGLVERTEXATTRIBDIVISORARBPROC glad_glVertexAttribDivisorARB;
#define glVertexAttribDivisorARB glad_glVertexAttribDivisorARB
GLAD_API_CALL PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat;
#define glVertexAttribFormat glad_glVertexAttribFormat
GLAD_API_CALL PFNGLVERTEXATTRIBFORMATNVPROC glad_glVertexAttribFormatNV;
#define glVertexAttribFormatNV glad_glVertexAttribFormatNV
GLAD_API_CALL PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;
#define glVertexAttribI1i glad_glVertexAttribI1i
GLAD_API_CALL PFNGLVERTEXATTRIBI1IEXTPROC glad_glVertexAttribI1iEXT;
#define glVertexAttribI1iEXT glad_glVertexAttribI1iEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;
#define glVertexAttribI1iv glad_glVertexAttribI1iv
GLAD_API_CALL PFNGLVERTEXATTRIBI1IVEXTPROC glad_glVertexAttribI1ivEXT;
#define glVertexAttribI1ivEXT glad_glVertexAttribI1ivEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;
#define glVertexAttribI1ui glad_glVertexAttribI1ui
GLAD_API_CALL PFNGLVERTEXATTRIBI1UIEXTPROC glad_glVertexAttribI1uiEXT;
#define glVertexAttribI1uiEXT glad_glVertexAttribI1uiEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;
#define glVertexAttribI1uiv glad_glVertexAttribI1uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI1UIVEXTPROC glad_glVertexAttribI1uivEXT;
#define glVertexAttribI1uivEXT glad_glVertexAttribI1uivEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;
#define glVertexAttribI2i glad_glVertexAttribI2i
GLAD_API_CALL PFNGLVERTEXATTRIBI2IEXTPROC glad_glVertexAttribI2iEXT;
#define glVertexAttribI2iEXT glad_glVertexAttribI2iEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;
#define glVertexAttribI2iv glad_glVertexAttribI2iv
GLAD_API_CALL PFNGLVERTEXATTRIBI2IVEXTPROC glad_glVertexAttribI2ivEXT;
#define glVertexAttribI2ivEXT glad_glVertexAttribI2ivEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;
#define glVertexAttribI2ui glad_glVertexAttribI2ui
GLAD_API_CALL PFNGLVERTEXATTRIBI2UIEXTPROC glad_glVertexAttribI2uiEXT;
#define glVertexAttribI2uiEXT glad_glVertexAttribI2uiEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;
#define glVertexAttribI2uiv glad_glVertexAttribI2uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI2UIVEXTPROC glad_glVertexAttribI2uivEXT;
#define glVertexAttribI2uivEXT glad_glVertexAttribI2uivEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;
#define glVertexAttribI3i glad_glVertexAttribI3i
GLAD_API_CALL PFNGLVERTEXATTRIBI3IEXTPROC glad_glVertexAttribI3iEXT;
#define glVertexAttribI3iEXT glad_glVertexAttribI3iEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;
#define glVertexAttribI3iv glad_glVertexAttribI3iv
GLAD_API_CALL PFNGLVERTEXATTRIBI3IVEXTPROC glad_glVertexAttribI3ivEXT;
#define glVertexAttribI3ivEXT glad_glVertexAttribI3ivEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;
#define glVertexAttribI3ui glad_glVertexAttribI3ui
GLAD_API_CALL PFNGLVERTEXATTRIBI3UIEXTPROC glad_glVertexAttribI3uiEXT;
#define glVertexAttribI3uiEXT glad_glVertexAttribI3uiEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;
#define glVertexAttribI3uiv glad_glVertexAttribI3uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI3UIVEXTPROC glad_glVertexAttribI3uivEXT;
#define glVertexAttribI3uivEXT glad_glVertexAttribI3uivEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;
#define glVertexAttribI4bv glad_glVertexAttribI4bv
GLAD_API_CALL PFNGLVERTEXATTRIBI4BVEXTPROC glad_glVertexAttribI4bvEXT;
#define glVertexAttribI4bvEXT glad_glVertexAttribI4bvEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;
#define glVertexAttribI4i glad_glVertexAttribI4i
GLAD_API_CALL PFNGLVERTEXATTRIBI4IEXTPROC glad_glVertexAttribI4iEXT;
#define glVertexAttribI4iEXT glad_glVertexAttribI4iEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;
#define glVertexAttribI4iv glad_glVertexAttribI4iv
GLAD_API_CALL PFNGLVERTEXATTRIBI4IVEXTPROC glad_glVertexAttribI4ivEXT;
#define glVertexAttribI4ivEXT glad_glVertexAttribI4ivEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;
#define glVertexAttribI4sv glad_glVertexAttribI4sv
GLAD_API_CALL PFNGLVERTEXATTRIBI4SVEXTPROC glad_glVertexAttribI4svEXT;
#define glVertexAttribI4svEXT glad_glVertexAttribI4svEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;
#define glVertexAttribI4ubv glad_glVertexAttribI4ubv
GLAD_API_CALL PFNGLVERTEXATTRIBI4UBVEXTPROC glad_glVertexAttribI4ubvEXT;
#define glVertexAttribI4ubvEXT glad_glVertexAttribI4ubvEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;
#define glVertexAttribI4ui glad_glVertexAttribI4ui
GLAD_API_CALL PFNGLVERTEXATTRIBI4UIEXTPROC glad_glVertexAttribI4uiEXT;
#define glVertexAttribI4uiEXT glad_glVertexAttribI4uiEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;
#define glVertexAttribI4uiv glad_glVertexAttribI4uiv
GLAD_API_CALL PFNGLVERTEXATTRIBI4UIVEXTPROC glad_glVertexAttribI4uivEXT;
#define glVertexAttribI4uivEXT glad_glVertexAttribI4uivEXT
GLAD_API_CALL PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;
#define glVertexAttribI4usv glad_glVertexAttribI4usv
GLAD_API_CALL PFNGLVERTEXATTRIBI4USVEXTPROC glad_glVertexAttribI4usvEXT;
#define glVertexAttribI4usvEXT glad_glVertexAttribI4usvEXT
GLAD_API_CALL PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat;
#define glVertexAttribIFormat glad_glVertexAttribIFormat
GLAD_API_CALL PFNGLVERTEXATTRIBIFORMATNVPROC glad_glVertexAttribIFormatNV;
#define glVertexAttribIFormatNV glad_glVertexAttribIFormatNV
GLAD_API_CALL PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;
#define glVertexAttribIPointer glad_glVertexAttribIPointer
GLAD_API_CALL PFNGLVERTEXATTRIBIPOINTEREXTPROC glad_glVertexAttribIPointerEXT;
#define glVertexAttribIPointerEXT glad_glVertexAttribIPointerEXT
GLAD_API_CALL PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d;
#define glVertexAttribL1d glad_glVertexAttribL1d
GLAD_API_CALL PFNGLVERTEXATTRIBL1DEXTPROC glad_glVertexAttribL1dEXT;
#define glVertexAttribL1dEXT glad_glVertexAttribL1dEXT
GLAD_API_CALL PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv;
#define glVertexAttribL1dv glad_glVertexAttribL1dv
GLAD_API_CALL PFNGLVERTEXATTRIBL1DVEXTPROC glad_glVertexAttribL1dvEXT;
#define glVertexAttribL1dvEXT glad_glVertexAttribL1dvEXT
GLAD_API_CALL PFNGLVERTEXATTRIBL1I64NVPROC glad_glVertexAttribL1i64NV;
#define glVertexAttribL1i64NV glad_glVertexAttribL1i64NV
GLAD_API_CALL PFNGLVERTEXATTRIBL1I64VNVPROC glad_glVertexAttribL1i64vNV;
#define glVertexAttribL1i64vNV glad_glVertexAttribL1i64vNV
GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64ARBPROC glad_glVertexAttribL1ui64ARB;
#define glVertexAttribL1ui64ARB glad_glVertexAttribL1ui64ARB
GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64NVPROC glad_glVertexAttribL1ui64NV;
#define glVertexAttribL1ui64NV glad_glVertexAttribL1ui64NV
GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64VARBPROC glad_glVertexAttribL1ui64vARB;
#define glVertexAttribL1ui64vARB glad_glVertexAttribL1ui64vARB
GLAD_API_CALL PFNGLVERTEXATTRIBL1UI64VNVPROC glad_glVertexAttribL1ui64vNV;
#define glVertexAttribL1ui64vNV glad_glVertexAttribL1ui64vNV
GLAD_API_CALL PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d;
#define glVertexAttribL2d glad_glVertexAttribL2d
GLAD_API_CALL PFNGLVERTEXATTRIBL2DEXTPROC glad_glVertexAttribL2dEXT;
#define glVertexAttribL2dEXT glad_glVertexAttribL2dEXT
GLAD_API_CALL PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv;
#define glVertexAttribL2dv glad_glVertexAttribL2dv
GLAD_API_CALL PFNGLVERTEXATTRIBL2DVEXTPROC glad_glVertexAttribL2dvEXT;
#define glVertexAttribL2dvEXT glad_glVertexAttribL2dvEXT
GLAD_API_CALL PFNGLVERTEXATTRIBL2I64NVPROC glad_glVertexAttribL2i64NV;
#define glVertexAttribL2i64NV glad_glVertexAttribL2i64NV
GLAD_API_CALL PFNGLVERTEXATTRIBL2I64VNVPROC glad_glVertexAttribL2i64vNV;
#define glVertexAttribL2i64vNV glad_glVertexAttribL2i64vNV
GLAD_API_CALL PFNGLVERTEXATTRIBL2UI64NVPROC glad_glVertexAttribL2ui64NV;
#define glVertexAttribL2ui64NV glad_glVertexAttribL2ui64NV
GLAD_API_CALL PFNGLVERTEXATTRIBL2UI64VNVPROC glad_glVertexAttribL2ui64vNV;
#define glVertexAttribL2ui64vNV glad_glVertexAttribL2ui64vNV
GLAD_API_CALL PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d;
#define glVertexAttribL3d glad_glVertexAttribL3d
GLAD_API_CALL PFNGLVERTEXATTRIBL3DEXTPROC glad_glVertexAttribL3dEXT;
#define glVertexAttribL3dEXT glad_glVertexAttribL3dEXT
GLAD_API_CALL PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv;
#define glVertexAttribL3dv glad_glVertexAttribL3dv
GLAD_API_CALL PFNGLVERTEXATTRIBL3DVEXTPROC glad_glVertexAttribL3dvEXT;
#define glVertexAttribL3dvEXT glad_glVertexAttribL3dvEXT
GLAD_API_CALL PFNGLVERTEXATTRIBL3I64NVPROC glad_glVertexAttribL3i64NV;
#define glVertexAttribL3i64NV glad_glVertexAttribL3i64NV
GLAD_API_CALL PFNGLVERTEXATTRIBL3I64VNVPROC glad_glVertexAttribL3i64vNV;
#define glVertexAttribL3i64vNV glad_glVertexAttribL3i64vNV
GLAD_API_CALL PFNGLVERTEXATTRIBL3UI64NVPROC glad_glVertexAttribL3ui64NV;
#define glVertexAttribL3ui64NV glad_glVertexAttribL3ui64NV
GLAD_API_CALL PFNGLVERTEXATTRIBL3UI64VNVPROC glad_glVertexAttribL3ui64vNV;
#define glVertexAttribL3ui64vNV glad_glVertexAttribL3ui64vNV
GLAD_API_CALL PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d;
#define glVertexAttribL4d glad_glVertexAttribL4d
GLAD_API_CALL PFNGLVERTEXATTRIBL4DEXTPROC glad_glVertexAttribL4dEXT;
#define glVertexAttribL4dEXT glad_glVertexAttribL4dEXT
GLAD_API_CALL PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv;
#define glVertexAttribL4dv glad_glVertexAttribL4dv
GLAD_API_CALL PFNGLVERTEXATTRIBL4DVEXTPROC glad_glVertexAttribL4dvEXT;
#define glVertexAttribL4dvEXT glad_glVertexAttribL4dvEXT
GLAD_API_CALL PFNGLVERTEXATTRIBL4I64NVPROC glad_glVertexAttribL4i64NV;
#define glVertexAttribL4i64NV glad_glVertexAttribL4i64NV
GLAD_API_CALL PFNGLVERTEXATTRIBL4I64VNVPROC glad_glVertexAttribL4i64vNV;
#define glVertexAttribL4i64vNV glad_glVertexAttribL4i64vNV
GLAD_API_CALL PFNGLVERTEXATTRIBL4UI64NVPROC glad_glVertexAttribL4ui64NV;
#define glVertexAttribL4ui64NV glad_glVertexAttribL4ui64NV
GLAD_API_CALL PFNGLVERTEXATTRIBL4UI64VNVPROC glad_glVertexAttribL4ui64vNV;
#define glVertexAttribL4ui64vNV glad_glVertexAttribL4ui64vNV
GLAD_API_CALL PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat;
#define glVertexAttribLFormat glad_glVertexAttribLFormat
GLAD_API_CALL PFNGLVERTEXATTRIBLFORMATNVPROC glad_glVertexAttribLFormatNV;
#define glVertexAttribLFormatNV glad_glVertexAttribLFormatNV
GLAD_API_CALL PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer;
#define glVertexAttribLPointer glad_glVertexAttribLPointer
GLAD_API_CALL PFNGLVERTEXATTRIBLPOINTEREXTPROC glad_glVertexAttribLPointerEXT;
#define glVertexAttribLPointerEXT glad_glVertexAttribLPointerEXT
GLAD_API_CALL PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;
#define glVertexAttribP1ui glad_glVertexAttribP1ui
GLAD_API_CALL PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;
#define glVertexAttribP1uiv glad_glVertexAttribP1uiv
GLAD_API_CALL PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;
#define glVertexAttribP2ui glad_glVertexAttribP2ui
GLAD_API_CALL PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;
#define glVertexAttribP2uiv glad_glVertexAttribP2uiv
GLAD_API_CALL PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;
#define glVertexAttribP3ui glad_glVertexAttribP3ui
GLAD_API_CALL PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;
#define glVertexAttribP3uiv glad_glVertexAttribP3uiv
GLAD_API_CALL PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;
#define glVertexAttribP4ui glad_glVertexAttribP4ui
GLAD_API_CALL PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;
#define glVertexAttribP4uiv glad_glVertexAttribP4uiv
GLAD_API_CALL PFNGLVERTEXATTRIBPARAMETERIAMDPROC glad_glVertexAttribParameteriAMD;
#define glVertexAttribParameteriAMD glad_glVertexAttribParameteriAMD
GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;
#define glVertexAttribPointer glad_glVertexAttribPointer
GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERARBPROC glad_glVertexAttribPointerARB;
#define glVertexAttribPointerARB glad_glVertexAttribPointerARB
GLAD_API_CALL PFNGLVERTEXATTRIBPOINTERNVPROC glad_glVertexAttribPointerNV;
#define glVertexAttribPointerNV glad_glVertexAttribPointerNV
GLAD_API_CALL PFNGLVERTEXATTRIBS1DVNVPROC glad_glVertexAttribs1dvNV;
#define glVertexAttribs1dvNV glad_glVertexAttribs1dvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS1FVNVPROC glad_glVertexAttribs1fvNV;
#define glVertexAttribs1fvNV glad_glVertexAttribs1fvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS1HVNVPROC glad_glVertexAttribs1hvNV;
#define glVertexAttribs1hvNV glad_glVertexAttribs1hvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS1SVNVPROC glad_glVertexAttribs1svNV;
#define glVertexAttribs1svNV glad_glVertexAttribs1svNV
GLAD_API_CALL PFNGLVERTEXATTRIBS2DVNVPROC glad_glVertexAttribs2dvNV;
#define glVertexAttribs2dvNV glad_glVertexAttribs2dvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS2FVNVPROC glad_glVertexAttribs2fvNV;
#define glVertexAttribs2fvNV glad_glVertexAttribs2fvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS2HVNVPROC glad_glVertexAttribs2hvNV;
#define glVertexAttribs2hvNV glad_glVertexAttribs2hvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS2SVNVPROC glad_glVertexAttribs2svNV;
#define glVertexAttribs2svNV glad_glVertexAttribs2svNV
GLAD_API_CALL PFNGLVERTEXATTRIBS3DVNVPROC glad_glVertexAttribs3dvNV;
#define glVertexAttribs3dvNV glad_glVertexAttribs3dvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS3FVNVPROC glad_glVertexAttribs3fvNV;
#define glVertexAttribs3fvNV glad_glVertexAttribs3fvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS3HVNVPROC glad_glVertexAttribs3hvNV;
#define glVertexAttribs3hvNV glad_glVertexAttribs3hvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS3SVNVPROC glad_glVertexAttribs3svNV;
#define glVertexAttribs3svNV glad_glVertexAttribs3svNV
GLAD_API_CALL PFNGLVERTEXATTRIBS4DVNVPROC glad_glVertexAttribs4dvNV;
#define glVertexAttribs4dvNV glad_glVertexAttribs4dvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS4FVNVPROC glad_glVertexAttribs4fvNV;
#define glVertexAttribs4fvNV glad_glVertexAttribs4fvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS4HVNVPROC glad_glVertexAttribs4hvNV;
#define glVertexAttribs4hvNV glad_glVertexAttribs4hvNV
GLAD_API_CALL PFNGLVERTEXATTRIBS4SVNVPROC glad_glVertexAttribs4svNV;
#define glVertexAttribs4svNV glad_glVertexAttribs4svNV
GLAD_API_CALL PFNGLVERTEXATTRIBS4UBVNVPROC glad_glVertexAttribs4ubvNV;
#define glVertexAttribs4ubvNV glad_glVertexAttribs4ubvNV
GLAD_API_CALL PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor;
#define glVertexBindingDivisor glad_glVertexBindingDivisor
GLAD_API_CALL PFNGLVERTEXBLENDARBPROC glad_glVertexBlendARB;
#define glVertexBlendARB glad_glVertexBlendARB
GLAD_API_CALL PFNGLVERTEXBLENDENVFATIPROC glad_glVertexBlendEnvfATI;
#define glVertexBlendEnvfATI glad_glVertexBlendEnvfATI
GLAD_API_CALL PFNGLVERTEXBLENDENVIATIPROC glad_glVertexBlendEnviATI;
#define glVertexBlendEnviATI glad_glVertexBlendEnviATI
GLAD_API_CALL PFNGLVERTEXFORMATNVPROC glad_glVertexFormatNV;
#define glVertexFormatNV glad_glVertexFormatNV
GLAD_API_CALL PFNGLVERTEXPOINTEREXTPROC glad_glVertexPointerEXT;
#define glVertexPointerEXT glad_glVertexPointerEXT
GLAD_API_CALL PFNGLVERTEXPOINTERVINTELPROC glad_glVertexPointervINTEL;
#define glVertexPointervINTEL glad_glVertexPointervINTEL
GLAD_API_CALL PFNGLVERTEXSTREAM1DATIPROC glad_glVertexStream1dATI;
#define glVertexStream1dATI glad_glVertexStream1dATI
GLAD_API_CALL PFNGLVERTEXSTREAM1DVATIPROC glad_glVertexStream1dvATI;
#define glVertexStream1dvATI glad_glVertexStream1dvATI
GLAD_API_CALL PFNGLVERTEXSTREAM1FATIPROC glad_glVertexStream1fATI;
#define glVertexStream1fATI glad_glVertexStream1fATI
GLAD_API_CALL PFNGLVERTEXSTREAM1FVATIPROC glad_glVertexStream1fvATI;
#define glVertexStream1fvATI glad_glVertexStream1fvATI
GLAD_API_CALL PFNGLVERTEXSTREAM1IATIPROC glad_glVertexStream1iATI;
#define glVertexStream1iATI glad_glVertexStream1iATI
GLAD_API_CALL PFNGLVERTEXSTREAM1IVATIPROC glad_glVertexStream1ivATI;
#define glVertexStream1ivATI glad_glVertexStream1ivATI
GLAD_API_CALL PFNGLVERTEXSTREAM1SATIPROC glad_glVertexStream1sATI;
#define glVertexStream1sATI glad_glVertexStream1sATI
GLAD_API_CALL PFNGLVERTEXSTREAM1SVATIPROC glad_glVertexStream1svATI;
#define glVertexStream1svATI glad_glVertexStream1svATI
GLAD_API_CALL PFNGLVERTEXSTREAM2DATIPROC glad_glVertexStream2dATI;
#define glVertexStream2dATI glad_glVertexStream2dATI
GLAD_API_CALL PFNGLVERTEXSTREAM2DVATIPROC glad_glVertexStream2dvATI;
#define glVertexStream2dvATI glad_glVertexStream2dvATI
GLAD_API_CALL PFNGLVERTEXSTREAM2FATIPROC glad_glVertexStream2fATI;
#define glVertexStream2fATI glad_glVertexStream2fATI
GLAD_API_CALL PFNGLVERTEXSTREAM2FVATIPROC glad_glVertexStream2fvATI;
#define glVertexStream2fvATI glad_glVertexStream2fvATI
GLAD_API_CALL PFNGLVERTEXSTREAM2IATIPROC glad_glVertexStream2iATI;
#define glVertexStream2iATI glad_glVertexStream2iATI
GLAD_API_CALL PFNGLVERTEXSTREAM2IVATIPROC glad_glVertexStream2ivATI;
#define glVertexStream2ivATI glad_glVertexStream2ivATI
GLAD_API_CALL PFNGLVERTEXSTREAM2SATIPROC glad_glVertexStream2sATI;
#define glVertexStream2sATI glad_glVertexStream2sATI
GLAD_API_CALL PFNGLVERTEXSTREAM2SVATIPROC glad_glVertexStream2svATI;
#define glVertexStream2svATI glad_glVertexStream2svATI
GLAD_API_CALL PFNGLVERTEXSTREAM3DATIPROC glad_glVertexStream3dATI;
#define glVertexStream3dATI glad_glVertexStream3dATI
GLAD_API_CALL PFNGLVERTEXSTREAM3DVATIPROC glad_glVertexStream3dvATI;
#define glVertexStream3dvATI glad_glVertexStream3dvATI
GLAD_API_CALL PFNGLVERTEXSTREAM3FATIPROC glad_glVertexStream3fATI;
#define glVertexStream3fATI glad_glVertexStream3fATI
GLAD_API_CALL PFNGLVERTEXSTREAM3FVATIPROC glad_glVertexStream3fvATI;
#define glVertexStream3fvATI glad_glVertexStream3fvATI
GLAD_API_CALL PFNGLVERTEXSTREAM3IATIPROC glad_glVertexStream3iATI;
#define glVertexStream3iATI glad_glVertexStream3iATI
GLAD_API_CALL PFNGLVERTEXSTREAM3IVATIPROC glad_glVertexStream3ivATI;
#define glVertexStream3ivATI glad_glVertexStream3ivATI
GLAD_API_CALL PFNGLVERTEXSTREAM3SATIPROC glad_glVertexStream3sATI;
#define glVertexStream3sATI glad_glVertexStream3sATI
GLAD_API_CALL PFNGLVERTEXSTREAM3SVATIPROC glad_glVertexStream3svATI;
#define glVertexStream3svATI glad_glVertexStream3svATI
GLAD_API_CALL PFNGLVERTEXSTREAM4DATIPROC glad_glVertexStream4dATI;
#define glVertexStream4dATI glad_glVertexStream4dATI
GLAD_API_CALL PFNGLVERTEXSTREAM4DVATIPROC glad_glVertexStream4dvATI;
#define glVertexStream4dvATI glad_glVertexStream4dvATI
GLAD_API_CALL PFNGLVERTEXSTREAM4FATIPROC glad_glVertexStream4fATI;
#define glVertexStream4fATI glad_glVertexStream4fATI
GLAD_API_CALL PFNGLVERTEXSTREAM4FVATIPROC glad_glVertexStream4fvATI;
#define glVertexStream4fvATI glad_glVertexStream4fvATI
GLAD_API_CALL PFNGLVERTEXSTREAM4IATIPROC glad_glVertexStream4iATI;
#define glVertexStream4iATI glad_glVertexStream4iATI
GLAD_API_CALL PFNGLVERTEXSTREAM4IVATIPROC glad_glVertexStream4ivATI;
#define glVertexStream4ivATI glad_glVertexStream4ivATI
GLAD_API_CALL PFNGLVERTEXSTREAM4SATIPROC glad_glVertexStream4sATI;
#define glVertexStream4sATI glad_glVertexStream4sATI
GLAD_API_CALL PFNGLVERTEXSTREAM4SVATIPROC glad_glVertexStream4svATI;
#define glVertexStream4svATI glad_glVertexStream4svATI
GLAD_API_CALL PFNGLVERTEXWEIGHTPOINTEREXTPROC glad_glVertexWeightPointerEXT;
#define glVertexWeightPointerEXT glad_glVertexWeightPointerEXT
GLAD_API_CALL PFNGLVERTEXWEIGHTFEXTPROC glad_glVertexWeightfEXT;
#define glVertexWeightfEXT glad_glVertexWeightfEXT
GLAD_API_CALL PFNGLVERTEXWEIGHTFVEXTPROC glad_glVertexWeightfvEXT;
#define glVertexWeightfvEXT glad_glVertexWeightfvEXT
GLAD_API_CALL PFNGLVERTEXWEIGHTHNVPROC glad_glVertexWeighthNV;
#define glVertexWeighthNV glad_glVertexWeighthNV
GLAD_API_CALL PFNGLVERTEXWEIGHTHVNVPROC glad_glVertexWeighthvNV;
#define glVertexWeighthvNV glad_glVertexWeighthvNV
GLAD_API_CALL PFNGLVIDEOCAPTURENVPROC glad_glVideoCaptureNV;
#define glVideoCaptureNV glad_glVideoCaptureNV
GLAD_API_CALL PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC glad_glVideoCaptureStreamParameterdvNV;
#define glVideoCaptureStreamParameterdvNV glad_glVideoCaptureStreamParameterdvNV
GLAD_API_CALL PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC glad_glVideoCaptureStreamParameterfvNV;
#define glVideoCaptureStreamParameterfvNV glad_glVideoCaptureStreamParameterfvNV
GLAD_API_CALL PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC glad_glVideoCaptureStreamParameterivNV;
#define glVideoCaptureStreamParameterivNV glad_glVideoCaptureStreamParameterivNV
GLAD_API_CALL PFNGLVIEWPORTPROC glad_glViewport;
#define glViewport glad_glViewport
GLAD_API_CALL PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv;
#define glViewportArrayv glad_glViewportArrayv
GLAD_API_CALL PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf;
#define glViewportIndexedf glad_glViewportIndexedf
GLAD_API_CALL PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv;
#define glViewportIndexedfv glad_glViewportIndexedfv
GLAD_API_CALL PFNGLVIEWPORTPOSITIONWSCALENVPROC glad_glViewportPositionWScaleNV;
#define glViewportPositionWScaleNV glad_glViewportPositionWScaleNV
GLAD_API_CALL PFNGLVIEWPORTSWIZZLENVPROC glad_glViewportSwizzleNV;
#define glViewportSwizzleNV glad_glViewportSwizzleNV
GLAD_API_CALL PFNGLWAITSEMAPHOREEXTPROC glad_glWaitSemaphoreEXT;
#define glWaitSemaphoreEXT glad_glWaitSemaphoreEXT
GLAD_API_CALL PFNGLWAITSYNCPROC glad_glWaitSync;
#define glWaitSync glad_glWaitSync
GLAD_API_CALL PFNGLWAITVKSEMAPHORENVPROC glad_glWaitVkSemaphoreNV;
#define glWaitVkSemaphoreNV glad_glWaitVkSemaphoreNV
GLAD_API_CALL PFNGLWEIGHTPATHSNVPROC glad_glWeightPathsNV;
#define glWeightPathsNV glad_glWeightPathsNV
GLAD_API_CALL PFNGLWEIGHTPOINTERARBPROC glad_glWeightPointerARB;
#define glWeightPointerARB glad_glWeightPointerARB
GLAD_API_CALL PFNGLWEIGHTBVARBPROC glad_glWeightbvARB;
#define glWeightbvARB glad_glWeightbvARB
GLAD_API_CALL PFNGLWEIGHTDVARBPROC glad_glWeightdvARB;
#define glWeightdvARB glad_glWeightdvARB
GLAD_API_CALL PFNGLWEIGHTFVARBPROC glad_glWeightfvARB;
#define glWeightfvARB glad_glWeightfvARB
GLAD_API_CALL PFNGLWEIGHTIVARBPROC glad_glWeightivARB;
#define glWeightivARB glad_glWeightivARB
GLAD_API_CALL PFNGLWEIGHTSVARBPROC glad_glWeightsvARB;
#define glWeightsvARB glad_glWeightsvARB
GLAD_API_CALL PFNGLWEIGHTUBVARBPROC glad_glWeightubvARB;
#define glWeightubvARB glad_glWeightubvARB
GLAD_API_CALL PFNGLWEIGHTUIVARBPROC glad_glWeightuivARB;
#define glWeightuivARB glad_glWeightuivARB
GLAD_API_CALL PFNGLWEIGHTUSVARBPROC glad_glWeightusvARB;
#define glWeightusvARB glad_glWeightusvARB
GLAD_API_CALL PFNGLWINDOWPOS2DPROC glad_glWindowPos2d;
#define glWindowPos2d glad_glWindowPos2d
GLAD_API_CALL PFNGLWINDOWPOS2DARBPROC glad_glWindowPos2dARB;
#define glWindowPos2dARB glad_glWindowPos2dARB
GLAD_API_CALL PFNGLWINDOWPOS2DMESAPROC glad_glWindowPos2dMESA;
#define glWindowPos2dMESA glad_glWindowPos2dMESA
GLAD_API_CALL PFNGLWINDOWPOS2DVPROC glad_glWindowPos2dv;
#define glWindowPos2dv glad_glWindowPos2dv
GLAD_API_CALL PFNGLWINDOWPOS2DVARBPROC glad_glWindowPos2dvARB;
#define glWindowPos2dvARB glad_glWindowPos2dvARB
GLAD_API_CALL PFNGLWINDOWPOS2DVMESAPROC glad_glWindowPos2dvMESA;
#define glWindowPos2dvMESA glad_glWindowPos2dvMESA
GLAD_API_CALL PFNGLWINDOWPOS2FPROC glad_glWindowPos2f;
#define glWindowPos2f glad_glWindowPos2f
GLAD_API_CALL PFNGLWINDOWPOS2FARBPROC glad_glWindowPos2fARB;
#define glWindowPos2fARB glad_glWindowPos2fARB
GLAD_API_CALL PFNGLWINDOWPOS2FMESAPROC glad_glWindowPos2fMESA;
#define glWindowPos2fMESA glad_glWindowPos2fMESA
GLAD_API_CALL PFNGLWINDOWPOS2FVPROC glad_glWindowPos2fv;
#define glWindowPos2fv glad_glWindowPos2fv
GLAD_API_CALL PFNGLWINDOWPOS2FVARBPROC glad_glWindowPos2fvARB;
#define glWindowPos2fvARB glad_glWindowPos2fvARB
GLAD_API_CALL PFNGLWINDOWPOS2FVMESAPROC glad_glWindowPos2fvMESA;
#define glWindowPos2fvMESA glad_glWindowPos2fvMESA
GLAD_API_CALL PFNGLWINDOWPOS2IPROC glad_glWindowPos2i;
#define glWindowPos2i glad_glWindowPos2i
GLAD_API_CALL PFNGLWINDOWPOS2IARBPROC glad_glWindowPos2iARB;
#define glWindowPos2iARB glad_glWindowPos2iARB
GLAD_API_CALL PFNGLWINDOWPOS2IMESAPROC glad_glWindowPos2iMESA;
#define glWindowPos2iMESA glad_glWindowPos2iMESA
GLAD_API_CALL PFNGLWINDOWPOS2IVPROC glad_glWindowPos2iv;
#define glWindowPos2iv glad_glWindowPos2iv
GLAD_API_CALL PFNGLWINDOWPOS2IVARBPROC glad_glWindowPos2ivARB;
#define glWindowPos2ivARB glad_glWindowPos2ivARB
GLAD_API_CALL PFNGLWINDOWPOS2IVMESAPROC glad_glWindowPos2ivMESA;
#define glWindowPos2ivMESA glad_glWindowPos2ivMESA
GLAD_API_CALL PFNGLWINDOWPOS2SPROC glad_glWindowPos2s;
#define glWindowPos2s glad_glWindowPos2s
GLAD_API_CALL PFNGLWINDOWPOS2SARBPROC glad_glWindowPos2sARB;
#define glWindowPos2sARB glad_glWindowPos2sARB
GLAD_API_CALL PFNGLWINDOWPOS2SMESAPROC glad_glWindowPos2sMESA;
#define glWindowPos2sMESA glad_glWindowPos2sMESA
GLAD_API_CALL PFNGLWINDOWPOS2SVPROC glad_glWindowPos2sv;
#define glWindowPos2sv glad_glWindowPos2sv
GLAD_API_CALL PFNGLWINDOWPOS2SVARBPROC glad_glWindowPos2svARB;
#define glWindowPos2svARB glad_glWindowPos2svARB
GLAD_API_CALL PFNGLWINDOWPOS2SVMESAPROC glad_glWindowPos2svMESA;
#define glWindowPos2svMESA glad_glWindowPos2svMESA
GLAD_API_CALL PFNGLWINDOWPOS3DPROC glad_glWindowPos3d;
#define glWindowPos3d glad_glWindowPos3d
GLAD_API_CALL PFNGLWINDOWPOS3DARBPROC glad_glWindowPos3dARB;
#define glWindowPos3dARB glad_glWindowPos3dARB
GLAD_API_CALL PFNGLWINDOWPOS3DMESAPROC glad_glWindowPos3dMESA;
#define glWindowPos3dMESA glad_glWindowPos3dMESA
GLAD_API_CALL PFNGLWINDOWPOS3DVPROC glad_glWindowPos3dv;
#define glWindowPos3dv glad_glWindowPos3dv
GLAD_API_CALL PFNGLWINDOWPOS3DVARBPROC glad_glWindowPos3dvARB;
#define glWindowPos3dvARB glad_glWindowPos3dvARB
GLAD_API_CALL PFNGLWINDOWPOS3DVMESAPROC glad_glWindowPos3dvMESA;
#define glWindowPos3dvMESA glad_glWindowPos3dvMESA
GLAD_API_CALL PFNGLWINDOWPOS3FPROC glad_glWindowPos3f;
#define glWindowPos3f glad_glWindowPos3f
GLAD_API_CALL PFNGLWINDOWPOS3FARBPROC glad_glWindowPos3fARB;
#define glWindowPos3fARB glad_glWindowPos3fARB
GLAD_API_CALL PFNGLWINDOWPOS3FMESAPROC glad_glWindowPos3fMESA;
#define glWindowPos3fMESA glad_glWindowPos3fMESA
GLAD_API_CALL PFNGLWINDOWPOS3FVPROC glad_glWindowPos3fv;
#define glWindowPos3fv glad_glWindowPos3fv
GLAD_API_CALL PFNGLWINDOWPOS3FVARBPROC glad_glWindowPos3fvARB;
#define glWindowPos3fvARB glad_glWindowPos3fvARB
GLAD_API_CALL PFNGLWINDOWPOS3FVMESAPROC glad_glWindowPos3fvMESA;
#define glWindowPos3fvMESA glad_glWindowPos3fvMESA
GLAD_API_CALL PFNGLWINDOWPOS3IPROC glad_glWindowPos3i;
#define glWindowPos3i glad_glWindowPos3i
GLAD_API_CALL PFNGLWINDOWPOS3IARBPROC glad_glWindowPos3iARB;
#define glWindowPos3iARB glad_glWindowPos3iARB
GLAD_API_CALL PFNGLWINDOWPOS3IMESAPROC glad_glWindowPos3iMESA;
#define glWindowPos3iMESA glad_glWindowPos3iMESA
GLAD_API_CALL PFNGLWINDOWPOS3IVPROC glad_glWindowPos3iv;
#define glWindowPos3iv glad_glWindowPos3iv
GLAD_API_CALL PFNGLWINDOWPOS3IVARBPROC glad_glWindowPos3ivARB;
#define glWindowPos3ivARB glad_glWindowPos3ivARB
GLAD_API_CALL PFNGLWINDOWPOS3IVMESAPROC glad_glWindowPos3ivMESA;
#define glWindowPos3ivMESA glad_glWindowPos3ivMESA
GLAD_API_CALL PFNGLWINDOWPOS3SPROC glad_glWindowPos3s;
#define glWindowPos3s glad_glWindowPos3s
GLAD_API_CALL PFNGLWINDOWPOS3SARBPROC glad_glWindowPos3sARB;
#define glWindowPos3sARB glad_glWindowPos3sARB
GLAD_API_CALL PFNGLWINDOWPOS3SMESAPROC glad_glWindowPos3sMESA;
#define glWindowPos3sMESA glad_glWindowPos3sMESA
GLAD_API_CALL PFNGLWINDOWPOS3SVPROC glad_glWindowPos3sv;
#define glWindowPos3sv glad_glWindowPos3sv
GLAD_API_CALL PFNGLWINDOWPOS3SVARBPROC glad_glWindowPos3svARB;
#define glWindowPos3svARB glad_glWindowPos3svARB
GLAD_API_CALL PFNGLWINDOWPOS3SVMESAPROC glad_glWindowPos3svMESA;
#define glWindowPos3svMESA glad_glWindowPos3svMESA
GLAD_API_CALL PFNGLWINDOWPOS4DMESAPROC glad_glWindowPos4dMESA;
#define glWindowPos4dMESA glad_glWindowPos4dMESA
GLAD_API_CALL PFNGLWINDOWPOS4DVMESAPROC glad_glWindowPos4dvMESA;
#define glWindowPos4dvMESA glad_glWindowPos4dvMESA
GLAD_API_CALL PFNGLWINDOWPOS4FMESAPROC glad_glWindowPos4fMESA;
#define glWindowPos4fMESA glad_glWindowPos4fMESA
GLAD_API_CALL PFNGLWINDOWPOS4FVMESAPROC glad_glWindowPos4fvMESA;
#define glWindowPos4fvMESA glad_glWindowPos4fvMESA
GLAD_API_CALL PFNGLWINDOWPOS4IMESAPROC glad_glWindowPos4iMESA;
#define glWindowPos4iMESA glad_glWindowPos4iMESA
GLAD_API_CALL PFNGLWINDOWPOS4IVMESAPROC glad_glWindowPos4ivMESA;
#define glWindowPos4ivMESA glad_glWindowPos4ivMESA
GLAD_API_CALL PFNGLWINDOWPOS4SMESAPROC glad_glWindowPos4sMESA;
#define glWindowPos4sMESA glad_glWindowPos4sMESA
GLAD_API_CALL PFNGLWINDOWPOS4SVMESAPROC glad_glWindowPos4svMESA;
#define glWindowPos4svMESA glad_glWindowPos4svMESA
GLAD_API_CALL PFNGLWINDOWRECTANGLESEXTPROC glad_glWindowRectanglesEXT;
#define glWindowRectanglesEXT glad_glWindowRectanglesEXT
GLAD_API_CALL PFNGLWRITEMASKEXTPROC glad_glWriteMaskEXT;
#define glWriteMaskEXT glad_glWriteMaskEXT





GLAD_API_CALL int gladLoadGLUserPtr( GLADuserptrloadfunc load, void *userptr);
GLAD_API_CALL int gladLoadGL( GLADloadfunc load);


#ifdef GLAD_GL

GLAD_API_CALL int gladLoaderLoadGL(void);
GLAD_API_CALL void gladLoaderUnloadGL(void);

#endif

#ifdef __cplusplus
}
#endif
#endif

```

`Modules/SDL2/CMakeLists.txt`:

```txt

SET(_target ToonSDL2)

DEFINE_MODULE(${_target} SDL2)

TARGET_LINK_LIBRARIES(
    ${_target}
    PUBLIC
        SDL2::SDL2
)
```

`Modules/SDL2/Private/SDL2GraphicsDriver.cpp`:

```cpp
#include <Toon/SDL2/SDL2GraphicsDriver.hpp>

#include <Toon/Toon.hpp>
#include <Toon/Log.hpp>

namespace Toon::SDL2 {

TOON_SDL2_API
bool SDL2GraphicsDriver::Initialize()
{
    if (SDL_Init(SDL_INIT_EVERYTHING) < 0) {
        ToonLogError("Failed to initialize SDL, %s", SDL_GetError());
        return false;
    }

    SDL_version version;
    SDL_GetVersion(&version);
    ToonLogVerbose("SDL Version: %d.%d.%d", (int)version.major, (int)version.minor, (int)version.patch);

    _inputDriver = new SDL2InputDriver();
    SetInputDriver(std::unique_ptr<InputDriver>(_inputDriver));

    return true;
}

TOON_SDL2_API
void SDL2GraphicsDriver::Terminate()
{
    _inputDriver = nullptr;
    SetInputDriver(nullptr);

    SDL_DestroyWindow(_sdlWindow);
    _sdlWindow = nullptr;

    SDL_Quit();
}

TOON_SDL2_API
bool SDL2GraphicsDriver::CreateWindow(unsigned flags)
{
    _windowTitle = GetApplicationName() + " (" + GetApplicationVersion().ToString() + ")";

    glm::ivec2 size = GetWindowSize();

    if (_sdlWindow) {
        SDL_DestroyWindow(_sdlWindow);
        _sdlWindow = nullptr;
    }

    _sdlWindow = SDL_CreateWindow(_windowTitle.c_str(),
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        size.x, size.y, 
        flags | SDL_WINDOW_RESIZABLE);

    if (!_sdlWindow) {
        ToonLogError("SDL_CreateWindow() failed, %s", SDL_GetError());
        return false;
    }

    Uint16 pixels[16 * 16] = { 0xFFFF };
    SDL_Surface * surface = SDL_CreateRGBSurfaceFrom(pixels, 16, 16, 16, 16 * 2,
                                                     0x0f00, 0x00f0, 0x000f, 0xf000);
    SDL_SetWindowIcon(_sdlWindow, surface);
    SDL_FreeSurface(surface);

    return true;
}

TOON_SDL2_API
void SDL2GraphicsDriver::ProcessEvents()
{
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        if (event.type == SDL_QUIT) {
            SetRunning(false);
        }

        _inputDriver->ProcessEvent(&event);

        if (event.type == SDL_WINDOWEVENT)
        {
            switch (event.window.event) {
            case SDL_WINDOWEVENT_RESIZED:
            {
                glm::ivec2 size = { event.window.data1, event.window.data2 };
                _windowSize = size;

                WindowResizedEventData data;
                data.Size = size;
                WindowResizedEvent.Call(&data);

                break;
            }
            }
        }
    }
}

void SDL2GraphicsDriver::UpdateWindowTitle(const string& title)
{
    SDL_SetWindowTitle(_sdlWindow, title.c_str());
}

void SDL2GraphicsDriver::UpdateWindowSize(const glm::ivec2& size) 
{
    SDL_SetWindowSize(_sdlWindow, size.x, size.y);

    // TODO: Investigate why this wasn't done automatically from the ProcessEvents loop
    WindowResizedEventData data;
    data.Size = size;
    WindowResizedEvent.Call(&data);
}

} // namespace Toon::SDL2
```

`Modules/SDL2/Private/SDL2InputDriver.cpp`:

```cpp
#include <Toon/SDL2/SDL2InputDriver.hpp>

#include <Toon/Log.hpp>

namespace Toon::SDL2 {

void SDL2InputDriver::ProcessEvent(SDL_Event * event)
{
    switch (event->type) {
    case SDL_KEYDOWN:
        {
            KeyboardKey key = GetSDLKey(event->key.keysym.sym);
            ToonLogInfo("%s Pressed", GetKeyboardKeyName(key));
        }
        break;
    case SDL_KEYUP:
        {
            KeyboardKey key = GetSDLKey(event->key.keysym.sym);
            ToonLogInfo("%s Released", GetKeyboardKeyName(key));
        }
        break;
    case SDL_MOUSEBUTTONDOWN:
        {
            MouseButton button = GetSDLMouseButton(event->button.button);
            ToonLogInfo("Mouse %s Pressed", GetMouseButtonName(button));
        }
        break;
    case SDL_MOUSEBUTTONUP:
        {
            MouseButton button = GetSDLMouseButton(event->button.button);
            ToonLogInfo("Mouse %s Released", GetMouseButtonName(button));
        }
        break;
    case SDL_MOUSEMOTION:
        {
        }
        break;
    case SDL_CONTROLLERBUTTONDOWN:
        {
            ControllerButton button = GetSDLControllerButton(event->cbutton.button);
            ToonLogInfo("%s Pressed", GetControllerButtonName(button));
        }
        break;
    case SDL_CONTROLLERBUTTONUP:
        {
            ControllerButton button = GetSDLControllerButton(event->cbutton.button);
            ToonLogInfo("%s Released", GetControllerButtonName(button));
        }
        break;
    case SDL_CONTROLLERDEVICEADDED:
        {
        }
        break;
    case SDL_CONTROLLERDEVICEREMOVED:
        {
        }
        break;
    default: ;
    }
}

glm::ivec2 SDL2InputDriver::GetMouseCoordinates() const
{
    int x, y;
    SDL_GetMouseState(&x, &y);
    return { x, y };
}

KeyboardKey SDL2InputDriver::GetSDLKey(int sdlKey)
{
    switch (sdlKey) {
    case SDLK_a:
        return KeyboardKey::A;
    case SDLK_b:
        return KeyboardKey::B;
    case SDLK_c:
        return KeyboardKey::C;
    case SDLK_d:
        return KeyboardKey::D;
    case SDLK_e:
        return KeyboardKey::E;
    case SDLK_f:
        return KeyboardKey::F;
    case SDLK_g:
        return KeyboardKey::G;
    case SDLK_h:
        return KeyboardKey::H;
    case SDLK_i:
        return KeyboardKey::I;
    case SDLK_j:
        return KeyboardKey::J;
    case SDLK_k:
        return KeyboardKey::K;
    case SDLK_l:
        return KeyboardKey::L;
    case SDLK_m:
        return KeyboardKey::M;
    case SDLK_n:
        return KeyboardKey::N;
    case SDLK_o:
        return KeyboardKey::O;
    case SDLK_p:
        return KeyboardKey::P;
    case SDLK_q:
        return KeyboardKey::Q;
    case SDLK_r:
        return KeyboardKey::R;
    case SDLK_s:
        return KeyboardKey::S;
    case SDLK_t:
        return KeyboardKey::T;
    case SDLK_u:
        return KeyboardKey::U;
    case SDLK_v:
        return KeyboardKey::V;
    case SDLK_w:
        return KeyboardKey::W;
    case SDLK_x:
        return KeyboardKey::X;
    case SDLK_y:
        return KeyboardKey::Y;
    case SDLK_z:
        return KeyboardKey::Z;
    case SDLK_0:
        return KeyboardKey::Num0;
    case SDLK_1:
        return KeyboardKey::Num1;
    case SDLK_2:
        return KeyboardKey::Num2;
    case SDLK_3:
        return KeyboardKey::Num3;
    case SDLK_4:
        return KeyboardKey::Num4;
    case SDLK_5:
        return KeyboardKey::Num5;
    case SDLK_6:
        return KeyboardKey::Num6;
    case SDLK_7:
        return KeyboardKey::Num7;
    case SDLK_8:
        return KeyboardKey::Num8;
    case SDLK_9:
        return KeyboardKey::Num9;
    case SDLK_KP_0:
        return KeyboardKey::Numpad0;
    case SDLK_KP_1:
        return KeyboardKey::Numpad1;
    case SDLK_KP_2:
        return KeyboardKey::Numpad2;
    case SDLK_KP_3:
        return KeyboardKey::Numpad3;
    case SDLK_KP_4:
        return KeyboardKey::Numpad4;
    case SDLK_KP_5:
        return KeyboardKey::Numpad5;
    case SDLK_KP_6:
        return KeyboardKey::Numpad6;
    case SDLK_KP_7:
        return KeyboardKey::Numpad7;
    case SDLK_KP_8:
        return KeyboardKey::Numpad8;
    case SDLK_KP_9:
        return KeyboardKey::Numpad9;
    case SDLK_KP_PLUS:
        return KeyboardKey::NumpadPlus;
    case SDLK_KP_MINUS:
        return KeyboardKey::NumpadMinus;
    case SDLK_KP_MULTIPLY:
        return KeyboardKey::NumpadMultiply;
    case SDLK_KP_DIVIDE:
        return KeyboardKey::NumpadDivide;
    case SDLK_KP_ENTER:
        return KeyboardKey::NumpadEnter;
    case SDLK_KP_PERIOD:
        return KeyboardKey::NumpadPeriod;
    case SDLK_F1:
        return KeyboardKey::F1;
    case SDLK_F2:
        return KeyboardKey::F2;
    case SDLK_F3:
        return KeyboardKey::F3;
    case SDLK_F4:
        return KeyboardKey::F4;
    case SDLK_F5:
        return KeyboardKey::F5;
    case SDLK_F6:
        return KeyboardKey::F6;
    case SDLK_F7:
        return KeyboardKey::F7;
    case SDLK_F8:
        return KeyboardKey::F8;
    case SDLK_F9:
        return KeyboardKey::F9;
    case SDLK_F10:
        return KeyboardKey::F10;
    case SDLK_F11:
        return KeyboardKey::F11;
    case SDLK_F12:
        return KeyboardKey::F12;
    case SDLK_F13:
        return KeyboardKey::F13;
    case SDLK_F14:
        return KeyboardKey::F14;
    case SDLK_F15:
        return KeyboardKey::F15;
    case SDLK_F16:
        return KeyboardKey::F16;
    case SDLK_F17:
        return KeyboardKey::F17;
    case SDLK_F18:
        return KeyboardKey::F18;
    case SDLK_F19:
        return KeyboardKey::F19;
    case SDLK_F20:
        return KeyboardKey::F20;
    case SDLK_F21:
        return KeyboardKey::F21;
    case SDLK_F22:
        return KeyboardKey::F22;
    case SDLK_F23:
        return KeyboardKey::F23;
    case SDLK_F24:
        return KeyboardKey::F24;
    case SDLK_ESCAPE:
        return KeyboardKey::Escape;
    case SDLK_DELETE:
        return KeyboardKey::Delete;
    case SDLK_INSERT:
        return KeyboardKey::Insert;
    case SDLK_HOME:
        return KeyboardKey::Home;
    case SDLK_END:
        return KeyboardKey::End;
    case SDLK_PAGEUP:
        return KeyboardKey::PageUp;
    case SDLK_PAGEDOWN:
        return KeyboardKey::PageDown;
    case SDLK_BACKSPACE:
        return KeyboardKey::Backspace;
    case SDLK_RETURN:
        return KeyboardKey::Enter;
    case SDLK_SPACE:
        return KeyboardKey::Space;
    case SDLK_LSHIFT:
        return KeyboardKey::LeftShift;
    case SDLK_RSHIFT:
        return KeyboardKey::RightShift;
    case SDLK_LCTRL:
        return KeyboardKey::LeftControl;
    case SDLK_RCTRL:
        return KeyboardKey::RightControl;
    case SDLK_LALT:
        return KeyboardKey::LeftAlt;
    case SDLK_RALT:
        return KeyboardKey::RightAlt;
    case SDLK_PRINTSCREEN:
        return KeyboardKey::PrintScreen;
    case SDLK_PAUSE:
        return KeyboardKey::Break;
    case SDLK_BACKQUOTE:
        return KeyboardKey::Grave;
    case SDLK_TAB:
        return KeyboardKey::Tab;
    case SDLK_CAPSLOCK:
        return KeyboardKey::CapsLock;
    case SDLK_NUMLOCKCLEAR:
        return KeyboardKey::NumLock;
    case SDLK_SCROLLLOCK:
        return KeyboardKey::ScrollLock;
    case SDLK_LGUI:
        return KeyboardKey::LeftSuper;
    case SDLK_RGUI:
        return KeyboardKey::RightSuper;
    case SDLK_MENU:
        return KeyboardKey::Menu;
    case SDLK_LEFT:
        return KeyboardKey::Left;
    case SDLK_RIGHT:
        return KeyboardKey::Right;
    case SDLK_UP:
        return KeyboardKey::Up;
    case SDLK_DOWN:
        return KeyboardKey::Down;
    case SDLK_MINUS:
        return KeyboardKey::Minus;
    case SDLK_EQUALS:
        return KeyboardKey::Equals;
    case SDLK_SEMICOLON:
        return KeyboardKey::Semicolon;
    case SDLK_QUOTE:
        return KeyboardKey::Quote;
    case SDLK_SLASH:
        return KeyboardKey::Slash;
    case SDLK_BACKSLASH:
        return KeyboardKey::Backslash;
    case SDLK_COMMA:
        return KeyboardKey::Comma;
    case SDLK_PERIOD:
        return KeyboardKey::Period;
    case SDLK_LEFTBRACKET:
        return KeyboardKey::LeftBracket;
    case SDLK_RIGHTBRACKET:
        return KeyboardKey::RightBracket;
    }

    return KeyboardKey::Unknown;
}

MouseButton SDL2InputDriver::GetSDLMouseButton(int sdlButton)
{
    switch (sdlButton) {
    case SDL_BUTTON_LEFT:
        return MouseButton::Left;
    case SDL_BUTTON_RIGHT:
        return MouseButton::Right;
    case SDL_BUTTON_MIDDLE:
        return MouseButton::Middle;
    }

    return MouseButton::Unknown;
}

ControllerButton SDL2InputDriver::GetSDLControllerButton(int sdlButton)
{
    switch (sdlButton) {
    case SDL_CONTROLLER_BUTTON_A:
        return ControllerButton::A;
    case SDL_CONTROLLER_BUTTON_B:
        return ControllerButton::B;
    case SDL_CONTROLLER_BUTTON_X:
        return ControllerButton::X;
    case SDL_CONTROLLER_BUTTON_Y:
        return ControllerButton::Y;
    case SDL_CONTROLLER_BUTTON_BACK:
        return ControllerButton::Back;
    case SDL_CONTROLLER_BUTTON_GUIDE:
        return ControllerButton::Guide;
    case SDL_CONTROLLER_BUTTON_START:
        return ControllerButton::Start;
    case SDL_CONTROLLER_BUTTON_LEFTSTICK:
        return ControllerButton::LeftStick;
    case SDL_CONTROLLER_BUTTON_RIGHTSTICK:
        return ControllerButton::RightStick;
    case SDL_CONTROLLER_BUTTON_LEFTSHOULDER:
        return ControllerButton::LeftShoulder;
    case SDL_CONTROLLER_BUTTON_RIGHTSHOULDER:
        return ControllerButton::RightShoulder;
    case SDL_CONTROLLER_BUTTON_DPAD_UP:
        return ControllerButton::DPadUp;
    case SDL_CONTROLLER_BUTTON_DPAD_DOWN:
        return ControllerButton::DPadDown;
    case SDL_CONTROLLER_BUTTON_DPAD_LEFT:
        return ControllerButton::DPadLeft;
    case SDL_CONTROLLER_BUTTON_DPAD_RIGHT:
        return ControllerButton::DPadRight;
    }

    return ControllerButton::Unknown;
}

} // namespace Toon::SDL2

```

`Modules/SDL2/Public/Toon/SDL2/SDL2Config.hpp`:

```hpp
#ifndef TOON_SDL2_CONFIG_HPP
#define TOON_SDL2_CONFIG_HPP

#include <Toon/Config.hpp>

#if defined(TOON_SDL2_EXPORT)
    #define TOON_SDL2_API TOON_API_EXPORT
#else
    #define TOON_SDL2_API TOON_API_IMPORT
#endif

#include <SDL.h>

#endif // TOON_SDL2_CONFIG_HPP
```

`Modules/SDL2/Public/Toon/SDL2/SDL2GraphicsDriver.hpp`:

```hpp
#ifndef TOON_SDL2_GRAPHICS_DRIVER_HPP
#define TOON_SDL2_GRAPHICS_DRIVER_HPP

#include <Toon/SDL2/SDL2Config.hpp>

#include <Toon/GraphicsDriver.hpp>
#include <Toon/SDL2/SDL2InputDriver.hpp>

namespace Toon::SDL2 {

class TOON_SDL2_API SDL2GraphicsDriver : public GraphicsDriver
{
public:

    bool Initialize() override;

    void Terminate() override;

    virtual bool CreateWindow(unsigned flags);

    void ProcessEvents() override;

    SDL_Window * GetSDL2Window() const {
        return _sdlWindow;
    }

protected:

    void UpdateWindowTitle(const string& title) override;

    void UpdateWindowSize(const glm::ivec2& size) override;

private:

    SDL_Window * _sdlWindow = nullptr;

    SDL2InputDriver * _inputDriver = nullptr;

}; // class SDL2GraphicsDriver

} // namespace Toon::SDL2

#endif // TOON_SDL2_GRAPHICS_DRIVER_HPP
```

`Modules/SDL2/Public/Toon/SDL2/SDL2InputDriver.hpp`:

```hpp
#ifndef TOON_SDL2_INPUT_DRIVER_HPP
#define TOON_SDL2_INPUT_DRIVER_HPP

#include <Toon/SDL2/SDL2Config.hpp>

#include <Toon/InputDriver.hpp>

namespace Toon::SDL2 {

class TOON_SDL2_API SDL2InputDriver : public InputDriver
{
public:

    DISALLOW_COPY_AND_ASSIGN(SDL2InputDriver)

    SDL2InputDriver() = default;

    virtual ~SDL2InputDriver() = default;

    void ProcessEvent(SDL_Event * event);

    glm::ivec2 GetMouseCoordinates() const;

private:

    KeyboardKey GetSDLKey(int sdlKey);

    MouseButton GetSDLMouseButton(int button);

    ControllerButton GetSDLControllerButton(int button);
    
}; // class SDL2InputDriver

} // namespace Toon::SDL2

#endif // TOON_SDL2_INPUT_DRIVER_HPP

```

`Modules/STBI/CMakeLists.txt`:

```txt

SET(_target ToonSTBI)

DEFINE_MODULE(${_target} STBI)

```

`Modules/STBI/Private/STBIModule.cpp`:

```cpp
#include <Toon/Module.hpp>

#include <Toon/STBI/STBITextureImporter.hpp>

namespace Toon::STBI {

bool ModuleInit() {
    AddTextureImporter("STBI", std::unique_ptr<TextureImporter>(new STBITextureImporter()));
    return true;
}

void ModuleTerm() {
    RemoveTextureImporter("STBI");
}

TOON_MODULE {
    .Name       = "STBI",
    .Initialize = ModuleInit,
    .Terminate  = ModuleTerm,
};

} // namespace Toon::STBI
```

`Modules/STBI/Private/STBITextureImporter.cpp`:

```cpp
#include <Toon/STBI/STBITextureImporter.hpp>

#include <Toon/Log.hpp>
#include <Toon/Math.hpp>
#include <Toon/Benchmark.hpp>
#include <Toon/GraphicsDriver.hpp>
#include <Toon/STBI/STBITextureData.hpp>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"

#define STB_IMAGE_IMPLEMENTATION
#include <stb/stb_image.h>

#pragma clang diagnostic pop

#pragma GCC diagnostic pop

namespace Toon::STBI {

TOON_STBI_API
std::unique_ptr<TextureData> STBITextureImporter::LoadFromFile(const std::string& filename, bool useAssetPath)
{
    ToonBenchmarkStart();

    glm::ivec2 size;
    int components;
    uint8_t* data = nullptr;

    if (useAssetPath) {
        const auto& assetPathList = GetAssetPathList();

        for (const auto& path : assetPathList) {
            Path fullPath = path / "Textures" / filename;
            data = stbi_load(fullPath.ToCString(), &size.x, &size.y, &components, STBI_rgb_alpha);
            if (data) {
                break;
            }
        }
    }
    else {
        data = stbi_load(filename.c_str(), &size.x, &size.y, &components, STBI_rgb_alpha);
    }

    if (!data) {
        return nullptr;
    }

    ToonLogLoad("Loaded texture from '%s'", filename);

    STBITextureData * textureData = new STBITextureData();
    textureData->Data = data;
    textureData->Size = size;

    ToonBenchmarkEnd();
    return std::unique_ptr<TextureData>(textureData);
}

TOON_STBI_API
std::unique_ptr<TextureData> STBITextureImporter::LoadFromMemory(const uint8_t * buffer, size_t length)
{
    ToonBenchmarkStart();

    glm::ivec2 size;
    int components;

    uint8_t * data = stbi_load_from_memory(buffer, length, &size.x, &size.y, &components, STBI_rgb_alpha);
    if (!data) {
        return nullptr;
    }

    STBITextureData * textureData = new STBITextureData();
    textureData->Data = data;
    textureData->Size = size;
    
    ToonBenchmarkEnd();
    return std::unique_ptr<TextureData>(textureData);
}

} // namespace Toon::STBI
```

`Modules/STBI/Public/Toon/STBI/STBIConfig.hpp`:

```hpp
#ifndef TOON_STBI_CONFIG_HPP
#define TOON_STBI_CONFIG_HPP

#include <Toon/Config.hpp>

#if defined(TOON_STBI_EXPORT)
    #define TOON_STBI_API TOON_API_EXPORT
#else
    #define TOON_STBI_API TOON_API_IMPORT
#endif

#define STB_NO_HDR
#define STB_NO_PSD
#define STB_NO_PIC
#define STB_NO_PNM
#include <stb/stb_image.h>

#endif // TOON_STBI_CONFIG_HPP
```

`Modules/STBI/Public/Toon/STBI/STBITextureData.hpp`:

```hpp
#ifndef TOON_STBI_TEXTURE_DATA_HPP
#define TOON_STBI_TEXTURE_DATA_HPP

#include <Toon/STBI/STBIConfig.hpp>
#include <Toon/TextureData.hpp>

namespace Toon::STBI {

class TOON_STBI_API STBITextureData : public TextureData
{
public:
    
    uint8_t * Data = nullptr;

    glm::uvec2 Size;

    virtual ~STBITextureData() {
        stbi_image_free(Data);
    }

    uint8_t * GetData() const override {
        return Data;
    }

    glm::uvec2 GetSize() const override {
        return Size;
    }

    TextureDataType GetDataType() const override {
        return TextureDataType::UnsignedByte;
    }
    
}; // class STBITextureData

} // namespace Toon::STBI

#endif // TOON_STBI_TEXTURE_DATA_HPP
```

`Modules/STBI/Public/Toon/STBI/STBITextureImporter.hpp`:

```hpp
#ifndef TOON_STBI_TEXTURE_IMPORTER_HPP
#define TOON_STBI_TEXTURE_IMPORTER_HPP

#include <Toon/STBI/STBIConfig.hpp>

#include <Toon/TextureImporter.hpp>

namespace Toon::STBI {

class TOON_STBI_API STBITextureImporter : public TextureImporter
{
public:

    DISALLOW_COPY_AND_ASSIGN(STBITextureImporter)

    STBITextureImporter() = default;
    
    virtual std::unique_ptr<Toon::TextureData> LoadFromFile(const std::string& filename, bool useAssetPath = true) override;

    virtual std::unique_ptr<Toon::TextureData> LoadFromMemory(const uint8_t * buffer, size_t length) override;
}; // class STBITextureImporter

} // namespace Toon::STBI

#endif // TOON_STBI_TEXTURE_IMPORTER_HPP
```

`Modules/STBI/Public/Toon/STBI/Tests/STBI_TextureImporter_Test.cpp`:

```cpp
#include <Toon/STBI/STBITextureImporter.hpp>

#include <gtest/gtest.h>

#include "test.h"

static Toon::STBI::STBITextureImporter _TextureImporter;

TEST(LoadFromFile, PNG_RGB) {
    auto data = _TextureImporter.LoadFromFile("test_rgb.png");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, PNG_RGBA) {
    auto data = _TextureImporter.LoadFromFile("test_rgba.png");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, PNG_Grey) {
    auto data = _TextureImporter.LoadFromFile("test_grey.png");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, JPEG_RGB) {
    auto data = _TextureImporter.LoadFromFile("test_rgb.jpg");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, JPEG_Grey) {
    auto data = _TextureImporter.LoadFromFile("test_grey.jpg");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, BMP_RGB) {
    auto data = _TextureImporter.LoadFromFile("test_rgb.bmp");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, BMP_Grey) {
    auto data = _TextureImporter.LoadFromFile("test_rgb.bmp");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, TGA) {
    auto data = _TextureImporter.LoadFromFile("test_rgb.tga");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}
TEST(LoadFromFile, GIF_RGB) {
    auto data = _TextureImporter.LoadFromFile("test_rgb.gif");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, GIF_RGBA) {
    auto data = _TextureImporter.LoadFromFile("test_rgba.gif");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, GIF_Grey) {
    auto data = _TextureImporter.LoadFromFile("test_grey.gif");
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromFile, NoFilename) {
    auto data = _TextureImporter.LoadFromFile("");
    EXPECT_TRUE(data == nullptr);
}

TEST(LoadFromFile, FileNotFound) {
    auto data = _TextureImporter.LoadFromFile("asdf.png");
    EXPECT_TRUE(data == nullptr);
}

TEST(LoadFromMemory, PNG_RGB) {
    auto data = _TextureImporter.LoadFromMemory(___Modules_STBI_Tests_test_png, ___Modules_STBI_Tests_test_png_len);
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromMemory, JPEG_RGB) {
    auto data = _TextureImporter.LoadFromMemory(___Modules_STBI_Tests_test_jpg, ___Modules_STBI_Tests_test_jpg_len);
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromMemory, BMP_RGB) {
    auto data = _TextureImporter.LoadFromMemory(___Modules_STBI_Tests_test_bmp, ___Modules_STBI_Tests_test_bmp_len);
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromMemory, TGA_RGB) {
    auto data = _TextureImporter.LoadFromMemory(___Modules_STBI_Tests_test_tga, ___Modules_STBI_Tests_test_tga_len);
    ASSERT_FALSE(data == nullptr);
    EXPECT_EQ(data->GetSize(), Toon::uvec2(32, 32));
}

TEST(LoadFromMemory, NullInput) {
    auto data = _TextureImporter.LoadFromMemory(nullptr, 0);
    EXPECT_TRUE(data == nullptr);
}

int main(int argc, char ** argv)
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

`Modules/STBI/Public/stb/stb_image.h`:

```h
/* stb_image - v2.25 - public domain image loader - http://nothings.org/stb
                                  no warranty implied; use at your own risk

   Do this:
      #define STB_IMAGE_IMPLEMENTATION
   before you include this file in *one* C or C++ file to create the implementation.

   // i.e. it should look like this:
   #include ...
   #include ...
   #include ...
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"

   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free


   QUICK NOTES:
      Primarily of interest to game developers and other people who can
          avoid problematic images and only need the trivial interface

      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
      PNG 1/2/4/8/16-bit-per-channel

      TGA (not sure what subset, if a subset)
      BMP non-1bpp, non-RLE
      PSD (composited view only, no extra channels, 8/16 bit-per-channel)

      GIF (*comp always reports as 4-channel)
      HDR (radiance rgbE format)
      PIC (Softimage PIC)
      PNM (PPM and PGM binary only)

      Animated GIF still needs a proper API, but here's one way to do it:
          http://gist.github.com/urraka/685d9a6340b26b830d49

      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
      - decode from arbitrary I/O callbacks
      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)

   Full documentation under "DOCUMENTATION" below.


LICENSE

  See end of file for license information.

RECENT REVISION HISTORY:

      2.25  (2020-02-02) fix warnings
      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
      2.23  (2019-08-11) fix clang static analysis warning
      2.22  (2019-03-04) gif fixes, fix warnings
      2.21  (2019-02-25) fix typo in comment
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
                         RGB-format JPEG; remove white matting in PSD;
                         allocate large structures on the stack;
                         correct channel count for PNG & BMP
      2.10  (2016-01-22) avoid warning introduced in 2.09
      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED

   See end of file for full revision history.


 ============================    Contributors    =========================

 Image formats                          Extensions, features
    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
    github:urraka (animated gif)           Junggon Kim (PNM comments)
    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
                                           socks-the-fox (16-bit PNG)
                                           Jeremy Sawicki (handle all ImageNet JPGs)
 Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
    Arseny Kapoulkine
    John-Mark Allen
    Carmelo J Fdez-Aguera

 Bug & warning fixes
    Marc LeBlanc            David Woo          Guillaume George   Martins Mozeiko
    Christpher Lloyd        Jerry Jansson      Joseph Thomson     Phil Jordan
    Dave Moore              Roy Eltham         Hayaki Saito       Nathan Reed
    Won Chun                Luke Graham        Johan Duparc       Nick Verigakis
    the Horde3D community   Thomas Ruf         Ronny Chevalier    github:rlyeh
    Janez Zemva             John Bartholomew   Michal Cichon      github:romigrou
    Jonathan Blow           Ken Hamada         Tero Hanninen      github:svdijk
    Laurent Gomila          Cort Stratton      Sergio Gonzalez    github:snagar
    Aruelien Pocheville     Thibault Reuille   Cass Everitt       github:Zelex
    Ryamond Barbiero        Paul Du Bois       Engin Manap        github:grim210
    Aldo Culquicondor       Philipp Wiesemann  Dale Weiler        github:sammyhw
    Oriol Ferrer Mesia      Josh Tobin         Matthew Gregan     github:phprus
    Julian Raschke          Gregory Mullen     Baldur Karlsson    github:poppolopoppo
    Christian Floisand      Kevin Schmidt      JR Smith           github:darealshinji
    Brad Weinberger         Matvey Cherevko                       github:Michaelangel007
    Blazej Dariusz Roszkowski                  Alexander Veselov
*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x                 -- outputs image width in pixels
//    int *y                 -- outputs image height in pixels
//    int *channels_in_file  -- outputs # of image components in image file
//    int desired_channels   -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'desired_channels' if desired_channels is non-zero, or
// *channels_in_file otherwise. If desired_channels is non-zero,
// *channels_in_file has the number of components that _would_ have been
// output otherwise. E.g. if you set desired_channels to 4, you will always
// get RGBA output, but you can check *channels_in_file to see if it's trivially
// opaque because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *channels_in_file will be unchanged. The function
// stbi_failure_reason() can be queried for an extremely brief, end-user
// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// ===========================================================================
//
// UNICODE:
//
//   If compiling for Windows and you wish to use Unicode filenames, compile
//   with
//       #define STBI_WINDOWS_UTF8
//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
//   Windows wchar_t filenames to utf8.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy-to-use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// provide more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small source code footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image supports loading HDR images in general, and currently the Radiance
// .HDR file format specifically. You can still load any file through the existing
// interface; if you attempt to load an HDR file, it will be automatically remapped
// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// By default we convert iphone-formatted PNGs back to RGB, even though
// they are internally encoded differently. You can disable this conversion
// by calling stbi_convert_iphone_png_to_rgb(0), in which case
// you will always just get the native iphone "format" through (which
// is BGR stored in RGB).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// ADDITIONAL CONFIGURATION
//
//  - You can suppress implementation of any of the decoders to reduce
//    your code footprint by #defining one or more of the following
//    symbols before creating the implementation.
//
//        STBI_NO_JPEG
//        STBI_NO_PNG
//        STBI_NO_BMP
//        STBI_NO_PSD
//        STBI_NO_TGA
//        STBI_NO_GIF
//        STBI_NO_HDR
//        STBI_NO_PIC
//        STBI_NO_PNM   (.ppm and .pgm)
//
//  - You can request *only* certain decoders and suppress all other ones
//    (this will be more forward-compatible, as addition of new decoders
//    doesn't require you to disable them explicitly):
//
//        STBI_ONLY_JPEG
//        STBI_ONLY_PNG
//        STBI_ONLY_BMP
//        STBI_ONLY_PSD
//        STBI_ONLY_TGA
//        STBI_ONLY_GIF
//        STBI_ONLY_HDR
//        STBI_ONLY_PIC
//        STBI_ONLY_PNM   (.ppm and .pgm)
//
//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
//


#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
   STBI_default = 0, // only used for desired_channels

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4
};

#include <stdlib.h>
typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;

#ifdef __cplusplus
extern "C" {
#endif

#ifndef STBIDEF
#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif
#endif

//////////////////////////////////////////////////////////////////////////////
//
// PRIMARY API - works on images of any type
//

//
// load image by filename, open file, or memory buffer
//

typedef struct
{
   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
} stbi_io_callbacks;

////////////////////////////////////
//
// 8-bits-per-channel interface
//

STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
#endif

#ifdef STBI_WINDOWS_UTF8
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
#endif

////////////////////////////////////
//
// 16-bits-per-channel interface
//

STBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#endif

////////////////////////////////////
//
// float-per-channel interface
//
#ifndef STBI_NO_LINEAR
   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);

   #ifndef STBI_NO_STDIO
   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
   #endif
#endif

#ifndef STBI_NO_HDR
   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_LINEAR

// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename);
STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO


// get a VERY brief reason for failure
// on most compilers (and ALL modern mainstream compilers) this is threadsafe
STBIDEF const char *stbi_failure_reason  (void);

// free the loaded image -- this is just free()
STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit          (char const *filename);
STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
#endif



// for image formats that explicitly notate that they have premultiplied alpha,
// we just return the colors as stored in the file. set this flag to force
// unpremultiplication. results are undefined if the unpremultiply overflow.
STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

// indicate whether we should process iphone images back to canonical format,
// or just pass them through "as-is"
STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

// flip the image vertically, so the first pixel in the output array is the bottom left
STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

// as above, but only applies to images loaded on the thread that calls the function
// this function is only available if your compiler supports thread-local variables;
// calling it will fail to link if your compiler doesn't
STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);

// ZLIB client - used by PNG, available for other purposes

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
   #ifndef STBI_ONLY_JPEG
   #define STBI_NO_JPEG
   #endif
   #ifndef STBI_ONLY_PNG
   #define STBI_NO_PNG
   #endif
   #ifndef STBI_ONLY_BMP
   #define STBI_NO_BMP
   #endif
   #ifndef STBI_ONLY_PSD
   #define STBI_NO_PSD
   #endif
   #ifndef STBI_ONLY_TGA
   #define STBI_NO_TGA
   #endif
   #ifndef STBI_ONLY_GIF
   #define STBI_NO_GIF
   #endif
   #ifndef STBI_ONLY_HDR
   #define STBI_NO_HDR
   #endif
   #ifndef STBI_ONLY_PIC
   #define STBI_NO_PIC
   #endif
   #ifndef STBI_ONLY_PNM
   #define STBI_NO_PNM
   #endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif


#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#include <math.h>  // ldexp, pow
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifdef __cplusplus
#define STBI_EXTERN extern "C"
#else
#define STBI_EXTERN extern
#endif


#ifndef _MSC_VER
   #ifdef __cplusplus
   #define stbi_inline inline
   #else
   #define stbi_inline
   #endif
#else
   #define stbi_inline __forceinline
#endif

#ifndef STBI_NO_THREAD_LOCALS
   #if defined(__cplusplus) &&  __cplusplus >= 201103L
      #define STBI_THREAD_LOCAL       thread_local
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
      #define STBI_THREAD_LOCAL       _Thread_local
   #elif defined(__GNUC__)
      #define STBI_THREAD_LOCAL       __thread
   #elif defined(_MSC_VER)
      #define STBI_THREAD_LOCAL       __declspec(thread)
#endif
#endif

#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
   #define stbi_lrot(x,y)  _lrotl(x,y)
#else
   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
// but previous attempts to provide the SSE2 functions with runtime
// detection caused numerous issues. The way architecture extensions are
// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
// New behavior: if compiled with -msse2, we use SSE2 without any
// detection; if not, we don't use it at all.
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
//
// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
// simultaneously enabling "-mstackrealign".
//
// See https://github.com/nothings/stb/issues/81 for more information.
//
// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
   int info[4];
   __cpuid(info,1);
   return info[3];
}
#else
static int stbi__cpuid3(void)
{
   int res;
   __asm {
      mov  eax,1
      cpuid
      mov  res,edx
   }
   return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   int info3 = stbi__cpuid3();
   return ((info3 >> 26) & 1) != 0;
}
#endif

#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}
#endif

#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
// assume GCC or Clang on ARM targets
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   fseek((FILE*) user, n, SEEK_CUR);
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
   STBI_ORDER_RGB,
   STBI_ORDER_BGR
};

typedef struct
{
   int bits_per_channel;
   int num_channels;
   int channel_order;
} stbi__result_info;

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__png_is16(stbi__context *s);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__psd_is16(stbi__context *s);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
#endif

static
#ifdef STBI_THREAD_LOCAL
STBI_THREAD_LOCAL
#endif
const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

#ifndef STBI_NO_FAILURE_STRINGS
static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}
#endif

static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}

// stb_image uses ints pervasively, including for offset calculations.
// therefore the largest decoded image size we can support with the
// current code, even on 64-bit targets, is INT_MAX. this is not a
// significant limitation for the intended use case.
//
// we do, however, need to make sure our size calculations don't
// overflow. hence a few helper functions for size calculations that
// multiply integers together, making sure that they're non-negative
// and no overflow occurs.

// return 1 if the sum is valid, 0 on overflow.
// negative terms are considered invalid.
static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And "a + b <= INT_MAX" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}

// returns 1 if the product is valid, 0 on overflow.
// negative factors are considered invalid.
static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}
#endif

// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}

// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}
#endif

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// mallocs with size overflow checking
static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}
#endif

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}
#endif

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
   #define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
   #define stbi__err(x,y)  stbi__err(y)
#else
   #define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load_global = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
#else
static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;

STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}

#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
                                         ? stbi__vertically_flip_on_load_local  \
                                         : stbi__vertically_flip_on_load_global)
#endif // STBI_THREAD_LOCAL

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}

static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}

#ifndef STBI_NO_GIF
static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}
#endif

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   if (ri.bits_per_channel != 8) {
      STBI_ASSERT(ri.bits_per_channel == 16);
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   if (ri.bits_per_channel != 16) {
      STBI_ASSERT(ri.bits_per_channel == 8);
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}

#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}
#endif

#ifndef STBI_NO_STDIO

#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
#endif

#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
{
	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
}
#endif

static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)))
      return 0;

#if _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}


STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}


#endif //!STBI_NO_STDIO

STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}
#endif

#ifndef STBI_NO_LINEAR
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}

STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}

#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
stbi_inline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
// nothing
#else
static void stbi__skip(stbi__context *s, int n)
{
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
// nothing
#else
static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}
#endif

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   return z + (stbi__get16le(s) << 16);
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0);
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0);
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
   stbi_uc  fast[1 << FAST_BITS];
   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
   stbi__uint16 code[256];
   stbi_uc  values[256];
   stbi_uc  size[257];
   unsigned int maxcode[18];
   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi__uint16 dequant[4][64];
   stbi__int16 fast_ac[4][1 << FAST_BITS];

// sizes for components, interleaved MCUs
   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;

// definition of jpeg image component
   struct
   {
      int id;
      int h,v;
      int tq;
      int hd,ha;
      int dc_pred;

      int x,y,w2,h2;
      stbi_uc *data;
      void *raw_data, *raw_coeff;
      stbi_uc *linebuf;
      short   *coeff;   // progressive only
      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
   } img_comp[4];

   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
   int            code_bits;   // number of valid bits
   unsigned char  marker;      // marker seen while filling entropy buffer
   int            nomore;      // flag if we saw a marker so must stop

   int            progressive;
   int            spec_start;
   int            spec_end;
   int            succ_high;
   int            succ_low;
   int            eob_run;
   int            jfif;
   int            app14_color_transform; // Adobe APP14 tag
   int            rgb;

   int scan_n, order[4];
   int restart_interval, todo;

// kernels
   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i)
      for (j=0; j < count[i]; ++j)
         h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}

// (1 << n) - 1
static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}

// bias[n] = (-1<<n) + 1
static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB
   k = stbi_lrot(j->code_buffer, n);
   STBI_ASSERT(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)));
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & ~sgn);
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static const stbi_uc stbi__jpeg_dezigzag[64+15] =
{
    0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0) return stbi__err("bad huffman code","Corrupt JPEG");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      diff = t ? stbi__extend_receive(j, t) : 0;

      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      data[0] = (short) (dc << j->succ_low);
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) << shift);
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) << shift);
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) * 4096)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
      dct_wadd(sum, a, b); \
      dct_wsub(dif, a, b); \
      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
      /* even part */ \
      int16x8_t sum26 = vaddq_s16(row2, row6); \
      dct_long_mul(p1e, sum26, rot0_0); \
      dct_long_mac(t2e, p1e, row6, rot0_1); \
      dct_long_mac(t3e, p1e, row2, rot0_2); \
      int16x8_t sum04 = vaddq_s16(row0, row4); \
      int16x8_t dif04 = vsubq_s16(row0, row4); \
      dct_widen(t0e, sum04); \
      dct_widen(t1e, dif04); \
      dct_wadd(x0, t0e, t3e); \
      dct_wsub(x3, t0e, t3e); \
      dct_wadd(x1, t1e, t2e); \
      dct_wsub(x2, t1e, t2e); \
      /* odd part */ \
      int16x8_t sum15 = vaddq_s16(row1, row5); \
      int16x8_t sum17 = vaddq_s16(row1, row7); \
      int16x8_t sum35 = vaddq_s16(row3, row5); \
      int16x8_t sum37 = vaddq_s16(row3, row7); \
      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
      dct_long_mul(p5o, sumodd, rot1_0); \
      dct_long_mac(p1o, p5o, sum17, rot1_1); \
      dct_long_mac(p2o, p5o, sum35, rot1_2); \
      dct_long_mul(p3o, sum37, rot2_0); \
      dct_long_mul(p4o, sum15, rot2_1); \
      dct_wadd(sump13o, p1o, p3o); \
      dct_wadd(sump24o, p2o, p4o); \
      dct_wadd(sump23o, p2o, p3o); \
      dct_wadd(sump14o, p1o, p4o); \
      dct_long_mac(x4, sump13o, row7, rot3_0); \
      dct_long_mac(x5, sump24o, row5, rot3_1); \
      dct_long_mac(x6, sump23o, row3, rot3_2); \
      dct_long_mac(x7, sump14o, row1, rot3_3); \
      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
   row0 = vld1q_s16(data + 0*8);
   row1 = vld1q_s16(data + 1*8);
   row2 = vld1q_s16(data + 2*8);
   row3 = vld1q_s16(data + 3*8);
   row4 = vld1q_s16(data + 4*8);
   row5 = vld1q_s16(data + 5*8);
   row6 = vld1q_s16(data + 6*8);
   row7 = vld1q_s16(data + 7*8);

   // add DC bias
   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

   // column pass
   dct_pass(vrshrn_n_s32, 10);

   // 16bit 8x8 transpose
   {
// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

      // pass 1
      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
      dct_trn16(row2, row3);
      dct_trn16(row4, row5);
      dct_trn16(row6, row7);

      // pass 2
      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
      dct_trn32(row1, row3);
      dct_trn32(row4, row6);
      dct_trn32(row5, row7);

      // pass 3
      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
      dct_trn64(row1, row5);
      dct_trn64(row2, row6);
      dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
   }

   // row pass
   // vrshrn_n_s32 only supports shifts up to 16, we need
   // 17. so do a non-rounding shift of 16 first then follow
   // up with a rounding shift by 1.
   dct_pass(vshrn_n_s32, 16);

   {
      // pack and round
      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

      // again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

      // sadly can't use interleaved stores here since we only write
      // 8 bytes to each scan line!

      // 8x8 8-bit transpose pass 1
      dct_trn8_8(p0, p1);
      dct_trn8_8(p2, p3);
      dct_trn8_8(p4, p5);
      dct_trn8_8(p6, p7);

      // pass 2
      dct_trn8_16(p0, p2);
      dct_trn8_16(p1, p3);
      dct_trn8_16(p4, p6);
      dct_trn8_16(p5, p7);

      // pass 3
      dct_trn8_32(p0, p4);
      dct_trn8_32(p1, p5);
      dct_trn8_32(p2, p6);
      dct_trn8_32(p3, p7);

      // store
      vst1_u8(out, p0); out += out_stride;
      vst1_u8(out, p1); out += out_stride;
      vst1_u8(out, p2); out += out_stride;
      vst1_u8(out, p3); out += out_stride;
      vst1_u8(out, p4); out += out_stride;
      vst1_u8(out, p5); out += out_stride;
      vst1_u8(out, p6); out += out_stride;
      vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
   }

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err("expected marker","Corrupt JPEG");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err("bad COM len","Corrupt JPEG");
         else
            return stbi__err("bad APP len","Corrupt JPEG");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err("unknown marker","Corrupt JPEG");
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err("bad SOS", "Corrupt JPEG");
      } else {
         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
         z->spec_end = 63;
      }
   }

   return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
            // handle 0s at the end of image data from IP Kamera 9060
            while (!stbi__at_eof(j->s)) {
               int x = stbi__get8(j->s);
               if (x == 255) {
                  j->marker = stbi__get8(j->s);
                  break;
               }
            }
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
      } else {
         if (!stbi__process_marker(j, m)) return 0;
      }
      m = stbi__get_marker(j);
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
                                    int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // "previous" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}

// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;   // expansion factor in each axis
   int w_lores; // horizontal pixels pre-expansion
   int ystep;   // how far through vertical expansion we are
   int ypos;    // which pre-expansion row we're on
} stbi__resample;

// fast 0..255 * 0..255 => 0..255 rounded multiplication
static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}

static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc  size[288];
   stbi__uint16 value[288];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err("bad sizes", "Corrupt PNG");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   if (z->zbuffer >= z->zbuffer_end) return 0;
   return *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      STBI_ASSERT(z->code_buffer < (1U << z->num_bits));
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s == 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   STBI_ASSERT(z->size[b] == s);
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) stbi__fill_bits(a);
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
   cur   = (int) (z->zout     - z->zout_start);
   limit = old_limit = (int) (z->zout_end - z->zout_start);
   while (cur + n > limit)
      limit *= 2;
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err("outofmem", "Out of memory");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static const int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static const int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static const int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            return 1;
         }
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
         if (zout + len > a->zout_end) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
            fill = lencodes[n-1];
         } else if (c == 17)
            c = stbi__zreceive(a,3)+3;
         else {
            STBI_ASSERT(c == 18);
            c = stbi__zreceive(a,7)+11;
         }
         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   STBI_ASSERT(a->num_bits == 0);
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}

static const stbi_uc stbi__zdefault_length[288] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
/*
Init algorithm:
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}
*/

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
   int depth;
} stbi__png;


enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,
   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err("outofmem", "Out of memory");

   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

   for (j=0; j < y; ++j) {
      stbi_uc *cur = a->out + stride*j;
      stbi_uc *prior;
      int filter = *raw++;

      if (filter > 4)
         return stbi__err("invalid filter","Corrupt PNG");

      if (depth < 8) {
         STBI_ASSERT(img_width_bytes <= x);
         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
         filter_bytes = 1;
         width = img_width_bytes;
      }
      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // handle first byte explicitly
      for (k=0; k < filter_bytes; ++k) {
         switch (filter) {
            case STBI__F_none       : cur[k] = raw[k]; break;
            case STBI__F_sub        : cur[k] = raw[k]; break;
            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
            case STBI__F_avg_first  : cur[k] = raw[k]; break;
            case STBI__F_paeth_first: cur[k] = raw[k]; break;
         }
      }

      if (depth == 8) {
         if (img_n != out_n)
            cur[img_n] = 255; // first pixel
         raw += img_n;
         cur += out_n;
         prior += out_n;
      } else if (depth == 16) {
         if (img_n != out_n) {
            cur[filter_bytes]   = 255; // first pixel top byte
            cur[filter_bytes+1] = 255; // first pixel bottom byte
         }
         raw += filter_bytes;
         cur += output_bytes;
         prior += output_bytes;
      } else {
         raw += 1;
         cur += 1;
         prior += 1;
      }

      // this is a little gross, so that we don't switch per-pixel or per-component
      if (depth < 8 || img_n == out_n) {
         int nk = (width - 1)*filter_bytes;
         #define STBI__CASE(f) \
             case f:     \
                for (k=0; k < nk; ++k)
         switch (filter) {
            // "none" filter turns into a memcpy here; make that explicit.
            case STBI__F_none:         memcpy(cur, raw, nk); break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
         }
         #undef STBI__CASE
         raw += nk;
      } else {
         STBI_ASSERT(img_n+1 == out_n);
         #define STBI__CASE(f) \
             case f:     \
                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
                   for (k=0; k < filter_bytes; ++k)
         switch (filter) {
            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
         }
         #undef STBI__CASE

         // the loop above sets the high byte of the pixels' alpha, but for
         // 16 bit png files we also need the low byte set. we'll do that here.
         if (depth == 16) {
            cur = a->out + stride*j; // start at the beginning of the row again
            for (i=0; i < x; ++i,cur+=output_bytes) {
               cur[filter_bytes+1] = 255;
            }
         }
      }
   }

   // we make a separate pass to expand bits to pixels; for performance,
   // this could run two scanlines behind the above code, so it won't
   // intefere with filtering but will still be in the cache.
   if (depth < 8) {
      for (j=0; j < y; ++j) {
         stbi_uc *cur = a->out + stride*j;
         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

         // note that the final byte might overshoot and write more data than desired.
         // we can allocate enough data that this never writes out of memory, but it
         // could also overwrite the next scanline. can it overwrite non-empty data
         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
         // so we need to explicitly clamp the final ones

         if (depth == 4) {
            for (k=x*img_n; k >= 2; k-=2, ++in) {
               *cur++ = scale * ((*in >> 4)       );
               *cur++ = scale * ((*in     ) & 0x0f);
            }
            if (k > 0) *cur++ = scale * ((*in >> 4)       );
         } else if (depth == 2) {
            for (k=x*img_n; k >= 4; k-=4, ++in) {
               *cur++ = scale * ((*in >> 6)       );
               *cur++ = scale * ((*in >> 4) & 0x03);
               *cur++ = scale * ((*in >> 2) & 0x03);
               *cur++ = scale * ((*in     ) & 0x03);
            }
            if (k > 0) *cur++ = scale * ((*in >> 6)       );
            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
         } else if (depth == 1) {
            for (k=x*img_n; k >= 8; k-=8, ++in) {
               *cur++ = scale * ((*in >> 7)       );
               *cur++ = scale * ((*in >> 6) & 0x01);
               *cur++ = scale * ((*in >> 5) & 0x01);
               *cur++ = scale * ((*in >> 4) & 0x01);
               *cur++ = scale * ((*in >> 3) & 0x01);
               *cur++ = scale * ((*in >> 2) & 0x01);
               *cur++ = scale * ((*in >> 1) & 0x01);
               *cur++ = scale * ((*in     ) & 0x01);
            }
            if (k > 0) *cur++ = scale * ((*in >> 7)       );
            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
         }
         if (img_n != out_n) {
            int q;
            // insert alpha = 255
            cur = a->out + stride*j;
            if (img_n == 1) {
               for (q=x-1; q >= 0; --q) {
                  cur[q*2+1] = 255;
                  cur[q*2+0] = cur[q];
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (q=x-1; q >= 0; --q) {
                  cur[q*4+3] = 255;
                  cur[q*4+2] = cur[q*3+2];
                  cur[q*4+1] = cur[q*3+1];
                  cur[q*4+0] = cur[q*3+0];
               }
            }
         }
      }
   } else if (depth == 16) {
      // force the image data from big-endian to platform-native.
      // this is done in a separate pass due to the decoding relying
      // on the data being untouched, but could probably be done
      // per-line during decode if care is taken.
      stbi_uc *cur = a->out;
      stbi__uint16 *cur16 = (stbi__uint16*)cur;

      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
         *cur16 = (cur[0] << 8) | cur[1];
      }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err("outofmem", "Out of memory");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}

static int stbi__unpremultiply_on_load = 0;
static int stbi__de_iphone_flag = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag = flag_true_if_should_convert;
}

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}

#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
            first = 0;
            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
            s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
            s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
               if (scan == STBI__SCAN_header) return 1;
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
               // if SCAN_header, have to scan to see if we have a tRNS
            }
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
               has_trans = 1;
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = "XXXX PNG chunk not known";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth < 8)
         ri->bits_per_channel = 8;
      else
         ri->bits_per_channel = p->depth;
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}

static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}


// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}

// extract an arbitrarily-aligned N-bit value (N=bits)
// from v, and then make it 8-bits long and fractionally
// extend it to full full range.
static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}

typedef struct
{
   int bpp, offset, hsz;
   unsigned int mr,mg,mb,ma, all_a;
   int extra_read;
} stbi__bmp_data;

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               if (info->bpp == 32) {
                  info->mr = 0xffu << 16;
                  info->mg = 0xffu <<  8;
                  info->mb = 0xffu <<  0;
                  info->ma = 0xffu << 24;
                  info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
               } else {
                  info->mr = 31u << 10;
                  info->mg = 31u <<  5;
                  info->mb = 31u <<  0;
               }
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc("bad BMP", "bad BMP");
               }
            } else
               return stbi__errpuc("bad BMP", "bad BMP");
         }
      } else {
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc("bad BMP", "bad BMP");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}


static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      STBI_ASSERT(info.offset == (s->img_buffer - s->buffer_start));
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc("too large", "Corrupt BMP");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // "normal" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}

// read 16bit value and convert to 24bit RGB
static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the "image descriptor byte")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc("too large", "Corrupt TGA");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc("outofmem", "Out of memory");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc("bad palette", "Corrupt TGA");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
      return stbi__errpuc("not PSD", "Corrupt PSD image");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc("wrong version", "Unsupported version of PSD image");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc("bad compression", "PSD has an unknown compression format");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc("too large", "Corrupt PSD");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc("corrupt", "bad RLE data");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
      return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc("bad format","too many packets");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc("bad format","packet has bad compression type");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc("bad file","scanline overrun");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc("bad file","scanline overrun");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}

static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);
   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
   stbi__int16 prefix;
   stbi_uc first;
   stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
   int w,h;
   stbi_uc *out;                 // output buffer (always 4 components)
   stbi_uc *background;          // The current "background" as far as a gif is concerned
   stbi_uc *history;
   int flags, bgindex, ratio, transparent, eflags;
   stbi_uc  pal[256][4];
   stbi_uc lpal[256][4];
   stbi__gif_lzw codes[8192];
   stbi_uc *color_table;
   int parse, step;
   int lflags;
   int start_x, start_y;
   int max_x, max_y;
   int cur_x, cur_y;
   int line_size;
   int delay;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}

static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err("not GIF", "Corrupt GIF");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

   stbi__g_failure_reason = "";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc("no clear code", "Corrupt GIF");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc("too many codes", "Corrupt GIF");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc("illegal code in raster", "Corrupt GIF");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
         }
      }
   }
}

// this function is designed to support animated gifs, although stb_image doesn't support it
// two back is the image from two frames ago, used for a very specific disposal format
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc("too large", "GIF image is too large");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc("outofmem", "Out of memory");

      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that "background"
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispoase of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc("missing color table", "Corrupt GIF");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc("unknown code", "Corrupt GIF");
      }
   }
}

static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC( out, layers * stride );
               if (NULL == tmp) {
                  STBI_FREE(g.out);
                  STBI_FREE(g.history);
                  STBI_FREE(g.background);
                  return stbi__errpuc("outofmem", "Out of memory");
               }
               else
                  out = (stbi_uc*) tmp;
               if (delays) {
                  *delays = (int*) STBI_REALLOC( *delays, sizeof(int) * layers );
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc("not GIF", "Image was not as a gif type.");
   }
}

static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, "#?RGBE\n");
       stbi__rewind(s);
   }
   return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
      return stbi__errpf("not HDR", "Corrupt HDR image");

   // Parse header
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return stbi__errpf("too large", "HDR image is too large");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return stbi__errpf("outofmem", "Out of memory");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
      // Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      // Read RLE-encoded data
      scanline = NULL;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            STBI_FREE(scanline);
            goto main_decode_loop; // yes, this makes no sense
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
         if (scanline == NULL) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               STBI_FREE(hdr_data);
               return stbi__errpf("outofmem", "Out of memory");
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  // Run
                  value = stbi__get8(s);
                  count -= 128;
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  // Dump
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         STBI_FREE(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   stbi__rewind( s );
   if (p == NULL)
      return 0;
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) {
      if (info.bpp == 24 && info.ma == 0xff000000)
         *comp = 3;
      else
         *comp = info.ma ? 4 : 3;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}

static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   (void) stbi__get32be(s);
   (void) stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)
//    Does not support 16-bit-per-channel

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))
      return 0;

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))
      return stbi__errpuc("too large", "PNM too large");

   out = (stbi_uc *) stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

   if (req_comp && req_comp != s->img_n) {
      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}

static int      stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}

static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
   }

   return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value

   if (maxv > 255)
      return stbi__err("max value > 255", "PPM image not 8-bit");
   else
      return 1;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #endif
   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

static int stbi__is_16_main(stbi__context *s)
{
   #ifndef STBI_NO_PNG
   if (stbi__png_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_is16(s))  return 1;
   #endif

   return 0;
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}

STBIDEF int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}

STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,SEEK_SET);
   return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}

STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}

#endif // STB_IMAGE_IMPLEMENTATION

/*
   revision history:
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
                         1-bit BMP
                         *_is_16_bit api
                         avoid warnings
      2.16  (2017-07-23) all functions have 16-bit variants;
                         STBI_NO_STDIO works again;
                         compilation fixes;
                         fix rounding in unpremultiply;
                         optimize vertical flip;
                         disable raw_len validation;
                         documentation fixes
      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
                         warning fixes; disable run-time SSE detection on gcc;
                         uniform handling of optional "return" values;
                         thread-safe initialization of zlib tables
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) allocate large structures on the stack
                         remove white matting for transparent PSD
                         fix reported channel count for PNG & BMP
                         re-enable SSE2 in non-gcc 64-bit
                         support RGB-formatted JPEG
                         read 16-bit PNGs (only as 8-bit)
      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
      2.09  (2016-01-16) allow comments in PNM files
                         16-bit-per-pixel TGA (not bit-per-component)
                         info() for TGA could break due to .hdr handling
                         info() for BMP to shares code instead of sloppy parse
                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
                         code cleanup
      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
      2.07  (2015-09-13) fix compiler warnings
                         partial animated GIF support
                         limited 16-bpc PSD support
                         #ifdef unused functions
                         bug with < 92 byte PIC,PNM,HDR,TGA
      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
      2.03  (2015-04-12) extra corruption checking (mmozeiko)
                         stbi_set_flip_vertically_on_load (nguillemot)
                         fix NEON support; fix mingw support
      2.02  (2015-01-19) fix incorrect assert, fix warning
      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
                         progressive JPEG (stb)
                         PGM/PPM support (Ken Miller)
                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
                         GIF bugfix -- seemingly never worked
                         STBI_NO_*, STBI_ONLY_*
      1.48  (2014-12-14) fix incorrectly-named assert()
      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
                         optimize PNG (ryg)
                         fix bug in interlaced PNG with user-specified channel count (stb)
      1.46  (2014-08-26)
              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
      1.45  (2014-08-16)
              fix MSVC-ARM internal compiler error by wrapping malloc
      1.44  (2014-08-07)
              various warning fixes from Ronny Chevalier
      1.43  (2014-07-15)
              fix MSVC-only compiler problem in code changed in 1.42
      1.42  (2014-07-09)
              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
              fixes to stbi__cleanup_jpeg path
              added STBI_ASSERT to avoid requiring assert.h
      1.41  (2014-06-25)
              fix search&replace from 1.36 that messed up comments/error messages
      1.40  (2014-06-22)
              fix gcc struct-initialization warning
      1.39  (2014-06-15)
              fix to TGA optimization when req_comp != number of components in TGA;
              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
              add support for BMP version 5 (more ignored fields)
      1.38  (2014-06-06)
              suppress MSVC warnings on integer casts truncating values
              fix accidental rename of 'skip' field of I/O
      1.37  (2014-06-04)
              remove duplicate typedef
      1.36  (2014-06-03)
              convert to header file single-file library
              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
      1.35  (2014-05-27)
              various warnings
              fix broken STBI_SIMD path
              fix bug where stbi_load_from_file no longer left file pointer in correct place
              fix broken non-easy path for 32-bit BMP (possibly never used)
              TGA optimization by Arseny Kapoulkine
      1.34  (unknown)
              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
      1.33  (2011-07-14)
              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
      1.32  (2011-07-13)
              support for "info" function for all supported filetypes (SpartanJ)
      1.31  (2011-06-20)
              a few more leak fixes, bug in PNG handling (SpartanJ)
      1.30  (2011-06-11)
              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
              removed deprecated format-specific test/load functions
              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
              fix inefficiency in decoding 32-bit BMP (David Woo)
      1.29  (2010-08-16)
              various warning fixes from Aurelien Pocheville
      1.28  (2010-08-01)
              fix bug in GIF palette transparency (SpartanJ)
      1.27  (2010-08-01)
              cast-to-stbi_uc to fix warnings
      1.26  (2010-07-24)
              fix bug in file buffering for PNG reported by SpartanJ
      1.25  (2010-07-17)
              refix trans_data warning (Won Chun)
      1.24  (2010-07-12)
              perf improvements reading from files on platforms with lock-heavy fgetc()
              minor perf improvements for jpeg
              deprecated type-specific functions so we'll get feedback if they're needed
              attempt to fix trans_data warning (Won Chun)
      1.23    fixed bug in iPhone support
      1.22  (2010-07-10)
              removed image *writing* support
              stbi_info support from Jetro Lauha
              GIF support from Jean-Marc Lienher
              iPhone PNG-extensions from James Brown
              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
      1.20    added support for Softimage PIC, by Tom Seddon
      1.19    bug in interlaced PNG corruption check (found by ryg)
      1.18  (2008-08-02)
              fix a threading bug (local mutable static)
      1.17    support interlaced PNG
      1.16    major bugfix - stbi__convert_format converted one too many pixels
      1.15    initialize some fields for thread safety
      1.14    fix threadsafe conversion bug
              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
      1.13    threadsafe
      1.12    const qualifiers in the API
      1.11    Support installable IDCT, colorspace conversion routines
      1.10    Fixes for 64-bit (don't use "unsigned long")
              optimized upsampling by Fabian "ryg" Giesen
      1.09    Fix format-conversion for PSD code (bad global variables!)
      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
      1.07    attempt to fix C++ warning/errors again
      1.06    attempt to fix C++ warning/errors again
      1.05    fix TGA loading to return correct *comp and use good luminance calc
      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
      1.02    support for (subset of) HDR files, float interface for preferred access to them
      1.01    fix bug: possible bug in handling right-side up bmps... not sure
              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
      1.00    interface to zlib that skips zlib header
      0.99    correct handling of alpha in palette
      0.98    TGA loader by lonesock; dynamically add loaders (untested)
      0.97    jpeg errors on too large a file; also catch another malloc failure
      0.96    fix detection of invalid v value - particleman@mollyrocket forum
      0.95    during header scan, seek to markers in case of padding
      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
      0.93    handle jpegtran output; verbose errors
      0.92    read 4,8,16,24,32-bit BMP files of several formats
      0.91    output 24-bit Windows 3.0 BMP files
      0.90    fix a few more warnings; bump version number to approach 1.0
      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
      0.60    fix compiling as c++
      0.59    fix warnings: merge Dave Moore's -Wall fixes
      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
      0.56    fix bug: zlib uncompressed mode len vs. nlen
      0.55    fix bug: restart_interval not initialized to 0
      0.54    allow NULL for 'int *comp'
      0.53    fix bug in png 3->4; speedup png decoding
      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
              on 'test' only check type, not whether we support this variant
      0.50  (2006-11-19)
              first released version
*/


/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`Modules/TinyOBJ/CMakeLists.txt`:

```txt

SET(_target ToonTinyOBJ)

DEFINE_MODULE(${_target} TINYOBJ)

```

`Modules/TinyOBJ/Private/TinyOBJMeshImporter.cpp`:

```cpp
#include <Toon/TinyOBJ/TinyOBJMeshImporter.hpp>
#include <Toon/Log.hpp>
#include <Toon/Benchmark.hpp>
#include <Toon/Util.hpp>
#include <Toon/TinyOBJ/TinyOBJPrimitiveData.hpp>

#define TINYOBJLOADER_IMPLEMENTATION
#include <tiny_obj_loader.h>

namespace Toon::TinyOBJ {

TOON_TINYOBJ_API
std::vector<std::unique_ptr<PrimitiveData>> TinyOBJMeshImporter::LoadFromFile(const std::string& filename, bool useAssetPath /*= true*/)
{
    ToonBenchmarkStart();

    std::vector<std::unique_ptr<PrimitiveData>> primitiveList;

    tinyobj::attrib_t attrib;
    std::vector<tinyobj::shape_t> shapeList;
    std::vector<tinyobj::material_t> materialList;

    std::string warn, err;
    bool result = false;

    if (useAssetPath) {
        const auto& assetPaths = GetAssetPathList();

        for (const auto& path : assetPaths) {
            std::string fullPath = path / "Models" / filename;
            ToonLogInfo("Loading from File: %s", fullPath);

            std::string dir = GetDirname(fullPath);

            warn = "";
            err = "";

            result = tinyobj::LoadObj(&attrib, &shapeList, &materialList, &warn, &err, fullPath.c_str(), dir.c_str());

            // If the error isn't 'Cannot open file', the .obj file is probably
            // broken, and we should fail
            if (!err.empty() && err.rfind("Cannot open file", 0) != 0) {
                break;
            }

            if (result) {
                break;
            }
        }
    }
    else {
        string dir = GetDirname(filename);
        result = tinyobj::LoadObj(&attrib, &shapeList, &materialList, &warn, &err, filename.c_str(), dir.c_str());
    }


    if (!warn.empty()) {
        ToonLogWarn("tinyobj: %s", warn);
    }

    if (!err.empty()) {
        ToonLogError("tinyobj: %s", err);
    }

    bool hasNormals = (!attrib.normals.empty());
    bool hasTexCoords = (!attrib.texcoords.empty());
    bool hasColors = (!attrib.colors.empty());

    for (auto& shape : shapeList) {
        TinyOBJPrimitiveData * primitiveData = new TinyOBJPrimitiveData();
        
        primitiveData->VertexList.resize(shape.mesh.indices.size());

        for (size_t i = 0; i < shape.mesh.indices.size(); ++i) {
            auto index = shape.mesh.indices[i];
            auto& vertex = primitiveData->VertexList[i];

            vertex.Position = {
                attrib.vertices[3 * index.vertex_index + 0],
                attrib.vertices[3 * index.vertex_index + 1],
                attrib.vertices[3 * index.vertex_index + 2],
                1.0f,
            };

            if (hasNormals) {
                vertex.Normal = {
                    attrib.normals[3 * index.normal_index + 0],
                    attrib.normals[3 * index.normal_index + 1],
                    attrib.normals[3 * index.normal_index + 2],
                    1.0f,
                };
            }
            
            if (hasColors) {
                vertex.Color = {
                    attrib.colors[3 * index.vertex_index + 0],
                    attrib.colors[3 * index.vertex_index + 1],
                    attrib.colors[3 * index.vertex_index + 2],
                    1.0f,
                };
            }
            
            if (hasTexCoords) {
                vertex.TexCoord1 = {
                    attrib.texcoords[2 * index.texcoord_index + 0],
                    attrib.texcoords[2 * index.texcoord_index + 1],
                };
            }
        }

        primitiveData->CalculateTangents();
        primitiveList.push_back(std::unique_ptr<PrimitiveData>(primitiveData));
    }

    ToonBenchmarkEnd();
    return primitiveList;
}

} // namespace Toon::TinyOBJ
```

`Modules/TinyOBJ/Private/TinyOBJModule.cpp`:

```cpp
#include <Toon/Module.hpp>
#include <Toon/TinyOBJ/TinyOBJMeshImporter.hpp>

namespace Toon::TinyOBJ {

bool ModuleInit() {
    AddMeshImporter("TinyOBJ", std::unique_ptr<TinyOBJMeshImporter>(new TinyOBJMeshImporter));
    
    return true;
}

void ModuleTerm() {
    RemoveMeshImporter("TinyOBJ");
}

TOON_MODULE {
    .Name       = "TinyOBJ",
    .Initialize = ModuleInit,
    .Terminate  = ModuleTerm,
};

} // namespace Toon::TinyOBJ
```

`Modules/TinyOBJ/Private/tiny_obj_loader.h`:

```h
/*
The MIT License (MIT)

Copyright (c) 2012-2018 Syoyo Fujita and many contributors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

//
// version 2.0.0 : Add new object oriented API. 1.x API is still provided.
//                 * Support line primitive.
//                 * Support points primitive.
//                 * Support multiple search path for .mtl(v1 API).
//                 * Support vertex weight `vw`(as an tinyobj extension)
//                 * Support escaped whitespece in mtllib
// version 1.4.0 : Modifed ParseTextureNameAndOption API
// version 1.3.1 : Make ParseTextureNameAndOption API public
// version 1.3.0 : Separate warning and error message(breaking API of LoadObj)
// version 1.2.3 : Added color space extension('-colorspace') to tex opts.
// version 1.2.2 : Parse multiple group names.
// version 1.2.1 : Added initial support for line('l') primitive(PR #178)
// version 1.2.0 : Hardened implementation(#175)
// version 1.1.1 : Support smoothing groups(#162)
// version 1.1.0 : Support parsing vertex color(#144)
// version 1.0.8 : Fix parsing `g` tag just after `usemtl`(#138)
// version 1.0.7 : Support multiple tex options(#126)
// version 1.0.6 : Add TINYOBJLOADER_USE_DOUBLE option(#124)
// version 1.0.5 : Ignore `Tr` when `d` exists in MTL(#43)
// version 1.0.4 : Support multiple filenames for 'mtllib'(#112)
// version 1.0.3 : Support parsing texture options(#85)
// version 1.0.2 : Improve parsing speed by about a factor of 2 for large
// files(#105)
// version 1.0.1 : Fixes a shape is lost if obj ends with a 'usemtl'(#104)
// version 1.0.0 : Change data structure. Change license from BSD to MIT.
//

//
// Use this in *one* .cc
//   #define TINYOBJLOADER_IMPLEMENTATION
//   #include "tiny_obj_loader.h"
//

#ifndef TINY_OBJ_LOADER_H_
#define TINY_OBJ_LOADER_H_

#include <map>
#include <Toon/String.hpp>
#include <vector>

namespace tinyobj {

// TODO(syoyo): Better C++11 detection for older compiler
#if __cplusplus > 199711L
#define TINYOBJ_OVERRIDE override
#else
#define TINYOBJ_OVERRIDE
#endif

#ifdef __clang__
#pragma clang diagnostic push
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif

#pragma clang diagnostic ignored "-Wpadded"

#endif

// https://en.wikipedia.org/wiki/Wavefront_.obj_file says ...
//
//  -blendu on | off                       # set horizontal texture blending
//  (default on)
//  -blendv on | off                       # set vertical texture blending
//  (default on)
//  -boost real_value                      # boost mip-map sharpness
//  -mm base_value gain_value              # modify texture map values (default
//  0 1)
//                                         #     base_value = brightness,
//                                         gain_value = contrast
//  -o u [v [w]]                           # Origin offset             (default
//  0 0 0)
//  -s u [v [w]]                           # Scale                     (default
//  1 1 1)
//  -t u [v [w]]                           # Turbulence                (default
//  0 0 0)
//  -texres resolution                     # texture resolution to create
//  -clamp on | off                        # only render texels in the clamped
//  0-1 range (default off)
//                                         #   When unclamped, textures are
//                                         repeated across a surface,
//                                         #   when clamped, only texels which
//                                         fall within the 0-1
//                                         #   range are rendered.
//  -bm mult_value                         # bump multiplier (for bump maps
//  only)
//
//  -imfchan r | g | b | m | l | z         # specifies which channel of the file
//  is used to
//                                         # create a scalar or bump texture.
//                                         r:red, g:green,
//                                         # b:blue, m:matte, l:luminance,
//                                         z:z-depth..
//                                         # (the default for bump is 'l' and
//                                         for decal is 'm')
//  bump -imfchan r bumpmap.tga            # says to use the red channel of
//  bumpmap.tga as the bumpmap
//
// For reflection maps...
//
//   -type sphere                           # specifies a sphere for a "refl"
//   reflection map
//   -type cube_top    | cube_bottom |      # when using a cube map, the texture
//   file for each
//         cube_front  | cube_back   |      # side of the cube is specified
//         separately
//         cube_left   | cube_right
//
// TinyObjLoader extension.
//
//   -colorspace SPACE                      # Color space of the texture. e.g.
//   'sRGB` or 'linear'
//

#ifdef TINYOBJLOADER_USE_DOUBLE
//#pragma message "using double"
typedef double real_t;
#else
//#pragma message "using float"
typedef float real_t;
#endif

typedef enum {
  TEXTURE_TYPE_NONE,  // default
  TEXTURE_TYPE_SPHERE,
  TEXTURE_TYPE_CUBE_TOP,
  TEXTURE_TYPE_CUBE_BOTTOM,
  TEXTURE_TYPE_CUBE_FRONT,
  TEXTURE_TYPE_CUBE_BACK,
  TEXTURE_TYPE_CUBE_LEFT,
  TEXTURE_TYPE_CUBE_RIGHT
} texture_type_t;

struct texture_option_t {
  texture_type_t type;      // -type (default TEXTURE_TYPE_NONE)
  real_t sharpness;         // -boost (default 1.0?)
  real_t brightness;        // base_value in -mm option (default 0)
  real_t contrast;          // gain_value in -mm option (default 1)
  real_t origin_offset[3];  // -o u [v [w]] (default 0 0 0)
  real_t scale[3];          // -s u [v [w]] (default 1 1 1)
  real_t turbulence[3];     // -t u [v [w]] (default 0 0 0)
  int texture_resolution;   // -texres resolution (No default value in the spec.
                            // We'll use -1)
  bool clamp;               // -clamp (default false)
  char imfchan;  // -imfchan (the default for bump is 'l' and for decal is 'm')
  bool blendu;   // -blendu (default on)
  bool blendv;   // -blendv (default on)
  real_t bump_multiplier;  // -bm (for bump maps only, default 1.0)

  // extension
  std::string colorspace;  // Explicitly specify color space of stored texel
                           // value. Usually `sRGB` or `linear` (default empty).
};

struct material_t {
  std::string name;

  real_t ambient[3];
  real_t diffuse[3];
  real_t specular[3];
  real_t transmittance[3];
  real_t emission[3];
  real_t shininess;
  real_t ior;       // index of refraction
  real_t dissolve;  // 1 == opaque; 0 == fully transparent
  // illumination model (see http://www.fileformat.info/format/material/)
  int illum;

  int dummy;  // Suppress padding warning.

  std::string ambient_texname;             // map_Ka
  std::string diffuse_texname;             // map_Kd
  std::string specular_texname;            // map_Ks
  std::string specular_highlight_texname;  // map_Ns
  std::string bump_texname;                // map_bump, map_Bump, bump
  std::string displacement_texname;        // disp
  std::string alpha_texname;               // map_d
  std::string reflection_texname;          // refl

  texture_option_t ambient_texopt;
  texture_option_t diffuse_texopt;
  texture_option_t specular_texopt;
  texture_option_t specular_highlight_texopt;
  texture_option_t bump_texopt;
  texture_option_t displacement_texopt;
  texture_option_t alpha_texopt;
  texture_option_t reflection_texopt;

  // PBR extension
  // http://exocortex.com/blog/extending_wavefront_mtl_to_support_pbr
  real_t roughness;            // [0, 1] default 0
  real_t metallic;             // [0, 1] default 0
  real_t sheen;                // [0, 1] default 0
  real_t clearcoat_thickness;  // [0, 1] default 0
  real_t clearcoat_roughness;  // [0, 1] default 0
  real_t anisotropy;           // aniso. [0, 1] default 0
  real_t anisotropy_rotation;  // anisor. [0, 1] default 0
  real_t pad0;
  std::string roughness_texname;  // map_Pr
  std::string metallic_texname;   // map_Pm
  std::string sheen_texname;      // map_Ps
  std::string emissive_texname;   // map_Ke
  std::string normal_texname;     // norm. For normal mapping.

  texture_option_t roughness_texopt;
  texture_option_t metallic_texopt;
  texture_option_t sheen_texopt;
  texture_option_t emissive_texopt;
  texture_option_t normal_texopt;

  int pad2;

  std::map<std::string, std::string> unknown_parameter;

#ifdef TINY_OBJ_LOADER_PYTHON_BINDING
  // For pybind11
  std::array<double, 3> GetDiffuse() {
    std::array<double, 3> values;
    values[0] = double(diffuse[0]);
    values[1] = double(diffuse[1]);
    values[2] = double(diffuse[2]);

    return values;
  }

  std::array<double, 3> GetSpecular() {
    std::array<double, 3> values;
    values[0] = double(specular[0]);
    values[1] = double(specular[1]);
    values[2] = double(specular[2]);

    return values;
  }

  std::array<double, 3> GetTransmittance() {
    std::array<double, 3> values;
    values[0] = double(transmittance[0]);
    values[1] = double(transmittance[1]);
    values[2] = double(transmittance[2]);

    return values;
  }

  std::array<double, 3> GetEmission() {
    std::array<double, 3> values;
    values[0] = double(emission[0]);
    values[1] = double(emission[1]);
    values[2] = double(emission[2]);

    return values;
  }

  std::array<double, 3> GetAmbient() {
    std::array<double, 3> values;
    values[0] = double(ambient[0]);
    values[1] = double(ambient[1]);
    values[2] = double(ambient[2]);

    return values;
  }

  void SetDiffuse(std::array<double, 3> &a) {
    diffuse[0] = real_t(a[0]);
    diffuse[1] = real_t(a[1]);
    diffuse[2] = real_t(a[2]);
  }

  void SetAmbient(std::array<double, 3> &a) {
    ambient[0] = real_t(a[0]);
    ambient[1] = real_t(a[1]);
    ambient[2] = real_t(a[2]);
  }

  void SetSpecular(std::array<double, 3> &a) {
    specular[0] = real_t(a[0]);
    specular[1] = real_t(a[1]);
    specular[2] = real_t(a[2]);
  }

  void SetTransmittance(std::array<double, 3> &a) {
    transmittance[0] = real_t(a[0]);
    transmittance[1] = real_t(a[1]);
    transmittance[2] = real_t(a[2]);
  }

  std::string GetCustomParameter(const std::string &key) {
    std::map<std::string, std::string>::const_iterator it =
        unknown_parameter.find(key);

    if (it != unknown_parameter.end()) {
      return it->second;
    }
    return std::string();
  }

#endif
};

struct tag_t {
  std::string name;

  std::vector<int> intValues;
  std::vector<real_t> floatValues;
  std::vector<std::string> stringValues;
};

struct joint_and_weight_t {
  int joint_id;
  real_t weight;
};

struct skin_weight_t {
  int vertex_id;  // Corresponding vertex index in `attrib_t::vertices`.
                  // Compared to `index_t`, this index must be positive and
                  // start with 0(does not allow relative indexing)
  std::vector<joint_and_weight_t> weightValues;
};

// Index struct to support different indices for vtx/normal/texcoord.
// -1 means not used.
struct index_t {
  int vertex_index;
  int normal_index;
  int texcoord_index;
};

struct mesh_t {
  std::vector<index_t> indices;
  std::vector<unsigned char>
      num_face_vertices;          // The number of vertices per
                                  // face. 3 = triangle, 4 = quad,
                                  // ... Up to 255 vertices per face.
  std::vector<int> material_ids;  // per-face material ID
  std::vector<unsigned int> smoothing_group_ids;  // per-face smoothing group
                                                  // ID(0 = off. positive value
                                                  // = group id)
  std::vector<tag_t> tags;                        // SubD tag
};

// struct path_t {
//  std::vector<int> indices;  // pairs of indices for lines
//};

struct lines_t {
  // Linear flattened indices.
  std::vector<index_t> indices;        // indices for vertices(poly lines)
  std::vector<int> num_line_vertices;  // The number of vertices per line.
};

struct points_t {
  std::vector<index_t> indices;  // indices for points
};

struct shape_t {
  std::string name;
  mesh_t mesh;
  lines_t lines;
  points_t points;
};

// Vertex attributes
struct attrib_t {
  std::vector<real_t> vertices;  // 'v'(xyz)

  // For backward compatibility, we store vertex weight in separate array.
  std::vector<real_t> vertex_weights;  // 'v'(w)
  std::vector<real_t> normals;         // 'vn'
  std::vector<real_t> texcoords;       // 'vt'(uv)

  // For backward compatibility, we store texture coordinate 'w' in separate
  // array.
  std::vector<real_t> texcoord_ws;  // 'vt'(w)
  std::vector<real_t> colors;       // extension: vertex colors

  //
  // TinyObj extension.
  //

  // NOTE(syoyo): array index is based on the appearance order.
  // To get a corresponding skin weight for a specific vertex id `vid`,
  // Need to reconstruct a look up table: `skin_weight_t::vertex_id` == `vid`
  // (e.g. using std::map, std::unordered_map)
  std::vector<skin_weight_t> skin_weights;

  attrib_t() {}

  //
  // For pybind11
  //
  const std::vector<real_t> &GetVertices() const { return vertices; }

  const std::vector<real_t> &GetVertexWeights() const { return vertex_weights; }
};

struct callback_t {
  // W is optional and set to 1 if there is no `w` item in `v` line
  void (*vertex_cb)(void *user_data, real_t x, real_t y, real_t z, real_t w);
  void (*normal_cb)(void *user_data, real_t x, real_t y, real_t z);

  // y and z are optional and set to 0 if there is no `y` and/or `z` item(s) in
  // `vt` line.
  void (*texcoord_cb)(void *user_data, real_t x, real_t y, real_t z);

  // called per 'f' line. num_indices is the number of face indices(e.g. 3 for
  // triangle, 4 for quad)
  // 0 will be passed for undefined index in index_t members.
  void (*index_cb)(void *user_data, index_t *indices, int num_indices);
  // `name` material name, `material_id` = the array index of material_t[]. -1
  // if
  // a material not found in .mtl
  void (*usemtl_cb)(void *user_data, const char *name, int material_id);
  // `materials` = parsed material data.
  void (*mtllib_cb)(void *user_data, const material_t *materials,
                    int num_materials);
  // There may be multiple group names
  void (*group_cb)(void *user_data, const char **names, int num_names);
  void (*object_cb)(void *user_data, const char *name);

  callback_t()
      : vertex_cb(NULL),
        normal_cb(NULL),
        texcoord_cb(NULL),
        index_cb(NULL),
        usemtl_cb(NULL),
        mtllib_cb(NULL),
        group_cb(NULL),
        object_cb(NULL) {}
};

class MaterialReader {
 public:
  MaterialReader() {}
  virtual ~MaterialReader();

  virtual bool operator()(const std::string &matId,
                          std::vector<material_t> *materials,
                          std::map<std::string, int> *matMap, std::string *warn,
                          std::string *err) = 0;
};

///
/// Read .mtl from a file.
///
class MaterialFileReader : public MaterialReader {
 public:
  // Path could contain separator(';' in Windows, ':' in Posix)
  explicit MaterialFileReader(const std::string &mtl_basedir)
      : m_mtlBaseDir(mtl_basedir) {}
  virtual ~MaterialFileReader() TINYOBJ_OVERRIDE {}
  virtual bool operator()(const std::string &matId,
                          std::vector<material_t> *materials,
                          std::map<std::string, int> *matMap, std::string *warn,
                          std::string *err) TINYOBJ_OVERRIDE;

 private:
  std::string m_mtlBaseDir;
};

///
/// Read .mtl from a stream.
///
class MaterialStreamReader : public MaterialReader {
 public:
  explicit MaterialStreamReader(std::istream &inStream)
      : m_inStream(inStream) {}
  virtual ~MaterialStreamReader() TINYOBJ_OVERRIDE {}
  virtual bool operator()(const std::string &matId,
                          std::vector<material_t> *materials,
                          std::map<std::string, int> *matMap, std::string *warn,
                          std::string *err) TINYOBJ_OVERRIDE;

 private:
  std::istream &m_inStream;
};

// v2 API
struct ObjReaderConfig {
  bool triangulate;  // triangulate polygon?

  /// Parse vertex color.
  /// If vertex color is not present, its filled with default value.
  /// false = no vertex color
  /// This will increase memory of parsed .obj
  bool vertex_color;

  ///
  /// Search path to .mtl file.
  /// Default = "" = search from the same directory of .obj file.
  /// Valid only when loading .obj from a file.
  ///
  std::string mtl_search_path;

  ObjReaderConfig() : triangulate(true), vertex_color(true) {}
};

///
/// Wavefront .obj reader class(v2 API)
///
class ObjReader {
 public:
  ObjReader() : valid_(false) {}
  ~ObjReader() {}

  ///
  /// Load .obj and .mtl from a file.
  ///
  /// @param[in] filename wavefront .obj filename
  /// @param[in] config Reader configuration
  ///
  bool ParseFromFile(const std::string &filename,
                     const ObjReaderConfig &config = ObjReaderConfig());

  ///
  /// Parse .obj from a text string.
  /// Need to supply .mtl text string by `mtl_text`.
  /// This function ignores `mtllib` line in .obj text.
  ///
  /// @param[in] obj_text wavefront .obj filename
  /// @param[in] mtl_text wavefront .mtl filename
  /// @param[in] config Reader configuration
  ///
  bool ParseFromString(const std::string &obj_text, const std::string &mtl_text,
                       const ObjReaderConfig &config = ObjReaderConfig());

  ///
  /// .obj was loaded or parsed correctly.
  ///
  bool Valid() const { return valid_; }

  const attrib_t &GetAttrib() const { return attrib_; }

  const std::vector<shape_t> &GetShapes() const { return shapes_; }

  const std::vector<material_t> &GetMaterials() const { return materials_; }

  ///
  /// Warning message(may be filled after `Load` or `Parse`)
  ///
  const std::string &Warning() const { return warning_; }

  ///
  /// Error message(filled when `Load` or `Parse` failed)
  ///
  const std::string &Error() const { return error_; }

 private:
  bool valid_;

  attrib_t attrib_;
  std::vector<shape_t> shapes_;
  std::vector<material_t> materials_;

  std::string warning_;
  std::string error_;
};

/// ==>>========= Legacy v1 API =============================================

/// Loads .obj from a file.
/// 'attrib', 'shapes' and 'materials' will be filled with parsed shape data
/// 'shapes' will be filled with parsed shape data
/// Returns true when loading .obj become success.
/// Returns warning message into `warn`, and error message into `err`
/// 'mtl_basedir' is optional, and used for base directory for .mtl file.
/// In default(`NULL'), .mtl file is searched from an application's working
/// directory.
/// 'triangulate' is optional, and used whether triangulate polygon face in .obj
/// or not.
/// Option 'default_vcols_fallback' specifies whether vertex colors should
/// always be defined, even if no colors are given (fallback to white).
bool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,
             std::vector<material_t> *materials, std::string *warn,
             std::string *err, const char *filename,
             const char *mtl_basedir = NULL, bool triangulate = true,
             bool default_vcols_fallback = true);

/// Loads .obj from a file with custom user callback.
/// .mtl is loaded as usual and parsed material_t data will be passed to
/// `callback.mtllib_cb`.
/// Returns true when loading .obj/.mtl become success.
/// Returns warning message into `warn`, and error message into `err`
/// See `examples/callback_api/` for how to use this function.
bool LoadObjWithCallback(std::istream &inStream, const callback_t &callback,
                         void *user_data = NULL,
                         MaterialReader *readMatFn = NULL,
                         std::string *warn = NULL, std::string *err = NULL);

/// Loads object from a std::istream, uses `readMatFn` to retrieve
/// std::istream for materials.
/// Returns true when loading .obj become success.
/// Returns warning and error message into `err`
bool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,
             std::vector<material_t> *materials, std::string *warn,
             std::string *err, std::istream *inStream,
             MaterialReader *readMatFn = NULL, bool triangulate = true,
             bool default_vcols_fallback = true);

/// Loads materials into std::map
void LoadMtl(std::map<std::string, int> *material_map,
             std::vector<material_t> *materials, std::istream *inStream,
             std::string *warning, std::string *err);

///
/// Parse texture name and texture option for custom texture parameter through
/// material::unknown_parameter
///
/// @param[out] texname Parsed texture name
/// @param[out] texopt Parsed texopt
/// @param[in] linebuf Input string
///
bool ParseTextureNameAndOption(std::string *texname, texture_option_t *texopt,
                               const char *linebuf);

/// =<<========== Legacy v1 API =============================================

}  // namespace tinyobj

#endif  // TINY_OBJ_LOADER_H_

#ifdef TINYOBJLOADER_IMPLEMENTATION
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstddef>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <limits>
#include <sstream>
#include <utility>

namespace tinyobj {

MaterialReader::~MaterialReader() {}

struct vertex_index_t {
  int v_idx, vt_idx, vn_idx;
  vertex_index_t() : v_idx(-1), vt_idx(-1), vn_idx(-1) {}
  explicit vertex_index_t(int idx) : v_idx(idx), vt_idx(idx), vn_idx(idx) {}
  vertex_index_t(int vidx, int vtidx, int vnidx)
      : v_idx(vidx), vt_idx(vtidx), vn_idx(vnidx) {}
};

// Internal data structure for face representation
// index + smoothing group.
struct face_t {
  unsigned int
      smoothing_group_id;  // smoothing group id. 0 = smoothing groupd is off.
  int pad_;
  std::vector<vertex_index_t> vertex_indices;  // face vertex indices.

  face_t() : smoothing_group_id(0), pad_(0) {}
};

// Internal data structure for line representation
struct __line_t {
  // l v1/vt1 v2/vt2 ...
  // In the specification, line primitrive does not have normal index, but
  // TinyObjLoader allow it
  std::vector<vertex_index_t> vertex_indices;
};

// Internal data structure for points representation
struct __points_t {
  // p v1 v2 ...
  // In the specification, point primitrive does not have normal index and
  // texture coord index, but TinyObjLoader allow it.
  std::vector<vertex_index_t> vertex_indices;
};

struct tag_sizes {
  tag_sizes() : num_ints(0), num_reals(0), num_strings(0) {}
  int num_ints;
  int num_reals;
  int num_strings;
};

struct obj_shape {
  std::vector<real_t> v;
  std::vector<real_t> vn;
  std::vector<real_t> vt;
};

//
// Manages group of primitives(face, line, points, ...)
struct PrimGroup {
  std::vector<face_t> faceGroup;
  std::vector<__line_t> lineGroup;
  std::vector<__points_t> pointsGroup;

  void clear() {
    faceGroup.clear();
    lineGroup.clear();
    pointsGroup.clear();
  }

  bool IsEmpty() const {
    return faceGroup.empty() && lineGroup.empty() && pointsGroup.empty();
  }

  // TODO(syoyo): bspline, surface, ...
};

// See
// http://stackoverflow.com/questions/6089231/getting-std-ifstream-to-handle-lf-cr-and-crlf
static std::istream &safeGetline(std::istream &is, std::string &t) {
  t.clear();

  // The characters in the stream are read one-by-one using a std::streambuf.
  // That is faster than reading them one-by-one using the std::istream.
  // Code that uses streambuf this way must be guarded by a sentry object.
  // The sentry object performs various tasks,
  // such as thread synchronization and updating the stream state.

  std::istream::sentry se(is, true);
  std::streambuf *sb = is.rdbuf();

  if (se) {
    for (;;) {
      int c = sb->sbumpc();
      switch (c) {
        case '\n':
          return is;
        case '\r':
          if (sb->sgetc() == '\n') sb->sbumpc();
          return is;
        case EOF:
          // Also handle the case when the last line has no line ending
          if (t.empty()) is.setstate(std::ios::eofbit);
          return is;
        default:
          t += static_cast<char>(c);
      }
    }
  }

  return is;
}

#define IS_SPACE(x) (((x) == ' ') || ((x) == '\t'))
#define IS_DIGIT(x) \
  (static_cast<unsigned int>((x) - '0') < static_cast<unsigned int>(10))
#define IS_NEW_LINE(x) (((x) == '\r') || ((x) == '\n') || ((x) == '\0'))

// Make index zero-base, and also support relative index.
static inline bool fixIndex(int idx, int n, int *ret) {
  if (!ret) {
    return false;
  }

  if (idx > 0) {
    (*ret) = idx - 1;
    return true;
  }

  if (idx == 0) {
    // zero is not allowed according to the spec.
    return false;
  }

  if (idx < 0) {
    (*ret) = n + idx;  // negative value = relative
    return true;
  }

  return false;  // never reach here.
}

static inline std::string parseString(const char **token) {
  std::string s;
  (*token) += strspn((*token), " \t");
  size_t e = strcspn((*token), " \t\r");
  s = std::string((*token), &(*token)[e]);
  (*token) += e;
  return s;
}

static inline int parseInt(const char **token) {
  (*token) += strspn((*token), " \t");
  int i = atoi((*token));
  (*token) += strcspn((*token), " \t\r");
  return i;
}

// Tries to parse a floating point number located at s.
//
// s_end should be a location in the string where reading should absolutely
// stop. For example at the end of the string, to prevent buffer overflows.
//
// Parses the following EBNF grammar:
//   sign    = "+" | "-" ;
//   END     = ? anything not in digit ?
//   digit   = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
//   integer = [sign] , digit , {digit} ;
//   decimal = integer , ["." , integer] ;
//   float   = ( decimal , END ) | ( decimal , ("E" | "e") , integer , END ) ;
//
//  Valid strings are for example:
//   -0  +3.1417e+2  -0.0E-3  1.0324  -1.41   11e2
//
// If the parsing is a success, result is set to the parsed value and true
// is returned.
//
// The function is greedy and will parse until any of the following happens:
//  - a non-conforming character is encountered.
//  - s_end is reached.
//
// The following situations triggers a failure:
//  - s >= s_end.
//  - parse failure.
//
static bool tryParseDouble(const char *s, const char *s_end, double *result) {
  if (s >= s_end) {
    return false;
  }

  double mantissa = 0.0;
  // This exponent is base 2 rather than 10.
  // However the exponent we parse is supposed to be one of ten,
  // thus we must take care to convert the exponent/and or the
  // mantissa to a * 2^E, where a is the mantissa and E is the
  // exponent.
  // To get the final double we will use ldexp, it requires the
  // exponent to be in base 2.
  int exponent = 0;

  // NOTE: THESE MUST BE DECLARED HERE SINCE WE ARE NOT ALLOWED
  // TO JUMP OVER DEFINITIONS.
  char sign = '+';
  char exp_sign = '+';
  char const *curr = s;

  // How many characters were read in a loop.
  int read = 0;
  // Tells whether a loop terminated due to reaching s_end.
  bool end_not_reached = false;
  bool leading_decimal_dots = false;

  /*
          BEGIN PARSING.
  */

  // Find out what sign we've got.
  if (*curr == '+' || *curr == '-') {
    sign = *curr;
    curr++;
    if ((curr != s_end) && (*curr == '.')) {
      // accept. Somethig like `.7e+2`, `-.5234`
      leading_decimal_dots = true;
    }
  } else if (IS_DIGIT(*curr)) { /* Pass through. */
  } else if (*curr == '.') {
    // accept. Somethig like `.7e+2`, `-.5234`
    leading_decimal_dots = true;
  } else {
    goto fail;
  }

  // Read the integer part.
  end_not_reached = (curr != s_end);
  if (!leading_decimal_dots) {
    while (end_not_reached && IS_DIGIT(*curr)) {
      mantissa *= 10;
      mantissa += static_cast<int>(*curr - 0x30);
      curr++;
      read++;
      end_not_reached = (curr != s_end);
    }

    // We must make sure we actually got something.
    if (read == 0) goto fail;
  }

  // We allow numbers of form "#", "###" etc.
  if (!end_not_reached) goto assemble;

  // Read the decimal part.
  if (*curr == '.') {
    curr++;
    read = 1;
    end_not_reached = (curr != s_end);
    while (end_not_reached && IS_DIGIT(*curr)) {
      static const double pow_lut[] = {
          1.0, 0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001, 0.0000001,
      };
      const int lut_entries = sizeof pow_lut / sizeof pow_lut[0];

      // NOTE: Don't use powf here, it will absolutely murder precision.
      mantissa += static_cast<int>(*curr - 0x30) *
                  (read < lut_entries ? pow_lut[read] : std::pow(10.0, -read));
      read++;
      curr++;
      end_not_reached = (curr != s_end);
    }
  } else if (*curr == 'e' || *curr == 'E') {
  } else {
    goto assemble;
  }

  if (!end_not_reached) goto assemble;

  // Read the exponent part.
  if (*curr == 'e' || *curr == 'E') {
    curr++;
    // Figure out if a sign is present and if it is.
    end_not_reached = (curr != s_end);
    if (end_not_reached && (*curr == '+' || *curr == '-')) {
      exp_sign = *curr;
      curr++;
    } else if (IS_DIGIT(*curr)) { /* Pass through. */
    } else {
      // Empty E is not allowed.
      goto fail;
    }

    read = 0;
    end_not_reached = (curr != s_end);
    while (end_not_reached && IS_DIGIT(*curr)) {
      exponent *= 10;
      exponent += static_cast<int>(*curr - 0x30);
      curr++;
      read++;
      end_not_reached = (curr != s_end);
    }
    exponent *= (exp_sign == '+' ? 1 : -1);
    if (read == 0) goto fail;
  }

assemble:
  *result = (sign == '+' ? 1 : -1) *
            (exponent ? std::ldexp(mantissa * std::pow(5.0, exponent), exponent)
                      : mantissa);
  return true;
fail:
  return false;
}

static inline real_t parseReal(const char **token, double default_value = 0.0) {
  (*token) += strspn((*token), " \t");
  const char *end = (*token) + strcspn((*token), " \t\r");
  double val = default_value;
  tryParseDouble((*token), end, &val);
  real_t f = static_cast<real_t>(val);
  (*token) = end;
  return f;
}

static inline bool parseReal(const char **token, real_t *out) {
  (*token) += strspn((*token), " \t");
  const char *end = (*token) + strcspn((*token), " \t\r");
  double val;
  bool ret = tryParseDouble((*token), end, &val);
  if (ret) {
    real_t f = static_cast<real_t>(val);
    (*out) = f;
  }
  (*token) = end;
  return ret;
}

static inline void parseReal2(real_t *x, real_t *y, const char **token,
                              const double default_x = 0.0,
                              const double default_y = 0.0) {
  (*x) = parseReal(token, default_x);
  (*y) = parseReal(token, default_y);
}

static inline void parseReal3(real_t *x, real_t *y, real_t *z,
                              const char **token, const double default_x = 0.0,
                              const double default_y = 0.0,
                              const double default_z = 0.0) {
  (*x) = parseReal(token, default_x);
  (*y) = parseReal(token, default_y);
  (*z) = parseReal(token, default_z);
}

static inline void parseV(real_t *x, real_t *y, real_t *z, real_t *w,
                          const char **token, const double default_x = 0.0,
                          const double default_y = 0.0,
                          const double default_z = 0.0,
                          const double default_w = 1.0) {
  (*x) = parseReal(token, default_x);
  (*y) = parseReal(token, default_y);
  (*z) = parseReal(token, default_z);
  (*w) = parseReal(token, default_w);
}

// Extension: parse vertex with colors(6 items)
static inline bool parseVertexWithColor(real_t *x, real_t *y, real_t *z,
                                        real_t *r, real_t *g, real_t *b,
                                        const char **token,
                                        const double default_x = 0.0,
                                        const double default_y = 0.0,
                                        const double default_z = 0.0) {
  (*x) = parseReal(token, default_x);
  (*y) = parseReal(token, default_y);
  (*z) = parseReal(token, default_z);

  const bool found_color =
      parseReal(token, r) && parseReal(token, g) && parseReal(token, b);

  if (!found_color) {
    (*r) = (*g) = (*b) = 1.0;
  }

  return found_color;
}

static inline bool parseOnOff(const char **token, bool default_value = true) {
  (*token) += strspn((*token), " \t");
  const char *end = (*token) + strcspn((*token), " \t\r");

  bool ret = default_value;
  if ((0 == strncmp((*token), "on", 2))) {
    ret = true;
  } else if ((0 == strncmp((*token), "off", 3))) {
    ret = false;
  }

  (*token) = end;
  return ret;
}

static inline texture_type_t parseTextureType(
    const char **token, texture_type_t default_value = TEXTURE_TYPE_NONE) {
  (*token) += strspn((*token), " \t");
  const char *end = (*token) + strcspn((*token), " \t\r");
  texture_type_t ty = default_value;

  if ((0 == strncmp((*token), "cube_top", strlen("cube_top")))) {
    ty = TEXTURE_TYPE_CUBE_TOP;
  } else if ((0 == strncmp((*token), "cube_bottom", strlen("cube_bottom")))) {
    ty = TEXTURE_TYPE_CUBE_BOTTOM;
  } else if ((0 == strncmp((*token), "cube_left", strlen("cube_left")))) {
    ty = TEXTURE_TYPE_CUBE_LEFT;
  } else if ((0 == strncmp((*token), "cube_right", strlen("cube_right")))) {
    ty = TEXTURE_TYPE_CUBE_RIGHT;
  } else if ((0 == strncmp((*token), "cube_front", strlen("cube_front")))) {
    ty = TEXTURE_TYPE_CUBE_FRONT;
  } else if ((0 == strncmp((*token), "cube_back", strlen("cube_back")))) {
    ty = TEXTURE_TYPE_CUBE_BACK;
  } else if ((0 == strncmp((*token), "sphere", strlen("sphere")))) {
    ty = TEXTURE_TYPE_SPHERE;
  }

  (*token) = end;
  return ty;
}

static tag_sizes parseTagTriple(const char **token) {
  tag_sizes ts;

  (*token) += strspn((*token), " \t");
  ts.num_ints = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    return ts;
  }

  (*token)++;  // Skip '/'

  (*token) += strspn((*token), " \t");
  ts.num_reals = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    return ts;
  }
  (*token)++;  // Skip '/'

  ts.num_strings = parseInt(token);

  return ts;
}

// Parse triples with index offsets: i, i/j/k, i//k, i/j
static bool parseTriple(const char **token, int vsize, int vnsize, int vtsize,
                        vertex_index_t *ret) {
  if (!ret) {
    return false;
  }

  vertex_index_t vi(-1);

  if (!fixIndex(atoi((*token)), vsize, &(vi.v_idx))) {
    return false;
  }

  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    (*ret) = vi;
    return true;
  }
  (*token)++;

  // i//k
  if ((*token)[0] == '/') {
    (*token)++;
    if (!fixIndex(atoi((*token)), vnsize, &(vi.vn_idx))) {
      return false;
    }
    (*token) += strcspn((*token), "/ \t\r");
    (*ret) = vi;
    return true;
  }

  // i/j/k or i/j
  if (!fixIndex(atoi((*token)), vtsize, &(vi.vt_idx))) {
    return false;
  }

  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    (*ret) = vi;
    return true;
  }

  // i/j/k
  (*token)++;  // skip '/'
  if (!fixIndex(atoi((*token)), vnsize, &(vi.vn_idx))) {
    return false;
  }
  (*token) += strcspn((*token), "/ \t\r");

  (*ret) = vi;

  return true;
}

// Parse raw triples: i, i/j/k, i//k, i/j
static vertex_index_t parseRawTriple(const char **token) {
  vertex_index_t vi(static_cast<int>(0));  // 0 is an invalid index in OBJ

  vi.v_idx = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    return vi;
  }
  (*token)++;

  // i//k
  if ((*token)[0] == '/') {
    (*token)++;
    vi.vn_idx = atoi((*token));
    (*token) += strcspn((*token), "/ \t\r");
    return vi;
  }

  // i/j/k or i/j
  vi.vt_idx = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  if ((*token)[0] != '/') {
    return vi;
  }

  // i/j/k
  (*token)++;  // skip '/'
  vi.vn_idx = atoi((*token));
  (*token) += strcspn((*token), "/ \t\r");
  return vi;
}

bool ParseTextureNameAndOption(std::string *texname, texture_option_t *texopt,
                               const char *linebuf) {
  // @todo { write more robust lexer and parser. }
  bool found_texname = false;
  std::string texture_name;

  const char *token = linebuf;  // Assume line ends with NULL

  while (!IS_NEW_LINE((*token))) {
    token += strspn(token, " \t");  // skip space
    if ((0 == strncmp(token, "-blendu", 7)) && IS_SPACE((token[7]))) {
      token += 8;
      texopt->blendu = parseOnOff(&token, /* default */ true);
    } else if ((0 == strncmp(token, "-blendv", 7)) && IS_SPACE((token[7]))) {
      token += 8;
      texopt->blendv = parseOnOff(&token, /* default */ true);
    } else if ((0 == strncmp(token, "-clamp", 6)) && IS_SPACE((token[6]))) {
      token += 7;
      texopt->clamp = parseOnOff(&token, /* default */ true);
    } else if ((0 == strncmp(token, "-boost", 6)) && IS_SPACE((token[6]))) {
      token += 7;
      texopt->sharpness = parseReal(&token, 1.0);
    } else if ((0 == strncmp(token, "-bm", 3)) && IS_SPACE((token[3]))) {
      token += 4;
      texopt->bump_multiplier = parseReal(&token, 1.0);
    } else if ((0 == strncmp(token, "-o", 2)) && IS_SPACE((token[2]))) {
      token += 3;
      parseReal3(&(texopt->origin_offset[0]), &(texopt->origin_offset[1]),
                 &(texopt->origin_offset[2]), &token);
    } else if ((0 == strncmp(token, "-s", 2)) && IS_SPACE((token[2]))) {
      token += 3;
      parseReal3(&(texopt->scale[0]), &(texopt->scale[1]), &(texopt->scale[2]),
                 &token, 1.0, 1.0, 1.0);
    } else if ((0 == strncmp(token, "-t", 2)) && IS_SPACE((token[2]))) {
      token += 3;
      parseReal3(&(texopt->turbulence[0]), &(texopt->turbulence[1]),
                 &(texopt->turbulence[2]), &token);
    } else if ((0 == strncmp(token, "-type", 5)) && IS_SPACE((token[5]))) {
      token += 5;
      texopt->type = parseTextureType((&token), TEXTURE_TYPE_NONE);
    } else if ((0 == strncmp(token, "-texres", 7)) && IS_SPACE((token[7]))) {
      token += 7;
      // TODO(syoyo): Check if arg is int type.
      texopt->texture_resolution = parseInt(&token);
    } else if ((0 == strncmp(token, "-imfchan", 8)) && IS_SPACE((token[8]))) {
      token += 9;
      token += strspn(token, " \t");
      const char *end = token + strcspn(token, " \t\r");
      if ((end - token) == 1) {  // Assume one char for -imfchan
        texopt->imfchan = (*token);
      }
      token = end;
    } else if ((0 == strncmp(token, "-mm", 3)) && IS_SPACE((token[3]))) {
      token += 4;
      parseReal2(&(texopt->brightness), &(texopt->contrast), &token, 0.0, 1.0);
    } else if ((0 == strncmp(token, "-colorspace", 11)) &&
               IS_SPACE((token[11]))) {
      token += 12;
      texopt->colorspace = parseString(&token);
    } else {
// Assume texture filename
#if 0
      size_t len = strcspn(token, " \t\r");  // untile next space
      texture_name = std::string(token, token + len);
      token += len;

      token += strspn(token, " \t");  // skip space
#else
      // Read filename until line end to parse filename containing whitespace
      // TODO(syoyo): Support parsing texture option flag after the filename.
      texture_name = std::string(token);
      token += texture_name.length();
#endif

      found_texname = true;
    }
  }

  if (found_texname) {
    (*texname) = texture_name;
    return true;
  } else {
    return false;
  }
}

static void InitTexOpt(texture_option_t *texopt, const bool is_bump) {
  if (is_bump) {
    texopt->imfchan = 'l';
  } else {
    texopt->imfchan = 'm';
  }
  texopt->bump_multiplier = static_cast<real_t>(1.0);
  texopt->clamp = false;
  texopt->blendu = true;
  texopt->blendv = true;
  texopt->sharpness = static_cast<real_t>(1.0);
  texopt->brightness = static_cast<real_t>(0.0);
  texopt->contrast = static_cast<real_t>(1.0);
  texopt->origin_offset[0] = static_cast<real_t>(0.0);
  texopt->origin_offset[1] = static_cast<real_t>(0.0);
  texopt->origin_offset[2] = static_cast<real_t>(0.0);
  texopt->scale[0] = static_cast<real_t>(1.0);
  texopt->scale[1] = static_cast<real_t>(1.0);
  texopt->scale[2] = static_cast<real_t>(1.0);
  texopt->turbulence[0] = static_cast<real_t>(0.0);
  texopt->turbulence[1] = static_cast<real_t>(0.0);
  texopt->turbulence[2] = static_cast<real_t>(0.0);
  texopt->texture_resolution = -1;
  texopt->type = TEXTURE_TYPE_NONE;
}

static void InitMaterial(material_t *material) {
  InitTexOpt(&material->ambient_texopt, /* is_bump */ false);
  InitTexOpt(&material->diffuse_texopt, /* is_bump */ false);
  InitTexOpt(&material->specular_texopt, /* is_bump */ false);
  InitTexOpt(&material->specular_highlight_texopt, /* is_bump */ false);
  InitTexOpt(&material->bump_texopt, /* is_bump */ true);
  InitTexOpt(&material->displacement_texopt, /* is_bump */ false);
  InitTexOpt(&material->alpha_texopt, /* is_bump */ false);
  InitTexOpt(&material->reflection_texopt, /* is_bump */ false);
  InitTexOpt(&material->roughness_texopt, /* is_bump */ false);
  InitTexOpt(&material->metallic_texopt, /* is_bump */ false);
  InitTexOpt(&material->sheen_texopt, /* is_bump */ false);
  InitTexOpt(&material->emissive_texopt, /* is_bump */ false);
  InitTexOpt(&material->normal_texopt,
             /* is_bump */ false);  // @fixme { is_bump will be true? }
  material->name = "";
  material->ambient_texname = "";
  material->diffuse_texname = "";
  material->specular_texname = "";
  material->specular_highlight_texname = "";
  material->bump_texname = "";
  material->displacement_texname = "";
  material->reflection_texname = "";
  material->alpha_texname = "";
  for (int i = 0; i < 3; i++) {
    material->ambient[i] = static_cast<real_t>(0.0);
    material->diffuse[i] = static_cast<real_t>(0.0);
    material->specular[i] = static_cast<real_t>(0.0);
    material->transmittance[i] = static_cast<real_t>(0.0);
    material->emission[i] = static_cast<real_t>(0.0);
  }
  material->illum = 0;
  material->dissolve = static_cast<real_t>(1.0);
  material->shininess = static_cast<real_t>(1.0);
  material->ior = static_cast<real_t>(1.0);

  material->roughness = static_cast<real_t>(0.0);
  material->metallic = static_cast<real_t>(0.0);
  material->sheen = static_cast<real_t>(0.0);
  material->clearcoat_thickness = static_cast<real_t>(0.0);
  material->clearcoat_roughness = static_cast<real_t>(0.0);
  material->anisotropy_rotation = static_cast<real_t>(0.0);
  material->anisotropy = static_cast<real_t>(0.0);
  material->roughness_texname = "";
  material->metallic_texname = "";
  material->sheen_texname = "";
  material->emissive_texname = "";
  material->normal_texname = "";

  material->unknown_parameter.clear();
}

// code from https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html
template <typename T>
static int pnpoly(int nvert, T *vertx, T *verty, T testx, T testy) {
  int i, j, c = 0;
  for (i = 0, j = nvert - 1; i < nvert; j = i++) {
    if (((verty[i] > testy) != (verty[j] > testy)) &&
        (testx <
         (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) +
             vertx[i]))
      c = !c;
  }
  return c;
}

// TODO(syoyo): refactor function.
static bool exportGroupsToShape(shape_t *shape, const PrimGroup &prim_group,
                                const std::vector<tag_t> &tags,
                                const int material_id, const std::string &name,
                                bool triangulate,
                                const std::vector<real_t> &v) {
  if (prim_group.IsEmpty()) {
    return false;
  }

  shape->name = name;

  // polygon
  if (!prim_group.faceGroup.empty()) {
    // Flatten vertices and indices
    for (size_t i = 0; i < prim_group.faceGroup.size(); i++) {
      const face_t &face = prim_group.faceGroup[i];

      size_t npolys = face.vertex_indices.size();

      if (npolys < 3) {
        // Face must have 3+ vertices.
        continue;
      }

      vertex_index_t i0 = face.vertex_indices[0];
      vertex_index_t i1(-1);
      vertex_index_t i2 = face.vertex_indices[1];

      if (triangulate) {
        // find the two axes to work in
        size_t axes[2] = {1, 2};
        for (size_t k = 0; k < npolys; ++k) {
          i0 = face.vertex_indices[(k + 0) % npolys];
          i1 = face.vertex_indices[(k + 1) % npolys];
          i2 = face.vertex_indices[(k + 2) % npolys];
          size_t vi0 = size_t(i0.v_idx);
          size_t vi1 = size_t(i1.v_idx);
          size_t vi2 = size_t(i2.v_idx);

          if (((3 * vi0 + 2) >= v.size()) || ((3 * vi1 + 2) >= v.size()) ||
              ((3 * vi2 + 2) >= v.size())) {
            // Invalid triangle.
            // FIXME(syoyo): Is it ok to simply skip this invalid triangle?
            continue;
          }
          real_t v0x = v[vi0 * 3 + 0];
          real_t v0y = v[vi0 * 3 + 1];
          real_t v0z = v[vi0 * 3 + 2];
          real_t v1x = v[vi1 * 3 + 0];
          real_t v1y = v[vi1 * 3 + 1];
          real_t v1z = v[vi1 * 3 + 2];
          real_t v2x = v[vi2 * 3 + 0];
          real_t v2y = v[vi2 * 3 + 1];
          real_t v2z = v[vi2 * 3 + 2];
          real_t e0x = v1x - v0x;
          real_t e0y = v1y - v0y;
          real_t e0z = v1z - v0z;
          real_t e1x = v2x - v1x;
          real_t e1y = v2y - v1y;
          real_t e1z = v2z - v1z;
          real_t cx = std::fabs(e0y * e1z - e0z * e1y);
          real_t cy = std::fabs(e0z * e1x - e0x * e1z);
          real_t cz = std::fabs(e0x * e1y - e0y * e1x);
          const real_t epsilon = std::numeric_limits<real_t>::epsilon();
          if (cx > epsilon || cy > epsilon || cz > epsilon) {
            // found a corner
            if (cx > cy && cx > cz) {
            } else {
              axes[0] = 0;
              if (cz > cx && cz > cy) axes[1] = 1;
            }
            break;
          }
        }

        real_t area = 0;
        for (size_t k = 0; k < npolys; ++k) {
          i0 = face.vertex_indices[(k + 0) % npolys];
          i1 = face.vertex_indices[(k + 1) % npolys];
          size_t vi0 = size_t(i0.v_idx);
          size_t vi1 = size_t(i1.v_idx);
          if (((vi0 * 3 + axes[0]) >= v.size()) ||
              ((vi0 * 3 + axes[1]) >= v.size()) ||
              ((vi1 * 3 + axes[0]) >= v.size()) ||
              ((vi1 * 3 + axes[1]) >= v.size())) {
            // Invalid index.
            continue;
          }
          real_t v0x = v[vi0 * 3 + axes[0]];
          real_t v0y = v[vi0 * 3 + axes[1]];
          real_t v1x = v[vi1 * 3 + axes[0]];
          real_t v1y = v[vi1 * 3 + axes[1]];
          area += (v0x * v1y - v0y * v1x) * static_cast<real_t>(0.5);
        }

        face_t remainingFace = face;  // copy
        size_t guess_vert = 0;
        vertex_index_t ind[3];
        real_t vx[3];
        real_t vy[3];

        // How many iterations can we do without decreasing the remaining
        // vertices.
        size_t remainingIterations = face.vertex_indices.size();
        size_t previousRemainingVertices = remainingFace.vertex_indices.size();

        while (remainingFace.vertex_indices.size() > 3 &&
               remainingIterations > 0) {
          npolys = remainingFace.vertex_indices.size();
          if (guess_vert >= npolys) {
            guess_vert -= npolys;
          }

          if (previousRemainingVertices != npolys) {
            // The number of remaining vertices decreased. Reset counters.
            previousRemainingVertices = npolys;
            remainingIterations = npolys;
          } else {
            // We didn't consume a vertex on previous iteration, reduce the
            // available iterations.
            remainingIterations--;
          }

          for (size_t k = 0; k < 3; k++) {
            ind[k] = remainingFace.vertex_indices[(guess_vert + k) % npolys];
            size_t vi = size_t(ind[k].v_idx);
            if (((vi * 3 + axes[0]) >= v.size()) ||
                ((vi * 3 + axes[1]) >= v.size())) {
              // ???
              vx[k] = static_cast<real_t>(0.0);
              vy[k] = static_cast<real_t>(0.0);
            } else {
              vx[k] = v[vi * 3 + axes[0]];
              vy[k] = v[vi * 3 + axes[1]];
            }
          }
          real_t e0x = vx[1] - vx[0];
          real_t e0y = vy[1] - vy[0];
          real_t e1x = vx[2] - vx[1];
          real_t e1y = vy[2] - vy[1];
          real_t cross = e0x * e1y - e0y * e1x;
          // if an internal angle
          if (cross * area < static_cast<real_t>(0.0)) {
            guess_vert += 1;
            continue;
          }

          // check all other verts in case they are inside this triangle
          bool overlap = false;
          for (size_t otherVert = 3; otherVert < npolys; ++otherVert) {
            size_t idx = (guess_vert + otherVert) % npolys;

            if (idx >= remainingFace.vertex_indices.size()) {
              // ???
              continue;
            }

            size_t ovi = size_t(remainingFace.vertex_indices[idx].v_idx);

            if (((ovi * 3 + axes[0]) >= v.size()) ||
                ((ovi * 3 + axes[1]) >= v.size())) {
              // ???
              continue;
            }
            real_t tx = v[ovi * 3 + axes[0]];
            real_t ty = v[ovi * 3 + axes[1]];
            if (pnpoly(3, vx, vy, tx, ty)) {
              overlap = true;
              break;
            }
          }

          if (overlap) {
            guess_vert += 1;
            continue;
          }

          // this triangle is an ear
          {
            index_t idx0, idx1, idx2;
            idx0.vertex_index = ind[0].v_idx;
            idx0.normal_index = ind[0].vn_idx;
            idx0.texcoord_index = ind[0].vt_idx;
            idx1.vertex_index = ind[1].v_idx;
            idx1.normal_index = ind[1].vn_idx;
            idx1.texcoord_index = ind[1].vt_idx;
            idx2.vertex_index = ind[2].v_idx;
            idx2.normal_index = ind[2].vn_idx;
            idx2.texcoord_index = ind[2].vt_idx;

            shape->mesh.indices.push_back(idx0);
            shape->mesh.indices.push_back(idx1);
            shape->mesh.indices.push_back(idx2);

            shape->mesh.num_face_vertices.push_back(3);
            shape->mesh.material_ids.push_back(material_id);
            shape->mesh.smoothing_group_ids.push_back(face.smoothing_group_id);
          }

          // remove v1 from the list
          size_t removed_vert_index = (guess_vert + 1) % npolys;
          while (removed_vert_index + 1 < npolys) {
            remainingFace.vertex_indices[removed_vert_index] =
                remainingFace.vertex_indices[removed_vert_index + 1];
            removed_vert_index += 1;
          }
          remainingFace.vertex_indices.pop_back();
        }

        if (remainingFace.vertex_indices.size() == 3) {
          i0 = remainingFace.vertex_indices[0];
          i1 = remainingFace.vertex_indices[1];
          i2 = remainingFace.vertex_indices[2];
          {
            index_t idx0, idx1, idx2;
            idx0.vertex_index = i0.v_idx;
            idx0.normal_index = i0.vn_idx;
            idx0.texcoord_index = i0.vt_idx;
            idx1.vertex_index = i1.v_idx;
            idx1.normal_index = i1.vn_idx;
            idx1.texcoord_index = i1.vt_idx;
            idx2.vertex_index = i2.v_idx;
            idx2.normal_index = i2.vn_idx;
            idx2.texcoord_index = i2.vt_idx;

            shape->mesh.indices.push_back(idx0);
            shape->mesh.indices.push_back(idx1);
            shape->mesh.indices.push_back(idx2);

            shape->mesh.num_face_vertices.push_back(3);
            shape->mesh.material_ids.push_back(material_id);
            shape->mesh.smoothing_group_ids.push_back(face.smoothing_group_id);
          }
        }
      } else {
        for (size_t k = 0; k < npolys; k++) {
          index_t idx;
          idx.vertex_index = face.vertex_indices[k].v_idx;
          idx.normal_index = face.vertex_indices[k].vn_idx;
          idx.texcoord_index = face.vertex_indices[k].vt_idx;
          shape->mesh.indices.push_back(idx);
        }

        shape->mesh.num_face_vertices.push_back(
            static_cast<unsigned char>(npolys));
        shape->mesh.material_ids.push_back(material_id);  // per face
        shape->mesh.smoothing_group_ids.push_back(
            face.smoothing_group_id);  // per face
      }
    }

    shape->mesh.tags = tags;
  }

  // line
  if (!prim_group.lineGroup.empty()) {
    // Flatten indices
    for (size_t i = 0; i < prim_group.lineGroup.size(); i++) {
      for (size_t j = 0; j < prim_group.lineGroup[i].vertex_indices.size();
           j++) {
        const vertex_index_t &vi = prim_group.lineGroup[i].vertex_indices[j];

        index_t idx;
        idx.vertex_index = vi.v_idx;
        idx.normal_index = vi.vn_idx;
        idx.texcoord_index = vi.vt_idx;

        shape->lines.indices.push_back(idx);
      }

      shape->lines.num_line_vertices.push_back(
          int(prim_group.lineGroup[i].vertex_indices.size()));
    }
  }

  // points
  if (!prim_group.pointsGroup.empty()) {
    // Flatten & convert indices
    for (size_t i = 0; i < prim_group.pointsGroup.size(); i++) {
      for (size_t j = 0; j < prim_group.pointsGroup[i].vertex_indices.size();
           j++) {
        const vertex_index_t &vi = prim_group.pointsGroup[i].vertex_indices[j];

        index_t idx;
        idx.vertex_index = vi.v_idx;
        idx.normal_index = vi.vn_idx;
        idx.texcoord_index = vi.vt_idx;

        shape->points.indices.push_back(idx);
      }
    }
  }

  return true;
}

// Split a string with specified delimiter character and escape character.
// https://rosettacode.org/wiki/Tokenize_a_string_with_escaping#C.2B.2B
static void SplitString(const std::string &s, char delim, char escape,
                        std::vector<std::string> &elems) {
  std::string token;

  bool escaping = false;
  for (int i = 0; i < s.size(); ++i) {
    char ch = s[i];
    if (escaping) {
      escaping = false;
    } else if (ch == escape) {
      escaping = true;
      continue;
    } else if (ch == delim) {
      if (!token.empty()) {
        elems.push_back(token);
      }
      token.clear();
      continue;
    }
    token += ch;
  }

  elems.push_back(token);
}

static std::string JoinPath(const std::string &dir,
                            const std::string &filename) {
  if (dir.empty()) {
    return filename;
  } else {
    // check '/'
    char lastChar = *dir.rbegin();
    if (lastChar != '/') {
      return dir + std::string("/") + filename;
    } else {
      return dir + filename;
    }
  }
}

void LoadMtl(std::map<std::string, int> *material_map,
             std::vector<material_t> *materials, std::istream *inStream,
             std::string *warning, std::string *err) {
  (void)err;

  // Create a default material anyway.
  material_t material;
  InitMaterial(&material);

  // Issue 43. `d` wins against `Tr` since `Tr` is not in the MTL specification.
  bool has_d = false;
  bool has_tr = false;

  // has_kd is used to set a default diffuse value when map_Kd is present
  // and Kd is not.
  bool has_kd = false;

  std::stringstream warn_ss;

  size_t line_no = 0;
  std::string linebuf;
  while (inStream->peek() != -1) {
    safeGetline(*inStream, linebuf);
    line_no++;

    // Trim trailing whitespace.
    if (linebuf.size() > 0) {
      linebuf = linebuf.substr(0, linebuf.find_last_not_of(" \t") + 1);
    }

    // Trim newline '\r\n' or '\n'
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\n')
        linebuf.erase(linebuf.size() - 1);
    }
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\r')
        linebuf.erase(linebuf.size() - 1);
    }

    // Skip if empty line.
    if (linebuf.empty()) {
      continue;
    }

    // Skip leading space.
    const char *token = linebuf.c_str();
    token += strspn(token, " \t");

    assert(token);
    if (token[0] == '\0') continue;  // empty line

    if (token[0] == '#') continue;  // comment line

    // new mtl
    if ((0 == strncmp(token, "newmtl", 6)) && IS_SPACE((token[6]))) {
      // flush previous material.
      if (!material.name.empty()) {
        material_map->insert(std::pair<std::string, int>(
            material.name, static_cast<int>(materials->size())));
        materials->push_back(material);
      }

      // initial temporary material
      InitMaterial(&material);

      has_d = false;
      has_tr = false;

      // set new mtl name
      token += 7;
      {
        std::stringstream sstr;
        sstr << token;
        material.name = sstr.str();
      }
      continue;
    }

    // ambient
    if (token[0] == 'K' && token[1] == 'a' && IS_SPACE((token[2]))) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.ambient[0] = r;
      material.ambient[1] = g;
      material.ambient[2] = b;
      continue;
    }

    // diffuse
    if (token[0] == 'K' && token[1] == 'd' && IS_SPACE((token[2]))) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.diffuse[0] = r;
      material.diffuse[1] = g;
      material.diffuse[2] = b;
      has_kd = true;
      continue;
    }

    // specular
    if (token[0] == 'K' && token[1] == 's' && IS_SPACE((token[2]))) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.specular[0] = r;
      material.specular[1] = g;
      material.specular[2] = b;
      continue;
    }

    // transmittance
    if ((token[0] == 'K' && token[1] == 't' && IS_SPACE((token[2]))) ||
        (token[0] == 'T' && token[1] == 'f' && IS_SPACE((token[2])))) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.transmittance[0] = r;
      material.transmittance[1] = g;
      material.transmittance[2] = b;
      continue;
    }

    // ior(index of refraction)
    if (token[0] == 'N' && token[1] == 'i' && IS_SPACE((token[2]))) {
      token += 2;
      material.ior = parseReal(&token);
      continue;
    }

    // emission
    if (token[0] == 'K' && token[1] == 'e' && IS_SPACE(token[2])) {
      token += 2;
      real_t r, g, b;
      parseReal3(&r, &g, &b, &token);
      material.emission[0] = r;
      material.emission[1] = g;
      material.emission[2] = b;
      continue;
    }

    // shininess
    if (token[0] == 'N' && token[1] == 's' && IS_SPACE(token[2])) {
      token += 2;
      material.shininess = parseReal(&token);
      continue;
    }

    // illum model
    if (0 == strncmp(token, "illum", 5) && IS_SPACE(token[5])) {
      token += 6;
      material.illum = parseInt(&token);
      continue;
    }

    // dissolve
    if ((token[0] == 'd' && IS_SPACE(token[1]))) {
      token += 1;
      material.dissolve = parseReal(&token);

      if (has_tr) {
        warn_ss << "Both `d` and `Tr` parameters defined for \""
                << material.name
                << "\". Use the value of `d` for dissolve (line " << line_no
                << " in .mtl.)" << std::endl;
      }
      has_d = true;
      continue;
    }
    if (token[0] == 'T' && token[1] == 'r' && IS_SPACE(token[2])) {
      token += 2;
      if (has_d) {
        // `d` wins. Ignore `Tr` value.
        warn_ss << "Both `d` and `Tr` parameters defined for \""
                << material.name
                << "\". Use the value of `d` for dissolve (line " << line_no
                << " in .mtl.)" << std::endl;
      } else {
        // We invert value of Tr(assume Tr is in range [0, 1])
        // NOTE: Interpretation of Tr is application(exporter) dependent. For
        // some application(e.g. 3ds max obj exporter), Tr = d(Issue 43)
        material.dissolve = static_cast<real_t>(1.0) - parseReal(&token);
      }
      has_tr = true;
      continue;
    }

    // PBR: roughness
    if (token[0] == 'P' && token[1] == 'r' && IS_SPACE(token[2])) {
      token += 2;
      material.roughness = parseReal(&token);
      continue;
    }

    // PBR: metallic
    if (token[0] == 'P' && token[1] == 'm' && IS_SPACE(token[2])) {
      token += 2;
      material.metallic = parseReal(&token);
      continue;
    }

    // PBR: sheen
    if (token[0] == 'P' && token[1] == 's' && IS_SPACE(token[2])) {
      token += 2;
      material.sheen = parseReal(&token);
      continue;
    }

    // PBR: clearcoat thickness
    if (token[0] == 'P' && token[1] == 'c' && IS_SPACE(token[2])) {
      token += 2;
      material.clearcoat_thickness = parseReal(&token);
      continue;
    }

    // PBR: clearcoat roughness
    if ((0 == strncmp(token, "Pcr", 3)) && IS_SPACE(token[3])) {
      token += 4;
      material.clearcoat_roughness = parseReal(&token);
      continue;
    }

    // PBR: anisotropy
    if ((0 == strncmp(token, "aniso", 5)) && IS_SPACE(token[5])) {
      token += 6;
      material.anisotropy = parseReal(&token);
      continue;
    }

    // PBR: anisotropy rotation
    if ((0 == strncmp(token, "anisor", 6)) && IS_SPACE(token[6])) {
      token += 7;
      material.anisotropy_rotation = parseReal(&token);
      continue;
    }

    // ambient texture
    if ((0 == strncmp(token, "map_Ka", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.ambient_texname),
                                &(material.ambient_texopt), token);
      continue;
    }

    // diffuse texture
    if ((0 == strncmp(token, "map_Kd", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.diffuse_texname),
                                &(material.diffuse_texopt), token);

      // Set a decent diffuse default value if a diffuse texture is specified
      // without a matching Kd value.
      if (!has_kd) {
        material.diffuse[0] = static_cast<real_t>(0.6);
        material.diffuse[1] = static_cast<real_t>(0.6);
        material.diffuse[2] = static_cast<real_t>(0.6);
      }

      continue;
    }

    // specular texture
    if ((0 == strncmp(token, "map_Ks", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.specular_texname),
                                &(material.specular_texopt), token);
      continue;
    }

    // specular highlight texture
    if ((0 == strncmp(token, "map_Ns", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.specular_highlight_texname),
                                &(material.specular_highlight_texopt), token);
      continue;
    }

    // bump texture
    if ((0 == strncmp(token, "map_bump", 8)) && IS_SPACE(token[8])) {
      token += 9;
      ParseTextureNameAndOption(&(material.bump_texname),
                                &(material.bump_texopt), token);
      continue;
    }

    // bump texture
    if ((0 == strncmp(token, "map_Bump", 8)) && IS_SPACE(token[8])) {
      token += 9;
      ParseTextureNameAndOption(&(material.bump_texname),
                                &(material.bump_texopt), token);
      continue;
    }

    // bump texture
    if ((0 == strncmp(token, "bump", 4)) && IS_SPACE(token[4])) {
      token += 5;
      ParseTextureNameAndOption(&(material.bump_texname),
                                &(material.bump_texopt), token);
      continue;
    }

    // alpha texture
    if ((0 == strncmp(token, "map_d", 5)) && IS_SPACE(token[5])) {
      token += 6;
      material.alpha_texname = token;
      ParseTextureNameAndOption(&(material.alpha_texname),
                                &(material.alpha_texopt), token);
      continue;
    }

    // displacement texture
    if ((0 == strncmp(token, "disp", 4)) && IS_SPACE(token[4])) {
      token += 5;
      ParseTextureNameAndOption(&(material.displacement_texname),
                                &(material.displacement_texopt), token);
      continue;
    }

    // reflection map
    if ((0 == strncmp(token, "refl", 4)) && IS_SPACE(token[4])) {
      token += 5;
      ParseTextureNameAndOption(&(material.reflection_texname),
                                &(material.reflection_texopt), token);
      continue;
    }

    // PBR: roughness texture
    if ((0 == strncmp(token, "map_Pr", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.roughness_texname),
                                &(material.roughness_texopt), token);
      continue;
    }

    // PBR: metallic texture
    if ((0 == strncmp(token, "map_Pm", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.metallic_texname),
                                &(material.metallic_texopt), token);
      continue;
    }

    // PBR: sheen texture
    if ((0 == strncmp(token, "map_Ps", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.sheen_texname),
                                &(material.sheen_texopt), token);
      continue;
    }

    // PBR: emissive texture
    if ((0 == strncmp(token, "map_Ke", 6)) && IS_SPACE(token[6])) {
      token += 7;
      ParseTextureNameAndOption(&(material.emissive_texname),
                                &(material.emissive_texopt), token);
      continue;
    }

    // PBR: normal map texture
    if ((0 == strncmp(token, "norm", 4)) && IS_SPACE(token[4])) {
      token += 5;
      ParseTextureNameAndOption(&(material.normal_texname),
                                &(material.normal_texopt), token);
      continue;
    }

    // unknown parameter
    const char *_space = strchr(token, ' ');
    if (!_space) {
      _space = strchr(token, '\t');
    }
    if (_space) {
      std::ptrdiff_t len = _space - token;
      std::string key(token, static_cast<size_t>(len));
      std::string value = _space + 1;
      material.unknown_parameter.insert(
          std::pair<std::string, std::string>(key, value));
    }
  }
  // flush last material.
  material_map->insert(std::pair<std::string, int>(
      material.name, static_cast<int>(materials->size())));
  materials->push_back(material);

  if (warning) {
    (*warning) = warn_ss.str();
  }
}

bool MaterialFileReader::operator()(const std::string &matId,
                                    std::vector<material_t> *materials,
                                    std::map<std::string, int> *matMap,
                                    std::string *warn, std::string *err) {
  if (!m_mtlBaseDir.empty()) {
#ifdef _WIN32
    char sep = ';';
#else
    char sep = ':';
#endif

    // https://stackoverflow.com/questions/5167625/splitting-a-c-stdstring-using-tokens-e-g
    std::vector<std::string> paths;
    std::istringstream f(m_mtlBaseDir);

    std::string s;
    while (getline(f, s, sep)) {
      paths.push_back(s);
    }

    for (size_t i = 0; i < paths.size(); i++) {
      std::string filepath = JoinPath(paths[i], matId);

      std::ifstream matIStream(filepath.c_str());
      if (matIStream) {
        LoadMtl(matMap, materials, &matIStream, warn, err);

        return true;
      }
    }

    std::stringstream ss;
    ss << "Material file [ " << matId
       << " ] not found in a path : " << m_mtlBaseDir << std::endl;
    if (warn) {
      (*warn) += ss.str();
    }
    return false;

  } else {
    std::string filepath = matId;
    std::ifstream matIStream(filepath.c_str());
    if (matIStream) {
      LoadMtl(matMap, materials, &matIStream, warn, err);

      return true;
    }

    std::stringstream ss;
    ss << "Material file [ " << filepath
       << " ] not found in a path : " << m_mtlBaseDir << std::endl;
    if (warn) {
      (*warn) += ss.str();
    }

    return false;
  }
}

bool MaterialStreamReader::operator()(const std::string &matId,
                                      std::vector<material_t> *materials,
                                      std::map<std::string, int> *matMap,
                                      std::string *warn, std::string *err) {
  (void)err;
  (void)matId;
  if (!m_inStream) {
    std::stringstream ss;
    ss << "Material stream in error state. " << std::endl;
    if (warn) {
      (*warn) += ss.str();
    }
    return false;
  }

  LoadMtl(matMap, materials, &m_inStream, warn, err);

  return true;
}

bool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,
             std::vector<material_t> *materials, std::string *warn,
             std::string *err, const char *filename, const char *mtl_basedir,
             bool trianglulate, bool default_vcols_fallback) {
  attrib->vertices.clear();
  attrib->normals.clear();
  attrib->texcoords.clear();
  attrib->colors.clear();
  shapes->clear();

  std::stringstream errss;

  std::ifstream ifs(filename);
  if (!ifs) {
    errss << "Cannot open file [" << filename << "]" << std::endl;
    if (err) {
      (*err) = errss.str();
    }
    return false;
  }

  std::string baseDir = mtl_basedir ? mtl_basedir : "";
  if (!baseDir.empty()) {
#ifndef _WIN32
    const char dirsep = '/';
#else
    const char dirsep = '\\';
#endif
    if (baseDir[baseDir.length() - 1] != dirsep) baseDir += dirsep;
  }
  MaterialFileReader matFileReader(baseDir);

  return LoadObj(attrib, shapes, materials, warn, err, &ifs, &matFileReader,
                 trianglulate, default_vcols_fallback);
}

bool LoadObj(attrib_t *attrib, std::vector<shape_t> *shapes,
             std::vector<material_t> *materials, std::string *warn,
             std::string *err, std::istream *inStream,
             MaterialReader *readMatFn /*= NULL*/, bool triangulate,
             bool default_vcols_fallback) {
  std::stringstream errss;

  std::vector<real_t> v;
  std::vector<real_t> vn;
  std::vector<real_t> vt;
  std::vector<real_t> vc;
  std::vector<skin_weight_t> vw;
  std::vector<tag_t> tags;
  PrimGroup prim_group;
  std::string name;

  // material
  std::map<std::string, int> material_map;
  int material = -1;

  // smoothing group id
  unsigned int current_smoothing_id =
      0;  // Initial value. 0 means no smoothing.

  int greatest_v_idx = -1;
  int greatest_vn_idx = -1;
  int greatest_vt_idx = -1;

  shape_t shape;

  bool found_all_colors = true;

  size_t line_num = 0;
  std::string linebuf;
  while (inStream->peek() != -1) {
    safeGetline(*inStream, linebuf);

    line_num++;

    // Trim newline '\r\n' or '\n'
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\n')
        linebuf.erase(linebuf.size() - 1);
    }
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\r')
        linebuf.erase(linebuf.size() - 1);
    }

    // Skip if empty line.
    if (linebuf.empty()) {
      continue;
    }

    // Skip leading space.
    const char *token = linebuf.c_str();
    token += strspn(token, " \t");

    assert(token);
    if (token[0] == '\0') continue;  // empty line

    if (token[0] == '#') continue;  // comment line

    // vertex
    if (token[0] == 'v' && IS_SPACE((token[1]))) {
      token += 2;
      real_t x, y, z;
      real_t r, g, b;

      found_all_colors &= parseVertexWithColor(&x, &y, &z, &r, &g, &b, &token);

      v.push_back(x);
      v.push_back(y);
      v.push_back(z);

      if (found_all_colors || default_vcols_fallback) {
        vc.push_back(r);
        vc.push_back(g);
        vc.push_back(b);
      }

      continue;
    }

    // normal
    if (token[0] == 'v' && token[1] == 'n' && IS_SPACE((token[2]))) {
      token += 3;
      real_t x, y, z;
      parseReal3(&x, &y, &z, &token);
      vn.push_back(x);
      vn.push_back(y);
      vn.push_back(z);
      continue;
    }

    // texcoord
    if (token[0] == 'v' && token[1] == 't' && IS_SPACE((token[2]))) {
      token += 3;
      real_t x, y;
      parseReal2(&x, &y, &token);
      vt.push_back(x);
      vt.push_back(y);
      continue;
    }

    // skin weight. tinyobj extension
    if (token[0] == 'v' && token[1] == 'w' && IS_SPACE((token[2]))) {
      token += 3;

      // vw <vid> <joint_0> <weight_0> <joint_1> <weight_1> ...
      // example:
      // vw 0 0 0.25 1 0.25 2 0.5

      // TODO(syoyo): Add syntax check
      int vid = 0;
      vid = parseInt(&token);

      skin_weight_t sw;

      sw.vertex_id = vid;

      while (!IS_NEW_LINE(token[0])) {
        real_t j, w;
        // joint_id should not be negative, weight may be negative
        // TODO(syoyo): # of elements check
        parseReal2(&j, &w, &token, -1.0);

        if (j < 0.0) {
          if (err) {
            std::stringstream ss;
            ss << "Failed parse `vw' line. joint_id is negative. "
                  "line "
               << line_num << ".)\n";
            (*err) += ss.str();
          }
          return false;
        }

        joint_and_weight_t jw;

        jw.joint_id = int(j);
        jw.weight = w;

        sw.weightValues.push_back(jw);

        size_t n = strspn(token, " \t\r");
        token += n;
      }

      vw.push_back(sw);
    }

    // line
    if (token[0] == 'l' && IS_SPACE((token[1]))) {
      token += 2;

      __line_t line;

      while (!IS_NEW_LINE(token[0])) {
        vertex_index_t vi;
        if (!parseTriple(&token, static_cast<int>(v.size() / 3),
                         static_cast<int>(vn.size() / 3),
                         static_cast<int>(vt.size() / 2), &vi)) {
          if (err) {
            std::stringstream ss;
            ss << "Failed parse `l' line(e.g. zero value for vertex index. "
                  "line "
               << line_num << ".)\n";
            (*err) += ss.str();
          }
          return false;
        }

        line.vertex_indices.push_back(vi);

        size_t n = strspn(token, " \t\r");
        token += n;
      }

      prim_group.lineGroup.push_back(line);

      continue;
    }

    // points
    if (token[0] == 'p' && IS_SPACE((token[1]))) {
      token += 2;

      __points_t pts;

      while (!IS_NEW_LINE(token[0])) {
        vertex_index_t vi;
        if (!parseTriple(&token, static_cast<int>(v.size() / 3),
                         static_cast<int>(vn.size() / 3),
                         static_cast<int>(vt.size() / 2), &vi)) {
          if (err) {
            std::stringstream ss;
            ss << "Failed parse `p' line(e.g. zero value for vertex index. "
                  "line "
               << line_num << ".)\n";
            (*err) += ss.str();
          }
          return false;
        }

        pts.vertex_indices.push_back(vi);

        size_t n = strspn(token, " \t\r");
        token += n;
      }

      prim_group.pointsGroup.push_back(pts);

      continue;
    }

    // face
    if (token[0] == 'f' && IS_SPACE((token[1]))) {
      token += 2;
      token += strspn(token, " \t");

      face_t face;

      face.smoothing_group_id = current_smoothing_id;
      face.vertex_indices.reserve(3);

      while (!IS_NEW_LINE(token[0])) {
        vertex_index_t vi;
        if (!parseTriple(&token, static_cast<int>(v.size() / 3),
                         static_cast<int>(vn.size() / 3),
                         static_cast<int>(vt.size() / 2), &vi)) {
          if (err) {
            std::stringstream ss;
            ss << "Failed parse `f' line(e.g. zero value for face index. line "
               << line_num << ".)\n";
            (*err) += ss.str();
          }
          return false;
        }

        greatest_v_idx = greatest_v_idx > vi.v_idx ? greatest_v_idx : vi.v_idx;
        greatest_vn_idx =
            greatest_vn_idx > vi.vn_idx ? greatest_vn_idx : vi.vn_idx;
        greatest_vt_idx =
            greatest_vt_idx > vi.vt_idx ? greatest_vt_idx : vi.vt_idx;

        face.vertex_indices.push_back(vi);
        size_t n = strspn(token, " \t\r");
        token += n;
      }

      // replace with emplace_back + std::move on C++11
      prim_group.faceGroup.push_back(face);

      continue;
    }

    // use mtl
    if ((0 == strncmp(token, "usemtl", 6))) {
      token += 6;
      std::string namebuf = parseString(&token);

      int newMaterialId = -1;
      std::map<std::string, int>::const_iterator it = material_map.find(namebuf);
      if (it != material_map.end()) {
        newMaterialId = it->second;
      } else {
        // { error!! material not found }
        if (warn) {
          (*warn) += "material [ '" + namebuf + "' ] not found in .mtl\n";
        }
      }

      if (newMaterialId != material) {
        // Create per-face material. Thus we don't add `shape` to `shapes` at
        // this time.
        // just clear `faceGroup` after `exportGroupsToShape()` call.
        exportGroupsToShape(&shape, prim_group, tags, material, name,
                            triangulate, v);
        prim_group.faceGroup.clear();
        material = newMaterialId;
      }

      continue;
    }

    // load mtl
    if ((0 == strncmp(token, "mtllib", 6)) && IS_SPACE((token[6]))) {
      if (readMatFn) {
        token += 7;

        std::vector<std::string> filenames;
        SplitString(std::string(token), ' ', '\\', filenames);

        if (filenames.empty()) {
          if (warn) {
            std::stringstream ss;
            ss << "Looks like empty filename for mtllib. Use default "
                  "material (line "
               << line_num << ".)\n";

            (*warn) += ss.str();
          }
        } else {
          bool found = false;
          for (size_t s = 0; s < filenames.size(); s++) {
            std::string warn_mtl;
            std::string err_mtl;
            bool ok = (*readMatFn)(filenames[s].c_str(), materials,
                                   &material_map, &warn_mtl, &err_mtl);
            if (warn && (!warn_mtl.empty())) {
              (*warn) += warn_mtl;
            }

            if (err && (!err_mtl.empty())) {
              (*err) += err_mtl;
            }

            if (ok) {
              found = true;
              break;
            }
          }

          if (!found) {
            if (warn) {
              (*warn) +=
                  "Failed to load material file(s). Use default "
                  "material.\n";
            }
          }
        }
      }

      continue;
    }

    // group name
    if (token[0] == 'g' && IS_SPACE((token[1]))) {
      // flush previous face group.
      bool ret = exportGroupsToShape(&shape, prim_group, tags, material, name,
                                     triangulate, v);
      (void)ret;  // return value not used.

      if (shape.mesh.indices.size() > 0) {
        shapes->push_back(shape);
      }

      shape = shape_t();

      // material = -1;
      prim_group.clear();

      std::vector<std::string> names;

      while (!IS_NEW_LINE(token[0])) {
        std::string str = parseString(&token);
        names.push_back(str);
        token += strspn(token, " \t\r");  // skip tag
      }

      // names[0] must be 'g'

      if (names.size() < 2) {
        // 'g' with empty names
        if (warn) {
          std::stringstream ss;
          ss << "Empty group name. line: " << line_num << "\n";
          (*warn) += ss.str();
          name = "";
        }
      } else {
        std::stringstream ss;
        ss << names[1];

        // tinyobjloader does not support multiple groups for a primitive.
        // Currently we concatinate multiple group names with a space to get
        // single group name.

        for (size_t i = 2; i < names.size(); i++) {
          ss << " " << names[i];
        }

        name = ss.str();
      }

      continue;
    }

    // object name
    if (token[0] == 'o' && IS_SPACE((token[1]))) {
      // flush previous face group.
      bool ret = exportGroupsToShape(&shape, prim_group, tags, material, name,
                                     triangulate, v);
      (void)ret;  // return value not used.

      if (shape.mesh.indices.size() > 0 || shape.lines.indices.size() > 0 ||
          shape.points.indices.size() > 0) {
        shapes->push_back(shape);
      }

      // material = -1;
      prim_group.clear();
      shape = shape_t();

      // @todo { multiple object name? }
      token += 2;
      std::stringstream ss;
      ss << token;
      name = ss.str();

      continue;
    }

    if (token[0] == 't' && IS_SPACE(token[1])) {
      const int max_tag_nums = 8192;  // FIXME(syoyo): Parameterize.
      tag_t tag;

      token += 2;

      tag.name = parseString(&token);

      tag_sizes ts = parseTagTriple(&token);

      if (ts.num_ints < 0) {
        ts.num_ints = 0;
      }
      if (ts.num_ints > max_tag_nums) {
        ts.num_ints = max_tag_nums;
      }

      if (ts.num_reals < 0) {
        ts.num_reals = 0;
      }
      if (ts.num_reals > max_tag_nums) {
        ts.num_reals = max_tag_nums;
      }

      if (ts.num_strings < 0) {
        ts.num_strings = 0;
      }
      if (ts.num_strings > max_tag_nums) {
        ts.num_strings = max_tag_nums;
      }

      tag.intValues.resize(static_cast<size_t>(ts.num_ints));

      for (size_t i = 0; i < static_cast<size_t>(ts.num_ints); ++i) {
        tag.intValues[i] = parseInt(&token);
      }

      tag.floatValues.resize(static_cast<size_t>(ts.num_reals));
      for (size_t i = 0; i < static_cast<size_t>(ts.num_reals); ++i) {
        tag.floatValues[i] = parseReal(&token);
      }

      tag.stringValues.resize(static_cast<size_t>(ts.num_strings));
      for (size_t i = 0; i < static_cast<size_t>(ts.num_strings); ++i) {
        tag.stringValues[i] = parseString(&token);
      }

      tags.push_back(tag);

      continue;
    }

    if (token[0] == 's' && IS_SPACE(token[1])) {
      // smoothing group id
      token += 2;

      // skip space.
      token += strspn(token, " \t");  // skip space

      if (token[0] == '\0') {
        continue;
      }

      if (token[0] == '\r' || token[1] == '\n') {
        continue;
      }

      if (strlen(token) >= 3 && token[0] == 'o' && token[1] == 'f' &&
          token[2] == 'f') {
        current_smoothing_id = 0;
      } else {
        // assume number
        int smGroupId = parseInt(&token);
        if (smGroupId < 0) {
          // parse error. force set to 0.
          // FIXME(syoyo): Report warning.
          current_smoothing_id = 0;
        } else {
          current_smoothing_id = static_cast<unsigned int>(smGroupId);
        }
      }

      continue;
    }  // smoothing group id

    // Ignore unknown command.
  }

  // not all vertices have colors, no default colors desired? -> clear colors
  if (!found_all_colors && !default_vcols_fallback) {
    vc.clear();
  }

  if (greatest_v_idx >= static_cast<int>(v.size() / 3)) {
    if (warn) {
      std::stringstream ss;
      ss << "Vertex indices out of bounds (line " << line_num << ".)\n"
         << std::endl;
      (*warn) += ss.str();
    }
  }
  if (greatest_vn_idx >= static_cast<int>(vn.size() / 3)) {
    if (warn) {
      std::stringstream ss;
      ss << "Vertex normal indices out of bounds (line " << line_num << ".)\n"
         << std::endl;
      (*warn) += ss.str();
    }
  }
  if (greatest_vt_idx >= static_cast<int>(vt.size() / 2)) {
    if (warn) {
      std::stringstream ss;
      ss << "Vertex texcoord indices out of bounds (line " << line_num << ".)\n"
         << std::endl;
      (*warn) += ss.str();
    }
  }

  bool ret = exportGroupsToShape(&shape, prim_group, tags, material, name,
                                 triangulate, v);
  // exportGroupsToShape return false when `usemtl` is called in the last
  // line.
  // we also add `shape` to `shapes` when `shape.mesh` has already some
  // faces(indices)
  if (ret || shape.mesh.indices
                 .size()) {  // FIXME(syoyo): Support other prims(e.g. lines)
    shapes->push_back(shape);
  }
  prim_group.clear();  // for safety

  if (err) {
    (*err) += errss.str();
  }

  attrib->vertices.swap(v);
  attrib->vertex_weights.swap(v);
  attrib->normals.swap(vn);
  attrib->texcoords.swap(vt);
  attrib->texcoord_ws.swap(vt);
  attrib->colors.swap(vc);
  attrib->skin_weights.swap(vw);

  return true;
}

bool LoadObjWithCallback(std::istream &inStream, const callback_t &callback,
                         void *user_data /*= NULL*/,
                         MaterialReader *readMatFn /*= NULL*/,
                         std::string *warn, /* = NULL*/
                         std::string *err /*= NULL*/) {
  std::stringstream errss;

  // material
  std::map<std::string, int> material_map;
  int material_id = -1;  // -1 = invalid

  std::vector<index_t> indices;
  std::vector<material_t> materials;
  std::vector<std::string> names;
  names.reserve(2);
  std::vector<const char *> names_out;

  std::string linebuf;
  while (inStream.peek() != -1) {
    safeGetline(inStream, linebuf);

    // Trim newline '\r\n' or '\n'
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\n')
        linebuf.erase(linebuf.size() - 1);
    }
    if (linebuf.size() > 0) {
      if (linebuf[linebuf.size() - 1] == '\r')
        linebuf.erase(linebuf.size() - 1);
    }

    // Skip if empty line.
    if (linebuf.empty()) {
      continue;
    }

    // Skip leading space.
    const char *token = linebuf.c_str();
    token += strspn(token, " \t");

    assert(token);
    if (token[0] == '\0') continue;  // empty line

    if (token[0] == '#') continue;  // comment line

    // vertex
    if (token[0] == 'v' && IS_SPACE((token[1]))) {
      token += 2;
      // TODO(syoyo): Support parsing vertex color extension.
      real_t x, y, z, w;  // w is optional. default = 1.0
      parseV(&x, &y, &z, &w, &token);
      if (callback.vertex_cb) {
        callback.vertex_cb(user_data, x, y, z, w);
      }
      continue;
    }

    // normal
    if (token[0] == 'v' && token[1] == 'n' && IS_SPACE((token[2]))) {
      token += 3;
      real_t x, y, z;
      parseReal3(&x, &y, &z, &token);
      if (callback.normal_cb) {
        callback.normal_cb(user_data, x, y, z);
      }
      continue;
    }

    // texcoord
    if (token[0] == 'v' && token[1] == 't' && IS_SPACE((token[2]))) {
      token += 3;
      real_t x, y, z;  // y and z are optional. default = 0.0
      parseReal3(&x, &y, &z, &token);
      if (callback.texcoord_cb) {
        callback.texcoord_cb(user_data, x, y, z);
      }
      continue;
    }

    // face
    if (token[0] == 'f' && IS_SPACE((token[1]))) {
      token += 2;
      token += strspn(token, " \t");

      indices.clear();
      while (!IS_NEW_LINE(token[0])) {
        vertex_index_t vi = parseRawTriple(&token);

        index_t idx;
        idx.vertex_index = vi.v_idx;
        idx.normal_index = vi.vn_idx;
        idx.texcoord_index = vi.vt_idx;

        indices.push_back(idx);
        size_t n = strspn(token, " \t\r");
        token += n;
      }

      if (callback.index_cb && indices.size() > 0) {
        callback.index_cb(user_data, &indices.at(0),
                          static_cast<int>(indices.size()));
      }

      continue;
    }

    // use mtl
    if ((0 == strncmp(token, "usemtl", 6)) && IS_SPACE((token[6]))) {
      token += 7;
      std::stringstream ss;
      ss << token;
      std::string namebuf = ss.str();

      int newMaterialId = -1;
      std::map<std::string, int>::const_iterator it = material_map.find(namebuf);
      if (it != material_map.end()) {
        newMaterialId = it->second;
      } else {
        // { warn!! material not found }
        if (warn && (!callback.usemtl_cb)) {
          (*warn) += "material [ " + namebuf + " ] not found in .mtl\n";
        }
      }

      if (newMaterialId != material_id) {
        material_id = newMaterialId;
      }

      if (callback.usemtl_cb) {
        callback.usemtl_cb(user_data, namebuf.c_str(), material_id);
      }

      continue;
    }

    // load mtl
    if ((0 == strncmp(token, "mtllib", 6)) && IS_SPACE((token[6]))) {
      if (readMatFn) {
        token += 7;

        std::vector<std::string> filenames;
        SplitString(std::string(token), ' ', '\\', filenames);

        if (filenames.empty()) {
          if (warn) {
            (*warn) +=
                "Looks like empty filename for mtllib. Use default "
                "material. \n";
          }
        } else {
          bool found = false;
          for (size_t s = 0; s < filenames.size(); s++) {
            std::string warn_mtl;
            std::string err_mtl;
            bool ok = (*readMatFn)(filenames[s].c_str(), &materials,
                                   &material_map, &warn_mtl, &err_mtl);

            if (warn && (!warn_mtl.empty())) {
              (*warn) += warn_mtl;  // This should be warn message.
            }

            if (err && (!err_mtl.empty())) {
              (*err) += err_mtl;
            }

            if (ok) {
              found = true;
              break;
            }
          }

          if (!found) {
            if (warn) {
              (*warn) +=
                  "Failed to load material file(s). Use default "
                  "material.\n";
            }
          } else {
            if (callback.mtllib_cb) {
              callback.mtllib_cb(user_data, &materials.at(0),
                                 static_cast<int>(materials.size()));
            }
          }
        }
      }

      continue;
    }

    // group name
    if (token[0] == 'g' && IS_SPACE((token[1]))) {
      names.clear();

      while (!IS_NEW_LINE(token[0])) {
        std::string str = parseString(&token);
        names.push_back(str);
        token += strspn(token, " \t\r");  // skip tag
      }

      assert(names.size() > 0);

      if (callback.group_cb) {
        if (names.size() > 1) {
          // create const char* array.
          names_out.resize(names.size() - 1);
          for (size_t j = 0; j < names_out.size(); j++) {
            names_out[j] = names[j + 1].c_str();
          }
          callback.group_cb(user_data, &names_out.at(0),
                            static_cast<int>(names_out.size()));

        } else {
          callback.group_cb(user_data, NULL, 0);
        }
      }

      continue;
    }

    // object name
    if (token[0] == 'o' && IS_SPACE((token[1]))) {
      // @todo { multiple object name? }
      token += 2;

      std::stringstream ss;
      ss << token;
      std::string object_name = ss.str();

      if (callback.object_cb) {
        callback.object_cb(user_data, object_name.c_str());
      }

      continue;
    }

#if 0  // @todo
    if (token[0] == 't' && IS_SPACE(token[1])) {
      tag_t tag;

      token += 2;
      std::stringstream ss;
      ss << token;
      tag.name = ss.str();

      token += tag.name.size() + 1;

      tag_sizes ts = parseTagTriple(&token);

      tag.intValues.resize(static_cast<size_t>(ts.num_ints));

      for (size_t i = 0; i < static_cast<size_t>(ts.num_ints); ++i) {
        tag.intValues[i] = atoi(token);
        token += strcspn(token, "/ \t\r") + 1;
      }

      tag.floatValues.resize(static_cast<size_t>(ts.num_reals));
      for (size_t i = 0; i < static_cast<size_t>(ts.num_reals); ++i) {
        tag.floatValues[i] = parseReal(&token);
        token += strcspn(token, "/ \t\r") + 1;
      }

      tag.stringValues.resize(static_cast<size_t>(ts.num_strings));
      for (size_t i = 0; i < static_cast<size_t>(ts.num_strings); ++i) {
        std::stringstream ss;
        ss << token;
        tag.stringValues[i] = ss.str();
        token += tag.stringValues[i].size() + 1;
      }

      tags.push_back(tag);
    }
#endif

    // Ignore unknown command.
  }

  if (err) {
    (*err) += errss.str();
  }

  return true;
}

bool ObjReader::ParseFromFile(const std::string &filename,
                              const ObjReaderConfig &config) {
  std::string mtl_search_path;

  if (config.mtl_search_path.empty()) {
    //
    // split at last '/'(for unixish system) or '\\'(for windows) to get
    // the base directory of .obj file
    //
    size_t pos = filename.find_last_of("/\\");
    if (pos != std::string::npos) {
      mtl_search_path = filename.substr(0, pos);
    }
  } else {
    mtl_search_path = config.mtl_search_path;
  }

  valid_ = LoadObj(&attrib_, &shapes_, &materials_, &warning_, &error_,
                   filename.c_str(), mtl_search_path.c_str(),
                   config.triangulate, config.vertex_color);

  return valid_;
}

bool ObjReader::ParseFromString(const std::string &obj_text,
                                const std::string &mtl_text,
                                const ObjReaderConfig &config) {
  std::stringbuf obj_buf(obj_text);
  std::stringbuf mtl_buf(mtl_text);

  std::istream obj_ifs(&obj_buf);
  std::istream mtl_ifs(&mtl_buf);

  MaterialStreamReader mtl_ss(mtl_ifs);

  valid_ = LoadObj(&attrib_, &shapes_, &materials_, &warning_, &error_,
                   &obj_ifs, &mtl_ss, config.triangulate, config.vertex_color);

  return valid_;
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif
}  // namespace tinyobj

#endif

```

`Modules/TinyOBJ/Public/Toon/TinyOBJ/TinyOBJConfig.hpp`:

```hpp
#ifndef TOON_TINYOBJ_CONFIG_HPP
#define TOON_TINYOBJ_CONFIG_HPP

#include <Toon/Config.hpp>

#if defined(TOON_TINYOBJ_EXPORT)
    #define TOON_TINYOBJ_API TOON_API_EXPORT
#else
    #define TOON_TINYOBJ_API TOON_API_IMPORT
#endif

#endif // TOON_TINYOBJ_CONFIG_HPP
```

`Modules/TinyOBJ/Public/Toon/TinyOBJ/TinyOBJMeshImporter.hpp`:

```hpp
#ifndef TOON_TINYOBJ_MESH_IMPORTER_HPP
#define TOON_TINYOBJ_MESH_IMPORTER_HPP

#include <Toon/TinyOBJ/TinyOBJConfig.hpp>

#include <Toon/MeshImporter.hpp>

#include <vector>

namespace Toon::TinyOBJ {

class TOON_TINYOBJ_API TinyOBJMeshImporter : public MeshImporter
{
public:

    DISALLOW_COPY_AND_ASSIGN(TinyOBJMeshImporter)

    TinyOBJMeshImporter() = default;

    std::vector<std::unique_ptr<PrimitiveData>> LoadFromFile(const std::string& filename, bool useAssetPath = true) override;
    
}; // class TinyOBJMeshImporter

} // namespace Toon::TinyOBJ

#endif // TOON_TINYOBJ_MESH_IMPORTER_HPP
```

`Modules/TinyOBJ/Public/Toon/TinyOBJ/TinyOBJPrimitiveData.hpp`:

```hpp
#ifndef TOON_TINYOBJ_PRIMITIVE_DATA_HPP
#define TOON_TINYOBJ_PRIMITIVE_DATA_HPP

#include <Toon/TinyOBJ/TinyOBJConfig.hpp>

#include <Toon/PrimitiveData.hpp>

namespace Toon::TinyOBJ {

class TOON_TINYOBJ_API TinyOBJPrimitiveData : public PrimitiveData
{
public:

    std::vector<Vertex> VertexList;

    PrimitiveTopology GetTopology() const override {
        return PrimitiveTopology::TriangleList;
    }

    gsl::span<Vertex> GetVertexList() override {
        return VertexList;
    }

}; // class TinyOBJPrimitiveData

} // namespace Toon::TinyOBJ

#endif // TOON_TINYOBJ_PRIMITIVE_DATA_HPP
```

`Modules/Vulkan/CMakeLists.txt`:

```txt

SET(_target ToonVulkan)

DEFINE_MODULE(${_target} VULKAN)

TARGET_LINK_LIBRARIES(
    ${_target}
    PUBLIC
        ToonSDL2
)
```

`Modules/Vulkan/Private/VulkanBuffer.cpp`:

```cpp
#include <Toon/Vulkan/VulkanBuffer.hpp>
#include <Toon/Vulkan/VulkanGraphicsDriver.hpp>

namespace Toon::Vulkan {

TOON_VULKAN_API
bool VulkanBuffer::Initialize(size_t size, uint8_t * data, BufferUsage bufferUsage, MemoryUsage memoryUsage)
{
    bool result;
    VkResult vkResult;

    _bufferUsage = bufferUsage;
    _memoryUsage = memoryUsage;
    _size = static_cast<VkDeviceSize>(size);

    if (!data && _memoryUsage == MemoryUsage::GPU) {
        ToonLogError("Attempting to create an empty buffer with MemoryUsage GPU");
        return false;
    }

    VulkanGraphicsDriver * gfx = TOON_VULKAN_GRAPHICS_DRIVER(GetGraphicsDriver());

    auto vkBufferUsage = GetVkBufferUsage(_bufferUsage);
    auto vkMemoryUsage = GetVkMemoryUsage(_memoryUsage);

    if (!vkBufferUsage || !vkMemoryUsage) {
        return false;
    }

    // If we are uploading to a GPU only buffer, use a staging buffer
    if (_memoryUsage == MemoryUsage::GPU) {
        VkBufferCreateInfo stagingBufferCreateInfo = {
            .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            .pNext = nullptr,
            .flags = 0,
            .size = _size,
            .usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
            .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
        };

        VmaAllocationCreateInfo stagingAllocationCreateInfo = {
            .flags = VMA_ALLOCATION_CREATE_MAPPED_BIT,
            .usage = VMA_MEMORY_USAGE_CPU_ONLY,
        };

        VkBuffer stagingBuffer;
        VmaAllocation stagingAllocation;
        VmaAllocationInfo stagingAllocationInfo;
        
        vkResult = vmaCreateBuffer(
            gfx->GetAllocator(),
            &stagingBufferCreateInfo,
            &stagingAllocationCreateInfo,
            &stagingBuffer,
            &stagingAllocation,
            &stagingAllocationInfo
        );

        if (vkResult != VK_SUCCESS) {
            ToonLogError("vmaCreateBuffer() failed, unable to create staging buffer");
            return false;
        }

        memcpy(stagingAllocationInfo.pMappedData, data, _size);

        VkBufferUsageFlags bufferUsageFlags = VK_BUFFER_USAGE_TRANSFER_DST_BIT | vkBufferUsage.value();

        VkBufferCreateInfo bufferCreateInfo = {
            .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            .pNext = nullptr,
            .flags = 0,
            .size = _size,
            .usage = bufferUsageFlags,
            .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
        };

        VmaAllocationCreateInfo allocationCreateInfo = {
            .flags = 0,
            .usage = vkMemoryUsage.value(),
        };

        vkResult = vmaCreateBuffer(
            gfx->GetAllocator(),
            &bufferCreateInfo,
            &allocationCreateInfo,
            &_vkBuffer,
            &_vmaAllocation,
            nullptr
        );
            
        if (vkResult != VK_SUCCESS) {
            ToonLogError("vmaCreateBuffer() failed, unable to create buffer");
            return false;
        }

        result = gfx->CopyBuffer(stagingBuffer, _vkBuffer, _size);

        if (!result) {
            ToonLogError("CopyBuffer() failed, unable to copy staging buffer to buffer");
        }

        vkDestroyBuffer(gfx->GetDevice(), stagingBuffer, nullptr);
        vmaFreeMemory(gfx->GetAllocator(), stagingAllocation);
    }
    else {

        VkBufferUsageFlags bufferUsageFlags = vkBufferUsage.value();

        VkBufferCreateInfo bufferCreateInfo = {
            .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            .pNext = nullptr,
            .flags = 0,
            .size = _size,
            .usage = bufferUsageFlags,
            .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
        };

        VmaAllocationCreateInfo allocationCreateInfo = {
            .flags = VMA_ALLOCATION_CREATE_MAPPED_BIT,
            .usage = vkMemoryUsage.value(),
        };

        VmaAllocationInfo allocationInfo;

        vkResult = vmaCreateBuffer(
            gfx->GetAllocator(),
            &bufferCreateInfo,
            &allocationCreateInfo,
            &_vkBuffer,
            &_vmaAllocation,
            &allocationInfo
        );
            
        if (vkResult != VK_SUCCESS) {
            ToonLogError("CreateBuffer() failed, unable to create buffer");
            return false;
        }

        _mappedBufferMemory = allocationInfo.pMappedData;

        bool upload = (_memoryUsage == MemoryUsage::UploadOnce || _memoryUsage == MemoryUsage::UploadOften);

        if (data && upload) {
            memcpy(_mappedBufferMemory, data, _size);
        }
    }

    return true;
}

TOON_VULKAN_API
void VulkanBuffer::Terminate()
{
    VulkanGraphicsDriver * gfx = TOON_VULKAN_GRAPHICS_DRIVER(GetGraphicsDriver());

    if (_vkBuffer) {
        vkDestroyBuffer(gfx->GetDevice(), _vkBuffer, nullptr);
        _vkBuffer = nullptr;
    }

    if (_vmaAllocation) {
        if (_mappedBufferMemory) {
            vmaUnmapMemory(gfx->GetAllocator(), _vmaAllocation);
            _mappedBufferMemory = nullptr;
        }

        vmaFreeMemory(gfx->GetAllocator(), _vmaAllocation);
        _vmaAllocation = nullptr;
    }
}

} // namespace Toon::Vulkan
```

`Modules/Vulkan/Private/VulkanGraphicsDriver.cpp`:

```cpp
#include <Toon/Vulkan/VulkanGraphicsDriver.hpp>

#include <Toon/Toon.hpp>
#include <Toon/Log.hpp>
#include <Toon/Benchmark.hpp>
#include <Toon/MeshImporter.hpp>
#include <Toon/Camera.hpp>
#include <Toon/Scene.hpp>

#include <algorithm>
#include <set>

DISABLE_WARNINGS()

    #define VMA_IMPLEMENTATION
    #include <vk_mem_alloc.h>

ENABLE_WARNINGS()

namespace Toon::Vulkan {

TOON_VULKAN_API
bool VulkanGraphicsDriver::Initialize()
{
    ToonBenchmarkStart();

    SDL2GraphicsDriver::Initialize();
    
    SDL2GraphicsDriver::CreateWindow(SDL_WINDOW_VULKAN);

    if (!InitInstance()) {
        return false;
    }

    #if defined(TOON_BUILD_DEBUG)

        if (!InitDebugUtilsMessenger()) {
            ToonLogWarn("Failed to initialize Vulkan Debug Utils Messenger");
        }

    #endif

    if (!InitSurface()) {
        return false;
    }

    if (!InitPhysicalDevice()) {
        return false;
    }

    if (!InitLogicalDevice()) {
        return false;
    }

    if (!InitAllocator()) {
        return false;
    }

    InitializeUpdateContext();
    InitializeRenderContext();

    if (!InitializeConstantBuffers()) {
        return false;
    }

    if (!InitializeDefaults()) {
        return false;
    }
    
    if (!InitSwapChain()) {
        return false;
    }

    if (!InitSyncObjects()) {
        return false;
    }

    VmaStats stats;
    vmaCalculateStats(_vmaAllocator, &stats);
    
    ToonLogVerbose("Allocated Memory Blocks: %u", stats.total.blockCount);
    ToonLogVerbose("Allocation Objects: %u", stats.total.allocationCount);
    ToonLogVerbose("Used bytes: %u", stats.total.usedBytes);
    ToonLogVerbose("Unused bytes: %u", stats.total.unusedBytes);

    ToonBenchmarkEnd();
    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::Terminate()
{
    ToonBenchmarkStart();

    if (_vkDevice) {
        vkDeviceWaitIdle(_vkDevice);
    }

    TermSyncObjects();

    TermSwapChain();

    for (auto& primitive : _primitiveList) {
        primitive->Terminate();
    }

    _primitiveList.clear();

    // TODO: Move
    if (_shaderGlobalsBuffer) {
        _shaderGlobalsBuffer->Terminate();
    }

    for (auto& shader : _shaderList) {
        shader->Terminate();
    }

    _shaderList.clear();

    TermAllocator();
    TermLogicalDevice();
    TermSurface();

    #if defined(TOON_BUILD_DEBUG)

        TermDebugUtilsMessenger();

    #endif

    TermInstance();

    SDL2GraphicsDriver::Terminate();

    ToonBenchmarkEnd();
}

void VulkanGraphicsDriver::InitializeRenderContext()
{
    _renderContext.reset(new VulkanRenderContext());
    SDL2GraphicsDriver::InitializeRenderContext();
}

TOON_VULKAN_API
void VulkanGraphicsDriver::SetBackbufferCount(unsigned backbufferCount)
{
    if (backbufferCount != GetBackbufferCount()) {
        ResetSwapChain();
    }

    SDL2GraphicsDriver::SetBackbufferCount(backbufferCount);
}

TOON_VULKAN_API
void VulkanGraphicsDriver::Render()
{
    VkResult vkResult;

    SDL2GraphicsDriver::Render();

    VulkanRenderContext * vkRenderCtx = TOON_VULKAN_RENDER_CONTEXT(_renderContext.get());
    vkRenderCtx->SetVkCommandBuffer(nullptr);
    
    Scene * scene = GetCurrentScene();
    if (scene) {
        scene->Render(_renderContext.get());
    }

    vmaSetCurrentFrameIndex(_vmaAllocator, _currentFrame);

    vkWaitForFences(_vkDevice, 1, &_vkInFlightFences[_currentFrame], VK_TRUE, UINT64_MAX);

    uint32_t imageIndex = 0;
    vkResult = vkAcquireNextImageKHR(_vkDevice, _vkSwapChain, UINT64_MAX, _vkImageAvailableSemaphores[_currentFrame], VK_NULL_HANDLE, &imageIndex);
    if (vkResult == VK_ERROR_OUT_OF_DATE_KHR) {
        if (!ResetSwapChain()) {
            ToonLogFatal("Failed to resize swap chain");
        }
    }
    else if (vkResult != VK_SUCCESS && vkResult != VK_SUBOPTIMAL_KHR) {
        ToonLogFatal("vkAcquireNextImageKHR() failed");
    }

    if (_vkImagesInFlight[imageIndex] != VK_NULL_HANDLE) {
        vkWaitForFences(_vkDevice, 1, &_vkImagesInFlight[imageIndex], VK_TRUE, UINT64_MAX);
    }
    _vkImagesInFlight[imageIndex] = _vkInFlightFences[_currentFrame];

    // "Present Complete"
    VkSemaphore waitSemaphores[] = { _vkImageAvailableSemaphores[_currentFrame] };
    VkPipelineStageFlags waitStages[] = { VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT };

    // "Render Complete"
    VkSemaphore signalSemaphores[] = { _vkRenderingFinishedSemaphores[_currentFrame] };

    VkSubmitInfo submitInfo = {
        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
        .pNext = nullptr,
        .waitSemaphoreCount = 1,
        .pWaitSemaphores = waitSemaphores,
        .pWaitDstStageMask = waitStages,
        .commandBufferCount = 1,
        .pCommandBuffers = &_vkCommandBuffers[imageIndex],
        .signalSemaphoreCount = 1,
        .pSignalSemaphores = signalSemaphores,
    };

    vkResetFences(_vkDevice, 1, &_vkInFlightFences[_currentFrame]);

    vkResult = vkQueueSubmit(_vkGraphicsQueue, 1, &submitInfo, _vkInFlightFences[_currentFrame]);
    if (vkResult != VK_SUCCESS) {
        ToonLogFatal("vkQueueSubmit() failed");
    }

    VkSwapchainKHR swapChains[] = { _vkSwapChain };

    VkPresentInfoKHR presentInfo = {
        .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
        .pNext = 0,
        .waitSemaphoreCount = 1,
        .pWaitSemaphores = signalSemaphores,
        .swapchainCount = 1,
        .pSwapchains = swapChains,
        .pImageIndices = &imageIndex,
    };

    vkResult = vkQueuePresentKHR(_vkPresentQueue, &presentInfo);

    if (vkResult == VK_ERROR_OUT_OF_DATE_KHR || vkResult == VK_SUBOPTIMAL_KHR) {
        if (!ResetSwapChain()) {
            ToonLogFatal("Failed to resize swap chain");
        }
    }
    else if (vkResult != VK_SUCCESS) {
        ToonLogFatal("vkQueuePresentKHR() failed");
    }

    _currentFrame = (_currentFrame + 1) % GetBackbufferCount();
}

TOON_VULKAN_API
std::shared_ptr<Buffer> VulkanGraphicsDriver::CreateBuffer()
{
    return std::shared_ptr<Buffer>(new VulkanBuffer());
}


TOON_VULKAN_API
std::shared_ptr<Pipeline> VulkanGraphicsDriver::CreatePipeline(std::shared_ptr<Shader> shader)
{
    auto ptr = std::shared_ptr<Pipeline>(new VulkanPipeline());
    ptr->Initialize(shader);
    _pipelineList.push_back(ptr);
    return ptr;
}

TOON_VULKAN_API
std::shared_ptr<Texture> VulkanGraphicsDriver::CreateTexture()
{
    return std::shared_ptr<Texture>(new VulkanTexture());
}

TOON_VULKAN_API
std::shared_ptr<Shader> VulkanGraphicsDriver::CreateShader()
{
    auto ptr = std::shared_ptr<Shader>(new VulkanShader());
    // ptr->Initialize();
    _shaderList.push_back(ptr);
    return ptr;
}

TOON_VULKAN_API
std::shared_ptr<Mesh> VulkanGraphicsDriver::CreateMesh()
{
    auto ptr = std::shared_ptr<Mesh>(new VulkanMesh());
    ptr->Initialize();
    _meshList.push_back(ptr);

    // Reset swap chain?
    return ptr;
}

TOON_VULKAN_API
std::shared_ptr<Material> VulkanGraphicsDriver::CreateMaterial()
{
    // auto ptr = std::shared_ptr<Material>(New VulkanMaterial());
    // _primitiveList.push_back(ptr);
    // return ptr;
    return nullptr;
}

TOON_VULKAN_API
std::shared_ptr<Primitive> VulkanGraphicsDriver::CreatePrimitive()
{
    auto ptr = std::shared_ptr<Primitive>(new VulkanPrimitive());
    _primitiveList.push_back(ptr);
    return ptr;
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::CopyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)
{
    VkResult vkResult;

    VkCommandBufferAllocateInfo commandBufferAllocateInfo = {
        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        .pNext = nullptr,
        .commandPool = _vkCommandPool,
        .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        .commandBufferCount = 1,
    };

    VkCommandBuffer commandBuffer;
    vkResult = vkAllocateCommandBuffers(_vkDevice, &commandBufferAllocateInfo, &commandBuffer);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("Failed to allocate command buffer");
        return false;
    }

    VkCommandBufferBeginInfo commandBufferBeginInfo = {
        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
    };

    vkBeginCommandBuffer(commandBuffer, &commandBufferBeginInfo);

    VkBufferCopy copyRegion = {
        .srcOffset = 0,
        .dstOffset = 0,
        .size = size,
    };

    vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

    vkResult = vkEndCommandBuffer(commandBuffer);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("Failed to build command buffer");
        return false;
    }

    VkSubmitInfo submitInfo = {
        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
        .pNext = nullptr,
        .commandBufferCount = 1,
        .pCommandBuffers = &commandBuffer,
    };

    vkResult = vkQueueSubmit(_vkGraphicsQueue, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(_vkGraphicsQueue);

    vkFreeCommandBuffers(_vkDevice, _vkCommandPool, 1, &commandBuffer);

    return true;
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::CreateDescriptorSet(VkDescriptorSet * descriptorSet)
{
    VkResult vkResult;

    VkDescriptorSetLayout setLayouts[] = { _vkDescriptorSetLayout };

    VkDescriptorSetAllocateInfo allocateInfo = {
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
        .pNext = nullptr,
        .descriptorPool = _vkDescriptorPool,
        .descriptorSetCount = 1,
        .pSetLayouts = setLayouts,
    };

    vkResult = vkAllocateDescriptorSets(_vkDevice, &allocateInfo, descriptorSet);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkAllocateDescriptorSets() failed");
        return false;
    }

    VulkanBuffer * vkShaderGlobalsBuffer = TOON_VULKAN_BUFFER(GetShaderGlobalsBuffer().get());

    VkDescriptorBufferInfo bufferInfo = {
        .buffer = vkShaderGlobalsBuffer->GetVkBuffer(),
        .offset = 0,
        .range = VK_WHOLE_SIZE,
    };

    VkWriteDescriptorSet writeDescriptorSet = {
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        .dstSet = *descriptorSet,
        .dstBinding = TOON_SHADER_GLOBALS_BINDING,
        .dstArrayElement = 0,
        .descriptorCount = 1,
        .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        .pBufferInfo = &bufferInfo,
    };

    vkUpdateDescriptorSets(_vkDevice, 1, &writeDescriptorSet, 0, nullptr);

    return true;
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::IsDeviceSuitable(const VkPhysicalDevice device)
{
    vkGetPhysicalDeviceProperties(device, &_vkPhysicalDeviceProperties);
    vkGetPhysicalDeviceFeatures(device, &_vkPhysicalDeviceFeatures);

    // TODO:
    // * Queue Families
    // * Device Extensions
    // * Swap Chain Support

    return _vkPhysicalDeviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU 
        && _vkPhysicalDeviceFeatures.geometryShader;
}

TOON_VULKAN_API
std::vector<const char *> VulkanGraphicsDriver::GetRequiredLayers()
{
    std::vector<const char *> requiredLayers = { };

    #if defined(TOON_BUILD_DEBUG)

        auto it = _vkAvailableLayers.find("VK_LAYER_KHRONOS_validation");
        if (it != _vkAvailableLayers.end()) {
            requiredLayers.push_back("VK_LAYER_KHRONOS_validation");
        }

    #endif

    return requiredLayers;
}

TOON_VULKAN_API
std::vector<const char *> VulkanGraphicsDriver::GetRequiredDeviceExtensions()
{
    std::vector<const char *> requiredExtensions = {
        VK_KHR_SWAPCHAIN_EXTENSION_NAME,
    };

    auto it = _vkAvailableDeviceExtensions.find(VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);
    if (it != _vkAvailableDeviceExtensions.end()) {
        requiredExtensions.push_back(VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);
    }

    it = _vkAvailableDeviceExtensions.find(VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME);
    if (it != _vkAvailableDeviceExtensions.end()) {
        requiredExtensions.push_back(VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME);
    }

    it = _vkAvailableDeviceExtensions.find(VK_KHR_BIND_MEMORY_2_EXTENSION_NAME);
    if (it != _vkAvailableDeviceExtensions.end()) {
        requiredExtensions.push_back(VK_KHR_BIND_MEMORY_2_EXTENSION_NAME);
    }

    it = _vkAvailableDeviceExtensions.find(VK_EXT_MEMORY_BUDGET_EXTENSION_NAME);
    if (it != _vkAvailableDeviceExtensions.end()) {
        requiredExtensions.push_back(VK_EXT_MEMORY_BUDGET_EXTENSION_NAME);
    }

    return requiredExtensions;
}

TOON_VULKAN_API
std::vector<const char *> VulkanGraphicsDriver::GetRequiredInstanceExtensions()
{
    SDL_bool sdlResult;

    uint32_t requiredExtensionCount;
    SDL_Vulkan_GetInstanceExtensions(GetSDL2Window(), &requiredExtensionCount, nullptr);

    std::vector<const char *> requiredExtensions(requiredExtensionCount);
    sdlResult = SDL_Vulkan_GetInstanceExtensions(GetSDL2Window(), &requiredExtensionCount, requiredExtensions.data());
    if (!sdlResult) {
        ToonLogError("SDL_Vulkan_GetInstanceExtensions() failed, %s", SDL_GetError());
        return std::vector<const char *>();
    }

    #if defined(TOON_BUILD_DEBUG)

        auto it = _vkAvailableInstanceExtensions.find(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
        if (it != _vkAvailableInstanceExtensions.end()) {
            requiredExtensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
        }
        else {
            ToonLogWarn("Vulkan Extension '%s' not available", VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
        }

    #endif

    return requiredExtensions;
}

static VKAPI_ATTR VkBool32 VKAPI_CALL _VulkanDebugMessageCallback(
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageType,
    const VkDebugUtilsMessengerCallbackDataEXT * callbackData,
    void * userData)
{
    // if (callbackData->messageIdNumber == 0) { // Loader Message
    //     return VK_FALSE;
    // }

    LogLevel level = LogLevel::Info;

    if ((messageType & VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) > 0) {
        level = LogLevel::Performance;
    }
    else {
        if ((messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) > 0) {
            level = LogLevel::Error;
        }
        else if ((messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) > 0) {
            level = LogLevel::Warning;
        }
        else if ((messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT) > 0) {
            level = LogLevel::Info;
        }
        else if ((messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) > 0) {
            level = LogLevel::Verbose;

            /*if (!IsVerboseLoggingEnabled()) {
                return VK_FALSE;
            }*/
        }
    }

    const char * prefix;

    switch (level) {
    case LogLevel::Error:
        prefix = "ERRO";
        break;
    case LogLevel::Warning:
        prefix = "WARN";
        break;
    case LogLevel::Info:
        prefix = "INFO";
        break;
    case LogLevel::Performance:
        prefix = "PERF";
        break;
    case LogLevel::Verbose:
        prefix = "VERB";
        break;
    default: ;
    }

    Log(level, "[%s](VkDebugUtilsMessenger) %s %s\n", 
        prefix, 
        callbackData->pMessageIdName, 
        callbackData->pMessage);

    if (callbackData->objectCount > 0) {
        for (uint32_t i = 0; i < callbackData->objectCount; ++i) {
            const char * name = callbackData->pObjects[i].pObjectName;
            if (name) {
                Log(level, "\t\tObject #%d: Type %d, Value %p, Name '%s'\n",
                    i,
                    callbackData->pObjects[i].objectType,
                    callbackData->pObjects[i].objectHandle,
                    callbackData->pObjects[i].pObjectName);
            }
        }
    }

    if (callbackData->cmdBufLabelCount > 0) {
        for (uint32_t i = 0; i < callbackData->cmdBufLabelCount; ++i) {
            const char * name = callbackData->pCmdBufLabels[i].pLabelName;
            if (name) {
                Log(level, "\t\tLabel #%d: %s\n", name);
            }
        }
    }

    return VK_FALSE;
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitInstance()
{
    VkResult vkResult;

    int vkVersion = gladLoaderLoadVulkan(nullptr, nullptr, nullptr);
    if (vkVersion == 0) {
        ToonLogError("gladLoaderLoadVulkan() failed");
        return false;
    }
    
    ToonLogVerbose("Vulkan %d.%d", GLAD_VERSION_MAJOR(vkVersion), GLAD_VERSION_MINOR(vkVersion));

    uint32_t availableLayerCount = 0;
    vkEnumerateInstanceLayerProperties(&availableLayerCount, nullptr);

    if (availableLayerCount == 0) {
        ToonLogError("vkEnumerateInstanceLayerProperties() failed, no available layers");
        return false;
    }

    std::vector<VkLayerProperties> availableLayers(availableLayerCount);
    vkResult = vkEnumerateInstanceLayerProperties(&availableLayerCount, availableLayers.data());
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkEnumerateInstanceLayerProperties() failed");
        return false;
    }

    ToonLogVerbose("Available Vulkan Layers:");
    for (const auto& layer : availableLayers) {
        ToonLogVerbose("\t%s: %s", layer.layerName, layer.description);
        _vkAvailableLayers.emplace(layer.layerName, layer);
    }

    const auto& requiredLayers = GetRequiredLayers();

    ToonLogVerbose("Required Vulkan Device Layers:");
    for (const auto& layer : requiredLayers) {
        ToonLogVerbose("\t%s", layer);
    }

    uint32_t availableExtensionCount = 0;
    vkEnumerateInstanceExtensionProperties(nullptr, &availableExtensionCount, nullptr);

    if (availableExtensionCount == 0) {
        ToonLogError("vkEnumerateInstanceExtensionProperties() failed, no extensions available");
        return false;
    }

    std::vector<VkExtensionProperties> availableExtensions(availableExtensionCount);
    vkResult = vkEnumerateInstanceExtensionProperties(nullptr, &availableExtensionCount, availableExtensions.data());
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkEnumerateInstanceExtensionProperties() failed");
        return false;
    }

    ToonLogVerbose("Available Vulkan Instance Extensions:");
    for (const auto& extension : availableExtensions) {
        ToonLogVerbose("\t%s", extension.extensionName);
        _vkAvailableInstanceExtensions.emplace(extension.extensionName, extension);
    }

    const auto& requiredExtensions = GetRequiredInstanceExtensions();
    if (requiredExtensions.empty()) {
        ToonLogError("Failed to get Required Instance Extensions");
        return false;
    }

    ToonLogVerbose("Required Vulkan Instance Extensions:");
    for (const auto& extension : requiredExtensions) {
        ToonLogVerbose("\t%s", extension);
    }

    const auto& engineVersion = GetVersion();
    const auto& appVersion = GetApplicationVersion();
    const auto& appName = GetApplicationName();

    VkApplicationInfo applicationInfo = {
        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
        .pNext = nullptr,
        .pApplicationName = appName.c_str(),
        .applicationVersion = VK_MAKE_VERSION(
            appVersion.Major,
            appVersion.Minor,
            appVersion.Patch
        ),
        .pEngineName = "Toon",
        .engineVersion = VK_MAKE_VERSION(
            engineVersion.Major,
            engineVersion.Minor,
            engineVersion.Patch
        ),
        .apiVersion = VK_API_VERSION_1_1,
    };


    VkInstanceCreateInfo instanceCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .pApplicationInfo = &applicationInfo,
        .enabledLayerCount = static_cast<uint32_t>(requiredLayers.size()),
        .ppEnabledLayerNames = requiredLayers.data(),
        .enabledExtensionCount = static_cast<uint32_t>(requiredExtensions.size()),
        .ppEnabledExtensionNames = requiredExtensions.data(),
    };

    VkDebugUtilsMessengerCreateInfoEXT debugUtilsMessengerCreateInfo;

    auto it = _vkAvailableLayers.find("VK_LAYER_KHRONOS_validation");
    if (it != _vkAvailableLayers.end()) {
        VkDebugUtilsMessageSeverityFlagsEXT messageSeverity = 
            VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT |
            VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
            VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT;

        #if defined(TOON_BUILD_DEBUG)
            messageSeverity |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
        #endif

        VkDebugUtilsMessageTypeFlagsEXT messageType =
            VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | 
            VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | 
            VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;

        debugUtilsMessengerCreateInfo = {
            .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = 0,
            .messageSeverity = messageSeverity,
            .messageType = messageType,
            .pfnUserCallback = _VulkanDebugMessageCallback,
            .pUserData = nullptr,
        };

        instanceCreateInfo.pNext = &debugUtilsMessengerCreateInfo;
    }

    vkResult = vkCreateInstance(&instanceCreateInfo, nullptr, &_vkInstance);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkCreateInstance() failed");
        return false;
    }

    // Reload glad to load instance pointers and populate available extensions
    vkVersion = gladLoaderLoadVulkan(_vkInstance, nullptr, nullptr);
    if (vkVersion == 0) {
        ToonLogError("gladLoaderLoadVulkan() failed, unable to reload symbols with VkInstance");
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermInstance()
{
    if (!_vkInstance) {
        vkDestroyInstance(_vkInstance, nullptr);
        _vkInstance = nullptr;
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitDebugUtilsMessenger()
{
    VkResult vkResult;

    auto it = _vkAvailableLayers.find("VK_LAYER_KHRONOS_validation");
    if (it == _vkAvailableLayers.end()) {
        ToonLogWarn("Unable to find VK_LAYER_KHRONOS_validation");
        return false;
    }

    VkDebugUtilsMessageSeverityFlagsEXT messageSeverity = 
        VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT |
        VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
        VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT;

    #if defined(TOON_BUILD_DEBUG)
        messageSeverity |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
    #endif

    VkDebugUtilsMessageTypeFlagsEXT messageType =
        VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | 
        VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | 
        VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;

    VkDebugUtilsMessengerCreateInfoEXT debugUtilsMessengerCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
        .pNext = nullptr,
        .flags = 0,
        .messageSeverity = messageSeverity,
        .messageType = messageType,
        .pfnUserCallback = _VulkanDebugMessageCallback,
        .pUserData = nullptr,
    };

    if (!vkCreateDebugUtilsMessengerEXT) {
        ToonLogWarn("vkCreateDebugUtilsMessengerEXT() is not bound");
        return false;
    }

    vkResult = vkCreateDebugUtilsMessengerEXT(_vkInstance, &debugUtilsMessengerCreateInfo, nullptr, &_vkDebugMessenger);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkCreateDebugUtilsMessengerEXT() failed");
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermDebugUtilsMessenger()
{
    if (!_vkDebugMessenger) {
        return;
    }
    
    if (!vkDestroyDebugUtilsMessengerEXT) {
        ToonLogWarn("vkDestroyDebugUtilsMessengerEXT() is not bound");
        return;
    }

    vkDestroyDebugUtilsMessengerEXT(_vkInstance, _vkDebugMessenger, nullptr);
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitSurface()
{
    SDL_bool sdlResult;

    sdlResult = SDL_Vulkan_CreateSurface(GetSDL2Window(), _vkInstance, &_vkSurface);
    if (!sdlResult) {
        ToonLogError("SDL_Vulkan_CreateSurface() failed, %s", SDL_GetError());
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermSurface()
{
    if (_vkSurface) {
        vkDestroySurfaceKHR(_vkInstance, _vkSurface, nullptr);
        _vkSurface = nullptr;
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitPhysicalDevice()
{
    VkResult vkResult;

    uint32_t deviceCount = 0;
    vkEnumeratePhysicalDevices(_vkInstance, &deviceCount, nullptr);

    if (deviceCount == 0) {
        ToonLogError("vkEnumeratePhysicalDevices() failed, no devices found");
        return false;
    }

    std::vector<VkPhysicalDevice> devices(deviceCount);
    vkResult = vkEnumeratePhysicalDevices(_vkInstance, &deviceCount, devices.data());
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkEnumeratePhysicalDevices() failed");
        return false;
    }

    for (const auto& device : devices) {
        if (IsDeviceSuitable(device)) {
            _vkPhysicalDevice = device;
            break;
        }
    }

    if (_vkPhysicalDevice == VK_NULL_HANDLE) {
        ToonLogError("No suitable graphics device found");
        return false;
    }

    ToonLogVerbose("Physical Device Name: %s", _vkPhysicalDeviceProperties.deviceName);

    // Reload glad to load instance pointers and populate available extensions
    int vkVersion = gladLoaderLoadVulkan(_vkInstance, _vkPhysicalDevice, nullptr);
    if (vkVersion == 0) {
        ToonLogError("gladLoaderLoadVulkan() failed, unable to reload symbols with VkInstance and VkPhysicalDevice");
        return false;
    }

    uint32_t availableExtensionCount = 0;
    vkEnumerateDeviceExtensionProperties(_vkPhysicalDevice, nullptr, &availableExtensionCount, nullptr);

    if (availableExtensionCount == 0) {
        ToonLogError("vkEnumerateDeviceExtensionProperties() failed, no extensions available");
        return false;
    }

    std::vector<VkExtensionProperties> availableExtensions(availableExtensionCount);
    vkResult = vkEnumerateDeviceExtensionProperties(_vkPhysicalDevice, nullptr, &availableExtensionCount, availableExtensions.data());
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkEnumerateDeviceExtensionProperties() failed");
        return false;
    }

    ToonLogVerbose("Available Vulkan Device Extensions:");
    for (const auto& extension : availableExtensions) {
        ToonLogVerbose("\t%s", extension.extensionName);
        _vkAvailableDeviceExtensions.emplace(extension.extensionName, extension);
    }
    
    return true;
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitLogicalDevice()
{
    VkResult vkResult;

    uint32_t queueFamilyCount;
    vkGetPhysicalDeviceQueueFamilyProperties(_vkPhysicalDevice, &queueFamilyCount, nullptr);
    if (queueFamilyCount == 0) {
        ToonLogError("vkGetPhysicalDeviceQueueFamilyProperties(), no queues found");
        return false;
    }

    std::vector<VkQueueFamilyProperties> queueFamilyProps(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(_vkPhysicalDevice, &queueFamilyCount, queueFamilyProps.data());

    _vkGraphicsQueueFamilyIndex = UINT32_MAX;
    _vkPresentQueueFamilyIndex = UINT32_MAX;
    
    for (const auto& prop : queueFamilyProps) {
        string types;
        if (prop.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            types += "Graphics ";
        }
        if (prop.queueFlags & VK_QUEUE_COMPUTE_BIT) {
            types += "Compute ";
        }
        if (prop.queueFlags & VK_QUEUE_TRANSFER_BIT) {
            types += "Transfer ";
        }
        if (prop.queueFlags & VK_QUEUE_SPARSE_BINDING_BIT) {
            types += "SparseBinding ";
        }

        ToonLogVerbose("Queue #%d: %s", prop.queueCount, types);
    }

    uint32_t index = 0;
    for (const auto& prop : queueFamilyProps) {
        if (prop.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            _vkGraphicsQueueFamilyIndex = index;
        }

        VkBool32 presentSupported = VK_FALSE;
        vkGetPhysicalDeviceSurfaceSupportKHR(_vkPhysicalDevice, index, _vkSurface, &presentSupported);

        if (presentSupported) {
            _vkPresentQueueFamilyIndex = index;
        }

        if (_vkGraphicsQueueFamilyIndex != UINT32_MAX && _vkPresentQueueFamilyIndex != UINT32_MAX) {
            break;
        }

        ++index;
    }

    if (_vkGraphicsQueueFamilyIndex == UINT32_MAX) {
        ToonLogError("No suitable graphics queue found");
        return false;
    }

    if (_vkPresentQueueFamilyIndex == UINT32_MAX) {
        ToonLogError("No suitable present queue found");
        return false;
    }

    const float queuePriorities = 1.0f;

    std::vector<VkDeviceQueueCreateInfo> queueCreateInfoList;
    std::set<uint32_t> uniqueQueueFamilies = { _vkGraphicsQueueFamilyIndex, _vkPresentQueueFamilyIndex };

    for (auto family : uniqueQueueFamilies) {
        queueCreateInfoList.push_back({
            .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
            .pNext = nullptr,
            .flags = 0,
            .queueFamilyIndex = family,
            .queueCount = 1,
            .pQueuePriorities = &queuePriorities,
        });
    }

    VkPhysicalDeviceFeatures requiredDeviceFeatures = {
        // TODO
    };

    const auto& requiredLayers = GetRequiredLayers();

    const auto& requiredExtensions = GetRequiredDeviceExtensions();
    
    ToonLogVerbose("Required Vulkan Device Extensions:");
    for (const auto& extension : requiredExtensions) {
        ToonLogVerbose("\t%s", extension);
    }

    VkDeviceCreateInfo deviceCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfoList.size()),
        .pQueueCreateInfos = queueCreateInfoList.data(),
        .enabledLayerCount = static_cast<uint32_t>(requiredLayers.size()),
        .ppEnabledLayerNames = requiredLayers.data(),
        .enabledExtensionCount = static_cast<uint32_t>(requiredExtensions.size()),
        .ppEnabledExtensionNames = requiredExtensions.data(),
        .pEnabledFeatures = &requiredDeviceFeatures,
    };

    vkResult = vkCreateDevice(_vkPhysicalDevice, &deviceCreateInfo, nullptr, &_vkDevice);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkCreateDevice() failed");
        return false;
    }

    // Reload glad to load instance pointers and populate available extensions
    int vkVersion = gladLoaderLoadVulkan(_vkInstance, _vkPhysicalDevice, _vkDevice);
    if (vkVersion == 0) {
        ToonLogError("gladLoaderLoadVulkan() failed, unable to reload symbols with VkInstance, VkPhysicalDevice, and VkDevice");
        return false;
    }

    vkGetDeviceQueue(_vkDevice, _vkGraphicsQueueFamilyIndex, 0, &_vkGraphicsQueue);
    vkGetDeviceQueue(_vkDevice, _vkPresentQueueFamilyIndex, 0, &_vkPresentQueue);

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermLogicalDevice()
{
    if (_vkDevice) {
        vkDestroyDevice(_vkDevice, nullptr);
        _vkDevice = nullptr;
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitAllocator()
{
    VkResult vkResult;

    VmaAllocatorCreateFlags flags = 0;

    auto it = _vkAvailableDeviceExtensions.find(VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME);
    if (it != _vkAvailableDeviceExtensions.end()) {
        flags |= VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT;
    }

    it = _vkAvailableDeviceExtensions.find(VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME);
    if (it != _vkAvailableDeviceExtensions.end()) {
        flags |= VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT;
    }

    it = _vkAvailableDeviceExtensions.find(VK_EXT_MEMORY_BUDGET_EXTENSION_NAME);
    if (it != _vkAvailableDeviceExtensions.end()) {
        flags |= VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT;
    }

    VmaAllocatorCreateInfo allocatorCreateInfo = {
        .flags = flags,
        .physicalDevice = _vkPhysicalDevice,
        .device = _vkDevice,
        // .preferredLargeHeapBlockSize = ,
        // .pAllocationCallbacks = ,
        // .pDeviceMemoryCallbacks = ,
        .instance = _vkInstance,
        .vulkanApiVersion = VK_API_VERSION_1_1,
    };

    vkResult = vmaCreateAllocator(&allocatorCreateInfo, &_vmaAllocator);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vmaCreateAllocator() failed");
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermAllocator()
{
    if (_vmaAllocator) {
        vmaDestroyAllocator(_vmaAllocator);
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitSwapChain()
{
    VkResult vkResult;

    VkSurfaceCapabilitiesKHR surfaceCapabilities;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(_vkPhysicalDevice, _vkSurface, &surfaceCapabilities);

    uint32_t formatCount;
    vkGetPhysicalDeviceSurfaceFormatsKHR(_vkPhysicalDevice, _vkSurface, &formatCount, nullptr);

    std::vector<VkSurfaceFormatKHR> formats(formatCount);
    vkGetPhysicalDeviceSurfaceFormatsKHR(_vkPhysicalDevice, _vkSurface, &formatCount, formats.data());

    uint32_t presentModeCount;
    vkGetPhysicalDeviceSurfacePresentModesKHR(_vkPhysicalDevice, _vkSurface, &presentModeCount, nullptr);

    std::vector<VkPresentModeKHR> presentModes(presentModeCount);
    vkGetPhysicalDeviceSurfacePresentModesKHR(_vkPhysicalDevice, _vkSurface, &presentModeCount, presentModes.data());

    // VK_FORMAT_R8G8B8A8_UNORM
    // VK_FORMAT_B8G8R8A8_SRGB

    _vkSwapChainImageFormat = formats[0];
    for (const auto& format : formats) {
        // TODO: Investigate
        if (format.format == VK_FORMAT_R8G8B8A8_UNORM && format.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
            _vkSwapChainImageFormat = format;
            break;
        }
    }

    // TODO: Investigate
    // VK_PRESENT_MODE_FIFO_KHR = Queue of presentation requests, wait for vsync, required to be supported
    // VK_PRESENT_MODE_MAILBOX_KHR = Queue of presentation requests, wait for vsync, replaces entries if the queue is full
    VkPresentModeKHR swapChainPresentMode = VK_PRESENT_MODE_FIFO_KHR;
    for (const auto& presentMode : presentModes) {
        if (presentMode == VK_PRESENT_MODE_MAILBOX_KHR) {
            swapChainPresentMode = presentMode;
            break;
        }
    }

    _vkSwapChainExtent = surfaceCapabilities.currentExtent;
    if (_vkSwapChainExtent.width == UINT32_MAX) {
        glm::ivec2 size = GetWindowSize();

        _vkSwapChainExtent.width = std::clamp(static_cast<uint32_t>(size.x),
            surfaceCapabilities.minImageExtent.width, surfaceCapabilities.maxImageExtent.width);

        _vkSwapChainExtent.height = std::clamp(static_cast<uint32_t>(size.y),
            surfaceCapabilities.minImageExtent.height, surfaceCapabilities.maxImageExtent.height);
    }

    uint32_t backbufferCount = std::clamp(
        GetBackbufferCount(),
        surfaceCapabilities.minImageCount,
        surfaceCapabilities.maxImageCount
    );

    VkSwapchainCreateInfoKHR swapChainCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
        .pNext = nullptr,
        .flags = 0,
        .surface = _vkSurface,
        .minImageCount = static_cast<uint32_t>(backbufferCount),
        .imageFormat = _vkSwapChainImageFormat.format,
        .imageColorSpace = _vkSwapChainImageFormat.colorSpace,
        .imageExtent = _vkSwapChainExtent,
        .imageArrayLayers = 1,
        .imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
        .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE,
        .queueFamilyIndexCount = 0,
        .pQueueFamilyIndices = nullptr,
        .preTransform = surfaceCapabilities.currentTransform,
        .compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
        .presentMode = swapChainPresentMode,
        .clipped = VK_TRUE,
    };

    uint32_t queueFamilyIndices[] = {
        _vkGraphicsQueueFamilyIndex,
        _vkPresentQueueFamilyIndex
    };

    // TODO: Refactor
    if (_vkGraphicsQueueFamilyIndex != _vkPresentQueueFamilyIndex) {
        swapChainCreateInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
        swapChainCreateInfo.queueFamilyIndexCount = 2;
        swapChainCreateInfo.pQueueFamilyIndices = queueFamilyIndices;
    }

    vkResult = vkCreateSwapchainKHR(_vkDevice, &swapChainCreateInfo, nullptr, &_vkSwapChain);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkCreateSwapchainKHR() failed");
        return false;
    }

    vkGetSwapchainImagesKHR(_vkDevice, _vkSwapChain, &backbufferCount, nullptr);

    _vkSwapChainImages.resize(backbufferCount);
    vkGetSwapchainImagesKHR(_vkDevice, _vkSwapChain, &backbufferCount, _vkSwapChainImages.data());

    _vkSwapChainImageViews.resize(backbufferCount);

    for (size_t i = 0; i < _vkSwapChainImages.size(); ++i) {
        VkImageViewCreateInfo imageViewCreateInfo = {
            .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            .pNext = nullptr,
            .flags = 0,
            .image = _vkSwapChainImages[i],
            .viewType = VK_IMAGE_VIEW_TYPE_2D,
            .format = _vkSwapChainImageFormat.format,
            .subresourceRange = {
                .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
                .baseMipLevel = 0,
                .levelCount = 1,
                .baseArrayLayer = 0,
                .layerCount = 1,
            },
        };

        vkResult = vkCreateImageView(_vkDevice, &imageViewCreateInfo, nullptr, &_vkSwapChainImageViews[i]);
        if (vkResult != VK_SUCCESS) {
            ToonLogError("vkCreateImageView() failed");
            return false;
        }
    }

    GraphicsDriver::SetBackbufferCount(backbufferCount);

    if (!InitDepthBuffer()) {
        return false;
    }

    if (!InitRenderPass()) {
        return false;
    }

    if (!InitDescriptorPool()) {
        return false;
    }

    for (const auto& pipeline : _pipelineList) {
        VulkanPipeline * vkPipeline = TOON_VULKAN_PIPELINE(pipeline.get());
        vkPipeline->Create();
    }

    if (!InitFramebuffers()) {
        return false;
    }

    if (!InitCommandPool()) {
        return false;
    }

    if (!InitCommandBuffers()) {
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermSwapChain(bool resetting /*= false*/)
{
    TermCommandBuffers();
    TermCommandPool();
    TermFramebuffers();

    if (resetting) {
        for (const auto& pipeline : _pipelineList) {
            VulkanPipeline * vkPipeline = TOON_VULKAN_PIPELINE(pipeline.get());
            vkPipeline->Destroy();
        }

        for (const auto& mesh : _meshList) {
            VulkanMesh * vkMesh = TOON_VULKAN_MESH(mesh.get());
            vkMesh->Destroy();
        }
    }
    else {
        for (const auto& pipeline : _pipelineList) {
            pipeline->Terminate();
        }
        _pipelineList.clear();

        for (const auto& mesh : _meshList) {
            mesh->Terminate();
        }
        _meshList.clear();
    }

    TermDescriptorPool();
    TermRenderPass();
    TermDepthBuffer();

    for (auto& imageView : _vkSwapChainImageViews) {
        if (imageView) {
            vkDestroyImageView(_vkDevice, imageView, nullptr);
            imageView = nullptr;
        }
    }

    if (_vkSwapChain) {
        vkDestroySwapchainKHR(_vkDevice, _vkSwapChain, nullptr);
        _vkSwapChain = nullptr;
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::ResetSwapChain()
{
    ToonBenchmarkStart();

    vkDeviceWaitIdle(_vkDevice);

    TermSwapChain(true);

    if (!InitSwapChain()) {
        return false;
    }

    ToonBenchmarkEnd();
    return true;
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitDepthBuffer()
{
    VkResult vkResult;

    std::vector<VkFormat> potentialDepthFormats = {
        VK_FORMAT_D32_SFLOAT,
        VK_FORMAT_D32_SFLOAT_S8_UINT,
        VK_FORMAT_D24_UNORM_S8_UINT,
    };

    _vkDepthImageFormat = VK_FORMAT_UNDEFINED;

    for (VkFormat format : potentialDepthFormats) {
        VkFormatProperties formatProperties;
        vkGetPhysicalDeviceFormatProperties(_vkPhysicalDevice, format, &formatProperties);

        VkFormatFeatureFlags features = (formatProperties.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT);
        if (features == VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) {
            _vkDepthImageFormat = format;
            break;
        }
    }

    if (_vkDepthImageFormat == VK_FORMAT_UNDEFINED) {
        ToonLogError("Unable to find suitable depth buffer image format");
        return false;
    }

    VkImageCreateInfo imageCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .imageType = VK_IMAGE_TYPE_2D,
        .format = _vkDepthImageFormat,
        .extent = {
            .width = _vkSwapChainExtent.width,
            .height = _vkSwapChainExtent.height,
            .depth = 1,
        },
        .mipLevels = 1,
        .arrayLayers = 1,
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .tiling = VK_IMAGE_TILING_OPTIMAL,
        .usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
        .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
    };

    VmaAllocationCreateInfo allocationCreateInfo = {
        .flags = 0,
        .usage = VMA_MEMORY_USAGE_GPU_ONLY,
    };

    vkResult = vmaCreateImage(
        _vmaAllocator,
        &imageCreateInfo,
        &allocationCreateInfo,
        &_vkDepthImage,
        &_vmaDepthImageAllocation,
        nullptr
    );

    if (vkResult != VK_SUCCESS) {
        ToonLogError("vmaCreateImage() failed, unable to create depth buffer image");
        return false;
    }

    VkImageViewCreateInfo imageViewCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .image = _vkDepthImage,
        .viewType = VK_IMAGE_VIEW_TYPE_2D,
        .format = VK_FORMAT_D32_SFLOAT,
        // .components
        .subresourceRange = {
            .aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT,
            .baseMipLevel = 0,
            .levelCount = 1,
            .baseArrayLayer = 0,
            .layerCount = 1,
        },
    };

    if (vkCreateImageView(_vkDevice, &imageViewCreateInfo, nullptr, &_vkDepthImageView) != VK_SUCCESS) {
        ToonLogError("Failed to create depth buffer image view");
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermDepthBuffer()
{
    if (_vkDepthImageView) {
        vkDestroyImageView(_vkDevice, _vkDepthImageView, nullptr);
        _vkDepthImageView = nullptr;
    }

    if (_vkDepthImage) {
        vkDestroyImage(_vkDevice, _vkDepthImage, nullptr);
        _vkDepthImage = nullptr;
    }

    if (_vmaDepthImageAllocation) {
        vmaFreeMemory(_vmaAllocator, _vmaDepthImageAllocation);
        _vmaDepthImageAllocation = nullptr;
    }

}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitRenderPass()
{
    VkResult vkResult;

    VkAttachmentDescription colorAttachmentDescription = {
        .flags = 0,
        .format = _vkSwapChainImageFormat.format,
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
        .storeOp = VK_ATTACHMENT_STORE_OP_STORE,
        .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
    };

    VkAttachmentDescription depthAttachmentDescription = {
        .flags = 0,
        .format = _vkDepthImageFormat,
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
        .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    };

    VkAttachmentReference colorAttachmentReference = {
        .attachment = 0,
        .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
    };

    VkAttachmentReference depthAttachmentReference = {
        .attachment = 1,
        .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    };

    VkSubpassDescription subpassDescription = {
        .flags = 0,
        .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS,
        .inputAttachmentCount = 0,
        .pInputAttachments = nullptr,
        .colorAttachmentCount = 1,
        .pColorAttachments = &colorAttachmentReference,
        .pResolveAttachments = nullptr,
        .pDepthStencilAttachment = &depthAttachmentReference,
        .preserveAttachmentCount = 0,
        .pPreserveAttachments = nullptr,
    };

    VkSubpassDependency subpassDependency = {
        .srcSubpass = VK_SUBPASS_EXTERNAL,
        .dstSubpass = 0,
        .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
        .dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
        .srcAccessMask = 0,
        .dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
    };

    std::array<VkAttachmentDescription, 2> attachments = {
        colorAttachmentDescription,
        depthAttachmentDescription,
    };

    VkRenderPassCreateInfo renderPassCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .attachmentCount = static_cast<uint32_t>(attachments.size()),
        .pAttachments = attachments.data(),
        .subpassCount = 1,
        .pSubpasses = &subpassDescription,
        .dependencyCount = 1,
        .pDependencies = &subpassDependency,
    };

    vkResult = vkCreateRenderPass(_vkDevice, &renderPassCreateInfo, nullptr, &_vkRenderPass);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkCreateRenderPass() failed");
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermRenderPass()
{
    if (_vkRenderPass) {
        vkDestroyRenderPass(_vkDevice, _vkRenderPass, nullptr);
        _vkRenderPass = nullptr;
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitDescriptorPool()
{
    VkResult vkResult;

    std::array<VkDescriptorPoolSize, 1> descriptorPoolSizeList = {
        VkDescriptorPoolSize {
            .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            // + _materialList.size()
            .descriptorCount = static_cast<uint32_t>(1 + _meshList.size()), // Can never be 0
        },
        // VkDescriptorPoolSize {
        //     .type = VK_DESCRIPTOR_TYPE_SAMPLER,
        //     .descriptorCount = 0,
        // },
    };

    VkDescriptorPoolCreateInfo descriptorPoolCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
        .maxSets = static_cast<uint32_t>(_vkSwapChainImages.size()),
        .poolSizeCount = descriptorPoolSizeList.size(),
        .pPoolSizes = descriptorPoolSizeList.data(),
    };

    vkResult = vkCreateDescriptorPool(_vkDevice, &descriptorPoolCreateInfo, nullptr, &_vkDescriptorPool);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkCreateDescriptorPool() failed");
        return false;
    }

    std::array<VkDescriptorSetLayoutBinding, 2> descriptorSetLayoutBindingList = {
        VkDescriptorSetLayoutBinding {
            .binding = TOON_SHADER_GLOBALS_BINDING,
            .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            .descriptorCount = 1,
            .stageFlags = VK_SHADER_STAGE_ALL_GRAPHICS,
            .pImmutableSamplers = nullptr,
        },
        VkDescriptorSetLayoutBinding {
            .binding = TOON_SHADER_TRANSFORM_BINDING,
            .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            .descriptorCount = 1,
            .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,
            .pImmutableSamplers = nullptr,
        },
    };

    VkDescriptorSetLayoutCreateInfo descriptorSetLayoutCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .bindingCount = static_cast<uint32_t>(descriptorSetLayoutBindingList.size()),
        .pBindings = descriptorSetLayoutBindingList.data(),
    };

    vkResult = vkCreateDescriptorSetLayout(_vkDevice, &descriptorSetLayoutCreateInfo, nullptr, &_vkDescriptorSetLayout);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkCreateDescriptorSetLayout() failed");
        return false;
    }

    for (auto& mesh : _meshList) {
        VulkanMesh * vkMesh = TOON_VULKAN_MESH(mesh.get());
        if (!vkMesh->Create()) {
            return false;
        }
    }

    std::array<VkDescriptorSetLayout, 1> setLayouts = {
        _vkDescriptorSetLayout,
    };

    // TODO: Move into Pipeline
    VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .setLayoutCount = static_cast<uint32_t>(setLayouts.size()),
        .pSetLayouts = setLayouts.data(),
        .pushConstantRangeCount = 0,
        .pPushConstantRanges = nullptr,
    };

    vkResult = vkCreatePipelineLayout(_vkDevice, &pipelineLayoutCreateInfo, nullptr, &_vkPipelineLayout);
    if (vkResult != VK_SUCCESS) {
        ToonLogFatal("vkCreatePipelineLayout() failed");
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermDescriptorPool()
{
    if (_vkPipelineLayout) {
        vkDestroyPipelineLayout(_vkDevice, _vkPipelineLayout, nullptr);
        _vkPipelineLayout = nullptr;
    }

    if (_vkDescriptorSetLayout) {
        vkDestroyDescriptorSetLayout(_vkDevice, _vkDescriptorSetLayout, nullptr);
        _vkDescriptorSetLayout = nullptr;
    }

    if (_vkDescriptorPool) {
        vkResetDescriptorPool(_vkDevice, _vkDescriptorPool, 0); // ?
        vkDestroyDescriptorPool(_vkDevice, _vkDescriptorPool, nullptr);
        _vkDescriptorPool = nullptr;
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitFramebuffers()
{
    VkResult vkResult;

    _vkFramebuffers.resize(_vkSwapChainImageViews.size());

    for (size_t i = 0; i < _vkSwapChainImageViews.size(); ++i) {
        std::array<VkImageView, 2> attachments = {
            _vkSwapChainImageViews[i],
            _vkDepthImageView,
        };

        VkFramebufferCreateInfo framebufferCreateInfo = {
            .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
            .pNext = nullptr,
            .flags = 0,
            .renderPass = _vkRenderPass,
            .attachmentCount = static_cast<uint32_t>(attachments.size()),
            .pAttachments = attachments.data(),
            .width = _vkSwapChainExtent.width,
            .height = _vkSwapChainExtent.height,
            .layers = 1,
        };

        vkResult = vkCreateFramebuffer(_vkDevice, &framebufferCreateInfo, nullptr, &_vkFramebuffers[i]);
        if (vkResult != VK_SUCCESS) {
            ToonLogError("vkCreateFramebuffer() failed");
            return false;
        }
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermFramebuffers()
{
    for (auto& framebuffer : _vkFramebuffers) {
        if (framebuffer) {
            vkDestroyFramebuffer(_vkDevice, framebuffer, nullptr);
        }
    }
    _vkFramebuffers.clear();
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitCommandPool()
{
    VkResult vkResult;

    VkCommandPoolCreateInfo commandPoolCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .queueFamilyIndex = _vkGraphicsQueueFamilyIndex,
    };

    vkResult = vkCreateCommandPool(_vkDevice, &commandPoolCreateInfo, nullptr, &_vkCommandPool);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkCreateCommandPool() failed");
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermCommandPool()
{
    if (_vkCommandPool) {
        vkDestroyCommandPool(_vkDevice, _vkCommandPool, nullptr);
        _vkCommandPool = nullptr;
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitCommandBuffers()
{
    VkResult vkResult;

    VkCommandBufferAllocateInfo commandBufferAllocateInfo = {
        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        .pNext = nullptr,
        .commandPool = _vkCommandPool,
        .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        .commandBufferCount = static_cast<uint32_t>(_vkFramebuffers.size()),
    };

    _vkCommandBuffers.resize(_vkFramebuffers.size());

    vkResult = vkAllocateCommandBuffers(_vkDevice, &commandBufferAllocateInfo, _vkCommandBuffers.data());
    if (vkResult != VK_SUCCESS) {
        ToonLogError("vkAllocateCommandBuffers() failed");
        return false;
    }

    if (!FillCommandBuffers()) {
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermCommandBuffers()
{
    if (!_vkCommandBuffers.empty()) {
        vkFreeCommandBuffers(_vkDevice, _vkCommandPool, static_cast<size_t>(_vkCommandBuffers.size()), _vkCommandBuffers.data());
        _vkCommandBuffers.clear();
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::InitSyncObjects()
{
    VkResult vkResult;

    _vkImageAvailableSemaphores.resize(2);
    _vkRenderingFinishedSemaphores.resize(2);
    _vkInFlightFences.resize(2);
    _vkImagesInFlight.resize(_vkSwapChainImages.size(), VK_NULL_HANDLE);

    VkSemaphoreCreateInfo semaphoreCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
    };

    VkFenceCreateInfo fenceCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
        .pNext = nullptr,
        .flags = VK_FENCE_CREATE_SIGNALED_BIT,
    };

    for (size_t i = 0; i < 2; ++i) {
        vkResult = vkCreateSemaphore(_vkDevice, &semaphoreCreateInfo, nullptr, &_vkImageAvailableSemaphores[i]);
        if (vkResult != VK_SUCCESS) {
            ToonLogError("vkCreateSemaphore() failed");
            return false;
        }
        else {
            vkResult = vkCreateSemaphore(_vkDevice, &semaphoreCreateInfo, nullptr, &_vkRenderingFinishedSemaphores[i]);
            if (vkResult != VK_SUCCESS) {
                ToonLogError("vkCreateSemaphore() failed");
                return false;
            }
            else {
                vkResult = vkCreateFence(_vkDevice, &fenceCreateInfo, nullptr, &_vkInFlightFences[i]);
                if (vkResult != VK_SUCCESS) {
                    ToonLogError("vkCreateFence() failed");
                    return false;
                }   
            }
        }
    }

    return true;
}

TOON_VULKAN_API
void VulkanGraphicsDriver::TermSyncObjects()
{
    for (auto fence : _vkInFlightFences) {
        vkDestroyFence(_vkDevice, fence, nullptr);
        fence = nullptr;
    }

    for (auto semaphore : _vkRenderingFinishedSemaphores) {
        vkDestroySemaphore(_vkDevice, semaphore, nullptr);
        semaphore = nullptr;
    }

    for (auto semaphore : _vkImageAvailableSemaphores) {
        vkDestroySemaphore(_vkDevice, semaphore, nullptr);
        semaphore = nullptr;
    }
}

TOON_VULKAN_API
bool VulkanGraphicsDriver::FillCommandBuffers()
{
    VkResult vkResult;

    for (size_t i = 0; i < _vkCommandBuffers.size(); ++i) {

        VkCommandBufferBeginInfo commandBufferBeginInfo = {
            .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
            .pNext = nullptr,
            .flags = 0,
            .pInheritanceInfo = nullptr,
        };

        // Requires VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
        // vkResetCommandBuffer(_vkCommandBuffers[i], 0);

        vkResult = vkBeginCommandBuffer(_vkCommandBuffers[i], &commandBufferBeginInfo);
        if (vkResult != VK_SUCCESS) {
            ToonLogError("vkBeginCommandBuffer() failed");
            return false;
        }

        VulkanRenderContext * vkRenderContext = TOON_VULKAN_RENDER_CONTEXT(_renderContext.get());
        vkRenderContext->SetVkCommandBuffer(_vkCommandBuffers[i]);

        std::array<VkClearValue, 2> clearValues = { };

        const glm::vec4& cc = GetClearColor();
        clearValues[0].color = {
            .float32 = { cc.r, cc.g, cc.b, cc.a }
        };
        
        clearValues[1].depthStencil = { 
            .depth = 1.0f, 
            .stencil = 0,
        };

        VkRenderPassBeginInfo renderPassBeginInfo = {
            .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
            .renderPass = _vkRenderPass,
            .framebuffer = _vkFramebuffers[i],
            .renderArea = {
                .offset = { 0, 0 },
                .extent = _vkSwapChainExtent,
            },
            .clearValueCount = static_cast<uint32_t>(clearValues.size()),
            .pClearValues = clearValues.data(),
        };

        vkCmdBeginRenderPass(_vkCommandBuffers[i], &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

        Scene * scene = GetCurrentScene();
        if (scene) {
            scene->Render(_renderContext.get());
        }


        vkCmdEndRenderPass(_vkCommandBuffers[i]);

        vkResult = vkEndCommandBuffer(_vkCommandBuffers[i]);
        if (vkResult != VK_SUCCESS) {
            ToonLogError("vkEndCommandBuffer() failed");
            return false;
        }
    }

    return true;
}

} // namespace Toon::Vulkan

```

`Modules/Vulkan/Private/VulkanMesh.cpp`:

```cpp
#include <Toon/Vulkan/VulkanMesh.hpp>

#include <Toon/Log.hpp>
#include <Toon/Vulkan/VulkanGraphicsDriver.hpp>

namespace Toon::Vulkan {

TOON_VULKAN_API
bool VulkanMesh::Initialize()
{
    if (!Mesh::Initialize()) {
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanMesh::Terminate()
{
    Destroy();

    Mesh::Terminate();
}

TOON_VULKAN_API
bool VulkanMesh::Create()
{
    VulkanGraphicsDriver * gfx = TOON_VULKAN_GRAPHICS_DRIVER(GetGraphicsDriver());
    if (!gfx->CreateDescriptorSet(&_vkDescriptorSet)) {
        return false;
    }

    VulkanBuffer * vkTransformBuffer = TOON_VULKAN_BUFFER(_shaderTransformBuffer.get());

    VkDescriptorBufferInfo bufferInfo = {
        .buffer = vkTransformBuffer->GetVkBuffer(),
        .offset = 0,
        .range = VK_WHOLE_SIZE,
    };

    VkWriteDescriptorSet writeDescriptorSet = {
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        .dstSet = _vkDescriptorSet,
        .dstBinding = TOON_SHADER_TRANSFORM_BINDING,
        .dstArrayElement = 0,
        .descriptorCount = 1,
        .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        .pBufferInfo = &bufferInfo,
    };

    vkUpdateDescriptorSets(gfx->GetDevice(), 1, &writeDescriptorSet, 0, nullptr);

    return true;
}

TOON_VULKAN_API
void VulkanMesh::Destroy()
{
    // Descriptor Sets are automatically freed (I hope)
    _vkDescriptorSet = nullptr;
}

TOON_VULKAN_API
void VulkanMesh::Render(RenderContext * ctx)
{
    Mesh::Render(ctx);

    VulkanGraphicsDriver * gfx = TOON_VULKAN_GRAPHICS_DRIVER(GetGraphicsDriver());

    VulkanRenderContext * vkRenderContext = TOON_VULKAN_RENDER_CONTEXT(ctx);
    VkCommandBuffer vkCommandBuffer = vkRenderContext->GetVkCommandBuffer();

    if (vkCommandBuffer) {
        VulkanPipeline * vkPipeline = TOON_VULKAN_PIPELINE(_pipeline.get());
        vkPipeline->GenerateCommands(vkCommandBuffer);

        vkCmdBindDescriptorSets(vkCommandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, 
            gfx->GetPipelineLayout(), 0, 1, &_vkDescriptorSet, 0, nullptr);

        for (auto& primitive : _primitiveList) {
            VulkanPrimitive * vkPrimitive = TOON_VULKAN_PRIMITIVE(primitive.get());
            vkPrimitive->GenerateCommands(vkCommandBuffer);
        }
    }
}

} // namespace Toon::Vulkan
```

`Modules/Vulkan/Private/VulkanModule.cpp`:

```cpp
#include <Toon/Module.hpp>
#include <Toon/Vulkan/VulkanGraphicsDriver.hpp>

namespace Toon::Vulkan {

bool ModuleInit() {
    SetGraphicsDriver(std::unique_ptr<GraphicsDriver>(new VulkanGraphicsDriver()));
    if (!GetGraphicsDriver()->Initialize()) {
        SetGraphicsDriver(nullptr);
        return false;
    }

    return true;
}

void ModuleTerm() {
    SetGraphicsDriver(nullptr);
}

TOON_MODULE {
    .Name       = "Vulkan",
    .Initialize = ModuleInit,
    .Terminate  = ModuleTerm,
};

} // namespace Toon::Vulkan
```

`Modules/Vulkan/Private/VulkanPipeline.cpp`:

```cpp
#include <Toon/Vulkan/VulkanPipeline.hpp>

#include <Toon/Log.hpp>
#include <Toon/Benchmark.hpp>
#include <Toon/Vertex.hpp>
#include <Toon/Vulkan/VulkanGraphicsDriver.hpp>
#include <Toon/Vulkan/VulkanShader.hpp>
#include <Toon/Vulkan/VulkanMesh.hpp>

namespace Toon::Vulkan {

TOON_VULKAN_API
bool VulkanPipeline::Initialize(std::shared_ptr<Shader> shader)
{
    if (!Pipeline::Initialize(shader)) {
        return false;
    }

    return Create();
}

TOON_VULKAN_API
void VulkanPipeline::Terminate()
{
    _shader.reset();

    Destroy();
}

TOON_VULKAN_API
bool VulkanPipeline::Create()
{
    VkResult vkResult;

    VulkanGraphicsDriver * gfx = TOON_VULKAN_GRAPHICS_DRIVER(GetGraphicsDriver());

    VulkanShader * vkShader = TOON_VULKAN_SHADER(_shader.get());
    if (!vkShader) {
        ToonLogError("Trying to bind a Vulkan VulkanPipeline with no shader");
        return false;
    }

    const auto& stageList = vkShader->GetStageList();

    VkExtent2D extent = gfx->GetSwapChainExtent();

    VkViewport viewport = {
        .x = 0,
        .y = static_cast<float>(extent.height),
        .width = static_cast<float>(extent.width),
        .height = -1.0f * static_cast<float>(extent.height),
        .minDepth = 0.0f,
        .maxDepth = 1.0f,
    };

    VkRect2D scissor = {
        .offset = { 0, 0 },
        .extent = { extent.width, extent.height },
    };

    VkPipelineViewportStateCreateInfo viewportStateCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .viewportCount = 1,
        .pViewports = &viewport,
        .scissorCount = 1,
        .pScissors = &scissor,
    };

    auto polygonMode = GetVkPolygonMode(_fillMode);
    auto cullMode = GetVkCullMode(_cullMode);
    auto frontFace = GetVkFrontFace(_frontFace);

    if (!polygonMode || !cullMode || !frontFace) {
        return false;
    }

    VkPipelineRasterizationStateCreateInfo rasterizationStateCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .depthClampEnable = (_depthBiasMode == DepthBiasMode::Clamp),
        .rasterizerDiscardEnable = VK_FALSE,
        .polygonMode = polygonMode.value(),
        .cullMode = cullMode.value(),
        .frontFace = frontFace.value(),
        .depthBiasEnable = VK_TRUE,
        .depthBiasConstantFactor = _depthBiasFactor,
        .depthBiasClamp = _depthBiasClamp,
        .depthBiasSlopeFactor = _depthBiasSlopeFactor,
        .lineWidth = 1.0f,
    };

    VkPipelineMultisampleStateCreateInfo multisampleStateCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT,
        .sampleShadingEnable = VK_FALSE,
    };

    auto depthCompareOp = GetVkCompareOp(_depthCompareOperation);

    if (!depthCompareOp) {
        return false;
    }

    VkPipelineDepthStencilStateCreateInfo depthStencilStateCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .depthTestEnable = (_depthCompareOperation != CompareOperation::Always),
        .depthWriteEnable = VK_TRUE,
        .depthCompareOp = depthCompareOp.value(),
        .depthBoundsTestEnable = VK_FALSE,
        .stencilTestEnable = VK_FALSE,
        // .front,
        // .back,
        // .minDepthBounds,
        // .maxDepthBounds,
    };

    auto srcColorFactor = GetVkBlendFactor(_srcColorFactor);
    auto dstColorFactor = GetVkBlendFactor(_dstColorFactor);
    auto colorBlendOp = GetVkBlendOp(_colorBlendOp);

    if (!srcColorFactor || !dstColorFactor || !colorBlendOp) {
        return false;
    }
    
    auto srcAlphaFactor = GetVkBlendFactor(_srcAlphaFactor);
    auto dstAlphaFactor = GetVkBlendFactor(_dstAlphaFactor);
    auto alphaBlendOp = GetVkBlendOp(_alphaBlendOp);

    if (!srcAlphaFactor || !dstAlphaFactor || !alphaBlendOp) {
        return false;
    }

    VkPipelineColorBlendAttachmentState colorBlendAttachmentState = {
        .blendEnable = _blendEnabled,
        .srcColorBlendFactor = srcColorFactor.value(),
        .dstColorBlendFactor = dstColorFactor.value(),
        .colorBlendOp = colorBlendOp.value(),
        .srcAlphaBlendFactor = srcAlphaFactor.value(),
        .dstAlphaBlendFactor = dstAlphaFactor.value(),
        .alphaBlendOp = alphaBlendOp.value(),
        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT
                        | VK_COLOR_COMPONENT_G_BIT
                        | VK_COLOR_COMPONENT_B_BIT
                        | VK_COLOR_COMPONENT_A_BIT,
    };

    VkPipelineColorBlendStateCreateInfo colorBlendStateCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .logicOpEnable = VK_FALSE,
        .logicOp = VK_LOGIC_OP_COPY,
        .attachmentCount = 1,
        .pAttachments = &colorBlendAttachmentState,
        .blendConstants = { 0.0f, 0.0f, 0.0f, 0.0f },
    };

    std::array<VkVertexInputBindingDescription, 1> bindings = {
        VkVertexInputBindingDescription {
            .binding = 0,
            .stride = sizeof(Vertex),
            .inputRate = VK_VERTEX_INPUT_RATE_VERTEX,
        }
    };

    std::array<VkVertexInputAttributeDescription, 9> attributes = {
        VkVertexInputAttributeDescription {
            .location = GetVertexAttributeLocation(VertexAttribute::Position),
            .binding = 0,
            .format = VK_FORMAT_R32G32B32A32_SFLOAT,
            .offset = offsetof(Vertex, Position),
        },
        VkVertexInputAttributeDescription {
            .location = GetVertexAttributeLocation(VertexAttribute::Normal),
            .binding = 0,
            .format = VK_FORMAT_R32G32B32A32_SFLOAT,
            .offset = offsetof(Vertex, Normal),
        },
        VkVertexInputAttributeDescription {
            .location = GetVertexAttributeLocation(VertexAttribute::Tangent),
            .binding = 0,
            .format = VK_FORMAT_R32G32B32A32_SFLOAT,
            .offset = offsetof(Vertex, Tangent),
        },
        VkVertexInputAttributeDescription {
            .location = GetVertexAttributeLocation(VertexAttribute::Bitangent),
            .binding = 0,
            .format = VK_FORMAT_R32G32B32A32_SFLOAT,
            .offset = offsetof(Vertex, Bitangent),
        },
        VkVertexInputAttributeDescription {
            .location = GetVertexAttributeLocation(VertexAttribute::Color),
            .binding = 0,
            .format = VK_FORMAT_R32G32B32A32_SFLOAT,
            .offset = offsetof(Vertex, Color),
        },
        VkVertexInputAttributeDescription {
            .location = GetVertexAttributeLocation(VertexAttribute::TexCoord1),
            .binding = 0,
            .format = VK_FORMAT_R32G32_SFLOAT,
            .offset = offsetof(Vertex, TexCoord1),
        },
        VkVertexInputAttributeDescription {
            .location = GetVertexAttributeLocation(VertexAttribute::TexCoord2),
            .binding = 0,
            .format = VK_FORMAT_R32G32_SFLOAT,
            .offset = offsetof(Vertex, TexCoord2),
        },
        VkVertexInputAttributeDescription {
            .location = GetVertexAttributeLocation(VertexAttribute::Joints),
            .binding = 0,
            .format = VK_FORMAT_R32G32B32A32_UINT,
            .offset = offsetof(Vertex, Joints),
        },
        VkVertexInputAttributeDescription {
            .location = GetVertexAttributeLocation(VertexAttribute::Weights),
            .binding = 0,
            .format = VK_FORMAT_R32G32B32A32_SFLOAT,
            .offset = offsetof(Vertex, Weights),
        },
    };

    VkPipelineVertexInputStateCreateInfo vertexInputStateCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .vertexBindingDescriptionCount = static_cast<uint32_t>(bindings.size()),
        .pVertexBindingDescriptions = bindings.data(),
        .vertexAttributeDescriptionCount = static_cast<uint32_t>(attributes.size()),
        .pVertexAttributeDescriptions = attributes.data(),
    };

    auto primitiveTopology = GetVkPrimitiveTopology(_primitiveTopology);

    VkPipelineInputAssemblyStateCreateInfo vertexInputAssemblyStateCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .topology = primitiveTopology.value(),
        .primitiveRestartEnable = VK_FALSE,
    };

    VkGraphicsPipelineCreateInfo pipelineCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .stageCount = static_cast<uint32_t>(stageList.size()),
        .pStages = stageList.data(),
        .pVertexInputState = &vertexInputStateCreateInfo,
        .pInputAssemblyState = &vertexInputAssemblyStateCreateInfo,
        .pTessellationState = nullptr,
        .pViewportState = &viewportStateCreateInfo,
        .pRasterizationState = &rasterizationStateCreateInfo,
        .pMultisampleState = &multisampleStateCreateInfo,
        .pDepthStencilState = &depthStencilStateCreateInfo,
        .pColorBlendState = &colorBlendStateCreateInfo,
        .pDynamicState = nullptr,
        .layout = gfx->GetPipelineLayout(),
        .renderPass = gfx->GetRenderPass(),
        .subpass = 0,
        .basePipelineHandle = VK_NULL_HANDLE,
        .basePipelineIndex = 0,
    };

    if (_vkPipeline) {
        vkDestroyPipeline(gfx->GetDevice(), _vkPipeline, nullptr);
    }

    vkResult = vkCreateGraphicsPipelines(gfx->GetDevice(), nullptr, 1, &pipelineCreateInfo, nullptr, &_vkPipeline);
    if (vkResult != VK_SUCCESS) {
        ToonLogError("Failed to create graphics pipeline");
        return false;
    }

    return true;
}

TOON_VULKAN_API
void VulkanPipeline::Destroy()
{
    VulkanGraphicsDriver * gfx = TOON_VULKAN_GRAPHICS_DRIVER(GetGraphicsDriver());
 
    if (_vkPipeline) {
        vkDestroyPipeline(gfx->GetDevice(), _vkPipeline, nullptr);
        _vkPipeline = nullptr;
    }
}

TOON_VULKAN_API
void VulkanPipeline::GenerateCommands(VkCommandBuffer vkCommandBuffer)
{
    vkCmdBindPipeline(vkCommandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, _vkPipeline);
}

} // namespace Toon::Vulkan

```

`Modules/Vulkan/Private/VulkanPrimitive.cpp`:

```cpp
#include <Toon/Vulkan/VulkanPrimitive.hpp>
#include <Toon/Vulkan/VulkanGraphicsDriver.hpp>
#include <Toon/Benchmark.hpp>

namespace Toon::Vulkan {

TOON_VULKAN_API
void VulkanPrimitive::Terminate()
{
    if (_vertexBuffer) {
        _vertexBuffer->Terminate();
    }

    if (_indexBuffer) {
        _indexBuffer->Terminate();
    }
}

bool VulkanPrimitive::Load(const std::unique_ptr<PrimitiveData>& data)
{
    ToonBenchmarkStart();

    auto gfx = GetGraphicsDriver();

    bool result;

    _material = data->GetMaterial();
    if (_material) {
        _material = gfx->GetDefaultMaterial();
    }

    const auto& indexList = data->GetIndexList();
    const auto& vertexList = data->GetVertexList();

    _vertexBuffer.reset(new VulkanBuffer());

    result = _vertexBuffer->Initialize(
        vertexList.size() * sizeof(Vertex),
        reinterpret_cast<uint8_t *>(vertexList.data()),
        BufferUsage::Vertex, MemoryUsage::GPU);

    if (!result) {
        return false;
    }

    if (indexList.empty()) {
        _indexed = false;
        _count = vertexList.size();
    }
    else {
        ToonLogFatal("UNTESTED");

        _indexed = true;
        _count = indexList.size();

        _indexBuffer.reset(new VulkanBuffer());

        result = _indexBuffer->Initialize(
            indexList.size() * sizeof(uint32_t), 
            reinterpret_cast<uint8_t *>(indexList.data()), 
            BufferUsage::Index, MemoryUsage::GPU);
        
        if (!result) {
            return false;
        }
    }

    ToonBenchmarkEnd();
    return true;
}

void VulkanPrimitive::GenerateCommands(VkCommandBuffer vkCommandBuffer)
{
    // TODO: Test moving index buffer inside of other if _indexed check
    if (_indexed) {
        VulkanBuffer * vkIndexBuffer = TOON_VULKAN_BUFFER(_indexBuffer.get());
        vkCmdBindIndexBuffer(vkCommandBuffer, vkIndexBuffer->GetVkBuffer(), 0, VK_INDEX_TYPE_UINT32);
    }

    VulkanBuffer * vkVertexBuffer = TOON_VULKAN_BUFFER(_vertexBuffer.get());
    VkBuffer vertexBuffers[] = { vkVertexBuffer->GetVkBuffer() };
    
    VkDeviceSize offsets[] = { 0 };
    vkCmdBindVertexBuffers(vkCommandBuffer, 0, 1, vertexBuffers, offsets);
    
    if (_indexed) {
        vkCmdDrawIndexed(vkCommandBuffer, _count, 1, 0, 0, 0);
    }
    else {
        vkCmdDraw(vkCommandBuffer, _count, 1, 0, 0);
    }
}

} // namespace Toon::Vulkan

```

`Modules/Vulkan/Private/VulkanShader.cpp`:

```cpp
#include <Toon/Vulkan/VulkanShader.hpp>

#include <Toon/Log.hpp>
#include <Toon/Benchmark.hpp>
#include <Toon/Vulkan/VulkanGraphicsDriver.hpp>

#include <fstream>

namespace Toon::Vulkan {

TOON_VULKAN_API
void VulkanShader::Terminate()
{
    auto gfx = TOON_VULKAN_GRAPHICS_DRIVER(GetGraphicsDriver());

    for (auto& shaderModule : _shaderModuleList) {
        vkDestroyShaderModule(gfx->GetDevice(), shaderModule, nullptr);
    }
    _shaderModuleList.clear();
}

TOON_VULKAN_API
bool VulkanShader::LoadFromFiles(const std::vector<string>& filenames, bool useAssetPath /*= true*/)
{
    ToonBenchmarkStart();

    for (const auto& filename : filenames) {
        if (!LoadSPV(filename, useAssetPath)) {
            if (!LoadSPV(filename + ".spv", useAssetPath)) {
                ToonLogError("Failed to load '%s'", filename);
                return false;
            }
        }
    }

    ToonBenchmarkEnd();
    return true;
}

TOON_VULKAN_API
bool VulkanShader::LoadSPV(const string& filename, bool useAssetPath)
{
    VulkanGraphicsDriver * gfx = TOON_VULKAN_GRAPHICS_DRIVER(GetGraphicsDriver());

    const auto& assetPaths = GetAssetPathList();

    std::ifstream file;

    if (useAssetPath) {
        for (const auto& path : assetPaths) {
            Path fullPath = path / "Shaders" / filename;
            ToonLogVerbose("Checking '%s'", fullPath);

            file.open(fullPath.ToString(), std::ios::binary);
            if (file.is_open()) {
                break;
            }
        }
    }
    else {
        file.open(filename, std::ios::binary);
    }

    if (!file.is_open()) {
        return false;
    }

    file.unsetf(std::ios::skipws);

    ToonLogLoad("Loading SPIR-V shader '%s'", filename);

    std::vector<uint8_t> data(
        (std::istreambuf_iterator<char>(file)),
        std::istreambuf_iterator<char>()
    );

    VkShaderStageFlagBits type = GetVkShaderType(filename);
    if (type == VK_SHADER_STAGE_ALL) {
        ToonLogError("Failed to determine shader type of '%s'", filename);
        return false;
    }

    VkShaderModuleCreateInfo shaderModuleCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .codeSize = data.size(),
        .pCode = reinterpret_cast<const uint32_t *>(data.data()),
    };

    VkShaderModule shaderModule;

    if (vkCreateShaderModule(gfx->GetDevice(), &shaderModuleCreateInfo, nullptr, &shaderModule) != VK_SUCCESS) {
        ToonLogError("Failed to create shader module");
        return false;
    }

    VkPipelineShaderStageCreateInfo shaderStageCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .stage = type,
        .module = shaderModule, // This conflicts with the `module` keyword in C++20
        .pName = "main", // TODO: Update
        .pSpecializationInfo = nullptr,
    };

    _shaderModuleList.push_back(shaderModule);
    _shaderStageList.push_back(shaderStageCreateInfo);

    return true;
}

TOON_VULKAN_API
VkShaderStageFlagBits VulkanShader::GetVkShaderType(const string& filename)
{
    string ext = GetExtension(filename);
    size_t pivot = filename.find_last_of('.');
    if (pivot == string::npos) {
        return VK_SHADER_STAGE_ALL; // Invalid
    }
    ext = GetExtension(filename.substr(0, pivot));

    if (ext == "vert" || ext == "vertex") {
        return VK_SHADER_STAGE_VERTEX_BIT;
    }
    else if (ext == "frag" || ext == "fragment") {
        return VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    else if (ext == "tesc" || ext == "tesscontrol") {
        return VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT;
    }
    else if (ext == "tese" || ext == "tesseval") {
        return VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
    }
    else if (ext == "comp" || ext == "compute") {
        return VK_SHADER_STAGE_COMPUTE_BIT;
    }

    return VK_SHADER_STAGE_ALL; // Invalid
}

} // namespace Toon::Vulkan
```

`Modules/Vulkan/Private/VulkanTexture.cpp`:

```cpp
#include <Toon/Vulkan/VulkanTexture.hpp>

#include <Toon/Log.hpp>
#include <Toon/Benchmark.hpp>
#include <Toon/Vulkan/VulkanGraphicsDriver.hpp>

namespace Toon::Vulkan {

TOON_VULKAN_API
VulkanTexture::~VulkanTexture()
{

}

TOON_VULKAN_API
bool VulkanTexture::Load(const std::unique_ptr<TextureData>& data, Options opts /*= Options()*/)
{
    ToonBenchmarkStart();

    // VulkanGraphicsDriver * gfx = TOON_VULKAN_GRAPHICS_DRIVER(GetGraphicsDriver());

    // const auto& size = data->GetSize();
    // VkDeviceSize imageSize = size.x * size.y * data->GetComponents();

    // VkImageCreateInfo imageCreateInfo = {
    //     .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    //     .pNext = nullptr,
    //     .flags = 0,
    //     .imageType = VK_IMAGE_TYPE_2D,
    //     .format = GetVkDataFormat(data->GetComponents(), data->GetDataType()),
    //     .extent = {
    //         .width = size.x,
    //         .height = size.y,
    //         .depth = 1,
    //     },
    //     .mipLevels = 1,
    //     .arrayLayers = 1,
    //     .samples = VK_SAMPLE_COUNT_1_BIT,
    //     .tiling = VK_IMAGE_TILING_OPTIMAL,
    //     .usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
    //     .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    //     .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
    // };

    // if (vkCreateImage(gfx->GetDevice(), &imageCreateInfo, nullptr, &_vkImage) != VK_SUCCESS) {
    //     ToonLogError("Failed to create image");
    //     return false;
    // }

    // VkDeviceMemory memory;

    // TODO:

    ToonBenchmarkEnd();
    return true;
}

} // namespace Toon::Vulkan

```

`Modules/Vulkan/Private/glad/vulkan.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <glad/vulkan.h>

#ifndef GLAD_IMPL_UTIL_C_
#define GLAD_IMPL_UTIL_C_

#ifdef _MSC_VER
#define GLAD_IMPL_UTIL_SSCANF sscanf_s
#else
#define GLAD_IMPL_UTIL_SSCANF sscanf
#endif

#endif /* GLAD_IMPL_UTIL_C_ */

#ifdef __cplusplus
extern "C" {
#endif



int GLAD_VK_VERSION_1_0 = 0;
int GLAD_VK_VERSION_1_1 = 0;
int GLAD_VK_VERSION_1_2 = 0;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
int GLAD_VK_ANDROID_external_memory_android_hardware_buffer = 0;
#endif
int GLAD_VK_EXT_4444_formats = 0;
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
int GLAD_VK_EXT_acquire_xlib_display = 0;
#endif
int GLAD_VK_EXT_astc_decode_mode = 0;
int GLAD_VK_EXT_blend_operation_advanced = 0;
int GLAD_VK_EXT_buffer_device_address = 0;
int GLAD_VK_EXT_calibrated_timestamps = 0;
int GLAD_VK_EXT_conditional_rendering = 0;
int GLAD_VK_EXT_conservative_rasterization = 0;
int GLAD_VK_EXT_custom_border_color = 0;
int GLAD_VK_EXT_debug_marker = 0;
int GLAD_VK_EXT_debug_report = 0;
int GLAD_VK_EXT_debug_utils = 0;
int GLAD_VK_EXT_depth_clip_enable = 0;
int GLAD_VK_EXT_depth_range_unrestricted = 0;
int GLAD_VK_EXT_descriptor_indexing = 0;
int GLAD_VK_EXT_direct_mode_display = 0;
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
int GLAD_VK_EXT_directfb_surface = 0;
#endif
int GLAD_VK_EXT_discard_rectangles = 0;
int GLAD_VK_EXT_display_control = 0;
int GLAD_VK_EXT_display_surface_counter = 0;
int GLAD_VK_EXT_extended_dynamic_state = 0;
int GLAD_VK_EXT_external_memory_dma_buf = 0;
int GLAD_VK_EXT_external_memory_host = 0;
int GLAD_VK_EXT_filter_cubic = 0;
int GLAD_VK_EXT_fragment_density_map = 0;
int GLAD_VK_EXT_fragment_density_map2 = 0;
int GLAD_VK_EXT_fragment_shader_interlock = 0;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
int GLAD_VK_EXT_full_screen_exclusive = 0;
#endif
int GLAD_VK_EXT_global_priority = 0;
int GLAD_VK_EXT_hdr_metadata = 0;
int GLAD_VK_EXT_headless_surface = 0;
int GLAD_VK_EXT_host_query_reset = 0;
int GLAD_VK_EXT_image_drm_format_modifier = 0;
int GLAD_VK_EXT_image_robustness = 0;
int GLAD_VK_EXT_index_type_uint8 = 0;
int GLAD_VK_EXT_inline_uniform_block = 0;
int GLAD_VK_EXT_line_rasterization = 0;
int GLAD_VK_EXT_memory_budget = 0;
int GLAD_VK_EXT_memory_priority = 0;
#if defined(VK_USE_PLATFORM_METAL_EXT)
int GLAD_VK_EXT_metal_surface = 0;
#endif
int GLAD_VK_EXT_pci_bus_info = 0;
int GLAD_VK_EXT_pipeline_creation_cache_control = 0;
int GLAD_VK_EXT_pipeline_creation_feedback = 0;
int GLAD_VK_EXT_post_depth_coverage = 0;
int GLAD_VK_EXT_private_data = 0;
int GLAD_VK_EXT_queue_family_foreign = 0;
int GLAD_VK_EXT_robustness2 = 0;
int GLAD_VK_EXT_sample_locations = 0;
int GLAD_VK_EXT_sampler_filter_minmax = 0;
int GLAD_VK_EXT_scalar_block_layout = 0;
int GLAD_VK_EXT_separate_stencil_usage = 0;
int GLAD_VK_EXT_shader_atomic_float = 0;
int GLAD_VK_EXT_shader_demote_to_helper_invocation = 0;
int GLAD_VK_EXT_shader_stencil_export = 0;
int GLAD_VK_EXT_shader_subgroup_ballot = 0;
int GLAD_VK_EXT_shader_subgroup_vote = 0;
int GLAD_VK_EXT_shader_viewport_index_layer = 0;
int GLAD_VK_EXT_subgroup_size_control = 0;
int GLAD_VK_EXT_swapchain_colorspace = 0;
int GLAD_VK_EXT_texel_buffer_alignment = 0;
int GLAD_VK_EXT_texture_compression_astc_hdr = 0;
int GLAD_VK_EXT_tooling_info = 0;
int GLAD_VK_EXT_transform_feedback = 0;
int GLAD_VK_EXT_validation_cache = 0;
int GLAD_VK_EXT_validation_features = 0;
int GLAD_VK_EXT_validation_flags = 0;
int GLAD_VK_EXT_vertex_attribute_divisor = 0;
int GLAD_VK_EXT_ycbcr_image_arrays = 0;
int GLAD_VK_KHR_16bit_storage = 0;
int GLAD_VK_KHR_8bit_storage = 0;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
int GLAD_VK_KHR_android_surface = 0;
#endif
int GLAD_VK_KHR_bind_memory2 = 0;
int GLAD_VK_KHR_buffer_device_address = 0;
int GLAD_VK_KHR_create_renderpass2 = 0;
int GLAD_VK_KHR_dedicated_allocation = 0;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
int GLAD_VK_KHR_deferred_host_operations = 0;
#endif
int GLAD_VK_KHR_depth_stencil_resolve = 0;
int GLAD_VK_KHR_descriptor_update_template = 0;
int GLAD_VK_KHR_device_group = 0;
int GLAD_VK_KHR_device_group_creation = 0;
int GLAD_VK_KHR_display = 0;
int GLAD_VK_KHR_display_swapchain = 0;
int GLAD_VK_KHR_draw_indirect_count = 0;
int GLAD_VK_KHR_driver_properties = 0;
int GLAD_VK_KHR_external_fence = 0;
int GLAD_VK_KHR_external_fence_capabilities = 0;
int GLAD_VK_KHR_external_fence_fd = 0;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
int GLAD_VK_KHR_external_fence_win32 = 0;
#endif
int GLAD_VK_KHR_external_memory = 0;
int GLAD_VK_KHR_external_memory_capabilities = 0;
int GLAD_VK_KHR_external_memory_fd = 0;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
int GLAD_VK_KHR_external_memory_win32 = 0;
#endif
int GLAD_VK_KHR_external_semaphore = 0;
int GLAD_VK_KHR_external_semaphore_capabilities = 0;
int GLAD_VK_KHR_external_semaphore_fd = 0;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
int GLAD_VK_KHR_external_semaphore_win32 = 0;
#endif
int GLAD_VK_KHR_get_display_properties2 = 0;
int GLAD_VK_KHR_get_memory_requirements2 = 0;
int GLAD_VK_KHR_get_physical_device_properties2 = 0;
int GLAD_VK_KHR_get_surface_capabilities2 = 0;
int GLAD_VK_KHR_image_format_list = 0;
int GLAD_VK_KHR_imageless_framebuffer = 0;
int GLAD_VK_KHR_incremental_present = 0;
int GLAD_VK_KHR_maintenance1 = 0;
int GLAD_VK_KHR_maintenance2 = 0;
int GLAD_VK_KHR_maintenance3 = 0;
int GLAD_VK_KHR_multiview = 0;
int GLAD_VK_KHR_performance_query = 0;
int GLAD_VK_KHR_pipeline_executable_properties = 0;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
int GLAD_VK_KHR_pipeline_library = 0;
#endif
int GLAD_VK_KHR_push_descriptor = 0;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
int GLAD_VK_KHR_ray_tracing = 0;
#endif
int GLAD_VK_KHR_relaxed_block_layout = 0;
int GLAD_VK_KHR_sampler_mirror_clamp_to_edge = 0;
int GLAD_VK_KHR_sampler_ycbcr_conversion = 0;
int GLAD_VK_KHR_separate_depth_stencil_layouts = 0;
int GLAD_VK_KHR_shader_atomic_int64 = 0;
int GLAD_VK_KHR_shader_clock = 0;
int GLAD_VK_KHR_shader_draw_parameters = 0;
int GLAD_VK_KHR_shader_float16_int8 = 0;
int GLAD_VK_KHR_shader_float_controls = 0;
int GLAD_VK_KHR_shader_non_semantic_info = 0;
int GLAD_VK_KHR_shader_subgroup_extended_types = 0;
int GLAD_VK_KHR_shared_presentable_image = 0;
int GLAD_VK_KHR_spirv_1_4 = 0;
int GLAD_VK_KHR_storage_buffer_storage_class = 0;
int GLAD_VK_KHR_surface = 0;
int GLAD_VK_KHR_surface_protected_capabilities = 0;
int GLAD_VK_KHR_swapchain = 0;
int GLAD_VK_KHR_swapchain_mutable_format = 0;
int GLAD_VK_KHR_timeline_semaphore = 0;
int GLAD_VK_KHR_uniform_buffer_standard_layout = 0;
int GLAD_VK_KHR_variable_pointers = 0;
int GLAD_VK_KHR_vulkan_memory_model = 0;
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
int GLAD_VK_KHR_wayland_surface = 0;
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
int GLAD_VK_KHR_win32_keyed_mutex = 0;
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
int GLAD_VK_KHR_win32_surface = 0;
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
int GLAD_VK_KHR_xcb_surface = 0;
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
int GLAD_VK_KHR_xlib_surface = 0;
#endif



#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkAcquireFullScreenExclusiveModeEXT glad_vkAcquireFullScreenExclusiveModeEXT = NULL;
#endif
PFN_vkAcquireNextImage2KHR glad_vkAcquireNextImage2KHR = NULL;
PFN_vkAcquireNextImageKHR glad_vkAcquireNextImageKHR = NULL;
PFN_vkAcquireProfilingLockKHR glad_vkAcquireProfilingLockKHR = NULL;
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
PFN_vkAcquireXlibDisplayEXT glad_vkAcquireXlibDisplayEXT = NULL;
#endif
PFN_vkAllocateCommandBuffers glad_vkAllocateCommandBuffers = NULL;
PFN_vkAllocateDescriptorSets glad_vkAllocateDescriptorSets = NULL;
PFN_vkAllocateMemory glad_vkAllocateMemory = NULL;
PFN_vkBeginCommandBuffer glad_vkBeginCommandBuffer = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkBindAccelerationStructureMemoryKHR glad_vkBindAccelerationStructureMemoryKHR = NULL;
#endif
PFN_vkBindBufferMemory glad_vkBindBufferMemory = NULL;
PFN_vkBindBufferMemory2 glad_vkBindBufferMemory2 = NULL;
PFN_vkBindBufferMemory2KHR glad_vkBindBufferMemory2KHR = NULL;
PFN_vkBindImageMemory glad_vkBindImageMemory = NULL;
PFN_vkBindImageMemory2 glad_vkBindImageMemory2 = NULL;
PFN_vkBindImageMemory2KHR glad_vkBindImageMemory2KHR = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkBuildAccelerationStructureKHR glad_vkBuildAccelerationStructureKHR = NULL;
#endif
PFN_vkCmdBeginConditionalRenderingEXT glad_vkCmdBeginConditionalRenderingEXT = NULL;
PFN_vkCmdBeginDebugUtilsLabelEXT glad_vkCmdBeginDebugUtilsLabelEXT = NULL;
PFN_vkCmdBeginQuery glad_vkCmdBeginQuery = NULL;
PFN_vkCmdBeginQueryIndexedEXT glad_vkCmdBeginQueryIndexedEXT = NULL;
PFN_vkCmdBeginRenderPass glad_vkCmdBeginRenderPass = NULL;
PFN_vkCmdBeginRenderPass2 glad_vkCmdBeginRenderPass2 = NULL;
PFN_vkCmdBeginRenderPass2KHR glad_vkCmdBeginRenderPass2KHR = NULL;
PFN_vkCmdBeginTransformFeedbackEXT glad_vkCmdBeginTransformFeedbackEXT = NULL;
PFN_vkCmdBindDescriptorSets glad_vkCmdBindDescriptorSets = NULL;
PFN_vkCmdBindIndexBuffer glad_vkCmdBindIndexBuffer = NULL;
PFN_vkCmdBindPipeline glad_vkCmdBindPipeline = NULL;
PFN_vkCmdBindTransformFeedbackBuffersEXT glad_vkCmdBindTransformFeedbackBuffersEXT = NULL;
PFN_vkCmdBindVertexBuffers glad_vkCmdBindVertexBuffers = NULL;
PFN_vkCmdBindVertexBuffers2EXT glad_vkCmdBindVertexBuffers2EXT = NULL;
PFN_vkCmdBlitImage glad_vkCmdBlitImage = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCmdBuildAccelerationStructureIndirectKHR glad_vkCmdBuildAccelerationStructureIndirectKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCmdBuildAccelerationStructureKHR glad_vkCmdBuildAccelerationStructureKHR = NULL;
#endif
PFN_vkCmdClearAttachments glad_vkCmdClearAttachments = NULL;
PFN_vkCmdClearColorImage glad_vkCmdClearColorImage = NULL;
PFN_vkCmdClearDepthStencilImage glad_vkCmdClearDepthStencilImage = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCmdCopyAccelerationStructureKHR glad_vkCmdCopyAccelerationStructureKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCmdCopyAccelerationStructureToMemoryKHR glad_vkCmdCopyAccelerationStructureToMemoryKHR = NULL;
#endif
PFN_vkCmdCopyBuffer glad_vkCmdCopyBuffer = NULL;
PFN_vkCmdCopyBufferToImage glad_vkCmdCopyBufferToImage = NULL;
PFN_vkCmdCopyImage glad_vkCmdCopyImage = NULL;
PFN_vkCmdCopyImageToBuffer glad_vkCmdCopyImageToBuffer = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCmdCopyMemoryToAccelerationStructureKHR glad_vkCmdCopyMemoryToAccelerationStructureKHR = NULL;
#endif
PFN_vkCmdCopyQueryPoolResults glad_vkCmdCopyQueryPoolResults = NULL;
PFN_vkCmdDebugMarkerBeginEXT glad_vkCmdDebugMarkerBeginEXT = NULL;
PFN_vkCmdDebugMarkerEndEXT glad_vkCmdDebugMarkerEndEXT = NULL;
PFN_vkCmdDebugMarkerInsertEXT glad_vkCmdDebugMarkerInsertEXT = NULL;
PFN_vkCmdDispatch glad_vkCmdDispatch = NULL;
PFN_vkCmdDispatchBase glad_vkCmdDispatchBase = NULL;
PFN_vkCmdDispatchBaseKHR glad_vkCmdDispatchBaseKHR = NULL;
PFN_vkCmdDispatchIndirect glad_vkCmdDispatchIndirect = NULL;
PFN_vkCmdDraw glad_vkCmdDraw = NULL;
PFN_vkCmdDrawIndexed glad_vkCmdDrawIndexed = NULL;
PFN_vkCmdDrawIndexedIndirect glad_vkCmdDrawIndexedIndirect = NULL;
PFN_vkCmdDrawIndexedIndirectCount glad_vkCmdDrawIndexedIndirectCount = NULL;
PFN_vkCmdDrawIndexedIndirectCountKHR glad_vkCmdDrawIndexedIndirectCountKHR = NULL;
PFN_vkCmdDrawIndirect glad_vkCmdDrawIndirect = NULL;
PFN_vkCmdDrawIndirectByteCountEXT glad_vkCmdDrawIndirectByteCountEXT = NULL;
PFN_vkCmdDrawIndirectCount glad_vkCmdDrawIndirectCount = NULL;
PFN_vkCmdDrawIndirectCountKHR glad_vkCmdDrawIndirectCountKHR = NULL;
PFN_vkCmdEndConditionalRenderingEXT glad_vkCmdEndConditionalRenderingEXT = NULL;
PFN_vkCmdEndDebugUtilsLabelEXT glad_vkCmdEndDebugUtilsLabelEXT = NULL;
PFN_vkCmdEndQuery glad_vkCmdEndQuery = NULL;
PFN_vkCmdEndQueryIndexedEXT glad_vkCmdEndQueryIndexedEXT = NULL;
PFN_vkCmdEndRenderPass glad_vkCmdEndRenderPass = NULL;
PFN_vkCmdEndRenderPass2 glad_vkCmdEndRenderPass2 = NULL;
PFN_vkCmdEndRenderPass2KHR glad_vkCmdEndRenderPass2KHR = NULL;
PFN_vkCmdEndTransformFeedbackEXT glad_vkCmdEndTransformFeedbackEXT = NULL;
PFN_vkCmdExecuteCommands glad_vkCmdExecuteCommands = NULL;
PFN_vkCmdFillBuffer glad_vkCmdFillBuffer = NULL;
PFN_vkCmdInsertDebugUtilsLabelEXT glad_vkCmdInsertDebugUtilsLabelEXT = NULL;
PFN_vkCmdNextSubpass glad_vkCmdNextSubpass = NULL;
PFN_vkCmdNextSubpass2 glad_vkCmdNextSubpass2 = NULL;
PFN_vkCmdNextSubpass2KHR glad_vkCmdNextSubpass2KHR = NULL;
PFN_vkCmdPipelineBarrier glad_vkCmdPipelineBarrier = NULL;
PFN_vkCmdPushConstants glad_vkCmdPushConstants = NULL;
PFN_vkCmdPushDescriptorSetKHR glad_vkCmdPushDescriptorSetKHR = NULL;
PFN_vkCmdPushDescriptorSetWithTemplateKHR glad_vkCmdPushDescriptorSetWithTemplateKHR = NULL;
PFN_vkCmdResetEvent glad_vkCmdResetEvent = NULL;
PFN_vkCmdResetQueryPool glad_vkCmdResetQueryPool = NULL;
PFN_vkCmdResolveImage glad_vkCmdResolveImage = NULL;
PFN_vkCmdSetBlendConstants glad_vkCmdSetBlendConstants = NULL;
PFN_vkCmdSetCullModeEXT glad_vkCmdSetCullModeEXT = NULL;
PFN_vkCmdSetDepthBias glad_vkCmdSetDepthBias = NULL;
PFN_vkCmdSetDepthBounds glad_vkCmdSetDepthBounds = NULL;
PFN_vkCmdSetDepthBoundsTestEnableEXT glad_vkCmdSetDepthBoundsTestEnableEXT = NULL;
PFN_vkCmdSetDepthCompareOpEXT glad_vkCmdSetDepthCompareOpEXT = NULL;
PFN_vkCmdSetDepthTestEnableEXT glad_vkCmdSetDepthTestEnableEXT = NULL;
PFN_vkCmdSetDepthWriteEnableEXT glad_vkCmdSetDepthWriteEnableEXT = NULL;
PFN_vkCmdSetDeviceMask glad_vkCmdSetDeviceMask = NULL;
PFN_vkCmdSetDeviceMaskKHR glad_vkCmdSetDeviceMaskKHR = NULL;
PFN_vkCmdSetDiscardRectangleEXT glad_vkCmdSetDiscardRectangleEXT = NULL;
PFN_vkCmdSetEvent glad_vkCmdSetEvent = NULL;
PFN_vkCmdSetFrontFaceEXT glad_vkCmdSetFrontFaceEXT = NULL;
PFN_vkCmdSetLineStippleEXT glad_vkCmdSetLineStippleEXT = NULL;
PFN_vkCmdSetLineWidth glad_vkCmdSetLineWidth = NULL;
PFN_vkCmdSetPrimitiveTopologyEXT glad_vkCmdSetPrimitiveTopologyEXT = NULL;
PFN_vkCmdSetSampleLocationsEXT glad_vkCmdSetSampleLocationsEXT = NULL;
PFN_vkCmdSetScissor glad_vkCmdSetScissor = NULL;
PFN_vkCmdSetScissorWithCountEXT glad_vkCmdSetScissorWithCountEXT = NULL;
PFN_vkCmdSetStencilCompareMask glad_vkCmdSetStencilCompareMask = NULL;
PFN_vkCmdSetStencilOpEXT glad_vkCmdSetStencilOpEXT = NULL;
PFN_vkCmdSetStencilReference glad_vkCmdSetStencilReference = NULL;
PFN_vkCmdSetStencilTestEnableEXT glad_vkCmdSetStencilTestEnableEXT = NULL;
PFN_vkCmdSetStencilWriteMask glad_vkCmdSetStencilWriteMask = NULL;
PFN_vkCmdSetViewport glad_vkCmdSetViewport = NULL;
PFN_vkCmdSetViewportWithCountEXT glad_vkCmdSetViewportWithCountEXT = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCmdTraceRaysIndirectKHR glad_vkCmdTraceRaysIndirectKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCmdTraceRaysKHR glad_vkCmdTraceRaysKHR = NULL;
#endif
PFN_vkCmdUpdateBuffer glad_vkCmdUpdateBuffer = NULL;
PFN_vkCmdWaitEvents glad_vkCmdWaitEvents = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCmdWriteAccelerationStructuresPropertiesKHR glad_vkCmdWriteAccelerationStructuresPropertiesKHR = NULL;
#endif
PFN_vkCmdWriteTimestamp glad_vkCmdWriteTimestamp = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCopyAccelerationStructureKHR glad_vkCopyAccelerationStructureKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCopyAccelerationStructureToMemoryKHR glad_vkCopyAccelerationStructureToMemoryKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCopyMemoryToAccelerationStructureKHR glad_vkCopyMemoryToAccelerationStructureKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCreateAccelerationStructureKHR glad_vkCreateAccelerationStructureKHR = NULL;
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
PFN_vkCreateAndroidSurfaceKHR glad_vkCreateAndroidSurfaceKHR = NULL;
#endif
PFN_vkCreateBuffer glad_vkCreateBuffer = NULL;
PFN_vkCreateBufferView glad_vkCreateBufferView = NULL;
PFN_vkCreateCommandPool glad_vkCreateCommandPool = NULL;
PFN_vkCreateComputePipelines glad_vkCreateComputePipelines = NULL;
PFN_vkCreateDebugReportCallbackEXT glad_vkCreateDebugReportCallbackEXT = NULL;
PFN_vkCreateDebugUtilsMessengerEXT glad_vkCreateDebugUtilsMessengerEXT = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCreateDeferredOperationKHR glad_vkCreateDeferredOperationKHR = NULL;
#endif
PFN_vkCreateDescriptorPool glad_vkCreateDescriptorPool = NULL;
PFN_vkCreateDescriptorSetLayout glad_vkCreateDescriptorSetLayout = NULL;
PFN_vkCreateDescriptorUpdateTemplate glad_vkCreateDescriptorUpdateTemplate = NULL;
PFN_vkCreateDescriptorUpdateTemplateKHR glad_vkCreateDescriptorUpdateTemplateKHR = NULL;
PFN_vkCreateDevice glad_vkCreateDevice = NULL;
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
PFN_vkCreateDirectFBSurfaceEXT glad_vkCreateDirectFBSurfaceEXT = NULL;
#endif
PFN_vkCreateDisplayModeKHR glad_vkCreateDisplayModeKHR = NULL;
PFN_vkCreateDisplayPlaneSurfaceKHR glad_vkCreateDisplayPlaneSurfaceKHR = NULL;
PFN_vkCreateEvent glad_vkCreateEvent = NULL;
PFN_vkCreateFence glad_vkCreateFence = NULL;
PFN_vkCreateFramebuffer glad_vkCreateFramebuffer = NULL;
PFN_vkCreateGraphicsPipelines glad_vkCreateGraphicsPipelines = NULL;
PFN_vkCreateHeadlessSurfaceEXT glad_vkCreateHeadlessSurfaceEXT = NULL;
PFN_vkCreateImage glad_vkCreateImage = NULL;
PFN_vkCreateImageView glad_vkCreateImageView = NULL;
PFN_vkCreateInstance glad_vkCreateInstance = NULL;
#if defined(VK_USE_PLATFORM_METAL_EXT)
PFN_vkCreateMetalSurfaceEXT glad_vkCreateMetalSurfaceEXT = NULL;
#endif
PFN_vkCreatePipelineCache glad_vkCreatePipelineCache = NULL;
PFN_vkCreatePipelineLayout glad_vkCreatePipelineLayout = NULL;
PFN_vkCreatePrivateDataSlotEXT glad_vkCreatePrivateDataSlotEXT = NULL;
PFN_vkCreateQueryPool glad_vkCreateQueryPool = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkCreateRayTracingPipelinesKHR glad_vkCreateRayTracingPipelinesKHR = NULL;
#endif
PFN_vkCreateRenderPass glad_vkCreateRenderPass = NULL;
PFN_vkCreateRenderPass2 glad_vkCreateRenderPass2 = NULL;
PFN_vkCreateRenderPass2KHR glad_vkCreateRenderPass2KHR = NULL;
PFN_vkCreateSampler glad_vkCreateSampler = NULL;
PFN_vkCreateSamplerYcbcrConversion glad_vkCreateSamplerYcbcrConversion = NULL;
PFN_vkCreateSamplerYcbcrConversionKHR glad_vkCreateSamplerYcbcrConversionKHR = NULL;
PFN_vkCreateSemaphore glad_vkCreateSemaphore = NULL;
PFN_vkCreateShaderModule glad_vkCreateShaderModule = NULL;
PFN_vkCreateSharedSwapchainsKHR glad_vkCreateSharedSwapchainsKHR = NULL;
PFN_vkCreateSwapchainKHR glad_vkCreateSwapchainKHR = NULL;
PFN_vkCreateValidationCacheEXT glad_vkCreateValidationCacheEXT = NULL;
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
PFN_vkCreateWaylandSurfaceKHR glad_vkCreateWaylandSurfaceKHR = NULL;
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkCreateWin32SurfaceKHR glad_vkCreateWin32SurfaceKHR = NULL;
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
PFN_vkCreateXcbSurfaceKHR glad_vkCreateXcbSurfaceKHR = NULL;
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
PFN_vkCreateXlibSurfaceKHR glad_vkCreateXlibSurfaceKHR = NULL;
#endif
PFN_vkDebugMarkerSetObjectNameEXT glad_vkDebugMarkerSetObjectNameEXT = NULL;
PFN_vkDebugMarkerSetObjectTagEXT glad_vkDebugMarkerSetObjectTagEXT = NULL;
PFN_vkDebugReportMessageEXT glad_vkDebugReportMessageEXT = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkDeferredOperationJoinKHR glad_vkDeferredOperationJoinKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkDestroyAccelerationStructureKHR glad_vkDestroyAccelerationStructureKHR = NULL;
#endif
PFN_vkDestroyBuffer glad_vkDestroyBuffer = NULL;
PFN_vkDestroyBufferView glad_vkDestroyBufferView = NULL;
PFN_vkDestroyCommandPool glad_vkDestroyCommandPool = NULL;
PFN_vkDestroyDebugReportCallbackEXT glad_vkDestroyDebugReportCallbackEXT = NULL;
PFN_vkDestroyDebugUtilsMessengerEXT glad_vkDestroyDebugUtilsMessengerEXT = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkDestroyDeferredOperationKHR glad_vkDestroyDeferredOperationKHR = NULL;
#endif
PFN_vkDestroyDescriptorPool glad_vkDestroyDescriptorPool = NULL;
PFN_vkDestroyDescriptorSetLayout glad_vkDestroyDescriptorSetLayout = NULL;
PFN_vkDestroyDescriptorUpdateTemplate glad_vkDestroyDescriptorUpdateTemplate = NULL;
PFN_vkDestroyDescriptorUpdateTemplateKHR glad_vkDestroyDescriptorUpdateTemplateKHR = NULL;
PFN_vkDestroyDevice glad_vkDestroyDevice = NULL;
PFN_vkDestroyEvent glad_vkDestroyEvent = NULL;
PFN_vkDestroyFence glad_vkDestroyFence = NULL;
PFN_vkDestroyFramebuffer glad_vkDestroyFramebuffer = NULL;
PFN_vkDestroyImage glad_vkDestroyImage = NULL;
PFN_vkDestroyImageView glad_vkDestroyImageView = NULL;
PFN_vkDestroyInstance glad_vkDestroyInstance = NULL;
PFN_vkDestroyPipeline glad_vkDestroyPipeline = NULL;
PFN_vkDestroyPipelineCache glad_vkDestroyPipelineCache = NULL;
PFN_vkDestroyPipelineLayout glad_vkDestroyPipelineLayout = NULL;
PFN_vkDestroyPrivateDataSlotEXT glad_vkDestroyPrivateDataSlotEXT = NULL;
PFN_vkDestroyQueryPool glad_vkDestroyQueryPool = NULL;
PFN_vkDestroyRenderPass glad_vkDestroyRenderPass = NULL;
PFN_vkDestroySampler glad_vkDestroySampler = NULL;
PFN_vkDestroySamplerYcbcrConversion glad_vkDestroySamplerYcbcrConversion = NULL;
PFN_vkDestroySamplerYcbcrConversionKHR glad_vkDestroySamplerYcbcrConversionKHR = NULL;
PFN_vkDestroySemaphore glad_vkDestroySemaphore = NULL;
PFN_vkDestroyShaderModule glad_vkDestroyShaderModule = NULL;
PFN_vkDestroySurfaceKHR glad_vkDestroySurfaceKHR = NULL;
PFN_vkDestroySwapchainKHR glad_vkDestroySwapchainKHR = NULL;
PFN_vkDestroyValidationCacheEXT glad_vkDestroyValidationCacheEXT = NULL;
PFN_vkDeviceWaitIdle glad_vkDeviceWaitIdle = NULL;
PFN_vkDisplayPowerControlEXT glad_vkDisplayPowerControlEXT = NULL;
PFN_vkEndCommandBuffer glad_vkEndCommandBuffer = NULL;
PFN_vkEnumerateDeviceExtensionProperties glad_vkEnumerateDeviceExtensionProperties = NULL;
PFN_vkEnumerateDeviceLayerProperties glad_vkEnumerateDeviceLayerProperties = NULL;
PFN_vkEnumerateInstanceExtensionProperties glad_vkEnumerateInstanceExtensionProperties = NULL;
PFN_vkEnumerateInstanceLayerProperties glad_vkEnumerateInstanceLayerProperties = NULL;
PFN_vkEnumerateInstanceVersion glad_vkEnumerateInstanceVersion = NULL;
PFN_vkEnumeratePhysicalDeviceGroups glad_vkEnumeratePhysicalDeviceGroups = NULL;
PFN_vkEnumeratePhysicalDeviceGroupsKHR glad_vkEnumeratePhysicalDeviceGroupsKHR = NULL;
PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR glad_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = NULL;
PFN_vkEnumeratePhysicalDevices glad_vkEnumeratePhysicalDevices = NULL;
PFN_vkFlushMappedMemoryRanges glad_vkFlushMappedMemoryRanges = NULL;
PFN_vkFreeCommandBuffers glad_vkFreeCommandBuffers = NULL;
PFN_vkFreeDescriptorSets glad_vkFreeDescriptorSets = NULL;
PFN_vkFreeMemory glad_vkFreeMemory = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkGetAccelerationStructureDeviceAddressKHR glad_vkGetAccelerationStructureDeviceAddressKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkGetAccelerationStructureMemoryRequirementsKHR glad_vkGetAccelerationStructureMemoryRequirementsKHR = NULL;
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
PFN_vkGetAndroidHardwareBufferPropertiesANDROID glad_vkGetAndroidHardwareBufferPropertiesANDROID = NULL;
#endif
PFN_vkGetBufferDeviceAddress glad_vkGetBufferDeviceAddress = NULL;
PFN_vkGetBufferDeviceAddressEXT glad_vkGetBufferDeviceAddressEXT = NULL;
PFN_vkGetBufferDeviceAddressKHR glad_vkGetBufferDeviceAddressKHR = NULL;
PFN_vkGetBufferMemoryRequirements glad_vkGetBufferMemoryRequirements = NULL;
PFN_vkGetBufferMemoryRequirements2 glad_vkGetBufferMemoryRequirements2 = NULL;
PFN_vkGetBufferMemoryRequirements2KHR glad_vkGetBufferMemoryRequirements2KHR = NULL;
PFN_vkGetBufferOpaqueCaptureAddress glad_vkGetBufferOpaqueCaptureAddress = NULL;
PFN_vkGetBufferOpaqueCaptureAddressKHR glad_vkGetBufferOpaqueCaptureAddressKHR = NULL;
PFN_vkGetCalibratedTimestampsEXT glad_vkGetCalibratedTimestampsEXT = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkGetDeferredOperationMaxConcurrencyKHR glad_vkGetDeferredOperationMaxConcurrencyKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkGetDeferredOperationResultKHR glad_vkGetDeferredOperationResultKHR = NULL;
#endif
PFN_vkGetDescriptorSetLayoutSupport glad_vkGetDescriptorSetLayoutSupport = NULL;
PFN_vkGetDescriptorSetLayoutSupportKHR glad_vkGetDescriptorSetLayoutSupportKHR = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkGetDeviceAccelerationStructureCompatibilityKHR glad_vkGetDeviceAccelerationStructureCompatibilityKHR = NULL;
#endif
PFN_vkGetDeviceGroupPeerMemoryFeatures glad_vkGetDeviceGroupPeerMemoryFeatures = NULL;
PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR glad_vkGetDeviceGroupPeerMemoryFeaturesKHR = NULL;
PFN_vkGetDeviceGroupPresentCapabilitiesKHR glad_vkGetDeviceGroupPresentCapabilitiesKHR = NULL;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkGetDeviceGroupSurfacePresentModes2EXT glad_vkGetDeviceGroupSurfacePresentModes2EXT = NULL;
#endif
PFN_vkGetDeviceGroupSurfacePresentModesKHR glad_vkGetDeviceGroupSurfacePresentModesKHR = NULL;
PFN_vkGetDeviceMemoryCommitment glad_vkGetDeviceMemoryCommitment = NULL;
PFN_vkGetDeviceMemoryOpaqueCaptureAddress glad_vkGetDeviceMemoryOpaqueCaptureAddress = NULL;
PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR glad_vkGetDeviceMemoryOpaqueCaptureAddressKHR = NULL;
PFN_vkGetDeviceProcAddr glad_vkGetDeviceProcAddr = NULL;
PFN_vkGetDeviceQueue glad_vkGetDeviceQueue = NULL;
PFN_vkGetDeviceQueue2 glad_vkGetDeviceQueue2 = NULL;
PFN_vkGetDisplayModeProperties2KHR glad_vkGetDisplayModeProperties2KHR = NULL;
PFN_vkGetDisplayModePropertiesKHR glad_vkGetDisplayModePropertiesKHR = NULL;
PFN_vkGetDisplayPlaneCapabilities2KHR glad_vkGetDisplayPlaneCapabilities2KHR = NULL;
PFN_vkGetDisplayPlaneCapabilitiesKHR glad_vkGetDisplayPlaneCapabilitiesKHR = NULL;
PFN_vkGetDisplayPlaneSupportedDisplaysKHR glad_vkGetDisplayPlaneSupportedDisplaysKHR = NULL;
PFN_vkGetEventStatus glad_vkGetEventStatus = NULL;
PFN_vkGetFenceFdKHR glad_vkGetFenceFdKHR = NULL;
PFN_vkGetFenceStatus glad_vkGetFenceStatus = NULL;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkGetFenceWin32HandleKHR glad_vkGetFenceWin32HandleKHR = NULL;
#endif
PFN_vkGetImageDrmFormatModifierPropertiesEXT glad_vkGetImageDrmFormatModifierPropertiesEXT = NULL;
PFN_vkGetImageMemoryRequirements glad_vkGetImageMemoryRequirements = NULL;
PFN_vkGetImageMemoryRequirements2 glad_vkGetImageMemoryRequirements2 = NULL;
PFN_vkGetImageMemoryRequirements2KHR glad_vkGetImageMemoryRequirements2KHR = NULL;
PFN_vkGetImageSparseMemoryRequirements glad_vkGetImageSparseMemoryRequirements = NULL;
PFN_vkGetImageSparseMemoryRequirements2 glad_vkGetImageSparseMemoryRequirements2 = NULL;
PFN_vkGetImageSparseMemoryRequirements2KHR glad_vkGetImageSparseMemoryRequirements2KHR = NULL;
PFN_vkGetImageSubresourceLayout glad_vkGetImageSubresourceLayout = NULL;
PFN_vkGetInstanceProcAddr glad_vkGetInstanceProcAddr = NULL;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
PFN_vkGetMemoryAndroidHardwareBufferANDROID glad_vkGetMemoryAndroidHardwareBufferANDROID = NULL;
#endif
PFN_vkGetMemoryFdKHR glad_vkGetMemoryFdKHR = NULL;
PFN_vkGetMemoryFdPropertiesKHR glad_vkGetMemoryFdPropertiesKHR = NULL;
PFN_vkGetMemoryHostPointerPropertiesEXT glad_vkGetMemoryHostPointerPropertiesEXT = NULL;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkGetMemoryWin32HandleKHR glad_vkGetMemoryWin32HandleKHR = NULL;
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkGetMemoryWin32HandlePropertiesKHR glad_vkGetMemoryWin32HandlePropertiesKHR = NULL;
#endif
PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT glad_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = NULL;
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT glad_vkGetPhysicalDeviceDirectFBPresentationSupportEXT = NULL;
#endif
PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR glad_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = NULL;
PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR glad_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = NULL;
PFN_vkGetPhysicalDeviceDisplayProperties2KHR glad_vkGetPhysicalDeviceDisplayProperties2KHR = NULL;
PFN_vkGetPhysicalDeviceDisplayPropertiesKHR glad_vkGetPhysicalDeviceDisplayPropertiesKHR = NULL;
PFN_vkGetPhysicalDeviceExternalBufferProperties glad_vkGetPhysicalDeviceExternalBufferProperties = NULL;
PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR glad_vkGetPhysicalDeviceExternalBufferPropertiesKHR = NULL;
PFN_vkGetPhysicalDeviceExternalFenceProperties glad_vkGetPhysicalDeviceExternalFenceProperties = NULL;
PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR glad_vkGetPhysicalDeviceExternalFencePropertiesKHR = NULL;
PFN_vkGetPhysicalDeviceExternalSemaphoreProperties glad_vkGetPhysicalDeviceExternalSemaphoreProperties = NULL;
PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR glad_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = NULL;
PFN_vkGetPhysicalDeviceFeatures glad_vkGetPhysicalDeviceFeatures = NULL;
PFN_vkGetPhysicalDeviceFeatures2 glad_vkGetPhysicalDeviceFeatures2 = NULL;
PFN_vkGetPhysicalDeviceFeatures2KHR glad_vkGetPhysicalDeviceFeatures2KHR = NULL;
PFN_vkGetPhysicalDeviceFormatProperties glad_vkGetPhysicalDeviceFormatProperties = NULL;
PFN_vkGetPhysicalDeviceFormatProperties2 glad_vkGetPhysicalDeviceFormatProperties2 = NULL;
PFN_vkGetPhysicalDeviceFormatProperties2KHR glad_vkGetPhysicalDeviceFormatProperties2KHR = NULL;
PFN_vkGetPhysicalDeviceImageFormatProperties glad_vkGetPhysicalDeviceImageFormatProperties = NULL;
PFN_vkGetPhysicalDeviceImageFormatProperties2 glad_vkGetPhysicalDeviceImageFormatProperties2 = NULL;
PFN_vkGetPhysicalDeviceImageFormatProperties2KHR glad_vkGetPhysicalDeviceImageFormatProperties2KHR = NULL;
PFN_vkGetPhysicalDeviceMemoryProperties glad_vkGetPhysicalDeviceMemoryProperties = NULL;
PFN_vkGetPhysicalDeviceMemoryProperties2 glad_vkGetPhysicalDeviceMemoryProperties2 = NULL;
PFN_vkGetPhysicalDeviceMemoryProperties2KHR glad_vkGetPhysicalDeviceMemoryProperties2KHR = NULL;
PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT glad_vkGetPhysicalDeviceMultisamplePropertiesEXT = NULL;
PFN_vkGetPhysicalDevicePresentRectanglesKHR glad_vkGetPhysicalDevicePresentRectanglesKHR = NULL;
PFN_vkGetPhysicalDeviceProperties glad_vkGetPhysicalDeviceProperties = NULL;
PFN_vkGetPhysicalDeviceProperties2 glad_vkGetPhysicalDeviceProperties2 = NULL;
PFN_vkGetPhysicalDeviceProperties2KHR glad_vkGetPhysicalDeviceProperties2KHR = NULL;
PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR glad_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = NULL;
PFN_vkGetPhysicalDeviceQueueFamilyProperties glad_vkGetPhysicalDeviceQueueFamilyProperties = NULL;
PFN_vkGetPhysicalDeviceQueueFamilyProperties2 glad_vkGetPhysicalDeviceQueueFamilyProperties2 = NULL;
PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR glad_vkGetPhysicalDeviceQueueFamilyProperties2KHR = NULL;
PFN_vkGetPhysicalDeviceSparseImageFormatProperties glad_vkGetPhysicalDeviceSparseImageFormatProperties = NULL;
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 glad_vkGetPhysicalDeviceSparseImageFormatProperties2 = NULL;
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR glad_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = NULL;
PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT glad_vkGetPhysicalDeviceSurfaceCapabilities2EXT = NULL;
PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR glad_vkGetPhysicalDeviceSurfaceCapabilities2KHR = NULL;
PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR glad_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = NULL;
PFN_vkGetPhysicalDeviceSurfaceFormats2KHR glad_vkGetPhysicalDeviceSurfaceFormats2KHR = NULL;
PFN_vkGetPhysicalDeviceSurfaceFormatsKHR glad_vkGetPhysicalDeviceSurfaceFormatsKHR = NULL;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT glad_vkGetPhysicalDeviceSurfacePresentModes2EXT = NULL;
#endif
PFN_vkGetPhysicalDeviceSurfacePresentModesKHR glad_vkGetPhysicalDeviceSurfacePresentModesKHR = NULL;
PFN_vkGetPhysicalDeviceSurfaceSupportKHR glad_vkGetPhysicalDeviceSurfaceSupportKHR = NULL;
PFN_vkGetPhysicalDeviceToolPropertiesEXT glad_vkGetPhysicalDeviceToolPropertiesEXT = NULL;
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR glad_vkGetPhysicalDeviceWaylandPresentationSupportKHR = NULL;
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR glad_vkGetPhysicalDeviceWin32PresentationSupportKHR = NULL;
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR glad_vkGetPhysicalDeviceXcbPresentationSupportKHR = NULL;
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR glad_vkGetPhysicalDeviceXlibPresentationSupportKHR = NULL;
#endif
PFN_vkGetPipelineCacheData glad_vkGetPipelineCacheData = NULL;
PFN_vkGetPipelineExecutableInternalRepresentationsKHR glad_vkGetPipelineExecutableInternalRepresentationsKHR = NULL;
PFN_vkGetPipelineExecutablePropertiesKHR glad_vkGetPipelineExecutablePropertiesKHR = NULL;
PFN_vkGetPipelineExecutableStatisticsKHR glad_vkGetPipelineExecutableStatisticsKHR = NULL;
PFN_vkGetPrivateDataEXT glad_vkGetPrivateDataEXT = NULL;
PFN_vkGetQueryPoolResults glad_vkGetQueryPoolResults = NULL;
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
PFN_vkGetRandROutputDisplayEXT glad_vkGetRandROutputDisplayEXT = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR glad_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = NULL;
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkGetRayTracingShaderGroupHandlesKHR glad_vkGetRayTracingShaderGroupHandlesKHR = NULL;
#endif
PFN_vkGetRenderAreaGranularity glad_vkGetRenderAreaGranularity = NULL;
PFN_vkGetSemaphoreCounterValue glad_vkGetSemaphoreCounterValue = NULL;
PFN_vkGetSemaphoreCounterValueKHR glad_vkGetSemaphoreCounterValueKHR = NULL;
PFN_vkGetSemaphoreFdKHR glad_vkGetSemaphoreFdKHR = NULL;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkGetSemaphoreWin32HandleKHR glad_vkGetSemaphoreWin32HandleKHR = NULL;
#endif
PFN_vkGetSwapchainCounterEXT glad_vkGetSwapchainCounterEXT = NULL;
PFN_vkGetSwapchainImagesKHR glad_vkGetSwapchainImagesKHR = NULL;
PFN_vkGetSwapchainStatusKHR glad_vkGetSwapchainStatusKHR = NULL;
PFN_vkGetValidationCacheDataEXT glad_vkGetValidationCacheDataEXT = NULL;
PFN_vkImportFenceFdKHR glad_vkImportFenceFdKHR = NULL;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkImportFenceWin32HandleKHR glad_vkImportFenceWin32HandleKHR = NULL;
#endif
PFN_vkImportSemaphoreFdKHR glad_vkImportSemaphoreFdKHR = NULL;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkImportSemaphoreWin32HandleKHR glad_vkImportSemaphoreWin32HandleKHR = NULL;
#endif
PFN_vkInvalidateMappedMemoryRanges glad_vkInvalidateMappedMemoryRanges = NULL;
PFN_vkMapMemory glad_vkMapMemory = NULL;
PFN_vkMergePipelineCaches glad_vkMergePipelineCaches = NULL;
PFN_vkMergeValidationCachesEXT glad_vkMergeValidationCachesEXT = NULL;
PFN_vkQueueBeginDebugUtilsLabelEXT glad_vkQueueBeginDebugUtilsLabelEXT = NULL;
PFN_vkQueueBindSparse glad_vkQueueBindSparse = NULL;
PFN_vkQueueEndDebugUtilsLabelEXT glad_vkQueueEndDebugUtilsLabelEXT = NULL;
PFN_vkQueueInsertDebugUtilsLabelEXT glad_vkQueueInsertDebugUtilsLabelEXT = NULL;
PFN_vkQueuePresentKHR glad_vkQueuePresentKHR = NULL;
PFN_vkQueueSubmit glad_vkQueueSubmit = NULL;
PFN_vkQueueWaitIdle glad_vkQueueWaitIdle = NULL;
PFN_vkRegisterDeviceEventEXT glad_vkRegisterDeviceEventEXT = NULL;
PFN_vkRegisterDisplayEventEXT glad_vkRegisterDisplayEventEXT = NULL;
PFN_vkReleaseDisplayEXT glad_vkReleaseDisplayEXT = NULL;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
PFN_vkReleaseFullScreenExclusiveModeEXT glad_vkReleaseFullScreenExclusiveModeEXT = NULL;
#endif
PFN_vkReleaseProfilingLockKHR glad_vkReleaseProfilingLockKHR = NULL;
PFN_vkResetCommandBuffer glad_vkResetCommandBuffer = NULL;
PFN_vkResetCommandPool glad_vkResetCommandPool = NULL;
PFN_vkResetDescriptorPool glad_vkResetDescriptorPool = NULL;
PFN_vkResetEvent glad_vkResetEvent = NULL;
PFN_vkResetFences glad_vkResetFences = NULL;
PFN_vkResetQueryPool glad_vkResetQueryPool = NULL;
PFN_vkResetQueryPoolEXT glad_vkResetQueryPoolEXT = NULL;
PFN_vkSetDebugUtilsObjectNameEXT glad_vkSetDebugUtilsObjectNameEXT = NULL;
PFN_vkSetDebugUtilsObjectTagEXT glad_vkSetDebugUtilsObjectTagEXT = NULL;
PFN_vkSetEvent glad_vkSetEvent = NULL;
PFN_vkSetHdrMetadataEXT glad_vkSetHdrMetadataEXT = NULL;
PFN_vkSetPrivateDataEXT glad_vkSetPrivateDataEXT = NULL;
PFN_vkSignalSemaphore glad_vkSignalSemaphore = NULL;
PFN_vkSignalSemaphoreKHR glad_vkSignalSemaphoreKHR = NULL;
PFN_vkSubmitDebugUtilsMessageEXT glad_vkSubmitDebugUtilsMessageEXT = NULL;
PFN_vkTrimCommandPool glad_vkTrimCommandPool = NULL;
PFN_vkTrimCommandPoolKHR glad_vkTrimCommandPoolKHR = NULL;
PFN_vkUnmapMemory glad_vkUnmapMemory = NULL;
PFN_vkUpdateDescriptorSetWithTemplate glad_vkUpdateDescriptorSetWithTemplate = NULL;
PFN_vkUpdateDescriptorSetWithTemplateKHR glad_vkUpdateDescriptorSetWithTemplateKHR = NULL;
PFN_vkUpdateDescriptorSets glad_vkUpdateDescriptorSets = NULL;
PFN_vkWaitForFences glad_vkWaitForFences = NULL;
PFN_vkWaitSemaphores glad_vkWaitSemaphores = NULL;
PFN_vkWaitSemaphoresKHR glad_vkWaitSemaphoresKHR = NULL;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
PFN_vkWriteAccelerationStructuresPropertiesKHR glad_vkWriteAccelerationStructuresPropertiesKHR = NULL;
#endif


static void glad_vk_load_VK_VERSION_1_0( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_VERSION_1_0) return;
    glad_vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers) load(userptr, "vkAllocateCommandBuffers");
    glad_vkAllocateDescriptorSets = (PFN_vkAllocateDescriptorSets) load(userptr, "vkAllocateDescriptorSets");
    glad_vkAllocateMemory = (PFN_vkAllocateMemory) load(userptr, "vkAllocateMemory");
    glad_vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer) load(userptr, "vkBeginCommandBuffer");
    glad_vkBindBufferMemory = (PFN_vkBindBufferMemory) load(userptr, "vkBindBufferMemory");
    glad_vkBindImageMemory = (PFN_vkBindImageMemory) load(userptr, "vkBindImageMemory");
    glad_vkCmdBeginQuery = (PFN_vkCmdBeginQuery) load(userptr, "vkCmdBeginQuery");
    glad_vkCmdBeginRenderPass = (PFN_vkCmdBeginRenderPass) load(userptr, "vkCmdBeginRenderPass");
    glad_vkCmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets) load(userptr, "vkCmdBindDescriptorSets");
    glad_vkCmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer) load(userptr, "vkCmdBindIndexBuffer");
    glad_vkCmdBindPipeline = (PFN_vkCmdBindPipeline) load(userptr, "vkCmdBindPipeline");
    glad_vkCmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers) load(userptr, "vkCmdBindVertexBuffers");
    glad_vkCmdBlitImage = (PFN_vkCmdBlitImage) load(userptr, "vkCmdBlitImage");
    glad_vkCmdClearAttachments = (PFN_vkCmdClearAttachments) load(userptr, "vkCmdClearAttachments");
    glad_vkCmdClearColorImage = (PFN_vkCmdClearColorImage) load(userptr, "vkCmdClearColorImage");
    glad_vkCmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage) load(userptr, "vkCmdClearDepthStencilImage");
    glad_vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer) load(userptr, "vkCmdCopyBuffer");
    glad_vkCmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage) load(userptr, "vkCmdCopyBufferToImage");
    glad_vkCmdCopyImage = (PFN_vkCmdCopyImage) load(userptr, "vkCmdCopyImage");
    glad_vkCmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer) load(userptr, "vkCmdCopyImageToBuffer");
    glad_vkCmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults) load(userptr, "vkCmdCopyQueryPoolResults");
    glad_vkCmdDispatch = (PFN_vkCmdDispatch) load(userptr, "vkCmdDispatch");
    glad_vkCmdDispatchIndirect = (PFN_vkCmdDispatchIndirect) load(userptr, "vkCmdDispatchIndirect");
    glad_vkCmdDraw = (PFN_vkCmdDraw) load(userptr, "vkCmdDraw");
    glad_vkCmdDrawIndexed = (PFN_vkCmdDrawIndexed) load(userptr, "vkCmdDrawIndexed");
    glad_vkCmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect) load(userptr, "vkCmdDrawIndexedIndirect");
    glad_vkCmdDrawIndirect = (PFN_vkCmdDrawIndirect) load(userptr, "vkCmdDrawIndirect");
    glad_vkCmdEndQuery = (PFN_vkCmdEndQuery) load(userptr, "vkCmdEndQuery");
    glad_vkCmdEndRenderPass = (PFN_vkCmdEndRenderPass) load(userptr, "vkCmdEndRenderPass");
    glad_vkCmdExecuteCommands = (PFN_vkCmdExecuteCommands) load(userptr, "vkCmdExecuteCommands");
    glad_vkCmdFillBuffer = (PFN_vkCmdFillBuffer) load(userptr, "vkCmdFillBuffer");
    glad_vkCmdNextSubpass = (PFN_vkCmdNextSubpass) load(userptr, "vkCmdNextSubpass");
    glad_vkCmdPipelineBarrier = (PFN_vkCmdPipelineBarrier) load(userptr, "vkCmdPipelineBarrier");
    glad_vkCmdPushConstants = (PFN_vkCmdPushConstants) load(userptr, "vkCmdPushConstants");
    glad_vkCmdResetEvent = (PFN_vkCmdResetEvent) load(userptr, "vkCmdResetEvent");
    glad_vkCmdResetQueryPool = (PFN_vkCmdResetQueryPool) load(userptr, "vkCmdResetQueryPool");
    glad_vkCmdResolveImage = (PFN_vkCmdResolveImage) load(userptr, "vkCmdResolveImage");
    glad_vkCmdSetBlendConstants = (PFN_vkCmdSetBlendConstants) load(userptr, "vkCmdSetBlendConstants");
    glad_vkCmdSetDepthBias = (PFN_vkCmdSetDepthBias) load(userptr, "vkCmdSetDepthBias");
    glad_vkCmdSetDepthBounds = (PFN_vkCmdSetDepthBounds) load(userptr, "vkCmdSetDepthBounds");
    glad_vkCmdSetEvent = (PFN_vkCmdSetEvent) load(userptr, "vkCmdSetEvent");
    glad_vkCmdSetLineWidth = (PFN_vkCmdSetLineWidth) load(userptr, "vkCmdSetLineWidth");
    glad_vkCmdSetScissor = (PFN_vkCmdSetScissor) load(userptr, "vkCmdSetScissor");
    glad_vkCmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask) load(userptr, "vkCmdSetStencilCompareMask");
    glad_vkCmdSetStencilReference = (PFN_vkCmdSetStencilReference) load(userptr, "vkCmdSetStencilReference");
    glad_vkCmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask) load(userptr, "vkCmdSetStencilWriteMask");
    glad_vkCmdSetViewport = (PFN_vkCmdSetViewport) load(userptr, "vkCmdSetViewport");
    glad_vkCmdUpdateBuffer = (PFN_vkCmdUpdateBuffer) load(userptr, "vkCmdUpdateBuffer");
    glad_vkCmdWaitEvents = (PFN_vkCmdWaitEvents) load(userptr, "vkCmdWaitEvents");
    glad_vkCmdWriteTimestamp = (PFN_vkCmdWriteTimestamp) load(userptr, "vkCmdWriteTimestamp");
    glad_vkCreateBuffer = (PFN_vkCreateBuffer) load(userptr, "vkCreateBuffer");
    glad_vkCreateBufferView = (PFN_vkCreateBufferView) load(userptr, "vkCreateBufferView");
    glad_vkCreateCommandPool = (PFN_vkCreateCommandPool) load(userptr, "vkCreateCommandPool");
    glad_vkCreateComputePipelines = (PFN_vkCreateComputePipelines) load(userptr, "vkCreateComputePipelines");
    glad_vkCreateDescriptorPool = (PFN_vkCreateDescriptorPool) load(userptr, "vkCreateDescriptorPool");
    glad_vkCreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout) load(userptr, "vkCreateDescriptorSetLayout");
    glad_vkCreateDevice = (PFN_vkCreateDevice) load(userptr, "vkCreateDevice");
    glad_vkCreateEvent = (PFN_vkCreateEvent) load(userptr, "vkCreateEvent");
    glad_vkCreateFence = (PFN_vkCreateFence) load(userptr, "vkCreateFence");
    glad_vkCreateFramebuffer = (PFN_vkCreateFramebuffer) load(userptr, "vkCreateFramebuffer");
    glad_vkCreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines) load(userptr, "vkCreateGraphicsPipelines");
    glad_vkCreateImage = (PFN_vkCreateImage) load(userptr, "vkCreateImage");
    glad_vkCreateImageView = (PFN_vkCreateImageView) load(userptr, "vkCreateImageView");
    glad_vkCreateInstance = (PFN_vkCreateInstance) load(userptr, "vkCreateInstance");
    glad_vkCreatePipelineCache = (PFN_vkCreatePipelineCache) load(userptr, "vkCreatePipelineCache");
    glad_vkCreatePipelineLayout = (PFN_vkCreatePipelineLayout) load(userptr, "vkCreatePipelineLayout");
    glad_vkCreateQueryPool = (PFN_vkCreateQueryPool) load(userptr, "vkCreateQueryPool");
    glad_vkCreateRenderPass = (PFN_vkCreateRenderPass) load(userptr, "vkCreateRenderPass");
    glad_vkCreateSampler = (PFN_vkCreateSampler) load(userptr, "vkCreateSampler");
    glad_vkCreateSemaphore = (PFN_vkCreateSemaphore) load(userptr, "vkCreateSemaphore");
    glad_vkCreateShaderModule = (PFN_vkCreateShaderModule) load(userptr, "vkCreateShaderModule");
    glad_vkDestroyBuffer = (PFN_vkDestroyBuffer) load(userptr, "vkDestroyBuffer");
    glad_vkDestroyBufferView = (PFN_vkDestroyBufferView) load(userptr, "vkDestroyBufferView");
    glad_vkDestroyCommandPool = (PFN_vkDestroyCommandPool) load(userptr, "vkDestroyCommandPool");
    glad_vkDestroyDescriptorPool = (PFN_vkDestroyDescriptorPool) load(userptr, "vkDestroyDescriptorPool");
    glad_vkDestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout) load(userptr, "vkDestroyDescriptorSetLayout");
    glad_vkDestroyDevice = (PFN_vkDestroyDevice) load(userptr, "vkDestroyDevice");
    glad_vkDestroyEvent = (PFN_vkDestroyEvent) load(userptr, "vkDestroyEvent");
    glad_vkDestroyFence = (PFN_vkDestroyFence) load(userptr, "vkDestroyFence");
    glad_vkDestroyFramebuffer = (PFN_vkDestroyFramebuffer) load(userptr, "vkDestroyFramebuffer");
    glad_vkDestroyImage = (PFN_vkDestroyImage) load(userptr, "vkDestroyImage");
    glad_vkDestroyImageView = (PFN_vkDestroyImageView) load(userptr, "vkDestroyImageView");
    glad_vkDestroyInstance = (PFN_vkDestroyInstance) load(userptr, "vkDestroyInstance");
    glad_vkDestroyPipeline = (PFN_vkDestroyPipeline) load(userptr, "vkDestroyPipeline");
    glad_vkDestroyPipelineCache = (PFN_vkDestroyPipelineCache) load(userptr, "vkDestroyPipelineCache");
    glad_vkDestroyPipelineLayout = (PFN_vkDestroyPipelineLayout) load(userptr, "vkDestroyPipelineLayout");
    glad_vkDestroyQueryPool = (PFN_vkDestroyQueryPool) load(userptr, "vkDestroyQueryPool");
    glad_vkDestroyRenderPass = (PFN_vkDestroyRenderPass) load(userptr, "vkDestroyRenderPass");
    glad_vkDestroySampler = (PFN_vkDestroySampler) load(userptr, "vkDestroySampler");
    glad_vkDestroySemaphore = (PFN_vkDestroySemaphore) load(userptr, "vkDestroySemaphore");
    glad_vkDestroyShaderModule = (PFN_vkDestroyShaderModule) load(userptr, "vkDestroyShaderModule");
    glad_vkDeviceWaitIdle = (PFN_vkDeviceWaitIdle) load(userptr, "vkDeviceWaitIdle");
    glad_vkEndCommandBuffer = (PFN_vkEndCommandBuffer) load(userptr, "vkEndCommandBuffer");
    glad_vkEnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties) load(userptr, "vkEnumerateDeviceExtensionProperties");
    glad_vkEnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties) load(userptr, "vkEnumerateDeviceLayerProperties");
    glad_vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties) load(userptr, "vkEnumerateInstanceExtensionProperties");
    glad_vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties) load(userptr, "vkEnumerateInstanceLayerProperties");
    glad_vkEnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices) load(userptr, "vkEnumeratePhysicalDevices");
    glad_vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges) load(userptr, "vkFlushMappedMemoryRanges");
    glad_vkFreeCommandBuffers = (PFN_vkFreeCommandBuffers) load(userptr, "vkFreeCommandBuffers");
    glad_vkFreeDescriptorSets = (PFN_vkFreeDescriptorSets) load(userptr, "vkFreeDescriptorSets");
    glad_vkFreeMemory = (PFN_vkFreeMemory) load(userptr, "vkFreeMemory");
    glad_vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements) load(userptr, "vkGetBufferMemoryRequirements");
    glad_vkGetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment) load(userptr, "vkGetDeviceMemoryCommitment");
    glad_vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr) load(userptr, "vkGetDeviceProcAddr");
    glad_vkGetDeviceQueue = (PFN_vkGetDeviceQueue) load(userptr, "vkGetDeviceQueue");
    glad_vkGetEventStatus = (PFN_vkGetEventStatus) load(userptr, "vkGetEventStatus");
    glad_vkGetFenceStatus = (PFN_vkGetFenceStatus) load(userptr, "vkGetFenceStatus");
    glad_vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements) load(userptr, "vkGetImageMemoryRequirements");
    glad_vkGetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements) load(userptr, "vkGetImageSparseMemoryRequirements");
    glad_vkGetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout) load(userptr, "vkGetImageSubresourceLayout");
    glad_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr) load(userptr, "vkGetInstanceProcAddr");
    glad_vkGetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures) load(userptr, "vkGetPhysicalDeviceFeatures");
    glad_vkGetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties) load(userptr, "vkGetPhysicalDeviceFormatProperties");
    glad_vkGetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties) load(userptr, "vkGetPhysicalDeviceImageFormatProperties");
    glad_vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties) load(userptr, "vkGetPhysicalDeviceMemoryProperties");
    glad_vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties) load(userptr, "vkGetPhysicalDeviceProperties");
    glad_vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties) load(userptr, "vkGetPhysicalDeviceQueueFamilyProperties");
    glad_vkGetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties) load(userptr, "vkGetPhysicalDeviceSparseImageFormatProperties");
    glad_vkGetPipelineCacheData = (PFN_vkGetPipelineCacheData) load(userptr, "vkGetPipelineCacheData");
    glad_vkGetQueryPoolResults = (PFN_vkGetQueryPoolResults) load(userptr, "vkGetQueryPoolResults");
    glad_vkGetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity) load(userptr, "vkGetRenderAreaGranularity");
    glad_vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges) load(userptr, "vkInvalidateMappedMemoryRanges");
    glad_vkMapMemory = (PFN_vkMapMemory) load(userptr, "vkMapMemory");
    glad_vkMergePipelineCaches = (PFN_vkMergePipelineCaches) load(userptr, "vkMergePipelineCaches");
    glad_vkQueueBindSparse = (PFN_vkQueueBindSparse) load(userptr, "vkQueueBindSparse");
    glad_vkQueueSubmit = (PFN_vkQueueSubmit) load(userptr, "vkQueueSubmit");
    glad_vkQueueWaitIdle = (PFN_vkQueueWaitIdle) load(userptr, "vkQueueWaitIdle");
    glad_vkResetCommandBuffer = (PFN_vkResetCommandBuffer) load(userptr, "vkResetCommandBuffer");
    glad_vkResetCommandPool = (PFN_vkResetCommandPool) load(userptr, "vkResetCommandPool");
    glad_vkResetDescriptorPool = (PFN_vkResetDescriptorPool) load(userptr, "vkResetDescriptorPool");
    glad_vkResetEvent = (PFN_vkResetEvent) load(userptr, "vkResetEvent");
    glad_vkResetFences = (PFN_vkResetFences) load(userptr, "vkResetFences");
    glad_vkSetEvent = (PFN_vkSetEvent) load(userptr, "vkSetEvent");
    glad_vkUnmapMemory = (PFN_vkUnmapMemory) load(userptr, "vkUnmapMemory");
    glad_vkUpdateDescriptorSets = (PFN_vkUpdateDescriptorSets) load(userptr, "vkUpdateDescriptorSets");
    glad_vkWaitForFences = (PFN_vkWaitForFences) load(userptr, "vkWaitForFences");
}
static void glad_vk_load_VK_VERSION_1_1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_VERSION_1_1) return;
    glad_vkBindBufferMemory2 = (PFN_vkBindBufferMemory2) load(userptr, "vkBindBufferMemory2");
    glad_vkBindImageMemory2 = (PFN_vkBindImageMemory2) load(userptr, "vkBindImageMemory2");
    glad_vkCmdDispatchBase = (PFN_vkCmdDispatchBase) load(userptr, "vkCmdDispatchBase");
    glad_vkCmdSetDeviceMask = (PFN_vkCmdSetDeviceMask) load(userptr, "vkCmdSetDeviceMask");
    glad_vkCreateDescriptorUpdateTemplate = (PFN_vkCreateDescriptorUpdateTemplate) load(userptr, "vkCreateDescriptorUpdateTemplate");
    glad_vkCreateSamplerYcbcrConversion = (PFN_vkCreateSamplerYcbcrConversion) load(userptr, "vkCreateSamplerYcbcrConversion");
    glad_vkDestroyDescriptorUpdateTemplate = (PFN_vkDestroyDescriptorUpdateTemplate) load(userptr, "vkDestroyDescriptorUpdateTemplate");
    glad_vkDestroySamplerYcbcrConversion = (PFN_vkDestroySamplerYcbcrConversion) load(userptr, "vkDestroySamplerYcbcrConversion");
    glad_vkEnumerateInstanceVersion = (PFN_vkEnumerateInstanceVersion) load(userptr, "vkEnumerateInstanceVersion");
    glad_vkEnumeratePhysicalDeviceGroups = (PFN_vkEnumeratePhysicalDeviceGroups) load(userptr, "vkEnumeratePhysicalDeviceGroups");
    glad_vkGetBufferMemoryRequirements2 = (PFN_vkGetBufferMemoryRequirements2) load(userptr, "vkGetBufferMemoryRequirements2");
    glad_vkGetDescriptorSetLayoutSupport = (PFN_vkGetDescriptorSetLayoutSupport) load(userptr, "vkGetDescriptorSetLayoutSupport");
    glad_vkGetDeviceGroupPeerMemoryFeatures = (PFN_vkGetDeviceGroupPeerMemoryFeatures) load(userptr, "vkGetDeviceGroupPeerMemoryFeatures");
    glad_vkGetDeviceQueue2 = (PFN_vkGetDeviceQueue2) load(userptr, "vkGetDeviceQueue2");
    glad_vkGetImageMemoryRequirements2 = (PFN_vkGetImageMemoryRequirements2) load(userptr, "vkGetImageMemoryRequirements2");
    glad_vkGetImageSparseMemoryRequirements2 = (PFN_vkGetImageSparseMemoryRequirements2) load(userptr, "vkGetImageSparseMemoryRequirements2");
    glad_vkGetPhysicalDeviceExternalBufferProperties = (PFN_vkGetPhysicalDeviceExternalBufferProperties) load(userptr, "vkGetPhysicalDeviceExternalBufferProperties");
    glad_vkGetPhysicalDeviceExternalFenceProperties = (PFN_vkGetPhysicalDeviceExternalFenceProperties) load(userptr, "vkGetPhysicalDeviceExternalFenceProperties");
    glad_vkGetPhysicalDeviceExternalSemaphoreProperties = (PFN_vkGetPhysicalDeviceExternalSemaphoreProperties) load(userptr, "vkGetPhysicalDeviceExternalSemaphoreProperties");
    glad_vkGetPhysicalDeviceFeatures2 = (PFN_vkGetPhysicalDeviceFeatures2) load(userptr, "vkGetPhysicalDeviceFeatures2");
    glad_vkGetPhysicalDeviceFormatProperties2 = (PFN_vkGetPhysicalDeviceFormatProperties2) load(userptr, "vkGetPhysicalDeviceFormatProperties2");
    glad_vkGetPhysicalDeviceImageFormatProperties2 = (PFN_vkGetPhysicalDeviceImageFormatProperties2) load(userptr, "vkGetPhysicalDeviceImageFormatProperties2");
    glad_vkGetPhysicalDeviceMemoryProperties2 = (PFN_vkGetPhysicalDeviceMemoryProperties2) load(userptr, "vkGetPhysicalDeviceMemoryProperties2");
    glad_vkGetPhysicalDeviceProperties2 = (PFN_vkGetPhysicalDeviceProperties2) load(userptr, "vkGetPhysicalDeviceProperties2");
    glad_vkGetPhysicalDeviceQueueFamilyProperties2 = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2) load(userptr, "vkGetPhysicalDeviceQueueFamilyProperties2");
    glad_vkGetPhysicalDeviceSparseImageFormatProperties2 = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2) load(userptr, "vkGetPhysicalDeviceSparseImageFormatProperties2");
    glad_vkTrimCommandPool = (PFN_vkTrimCommandPool) load(userptr, "vkTrimCommandPool");
    glad_vkUpdateDescriptorSetWithTemplate = (PFN_vkUpdateDescriptorSetWithTemplate) load(userptr, "vkUpdateDescriptorSetWithTemplate");
}
static void glad_vk_load_VK_VERSION_1_2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_VERSION_1_2) return;
    glad_vkCmdBeginRenderPass2 = (PFN_vkCmdBeginRenderPass2) load(userptr, "vkCmdBeginRenderPass2");
    glad_vkCmdDrawIndexedIndirectCount = (PFN_vkCmdDrawIndexedIndirectCount) load(userptr, "vkCmdDrawIndexedIndirectCount");
    glad_vkCmdDrawIndirectCount = (PFN_vkCmdDrawIndirectCount) load(userptr, "vkCmdDrawIndirectCount");
    glad_vkCmdEndRenderPass2 = (PFN_vkCmdEndRenderPass2) load(userptr, "vkCmdEndRenderPass2");
    glad_vkCmdNextSubpass2 = (PFN_vkCmdNextSubpass2) load(userptr, "vkCmdNextSubpass2");
    glad_vkCreateRenderPass2 = (PFN_vkCreateRenderPass2) load(userptr, "vkCreateRenderPass2");
    glad_vkGetBufferDeviceAddress = (PFN_vkGetBufferDeviceAddress) load(userptr, "vkGetBufferDeviceAddress");
    glad_vkGetBufferOpaqueCaptureAddress = (PFN_vkGetBufferOpaqueCaptureAddress) load(userptr, "vkGetBufferOpaqueCaptureAddress");
    glad_vkGetDeviceMemoryOpaqueCaptureAddress = (PFN_vkGetDeviceMemoryOpaqueCaptureAddress) load(userptr, "vkGetDeviceMemoryOpaqueCaptureAddress");
    glad_vkGetSemaphoreCounterValue = (PFN_vkGetSemaphoreCounterValue) load(userptr, "vkGetSemaphoreCounterValue");
    glad_vkResetQueryPool = (PFN_vkResetQueryPool) load(userptr, "vkResetQueryPool");
    glad_vkSignalSemaphore = (PFN_vkSignalSemaphore) load(userptr, "vkSignalSemaphore");
    glad_vkWaitSemaphores = (PFN_vkWaitSemaphores) load(userptr, "vkWaitSemaphores");
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
static void glad_vk_load_VK_ANDROID_external_memory_android_hardware_buffer( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_ANDROID_external_memory_android_hardware_buffer) return;
    glad_vkGetAndroidHardwareBufferPropertiesANDROID = (PFN_vkGetAndroidHardwareBufferPropertiesANDROID) load(userptr, "vkGetAndroidHardwareBufferPropertiesANDROID");
    glad_vkGetMemoryAndroidHardwareBufferANDROID = (PFN_vkGetMemoryAndroidHardwareBufferANDROID) load(userptr, "vkGetMemoryAndroidHardwareBufferANDROID");
}
#endif
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
static void glad_vk_load_VK_EXT_acquire_xlib_display( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_acquire_xlib_display) return;
    glad_vkAcquireXlibDisplayEXT = (PFN_vkAcquireXlibDisplayEXT) load(userptr, "vkAcquireXlibDisplayEXT");
    glad_vkGetRandROutputDisplayEXT = (PFN_vkGetRandROutputDisplayEXT) load(userptr, "vkGetRandROutputDisplayEXT");
}
#endif
static void glad_vk_load_VK_EXT_buffer_device_address( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_buffer_device_address) return;
    glad_vkGetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT) load(userptr, "vkGetBufferDeviceAddressEXT");
}
static void glad_vk_load_VK_EXT_calibrated_timestamps( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_calibrated_timestamps) return;
    glad_vkGetCalibratedTimestampsEXT = (PFN_vkGetCalibratedTimestampsEXT) load(userptr, "vkGetCalibratedTimestampsEXT");
    glad_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT) load(userptr, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
}
static void glad_vk_load_VK_EXT_conditional_rendering( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_conditional_rendering) return;
    glad_vkCmdBeginConditionalRenderingEXT = (PFN_vkCmdBeginConditionalRenderingEXT) load(userptr, "vkCmdBeginConditionalRenderingEXT");
    glad_vkCmdEndConditionalRenderingEXT = (PFN_vkCmdEndConditionalRenderingEXT) load(userptr, "vkCmdEndConditionalRenderingEXT");
}
static void glad_vk_load_VK_EXT_debug_marker( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_debug_marker) return;
    glad_vkCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT) load(userptr, "vkCmdDebugMarkerBeginEXT");
    glad_vkCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT) load(userptr, "vkCmdDebugMarkerEndEXT");
    glad_vkCmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT) load(userptr, "vkCmdDebugMarkerInsertEXT");
    glad_vkDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT) load(userptr, "vkDebugMarkerSetObjectNameEXT");
    glad_vkDebugMarkerSetObjectTagEXT = (PFN_vkDebugMarkerSetObjectTagEXT) load(userptr, "vkDebugMarkerSetObjectTagEXT");
}
static void glad_vk_load_VK_EXT_debug_report( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_debug_report) return;
    glad_vkCreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT) load(userptr, "vkCreateDebugReportCallbackEXT");
    glad_vkDebugReportMessageEXT = (PFN_vkDebugReportMessageEXT) load(userptr, "vkDebugReportMessageEXT");
    glad_vkDestroyDebugReportCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT) load(userptr, "vkDestroyDebugReportCallbackEXT");
}
static void glad_vk_load_VK_EXT_debug_utils( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_debug_utils) return;
    glad_vkCmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT) load(userptr, "vkCmdBeginDebugUtilsLabelEXT");
    glad_vkCmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT) load(userptr, "vkCmdEndDebugUtilsLabelEXT");
    glad_vkCmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT) load(userptr, "vkCmdInsertDebugUtilsLabelEXT");
    glad_vkCreateDebugUtilsMessengerEXT = (PFN_vkCreateDebugUtilsMessengerEXT) load(userptr, "vkCreateDebugUtilsMessengerEXT");
    glad_vkDestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT) load(userptr, "vkDestroyDebugUtilsMessengerEXT");
    glad_vkQueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT) load(userptr, "vkQueueBeginDebugUtilsLabelEXT");
    glad_vkQueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT) load(userptr, "vkQueueEndDebugUtilsLabelEXT");
    glad_vkQueueInsertDebugUtilsLabelEXT = (PFN_vkQueueInsertDebugUtilsLabelEXT) load(userptr, "vkQueueInsertDebugUtilsLabelEXT");
    glad_vkSetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT) load(userptr, "vkSetDebugUtilsObjectNameEXT");
    glad_vkSetDebugUtilsObjectTagEXT = (PFN_vkSetDebugUtilsObjectTagEXT) load(userptr, "vkSetDebugUtilsObjectTagEXT");
    glad_vkSubmitDebugUtilsMessageEXT = (PFN_vkSubmitDebugUtilsMessageEXT) load(userptr, "vkSubmitDebugUtilsMessageEXT");
}
static void glad_vk_load_VK_EXT_direct_mode_display( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_direct_mode_display) return;
    glad_vkReleaseDisplayEXT = (PFN_vkReleaseDisplayEXT) load(userptr, "vkReleaseDisplayEXT");
}
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
static void glad_vk_load_VK_EXT_directfb_surface( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_directfb_surface) return;
    glad_vkCreateDirectFBSurfaceEXT = (PFN_vkCreateDirectFBSurfaceEXT) load(userptr, "vkCreateDirectFBSurfaceEXT");
    glad_vkGetPhysicalDeviceDirectFBPresentationSupportEXT = (PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT) load(userptr, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT");
}
#endif
static void glad_vk_load_VK_EXT_discard_rectangles( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_discard_rectangles) return;
    glad_vkCmdSetDiscardRectangleEXT = (PFN_vkCmdSetDiscardRectangleEXT) load(userptr, "vkCmdSetDiscardRectangleEXT");
}
static void glad_vk_load_VK_EXT_display_control( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_display_control) return;
    glad_vkDisplayPowerControlEXT = (PFN_vkDisplayPowerControlEXT) load(userptr, "vkDisplayPowerControlEXT");
    glad_vkGetSwapchainCounterEXT = (PFN_vkGetSwapchainCounterEXT) load(userptr, "vkGetSwapchainCounterEXT");
    glad_vkRegisterDeviceEventEXT = (PFN_vkRegisterDeviceEventEXT) load(userptr, "vkRegisterDeviceEventEXT");
    glad_vkRegisterDisplayEventEXT = (PFN_vkRegisterDisplayEventEXT) load(userptr, "vkRegisterDisplayEventEXT");
}
static void glad_vk_load_VK_EXT_display_surface_counter( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_display_surface_counter) return;
    glad_vkGetPhysicalDeviceSurfaceCapabilities2EXT = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT) load(userptr, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
}
static void glad_vk_load_VK_EXT_extended_dynamic_state( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_extended_dynamic_state) return;
    glad_vkCmdBindVertexBuffers2EXT = (PFN_vkCmdBindVertexBuffers2EXT) load(userptr, "vkCmdBindVertexBuffers2EXT");
    glad_vkCmdSetCullModeEXT = (PFN_vkCmdSetCullModeEXT) load(userptr, "vkCmdSetCullModeEXT");
    glad_vkCmdSetDepthBoundsTestEnableEXT = (PFN_vkCmdSetDepthBoundsTestEnableEXT) load(userptr, "vkCmdSetDepthBoundsTestEnableEXT");
    glad_vkCmdSetDepthCompareOpEXT = (PFN_vkCmdSetDepthCompareOpEXT) load(userptr, "vkCmdSetDepthCompareOpEXT");
    glad_vkCmdSetDepthTestEnableEXT = (PFN_vkCmdSetDepthTestEnableEXT) load(userptr, "vkCmdSetDepthTestEnableEXT");
    glad_vkCmdSetDepthWriteEnableEXT = (PFN_vkCmdSetDepthWriteEnableEXT) load(userptr, "vkCmdSetDepthWriteEnableEXT");
    glad_vkCmdSetFrontFaceEXT = (PFN_vkCmdSetFrontFaceEXT) load(userptr, "vkCmdSetFrontFaceEXT");
    glad_vkCmdSetPrimitiveTopologyEXT = (PFN_vkCmdSetPrimitiveTopologyEXT) load(userptr, "vkCmdSetPrimitiveTopologyEXT");
    glad_vkCmdSetScissorWithCountEXT = (PFN_vkCmdSetScissorWithCountEXT) load(userptr, "vkCmdSetScissorWithCountEXT");
    glad_vkCmdSetStencilOpEXT = (PFN_vkCmdSetStencilOpEXT) load(userptr, "vkCmdSetStencilOpEXT");
    glad_vkCmdSetStencilTestEnableEXT = (PFN_vkCmdSetStencilTestEnableEXT) load(userptr, "vkCmdSetStencilTestEnableEXT");
    glad_vkCmdSetViewportWithCountEXT = (PFN_vkCmdSetViewportWithCountEXT) load(userptr, "vkCmdSetViewportWithCountEXT");
}
static void glad_vk_load_VK_EXT_external_memory_host( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_external_memory_host) return;
    glad_vkGetMemoryHostPointerPropertiesEXT = (PFN_vkGetMemoryHostPointerPropertiesEXT) load(userptr, "vkGetMemoryHostPointerPropertiesEXT");
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
static void glad_vk_load_VK_EXT_full_screen_exclusive( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_full_screen_exclusive) return;
    glad_vkAcquireFullScreenExclusiveModeEXT = (PFN_vkAcquireFullScreenExclusiveModeEXT) load(userptr, "vkAcquireFullScreenExclusiveModeEXT");
    glad_vkGetDeviceGroupSurfacePresentModes2EXT = (PFN_vkGetDeviceGroupSurfacePresentModes2EXT) load(userptr, "vkGetDeviceGroupSurfacePresentModes2EXT");
    glad_vkGetPhysicalDeviceSurfacePresentModes2EXT = (PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT) load(userptr, "vkGetPhysicalDeviceSurfacePresentModes2EXT");
    glad_vkReleaseFullScreenExclusiveModeEXT = (PFN_vkReleaseFullScreenExclusiveModeEXT) load(userptr, "vkReleaseFullScreenExclusiveModeEXT");
}
#endif
static void glad_vk_load_VK_EXT_hdr_metadata( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_hdr_metadata) return;
    glad_vkSetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT) load(userptr, "vkSetHdrMetadataEXT");
}
static void glad_vk_load_VK_EXT_headless_surface( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_headless_surface) return;
    glad_vkCreateHeadlessSurfaceEXT = (PFN_vkCreateHeadlessSurfaceEXT) load(userptr, "vkCreateHeadlessSurfaceEXT");
}
static void glad_vk_load_VK_EXT_host_query_reset( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_host_query_reset) return;
    glad_vkResetQueryPoolEXT = (PFN_vkResetQueryPoolEXT) load(userptr, "vkResetQueryPoolEXT");
}
static void glad_vk_load_VK_EXT_image_drm_format_modifier( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_image_drm_format_modifier) return;
    glad_vkGetImageDrmFormatModifierPropertiesEXT = (PFN_vkGetImageDrmFormatModifierPropertiesEXT) load(userptr, "vkGetImageDrmFormatModifierPropertiesEXT");
}
static void glad_vk_load_VK_EXT_line_rasterization( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_line_rasterization) return;
    glad_vkCmdSetLineStippleEXT = (PFN_vkCmdSetLineStippleEXT) load(userptr, "vkCmdSetLineStippleEXT");
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
static void glad_vk_load_VK_EXT_metal_surface( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_metal_surface) return;
    glad_vkCreateMetalSurfaceEXT = (PFN_vkCreateMetalSurfaceEXT) load(userptr, "vkCreateMetalSurfaceEXT");
}
#endif
static void glad_vk_load_VK_EXT_private_data( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_private_data) return;
    glad_vkCreatePrivateDataSlotEXT = (PFN_vkCreatePrivateDataSlotEXT) load(userptr, "vkCreatePrivateDataSlotEXT");
    glad_vkDestroyPrivateDataSlotEXT = (PFN_vkDestroyPrivateDataSlotEXT) load(userptr, "vkDestroyPrivateDataSlotEXT");
    glad_vkGetPrivateDataEXT = (PFN_vkGetPrivateDataEXT) load(userptr, "vkGetPrivateDataEXT");
    glad_vkSetPrivateDataEXT = (PFN_vkSetPrivateDataEXT) load(userptr, "vkSetPrivateDataEXT");
}
static void glad_vk_load_VK_EXT_sample_locations( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_sample_locations) return;
    glad_vkCmdSetSampleLocationsEXT = (PFN_vkCmdSetSampleLocationsEXT) load(userptr, "vkCmdSetSampleLocationsEXT");
    glad_vkGetPhysicalDeviceMultisamplePropertiesEXT = (PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT) load(userptr, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
}
static void glad_vk_load_VK_EXT_tooling_info( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_tooling_info) return;
    glad_vkGetPhysicalDeviceToolPropertiesEXT = (PFN_vkGetPhysicalDeviceToolPropertiesEXT) load(userptr, "vkGetPhysicalDeviceToolPropertiesEXT");
}
static void glad_vk_load_VK_EXT_transform_feedback( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_transform_feedback) return;
    glad_vkCmdBeginQueryIndexedEXT = (PFN_vkCmdBeginQueryIndexedEXT) load(userptr, "vkCmdBeginQueryIndexedEXT");
    glad_vkCmdBeginTransformFeedbackEXT = (PFN_vkCmdBeginTransformFeedbackEXT) load(userptr, "vkCmdBeginTransformFeedbackEXT");
    glad_vkCmdBindTransformFeedbackBuffersEXT = (PFN_vkCmdBindTransformFeedbackBuffersEXT) load(userptr, "vkCmdBindTransformFeedbackBuffersEXT");
    glad_vkCmdDrawIndirectByteCountEXT = (PFN_vkCmdDrawIndirectByteCountEXT) load(userptr, "vkCmdDrawIndirectByteCountEXT");
    glad_vkCmdEndQueryIndexedEXT = (PFN_vkCmdEndQueryIndexedEXT) load(userptr, "vkCmdEndQueryIndexedEXT");
    glad_vkCmdEndTransformFeedbackEXT = (PFN_vkCmdEndTransformFeedbackEXT) load(userptr, "vkCmdEndTransformFeedbackEXT");
}
static void glad_vk_load_VK_EXT_validation_cache( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_EXT_validation_cache) return;
    glad_vkCreateValidationCacheEXT = (PFN_vkCreateValidationCacheEXT) load(userptr, "vkCreateValidationCacheEXT");
    glad_vkDestroyValidationCacheEXT = (PFN_vkDestroyValidationCacheEXT) load(userptr, "vkDestroyValidationCacheEXT");
    glad_vkGetValidationCacheDataEXT = (PFN_vkGetValidationCacheDataEXT) load(userptr, "vkGetValidationCacheDataEXT");
    glad_vkMergeValidationCachesEXT = (PFN_vkMergeValidationCachesEXT) load(userptr, "vkMergeValidationCachesEXT");
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
static void glad_vk_load_VK_KHR_android_surface( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_android_surface) return;
    glad_vkCreateAndroidSurfaceKHR = (PFN_vkCreateAndroidSurfaceKHR) load(userptr, "vkCreateAndroidSurfaceKHR");
}
#endif
static void glad_vk_load_VK_KHR_bind_memory2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_bind_memory2) return;
    glad_vkBindBufferMemory2KHR = (PFN_vkBindBufferMemory2KHR) load(userptr, "vkBindBufferMemory2KHR");
    glad_vkBindImageMemory2KHR = (PFN_vkBindImageMemory2KHR) load(userptr, "vkBindImageMemory2KHR");
}
static void glad_vk_load_VK_KHR_buffer_device_address( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_buffer_device_address) return;
    glad_vkGetBufferDeviceAddressKHR = (PFN_vkGetBufferDeviceAddressKHR) load(userptr, "vkGetBufferDeviceAddressKHR");
    glad_vkGetBufferOpaqueCaptureAddressKHR = (PFN_vkGetBufferOpaqueCaptureAddressKHR) load(userptr, "vkGetBufferOpaqueCaptureAddressKHR");
    glad_vkGetDeviceMemoryOpaqueCaptureAddressKHR = (PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR) load(userptr, "vkGetDeviceMemoryOpaqueCaptureAddressKHR");
}
static void glad_vk_load_VK_KHR_create_renderpass2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_create_renderpass2) return;
    glad_vkCmdBeginRenderPass2KHR = (PFN_vkCmdBeginRenderPass2KHR) load(userptr, "vkCmdBeginRenderPass2KHR");
    glad_vkCmdEndRenderPass2KHR = (PFN_vkCmdEndRenderPass2KHR) load(userptr, "vkCmdEndRenderPass2KHR");
    glad_vkCmdNextSubpass2KHR = (PFN_vkCmdNextSubpass2KHR) load(userptr, "vkCmdNextSubpass2KHR");
    glad_vkCreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR) load(userptr, "vkCreateRenderPass2KHR");
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
static void glad_vk_load_VK_KHR_deferred_host_operations( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_deferred_host_operations) return;
    glad_vkCreateDeferredOperationKHR = (PFN_vkCreateDeferredOperationKHR) load(userptr, "vkCreateDeferredOperationKHR");
    glad_vkDeferredOperationJoinKHR = (PFN_vkDeferredOperationJoinKHR) load(userptr, "vkDeferredOperationJoinKHR");
    glad_vkDestroyDeferredOperationKHR = (PFN_vkDestroyDeferredOperationKHR) load(userptr, "vkDestroyDeferredOperationKHR");
    glad_vkGetDeferredOperationMaxConcurrencyKHR = (PFN_vkGetDeferredOperationMaxConcurrencyKHR) load(userptr, "vkGetDeferredOperationMaxConcurrencyKHR");
    glad_vkGetDeferredOperationResultKHR = (PFN_vkGetDeferredOperationResultKHR) load(userptr, "vkGetDeferredOperationResultKHR");
}
#endif
static void glad_vk_load_VK_KHR_descriptor_update_template( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_descriptor_update_template) return;
    glad_vkCmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR) load(userptr, "vkCmdPushDescriptorSetWithTemplateKHR");
    glad_vkCreateDescriptorUpdateTemplateKHR = (PFN_vkCreateDescriptorUpdateTemplateKHR) load(userptr, "vkCreateDescriptorUpdateTemplateKHR");
    glad_vkDestroyDescriptorUpdateTemplateKHR = (PFN_vkDestroyDescriptorUpdateTemplateKHR) load(userptr, "vkDestroyDescriptorUpdateTemplateKHR");
    glad_vkUpdateDescriptorSetWithTemplateKHR = (PFN_vkUpdateDescriptorSetWithTemplateKHR) load(userptr, "vkUpdateDescriptorSetWithTemplateKHR");
}
static void glad_vk_load_VK_KHR_device_group( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_device_group) return;
    glad_vkAcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR) load(userptr, "vkAcquireNextImage2KHR");
    glad_vkCmdDispatchBaseKHR = (PFN_vkCmdDispatchBaseKHR) load(userptr, "vkCmdDispatchBaseKHR");
    glad_vkCmdSetDeviceMaskKHR = (PFN_vkCmdSetDeviceMaskKHR) load(userptr, "vkCmdSetDeviceMaskKHR");
    glad_vkGetDeviceGroupPeerMemoryFeaturesKHR = (PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR) load(userptr, "vkGetDeviceGroupPeerMemoryFeaturesKHR");
    glad_vkGetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR) load(userptr, "vkGetDeviceGroupPresentCapabilitiesKHR");
    glad_vkGetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR) load(userptr, "vkGetDeviceGroupSurfacePresentModesKHR");
    glad_vkGetPhysicalDevicePresentRectanglesKHR = (PFN_vkGetPhysicalDevicePresentRectanglesKHR) load(userptr, "vkGetPhysicalDevicePresentRectanglesKHR");
}
static void glad_vk_load_VK_KHR_device_group_creation( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_device_group_creation) return;
    glad_vkEnumeratePhysicalDeviceGroupsKHR = (PFN_vkEnumeratePhysicalDeviceGroupsKHR) load(userptr, "vkEnumeratePhysicalDeviceGroupsKHR");
}
static void glad_vk_load_VK_KHR_display( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_display) return;
    glad_vkCreateDisplayModeKHR = (PFN_vkCreateDisplayModeKHR) load(userptr, "vkCreateDisplayModeKHR");
    glad_vkCreateDisplayPlaneSurfaceKHR = (PFN_vkCreateDisplayPlaneSurfaceKHR) load(userptr, "vkCreateDisplayPlaneSurfaceKHR");
    glad_vkGetDisplayModePropertiesKHR = (PFN_vkGetDisplayModePropertiesKHR) load(userptr, "vkGetDisplayModePropertiesKHR");
    glad_vkGetDisplayPlaneCapabilitiesKHR = (PFN_vkGetDisplayPlaneCapabilitiesKHR) load(userptr, "vkGetDisplayPlaneCapabilitiesKHR");
    glad_vkGetDisplayPlaneSupportedDisplaysKHR = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR) load(userptr, "vkGetDisplayPlaneSupportedDisplaysKHR");
    glad_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR) load(userptr, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
    glad_vkGetPhysicalDeviceDisplayPropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR) load(userptr, "vkGetPhysicalDeviceDisplayPropertiesKHR");
}
static void glad_vk_load_VK_KHR_display_swapchain( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_display_swapchain) return;
    glad_vkCreateSharedSwapchainsKHR = (PFN_vkCreateSharedSwapchainsKHR) load(userptr, "vkCreateSharedSwapchainsKHR");
}
static void glad_vk_load_VK_KHR_draw_indirect_count( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_draw_indirect_count) return;
    glad_vkCmdDrawIndexedIndirectCountKHR = (PFN_vkCmdDrawIndexedIndirectCountKHR) load(userptr, "vkCmdDrawIndexedIndirectCountKHR");
    glad_vkCmdDrawIndirectCountKHR = (PFN_vkCmdDrawIndirectCountKHR) load(userptr, "vkCmdDrawIndirectCountKHR");
}
static void glad_vk_load_VK_KHR_external_fence_capabilities( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_external_fence_capabilities) return;
    glad_vkGetPhysicalDeviceExternalFencePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR) load(userptr, "vkGetPhysicalDeviceExternalFencePropertiesKHR");
}
static void glad_vk_load_VK_KHR_external_fence_fd( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_external_fence_fd) return;
    glad_vkGetFenceFdKHR = (PFN_vkGetFenceFdKHR) load(userptr, "vkGetFenceFdKHR");
    glad_vkImportFenceFdKHR = (PFN_vkImportFenceFdKHR) load(userptr, "vkImportFenceFdKHR");
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
static void glad_vk_load_VK_KHR_external_fence_win32( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_external_fence_win32) return;
    glad_vkGetFenceWin32HandleKHR = (PFN_vkGetFenceWin32HandleKHR) load(userptr, "vkGetFenceWin32HandleKHR");
    glad_vkImportFenceWin32HandleKHR = (PFN_vkImportFenceWin32HandleKHR) load(userptr, "vkImportFenceWin32HandleKHR");
}
#endif
static void glad_vk_load_VK_KHR_external_memory_capabilities( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_external_memory_capabilities) return;
    glad_vkGetPhysicalDeviceExternalBufferPropertiesKHR = (PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR) load(userptr, "vkGetPhysicalDeviceExternalBufferPropertiesKHR");
}
static void glad_vk_load_VK_KHR_external_memory_fd( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_external_memory_fd) return;
    glad_vkGetMemoryFdKHR = (PFN_vkGetMemoryFdKHR) load(userptr, "vkGetMemoryFdKHR");
    glad_vkGetMemoryFdPropertiesKHR = (PFN_vkGetMemoryFdPropertiesKHR) load(userptr, "vkGetMemoryFdPropertiesKHR");
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
static void glad_vk_load_VK_KHR_external_memory_win32( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_external_memory_win32) return;
    glad_vkGetMemoryWin32HandleKHR = (PFN_vkGetMemoryWin32HandleKHR) load(userptr, "vkGetMemoryWin32HandleKHR");
    glad_vkGetMemoryWin32HandlePropertiesKHR = (PFN_vkGetMemoryWin32HandlePropertiesKHR) load(userptr, "vkGetMemoryWin32HandlePropertiesKHR");
}
#endif
static void glad_vk_load_VK_KHR_external_semaphore_capabilities( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_external_semaphore_capabilities) return;
    glad_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR) load(userptr, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
}
static void glad_vk_load_VK_KHR_external_semaphore_fd( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_external_semaphore_fd) return;
    glad_vkGetSemaphoreFdKHR = (PFN_vkGetSemaphoreFdKHR) load(userptr, "vkGetSemaphoreFdKHR");
    glad_vkImportSemaphoreFdKHR = (PFN_vkImportSemaphoreFdKHR) load(userptr, "vkImportSemaphoreFdKHR");
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
static void glad_vk_load_VK_KHR_external_semaphore_win32( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_external_semaphore_win32) return;
    glad_vkGetSemaphoreWin32HandleKHR = (PFN_vkGetSemaphoreWin32HandleKHR) load(userptr, "vkGetSemaphoreWin32HandleKHR");
    glad_vkImportSemaphoreWin32HandleKHR = (PFN_vkImportSemaphoreWin32HandleKHR) load(userptr, "vkImportSemaphoreWin32HandleKHR");
}
#endif
static void glad_vk_load_VK_KHR_get_display_properties2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_get_display_properties2) return;
    glad_vkGetDisplayModeProperties2KHR = (PFN_vkGetDisplayModeProperties2KHR) load(userptr, "vkGetDisplayModeProperties2KHR");
    glad_vkGetDisplayPlaneCapabilities2KHR = (PFN_vkGetDisplayPlaneCapabilities2KHR) load(userptr, "vkGetDisplayPlaneCapabilities2KHR");
    glad_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR) load(userptr, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
    glad_vkGetPhysicalDeviceDisplayProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayProperties2KHR) load(userptr, "vkGetPhysicalDeviceDisplayProperties2KHR");
}
static void glad_vk_load_VK_KHR_get_memory_requirements2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_get_memory_requirements2) return;
    glad_vkGetBufferMemoryRequirements2KHR = (PFN_vkGetBufferMemoryRequirements2KHR) load(userptr, "vkGetBufferMemoryRequirements2KHR");
    glad_vkGetImageMemoryRequirements2KHR = (PFN_vkGetImageMemoryRequirements2KHR) load(userptr, "vkGetImageMemoryRequirements2KHR");
    glad_vkGetImageSparseMemoryRequirements2KHR = (PFN_vkGetImageSparseMemoryRequirements2KHR) load(userptr, "vkGetImageSparseMemoryRequirements2KHR");
}
static void glad_vk_load_VK_KHR_get_physical_device_properties2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_get_physical_device_properties2) return;
    glad_vkGetPhysicalDeviceFeatures2KHR = (PFN_vkGetPhysicalDeviceFeatures2KHR) load(userptr, "vkGetPhysicalDeviceFeatures2KHR");
    glad_vkGetPhysicalDeviceFormatProperties2KHR = (PFN_vkGetPhysicalDeviceFormatProperties2KHR) load(userptr, "vkGetPhysicalDeviceFormatProperties2KHR");
    glad_vkGetPhysicalDeviceImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceImageFormatProperties2KHR) load(userptr, "vkGetPhysicalDeviceImageFormatProperties2KHR");
    glad_vkGetPhysicalDeviceMemoryProperties2KHR = (PFN_vkGetPhysicalDeviceMemoryProperties2KHR) load(userptr, "vkGetPhysicalDeviceMemoryProperties2KHR");
    glad_vkGetPhysicalDeviceProperties2KHR = (PFN_vkGetPhysicalDeviceProperties2KHR) load(userptr, "vkGetPhysicalDeviceProperties2KHR");
    glad_vkGetPhysicalDeviceQueueFamilyProperties2KHR = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR) load(userptr, "vkGetPhysicalDeviceQueueFamilyProperties2KHR");
    glad_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR) load(userptr, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
}
static void glad_vk_load_VK_KHR_get_surface_capabilities2( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_get_surface_capabilities2) return;
    glad_vkGetPhysicalDeviceSurfaceCapabilities2KHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR) load(userptr, "vkGetPhysicalDeviceSurfaceCapabilities2KHR");
    glad_vkGetPhysicalDeviceSurfaceFormats2KHR = (PFN_vkGetPhysicalDeviceSurfaceFormats2KHR) load(userptr, "vkGetPhysicalDeviceSurfaceFormats2KHR");
}
static void glad_vk_load_VK_KHR_maintenance1( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_maintenance1) return;
    glad_vkTrimCommandPoolKHR = (PFN_vkTrimCommandPoolKHR) load(userptr, "vkTrimCommandPoolKHR");
}
static void glad_vk_load_VK_KHR_maintenance3( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_maintenance3) return;
    glad_vkGetDescriptorSetLayoutSupportKHR = (PFN_vkGetDescriptorSetLayoutSupportKHR) load(userptr, "vkGetDescriptorSetLayoutSupportKHR");
}
static void glad_vk_load_VK_KHR_performance_query( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_performance_query) return;
    glad_vkAcquireProfilingLockKHR = (PFN_vkAcquireProfilingLockKHR) load(userptr, "vkAcquireProfilingLockKHR");
    glad_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = (PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR) load(userptr, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
    glad_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = (PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR) load(userptr, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
    glad_vkReleaseProfilingLockKHR = (PFN_vkReleaseProfilingLockKHR) load(userptr, "vkReleaseProfilingLockKHR");
}
static void glad_vk_load_VK_KHR_pipeline_executable_properties( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_pipeline_executable_properties) return;
    glad_vkGetPipelineExecutableInternalRepresentationsKHR = (PFN_vkGetPipelineExecutableInternalRepresentationsKHR) load(userptr, "vkGetPipelineExecutableInternalRepresentationsKHR");
    glad_vkGetPipelineExecutablePropertiesKHR = (PFN_vkGetPipelineExecutablePropertiesKHR) load(userptr, "vkGetPipelineExecutablePropertiesKHR");
    glad_vkGetPipelineExecutableStatisticsKHR = (PFN_vkGetPipelineExecutableStatisticsKHR) load(userptr, "vkGetPipelineExecutableStatisticsKHR");
}
static void glad_vk_load_VK_KHR_push_descriptor( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_push_descriptor) return;
    glad_vkCmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR) load(userptr, "vkCmdPushDescriptorSetKHR");
    glad_vkCmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR) load(userptr, "vkCmdPushDescriptorSetWithTemplateKHR");
}
#if defined(VK_ENABLE_BETA_EXTENSIONS)
static void glad_vk_load_VK_KHR_ray_tracing( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_ray_tracing) return;
    glad_vkBindAccelerationStructureMemoryKHR = (PFN_vkBindAccelerationStructureMemoryKHR) load(userptr, "vkBindAccelerationStructureMemoryKHR");
    glad_vkBuildAccelerationStructureKHR = (PFN_vkBuildAccelerationStructureKHR) load(userptr, "vkBuildAccelerationStructureKHR");
    glad_vkCmdBuildAccelerationStructureIndirectKHR = (PFN_vkCmdBuildAccelerationStructureIndirectKHR) load(userptr, "vkCmdBuildAccelerationStructureIndirectKHR");
    glad_vkCmdBuildAccelerationStructureKHR = (PFN_vkCmdBuildAccelerationStructureKHR) load(userptr, "vkCmdBuildAccelerationStructureKHR");
    glad_vkCmdCopyAccelerationStructureKHR = (PFN_vkCmdCopyAccelerationStructureKHR) load(userptr, "vkCmdCopyAccelerationStructureKHR");
    glad_vkCmdCopyAccelerationStructureToMemoryKHR = (PFN_vkCmdCopyAccelerationStructureToMemoryKHR) load(userptr, "vkCmdCopyAccelerationStructureToMemoryKHR");
    glad_vkCmdCopyMemoryToAccelerationStructureKHR = (PFN_vkCmdCopyMemoryToAccelerationStructureKHR) load(userptr, "vkCmdCopyMemoryToAccelerationStructureKHR");
    glad_vkCmdTraceRaysIndirectKHR = (PFN_vkCmdTraceRaysIndirectKHR) load(userptr, "vkCmdTraceRaysIndirectKHR");
    glad_vkCmdTraceRaysKHR = (PFN_vkCmdTraceRaysKHR) load(userptr, "vkCmdTraceRaysKHR");
    glad_vkCmdWriteAccelerationStructuresPropertiesKHR = (PFN_vkCmdWriteAccelerationStructuresPropertiesKHR) load(userptr, "vkCmdWriteAccelerationStructuresPropertiesKHR");
    glad_vkCopyAccelerationStructureKHR = (PFN_vkCopyAccelerationStructureKHR) load(userptr, "vkCopyAccelerationStructureKHR");
    glad_vkCopyAccelerationStructureToMemoryKHR = (PFN_vkCopyAccelerationStructureToMemoryKHR) load(userptr, "vkCopyAccelerationStructureToMemoryKHR");
    glad_vkCopyMemoryToAccelerationStructureKHR = (PFN_vkCopyMemoryToAccelerationStructureKHR) load(userptr, "vkCopyMemoryToAccelerationStructureKHR");
    glad_vkCreateAccelerationStructureKHR = (PFN_vkCreateAccelerationStructureKHR) load(userptr, "vkCreateAccelerationStructureKHR");
    glad_vkCreateRayTracingPipelinesKHR = (PFN_vkCreateRayTracingPipelinesKHR) load(userptr, "vkCreateRayTracingPipelinesKHR");
    glad_vkDestroyAccelerationStructureKHR = (PFN_vkDestroyAccelerationStructureKHR) load(userptr, "vkDestroyAccelerationStructureKHR");
    glad_vkGetAccelerationStructureDeviceAddressKHR = (PFN_vkGetAccelerationStructureDeviceAddressKHR) load(userptr, "vkGetAccelerationStructureDeviceAddressKHR");
    glad_vkGetAccelerationStructureMemoryRequirementsKHR = (PFN_vkGetAccelerationStructureMemoryRequirementsKHR) load(userptr, "vkGetAccelerationStructureMemoryRequirementsKHR");
    glad_vkGetDeviceAccelerationStructureCompatibilityKHR = (PFN_vkGetDeviceAccelerationStructureCompatibilityKHR) load(userptr, "vkGetDeviceAccelerationStructureCompatibilityKHR");
    glad_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = (PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR) load(userptr, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
    glad_vkGetRayTracingShaderGroupHandlesKHR = (PFN_vkGetRayTracingShaderGroupHandlesKHR) load(userptr, "vkGetRayTracingShaderGroupHandlesKHR");
    glad_vkWriteAccelerationStructuresPropertiesKHR = (PFN_vkWriteAccelerationStructuresPropertiesKHR) load(userptr, "vkWriteAccelerationStructuresPropertiesKHR");
}
#endif
static void glad_vk_load_VK_KHR_sampler_ycbcr_conversion( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_sampler_ycbcr_conversion) return;
    glad_vkCreateSamplerYcbcrConversionKHR = (PFN_vkCreateSamplerYcbcrConversionKHR) load(userptr, "vkCreateSamplerYcbcrConversionKHR");
    glad_vkDestroySamplerYcbcrConversionKHR = (PFN_vkDestroySamplerYcbcrConversionKHR) load(userptr, "vkDestroySamplerYcbcrConversionKHR");
}
static void glad_vk_load_VK_KHR_shared_presentable_image( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_shared_presentable_image) return;
    glad_vkGetSwapchainStatusKHR = (PFN_vkGetSwapchainStatusKHR) load(userptr, "vkGetSwapchainStatusKHR");
}
static void glad_vk_load_VK_KHR_surface( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_surface) return;
    glad_vkDestroySurfaceKHR = (PFN_vkDestroySurfaceKHR) load(userptr, "vkDestroySurfaceKHR");
    glad_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR) load(userptr, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
    glad_vkGetPhysicalDeviceSurfaceFormatsKHR = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR) load(userptr, "vkGetPhysicalDeviceSurfaceFormatsKHR");
    glad_vkGetPhysicalDeviceSurfacePresentModesKHR = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR) load(userptr, "vkGetPhysicalDeviceSurfacePresentModesKHR");
    glad_vkGetPhysicalDeviceSurfaceSupportKHR = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR) load(userptr, "vkGetPhysicalDeviceSurfaceSupportKHR");
}
static void glad_vk_load_VK_KHR_swapchain( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_swapchain) return;
    glad_vkAcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR) load(userptr, "vkAcquireNextImage2KHR");
    glad_vkAcquireNextImageKHR = (PFN_vkAcquireNextImageKHR) load(userptr, "vkAcquireNextImageKHR");
    glad_vkCreateSwapchainKHR = (PFN_vkCreateSwapchainKHR) load(userptr, "vkCreateSwapchainKHR");
    glad_vkDestroySwapchainKHR = (PFN_vkDestroySwapchainKHR) load(userptr, "vkDestroySwapchainKHR");
    glad_vkGetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR) load(userptr, "vkGetDeviceGroupPresentCapabilitiesKHR");
    glad_vkGetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR) load(userptr, "vkGetDeviceGroupSurfacePresentModesKHR");
    glad_vkGetPhysicalDevicePresentRectanglesKHR = (PFN_vkGetPhysicalDevicePresentRectanglesKHR) load(userptr, "vkGetPhysicalDevicePresentRectanglesKHR");
    glad_vkGetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR) load(userptr, "vkGetSwapchainImagesKHR");
    glad_vkQueuePresentKHR = (PFN_vkQueuePresentKHR) load(userptr, "vkQueuePresentKHR");
}
static void glad_vk_load_VK_KHR_timeline_semaphore( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_timeline_semaphore) return;
    glad_vkGetSemaphoreCounterValueKHR = (PFN_vkGetSemaphoreCounterValueKHR) load(userptr, "vkGetSemaphoreCounterValueKHR");
    glad_vkSignalSemaphoreKHR = (PFN_vkSignalSemaphoreKHR) load(userptr, "vkSignalSemaphoreKHR");
    glad_vkWaitSemaphoresKHR = (PFN_vkWaitSemaphoresKHR) load(userptr, "vkWaitSemaphoresKHR");
}
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
static void glad_vk_load_VK_KHR_wayland_surface( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_wayland_surface) return;
    glad_vkCreateWaylandSurfaceKHR = (PFN_vkCreateWaylandSurfaceKHR) load(userptr, "vkCreateWaylandSurfaceKHR");
    glad_vkGetPhysicalDeviceWaylandPresentationSupportKHR = (PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR) load(userptr, "vkGetPhysicalDeviceWaylandPresentationSupportKHR");
}
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
static void glad_vk_load_VK_KHR_win32_surface( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_win32_surface) return;
    glad_vkCreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) load(userptr, "vkCreateWin32SurfaceKHR");
    glad_vkGetPhysicalDeviceWin32PresentationSupportKHR = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR) load(userptr, "vkGetPhysicalDeviceWin32PresentationSupportKHR");
}
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
static void glad_vk_load_VK_KHR_xcb_surface( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_xcb_surface) return;
    glad_vkCreateXcbSurfaceKHR = (PFN_vkCreateXcbSurfaceKHR) load(userptr, "vkCreateXcbSurfaceKHR");
    glad_vkGetPhysicalDeviceXcbPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR) load(userptr, "vkGetPhysicalDeviceXcbPresentationSupportKHR");
}
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
static void glad_vk_load_VK_KHR_xlib_surface( GLADuserptrloadfunc load, void* userptr) {
    if(!GLAD_VK_KHR_xlib_surface) return;
    glad_vkCreateXlibSurfaceKHR = (PFN_vkCreateXlibSurfaceKHR) load(userptr, "vkCreateXlibSurfaceKHR");
    glad_vkGetPhysicalDeviceXlibPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR) load(userptr, "vkGetPhysicalDeviceXlibPresentationSupportKHR");
}
#endif



static int glad_vk_get_extensions( VkPhysicalDevice physical_device, uint32_t *out_extension_count, char ***out_extensions) {
    uint32_t i;
    uint32_t instance_extension_count = 0;
    uint32_t device_extension_count = 0;
    uint32_t max_extension_count = 0;
    uint32_t total_extension_count = 0;
    char **extensions = NULL;
    VkExtensionProperties *ext_properties = NULL;
    VkResult result;

    if (glad_vkEnumerateInstanceExtensionProperties == NULL || (physical_device != NULL && glad_vkEnumerateDeviceExtensionProperties == NULL)) {
        return 0;
    }

    result = glad_vkEnumerateInstanceExtensionProperties(NULL, &instance_extension_count, NULL);
    if (result != VK_SUCCESS) {
        return 0;
    }

    if (physical_device != NULL) {
        result = glad_vkEnumerateDeviceExtensionProperties(physical_device, NULL, &device_extension_count, NULL);
        if (result != VK_SUCCESS) {
            return 0;
        }
    }

    total_extension_count = instance_extension_count + device_extension_count;
    if (total_extension_count <= 0) {
        return 0;
    }

    max_extension_count = instance_extension_count > device_extension_count
        ? instance_extension_count : device_extension_count;

    ext_properties = (VkExtensionProperties*) malloc(max_extension_count * sizeof(VkExtensionProperties));
    if (ext_properties == NULL) {
        goto glad_vk_get_extensions_error;
    }

    result = glad_vkEnumerateInstanceExtensionProperties(NULL, &instance_extension_count, ext_properties);
    if (result != VK_SUCCESS) {
        goto glad_vk_get_extensions_error;
    }

    extensions = (char**) calloc(total_extension_count, sizeof(char*));
    if (extensions == NULL) {
        goto glad_vk_get_extensions_error;
    }

    for (i = 0; i < instance_extension_count; ++i) {
        VkExtensionProperties ext = ext_properties[i];

        size_t extension_name_length = strlen(ext.extensionName) + 1;
        extensions[i] = (char*) malloc(extension_name_length * sizeof(char));
        if (extensions[i] == NULL) {
            goto glad_vk_get_extensions_error;
        }
        memcpy(extensions[i], ext.extensionName, extension_name_length * sizeof(char));
    }

    if (physical_device != NULL) {
        result = glad_vkEnumerateDeviceExtensionProperties(physical_device, NULL, &device_extension_count, ext_properties);
        if (result != VK_SUCCESS) {
            goto glad_vk_get_extensions_error;
        }

        for (i = 0; i < device_extension_count; ++i) {
            VkExtensionProperties ext = ext_properties[i];

            size_t extension_name_length = strlen(ext.extensionName) + 1;
            extensions[instance_extension_count + i] = (char*) malloc(extension_name_length * sizeof(char));
            if (extensions[instance_extension_count + i] == NULL) {
                goto glad_vk_get_extensions_error;
            }
            memcpy(extensions[instance_extension_count + i], ext.extensionName, extension_name_length * sizeof(char));
        }
    }

    free((void*) ext_properties);

    *out_extension_count = total_extension_count;
    *out_extensions = extensions;

    return 1;

glad_vk_get_extensions_error:
    free((void*) ext_properties);
    if (extensions != NULL) {
        for (i = 0; i < total_extension_count; ++i) {
            free((void*) extensions[i]);
        }
        free(extensions);
    }
    return 0;
}

static void glad_vk_free_extensions(uint32_t extension_count, char **extensions) {
    uint32_t i;

    for(i = 0; i < extension_count ; ++i) {
        free((void*) (extensions[i]));
    }

    free((void*) extensions);
}

static int glad_vk_has_extension(const char *name, uint32_t extension_count, char **extensions) {
    uint32_t i;

    for (i = 0; i < extension_count; ++i) {
        if(extensions[i] != NULL && strcmp(name, extensions[i]) == 0) {
            return 1;
        }
    }

    return 0;
}

static GLADapiproc glad_vk_get_proc_from_userptr(void *userptr, const char* name) {
    return (GLAD_GNUC_EXTENSION (GLADapiproc (*)(const char *name)) userptr)(name);
}

static int glad_vk_find_extensions_vulkan( VkPhysicalDevice physical_device) {
    uint32_t extension_count = 0;
    char **extensions = NULL;
    if (!glad_vk_get_extensions(physical_device, &extension_count, &extensions)) return 0;

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    GLAD_VK_ANDROID_external_memory_android_hardware_buffer = glad_vk_has_extension("VK_ANDROID_external_memory_android_hardware_buffer", extension_count, extensions);
#endif
    GLAD_VK_EXT_4444_formats = glad_vk_has_extension("VK_EXT_4444_formats", extension_count, extensions);
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
    GLAD_VK_EXT_acquire_xlib_display = glad_vk_has_extension("VK_EXT_acquire_xlib_display", extension_count, extensions);
#endif
    GLAD_VK_EXT_astc_decode_mode = glad_vk_has_extension("VK_EXT_astc_decode_mode", extension_count, extensions);
    GLAD_VK_EXT_blend_operation_advanced = glad_vk_has_extension("VK_EXT_blend_operation_advanced", extension_count, extensions);
    GLAD_VK_EXT_buffer_device_address = glad_vk_has_extension("VK_EXT_buffer_device_address", extension_count, extensions);
    GLAD_VK_EXT_calibrated_timestamps = glad_vk_has_extension("VK_EXT_calibrated_timestamps", extension_count, extensions);
    GLAD_VK_EXT_conditional_rendering = glad_vk_has_extension("VK_EXT_conditional_rendering", extension_count, extensions);
    GLAD_VK_EXT_conservative_rasterization = glad_vk_has_extension("VK_EXT_conservative_rasterization", extension_count, extensions);
    GLAD_VK_EXT_custom_border_color = glad_vk_has_extension("VK_EXT_custom_border_color", extension_count, extensions);
    GLAD_VK_EXT_debug_marker = glad_vk_has_extension("VK_EXT_debug_marker", extension_count, extensions);
    GLAD_VK_EXT_debug_report = glad_vk_has_extension("VK_EXT_debug_report", extension_count, extensions);
    GLAD_VK_EXT_debug_utils = glad_vk_has_extension("VK_EXT_debug_utils", extension_count, extensions);
    GLAD_VK_EXT_depth_clip_enable = glad_vk_has_extension("VK_EXT_depth_clip_enable", extension_count, extensions);
    GLAD_VK_EXT_depth_range_unrestricted = glad_vk_has_extension("VK_EXT_depth_range_unrestricted", extension_count, extensions);
    GLAD_VK_EXT_descriptor_indexing = glad_vk_has_extension("VK_EXT_descriptor_indexing", extension_count, extensions);
    GLAD_VK_EXT_direct_mode_display = glad_vk_has_extension("VK_EXT_direct_mode_display", extension_count, extensions);
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
    GLAD_VK_EXT_directfb_surface = glad_vk_has_extension("VK_EXT_directfb_surface", extension_count, extensions);
#endif
    GLAD_VK_EXT_discard_rectangles = glad_vk_has_extension("VK_EXT_discard_rectangles", extension_count, extensions);
    GLAD_VK_EXT_display_control = glad_vk_has_extension("VK_EXT_display_control", extension_count, extensions);
    GLAD_VK_EXT_display_surface_counter = glad_vk_has_extension("VK_EXT_display_surface_counter", extension_count, extensions);
    GLAD_VK_EXT_extended_dynamic_state = glad_vk_has_extension("VK_EXT_extended_dynamic_state", extension_count, extensions);
    GLAD_VK_EXT_external_memory_dma_buf = glad_vk_has_extension("VK_EXT_external_memory_dma_buf", extension_count, extensions);
    GLAD_VK_EXT_external_memory_host = glad_vk_has_extension("VK_EXT_external_memory_host", extension_count, extensions);
    GLAD_VK_EXT_filter_cubic = glad_vk_has_extension("VK_EXT_filter_cubic", extension_count, extensions);
    GLAD_VK_EXT_fragment_density_map = glad_vk_has_extension("VK_EXT_fragment_density_map", extension_count, extensions);
    GLAD_VK_EXT_fragment_density_map2 = glad_vk_has_extension("VK_EXT_fragment_density_map2", extension_count, extensions);
    GLAD_VK_EXT_fragment_shader_interlock = glad_vk_has_extension("VK_EXT_fragment_shader_interlock", extension_count, extensions);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    GLAD_VK_EXT_full_screen_exclusive = glad_vk_has_extension("VK_EXT_full_screen_exclusive", extension_count, extensions);
#endif
    GLAD_VK_EXT_global_priority = glad_vk_has_extension("VK_EXT_global_priority", extension_count, extensions);
    GLAD_VK_EXT_hdr_metadata = glad_vk_has_extension("VK_EXT_hdr_metadata", extension_count, extensions);
    GLAD_VK_EXT_headless_surface = glad_vk_has_extension("VK_EXT_headless_surface", extension_count, extensions);
    GLAD_VK_EXT_host_query_reset = glad_vk_has_extension("VK_EXT_host_query_reset", extension_count, extensions);
    GLAD_VK_EXT_image_drm_format_modifier = glad_vk_has_extension("VK_EXT_image_drm_format_modifier", extension_count, extensions);
    GLAD_VK_EXT_image_robustness = glad_vk_has_extension("VK_EXT_image_robustness", extension_count, extensions);
    GLAD_VK_EXT_index_type_uint8 = glad_vk_has_extension("VK_EXT_index_type_uint8", extension_count, extensions);
    GLAD_VK_EXT_inline_uniform_block = glad_vk_has_extension("VK_EXT_inline_uniform_block", extension_count, extensions);
    GLAD_VK_EXT_line_rasterization = glad_vk_has_extension("VK_EXT_line_rasterization", extension_count, extensions);
    GLAD_VK_EXT_memory_budget = glad_vk_has_extension("VK_EXT_memory_budget", extension_count, extensions);
    GLAD_VK_EXT_memory_priority = glad_vk_has_extension("VK_EXT_memory_priority", extension_count, extensions);
#if defined(VK_USE_PLATFORM_METAL_EXT)
    GLAD_VK_EXT_metal_surface = glad_vk_has_extension("VK_EXT_metal_surface", extension_count, extensions);
#endif
    GLAD_VK_EXT_pci_bus_info = glad_vk_has_extension("VK_EXT_pci_bus_info", extension_count, extensions);
    GLAD_VK_EXT_pipeline_creation_cache_control = glad_vk_has_extension("VK_EXT_pipeline_creation_cache_control", extension_count, extensions);
    GLAD_VK_EXT_pipeline_creation_feedback = glad_vk_has_extension("VK_EXT_pipeline_creation_feedback", extension_count, extensions);
    GLAD_VK_EXT_post_depth_coverage = glad_vk_has_extension("VK_EXT_post_depth_coverage", extension_count, extensions);
    GLAD_VK_EXT_private_data = glad_vk_has_extension("VK_EXT_private_data", extension_count, extensions);
    GLAD_VK_EXT_queue_family_foreign = glad_vk_has_extension("VK_EXT_queue_family_foreign", extension_count, extensions);
    GLAD_VK_EXT_robustness2 = glad_vk_has_extension("VK_EXT_robustness2", extension_count, extensions);
    GLAD_VK_EXT_sample_locations = glad_vk_has_extension("VK_EXT_sample_locations", extension_count, extensions);
    GLAD_VK_EXT_sampler_filter_minmax = glad_vk_has_extension("VK_EXT_sampler_filter_minmax", extension_count, extensions);
    GLAD_VK_EXT_scalar_block_layout = glad_vk_has_extension("VK_EXT_scalar_block_layout", extension_count, extensions);
    GLAD_VK_EXT_separate_stencil_usage = glad_vk_has_extension("VK_EXT_separate_stencil_usage", extension_count, extensions);
    GLAD_VK_EXT_shader_atomic_float = glad_vk_has_extension("VK_EXT_shader_atomic_float", extension_count, extensions);
    GLAD_VK_EXT_shader_demote_to_helper_invocation = glad_vk_has_extension("VK_EXT_shader_demote_to_helper_invocation", extension_count, extensions);
    GLAD_VK_EXT_shader_stencil_export = glad_vk_has_extension("VK_EXT_shader_stencil_export", extension_count, extensions);
    GLAD_VK_EXT_shader_subgroup_ballot = glad_vk_has_extension("VK_EXT_shader_subgroup_ballot", extension_count, extensions);
    GLAD_VK_EXT_shader_subgroup_vote = glad_vk_has_extension("VK_EXT_shader_subgroup_vote", extension_count, extensions);
    GLAD_VK_EXT_shader_viewport_index_layer = glad_vk_has_extension("VK_EXT_shader_viewport_index_layer", extension_count, extensions);
    GLAD_VK_EXT_subgroup_size_control = glad_vk_has_extension("VK_EXT_subgroup_size_control", extension_count, extensions);
    GLAD_VK_EXT_swapchain_colorspace = glad_vk_has_extension("VK_EXT_swapchain_colorspace", extension_count, extensions);
    GLAD_VK_EXT_texel_buffer_alignment = glad_vk_has_extension("VK_EXT_texel_buffer_alignment", extension_count, extensions);
    GLAD_VK_EXT_texture_compression_astc_hdr = glad_vk_has_extension("VK_EXT_texture_compression_astc_hdr", extension_count, extensions);
    GLAD_VK_EXT_tooling_info = glad_vk_has_extension("VK_EXT_tooling_info", extension_count, extensions);
    GLAD_VK_EXT_transform_feedback = glad_vk_has_extension("VK_EXT_transform_feedback", extension_count, extensions);
    GLAD_VK_EXT_validation_cache = glad_vk_has_extension("VK_EXT_validation_cache", extension_count, extensions);
    GLAD_VK_EXT_validation_features = glad_vk_has_extension("VK_EXT_validation_features", extension_count, extensions);
    GLAD_VK_EXT_validation_flags = glad_vk_has_extension("VK_EXT_validation_flags", extension_count, extensions);
    GLAD_VK_EXT_vertex_attribute_divisor = glad_vk_has_extension("VK_EXT_vertex_attribute_divisor", extension_count, extensions);
    GLAD_VK_EXT_ycbcr_image_arrays = glad_vk_has_extension("VK_EXT_ycbcr_image_arrays", extension_count, extensions);
    GLAD_VK_KHR_16bit_storage = glad_vk_has_extension("VK_KHR_16bit_storage", extension_count, extensions);
    GLAD_VK_KHR_8bit_storage = glad_vk_has_extension("VK_KHR_8bit_storage", extension_count, extensions);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    GLAD_VK_KHR_android_surface = glad_vk_has_extension("VK_KHR_android_surface", extension_count, extensions);
#endif
    GLAD_VK_KHR_bind_memory2 = glad_vk_has_extension("VK_KHR_bind_memory2", extension_count, extensions);
    GLAD_VK_KHR_buffer_device_address = glad_vk_has_extension("VK_KHR_buffer_device_address", extension_count, extensions);
    GLAD_VK_KHR_create_renderpass2 = glad_vk_has_extension("VK_KHR_create_renderpass2", extension_count, extensions);
    GLAD_VK_KHR_dedicated_allocation = glad_vk_has_extension("VK_KHR_dedicated_allocation", extension_count, extensions);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    GLAD_VK_KHR_deferred_host_operations = glad_vk_has_extension("VK_KHR_deferred_host_operations", extension_count, extensions);
#endif
    GLAD_VK_KHR_depth_stencil_resolve = glad_vk_has_extension("VK_KHR_depth_stencil_resolve", extension_count, extensions);
    GLAD_VK_KHR_descriptor_update_template = glad_vk_has_extension("VK_KHR_descriptor_update_template", extension_count, extensions);
    GLAD_VK_KHR_device_group = glad_vk_has_extension("VK_KHR_device_group", extension_count, extensions);
    GLAD_VK_KHR_device_group_creation = glad_vk_has_extension("VK_KHR_device_group_creation", extension_count, extensions);
    GLAD_VK_KHR_display = glad_vk_has_extension("VK_KHR_display", extension_count, extensions);
    GLAD_VK_KHR_display_swapchain = glad_vk_has_extension("VK_KHR_display_swapchain", extension_count, extensions);
    GLAD_VK_KHR_draw_indirect_count = glad_vk_has_extension("VK_KHR_draw_indirect_count", extension_count, extensions);
    GLAD_VK_KHR_driver_properties = glad_vk_has_extension("VK_KHR_driver_properties", extension_count, extensions);
    GLAD_VK_KHR_external_fence = glad_vk_has_extension("VK_KHR_external_fence", extension_count, extensions);
    GLAD_VK_KHR_external_fence_capabilities = glad_vk_has_extension("VK_KHR_external_fence_capabilities", extension_count, extensions);
    GLAD_VK_KHR_external_fence_fd = glad_vk_has_extension("VK_KHR_external_fence_fd", extension_count, extensions);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    GLAD_VK_KHR_external_fence_win32 = glad_vk_has_extension("VK_KHR_external_fence_win32", extension_count, extensions);
#endif
    GLAD_VK_KHR_external_memory = glad_vk_has_extension("VK_KHR_external_memory", extension_count, extensions);
    GLAD_VK_KHR_external_memory_capabilities = glad_vk_has_extension("VK_KHR_external_memory_capabilities", extension_count, extensions);
    GLAD_VK_KHR_external_memory_fd = glad_vk_has_extension("VK_KHR_external_memory_fd", extension_count, extensions);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    GLAD_VK_KHR_external_memory_win32 = glad_vk_has_extension("VK_KHR_external_memory_win32", extension_count, extensions);
#endif
    GLAD_VK_KHR_external_semaphore = glad_vk_has_extension("VK_KHR_external_semaphore", extension_count, extensions);
    GLAD_VK_KHR_external_semaphore_capabilities = glad_vk_has_extension("VK_KHR_external_semaphore_capabilities", extension_count, extensions);
    GLAD_VK_KHR_external_semaphore_fd = glad_vk_has_extension("VK_KHR_external_semaphore_fd", extension_count, extensions);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    GLAD_VK_KHR_external_semaphore_win32 = glad_vk_has_extension("VK_KHR_external_semaphore_win32", extension_count, extensions);
#endif
    GLAD_VK_KHR_get_display_properties2 = glad_vk_has_extension("VK_KHR_get_display_properties2", extension_count, extensions);
    GLAD_VK_KHR_get_memory_requirements2 = glad_vk_has_extension("VK_KHR_get_memory_requirements2", extension_count, extensions);
    GLAD_VK_KHR_get_physical_device_properties2 = glad_vk_has_extension("VK_KHR_get_physical_device_properties2", extension_count, extensions);
    GLAD_VK_KHR_get_surface_capabilities2 = glad_vk_has_extension("VK_KHR_get_surface_capabilities2", extension_count, extensions);
    GLAD_VK_KHR_image_format_list = glad_vk_has_extension("VK_KHR_image_format_list", extension_count, extensions);
    GLAD_VK_KHR_imageless_framebuffer = glad_vk_has_extension("VK_KHR_imageless_framebuffer", extension_count, extensions);
    GLAD_VK_KHR_incremental_present = glad_vk_has_extension("VK_KHR_incremental_present", extension_count, extensions);
    GLAD_VK_KHR_maintenance1 = glad_vk_has_extension("VK_KHR_maintenance1", extension_count, extensions);
    GLAD_VK_KHR_maintenance2 = glad_vk_has_extension("VK_KHR_maintenance2", extension_count, extensions);
    GLAD_VK_KHR_maintenance3 = glad_vk_has_extension("VK_KHR_maintenance3", extension_count, extensions);
    GLAD_VK_KHR_multiview = glad_vk_has_extension("VK_KHR_multiview", extension_count, extensions);
    GLAD_VK_KHR_performance_query = glad_vk_has_extension("VK_KHR_performance_query", extension_count, extensions);
    GLAD_VK_KHR_pipeline_executable_properties = glad_vk_has_extension("VK_KHR_pipeline_executable_properties", extension_count, extensions);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    GLAD_VK_KHR_pipeline_library = glad_vk_has_extension("VK_KHR_pipeline_library", extension_count, extensions);
#endif
    GLAD_VK_KHR_push_descriptor = glad_vk_has_extension("VK_KHR_push_descriptor", extension_count, extensions);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    GLAD_VK_KHR_ray_tracing = glad_vk_has_extension("VK_KHR_ray_tracing", extension_count, extensions);
#endif
    GLAD_VK_KHR_relaxed_block_layout = glad_vk_has_extension("VK_KHR_relaxed_block_layout", extension_count, extensions);
    GLAD_VK_KHR_sampler_mirror_clamp_to_edge = glad_vk_has_extension("VK_KHR_sampler_mirror_clamp_to_edge", extension_count, extensions);
    GLAD_VK_KHR_sampler_ycbcr_conversion = glad_vk_has_extension("VK_KHR_sampler_ycbcr_conversion", extension_count, extensions);
    GLAD_VK_KHR_separate_depth_stencil_layouts = glad_vk_has_extension("VK_KHR_separate_depth_stencil_layouts", extension_count, extensions);
    GLAD_VK_KHR_shader_atomic_int64 = glad_vk_has_extension("VK_KHR_shader_atomic_int64", extension_count, extensions);
    GLAD_VK_KHR_shader_clock = glad_vk_has_extension("VK_KHR_shader_clock", extension_count, extensions);
    GLAD_VK_KHR_shader_draw_parameters = glad_vk_has_extension("VK_KHR_shader_draw_parameters", extension_count, extensions);
    GLAD_VK_KHR_shader_float16_int8 = glad_vk_has_extension("VK_KHR_shader_float16_int8", extension_count, extensions);
    GLAD_VK_KHR_shader_float_controls = glad_vk_has_extension("VK_KHR_shader_float_controls", extension_count, extensions);
    GLAD_VK_KHR_shader_non_semantic_info = glad_vk_has_extension("VK_KHR_shader_non_semantic_info", extension_count, extensions);
    GLAD_VK_KHR_shader_subgroup_extended_types = glad_vk_has_extension("VK_KHR_shader_subgroup_extended_types", extension_count, extensions);
    GLAD_VK_KHR_shared_presentable_image = glad_vk_has_extension("VK_KHR_shared_presentable_image", extension_count, extensions);
    GLAD_VK_KHR_spirv_1_4 = glad_vk_has_extension("VK_KHR_spirv_1_4", extension_count, extensions);
    GLAD_VK_KHR_storage_buffer_storage_class = glad_vk_has_extension("VK_KHR_storage_buffer_storage_class", extension_count, extensions);
    GLAD_VK_KHR_surface = glad_vk_has_extension("VK_KHR_surface", extension_count, extensions);
    GLAD_VK_KHR_surface_protected_capabilities = glad_vk_has_extension("VK_KHR_surface_protected_capabilities", extension_count, extensions);
    GLAD_VK_KHR_swapchain = glad_vk_has_extension("VK_KHR_swapchain", extension_count, extensions);
    GLAD_VK_KHR_swapchain_mutable_format = glad_vk_has_extension("VK_KHR_swapchain_mutable_format", extension_count, extensions);
    GLAD_VK_KHR_timeline_semaphore = glad_vk_has_extension("VK_KHR_timeline_semaphore", extension_count, extensions);
    GLAD_VK_KHR_uniform_buffer_standard_layout = glad_vk_has_extension("VK_KHR_uniform_buffer_standard_layout", extension_count, extensions);
    GLAD_VK_KHR_variable_pointers = glad_vk_has_extension("VK_KHR_variable_pointers", extension_count, extensions);
    GLAD_VK_KHR_vulkan_memory_model = glad_vk_has_extension("VK_KHR_vulkan_memory_model", extension_count, extensions);
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
    GLAD_VK_KHR_wayland_surface = glad_vk_has_extension("VK_KHR_wayland_surface", extension_count, extensions);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    GLAD_VK_KHR_win32_keyed_mutex = glad_vk_has_extension("VK_KHR_win32_keyed_mutex", extension_count, extensions);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    GLAD_VK_KHR_win32_surface = glad_vk_has_extension("VK_KHR_win32_surface", extension_count, extensions);
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
    GLAD_VK_KHR_xcb_surface = glad_vk_has_extension("VK_KHR_xcb_surface", extension_count, extensions);
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
    GLAD_VK_KHR_xlib_surface = glad_vk_has_extension("VK_KHR_xlib_surface", extension_count, extensions);
#endif

    glad_vk_free_extensions(extension_count, extensions);

    return 1;
}

static int glad_vk_find_core_vulkan( VkPhysicalDevice physical_device) {
    int major = 1;
    int minor = 0;

#ifdef VK_VERSION_1_1
    if (glad_vkEnumerateInstanceVersion != NULL) {
        uint32_t version;
        VkResult result;

        result = glad_vkEnumerateInstanceVersion(&version);
        if (result == VK_SUCCESS) {
            major = (int) VK_VERSION_MAJOR(version);
            minor = (int) VK_VERSION_MINOR(version);
        }
    }
#endif

    if (physical_device != NULL && glad_vkGetPhysicalDeviceProperties != NULL) {
        VkPhysicalDeviceProperties properties;
        glad_vkGetPhysicalDeviceProperties(physical_device, &properties);

        major = (int) VK_VERSION_MAJOR(properties.apiVersion);
        minor = (int) VK_VERSION_MINOR(properties.apiVersion);
    }

    GLAD_VK_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;
    GLAD_VK_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;
    GLAD_VK_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;

    return GLAD_MAKE_VERSION(major, minor);
}

int gladLoadVulkanUserPtr( VkPhysicalDevice physical_device, GLADuserptrloadfunc load, void *userptr) {
    int version;

#ifdef VK_VERSION_1_1
    glad_vkEnumerateInstanceVersion  = (PFN_vkEnumerateInstanceVersion) load(userptr, "vkEnumerateInstanceVersion");
#endif
    version = glad_vk_find_core_vulkan( physical_device);
    if (!version) {
        return 0;
    }

    glad_vk_load_VK_VERSION_1_0(load, userptr);
    glad_vk_load_VK_VERSION_1_1(load, userptr);
    glad_vk_load_VK_VERSION_1_2(load, userptr);

    if (!glad_vk_find_extensions_vulkan( physical_device)) return 0;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    glad_vk_load_VK_ANDROID_external_memory_android_hardware_buffer(load, userptr);
#endif
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
    glad_vk_load_VK_EXT_acquire_xlib_display(load, userptr);
#endif
    glad_vk_load_VK_EXT_buffer_device_address(load, userptr);
    glad_vk_load_VK_EXT_calibrated_timestamps(load, userptr);
    glad_vk_load_VK_EXT_conditional_rendering(load, userptr);
    glad_vk_load_VK_EXT_debug_marker(load, userptr);
    glad_vk_load_VK_EXT_debug_report(load, userptr);
    glad_vk_load_VK_EXT_debug_utils(load, userptr);
    glad_vk_load_VK_EXT_direct_mode_display(load, userptr);
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
    glad_vk_load_VK_EXT_directfb_surface(load, userptr);
#endif
    glad_vk_load_VK_EXT_discard_rectangles(load, userptr);
    glad_vk_load_VK_EXT_display_control(load, userptr);
    glad_vk_load_VK_EXT_display_surface_counter(load, userptr);
    glad_vk_load_VK_EXT_extended_dynamic_state(load, userptr);
    glad_vk_load_VK_EXT_external_memory_host(load, userptr);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    glad_vk_load_VK_EXT_full_screen_exclusive(load, userptr);
#endif
    glad_vk_load_VK_EXT_hdr_metadata(load, userptr);
    glad_vk_load_VK_EXT_headless_surface(load, userptr);
    glad_vk_load_VK_EXT_host_query_reset(load, userptr);
    glad_vk_load_VK_EXT_image_drm_format_modifier(load, userptr);
    glad_vk_load_VK_EXT_line_rasterization(load, userptr);
#if defined(VK_USE_PLATFORM_METAL_EXT)
    glad_vk_load_VK_EXT_metal_surface(load, userptr);
#endif
    glad_vk_load_VK_EXT_private_data(load, userptr);
    glad_vk_load_VK_EXT_sample_locations(load, userptr);
    glad_vk_load_VK_EXT_tooling_info(load, userptr);
    glad_vk_load_VK_EXT_transform_feedback(load, userptr);
    glad_vk_load_VK_EXT_validation_cache(load, userptr);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    glad_vk_load_VK_KHR_android_surface(load, userptr);
#endif
    glad_vk_load_VK_KHR_bind_memory2(load, userptr);
    glad_vk_load_VK_KHR_buffer_device_address(load, userptr);
    glad_vk_load_VK_KHR_create_renderpass2(load, userptr);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    glad_vk_load_VK_KHR_deferred_host_operations(load, userptr);
#endif
    glad_vk_load_VK_KHR_descriptor_update_template(load, userptr);
    glad_vk_load_VK_KHR_device_group(load, userptr);
    glad_vk_load_VK_KHR_device_group_creation(load, userptr);
    glad_vk_load_VK_KHR_display(load, userptr);
    glad_vk_load_VK_KHR_display_swapchain(load, userptr);
    glad_vk_load_VK_KHR_draw_indirect_count(load, userptr);
    glad_vk_load_VK_KHR_external_fence_capabilities(load, userptr);
    glad_vk_load_VK_KHR_external_fence_fd(load, userptr);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    glad_vk_load_VK_KHR_external_fence_win32(load, userptr);
#endif
    glad_vk_load_VK_KHR_external_memory_capabilities(load, userptr);
    glad_vk_load_VK_KHR_external_memory_fd(load, userptr);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    glad_vk_load_VK_KHR_external_memory_win32(load, userptr);
#endif
    glad_vk_load_VK_KHR_external_semaphore_capabilities(load, userptr);
    glad_vk_load_VK_KHR_external_semaphore_fd(load, userptr);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    glad_vk_load_VK_KHR_external_semaphore_win32(load, userptr);
#endif
    glad_vk_load_VK_KHR_get_display_properties2(load, userptr);
    glad_vk_load_VK_KHR_get_memory_requirements2(load, userptr);
    glad_vk_load_VK_KHR_get_physical_device_properties2(load, userptr);
    glad_vk_load_VK_KHR_get_surface_capabilities2(load, userptr);
    glad_vk_load_VK_KHR_maintenance1(load, userptr);
    glad_vk_load_VK_KHR_maintenance3(load, userptr);
    glad_vk_load_VK_KHR_performance_query(load, userptr);
    glad_vk_load_VK_KHR_pipeline_executable_properties(load, userptr);
    glad_vk_load_VK_KHR_push_descriptor(load, userptr);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
    glad_vk_load_VK_KHR_ray_tracing(load, userptr);
#endif
    glad_vk_load_VK_KHR_sampler_ycbcr_conversion(load, userptr);
    glad_vk_load_VK_KHR_shared_presentable_image(load, userptr);
    glad_vk_load_VK_KHR_surface(load, userptr);
    glad_vk_load_VK_KHR_swapchain(load, userptr);
    glad_vk_load_VK_KHR_timeline_semaphore(load, userptr);
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
    glad_vk_load_VK_KHR_wayland_surface(load, userptr);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    glad_vk_load_VK_KHR_win32_surface(load, userptr);
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
    glad_vk_load_VK_KHR_xcb_surface(load, userptr);
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
    glad_vk_load_VK_KHR_xlib_surface(load, userptr);
#endif


    return version;
}


int gladLoadVulkan( VkPhysicalDevice physical_device, GLADloadfunc load) {
    return gladLoadVulkanUserPtr( physical_device, glad_vk_get_proc_from_userptr, GLAD_GNUC_EXTENSION (void*) load);
}



 

#ifdef GLAD_VULKAN

#ifndef GLAD_LOADER_LIBRARY_C_
#define GLAD_LOADER_LIBRARY_C_

#include <stddef.h>
#include <stdlib.h>

#if GLAD_PLATFORM_WIN32
#include <windows.h>
#else
#include <dlfcn.h>
#endif


static void* glad_get_dlopen_handle(const char *lib_names[], int length) {
    void *handle = NULL;
    int i;

    for (i = 0; i < length; ++i) {
#if GLAD_PLATFORM_WIN32
  #if GLAD_PLATFORM_UWP
        size_t buffer_size = (strlen(lib_names[i]) + 1) * sizeof(WCHAR);
        LPWSTR buffer = (LPWSTR) malloc(buffer_size);
        if (buffer != NULL) {
            int ret = MultiByteToWideChar(CP_ACP, 0, lib_names[i], -1, buffer, buffer_size);
            if (ret != 0) {
                handle = (void*) LoadPackagedLibrary(buffer, 0);
            }
            free((void*) buffer);
        }
  #else
        handle = (void*) LoadLibraryA(lib_names[i]);
  #endif
#else
        handle = dlopen(lib_names[i], RTLD_LAZY | RTLD_LOCAL);
#endif
        if (handle != NULL) {
            return handle;
        }
    }

    return NULL;
}

static void glad_close_dlopen_handle(void* handle) {
    if (handle != NULL) {
#if GLAD_PLATFORM_WIN32
        FreeLibrary((HMODULE) handle);
#else
        dlclose(handle);
#endif
    }
}

static GLADapiproc glad_dlsym_handle(void* handle, const char *name) {
    if (handle == NULL) {
        return NULL;
    }

#if GLAD_PLATFORM_WIN32
    return (GLADapiproc) GetProcAddress((HMODULE) handle, name);
#else
    return GLAD_GNUC_EXTENSION (GLADapiproc) dlsym(handle, name);
#endif
}

#endif /* GLAD_LOADER_LIBRARY_C_ */


static const char* DEVICE_FUNCTIONS[] = {
    "vkAcquireFullScreenExclusiveModeEXT",
    "vkAcquireNextImage2KHR",
    "vkAcquireNextImageKHR",
    "vkAcquireProfilingLockKHR",
    "vkAllocateCommandBuffers",
    "vkAllocateDescriptorSets",
    "vkAllocateMemory",
    "vkBeginCommandBuffer",
    "vkBindAccelerationStructureMemoryKHR",
    "vkBindBufferMemory",
    "vkBindBufferMemory2",
    "vkBindBufferMemory2KHR",
    "vkBindImageMemory",
    "vkBindImageMemory2",
    "vkBindImageMemory2KHR",
    "vkBuildAccelerationStructureKHR",
    "vkCmdBeginConditionalRenderingEXT",
    "vkCmdBeginDebugUtilsLabelEXT",
    "vkCmdBeginQuery",
    "vkCmdBeginQueryIndexedEXT",
    "vkCmdBeginRenderPass",
    "vkCmdBeginRenderPass2",
    "vkCmdBeginRenderPass2KHR",
    "vkCmdBeginTransformFeedbackEXT",
    "vkCmdBindDescriptorSets",
    "vkCmdBindIndexBuffer",
    "vkCmdBindPipeline",
    "vkCmdBindTransformFeedbackBuffersEXT",
    "vkCmdBindVertexBuffers",
    "vkCmdBindVertexBuffers2EXT",
    "vkCmdBlitImage",
    "vkCmdBuildAccelerationStructureIndirectKHR",
    "vkCmdBuildAccelerationStructureKHR",
    "vkCmdClearAttachments",
    "vkCmdClearColorImage",
    "vkCmdClearDepthStencilImage",
    "vkCmdCopyAccelerationStructureKHR",
    "vkCmdCopyAccelerationStructureToMemoryKHR",
    "vkCmdCopyBuffer",
    "vkCmdCopyBufferToImage",
    "vkCmdCopyImage",
    "vkCmdCopyImageToBuffer",
    "vkCmdCopyMemoryToAccelerationStructureKHR",
    "vkCmdCopyQueryPoolResults",
    "vkCmdDebugMarkerBeginEXT",
    "vkCmdDebugMarkerEndEXT",
    "vkCmdDebugMarkerInsertEXT",
    "vkCmdDispatch",
    "vkCmdDispatchBase",
    "vkCmdDispatchBaseKHR",
    "vkCmdDispatchIndirect",
    "vkCmdDraw",
    "vkCmdDrawIndexed",
    "vkCmdDrawIndexedIndirect",
    "vkCmdDrawIndexedIndirectCount",
    "vkCmdDrawIndexedIndirectCountKHR",
    "vkCmdDrawIndirect",
    "vkCmdDrawIndirectByteCountEXT",
    "vkCmdDrawIndirectCount",
    "vkCmdDrawIndirectCountKHR",
    "vkCmdEndConditionalRenderingEXT",
    "vkCmdEndDebugUtilsLabelEXT",
    "vkCmdEndQuery",
    "vkCmdEndQueryIndexedEXT",
    "vkCmdEndRenderPass",
    "vkCmdEndRenderPass2",
    "vkCmdEndRenderPass2KHR",
    "vkCmdEndTransformFeedbackEXT",
    "vkCmdExecuteCommands",
    "vkCmdFillBuffer",
    "vkCmdInsertDebugUtilsLabelEXT",
    "vkCmdNextSubpass",
    "vkCmdNextSubpass2",
    "vkCmdNextSubpass2KHR",
    "vkCmdPipelineBarrier",
    "vkCmdPushConstants",
    "vkCmdPushDescriptorSetKHR",
    "vkCmdPushDescriptorSetWithTemplateKHR",
    "vkCmdResetEvent",
    "vkCmdResetQueryPool",
    "vkCmdResolveImage",
    "vkCmdSetBlendConstants",
    "vkCmdSetCullModeEXT",
    "vkCmdSetDepthBias",
    "vkCmdSetDepthBounds",
    "vkCmdSetDepthBoundsTestEnableEXT",
    "vkCmdSetDepthCompareOpEXT",
    "vkCmdSetDepthTestEnableEXT",
    "vkCmdSetDepthWriteEnableEXT",
    "vkCmdSetDeviceMask",
    "vkCmdSetDeviceMaskKHR",
    "vkCmdSetDiscardRectangleEXT",
    "vkCmdSetEvent",
    "vkCmdSetFrontFaceEXT",
    "vkCmdSetLineStippleEXT",
    "vkCmdSetLineWidth",
    "vkCmdSetPrimitiveTopologyEXT",
    "vkCmdSetSampleLocationsEXT",
    "vkCmdSetScissor",
    "vkCmdSetScissorWithCountEXT",
    "vkCmdSetStencilCompareMask",
    "vkCmdSetStencilOpEXT",
    "vkCmdSetStencilReference",
    "vkCmdSetStencilTestEnableEXT",
    "vkCmdSetStencilWriteMask",
    "vkCmdSetViewport",
    "vkCmdSetViewportWithCountEXT",
    "vkCmdTraceRaysIndirectKHR",
    "vkCmdTraceRaysKHR",
    "vkCmdUpdateBuffer",
    "vkCmdWaitEvents",
    "vkCmdWriteAccelerationStructuresPropertiesKHR",
    "vkCmdWriteTimestamp",
    "vkCopyAccelerationStructureKHR",
    "vkCopyAccelerationStructureToMemoryKHR",
    "vkCopyMemoryToAccelerationStructureKHR",
    "vkCreateAccelerationStructureKHR",
    "vkCreateBuffer",
    "vkCreateBufferView",
    "vkCreateCommandPool",
    "vkCreateComputePipelines",
    "vkCreateDeferredOperationKHR",
    "vkCreateDescriptorPool",
    "vkCreateDescriptorSetLayout",
    "vkCreateDescriptorUpdateTemplate",
    "vkCreateDescriptorUpdateTemplateKHR",
    "vkCreateEvent",
    "vkCreateFence",
    "vkCreateFramebuffer",
    "vkCreateGraphicsPipelines",
    "vkCreateImage",
    "vkCreateImageView",
    "vkCreatePipelineCache",
    "vkCreatePipelineLayout",
    "vkCreatePrivateDataSlotEXT",
    "vkCreateQueryPool",
    "vkCreateRayTracingPipelinesKHR",
    "vkCreateRenderPass",
    "vkCreateRenderPass2",
    "vkCreateRenderPass2KHR",
    "vkCreateSampler",
    "vkCreateSamplerYcbcrConversion",
    "vkCreateSamplerYcbcrConversionKHR",
    "vkCreateSemaphore",
    "vkCreateShaderModule",
    "vkCreateSharedSwapchainsKHR",
    "vkCreateSwapchainKHR",
    "vkCreateValidationCacheEXT",
    "vkDebugMarkerSetObjectNameEXT",
    "vkDebugMarkerSetObjectTagEXT",
    "vkDeferredOperationJoinKHR",
    "vkDestroyAccelerationStructureKHR",
    "vkDestroyBuffer",
    "vkDestroyBufferView",
    "vkDestroyCommandPool",
    "vkDestroyDeferredOperationKHR",
    "vkDestroyDescriptorPool",
    "vkDestroyDescriptorSetLayout",
    "vkDestroyDescriptorUpdateTemplate",
    "vkDestroyDescriptorUpdateTemplateKHR",
    "vkDestroyDevice",
    "vkDestroyEvent",
    "vkDestroyFence",
    "vkDestroyFramebuffer",
    "vkDestroyImage",
    "vkDestroyImageView",
    "vkDestroyPipeline",
    "vkDestroyPipelineCache",
    "vkDestroyPipelineLayout",
    "vkDestroyPrivateDataSlotEXT",
    "vkDestroyQueryPool",
    "vkDestroyRenderPass",
    "vkDestroySampler",
    "vkDestroySamplerYcbcrConversion",
    "vkDestroySamplerYcbcrConversionKHR",
    "vkDestroySemaphore",
    "vkDestroyShaderModule",
    "vkDestroySwapchainKHR",
    "vkDestroyValidationCacheEXT",
    "vkDeviceWaitIdle",
    "vkDisplayPowerControlEXT",
    "vkEndCommandBuffer",
    "vkFlushMappedMemoryRanges",
    "vkFreeCommandBuffers",
    "vkFreeDescriptorSets",
    "vkFreeMemory",
    "vkGetAccelerationStructureDeviceAddressKHR",
    "vkGetAccelerationStructureMemoryRequirementsKHR",
    "vkGetAndroidHardwareBufferPropertiesANDROID",
    "vkGetBufferDeviceAddress",
    "vkGetBufferDeviceAddressEXT",
    "vkGetBufferDeviceAddressKHR",
    "vkGetBufferMemoryRequirements",
    "vkGetBufferMemoryRequirements2",
    "vkGetBufferMemoryRequirements2KHR",
    "vkGetBufferOpaqueCaptureAddress",
    "vkGetBufferOpaqueCaptureAddressKHR",
    "vkGetCalibratedTimestampsEXT",
    "vkGetDeferredOperationMaxConcurrencyKHR",
    "vkGetDeferredOperationResultKHR",
    "vkGetDescriptorSetLayoutSupport",
    "vkGetDescriptorSetLayoutSupportKHR",
    "vkGetDeviceAccelerationStructureCompatibilityKHR",
    "vkGetDeviceGroupPeerMemoryFeatures",
    "vkGetDeviceGroupPeerMemoryFeaturesKHR",
    "vkGetDeviceGroupPresentCapabilitiesKHR",
    "vkGetDeviceGroupSurfacePresentModes2EXT",
    "vkGetDeviceGroupSurfacePresentModesKHR",
    "vkGetDeviceMemoryCommitment",
    "vkGetDeviceMemoryOpaqueCaptureAddress",
    "vkGetDeviceMemoryOpaqueCaptureAddressKHR",
    "vkGetDeviceProcAddr",
    "vkGetDeviceQueue",
    "vkGetDeviceQueue2",
    "vkGetEventStatus",
    "vkGetFenceFdKHR",
    "vkGetFenceStatus",
    "vkGetFenceWin32HandleKHR",
    "vkGetImageDrmFormatModifierPropertiesEXT",
    "vkGetImageMemoryRequirements",
    "vkGetImageMemoryRequirements2",
    "vkGetImageMemoryRequirements2KHR",
    "vkGetImageSparseMemoryRequirements",
    "vkGetImageSparseMemoryRequirements2",
    "vkGetImageSparseMemoryRequirements2KHR",
    "vkGetImageSubresourceLayout",
    "vkGetMemoryAndroidHardwareBufferANDROID",
    "vkGetMemoryFdKHR",
    "vkGetMemoryFdPropertiesKHR",
    "vkGetMemoryHostPointerPropertiesEXT",
    "vkGetMemoryWin32HandleKHR",
    "vkGetMemoryWin32HandlePropertiesKHR",
    "vkGetPipelineCacheData",
    "vkGetPipelineExecutableInternalRepresentationsKHR",
    "vkGetPipelineExecutablePropertiesKHR",
    "vkGetPipelineExecutableStatisticsKHR",
    "vkGetPrivateDataEXT",
    "vkGetQueryPoolResults",
    "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR",
    "vkGetRayTracingShaderGroupHandlesKHR",
    "vkGetRenderAreaGranularity",
    "vkGetSemaphoreCounterValue",
    "vkGetSemaphoreCounterValueKHR",
    "vkGetSemaphoreFdKHR",
    "vkGetSemaphoreWin32HandleKHR",
    "vkGetSwapchainCounterEXT",
    "vkGetSwapchainImagesKHR",
    "vkGetSwapchainStatusKHR",
    "vkGetValidationCacheDataEXT",
    "vkImportFenceFdKHR",
    "vkImportFenceWin32HandleKHR",
    "vkImportSemaphoreFdKHR",
    "vkImportSemaphoreWin32HandleKHR",
    "vkInvalidateMappedMemoryRanges",
    "vkMapMemory",
    "vkMergePipelineCaches",
    "vkMergeValidationCachesEXT",
    "vkQueueBeginDebugUtilsLabelEXT",
    "vkQueueBindSparse",
    "vkQueueEndDebugUtilsLabelEXT",
    "vkQueueInsertDebugUtilsLabelEXT",
    "vkQueuePresentKHR",
    "vkQueueSubmit",
    "vkQueueWaitIdle",
    "vkRegisterDeviceEventEXT",
    "vkRegisterDisplayEventEXT",
    "vkReleaseFullScreenExclusiveModeEXT",
    "vkReleaseProfilingLockKHR",
    "vkResetCommandBuffer",
    "vkResetCommandPool",
    "vkResetDescriptorPool",
    "vkResetEvent",
    "vkResetFences",
    "vkResetQueryPool",
    "vkResetQueryPoolEXT",
    "vkSetDebugUtilsObjectNameEXT",
    "vkSetDebugUtilsObjectTagEXT",
    "vkSetEvent",
    "vkSetHdrMetadataEXT",
    "vkSetPrivateDataEXT",
    "vkSignalSemaphore",
    "vkSignalSemaphoreKHR",
    "vkTrimCommandPool",
    "vkTrimCommandPoolKHR",
    "vkUnmapMemory",
    "vkUpdateDescriptorSetWithTemplate",
    "vkUpdateDescriptorSetWithTemplateKHR",
    "vkUpdateDescriptorSets",
    "vkWaitForFences",
    "vkWaitSemaphores",
    "vkWaitSemaphoresKHR",
    "vkWriteAccelerationStructuresPropertiesKHR",
};

static int glad_vulkan_is_device_function(const char *name) {
    /* Exists as a workaround for:
     * https://github.com/KhronosGroup/Vulkan-LoaderAndValidationLayers/issues/2323
     *
     * `vkGetDeviceProcAddr` does not return NULL for non-device functions.
     */
    int i;
    int length = sizeof(DEVICE_FUNCTIONS) / sizeof(DEVICE_FUNCTIONS[0]);

    for (i=0; i < length; ++i) {
        if (strcmp(DEVICE_FUNCTIONS[i], name) == 0) {
            return 1;
        }
    }

    return 0;
}

struct _glad_vulkan_userptr {
    void *vk_handle;
    VkInstance vk_instance;
    VkDevice vk_device;
    PFN_vkGetInstanceProcAddr get_instance_proc_addr;
    PFN_vkGetDeviceProcAddr get_device_proc_addr;
};

static GLADapiproc glad_vulkan_get_proc(void *vuserptr, const char *name) {
    struct _glad_vulkan_userptr userptr = *(struct _glad_vulkan_userptr*) vuserptr;
    PFN_vkVoidFunction result = NULL;

    if (userptr.vk_device != NULL && glad_vulkan_is_device_function(name)) {
        result = userptr.get_device_proc_addr(userptr.vk_device, name);
    }

    if (result == NULL && userptr.vk_instance != NULL) {
        result = userptr.get_instance_proc_addr(userptr.vk_instance, name);
    }

    if(result == NULL) {
        result = (PFN_vkVoidFunction) glad_dlsym_handle(userptr.vk_handle, name);
    }

    return (GLADapiproc) result;
}


static void* _vulkan_handle;

static void* glad_vulkan_dlopen_handle(void) {
    static const char *NAMES[] = {
#if GLAD_PLATFORM_APPLE
        "libvulkan.1.dylib",
#elif GLAD_PLATFORM_WIN32
        "vulkan-1.dll",
        "vulkan.dll",
#else
        "libvulkan.so.1",
        "libvulkan.so",
#endif
    };

    if (_vulkan_handle == NULL) {
        _vulkan_handle = glad_get_dlopen_handle(NAMES, sizeof(NAMES) / sizeof(NAMES[0]));
    }

    return _vulkan_handle;
}

static struct _glad_vulkan_userptr glad_vulkan_build_userptr(void *handle, VkInstance instance, VkDevice device) {
    struct _glad_vulkan_userptr userptr;
    userptr.vk_handle = handle;
    userptr.vk_instance = instance;
    userptr.vk_device = device;
    userptr.get_instance_proc_addr = (PFN_vkGetInstanceProcAddr) glad_dlsym_handle(handle, "vkGetInstanceProcAddr");
    userptr.get_device_proc_addr = (PFN_vkGetDeviceProcAddr) glad_dlsym_handle(handle, "vkGetDeviceProcAddr");
    return userptr;
}

int gladLoaderLoadVulkan( VkInstance instance, VkPhysicalDevice physical_device, VkDevice device) {
    int version = 0;
    void *handle = NULL;
    int did_load = 0;
    struct _glad_vulkan_userptr userptr;

    did_load = _vulkan_handle == NULL;
    handle = glad_vulkan_dlopen_handle();
    if (handle != NULL) {
        userptr = glad_vulkan_build_userptr(handle, instance, device);

        if (userptr.get_instance_proc_addr != NULL && userptr.get_device_proc_addr != NULL) {
            version = gladLoadVulkanUserPtr( physical_device, glad_vulkan_get_proc, &userptr);
        }

        if (!version && did_load) {
            gladLoaderUnloadVulkan();
        }
    }

    return version;
}



void gladLoaderUnloadVulkan(void) {
    if (_vulkan_handle != NULL) {
        glad_close_dlopen_handle(_vulkan_handle);
        _vulkan_handle = NULL;
    }
}

#endif /* GLAD_VULKAN */

#ifdef __cplusplus
}
#endif

```

`Modules/Vulkan/Public/Toon/Vulkan/VulkanBuffer.hpp`:

```hpp
#ifndef TOON_VULKAN_BUFFER_HPP
#define TOON_VULKAN_BUFFER_HPP

#include <Toon/Vulkan/VulkanConfig.hpp>
#include <Toon/Buffer.hpp>

#include <optional>

#include <vk_mem_alloc.h>

namespace Toon::Vulkan {

#define TOON_VULKAN_BUFFER(x) (dynamic_cast<Toon::Vulkan::VulkanBuffer *>(x))

class TOON_VULKAN_API VulkanBuffer : public Buffer
{
public:

    DISALLOW_COPY_AND_ASSIGN(VulkanBuffer)

    VulkanBuffer() = default;

    virtual inline ~VulkanBuffer() = default;

    bool Initialize(size_t size, uint8_t * data, BufferUsage bufferUsage, MemoryUsage memoryUsage) override;

    void Terminate() override;

    inline VkBuffer GetVkBuffer() {
        return _vkBuffer;
    }

private:

    VkBuffer _vkBuffer;

    VmaAllocation _vmaAllocation;

    VkDeviceSize _size;
    
}; // class VulkanBuffer

inline std::optional<VkBufferUsageFlagBits> GetVkBufferUsage(BufferUsage bufferUsage)
{
    switch (bufferUsage) {
    case BufferUsage::Index:
        return VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    case BufferUsage::Vertex:
        return VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    case BufferUsage::Constant:
        return VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    }

    return {};
}

inline std::optional<VmaMemoryUsage> GetVkMemoryUsage(MemoryUsage memoryUsage)
{
    switch (memoryUsage) {
    case MemoryUsage::GPU:
        return VMA_MEMORY_USAGE_GPU_ONLY;
    case MemoryUsage::UploadOnce:
        return VMA_MEMORY_USAGE_CPU_ONLY;
    case MemoryUsage::UploadOften:
        return VMA_MEMORY_USAGE_CPU_TO_GPU;
    case MemoryUsage::Download:
        return VMA_MEMORY_USAGE_GPU_TO_CPU;
    }

    return {};
}

}; // namespace Toon::Vulkan

#endif // TOON_VULKAN_BUFFER_HPP
```

`Modules/Vulkan/Public/Toon/Vulkan/VulkanConfig.hpp`:

```hpp
#ifndef TOON_VULKAN_CONFIG_HPP
#define TOON_VULKAN_CONFIG_HPP

#include <Toon/Config.hpp>

#if defined(TOON_VULKAN_EXPORT)
    #define TOON_VULKAN_API TOON_API_EXPORT
#else
    #define TOON_VULKAN_API TOON_API_IMPORT
#endif

#define GLM_FORCE_DEPTH_ZERO_TO_ONE

#include <glad/vulkan.h>

#include <Toon/SDL2/SDL2Config.hpp>
#include <SDL_vulkan.h>

DISABLE_WARNINGS()

    #include <vk_mem_alloc.h>

ENABLE_WARNINGS()

#endif // TOON_VULKAN_CONFIG_HPP
```

`Modules/Vulkan/Public/Toon/Vulkan/VulkanGraphicsDriver.hpp`:

```hpp
#ifndef TOON_VULKAN_GRAPHICS_DRIVER_HPP
#define TOON_VULKAN_GRAPHICS_DRIVER_HPP

#include <Toon/Vulkan/VulkanConfig.hpp>

#include <Toon/SDL2/SDL2GraphicsDriver.hpp>
#include <Toon/Vulkan/VulkanPipeline.hpp>
#include <Toon/Vulkan/VulkanTexture.hpp>
#include <Toon/Vulkan/VulkanShader.hpp>
#include <Toon/Vulkan/VulkanMesh.hpp>
#include <Toon/Vulkan/VulkanPrimitive.hpp>
#include <Toon/Vulkan/VulkanBuffer.hpp>
#include <Toon/Vulkan/VulkanRenderContext.hpp>

#include <vector>
#include <unordered_map>

namespace Toon::Vulkan {

#define TOON_VULKAN_GRAPHICS_DRIVER(x) (dynamic_cast<Toon::Vulkan::VulkanGraphicsDriver *>(x))

class TOON_VULKAN_API VulkanGraphicsDriver : public SDL2::SDL2GraphicsDriver
{
public:
    
    DISALLOW_COPY_AND_ASSIGN(VulkanGraphicsDriver)

    VulkanGraphicsDriver() = default;

    virtual ~VulkanGraphicsDriver() = default;

    bool Initialize() override;

    void Terminate() override;

    void InitializeRenderContext() override;

    void SetBackbufferCount(unsigned backbufferCount) override;

    void Render() override;

    std::shared_ptr<Buffer> CreateBuffer() override;

    std::shared_ptr<Pipeline> CreatePipeline(std::shared_ptr<Shader> shader) override;

    std::shared_ptr<Texture> CreateTexture() override;

    std::shared_ptr<Shader> CreateShader() override;

    std::shared_ptr<Mesh> CreateMesh() override;

    std::shared_ptr<Material> CreateMaterial() override;

    std::shared_ptr<Primitive> CreatePrimitive() override;

    inline VkDevice GetDevice() const {
        return _vkDevice;
    }

    inline VmaAllocator GetAllocator() const {
        return _vmaAllocator;
    }

    inline VkDescriptorPool GetDescriptorPool() const {
        return _vkDescriptorPool;
    }

    inline VkExtent2D GetSwapChainExtent() const {
        return _vkSwapChainExtent;
    }

    inline VkPipelineLayout GetPipelineLayout() {
        return _vkPipelineLayout;
    }

    inline VkRenderPass GetRenderPass() const {
        return _vkRenderPass;
    }

    bool CopyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size);

    bool CreateDescriptorSet(VkDescriptorSet * descriptorSet);

private:

    bool IsDeviceSuitable(const VkPhysicalDevice device);

    std::vector<const char *> GetRequiredLayers();

    std::vector<const char *> GetRequiredDeviceExtensions();

    std::vector<const char *> GetRequiredInstanceExtensions();

    bool InitDebugUtilsMessenger();

    void TermDebugUtilsMessenger();

    bool InitInstance();

    void TermInstance();
    
    bool InitSurface();

    void TermSurface();
    
    bool InitPhysicalDevice();

    bool InitLogicalDevice();

    void TermLogicalDevice();

    bool InitAllocator();

    void TermAllocator();
    
    bool InitSwapChain();

    void TermSwapChain(bool resetting = false);

    bool ResetSwapChain();

    bool InitRenderPass();

    void TermRenderPass();

    bool InitDescriptorPool();

    void TermDescriptorPool();

    bool ResetGraphicsPipelines();

    bool InitDepthBuffer();

    void TermDepthBuffer();

    bool InitFramebuffers();

    void TermFramebuffers();

    bool InitCommandPool();

    void TermCommandPool();

    bool InitCommandBuffers();

    void TermCommandBuffers();

    bool InitSyncObjects();

    void TermSyncObjects();

    bool FillCommandBuffers();

    std::unordered_map<string, VkLayerProperties> _vkAvailableLayers;

    std::unordered_map<string, VkExtensionProperties> _vkAvailableInstanceExtensions;

    std::unordered_map<string, VkExtensionProperties> _vkAvailableDeviceExtensions;

    VkInstance _vkInstance = nullptr;

    VkDebugUtilsMessengerEXT _vkDebugMessenger = nullptr;

    VkSurfaceKHR _vkSurface = nullptr;

    VkPhysicalDeviceProperties _vkPhysicalDeviceProperties;
    
    VkPhysicalDeviceFeatures _vkPhysicalDeviceFeatures;

    VkPhysicalDevice _vkPhysicalDevice = nullptr;

    VkDevice _vkDevice = nullptr;

    uint32_t _vkGraphicsQueueFamilyIndex;

    uint32_t _vkPresentQueueFamilyIndex;

    VkQueue _vkGraphicsQueue = nullptr;
    
    VkQueue _vkPresentQueue = nullptr;

    VmaAllocator _vmaAllocator = nullptr;

    VkSurfaceFormatKHR _vkSwapChainImageFormat;

    VkExtent2D _vkSwapChainExtent;

    VkSwapchainKHR _vkSwapChain = nullptr;

    std::vector<VkImage> _vkSwapChainImages;

    std::vector<VkImageView> _vkSwapChainImageViews;

    VkRenderPass _vkRenderPass = nullptr;

    VkFormat _vkDepthImageFormat;

    VkImage _vkDepthImage = nullptr;

    VmaAllocation _vmaDepthImageAllocation = nullptr;

    VkImageView _vkDepthImageView = nullptr;

    std::vector<VkFramebuffer> _vkFramebuffers;

    VkCommandPool _vkCommandPool = nullptr;

    std::vector<VkCommandBuffer> _vkCommandBuffers;

    std::vector<VkSemaphore> _vkImageAvailableSemaphores;
    
    std::vector<VkSemaphore> _vkRenderingFinishedSemaphores;

    std::vector<VkFence> _vkInFlightFences;

    std::vector<VkFence> _vkImagesInFlight;

    std::vector<VkBuffer> _vkUniformBuffers;

    std::vector<VmaAllocation> _vkUniformBufferAllocations;

    VkDescriptorPool _vkDescriptorPool = nullptr;

    VkDescriptorSetLayout _vkDescriptorSetLayout = nullptr;

    VkPipelineLayout _vkPipelineLayout = nullptr;

    int _currentFrame = 0;



    std::vector<std::shared_ptr<Shader>> _shaderList;

    std::vector<std::shared_ptr<Mesh>> _meshList;

    std::vector<std::shared_ptr<Primitive>> _primitiveList;

    std::vector<std::shared_ptr<Pipeline>> _pipelineList;



    // bool InitGraphicsPipeline();

    // void TermGraphicsPipeline();

    

}; // class VulkanGraphicsDriver

} // namespace Toon::Vulkan

#endif // TOON_VULKAN_GRAPHICS_DRIVER_HPP
```

`Modules/Vulkan/Public/Toon/Vulkan/VulkanMesh.hpp`:

```hpp
#ifndef TOON_VULKAN_MESH_HPP
#define TOON_VULKAN_MESH_HPP

#include <Toon/Vulkan/VulkanConfig.hpp>

#include <Toon/Mesh.hpp>

namespace Toon::Vulkan {

#define TOON_VULKAN_MESH(x) (dynamic_cast<Toon::Vulkan::VulkanMesh *>(x))

class TOON_VULKAN_API VulkanMesh : public Mesh
{
public:

    DISALLOW_COPY_AND_ASSIGN(VulkanMesh)

    VulkanMesh() = default;

    virtual ~VulkanMesh() = default;

    bool Initialize() override;

    void Terminate() override;

    bool Create();

    void Destroy();

    void Render(RenderContext * ctx) override;

private:

    VkDescriptorSet _vkDescriptorSet;

}; // class VulkanMesh

} // namespace Toon::Vulkan

#endif // TOON_VULKAN_MESH_HPP
```

`Modules/Vulkan/Public/Toon/Vulkan/VulkanPipeline.hpp`:

```hpp
#ifndef TOON_VULKAN_PIPELINE_HPP
#define TOON_VULKAN_PIPELINE_HPP

#include <Toon/Vulkan/VulkanConfig.hpp>

#include <Toon/Log.hpp>
#include <Toon/Pipeline.hpp>

#include <optional>

namespace Toon::Vulkan {

#define TOON_VULKAN_PIPELINE(x) (dynamic_cast<Toon::Vulkan::VulkanPipeline *>(x))

class TOON_VULKAN_API VulkanPipeline : public Pipeline
{
public:

    DISALLOW_COPY_AND_ASSIGN(VulkanPipeline)

    VulkanPipeline() = default;

    virtual ~VulkanPipeline() = default;

    bool Initialize(std::shared_ptr<Shader> shader) override;

    void Terminate() override;

    bool Create();

    void Destroy();

    void GenerateCommands(VkCommandBuffer vkCommandBuffer);

private:

    VkPipeline _vkPipeline;

}; // class VulkanPipeline

inline std::optional<VkFrontFace> GetVkFrontFace(FrontFace frontFace)
{
    switch (frontFace) {
    case FrontFace::Clockwise:
        return VK_FRONT_FACE_CLOCKWISE;
    case FrontFace::CounterClockwise:
        return VK_FRONT_FACE_COUNTER_CLOCKWISE;
    }
    
    return {};
}

inline std::optional<VkCullModeFlags> GetVkCullMode(CullMode cullMode)
{
    switch (cullMode) {
    case CullMode::None:
        return 0;
    case CullMode::Front:
        return VK_CULL_MODE_FRONT_BIT;
    case CullMode::Back:
        return VK_CULL_MODE_BACK_BIT;
    }
    
    return {};
}

inline std::optional<VkPolygonMode> GetVkPolygonMode(FillMode fillMode)
{
    switch (fillMode) {
    case FillMode::Line:
        return VK_POLYGON_MODE_LINE;
    case FillMode::Fill:
        return VK_POLYGON_MODE_FILL;
    }

    return {};
}

inline std::optional<VkBlendFactor> GetVkBlendFactor(BlendFactor factor)
{
    switch (factor) {
    case BlendFactor::Zero:
        return VK_BLEND_FACTOR_ZERO;
    case BlendFactor::One:
        return VK_BLEND_FACTOR_ONE;
    case BlendFactor::SrcColor:
        return VK_BLEND_FACTOR_SRC_COLOR;
    case BlendFactor::OneMinusSrcColor:
        return VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR;
    case BlendFactor::SrcAlpha:
        return VK_BLEND_FACTOR_SRC_ALPHA;
    case BlendFactor::OneMinusSrcAlpha:
        return VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    case BlendFactor::DstColor:
        return VK_BLEND_FACTOR_DST_COLOR;
    case BlendFactor::OneMinusDstColor:
        return VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR;
    case BlendFactor::DstAlpha:
        return VK_BLEND_FACTOR_DST_ALPHA;
    case BlendFactor::OneMinusDstAlpha:
        return VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;
    case BlendFactor::ConstantColor:
        return VK_BLEND_FACTOR_CONSTANT_COLOR;
    case BlendFactor::OneMinusConstantColor:
        return VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR;
    case BlendFactor::ConstantAlpha:
        return VK_BLEND_FACTOR_CONSTANT_ALPHA;
    case BlendFactor::OneMinusConstantAlpha:
        return VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA;
    case BlendFactor::SrcAlphaSaturated:
        return VK_BLEND_FACTOR_SRC_ALPHA_SATURATE;
    }
    
    return {};
}

inline std::optional<VkBlendOp> GetVkBlendOp(BlendOperation op)
{
    switch (op) {
    case BlendOperation::Add:
        return VK_BLEND_OP_ADD;
    case BlendOperation::Subtract:
        return VK_BLEND_OP_SUBTRACT;
    case BlendOperation::ReverseSubtract:
        return VK_BLEND_OP_REVERSE_SUBTRACT;
    case BlendOperation::Min:
        return VK_BLEND_OP_MIN;
    case BlendOperation::Max:
        return VK_BLEND_OP_MAX;
    }
    
    return {};
}

inline std::optional<VkCompareOp> GetVkCompareOp(CompareOperation op)
{
    switch (op) {
    case CompareOperation::Never:
        return VK_COMPARE_OP_NEVER;
    case CompareOperation::Less:
        return VK_COMPARE_OP_LESS;
    case CompareOperation::Equal:
        return VK_COMPARE_OP_EQUAL;
    case CompareOperation::LessOrEqual:
        return VK_COMPARE_OP_LESS_OR_EQUAL;
    case CompareOperation::Greater:
        return VK_COMPARE_OP_GREATER;
    case CompareOperation::NotEqual:
        return VK_COMPARE_OP_NOT_EQUAL;
    case CompareOperation::GreaterOrEqual:
        return VK_COMPARE_OP_GREATER_OR_EQUAL;
    case CompareOperation::Always:
        return VK_COMPARE_OP_ALWAYS;
    }

    return {};
}

} // namespace Toon::Vulkan

#endif // TOON_VULKAN_PIPELINE_HPP
```

`Modules/Vulkan/Public/Toon/Vulkan/VulkanPrimitive.hpp`:

```hpp
#ifndef TOON_VULKAN_PRIMITIVE_HPP
#define TOON_VULKAN_PRIMITIVE_HPP

#include <Toon/Vulkan/VulkanConfig.hpp>

#include <Toon/Log.hpp>
#include <Toon/Primitive.hpp>
#include <Toon/PrimitiveData.hpp>
#include <Toon/Vulkan/VulkanBuffer.hpp>

#include <vector>
#include <optional>

namespace Toon::Vulkan {

#define TOON_VULKAN_PRIMITIVE(x) (dynamic_cast<Toon::Vulkan::VulkanPrimitive *>(x))

class TOON_VULKAN_API VulkanPrimitive : public Primitive
{
public:

    DISALLOW_COPY_AND_ASSIGN(VulkanPrimitive)

    VulkanPrimitive() = default;

    virtual ~VulkanPrimitive() = default;

    void Terminate() override;

    bool Load(const std::unique_ptr<PrimitiveData>& data) override;

    VkPrimitiveTopology GetVkPrimitiveTopology() {
        return _vkPrimitiveTopology;
    }
    
    void GenerateCommands(VkCommandBuffer vkCommandBuffer);

private:

    std::unique_ptr<Buffer> _indexBuffer;

    std::unique_ptr<Buffer> _vertexBuffer;

    VkPrimitiveTopology _vkPrimitiveTopology;

    bool _indexed = false;

    uint32_t _count = 0;

}; // class VulkanPrimitive

inline std::optional<VkPrimitiveTopology> GetVkPrimitiveTopology(PrimitiveTopology primitiveTopology)
{
    switch (primitiveTopology) {
    case PrimitiveTopology::PointList:
        return VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
    case PrimitiveTopology::LineList:
        return VK_PRIMITIVE_TOPOLOGY_LINE_LIST;
    case PrimitiveTopology::LineStrip:
        return VK_PRIMITIVE_TOPOLOGY_LINE_STRIP;
    case PrimitiveTopology::TriangleList:
        return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    case PrimitiveTopology::TriangleStrip:
        return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    }

    return {};
}

} // namespace Toon::Vulkan

#endif // TOON_VULKAN_PRIMITIVE_HPP
```

`Modules/Vulkan/Public/Toon/Vulkan/VulkanRenderContext.hpp`:

```hpp
#ifndef VULKAN_RENDER_CONTEXT_HPP
#define VULKAN_RENDER_CONTEXT_HPP

#include <Toon/Vulkan/VulkanConfig.hpp>
#include <Toon/RenderContext.hpp>

namespace Toon::Vulkan {

#define TOON_VULKAN_RENDER_CONTEXT(x) (dynamic_cast<Toon::Vulkan::VulkanRenderContext *>(x))

class TOON_VULKAN_API VulkanRenderContext : public RenderContext
{
public:

    DISALLOW_COPY_AND_ASSIGN(VulkanRenderContext)

    VulkanRenderContext() = default;

    virtual ~VulkanRenderContext() = default;

    inline void SetVkCommandBuffer(VkCommandBuffer vkCommandBuffer) {
        _vkCommandBuffer = vkCommandBuffer;
    }

    inline VkCommandBuffer GetVkCommandBuffer() {
        return _vkCommandBuffer;
    }

private:

    VkCommandBuffer _vkCommandBuffer;
}; // class VulkanRenderContext

} // namespace Toon::Vulkan

#endif // VULKAN_RENDER_CONTEXT_HPP
```

`Modules/Vulkan/Public/Toon/Vulkan/VulkanShader.hpp`:

```hpp
#ifndef TOON_VULKAN_SHADER_HPP
#define TOON_VULKAN_SHADER_HPP

#include <Toon/Vulkan/VulkanConfig.hpp>

#include <Toon/Shader.hpp>
#include <vector>

namespace Toon::Vulkan {

#define TOON_VULKAN_SHADER(x) (dynamic_cast<Toon::Vulkan::VulkanShader *>(x))

class TOON_VULKAN_API VulkanShader : public Toon::Shader
{
public:

    DISALLOW_COPY_AND_ASSIGN(VulkanShader)

    VulkanShader() = default;

    virtual ~VulkanShader() = default;

    void Terminate() override;

    bool LoadFromFiles(const std::vector<std::string>& filenames, bool useAssetPath = true) override;

    inline std::vector<VkPipelineShaderStageCreateInfo>& GetStageList() {
        return _shaderStageList;
    }

private:

    bool LoadSPV(const std::string& filename, bool useAssetPath);

    VkShaderStageFlagBits GetVkShaderType(const std::string& filename);

    std::vector<VkShaderModule> _shaderModuleList;

    std::vector<VkPipelineShaderStageCreateInfo> _shaderStageList;
    
}; // class VulkanShader

} // namespace Toon::Vulkan

#endif // TOON_VULKAN_SHADER_HPP
```

`Modules/Vulkan/Public/Toon/Vulkan/VulkanTexture.hpp`:

```hpp
#ifndef TOON_VULKAN_TEXTURE_HPP
#define TOON_VULKAN_TEXTURE_HPP

#include <Toon/Vulkan/VulkanConfig.hpp>

#include <Toon/Texture.hpp>

namespace Toon::Vulkan {

#define TOON_VULKAN_TEXTURE(x) (dynamic_cast<Toon::Vulkan::VulkanTexture *>(x))

class TOON_VULKAN_API VulkanTexture : public Texture
{
public:

    DISALLOW_COPY_AND_ASSIGN(VulkanTexture)

    VulkanTexture() = default;

    virtual ~VulkanTexture();

    bool Load(const std::unique_ptr<TextureData>& data, Options opts = Options()) override;

    VkImage GetVKImage() const;

private:

    VkImage _vkImage;
}; // class VulkanTexture

inline VkFormat GetVkDataFormat(int components, const TextureDataType& dataType)
{
    if (components == 1) {
        switch(dataType) {
            case TextureDataType::UnsignedByte:
                return VK_FORMAT_R8_UINT;
            case TextureDataType::Byte:
                return VK_FORMAT_R8_SINT;
            case TextureDataType::UnsignedShort:
                return VK_FORMAT_R16_UINT;
            case TextureDataType::Short:
                return VK_FORMAT_R16_SINT;
            case TextureDataType::UnsignedInt:
                return VK_FORMAT_R32_UINT;
            case TextureDataType::Int:
                return VK_FORMAT_R32_SINT;
        }
    }
    else if (components == 2) {
        switch(dataType) {
            case TextureDataType::UnsignedByte:
                return VK_FORMAT_R8G8_UINT;
            case TextureDataType::Byte:
                return VK_FORMAT_R8G8_SINT;
            case TextureDataType::UnsignedShort:
                return VK_FORMAT_R16G16_UINT;
            case TextureDataType::Short:
                return VK_FORMAT_R16G16_SINT;
            case TextureDataType::UnsignedInt:
                return VK_FORMAT_R32G32_UINT;
            case TextureDataType::Int:
                return VK_FORMAT_R32G32_SINT;
        }
    }
    else if (components == 3) {
        switch(dataType) {
            case TextureDataType::UnsignedByte:
                return VK_FORMAT_R8G8B8_UINT;
            case TextureDataType::Byte:
                return VK_FORMAT_R8G8B8_SINT;
            case TextureDataType::UnsignedShort:
                return VK_FORMAT_R16G16B16_UINT;
            case TextureDataType::Short:
                return VK_FORMAT_R16G16B16_SINT;
            case TextureDataType::UnsignedInt:
                return VK_FORMAT_R32G32B32_UINT;
            case TextureDataType::Int:
                return VK_FORMAT_R32G32B32_SINT;
        }
    }
    else if (components == 4) {
        switch(dataType) {
            case TextureDataType::UnsignedByte:
                return VK_FORMAT_R8G8B8A8_UINT;
            case TextureDataType::Byte:
                return VK_FORMAT_R8G8B8A8_SINT;
            case TextureDataType::UnsignedShort:
                return VK_FORMAT_R16G16B16A16_UINT;
            case TextureDataType::Short:
                return VK_FORMAT_R16G16B16A16_SINT;
            case TextureDataType::UnsignedInt:
                return VK_FORMAT_R32G32B32A32_UINT;
            case TextureDataType::Int:
                return VK_FORMAT_R32G32B32A32_SINT;
        }
    }

    return VK_FORMAT_UNDEFINED;
}

} // namespace Toon::Vulkan

#endif // TOON_VULKAN_TEXTURE_HPP

```

`Modules/Vulkan/Public/glad/vulkan.h`:

```h
/**
 * Loader generated by glad 2.0.0-beta on Tue Dec  8 04:42:16 2020
 *
 * Generator: C/C++
 * Specification: vk
 * Extensions: 140
 *
 * APIs:
 *  - vulkan=1.2
 *
 * Options:
 *  - MX_GLOBAL = False
 *  - ON_DEMAND = False
 *  - LOADER = True
 *  - ALIAS = False
 *  - HEADER_ONLY = False
 *  - DEBUG = False
 *  - MX = False
 *
 * Commandline:
 *    --api='vulkan=1.2' --extensions='VK_ANDROID_external_memory_android_hardware_buffer,VK_EXT_4444_formats,VK_EXT_acquire_xlib_display,VK_EXT_astc_decode_mode,VK_EXT_blend_operation_advanced,VK_EXT_buffer_device_address,VK_EXT_calibrated_timestamps,VK_EXT_conditional_rendering,VK_EXT_conservative_rasterization,VK_EXT_custom_border_color,VK_EXT_debug_marker,VK_EXT_debug_report,VK_EXT_debug_utils,VK_EXT_depth_clip_enable,VK_EXT_depth_range_unrestricted,VK_EXT_descriptor_indexing,VK_EXT_direct_mode_display,VK_EXT_directfb_surface,VK_EXT_discard_rectangles,VK_EXT_display_control,VK_EXT_display_surface_counter,VK_EXT_extended_dynamic_state,VK_EXT_external_memory_dma_buf,VK_EXT_external_memory_host,VK_EXT_filter_cubic,VK_EXT_fragment_density_map,VK_EXT_fragment_density_map2,VK_EXT_fragment_shader_interlock,VK_EXT_full_screen_exclusive,VK_EXT_global_priority,VK_EXT_hdr_metadata,VK_EXT_headless_surface,VK_EXT_host_query_reset,VK_EXT_image_drm_format_modifier,VK_EXT_image_robustness,VK_EXT_index_type_uint8,VK_EXT_inline_uniform_block,VK_EXT_line_rasterization,VK_EXT_memory_budget,VK_EXT_memory_priority,VK_EXT_metal_surface,VK_EXT_pci_bus_info,VK_EXT_pipeline_creation_cache_control,VK_EXT_pipeline_creation_feedback,VK_EXT_post_depth_coverage,VK_EXT_private_data,VK_EXT_queue_family_foreign,VK_EXT_robustness2,VK_EXT_sample_locations,VK_EXT_sampler_filter_minmax,VK_EXT_scalar_block_layout,VK_EXT_separate_stencil_usage,VK_EXT_shader_atomic_float,VK_EXT_shader_demote_to_helper_invocation,VK_EXT_shader_stencil_export,VK_EXT_shader_subgroup_ballot,VK_EXT_shader_subgroup_vote,VK_EXT_shader_viewport_index_layer,VK_EXT_subgroup_size_control,VK_EXT_swapchain_colorspace,VK_EXT_texel_buffer_alignment,VK_EXT_texture_compression_astc_hdr,VK_EXT_tooling_info,VK_EXT_transform_feedback,VK_EXT_validation_cache,VK_EXT_validation_features,VK_EXT_validation_flags,VK_EXT_vertex_attribute_divisor,VK_EXT_ycbcr_image_arrays,VK_KHR_16bit_storage,VK_KHR_8bit_storage,VK_KHR_android_surface,VK_KHR_bind_memory2,VK_KHR_buffer_device_address,VK_KHR_create_renderpass2,VK_KHR_dedicated_allocation,VK_KHR_deferred_host_operations,VK_KHR_depth_stencil_resolve,VK_KHR_descriptor_update_template,VK_KHR_device_group,VK_KHR_device_group_creation,VK_KHR_display,VK_KHR_display_swapchain,VK_KHR_draw_indirect_count,VK_KHR_driver_properties,VK_KHR_external_fence,VK_KHR_external_fence_capabilities,VK_KHR_external_fence_fd,VK_KHR_external_fence_win32,VK_KHR_external_memory,VK_KHR_external_memory_capabilities,VK_KHR_external_memory_fd,VK_KHR_external_memory_win32,VK_KHR_external_semaphore,VK_KHR_external_semaphore_capabilities,VK_KHR_external_semaphore_fd,VK_KHR_external_semaphore_win32,VK_KHR_get_display_properties2,VK_KHR_get_memory_requirements2,VK_KHR_get_physical_device_properties2,VK_KHR_get_surface_capabilities2,VK_KHR_image_format_list,VK_KHR_imageless_framebuffer,VK_KHR_incremental_present,VK_KHR_maintenance1,VK_KHR_maintenance2,VK_KHR_maintenance3,VK_KHR_multiview,VK_KHR_performance_query,VK_KHR_pipeline_executable_properties,VK_KHR_pipeline_library,VK_KHR_push_descriptor,VK_KHR_ray_tracing,VK_KHR_relaxed_block_layout,VK_KHR_sampler_mirror_clamp_to_edge,VK_KHR_sampler_ycbcr_conversion,VK_KHR_separate_depth_stencil_layouts,VK_KHR_shader_atomic_int64,VK_KHR_shader_clock,VK_KHR_shader_draw_parameters,VK_KHR_shader_float16_int8,VK_KHR_shader_float_controls,VK_KHR_shader_non_semantic_info,VK_KHR_shader_subgroup_extended_types,VK_KHR_shared_presentable_image,VK_KHR_spirv_1_4,VK_KHR_storage_buffer_storage_class,VK_KHR_surface,VK_KHR_surface_protected_capabilities,VK_KHR_swapchain,VK_KHR_swapchain_mutable_format,VK_KHR_timeline_semaphore,VK_KHR_uniform_buffer_standard_layout,VK_KHR_variable_pointers,VK_KHR_vulkan_memory_model,VK_KHR_wayland_surface,VK_KHR_win32_keyed_mutex,VK_KHR_win32_surface,VK_KHR_xcb_surface,VK_KHR_xlib_surface' c --loader
 *
 * Online:
 *    http://glad.sh/#api=vulkan%3D1.2&generator=c&options=LOADER
 *
 */

#ifndef GLAD_VULKAN_H_
#define GLAD_VULKAN_H_

#ifdef VULKAN_H_
  #error  header already included (API: vulkan), remove previous include!
#endif
#define VULKAN_H_ 1

#ifdef VULKAN_CORE_H_
  #error  header already included (API: vulkan), remove previous include!
#endif
#define VULKAN_CORE_H_ 1


#define GLAD_VULKAN
#define GLAD_OPTION_VULKAN_LOADER

#ifdef __cplusplus
extern "C" {
#endif

#ifndef GLAD_PLATFORM_H_
#define GLAD_PLATFORM_H_

#ifndef GLAD_PLATFORM_WIN32
  #if defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__MINGW32__)
    #define GLAD_PLATFORM_WIN32 1
  #else
    #define GLAD_PLATFORM_WIN32 0
  #endif
#endif

#ifndef GLAD_PLATFORM_APPLE
  #ifdef __APPLE__
    #define GLAD_PLATFORM_APPLE 1
  #else
    #define GLAD_PLATFORM_APPLE 0
  #endif
#endif

#ifndef GLAD_PLATFORM_EMSCRIPTEN
  #ifdef __EMSCRIPTEN__
    #define GLAD_PLATFORM_EMSCRIPTEN 1
  #else
    #define GLAD_PLATFORM_EMSCRIPTEN 0
  #endif
#endif

#ifndef GLAD_PLATFORM_UWP
  #if defined(_MSC_VER) && !defined(GLAD_INTERNAL_HAVE_WINAPIFAMILY)
    #ifdef __has_include
      #if __has_include(<winapifamily.h>)
        #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
      #endif
    #elif _MSC_VER >= 1700 && !_USING_V110_SDK71_
      #define GLAD_INTERNAL_HAVE_WINAPIFAMILY 1
    #endif
  #endif

  #ifdef GLAD_INTERNAL_HAVE_WINAPIFAMILY
    #include <winapifamily.h>
    #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
      #define GLAD_PLATFORM_UWP 1
    #endif
  #endif

  #ifndef GLAD_PLATFORM_UWP
    #define GLAD_PLATFORM_UWP 0
  #endif
#endif

#ifdef __GNUC__
  #define GLAD_GNUC_EXTENSION __extension__
#else
  #define GLAD_GNUC_EXTENSION
#endif

#ifndef GLAD_API_CALL
  #if defined(GLAD_API_CALL_EXPORT)
    #if GLAD_PLATFORM_WIN32 || defined(__CYGWIN__)
      #if defined(GLAD_API_CALL_EXPORT_BUILD)
        #if defined(__GNUC__)
          #define GLAD_API_CALL __attribute__ ((dllexport)) extern
        #else
          #define GLAD_API_CALL __declspec(dllexport) extern
        #endif
      #else
        #if defined(__GNUC__)
          #define GLAD_API_CALL __attribute__ ((dllimport)) extern
        #else
          #define GLAD_API_CALL __declspec(dllimport) extern
        #endif
      #endif
    #elif defined(__GNUC__) && defined(GLAD_API_CALL_EXPORT_BUILD)
      #define GLAD_API_CALL __attribute__ ((visibility ("default"))) extern
    #else
      #define GLAD_API_CALL extern
    #endif
  #else
    #define GLAD_API_CALL extern
  #endif
#endif

#ifdef APIENTRY
  #define GLAD_API_PTR APIENTRY
#elif GLAD_PLATFORM_WIN32
  #define GLAD_API_PTR __stdcall
#else
  #define GLAD_API_PTR
#endif

#ifndef GLAPI
#define GLAPI GLAD_API_CALL
#endif

#ifndef GLAPIENTRY
#define GLAPIENTRY GLAD_API_PTR
#endif

#define GLAD_MAKE_VERSION(major, minor) (major * 10000 + minor)
#define GLAD_VERSION_MAJOR(version) (version / 10000)
#define GLAD_VERSION_MINOR(version) (version % 10000)

#define GLAD_GENERATOR_VERSION "2.0.0-beta"

typedef void (*GLADapiproc)(void);

typedef GLADapiproc (*GLADloadfunc)(const char *name);
typedef GLADapiproc (*GLADuserptrloadfunc)(void *userptr, const char *name);

typedef void (*GLADprecallback)(const char *name, GLADapiproc apiproc, int len_args, ...);
typedef void (*GLADpostcallback)(void *ret, const char *name, GLADapiproc apiproc, int len_args, ...);

#endif /* GLAD_PLATFORM_H_ */

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#define VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME "VK_ANDROID_external_memory_android_hardware_buffer"
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#define VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION 3
#endif
#define VK_ATTACHMENT_UNUSED (~0U)
#define VK_EXT_4444_FORMATS_EXTENSION_NAME "VK_EXT_4444_formats"
#define VK_EXT_4444_FORMATS_SPEC_VERSION 1
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
#define VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME "VK_EXT_acquire_xlib_display"
#endif
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
#define VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION 1
#endif
#define VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME "VK_EXT_astc_decode_mode"
#define VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION 1
#define VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME "VK_EXT_blend_operation_advanced"
#define VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION 2
#define VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME "VK_EXT_buffer_device_address"
#define VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION 2
#define VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME "VK_EXT_calibrated_timestamps"
#define VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION 1
#define VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME "VK_EXT_conditional_rendering"
#define VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION 2
#define VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME "VK_EXT_conservative_rasterization"
#define VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION 1
#define VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME "VK_EXT_custom_border_color"
#define VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION 12
#define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"
#define VK_EXT_DEBUG_MARKER_SPEC_VERSION 4
#define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
#define VK_EXT_DEBUG_REPORT_SPEC_VERSION 9
#define VK_EXT_DEBUG_UTILS_EXTENSION_NAME "VK_EXT_debug_utils"
#define VK_EXT_DEBUG_UTILS_SPEC_VERSION 2
#define VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME "VK_EXT_depth_clip_enable"
#define VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION 1
#define VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME "VK_EXT_depth_range_unrestricted"
#define VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION 1
#define VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME "VK_EXT_descriptor_indexing"
#define VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION 2
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#define VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME "VK_EXT_directfb_surface"
#endif
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#define VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION 1
#endif
#define VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME "VK_EXT_direct_mode_display"
#define VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION 1
#define VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME "VK_EXT_discard_rectangles"
#define VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION 1
#define VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME "VK_EXT_display_control"
#define VK_EXT_DISPLAY_CONTROL_SPEC_VERSION 1
#define VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME "VK_EXT_display_surface_counter"
#define VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION 1
#define VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME "VK_EXT_extended_dynamic_state"
#define VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION 1
#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME "VK_EXT_external_memory_dma_buf"
#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION 1
#define VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME "VK_EXT_external_memory_host"
#define VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION 1
#define VK_EXT_FILTER_CUBIC_EXTENSION_NAME "VK_EXT_filter_cubic"
#define VK_EXT_FILTER_CUBIC_SPEC_VERSION 3
#define VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME "VK_EXT_fragment_density_map2"
#define VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION 1
#define VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME "VK_EXT_fragment_density_map"
#define VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION 1
#define VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME "VK_EXT_fragment_shader_interlock"
#define VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION 1
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME "VK_EXT_full_screen_exclusive"
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION 4
#endif
#define VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME "VK_EXT_global_priority"
#define VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION 2
#define VK_EXT_HDR_METADATA_EXTENSION_NAME "VK_EXT_hdr_metadata"
#define VK_EXT_HDR_METADATA_SPEC_VERSION 2
#define VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME "VK_EXT_headless_surface"
#define VK_EXT_HEADLESS_SURFACE_SPEC_VERSION 1
#define VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME "VK_EXT_host_query_reset"
#define VK_EXT_HOST_QUERY_RESET_SPEC_VERSION 1
#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME "VK_EXT_image_drm_format_modifier"
#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION 1
#define VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME "VK_EXT_image_robustness"
#define VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION 1
#define VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME "VK_EXT_index_type_uint8"
#define VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION 1
#define VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME "VK_EXT_inline_uniform_block"
#define VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION 1
#define VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME "VK_EXT_line_rasterization"
#define VK_EXT_LINE_RASTERIZATION_SPEC_VERSION 1
#define VK_EXT_MEMORY_BUDGET_EXTENSION_NAME "VK_EXT_memory_budget"
#define VK_EXT_MEMORY_BUDGET_SPEC_VERSION 1
#define VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME "VK_EXT_memory_priority"
#define VK_EXT_MEMORY_PRIORITY_SPEC_VERSION 1
#if defined(VK_USE_PLATFORM_METAL_EXT)
#define VK_EXT_METAL_SURFACE_EXTENSION_NAME "VK_EXT_metal_surface"
#endif
#if defined(VK_USE_PLATFORM_METAL_EXT)
#define VK_EXT_METAL_SURFACE_SPEC_VERSION 1
#endif
#define VK_EXT_PCI_BUS_INFO_EXTENSION_NAME "VK_EXT_pci_bus_info"
#define VK_EXT_PCI_BUS_INFO_SPEC_VERSION 2
#define VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME "VK_EXT_pipeline_creation_cache_control"
#define VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION 3
#define VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME "VK_EXT_pipeline_creation_feedback"
#define VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION 1
#define VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME "VK_EXT_post_depth_coverage"
#define VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION 1
#define VK_EXT_PRIVATE_DATA_EXTENSION_NAME "VK_EXT_private_data"
#define VK_EXT_PRIVATE_DATA_SPEC_VERSION 1
#define VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME "VK_EXT_queue_family_foreign"
#define VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION 1
#define VK_EXT_ROBUSTNESS_2_EXTENSION_NAME "VK_EXT_robustness2"
#define VK_EXT_ROBUSTNESS_2_SPEC_VERSION 1
#define VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME "VK_EXT_sampler_filter_minmax"
#define VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION 2
#define VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME "VK_EXT_sample_locations"
#define VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION 1
#define VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME "VK_EXT_scalar_block_layout"
#define VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION 1
#define VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME "VK_EXT_separate_stencil_usage"
#define VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION 1
#define VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME "VK_EXT_shader_atomic_float"
#define VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION 1
#define VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME "VK_EXT_shader_demote_to_helper_invocation"
#define VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION 1
#define VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME "VK_EXT_shader_stencil_export"
#define VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION 1
#define VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME "VK_EXT_shader_subgroup_ballot"
#define VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION 1
#define VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME "VK_EXT_shader_subgroup_vote"
#define VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION 1
#define VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME "VK_EXT_shader_viewport_index_layer"
#define VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION 1
#define VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME "VK_EXT_subgroup_size_control"
#define VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION 2
#define VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME "VK_EXT_swapchain_colorspace"
#define VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION 4
#define VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME "VK_EXT_texel_buffer_alignment"
#define VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION 1
#define VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME "VK_EXT_texture_compression_astc_hdr"
#define VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION 1
#define VK_EXT_TOOLING_INFO_EXTENSION_NAME "VK_EXT_tooling_info"
#define VK_EXT_TOOLING_INFO_SPEC_VERSION 1
#define VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME "VK_EXT_transform_feedback"
#define VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION 1
#define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"
#define VK_EXT_VALIDATION_CACHE_SPEC_VERSION 1
#define VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME "VK_EXT_validation_features"
#define VK_EXT_VALIDATION_FEATURES_SPEC_VERSION 4
#define VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME "VK_EXT_validation_flags"
#define VK_EXT_VALIDATION_FLAGS_SPEC_VERSION 2
#define VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME "VK_EXT_vertex_attribute_divisor"
#define VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION 3
#define VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME "VK_EXT_ycbcr_image_arrays"
#define VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION 1
#define VK_FALSE 0
#define VK_KHR_16BIT_STORAGE_EXTENSION_NAME "VK_KHR_16bit_storage"
#define VK_KHR_16BIT_STORAGE_SPEC_VERSION 1
#define VK_KHR_8BIT_STORAGE_EXTENSION_NAME "VK_KHR_8bit_storage"
#define VK_KHR_8BIT_STORAGE_SPEC_VERSION 1
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#define VK_KHR_ANDROID_SURFACE_EXTENSION_NAME "VK_KHR_android_surface"
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#define VK_KHR_ANDROID_SURFACE_SPEC_VERSION 6
#endif
#define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"
#define VK_KHR_BIND_MEMORY_2_SPEC_VERSION 1
#define VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME "VK_KHR_buffer_device_address"
#define VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION 1
#define VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME "VK_KHR_create_renderpass2"
#define VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION 1
#define VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_KHR_dedicated_allocation"
#define VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION 3
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME "VK_KHR_deferred_host_operations"
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION 3
#endif
#define VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME "VK_KHR_depth_stencil_resolve"
#define VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION 1
#define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME "VK_KHR_descriptor_update_template"
#define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION 1
#define VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME "VK_KHR_device_group_creation"
#define VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION 1
#define VK_KHR_DEVICE_GROUP_EXTENSION_NAME "VK_KHR_device_group"
#define VK_KHR_DEVICE_GROUP_SPEC_VERSION 4
#define VK_KHR_DISPLAY_EXTENSION_NAME "VK_KHR_display"
#define VK_KHR_DISPLAY_SPEC_VERSION 23
#define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"
#define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION 10
#define VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_KHR_draw_indirect_count"
#define VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION 1
#define VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME "VK_KHR_driver_properties"
#define VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"
#define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"
#define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"
#define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME "VK_KHR_external_fence_win32"
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION 1
#endif
#define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_memory_capabilities"
#define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"
#define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"
#define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION 1
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#endif
#define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"
#define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"
#define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"
#define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
#define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME "VK_KHR_external_semaphore_win32"
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION 1
#endif
#define VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_display_properties2"
#define VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION 1
#define VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME "VK_KHR_get_memory_requirements2"
#define VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION 1
#define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_physical_device_properties2"
#define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION 2
#define VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME "VK_KHR_get_surface_capabilities2"
#define VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION 1
#define VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME "VK_KHR_imageless_framebuffer"
#define VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION 1
#define VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME "VK_KHR_image_format_list"
#define VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION 1
#define VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME "VK_KHR_incremental_present"
#define VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION 1
#define VK_KHR_MAINTENANCE1_EXTENSION_NAME "VK_KHR_maintenance1"
#define VK_KHR_MAINTENANCE1_SPEC_VERSION 2
#define VK_KHR_MAINTENANCE2_EXTENSION_NAME "VK_KHR_maintenance2"
#define VK_KHR_MAINTENANCE2_SPEC_VERSION 1
#define VK_KHR_MAINTENANCE3_EXTENSION_NAME "VK_KHR_maintenance3"
#define VK_KHR_MAINTENANCE3_SPEC_VERSION 1
#define VK_KHR_MULTIVIEW_EXTENSION_NAME "VK_KHR_multiview"
#define VK_KHR_MULTIVIEW_SPEC_VERSION 1
#define VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME "VK_KHR_performance_query"
#define VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION 1
#define VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME "VK_KHR_pipeline_executable_properties"
#define VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION 1
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME "VK_KHR_pipeline_library"
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION 1
#endif
#define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"
#define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 2
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_KHR_RAY_TRACING_EXTENSION_NAME "VK_KHR_ray_tracing"
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_KHR_RAY_TRACING_SPEC_VERSION 8
#endif
#define VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME "VK_KHR_relaxed_block_layout"
#define VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION 3
#define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"
#define VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION 14
#define VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME "VK_KHR_separate_depth_stencil_layouts"
#define VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION 1
#define VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME "VK_KHR_shader_atomic_int64"
#define VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION 1
#define VK_KHR_SHADER_CLOCK_EXTENSION_NAME "VK_KHR_shader_clock"
#define VK_KHR_SHADER_CLOCK_SPEC_VERSION 1
#define VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME "VK_KHR_shader_draw_parameters"
#define VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION 1
#define VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME "VK_KHR_shader_float16_int8"
#define VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION 1
#define VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME "VK_KHR_shader_float_controls"
#define VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION 4
#define VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME "VK_KHR_shader_non_semantic_info"
#define VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION 1
#define VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME "VK_KHR_shader_subgroup_extended_types"
#define VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION 1
#define VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME "VK_KHR_shared_presentable_image"
#define VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION 1
#define VK_KHR_SPIRV_1_4_EXTENSION_NAME "VK_KHR_spirv_1_4"
#define VK_KHR_SPIRV_1_4_SPEC_VERSION 1
#define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME "VK_KHR_storage_buffer_storage_class"
#define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION 1
#define VK_KHR_SURFACE_EXTENSION_NAME "VK_KHR_surface"
#define VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME "VK_KHR_surface_protected_capabilities"
#define VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION 1
#define VK_KHR_SURFACE_SPEC_VERSION 25
#define VK_KHR_SWAPCHAIN_EXTENSION_NAME "VK_KHR_swapchain"
#define VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME "VK_KHR_swapchain_mutable_format"
#define VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION 1
#define VK_KHR_SWAPCHAIN_SPEC_VERSION 70
#define VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME "VK_KHR_timeline_semaphore"
#define VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION 2
#define VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME "VK_KHR_uniform_buffer_standard_layout"
#define VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION 1
#define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"
#define VK_KHR_VARIABLE_POINTERS_SPEC_VERSION 1
#define VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME "VK_KHR_vulkan_memory_model"
#define VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION 3
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
#define VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME "VK_KHR_wayland_surface"
#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
#define VK_KHR_WAYLAND_SURFACE_SPEC_VERSION 6
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_KHR_win32_keyed_mutex"
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION 1
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_WIN32_SURFACE_EXTENSION_NAME "VK_KHR_win32_surface"
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_WIN32_SURFACE_SPEC_VERSION 6
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
#define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
#define VK_KHR_XCB_SURFACE_SPEC_VERSION 6
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
#define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
#define VK_KHR_XLIB_SURFACE_SPEC_VERSION 6
#endif
#define VK_LOD_CLAMP_NONE 1000.0f
#define VK_LUID_SIZE 8
#define VK_LUID_SIZE_KHR 8
#define VK_MAX_DESCRIPTION_SIZE 256
#define VK_MAX_DEVICE_GROUP_SIZE 32
#define VK_MAX_DEVICE_GROUP_SIZE_KHR 32
#define VK_MAX_DRIVER_INFO_SIZE 256
#define VK_MAX_DRIVER_INFO_SIZE_KHR 256
#define VK_MAX_DRIVER_NAME_SIZE 256
#define VK_MAX_DRIVER_NAME_SIZE_KHR 256
#define VK_MAX_EXTENSION_NAME_SIZE 256
#define VK_MAX_MEMORY_HEAPS 16
#define VK_MAX_MEMORY_TYPES 32
#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE 256
#define VK_QUEUE_FAMILY_EXTERNAL (~0U-1)
#define VK_QUEUE_FAMILY_EXTERNAL_KHR (~0U-1)
#define VK_QUEUE_FAMILY_FOREIGN_EXT (~0U-2)
#define VK_QUEUE_FAMILY_IGNORED (~0U)
#define VK_REMAINING_ARRAY_LAYERS (~0U)
#define VK_REMAINING_MIP_LEVELS (~0U)
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_SHADER_UNUSED_KHR (~0U)
#endif
#define VK_SUBPASS_EXTERNAL (~0U)
#define VK_TRUE 1
#define VK_UUID_SIZE 16
#define VK_WHOLE_SIZE (~0ULL)


#include "vk_platform.h"

#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT) || defined(VK_USE_PLATFORM_XLIB_KHR)
#endif

#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
#endif

#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR)
#endif

#if defined(VK_USE_PLATFORM_XCB_KHR)
#endif

#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#endif

#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT) || defined(VK_USE_PLATFORM_XLIB_KHR)
#endif

#if defined(VK_USE_PLATFORM_XLIB_KHR)
#endif

#if defined(VK_USE_PLATFORM_XLIB_KHR)
#endif

#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
#endif

#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
#endif

#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR)
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR)
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR)
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR) || defined(VK_USE_PLATFORM_WIN32_KHR)
#endif

#if defined(VK_USE_PLATFORM_XCB_KHR)
#endif

#if defined(VK_USE_PLATFORM_XCB_KHR)
#endif

#if defined(VK_USE_PLATFORM_XCB_KHR)
#endif

#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#endif

#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#endif

#define VK_MAKE_VERSION(major, minor, patch) \
    ((((uint32_t)(major)) << 22) | (((uint32_t)(minor)) << 12) | ((uint32_t)(patch)))

#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22)

#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12) & 0x3ff)

#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xfff)

/* DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead. */
/*#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0) // Patch version should always be set to 0 */

/* Vulkan 1.0 version number */
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)/* Patch version should always be set to 0 */

/* Vulkan 1.1 version number */
#define VK_API_VERSION_1_1 VK_MAKE_VERSION(1, 1, 0)/* Patch version should always be set to 0 */

/* Vulkan 1.2 version number */
#define VK_API_VERSION_1_2 VK_MAKE_VERSION(1, 2, 0)/* Patch version should always be set to 0 */

/* Version of this file */
#define VK_HEADER_VERSION 152

/* Complete version of this file */
#define VK_HEADER_VERSION_COMPLETE VK_MAKE_VERSION(1, 2, VK_HEADER_VERSION)

#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;

#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif

#define VK_NULL_HANDLE 0

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct ANativeWindow;
#endif

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct AHardwareBuffer;
#endif

#if defined(VK_USE_PLATFORM_METAL_EXT)
#ifdef __OBJC__
@class CAMetalLayer;
#else
typedef void CAMetalLayer;
#endif
#endif













VK_DEFINE_HANDLE(VkInstance)

VK_DEFINE_HANDLE(VkPhysicalDevice)

VK_DEFINE_HANDLE(VkDevice)

VK_DEFINE_HANDLE(VkQueue)

VK_DEFINE_HANDLE(VkCommandBuffer)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorUpdateTemplate)

#define VkDescriptorUpdateTemplateKHR VkDescriptorUpdateTemplate

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSamplerYcbcrConversion)

#define VkSamplerYcbcrConversionKHR VkSamplerYcbcrConversion

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkValidationCacheEXT)

#if defined(VK_ENABLE_BETA_EXTENSIONS)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkAccelerationStructureKHR)
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeferredOperationKHR)
#endif

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPrivateDataSlotEXT)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugUtilsMessengerEXT)

typedef enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2
} VkAttachmentLoadOp;

typedef enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1
} VkAttachmentStoreOp;

typedef enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18
} VkBlendFactor;

typedef enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_ZERO_EXT = 1000148000,
    VK_BLEND_OP_SRC_EXT = 1000148001,
    VK_BLEND_OP_DST_EXT = 1000148002,
    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
    VK_BLEND_OP_DST_IN_EXT = 1000148006,
    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
    VK_BLEND_OP_XOR_EXT = 1000148011,
    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
    VK_BLEND_OP_SCREEN_EXT = 1000148013,
    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
    VK_BLEND_OP_DARKEN_EXT = 1000148015,
    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
    VK_BLEND_OP_INVERT_EXT = 1000148023,
    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
    VK_BLEND_OP_PLUS_EXT = 1000148035,
    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
    VK_BLEND_OP_MINUS_EXT = 1000148039,
    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
    VK_BLEND_OP_RED_EXT = 1000148043,
    VK_BLEND_OP_GREEN_EXT = 1000148044,
    VK_BLEND_OP_BLUE_EXT = 1000148045
} VkBlendOp;

typedef enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
    VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004
} VkBorderColor;

typedef enum VkFramebufferCreateFlagBits {
    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 1,
    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT
} VkFramebufferCreateFlagBits;


typedef enum VkSamplerCreateFlagBits {
    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 1,
    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 2
} VkSamplerCreateFlagBits;

typedef enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1
} VkPipelineCacheHeaderVersion;

typedef enum VkPipelineCacheCreateFlagBits {
    VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT = 1
} VkPipelineCacheCreateFlagBits;

typedef enum VkPipelineShaderStageCreateFlagBits {
    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 1,
    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 2
} VkPipelineShaderStageCreateFlagBits;

typedef enum VkDescriptorSetLayoutCreateFlagBits {
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 2,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 1,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT
} VkDescriptorSetLayoutCreateFlagBits;

typedef enum VkDeviceQueueCreateFlagBits {
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 1
} VkDeviceQueueCreateFlagBits;

typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 1,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_BUFFER_CREATE_PROTECTED_BIT = 8,
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 16,
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
} VkBufferCreateFlagBits;

typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 1,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 2,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 4,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 8,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 16,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 32,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 64,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 128,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 256,
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 131072,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 2048,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 4096,
    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 512,
    VK_BUFFER_USAGE_RAY_TRACING_BIT_KHR = 1024,
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
} VkBufferUsageFlagBits;

typedef enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 1,
    VK_COLOR_COMPONENT_G_BIT = 2,
    VK_COLOR_COMPONENT_B_BIT = 4,
    VK_COLOR_COMPONENT_A_BIT = 8
} VkColorComponentFlagBits;

typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6
} VkComponentSwizzle;

typedef enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 2,
    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 4
} VkCommandPoolCreateFlagBits;

typedef enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1
} VkCommandPoolResetFlagBits;

typedef enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1
} VkCommandBufferResetFlagBits;

typedef enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1
} VkCommandBufferLevel;

typedef enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 2,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 4
} VkCommandBufferUsageFlagBits;

typedef enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7
} VkCompareOp;

typedef enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 1,
    VK_CULL_MODE_BACK_BIT = 2,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003
} VkCullModeFlagBits;

typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 1000138000,
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000165000
} VkDescriptorType;

typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
    VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000,
    VK_DYNAMIC_STATE_CULL_MODE_EXT = 1000267000,
    VK_DYNAMIC_STATE_FRONT_FACE_EXT = 1000267001,
    VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT = 1000267002,
    VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT = 1000267003,
    VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT = 1000267004,
    VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT = 1000267005,
    VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT = 1000267006,
    VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT = 1000267007,
    VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT = 1000267008,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT = 1000267009,
    VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT = 1000267010,
    VK_DYNAMIC_STATE_STENCIL_OP_EXT = 1000267011
} VkDynamicState;

typedef enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 1
} VkFenceCreateFlagBits;

typedef enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2
} VkPolygonMode;

typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,
    VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM,
    VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM,
    VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000,
    VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001
} VkFormat;

typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 2,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 4,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 8,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 16,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 64,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 128,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 256,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 512,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 1024,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 2048,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 16384,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 32768,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 131072,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 262144,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 524288,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1048576,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 2097152,
    VK_FORMAT_FEATURE_DISJOINT_BIT = 4194304,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 8388608,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 65536,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 8192,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
    VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 536870912,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 16777216
} VkFormatFeatureFlagBits;

typedef enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1
} VkFrontFace;

typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 1,
    VK_IMAGE_ASPECT_DEPTH_BIT = 2,
    VK_IMAGE_ASPECT_STENCIL_BIT = 4,
    VK_IMAGE_ASPECT_METADATA_BIT = 8,
    VK_IMAGE_ASPECT_PLANE_0_BIT = 16,
    VK_IMAGE_ASPECT_PLANE_1_BIT = 32,
    VK_IMAGE_ASPECT_PLANE_2_BIT = 64,
    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 128,
    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 256,
    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 512,
    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 1024
} VkImageAspectFlagBits;

typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 1,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 8,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 16,
    VK_IMAGE_CREATE_ALIAS_BIT = 1024,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 64,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 32,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 128,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 256,
    VK_IMAGE_CREATE_PROTECTED_BIT = 2048,
    VK_IMAGE_CREATE_DISJOINT_BIT = 512,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 4096,
    VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
    VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 16384
} VkImageCreateFlagBits;

typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL
} VkImageLayout;

typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000
} VkImageTiling;

typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2
} VkImageType;

typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 2,
    VK_IMAGE_USAGE_SAMPLED_BIT = 4,
    VK_IMAGE_USAGE_STORAGE_BIT = 8,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128,
    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 512
} VkImageUsageFlagBits;

typedef enum VkImageViewCreateFlagBits {
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 1,
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 2
} VkImageViewCreateFlagBits;

typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6
} VkImageViewType;

typedef enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1
} VkSharingMode;

typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_NONE_KHR = 1000165000,
    VK_INDEX_TYPE_UINT8_EXT = 1000265000
} VkIndexType;

typedef enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15
} VkLogicOp;

typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 2,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT
} VkMemoryHeapFlagBits;

typedef enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1,
    VK_ACCESS_INDEX_READ_BIT = 2,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 4,
    VK_ACCESS_UNIFORM_READ_BIT = 8,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 16,
    VK_ACCESS_SHADER_READ_BIT = 32,
    VK_ACCESS_SHADER_WRITE_BIT = 64,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 128,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
    VK_ACCESS_TRANSFER_READ_BIT = 2048,
    VK_ACCESS_TRANSFER_WRITE_BIT = 4096,
    VK_ACCESS_HOST_READ_BIT = 8192,
    VK_ACCESS_HOST_WRITE_BIT = 16384,
    VK_ACCESS_MEMORY_READ_BIT = 32768,
    VK_ACCESS_MEMORY_WRITE_BIT = 65536,
    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 33554432,
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 67108864,
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 134217728,
    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 1048576,
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 524288,
    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 2097152,
    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 4194304,
    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 16777216
} VkAccessFlagBits;

typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 2,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 4,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 8,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16,
    VK_MEMORY_PROPERTY_PROTECTED_BIT = 32
} VkMemoryPropertyFlagBits;

typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4
} VkPhysicalDeviceType;

typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000
} VkPipelineBindPoint;

typedef enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 2,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 4,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 8,
    VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 16,
    VK_PIPELINE_CREATE_DISPATCH_BASE = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 16384,
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 32768,
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 65536,
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 131072,
    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 4096,
    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 8192,
    VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 64,
    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 128,
    VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 2048,
    VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = 256,
    VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT = 512
} VkPipelineCreateFlagBits;

typedef enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10
} VkPrimitiveTopology;

typedef enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 1
} VkQueryControlFlagBits;

typedef enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 2,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 4,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 8,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 16,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 32,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 64,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 128,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 256,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 512,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1024
} VkQueryPipelineStatisticFlagBits;

typedef enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 1,
    VK_QUERY_RESULT_WAIT_BIT = 2,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 4,
    VK_QUERY_RESULT_PARTIAL_BIT = 8
} VkQueryResultFlagBits;

typedef enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
    VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000165000,
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150000
} VkQueryType;

typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 1,
    VK_QUEUE_COMPUTE_BIT = 2,
    VK_QUEUE_TRANSFER_BIT = 4,
    VK_QUEUE_SPARSE_BINDING_BIT = 8,
    VK_QUEUE_PROTECTED_BIT = 16
} VkQueueFlagBits;

typedef enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1
} VkSubpassContents;

typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_UNKNOWN = -13,
    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    VK_ERROR_FRAGMENTATION = -1000161000,
    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    VK_ERROR_INCOMPATIBLE_VERSION_KHR = -1000150000,
    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
    VK_ERROR_FRAGMENTATION_EXT = VK_ERROR_FRAGMENTATION,
    VK_ERROR_NOT_PERMITTED_EXT = -1000174001,
    VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
    VK_THREAD_IDLE_KHR = 1000268000,
    VK_THREAD_DONE_KHR = 1000268001,
    VK_OPERATION_DEFERRED_KHR = 1000268002,
    VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
    VK_PIPELINE_COMPILE_REQUIRED_EXT = 1000297000,
    VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT = VK_PIPELINE_COMPILE_REQUIRED_EXT
} VkResult;

typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 1,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4,
    VK_SHADER_STAGE_GEOMETRY_BIT = 8,
    VK_SHADER_STAGE_FRAGMENT_BIT = 16,
    VK_SHADER_STAGE_COMPUTE_BIT = 32,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
    VK_SHADER_STAGE_RAYGEN_BIT_KHR = 256,
    VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 512,
    VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 1024,
    VK_SHADER_STAGE_MISS_BIT_KHR = 2048,
    VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 4096,
    VK_SHADER_STAGE_CALLABLE_BIT_KHR = 8192
} VkShaderStageFlagBits;

typedef enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 1
} VkSparseMemoryBindFlagBits;

typedef enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 1,
    VK_STENCIL_FACE_BACK_BIT = 2,
    VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
    VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FACE_FRONT_AND_BACK
} VkStencilFaceFlagBits;

typedef enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7
} VkStencilOp;

typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
    VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
    VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
    VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
    VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
    VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR,
    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003,
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_KHR = 1000165006,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000165007,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_GEOMETRY_TYPE_INFO_KHR = 1000150001,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_KHR = 1000150008,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_KHR = 1000150009,
    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_FEATURES_KHR = 1000150013,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_KHR = 1000150014,
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
    VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
    VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
    VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
    VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000,
    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
    VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
    VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
    VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
    VK_STRUCTURE_TYPE_DEFERRED_OPERATION_INFO_KHR = 1000268000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
    VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001,
    VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
    VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = 1000295000,
    VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = 1000295001,
    VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = 1000295002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = 1000297000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = 1000335000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
    VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000
} VkStructureType;

typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4
} VkSystemAllocationScope;

typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0
} VkInternalAllocationType;

typedef enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE
} VkSamplerAddressMode;

typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_CUBIC_EXT = VK_FILTER_CUBIC_IMG
} VkFilter;

typedef enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1
} VkSamplerMipmapMode;

typedef enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1
} VkVertexInputRate;

typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 2,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 4,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 8,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 16,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 32,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 64,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 128,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 256,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 512,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 2048,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 4096,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 8192,
    VK_PIPELINE_STAGE_HOST_BIT = 16384,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 32768,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 65536,
    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 16777216,
    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 262144,
    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 2097152,
    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 33554432,
    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 8388608
} VkPipelineStageFlagBits;

typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 2,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 4
} VkSparseImageFormatFlagBits;

typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 1,
    VK_SAMPLE_COUNT_2_BIT = 2,
    VK_SAMPLE_COUNT_4_BIT = 4,
    VK_SAMPLE_COUNT_8_BIT = 8,
    VK_SAMPLE_COUNT_16_BIT = 16,
    VK_SAMPLE_COUNT_32_BIT = 32,
    VK_SAMPLE_COUNT_64_BIT = 64
} VkSampleCountFlagBits;

typedef enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1
} VkAttachmentDescriptionFlagBits;

typedef enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1,
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 2,
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT
} VkDescriptorPoolCreateFlagBits;

typedef enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 1,
    VK_DEPENDENCY_DEVICE_GROUP_BIT = 4,
    VK_DEPENDENCY_VIEW_LOCAL_BIT = 2,
    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT
} VkDependencyFlagBits;

typedef enum VkObjectType {
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000165000,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
    VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
    VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT = 1000295000
} VkObjectType;


typedef enum VkDescriptorUpdateTemplateType {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
} VkDescriptorUpdateTemplateType;

typedef enum VkDescriptorUpdateTemplateType VkDescriptorUpdateTemplateTypeKHR;

typedef enum VkDiscardRectangleModeEXT {
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1
} VkDiscardRectangleModeEXT;


typedef enum VkPointClippingBehavior {
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY
} VkPointClippingBehavior;

typedef enum VkPointClippingBehavior VkPointClippingBehaviorKHR;

typedef enum VkValidationCacheHeaderVersionEXT {
    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1
} VkValidationCacheHeaderVersionEXT;

typedef enum VkQueueGlobalPriorityEXT {
    VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128,
    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256,
    VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512,
    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024
} VkQueueGlobalPriorityEXT;

typedef enum VkTimeDomainEXT {
    VK_TIME_DOMAIN_DEVICE_EXT = 0,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2,
    VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3
} VkTimeDomainEXT;

typedef enum VkConservativeRasterizationModeEXT {
    VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
    VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
    VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2
} VkConservativeRasterizationModeEXT;

typedef enum VkResolveModeFlagBits {
    VK_RESOLVE_MODE_NONE = 0,
    VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 1,
    VK_RESOLVE_MODE_AVERAGE_BIT = 2,
    VK_RESOLVE_MODE_MIN_BIT = 4,
    VK_RESOLVE_MODE_MAX_BIT = 8,
    VK_RESOLVE_MODE_NONE_KHR = VK_RESOLVE_MODE_NONE,
    VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
    VK_RESOLVE_MODE_AVERAGE_BIT_KHR = VK_RESOLVE_MODE_AVERAGE_BIT,
    VK_RESOLVE_MODE_MIN_BIT_KHR = VK_RESOLVE_MODE_MIN_BIT,
    VK_RESOLVE_MODE_MAX_BIT_KHR = VK_RESOLVE_MODE_MAX_BIT
} VkResolveModeFlagBits;

typedef enum VkResolveModeFlagBits VkResolveModeFlagBitsKHR;

typedef enum VkDescriptorBindingFlagBits {
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 1,
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 2,
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 4,
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 8,
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT
} VkDescriptorBindingFlagBits;

typedef enum VkDescriptorBindingFlagBits VkDescriptorBindingFlagBitsEXT;

typedef enum VkConditionalRenderingFlagBitsEXT {
    VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 1
} VkConditionalRenderingFlagBitsEXT;

typedef enum VkSemaphoreType {
    VK_SEMAPHORE_TYPE_BINARY = 0,
    VK_SEMAPHORE_TYPE_TIMELINE = 1,
    VK_SEMAPHORE_TYPE_BINARY_KHR = VK_SEMAPHORE_TYPE_BINARY,
    VK_SEMAPHORE_TYPE_TIMELINE_KHR = VK_SEMAPHORE_TYPE_TIMELINE
} VkSemaphoreType;

typedef enum VkSemaphoreType VkSemaphoreTypeKHR;

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef enum VkGeometryFlagBitsKHR {
    VK_GEOMETRY_OPAQUE_BIT_KHR = 1,
    VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 2
} VkGeometryFlagBitsKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef enum VkGeometryInstanceFlagBitsKHR {
    VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 1,
    VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = 2,
    VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 4,
    VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 8
} VkGeometryInstanceFlagBitsKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef enum VkBuildAccelerationStructureFlagBitsKHR {
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 1,
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 2,
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 4,
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 8,
    VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 16
} VkBuildAccelerationStructureFlagBitsKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef enum VkCopyAccelerationStructureModeKHR {
    VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3
} VkCopyAccelerationStructureModeKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef enum VkAccelerationStructureTypeKHR {
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1
} VkAccelerationStructureTypeKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef enum VkGeometryTypeKHR {
    VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
    VK_GEOMETRY_TYPE_AABBS_KHR = 1,
    VK_GEOMETRY_TYPE_INSTANCES_KHR = 1000150000
} VkGeometryTypeKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef enum VkRayTracingShaderGroupTypeKHR {
    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2
} VkRayTracingShaderGroupTypeKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef enum VkAccelerationStructureMemoryRequirementsTypeKHR {
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_KHR = 0,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_KHR = 1,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_KHR = 2
} VkAccelerationStructureMemoryRequirementsTypeKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef enum VkAccelerationStructureBuildTypeKHR {
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2
} VkAccelerationStructureBuildTypeKHR;
#endif

typedef enum VkPipelineCreationFeedbackFlagBitsEXT {
    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 1,
    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 2,
    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 4
} VkPipelineCreationFeedbackFlagBitsEXT;

typedef enum VkPerformanceCounterScopeKHR {
    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
    VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
    VK_QUERY_SCOPE_COMMAND_BUFFER_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
    VK_QUERY_SCOPE_RENDER_PASS_KHR = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
    VK_QUERY_SCOPE_COMMAND_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR
} VkPerformanceCounterScopeKHR;

typedef enum VkPerformanceCounterUnitKHR {
    VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
    VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
    VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
    VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
    VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
    VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
    VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
    VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
    VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
    VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
    VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10
} VkPerformanceCounterUnitKHR;

typedef enum VkPerformanceCounterStorageKHR {
    VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
    VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
    VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
    VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5
} VkPerformanceCounterStorageKHR;

typedef enum VkPerformanceCounterDescriptionFlagBitsKHR {
    VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = 1,
    VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = 2
} VkPerformanceCounterDescriptionFlagBitsKHR;


typedef enum VkSemaphoreWaitFlagBits {
    VK_SEMAPHORE_WAIT_ANY_BIT = 1,
    VK_SEMAPHORE_WAIT_ANY_BIT_KHR = VK_SEMAPHORE_WAIT_ANY_BIT
} VkSemaphoreWaitFlagBits;

typedef enum VkSemaphoreWaitFlagBits VkSemaphoreWaitFlagBitsKHR;

typedef enum VkLineRasterizationModeEXT {
    VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0,
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1,
    VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2,
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3
} VkLineRasterizationModeEXT;


typedef enum VkToolPurposeFlagBitsEXT {
    VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = 1,
    VK_TOOL_PURPOSE_PROFILING_BIT_EXT = 2,
    VK_TOOL_PURPOSE_TRACING_BIT_EXT = 4,
    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = 8,
    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = 16,
    VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 32,
    VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 64
} VkToolPurposeFlagBitsEXT;

typedef enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT
} VkColorSpaceKHR;

typedef enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 2,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 4,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 8
} VkCompositeAlphaFlagBitsKHR;

typedef enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 2,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 4,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8
} VkDisplayPlaneAlphaFlagBitsKHR;

typedef enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001
} VkPresentModeKHR;

typedef enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 2,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 4,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 8,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 16,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 256
} VkSurfaceTransformFlagBitsKHR;

typedef enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 1,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 2,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 4,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 8,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 16
} VkDebugReportFlagBitsEXT;

typedef enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000165000,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
} VkDebugReportObjectTypeEXT;

typedef enum VkValidationCheckEXT {
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_SHADERS_EXT = 1
} VkValidationCheckEXT;

typedef enum VkValidationFeatureEnableEXT {
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
    VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
    VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
    VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4
} VkValidationFeatureEnableEXT;

typedef enum VkValidationFeatureDisableEXT {
    VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
    VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
    VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
    VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
    VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
    VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
    VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6
} VkValidationFeatureDisableEXT;

typedef enum VkExternalMemoryHandleTypeFlagBits {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 8,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 16,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 32,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 64,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 512,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 1024,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 128,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 256
} VkExternalMemoryHandleTypeFlagBits;

typedef enum VkExternalMemoryHandleTypeFlagBits VkExternalMemoryHandleTypeFlagBitsKHR;

typedef enum VkExternalMemoryFeatureFlagBits {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 1,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 2,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 4,
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT
} VkExternalMemoryFeatureFlagBits;

typedef enum VkExternalMemoryFeatureFlagBits VkExternalMemoryFeatureFlagBitsKHR;

typedef enum VkExternalSemaphoreHandleTypeFlagBits {
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 8,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 16,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
} VkExternalSemaphoreHandleTypeFlagBits;

typedef enum VkExternalSemaphoreHandleTypeFlagBits VkExternalSemaphoreHandleTypeFlagBitsKHR;

typedef enum VkExternalSemaphoreFeatureFlagBits {
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 1,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 2,
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
} VkExternalSemaphoreFeatureFlagBits;

typedef enum VkExternalSemaphoreFeatureFlagBits VkExternalSemaphoreFeatureFlagBitsKHR;

typedef enum VkSemaphoreImportFlagBits {
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 1,
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT
} VkSemaphoreImportFlagBits;

typedef enum VkSemaphoreImportFlagBits VkSemaphoreImportFlagBitsKHR;

typedef enum VkExternalFenceHandleTypeFlagBits {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 8,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
} VkExternalFenceHandleTypeFlagBits;

typedef enum VkExternalFenceHandleTypeFlagBits VkExternalFenceHandleTypeFlagBitsKHR;

typedef enum VkExternalFenceFeatureFlagBits {
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 1,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 2,
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
} VkExternalFenceFeatureFlagBits;

typedef enum VkExternalFenceFeatureFlagBits VkExternalFenceFeatureFlagBitsKHR;

typedef enum VkFenceImportFlagBits {
    VK_FENCE_IMPORT_TEMPORARY_BIT = 1,
    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT
} VkFenceImportFlagBits;

typedef enum VkFenceImportFlagBits VkFenceImportFlagBitsKHR;

typedef enum VkSurfaceCounterFlagBitsEXT {
    VK_SURFACE_COUNTER_VBLANK_EXT = 1
} VkSurfaceCounterFlagBitsEXT;

typedef enum VkDisplayPowerStateEXT {
    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
    VK_DISPLAY_POWER_STATE_ON_EXT = 2
} VkDisplayPowerStateEXT;

typedef enum VkDeviceEventTypeEXT {
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0
} VkDeviceEventTypeEXT;

typedef enum VkDisplayEventTypeEXT {
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0
} VkDisplayEventTypeEXT;

typedef enum VkPeerMemoryFeatureFlagBits {
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 1,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 2,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 4,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 8,
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT
} VkPeerMemoryFeatureFlagBits;

typedef enum VkPeerMemoryFeatureFlagBits VkPeerMemoryFeatureFlagBitsKHR;

typedef enum VkMemoryAllocateFlagBits {
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 1,
    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 2,
    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 4,
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
} VkMemoryAllocateFlagBits;

typedef enum VkMemoryAllocateFlagBits VkMemoryAllocateFlagBitsKHR;

typedef enum VkDeviceGroupPresentModeFlagBitsKHR {
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 1,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 2,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 4,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 8
} VkDeviceGroupPresentModeFlagBitsKHR;

typedef enum VkSwapchainCreateFlagBitsKHR {
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1,
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 2,
    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 4
} VkSwapchainCreateFlagBitsKHR;

typedef enum VkSubgroupFeatureFlagBits {
    VK_SUBGROUP_FEATURE_BASIC_BIT = 1,
    VK_SUBGROUP_FEATURE_VOTE_BIT = 2,
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 4,
    VK_SUBGROUP_FEATURE_BALLOT_BIT = 8,
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 16,
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 32,
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 64,
    VK_SUBGROUP_FEATURE_QUAD_BIT = 128
} VkSubgroupFeatureFlagBits;

typedef enum VkTessellationDomainOrigin {
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT
} VkTessellationDomainOrigin;

typedef enum VkTessellationDomainOrigin VkTessellationDomainOriginKHR;

typedef enum VkSamplerYcbcrModelConversion {
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020
} VkSamplerYcbcrModelConversion;

typedef enum VkSamplerYcbcrModelConversion VkSamplerYcbcrModelConversionKHR;

typedef enum VkSamplerYcbcrRange {
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW
} VkSamplerYcbcrRange;

typedef enum VkSamplerYcbcrRange VkSamplerYcbcrRangeKHR;

typedef enum VkChromaLocation {
    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
    VK_CHROMA_LOCATION_MIDPOINT = 1,
    VK_CHROMA_LOCATION_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN,
    VK_CHROMA_LOCATION_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT
} VkChromaLocation;

typedef enum VkChromaLocation VkChromaLocationKHR;

typedef enum VkSamplerReductionMode {
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
    VK_SAMPLER_REDUCTION_MODE_MIN = 1,
    VK_SAMPLER_REDUCTION_MODE_MAX = 2,
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
    VK_SAMPLER_REDUCTION_MODE_MIN_EXT = VK_SAMPLER_REDUCTION_MODE_MIN,
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT = VK_SAMPLER_REDUCTION_MODE_MAX
} VkSamplerReductionMode;

typedef enum VkSamplerReductionMode VkSamplerReductionModeEXT;

typedef enum VkBlendOverlapEXT {
    VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
    VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
    VK_BLEND_OVERLAP_CONJOINT_EXT = 2
} VkBlendOverlapEXT;

typedef enum VkDebugUtilsMessageSeverityFlagBitsEXT {
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 1,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 16,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 256,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 4096
} VkDebugUtilsMessageSeverityFlagBitsEXT;

typedef enum VkDebugUtilsMessageTypeFlagBitsEXT {
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 1,
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 2,
    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 4
} VkDebugUtilsMessageTypeFlagBitsEXT;

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef enum VkFullScreenExclusiveEXT {
    VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
    VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
    VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
    VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3
} VkFullScreenExclusiveEXT;
#endif

typedef enum VkShaderFloatControlsIndependence {
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE
} VkShaderFloatControlsIndependence;

typedef enum VkShaderFloatControlsIndependence VkShaderFloatControlsIndependenceKHR;

typedef enum VkVendorId {
    VK_VENDOR_ID_VIV = 0x10001,
    VK_VENDOR_ID_VSI = 0x10002,
    VK_VENDOR_ID_KAZAN = 0x10003,
    VK_VENDOR_ID_CODEPLAY = 0x10004,
    VK_VENDOR_ID_MESA = 0x10005
} VkVendorId;

typedef enum VkDriverId {
    VK_DRIVER_ID_AMD_PROPRIETARY = 1,
    VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
    VK_DRIVER_ID_MESA_RADV = 3,
    VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
    VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
    VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
    VK_DRIVER_ID_ARM_PROPRIETARY = 9,
    VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
    VK_DRIVER_ID_GGP_PROPRIETARY = 11,
    VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
    VK_DRIVER_ID_MESA_LLVMPIPE = 13,
    VK_DRIVER_ID_MOLTENVK = 14,
    VK_DRIVER_ID_AMD_PROPRIETARY_KHR = VK_DRIVER_ID_AMD_PROPRIETARY,
    VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = VK_DRIVER_ID_AMD_OPEN_SOURCE,
    VK_DRIVER_ID_MESA_RADV_KHR = VK_DRIVER_ID_MESA_RADV,
    VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = VK_DRIVER_ID_NVIDIA_PROPRIETARY,
    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
    VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
    VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
    VK_DRIVER_ID_ARM_PROPRIETARY_KHR = VK_DRIVER_ID_ARM_PROPRIETARY,
    VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
    VK_DRIVER_ID_GGP_PROPRIETARY_KHR = VK_DRIVER_ID_GGP_PROPRIETARY,
    VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR = VK_DRIVER_ID_BROADCOM_PROPRIETARY
} VkDriverId;

typedef enum VkDriverId VkDriverIdKHR;

typedef enum VkPipelineExecutableStatisticFormatKHR {
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3
} VkPipelineExecutableStatisticFormatKHR;

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);

typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);

typedef struct VkBaseOutStructure {
    VkStructureType   sType;
    struct  VkBaseOutStructure *  pNext;
} VkBaseOutStructure;

typedef struct VkBaseInStructure {
    VkStructureType   sType;
    const struct  VkBaseInStructure *  pNext;
} VkBaseInStructure;

typedef struct VkOffset2D {
    int32_t          x;
    int32_t          y;
} VkOffset2D;

typedef struct VkOffset3D {
    int32_t          x;
    int32_t          y;
    int32_t          z;
} VkOffset3D;

typedef struct VkExtent2D {
    uint32_t          width;
    uint32_t          height;
} VkExtent2D;

typedef struct VkExtent3D {
    uint32_t          width;
    uint32_t          height;
    uint32_t          depth;
} VkExtent3D;

typedef struct VkViewport {
    float   x;
    float   y;
    float   width;
    float   height;
    float                         minDepth;
    float                         maxDepth;
} VkViewport;

typedef struct VkRect2D {
    VkOffset2D       offset;
    VkExtent2D       extent;
} VkRect2D;

typedef struct VkClearRect {
    VkRect2D         rect;
    uint32_t         baseArrayLayer;
    uint32_t         layerCount;
} VkClearRect;

typedef struct VkComponentMapping {
    VkComponentSwizzle   r;
    VkComponentSwizzle   g;
    VkComponentSwizzle   b;
    VkComponentSwizzle   a;
} VkComponentMapping;

typedef struct VkExtensionProperties {
    char              extensionName [ VK_MAX_EXTENSION_NAME_SIZE ];
    uint32_t          specVersion;
} VkExtensionProperties;

typedef struct VkLayerProperties {
    char              layerName [ VK_MAX_EXTENSION_NAME_SIZE ];
    uint32_t          specVersion;
    uint32_t          implementationVersion;
    char              description [ VK_MAX_DESCRIPTION_SIZE ];
} VkLayerProperties;

typedef struct VkApplicationInfo {
    VkStructureType   sType;
    const  void *      pNext;
    const  char *      pApplicationName;
    uint32_t          applicationVersion;
    const  char *      pEngineName;
    uint32_t          engineVersion;
    uint32_t          apiVersion;
} VkApplicationInfo;

typedef struct VkAllocationCallbacks {
    void *            pUserData;
    PFN_vkAllocationFunction     pfnAllocation;
    PFN_vkReallocationFunction   pfnReallocation;
    PFN_vkFreeFunction      pfnFree;
    PFN_vkInternalAllocationNotification   pfnInternalAllocation;
    PFN_vkInternalFreeNotification   pfnInternalFree;
} VkAllocationCallbacks;

typedef struct VkDescriptorImageInfo {
    VkSampler         sampler;
    VkImageView       imageView;
    VkImageLayout     imageLayout;
} VkDescriptorImageInfo;

typedef struct VkCopyDescriptorSet {
    VkStructureType   sType;
    const  void *             pNext;
    VkDescriptorSet          srcSet;
    uint32_t                 srcBinding;
    uint32_t                 srcArrayElement;
    VkDescriptorSet          dstSet;
    uint32_t                 dstBinding;
    uint32_t                 dstArrayElement;
    uint32_t                 descriptorCount;
} VkCopyDescriptorSet;

typedef struct VkDescriptorPoolSize {
    VkDescriptorType         type;
    uint32_t                 descriptorCount;
} VkDescriptorPoolSize;

typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkDescriptorPool         descriptorPool;
    uint32_t                 descriptorSetCount;
    const  VkDescriptorSetLayout *  pSetLayouts;
} VkDescriptorSetAllocateInfo;

typedef struct VkSpecializationMapEntry {
    uint32_t                       constantID;
    uint32_t                       offset;
    size_t   size;
} VkSpecializationMapEntry;

typedef struct VkSpecializationInfo {
    uint32_t                 mapEntryCount;
    const  VkSpecializationMapEntry *  pMapEntries;
    size_t                   dataSize;
    const  void *             pData;
} VkSpecializationInfo;

typedef struct VkVertexInputBindingDescription {
    uint32_t                 binding;
    uint32_t                 stride;
    VkVertexInputRate        inputRate;
} VkVertexInputBindingDescription;

typedef struct VkVertexInputAttributeDescription {
    uint32_t                 location;
    uint32_t                 binding;
    VkFormat                 format;
    uint32_t                 offset;
} VkVertexInputAttributeDescription;

typedef struct VkStencilOpState {
    VkStencilOp              failOp;
    VkStencilOp              passOp;
    VkStencilOp              depthFailOp;
    VkCompareOp              compareOp;
    uint32_t                 compareMask;
    uint32_t                 writeMask;
    uint32_t                 reference;
} VkStencilOpState;

typedef struct VkCommandBufferAllocateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkCommandPool            commandPool;
    VkCommandBufferLevel     level;
    uint32_t                 commandBufferCount;
} VkCommandBufferAllocateInfo;

typedef union VkClearColorValue {
    float                    float32 [4];
    int32_t                  int32 [4];
    uint32_t                 uint32 [4];
} VkClearColorValue;

typedef struct VkClearDepthStencilValue {
    float                    depth;
    uint32_t                 stencil;
} VkClearDepthStencilValue;

typedef union VkClearValue {
    VkClearColorValue        color;
    VkClearDepthStencilValue   depthStencil;
} VkClearValue;

typedef struct VkAttachmentReference {
    uint32_t                 attachment;
    VkImageLayout            layout;
} VkAttachmentReference;

typedef struct VkDrawIndirectCommand {
    uint32_t                         vertexCount;
    uint32_t                         instanceCount;
    uint32_t                         firstVertex;
    uint32_t   firstInstance;
} VkDrawIndirectCommand;

typedef struct VkDrawIndexedIndirectCommand {
    uint32_t                         indexCount;
    uint32_t                         instanceCount;
    uint32_t                         firstIndex;
    int32_t                          vertexOffset;
    uint32_t   firstInstance;
} VkDrawIndexedIndirectCommand;

typedef struct VkDispatchIndirectCommand {
    uint32_t   x;
    uint32_t   y;
    uint32_t   z;
} VkDispatchIndirectCommand;

typedef struct VkDisplayPlanePropertiesKHR {
    VkDisplayKHR                       currentDisplay;
    uint32_t                           currentStackIndex;
} VkDisplayPlanePropertiesKHR;

typedef struct VkDisplayModeParametersKHR {
    VkExtent2D                         visibleRegion;
    uint32_t     refreshRate;
} VkDisplayModeParametersKHR;

typedef struct VkDisplayModePropertiesKHR {
    VkDisplayModeKHR                   displayMode;
    VkDisplayModeParametersKHR         parameters;
} VkDisplayModePropertiesKHR;

typedef struct VkSurfaceFormatKHR {
    VkFormat                           format;
    VkColorSpaceKHR                    colorSpace;
} VkSurfaceFormatKHR;

typedef struct VkPresentInfoKHR {
    VkStructureType   sType;
    const  void *   pNext;
    uint32_t           waitSemaphoreCount;
    const  VkSemaphore *  pWaitSemaphores;
    uint32_t                           swapchainCount;
    const  VkSwapchainKHR *  pSwapchains;
    const  uint32_t *  pImageIndices;
    VkResult *  pResults;
} VkPresentInfoKHR;

typedef struct VkValidationFlagsEXT {
    VkStructureType                    sType;
    const  void *                       pNext;
    uint32_t                           disabledValidationCheckCount;
    const  VkValidationCheckEXT *  pDisabledValidationChecks;
} VkValidationFlagsEXT;

typedef struct VkValidationFeaturesEXT {
    VkStructureType    sType;
    const  void *                       pNext;
    uint32_t                           enabledValidationFeatureCount;
    const  VkValidationFeatureEnableEXT *  pEnabledValidationFeatures;
    uint32_t                           disabledValidationFeatureCount;
    const  VkValidationFeatureDisableEXT *  pDisabledValidationFeatures;
} VkValidationFeaturesEXT;

typedef struct VkDebugMarkerObjectNameInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDebugReportObjectTypeEXT         objectType;
    uint64_t                           object;
    const  char *  pObjectName;
} VkDebugMarkerObjectNameInfoEXT;

typedef struct VkDebugMarkerObjectTagInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDebugReportObjectTypeEXT         objectType;
    uint64_t                           object;
    uint64_t                           tagName;
    size_t                             tagSize;
    const  void *         pTag;
} VkDebugMarkerObjectTagInfoEXT;

typedef struct VkDebugMarkerMarkerInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    const  char *  pMarkerName;
    float              color [4];
} VkDebugMarkerMarkerInfoEXT;

typedef struct VkDevicePrivateDataCreateInfoEXT {
    VkStructureType   sType;
    const  void *                             pNext;
    uint32_t                                 privateDataSlotRequestCount;
} VkDevicePrivateDataCreateInfoEXT;

typedef struct VkPhysicalDevicePushDescriptorPropertiesKHR {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                           maxPushDescriptors;
} VkPhysicalDevicePushDescriptorPropertiesKHR;

typedef struct VkConformanceVersion {
    uint8_t                            major;
    uint8_t                            minor;
    uint8_t                            subminor;
    uint8_t                            patch;
} VkConformanceVersion;

typedef struct VkConformanceVersion  VkConformanceVersionKHR;

typedef struct VkPhysicalDeviceDriverProperties {
    VkStructureType   sType;
    void *                             pNext;
    VkDriverId                         driverID;
    char                               driverName [ VK_MAX_DRIVER_NAME_SIZE ];
    char                               driverInfo [ VK_MAX_DRIVER_INFO_SIZE ];
    VkConformanceVersion               conformanceVersion;
} VkPhysicalDeviceDriverProperties;

typedef struct VkPhysicalDeviceDriverProperties  VkPhysicalDeviceDriverPropertiesKHR;

typedef struct VkRectLayerKHR {
    VkOffset2D                         offset;
    VkExtent2D   extent;
    uint32_t                           layer;
} VkRectLayerKHR;

typedef struct VkPhysicalDeviceExternalImageFormatInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalMemoryHandleTypeFlagBits   handleType;
} VkPhysicalDeviceExternalImageFormatInfo;

typedef struct VkPhysicalDeviceExternalImageFormatInfo  VkPhysicalDeviceExternalImageFormatInfoKHR;

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkImportMemoryWin32HandleInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalMemoryHandleTypeFlagBits   handleType;
    HANDLE             handle;
    LPCWSTR            name;
} VkImportMemoryWin32HandleInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkExportMemoryWin32HandleInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    const  SECURITY_ATTRIBUTES *  pAttributes;
    DWORD                              dwAccess;
    LPCWSTR                            name;
} VkExportMemoryWin32HandleInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkMemoryWin32HandlePropertiesKHR {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                           memoryTypeBits;
} VkMemoryWin32HandlePropertiesKHR;
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkMemoryGetWin32HandleInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDeviceMemory                     memory;
    VkExternalMemoryHandleTypeFlagBits   handleType;
} VkMemoryGetWin32HandleInfoKHR;
#endif

typedef struct VkImportMemoryFdInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalMemoryHandleTypeFlagBits   handleType;
    int                                fd;
} VkImportMemoryFdInfoKHR;

typedef struct VkMemoryFdPropertiesKHR {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                           memoryTypeBits;
} VkMemoryFdPropertiesKHR;

typedef struct VkMemoryGetFdInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDeviceMemory                     memory;
    VkExternalMemoryHandleTypeFlagBits   handleType;
} VkMemoryGetFdInfoKHR;

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkWin32KeyedMutexAcquireReleaseInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t           acquireCount;
    const  VkDeviceMemory *  pAcquireSyncs;
    const  uint64_t *  pAcquireKeys;
    const  uint32_t *  pAcquireTimeouts;
    uint32_t           releaseCount;
    const  VkDeviceMemory *  pReleaseSyncs;
    const  uint64_t *  pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoKHR;
#endif

typedef struct VkPhysicalDeviceExternalSemaphoreInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalSemaphoreHandleTypeFlagBits   handleType;
} VkPhysicalDeviceExternalSemaphoreInfo;

typedef struct VkPhysicalDeviceExternalSemaphoreInfo  VkPhysicalDeviceExternalSemaphoreInfoKHR;

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkExportSemaphoreWin32HandleInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    const  SECURITY_ATTRIBUTES *        pAttributes;
    DWORD                              dwAccess;
    LPCWSTR                            name;
} VkExportSemaphoreWin32HandleInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkD3D12FenceSubmitInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t           waitSemaphoreValuesCount;
    const  uint64_t *  pWaitSemaphoreValues;
    uint32_t           signalSemaphoreValuesCount;
    const  uint64_t *  pSignalSemaphoreValues;
} VkD3D12FenceSubmitInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkSemaphoreGetWin32HandleInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSemaphore                        semaphore;
    VkExternalSemaphoreHandleTypeFlagBits   handleType;
} VkSemaphoreGetWin32HandleInfoKHR;
#endif

typedef struct VkSemaphoreGetFdInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSemaphore                        semaphore;
    VkExternalSemaphoreHandleTypeFlagBits   handleType;
} VkSemaphoreGetFdInfoKHR;

typedef struct VkPhysicalDeviceExternalFenceInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalFenceHandleTypeFlagBits   handleType;
} VkPhysicalDeviceExternalFenceInfo;

typedef struct VkPhysicalDeviceExternalFenceInfo  VkPhysicalDeviceExternalFenceInfoKHR;

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkExportFenceWin32HandleInfoKHR {
    VkStructureType   sType;
    const  void *                                 pNext;
    const  SECURITY_ATTRIBUTES *  pAttributes;
    DWORD                                        dwAccess;
    LPCWSTR                                      name;
} VkExportFenceWin32HandleInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkFenceGetWin32HandleInfoKHR {
    VkStructureType   sType;
    const  void *                             pNext;
    VkFence                                  fence;
    VkExternalFenceHandleTypeFlagBits     handleType;
} VkFenceGetWin32HandleInfoKHR;
#endif

typedef struct VkFenceGetFdInfoKHR {
    VkStructureType   sType;
    const  void *                             pNext;
    VkFence                                  fence;
    VkExternalFenceHandleTypeFlagBits     handleType;
} VkFenceGetFdInfoKHR;

typedef struct VkPhysicalDeviceMultiviewProperties {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                           maxMultiviewViewCount;
    uint32_t                           maxMultiviewInstanceIndex;
} VkPhysicalDeviceMultiviewProperties;

typedef struct VkPhysicalDeviceMultiviewProperties  VkPhysicalDeviceMultiviewPropertiesKHR;

typedef struct VkRenderPassMultiviewCreateInfo {
    VkStructureType          sType;
    const  void *             pNext;
    uint32_t                 subpassCount;
    const  uint32_t *      pViewMasks;
    uint32_t                 dependencyCount;
    const  int32_t *    pViewOffsets;
    uint32_t                 correlationMaskCount;
    const  uint32_t *  pCorrelationMasks;
} VkRenderPassMultiviewCreateInfo;

typedef struct VkRenderPassMultiviewCreateInfo  VkRenderPassMultiviewCreateInfoKHR;

typedef struct VkDisplayPowerInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDisplayPowerStateEXT             powerState;
} VkDisplayPowerInfoEXT;

typedef struct VkDeviceEventInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDeviceEventTypeEXT               deviceEvent;
} VkDeviceEventInfoEXT;

typedef struct VkDisplayEventInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDisplayEventTypeEXT              displayEvent;
} VkDisplayEventInfoEXT;

typedef struct VkBindBufferMemoryDeviceGroupInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t           deviceIndexCount;
    const  uint32_t *   pDeviceIndices;
} VkBindBufferMemoryDeviceGroupInfo;

typedef struct VkBindBufferMemoryDeviceGroupInfo  VkBindBufferMemoryDeviceGroupInfoKHR;

typedef struct VkBindImageMemoryDeviceGroupInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t           deviceIndexCount;
    const  uint32_t *   pDeviceIndices;
    uint32_t           splitInstanceBindRegionCount;
    const  VkRect2D *   pSplitInstanceBindRegions;
} VkBindImageMemoryDeviceGroupInfo;

typedef struct VkBindImageMemoryDeviceGroupInfo  VkBindImageMemoryDeviceGroupInfoKHR;

typedef struct VkDeviceGroupRenderPassBeginInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t                           deviceMask;
    uint32_t           deviceRenderAreaCount;
    const  VkRect2D *   pDeviceRenderAreas;
} VkDeviceGroupRenderPassBeginInfo;

typedef struct VkDeviceGroupRenderPassBeginInfo  VkDeviceGroupRenderPassBeginInfoKHR;

typedef struct VkDeviceGroupCommandBufferBeginInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t                           deviceMask;
} VkDeviceGroupCommandBufferBeginInfo;

typedef struct VkDeviceGroupCommandBufferBeginInfo  VkDeviceGroupCommandBufferBeginInfoKHR;

typedef struct VkDeviceGroupSubmitInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t           waitSemaphoreCount;
    const  uint32_t *     pWaitSemaphoreDeviceIndices;
    uint32_t           commandBufferCount;
    const  uint32_t *     pCommandBufferDeviceMasks;
    uint32_t           signalSemaphoreCount;
    const  uint32_t *   pSignalSemaphoreDeviceIndices;
} VkDeviceGroupSubmitInfo;

typedef struct VkDeviceGroupSubmitInfo  VkDeviceGroupSubmitInfoKHR;

typedef struct VkDeviceGroupBindSparseInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t                           resourceDeviceIndex;
    uint32_t                           memoryDeviceIndex;
} VkDeviceGroupBindSparseInfo;

typedef struct VkDeviceGroupBindSparseInfo  VkDeviceGroupBindSparseInfoKHR;

typedef struct VkImageSwapchainCreateInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSwapchainKHR     swapchain;
} VkImageSwapchainCreateInfoKHR;

typedef struct VkBindImageMemorySwapchainInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSwapchainKHR   swapchain;
    uint32_t                           imageIndex;
} VkBindImageMemorySwapchainInfoKHR;

typedef struct VkAcquireNextImageInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSwapchainKHR   swapchain;
    uint64_t                           timeout;
    VkSemaphore   semaphore;
    VkFence   fence;
    uint32_t                           deviceMask;
} VkAcquireNextImageInfoKHR;

typedef struct VkDeviceGroupPresentInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t           swapchainCount;
    const  uint32_t *  pDeviceMasks;
    VkDeviceGroupPresentModeFlagBitsKHR   mode;
} VkDeviceGroupPresentInfoKHR;

typedef struct VkDeviceGroupDeviceCreateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t                           physicalDeviceCount;
    const  VkPhysicalDevice *   pPhysicalDevices;
} VkDeviceGroupDeviceCreateInfo;

typedef struct VkDeviceGroupDeviceCreateInfo  VkDeviceGroupDeviceCreateInfoKHR;

typedef struct VkDescriptorUpdateTemplateEntry {
    uint32_t                           dstBinding;
    uint32_t                           dstArrayElement;
    uint32_t                           descriptorCount;
    VkDescriptorType                   descriptorType;
    size_t                             offset;
    size_t                             stride;
} VkDescriptorUpdateTemplateEntry;

typedef struct VkDescriptorUpdateTemplateEntry  VkDescriptorUpdateTemplateEntryKHR;

typedef struct VkXYColorEXT {
    float     x;
    float     y;
} VkXYColorEXT;

typedef struct VkHdrMetadataEXT {
    VkStructureType   sType;
    const  void *     pNext;
    VkXYColorEXT     displayPrimaryRed;
    VkXYColorEXT     displayPrimaryGreen;
    VkXYColorEXT     displayPrimaryBlue;
    VkXYColorEXT     whitePoint;
    float            maxLuminance;
    float            minLuminance;
    float            maxContentLightLevel;
    float            maxFrameAverageLightLevel;
} VkHdrMetadataEXT;

typedef struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    VkStructureType   sType;
    void *                   pNext;
    uint32_t                 maxDiscardRectangles;
} VkPhysicalDeviceDiscardRectanglePropertiesEXT;

typedef struct VkPhysicalDeviceSurfaceInfo2KHR {
    VkStructureType   sType;
    const  void *  pNext;
    VkSurfaceKHR   surface;
} VkPhysicalDeviceSurfaceInfo2KHR;

typedef struct VkSurfaceFormat2KHR {
    VkStructureType   sType;
    void *  pNext;
    VkSurfaceFormatKHR   surfaceFormat;
} VkSurfaceFormat2KHR;

typedef struct VkDisplayPlaneProperties2KHR {
    VkStructureType   sType;
    void *  pNext;
    VkDisplayPlanePropertiesKHR   displayPlaneProperties;
} VkDisplayPlaneProperties2KHR;

typedef struct VkDisplayModeProperties2KHR {
    VkStructureType   sType;
    void *  pNext;
    VkDisplayModePropertiesKHR   displayModeProperties;
} VkDisplayModeProperties2KHR;

typedef struct VkDisplayPlaneInfo2KHR {
    VkStructureType   sType;
    const  void *  pNext;
    VkDisplayModeKHR   mode;
    uint32_t   planeIndex;
} VkDisplayPlaneInfo2KHR;

typedef struct VkBufferMemoryRequirementsInfo2 {
    VkStructureType   sType;
    const  void *                                                           pNext;
    VkBuffer                                                               buffer;
} VkBufferMemoryRequirementsInfo2;

typedef struct VkBufferMemoryRequirementsInfo2  VkBufferMemoryRequirementsInfo2KHR;

typedef struct VkImageMemoryRequirementsInfo2 {
    VkStructureType   sType;
    const  void *                                                           pNext;
    VkImage                                                                image;
} VkImageMemoryRequirementsInfo2;

typedef struct VkImageMemoryRequirementsInfo2  VkImageMemoryRequirementsInfo2KHR;

typedef struct VkImageSparseMemoryRequirementsInfo2 {
    VkStructureType   sType;
    const  void *                                                           pNext;
    VkImage                                                                image;
} VkImageSparseMemoryRequirementsInfo2;

typedef struct VkImageSparseMemoryRequirementsInfo2  VkImageSparseMemoryRequirementsInfo2KHR;

typedef struct VkPhysicalDevicePointClippingProperties {
    VkStructureType   sType;
    void *                             pNext;
    VkPointClippingBehavior        pointClippingBehavior;
} VkPhysicalDevicePointClippingProperties;

typedef struct VkPhysicalDevicePointClippingProperties  VkPhysicalDevicePointClippingPropertiesKHR;

typedef struct VkMemoryDedicatedAllocateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkMemoryDedicatedAllocateInfo;

typedef struct VkMemoryDedicatedAllocateInfo  VkMemoryDedicatedAllocateInfoKHR;

typedef struct VkPipelineTessellationDomainOriginStateCreateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkTessellationDomainOrigin      domainOrigin;
} VkPipelineTessellationDomainOriginStateCreateInfo;

typedef struct VkPipelineTessellationDomainOriginStateCreateInfo  VkPipelineTessellationDomainOriginStateCreateInfoKHR;

typedef struct VkSamplerYcbcrConversionInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSamplerYcbcrConversion        conversion;
} VkSamplerYcbcrConversionInfo;

typedef struct VkSamplerYcbcrConversionInfo  VkSamplerYcbcrConversionInfoKHR;

typedef struct VkBindImagePlaneMemoryInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkImageAspectFlagBits              planeAspect;
} VkBindImagePlaneMemoryInfo;

typedef struct VkBindImagePlaneMemoryInfo  VkBindImagePlaneMemoryInfoKHR;

typedef struct VkImagePlaneMemoryRequirementsInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkImageAspectFlagBits              planeAspect;
} VkImagePlaneMemoryRequirementsInfo;

typedef struct VkImagePlaneMemoryRequirementsInfo  VkImagePlaneMemoryRequirementsInfoKHR;

typedef struct VkSamplerYcbcrConversionImageFormatProperties {
    VkStructureType   sType;
    void *       pNext;
    uint32_t                           combinedImageSamplerDescriptorCount;
} VkSamplerYcbcrConversionImageFormatProperties;

typedef struct VkSamplerYcbcrConversionImageFormatProperties  VkSamplerYcbcrConversionImageFormatPropertiesKHR;

typedef struct VkSampleLocationEXT {
    float                              x;
    float                              y;
} VkSampleLocationEXT;

typedef struct VkSampleLocationsInfoEXT {
    VkStructureType   sType;
    const  void *                             pNext;
    VkSampleCountFlagBits    sampleLocationsPerPixel;
    VkExtent2D                               sampleLocationGridSize;
    uint32_t                 sampleLocationsCount;
    const  VkSampleLocationEXT *  pSampleLocations;
} VkSampleLocationsInfoEXT;

typedef struct VkAttachmentSampleLocationsEXT {
    uint32_t                           attachmentIndex;
    VkSampleLocationsInfoEXT           sampleLocationsInfo;
} VkAttachmentSampleLocationsEXT;

typedef struct VkSubpassSampleLocationsEXT {
    uint32_t                           subpassIndex;
    VkSampleLocationsInfoEXT           sampleLocationsInfo;
} VkSubpassSampleLocationsEXT;

typedef struct VkRenderPassSampleLocationsBeginInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t           attachmentInitialSampleLocationsCount;
    const  VkAttachmentSampleLocationsEXT *  pAttachmentInitialSampleLocations;
    uint32_t           postSubpassSampleLocationsCount;
    const  VkSubpassSampleLocationsEXT *  pPostSubpassSampleLocations;
} VkRenderPassSampleLocationsBeginInfoEXT;

typedef struct VkMultisamplePropertiesEXT {
    VkStructureType   sType;
    void *                             pNext;
    VkExtent2D                         maxSampleLocationGridSize;
} VkMultisamplePropertiesEXT;

typedef struct VkSamplerReductionModeCreateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSamplerReductionMode             reductionMode;
} VkSamplerReductionModeCreateInfo;

typedef struct VkSamplerReductionModeCreateInfo  VkSamplerReductionModeCreateInfoEXT;

typedef struct VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
    VkStructureType   sType;
    void *                   pNext;
    uint32_t                 maxInlineUniformBlockSize;
    uint32_t                 maxPerStageDescriptorInlineUniformBlocks;
    uint32_t                 maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    uint32_t                 maxDescriptorSetInlineUniformBlocks;
    uint32_t                 maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
} VkPhysicalDeviceInlineUniformBlockPropertiesEXT;

typedef struct VkWriteDescriptorSetInlineUniformBlockEXT {
    VkStructureType   sType;
    const  void *             pNext;
    uint32_t                 dataSize;
    const  void *  pData;
} VkWriteDescriptorSetInlineUniformBlockEXT;

typedef struct VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
    VkStructureType   sType;
    const  void *             pNext;
    uint32_t                 maxInlineUniformBlockBindings;
} VkDescriptorPoolInlineUniformBlockCreateInfoEXT;

typedef struct VkImageFormatListCreateInfo {
    VkStructureType   sType;
    const  void *                             pNext;
    uint32_t                 viewFormatCount;
    const  VkFormat *   pViewFormats;
} VkImageFormatListCreateInfo;

typedef struct VkImageFormatListCreateInfo  VkImageFormatListCreateInfoKHR;

typedef struct VkShaderModuleValidationCacheCreateInfoEXT {
    VkStructureType   sType;
    const  void *             pNext;
    VkValidationCacheEXT      validationCache;
} VkShaderModuleValidationCacheCreateInfoEXT;

typedef struct VkDeviceQueueGlobalPriorityCreateInfoEXT {
    VkStructureType   sType;
    const  void *                     pNext;
    VkQueueGlobalPriorityEXT         globalPriority;
} VkDeviceQueueGlobalPriorityCreateInfoEXT;

typedef struct VkDebugUtilsObjectNameInfoEXT {
    VkStructureType   sType;
    const  void *                                             pNext;
    VkObjectType                                             objectType;
    uint64_t                                                 objectHandle;
    const  char *       pObjectName;
} VkDebugUtilsObjectNameInfoEXT;

typedef struct VkDebugUtilsObjectTagInfoEXT {
    VkStructureType   sType;
    const  void *                             pNext;
    VkObjectType                             objectType;
    uint64_t                                 objectHandle;
    uint64_t                                 tagName;
    size_t                                   tagSize;
    const  void *               pTag;
} VkDebugUtilsObjectTagInfoEXT;

typedef struct VkDebugUtilsLabelEXT {
    VkStructureType   sType;
    const  void *                             pNext;
    const  char *       pLabelName;
    float                    color [4];
} VkDebugUtilsLabelEXT;

typedef struct VkImportMemoryHostPointerInfoEXT {
    VkStructureType   sType;
    const  void *  pNext;
    VkExternalMemoryHandleTypeFlagBits   handleType;
    void *  pHostPointer;
} VkImportMemoryHostPointerInfoEXT;

typedef struct VkMemoryHostPointerPropertiesEXT {
    VkStructureType   sType;
    void *  pNext;
    uint32_t   memoryTypeBits;
} VkMemoryHostPointerPropertiesEXT;

typedef struct VkCalibratedTimestampInfoEXT {
    VkStructureType   sType;
    const  void *             pNext;
    VkTimeDomainEXT          timeDomain;
} VkCalibratedTimestampInfoEXT;

typedef struct VkDescriptorSetVariableDescriptorCountAllocateInfo {
    VkStructureType   sType;
    const  void *                             pNext;
    uint32_t                 descriptorSetCount;
    const  uint32_t *  pDescriptorCounts;
} VkDescriptorSetVariableDescriptorCountAllocateInfo;

typedef struct VkDescriptorSetVariableDescriptorCountAllocateInfo  VkDescriptorSetVariableDescriptorCountAllocateInfoEXT;

typedef struct VkDescriptorSetVariableDescriptorCountLayoutSupport {
    VkStructureType   sType;
    void *             pNext;
    uint32_t           maxVariableDescriptorCount;
} VkDescriptorSetVariableDescriptorCountLayoutSupport;

typedef struct VkDescriptorSetVariableDescriptorCountLayoutSupport  VkDescriptorSetVariableDescriptorCountLayoutSupportEXT;

typedef struct VkSubpassBeginInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkSubpassContents        contents;
} VkSubpassBeginInfo;

typedef struct VkSubpassBeginInfo  VkSubpassBeginInfoKHR;

typedef struct VkSubpassEndInfo {
    VkStructureType   sType;
    const  void *             pNext;
} VkSubpassEndInfo;

typedef struct VkSubpassEndInfo  VkSubpassEndInfoKHR;

typedef struct VkPhysicalDeviceTimelineSemaphoreProperties {
    VkStructureType   sType;
    void *                   pNext;
    uint64_t                 maxTimelineSemaphoreValueDifference;
} VkPhysicalDeviceTimelineSemaphoreProperties;

typedef struct VkPhysicalDeviceTimelineSemaphoreProperties  VkPhysicalDeviceTimelineSemaphorePropertiesKHR;

typedef struct VkSemaphoreTypeCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkSemaphoreType          semaphoreType;
    uint64_t                 initialValue;
} VkSemaphoreTypeCreateInfo;

typedef struct VkSemaphoreTypeCreateInfo  VkSemaphoreTypeCreateInfoKHR;

typedef struct VkTimelineSemaphoreSubmitInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t           waitSemaphoreValueCount;
    const  uint64_t *  pWaitSemaphoreValues;
    uint32_t           signalSemaphoreValueCount;
    const  uint64_t *  pSignalSemaphoreValues;
} VkTimelineSemaphoreSubmitInfo;

typedef struct VkTimelineSemaphoreSubmitInfo  VkTimelineSemaphoreSubmitInfoKHR;

typedef struct VkSemaphoreSignalInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkSemaphore              semaphore;
    uint64_t                 value;
} VkSemaphoreSignalInfo;

typedef struct VkSemaphoreSignalInfo  VkSemaphoreSignalInfoKHR;

typedef struct VkVertexInputBindingDivisorDescriptionEXT {
    uint32_t            binding;
    uint32_t            divisor;
} VkVertexInputBindingDivisorDescriptionEXT;

typedef struct VkPipelineVertexInputDivisorStateCreateInfoEXT {
    VkStructureType   sType;
    const  void *                          pNext;
    uint32_t                              vertexBindingDivisorCount;
    const  VkVertexInputBindingDivisorDescriptionEXT *       pVertexBindingDivisors;
} VkPipelineVertexInputDivisorStateCreateInfoEXT;

typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    VkStructureType   sType;
    void *                   pNext;
    uint32_t                 maxVertexAttribDivisor;
} VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;

typedef struct VkPhysicalDevicePCIBusInfoPropertiesEXT {
    VkStructureType   sType;
    void *                   pNext;
    uint32_t                 pciDomain;
    uint32_t                 pciBus;
    uint32_t                 pciDevice;
    uint32_t                 pciFunction;
} VkPhysicalDevicePCIBusInfoPropertiesEXT;

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef struct VkImportAndroidHardwareBufferInfoANDROID {
    VkStructureType   sType;
    const  void *                         pNext;
    struct  AHardwareBuffer *             buffer;
} VkImportAndroidHardwareBufferInfoANDROID;
#endif

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef struct VkAndroidHardwareBufferUsageANDROID {
    VkStructureType   sType;
    void *                               pNext;
    uint64_t                             androidHardwareBufferUsage;
} VkAndroidHardwareBufferUsageANDROID;
#endif

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef struct VkMemoryGetAndroidHardwareBufferInfoANDROID {
    VkStructureType   sType;
    const  void *                         pNext;
    VkDeviceMemory                       memory;
} VkMemoryGetAndroidHardwareBufferInfoANDROID;
#endif

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef struct VkExternalFormatANDROID {
    VkStructureType   sType;
    void *                               pNext;
    uint64_t                             externalFormat;
} VkExternalFormatANDROID;
#endif

typedef struct VkImageViewASTCDecodeModeEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkFormat                           decodeMode;
} VkImageViewASTCDecodeModeEXT;

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkRayTracingShaderGroupCreateInfoKHR {
    VkStructureType   sType;
    const  void *             pNext;
    VkRayTracingShaderGroupTypeKHR   type;
    uint32_t                 generalShader;
    uint32_t                 closestHitShader;
    uint32_t                 anyHitShader;
    uint32_t                 intersectionShader;
    const  void *  pShaderGroupCaptureReplayHandle;
} VkRayTracingShaderGroupCreateInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkWriteDescriptorSetAccelerationStructureKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t                           accelerationStructureCount;
    const  VkAccelerationStructureKHR *  pAccelerationStructures;
} VkWriteDescriptorSetAccelerationStructureKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureMemoryRequirementsInfoKHR {
    VkStructureType   sType;
    const  void *                                                           pNext;
    VkAccelerationStructureMemoryRequirementsTypeKHR                       type;
    VkAccelerationStructureBuildTypeKHR                                    buildType;
    VkAccelerationStructureKHR                                             accelerationStructure;
} VkAccelerationStructureMemoryRequirementsInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkPhysicalDeviceRayTracingPropertiesKHR {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                           shaderGroupHandleSize;
    uint32_t                           maxRecursionDepth;
    uint32_t                           maxShaderGroupStride;
    uint32_t                           shaderGroupBaseAlignment;
    uint64_t                           maxGeometryCount;
    uint64_t                           maxInstanceCount;
    uint64_t                           maxPrimitiveCount;
    uint32_t                           maxDescriptorSetAccelerationStructures;
    uint32_t                           shaderGroupHandleCaptureReplaySize;
} VkPhysicalDeviceRayTracingPropertiesKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkTraceRaysIndirectCommandKHR {
    uint32_t                 width;
    uint32_t                 height;
    uint32_t                 depth;
} VkTraceRaysIndirectCommandKHR;
#endif

typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
    VkStructureType   sType;
    const  void *  pNext;
    uint64_t   drmFormatModifier;
    VkSharingMode   sharingMode;
    uint32_t   queueFamilyIndexCount;
    const  uint32_t *  pQueueFamilyIndices;
} VkPhysicalDeviceImageDrmFormatModifierInfoEXT;

typedef struct VkImageDrmFormatModifierListCreateInfoEXT {
    VkStructureType   sType;
    const  void *  pNext;
    uint32_t   drmFormatModifierCount;
    const  uint64_t *  pDrmFormatModifiers;
} VkImageDrmFormatModifierListCreateInfoEXT;

typedef struct VkImageDrmFormatModifierPropertiesEXT {
    VkStructureType   sType;
    void *  pNext;
    uint64_t   drmFormatModifier;
} VkImageDrmFormatModifierPropertiesEXT;

typedef struct VkRenderPassFragmentDensityMapCreateInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkAttachmentReference              fragmentDensityMapAttachment;
} VkRenderPassFragmentDensityMapCreateInfoEXT;

typedef struct VkMemoryPriorityAllocateInfoEXT {
    VkStructureType   sType;
    const  void *                         pNext;
    float                                priority;
} VkMemoryPriorityAllocateInfoEXT;

typedef struct VkBufferDeviceAddressInfo {
    VkStructureType   sType;
    const  void *                                             pNext;
    VkBuffer                                                 buffer;
} VkBufferDeviceAddressInfo;

typedef struct VkBufferDeviceAddressInfo  VkBufferDeviceAddressInfoKHR;

typedef struct VkBufferDeviceAddressInfo  VkBufferDeviceAddressInfoEXT;

typedef struct VkBufferOpaqueCaptureAddressCreateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    uint64_t                           opaqueCaptureAddress;
} VkBufferOpaqueCaptureAddressCreateInfo;

typedef struct VkBufferOpaqueCaptureAddressCreateInfo  VkBufferOpaqueCaptureAddressCreateInfoKHR;

typedef struct VkPhysicalDeviceImageViewImageFormatInfoEXT {
    VkStructureType   sType;
    void *                             pNext;
    VkImageViewType                    imageViewType;
} VkPhysicalDeviceImageViewImageFormatInfoEXT;

typedef struct VkRenderPassAttachmentBeginInfo {
    VkStructureType   sType;
    const  void *                               pNext;
    uint32_t                   attachmentCount;
    const  VkImageView *  pAttachments;
} VkRenderPassAttachmentBeginInfo;

typedef struct VkRenderPassAttachmentBeginInfo  VkRenderPassAttachmentBeginInfoKHR;

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkSurfaceFullScreenExclusiveInfoEXT {
    VkStructureType   sType;
    void *                             pNext;
    VkFullScreenExclusiveEXT           fullScreenExclusive;
} VkSurfaceFullScreenExclusiveInfoEXT;
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkSurfaceFullScreenExclusiveWin32InfoEXT {
    VkStructureType   sType;
    const  void *       pNext;
    HMONITOR           hmonitor;
} VkSurfaceFullScreenExclusiveWin32InfoEXT;
#endif

typedef struct VkPerformanceCounterKHR {
    VkStructureType   sType;
    const  void *                              pNext;
    VkPerformanceCounterUnitKHR          unit;
    VkPerformanceCounterScopeKHR         scope;
    VkPerformanceCounterStorageKHR       storage;
    uint8_t   uuid [ VK_UUID_SIZE ];
} VkPerformanceCounterKHR;

typedef struct VkQueryPoolPerformanceCreateInfoKHR {
    VkStructureType   sType;
    const  void *                              pNext;
    uint32_t                                  queueFamilyIndex;
    uint32_t                                  counterIndexCount;
    const  uint32_t *  pCounterIndices;
} VkQueryPoolPerformanceCreateInfoKHR;

typedef union VkPerformanceCounterResultKHR {
    int32_t    int32;
    int64_t    int64;
    uint32_t   uint32;
    uint64_t   uint64;
    float      float32;
    double     float64;
} VkPerformanceCounterResultKHR;

typedef struct VkPerformanceQuerySubmitInfoKHR {
    VkStructureType   sType;
    const  void *          pNext;
    uint32_t              counterPassIndex;
} VkPerformanceQuerySubmitInfoKHR;

typedef struct VkAttachmentReferenceStencilLayout {
    VkStructureType sType;
    void *     pNext;
    VkImageLayout                    stencilLayout;
} VkAttachmentReferenceStencilLayout;

typedef struct VkAttachmentReferenceStencilLayout  VkAttachmentReferenceStencilLayoutKHR;

typedef struct VkAttachmentDescriptionStencilLayout {
    VkStructureType sType;
    void *     pNext;
    VkImageLayout                    stencilInitialLayout;
    VkImageLayout                    stencilFinalLayout;
} VkAttachmentDescriptionStencilLayout;

typedef struct VkAttachmentDescriptionStencilLayout  VkAttachmentDescriptionStencilLayoutKHR;

typedef struct VkPipelineInfoKHR {
    VkStructureType   sType;
    const  void *         pNext;
    VkPipeline           pipeline;
} VkPipelineInfoKHR;

typedef struct VkPipelineExecutableInfoKHR {
    VkStructureType   sType;
    const  void *         pNext;
    VkPipeline           pipeline;
    uint32_t             executableIndex;
} VkPipelineExecutableInfoKHR;

typedef struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
    VkStructureType   sType;
    void *                   pNext;
    uint32_t                 requiredSubgroupSize;
} VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;

typedef struct VkMemoryOpaqueCaptureAddressAllocateInfo {
    VkStructureType   sType;
    const  void *                    pNext;
    uint64_t                        opaqueCaptureAddress;
} VkMemoryOpaqueCaptureAddressAllocateInfo;

typedef struct VkMemoryOpaqueCaptureAddressAllocateInfo  VkMemoryOpaqueCaptureAddressAllocateInfoKHR;

typedef struct VkDeviceMemoryOpaqueCaptureAddressInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDeviceMemory                     memory;
} VkDeviceMemoryOpaqueCaptureAddressInfo;

typedef struct VkDeviceMemoryOpaqueCaptureAddressInfo  VkDeviceMemoryOpaqueCaptureAddressInfoKHR;

typedef struct VkPhysicalDeviceLineRasterizationPropertiesEXT {
    VkStructureType   sType;
    void *                                pNext;
    uint32_t                              lineSubPixelPrecisionBits;
} VkPhysicalDeviceLineRasterizationPropertiesEXT;

typedef struct VkSamplerCustomBorderColorCreateInfoEXT {
    VkStructureType   sType;
    const  void *                                                                             pNext;
    VkClearColorValue                                                                        customBorderColor;
    VkFormat                                                                                 format;
} VkSamplerCustomBorderColorCreateInfoEXT;

typedef struct VkPhysicalDeviceCustomBorderColorPropertiesEXT {
    VkStructureType   sType;
    void *                                                                    pNext;
    uint32_t                                                                                        maxCustomBorderColorSamplers;
} VkPhysicalDeviceCustomBorderColorPropertiesEXT;

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureBuildOffsetInfoKHR {
    uint32_t                                                  primitiveCount;
    uint32_t                                                  primitiveOffset;
    uint32_t                                  firstVertex;
    uint32_t                                  transformOffset;
} VkAccelerationStructureBuildOffsetInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAabbPositionsKHR {
    float                                                     minX;
    float                                                     minY;
    float                                                     minZ;
    float                                                     maxX;
    float                                                     maxY;
    float                                                     maxZ;
} VkAabbPositionsKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkTransformMatrixKHR {
    float                                                     matrix [3][4];
} VkTransformMatrixKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureDeviceAddressInfoKHR {
    VkStructureType   sType;
    const  void *                                             pNext;
    VkAccelerationStructureKHR                               accelerationStructure;
} VkAccelerationStructureDeviceAddressInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureVersionKHR {
    VkStructureType   sType;
    const  void *                                             pNext;
    const  uint8_t *                     versionData;
} VkAccelerationStructureVersionKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkCopyAccelerationStructureInfoKHR {
    VkStructureType   sType;
    const  void *                                             pNext;
    VkAccelerationStructureKHR                               src;
    VkAccelerationStructureKHR                               dst;
    VkCopyAccelerationStructureModeKHR                       mode;
} VkCopyAccelerationStructureInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkRayTracingPipelineInterfaceCreateInfoKHR {
    VkStructureType   sType;
    const  void *                                             pNext;
    uint32_t                                                 maxPayloadSize;
    uint32_t                                                 maxAttributeSize;
    uint32_t                                                 maxCallableSize;
} VkRayTracingPipelineInterfaceCreateInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkDeferredOperationInfoKHR {
    VkStructureType   sType;
    const  void *                    pNext;
    VkDeferredOperationKHR          operationHandle;
} VkDeferredOperationInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS) || defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkPipelineLibraryCreateInfoKHR {
    VkStructureType   sType;
    const  void *                                             pNext;
    uint32_t                                 libraryCount;
    const  VkPipeline *                    pLibraries;
} VkPipelineLibraryCreateInfoKHR;
#endif

typedef uint32_t VkSampleMask;

typedef uint32_t VkBool32;

typedef uint32_t VkFlags;

typedef uint64_t VkDeviceSize;

typedef uint64_t VkDeviceAddress;

typedef VkFlags VkFramebufferCreateFlags;

typedef VkFlags VkQueryPoolCreateFlags;

typedef VkFlags VkRenderPassCreateFlags;

typedef VkFlags VkSamplerCreateFlags;

typedef VkFlags VkPipelineLayoutCreateFlags;

typedef VkFlags VkPipelineCacheCreateFlags;

typedef VkFlags VkPipelineDepthStencilStateCreateFlags;

typedef VkFlags VkPipelineDynamicStateCreateFlags;

typedef VkFlags VkPipelineColorBlendStateCreateFlags;

typedef VkFlags VkPipelineMultisampleStateCreateFlags;

typedef VkFlags VkPipelineRasterizationStateCreateFlags;

typedef VkFlags VkPipelineViewportStateCreateFlags;

typedef VkFlags VkPipelineTessellationStateCreateFlags;

typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;

typedef VkFlags VkPipelineVertexInputStateCreateFlags;

typedef VkFlags VkPipelineShaderStageCreateFlags;

typedef VkFlags VkDescriptorSetLayoutCreateFlags;

typedef VkFlags VkBufferViewCreateFlags;

typedef VkFlags VkInstanceCreateFlags;

typedef VkFlags VkDeviceCreateFlags;

typedef VkFlags VkDeviceQueueCreateFlags;

typedef VkFlags VkQueueFlags;

typedef VkFlags VkMemoryPropertyFlags;

typedef VkFlags VkMemoryHeapFlags;

typedef VkFlags VkAccessFlags;

typedef VkFlags VkBufferUsageFlags;

typedef VkFlags VkBufferCreateFlags;

typedef VkFlags VkShaderStageFlags;

typedef VkFlags VkImageUsageFlags;

typedef VkFlags VkImageCreateFlags;

typedef VkFlags VkImageViewCreateFlags;

typedef VkFlags VkPipelineCreateFlags;

typedef VkFlags VkColorComponentFlags;

typedef VkFlags VkFenceCreateFlags;

typedef VkFlags VkSemaphoreCreateFlags;

typedef VkFlags VkFormatFeatureFlags;

typedef VkFlags VkQueryControlFlags;

typedef VkFlags VkQueryResultFlags;

typedef VkFlags VkShaderModuleCreateFlags;

typedef VkFlags VkEventCreateFlags;

typedef VkFlags VkCommandPoolCreateFlags;

typedef VkFlags VkCommandPoolResetFlags;

typedef VkFlags VkCommandBufferResetFlags;

typedef VkFlags VkCommandBufferUsageFlags;

typedef VkFlags VkQueryPipelineStatisticFlags;

typedef VkFlags VkMemoryMapFlags;

typedef VkFlags VkImageAspectFlags;

typedef VkFlags VkSparseMemoryBindFlags;

typedef VkFlags VkSparseImageFormatFlags;

typedef VkFlags VkSubpassDescriptionFlags;

typedef VkFlags VkPipelineStageFlags;

typedef VkFlags VkSampleCountFlags;

typedef VkFlags VkAttachmentDescriptionFlags;

typedef VkFlags VkStencilFaceFlags;

typedef VkFlags VkCullModeFlags;

typedef VkFlags VkDescriptorPoolCreateFlags;

typedef VkFlags VkDescriptorPoolResetFlags;

typedef VkFlags VkDependencyFlags;

typedef VkFlags VkSubgroupFeatureFlags;

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkFlags VkGeometryFlagsKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkFlags VkGeometryInstanceFlagsKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkFlags VkBuildAccelerationStructureFlagsKHR;
#endif

typedef VkFlags VkPrivateDataSlotCreateFlagsEXT;

typedef VkFlags VkDescriptorUpdateTemplateCreateFlags;

#define VkDescriptorUpdateTemplateCreateFlagsKHR VkDescriptorUpdateTemplateCreateFlags

typedef VkFlags VkPipelineCreationFeedbackFlagsEXT;

typedef VkFlags VkPerformanceCounterDescriptionFlagsKHR;

typedef VkFlags VkAcquireProfilingLockFlagsKHR;

typedef VkFlags VkSemaphoreWaitFlags;

#define VkSemaphoreWaitFlagsKHR VkSemaphoreWaitFlags

typedef VkFlags VkCompositeAlphaFlagsKHR;

typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;

typedef VkFlags VkSurfaceTransformFlagsKHR;

typedef VkFlags VkSwapchainCreateFlagsKHR;

typedef VkFlags VkDisplayModeCreateFlagsKHR;

typedef VkFlags VkDisplaySurfaceCreateFlagsKHR;

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef VkFlags VkAndroidSurfaceCreateFlagsKHR;
#endif

#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
typedef VkFlags VkWaylandSurfaceCreateFlagsKHR;
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkFlags VkWin32SurfaceCreateFlagsKHR;
#endif

#if defined(VK_USE_PLATFORM_XLIB_KHR)
typedef VkFlags VkXlibSurfaceCreateFlagsKHR;
#endif

#if defined(VK_USE_PLATFORM_XCB_KHR)
typedef VkFlags VkXcbSurfaceCreateFlagsKHR;
#endif

#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
typedef VkFlags VkDirectFBSurfaceCreateFlagsEXT;
#endif

#if defined(VK_USE_PLATFORM_METAL_EXT)
typedef VkFlags VkMetalSurfaceCreateFlagsEXT;
#endif

typedef VkFlags VkHeadlessSurfaceCreateFlagsEXT;

typedef VkFlags VkPeerMemoryFeatureFlags;

#define VkPeerMemoryFeatureFlagsKHR VkPeerMemoryFeatureFlags

typedef VkFlags VkMemoryAllocateFlags;

#define VkMemoryAllocateFlagsKHR VkMemoryAllocateFlags

typedef VkFlags VkDeviceGroupPresentModeFlagsKHR;

typedef VkFlags VkDebugReportFlagsEXT;

typedef VkFlags VkCommandPoolTrimFlags;

#define VkCommandPoolTrimFlagsKHR VkCommandPoolTrimFlags

typedef VkFlags VkExternalMemoryHandleTypeFlags;

#define VkExternalMemoryHandleTypeFlagsKHR VkExternalMemoryHandleTypeFlags

typedef VkFlags VkExternalMemoryFeatureFlags;

#define VkExternalMemoryFeatureFlagsKHR VkExternalMemoryFeatureFlags

typedef VkFlags VkExternalSemaphoreHandleTypeFlags;

#define VkExternalSemaphoreHandleTypeFlagsKHR VkExternalSemaphoreHandleTypeFlags

typedef VkFlags VkExternalSemaphoreFeatureFlags;

#define VkExternalSemaphoreFeatureFlagsKHR VkExternalSemaphoreFeatureFlags

typedef VkFlags VkSemaphoreImportFlags;

#define VkSemaphoreImportFlagsKHR VkSemaphoreImportFlags

typedef VkFlags VkExternalFenceHandleTypeFlags;

#define VkExternalFenceHandleTypeFlagsKHR VkExternalFenceHandleTypeFlags

typedef VkFlags VkExternalFenceFeatureFlags;

#define VkExternalFenceFeatureFlagsKHR VkExternalFenceFeatureFlags

typedef VkFlags VkFenceImportFlags;

#define VkFenceImportFlagsKHR VkFenceImportFlags

typedef VkFlags VkSurfaceCounterFlagsEXT;

typedef VkFlags VkPipelineDiscardRectangleStateCreateFlagsEXT;

typedef VkFlags VkValidationCacheCreateFlagsEXT;

typedef VkFlags VkDebugUtilsMessageSeverityFlagsEXT;

typedef VkFlags VkDebugUtilsMessageTypeFlagsEXT;

typedef VkFlags VkDebugUtilsMessengerCreateFlagsEXT;

typedef VkFlags VkDebugUtilsMessengerCallbackDataFlagsEXT;

typedef VkFlags VkPipelineRasterizationConservativeStateCreateFlagsEXT;

typedef VkFlags VkDescriptorBindingFlags;

#define VkDescriptorBindingFlagsEXT VkDescriptorBindingFlags

typedef VkFlags VkConditionalRenderingFlagsEXT;

typedef VkFlags VkResolveModeFlags;

#define VkResolveModeFlagsKHR VkResolveModeFlags

typedef VkFlags VkPipelineRasterizationStateStreamCreateFlagsEXT;

typedef VkFlags VkPipelineRasterizationDepthClipStateCreateFlagsEXT;

typedef VkFlags VkToolPurposeFlagsEXT;

typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage,
    void*                                       pUserData);

typedef struct VkDeviceQueueCreateInfo {
    VkStructureType   sType;
    const  void *      pNext;
    VkDeviceQueueCreateFlags      flags;
    uint32_t          queueFamilyIndex;
    uint32_t          queueCount;
    const  float *     pQueuePriorities;
} VkDeviceQueueCreateInfo;

typedef struct VkInstanceCreateInfo {
    VkStructureType   sType;
    const  void *      pNext;
    VkInstanceCreateFlags    flags;
    const  VkApplicationInfo *  pApplicationInfo;
    uint32_t                 enabledLayerCount;
    const  char * const*       ppEnabledLayerNames;
    uint32_t                 enabledExtensionCount;
    const  char * const*       ppEnabledExtensionNames;
} VkInstanceCreateInfo;

typedef struct VkQueueFamilyProperties {
    VkQueueFlags             queueFlags;
    uint32_t                 queueCount;
    uint32_t                 timestampValidBits;
    VkExtent3D               minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef struct VkMemoryAllocateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkDeviceSize             allocationSize;
    uint32_t                 memoryTypeIndex;
} VkMemoryAllocateInfo;

typedef struct VkMemoryRequirements {
    VkDeviceSize             size;
    VkDeviceSize             alignment;
    uint32_t                 memoryTypeBits;
} VkMemoryRequirements;

typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags       aspectMask;
    VkExtent3D               imageGranularity;
    VkSparseImageFormatFlags   flags;
} VkSparseImageFormatProperties;

typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties   formatProperties;
    uint32_t                 imageMipTailFirstLod;
    VkDeviceSize             imageMipTailSize;
    VkDeviceSize             imageMipTailOffset;
    VkDeviceSize             imageMipTailStride;
} VkSparseImageMemoryRequirements;

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;

typedef struct VkMemoryHeap {
    VkDeviceSize             size;
    VkMemoryHeapFlags        flags;
} VkMemoryHeap;

typedef struct VkMappedMemoryRange {
    VkStructureType   sType;
    const  void *             pNext;
    VkDeviceMemory           memory;
    VkDeviceSize             offset;
    VkDeviceSize             size;
} VkMappedMemoryRange;

typedef struct VkFormatProperties {
    VkFormatFeatureFlags     linearTilingFeatures;
    VkFormatFeatureFlags     optimalTilingFeatures;
    VkFormatFeatureFlags     bufferFeatures;
} VkFormatProperties;

typedef struct VkImageFormatProperties {
    VkExtent3D               maxExtent;
    uint32_t                 maxMipLevels;
    uint32_t                 maxArrayLayers;
    VkSampleCountFlags       sampleCounts;
    VkDeviceSize             maxResourceSize;
} VkImageFormatProperties;

typedef struct VkDescriptorBufferInfo {
    VkBuffer                 buffer;
    VkDeviceSize             offset;
    VkDeviceSize             range;
} VkDescriptorBufferInfo;

typedef struct VkWriteDescriptorSet {
    VkStructureType   sType;
    const  void *             pNext;
    VkDescriptorSet          dstSet;
    uint32_t                 dstBinding;
    uint32_t                 dstArrayElement;
    uint32_t                 descriptorCount;
    VkDescriptorType         descriptorType;
    const  VkDescriptorImageInfo *  pImageInfo;
    const  VkDescriptorBufferInfo *  pBufferInfo;
    const  VkBufferView *     pTexelBufferView;
} VkWriteDescriptorSet;

typedef struct VkBufferCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkBufferCreateFlags      flags;
    VkDeviceSize             size;
    VkBufferUsageFlags       usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    const  uint32_t *         pQueueFamilyIndices;
} VkBufferCreateInfo;

typedef struct VkBufferViewCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkBufferViewCreateFlags flags;
    VkBuffer                 buffer;
    VkFormat                 format;
    VkDeviceSize             offset;
    VkDeviceSize             range;
} VkBufferViewCreateInfo;

typedef struct VkImageSubresource {
    VkImageAspectFlags       aspectMask;
    uint32_t                 mipLevel;
    uint32_t                 arrayLayer;
} VkImageSubresource;

typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags       aspectMask;
    uint32_t                 mipLevel;
    uint32_t                 baseArrayLayer;
    uint32_t                 layerCount;
} VkImageSubresourceLayers;

typedef struct VkImageSubresourceRange {
    VkImageAspectFlags       aspectMask;
    uint32_t                 baseMipLevel;
    uint32_t                 levelCount;
    uint32_t                 baseArrayLayer;
    uint32_t                 layerCount;
} VkImageSubresourceRange;

typedef struct VkMemoryBarrier {
    VkStructureType   sType;
    const  void *             pNext;
    VkAccessFlags            srcAccessMask;
    VkAccessFlags            dstAccessMask;
} VkMemoryBarrier;

typedef struct VkBufferMemoryBarrier {
    VkStructureType   sType;
    const  void *             pNext;
    VkAccessFlags            srcAccessMask;
    VkAccessFlags            dstAccessMask;
    uint32_t                 srcQueueFamilyIndex;
    uint32_t                 dstQueueFamilyIndex;
    VkBuffer                 buffer;
    VkDeviceSize             offset;
    VkDeviceSize             size;
} VkBufferMemoryBarrier;

typedef struct VkImageMemoryBarrier {
    VkStructureType   sType;
    const  void *             pNext;
    VkAccessFlags            srcAccessMask;
    VkAccessFlags            dstAccessMask;
    VkImageLayout            oldLayout;
    VkImageLayout            newLayout;
    uint32_t                 srcQueueFamilyIndex;
    uint32_t                 dstQueueFamilyIndex;
    VkImage                  image;
    VkImageSubresourceRange   subresourceRange;
} VkImageMemoryBarrier;

typedef struct VkImageCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    const  uint32_t *         pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo;

typedef struct VkSubresourceLayout {
    VkDeviceSize             offset;
    VkDeviceSize             size;
    VkDeviceSize             rowPitch;
    VkDeviceSize             arrayPitch;
    VkDeviceSize             depthPitch;
} VkSubresourceLayout;

typedef struct VkImageViewCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkImageViewCreateFlags   flags;
    VkImage                  image;
    VkImageViewType          viewType;
    VkFormat                 format;
    VkComponentMapping       components;
    VkImageSubresourceRange   subresourceRange;
} VkImageViewCreateInfo;

typedef struct VkBufferCopy {
    VkDeviceSize                         srcOffset;
    VkDeviceSize                         dstOffset;
    VkDeviceSize   size;
} VkBufferCopy;

typedef struct VkSparseMemoryBind {
    VkDeviceSize             resourceOffset;
    VkDeviceSize             size;
    VkDeviceMemory           memory;
    VkDeviceSize             memoryOffset;
    VkSparseMemoryBindFlags flags;
} VkSparseMemoryBind;

typedef struct VkSparseImageMemoryBind {
    VkImageSubresource       subresource;
    VkOffset3D               offset;
    VkExtent3D               extent;
    VkDeviceMemory           memory;
    VkDeviceSize             memoryOffset;
    VkSparseMemoryBindFlags flags;
} VkSparseImageMemoryBind;

typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer   buffer;
    uint32_t                 bindCount;
    const  VkSparseMemoryBind *  pBinds;
} VkSparseBufferMemoryBindInfo;

typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage   image;
    uint32_t                 bindCount;
    const  VkSparseMemoryBind *  pBinds;
} VkSparseImageOpaqueMemoryBindInfo;

typedef struct VkSparseImageMemoryBindInfo {
    VkImage   image;
    uint32_t                 bindCount;
    const  VkSparseImageMemoryBind *  pBinds;
} VkSparseImageMemoryBindInfo;

typedef struct VkBindSparseInfo {
    VkStructureType   sType;
    const  void *             pNext;
    uint32_t                 waitSemaphoreCount;
    const  VkSemaphore *      pWaitSemaphores;
    uint32_t                 bufferBindCount;
    const  VkSparseBufferMemoryBindInfo *  pBufferBinds;
    uint32_t                 imageOpaqueBindCount;
    const  VkSparseImageOpaqueMemoryBindInfo *  pImageOpaqueBinds;
    uint32_t                 imageBindCount;
    const  VkSparseImageMemoryBindInfo *  pImageBinds;
    uint32_t                 signalSemaphoreCount;
    const  VkSemaphore *      pSignalSemaphores;
} VkBindSparseInfo;

typedef struct VkImageCopy {
    VkImageSubresourceLayers   srcSubresource;
    VkOffset3D               srcOffset;
    VkImageSubresourceLayers   dstSubresource;
    VkOffset3D               dstOffset;
    VkExtent3D               extent;
} VkImageCopy;

typedef struct VkImageBlit {
    VkImageSubresourceLayers   srcSubresource;
    VkOffset3D               srcOffsets [2];
    VkImageSubresourceLayers   dstSubresource;
    VkOffset3D               dstOffsets [2];
} VkImageBlit;

typedef struct VkBufferImageCopy {
    VkDeviceSize             bufferOffset;
    uint32_t                 bufferRowLength;
    uint32_t                 bufferImageHeight;
    VkImageSubresourceLayers   imageSubresource;
    VkOffset3D               imageOffset;
    VkExtent3D               imageExtent;
} VkBufferImageCopy;

typedef struct VkImageResolve {
    VkImageSubresourceLayers   srcSubresource;
    VkOffset3D               srcOffset;
    VkImageSubresourceLayers   dstSubresource;
    VkOffset3D               dstOffset;
    VkExtent3D               extent;
} VkImageResolve;

typedef struct VkShaderModuleCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkShaderModuleCreateFlags   flags;
    size_t                   codeSize;
    const  uint32_t *             pCode;
} VkShaderModuleCreateInfo;

typedef struct VkDescriptorSetLayoutBinding {
    uint32_t                 binding;
    VkDescriptorType         descriptorType;
    uint32_t   descriptorCount;
    VkShaderStageFlags       stageFlags;
    const  VkSampler *        pImmutableSamplers;
} VkDescriptorSetLayoutBinding;

typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkDescriptorSetLayoutCreateFlags      flags;
    uint32_t                 bindingCount;
    const  VkDescriptorSetLayoutBinding *  pBindings;
} VkDescriptorSetLayoutCreateInfo;

typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                 maxSets;
    uint32_t                 poolSizeCount;
    const  VkDescriptorPoolSize *  pPoolSizes;
} VkDescriptorPoolCreateInfo;

typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineShaderStageCreateFlags      flags;
    VkShaderStageFlagBits    stage;
    VkShaderModule           module;
    const  char *             pName;
    const  VkSpecializationInfo *  pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;

typedef struct VkComputePipelineCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineCreateFlags    flags;
    VkPipelineShaderStageCreateInfo   stage;
    VkPipelineLayout         layout;
    VkPipeline        basePipelineHandle;
    int32_t                  basePipelineIndex;
} VkComputePipelineCreateInfo;

typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineVertexInputStateCreateFlags      flags;
    uint32_t                 vertexBindingDescriptionCount;
    const  VkVertexInputBindingDescription *  pVertexBindingDescriptions;
    uint32_t                 vertexAttributeDescriptionCount;
    const  VkVertexInputAttributeDescription *  pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;

typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineInputAssemblyStateCreateFlags      flags;
    VkPrimitiveTopology      topology;
    VkBool32                 primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;

typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineTessellationStateCreateFlags      flags;
    uint32_t                 patchControlPoints;
} VkPipelineTessellationStateCreateInfo;

typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineViewportStateCreateFlags      flags;
    uint32_t                 viewportCount;
    const  VkViewport *       pViewports;
    uint32_t                 scissorCount;
    const  VkRect2D *         pScissors;
} VkPipelineViewportStateCreateInfo;

typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType   sType;
    const  void *  pNext;
    VkPipelineRasterizationStateCreateFlags      flags;
    VkBool32                 depthClampEnable;
    VkBool32                 rasterizerDiscardEnable;
    VkPolygonMode            polygonMode;
    VkCullModeFlags          cullMode;
    VkFrontFace              frontFace;
    VkBool32                 depthBiasEnable;
    float                    depthBiasConstantFactor;
    float                    depthBiasClamp;
    float                    depthBiasSlopeFactor;
    float                    lineWidth;
} VkPipelineRasterizationStateCreateInfo;

typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineMultisampleStateCreateFlags      flags;
    VkSampleCountFlagBits    rasterizationSamples;
    VkBool32                 sampleShadingEnable;
    float                    minSampleShading;
    const  VkSampleMask *     pSampleMask;
    VkBool32                 alphaToCoverageEnable;
    VkBool32                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo;

typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState;

typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineColorBlendStateCreateFlags      flags;
    VkBool32                 logicOpEnable;
    VkLogicOp                logicOp;
    uint32_t                 attachmentCount;
    const  VkPipelineColorBlendAttachmentState *  pAttachments;
    float                    blendConstants [4];
} VkPipelineColorBlendStateCreateInfo;

typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineDynamicStateCreateFlags      flags;
    uint32_t                 dynamicStateCount;
    const  VkDynamicState *   pDynamicStates;
} VkPipelineDynamicStateCreateInfo;

typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineDepthStencilStateCreateFlags      flags;
    VkBool32                 depthTestEnable;
    VkBool32                 depthWriteEnable;
    VkCompareOp              depthCompareOp;
    VkBool32                 depthBoundsTestEnable;
    VkBool32                 stencilTestEnable;
    VkStencilOpState         front;
    VkStencilOpState         back;
    float                    minDepthBounds;
    float                    maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo;

typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineCreateFlags    flags;
    uint32_t                 stageCount;
    const  VkPipelineShaderStageCreateInfo *  pStages;
    const  VkPipelineVertexInputStateCreateInfo *  pVertexInputState;
    const  VkPipelineInputAssemblyStateCreateInfo *  pInputAssemblyState;
    const  VkPipelineTessellationStateCreateInfo *  pTessellationState;
    const  VkPipelineViewportStateCreateInfo *  pViewportState;
    const  VkPipelineRasterizationStateCreateInfo *  pRasterizationState;
    const  VkPipelineMultisampleStateCreateInfo *  pMultisampleState;
    const  VkPipelineDepthStencilStateCreateInfo *  pDepthStencilState;
    const  VkPipelineColorBlendStateCreateInfo *  pColorBlendState;
    const  VkPipelineDynamicStateCreateInfo *  pDynamicState;
    VkPipelineLayout         layout;
    VkRenderPass             renderPass;
    uint32_t                 subpass;
    VkPipeline        basePipelineHandle;
    int32_t                  basePipelineIndex;
} VkGraphicsPipelineCreateInfo;

typedef struct VkPipelineCacheCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineCacheCreateFlags      flags;
    size_t                   initialDataSize;
    const  void *             pInitialData;
} VkPipelineCacheCreateInfo;

typedef struct VkPushConstantRange {
    VkShaderStageFlags       stageFlags;
    uint32_t                 offset;
    uint32_t                 size;
} VkPushConstantRange;

typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineLayoutCreateFlags      flags;
    uint32_t                 setLayoutCount;
    const  VkDescriptorSetLayout *  pSetLayouts;
    uint32_t                 pushConstantRangeCount;
    const  VkPushConstantRange *  pPushConstantRanges;
} VkPipelineLayoutCreateInfo;

typedef struct VkSamplerCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkSamplerCreateFlags     flags;
    VkFilter                 magFilter;
    VkFilter                 minFilter;
    VkSamplerMipmapMode      mipmapMode;
    VkSamplerAddressMode     addressModeU;
    VkSamplerAddressMode     addressModeV;
    VkSamplerAddressMode     addressModeW;
    float                    mipLodBias;
    VkBool32                 anisotropyEnable;
    float                    maxAnisotropy;
    VkBool32                 compareEnable;
    VkCompareOp              compareOp;
    float                    minLod;
    float                    maxLod;
    VkBorderColor            borderColor;
    VkBool32                 unnormalizedCoordinates;
} VkSamplerCreateInfo;

typedef struct VkCommandPoolCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkCommandPoolCreateFlags     flags;
    uint32_t                 queueFamilyIndex;
} VkCommandPoolCreateInfo;

typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkRenderPass      renderPass;
    uint32_t                 subpass;
    VkFramebuffer     framebuffer;
    VkBool32                 occlusionQueryEnable;
    VkQueryControlFlags      queryFlags;
    VkQueryPipelineStatisticFlags   pipelineStatistics;
} VkCommandBufferInheritanceInfo;

typedef struct VkCommandBufferBeginInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkCommandBufferUsageFlags    flags;
    const  VkCommandBufferInheritanceInfo *        pInheritanceInfo;
} VkCommandBufferBeginInfo;

typedef struct VkRenderPassBeginInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkRenderPass             renderPass;
    VkFramebuffer            framebuffer;
    VkRect2D                 renderArea;
    uint32_t                 clearValueCount;
    const  VkClearValue *     pClearValues;
} VkRenderPassBeginInfo;

typedef struct VkClearAttachment {
    VkImageAspectFlags       aspectMask;
    uint32_t                 colorAttachment;
    VkClearValue             clearValue;
} VkClearAttachment;

typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags   flags;
    VkFormat                 format;
    VkSampleCountFlagBits    samples;
    VkAttachmentLoadOp       loadOp;
    VkAttachmentStoreOp      storeOp;
    VkAttachmentLoadOp       stencilLoadOp;
    VkAttachmentStoreOp      stencilStoreOp;
    VkImageLayout            initialLayout;
    VkImageLayout            finalLayout;
} VkAttachmentDescription;

typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags   flags;
    VkPipelineBindPoint      pipelineBindPoint;
    uint32_t                 inputAttachmentCount;
    const  VkAttachmentReference *  pInputAttachments;
    uint32_t                 colorAttachmentCount;
    const  VkAttachmentReference *  pColorAttachments;
    const  VkAttachmentReference *  pResolveAttachments;
    const  VkAttachmentReference *  pDepthStencilAttachment;
    uint32_t                 preserveAttachmentCount;
    const  uint32_t *  pPreserveAttachments;
} VkSubpassDescription;

typedef struct VkSubpassDependency {
    uint32_t                 srcSubpass;
    uint32_t                 dstSubpass;
    VkPipelineStageFlags     srcStageMask;
    VkPipelineStageFlags     dstStageMask;
    VkAccessFlags            srcAccessMask;
    VkAccessFlags            dstAccessMask;
    VkDependencyFlags        dependencyFlags;
} VkSubpassDependency;

typedef struct VkRenderPassCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkRenderPassCreateFlags   flags;
    uint32_t     attachmentCount;
    const  VkAttachmentDescription *  pAttachments;
    uint32_t                 subpassCount;
    const  VkSubpassDescription *  pSubpasses;
    uint32_t         dependencyCount;
    const  VkSubpassDependency *  pDependencies;
} VkRenderPassCreateInfo;

typedef struct VkEventCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkEventCreateFlags       flags;
} VkEventCreateInfo;

typedef struct VkFenceCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkFenceCreateFlags       flags;
} VkFenceCreateInfo;

typedef struct VkPhysicalDeviceFeatures {
    VkBool32                 robustBufferAccess;
    VkBool32                 fullDrawIndexUint32;
    VkBool32                 imageCubeArray;
    VkBool32                 independentBlend;
    VkBool32                 geometryShader;
    VkBool32                 tessellationShader;
    VkBool32                 sampleRateShading;
    VkBool32                 dualSrcBlend;
    VkBool32                 logicOp;
    VkBool32                 multiDrawIndirect;
    VkBool32                 drawIndirectFirstInstance;
    VkBool32                 depthClamp;
    VkBool32                 depthBiasClamp;
    VkBool32                 fillModeNonSolid;
    VkBool32                 depthBounds;
    VkBool32                 wideLines;
    VkBool32                 largePoints;
    VkBool32                 alphaToOne;
    VkBool32                 multiViewport;
    VkBool32                 samplerAnisotropy;
    VkBool32                 textureCompressionETC2;
    VkBool32                 textureCompressionASTC_LDR;
    VkBool32                 textureCompressionBC;
    VkBool32                 occlusionQueryPrecise;
    VkBool32                 pipelineStatisticsQuery;
    VkBool32                 vertexPipelineStoresAndAtomics;
    VkBool32                 fragmentStoresAndAtomics;
    VkBool32                 shaderTessellationAndGeometryPointSize;
    VkBool32                 shaderImageGatherExtended;
    VkBool32                 shaderStorageImageExtendedFormats;
    VkBool32                 shaderStorageImageMultisample;
    VkBool32                 shaderStorageImageReadWithoutFormat;
    VkBool32                 shaderStorageImageWriteWithoutFormat;
    VkBool32                 shaderUniformBufferArrayDynamicIndexing;
    VkBool32                 shaderSampledImageArrayDynamicIndexing;
    VkBool32                 shaderStorageBufferArrayDynamicIndexing;
    VkBool32                 shaderStorageImageArrayDynamicIndexing;
    VkBool32                 shaderClipDistance;
    VkBool32                 shaderCullDistance;
    VkBool32                 shaderFloat64;
    VkBool32                 shaderInt64;
    VkBool32                 shaderInt16;
    VkBool32                 shaderResourceResidency;
    VkBool32                 shaderResourceMinLod;
    VkBool32                 sparseBinding;
    VkBool32                 sparseResidencyBuffer;
    VkBool32                 sparseResidencyImage2D;
    VkBool32                 sparseResidencyImage3D;
    VkBool32                 sparseResidency2Samples;
    VkBool32                 sparseResidency4Samples;
    VkBool32                 sparseResidency8Samples;
    VkBool32                 sparseResidency16Samples;
    VkBool32                 sparseResidencyAliased;
    VkBool32                 variableMultisampleRate;
    VkBool32                 inheritedQueries;
} VkPhysicalDeviceFeatures;

typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32                 residencyStandard2DBlockShape;
    VkBool32                 residencyStandard2DMultisampleBlockShape;
    VkBool32                 residencyStandard3DBlockShape;
    VkBool32                 residencyAlignedMipSize;
    VkBool32                 residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;

typedef struct VkPhysicalDeviceLimits {
    uint32_t                 maxImageDimension1D;
    uint32_t                 maxImageDimension2D;
    uint32_t                 maxImageDimension3D;
    uint32_t                 maxImageDimensionCube;
    uint32_t                 maxImageArrayLayers;
    uint32_t                 maxTexelBufferElements;
    uint32_t                 maxUniformBufferRange;
    uint32_t                 maxStorageBufferRange;
    uint32_t                 maxPushConstantsSize;
    uint32_t                 maxMemoryAllocationCount;
    uint32_t                 maxSamplerAllocationCount;
    VkDeviceSize             bufferImageGranularity;
    VkDeviceSize             sparseAddressSpaceSize;
    uint32_t                 maxBoundDescriptorSets;
    uint32_t                 maxPerStageDescriptorSamplers;
    uint32_t                 maxPerStageDescriptorUniformBuffers;
    uint32_t                 maxPerStageDescriptorStorageBuffers;
    uint32_t                 maxPerStageDescriptorSampledImages;
    uint32_t                 maxPerStageDescriptorStorageImages;
    uint32_t                 maxPerStageDescriptorInputAttachments;
    uint32_t                 maxPerStageResources;
    uint32_t                 maxDescriptorSetSamplers;
    uint32_t                 maxDescriptorSetUniformBuffers;
    uint32_t                 maxDescriptorSetUniformBuffersDynamic;
    uint32_t                 maxDescriptorSetStorageBuffers;
    uint32_t                 maxDescriptorSetStorageBuffersDynamic;
    uint32_t                 maxDescriptorSetSampledImages;
    uint32_t                 maxDescriptorSetStorageImages;
    uint32_t                 maxDescriptorSetInputAttachments;
    uint32_t                 maxVertexInputAttributes;
    uint32_t                 maxVertexInputBindings;
    uint32_t                 maxVertexInputAttributeOffset;
    uint32_t                 maxVertexInputBindingStride;
    uint32_t                 maxVertexOutputComponents;
    uint32_t                 maxTessellationGenerationLevel;
    uint32_t                 maxTessellationPatchSize;
    uint32_t                 maxTessellationControlPerVertexInputComponents;
    uint32_t                 maxTessellationControlPerVertexOutputComponents;
    uint32_t                 maxTessellationControlPerPatchOutputComponents;
    uint32_t                 maxTessellationControlTotalOutputComponents;
    uint32_t                 maxTessellationEvaluationInputComponents;
    uint32_t                 maxTessellationEvaluationOutputComponents;
    uint32_t                 maxGeometryShaderInvocations;
    uint32_t                 maxGeometryInputComponents;
    uint32_t                 maxGeometryOutputComponents;
    uint32_t                 maxGeometryOutputVertices;
    uint32_t                 maxGeometryTotalOutputComponents;
    uint32_t                 maxFragmentInputComponents;
    uint32_t                 maxFragmentOutputAttachments;
    uint32_t                 maxFragmentDualSrcAttachments;
    uint32_t                 maxFragmentCombinedOutputResources;
    uint32_t                 maxComputeSharedMemorySize;
    uint32_t                 maxComputeWorkGroupCount [3];
    uint32_t                 maxComputeWorkGroupInvocations;
    uint32_t                 maxComputeWorkGroupSize [3];
    uint32_t                 subPixelPrecisionBits;
    uint32_t                 subTexelPrecisionBits;
    uint32_t                 mipmapPrecisionBits;
    uint32_t                 maxDrawIndexedIndexValue;
    uint32_t                 maxDrawIndirectCount;
    float                    maxSamplerLodBias;
    float                    maxSamplerAnisotropy;
    uint32_t                 maxViewports;
    uint32_t                 maxViewportDimensions [2];
    float                    viewportBoundsRange [2];
    uint32_t                 viewportSubPixelBits;
    size_t                   minMemoryMapAlignment;
    VkDeviceSize             minTexelBufferOffsetAlignment;
    VkDeviceSize             minUniformBufferOffsetAlignment;
    VkDeviceSize             minStorageBufferOffsetAlignment;
    int32_t                  minTexelOffset;
    uint32_t                 maxTexelOffset;
    int32_t                  minTexelGatherOffset;
    uint32_t                 maxTexelGatherOffset;
    float                    minInterpolationOffset;
    float                    maxInterpolationOffset;
    uint32_t                 subPixelInterpolationOffsetBits;
    uint32_t                 maxFramebufferWidth;
    uint32_t                 maxFramebufferHeight;
    uint32_t                 maxFramebufferLayers;
    VkSampleCountFlags       framebufferColorSampleCounts;
    VkSampleCountFlags       framebufferDepthSampleCounts;
    VkSampleCountFlags       framebufferStencilSampleCounts;
    VkSampleCountFlags       framebufferNoAttachmentsSampleCounts;
    uint32_t                 maxColorAttachments;
    VkSampleCountFlags       sampledImageColorSampleCounts;
    VkSampleCountFlags       sampledImageIntegerSampleCounts;
    VkSampleCountFlags       sampledImageDepthSampleCounts;
    VkSampleCountFlags       sampledImageStencilSampleCounts;
    VkSampleCountFlags       storageImageSampleCounts;
    uint32_t                 maxSampleMaskWords;
    VkBool32                 timestampComputeAndGraphics;
    float                    timestampPeriod;
    uint32_t                 maxClipDistances;
    uint32_t                 maxCullDistances;
    uint32_t                 maxCombinedClipAndCullDistances;
    uint32_t                 discreteQueuePriorities;
    float                    pointSizeRange [2];
    float                    lineWidthRange [2];
    float                    pointSizeGranularity;
    float                    lineWidthGranularity;
    VkBool32                 strictLines;
    VkBool32                 standardSampleLocations;
    VkDeviceSize             optimalBufferCopyOffsetAlignment;
    VkDeviceSize             optimalBufferCopyRowPitchAlignment;
    VkDeviceSize             nonCoherentAtomSize;
} VkPhysicalDeviceLimits;

typedef struct VkSemaphoreCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkSemaphoreCreateFlags   flags;
} VkSemaphoreCreateInfo;

typedef struct VkQueryPoolCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkQueryPoolCreateFlags   flags;
    VkQueryType              queryType;
    uint32_t                 queryCount;
    VkQueryPipelineStatisticFlags   pipelineStatistics;
} VkQueryPoolCreateInfo;

typedef struct VkFramebufferCreateInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkFramebufferCreateFlags      flags;
    VkRenderPass             renderPass;
    uint32_t                 attachmentCount;
    const  VkImageView *      pAttachments;
    uint32_t                 width;
    uint32_t                 height;
    uint32_t                 layers;
} VkFramebufferCreateInfo;

typedef struct VkSubmitInfo {
    VkStructureType   sType;
    const  void *  pNext;
    uint32_t         waitSemaphoreCount;
    const  VkSemaphore *      pWaitSemaphores;
    const  VkPipelineStageFlags *            pWaitDstStageMask;
    uint32_t         commandBufferCount;
    const  VkCommandBuffer *      pCommandBuffers;
    uint32_t         signalSemaphoreCount;
    const  VkSemaphore *      pSignalSemaphores;
} VkSubmitInfo;

typedef struct VkDisplayPropertiesKHR {
    VkDisplayKHR                       display;
    const  char *                       displayName;
    VkExtent2D                         physicalDimensions;
    VkExtent2D                         physicalResolution;
    VkSurfaceTransformFlagsKHR         supportedTransforms;
    VkBool32                           planeReorderPossible;
    VkBool32                           persistentContent;
} VkDisplayPropertiesKHR;

typedef struct VkDisplayModeCreateInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDisplayModeCreateFlagsKHR        flags;
    VkDisplayModeParametersKHR         parameters;
} VkDisplayModeCreateInfoKHR;

typedef struct VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR        supportedAlpha;
    VkOffset2D                         minSrcPosition;
    VkOffset2D                         maxSrcPosition;
    VkExtent2D                         minSrcExtent;
    VkExtent2D                         maxSrcExtent;
    VkOffset2D                         minDstPosition;
    VkOffset2D                         maxDstPosition;
    VkExtent2D                         minDstExtent;
    VkExtent2D                         maxDstExtent;
} VkDisplayPlaneCapabilitiesKHR;

typedef struct VkDisplaySurfaceCreateInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDisplaySurfaceCreateFlagsKHR     flags;
    VkDisplayModeKHR                   displayMode;
    uint32_t                           planeIndex;
    uint32_t                           planeStackIndex;
    VkSurfaceTransformFlagBitsKHR      transform;
    float                              globalAlpha;
    VkDisplayPlaneAlphaFlagBitsKHR     alphaMode;
    VkExtent2D                         imageExtent;
} VkDisplaySurfaceCreateInfoKHR;

typedef struct VkDisplayPresentInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkRect2D                           srcRect;
    VkRect2D                           dstRect;
    VkBool32                           persistent;
} VkDisplayPresentInfoKHR;

typedef struct VkSurfaceCapabilitiesKHR {
    uint32_t                           minImageCount;
    uint32_t                           maxImageCount;
    VkExtent2D                         currentExtent;
    VkExtent2D                         minImageExtent;
    VkExtent2D                         maxImageExtent;
    uint32_t                           maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR         supportedTransforms;
    VkSurfaceTransformFlagBitsKHR      currentTransform;
    VkCompositeAlphaFlagsKHR           supportedCompositeAlpha;
    VkImageUsageFlags                  supportedUsageFlags;
} VkSurfaceCapabilitiesKHR;

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef struct VkAndroidSurfaceCreateInfoKHR {
    VkStructureType   sType;
    const  void *                                     pNext;
    VkAndroidSurfaceCreateFlagsKHR   flags;
    struct  ANativeWindow *     window;
} VkAndroidSurfaceCreateInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
typedef struct VkWaylandSurfaceCreateInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkWaylandSurfaceCreateFlagsKHR     flags;
    struct  wl_display *                display;
    struct  wl_surface *                surface;
} VkWaylandSurfaceCreateInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkWin32SurfaceCreateInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkWin32SurfaceCreateFlagsKHR     flags;
    HINSTANCE                          hinstance;
    HWND                               hwnd;
} VkWin32SurfaceCreateInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_XLIB_KHR)
typedef struct VkXlibSurfaceCreateInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkXlibSurfaceCreateFlagsKHR     flags;
    Display *                          dpy;
    Window                             window;
} VkXlibSurfaceCreateInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_XCB_KHR)
typedef struct VkXcbSurfaceCreateInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkXcbSurfaceCreateFlagsKHR     flags;
    xcb_connection_t *                 connection;
    xcb_window_t                       window;
} VkXcbSurfaceCreateInfoKHR;
#endif

#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
typedef struct VkDirectFBSurfaceCreateInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDirectFBSurfaceCreateFlagsEXT     flags;
    IDirectFB *                        dfb;
    IDirectFBSurface *                 surface;
} VkDirectFBSurfaceCreateInfoEXT;
#endif

typedef struct VkSwapchainCreateInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSwapchainCreateFlagsKHR          flags;
    VkSurfaceKHR                       surface;
    uint32_t                           minImageCount;
    VkFormat                           imageFormat;
    VkColorSpaceKHR                    imageColorSpace;
    VkExtent2D                         imageExtent;
    uint32_t                           imageArrayLayers;
    VkImageUsageFlags                  imageUsage;
    VkSharingMode                      imageSharingMode;
    uint32_t           queueFamilyIndexCount;
    const  uint32_t *                   pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR      preTransform;
    VkCompositeAlphaFlagBitsKHR        compositeAlpha;
    VkPresentModeKHR                   presentMode;
    VkBool32                           clipped;
    VkSwapchainKHR     oldSwapchain;
} VkSwapchainCreateInfoKHR;

typedef struct VkDebugReportCallbackCreateInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDebugReportFlagsEXT              flags;
    PFN_vkDebugReportCallbackEXT       pfnCallback;
    void *             pUserData;
} VkDebugReportCallbackCreateInfoEXT;

typedef struct VkPrivateDataSlotCreateInfoEXT {
    VkStructureType   sType;
    const  void *                             pNext;
    VkPrivateDataSlotCreateFlagsEXT          flags;
} VkPrivateDataSlotCreateInfoEXT;

typedef struct VkPhysicalDevicePrivateDataFeaturesEXT {
    VkStructureType   sType;
    void *                                   pNext;
    VkBool32                                 privateData;
} VkPhysicalDevicePrivateDataFeaturesEXT;

typedef struct VkPhysicalDeviceFeatures2 {
    VkStructureType   sType;
    void *                             pNext;
    VkPhysicalDeviceFeatures           features;
} VkPhysicalDeviceFeatures2;

typedef struct VkPhysicalDeviceFeatures2  VkPhysicalDeviceFeatures2KHR;

typedef struct VkFormatProperties2 {
    VkStructureType   sType;
    void *                             pNext;
    VkFormatProperties                 formatProperties;
} VkFormatProperties2;

typedef struct VkFormatProperties2  VkFormatProperties2KHR;

typedef struct VkImageFormatProperties2 {
    VkStructureType   sType;
    void *  pNext;
    VkImageFormatProperties            imageFormatProperties;
} VkImageFormatProperties2;

typedef struct VkImageFormatProperties2  VkImageFormatProperties2KHR;

typedef struct VkPhysicalDeviceImageFormatInfo2 {
    VkStructureType   sType;
    const  void *  pNext;
    VkFormat                           format;
    VkImageType                        type;
    VkImageTiling                      tiling;
    VkImageUsageFlags                  usage;
    VkImageCreateFlags   flags;
} VkPhysicalDeviceImageFormatInfo2;

typedef struct VkPhysicalDeviceImageFormatInfo2  VkPhysicalDeviceImageFormatInfo2KHR;

typedef struct VkQueueFamilyProperties2 {
    VkStructureType   sType;
    void *                             pNext;
    VkQueueFamilyProperties            queueFamilyProperties;
} VkQueueFamilyProperties2;

typedef struct VkQueueFamilyProperties2  VkQueueFamilyProperties2KHR;

typedef struct VkSparseImageFormatProperties2 {
    VkStructureType   sType;
    void *                             pNext;
    VkSparseImageFormatProperties      properties;
} VkSparseImageFormatProperties2;

typedef struct VkSparseImageFormatProperties2  VkSparseImageFormatProperties2KHR;

typedef struct VkPhysicalDeviceSparseImageFormatInfo2 {
    VkStructureType   sType;
    const  void *                       pNext;
    VkFormat                           format;
    VkImageType                        type;
    VkSampleCountFlagBits              samples;
    VkImageUsageFlags                  usage;
    VkImageTiling                      tiling;
} VkPhysicalDeviceSparseImageFormatInfo2;

typedef struct VkPhysicalDeviceSparseImageFormatInfo2  VkPhysicalDeviceSparseImageFormatInfo2KHR;

typedef struct VkPresentRegionKHR {
    uint32_t           rectangleCount;
    const  VkRectLayerKHR *    pRectangles;
} VkPresentRegionKHR;

typedef struct VkPhysicalDeviceVariablePointersFeatures {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                           variablePointersStorageBuffer;
    VkBool32                           variablePointers;
} VkPhysicalDeviceVariablePointersFeatures;

typedef struct VkPhysicalDeviceVariablePointersFeatures  VkPhysicalDeviceVariablePointersFeaturesKHR;

typedef struct VkPhysicalDeviceVariablePointersFeatures  VkPhysicalDeviceVariablePointerFeaturesKHR;

typedef struct VkPhysicalDeviceVariablePointersFeatures  VkPhysicalDeviceVariablePointerFeatures;

typedef struct VkExternalMemoryProperties {
    VkExternalMemoryFeatureFlags    externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlags   exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlags   compatibleHandleTypes;
} VkExternalMemoryProperties;

typedef struct VkExternalMemoryProperties  VkExternalMemoryPropertiesKHR;

typedef struct VkExternalImageFormatProperties {
    VkStructureType   sType;
    void *                             pNext;
    VkExternalMemoryProperties   externalMemoryProperties;
} VkExternalImageFormatProperties;

typedef struct VkExternalImageFormatProperties  VkExternalImageFormatPropertiesKHR;

typedef struct VkPhysicalDeviceExternalBufferInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkBufferCreateFlags   flags;
    VkBufferUsageFlags                 usage;
    VkExternalMemoryHandleTypeFlagBits   handleType;
} VkPhysicalDeviceExternalBufferInfo;

typedef struct VkPhysicalDeviceExternalBufferInfo  VkPhysicalDeviceExternalBufferInfoKHR;

typedef struct VkExternalBufferProperties {
    VkStructureType   sType;
    void *                             pNext;
    VkExternalMemoryProperties      externalMemoryProperties;
} VkExternalBufferProperties;

typedef struct VkExternalBufferProperties  VkExternalBufferPropertiesKHR;

typedef struct VkPhysicalDeviceIDProperties {
    VkStructureType   sType;
    void *                             pNext;
    uint8_t                            deviceUUID [ VK_UUID_SIZE ];
    uint8_t                            driverUUID [ VK_UUID_SIZE ];
    uint8_t                            deviceLUID [ VK_LUID_SIZE ];
    uint32_t                           deviceNodeMask;
    VkBool32                           deviceLUIDValid;
} VkPhysicalDeviceIDProperties;

typedef struct VkPhysicalDeviceIDProperties  VkPhysicalDeviceIDPropertiesKHR;

typedef struct VkExternalMemoryImageCreateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalMemoryHandleTypeFlags   handleTypes;
} VkExternalMemoryImageCreateInfo;

typedef struct VkExternalMemoryImageCreateInfo  VkExternalMemoryImageCreateInfoKHR;

typedef struct VkExternalMemoryBufferCreateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalMemoryHandleTypeFlags   handleTypes;
} VkExternalMemoryBufferCreateInfo;

typedef struct VkExternalMemoryBufferCreateInfo  VkExternalMemoryBufferCreateInfoKHR;

typedef struct VkExportMemoryAllocateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalMemoryHandleTypeFlags   handleTypes;
} VkExportMemoryAllocateInfo;

typedef struct VkExportMemoryAllocateInfo  VkExportMemoryAllocateInfoKHR;

typedef struct VkExternalSemaphoreProperties {
    VkStructureType   sType;
    void *                             pNext;
    VkExternalSemaphoreHandleTypeFlags   exportFromImportedHandleTypes;
    VkExternalSemaphoreHandleTypeFlags   compatibleHandleTypes;
    VkExternalSemaphoreFeatureFlags   externalSemaphoreFeatures;
} VkExternalSemaphoreProperties;

typedef struct VkExternalSemaphoreProperties  VkExternalSemaphorePropertiesKHR;

typedef struct VkExportSemaphoreCreateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalSemaphoreHandleTypeFlags   handleTypes;
} VkExportSemaphoreCreateInfo;

typedef struct VkExportSemaphoreCreateInfo  VkExportSemaphoreCreateInfoKHR;

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkImportSemaphoreWin32HandleInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSemaphore      semaphore;
    VkSemaphoreImportFlags   flags;
    VkExternalSemaphoreHandleTypeFlagBits   handleType;
    HANDLE             handle;
    LPCWSTR            name;
} VkImportSemaphoreWin32HandleInfoKHR;
#endif

typedef struct VkImportSemaphoreFdInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSemaphore      semaphore;
    VkSemaphoreImportFlags   flags;
    VkExternalSemaphoreHandleTypeFlagBits   handleType;
    int                                fd;
} VkImportSemaphoreFdInfoKHR;

typedef struct VkExternalFenceProperties {
    VkStructureType   sType;
    void *                             pNext;
    VkExternalFenceHandleTypeFlags   exportFromImportedHandleTypes;
    VkExternalFenceHandleTypeFlags   compatibleHandleTypes;
    VkExternalFenceFeatureFlags   externalFenceFeatures;
} VkExternalFenceProperties;

typedef struct VkExternalFenceProperties  VkExternalFencePropertiesKHR;

typedef struct VkExportFenceCreateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkExternalFenceHandleTypeFlags   handleTypes;
} VkExportFenceCreateInfo;

typedef struct VkExportFenceCreateInfo  VkExportFenceCreateInfoKHR;

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkImportFenceWin32HandleInfoKHR {
    VkStructureType   sType;
    const  void *                                         pNext;
    VkFence                            fence;
    VkFenceImportFlags                flags;
    VkExternalFenceHandleTypeFlagBits    handleType;
    HANDLE                               handle;
    LPCWSTR                              name;
} VkImportFenceWin32HandleInfoKHR;
#endif

typedef struct VkImportFenceFdInfoKHR {
    VkStructureType   sType;
    const  void *                             pNext;
    VkFence                fence;
    VkFenceImportFlags    flags;
    VkExternalFenceHandleTypeFlagBits     handleType;
    int                                      fd;
} VkImportFenceFdInfoKHR;

typedef struct VkPhysicalDeviceMultiviewFeatures {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                           multiview;
    VkBool32                           multiviewGeometryShader;
    VkBool32                           multiviewTessellationShader;
} VkPhysicalDeviceMultiviewFeatures;

typedef struct VkPhysicalDeviceMultiviewFeatures  VkPhysicalDeviceMultiviewFeaturesKHR;

typedef struct VkSurfaceCapabilities2EXT {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                           minImageCount;
    uint32_t                           maxImageCount;
    VkExtent2D                         currentExtent;
    VkExtent2D                         minImageExtent;
    VkExtent2D                         maxImageExtent;
    uint32_t                           maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR         supportedTransforms;
    VkSurfaceTransformFlagBitsKHR      currentTransform;
    VkCompositeAlphaFlagsKHR           supportedCompositeAlpha;
    VkImageUsageFlags                  supportedUsageFlags;
    VkSurfaceCounterFlagsEXT   supportedSurfaceCounters;
} VkSurfaceCapabilities2EXT;

typedef struct VkSwapchainCounterCreateInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkSurfaceCounterFlagsEXT           surfaceCounters;
} VkSwapchainCounterCreateInfoEXT;

typedef struct VkPhysicalDeviceGroupProperties {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                           physicalDeviceCount;
    VkPhysicalDevice                   physicalDevices [ VK_MAX_DEVICE_GROUP_SIZE ];
    VkBool32                           subsetAllocation;
} VkPhysicalDeviceGroupProperties;

typedef struct VkPhysicalDeviceGroupProperties  VkPhysicalDeviceGroupPropertiesKHR;

typedef struct VkMemoryAllocateFlagsInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkMemoryAllocateFlags   flags;
    uint32_t                           deviceMask;
} VkMemoryAllocateFlagsInfo;

typedef struct VkMemoryAllocateFlagsInfo  VkMemoryAllocateFlagsInfoKHR;

typedef struct VkBindBufferMemoryInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkBuffer                           buffer;
    VkDeviceMemory                     memory;
    VkDeviceSize                       memoryOffset;
} VkBindBufferMemoryInfo;

typedef struct VkBindBufferMemoryInfo  VkBindBufferMemoryInfoKHR;

typedef struct VkBindImageMemoryInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkImage                            image;
    VkDeviceMemory                     memory;
    VkDeviceSize                       memoryOffset;
} VkBindImageMemoryInfo;

typedef struct VkBindImageMemoryInfo  VkBindImageMemoryInfoKHR;

typedef struct VkDeviceGroupPresentCapabilitiesKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t                           presentMask [ VK_MAX_DEVICE_GROUP_SIZE ];
    VkDeviceGroupPresentModeFlagsKHR   modes;
} VkDeviceGroupPresentCapabilitiesKHR;

typedef struct VkDeviceGroupSwapchainCreateInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDeviceGroupPresentModeFlagsKHR                           modes;
} VkDeviceGroupSwapchainCreateInfoKHR;

typedef struct VkDescriptorUpdateTemplateCreateInfo {
    VkStructureType   sType;
    const  void *                                pNext;
    VkDescriptorUpdateTemplateCreateFlags      flags;
    uint32_t                   descriptorUpdateEntryCount;
    const  VkDescriptorUpdateTemplateEntry *  pDescriptorUpdateEntries;
    VkDescriptorUpdateTemplateType   templateType;
    VkDescriptorSetLayout   descriptorSetLayout;
    VkPipelineBindPoint   pipelineBindPoint;
    VkPipelineLayout pipelineLayout;
    uint32_t   set;
} VkDescriptorUpdateTemplateCreateInfo;

typedef struct VkDescriptorUpdateTemplateCreateInfo  VkDescriptorUpdateTemplateCreateInfoKHR;

#if defined(VK_USE_PLATFORM_METAL_EXT)
typedef struct VkMetalSurfaceCreateInfoEXT {
    VkStructureType   sType;
    const  void *                                     pNext;
    VkMetalSurfaceCreateFlagsEXT     flags;
    const  CAMetalLayer *       pLayer;
} VkMetalSurfaceCreateInfoEXT;
#endif

typedef struct VkPipelineDiscardRectangleStateCreateInfoEXT {
    VkStructureType   sType;
    const  void *                                                        pNext;
    VkPipelineDiscardRectangleStateCreateFlagsEXT       flags;
    VkDiscardRectangleModeEXT                                           discardRectangleMode;
    uint32_t                                            discardRectangleCount;
    const  VkRect2D *  pDiscardRectangles;
} VkPipelineDiscardRectangleStateCreateInfoEXT;

typedef struct VkInputAttachmentAspectReference {
    uint32_t                          subpass;
    uint32_t                          inputAttachmentIndex;
    VkImageAspectFlags                aspectMask;
} VkInputAttachmentAspectReference;

typedef struct VkInputAttachmentAspectReference  VkInputAttachmentAspectReferenceKHR;

typedef struct VkRenderPassInputAttachmentAspectCreateInfo {
    VkStructureType   sType;
    const  void *                      pNext;
    uint32_t                          aspectReferenceCount;
    const  VkInputAttachmentAspectReference *  pAspectReferences;
} VkRenderPassInputAttachmentAspectCreateInfo;

typedef struct VkRenderPassInputAttachmentAspectCreateInfo  VkRenderPassInputAttachmentAspectCreateInfoKHR;

typedef struct VkSurfaceCapabilities2KHR {
    VkStructureType   sType;
    void *    pNext;
    VkSurfaceCapabilitiesKHR   surfaceCapabilities;
} VkSurfaceCapabilities2KHR;

typedef struct VkDisplayProperties2KHR {
    VkStructureType   sType;
    void *  pNext;
    VkDisplayPropertiesKHR   displayProperties;
} VkDisplayProperties2KHR;

typedef struct VkDisplayPlaneCapabilities2KHR {
    VkStructureType   sType;
    void *  pNext;
    VkDisplayPlaneCapabilitiesKHR   capabilities;
} VkDisplayPlaneCapabilities2KHR;

typedef struct VkSharedPresentSurfaceCapabilitiesKHR {
    VkStructureType   sType;
    void *                             pNext;
    VkImageUsageFlags   sharedPresentSupportedUsageFlags;
} VkSharedPresentSurfaceCapabilitiesKHR;

typedef struct VkPhysicalDevice16BitStorageFeatures {
    VkStructureType   sType;
    void *       pNext;
    VkBool32                           storageBuffer16BitAccess;
    VkBool32                           uniformAndStorageBuffer16BitAccess;
    VkBool32                           storagePushConstant16;
    VkBool32                           storageInputOutput16;
} VkPhysicalDevice16BitStorageFeatures;

typedef struct VkPhysicalDevice16BitStorageFeatures  VkPhysicalDevice16BitStorageFeaturesKHR;

typedef struct VkPhysicalDeviceSubgroupProperties {
    VkStructureType   sType;
    void *                    pNext;
    uint32_t                        subgroupSize;
    VkShaderStageFlags              supportedStages;
    VkSubgroupFeatureFlags          supportedOperations;
    VkBool32   quadOperationsInAllStages;
} VkPhysicalDeviceSubgroupProperties;

typedef struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    VkStructureType   sType;
    void *                           pNext;
    VkBool32   shaderSubgroupExtendedTypes;
} VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;

typedef struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures  VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR;

typedef struct VkMemoryRequirements2 {
    VkStructureType   sType;
    void *  pNext;
    VkMemoryRequirements                                                   memoryRequirements;
} VkMemoryRequirements2;

typedef struct VkMemoryRequirements2  VkMemoryRequirements2KHR;

typedef struct VkSparseImageMemoryRequirements2 {
    VkStructureType   sType;
    void *                                        pNext;
    VkSparseImageMemoryRequirements                                        memoryRequirements;
} VkSparseImageMemoryRequirements2;

typedef struct VkSparseImageMemoryRequirements2  VkSparseImageMemoryRequirements2KHR;

typedef struct VkMemoryDedicatedRequirements {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                           prefersDedicatedAllocation;
    VkBool32                           requiresDedicatedAllocation;
} VkMemoryDedicatedRequirements;

typedef struct VkMemoryDedicatedRequirements  VkMemoryDedicatedRequirementsKHR;

typedef struct VkImageViewUsageCreateInfo {
    VkStructureType   sType;
    const  void *  pNext;
    VkImageUsageFlags   usage;
} VkImageViewUsageCreateInfo;

typedef struct VkImageViewUsageCreateInfo  VkImageViewUsageCreateInfoKHR;

typedef struct VkSamplerYcbcrConversionCreateInfo {
    VkStructureType   sType;
    const  void *                       pNext;
    VkFormat                           format;
    VkSamplerYcbcrModelConversion   ycbcrModel;
    VkSamplerYcbcrRange             ycbcrRange;
    VkComponentMapping                 components;
    VkChromaLocation                xChromaOffset;
    VkChromaLocation                yChromaOffset;
    VkFilter                           chromaFilter;
    VkBool32                           forceExplicitReconstruction;
} VkSamplerYcbcrConversionCreateInfo;

typedef struct VkSamplerYcbcrConversionCreateInfo  VkSamplerYcbcrConversionCreateInfoKHR;

typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    VkStructureType   sType;
    void *       pNext;
    VkBool32                           samplerYcbcrConversion;
} VkPhysicalDeviceSamplerYcbcrConversionFeatures;

typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures  VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR;

typedef struct VkConditionalRenderingBeginInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkBuffer                           buffer;
    VkDeviceSize                       offset;
    VkConditionalRenderingFlagsEXT      flags;
} VkConditionalRenderingBeginInfoEXT;

typedef struct VkProtectedSubmitInfo {
    VkStructureType   sType;
    const  void *                      pNext;
    VkBool32                          protectedSubmit;
} VkProtectedSubmitInfo;

typedef struct VkPhysicalDeviceProtectedMemoryFeatures {
    VkStructureType   sType;
    void *                                pNext;
    VkBool32                              protectedMemory;
} VkPhysicalDeviceProtectedMemoryFeatures;

typedef struct VkPhysicalDeviceProtectedMemoryProperties {
    VkStructureType   sType;
    void *                                pNext;
    VkBool32                              protectedNoFault;
} VkPhysicalDeviceProtectedMemoryProperties;

typedef struct VkDeviceQueueInfo2 {
    VkStructureType   sType;
    const  void *                          pNext;
    VkDeviceQueueCreateFlags              flags;
    uint32_t                              queueFamilyIndex;
    uint32_t                              queueIndex;
} VkDeviceQueueInfo2;

typedef struct VkPhysicalDeviceSamplerFilterMinmaxProperties {
    VkStructureType   sType;
    void *                   pNext;
    VkBool32                 filterMinmaxSingleComponentFormats;
    VkBool32                 filterMinmaxImageComponentMapping;
} VkPhysicalDeviceSamplerFilterMinmaxProperties;

typedef struct VkPhysicalDeviceSamplerFilterMinmaxProperties  VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT;

typedef struct VkPipelineSampleLocationsStateCreateInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkBool32                           sampleLocationsEnable;
    VkSampleLocationsInfoEXT           sampleLocationsInfo;
} VkPipelineSampleLocationsStateCreateInfoEXT;

typedef struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
    VkStructureType   sType;
    void *                             pNext;
    VkSampleCountFlags                 sampleLocationSampleCounts;
    VkExtent2D                         maxSampleLocationGridSize;
    float                              sampleLocationCoordinateRange [2];
    uint32_t                           sampleLocationSubPixelBits;
    VkBool32                           variableSampleLocations;
} VkPhysicalDeviceSampleLocationsPropertiesEXT;

typedef struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                           advancedBlendCoherentOperations;
} VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;

typedef struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                           advancedBlendMaxColorAttachments;
    VkBool32                           advancedBlendIndependentBlend;
    VkBool32                           advancedBlendNonPremultipliedSrcColor;
    VkBool32                           advancedBlendNonPremultipliedDstColor;
    VkBool32                           advancedBlendCorrelatedOverlap;
    VkBool32                           advancedBlendAllOperations;
} VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;

typedef struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    VkStructureType   sType;
    const  void *             pNext;
    VkBool32                 srcPremultiplied;
    VkBool32                 dstPremultiplied;
    VkBlendOverlapEXT        blendOverlap;
} VkPipelineColorBlendAdvancedStateCreateInfoEXT;

typedef struct VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
    VkStructureType   sType;
    void *                   pNext;
    VkBool32                 inlineUniformBlock;
    VkBool32                 descriptorBindingInlineUniformBlockUpdateAfterBind;
} VkPhysicalDeviceInlineUniformBlockFeaturesEXT;

typedef struct VkValidationCacheCreateInfoEXT {
    VkStructureType   sType;
    const  void *             pNext;
    VkValidationCacheCreateFlagsEXT      flags;
    size_t                   initialDataSize;
    const  void *             pInitialData;
} VkValidationCacheCreateInfoEXT;

typedef struct VkPhysicalDeviceMaintenance3Properties {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                           maxPerSetDescriptors;
    VkDeviceSize                       maxMemoryAllocationSize;
} VkPhysicalDeviceMaintenance3Properties;

typedef struct VkPhysicalDeviceMaintenance3Properties  VkPhysicalDeviceMaintenance3PropertiesKHR;

typedef struct VkDescriptorSetLayoutSupport {
    VkStructureType   sType;
    void *             pNext;
    VkBool32           supported;
} VkDescriptorSetLayoutSupport;

typedef struct VkDescriptorSetLayoutSupport  VkDescriptorSetLayoutSupportKHR;

typedef struct VkPhysicalDeviceShaderDrawParametersFeatures {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                           shaderDrawParameters;
} VkPhysicalDeviceShaderDrawParametersFeatures;

typedef struct VkPhysicalDeviceShaderDrawParametersFeatures  VkPhysicalDeviceShaderDrawParameterFeatures;

typedef struct VkPhysicalDeviceShaderFloat16Int8Features {
    VkStructureType   sType;
    void *       pNext;
    VkBool32                           shaderFloat16;
    VkBool32                           shaderInt8;
} VkPhysicalDeviceShaderFloat16Int8Features;

typedef struct VkPhysicalDeviceShaderFloat16Int8Features  VkPhysicalDeviceShaderFloat16Int8FeaturesKHR;

typedef struct VkPhysicalDeviceShaderFloat16Int8Features  VkPhysicalDeviceFloat16Int8FeaturesKHR;

typedef struct VkPhysicalDeviceFloatControlsProperties {
    VkStructureType   sType;
    void *                             pNext;
    VkShaderFloatControlsIndependence   denormBehaviorIndependence;
    VkShaderFloatControlsIndependence   roundingModeIndependence;
    VkBool32                           shaderSignedZeroInfNanPreserveFloat16;
    VkBool32                           shaderSignedZeroInfNanPreserveFloat32;
    VkBool32                           shaderSignedZeroInfNanPreserveFloat64;
    VkBool32                           shaderDenormPreserveFloat16;
    VkBool32                           shaderDenormPreserveFloat32;
    VkBool32                           shaderDenormPreserveFloat64;
    VkBool32                           shaderDenormFlushToZeroFloat16;
    VkBool32                           shaderDenormFlushToZeroFloat32;
    VkBool32                           shaderDenormFlushToZeroFloat64;
    VkBool32                           shaderRoundingModeRTEFloat16;
    VkBool32                           shaderRoundingModeRTEFloat32;
    VkBool32                           shaderRoundingModeRTEFloat64;
    VkBool32                           shaderRoundingModeRTZFloat16;
    VkBool32                           shaderRoundingModeRTZFloat32;
    VkBool32                           shaderRoundingModeRTZFloat64;
} VkPhysicalDeviceFloatControlsProperties;

typedef struct VkPhysicalDeviceFloatControlsProperties  VkPhysicalDeviceFloatControlsPropertiesKHR;

typedef struct VkPhysicalDeviceHostQueryResetFeatures {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             hostQueryReset;
} VkPhysicalDeviceHostQueryResetFeatures;

typedef struct VkPhysicalDeviceHostQueryResetFeatures  VkPhysicalDeviceHostQueryResetFeaturesEXT;

typedef struct VkDebugUtilsMessengerCallbackDataEXT {
    VkStructureType   sType;
    const  void *                                                         pNext;
    VkDebugUtilsMessengerCallbackDataFlagsEXT                            flags;
    const  char *                                   pMessageIdName;
    int32_t                                                              messageIdNumber;
    const  char *                                                   pMessage;
    uint32_t                                                             queueLabelCount;
    const  VkDebugUtilsLabelEXT *                   pQueueLabels;
    uint32_t                                                             cmdBufLabelCount;
    const  VkDebugUtilsLabelEXT *                  pCmdBufLabels;
    uint32_t                                                             objectCount;
    const  VkDebugUtilsObjectNameInfoEXT *              pObjects;
} VkDebugUtilsMessengerCallbackDataEXT;

typedef struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
    VkStructureType   sType;
    void *  pNext;
    VkDeviceSize   minImportedHostPointerAlignment;
} VkPhysicalDeviceExternalMemoryHostPropertiesEXT;

typedef struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
    VkStructureType   sType;
    void *                   pNext;
    float                    primitiveOverestimationSize;
    float                    maxExtraPrimitiveOverestimationSize;
    float                    extraPrimitiveOverestimationSizeGranularity;
    VkBool32                 primitiveUnderestimation;
    VkBool32                 conservativePointAndLineRasterization;
    VkBool32                 degenerateTrianglesRasterized;
    VkBool32                 degenerateLinesRasterized;
    VkBool32                 fullyCoveredFragmentShaderInputVariable;
    VkBool32                 conservativeRasterizationPostDepthCoverage;
} VkPhysicalDeviceConservativeRasterizationPropertiesEXT;

typedef struct VkPipelineRasterizationConservativeStateCreateInfoEXT {
    VkStructureType   sType;
    const  void *                                                                       pNext;
    VkPipelineRasterizationConservativeStateCreateFlagsEXT             flags;
    VkConservativeRasterizationModeEXT                                                 conservativeRasterizationMode;
    float                                                                              extraPrimitiveOverestimationSize;
} VkPipelineRasterizationConservativeStateCreateInfoEXT;

typedef struct VkPhysicalDeviceDescriptorIndexingFeatures {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                 shaderInputAttachmentArrayDynamicIndexing;
    VkBool32                 shaderUniformTexelBufferArrayDynamicIndexing;
    VkBool32                 shaderStorageTexelBufferArrayDynamicIndexing;
    VkBool32                 shaderUniformBufferArrayNonUniformIndexing;
    VkBool32                 shaderSampledImageArrayNonUniformIndexing;
    VkBool32                 shaderStorageBufferArrayNonUniformIndexing;
    VkBool32                 shaderStorageImageArrayNonUniformIndexing;
    VkBool32                 shaderInputAttachmentArrayNonUniformIndexing;
    VkBool32                 shaderUniformTexelBufferArrayNonUniformIndexing;
    VkBool32                 shaderStorageTexelBufferArrayNonUniformIndexing;
    VkBool32                 descriptorBindingUniformBufferUpdateAfterBind;
    VkBool32                 descriptorBindingSampledImageUpdateAfterBind;
    VkBool32                 descriptorBindingStorageImageUpdateAfterBind;
    VkBool32                 descriptorBindingStorageBufferUpdateAfterBind;
    VkBool32                 descriptorBindingUniformTexelBufferUpdateAfterBind;
    VkBool32                 descriptorBindingStorageTexelBufferUpdateAfterBind;
    VkBool32                 descriptorBindingUpdateUnusedWhilePending;
    VkBool32                 descriptorBindingPartiallyBound;
    VkBool32                 descriptorBindingVariableDescriptorCount;
    VkBool32                 runtimeDescriptorArray;
} VkPhysicalDeviceDescriptorIndexingFeatures;

typedef struct VkPhysicalDeviceDescriptorIndexingFeatures  VkPhysicalDeviceDescriptorIndexingFeaturesEXT;

typedef struct VkPhysicalDeviceDescriptorIndexingProperties {
    VkStructureType   sType;
    void *                             pNext;
    uint32_t                 maxUpdateAfterBindDescriptorsInAllPools;
    VkBool32                 shaderUniformBufferArrayNonUniformIndexingNative;
    VkBool32                 shaderSampledImageArrayNonUniformIndexingNative;
    VkBool32                 shaderStorageBufferArrayNonUniformIndexingNative;
    VkBool32                 shaderStorageImageArrayNonUniformIndexingNative;
    VkBool32                 shaderInputAttachmentArrayNonUniformIndexingNative;
    VkBool32                 robustBufferAccessUpdateAfterBind;
    VkBool32                 quadDivergentImplicitLod;
    uint32_t                 maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t                 maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t                 maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t                 maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t                 maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t                 maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t                 maxPerStageUpdateAfterBindResources;
    uint32_t                 maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t                 maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t                 maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t                 maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t                 maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t                 maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t                 maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t                 maxDescriptorSetUpdateAfterBindInputAttachments;
} VkPhysicalDeviceDescriptorIndexingProperties;

typedef struct VkPhysicalDeviceDescriptorIndexingProperties  VkPhysicalDeviceDescriptorIndexingPropertiesEXT;

typedef struct VkDescriptorSetLayoutBindingFlagsCreateInfo {
    VkStructureType   sType;
    const  void *                                                         pNext;
    uint32_t                                             bindingCount;
    const  VkDescriptorBindingFlags *  pBindingFlags;
} VkDescriptorSetLayoutBindingFlagsCreateInfo;

typedef struct VkDescriptorSetLayoutBindingFlagsCreateInfo  VkDescriptorSetLayoutBindingFlagsCreateInfoEXT;

typedef struct VkAttachmentDescription2 {
    VkStructureType   sType;
    const  void *             pNext;
    VkAttachmentDescriptionFlags   flags;
    VkFormat                                       format;
    VkSampleCountFlagBits                          samples;
    VkAttachmentLoadOp                             loadOp;
    VkAttachmentStoreOp                            storeOp;
    VkAttachmentLoadOp                             stencilLoadOp;
    VkAttachmentStoreOp                            stencilStoreOp;
    VkImageLayout                                  initialLayout;
    VkImageLayout                                  finalLayout;
} VkAttachmentDescription2;

typedef struct VkAttachmentDescription2  VkAttachmentDescription2KHR;

typedef struct VkAttachmentReference2 {
    VkStructureType   sType;
    const  void *  pNext;
    uint32_t                            attachment;
    VkImageLayout                       layout;
    VkImageAspectFlags   aspectMask;
} VkAttachmentReference2;

typedef struct VkAttachmentReference2  VkAttachmentReference2KHR;

typedef struct VkSubpassDescription2 {
    VkStructureType   sType;
    const  void *                            pNext;
    VkSubpassDescriptionFlags                     flags;
    VkPipelineBindPoint                                           pipelineBindPoint;
    uint32_t                                                      viewMask;
    uint32_t                                      inputAttachmentCount;
    const  VkAttachmentReference2 *     pInputAttachments;
    uint32_t                                      colorAttachmentCount;
    const  VkAttachmentReference2 *     pColorAttachments;
    const  VkAttachmentReference2 *  pResolveAttachments;
    const  VkAttachmentReference2 *                pDepthStencilAttachment;
    uint32_t                                      preserveAttachmentCount;
    const  uint32_t *                pPreserveAttachments;
} VkSubpassDescription2;

typedef struct VkSubpassDescription2  VkSubpassDescription2KHR;

typedef struct VkSubpassDependency2 {
    VkStructureType   sType;
    const  void *  pNext;
    uint32_t                            srcSubpass;
    uint32_t                            dstSubpass;
    VkPipelineStageFlags                srcStageMask;
    VkPipelineStageFlags                dstStageMask;
    VkAccessFlags       srcAccessMask;
    VkAccessFlags       dstAccessMask;
    VkDependencyFlags   dependencyFlags;
    int32_t             viewOffset;
} VkSubpassDependency2;

typedef struct VkSubpassDependency2  VkSubpassDependency2KHR;

typedef struct VkRenderPassCreateInfo2 {
    VkStructureType   sType;
    const  void *                                               pNext;
    VkRenderPassCreateFlags                    flags;
    uint32_t                                   attachmentCount;
    const  VkAttachmentDescription2 *     pAttachments;
    uint32_t                                                   subpassCount;
    const  VkSubpassDescription2 *           pSubpasses;
    uint32_t                                   dependencyCount;
    const  VkSubpassDependency2 *         pDependencies;
    uint32_t                                   correlatedViewMaskCount;
    const  uint32_t *             pCorrelatedViewMasks;
} VkRenderPassCreateInfo2;

typedef struct VkRenderPassCreateInfo2  VkRenderPassCreateInfo2KHR;

typedef struct VkPhysicalDeviceTimelineSemaphoreFeatures {
    VkStructureType   sType;
    void *                   pNext;
    VkBool32                 timelineSemaphore;
} VkPhysicalDeviceTimelineSemaphoreFeatures;

typedef struct VkPhysicalDeviceTimelineSemaphoreFeatures  VkPhysicalDeviceTimelineSemaphoreFeaturesKHR;

typedef struct VkSemaphoreWaitInfo {
    VkStructureType   sType;
    const  void *             pNext;
    VkSemaphoreWaitFlags   flags;
    uint32_t                 semaphoreCount;
    const  VkSemaphore *  pSemaphores;
    const  uint64_t *     pValues;
} VkSemaphoreWaitInfo;

typedef struct VkSemaphoreWaitInfo  VkSemaphoreWaitInfoKHR;

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef struct VkAndroidHardwareBufferPropertiesANDROID {
    VkStructureType   sType;
    void *                               pNext;
    VkDeviceSize                         allocationSize;
    uint32_t                             memoryTypeBits;
} VkAndroidHardwareBufferPropertiesANDROID;
#endif

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef struct VkAndroidHardwareBufferFormatPropertiesANDROID {
    VkStructureType   sType;
    void *                               pNext;
    VkFormat                             format;
    uint64_t                             externalFormat;
    VkFormatFeatureFlags                 formatFeatures;
    VkComponentMapping                   samplerYcbcrConversionComponents;
    VkSamplerYcbcrModelConversion        suggestedYcbcrModel;
    VkSamplerYcbcrRange                  suggestedYcbcrRange;
    VkChromaLocation                     suggestedXChromaOffset;
    VkChromaLocation                     suggestedYChromaOffset;
} VkAndroidHardwareBufferFormatPropertiesANDROID;
#endif

typedef struct VkCommandBufferInheritanceConditionalRenderingInfoEXT {
    VkStructureType   sType;
    const  void *                          pNext;
    VkBool32                              conditionalRenderingEnable;
} VkCommandBufferInheritanceConditionalRenderingInfoEXT;

typedef struct VkPhysicalDevice8BitStorageFeatures {
    VkStructureType   sType;
    void *       pNext;
    VkBool32                           storageBuffer8BitAccess;
    VkBool32                           uniformAndStorageBuffer8BitAccess;
    VkBool32                           storagePushConstant8;
} VkPhysicalDevice8BitStorageFeatures;

typedef struct VkPhysicalDevice8BitStorageFeatures  VkPhysicalDevice8BitStorageFeaturesKHR;

typedef struct VkPhysicalDeviceConditionalRenderingFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             conditionalRendering;
    VkBool32                             inheritedConditionalRendering;
} VkPhysicalDeviceConditionalRenderingFeaturesEXT;

typedef struct VkPhysicalDeviceVulkanMemoryModelFeatures {
    VkStructureType   sType;
    void *       pNext;
    VkBool32                           vulkanMemoryModel;
    VkBool32                           vulkanMemoryModelDeviceScope;
    VkBool32                           vulkanMemoryModelAvailabilityVisibilityChains;
} VkPhysicalDeviceVulkanMemoryModelFeatures;

typedef struct VkPhysicalDeviceVulkanMemoryModelFeatures  VkPhysicalDeviceVulkanMemoryModelFeaturesKHR;

typedef struct VkPhysicalDeviceShaderAtomicInt64Features {
    VkStructureType   sType;
    void *                                pNext;
    VkBool32                              shaderBufferInt64Atomics;
    VkBool32                              shaderSharedInt64Atomics;
} VkPhysicalDeviceShaderAtomicInt64Features;

typedef struct VkPhysicalDeviceShaderAtomicInt64Features  VkPhysicalDeviceShaderAtomicInt64FeaturesKHR;

typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
    VkStructureType   sType;
    void *                                pNext;
    VkBool32                              shaderBufferFloat32Atomics;
    VkBool32                              shaderBufferFloat32AtomicAdd;
    VkBool32                              shaderBufferFloat64Atomics;
    VkBool32                              shaderBufferFloat64AtomicAdd;
    VkBool32                              shaderSharedFloat32Atomics;
    VkBool32                              shaderSharedFloat32AtomicAdd;
    VkBool32                              shaderSharedFloat64Atomics;
    VkBool32                              shaderSharedFloat64AtomicAdd;
    VkBool32                              shaderImageFloat32Atomics;
    VkBool32                              shaderImageFloat32AtomicAdd;
    VkBool32                              sparseImageFloat32Atomics;
    VkBool32                              sparseImageFloat32AtomicAdd;
} VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;

typedef struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             vertexAttributeInstanceRateDivisor;
    VkBool32                             vertexAttributeInstanceRateZeroDivisor;
} VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;

typedef struct VkPhysicalDeviceDepthStencilResolveProperties {
    VkStructureType   sType;
    void *                                 pNext;
    VkResolveModeFlags                     supportedDepthResolveModes;
    VkResolveModeFlags                     supportedStencilResolveModes;
    VkBool32                               independentResolveNone;
    VkBool32                               independentResolve;
} VkPhysicalDeviceDepthStencilResolveProperties;

typedef struct VkPhysicalDeviceDepthStencilResolveProperties  VkPhysicalDeviceDepthStencilResolvePropertiesKHR;

typedef struct VkSubpassDescriptionDepthStencilResolve {
    VkStructureType   sType;
    const  void *                                               pNext;
    VkResolveModeFlagBits                                      depthResolveMode;
    VkResolveModeFlagBits                                      stencilResolveMode;
    const  VkAttachmentReference2 *             pDepthStencilResolveAttachment;
} VkSubpassDescriptionDepthStencilResolve;

typedef struct VkSubpassDescriptionDepthStencilResolve  VkSubpassDescriptionDepthStencilResolveKHR;

typedef struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
    VkStructureType   sType;
    void *       pNext;
    VkBool32                           decodeModeSharedExponent;
} VkPhysicalDeviceASTCDecodeFeaturesEXT;

typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT {
    VkStructureType   sType;
    void *                   pNext;
    VkBool32                 transformFeedback;
    VkBool32                 geometryStreams;
} VkPhysicalDeviceTransformFeedbackFeaturesEXT;

typedef struct VkPhysicalDeviceTransformFeedbackPropertiesEXT {
    VkStructureType   sType;
    void *                   pNext;
    uint32_t                 maxTransformFeedbackStreams;
    uint32_t                 maxTransformFeedbackBuffers;
    VkDeviceSize             maxTransformFeedbackBufferSize;
    uint32_t                 maxTransformFeedbackStreamDataSize;
    uint32_t                 maxTransformFeedbackBufferDataSize;
    uint32_t                 maxTransformFeedbackBufferDataStride;
    VkBool32                 transformFeedbackQueries;
    VkBool32                 transformFeedbackStreamsLinesTriangles;
    VkBool32                 transformFeedbackRasterizationStreamSelect;
    VkBool32                 transformFeedbackDraw;
} VkPhysicalDeviceTransformFeedbackPropertiesEXT;

typedef struct VkPipelineRasterizationStateStreamCreateInfoEXT {
    VkStructureType   sType;
    const  void *                                                                       pNext;
    VkPipelineRasterizationStateStreamCreateFlagsEXT                   flags;
    uint32_t                                                                           rasterizationStream;
} VkPipelineRasterizationStateStreamCreateInfoEXT;

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkRayTracingPipelineCreateInfoKHR {
    VkStructureType   sType;
    const  void *             pNext;
    VkPipelineCreateFlags    flags;
    uint32_t   stageCount;
    const  VkPipelineShaderStageCreateInfo *  pStages;
    uint32_t   groupCount;
    const  VkRayTracingShaderGroupCreateInfoKHR *  pGroups;
    uint32_t                 maxRecursionDepth;
    VkPipelineLibraryCreateInfoKHR   libraries;
    const  VkRayTracingPipelineInterfaceCreateInfoKHR *  pLibraryInterface;
    VkPipelineLayout         layout;
    VkPipeline        basePipelineHandle;
    int32_t                  basePipelineIndex;
} VkRayTracingPipelineCreateInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkBindAccelerationStructureMemoryInfoKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    VkAccelerationStructureKHR         accelerationStructure;
    VkDeviceMemory                     memory;
    VkDeviceSize                       memoryOffset;
    uint32_t           deviceIndexCount;
    const  uint32_t *   pDeviceIndices;
} VkBindAccelerationStructureMemoryInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkPhysicalDeviceRayTracingFeaturesKHR {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                           rayTracing;
    VkBool32                           rayTracingShaderGroupHandleCaptureReplay;
    VkBool32                           rayTracingShaderGroupHandleCaptureReplayMixed;
    VkBool32                           rayTracingAccelerationStructureCaptureReplay;
    VkBool32                           rayTracingIndirectTraceRays;
    VkBool32                           rayTracingIndirectAccelerationStructureBuild;
    VkBool32                           rayTracingHostAccelerationStructureCommands;
    VkBool32                           rayQuery;
    VkBool32                           rayTracingPrimitiveCulling;
} VkPhysicalDeviceRayTracingFeaturesKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkStridedBufferRegionKHR {
    VkBuffer           buffer;
    VkDeviceSize                       offset;
    VkDeviceSize                       stride;
    VkDeviceSize                       size;
} VkStridedBufferRegionKHR;
#endif

typedef struct VkDrmFormatModifierPropertiesEXT {
    uint64_t   drmFormatModifier;
    uint32_t   drmFormatModifierPlaneCount;
    VkFormatFeatureFlags   drmFormatModifierTilingFeatures;
} VkDrmFormatModifierPropertiesEXT;

typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT {
    VkStructureType   sType;
    const  void *  pNext;
    uint64_t   drmFormatModifier;
    uint32_t   drmFormatModifierPlaneCount;
    const  VkSubresourceLayout *  pPlaneLayouts;
} VkImageDrmFormatModifierExplicitCreateInfoEXT;

typedef struct VkImageStencilUsageCreateInfo {
    VkStructureType   sType;
    const  void *  pNext;
    VkImageUsageFlags   stencilUsage;
} VkImageStencilUsageCreateInfo;

typedef struct VkImageStencilUsageCreateInfo  VkImageStencilUsageCreateInfoEXT;

typedef struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                           fragmentDensityMap;
    VkBool32                           fragmentDensityMapDynamic;
    VkBool32                           fragmentDensityMapNonSubsampledImages;
} VkPhysicalDeviceFragmentDensityMapFeaturesEXT;

typedef struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                           fragmentDensityMapDeferred;
} VkPhysicalDeviceFragmentDensityMap2FeaturesEXT;

typedef struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
    VkStructureType   sType;
    void *                             pNext;
    VkExtent2D                         minFragmentDensityTexelSize;
    VkExtent2D                         maxFragmentDensityTexelSize;
    VkBool32                           fragmentDensityInvocations;
} VkPhysicalDeviceFragmentDensityMapPropertiesEXT;

typedef struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
    VkStructureType   sType;
    void *                           pNext;
    VkBool32                         subsampledLoads;
    VkBool32                         subsampledCoarseReconstructionEarlyAccess;
    uint32_t                         maxSubsampledArrayLayers;
    uint32_t                         maxDescriptorSetSubsampledSamplers;
} VkPhysicalDeviceFragmentDensityMap2PropertiesEXT;

typedef struct VkPhysicalDeviceScalarBlockLayoutFeatures {
    VkStructureType   sType;
    void *                                pNext;
    VkBool32                              scalarBlockLayout;
} VkPhysicalDeviceScalarBlockLayoutFeatures;

typedef struct VkPhysicalDeviceScalarBlockLayoutFeatures  VkPhysicalDeviceScalarBlockLayoutFeaturesEXT;

typedef struct VkSurfaceProtectedCapabilitiesKHR {
    VkStructureType   sType;
    const  void *  pNext;
    VkBool32   supportsProtected;
} VkSurfaceProtectedCapabilitiesKHR;

typedef struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
    VkStructureType   sType;
    void *                                pNext;
    VkBool32                              uniformBufferStandardLayout;
} VkPhysicalDeviceUniformBufferStandardLayoutFeatures;

typedef struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures  VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR;

typedef struct VkPhysicalDeviceDepthClipEnableFeaturesEXT {
    VkStructureType   sType;
    void *                   pNext;
    VkBool32                 depthClipEnable;
} VkPhysicalDeviceDepthClipEnableFeaturesEXT;

typedef struct VkPipelineRasterizationDepthClipStateCreateInfoEXT {
    VkStructureType   sType;
    const  void *                                                                  pNext;
    VkPipelineRasterizationDepthClipStateCreateFlagsEXT           flags;
    VkBool32                                                                      depthClipEnable;
} VkPipelineRasterizationDepthClipStateCreateInfoEXT;

typedef struct VkPhysicalDeviceMemoryBudgetPropertiesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkDeviceSize                         heapBudget [ VK_MAX_MEMORY_HEAPS ];
    VkDeviceSize                         heapUsage [ VK_MAX_MEMORY_HEAPS ];
} VkPhysicalDeviceMemoryBudgetPropertiesEXT;

typedef struct VkPhysicalDeviceMemoryPriorityFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             memoryPriority;
} VkPhysicalDeviceMemoryPriorityFeaturesEXT;

typedef struct VkPhysicalDeviceBufferDeviceAddressFeatures {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             bufferDeviceAddress;
    VkBool32                             bufferDeviceAddressCaptureReplay;
    VkBool32                             bufferDeviceAddressMultiDevice;
} VkPhysicalDeviceBufferDeviceAddressFeatures;

typedef struct VkPhysicalDeviceBufferDeviceAddressFeatures  VkPhysicalDeviceBufferDeviceAddressFeaturesKHR;

typedef struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             bufferDeviceAddress;
    VkBool32                             bufferDeviceAddressCaptureReplay;
    VkBool32                             bufferDeviceAddressMultiDevice;
} VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;

typedef struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT  VkPhysicalDeviceBufferAddressFeaturesEXT;

typedef struct VkBufferDeviceAddressCreateInfoEXT {
    VkStructureType   sType;
    const  void *                       pNext;
    VkDeviceAddress                    deviceAddress;
} VkBufferDeviceAddressCreateInfoEXT;

typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT {
    VkStructureType   sType;
    void *                             pNext;
    VkBool32                           filterCubic;
    VkBool32                           filterCubicMinmax;
} VkFilterCubicImageViewImageFormatPropertiesEXT;

typedef struct VkPhysicalDeviceImagelessFramebufferFeatures {
    VkStructureType   sType;
    void *                                     pNext;
    VkBool32                                   imagelessFramebuffer;
} VkPhysicalDeviceImagelessFramebufferFeatures;

typedef struct VkPhysicalDeviceImagelessFramebufferFeatures  VkPhysicalDeviceImagelessFramebufferFeaturesKHR;

typedef struct VkFramebufferAttachmentImageInfo {
    VkStructureType   sType;
    const  void *                               pNext;
    VkImageCreateFlags         flags;
    VkImageUsageFlags                          usage;
    uint32_t                                   width;
    uint32_t                                   height;
    uint32_t                                   layerCount;
    uint32_t                   viewFormatCount;
    const  VkFormat *     pViewFormats;
} VkFramebufferAttachmentImageInfo;

typedef struct VkFramebufferAttachmentImageInfo  VkFramebufferAttachmentImageInfoKHR;

typedef struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
    VkStructureType   sType;
    void *                   pNext;
    VkBool32                 textureCompressionASTC_HDR;
} VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT;

typedef struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             ycbcrImageArrays;
} VkPhysicalDeviceYcbcrImageArraysFeaturesEXT;

typedef struct VkPipelineCreationFeedbackEXT {
    VkPipelineCreationFeedbackFlagsEXT    flags;
    uint64_t                              duration;
} VkPipelineCreationFeedbackEXT;

typedef struct VkPipelineCreationFeedbackCreateInfoEXT {
    VkStructureType   sType;
    const  void *                          pNext;
    VkPipelineCreationFeedbackEXT *       pPipelineCreationFeedback;
    uint32_t                              pipelineStageCreationFeedbackCount;
    VkPipelineCreationFeedbackEXT *  pPipelineStageCreationFeedbacks;
} VkPipelineCreationFeedbackCreateInfoEXT;

#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef struct VkSurfaceCapabilitiesFullScreenExclusiveEXT {
    VkStructureType   sType;
    void *             pNext;
    VkBool32           fullScreenExclusiveSupported;
} VkSurfaceCapabilitiesFullScreenExclusiveEXT;
#endif

typedef struct VkPhysicalDevicePerformanceQueryFeaturesKHR {
    VkStructureType   sType;
    void *       pNext;
    VkBool32                           performanceCounterQueryPools;
    VkBool32                           performanceCounterMultipleQueryPools;
} VkPhysicalDevicePerformanceQueryFeaturesKHR;

typedef struct VkPhysicalDevicePerformanceQueryPropertiesKHR {
    VkStructureType   sType;
    void *  pNext;
    VkBool32   allowCommandBufferQueryCopies;
} VkPhysicalDevicePerformanceQueryPropertiesKHR;

typedef struct VkPerformanceCounterDescriptionKHR {
    VkStructureType   sType;
    const  void *                              pNext;
    VkPerformanceCounterDescriptionFlagsKHR   flags;
    char                                      name [ VK_MAX_DESCRIPTION_SIZE ];
    char                                      category [ VK_MAX_DESCRIPTION_SIZE ];
    char                                      description [ VK_MAX_DESCRIPTION_SIZE ];
} VkPerformanceCounterDescriptionKHR;

typedef struct VkAcquireProfilingLockInfoKHR {
    VkStructureType   sType;
    const  void *             pNext;
    VkAcquireProfilingLockFlagsKHR   flags;
    uint64_t   timeout;
} VkAcquireProfilingLockInfoKHR;

typedef struct VkHeadlessSurfaceCreateInfoEXT {
    VkStructureType   sType;
    const  void *             pNext;
    VkHeadlessSurfaceCreateFlagsEXT     flags;
} VkHeadlessSurfaceCreateInfoEXT;

typedef struct VkPhysicalDeviceShaderClockFeaturesKHR {
    VkStructureType   sType;
    void *                                pNext;
    VkBool32                              shaderSubgroupClock;
    VkBool32                              shaderDeviceClock;
} VkPhysicalDeviceShaderClockFeaturesKHR;

typedef struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             indexTypeUint8;
} VkPhysicalDeviceIndexTypeUint8FeaturesEXT;

typedef struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    VkStructureType   sType;
    void *                   pNext;
    VkBool32                 fragmentShaderSampleInterlock;
    VkBool32                 fragmentShaderPixelInterlock;
    VkBool32                 fragmentShaderShadingRateInterlock;
} VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT;

typedef struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    VkStructureType sType;
    void *     pNext;
    VkBool32                         separateDepthStencilLayouts;
} VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;

typedef struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures  VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR;

typedef struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    VkStructureType   sType;
    void *               pNext;
    VkBool32             pipelineExecutableInfo;
} VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR;

typedef struct VkPipelineExecutablePropertiesKHR {
    VkStructureType   sType;
    void *               pNext;
    VkShaderStageFlags   stages;
    char                 name [ VK_MAX_DESCRIPTION_SIZE ];
    char                 description [ VK_MAX_DESCRIPTION_SIZE ];
    uint32_t             subgroupSize;
} VkPipelineExecutablePropertiesKHR;

typedef union VkPipelineExecutableStatisticValueKHR {
    VkBool32             b32;
    int64_t              i64;
    uint64_t             u64;
    double               f64;
} VkPipelineExecutableStatisticValueKHR;

typedef struct VkPipelineExecutableStatisticKHR {
    VkStructureType   sType;
    void *               pNext;
    char                 name [ VK_MAX_DESCRIPTION_SIZE ];
    char                 description [ VK_MAX_DESCRIPTION_SIZE ];
    VkPipelineExecutableStatisticFormatKHR   format;
    VkPipelineExecutableStatisticValueKHR    value;
} VkPipelineExecutableStatisticKHR;

typedef struct VkPipelineExecutableInternalRepresentationKHR {
    VkStructureType   sType;
    void *               pNext;
    char                 name [ VK_MAX_DESCRIPTION_SIZE ];
    char                 description [ VK_MAX_DESCRIPTION_SIZE ];
    VkBool32             isText;
    size_t                 dataSize;
    void *  pData;
} VkPipelineExecutableInternalRepresentationKHR;

typedef struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             shaderDemoteToHelperInvocation;
} VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;

typedef struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             texelBufferAlignment;
} VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT;

typedef struct VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkDeviceSize                         storageTexelBufferOffsetAlignmentBytes;
    VkBool32                             storageTexelBufferOffsetSingleTexelAlignment;
    VkDeviceSize                         uniformTexelBufferOffsetAlignmentBytes;
    VkBool32                             uniformTexelBufferOffsetSingleTexelAlignment;
} VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT;

typedef struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXT {
    VkStructureType   sType;
    void *                           pNext;
    VkBool32   subgroupSizeControl;
    VkBool32   computeFullSubgroups;
} VkPhysicalDeviceSubgroupSizeControlFeaturesEXT;

typedef struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXT {
    VkStructureType   sType;
    void *                           pNext;
    uint32_t   minSubgroupSize;
    uint32_t   maxSubgroupSize;
    uint32_t   maxComputeWorkgroupSubgroups;
    VkShaderStageFlags               requiredSubgroupSizeStages;
} VkPhysicalDeviceSubgroupSizeControlPropertiesEXT;

typedef struct VkPhysicalDeviceLineRasterizationFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             rectangularLines;
    VkBool32                             bresenhamLines;
    VkBool32                             smoothLines;
    VkBool32                             stippledRectangularLines;
    VkBool32                             stippledBresenhamLines;
    VkBool32                             stippledSmoothLines;
} VkPhysicalDeviceLineRasterizationFeaturesEXT;

typedef struct VkPipelineRasterizationLineStateCreateInfoEXT {
    VkStructureType   sType;
    const  void *                                                       pNext;
    VkLineRasterizationModeEXT                                         lineRasterizationMode;
    VkBool32                                                           stippledLineEnable;
    uint32_t                                           lineStippleFactor;
    uint16_t                                           lineStipplePattern;
} VkPipelineRasterizationLineStateCreateInfoEXT;

typedef struct VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT {
    VkStructureType   sType;
    void *  pNext;
    VkBool32                                                           pipelineCreationCacheControl;
} VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT;

typedef struct VkPhysicalDeviceVulkan11Features {
    VkStructureType sType;
    void *     pNext;
    VkBool32                           storageBuffer16BitAccess;
    VkBool32                           uniformAndStorageBuffer16BitAccess;
    VkBool32                           storagePushConstant16;
    VkBool32                           storageInputOutput16;
    VkBool32                           multiview;
    VkBool32                           multiviewGeometryShader;
    VkBool32                           multiviewTessellationShader;
    VkBool32                           variablePointersStorageBuffer;
    VkBool32                           variablePointers;
    VkBool32                           protectedMemory;
    VkBool32                           samplerYcbcrConversion;
    VkBool32                           shaderDrawParameters;
} VkPhysicalDeviceVulkan11Features;

typedef struct VkPhysicalDeviceVulkan11Properties {
    VkStructureType sType;
    void *       pNext;
    uint8_t                            deviceUUID [ VK_UUID_SIZE ];
    uint8_t                            driverUUID [ VK_UUID_SIZE ];
    uint8_t                            deviceLUID [ VK_LUID_SIZE ];
    uint32_t                           deviceNodeMask;
    VkBool32                           deviceLUIDValid;
    uint32_t                        subgroupSize;
    VkShaderStageFlags              subgroupSupportedStages;
    VkSubgroupFeatureFlags          subgroupSupportedOperations;
    VkBool32                        subgroupQuadOperationsInAllStages;
    VkPointClippingBehavior            pointClippingBehavior;
    uint32_t                           maxMultiviewViewCount;
    uint32_t                           maxMultiviewInstanceIndex;
    VkBool32                           protectedNoFault;
    uint32_t                           maxPerSetDescriptors;
    VkDeviceSize                       maxMemoryAllocationSize;
} VkPhysicalDeviceVulkan11Properties;

typedef struct VkPhysicalDeviceVulkan12Features {
    VkStructureType sType;
    void *     pNext;
    VkBool32                           samplerMirrorClampToEdge;
    VkBool32                           drawIndirectCount;
    VkBool32                           storageBuffer8BitAccess;
    VkBool32                           uniformAndStorageBuffer8BitAccess;
    VkBool32                           storagePushConstant8;
    VkBool32                           shaderBufferInt64Atomics;
    VkBool32                           shaderSharedInt64Atomics;
    VkBool32                           shaderFloat16;
    VkBool32                           shaderInt8;
    VkBool32                           descriptorIndexing;
    VkBool32                           shaderInputAttachmentArrayDynamicIndexing;
    VkBool32                           shaderUniformTexelBufferArrayDynamicIndexing;
    VkBool32                           shaderStorageTexelBufferArrayDynamicIndexing;
    VkBool32                           shaderUniformBufferArrayNonUniformIndexing;
    VkBool32                           shaderSampledImageArrayNonUniformIndexing;
    VkBool32                           shaderStorageBufferArrayNonUniformIndexing;
    VkBool32                           shaderStorageImageArrayNonUniformIndexing;
    VkBool32                           shaderInputAttachmentArrayNonUniformIndexing;
    VkBool32                           shaderUniformTexelBufferArrayNonUniformIndexing;
    VkBool32                           shaderStorageTexelBufferArrayNonUniformIndexing;
    VkBool32                           descriptorBindingUniformBufferUpdateAfterBind;
    VkBool32                           descriptorBindingSampledImageUpdateAfterBind;
    VkBool32                           descriptorBindingStorageImageUpdateAfterBind;
    VkBool32                           descriptorBindingStorageBufferUpdateAfterBind;
    VkBool32                           descriptorBindingUniformTexelBufferUpdateAfterBind;
    VkBool32                           descriptorBindingStorageTexelBufferUpdateAfterBind;
    VkBool32                           descriptorBindingUpdateUnusedWhilePending;
    VkBool32                           descriptorBindingPartiallyBound;
    VkBool32                           descriptorBindingVariableDescriptorCount;
    VkBool32                           runtimeDescriptorArray;
    VkBool32                           samplerFilterMinmax;
    VkBool32                           scalarBlockLayout;
    VkBool32                           imagelessFramebuffer;
    VkBool32                           uniformBufferStandardLayout;
    VkBool32                           shaderSubgroupExtendedTypes;
    VkBool32                           separateDepthStencilLayouts;
    VkBool32                           hostQueryReset;
    VkBool32                           timelineSemaphore;
    VkBool32                           bufferDeviceAddress;
    VkBool32                           bufferDeviceAddressCaptureReplay;
    VkBool32                           bufferDeviceAddressMultiDevice;
    VkBool32                           vulkanMemoryModel;
    VkBool32                           vulkanMemoryModelDeviceScope;
    VkBool32                           vulkanMemoryModelAvailabilityVisibilityChains;
    VkBool32                           shaderOutputViewportIndex;
    VkBool32                           shaderOutputLayer;
    VkBool32                           subgroupBroadcastDynamicId;
} VkPhysicalDeviceVulkan12Features;

typedef struct VkPhysicalDeviceVulkan12Properties {
    VkStructureType sType;
    void *     pNext;
    VkDriverId                         driverID;
    char                               driverName [ VK_MAX_DRIVER_NAME_SIZE ];
    char                               driverInfo [ VK_MAX_DRIVER_INFO_SIZE ];
    VkConformanceVersion               conformanceVersion;
    VkShaderFloatControlsIndependence denormBehaviorIndependence;
    VkShaderFloatControlsIndependence roundingModeIndependence;
    VkBool32                           shaderSignedZeroInfNanPreserveFloat16;
    VkBool32                           shaderSignedZeroInfNanPreserveFloat32;
    VkBool32                           shaderSignedZeroInfNanPreserveFloat64;
    VkBool32                           shaderDenormPreserveFloat16;
    VkBool32                           shaderDenormPreserveFloat32;
    VkBool32                           shaderDenormPreserveFloat64;
    VkBool32                           shaderDenormFlushToZeroFloat16;
    VkBool32                           shaderDenormFlushToZeroFloat32;
    VkBool32                           shaderDenormFlushToZeroFloat64;
    VkBool32                           shaderRoundingModeRTEFloat16;
    VkBool32                           shaderRoundingModeRTEFloat32;
    VkBool32                           shaderRoundingModeRTEFloat64;
    VkBool32                           shaderRoundingModeRTZFloat16;
    VkBool32                           shaderRoundingModeRTZFloat32;
    VkBool32                           shaderRoundingModeRTZFloat64;
    uint32_t                           maxUpdateAfterBindDescriptorsInAllPools;
    VkBool32                           shaderUniformBufferArrayNonUniformIndexingNative;
    VkBool32                           shaderSampledImageArrayNonUniformIndexingNative;
    VkBool32                           shaderStorageBufferArrayNonUniformIndexingNative;
    VkBool32                           shaderStorageImageArrayNonUniformIndexingNative;
    VkBool32                           shaderInputAttachmentArrayNonUniformIndexingNative;
    VkBool32                           robustBufferAccessUpdateAfterBind;
    VkBool32                           quadDivergentImplicitLod;
    uint32_t                           maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t                           maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t                           maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t                           maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t                           maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t                           maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t                           maxPerStageUpdateAfterBindResources;
    uint32_t                           maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t                           maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t                           maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t                           maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t                           maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t                           maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t                           maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t                           maxDescriptorSetUpdateAfterBindInputAttachments;
    VkResolveModeFlags                 supportedDepthResolveModes;
    VkResolveModeFlags                 supportedStencilResolveModes;
    VkBool32                           independentResolveNone;
    VkBool32                           independentResolve;
    VkBool32                           filterMinmaxSingleComponentFormats;
    VkBool32                           filterMinmaxImageComponentMapping;
    uint64_t                           maxTimelineSemaphoreValueDifference;
    VkSampleCountFlags   framebufferIntegerColorSampleCounts;
} VkPhysicalDeviceVulkan12Properties;

typedef struct VkPhysicalDeviceToolPropertiesEXT {
    VkStructureType   sType;
    void *  pNext;
    char              name [ VK_MAX_EXTENSION_NAME_SIZE ];
    char              version [ VK_MAX_EXTENSION_NAME_SIZE ];
    VkToolPurposeFlagsEXT   purposes;
    char              description [ VK_MAX_DESCRIPTION_SIZE ];
    char              layer [ VK_MAX_EXTENSION_NAME_SIZE ];
} VkPhysicalDeviceToolPropertiesEXT;

typedef struct VkPhysicalDeviceCustomBorderColorFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             customBorderColors;
    VkBool32                             customBorderColorWithoutFormat;
} VkPhysicalDeviceCustomBorderColorFeaturesEXT;

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef union VkDeviceOrHostAddressKHR {
    VkDeviceAddress              deviceAddress;
    void *                       hostAddress;
} VkDeviceOrHostAddressKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef union VkDeviceOrHostAddressConstKHR {
    VkDeviceAddress              deviceAddress;
    const  void *                 hostAddress;
} VkDeviceOrHostAddressConstKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureGeometryTrianglesDataKHR {
    VkStructureType   sType;
    const  void *                                    pNext;
    VkFormat                                        vertexFormat;
    VkDeviceOrHostAddressConstKHR                   vertexData;
    VkDeviceSize                                    vertexStride;
    VkIndexType                                     indexType;
    VkDeviceOrHostAddressConstKHR   indexData;
    VkDeviceOrHostAddressConstKHR   transformData;
} VkAccelerationStructureGeometryTrianglesDataKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureGeometryAabbsDataKHR {
    VkStructureType   sType;
    const  void *                            pNext;
    VkDeviceOrHostAddressConstKHR           data;
    VkDeviceSize                            stride;
} VkAccelerationStructureGeometryAabbsDataKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureGeometryInstancesDataKHR {
    VkStructureType   sType;
    const  void *                            pNext;
    VkBool32                                arrayOfPointers;
    VkDeviceOrHostAddressConstKHR           data;
} VkAccelerationStructureGeometryInstancesDataKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef union VkAccelerationStructureGeometryDataKHR {
    VkAccelerationStructureGeometryTrianglesDataKHR   triangles;
    VkAccelerationStructureGeometryAabbsDataKHR           aabbs;
    VkAccelerationStructureGeometryInstancesDataKHR   instances;
} VkAccelerationStructureGeometryDataKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureGeometryKHR {
    VkStructureType   sType;
    const  void *                             pNext;
    VkGeometryTypeKHR                        geometryType;
    VkAccelerationStructureGeometryDataKHR   geometry;
    VkGeometryFlagsKHR       flags;
} VkAccelerationStructureGeometryKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureBuildGeometryInfoKHR {
    VkStructureType   sType;
    const  void *                                                         pNext;
    VkAccelerationStructureTypeKHR                                       type;
    VkBuildAccelerationStructureFlagsKHR                 flags;
    VkBool32                                                             update;
    VkAccelerationStructureKHR                           srcAccelerationStructure;
    VkAccelerationStructureKHR                                           dstAccelerationStructure;
    VkBool32                                                             geometryArrayOfPointers;
    uint32_t                                             geometryCount;
    const  VkAccelerationStructureGeometryKHR * const*    ppGeometries;
    VkDeviceOrHostAddressKHR                                             scratchData;
} VkAccelerationStructureBuildGeometryInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureCreateGeometryTypeInfoKHR {
    VkStructureType   sType;
    const  void *                                              pNext;
    VkGeometryTypeKHR                                         geometryType;
    uint32_t                                                  maxPrimitiveCount;
    VkIndexType                                                indexType;
    uint32_t                                  maxVertexCount;
    VkFormat                                  vertexFormat;
    VkBool32                                  allowsTransforms;
} VkAccelerationStructureCreateGeometryTypeInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureCreateInfoKHR {
    VkStructureType   sType;
    const  void *                                              pNext;
    VkDeviceSize                                              compactedSize;
    VkAccelerationStructureTypeKHR                            type;
    VkBuildAccelerationStructureFlagsKHR      flags;
    uint32_t                                  maxGeometryCount;
    const  VkAccelerationStructureCreateGeometryTypeInfoKHR *  pGeometryInfos;
    VkDeviceAddress                           deviceAddress;
} VkAccelerationStructureCreateInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkAccelerationStructureInstanceKHR {
    VkTransformMatrixKHR                                      transform;
    uint32_t                                                  instanceCustomIndex :24;
    uint32_t                                                  mask :8;
    uint32_t                                                  instanceShaderBindingTableRecordOffset :24;
    VkGeometryInstanceFlagsKHR                flags :8;
    uint64_t                                                  accelerationStructureReference;
} VkAccelerationStructureInstanceKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkCopyAccelerationStructureToMemoryInfoKHR {
    VkStructureType   sType;
    const  void *                                             pNext;
    VkAccelerationStructureKHR                               src;
    VkDeviceOrHostAddressKHR                                 dst;
    VkCopyAccelerationStructureModeKHR                       mode;
} VkCopyAccelerationStructureToMemoryInfoKHR;
#endif

#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef struct VkCopyMemoryToAccelerationStructureInfoKHR {
    VkStructureType   sType;
    const  void *                                             pNext;
    VkDeviceOrHostAddressConstKHR                            src;
    VkAccelerationStructureKHR                               dst;
    VkCopyAccelerationStructureModeKHR                       mode;
} VkCopyMemoryToAccelerationStructureInfoKHR;
#endif

typedef struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             extendedDynamicState;
} VkPhysicalDeviceExtendedDynamicStateFeaturesEXT;

typedef struct VkPhysicalDeviceRobustness2FeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             robustBufferAccess2;
    VkBool32                             robustImageAccess2;
    VkBool32                             nullDescriptor;
} VkPhysicalDeviceRobustness2FeaturesEXT;

typedef struct VkPhysicalDeviceRobustness2PropertiesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkDeviceSize                         robustStorageBufferAccessSizeAlignment;
    VkDeviceSize                         robustUniformBufferAccessSizeAlignment;
} VkPhysicalDeviceRobustness2PropertiesEXT;

typedef struct VkPhysicalDeviceImageRobustnessFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             robustImageAccess;
} VkPhysicalDeviceImageRobustnessFeaturesEXT;

typedef struct VkPhysicalDevice4444FormatsFeaturesEXT {
    VkStructureType   sType;
    void *         pNext;
    VkBool32                             formatA4R4G4B4;
    VkBool32                             formatA4B4G4R4;
} VkPhysicalDevice4444FormatsFeaturesEXT;

typedef VkBool32 (VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)(
    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,
    void*                                            pUserData);

typedef struct VkPhysicalDeviceProperties {
    uint32_t         apiVersion;
    uint32_t         driverVersion;
    uint32_t         vendorID;
    uint32_t         deviceID;
    VkPhysicalDeviceType   deviceType;
    char             deviceName [ VK_MAX_PHYSICAL_DEVICE_NAME_SIZE ];
    uint8_t          pipelineCacheUUID [ VK_UUID_SIZE ];
    VkPhysicalDeviceLimits   limits;
    VkPhysicalDeviceSparseProperties   sparseProperties;
} VkPhysicalDeviceProperties;

typedef struct VkDeviceCreateInfo {
    VkStructureType   sType;
    const  void *      pNext;
    VkDeviceCreateFlags      flags;
    uint32_t          queueCreateInfoCount;
    const  VkDeviceQueueCreateInfo *  pQueueCreateInfos;
    uint32_t                 enabledLayerCount;
    const  char * const*       ppEnabledLayerNames;
    uint32_t                 enabledExtensionCount;
    const  char * const*       ppEnabledExtensionNames;
    const  VkPhysicalDeviceFeatures *  pEnabledFeatures;
} VkDeviceCreateInfo;

typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t                 memoryTypeCount;
    VkMemoryType             memoryTypes [ VK_MAX_MEMORY_TYPES ];
    uint32_t                 memoryHeapCount;
    VkMemoryHeap             memoryHeaps [ VK_MAX_MEMORY_HEAPS ];
} VkPhysicalDeviceMemoryProperties;

typedef struct VkPhysicalDeviceProperties2 {
    VkStructureType   sType;
    void *                             pNext;
    VkPhysicalDeviceProperties         properties;
} VkPhysicalDeviceProperties2;

typedef struct VkPhysicalDeviceProperties2  VkPhysicalDeviceProperties2KHR;

typedef struct VkPhysicalDeviceMemoryProperties2 {
    VkStructureType   sType;
    void *                             pNext;
    VkPhysicalDeviceMemoryProperties   memoryProperties;
} VkPhysicalDeviceMemoryProperties2;

typedef struct VkPhysicalDeviceMemoryProperties2  VkPhysicalDeviceMemoryProperties2KHR;

typedef struct VkPresentRegionsKHR {
    VkStructureType   sType;
    const  void *                       pNext;
    uint32_t                           swapchainCount;
    const  VkPresentRegionKHR *    pRegions;
} VkPresentRegionsKHR;

typedef struct VkDebugUtilsMessengerCreateInfoEXT {
    VkStructureType   sType;
    const  void *                                           pNext;
    VkDebugUtilsMessengerCreateFlagsEXT    flags;
    VkDebugUtilsMessageSeverityFlagsEXT                    messageSeverity;
    VkDebugUtilsMessageTypeFlagsEXT                        messageType;
    PFN_vkDebugUtilsMessengerCallbackEXT                   pfnUserCallback;
    void *                                 pUserData;
} VkDebugUtilsMessengerCreateInfoEXT;

typedef struct VkDrmFormatModifierPropertiesListEXT {
    VkStructureType   sType;
    void *  pNext;
    uint32_t   drmFormatModifierCount;
    VkDrmFormatModifierPropertiesEXT *  pDrmFormatModifierProperties;
} VkDrmFormatModifierPropertiesListEXT;

typedef struct VkFramebufferAttachmentsCreateInfo {
    VkStructureType   sType;
    const  void *                               pNext;
    uint32_t                   attachmentImageInfoCount;
    const  VkFramebufferAttachmentImageInfo *  pAttachmentImageInfos;
} VkFramebufferAttachmentsCreateInfo;

typedef struct VkFramebufferAttachmentsCreateInfo  VkFramebufferAttachmentsCreateInfoKHR;



#define VK_VERSION_1_0 1
GLAD_API_CALL int GLAD_VK_VERSION_1_0;
#define VK_VERSION_1_1 1
GLAD_API_CALL int GLAD_VK_VERSION_1_1;
#define VK_VERSION_1_2 1
GLAD_API_CALL int GLAD_VK_VERSION_1_2;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#define VK_ANDROID_external_memory_android_hardware_buffer 1
GLAD_API_CALL int GLAD_VK_ANDROID_external_memory_android_hardware_buffer;
#endif
#define VK_EXT_4444_formats 1
GLAD_API_CALL int GLAD_VK_EXT_4444_formats;
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
#define VK_EXT_acquire_xlib_display 1
GLAD_API_CALL int GLAD_VK_EXT_acquire_xlib_display;
#endif
#define VK_EXT_astc_decode_mode 1
GLAD_API_CALL int GLAD_VK_EXT_astc_decode_mode;
#define VK_EXT_blend_operation_advanced 1
GLAD_API_CALL int GLAD_VK_EXT_blend_operation_advanced;
#define VK_EXT_buffer_device_address 1
GLAD_API_CALL int GLAD_VK_EXT_buffer_device_address;
#define VK_EXT_calibrated_timestamps 1
GLAD_API_CALL int GLAD_VK_EXT_calibrated_timestamps;
#define VK_EXT_conditional_rendering 1
GLAD_API_CALL int GLAD_VK_EXT_conditional_rendering;
#define VK_EXT_conservative_rasterization 1
GLAD_API_CALL int GLAD_VK_EXT_conservative_rasterization;
#define VK_EXT_custom_border_color 1
GLAD_API_CALL int GLAD_VK_EXT_custom_border_color;
#define VK_EXT_debug_marker 1
GLAD_API_CALL int GLAD_VK_EXT_debug_marker;
#define VK_EXT_debug_report 1
GLAD_API_CALL int GLAD_VK_EXT_debug_report;
#define VK_EXT_debug_utils 1
GLAD_API_CALL int GLAD_VK_EXT_debug_utils;
#define VK_EXT_depth_clip_enable 1
GLAD_API_CALL int GLAD_VK_EXT_depth_clip_enable;
#define VK_EXT_depth_range_unrestricted 1
GLAD_API_CALL int GLAD_VK_EXT_depth_range_unrestricted;
#define VK_EXT_descriptor_indexing 1
GLAD_API_CALL int GLAD_VK_EXT_descriptor_indexing;
#define VK_EXT_direct_mode_display 1
GLAD_API_CALL int GLAD_VK_EXT_direct_mode_display;
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
#define VK_EXT_directfb_surface 1
GLAD_API_CALL int GLAD_VK_EXT_directfb_surface;
#endif
#define VK_EXT_discard_rectangles 1
GLAD_API_CALL int GLAD_VK_EXT_discard_rectangles;
#define VK_EXT_display_control 1
GLAD_API_CALL int GLAD_VK_EXT_display_control;
#define VK_EXT_display_surface_counter 1
GLAD_API_CALL int GLAD_VK_EXT_display_surface_counter;
#define VK_EXT_extended_dynamic_state 1
GLAD_API_CALL int GLAD_VK_EXT_extended_dynamic_state;
#define VK_EXT_external_memory_dma_buf 1
GLAD_API_CALL int GLAD_VK_EXT_external_memory_dma_buf;
#define VK_EXT_external_memory_host 1
GLAD_API_CALL int GLAD_VK_EXT_external_memory_host;
#define VK_EXT_filter_cubic 1
GLAD_API_CALL int GLAD_VK_EXT_filter_cubic;
#define VK_EXT_fragment_density_map 1
GLAD_API_CALL int GLAD_VK_EXT_fragment_density_map;
#define VK_EXT_fragment_density_map2 1
GLAD_API_CALL int GLAD_VK_EXT_fragment_density_map2;
#define VK_EXT_fragment_shader_interlock 1
GLAD_API_CALL int GLAD_VK_EXT_fragment_shader_interlock;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_EXT_full_screen_exclusive 1
GLAD_API_CALL int GLAD_VK_EXT_full_screen_exclusive;
#endif
#define VK_EXT_global_priority 1
GLAD_API_CALL int GLAD_VK_EXT_global_priority;
#define VK_EXT_hdr_metadata 1
GLAD_API_CALL int GLAD_VK_EXT_hdr_metadata;
#define VK_EXT_headless_surface 1
GLAD_API_CALL int GLAD_VK_EXT_headless_surface;
#define VK_EXT_host_query_reset 1
GLAD_API_CALL int GLAD_VK_EXT_host_query_reset;
#define VK_EXT_image_drm_format_modifier 1
GLAD_API_CALL int GLAD_VK_EXT_image_drm_format_modifier;
#define VK_EXT_image_robustness 1
GLAD_API_CALL int GLAD_VK_EXT_image_robustness;
#define VK_EXT_index_type_uint8 1
GLAD_API_CALL int GLAD_VK_EXT_index_type_uint8;
#define VK_EXT_inline_uniform_block 1
GLAD_API_CALL int GLAD_VK_EXT_inline_uniform_block;
#define VK_EXT_line_rasterization 1
GLAD_API_CALL int GLAD_VK_EXT_line_rasterization;
#define VK_EXT_memory_budget 1
GLAD_API_CALL int GLAD_VK_EXT_memory_budget;
#define VK_EXT_memory_priority 1
GLAD_API_CALL int GLAD_VK_EXT_memory_priority;
#if defined(VK_USE_PLATFORM_METAL_EXT)
#define VK_EXT_metal_surface 1
GLAD_API_CALL int GLAD_VK_EXT_metal_surface;
#endif
#define VK_EXT_pci_bus_info 1
GLAD_API_CALL int GLAD_VK_EXT_pci_bus_info;
#define VK_EXT_pipeline_creation_cache_control 1
GLAD_API_CALL int GLAD_VK_EXT_pipeline_creation_cache_control;
#define VK_EXT_pipeline_creation_feedback 1
GLAD_API_CALL int GLAD_VK_EXT_pipeline_creation_feedback;
#define VK_EXT_post_depth_coverage 1
GLAD_API_CALL int GLAD_VK_EXT_post_depth_coverage;
#define VK_EXT_private_data 1
GLAD_API_CALL int GLAD_VK_EXT_private_data;
#define VK_EXT_queue_family_foreign 1
GLAD_API_CALL int GLAD_VK_EXT_queue_family_foreign;
#define VK_EXT_robustness2 1
GLAD_API_CALL int GLAD_VK_EXT_robustness2;
#define VK_EXT_sample_locations 1
GLAD_API_CALL int GLAD_VK_EXT_sample_locations;
#define VK_EXT_sampler_filter_minmax 1
GLAD_API_CALL int GLAD_VK_EXT_sampler_filter_minmax;
#define VK_EXT_scalar_block_layout 1
GLAD_API_CALL int GLAD_VK_EXT_scalar_block_layout;
#define VK_EXT_separate_stencil_usage 1
GLAD_API_CALL int GLAD_VK_EXT_separate_stencil_usage;
#define VK_EXT_shader_atomic_float 1
GLAD_API_CALL int GLAD_VK_EXT_shader_atomic_float;
#define VK_EXT_shader_demote_to_helper_invocation 1
GLAD_API_CALL int GLAD_VK_EXT_shader_demote_to_helper_invocation;
#define VK_EXT_shader_stencil_export 1
GLAD_API_CALL int GLAD_VK_EXT_shader_stencil_export;
#define VK_EXT_shader_subgroup_ballot 1
GLAD_API_CALL int GLAD_VK_EXT_shader_subgroup_ballot;
#define VK_EXT_shader_subgroup_vote 1
GLAD_API_CALL int GLAD_VK_EXT_shader_subgroup_vote;
#define VK_EXT_shader_viewport_index_layer 1
GLAD_API_CALL int GLAD_VK_EXT_shader_viewport_index_layer;
#define VK_EXT_subgroup_size_control 1
GLAD_API_CALL int GLAD_VK_EXT_subgroup_size_control;
#define VK_EXT_swapchain_colorspace 1
GLAD_API_CALL int GLAD_VK_EXT_swapchain_colorspace;
#define VK_EXT_texel_buffer_alignment 1
GLAD_API_CALL int GLAD_VK_EXT_texel_buffer_alignment;
#define VK_EXT_texture_compression_astc_hdr 1
GLAD_API_CALL int GLAD_VK_EXT_texture_compression_astc_hdr;
#define VK_EXT_tooling_info 1
GLAD_API_CALL int GLAD_VK_EXT_tooling_info;
#define VK_EXT_transform_feedback 1
GLAD_API_CALL int GLAD_VK_EXT_transform_feedback;
#define VK_EXT_validation_cache 1
GLAD_API_CALL int GLAD_VK_EXT_validation_cache;
#define VK_EXT_validation_features 1
GLAD_API_CALL int GLAD_VK_EXT_validation_features;
#define VK_EXT_validation_flags 1
GLAD_API_CALL int GLAD_VK_EXT_validation_flags;
#define VK_EXT_vertex_attribute_divisor 1
GLAD_API_CALL int GLAD_VK_EXT_vertex_attribute_divisor;
#define VK_EXT_ycbcr_image_arrays 1
GLAD_API_CALL int GLAD_VK_EXT_ycbcr_image_arrays;
#define VK_KHR_16bit_storage 1
GLAD_API_CALL int GLAD_VK_KHR_16bit_storage;
#define VK_KHR_8bit_storage 1
GLAD_API_CALL int GLAD_VK_KHR_8bit_storage;
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#define VK_KHR_android_surface 1
GLAD_API_CALL int GLAD_VK_KHR_android_surface;
#endif
#define VK_KHR_bind_memory2 1
GLAD_API_CALL int GLAD_VK_KHR_bind_memory2;
#define VK_KHR_buffer_device_address 1
GLAD_API_CALL int GLAD_VK_KHR_buffer_device_address;
#define VK_KHR_create_renderpass2 1
GLAD_API_CALL int GLAD_VK_KHR_create_renderpass2;
#define VK_KHR_dedicated_allocation 1
GLAD_API_CALL int GLAD_VK_KHR_dedicated_allocation;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_KHR_deferred_host_operations 1
GLAD_API_CALL int GLAD_VK_KHR_deferred_host_operations;
#endif
#define VK_KHR_depth_stencil_resolve 1
GLAD_API_CALL int GLAD_VK_KHR_depth_stencil_resolve;
#define VK_KHR_descriptor_update_template 1
GLAD_API_CALL int GLAD_VK_KHR_descriptor_update_template;
#define VK_KHR_device_group 1
GLAD_API_CALL int GLAD_VK_KHR_device_group;
#define VK_KHR_device_group_creation 1
GLAD_API_CALL int GLAD_VK_KHR_device_group_creation;
#define VK_KHR_display 1
GLAD_API_CALL int GLAD_VK_KHR_display;
#define VK_KHR_display_swapchain 1
GLAD_API_CALL int GLAD_VK_KHR_display_swapchain;
#define VK_KHR_draw_indirect_count 1
GLAD_API_CALL int GLAD_VK_KHR_draw_indirect_count;
#define VK_KHR_driver_properties 1
GLAD_API_CALL int GLAD_VK_KHR_driver_properties;
#define VK_KHR_external_fence 1
GLAD_API_CALL int GLAD_VK_KHR_external_fence;
#define VK_KHR_external_fence_capabilities 1
GLAD_API_CALL int GLAD_VK_KHR_external_fence_capabilities;
#define VK_KHR_external_fence_fd 1
GLAD_API_CALL int GLAD_VK_KHR_external_fence_fd;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_external_fence_win32 1
GLAD_API_CALL int GLAD_VK_KHR_external_fence_win32;
#endif
#define VK_KHR_external_memory 1
GLAD_API_CALL int GLAD_VK_KHR_external_memory;
#define VK_KHR_external_memory_capabilities 1
GLAD_API_CALL int GLAD_VK_KHR_external_memory_capabilities;
#define VK_KHR_external_memory_fd 1
GLAD_API_CALL int GLAD_VK_KHR_external_memory_fd;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_external_memory_win32 1
GLAD_API_CALL int GLAD_VK_KHR_external_memory_win32;
#endif
#define VK_KHR_external_semaphore 1
GLAD_API_CALL int GLAD_VK_KHR_external_semaphore;
#define VK_KHR_external_semaphore_capabilities 1
GLAD_API_CALL int GLAD_VK_KHR_external_semaphore_capabilities;
#define VK_KHR_external_semaphore_fd 1
GLAD_API_CALL int GLAD_VK_KHR_external_semaphore_fd;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_external_semaphore_win32 1
GLAD_API_CALL int GLAD_VK_KHR_external_semaphore_win32;
#endif
#define VK_KHR_get_display_properties2 1
GLAD_API_CALL int GLAD_VK_KHR_get_display_properties2;
#define VK_KHR_get_memory_requirements2 1
GLAD_API_CALL int GLAD_VK_KHR_get_memory_requirements2;
#define VK_KHR_get_physical_device_properties2 1
GLAD_API_CALL int GLAD_VK_KHR_get_physical_device_properties2;
#define VK_KHR_get_surface_capabilities2 1
GLAD_API_CALL int GLAD_VK_KHR_get_surface_capabilities2;
#define VK_KHR_image_format_list 1
GLAD_API_CALL int GLAD_VK_KHR_image_format_list;
#define VK_KHR_imageless_framebuffer 1
GLAD_API_CALL int GLAD_VK_KHR_imageless_framebuffer;
#define VK_KHR_incremental_present 1
GLAD_API_CALL int GLAD_VK_KHR_incremental_present;
#define VK_KHR_maintenance1 1
GLAD_API_CALL int GLAD_VK_KHR_maintenance1;
#define VK_KHR_maintenance2 1
GLAD_API_CALL int GLAD_VK_KHR_maintenance2;
#define VK_KHR_maintenance3 1
GLAD_API_CALL int GLAD_VK_KHR_maintenance3;
#define VK_KHR_multiview 1
GLAD_API_CALL int GLAD_VK_KHR_multiview;
#define VK_KHR_performance_query 1
GLAD_API_CALL int GLAD_VK_KHR_performance_query;
#define VK_KHR_pipeline_executable_properties 1
GLAD_API_CALL int GLAD_VK_KHR_pipeline_executable_properties;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_KHR_pipeline_library 1
GLAD_API_CALL int GLAD_VK_KHR_pipeline_library;
#endif
#define VK_KHR_push_descriptor 1
GLAD_API_CALL int GLAD_VK_KHR_push_descriptor;
#if defined(VK_ENABLE_BETA_EXTENSIONS)
#define VK_KHR_ray_tracing 1
GLAD_API_CALL int GLAD_VK_KHR_ray_tracing;
#endif
#define VK_KHR_relaxed_block_layout 1
GLAD_API_CALL int GLAD_VK_KHR_relaxed_block_layout;
#define VK_KHR_sampler_mirror_clamp_to_edge 1
GLAD_API_CALL int GLAD_VK_KHR_sampler_mirror_clamp_to_edge;
#define VK_KHR_sampler_ycbcr_conversion 1
GLAD_API_CALL int GLAD_VK_KHR_sampler_ycbcr_conversion;
#define VK_KHR_separate_depth_stencil_layouts 1
GLAD_API_CALL int GLAD_VK_KHR_separate_depth_stencil_layouts;
#define VK_KHR_shader_atomic_int64 1
GLAD_API_CALL int GLAD_VK_KHR_shader_atomic_int64;
#define VK_KHR_shader_clock 1
GLAD_API_CALL int GLAD_VK_KHR_shader_clock;
#define VK_KHR_shader_draw_parameters 1
GLAD_API_CALL int GLAD_VK_KHR_shader_draw_parameters;
#define VK_KHR_shader_float16_int8 1
GLAD_API_CALL int GLAD_VK_KHR_shader_float16_int8;
#define VK_KHR_shader_float_controls 1
GLAD_API_CALL int GLAD_VK_KHR_shader_float_controls;
#define VK_KHR_shader_non_semantic_info 1
GLAD_API_CALL int GLAD_VK_KHR_shader_non_semantic_info;
#define VK_KHR_shader_subgroup_extended_types 1
GLAD_API_CALL int GLAD_VK_KHR_shader_subgroup_extended_types;
#define VK_KHR_shared_presentable_image 1
GLAD_API_CALL int GLAD_VK_KHR_shared_presentable_image;
#define VK_KHR_spirv_1_4 1
GLAD_API_CALL int GLAD_VK_KHR_spirv_1_4;
#define VK_KHR_storage_buffer_storage_class 1
GLAD_API_CALL int GLAD_VK_KHR_storage_buffer_storage_class;
#define VK_KHR_surface 1
GLAD_API_CALL int GLAD_VK_KHR_surface;
#define VK_KHR_surface_protected_capabilities 1
GLAD_API_CALL int GLAD_VK_KHR_surface_protected_capabilities;
#define VK_KHR_swapchain 1
GLAD_API_CALL int GLAD_VK_KHR_swapchain;
#define VK_KHR_swapchain_mutable_format 1
GLAD_API_CALL int GLAD_VK_KHR_swapchain_mutable_format;
#define VK_KHR_timeline_semaphore 1
GLAD_API_CALL int GLAD_VK_KHR_timeline_semaphore;
#define VK_KHR_uniform_buffer_standard_layout 1
GLAD_API_CALL int GLAD_VK_KHR_uniform_buffer_standard_layout;
#define VK_KHR_variable_pointers 1
GLAD_API_CALL int GLAD_VK_KHR_variable_pointers;
#define VK_KHR_vulkan_memory_model 1
GLAD_API_CALL int GLAD_VK_KHR_vulkan_memory_model;
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
#define VK_KHR_wayland_surface 1
GLAD_API_CALL int GLAD_VK_KHR_wayland_surface;
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_win32_keyed_mutex 1
GLAD_API_CALL int GLAD_VK_KHR_win32_keyed_mutex;
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#define VK_KHR_win32_surface 1
GLAD_API_CALL int GLAD_VK_KHR_win32_surface;
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
#define VK_KHR_xcb_surface 1
GLAD_API_CALL int GLAD_VK_KHR_xcb_surface;
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
#define VK_KHR_xlib_surface 1
GLAD_API_CALL int GLAD_VK_KHR_xlib_surface;
#endif


#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkAcquireFullScreenExclusiveModeEXT)(VkDevice device, VkSwapchainKHR swapchain);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkAcquireNextImage2KHR)(VkDevice device, const VkAcquireNextImageInfoKHR * pAcquireInfo, uint32_t * pImageIndex);
typedef VkResult (GLAD_API_PTR *PFN_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t * pImageIndex);
typedef VkResult (GLAD_API_PTR *PFN_vkAcquireProfilingLockKHR)(VkDevice device, const VkAcquireProfilingLockInfoKHR * pInfo);
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
typedef VkResult (GLAD_API_PTR *PFN_vkAcquireXlibDisplayEXT)(VkPhysicalDevice physicalDevice, Display * dpy, VkDisplayKHR display);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkAllocateCommandBuffers)(VkDevice device, const VkCommandBufferAllocateInfo * pAllocateInfo, VkCommandBuffer * pCommandBuffers);
typedef VkResult (GLAD_API_PTR *PFN_vkAllocateDescriptorSets)(VkDevice device, const VkDescriptorSetAllocateInfo * pAllocateInfo, VkDescriptorSet * pDescriptorSets);
typedef VkResult (GLAD_API_PTR *PFN_vkAllocateMemory)(VkDevice device, const VkMemoryAllocateInfo * pAllocateInfo, const VkAllocationCallbacks * pAllocator, VkDeviceMemory * pMemory);
typedef VkResult (GLAD_API_PTR *PFN_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo * pBeginInfo);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkBindAccelerationStructureMemoryKHR)(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoKHR * pBindInfos);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef VkResult (GLAD_API_PTR *PFN_vkBindBufferMemory2)(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo * pBindInfos);
typedef VkResult (GLAD_API_PTR *PFN_vkBindBufferMemory2KHR)(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo * pBindInfos);
typedef VkResult (GLAD_API_PTR *PFN_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef VkResult (GLAD_API_PTR *PFN_vkBindImageMemory2)(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo * pBindInfos);
typedef VkResult (GLAD_API_PTR *PFN_vkBindImageMemory2KHR)(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo * pBindInfos);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkBuildAccelerationStructureKHR)(VkDevice device, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR * pInfos, const VkAccelerationStructureBuildOffsetInfoKHR * const* ppOffsetInfos);
#endif
typedef void (GLAD_API_PTR *PFN_vkCmdBeginConditionalRenderingEXT)(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT * pConditionalRenderingBegin);
typedef void (GLAD_API_PTR *PFN_vkCmdBeginDebugUtilsLabelEXT)(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT * pLabelInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
typedef void (GLAD_API_PTR *PFN_vkCmdBeginQueryIndexedEXT)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index);
typedef void (GLAD_API_PTR *PFN_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo * pRenderPassBegin, VkSubpassContents contents);
typedef void (GLAD_API_PTR *PFN_vkCmdBeginRenderPass2)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo * pRenderPassBegin, const VkSubpassBeginInfo * pSubpassBeginInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdBeginRenderPass2KHR)(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo * pRenderPassBegin, const VkSubpassBeginInfo * pSubpassBeginInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdBeginTransformFeedbackEXT)(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer * pCounterBuffers, const VkDeviceSize * pCounterBufferOffsets);
typedef void (GLAD_API_PTR *PFN_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet * pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t * pDynamicOffsets);
typedef void (GLAD_API_PTR *PFN_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
typedef void (GLAD_API_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
typedef void (GLAD_API_PTR *PFN_vkCmdBindTransformFeedbackBuffersEXT)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer * pBuffers, const VkDeviceSize * pOffsets, const VkDeviceSize * pSizes);
typedef void (GLAD_API_PTR *PFN_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer * pBuffers, const VkDeviceSize * pOffsets);
typedef void (GLAD_API_PTR *PFN_vkCmdBindVertexBuffers2EXT)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer * pBuffers, const VkDeviceSize * pOffsets, const VkDeviceSize * pSizes, const VkDeviceSize * pStrides);
typedef void (GLAD_API_PTR *PFN_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit * pRegions, VkFilter filter);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkCmdBuildAccelerationStructureIndirectKHR)(VkCommandBuffer commandBuffer, const VkAccelerationStructureBuildGeometryInfoKHR * pInfo, VkBuffer indirectBuffer, VkDeviceSize indirectOffset, uint32_t indirectStride);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkCmdBuildAccelerationStructureKHR)(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR * pInfos, const VkAccelerationStructureBuildOffsetInfoKHR * const* ppOffsetInfos);
#endif
typedef void (GLAD_API_PTR *PFN_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment * pAttachments, uint32_t rectCount, const VkClearRect * pRects);
typedef void (GLAD_API_PTR *PFN_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue * pColor, uint32_t rangeCount, const VkImageSubresourceRange * pRanges);
typedef void (GLAD_API_PTR *PFN_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue * pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange * pRanges);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkCmdCopyAccelerationStructureKHR)(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR * pInfo);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkCmdCopyAccelerationStructureToMemoryKHR)(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR * pInfo);
#endif
typedef void (GLAD_API_PTR *PFN_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy * pRegions);
typedef void (GLAD_API_PTR *PFN_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy * pRegions);
typedef void (GLAD_API_PTR *PFN_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy * pRegions);
typedef void (GLAD_API_PTR *PFN_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy * pRegions);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkCmdCopyMemoryToAccelerationStructureKHR)(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR * pInfo);
#endif
typedef void (GLAD_API_PTR *PFN_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
typedef void (GLAD_API_PTR *PFN_vkCmdDebugMarkerBeginEXT)(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT * pMarkerInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdDebugMarkerEndEXT)(VkCommandBuffer commandBuffer);
typedef void (GLAD_API_PTR *PFN_vkCmdDebugMarkerInsertEXT)(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT * pMarkerInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef void (GLAD_API_PTR *PFN_vkCmdDispatchBase)(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef void (GLAD_API_PTR *PFN_vkCmdDispatchBaseKHR)(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
typedef void (GLAD_API_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
typedef void (GLAD_API_PTR *PFN_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
typedef void (GLAD_API_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
typedef void (GLAD_API_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (GLAD_API_PTR *PFN_vkCmdDrawIndexedIndirectCount)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef void (GLAD_API_PTR *PFN_vkCmdDrawIndexedIndirectCountKHR)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef void (GLAD_API_PTR *PFN_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (GLAD_API_PTR *PFN_vkCmdDrawIndirectByteCountEXT)(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride);
typedef void (GLAD_API_PTR *PFN_vkCmdDrawIndirectCount)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef void (GLAD_API_PTR *PFN_vkCmdDrawIndirectCountKHR)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef void (GLAD_API_PTR *PFN_vkCmdEndConditionalRenderingEXT)(VkCommandBuffer commandBuffer);
typedef void (GLAD_API_PTR *PFN_vkCmdEndDebugUtilsLabelEXT)(VkCommandBuffer commandBuffer);
typedef void (GLAD_API_PTR *PFN_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
typedef void (GLAD_API_PTR *PFN_vkCmdEndQueryIndexedEXT)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index);
typedef void (GLAD_API_PTR *PFN_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
typedef void (GLAD_API_PTR *PFN_vkCmdEndRenderPass2)(VkCommandBuffer commandBuffer, const VkSubpassEndInfo * pSubpassEndInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdEndRenderPass2KHR)(VkCommandBuffer commandBuffer, const VkSubpassEndInfo * pSubpassEndInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdEndTransformFeedbackEXT)(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer * pCounterBuffers, const VkDeviceSize * pCounterBufferOffsets);
typedef void (GLAD_API_PTR *PFN_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer * pCommandBuffers);
typedef void (GLAD_API_PTR *PFN_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
typedef void (GLAD_API_PTR *PFN_vkCmdInsertDebugUtilsLabelEXT)(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT * pLabelInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
typedef void (GLAD_API_PTR *PFN_vkCmdNextSubpass2)(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo * pSubpassBeginInfo, const VkSubpassEndInfo * pSubpassEndInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdNextSubpass2KHR)(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo * pSubpassBeginInfo, const VkSubpassEndInfo * pSubpassEndInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier * pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier * pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier * pImageMemoryBarriers);
typedef void (GLAD_API_PTR *PFN_vkCmdPushConstants)(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void * pValues);
typedef void (GLAD_API_PTR *PFN_vkCmdPushDescriptorSetKHR)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet * pDescriptorWrites);
typedef void (GLAD_API_PTR *PFN_vkCmdPushDescriptorSetWithTemplateKHR)(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void * pData);
typedef void (GLAD_API_PTR *PFN_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (GLAD_API_PTR *PFN_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef void (GLAD_API_PTR *PFN_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve * pRegions);
typedef void (GLAD_API_PTR *PFN_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, const float blendConstants [4]);
typedef void (GLAD_API_PTR *PFN_vkCmdSetCullModeEXT)(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode);
typedef void (GLAD_API_PTR *PFN_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
typedef void (GLAD_API_PTR *PFN_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
typedef void (GLAD_API_PTR *PFN_vkCmdSetDepthBoundsTestEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable);
typedef void (GLAD_API_PTR *PFN_vkCmdSetDepthCompareOpEXT)(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp);
typedef void (GLAD_API_PTR *PFN_vkCmdSetDepthTestEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable);
typedef void (GLAD_API_PTR *PFN_vkCmdSetDepthWriteEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable);
typedef void (GLAD_API_PTR *PFN_vkCmdSetDeviceMask)(VkCommandBuffer commandBuffer, uint32_t deviceMask);
typedef void (GLAD_API_PTR *PFN_vkCmdSetDeviceMaskKHR)(VkCommandBuffer commandBuffer, uint32_t deviceMask);
typedef void (GLAD_API_PTR *PFN_vkCmdSetDiscardRectangleEXT)(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D * pDiscardRectangles);
typedef void (GLAD_API_PTR *PFN_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (GLAD_API_PTR *PFN_vkCmdSetFrontFaceEXT)(VkCommandBuffer commandBuffer, VkFrontFace frontFace);
typedef void (GLAD_API_PTR *PFN_vkCmdSetLineStippleEXT)(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern);
typedef void (GLAD_API_PTR *PFN_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
typedef void (GLAD_API_PTR *PFN_vkCmdSetPrimitiveTopologyEXT)(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology);
typedef void (GLAD_API_PTR *PFN_vkCmdSetSampleLocationsEXT)(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT * pSampleLocationsInfo);
typedef void (GLAD_API_PTR *PFN_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D * pScissors);
typedef void (GLAD_API_PTR *PFN_vkCmdSetScissorWithCountEXT)(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D * pScissors);
typedef void (GLAD_API_PTR *PFN_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
typedef void (GLAD_API_PTR *PFN_vkCmdSetStencilOpEXT)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp);
typedef void (GLAD_API_PTR *PFN_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
typedef void (GLAD_API_PTR *PFN_vkCmdSetStencilTestEnableEXT)(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable);
typedef void (GLAD_API_PTR *PFN_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
typedef void (GLAD_API_PTR *PFN_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport * pViewports);
typedef void (GLAD_API_PTR *PFN_vkCmdSetViewportWithCountEXT)(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport * pViewports);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkCmdTraceRaysIndirectKHR)(VkCommandBuffer commandBuffer, const VkStridedBufferRegionKHR * pRaygenShaderBindingTable, const VkStridedBufferRegionKHR * pMissShaderBindingTable, const VkStridedBufferRegionKHR * pHitShaderBindingTable, const VkStridedBufferRegionKHR * pCallableShaderBindingTable, VkBuffer buffer, VkDeviceSize offset);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkCmdTraceRaysKHR)(VkCommandBuffer commandBuffer, const VkStridedBufferRegionKHR * pRaygenShaderBindingTable, const VkStridedBufferRegionKHR * pMissShaderBindingTable, const VkStridedBufferRegionKHR * pHitShaderBindingTable, const VkStridedBufferRegionKHR * pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth);
#endif
typedef void (GLAD_API_PTR *PFN_vkCmdUpdateBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void * pData);
typedef void (GLAD_API_PTR *PFN_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent * pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier * pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier * pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier * pImageMemoryBarriers);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR * pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery);
#endif
typedef void (GLAD_API_PTR *PFN_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkCopyAccelerationStructureKHR)(VkDevice device, const VkCopyAccelerationStructureInfoKHR * pInfo);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkCopyAccelerationStructureToMemoryKHR)(VkDevice device, const VkCopyAccelerationStructureToMemoryInfoKHR * pInfo);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkCopyMemoryToAccelerationStructureKHR)(VkDevice device, const VkCopyMemoryToAccelerationStructureInfoKHR * pInfo);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateAccelerationStructureKHR)(VkDevice device, const VkAccelerationStructureCreateInfoKHR * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkAccelerationStructureKHR * pAccelerationStructure);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateAndroidSurfaceKHR)(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSurfaceKHR * pSurface);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkCreateBuffer)(VkDevice device, const VkBufferCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkBuffer * pBuffer);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateBufferView)(VkDevice device, const VkBufferViewCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkBufferView * pView);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateCommandPool)(VkDevice device, const VkCommandPoolCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkCommandPool * pCommandPool);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo * pCreateInfos, const VkAllocationCallbacks * pAllocator, VkPipeline * pPipelines);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDebugReportCallbackEXT)(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkDebugReportCallbackEXT * pCallback);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDebugUtilsMessengerEXT)(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkDebugUtilsMessengerEXT * pMessenger);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDeferredOperationKHR)(VkDevice device, const VkAllocationCallbacks * pAllocator, VkDeferredOperationKHR * pDeferredOperation);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDescriptorPool)(VkDevice device, const VkDescriptorPoolCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkDescriptorPool * pDescriptorPool);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDescriptorSetLayout)(VkDevice device, const VkDescriptorSetLayoutCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkDescriptorSetLayout * pSetLayout);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDescriptorUpdateTemplate)(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkDescriptorUpdateTemplate * pDescriptorUpdateTemplate);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDescriptorUpdateTemplateKHR)(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkDescriptorUpdateTemplate * pDescriptorUpdateTemplate);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDevice)(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkDevice * pDevice);
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDirectFBSurfaceEXT)(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSurfaceKHR * pSurface);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkDisplayModeKHR * pMode);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSurfaceKHR * pSurface);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateEvent)(VkDevice device, const VkEventCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkEvent * pEvent);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateFence)(VkDevice device, const VkFenceCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkFence * pFence);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateFramebuffer)(VkDevice device, const VkFramebufferCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkFramebuffer * pFramebuffer);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo * pCreateInfos, const VkAllocationCallbacks * pAllocator, VkPipeline * pPipelines);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateHeadlessSurfaceEXT)(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSurfaceKHR * pSurface);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateImage)(VkDevice device, const VkImageCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkImage * pImage);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateImageView)(VkDevice device, const VkImageViewCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkImageView * pView);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateInstance)(const VkInstanceCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkInstance * pInstance);
#if defined(VK_USE_PLATFORM_METAL_EXT)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateMetalSurfaceEXT)(VkInstance instance, const VkMetalSurfaceCreateInfoEXT * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSurfaceKHR * pSurface);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkCreatePipelineCache)(VkDevice device, const VkPipelineCacheCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkPipelineCache * pPipelineCache);
typedef VkResult (GLAD_API_PTR *PFN_vkCreatePipelineLayout)(VkDevice device, const VkPipelineLayoutCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkPipelineLayout * pPipelineLayout);
typedef VkResult (GLAD_API_PTR *PFN_vkCreatePrivateDataSlotEXT)(VkDevice device, const VkPrivateDataSlotCreateInfoEXT * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkPrivateDataSlotEXT * pPrivateDataSlot);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateQueryPool)(VkDevice device, const VkQueryPoolCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkQueryPool * pQueryPool);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateRayTracingPipelinesKHR)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR * pCreateInfos, const VkAllocationCallbacks * pAllocator, VkPipeline * pPipelines);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkCreateRenderPass)(VkDevice device, const VkRenderPassCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkRenderPass * pRenderPass);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateRenderPass2)(VkDevice device, const VkRenderPassCreateInfo2 * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkRenderPass * pRenderPass);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateRenderPass2KHR)(VkDevice device, const VkRenderPassCreateInfo2 * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkRenderPass * pRenderPass);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateSampler)(VkDevice device, const VkSamplerCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSampler * pSampler);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateSamplerYcbcrConversion)(VkDevice device, const VkSamplerYcbcrConversionCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSamplerYcbcrConversion * pYcbcrConversion);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateSamplerYcbcrConversionKHR)(VkDevice device, const VkSamplerYcbcrConversionCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSamplerYcbcrConversion * pYcbcrConversion);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateSemaphore)(VkDevice device, const VkSemaphoreCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSemaphore * pSemaphore);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateShaderModule)(VkDevice device, const VkShaderModuleCreateInfo * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkShaderModule * pShaderModule);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR * pCreateInfos, const VkAllocationCallbacks * pAllocator, VkSwapchainKHR * pSwapchains);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateSwapchainKHR)(VkDevice device, const VkSwapchainCreateInfoKHR * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSwapchainKHR * pSwapchain);
typedef VkResult (GLAD_API_PTR *PFN_vkCreateValidationCacheEXT)(VkDevice device, const VkValidationCacheCreateInfoEXT * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkValidationCacheEXT * pValidationCache);
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateWaylandSurfaceKHR)(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSurfaceKHR * pSurface);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateWin32SurfaceKHR)(VkInstance instance, const VkWin32SurfaceCreateInfoKHR * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSurfaceKHR * pSurface);
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, const VkXcbSurfaceCreateInfoKHR * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSurfaceKHR * pSurface);
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkCreateXlibSurfaceKHR)(VkInstance instance, const VkXlibSurfaceCreateInfoKHR * pCreateInfo, const VkAllocationCallbacks * pAllocator, VkSurfaceKHR * pSurface);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkDebugMarkerSetObjectNameEXT)(VkDevice device, const VkDebugMarkerObjectNameInfoEXT * pNameInfo);
typedef VkResult (GLAD_API_PTR *PFN_vkDebugMarkerSetObjectTagEXT)(VkDevice device, const VkDebugMarkerObjectTagInfoEXT * pTagInfo);
typedef void (GLAD_API_PTR *PFN_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char * pLayerPrefix, const char * pMessage);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkDeferredOperationJoinKHR)(VkDevice device, VkDeferredOperationKHR operation);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkDestroyAccelerationStructureKHR)(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks * pAllocator);
#endif
typedef void (GLAD_API_PTR *PFN_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyDebugUtilsMessengerEXT)(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks * pAllocator);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkDestroyDeferredOperationKHR)(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks * pAllocator);
#endif
typedef void (GLAD_API_PTR *PFN_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyDescriptorUpdateTemplate)(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyDescriptorUpdateTemplateKHR)(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyDevice)(VkDevice device, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyEvent)(VkDevice device, VkEvent event, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyImage)(VkDevice device, VkImage image, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyImageView)(VkDevice device, VkImageView imageView, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyInstance)(VkInstance instance, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyPrivateDataSlotEXT)(VkDevice device, VkPrivateDataSlotEXT privateDataSlot, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroySampler)(VkDevice device, VkSampler sampler, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroySamplerYcbcrConversion)(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroySamplerYcbcrConversionKHR)(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks * pAllocator);
typedef void (GLAD_API_PTR *PFN_vkDestroyValidationCacheEXT)(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks * pAllocator);
typedef VkResult (GLAD_API_PTR *PFN_vkDeviceWaitIdle)(VkDevice device);
typedef VkResult (GLAD_API_PTR *PFN_vkDisplayPowerControlEXT)(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT * pDisplayPowerInfo);
typedef VkResult (GLAD_API_PTR *PFN_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
typedef VkResult (GLAD_API_PTR *PFN_vkEnumerateDeviceExtensionProperties)(VkPhysicalDevice physicalDevice, const char * pLayerName, uint32_t * pPropertyCount, VkExtensionProperties * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkEnumerateDeviceLayerProperties)(VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, VkLayerProperties * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkEnumerateInstanceExtensionProperties)(const char * pLayerName, uint32_t * pPropertyCount, VkExtensionProperties * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkEnumerateInstanceLayerProperties)(uint32_t * pPropertyCount, VkLayerProperties * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkEnumerateInstanceVersion)(uint32_t * pApiVersion);
typedef VkResult (GLAD_API_PTR *PFN_vkEnumeratePhysicalDeviceGroups)(VkInstance instance, uint32_t * pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkEnumeratePhysicalDeviceGroupsKHR)(VkInstance instance, uint32_t * pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties * pPhysicalDeviceGroupProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t * pCounterCount, VkPerformanceCounterKHR * pCounters, VkPerformanceCounterDescriptionKHR * pCounterDescriptions);
typedef VkResult (GLAD_API_PTR *PFN_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t * pPhysicalDeviceCount, VkPhysicalDevice * pPhysicalDevices);
typedef VkResult (GLAD_API_PTR *PFN_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange * pMemoryRanges);
typedef void (GLAD_API_PTR *PFN_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer * pCommandBuffers);
typedef VkResult (GLAD_API_PTR *PFN_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet * pDescriptorSets);
typedef void (GLAD_API_PTR *PFN_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks * pAllocator);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkDeviceAddress (GLAD_API_PTR *PFN_vkGetAccelerationStructureDeviceAddressKHR)(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR * pInfo);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef void (GLAD_API_PTR *PFN_vkGetAccelerationStructureMemoryRequirementsKHR)(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoKHR * pInfo, VkMemoryRequirements2 * pMemoryRequirements);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkGetAndroidHardwareBufferPropertiesANDROID)(VkDevice device, const struct AHardwareBuffer * buffer, VkAndroidHardwareBufferPropertiesANDROID * pProperties);
#endif
typedef VkDeviceAddress (GLAD_API_PTR *PFN_vkGetBufferDeviceAddress)(VkDevice device, const VkBufferDeviceAddressInfo * pInfo);
typedef VkDeviceAddress (GLAD_API_PTR *PFN_vkGetBufferDeviceAddressEXT)(VkDevice device, const VkBufferDeviceAddressInfo * pInfo);
typedef VkDeviceAddress (GLAD_API_PTR *PFN_vkGetBufferDeviceAddressKHR)(VkDevice device, const VkBufferDeviceAddressInfo * pInfo);
typedef void (GLAD_API_PTR *PFN_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements * pMemoryRequirements);
typedef void (GLAD_API_PTR *PFN_vkGetBufferMemoryRequirements2)(VkDevice device, const VkBufferMemoryRequirementsInfo2 * pInfo, VkMemoryRequirements2 * pMemoryRequirements);
typedef void (GLAD_API_PTR *PFN_vkGetBufferMemoryRequirements2KHR)(VkDevice device, const VkBufferMemoryRequirementsInfo2 * pInfo, VkMemoryRequirements2 * pMemoryRequirements);
typedef uint64_t (GLAD_API_PTR *PFN_vkGetBufferOpaqueCaptureAddress)(VkDevice device, const VkBufferDeviceAddressInfo * pInfo);
typedef uint64_t (GLAD_API_PTR *PFN_vkGetBufferOpaqueCaptureAddressKHR)(VkDevice device, const VkBufferDeviceAddressInfo * pInfo);
typedef VkResult (GLAD_API_PTR *PFN_vkGetCalibratedTimestampsEXT)(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT * pTimestampInfos, uint64_t * pTimestamps, uint64_t * pMaxDeviation);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef uint32_t (GLAD_API_PTR *PFN_vkGetDeferredOperationMaxConcurrencyKHR)(VkDevice device, VkDeferredOperationKHR operation);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkGetDeferredOperationResultKHR)(VkDevice device, VkDeferredOperationKHR operation);
#endif
typedef void (GLAD_API_PTR *PFN_vkGetDescriptorSetLayoutSupport)(VkDevice device, const VkDescriptorSetLayoutCreateInfo * pCreateInfo, VkDescriptorSetLayoutSupport * pSupport);
typedef void (GLAD_API_PTR *PFN_vkGetDescriptorSetLayoutSupportKHR)(VkDevice device, const VkDescriptorSetLayoutCreateInfo * pCreateInfo, VkDescriptorSetLayoutSupport * pSupport);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)(VkDevice device, const VkAccelerationStructureVersionKHR * version);
#endif
typedef void (GLAD_API_PTR *PFN_vkGetDeviceGroupPeerMemoryFeatures)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags * pPeerMemoryFeatures);
typedef void (GLAD_API_PTR *PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR)(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags * pPeerMemoryFeatures);
typedef VkResult (GLAD_API_PTR *PFN_vkGetDeviceGroupPresentCapabilitiesKHR)(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR * pDeviceGroupPresentCapabilities);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkGetDeviceGroupSurfacePresentModes2EXT)(VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR * pModes);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkGetDeviceGroupSurfacePresentModesKHR)(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR * pModes);
typedef void (GLAD_API_PTR *PFN_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize * pCommittedMemoryInBytes);
typedef uint64_t (GLAD_API_PTR *PFN_vkGetDeviceMemoryOpaqueCaptureAddress)(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo * pInfo);
typedef uint64_t (GLAD_API_PTR *PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR)(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo * pInfo);
typedef PFN_vkVoidFunction (GLAD_API_PTR *PFN_vkGetDeviceProcAddr)(VkDevice device, const char * pName);
typedef void (GLAD_API_PTR *PFN_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue * pQueue);
typedef void (GLAD_API_PTR *PFN_vkGetDeviceQueue2)(VkDevice device, const VkDeviceQueueInfo2 * pQueueInfo, VkQueue * pQueue);
typedef VkResult (GLAD_API_PTR *PFN_vkGetDisplayModeProperties2KHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t * pPropertyCount, VkDisplayModeProperties2KHR * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t * pPropertyCount, VkDisplayModePropertiesKHR * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetDisplayPlaneCapabilities2KHR)(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR * pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR * pCapabilities);
typedef VkResult (GLAD_API_PTR *PFN_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR * pCapabilities);
typedef VkResult (GLAD_API_PTR *PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t * pDisplayCount, VkDisplayKHR * pDisplays);
typedef VkResult (GLAD_API_PTR *PFN_vkGetEventStatus)(VkDevice device, VkEvent event);
typedef VkResult (GLAD_API_PTR *PFN_vkGetFenceFdKHR)(VkDevice device, const VkFenceGetFdInfoKHR * pGetFdInfo, int * pFd);
typedef VkResult (GLAD_API_PTR *PFN_vkGetFenceStatus)(VkDevice device, VkFence fence);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkGetFenceWin32HandleKHR)(VkDevice device, const VkFenceGetWin32HandleInfoKHR * pGetWin32HandleInfo, HANDLE * pHandle);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkGetImageDrmFormatModifierPropertiesEXT)(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT * pProperties);
typedef void (GLAD_API_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements * pMemoryRequirements);
typedef void (GLAD_API_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice device, const VkImageMemoryRequirementsInfo2 * pInfo, VkMemoryRequirements2 * pMemoryRequirements);
typedef void (GLAD_API_PTR *PFN_vkGetImageMemoryRequirements2KHR)(VkDevice device, const VkImageMemoryRequirementsInfo2 * pInfo, VkMemoryRequirements2 * pMemoryRequirements);
typedef void (GLAD_API_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t * pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements * pSparseMemoryRequirements);
typedef void (GLAD_API_PTR *PFN_vkGetImageSparseMemoryRequirements2)(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 * pInfo, uint32_t * pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements);
typedef void (GLAD_API_PTR *PFN_vkGetImageSparseMemoryRequirements2KHR)(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 * pInfo, uint32_t * pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 * pSparseMemoryRequirements);
typedef void (GLAD_API_PTR *PFN_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, const VkImageSubresource * pSubresource, VkSubresourceLayout * pLayout);
typedef PFN_vkVoidFunction (GLAD_API_PTR *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char * pName);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkGetMemoryAndroidHardwareBufferANDROID)(VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID * pInfo, struct AHardwareBuffer ** pBuffer);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkGetMemoryFdKHR)(VkDevice device, const VkMemoryGetFdInfoKHR * pGetFdInfo, int * pFd);
typedef VkResult (GLAD_API_PTR *PFN_vkGetMemoryFdPropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR * pMemoryFdProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetMemoryHostPointerPropertiesEXT)(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void * pHostPointer, VkMemoryHostPointerPropertiesEXT * pMemoryHostPointerProperties);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkGetMemoryWin32HandleKHR)(VkDevice device, const VkMemoryGetWin32HandleInfoKHR * pGetWin32HandleInfo, HANDLE * pHandle);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR * pMemoryWin32HandleProperties);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)(VkPhysicalDevice physicalDevice, uint32_t * pTimeDomainCount, VkTimeDomainEXT * pTimeDomains);
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
typedef VkBool32 (GLAD_API_PTR *PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB * dfb);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)(VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, VkDisplayPlaneProperties2KHR * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, VkDisplayPlanePropertiesKHR * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceDisplayProperties2KHR)(VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, VkDisplayProperties2KHR * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t * pPropertyCount, VkDisplayPropertiesKHR * pProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo * pExternalBufferInfo, VkExternalBufferProperties * pExternalBufferProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo * pExternalBufferInfo, VkExternalBufferProperties * pExternalBufferProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceExternalFenceProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo * pExternalFenceInfo, VkExternalFenceProperties * pExternalFenceProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo * pExternalFenceInfo, VkExternalFenceProperties * pExternalFenceProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo * pExternalSemaphoreInfo, VkExternalSemaphoreProperties * pExternalSemaphoreProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo * pExternalSemaphoreInfo, VkExternalSemaphoreProperties * pExternalSemaphoreProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures * pFeatures);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceFeatures2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 * pFeatures);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceFeatures2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 * pFeatures);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties * pFormatProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceFormatProperties2)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 * pFormatProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceFormatProperties2KHR)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 * pFormatProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties * pImageFormatProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 * pImageFormatInfo, VkImageFormatProperties2 * pImageFormatProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 * pImageFormatInfo, VkImageFormatProperties2 * pImageFormatProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties * pMemoryProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceMemoryProperties2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 * pMemoryProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceMemoryProperties2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 * pMemoryProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT * pMultisampleProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t * pRectCount, VkRect2D * pRects);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties * pProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceProperties2)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 * pProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceProperties2KHR)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 * pProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR * pPerformanceQueryCreateInfo, uint32_t * pNumPasses);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t * pQueueFamilyPropertyCount, VkQueueFamilyProperties * pQueueFamilyProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties2)(VkPhysicalDevice physicalDevice, uint32_t * pQueueFamilyPropertyCount, VkQueueFamilyProperties2 * pQueueFamilyProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR)(VkPhysicalDevice physicalDevice, uint32_t * pQueueFamilyPropertyCount, VkQueueFamilyProperties2 * pQueueFamilyProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t * pPropertyCount, VkSparseImageFormatProperties * pProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 * pFormatInfo, uint32_t * pPropertyCount, VkSparseImageFormatProperties2 * pProperties);
typedef void (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 * pFormatInfo, uint32_t * pPropertyCount, VkSparseImageFormatProperties2 * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT * pSurfaceCapabilities);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, VkSurfaceCapabilities2KHR * pSurfaceCapabilities);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR * pSurfaceCapabilities);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, uint32_t * pSurfaceFormatCount, VkSurfaceFormat2KHR * pSurfaceFormats);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t * pSurfaceFormatCount, VkSurfaceFormatKHR * pSurfaceFormats);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT)(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR * pSurfaceInfo, uint32_t * pPresentModeCount, VkPresentModeKHR * pPresentModes);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t * pPresentModeCount, VkPresentModeKHR * pPresentModes);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 * pSupported);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPhysicalDeviceToolPropertiesEXT)(VkPhysicalDevice physicalDevice, uint32_t * pToolCount, VkPhysicalDeviceToolPropertiesEXT * pToolProperties);
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
typedef VkBool32 (GLAD_API_PTR *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display * display);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkBool32 (GLAD_API_PTR *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
typedef VkBool32 (GLAD_API_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t * connection, xcb_visualid_t visual_id);
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
typedef VkBool32 (GLAD_API_PTR *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display * dpy, VisualID visualID);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t * pDataSize, void * pData);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPipelineExecutableInternalRepresentationsKHR)(VkDevice device, const VkPipelineExecutableInfoKHR * pExecutableInfo, uint32_t * pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR * pInternalRepresentations);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPipelineExecutablePropertiesKHR)(VkDevice device, const VkPipelineInfoKHR * pPipelineInfo, uint32_t * pExecutableCount, VkPipelineExecutablePropertiesKHR * pProperties);
typedef VkResult (GLAD_API_PTR *PFN_vkGetPipelineExecutableStatisticsKHR)(VkDevice device, const VkPipelineExecutableInfoKHR * pExecutableInfo, uint32_t * pStatisticCount, VkPipelineExecutableStatisticKHR * pStatistics);
typedef void (GLAD_API_PTR *PFN_vkGetPrivateDataEXT)(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlotEXT privateDataSlot, uint64_t * pData);
typedef VkResult (GLAD_API_PTR *PFN_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void * pData, VkDeviceSize stride, VkQueryResultFlags flags);
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
typedef VkResult (GLAD_API_PTR *PFN_vkGetRandROutputDisplayEXT)(VkPhysicalDevice physicalDevice, Display * dpy, RROutput rrOutput, VkDisplayKHR * pDisplay);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void * pData);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkGetRayTracingShaderGroupHandlesKHR)(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void * pData);
#endif
typedef void (GLAD_API_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D * pGranularity);
typedef VkResult (GLAD_API_PTR *PFN_vkGetSemaphoreCounterValue)(VkDevice device, VkSemaphore semaphore, uint64_t * pValue);
typedef VkResult (GLAD_API_PTR *PFN_vkGetSemaphoreCounterValueKHR)(VkDevice device, VkSemaphore semaphore, uint64_t * pValue);
typedef VkResult (GLAD_API_PTR *PFN_vkGetSemaphoreFdKHR)(VkDevice device, const VkSemaphoreGetFdInfoKHR * pGetFdInfo, int * pFd);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkGetSemaphoreWin32HandleKHR)(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR * pGetWin32HandleInfo, HANDLE * pHandle);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkGetSwapchainCounterEXT)(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t * pCounterValue);
typedef VkResult (GLAD_API_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t * pSwapchainImageCount, VkImage * pSwapchainImages);
typedef VkResult (GLAD_API_PTR *PFN_vkGetSwapchainStatusKHR)(VkDevice device, VkSwapchainKHR swapchain);
typedef VkResult (GLAD_API_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice device, VkValidationCacheEXT validationCache, size_t * pDataSize, void * pData);
typedef VkResult (GLAD_API_PTR *PFN_vkImportFenceFdKHR)(VkDevice device, const VkImportFenceFdInfoKHR * pImportFenceFdInfo);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkImportFenceWin32HandleKHR)(VkDevice device, const VkImportFenceWin32HandleInfoKHR * pImportFenceWin32HandleInfo);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice device, const VkImportSemaphoreFdInfoKHR * pImportSemaphoreFdInfo);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkImportSemaphoreWin32HandleKHR)(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR * pImportSemaphoreWin32HandleInfo);
#endif
typedef VkResult (GLAD_API_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange * pMemoryRanges);
typedef VkResult (GLAD_API_PTR *PFN_vkMapMemory)(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void ** ppData);
typedef VkResult (GLAD_API_PTR *PFN_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache * pSrcCaches);
typedef VkResult (GLAD_API_PTR *PFN_vkMergeValidationCachesEXT)(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT * pSrcCaches);
typedef void (GLAD_API_PTR *PFN_vkQueueBeginDebugUtilsLabelEXT)(VkQueue queue, const VkDebugUtilsLabelEXT * pLabelInfo);
typedef VkResult (GLAD_API_PTR *PFN_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo * pBindInfo, VkFence fence);
typedef void (GLAD_API_PTR *PFN_vkQueueEndDebugUtilsLabelEXT)(VkQueue queue);
typedef void (GLAD_API_PTR *PFN_vkQueueInsertDebugUtilsLabelEXT)(VkQueue queue, const VkDebugUtilsLabelEXT * pLabelInfo);
typedef VkResult (GLAD_API_PTR *PFN_vkQueuePresentKHR)(VkQueue queue, const VkPresentInfoKHR * pPresentInfo);
typedef VkResult (GLAD_API_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, const VkSubmitInfo * pSubmits, VkFence fence);
typedef VkResult (GLAD_API_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
typedef VkResult (GLAD_API_PTR *PFN_vkRegisterDeviceEventEXT)(VkDevice device, const VkDeviceEventInfoEXT * pDeviceEventInfo, const VkAllocationCallbacks * pAllocator, VkFence * pFence);
typedef VkResult (GLAD_API_PTR *PFN_vkRegisterDisplayEventEXT)(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT * pDisplayEventInfo, const VkAllocationCallbacks * pAllocator, VkFence * pFence);
typedef VkResult (GLAD_API_PTR *PFN_vkReleaseDisplayEXT)(VkPhysicalDevice physicalDevice, VkDisplayKHR display);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
typedef VkResult (GLAD_API_PTR *PFN_vkReleaseFullScreenExclusiveModeEXT)(VkDevice device, VkSwapchainKHR swapchain);
#endif
typedef void (GLAD_API_PTR *PFN_vkReleaseProfilingLockKHR)(VkDevice device);
typedef VkResult (GLAD_API_PTR *PFN_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
typedef VkResult (GLAD_API_PTR *PFN_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
typedef VkResult (GLAD_API_PTR *PFN_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
typedef VkResult (GLAD_API_PTR *PFN_vkResetEvent)(VkDevice device, VkEvent event);
typedef VkResult (GLAD_API_PTR *PFN_vkResetFences)(VkDevice device, uint32_t fenceCount, const VkFence * pFences);
typedef void (GLAD_API_PTR *PFN_vkResetQueryPool)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef void (GLAD_API_PTR *PFN_vkResetQueryPoolEXT)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef VkResult (GLAD_API_PTR *PFN_vkSetDebugUtilsObjectNameEXT)(VkDevice device, const VkDebugUtilsObjectNameInfoEXT * pNameInfo);
typedef VkResult (GLAD_API_PTR *PFN_vkSetDebugUtilsObjectTagEXT)(VkDevice device, const VkDebugUtilsObjectTagInfoEXT * pTagInfo);
typedef VkResult (GLAD_API_PTR *PFN_vkSetEvent)(VkDevice device, VkEvent event);
typedef void (GLAD_API_PTR *PFN_vkSetHdrMetadataEXT)(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR * pSwapchains, const VkHdrMetadataEXT * pMetadata);
typedef VkResult (GLAD_API_PTR *PFN_vkSetPrivateDataEXT)(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlotEXT privateDataSlot, uint64_t data);
typedef VkResult (GLAD_API_PTR *PFN_vkSignalSemaphore)(VkDevice device, const VkSemaphoreSignalInfo * pSignalInfo);
typedef VkResult (GLAD_API_PTR *PFN_vkSignalSemaphoreKHR)(VkDevice device, const VkSemaphoreSignalInfo * pSignalInfo);
typedef void (GLAD_API_PTR *PFN_vkSubmitDebugUtilsMessageEXT)(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT * pCallbackData);
typedef void (GLAD_API_PTR *PFN_vkTrimCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags);
typedef void (GLAD_API_PTR *PFN_vkTrimCommandPoolKHR)(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags);
typedef void (GLAD_API_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
typedef void (GLAD_API_PTR *PFN_vkUpdateDescriptorSetWithTemplate)(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void * pData);
typedef void (GLAD_API_PTR *PFN_vkUpdateDescriptorSetWithTemplateKHR)(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void * pData);
typedef void (GLAD_API_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet * pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet * pDescriptorCopies);
typedef VkResult (GLAD_API_PTR *PFN_vkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence * pFences, VkBool32 waitAll, uint64_t timeout);
typedef VkResult (GLAD_API_PTR *PFN_vkWaitSemaphores)(VkDevice device, const VkSemaphoreWaitInfo * pWaitInfo, uint64_t timeout);
typedef VkResult (GLAD_API_PTR *PFN_vkWaitSemaphoresKHR)(VkDevice device, const VkSemaphoreWaitInfo * pWaitInfo, uint64_t timeout);
#if defined(VK_ENABLE_BETA_EXTENSIONS)
typedef VkResult (GLAD_API_PTR *PFN_vkWriteAccelerationStructuresPropertiesKHR)(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR * pAccelerationStructures, VkQueryType queryType, size_t dataSize, void * pData, size_t stride);
#endif

#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkAcquireFullScreenExclusiveModeEXT glad_vkAcquireFullScreenExclusiveModeEXT;
#define vkAcquireFullScreenExclusiveModeEXT glad_vkAcquireFullScreenExclusiveModeEXT
#endif
GLAD_API_CALL PFN_vkAcquireNextImage2KHR glad_vkAcquireNextImage2KHR;
#define vkAcquireNextImage2KHR glad_vkAcquireNextImage2KHR
GLAD_API_CALL PFN_vkAcquireNextImageKHR glad_vkAcquireNextImageKHR;
#define vkAcquireNextImageKHR glad_vkAcquireNextImageKHR
GLAD_API_CALL PFN_vkAcquireProfilingLockKHR glad_vkAcquireProfilingLockKHR;
#define vkAcquireProfilingLockKHR glad_vkAcquireProfilingLockKHR
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
GLAD_API_CALL PFN_vkAcquireXlibDisplayEXT glad_vkAcquireXlibDisplayEXT;
#define vkAcquireXlibDisplayEXT glad_vkAcquireXlibDisplayEXT
#endif
GLAD_API_CALL PFN_vkAllocateCommandBuffers glad_vkAllocateCommandBuffers;
#define vkAllocateCommandBuffers glad_vkAllocateCommandBuffers
GLAD_API_CALL PFN_vkAllocateDescriptorSets glad_vkAllocateDescriptorSets;
#define vkAllocateDescriptorSets glad_vkAllocateDescriptorSets
GLAD_API_CALL PFN_vkAllocateMemory glad_vkAllocateMemory;
#define vkAllocateMemory glad_vkAllocateMemory
GLAD_API_CALL PFN_vkBeginCommandBuffer glad_vkBeginCommandBuffer;
#define vkBeginCommandBuffer glad_vkBeginCommandBuffer
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkBindAccelerationStructureMemoryKHR glad_vkBindAccelerationStructureMemoryKHR;
#define vkBindAccelerationStructureMemoryKHR glad_vkBindAccelerationStructureMemoryKHR
#endif
GLAD_API_CALL PFN_vkBindBufferMemory glad_vkBindBufferMemory;
#define vkBindBufferMemory glad_vkBindBufferMemory
GLAD_API_CALL PFN_vkBindBufferMemory2 glad_vkBindBufferMemory2;
#define vkBindBufferMemory2 glad_vkBindBufferMemory2
GLAD_API_CALL PFN_vkBindBufferMemory2KHR glad_vkBindBufferMemory2KHR;
#define vkBindBufferMemory2KHR glad_vkBindBufferMemory2KHR
GLAD_API_CALL PFN_vkBindImageMemory glad_vkBindImageMemory;
#define vkBindImageMemory glad_vkBindImageMemory
GLAD_API_CALL PFN_vkBindImageMemory2 glad_vkBindImageMemory2;
#define vkBindImageMemory2 glad_vkBindImageMemory2
GLAD_API_CALL PFN_vkBindImageMemory2KHR glad_vkBindImageMemory2KHR;
#define vkBindImageMemory2KHR glad_vkBindImageMemory2KHR
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkBuildAccelerationStructureKHR glad_vkBuildAccelerationStructureKHR;
#define vkBuildAccelerationStructureKHR glad_vkBuildAccelerationStructureKHR
#endif
GLAD_API_CALL PFN_vkCmdBeginConditionalRenderingEXT glad_vkCmdBeginConditionalRenderingEXT;
#define vkCmdBeginConditionalRenderingEXT glad_vkCmdBeginConditionalRenderingEXT
GLAD_API_CALL PFN_vkCmdBeginDebugUtilsLabelEXT glad_vkCmdBeginDebugUtilsLabelEXT;
#define vkCmdBeginDebugUtilsLabelEXT glad_vkCmdBeginDebugUtilsLabelEXT
GLAD_API_CALL PFN_vkCmdBeginQuery glad_vkCmdBeginQuery;
#define vkCmdBeginQuery glad_vkCmdBeginQuery
GLAD_API_CALL PFN_vkCmdBeginQueryIndexedEXT glad_vkCmdBeginQueryIndexedEXT;
#define vkCmdBeginQueryIndexedEXT glad_vkCmdBeginQueryIndexedEXT
GLAD_API_CALL PFN_vkCmdBeginRenderPass glad_vkCmdBeginRenderPass;
#define vkCmdBeginRenderPass glad_vkCmdBeginRenderPass
GLAD_API_CALL PFN_vkCmdBeginRenderPass2 glad_vkCmdBeginRenderPass2;
#define vkCmdBeginRenderPass2 glad_vkCmdBeginRenderPass2
GLAD_API_CALL PFN_vkCmdBeginRenderPass2KHR glad_vkCmdBeginRenderPass2KHR;
#define vkCmdBeginRenderPass2KHR glad_vkCmdBeginRenderPass2KHR
GLAD_API_CALL PFN_vkCmdBeginTransformFeedbackEXT glad_vkCmdBeginTransformFeedbackEXT;
#define vkCmdBeginTransformFeedbackEXT glad_vkCmdBeginTransformFeedbackEXT
GLAD_API_CALL PFN_vkCmdBindDescriptorSets glad_vkCmdBindDescriptorSets;
#define vkCmdBindDescriptorSets glad_vkCmdBindDescriptorSets
GLAD_API_CALL PFN_vkCmdBindIndexBuffer glad_vkCmdBindIndexBuffer;
#define vkCmdBindIndexBuffer glad_vkCmdBindIndexBuffer
GLAD_API_CALL PFN_vkCmdBindPipeline glad_vkCmdBindPipeline;
#define vkCmdBindPipeline glad_vkCmdBindPipeline
GLAD_API_CALL PFN_vkCmdBindTransformFeedbackBuffersEXT glad_vkCmdBindTransformFeedbackBuffersEXT;
#define vkCmdBindTransformFeedbackBuffersEXT glad_vkCmdBindTransformFeedbackBuffersEXT
GLAD_API_CALL PFN_vkCmdBindVertexBuffers glad_vkCmdBindVertexBuffers;
#define vkCmdBindVertexBuffers glad_vkCmdBindVertexBuffers
GLAD_API_CALL PFN_vkCmdBindVertexBuffers2EXT glad_vkCmdBindVertexBuffers2EXT;
#define vkCmdBindVertexBuffers2EXT glad_vkCmdBindVertexBuffers2EXT
GLAD_API_CALL PFN_vkCmdBlitImage glad_vkCmdBlitImage;
#define vkCmdBlitImage glad_vkCmdBlitImage
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCmdBuildAccelerationStructureIndirectKHR glad_vkCmdBuildAccelerationStructureIndirectKHR;
#define vkCmdBuildAccelerationStructureIndirectKHR glad_vkCmdBuildAccelerationStructureIndirectKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCmdBuildAccelerationStructureKHR glad_vkCmdBuildAccelerationStructureKHR;
#define vkCmdBuildAccelerationStructureKHR glad_vkCmdBuildAccelerationStructureKHR
#endif
GLAD_API_CALL PFN_vkCmdClearAttachments glad_vkCmdClearAttachments;
#define vkCmdClearAttachments glad_vkCmdClearAttachments
GLAD_API_CALL PFN_vkCmdClearColorImage glad_vkCmdClearColorImage;
#define vkCmdClearColorImage glad_vkCmdClearColorImage
GLAD_API_CALL PFN_vkCmdClearDepthStencilImage glad_vkCmdClearDepthStencilImage;
#define vkCmdClearDepthStencilImage glad_vkCmdClearDepthStencilImage
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCmdCopyAccelerationStructureKHR glad_vkCmdCopyAccelerationStructureKHR;
#define vkCmdCopyAccelerationStructureKHR glad_vkCmdCopyAccelerationStructureKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCmdCopyAccelerationStructureToMemoryKHR glad_vkCmdCopyAccelerationStructureToMemoryKHR;
#define vkCmdCopyAccelerationStructureToMemoryKHR glad_vkCmdCopyAccelerationStructureToMemoryKHR
#endif
GLAD_API_CALL PFN_vkCmdCopyBuffer glad_vkCmdCopyBuffer;
#define vkCmdCopyBuffer glad_vkCmdCopyBuffer
GLAD_API_CALL PFN_vkCmdCopyBufferToImage glad_vkCmdCopyBufferToImage;
#define vkCmdCopyBufferToImage glad_vkCmdCopyBufferToImage
GLAD_API_CALL PFN_vkCmdCopyImage glad_vkCmdCopyImage;
#define vkCmdCopyImage glad_vkCmdCopyImage
GLAD_API_CALL PFN_vkCmdCopyImageToBuffer glad_vkCmdCopyImageToBuffer;
#define vkCmdCopyImageToBuffer glad_vkCmdCopyImageToBuffer
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCmdCopyMemoryToAccelerationStructureKHR glad_vkCmdCopyMemoryToAccelerationStructureKHR;
#define vkCmdCopyMemoryToAccelerationStructureKHR glad_vkCmdCopyMemoryToAccelerationStructureKHR
#endif
GLAD_API_CALL PFN_vkCmdCopyQueryPoolResults glad_vkCmdCopyQueryPoolResults;
#define vkCmdCopyQueryPoolResults glad_vkCmdCopyQueryPoolResults
GLAD_API_CALL PFN_vkCmdDebugMarkerBeginEXT glad_vkCmdDebugMarkerBeginEXT;
#define vkCmdDebugMarkerBeginEXT glad_vkCmdDebugMarkerBeginEXT
GLAD_API_CALL PFN_vkCmdDebugMarkerEndEXT glad_vkCmdDebugMarkerEndEXT;
#define vkCmdDebugMarkerEndEXT glad_vkCmdDebugMarkerEndEXT
GLAD_API_CALL PFN_vkCmdDebugMarkerInsertEXT glad_vkCmdDebugMarkerInsertEXT;
#define vkCmdDebugMarkerInsertEXT glad_vkCmdDebugMarkerInsertEXT
GLAD_API_CALL PFN_vkCmdDispatch glad_vkCmdDispatch;
#define vkCmdDispatch glad_vkCmdDispatch
GLAD_API_CALL PFN_vkCmdDispatchBase glad_vkCmdDispatchBase;
#define vkCmdDispatchBase glad_vkCmdDispatchBase
GLAD_API_CALL PFN_vkCmdDispatchBaseKHR glad_vkCmdDispatchBaseKHR;
#define vkCmdDispatchBaseKHR glad_vkCmdDispatchBaseKHR
GLAD_API_CALL PFN_vkCmdDispatchIndirect glad_vkCmdDispatchIndirect;
#define vkCmdDispatchIndirect glad_vkCmdDispatchIndirect
GLAD_API_CALL PFN_vkCmdDraw glad_vkCmdDraw;
#define vkCmdDraw glad_vkCmdDraw
GLAD_API_CALL PFN_vkCmdDrawIndexed glad_vkCmdDrawIndexed;
#define vkCmdDrawIndexed glad_vkCmdDrawIndexed
GLAD_API_CALL PFN_vkCmdDrawIndexedIndirect glad_vkCmdDrawIndexedIndirect;
#define vkCmdDrawIndexedIndirect glad_vkCmdDrawIndexedIndirect
GLAD_API_CALL PFN_vkCmdDrawIndexedIndirectCount glad_vkCmdDrawIndexedIndirectCount;
#define vkCmdDrawIndexedIndirectCount glad_vkCmdDrawIndexedIndirectCount
GLAD_API_CALL PFN_vkCmdDrawIndexedIndirectCountKHR glad_vkCmdDrawIndexedIndirectCountKHR;
#define vkCmdDrawIndexedIndirectCountKHR glad_vkCmdDrawIndexedIndirectCountKHR
GLAD_API_CALL PFN_vkCmdDrawIndirect glad_vkCmdDrawIndirect;
#define vkCmdDrawIndirect glad_vkCmdDrawIndirect
GLAD_API_CALL PFN_vkCmdDrawIndirectByteCountEXT glad_vkCmdDrawIndirectByteCountEXT;
#define vkCmdDrawIndirectByteCountEXT glad_vkCmdDrawIndirectByteCountEXT
GLAD_API_CALL PFN_vkCmdDrawIndirectCount glad_vkCmdDrawIndirectCount;
#define vkCmdDrawIndirectCount glad_vkCmdDrawIndirectCount
GLAD_API_CALL PFN_vkCmdDrawIndirectCountKHR glad_vkCmdDrawIndirectCountKHR;
#define vkCmdDrawIndirectCountKHR glad_vkCmdDrawIndirectCountKHR
GLAD_API_CALL PFN_vkCmdEndConditionalRenderingEXT glad_vkCmdEndConditionalRenderingEXT;
#define vkCmdEndConditionalRenderingEXT glad_vkCmdEndConditionalRenderingEXT
GLAD_API_CALL PFN_vkCmdEndDebugUtilsLabelEXT glad_vkCmdEndDebugUtilsLabelEXT;
#define vkCmdEndDebugUtilsLabelEXT glad_vkCmdEndDebugUtilsLabelEXT
GLAD_API_CALL PFN_vkCmdEndQuery glad_vkCmdEndQuery;
#define vkCmdEndQuery glad_vkCmdEndQuery
GLAD_API_CALL PFN_vkCmdEndQueryIndexedEXT glad_vkCmdEndQueryIndexedEXT;
#define vkCmdEndQueryIndexedEXT glad_vkCmdEndQueryIndexedEXT
GLAD_API_CALL PFN_vkCmdEndRenderPass glad_vkCmdEndRenderPass;
#define vkCmdEndRenderPass glad_vkCmdEndRenderPass
GLAD_API_CALL PFN_vkCmdEndRenderPass2 glad_vkCmdEndRenderPass2;
#define vkCmdEndRenderPass2 glad_vkCmdEndRenderPass2
GLAD_API_CALL PFN_vkCmdEndRenderPass2KHR glad_vkCmdEndRenderPass2KHR;
#define vkCmdEndRenderPass2KHR glad_vkCmdEndRenderPass2KHR
GLAD_API_CALL PFN_vkCmdEndTransformFeedbackEXT glad_vkCmdEndTransformFeedbackEXT;
#define vkCmdEndTransformFeedbackEXT glad_vkCmdEndTransformFeedbackEXT
GLAD_API_CALL PFN_vkCmdExecuteCommands glad_vkCmdExecuteCommands;
#define vkCmdExecuteCommands glad_vkCmdExecuteCommands
GLAD_API_CALL PFN_vkCmdFillBuffer glad_vkCmdFillBuffer;
#define vkCmdFillBuffer glad_vkCmdFillBuffer
GLAD_API_CALL PFN_vkCmdInsertDebugUtilsLabelEXT glad_vkCmdInsertDebugUtilsLabelEXT;
#define vkCmdInsertDebugUtilsLabelEXT glad_vkCmdInsertDebugUtilsLabelEXT
GLAD_API_CALL PFN_vkCmdNextSubpass glad_vkCmdNextSubpass;
#define vkCmdNextSubpass glad_vkCmdNextSubpass
GLAD_API_CALL PFN_vkCmdNextSubpass2 glad_vkCmdNextSubpass2;
#define vkCmdNextSubpass2 glad_vkCmdNextSubpass2
GLAD_API_CALL PFN_vkCmdNextSubpass2KHR glad_vkCmdNextSubpass2KHR;
#define vkCmdNextSubpass2KHR glad_vkCmdNextSubpass2KHR
GLAD_API_CALL PFN_vkCmdPipelineBarrier glad_vkCmdPipelineBarrier;
#define vkCmdPipelineBarrier glad_vkCmdPipelineBarrier
GLAD_API_CALL PFN_vkCmdPushConstants glad_vkCmdPushConstants;
#define vkCmdPushConstants glad_vkCmdPushConstants
GLAD_API_CALL PFN_vkCmdPushDescriptorSetKHR glad_vkCmdPushDescriptorSetKHR;
#define vkCmdPushDescriptorSetKHR glad_vkCmdPushDescriptorSetKHR
GLAD_API_CALL PFN_vkCmdPushDescriptorSetWithTemplateKHR glad_vkCmdPushDescriptorSetWithTemplateKHR;
#define vkCmdPushDescriptorSetWithTemplateKHR glad_vkCmdPushDescriptorSetWithTemplateKHR
GLAD_API_CALL PFN_vkCmdResetEvent glad_vkCmdResetEvent;
#define vkCmdResetEvent glad_vkCmdResetEvent
GLAD_API_CALL PFN_vkCmdResetQueryPool glad_vkCmdResetQueryPool;
#define vkCmdResetQueryPool glad_vkCmdResetQueryPool
GLAD_API_CALL PFN_vkCmdResolveImage glad_vkCmdResolveImage;
#define vkCmdResolveImage glad_vkCmdResolveImage
GLAD_API_CALL PFN_vkCmdSetBlendConstants glad_vkCmdSetBlendConstants;
#define vkCmdSetBlendConstants glad_vkCmdSetBlendConstants
GLAD_API_CALL PFN_vkCmdSetCullModeEXT glad_vkCmdSetCullModeEXT;
#define vkCmdSetCullModeEXT glad_vkCmdSetCullModeEXT
GLAD_API_CALL PFN_vkCmdSetDepthBias glad_vkCmdSetDepthBias;
#define vkCmdSetDepthBias glad_vkCmdSetDepthBias
GLAD_API_CALL PFN_vkCmdSetDepthBounds glad_vkCmdSetDepthBounds;
#define vkCmdSetDepthBounds glad_vkCmdSetDepthBounds
GLAD_API_CALL PFN_vkCmdSetDepthBoundsTestEnableEXT glad_vkCmdSetDepthBoundsTestEnableEXT;
#define vkCmdSetDepthBoundsTestEnableEXT glad_vkCmdSetDepthBoundsTestEnableEXT
GLAD_API_CALL PFN_vkCmdSetDepthCompareOpEXT glad_vkCmdSetDepthCompareOpEXT;
#define vkCmdSetDepthCompareOpEXT glad_vkCmdSetDepthCompareOpEXT
GLAD_API_CALL PFN_vkCmdSetDepthTestEnableEXT glad_vkCmdSetDepthTestEnableEXT;
#define vkCmdSetDepthTestEnableEXT glad_vkCmdSetDepthTestEnableEXT
GLAD_API_CALL PFN_vkCmdSetDepthWriteEnableEXT glad_vkCmdSetDepthWriteEnableEXT;
#define vkCmdSetDepthWriteEnableEXT glad_vkCmdSetDepthWriteEnableEXT
GLAD_API_CALL PFN_vkCmdSetDeviceMask glad_vkCmdSetDeviceMask;
#define vkCmdSetDeviceMask glad_vkCmdSetDeviceMask
GLAD_API_CALL PFN_vkCmdSetDeviceMaskKHR glad_vkCmdSetDeviceMaskKHR;
#define vkCmdSetDeviceMaskKHR glad_vkCmdSetDeviceMaskKHR
GLAD_API_CALL PFN_vkCmdSetDiscardRectangleEXT glad_vkCmdSetDiscardRectangleEXT;
#define vkCmdSetDiscardRectangleEXT glad_vkCmdSetDiscardRectangleEXT
GLAD_API_CALL PFN_vkCmdSetEvent glad_vkCmdSetEvent;
#define vkCmdSetEvent glad_vkCmdSetEvent
GLAD_API_CALL PFN_vkCmdSetFrontFaceEXT glad_vkCmdSetFrontFaceEXT;
#define vkCmdSetFrontFaceEXT glad_vkCmdSetFrontFaceEXT
GLAD_API_CALL PFN_vkCmdSetLineStippleEXT glad_vkCmdSetLineStippleEXT;
#define vkCmdSetLineStippleEXT glad_vkCmdSetLineStippleEXT
GLAD_API_CALL PFN_vkCmdSetLineWidth glad_vkCmdSetLineWidth;
#define vkCmdSetLineWidth glad_vkCmdSetLineWidth
GLAD_API_CALL PFN_vkCmdSetPrimitiveTopologyEXT glad_vkCmdSetPrimitiveTopologyEXT;
#define vkCmdSetPrimitiveTopologyEXT glad_vkCmdSetPrimitiveTopologyEXT
GLAD_API_CALL PFN_vkCmdSetSampleLocationsEXT glad_vkCmdSetSampleLocationsEXT;
#define vkCmdSetSampleLocationsEXT glad_vkCmdSetSampleLocationsEXT
GLAD_API_CALL PFN_vkCmdSetScissor glad_vkCmdSetScissor;
#define vkCmdSetScissor glad_vkCmdSetScissor
GLAD_API_CALL PFN_vkCmdSetScissorWithCountEXT glad_vkCmdSetScissorWithCountEXT;
#define vkCmdSetScissorWithCountEXT glad_vkCmdSetScissorWithCountEXT
GLAD_API_CALL PFN_vkCmdSetStencilCompareMask glad_vkCmdSetStencilCompareMask;
#define vkCmdSetStencilCompareMask glad_vkCmdSetStencilCompareMask
GLAD_API_CALL PFN_vkCmdSetStencilOpEXT glad_vkCmdSetStencilOpEXT;
#define vkCmdSetStencilOpEXT glad_vkCmdSetStencilOpEXT
GLAD_API_CALL PFN_vkCmdSetStencilReference glad_vkCmdSetStencilReference;
#define vkCmdSetStencilReference glad_vkCmdSetStencilReference
GLAD_API_CALL PFN_vkCmdSetStencilTestEnableEXT glad_vkCmdSetStencilTestEnableEXT;
#define vkCmdSetStencilTestEnableEXT glad_vkCmdSetStencilTestEnableEXT
GLAD_API_CALL PFN_vkCmdSetStencilWriteMask glad_vkCmdSetStencilWriteMask;
#define vkCmdSetStencilWriteMask glad_vkCmdSetStencilWriteMask
GLAD_API_CALL PFN_vkCmdSetViewport glad_vkCmdSetViewport;
#define vkCmdSetViewport glad_vkCmdSetViewport
GLAD_API_CALL PFN_vkCmdSetViewportWithCountEXT glad_vkCmdSetViewportWithCountEXT;
#define vkCmdSetViewportWithCountEXT glad_vkCmdSetViewportWithCountEXT
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCmdTraceRaysIndirectKHR glad_vkCmdTraceRaysIndirectKHR;
#define vkCmdTraceRaysIndirectKHR glad_vkCmdTraceRaysIndirectKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCmdTraceRaysKHR glad_vkCmdTraceRaysKHR;
#define vkCmdTraceRaysKHR glad_vkCmdTraceRaysKHR
#endif
GLAD_API_CALL PFN_vkCmdUpdateBuffer glad_vkCmdUpdateBuffer;
#define vkCmdUpdateBuffer glad_vkCmdUpdateBuffer
GLAD_API_CALL PFN_vkCmdWaitEvents glad_vkCmdWaitEvents;
#define vkCmdWaitEvents glad_vkCmdWaitEvents
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCmdWriteAccelerationStructuresPropertiesKHR glad_vkCmdWriteAccelerationStructuresPropertiesKHR;
#define vkCmdWriteAccelerationStructuresPropertiesKHR glad_vkCmdWriteAccelerationStructuresPropertiesKHR
#endif
GLAD_API_CALL PFN_vkCmdWriteTimestamp glad_vkCmdWriteTimestamp;
#define vkCmdWriteTimestamp glad_vkCmdWriteTimestamp
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCopyAccelerationStructureKHR glad_vkCopyAccelerationStructureKHR;
#define vkCopyAccelerationStructureKHR glad_vkCopyAccelerationStructureKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCopyAccelerationStructureToMemoryKHR glad_vkCopyAccelerationStructureToMemoryKHR;
#define vkCopyAccelerationStructureToMemoryKHR glad_vkCopyAccelerationStructureToMemoryKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCopyMemoryToAccelerationStructureKHR glad_vkCopyMemoryToAccelerationStructureKHR;
#define vkCopyMemoryToAccelerationStructureKHR glad_vkCopyMemoryToAccelerationStructureKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCreateAccelerationStructureKHR glad_vkCreateAccelerationStructureKHR;
#define vkCreateAccelerationStructureKHR glad_vkCreateAccelerationStructureKHR
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GLAD_API_CALL PFN_vkCreateAndroidSurfaceKHR glad_vkCreateAndroidSurfaceKHR;
#define vkCreateAndroidSurfaceKHR glad_vkCreateAndroidSurfaceKHR
#endif
GLAD_API_CALL PFN_vkCreateBuffer glad_vkCreateBuffer;
#define vkCreateBuffer glad_vkCreateBuffer
GLAD_API_CALL PFN_vkCreateBufferView glad_vkCreateBufferView;
#define vkCreateBufferView glad_vkCreateBufferView
GLAD_API_CALL PFN_vkCreateCommandPool glad_vkCreateCommandPool;
#define vkCreateCommandPool glad_vkCreateCommandPool
GLAD_API_CALL PFN_vkCreateComputePipelines glad_vkCreateComputePipelines;
#define vkCreateComputePipelines glad_vkCreateComputePipelines
GLAD_API_CALL PFN_vkCreateDebugReportCallbackEXT glad_vkCreateDebugReportCallbackEXT;
#define vkCreateDebugReportCallbackEXT glad_vkCreateDebugReportCallbackEXT
GLAD_API_CALL PFN_vkCreateDebugUtilsMessengerEXT glad_vkCreateDebugUtilsMessengerEXT;
#define vkCreateDebugUtilsMessengerEXT glad_vkCreateDebugUtilsMessengerEXT
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCreateDeferredOperationKHR glad_vkCreateDeferredOperationKHR;
#define vkCreateDeferredOperationKHR glad_vkCreateDeferredOperationKHR
#endif
GLAD_API_CALL PFN_vkCreateDescriptorPool glad_vkCreateDescriptorPool;
#define vkCreateDescriptorPool glad_vkCreateDescriptorPool
GLAD_API_CALL PFN_vkCreateDescriptorSetLayout glad_vkCreateDescriptorSetLayout;
#define vkCreateDescriptorSetLayout glad_vkCreateDescriptorSetLayout
GLAD_API_CALL PFN_vkCreateDescriptorUpdateTemplate glad_vkCreateDescriptorUpdateTemplate;
#define vkCreateDescriptorUpdateTemplate glad_vkCreateDescriptorUpdateTemplate
GLAD_API_CALL PFN_vkCreateDescriptorUpdateTemplateKHR glad_vkCreateDescriptorUpdateTemplateKHR;
#define vkCreateDescriptorUpdateTemplateKHR glad_vkCreateDescriptorUpdateTemplateKHR
GLAD_API_CALL PFN_vkCreateDevice glad_vkCreateDevice;
#define vkCreateDevice glad_vkCreateDevice
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
GLAD_API_CALL PFN_vkCreateDirectFBSurfaceEXT glad_vkCreateDirectFBSurfaceEXT;
#define vkCreateDirectFBSurfaceEXT glad_vkCreateDirectFBSurfaceEXT
#endif
GLAD_API_CALL PFN_vkCreateDisplayModeKHR glad_vkCreateDisplayModeKHR;
#define vkCreateDisplayModeKHR glad_vkCreateDisplayModeKHR
GLAD_API_CALL PFN_vkCreateDisplayPlaneSurfaceKHR glad_vkCreateDisplayPlaneSurfaceKHR;
#define vkCreateDisplayPlaneSurfaceKHR glad_vkCreateDisplayPlaneSurfaceKHR
GLAD_API_CALL PFN_vkCreateEvent glad_vkCreateEvent;
#define vkCreateEvent glad_vkCreateEvent
GLAD_API_CALL PFN_vkCreateFence glad_vkCreateFence;
#define vkCreateFence glad_vkCreateFence
GLAD_API_CALL PFN_vkCreateFramebuffer glad_vkCreateFramebuffer;
#define vkCreateFramebuffer glad_vkCreateFramebuffer
GLAD_API_CALL PFN_vkCreateGraphicsPipelines glad_vkCreateGraphicsPipelines;
#define vkCreateGraphicsPipelines glad_vkCreateGraphicsPipelines
GLAD_API_CALL PFN_vkCreateHeadlessSurfaceEXT glad_vkCreateHeadlessSurfaceEXT;
#define vkCreateHeadlessSurfaceEXT glad_vkCreateHeadlessSurfaceEXT
GLAD_API_CALL PFN_vkCreateImage glad_vkCreateImage;
#define vkCreateImage glad_vkCreateImage
GLAD_API_CALL PFN_vkCreateImageView glad_vkCreateImageView;
#define vkCreateImageView glad_vkCreateImageView
GLAD_API_CALL PFN_vkCreateInstance glad_vkCreateInstance;
#define vkCreateInstance glad_vkCreateInstance
#if defined(VK_USE_PLATFORM_METAL_EXT)
GLAD_API_CALL PFN_vkCreateMetalSurfaceEXT glad_vkCreateMetalSurfaceEXT;
#define vkCreateMetalSurfaceEXT glad_vkCreateMetalSurfaceEXT
#endif
GLAD_API_CALL PFN_vkCreatePipelineCache glad_vkCreatePipelineCache;
#define vkCreatePipelineCache glad_vkCreatePipelineCache
GLAD_API_CALL PFN_vkCreatePipelineLayout glad_vkCreatePipelineLayout;
#define vkCreatePipelineLayout glad_vkCreatePipelineLayout
GLAD_API_CALL PFN_vkCreatePrivateDataSlotEXT glad_vkCreatePrivateDataSlotEXT;
#define vkCreatePrivateDataSlotEXT glad_vkCreatePrivateDataSlotEXT
GLAD_API_CALL PFN_vkCreateQueryPool glad_vkCreateQueryPool;
#define vkCreateQueryPool glad_vkCreateQueryPool
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkCreateRayTracingPipelinesKHR glad_vkCreateRayTracingPipelinesKHR;
#define vkCreateRayTracingPipelinesKHR glad_vkCreateRayTracingPipelinesKHR
#endif
GLAD_API_CALL PFN_vkCreateRenderPass glad_vkCreateRenderPass;
#define vkCreateRenderPass glad_vkCreateRenderPass
GLAD_API_CALL PFN_vkCreateRenderPass2 glad_vkCreateRenderPass2;
#define vkCreateRenderPass2 glad_vkCreateRenderPass2
GLAD_API_CALL PFN_vkCreateRenderPass2KHR glad_vkCreateRenderPass2KHR;
#define vkCreateRenderPass2KHR glad_vkCreateRenderPass2KHR
GLAD_API_CALL PFN_vkCreateSampler glad_vkCreateSampler;
#define vkCreateSampler glad_vkCreateSampler
GLAD_API_CALL PFN_vkCreateSamplerYcbcrConversion glad_vkCreateSamplerYcbcrConversion;
#define vkCreateSamplerYcbcrConversion glad_vkCreateSamplerYcbcrConversion
GLAD_API_CALL PFN_vkCreateSamplerYcbcrConversionKHR glad_vkCreateSamplerYcbcrConversionKHR;
#define vkCreateSamplerYcbcrConversionKHR glad_vkCreateSamplerYcbcrConversionKHR
GLAD_API_CALL PFN_vkCreateSemaphore glad_vkCreateSemaphore;
#define vkCreateSemaphore glad_vkCreateSemaphore
GLAD_API_CALL PFN_vkCreateShaderModule glad_vkCreateShaderModule;
#define vkCreateShaderModule glad_vkCreateShaderModule
GLAD_API_CALL PFN_vkCreateSharedSwapchainsKHR glad_vkCreateSharedSwapchainsKHR;
#define vkCreateSharedSwapchainsKHR glad_vkCreateSharedSwapchainsKHR
GLAD_API_CALL PFN_vkCreateSwapchainKHR glad_vkCreateSwapchainKHR;
#define vkCreateSwapchainKHR glad_vkCreateSwapchainKHR
GLAD_API_CALL PFN_vkCreateValidationCacheEXT glad_vkCreateValidationCacheEXT;
#define vkCreateValidationCacheEXT glad_vkCreateValidationCacheEXT
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
GLAD_API_CALL PFN_vkCreateWaylandSurfaceKHR glad_vkCreateWaylandSurfaceKHR;
#define vkCreateWaylandSurfaceKHR glad_vkCreateWaylandSurfaceKHR
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkCreateWin32SurfaceKHR glad_vkCreateWin32SurfaceKHR;
#define vkCreateWin32SurfaceKHR glad_vkCreateWin32SurfaceKHR
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
GLAD_API_CALL PFN_vkCreateXcbSurfaceKHR glad_vkCreateXcbSurfaceKHR;
#define vkCreateXcbSurfaceKHR glad_vkCreateXcbSurfaceKHR
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
GLAD_API_CALL PFN_vkCreateXlibSurfaceKHR glad_vkCreateXlibSurfaceKHR;
#define vkCreateXlibSurfaceKHR glad_vkCreateXlibSurfaceKHR
#endif
GLAD_API_CALL PFN_vkDebugMarkerSetObjectNameEXT glad_vkDebugMarkerSetObjectNameEXT;
#define vkDebugMarkerSetObjectNameEXT glad_vkDebugMarkerSetObjectNameEXT
GLAD_API_CALL PFN_vkDebugMarkerSetObjectTagEXT glad_vkDebugMarkerSetObjectTagEXT;
#define vkDebugMarkerSetObjectTagEXT glad_vkDebugMarkerSetObjectTagEXT
GLAD_API_CALL PFN_vkDebugReportMessageEXT glad_vkDebugReportMessageEXT;
#define vkDebugReportMessageEXT glad_vkDebugReportMessageEXT
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkDeferredOperationJoinKHR glad_vkDeferredOperationJoinKHR;
#define vkDeferredOperationJoinKHR glad_vkDeferredOperationJoinKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkDestroyAccelerationStructureKHR glad_vkDestroyAccelerationStructureKHR;
#define vkDestroyAccelerationStructureKHR glad_vkDestroyAccelerationStructureKHR
#endif
GLAD_API_CALL PFN_vkDestroyBuffer glad_vkDestroyBuffer;
#define vkDestroyBuffer glad_vkDestroyBuffer
GLAD_API_CALL PFN_vkDestroyBufferView glad_vkDestroyBufferView;
#define vkDestroyBufferView glad_vkDestroyBufferView
GLAD_API_CALL PFN_vkDestroyCommandPool glad_vkDestroyCommandPool;
#define vkDestroyCommandPool glad_vkDestroyCommandPool
GLAD_API_CALL PFN_vkDestroyDebugReportCallbackEXT glad_vkDestroyDebugReportCallbackEXT;
#define vkDestroyDebugReportCallbackEXT glad_vkDestroyDebugReportCallbackEXT
GLAD_API_CALL PFN_vkDestroyDebugUtilsMessengerEXT glad_vkDestroyDebugUtilsMessengerEXT;
#define vkDestroyDebugUtilsMessengerEXT glad_vkDestroyDebugUtilsMessengerEXT
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkDestroyDeferredOperationKHR glad_vkDestroyDeferredOperationKHR;
#define vkDestroyDeferredOperationKHR glad_vkDestroyDeferredOperationKHR
#endif
GLAD_API_CALL PFN_vkDestroyDescriptorPool glad_vkDestroyDescriptorPool;
#define vkDestroyDescriptorPool glad_vkDestroyDescriptorPool
GLAD_API_CALL PFN_vkDestroyDescriptorSetLayout glad_vkDestroyDescriptorSetLayout;
#define vkDestroyDescriptorSetLayout glad_vkDestroyDescriptorSetLayout
GLAD_API_CALL PFN_vkDestroyDescriptorUpdateTemplate glad_vkDestroyDescriptorUpdateTemplate;
#define vkDestroyDescriptorUpdateTemplate glad_vkDestroyDescriptorUpdateTemplate
GLAD_API_CALL PFN_vkDestroyDescriptorUpdateTemplateKHR glad_vkDestroyDescriptorUpdateTemplateKHR;
#define vkDestroyDescriptorUpdateTemplateKHR glad_vkDestroyDescriptorUpdateTemplateKHR
GLAD_API_CALL PFN_vkDestroyDevice glad_vkDestroyDevice;
#define vkDestroyDevice glad_vkDestroyDevice
GLAD_API_CALL PFN_vkDestroyEvent glad_vkDestroyEvent;
#define vkDestroyEvent glad_vkDestroyEvent
GLAD_API_CALL PFN_vkDestroyFence glad_vkDestroyFence;
#define vkDestroyFence glad_vkDestroyFence
GLAD_API_CALL PFN_vkDestroyFramebuffer glad_vkDestroyFramebuffer;
#define vkDestroyFramebuffer glad_vkDestroyFramebuffer
GLAD_API_CALL PFN_vkDestroyImage glad_vkDestroyImage;
#define vkDestroyImage glad_vkDestroyImage
GLAD_API_CALL PFN_vkDestroyImageView glad_vkDestroyImageView;
#define vkDestroyImageView glad_vkDestroyImageView
GLAD_API_CALL PFN_vkDestroyInstance glad_vkDestroyInstance;
#define vkDestroyInstance glad_vkDestroyInstance
GLAD_API_CALL PFN_vkDestroyPipeline glad_vkDestroyPipeline;
#define vkDestroyPipeline glad_vkDestroyPipeline
GLAD_API_CALL PFN_vkDestroyPipelineCache glad_vkDestroyPipelineCache;
#define vkDestroyPipelineCache glad_vkDestroyPipelineCache
GLAD_API_CALL PFN_vkDestroyPipelineLayout glad_vkDestroyPipelineLayout;
#define vkDestroyPipelineLayout glad_vkDestroyPipelineLayout
GLAD_API_CALL PFN_vkDestroyPrivateDataSlotEXT glad_vkDestroyPrivateDataSlotEXT;
#define vkDestroyPrivateDataSlotEXT glad_vkDestroyPrivateDataSlotEXT
GLAD_API_CALL PFN_vkDestroyQueryPool glad_vkDestroyQueryPool;
#define vkDestroyQueryPool glad_vkDestroyQueryPool
GLAD_API_CALL PFN_vkDestroyRenderPass glad_vkDestroyRenderPass;
#define vkDestroyRenderPass glad_vkDestroyRenderPass
GLAD_API_CALL PFN_vkDestroySampler glad_vkDestroySampler;
#define vkDestroySampler glad_vkDestroySampler
GLAD_API_CALL PFN_vkDestroySamplerYcbcrConversion glad_vkDestroySamplerYcbcrConversion;
#define vkDestroySamplerYcbcrConversion glad_vkDestroySamplerYcbcrConversion
GLAD_API_CALL PFN_vkDestroySamplerYcbcrConversionKHR glad_vkDestroySamplerYcbcrConversionKHR;
#define vkDestroySamplerYcbcrConversionKHR glad_vkDestroySamplerYcbcrConversionKHR
GLAD_API_CALL PFN_vkDestroySemaphore glad_vkDestroySemaphore;
#define vkDestroySemaphore glad_vkDestroySemaphore
GLAD_API_CALL PFN_vkDestroyShaderModule glad_vkDestroyShaderModule;
#define vkDestroyShaderModule glad_vkDestroyShaderModule
GLAD_API_CALL PFN_vkDestroySurfaceKHR glad_vkDestroySurfaceKHR;
#define vkDestroySurfaceKHR glad_vkDestroySurfaceKHR
GLAD_API_CALL PFN_vkDestroySwapchainKHR glad_vkDestroySwapchainKHR;
#define vkDestroySwapchainKHR glad_vkDestroySwapchainKHR
GLAD_API_CALL PFN_vkDestroyValidationCacheEXT glad_vkDestroyValidationCacheEXT;
#define vkDestroyValidationCacheEXT glad_vkDestroyValidationCacheEXT
GLAD_API_CALL PFN_vkDeviceWaitIdle glad_vkDeviceWaitIdle;
#define vkDeviceWaitIdle glad_vkDeviceWaitIdle
GLAD_API_CALL PFN_vkDisplayPowerControlEXT glad_vkDisplayPowerControlEXT;
#define vkDisplayPowerControlEXT glad_vkDisplayPowerControlEXT
GLAD_API_CALL PFN_vkEndCommandBuffer glad_vkEndCommandBuffer;
#define vkEndCommandBuffer glad_vkEndCommandBuffer
GLAD_API_CALL PFN_vkEnumerateDeviceExtensionProperties glad_vkEnumerateDeviceExtensionProperties;
#define vkEnumerateDeviceExtensionProperties glad_vkEnumerateDeviceExtensionProperties
GLAD_API_CALL PFN_vkEnumerateDeviceLayerProperties glad_vkEnumerateDeviceLayerProperties;
#define vkEnumerateDeviceLayerProperties glad_vkEnumerateDeviceLayerProperties
GLAD_API_CALL PFN_vkEnumerateInstanceExtensionProperties glad_vkEnumerateInstanceExtensionProperties;
#define vkEnumerateInstanceExtensionProperties glad_vkEnumerateInstanceExtensionProperties
GLAD_API_CALL PFN_vkEnumerateInstanceLayerProperties glad_vkEnumerateInstanceLayerProperties;
#define vkEnumerateInstanceLayerProperties glad_vkEnumerateInstanceLayerProperties
GLAD_API_CALL PFN_vkEnumerateInstanceVersion glad_vkEnumerateInstanceVersion;
#define vkEnumerateInstanceVersion glad_vkEnumerateInstanceVersion
GLAD_API_CALL PFN_vkEnumeratePhysicalDeviceGroups glad_vkEnumeratePhysicalDeviceGroups;
#define vkEnumeratePhysicalDeviceGroups glad_vkEnumeratePhysicalDeviceGroups
GLAD_API_CALL PFN_vkEnumeratePhysicalDeviceGroupsKHR glad_vkEnumeratePhysicalDeviceGroupsKHR;
#define vkEnumeratePhysicalDeviceGroupsKHR glad_vkEnumeratePhysicalDeviceGroupsKHR
GLAD_API_CALL PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR glad_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
#define vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR glad_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
GLAD_API_CALL PFN_vkEnumeratePhysicalDevices glad_vkEnumeratePhysicalDevices;
#define vkEnumeratePhysicalDevices glad_vkEnumeratePhysicalDevices
GLAD_API_CALL PFN_vkFlushMappedMemoryRanges glad_vkFlushMappedMemoryRanges;
#define vkFlushMappedMemoryRanges glad_vkFlushMappedMemoryRanges
GLAD_API_CALL PFN_vkFreeCommandBuffers glad_vkFreeCommandBuffers;
#define vkFreeCommandBuffers glad_vkFreeCommandBuffers
GLAD_API_CALL PFN_vkFreeDescriptorSets glad_vkFreeDescriptorSets;
#define vkFreeDescriptorSets glad_vkFreeDescriptorSets
GLAD_API_CALL PFN_vkFreeMemory glad_vkFreeMemory;
#define vkFreeMemory glad_vkFreeMemory
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkGetAccelerationStructureDeviceAddressKHR glad_vkGetAccelerationStructureDeviceAddressKHR;
#define vkGetAccelerationStructureDeviceAddressKHR glad_vkGetAccelerationStructureDeviceAddressKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkGetAccelerationStructureMemoryRequirementsKHR glad_vkGetAccelerationStructureMemoryRequirementsKHR;
#define vkGetAccelerationStructureMemoryRequirementsKHR glad_vkGetAccelerationStructureMemoryRequirementsKHR
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GLAD_API_CALL PFN_vkGetAndroidHardwareBufferPropertiesANDROID glad_vkGetAndroidHardwareBufferPropertiesANDROID;
#define vkGetAndroidHardwareBufferPropertiesANDROID glad_vkGetAndroidHardwareBufferPropertiesANDROID
#endif
GLAD_API_CALL PFN_vkGetBufferDeviceAddress glad_vkGetBufferDeviceAddress;
#define vkGetBufferDeviceAddress glad_vkGetBufferDeviceAddress
GLAD_API_CALL PFN_vkGetBufferDeviceAddressEXT glad_vkGetBufferDeviceAddressEXT;
#define vkGetBufferDeviceAddressEXT glad_vkGetBufferDeviceAddressEXT
GLAD_API_CALL PFN_vkGetBufferDeviceAddressKHR glad_vkGetBufferDeviceAddressKHR;
#define vkGetBufferDeviceAddressKHR glad_vkGetBufferDeviceAddressKHR
GLAD_API_CALL PFN_vkGetBufferMemoryRequirements glad_vkGetBufferMemoryRequirements;
#define vkGetBufferMemoryRequirements glad_vkGetBufferMemoryRequirements
GLAD_API_CALL PFN_vkGetBufferMemoryRequirements2 glad_vkGetBufferMemoryRequirements2;
#define vkGetBufferMemoryRequirements2 glad_vkGetBufferMemoryRequirements2
GLAD_API_CALL PFN_vkGetBufferMemoryRequirements2KHR glad_vkGetBufferMemoryRequirements2KHR;
#define vkGetBufferMemoryRequirements2KHR glad_vkGetBufferMemoryRequirements2KHR
GLAD_API_CALL PFN_vkGetBufferOpaqueCaptureAddress glad_vkGetBufferOpaqueCaptureAddress;
#define vkGetBufferOpaqueCaptureAddress glad_vkGetBufferOpaqueCaptureAddress
GLAD_API_CALL PFN_vkGetBufferOpaqueCaptureAddressKHR glad_vkGetBufferOpaqueCaptureAddressKHR;
#define vkGetBufferOpaqueCaptureAddressKHR glad_vkGetBufferOpaqueCaptureAddressKHR
GLAD_API_CALL PFN_vkGetCalibratedTimestampsEXT glad_vkGetCalibratedTimestampsEXT;
#define vkGetCalibratedTimestampsEXT glad_vkGetCalibratedTimestampsEXT
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkGetDeferredOperationMaxConcurrencyKHR glad_vkGetDeferredOperationMaxConcurrencyKHR;
#define vkGetDeferredOperationMaxConcurrencyKHR glad_vkGetDeferredOperationMaxConcurrencyKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkGetDeferredOperationResultKHR glad_vkGetDeferredOperationResultKHR;
#define vkGetDeferredOperationResultKHR glad_vkGetDeferredOperationResultKHR
#endif
GLAD_API_CALL PFN_vkGetDescriptorSetLayoutSupport glad_vkGetDescriptorSetLayoutSupport;
#define vkGetDescriptorSetLayoutSupport glad_vkGetDescriptorSetLayoutSupport
GLAD_API_CALL PFN_vkGetDescriptorSetLayoutSupportKHR glad_vkGetDescriptorSetLayoutSupportKHR;
#define vkGetDescriptorSetLayoutSupportKHR glad_vkGetDescriptorSetLayoutSupportKHR
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkGetDeviceAccelerationStructureCompatibilityKHR glad_vkGetDeviceAccelerationStructureCompatibilityKHR;
#define vkGetDeviceAccelerationStructureCompatibilityKHR glad_vkGetDeviceAccelerationStructureCompatibilityKHR
#endif
GLAD_API_CALL PFN_vkGetDeviceGroupPeerMemoryFeatures glad_vkGetDeviceGroupPeerMemoryFeatures;
#define vkGetDeviceGroupPeerMemoryFeatures glad_vkGetDeviceGroupPeerMemoryFeatures
GLAD_API_CALL PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR glad_vkGetDeviceGroupPeerMemoryFeaturesKHR;
#define vkGetDeviceGroupPeerMemoryFeaturesKHR glad_vkGetDeviceGroupPeerMemoryFeaturesKHR
GLAD_API_CALL PFN_vkGetDeviceGroupPresentCapabilitiesKHR glad_vkGetDeviceGroupPresentCapabilitiesKHR;
#define vkGetDeviceGroupPresentCapabilitiesKHR glad_vkGetDeviceGroupPresentCapabilitiesKHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkGetDeviceGroupSurfacePresentModes2EXT glad_vkGetDeviceGroupSurfacePresentModes2EXT;
#define vkGetDeviceGroupSurfacePresentModes2EXT glad_vkGetDeviceGroupSurfacePresentModes2EXT
#endif
GLAD_API_CALL PFN_vkGetDeviceGroupSurfacePresentModesKHR glad_vkGetDeviceGroupSurfacePresentModesKHR;
#define vkGetDeviceGroupSurfacePresentModesKHR glad_vkGetDeviceGroupSurfacePresentModesKHR
GLAD_API_CALL PFN_vkGetDeviceMemoryCommitment glad_vkGetDeviceMemoryCommitment;
#define vkGetDeviceMemoryCommitment glad_vkGetDeviceMemoryCommitment
GLAD_API_CALL PFN_vkGetDeviceMemoryOpaqueCaptureAddress glad_vkGetDeviceMemoryOpaqueCaptureAddress;
#define vkGetDeviceMemoryOpaqueCaptureAddress glad_vkGetDeviceMemoryOpaqueCaptureAddress
GLAD_API_CALL PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR glad_vkGetDeviceMemoryOpaqueCaptureAddressKHR;
#define vkGetDeviceMemoryOpaqueCaptureAddressKHR glad_vkGetDeviceMemoryOpaqueCaptureAddressKHR
GLAD_API_CALL PFN_vkGetDeviceProcAddr glad_vkGetDeviceProcAddr;
#define vkGetDeviceProcAddr glad_vkGetDeviceProcAddr
GLAD_API_CALL PFN_vkGetDeviceQueue glad_vkGetDeviceQueue;
#define vkGetDeviceQueue glad_vkGetDeviceQueue
GLAD_API_CALL PFN_vkGetDeviceQueue2 glad_vkGetDeviceQueue2;
#define vkGetDeviceQueue2 glad_vkGetDeviceQueue2
GLAD_API_CALL PFN_vkGetDisplayModeProperties2KHR glad_vkGetDisplayModeProperties2KHR;
#define vkGetDisplayModeProperties2KHR glad_vkGetDisplayModeProperties2KHR
GLAD_API_CALL PFN_vkGetDisplayModePropertiesKHR glad_vkGetDisplayModePropertiesKHR;
#define vkGetDisplayModePropertiesKHR glad_vkGetDisplayModePropertiesKHR
GLAD_API_CALL PFN_vkGetDisplayPlaneCapabilities2KHR glad_vkGetDisplayPlaneCapabilities2KHR;
#define vkGetDisplayPlaneCapabilities2KHR glad_vkGetDisplayPlaneCapabilities2KHR
GLAD_API_CALL PFN_vkGetDisplayPlaneCapabilitiesKHR glad_vkGetDisplayPlaneCapabilitiesKHR;
#define vkGetDisplayPlaneCapabilitiesKHR glad_vkGetDisplayPlaneCapabilitiesKHR
GLAD_API_CALL PFN_vkGetDisplayPlaneSupportedDisplaysKHR glad_vkGetDisplayPlaneSupportedDisplaysKHR;
#define vkGetDisplayPlaneSupportedDisplaysKHR glad_vkGetDisplayPlaneSupportedDisplaysKHR
GLAD_API_CALL PFN_vkGetEventStatus glad_vkGetEventStatus;
#define vkGetEventStatus glad_vkGetEventStatus
GLAD_API_CALL PFN_vkGetFenceFdKHR glad_vkGetFenceFdKHR;
#define vkGetFenceFdKHR glad_vkGetFenceFdKHR
GLAD_API_CALL PFN_vkGetFenceStatus glad_vkGetFenceStatus;
#define vkGetFenceStatus glad_vkGetFenceStatus
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkGetFenceWin32HandleKHR glad_vkGetFenceWin32HandleKHR;
#define vkGetFenceWin32HandleKHR glad_vkGetFenceWin32HandleKHR
#endif
GLAD_API_CALL PFN_vkGetImageDrmFormatModifierPropertiesEXT glad_vkGetImageDrmFormatModifierPropertiesEXT;
#define vkGetImageDrmFormatModifierPropertiesEXT glad_vkGetImageDrmFormatModifierPropertiesEXT
GLAD_API_CALL PFN_vkGetImageMemoryRequirements glad_vkGetImageMemoryRequirements;
#define vkGetImageMemoryRequirements glad_vkGetImageMemoryRequirements
GLAD_API_CALL PFN_vkGetImageMemoryRequirements2 glad_vkGetImageMemoryRequirements2;
#define vkGetImageMemoryRequirements2 glad_vkGetImageMemoryRequirements2
GLAD_API_CALL PFN_vkGetImageMemoryRequirements2KHR glad_vkGetImageMemoryRequirements2KHR;
#define vkGetImageMemoryRequirements2KHR glad_vkGetImageMemoryRequirements2KHR
GLAD_API_CALL PFN_vkGetImageSparseMemoryRequirements glad_vkGetImageSparseMemoryRequirements;
#define vkGetImageSparseMemoryRequirements glad_vkGetImageSparseMemoryRequirements
GLAD_API_CALL PFN_vkGetImageSparseMemoryRequirements2 glad_vkGetImageSparseMemoryRequirements2;
#define vkGetImageSparseMemoryRequirements2 glad_vkGetImageSparseMemoryRequirements2
GLAD_API_CALL PFN_vkGetImageSparseMemoryRequirements2KHR glad_vkGetImageSparseMemoryRequirements2KHR;
#define vkGetImageSparseMemoryRequirements2KHR glad_vkGetImageSparseMemoryRequirements2KHR
GLAD_API_CALL PFN_vkGetImageSubresourceLayout glad_vkGetImageSubresourceLayout;
#define vkGetImageSubresourceLayout glad_vkGetImageSubresourceLayout
GLAD_API_CALL PFN_vkGetInstanceProcAddr glad_vkGetInstanceProcAddr;
#define vkGetInstanceProcAddr glad_vkGetInstanceProcAddr
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GLAD_API_CALL PFN_vkGetMemoryAndroidHardwareBufferANDROID glad_vkGetMemoryAndroidHardwareBufferANDROID;
#define vkGetMemoryAndroidHardwareBufferANDROID glad_vkGetMemoryAndroidHardwareBufferANDROID
#endif
GLAD_API_CALL PFN_vkGetMemoryFdKHR glad_vkGetMemoryFdKHR;
#define vkGetMemoryFdKHR glad_vkGetMemoryFdKHR
GLAD_API_CALL PFN_vkGetMemoryFdPropertiesKHR glad_vkGetMemoryFdPropertiesKHR;
#define vkGetMemoryFdPropertiesKHR glad_vkGetMemoryFdPropertiesKHR
GLAD_API_CALL PFN_vkGetMemoryHostPointerPropertiesEXT glad_vkGetMemoryHostPointerPropertiesEXT;
#define vkGetMemoryHostPointerPropertiesEXT glad_vkGetMemoryHostPointerPropertiesEXT
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkGetMemoryWin32HandleKHR glad_vkGetMemoryWin32HandleKHR;
#define vkGetMemoryWin32HandleKHR glad_vkGetMemoryWin32HandleKHR
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkGetMemoryWin32HandlePropertiesKHR glad_vkGetMemoryWin32HandlePropertiesKHR;
#define vkGetMemoryWin32HandlePropertiesKHR glad_vkGetMemoryWin32HandlePropertiesKHR
#endif
GLAD_API_CALL PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT glad_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT;
#define vkGetPhysicalDeviceCalibrateableTimeDomainsEXT glad_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
GLAD_API_CALL PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT glad_vkGetPhysicalDeviceDirectFBPresentationSupportEXT;
#define vkGetPhysicalDeviceDirectFBPresentationSupportEXT glad_vkGetPhysicalDeviceDirectFBPresentationSupportEXT
#endif
GLAD_API_CALL PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR glad_vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
#define vkGetPhysicalDeviceDisplayPlaneProperties2KHR glad_vkGetPhysicalDeviceDisplayPlaneProperties2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR glad_vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
#define vkGetPhysicalDeviceDisplayPlanePropertiesKHR glad_vkGetPhysicalDeviceDisplayPlanePropertiesKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceDisplayProperties2KHR glad_vkGetPhysicalDeviceDisplayProperties2KHR;
#define vkGetPhysicalDeviceDisplayProperties2KHR glad_vkGetPhysicalDeviceDisplayProperties2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceDisplayPropertiesKHR glad_vkGetPhysicalDeviceDisplayPropertiesKHR;
#define vkGetPhysicalDeviceDisplayPropertiesKHR glad_vkGetPhysicalDeviceDisplayPropertiesKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceExternalBufferProperties glad_vkGetPhysicalDeviceExternalBufferProperties;
#define vkGetPhysicalDeviceExternalBufferProperties glad_vkGetPhysicalDeviceExternalBufferProperties
GLAD_API_CALL PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR glad_vkGetPhysicalDeviceExternalBufferPropertiesKHR;
#define vkGetPhysicalDeviceExternalBufferPropertiesKHR glad_vkGetPhysicalDeviceExternalBufferPropertiesKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceExternalFenceProperties glad_vkGetPhysicalDeviceExternalFenceProperties;
#define vkGetPhysicalDeviceExternalFenceProperties glad_vkGetPhysicalDeviceExternalFenceProperties
GLAD_API_CALL PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR glad_vkGetPhysicalDeviceExternalFencePropertiesKHR;
#define vkGetPhysicalDeviceExternalFencePropertiesKHR glad_vkGetPhysicalDeviceExternalFencePropertiesKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceExternalSemaphoreProperties glad_vkGetPhysicalDeviceExternalSemaphoreProperties;
#define vkGetPhysicalDeviceExternalSemaphoreProperties glad_vkGetPhysicalDeviceExternalSemaphoreProperties
GLAD_API_CALL PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR glad_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
#define vkGetPhysicalDeviceExternalSemaphorePropertiesKHR glad_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceFeatures glad_vkGetPhysicalDeviceFeatures;
#define vkGetPhysicalDeviceFeatures glad_vkGetPhysicalDeviceFeatures
GLAD_API_CALL PFN_vkGetPhysicalDeviceFeatures2 glad_vkGetPhysicalDeviceFeatures2;
#define vkGetPhysicalDeviceFeatures2 glad_vkGetPhysicalDeviceFeatures2
GLAD_API_CALL PFN_vkGetPhysicalDeviceFeatures2KHR glad_vkGetPhysicalDeviceFeatures2KHR;
#define vkGetPhysicalDeviceFeatures2KHR glad_vkGetPhysicalDeviceFeatures2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceFormatProperties glad_vkGetPhysicalDeviceFormatProperties;
#define vkGetPhysicalDeviceFormatProperties glad_vkGetPhysicalDeviceFormatProperties
GLAD_API_CALL PFN_vkGetPhysicalDeviceFormatProperties2 glad_vkGetPhysicalDeviceFormatProperties2;
#define vkGetPhysicalDeviceFormatProperties2 glad_vkGetPhysicalDeviceFormatProperties2
GLAD_API_CALL PFN_vkGetPhysicalDeviceFormatProperties2KHR glad_vkGetPhysicalDeviceFormatProperties2KHR;
#define vkGetPhysicalDeviceFormatProperties2KHR glad_vkGetPhysicalDeviceFormatProperties2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceImageFormatProperties glad_vkGetPhysicalDeviceImageFormatProperties;
#define vkGetPhysicalDeviceImageFormatProperties glad_vkGetPhysicalDeviceImageFormatProperties
GLAD_API_CALL PFN_vkGetPhysicalDeviceImageFormatProperties2 glad_vkGetPhysicalDeviceImageFormatProperties2;
#define vkGetPhysicalDeviceImageFormatProperties2 glad_vkGetPhysicalDeviceImageFormatProperties2
GLAD_API_CALL PFN_vkGetPhysicalDeviceImageFormatProperties2KHR glad_vkGetPhysicalDeviceImageFormatProperties2KHR;
#define vkGetPhysicalDeviceImageFormatProperties2KHR glad_vkGetPhysicalDeviceImageFormatProperties2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceMemoryProperties glad_vkGetPhysicalDeviceMemoryProperties;
#define vkGetPhysicalDeviceMemoryProperties glad_vkGetPhysicalDeviceMemoryProperties
GLAD_API_CALL PFN_vkGetPhysicalDeviceMemoryProperties2 glad_vkGetPhysicalDeviceMemoryProperties2;
#define vkGetPhysicalDeviceMemoryProperties2 glad_vkGetPhysicalDeviceMemoryProperties2
GLAD_API_CALL PFN_vkGetPhysicalDeviceMemoryProperties2KHR glad_vkGetPhysicalDeviceMemoryProperties2KHR;
#define vkGetPhysicalDeviceMemoryProperties2KHR glad_vkGetPhysicalDeviceMemoryProperties2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT glad_vkGetPhysicalDeviceMultisamplePropertiesEXT;
#define vkGetPhysicalDeviceMultisamplePropertiesEXT glad_vkGetPhysicalDeviceMultisamplePropertiesEXT
GLAD_API_CALL PFN_vkGetPhysicalDevicePresentRectanglesKHR glad_vkGetPhysicalDevicePresentRectanglesKHR;
#define vkGetPhysicalDevicePresentRectanglesKHR glad_vkGetPhysicalDevicePresentRectanglesKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceProperties glad_vkGetPhysicalDeviceProperties;
#define vkGetPhysicalDeviceProperties glad_vkGetPhysicalDeviceProperties
GLAD_API_CALL PFN_vkGetPhysicalDeviceProperties2 glad_vkGetPhysicalDeviceProperties2;
#define vkGetPhysicalDeviceProperties2 glad_vkGetPhysicalDeviceProperties2
GLAD_API_CALL PFN_vkGetPhysicalDeviceProperties2KHR glad_vkGetPhysicalDeviceProperties2KHR;
#define vkGetPhysicalDeviceProperties2KHR glad_vkGetPhysicalDeviceProperties2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR glad_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
#define vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR glad_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceQueueFamilyProperties glad_vkGetPhysicalDeviceQueueFamilyProperties;
#define vkGetPhysicalDeviceQueueFamilyProperties glad_vkGetPhysicalDeviceQueueFamilyProperties
GLAD_API_CALL PFN_vkGetPhysicalDeviceQueueFamilyProperties2 glad_vkGetPhysicalDeviceQueueFamilyProperties2;
#define vkGetPhysicalDeviceQueueFamilyProperties2 glad_vkGetPhysicalDeviceQueueFamilyProperties2
GLAD_API_CALL PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR glad_vkGetPhysicalDeviceQueueFamilyProperties2KHR;
#define vkGetPhysicalDeviceQueueFamilyProperties2KHR glad_vkGetPhysicalDeviceQueueFamilyProperties2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceSparseImageFormatProperties glad_vkGetPhysicalDeviceSparseImageFormatProperties;
#define vkGetPhysicalDeviceSparseImageFormatProperties glad_vkGetPhysicalDeviceSparseImageFormatProperties
GLAD_API_CALL PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 glad_vkGetPhysicalDeviceSparseImageFormatProperties2;
#define vkGetPhysicalDeviceSparseImageFormatProperties2 glad_vkGetPhysicalDeviceSparseImageFormatProperties2
GLAD_API_CALL PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR glad_vkGetPhysicalDeviceSparseImageFormatProperties2KHR;
#define vkGetPhysicalDeviceSparseImageFormatProperties2KHR glad_vkGetPhysicalDeviceSparseImageFormatProperties2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT glad_vkGetPhysicalDeviceSurfaceCapabilities2EXT;
#define vkGetPhysicalDeviceSurfaceCapabilities2EXT glad_vkGetPhysicalDeviceSurfaceCapabilities2EXT
GLAD_API_CALL PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR glad_vkGetPhysicalDeviceSurfaceCapabilities2KHR;
#define vkGetPhysicalDeviceSurfaceCapabilities2KHR glad_vkGetPhysicalDeviceSurfaceCapabilities2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR glad_vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
#define vkGetPhysicalDeviceSurfaceCapabilitiesKHR glad_vkGetPhysicalDeviceSurfaceCapabilitiesKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceSurfaceFormats2KHR glad_vkGetPhysicalDeviceSurfaceFormats2KHR;
#define vkGetPhysicalDeviceSurfaceFormats2KHR glad_vkGetPhysicalDeviceSurfaceFormats2KHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceSurfaceFormatsKHR glad_vkGetPhysicalDeviceSurfaceFormatsKHR;
#define vkGetPhysicalDeviceSurfaceFormatsKHR glad_vkGetPhysicalDeviceSurfaceFormatsKHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT glad_vkGetPhysicalDeviceSurfacePresentModes2EXT;
#define vkGetPhysicalDeviceSurfacePresentModes2EXT glad_vkGetPhysicalDeviceSurfacePresentModes2EXT
#endif
GLAD_API_CALL PFN_vkGetPhysicalDeviceSurfacePresentModesKHR glad_vkGetPhysicalDeviceSurfacePresentModesKHR;
#define vkGetPhysicalDeviceSurfacePresentModesKHR glad_vkGetPhysicalDeviceSurfacePresentModesKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceSurfaceSupportKHR glad_vkGetPhysicalDeviceSurfaceSupportKHR;
#define vkGetPhysicalDeviceSurfaceSupportKHR glad_vkGetPhysicalDeviceSurfaceSupportKHR
GLAD_API_CALL PFN_vkGetPhysicalDeviceToolPropertiesEXT glad_vkGetPhysicalDeviceToolPropertiesEXT;
#define vkGetPhysicalDeviceToolPropertiesEXT glad_vkGetPhysicalDeviceToolPropertiesEXT
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
GLAD_API_CALL PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR glad_vkGetPhysicalDeviceWaylandPresentationSupportKHR;
#define vkGetPhysicalDeviceWaylandPresentationSupportKHR glad_vkGetPhysicalDeviceWaylandPresentationSupportKHR
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR glad_vkGetPhysicalDeviceWin32PresentationSupportKHR;
#define vkGetPhysicalDeviceWin32PresentationSupportKHR glad_vkGetPhysicalDeviceWin32PresentationSupportKHR
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
GLAD_API_CALL PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR glad_vkGetPhysicalDeviceXcbPresentationSupportKHR;
#define vkGetPhysicalDeviceXcbPresentationSupportKHR glad_vkGetPhysicalDeviceXcbPresentationSupportKHR
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
GLAD_API_CALL PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR glad_vkGetPhysicalDeviceXlibPresentationSupportKHR;
#define vkGetPhysicalDeviceXlibPresentationSupportKHR glad_vkGetPhysicalDeviceXlibPresentationSupportKHR
#endif
GLAD_API_CALL PFN_vkGetPipelineCacheData glad_vkGetPipelineCacheData;
#define vkGetPipelineCacheData glad_vkGetPipelineCacheData
GLAD_API_CALL PFN_vkGetPipelineExecutableInternalRepresentationsKHR glad_vkGetPipelineExecutableInternalRepresentationsKHR;
#define vkGetPipelineExecutableInternalRepresentationsKHR glad_vkGetPipelineExecutableInternalRepresentationsKHR
GLAD_API_CALL PFN_vkGetPipelineExecutablePropertiesKHR glad_vkGetPipelineExecutablePropertiesKHR;
#define vkGetPipelineExecutablePropertiesKHR glad_vkGetPipelineExecutablePropertiesKHR
GLAD_API_CALL PFN_vkGetPipelineExecutableStatisticsKHR glad_vkGetPipelineExecutableStatisticsKHR;
#define vkGetPipelineExecutableStatisticsKHR glad_vkGetPipelineExecutableStatisticsKHR
GLAD_API_CALL PFN_vkGetPrivateDataEXT glad_vkGetPrivateDataEXT;
#define vkGetPrivateDataEXT glad_vkGetPrivateDataEXT
GLAD_API_CALL PFN_vkGetQueryPoolResults glad_vkGetQueryPoolResults;
#define vkGetQueryPoolResults glad_vkGetQueryPoolResults
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
GLAD_API_CALL PFN_vkGetRandROutputDisplayEXT glad_vkGetRandROutputDisplayEXT;
#define vkGetRandROutputDisplayEXT glad_vkGetRandROutputDisplayEXT
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR glad_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR;
#define vkGetRayTracingCaptureReplayShaderGroupHandlesKHR glad_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkGetRayTracingShaderGroupHandlesKHR glad_vkGetRayTracingShaderGroupHandlesKHR;
#define vkGetRayTracingShaderGroupHandlesKHR glad_vkGetRayTracingShaderGroupHandlesKHR
#endif
GLAD_API_CALL PFN_vkGetRenderAreaGranularity glad_vkGetRenderAreaGranularity;
#define vkGetRenderAreaGranularity glad_vkGetRenderAreaGranularity
GLAD_API_CALL PFN_vkGetSemaphoreCounterValue glad_vkGetSemaphoreCounterValue;
#define vkGetSemaphoreCounterValue glad_vkGetSemaphoreCounterValue
GLAD_API_CALL PFN_vkGetSemaphoreCounterValueKHR glad_vkGetSemaphoreCounterValueKHR;
#define vkGetSemaphoreCounterValueKHR glad_vkGetSemaphoreCounterValueKHR
GLAD_API_CALL PFN_vkGetSemaphoreFdKHR glad_vkGetSemaphoreFdKHR;
#define vkGetSemaphoreFdKHR glad_vkGetSemaphoreFdKHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkGetSemaphoreWin32HandleKHR glad_vkGetSemaphoreWin32HandleKHR;
#define vkGetSemaphoreWin32HandleKHR glad_vkGetSemaphoreWin32HandleKHR
#endif
GLAD_API_CALL PFN_vkGetSwapchainCounterEXT glad_vkGetSwapchainCounterEXT;
#define vkGetSwapchainCounterEXT glad_vkGetSwapchainCounterEXT
GLAD_API_CALL PFN_vkGetSwapchainImagesKHR glad_vkGetSwapchainImagesKHR;
#define vkGetSwapchainImagesKHR glad_vkGetSwapchainImagesKHR
GLAD_API_CALL PFN_vkGetSwapchainStatusKHR glad_vkGetSwapchainStatusKHR;
#define vkGetSwapchainStatusKHR glad_vkGetSwapchainStatusKHR
GLAD_API_CALL PFN_vkGetValidationCacheDataEXT glad_vkGetValidationCacheDataEXT;
#define vkGetValidationCacheDataEXT glad_vkGetValidationCacheDataEXT
GLAD_API_CALL PFN_vkImportFenceFdKHR glad_vkImportFenceFdKHR;
#define vkImportFenceFdKHR glad_vkImportFenceFdKHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkImportFenceWin32HandleKHR glad_vkImportFenceWin32HandleKHR;
#define vkImportFenceWin32HandleKHR glad_vkImportFenceWin32HandleKHR
#endif
GLAD_API_CALL PFN_vkImportSemaphoreFdKHR glad_vkImportSemaphoreFdKHR;
#define vkImportSemaphoreFdKHR glad_vkImportSemaphoreFdKHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkImportSemaphoreWin32HandleKHR glad_vkImportSemaphoreWin32HandleKHR;
#define vkImportSemaphoreWin32HandleKHR glad_vkImportSemaphoreWin32HandleKHR
#endif
GLAD_API_CALL PFN_vkInvalidateMappedMemoryRanges glad_vkInvalidateMappedMemoryRanges;
#define vkInvalidateMappedMemoryRanges glad_vkInvalidateMappedMemoryRanges
GLAD_API_CALL PFN_vkMapMemory glad_vkMapMemory;
#define vkMapMemory glad_vkMapMemory
GLAD_API_CALL PFN_vkMergePipelineCaches glad_vkMergePipelineCaches;
#define vkMergePipelineCaches glad_vkMergePipelineCaches
GLAD_API_CALL PFN_vkMergeValidationCachesEXT glad_vkMergeValidationCachesEXT;
#define vkMergeValidationCachesEXT glad_vkMergeValidationCachesEXT
GLAD_API_CALL PFN_vkQueueBeginDebugUtilsLabelEXT glad_vkQueueBeginDebugUtilsLabelEXT;
#define vkQueueBeginDebugUtilsLabelEXT glad_vkQueueBeginDebugUtilsLabelEXT
GLAD_API_CALL PFN_vkQueueBindSparse glad_vkQueueBindSparse;
#define vkQueueBindSparse glad_vkQueueBindSparse
GLAD_API_CALL PFN_vkQueueEndDebugUtilsLabelEXT glad_vkQueueEndDebugUtilsLabelEXT;
#define vkQueueEndDebugUtilsLabelEXT glad_vkQueueEndDebugUtilsLabelEXT
GLAD_API_CALL PFN_vkQueueInsertDebugUtilsLabelEXT glad_vkQueueInsertDebugUtilsLabelEXT;
#define vkQueueInsertDebugUtilsLabelEXT glad_vkQueueInsertDebugUtilsLabelEXT
GLAD_API_CALL PFN_vkQueuePresentKHR glad_vkQueuePresentKHR;
#define vkQueuePresentKHR glad_vkQueuePresentKHR
GLAD_API_CALL PFN_vkQueueSubmit glad_vkQueueSubmit;
#define vkQueueSubmit glad_vkQueueSubmit
GLAD_API_CALL PFN_vkQueueWaitIdle glad_vkQueueWaitIdle;
#define vkQueueWaitIdle glad_vkQueueWaitIdle
GLAD_API_CALL PFN_vkRegisterDeviceEventEXT glad_vkRegisterDeviceEventEXT;
#define vkRegisterDeviceEventEXT glad_vkRegisterDeviceEventEXT
GLAD_API_CALL PFN_vkRegisterDisplayEventEXT glad_vkRegisterDisplayEventEXT;
#define vkRegisterDisplayEventEXT glad_vkRegisterDisplayEventEXT
GLAD_API_CALL PFN_vkReleaseDisplayEXT glad_vkReleaseDisplayEXT;
#define vkReleaseDisplayEXT glad_vkReleaseDisplayEXT
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GLAD_API_CALL PFN_vkReleaseFullScreenExclusiveModeEXT glad_vkReleaseFullScreenExclusiveModeEXT;
#define vkReleaseFullScreenExclusiveModeEXT glad_vkReleaseFullScreenExclusiveModeEXT
#endif
GLAD_API_CALL PFN_vkReleaseProfilingLockKHR glad_vkReleaseProfilingLockKHR;
#define vkReleaseProfilingLockKHR glad_vkReleaseProfilingLockKHR
GLAD_API_CALL PFN_vkResetCommandBuffer glad_vkResetCommandBuffer;
#define vkResetCommandBuffer glad_vkResetCommandBuffer
GLAD_API_CALL PFN_vkResetCommandPool glad_vkResetCommandPool;
#define vkResetCommandPool glad_vkResetCommandPool
GLAD_API_CALL PFN_vkResetDescriptorPool glad_vkResetDescriptorPool;
#define vkResetDescriptorPool glad_vkResetDescriptorPool
GLAD_API_CALL PFN_vkResetEvent glad_vkResetEvent;
#define vkResetEvent glad_vkResetEvent
GLAD_API_CALL PFN_vkResetFences glad_vkResetFences;
#define vkResetFences glad_vkResetFences
GLAD_API_CALL PFN_vkResetQueryPool glad_vkResetQueryPool;
#define vkResetQueryPool glad_vkResetQueryPool
GLAD_API_CALL PFN_vkResetQueryPoolEXT glad_vkResetQueryPoolEXT;
#define vkResetQueryPoolEXT glad_vkResetQueryPoolEXT
GLAD_API_CALL PFN_vkSetDebugUtilsObjectNameEXT glad_vkSetDebugUtilsObjectNameEXT;
#define vkSetDebugUtilsObjectNameEXT glad_vkSetDebugUtilsObjectNameEXT
GLAD_API_CALL PFN_vkSetDebugUtilsObjectTagEXT glad_vkSetDebugUtilsObjectTagEXT;
#define vkSetDebugUtilsObjectTagEXT glad_vkSetDebugUtilsObjectTagEXT
GLAD_API_CALL PFN_vkSetEvent glad_vkSetEvent;
#define vkSetEvent glad_vkSetEvent
GLAD_API_CALL PFN_vkSetHdrMetadataEXT glad_vkSetHdrMetadataEXT;
#define vkSetHdrMetadataEXT glad_vkSetHdrMetadataEXT
GLAD_API_CALL PFN_vkSetPrivateDataEXT glad_vkSetPrivateDataEXT;
#define vkSetPrivateDataEXT glad_vkSetPrivateDataEXT
GLAD_API_CALL PFN_vkSignalSemaphore glad_vkSignalSemaphore;
#define vkSignalSemaphore glad_vkSignalSemaphore
GLAD_API_CALL PFN_vkSignalSemaphoreKHR glad_vkSignalSemaphoreKHR;
#define vkSignalSemaphoreKHR glad_vkSignalSemaphoreKHR
GLAD_API_CALL PFN_vkSubmitDebugUtilsMessageEXT glad_vkSubmitDebugUtilsMessageEXT;
#define vkSubmitDebugUtilsMessageEXT glad_vkSubmitDebugUtilsMessageEXT
GLAD_API_CALL PFN_vkTrimCommandPool glad_vkTrimCommandPool;
#define vkTrimCommandPool glad_vkTrimCommandPool
GLAD_API_CALL PFN_vkTrimCommandPoolKHR glad_vkTrimCommandPoolKHR;
#define vkTrimCommandPoolKHR glad_vkTrimCommandPoolKHR
GLAD_API_CALL PFN_vkUnmapMemory glad_vkUnmapMemory;
#define vkUnmapMemory glad_vkUnmapMemory
GLAD_API_CALL PFN_vkUpdateDescriptorSetWithTemplate glad_vkUpdateDescriptorSetWithTemplate;
#define vkUpdateDescriptorSetWithTemplate glad_vkUpdateDescriptorSetWithTemplate
GLAD_API_CALL PFN_vkUpdateDescriptorSetWithTemplateKHR glad_vkUpdateDescriptorSetWithTemplateKHR;
#define vkUpdateDescriptorSetWithTemplateKHR glad_vkUpdateDescriptorSetWithTemplateKHR
GLAD_API_CALL PFN_vkUpdateDescriptorSets glad_vkUpdateDescriptorSets;
#define vkUpdateDescriptorSets glad_vkUpdateDescriptorSets
GLAD_API_CALL PFN_vkWaitForFences glad_vkWaitForFences;
#define vkWaitForFences glad_vkWaitForFences
GLAD_API_CALL PFN_vkWaitSemaphores glad_vkWaitSemaphores;
#define vkWaitSemaphores glad_vkWaitSemaphores
GLAD_API_CALL PFN_vkWaitSemaphoresKHR glad_vkWaitSemaphoresKHR;
#define vkWaitSemaphoresKHR glad_vkWaitSemaphoresKHR
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GLAD_API_CALL PFN_vkWriteAccelerationStructuresPropertiesKHR glad_vkWriteAccelerationStructuresPropertiesKHR;
#define vkWriteAccelerationStructuresPropertiesKHR glad_vkWriteAccelerationStructuresPropertiesKHR
#endif





GLAD_API_CALL int gladLoadVulkanUserPtr( VkPhysicalDevice physical_device, GLADuserptrloadfunc load, void *userptr);
GLAD_API_CALL int gladLoadVulkan( VkPhysicalDevice physical_device, GLADloadfunc load);


#ifdef GLAD_VULKAN

GLAD_API_CALL int gladLoaderLoadVulkan( VkInstance instance, VkPhysicalDevice physical_device, VkDevice device);
GLAD_API_CALL void gladLoaderUnloadVulkan(void);



#endif

#ifdef __cplusplus
}
#endif
#endif

```

`Modules/Vulkan/Public/vk_mem_alloc.h`:

```h
//
// Copyright (c) 2017-2019 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#ifndef AMD_VULKAN_MEMORY_ALLOCATOR_H
#define AMD_VULKAN_MEMORY_ALLOCATOR_H

#ifdef __cplusplus
extern "C" {
#endif

/** \mainpage Vulkan Memory Allocator

<b>Version 2.3.0</b> (2019-12-04)

Copyright (c) 2017-2019 Advanced Micro Devices, Inc. All rights reserved. \n
License: MIT

Documentation of all members: vk_mem_alloc.h

\section main_table_of_contents Table of contents

- <b>User guide</b>
  - \subpage quick_start
    - [Project setup](@ref quick_start_project_setup)
    - [Initialization](@ref quick_start_initialization)
    - [Resource allocation](@ref quick_start_resource_allocation)
  - \subpage choosing_memory_type
    - [Usage](@ref choosing_memory_type_usage)
    - [Required and preferred flags](@ref choosing_memory_type_required_preferred_flags)
    - [Explicit memory types](@ref choosing_memory_type_explicit_memory_types)
    - [Custom memory pools](@ref choosing_memory_type_custom_memory_pools)
    - [Dedicated allocations](@ref choosing_memory_type_dedicated_allocations)
  - \subpage memory_mapping
    - [Mapping functions](@ref memory_mapping_mapping_functions)
    - [Persistently mapped memory](@ref memory_mapping_persistently_mapped_memory)
    - [Cache flush and invalidate](@ref memory_mapping_cache_control)
    - [Finding out if memory is mappable](@ref memory_mapping_finding_if_memory_mappable)
  - \subpage staying_within_budget
    - [Querying for budget](@ref staying_within_budget_querying_for_budget)
    - [Controlling memory usage](@ref staying_within_budget_controlling_memory_usage)
  - \subpage custom_memory_pools
    - [Choosing memory type index](@ref custom_memory_pools_MemTypeIndex)
    - [Linear allocation algorithm](@ref linear_algorithm)
      - [Free-at-once](@ref linear_algorithm_free_at_once)
      - [Stack](@ref linear_algorithm_stack)
      - [Double stack](@ref linear_algorithm_double_stack)
      - [Ring buffer](@ref linear_algorithm_ring_buffer)
    - [Buddy allocation algorithm](@ref buddy_algorithm)
  - \subpage defragmentation
  	- [Defragmenting CPU memory](@ref defragmentation_cpu)
  	- [Defragmenting GPU memory](@ref defragmentation_gpu)
  	- [Additional notes](@ref defragmentation_additional_notes)
  	- [Writing custom allocation algorithm](@ref defragmentation_custom_algorithm)
  - \subpage lost_allocations
  - \subpage statistics
    - [Numeric statistics](@ref statistics_numeric_statistics)
    - [JSON dump](@ref statistics_json_dump)
  - \subpage allocation_annotation
    - [Allocation user data](@ref allocation_user_data)
    - [Allocation names](@ref allocation_names)
  - \subpage debugging_memory_usage
    - [Memory initialization](@ref debugging_memory_usage_initialization)
    - [Margins](@ref debugging_memory_usage_margins)
    - [Corruption detection](@ref debugging_memory_usage_corruption_detection)
  - \subpage record_and_replay
- \subpage usage_patterns
  - [Common mistakes](@ref usage_patterns_common_mistakes)
  - [Simple patterns](@ref usage_patterns_simple)
  - [Advanced patterns](@ref usage_patterns_advanced)
- \subpage configuration
  - [Pointers to Vulkan functions](@ref config_Vulkan_functions)
  - [Custom host memory allocator](@ref custom_memory_allocator)
  - [Device memory allocation callbacks](@ref allocation_callbacks)
  - [Device heap memory limit](@ref heap_memory_limit)
  - \subpage vk_khr_dedicated_allocation
- \subpage general_considerations
  - [Thread safety](@ref general_considerations_thread_safety)
  - [Validation layer warnings](@ref general_considerations_validation_layer_warnings)
  - [Allocation algorithm](@ref general_considerations_allocation_algorithm)
  - [Features not supported](@ref general_considerations_features_not_supported)

\section main_see_also See also

- [Product page on GPUOpen](https://gpuopen.com/gaming-product/vulkan-memory-allocator/)
- [Source repository on GitHub](https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator)




\page quick_start Quick start

\section quick_start_project_setup Project setup

Vulkan Memory Allocator comes in form of a "stb-style" single header file.
You don't need to build it as a separate library project.
You can add this file directly to your project and submit it to code repository next to your other source files.

"Single header" doesn't mean that everything is contained in C/C++ declarations,
like it tends to be in case of inline functions or C++ templates.
It means that implementation is bundled with interface in a single file and needs to be extracted using preprocessor macro.
If you don't do it properly, you will get linker errors.

To do it properly:

-# Include "vk_mem_alloc.h" file in each CPP file where you want to use the library.
   This includes declarations of all members of the library.
-# In exacly one CPP file define following macro before this include.
   It enables also internal definitions.

\code
#define VMA_IMPLEMENTATION
#include "vk_mem_alloc.h"
\endcode

It may be a good idea to create dedicated CPP file just for this purpose.

Note on language: This library is written in C++, but has C-compatible interface.
Thus you can include and use vk_mem_alloc.h in C or C++ code, but full
implementation with `VMA_IMPLEMENTATION` macro must be compiled as C++, NOT as C.

Please note that this library includes header `<vulkan/vulkan.h>`, which in turn
includes `<windows.h>` on Windows. If you need some specific macros defined
before including these headers (like `WIN32_LEAN_AND_MEAN` or
`WINVER` for Windows, `VK_USE_PLATFORM_WIN32_KHR` for Vulkan), you must define
them before every `#include` of this library.


\section quick_start_initialization Initialization

At program startup:

-# Initialize Vulkan to have `VkPhysicalDevice` and `VkDevice` object.
-# Fill VmaAllocatorCreateInfo structure and create #VmaAllocator object by
   calling vmaCreateAllocator().

\code
VmaAllocatorCreateInfo allocatorInfo = {};
allocatorInfo.physicalDevice = physicalDevice;
allocatorInfo.device = device;

VmaAllocator allocator;
vmaCreateAllocator(&allocatorInfo, &allocator);
\endcode

\section quick_start_resource_allocation Resource allocation

When you want to create a buffer or image:

-# Fill `VkBufferCreateInfo` / `VkImageCreateInfo` structure.
-# Fill VmaAllocationCreateInfo structure.
-# Call vmaCreateBuffer() / vmaCreateImage() to get `VkBuffer`/`VkImage` with memory
   already allocated and bound to it.

\code
VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
bufferInfo.size = 65536;
bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;

VmaAllocationCreateInfo allocInfo = {};
allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;

VkBuffer buffer;
VmaAllocation allocation;
vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &buffer, &allocation, nullptr);
\endcode

Don't forget to destroy your objects when no longer needed:

\code
vmaDestroyBuffer(allocator, buffer, allocation);
vmaDestroyAllocator(allocator);
\endcode


\page choosing_memory_type Choosing memory type

Physical devices in Vulkan support various combinations of memory heaps and
types. Help with choosing correct and optimal memory type for your specific
resource is one of the key features of this library. You can use it by filling
appropriate members of VmaAllocationCreateInfo structure, as described below.
You can also combine multiple methods.

-# If you just want to find memory type index that meets your requirements, you
   can use function: vmaFindMemoryTypeIndex(), vmaFindMemoryTypeIndexForBufferInfo(),
   vmaFindMemoryTypeIndexForImageInfo().
-# If you want to allocate a region of device memory without association with any
   specific image or buffer, you can use function vmaAllocateMemory(). Usage of
   this function is not recommended and usually not needed.
   vmaAllocateMemoryPages() function is also provided for creating multiple allocations at once,
   which may be useful for sparse binding.
-# If you already have a buffer or an image created, you want to allocate memory
   for it and then you will bind it yourself, you can use function
   vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage().
   For binding you should use functions: vmaBindBufferMemory(), vmaBindImageMemory()
   or their extended versions: vmaBindBufferMemory2(), vmaBindImageMemory2().
-# If you want to create a buffer or an image, allocate memory for it and bind
   them together, all in one call, you can use function vmaCreateBuffer(),
   vmaCreateImage(). This is the easiest and recommended way to use this library.

When using 3. or 4., the library internally queries Vulkan for memory types
supported for that buffer or image (function `vkGetBufferMemoryRequirements()`)
and uses only one of these types.

If no memory type can be found that meets all the requirements, these functions
return `VK_ERROR_FEATURE_NOT_PRESENT`.

You can leave VmaAllocationCreateInfo structure completely filled with zeros.
It means no requirements are specified for memory type.
It is valid, although not very useful.

\section choosing_memory_type_usage Usage

The easiest way to specify memory requirements is to fill member
VmaAllocationCreateInfo::usage using one of the values of enum #VmaMemoryUsage.
It defines high level, common usage types.
For more details, see description of this enum.

For example, if you want to create a uniform buffer that will be filled using
transfer only once or infrequently and used for rendering every frame, you can
do it using following code:

\code
VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
bufferInfo.size = 65536;
bufferInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;

VmaAllocationCreateInfo allocInfo = {};
allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;

VkBuffer buffer;
VmaAllocation allocation;
vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &buffer, &allocation, nullptr);
\endcode

\section choosing_memory_type_required_preferred_flags Required and preferred flags

You can specify more detailed requirements by filling members
VmaAllocationCreateInfo::requiredFlags and VmaAllocationCreateInfo::preferredFlags
with a combination of bits from enum `VkMemoryPropertyFlags`. For example,
if you want to create a buffer that will be persistently mapped on host (so it
must be `HOST_VISIBLE`) and preferably will also be `HOST_COHERENT` and `HOST_CACHED`,
use following code:

\code
VmaAllocationCreateInfo allocInfo = {};
allocInfo.requiredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
allocInfo.preferredFlags = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
allocInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;

VkBuffer buffer;
VmaAllocation allocation;
vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &buffer, &allocation, nullptr);
\endcode

A memory type is chosen that has all the required flags and as many preferred
flags set as possible.

If you use VmaAllocationCreateInfo::usage, it is just internally converted to
a set of required and preferred flags.

\section choosing_memory_type_explicit_memory_types Explicit memory types

If you inspected memory types available on the physical device and you have
a preference for memory types that you want to use, you can fill member
VmaAllocationCreateInfo::memoryTypeBits. It is a bit mask, where each bit set
means that a memory type with that index is allowed to be used for the
allocation. Special value 0, just like `UINT32_MAX`, means there are no
restrictions to memory type index.

Please note that this member is NOT just a memory type index.
Still you can use it to choose just one, specific memory type.
For example, if you already determined that your buffer should be created in
memory type 2, use following code:

\code
uint32_t memoryTypeIndex = 2;

VmaAllocationCreateInfo allocInfo = {};
allocInfo.memoryTypeBits = 1u << memoryTypeIndex;

VkBuffer buffer;
VmaAllocation allocation;
vmaCreateBuffer(allocator, &bufferInfo, &allocInfo, &buffer, &allocation, nullptr);
\endcode

\section choosing_memory_type_custom_memory_pools Custom memory pools

If you allocate from custom memory pool, all the ways of specifying memory
requirements described above are not applicable and the aforementioned members
of VmaAllocationCreateInfo structure are ignored. Memory type is selected
explicitly when creating the pool and then used to make all the allocations from
that pool. For further details, see \ref custom_memory_pools.

\section choosing_memory_type_dedicated_allocations Dedicated allocations

Memory for allocations is reserved out of larger block of `VkDeviceMemory`
allocated from Vulkan internally. That's the main feature of this whole library.
You can still request a separate memory block to be created for an allocation,
just like you would do in a trivial solution without using any allocator.
In that case, a buffer or image is always bound to that memory at offset 0.
This is called a "dedicated allocation".
You can explicitly request it by using flag #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
The library can also internally decide to use dedicated allocation in some cases, e.g.:

- When the size of the allocation is large.
- When [VK_KHR_dedicated_allocation](@ref vk_khr_dedicated_allocation) extension is enabled
  and it reports that dedicated allocation is required or recommended for the resource.
- When allocation of next big memory block fails due to not enough device memory,
  but allocation with the exact requested size succeeds.


\page memory_mapping Memory mapping

To "map memory" in Vulkan means to obtain a CPU pointer to `VkDeviceMemory`,
to be able to read from it or write to it in CPU code.
Mapping is possible only of memory allocated from a memory type that has
`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag.
Functions `vkMapMemory()`, `vkUnmapMemory()` are designed for this purpose.
You can use them directly with memory allocated by this library,
but it is not recommended because of following issue:
Mapping the same `VkDeviceMemory` block multiple times is illegal - only one mapping at a time is allowed.
This includes mapping disjoint regions. Mapping is not reference-counted internally by Vulkan.
Because of this, Vulkan Memory Allocator provides following facilities:

\section memory_mapping_mapping_functions Mapping functions

The library provides following functions for mapping of a specific #VmaAllocation: vmaMapMemory(), vmaUnmapMemory().
They are safer and more convenient to use than standard Vulkan functions.
You can map an allocation multiple times simultaneously - mapping is reference-counted internally.
You can also map different allocations simultaneously regardless of whether they use the same `VkDeviceMemory` block.
The way it's implemented is that the library always maps entire memory block, not just region of the allocation.
For further details, see description of vmaMapMemory() function.
Example:

\code
// Having these objects initialized:

struct ConstantBuffer
{
    ...
};
ConstantBuffer constantBufferData;

VmaAllocator allocator;
VkBuffer constantBuffer;
VmaAllocation constantBufferAllocation;

// You can map and fill your buffer using following code:

void* mappedData;
vmaMapMemory(allocator, constantBufferAllocation, &mappedData);
memcpy(mappedData, &constantBufferData, sizeof(constantBufferData));
vmaUnmapMemory(allocator, constantBufferAllocation);
\endcode

When mapping, you may see a warning from Vulkan validation layer similar to this one:

<i>Mapping an image with layout VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL can result in undefined behavior if this memory is used by the device. Only GENERAL or PREINITIALIZED should be used.</i>

It happens because the library maps entire `VkDeviceMemory` block, where different
types of images and buffers may end up together, especially on GPUs with unified memory like Intel.
You can safely ignore it if you are sure you access only memory of the intended
object that you wanted to map.


\section memory_mapping_persistently_mapped_memory Persistently mapped memory

Kepping your memory persistently mapped is generally OK in Vulkan.
You don't need to unmap it before using its data on the GPU.
The library provides a special feature designed for that:
Allocations made with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag set in
VmaAllocationCreateInfo::flags stay mapped all the time,
so you can just access CPU pointer to it any time
without a need to call any "map" or "unmap" function.
Example:

\code
VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
bufCreateInfo.size = sizeof(ConstantBuffer);
bufCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;

VmaAllocationCreateInfo allocCreateInfo = {};
allocCreateInfo.usage = VMA_MEMORY_USAGE_CPU_ONLY;
allocCreateInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;

VkBuffer buf;
VmaAllocation alloc;
VmaAllocationInfo allocInfo;
vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);

// Buffer is already mapped. You can access its memory.
memcpy(allocInfo.pMappedData, &constantBufferData, sizeof(constantBufferData));
\endcode

There are some exceptions though, when you should consider mapping memory only for a short period of time:

- When operating system is Windows 7 or 8.x (Windows 10 is not affected because it uses WDDM2),
  device is discrete AMD GPU,
  and memory type is the special 256 MiB pool of `DEVICE_LOCAL + HOST_VISIBLE` memory
  (selected when you use #VMA_MEMORY_USAGE_CPU_TO_GPU),
  then whenever a memory block allocated from this memory type stays mapped
  for the time of any call to `vkQueueSubmit()` or `vkQueuePresentKHR()`, this
  block is migrated by WDDM to system RAM, which degrades performance. It doesn't
  matter if that particular memory block is actually used by the command buffer
  being submitted.
- On Mac/MoltenVK there is a known bug - [Issue #175](https://github.com/KhronosGroup/MoltenVK/issues/175)
  which requires unmapping before GPU can see updated texture.
- Keeping many large memory blocks mapped may impact performance or stability of some debugging tools.

\section memory_mapping_cache_control Cache flush and invalidate
  
Memory in Vulkan doesn't need to be unmapped before using it on GPU,
but unless a memory types has `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` flag set,
you need to manually **invalidate** cache before reading of mapped pointer
and **flush** cache after writing to mapped pointer.
Map/unmap operations don't do that automatically.
Vulkan provides following functions for this purpose `vkFlushMappedMemoryRanges()`,
`vkInvalidateMappedMemoryRanges()`, but this library provides more convenient
functions that refer to given allocation object: vmaFlushAllocation(),
vmaInvalidateAllocation().

Regions of memory specified for flush/invalidate must be aligned to
`VkPhysicalDeviceLimits::nonCoherentAtomSize`. This is automatically ensured by the library.
In any memory type that is `HOST_VISIBLE` but not `HOST_COHERENT`, all allocations
within blocks are aligned to this value, so their offsets are always multiply of
`nonCoherentAtomSize` and two different allocations never share same "line" of this size.

Please note that memory allocated with #VMA_MEMORY_USAGE_CPU_ONLY is guaranteed to be `HOST_COHERENT`.

Also, Windows drivers from all 3 **PC** GPU vendors (AMD, Intel, NVIDIA)
currently provide `HOST_COHERENT` flag on all memory types that are
`HOST_VISIBLE`, so on this platform you may not need to bother.

\section memory_mapping_finding_if_memory_mappable Finding out if memory is mappable

It may happen that your allocation ends up in memory that is `HOST_VISIBLE` (available for mapping)
despite it wasn't explicitly requested.
For example, application may work on integrated graphics with unified memory (like Intel) or
allocation from video memory might have failed, so the library chose system memory as fallback.

You can detect this case and map such allocation to access its memory on CPU directly,
instead of launching a transfer operation.
In order to do that: inspect `allocInfo.memoryType`, call vmaGetMemoryTypeProperties(),
and look for `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag in properties of that memory type.

\code
VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
bufCreateInfo.size = sizeof(ConstantBuffer);
bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;

VmaAllocationCreateInfo allocCreateInfo = {};
allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
allocCreateInfo.preferredFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;

VkBuffer buf;
VmaAllocation alloc;
VmaAllocationInfo allocInfo;
vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);

VkMemoryPropertyFlags memFlags;
vmaGetMemoryTypeProperties(allocator, allocInfo.memoryType, &memFlags);
if((memFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
{
    // Allocation ended up in mappable memory. You can map it and access it directly.
    void* mappedData;
    vmaMapMemory(allocator, alloc, &mappedData);
    memcpy(mappedData, &constantBufferData, sizeof(constantBufferData));
    vmaUnmapMemory(allocator, alloc);
}
else
{
    // Allocation ended up in non-mappable memory.
    // You need to create CPU-side buffer in VMA_MEMORY_USAGE_CPU_ONLY and make a transfer.
}
\endcode

You can even use #VMA_ALLOCATION_CREATE_MAPPED_BIT flag while creating allocations
that are not necessarily `HOST_VISIBLE` (e.g. using #VMA_MEMORY_USAGE_GPU_ONLY).
If the allocation ends up in memory type that is `HOST_VISIBLE`, it will be persistently mapped and you can use it directly.
If not, the flag is just ignored.
Example:

\code
VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
bufCreateInfo.size = sizeof(ConstantBuffer);
bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;

VmaAllocationCreateInfo allocCreateInfo = {};
allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
allocCreateInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT;

VkBuffer buf;
VmaAllocation alloc;
VmaAllocationInfo allocInfo;
vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);

if(allocInfo.pUserData != nullptr)
{
    // Allocation ended up in mappable memory.
    // It's persistently mapped. You can access it directly.
    memcpy(allocInfo.pMappedData, &constantBufferData, sizeof(constantBufferData));
}
else
{
    // Allocation ended up in non-mappable memory.
    // You need to create CPU-side buffer in VMA_MEMORY_USAGE_CPU_ONLY and make a transfer.
}
\endcode


\page staying_within_budget Staying within budget

When developing a graphics-intensive game or program, it is important to avoid allocating
more GPU memory than it's physically available. When the memory is over-committed,
various bad things can happen, depending on the specific GPU, graphics driver, and
operating system:

- It may just work without any problems.
- The application may slow down because some memory blocks are moved to system RAM
  and the GPU has to access them through PCI Express bus.
- A new allocation may take very long time to complete, even few seconds, and possibly
  freeze entire system.
- The new allocation may fail with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
- It may even result in GPU crash (TDR), observed as `VK_ERROR_DEVICE_LOST`
  returned somewhere later.

\section staying_within_budget_querying_for_budget Querying for budget

To query for current memory usage and available budget, use function vmaGetBudget().
Returned structure #VmaBudget contains quantities expressed in bytes, per Vulkan memory heap.

Please note that this function returns different information and works faster than
vmaCalculateStats(). vmaGetBudget() can be called every frame or even before every
allocation, while vmaCalculateStats() is intended to be used rarely,
only to obtain statistical information, e.g. for debugging purposes.

It is recommended to use <b>VK_EXT_memory_budget</b> device extension to obtain information
about the budget from Vulkan device. VMA is able to use this extension automatically.
When not enabled, the allocator behaves same way, but then it estimates current usage
and available budget based on its internal information and Vulkan memory heap sizes,
which may be less precise. In order to use this extension:

1. Make sure extensions VK_EXT_memory_budget and VK_KHR_get_physical_device_properties2
   required by it are available and enable them. Please note that the first is a device
   extension and the second is instance extension!
2. Use flag #VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT when creating #VmaAllocator object.
3. Make sure to call vmaSetCurrentFrameIndex() every frame. Budget is queried from
   Vulkan inside of it to avoid overhead of querying it with every allocation.

\section staying_within_budget_controlling_memory_usage Controlling memory usage

There are many ways in which you can try to stay within the budget.

First, when making new allocation requires allocating a new memory block, the library
tries not to exceed the budget automatically. If a block with default recommended size
(e.g. 256 MB) would go over budget, a smaller block is allocated, possibly even
dedicated memory for just this resource.

If the size of the requested resource plus current memory usage is more than the
budget, by default the library still tries to create it, leaving it to the Vulkan
implementation whether the allocation succeeds or fails. You can change this behavior
by using #VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT flag. With it, the allocation is
not made if it would exceed the budget or if the budget is already exceeded.
Some other allocations become lost instead to make room for it, if the mechanism of
[lost allocations](@ref lost_allocations) is used.
If that is not possible, the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
Example usage pattern may be to pass the #VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT flag
when creating resources that are not essential for the application (e.g. the texture
of a specific object) and not to pass it when creating critically important resources
(e.g. render targets).

Finally, you can also use #VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT flag to make sure
a new allocation is created only when it fits inside one of the existing memory blocks.
If it would require to allocate a new block, if fails instead with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
This also ensures that the function call is very fast because it never goes to Vulkan
to obtain a new block.

Please note that creating \ref custom_memory_pools with VmaPoolCreateInfo::minBlockCount
set to more than 0 will try to allocate memory blocks without checking whether they
fit within budget.


\page custom_memory_pools Custom memory pools

A memory pool contains a number of `VkDeviceMemory` blocks.
The library automatically creates and manages default pool for each memory type available on the device.
Default memory pool automatically grows in size.
Size of allocated blocks is also variable and managed automatically.

You can create custom pool and allocate memory out of it.
It can be useful if you want to:

- Keep certain kind of allocations separate from others.
- Enforce particular, fixed size of Vulkan memory blocks.
- Limit maximum amount of Vulkan memory allocated for that pool.
- Reserve minimum or fixed amount of Vulkan memory always preallocated for that pool.

To use custom memory pools:

-# Fill VmaPoolCreateInfo structure.
-# Call vmaCreatePool() to obtain #VmaPool handle.
-# When making an allocation, set VmaAllocationCreateInfo::pool to this handle.
   You don't need to specify any other parameters of this structure, like `usage`.

Example:

\code
// Create a pool that can have at most 2 blocks, 128 MiB each.
VmaPoolCreateInfo poolCreateInfo = {};
poolCreateInfo.memoryTypeIndex = ...
poolCreateInfo.blockSize = 128ull * 1024 * 1024;
poolCreateInfo.maxBlockCount = 2;

VmaPool pool;
vmaCreatePool(allocator, &poolCreateInfo, &pool);

// Allocate a buffer out of it.
VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
bufCreateInfo.size = 1024;
bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;

VmaAllocationCreateInfo allocCreateInfo = {};
allocCreateInfo.pool = pool;

VkBuffer buf;
VmaAllocation alloc;
VmaAllocationInfo allocInfo;
vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &buf, &alloc, &allocInfo);
\endcode

You have to free all allocations made from this pool before destroying it.

\code
vmaDestroyBuffer(allocator, buf, alloc);
vmaDestroyPool(allocator, pool);
\endcode

\section custom_memory_pools_MemTypeIndex Choosing memory type index

When creating a pool, you must explicitly specify memory type index.
To find the one suitable for your buffers or images, you can use helper functions
vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo().
You need to provide structures with example parameters of buffers or images
that you are going to create in that pool.

\code
VkBufferCreateInfo exampleBufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
exampleBufCreateInfo.size = 1024; // Whatever.
exampleBufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT; // Change if needed.

VmaAllocationCreateInfo allocCreateInfo = {};
allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY; // Change if needed.

uint32_t memTypeIndex;
vmaFindMemoryTypeIndexForBufferInfo(allocator, &exampleBufCreateInfo, &allocCreateInfo, &memTypeIndex);

VmaPoolCreateInfo poolCreateInfo = {};
poolCreateInfo.memoryTypeIndex = memTypeIndex;
// ...
\endcode

When creating buffers/images allocated in that pool, provide following parameters:

- `VkBufferCreateInfo`: Prefer to pass same parameters as above.
  Otherwise you risk creating resources in a memory type that is not suitable for them, which may result in undefined behavior.
  Using different `VK_BUFFER_USAGE_` flags may work, but you shouldn't create images in a pool intended for buffers
  or the other way around.
- VmaAllocationCreateInfo: You don't need to pass same parameters. Fill only `pool` member.
  Other members are ignored anyway.

\section linear_algorithm Linear allocation algorithm

Each Vulkan memory block managed by this library has accompanying metadata that
keeps track of used and unused regions. By default, the metadata structure and
algorithm tries to find best place for new allocations among free regions to
optimize memory usage. This way you can allocate and free objects in any order.

![Default allocation algorithm](../gfx/Linear_allocator_1_algo_default.png)

Sometimes there is a need to use simpler, linear allocation algorithm. You can
create custom pool that uses such algorithm by adding flag
#VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT to VmaPoolCreateInfo::flags while creating
#VmaPool object. Then an alternative metadata management is used. It always
creates new allocations after last one and doesn't reuse free regions after
allocations freed in the middle. It results in better allocation performance and
less memory consumed by metadata.

![Linear allocation algorithm](../gfx/Linear_allocator_2_algo_linear.png)

With this one flag, you can create a custom pool that can be used in many ways:
free-at-once, stack, double stack, and ring buffer. See below for details.

\subsection linear_algorithm_free_at_once Free-at-once

In a pool that uses linear algorithm, you still need to free all the allocations
individually, e.g. by using vmaFreeMemory() or vmaDestroyBuffer(). You can free
them in any order. New allocations are always made after last one - free space
in the middle is not reused. However, when you release all the allocation and
the pool becomes empty, allocation starts from the beginning again. This way you
can use linear algorithm to speed up creation of allocations that you are going
to release all at once.

![Free-at-once](../gfx/Linear_allocator_3_free_at_once.png)

This mode is also available for pools created with VmaPoolCreateInfo::maxBlockCount
value that allows multiple memory blocks.

\subsection linear_algorithm_stack Stack

When you free an allocation that was created last, its space can be reused.
Thanks to this, if you always release allocations in the order opposite to their
creation (LIFO - Last In First Out), you can achieve behavior of a stack.

![Stack](../gfx/Linear_allocator_4_stack.png)

This mode is also available for pools created with VmaPoolCreateInfo::maxBlockCount
value that allows multiple memory blocks.

\subsection linear_algorithm_double_stack Double stack

The space reserved by a custom pool with linear algorithm may be used by two
stacks:

- First, default one, growing up from offset 0.
- Second, "upper" one, growing down from the end towards lower offsets.

To make allocation from upper stack, add flag #VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT
to VmaAllocationCreateInfo::flags.

![Double stack](../gfx/Linear_allocator_7_double_stack.png)

Double stack is available only in pools with one memory block -
VmaPoolCreateInfo::maxBlockCount must be 1. Otherwise behavior is undefined.

When the two stacks' ends meet so there is not enough space between them for a
new allocation, such allocation fails with usual
`VK_ERROR_OUT_OF_DEVICE_MEMORY` error.

\subsection linear_algorithm_ring_buffer Ring buffer

When you free some allocations from the beginning and there is not enough free space
for a new one at the end of a pool, allocator's "cursor" wraps around to the
beginning and starts allocation there. Thanks to this, if you always release
allocations in the same order as you created them (FIFO - First In First Out),
you can achieve behavior of a ring buffer / queue.

![Ring buffer](../gfx/Linear_allocator_5_ring_buffer.png)

Pools with linear algorithm support [lost allocations](@ref lost_allocations) when used as ring buffer.
If there is not enough free space for a new allocation, but existing allocations
from the front of the queue can become lost, they become lost and the allocation
succeeds.

![Ring buffer with lost allocations](../gfx/Linear_allocator_6_ring_buffer_lost.png)

Ring buffer is available only in pools with one memory block -
VmaPoolCreateInfo::maxBlockCount must be 1. Otherwise behavior is undefined.

\section buddy_algorithm Buddy allocation algorithm

There is another allocation algorithm that can be used with custom pools, called
"buddy". Its internal data structure is based on a tree of blocks, each having
size that is a power of two and a half of its parent's size. When you want to
allocate memory of certain size, a free node in the tree is located. If it's too
large, it is recursively split into two halves (called "buddies"). However, if
requested allocation size is not a power of two, the size of a tree node is
aligned up to the nearest power of two and the remaining space is wasted. When
two buddy nodes become free, they are merged back into one larger node.

![Buddy allocator](../gfx/Buddy_allocator.png)

The advantage of buddy allocation algorithm over default algorithm is faster
allocation and deallocation, as well as smaller external fragmentation. The
disadvantage is more wasted space (internal fragmentation).

For more information, please read ["Buddy memory allocation" on Wikipedia](https://en.wikipedia.org/wiki/Buddy_memory_allocation)
or other sources that describe this concept in general.

To use buddy allocation algorithm with a custom pool, add flag
#VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT to VmaPoolCreateInfo::flags while creating
#VmaPool object.

Several limitations apply to pools that use buddy algorithm:

- It is recommended to use VmaPoolCreateInfo::blockSize that is a power of two.
  Otherwise, only largest power of two smaller than the size is used for
  allocations. The remaining space always stays unused.
- [Margins](@ref debugging_memory_usage_margins) and
  [corruption detection](@ref debugging_memory_usage_corruption_detection)
  don't work in such pools.
- [Lost allocations](@ref lost_allocations) don't work in such pools. You can
  use them, but they never become lost. Support may be added in the future.
- [Defragmentation](@ref defragmentation) doesn't work with allocations made from
  such pool.

\page defragmentation Defragmentation

Interleaved allocations and deallocations of many objects of varying size can
cause fragmentation over time, which can lead to a situation where the library is unable
to find a continuous range of free memory for a new allocation despite there is
enough free space, just scattered across many small free ranges between existing
allocations.

To mitigate this problem, you can use defragmentation feature:
structure #VmaDefragmentationInfo2, function vmaDefragmentationBegin(), vmaDefragmentationEnd().
Given set of allocations, 
this function can move them to compact used memory, ensure more continuous free
space and possibly also free some `VkDeviceMemory` blocks.

What the defragmentation does is:

- Updates #VmaAllocation objects to point to new `VkDeviceMemory` and offset.
  After allocation has been moved, its VmaAllocationInfo::deviceMemory and/or
  VmaAllocationInfo::offset changes. You must query them again using
  vmaGetAllocationInfo() if you need them.
- Moves actual data in memory.

What it doesn't do, so you need to do it yourself:

- Recreate buffers and images that were bound to allocations that were defragmented and
  bind them with their new places in memory.
  You must use `vkDestroyBuffer()`, `vkDestroyImage()`,
  `vkCreateBuffer()`, `vkCreateImage()`, vmaBindBufferMemory(), vmaBindImageMemory()
  for that purpose and NOT vmaDestroyBuffer(),
  vmaDestroyImage(), vmaCreateBuffer(), vmaCreateImage(), because you don't need to
  destroy or create allocation objects!
- Recreate views and update descriptors that point to these buffers and images.

\section defragmentation_cpu Defragmenting CPU memory

Following example demonstrates how you can run defragmentation on CPU.
Only allocations created in memory types that are `HOST_VISIBLE` can be defragmented.
Others are ignored.

The way it works is:

- It temporarily maps entire memory blocks when necessary.
- It moves data using `memmove()` function.

\code
// Given following variables already initialized:
VkDevice device;
VmaAllocator allocator;
std::vector<VkBuffer> buffers;
std::vector<VmaAllocation> allocations;


const uint32_t allocCount = (uint32_t)allocations.size();
std::vector<VkBool32> allocationsChanged(allocCount);

VmaDefragmentationInfo2 defragInfo = {};
defragInfo.allocationCount = allocCount;
defragInfo.pAllocations = allocations.data();
defragInfo.pAllocationsChanged = allocationsChanged.data();
defragInfo.maxCpuBytesToMove = VK_WHOLE_SIZE; // No limit.
defragInfo.maxCpuAllocationsToMove = UINT32_MAX; // No limit.

VmaDefragmentationContext defragCtx;
vmaDefragmentationBegin(allocator, &defragInfo, nullptr, &defragCtx);
vmaDefragmentationEnd(allocator, defragCtx);

for(uint32_t i = 0; i < allocCount; ++i)
{
    if(allocationsChanged[i])
    {
        // Destroy buffer that is immutably bound to memory region which is no longer valid.
        vkDestroyBuffer(device, buffers[i], nullptr);

        // Create new buffer with same parameters.
        VkBufferCreateInfo bufferInfo = ...;
        vkCreateBuffer(device, &bufferInfo, nullptr, &buffers[i]);
            
        // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.
            
        // Bind new buffer to new memory region. Data contained in it is already moved.
        VmaAllocationInfo allocInfo;
        vmaGetAllocationInfo(allocator, allocations[i], &allocInfo);
        vmaBindBufferMemory(allocator, allocations[i], buffers[i]);
    }
}
\endcode

Setting VmaDefragmentationInfo2::pAllocationsChanged is optional.
This output array tells whether particular allocation in VmaDefragmentationInfo2::pAllocations at the same index
has been modified during defragmentation.
You can pass null, but you then need to query every allocation passed to defragmentation
for new parameters using vmaGetAllocationInfo() if you might need to recreate and rebind a buffer or image associated with it.

If you use [Custom memory pools](@ref choosing_memory_type_custom_memory_pools),
you can fill VmaDefragmentationInfo2::poolCount and VmaDefragmentationInfo2::pPools
instead of VmaDefragmentationInfo2::allocationCount and VmaDefragmentationInfo2::pAllocations
to defragment all allocations in given pools.
You cannot use VmaDefragmentationInfo2::pAllocationsChanged in that case.
You can also combine both methods.

\section defragmentation_gpu Defragmenting GPU memory

It is also possible to defragment allocations created in memory types that are not `HOST_VISIBLE`.
To do that, you need to pass a command buffer that meets requirements as described in
VmaDefragmentationInfo2::commandBuffer. The way it works is:

- It creates temporary buffers and binds them to entire memory blocks when necessary.
- It issues `vkCmdCopyBuffer()` to passed command buffer.

Example:

\code
// Given following variables already initialized:
VkDevice device;
VmaAllocator allocator;
VkCommandBuffer commandBuffer;
std::vector<VkBuffer> buffers;
std::vector<VmaAllocation> allocations;


const uint32_t allocCount = (uint32_t)allocations.size();
std::vector<VkBool32> allocationsChanged(allocCount);

VkCommandBufferBeginInfo cmdBufBeginInfo = ...;
vkBeginCommandBuffer(commandBuffer, &cmdBufBeginInfo);

VmaDefragmentationInfo2 defragInfo = {};
defragInfo.allocationCount = allocCount;
defragInfo.pAllocations = allocations.data();
defragInfo.pAllocationsChanged = allocationsChanged.data();
defragInfo.maxGpuBytesToMove = VK_WHOLE_SIZE; // Notice it's "GPU" this time.
defragInfo.maxGpuAllocationsToMove = UINT32_MAX; // Notice it's "GPU" this time.
defragInfo.commandBuffer = commandBuffer;

VmaDefragmentationContext defragCtx;
vmaDefragmentationBegin(allocator, &defragInfo, nullptr, &defragCtx);

vkEndCommandBuffer(commandBuffer);

// Submit commandBuffer.
// Wait for a fence that ensures commandBuffer execution finished.

vmaDefragmentationEnd(allocator, defragCtx);

for(uint32_t i = 0; i < allocCount; ++i)
{
    if(allocationsChanged[i])
    {
        // Destroy buffer that is immutably bound to memory region which is no longer valid.
        vkDestroyBuffer(device, buffers[i], nullptr);

        // Create new buffer with same parameters.
        VkBufferCreateInfo bufferInfo = ...;
        vkCreateBuffer(device, &bufferInfo, nullptr, &buffers[i]);
            
        // You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.
            
        // Bind new buffer to new memory region. Data contained in it is already moved.
        VmaAllocationInfo allocInfo;
        vmaGetAllocationInfo(allocator, allocations[i], &allocInfo);
        vmaBindBufferMemory(allocator, allocations[i], buffers[i]);
    }
}
\endcode

You can combine these two methods by specifying non-zero `maxGpu*` as well as `maxCpu*` parameters.
The library automatically chooses best method to defragment each memory pool.

You may try not to block your entire program to wait until defragmentation finishes,
but do it in the background, as long as you carefully fullfill requirements described
in function vmaDefragmentationBegin().

\section defragmentation_additional_notes Additional notes

It is only legal to defragment allocations bound to:

- buffers
- images created with `VK_IMAGE_CREATE_ALIAS_BIT`, `VK_IMAGE_TILING_LINEAR`, and
  being currently in `VK_IMAGE_LAYOUT_GENERAL` or `VK_IMAGE_LAYOUT_PREINITIALIZED`.

Defragmentation of images created with `VK_IMAGE_TILING_OPTIMAL` or in any other
layout may give undefined results.

If you defragment allocations bound to images, new images to be bound to new
memory region after defragmentation should be created with `VK_IMAGE_LAYOUT_PREINITIALIZED`
and then transitioned to their original layout from before defragmentation if
needed using an image memory barrier.

While using defragmentation, you may experience validation layer warnings, which you just need to ignore.
See [Validation layer warnings](@ref general_considerations_validation_layer_warnings).

Please don't expect memory to be fully compacted after defragmentation.
Algorithms inside are based on some heuristics that try to maximize number of Vulkan
memory blocks to make totally empty to release them, as well as to maximimze continuous
empty space inside remaining blocks, while minimizing the number and size of allocations that
need to be moved. Some fragmentation may still remain - this is normal.

\section defragmentation_custom_algorithm Writing custom defragmentation algorithm

If you want to implement your own, custom defragmentation algorithm,
there is infrastructure prepared for that,
but it is not exposed through the library API - you need to hack its source code.
Here are steps needed to do this:

-# Main thing you need to do is to define your own class derived from base abstract
   class `VmaDefragmentationAlgorithm` and implement your version of its pure virtual methods.
   See definition and comments of this class for details.
-# Your code needs to interact with device memory block metadata.
   If you need more access to its data than it's provided by its public interface,
   declare your new class as a friend class e.g. in class `VmaBlockMetadata_Generic`.
-# If you want to create a flag that would enable your algorithm or pass some additional
   flags to configure it, add them to `VmaDefragmentationFlagBits` and use them in
   VmaDefragmentationInfo2::flags.
-# Modify function `VmaBlockVectorDefragmentationContext::Begin` to create object
   of your new class whenever needed.


\page lost_allocations Lost allocations

If your game oversubscribes video memory, if may work OK in previous-generation
graphics APIs (DirectX 9, 10, 11, OpenGL) because resources are automatically
paged to system RAM. In Vulkan you can't do it because when you run out of
memory, an allocation just fails. If you have more data (e.g. textures) that can
fit into VRAM and you don't need it all at once, you may want to upload them to
GPU on demand and "push out" ones that are not used for a long time to make room
for the new ones, effectively using VRAM (or a cartain memory pool) as a form of
cache. Vulkan Memory Allocator can help you with that by supporting a concept of
"lost allocations".

To create an allocation that can become lost, include #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT
flag in VmaAllocationCreateInfo::flags. Before using a buffer or image bound to
such allocation in every new frame, you need to query it if it's not lost.
To check it, call vmaTouchAllocation().
If the allocation is lost, you should not use it or buffer/image bound to it.
You mustn't forget to destroy this allocation and this buffer/image.
vmaGetAllocationInfo() can also be used for checking status of the allocation.
Allocation is lost when returned VmaAllocationInfo::deviceMemory == `VK_NULL_HANDLE`.

To create an allocation that can make some other allocations lost to make room
for it, use #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flag. You will
usually use both flags #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT and
#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT at the same time.

Warning! Current implementation uses quite naive, brute force algorithm,
which can make allocation calls that use #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT
flag quite slow. A new, more optimal algorithm and data structure to speed this
up is planned for the future.

<b>Q: When interleaving creation of new allocations with usage of existing ones,
how do you make sure that an allocation won't become lost while it's used in the
current frame?</b>

It is ensured because vmaTouchAllocation() / vmaGetAllocationInfo() not only returns allocation
status/parameters and checks whether it's not lost, but when it's not, it also
atomically marks it as used in the current frame, which makes it impossible to
become lost in that frame. It uses lockless algorithm, so it works fast and
doesn't involve locking any internal mutex.

<b>Q: What if my allocation may still be in use by the GPU when it's rendering a
previous frame while I already submit new frame on the CPU?</b>

You can make sure that allocations "touched" by vmaTouchAllocation() / vmaGetAllocationInfo() will not
become lost for a number of additional frames back from the current one by
specifying this number as VmaAllocatorCreateInfo::frameInUseCount (for default
memory pool) and VmaPoolCreateInfo::frameInUseCount (for custom pool).

<b>Q: How do you inform the library when new frame starts?</b>

You need to call function vmaSetCurrentFrameIndex().

Example code:

\code
struct MyBuffer
{
    VkBuffer m_Buf = nullptr;
    VmaAllocation m_Alloc = nullptr;

    // Called when the buffer is really needed in the current frame.
    void EnsureBuffer();
};

void MyBuffer::EnsureBuffer()
{
    // Buffer has been created.
    if(m_Buf != VK_NULL_HANDLE)
    {
        // Check if its allocation is not lost + mark it as used in current frame.
        if(vmaTouchAllocation(allocator, m_Alloc))
        {
            // It's all OK - safe to use m_Buf.
            return;
        }
    }

    // Buffer not yet exists or lost - destroy and recreate it.

    vmaDestroyBuffer(allocator, m_Buf, m_Alloc);

    VkBufferCreateInfo bufCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
    bufCreateInfo.size = 1024;
    bufCreateInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;

    VmaAllocationCreateInfo allocCreateInfo = {};
    allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
    allocCreateInfo.flags = VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT |
        VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT;

    vmaCreateBuffer(allocator, &bufCreateInfo, &allocCreateInfo, &m_Buf, &m_Alloc, nullptr);
}
\endcode

When using lost allocations, you may see some Vulkan validation layer warnings
about overlapping regions of memory bound to different kinds of buffers and
images. This is still valid as long as you implement proper handling of lost
allocations (like in the example above) and don't use them.

You can create an allocation that is already in lost state from the beginning using function
vmaCreateLostAllocation(). It may be useful if you need a "dummy" allocation that is not null.

You can call function vmaMakePoolAllocationsLost() to set all eligible allocations
in a specified custom pool to lost state.
Allocations that have been "touched" in current frame or VmaPoolCreateInfo::frameInUseCount frames back
cannot become lost.

<b>Q: Can I touch allocation that cannot become lost?</b>

Yes, although it has no visible effect.
Calls to vmaGetAllocationInfo() and vmaTouchAllocation() update last use frame index
also for allocations that cannot become lost, but the only way to observe it is to dump
internal allocator state using vmaBuildStatsString().
You can use this feature for debugging purposes to explicitly mark allocations that you use
in current frame and then analyze JSON dump to see for how long each allocation stays unused.


\page statistics Statistics

This library contains functions that return information about its internal state,
especially the amount of memory allocated from Vulkan.
Please keep in mind that these functions need to traverse all internal data structures
to gather these information, so they may be quite time-consuming.
Don't call them too often.

\section statistics_numeric_statistics Numeric statistics

You can query for overall statistics of the allocator using function vmaCalculateStats().
Information are returned using structure #VmaStats.
It contains #VmaStatInfo - number of allocated blocks, number of allocations
(occupied ranges in these blocks), number of unused (free) ranges in these blocks,
number of bytes used and unused (but still allocated from Vulkan) and other information.
They are summed across memory heaps, memory types and total for whole allocator.

You can query for statistics of a custom pool using function vmaGetPoolStats().
Information are returned using structure #VmaPoolStats.

You can query for information about specific allocation using function vmaGetAllocationInfo().
It fill structure #VmaAllocationInfo.

\section statistics_json_dump JSON dump

You can dump internal state of the allocator to a string in JSON format using function vmaBuildStatsString().
The result is guaranteed to be correct JSON.
It uses ANSI encoding.
Any strings provided by user (see [Allocation names](@ref allocation_names))
are copied as-is and properly escaped for JSON, so if they use UTF-8, ISO-8859-2 or any other encoding,
this JSON string can be treated as using this encoding.
It must be freed using function vmaFreeStatsString().

The format of this JSON string is not part of official documentation of the library,
but it will not change in backward-incompatible way without increasing library major version number
and appropriate mention in changelog.

The JSON string contains all the data that can be obtained using vmaCalculateStats().
It can also contain detailed map of allocated memory blocks and their regions -
free and occupied by allocations.
This allows e.g. to visualize the memory or assess fragmentation.


\page allocation_annotation Allocation names and user data

\section allocation_user_data Allocation user data

You can annotate allocations with your own information, e.g. for debugging purposes.
To do that, fill VmaAllocationCreateInfo::pUserData field when creating
an allocation. It's an opaque `void*` pointer. You can use it e.g. as a pointer,
some handle, index, key, ordinal number or any other value that would associate
the allocation with your custom metadata.

\code
VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
// Fill bufferInfo...

MyBufferMetadata* pMetadata = CreateBufferMetadata();

VmaAllocationCreateInfo allocCreateInfo = {};
allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
allocCreateInfo.pUserData = pMetadata;

VkBuffer buffer;
VmaAllocation allocation;
vmaCreateBuffer(allocator, &bufferInfo, &allocCreateInfo, &buffer, &allocation, nullptr);
\endcode

The pointer may be later retrieved as VmaAllocationInfo::pUserData:

\code
VmaAllocationInfo allocInfo;
vmaGetAllocationInfo(allocator, allocation, &allocInfo);
MyBufferMetadata* pMetadata = (MyBufferMetadata*)allocInfo.pUserData;
\endcode

It can also be changed using function vmaSetAllocationUserData().

Values of (non-zero) allocations' `pUserData` are printed in JSON report created by
vmaBuildStatsString(), in hexadecimal form.

\section allocation_names Allocation names

There is alternative mode available where `pUserData` pointer is used to point to
a null-terminated string, giving a name to the allocation. To use this mode,
set #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT flag in VmaAllocationCreateInfo::flags.
Then `pUserData` passed as VmaAllocationCreateInfo::pUserData or argument to
vmaSetAllocationUserData() must be either null or pointer to a null-terminated string.
The library creates internal copy of the string, so the pointer you pass doesn't need
to be valid for whole lifetime of the allocation. You can free it after the call.

\code
VkImageCreateInfo imageInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
// Fill imageInfo...

std::string imageName = "Texture: ";
imageName += fileName;

VmaAllocationCreateInfo allocCreateInfo = {};
allocCreateInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
allocCreateInfo.flags = VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT;
allocCreateInfo.pUserData = imageName.c_str();

VkImage image;
VmaAllocation allocation;
vmaCreateImage(allocator, &imageInfo, &allocCreateInfo, &image, &allocation, nullptr);
\endcode

The value of `pUserData` pointer of the allocation will be different than the one
you passed when setting allocation's name - pointing to a buffer managed
internally that holds copy of the string.

\code
VmaAllocationInfo allocInfo;
vmaGetAllocationInfo(allocator, allocation, &allocInfo);
const char* imageName = (const char*)allocInfo.pUserData;
printf("Image name: %s\n", imageName);
\endcode

That string is also printed in JSON report created by vmaBuildStatsString().


\page debugging_memory_usage Debugging incorrect memory usage

If you suspect a bug with memory usage, like usage of uninitialized memory or
memory being overwritten out of bounds of an allocation,
you can use debug features of this library to verify this.

\section debugging_memory_usage_initialization Memory initialization

If you experience a bug with incorrect and nondeterministic data in your program and you suspect uninitialized memory to be used,
you can enable automatic memory initialization to verify this.
To do it, define macro `VMA_DEBUG_INITIALIZE_ALLOCATIONS` to 1.

\code
#define VMA_DEBUG_INITIALIZE_ALLOCATIONS 1
#include "vk_mem_alloc.h"
\endcode

It makes memory of all new allocations initialized to bit pattern `0xDCDCDCDC`.
Before an allocation is destroyed, its memory is filled with bit pattern `0xEFEFEFEF`.
Memory is automatically mapped and unmapped if necessary.

If you find these values while debugging your program, good chances are that you incorrectly
read Vulkan memory that is allocated but not initialized, or already freed, respectively.

Memory initialization works only with memory types that are `HOST_VISIBLE`.
It works also with dedicated allocations.
It doesn't work with allocations created with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag,
as they cannot be mapped.

\section debugging_memory_usage_margins Margins

By default, allocations are laid out in memory blocks next to each other if possible
(considering required alignment, `bufferImageGranularity`, and `nonCoherentAtomSize`).

![Allocations without margin](../gfx/Margins_1.png)

Define macro `VMA_DEBUG_MARGIN` to some non-zero value (e.g. 16) to enforce specified
number of bytes as a margin before and after every allocation.

\code
#define VMA_DEBUG_MARGIN 16
#include "vk_mem_alloc.h"
\endcode

![Allocations with margin](../gfx/Margins_2.png)

If your bug goes away after enabling margins, it means it may be caused by memory
being overwritten outside of allocation boundaries. It is not 100% certain though.
Change in application behavior may also be caused by different order and distribution
of allocations across memory blocks after margins are applied.

The margin is applied also before first and after last allocation in a block.
It may occur only once between two adjacent allocations.

Margins work with all types of memory.

Margin is applied only to allocations made out of memory blocks and not to dedicated
allocations, which have their own memory block of specific size.
It is thus not applied to allocations made using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT flag
or those automatically decided to put into dedicated allocations, e.g. due to its
large size or recommended by VK_KHR_dedicated_allocation extension.
Margins are also not active in custom pools created with #VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT flag.

Margins appear in [JSON dump](@ref statistics_json_dump) as part of free space.

Note that enabling margins increases memory usage and fragmentation.

\section debugging_memory_usage_corruption_detection Corruption detection

You can additionally define macro `VMA_DEBUG_DETECT_CORRUPTION` to 1 to enable validation
of contents of the margins.

\code
#define VMA_DEBUG_MARGIN 16
#define VMA_DEBUG_DETECT_CORRUPTION 1
#include "vk_mem_alloc.h"
\endcode

When this feature is enabled, number of bytes specified as `VMA_DEBUG_MARGIN`
(it must be multiply of 4) before and after every allocation is filled with a magic number.
This idea is also know as "canary".
Memory is automatically mapped and unmapped if necessary.

This number is validated automatically when the allocation is destroyed.
If it's not equal to the expected value, `VMA_ASSERT()` is executed.
It clearly means that either CPU or GPU overwritten the memory outside of boundaries of the allocation,
which indicates a serious bug.

You can also explicitly request checking margins of all allocations in all memory blocks
that belong to specified memory types by using function vmaCheckCorruption(),
or in memory blocks that belong to specified custom pool, by using function 
vmaCheckPoolCorruption().

Margin validation (corruption detection) works only for memory types that are
`HOST_VISIBLE` and `HOST_COHERENT`.


\page record_and_replay Record and replay

\section record_and_replay_introduction Introduction

While using the library, sequence of calls to its functions together with their
parameters can be recorded to a file and later replayed using standalone player
application. It can be useful to:

- Test correctness - check if same sequence of calls will not cause crash or
  failures on a target platform.
- Gather statistics - see number of allocations, peak memory usage, number of
  calls etc.
- Benchmark performance - see how much time it takes to replay the whole
  sequence.

\section record_and_replay_usage Usage

Recording functionality is disabled by default.
To enable it, define following macro before every include of this library:

\code
#define VMA_RECORDING_ENABLED 1
\endcode

<b>To record sequence of calls to a file:</b> Fill in
VmaAllocatorCreateInfo::pRecordSettings member while creating #VmaAllocator
object. File is opened and written during whole lifetime of the allocator.

<b>To replay file:</b> Use VmaReplay - standalone command-line program.
Precompiled binary can be found in "bin" directory.
Its source can be found in "src/VmaReplay" directory.
Its project is generated by Premake.
Command line syntax is printed when the program is launched without parameters.
Basic usage:

    VmaReplay.exe MyRecording.csv

<b>Documentation of file format</b> can be found in file: "docs/Recording file format.md".
It's a human-readable, text file in CSV format (Comma Separated Values).

\section record_and_replay_additional_considerations Additional considerations

- Replaying file that was recorded on a different GPU (with different parameters
  like `bufferImageGranularity`, `nonCoherentAtomSize`, and especially different
  set of memory heaps and types) may give different performance and memory usage
  results, as well as issue some warnings and errors.
- Current implementation of recording in VMA, as well as VmaReplay application, is
  coded and tested only on Windows. Inclusion of recording code is driven by
  `VMA_RECORDING_ENABLED` macro. Support for other platforms should be easy to
  add. Contributions are welcomed.


\page usage_patterns Recommended usage patterns

See also slides from talk:
[Sawicki, Adam. Advanced Graphics Techniques Tutorial: Memory management in Vulkan and DX12. Game Developers Conference, 2018](https://www.gdcvault.com/play/1025458/Advanced-Graphics-Techniques-Tutorial-New)


\section usage_patterns_common_mistakes Common mistakes

<b>Use of CPU_TO_GPU instead of CPU_ONLY memory</b>

#VMA_MEMORY_USAGE_CPU_TO_GPU is recommended only for resources that will be
mapped and written by the CPU, as well as read directly by the GPU - like some
buffers or textures updated every frame (dynamic). If you create a staging copy
of a resource to be written by CPU and then used as a source of transfer to
another resource placed in the GPU memory, that staging resource should be
created with #VMA_MEMORY_USAGE_CPU_ONLY. Please read the descriptions of these
enums carefully for details.

<b>Unnecessary use of custom pools</b>

\ref custom_memory_pools may be useful for special purposes - when you want to
keep certain type of resources separate e.g. to reserve minimum amount of memory
for them, limit maximum amount of memory they can occupy, or make some of them
push out the other through the mechanism of \ref lost_allocations. For most
resources this is not needed and so it is not recommended to create #VmaPool
objects and allocations out of them. Allocating from the default pool is sufficient.

\section usage_patterns_simple Simple patterns

\subsection usage_patterns_simple_render_targets Render targets

<b>When:</b>
Any resources that you frequently write and read on GPU,
e.g. images used as color attachments (aka "render targets"), depth-stencil attachments,
images/buffers used as storage image/buffer (aka "Unordered Access View (UAV)").

<b>What to do:</b>
Create them in video memory that is fastest to access from GPU using
#VMA_MEMORY_USAGE_GPU_ONLY.

Consider using [VK_KHR_dedicated_allocation](@ref vk_khr_dedicated_allocation) extension
and/or manually creating them as dedicated allocations using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT,
especially if they are large or if you plan to destroy and recreate them e.g. when
display resolution changes.
Prefer to create such resources first and all other GPU resources (like textures and vertex buffers) later.

\subsection usage_patterns_simple_immutable_resources Immutable resources

<b>When:</b>
Any resources that you fill on CPU only once (aka "immutable") or infrequently
and then read frequently on GPU,
e.g. textures, vertex and index buffers, constant buffers that don't change often.

<b>What to do:</b>
Create them in video memory that is fastest to access from GPU using
#VMA_MEMORY_USAGE_GPU_ONLY.

To initialize content of such resource, create a CPU-side (aka "staging") copy of it
in system memory - #VMA_MEMORY_USAGE_CPU_ONLY, map it, fill it,
and submit a transfer from it to the GPU resource.
You can keep the staging copy if you need it for another upload transfer in the future.
If you don't, you can destroy it or reuse this buffer for uploading different resource
after the transfer finishes.

Prefer to create just buffers in system memory rather than images, even for uploading textures.
Use `vkCmdCopyBufferToImage()`.
Dont use images with `VK_IMAGE_TILING_LINEAR`.

\subsection usage_patterns_dynamic_resources Dynamic resources

<b>When:</b>
Any resources that change frequently (aka "dynamic"), e.g. every frame or every draw call,
written on CPU, read on GPU.

<b>What to do:</b>
Create them using #VMA_MEMORY_USAGE_CPU_TO_GPU.
You can map it and write to it directly on CPU, as well as read from it on GPU.

This is a more complex situation. Different solutions are possible,
and the best one depends on specific GPU type, but you can use this simple approach for the start.
Prefer to write to such resource sequentially (e.g. using `memcpy`).
Don't perform random access or any reads from it on CPU, as it may be very slow.

\subsection usage_patterns_readback Readback

<b>When:</b>
Resources that contain data written by GPU that you want to read back on CPU,
e.g. results of some computations.

<b>What to do:</b>
Create them using #VMA_MEMORY_USAGE_GPU_TO_CPU.
You can write to them directly on GPU, as well as map and read them on CPU.

\section usage_patterns_advanced Advanced patterns

\subsection usage_patterns_integrated_graphics Detecting integrated graphics

You can support integrated graphics (like Intel HD Graphics, AMD APU) better
by detecting it in Vulkan.
To do it, call `vkGetPhysicalDeviceProperties()`, inspect
`VkPhysicalDeviceProperties::deviceType` and look for `VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU`.
When you find it, you can assume that memory is unified and all memory types are comparably fast
to access from GPU, regardless of `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`.

You can then sum up sizes of all available memory heaps and treat them as useful for
your GPU resources, instead of only `DEVICE_LOCAL` ones.
You can also prefer to create your resources in memory types that are `HOST_VISIBLE` to map them
directly instead of submitting explicit transfer (see below).

\subsection usage_patterns_direct_vs_transfer Direct access versus transfer

For resources that you frequently write on CPU and read on GPU, many solutions are possible:

-# Create one copy in video memory using #VMA_MEMORY_USAGE_GPU_ONLY,
   second copy in system memory using #VMA_MEMORY_USAGE_CPU_ONLY and submit explicit tranfer each time.
-# Create just single copy using #VMA_MEMORY_USAGE_CPU_TO_GPU, map it and fill it on CPU,
   read it directly on GPU.
-# Create just single copy using #VMA_MEMORY_USAGE_CPU_ONLY, map it and fill it on CPU,
   read it directly on GPU.

Which solution is the most efficient depends on your resource and especially on the GPU.
It is best to measure it and then make the decision.
Some general recommendations:

- On integrated graphics use (2) or (3) to avoid unnecesary time and memory overhead
  related to using a second copy and making transfer.
- For small resources (e.g. constant buffers) use (2).
  Discrete AMD cards have special 256 MiB pool of video memory that is directly mappable.
  Even if the resource ends up in system memory, its data may be cached on GPU after first
  fetch over PCIe bus.
- For larger resources (e.g. textures), decide between (1) and (2).
  You may want to differentiate NVIDIA and AMD, e.g. by looking for memory type that is
  both `DEVICE_LOCAL` and `HOST_VISIBLE`. When you find it, use (2), otherwise use (1).

Similarly, for resources that you frequently write on GPU and read on CPU, multiple
solutions are possible:

-# Create one copy in video memory using #VMA_MEMORY_USAGE_GPU_ONLY,
   second copy in system memory using #VMA_MEMORY_USAGE_GPU_TO_CPU and submit explicit tranfer each time.
-# Create just single copy using #VMA_MEMORY_USAGE_GPU_TO_CPU, write to it directly on GPU,
   map it and read it on CPU.

You should take some measurements to decide which option is faster in case of your specific
resource.

If you don't want to specialize your code for specific types of GPUs, you can still make
an simple optimization for cases when your resource ends up in mappable memory to use it
directly in this case instead of creating CPU-side staging copy.
For details see [Finding out if memory is mappable](@ref memory_mapping_finding_if_memory_mappable).


\page configuration Configuration

Please check "CONFIGURATION SECTION" in the code to find macros that you can define
before each include of this file or change directly in this file to provide
your own implementation of basic facilities like assert, `min()` and `max()` functions,
mutex, atomic etc.
The library uses its own implementation of containers by default, but you can switch to using
STL containers instead.

For example, define `VMA_ASSERT(expr)` before including the library to provide
custom implementation of the assertion, compatible with your project.
By default it is defined to standard C `assert(expr)` in `_DEBUG` configuration
and empty otherwise.

\section config_Vulkan_functions Pointers to Vulkan functions

The library uses Vulkan functions straight from the `vulkan.h` header by default.
If you want to provide your own pointers to these functions, e.g. fetched using
`vkGetInstanceProcAddr()` and `vkGetDeviceProcAddr()`:

-# Define `VMA_STATIC_VULKAN_FUNCTIONS 0`.
-# Provide valid pointers through VmaAllocatorCreateInfo::pVulkanFunctions.

\section custom_memory_allocator Custom host memory allocator

If you use custom allocator for CPU memory rather than default operator `new`
and `delete` from C++, you can make this library using your allocator as well
by filling optional member VmaAllocatorCreateInfo::pAllocationCallbacks. These
functions will be passed to Vulkan, as well as used by the library itself to
make any CPU-side allocations.

\section allocation_callbacks Device memory allocation callbacks

The library makes calls to `vkAllocateMemory()` and `vkFreeMemory()` internally.
You can setup callbacks to be informed about these calls, e.g. for the purpose
of gathering some statistics. To do it, fill optional member
VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.

\section heap_memory_limit Device heap memory limit

When device memory of certain heap runs out of free space, new allocations may
fail (returning error code) or they may succeed, silently pushing some existing
memory blocks from GPU VRAM to system RAM (which degrades performance). This
behavior is implementation-dependant - it depends on GPU vendor and graphics
driver.

On AMD cards it can be controlled while creating Vulkan device object by using
VK_AMD_memory_overallocation_behavior extension, if available.

Alternatively, if you want to test how your program behaves with limited amount of Vulkan device
memory available without switching your graphics card to one that really has
smaller VRAM, you can use a feature of this library intended for this purpose.
To do it, fill optional member VmaAllocatorCreateInfo::pHeapSizeLimit.



\page vk_khr_dedicated_allocation VK_KHR_dedicated_allocation

VK_KHR_dedicated_allocation is a Vulkan extension which can be used to improve
performance on some GPUs. It augments Vulkan API with possibility to query
driver whether it prefers particular buffer or image to have its own, dedicated
allocation (separate `VkDeviceMemory` block) for better efficiency - to be able
to do some internal optimizations.

The extension is supported by this library. It will be used automatically when
enabled. To enable it:

1 . When creating Vulkan device, check if following 2 device extensions are
supported (call `vkEnumerateDeviceExtensionProperties()`).
If yes, enable them (fill `VkDeviceCreateInfo::ppEnabledExtensionNames`).

- VK_KHR_get_memory_requirements2
- VK_KHR_dedicated_allocation

If you enabled these extensions:

2 . Use #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag when creating
your #VmaAllocator`to inform the library that you enabled required extensions
and you want the library to use them.

\code
allocatorInfo.flags |= VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT;

vmaCreateAllocator(&allocatorInfo, &allocator);
\endcode

That's all. The extension will be automatically used whenever you create a
buffer using vmaCreateBuffer() or image using vmaCreateImage().

When using the extension together with Vulkan Validation Layer, you will receive
warnings like this:

    vkBindBufferMemory(): Binding memory to buffer 0x33 but vkGetBufferMemoryRequirements() has not been called on that buffer.

It is OK, you should just ignore it. It happens because you use function
`vkGetBufferMemoryRequirements2KHR()` instead of standard
`vkGetBufferMemoryRequirements()`, while the validation layer seems to be
unaware of it.

To learn more about this extension, see:

- [VK_KHR_dedicated_allocation in Vulkan specification](https://www.khronos.org/registry/vulkan/specs/1.0-extensions/html/vkspec.html#VK_KHR_dedicated_allocation)
- [VK_KHR_dedicated_allocation unofficial manual](http://asawicki.info/articles/VK_KHR_dedicated_allocation.php5)



\page general_considerations General considerations

\section general_considerations_thread_safety Thread safety

- The library has no global state, so separate #VmaAllocator objects can be used
  independently.
  There should be no need to create multiple such objects though - one per `VkDevice` is enough.
- By default, all calls to functions that take #VmaAllocator as first parameter
  are safe to call from multiple threads simultaneously because they are
  synchronized internally when needed.
- When the allocator is created with #VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT
  flag, calls to functions that take such #VmaAllocator object must be
  synchronized externally.
- Access to a #VmaAllocation object must be externally synchronized. For example,
  you must not call vmaGetAllocationInfo() and vmaMapMemory() from different
  threads at the same time if you pass the same #VmaAllocation object to these
  functions.

\section general_considerations_validation_layer_warnings Validation layer warnings

When using this library, you can meet following types of warnings issued by
Vulkan validation layer. They don't necessarily indicate a bug, so you may need
to just ignore them.

- *vkBindBufferMemory(): Binding memory to buffer 0xeb8e4 but vkGetBufferMemoryRequirements() has not been called on that buffer.*
  - It happens when VK_KHR_dedicated_allocation extension is enabled.
    `vkGetBufferMemoryRequirements2KHR` function is used instead, while validation layer seems to be unaware of it.
- *Mapping an image with layout VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL can result in undefined behavior if this memory is used by the device. Only GENERAL or PREINITIALIZED should be used.*
  - It happens when you map a buffer or image, because the library maps entire
    `VkDeviceMemory` block, where different types of images and buffers may end
    up together, especially on GPUs with unified memory like Intel.
- *Non-linear image 0xebc91 is aliased with linear buffer 0xeb8e4 which may indicate a bug.*
  - It happens when you use lost allocations, and a new image or buffer is
    created in place of an existing object that bacame lost.
  - It may happen also when you use [defragmentation](@ref defragmentation).

\section general_considerations_allocation_algorithm Allocation algorithm

The library uses following algorithm for allocation, in order:

-# Try to find free range of memory in existing blocks.
-# If failed, try to create a new block of `VkDeviceMemory`, with preferred block size.
-# If failed, try to create such block with size/2, size/4, size/8.
-# If failed and #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flag was
   specified, try to find space in existing blocks, possilby making some other
   allocations lost.
-# If failed, try to allocate separate `VkDeviceMemory` for this allocation,
   just like when you use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
-# If failed, choose other memory type that meets the requirements specified in
   VmaAllocationCreateInfo and go to point 1.
-# If failed, return `VK_ERROR_OUT_OF_DEVICE_MEMORY`.

\section general_considerations_features_not_supported Features not supported

Features deliberately excluded from the scope of this library:

- Data transfer. Uploading (straming) and downloading data of buffers and images
  between CPU and GPU memory and related synchronization is responsibility of the user.
  Defining some "texture" object that would automatically stream its data from a
  staging copy in CPU memory to GPU memory would rather be a feature of another,
  higher-level library implemented on top of VMA.
- Allocations for imported/exported external memory. They tend to require
  explicit memory type index and dedicated allocation anyway, so they don't
  interact with main features of this library. Such special purpose allocations
  should be made manually, using `vkCreateBuffer()` and `vkAllocateMemory()`.
- Recreation of buffers and images. Although the library has functions for
  buffer and image creation (vmaCreateBuffer(), vmaCreateImage()), you need to
  recreate these objects yourself after defragmentation. That's because the big
  structures `VkBufferCreateInfo`, `VkImageCreateInfo` are not stored in
  #VmaAllocation object.
- Handling CPU memory allocation failures. When dynamically creating small C++
  objects in CPU memory (not Vulkan memory), allocation failures are not checked
  and handled gracefully, because that would complicate code significantly and
  is usually not needed in desktop PC applications anyway.
- Code free of any compiler warnings. Maintaining the library to compile and
  work correctly on so many different platforms is hard enough. Being free of 
  any warnings, on any version of any compiler, is simply not feasible.
- This is a C++ library with C interface.
  Bindings or ports to any other programming languages are welcomed as external projects and
  are not going to be included into this repository.

*/

/*
Define this macro to 0/1 to disable/enable support for recording functionality,
available through VmaAllocatorCreateInfo::pRecordSettings.
*/
#ifndef VMA_RECORDING_ENABLED
    #define VMA_RECORDING_ENABLED 0
#endif

#ifndef NOMINMAX
    #define NOMINMAX // For windows.h
#endif

#ifndef VULKAN_H_
    #include <vulkan/vulkan.h>
#endif

#if VMA_RECORDING_ENABLED
    #include <windows.h>
#endif

// Define this macro to declare maximum supported Vulkan version in format AAABBBCCC,
// where AAA = major, BBB = minor, CCC = patch.
// If you want to use version > 1.0, it still needs to be enabled via VmaAllocatorCreateInfo::vulkanApiVersion.
#if !defined(VMA_VULKAN_VERSION)
    #if defined(VK_VERSION_1_1)
        #define VMA_VULKAN_VERSION 1001000
    #else
        #define VMA_VULKAN_VERSION 1000000
    #endif
#endif

#if !defined(VMA_DEDICATED_ALLOCATION)
    #if VK_KHR_get_memory_requirements2 && VK_KHR_dedicated_allocation
        #define VMA_DEDICATED_ALLOCATION 1
    #else
        #define VMA_DEDICATED_ALLOCATION 0
    #endif
#endif

#if !defined(VMA_BIND_MEMORY2)
    #if VK_KHR_bind_memory2
        #define VMA_BIND_MEMORY2 1
    #else
        #define VMA_BIND_MEMORY2 0
    #endif
#endif

#if !defined(VMA_MEMORY_BUDGET)
    #if VK_EXT_memory_budget && (VK_KHR_get_physical_device_properties2 || VMA_VULKAN_VERSION >= 1001000)
        #define VMA_MEMORY_BUDGET 1
    #else
        #define VMA_MEMORY_BUDGET 0
    #endif
#endif

// Define these macros to decorate all public functions with additional code,
// before and after returned type, appropriately. This may be useful for
// exporing the functions when compiling VMA as a separate library. Example:
// #define VMA_CALL_PRE  __declspec(dllexport)
// #define VMA_CALL_POST __cdecl
#ifndef VMA_CALL_PRE
    #define VMA_CALL_PRE
#endif
#ifndef VMA_CALL_POST
    #define VMA_CALL_POST
#endif

/** \struct VmaAllocator
\brief Represents main object of this library initialized.

Fill structure #VmaAllocatorCreateInfo and call function vmaCreateAllocator() to create it.
Call function vmaDestroyAllocator() to destroy it.

It is recommended to create just one object of this type per `VkDevice` object,
right after Vulkan is initialized and keep it alive until before Vulkan device is destroyed.
*/
VK_DEFINE_HANDLE(VmaAllocator)

/// Callback function called after successful vkAllocateMemory.
typedef void (VKAPI_PTR *PFN_vmaAllocateDeviceMemoryFunction)(
    VmaAllocator      allocator,
    uint32_t          memoryType,
    VkDeviceMemory    memory,
    VkDeviceSize      size);
/// Callback function called before vkFreeMemory.
typedef void (VKAPI_PTR *PFN_vmaFreeDeviceMemoryFunction)(
    VmaAllocator      allocator,
    uint32_t          memoryType,
    VkDeviceMemory    memory,
    VkDeviceSize      size);

/** \brief Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`.

Provided for informative purpose, e.g. to gather statistics about number of
allocations or total amount of memory allocated in Vulkan.

Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.
*/
typedef struct VmaDeviceMemoryCallbacks {
    /// Optional, can be null.
    PFN_vmaAllocateDeviceMemoryFunction pfnAllocate;
    /// Optional, can be null.
    PFN_vmaFreeDeviceMemoryFunction pfnFree;
} VmaDeviceMemoryCallbacks;

/// Flags for created #VmaAllocator.
typedef enum VmaAllocatorCreateFlagBits {
    /** \brief Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time or synchronized externally by you.

    Using this flag may increase performance because internal mutexes are not used.
    */
    VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x00000001,
    /** \brief Enables usage of VK_KHR_dedicated_allocation extension.

    The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`.
    When it's `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.

    Using this extenion will automatically allocate dedicated blocks of memory for
    some buffers and images instead of suballocating place for them out of bigger
    memory blocks (as if you explicitly used #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
    flag) when it is recommended by the driver. It may improve performance on some
    GPUs.

    You may set this flag only if you found out that following device extensions are
    supported, you enabled them while creating Vulkan device passed as
    VmaAllocatorCreateInfo::device, and you want them to be used internally by this
    library:

    - VK_KHR_get_memory_requirements2 (device extension)
    - VK_KHR_dedicated_allocation (device extension)

    When this flag is set, you can experience following warnings reported by Vulkan
    validation layer. You can ignore them.

    > vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.
    */
    VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT = 0x00000002,
    /**
    Enables usage of VK_KHR_bind_memory2 extension.

    The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`.
    When it's `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.

    You may set this flag only if you found out that this device extension is supported,
    you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,
    and you want it to be used internally by this library.

    The extension provides functions `vkBindBufferMemory2KHR` and `vkBindImageMemory2KHR`,
    which allow to pass a chain of `pNext` structures while binding.
    This flag is required if you use `pNext` parameter in vmaBindBufferMemory2() or vmaBindImageMemory2().
    */
    VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT = 0x00000004,
    /**
    Enables usage of VK_EXT_memory_budget extension.

    You may set this flag only if you found out that this device extension is supported,
    you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,
    and you want it to be used internally by this library, along with another instance extension
    VK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted).

    The extension provides query for current memory usage and budget, which will probably
    be more accurate than an estimation used by the library otherwise.
    */
    VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT = 0x00000008,

    VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VmaAllocatorCreateFlagBits;
typedef VkFlags VmaAllocatorCreateFlags;

/** \brief Pointers to some Vulkan functions - a subset used by the library.

Used in VmaAllocatorCreateInfo::pVulkanFunctions.
*/
typedef struct VmaVulkanFunctions {
    PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties;
    PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties;
    PFN_vkAllocateMemory vkAllocateMemory;
    PFN_vkFreeMemory vkFreeMemory;
    PFN_vkMapMemory vkMapMemory;
    PFN_vkUnmapMemory vkUnmapMemory;
    PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges;
    PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges;
    PFN_vkBindBufferMemory vkBindBufferMemory;
    PFN_vkBindImageMemory vkBindImageMemory;
    PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements;
    PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements;
    PFN_vkCreateBuffer vkCreateBuffer;
    PFN_vkDestroyBuffer vkDestroyBuffer;
    PFN_vkCreateImage vkCreateImage;
    PFN_vkDestroyImage vkDestroyImage;
    PFN_vkCmdCopyBuffer vkCmdCopyBuffer;
#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
    PFN_vkGetBufferMemoryRequirements2KHR vkGetBufferMemoryRequirements2KHR;
    PFN_vkGetImageMemoryRequirements2KHR vkGetImageMemoryRequirements2KHR;
#endif
#if VMA_BIND_MEMORY2 || VMA_VULKAN_VERSION >= 1001000
    PFN_vkBindBufferMemory2KHR vkBindBufferMemory2KHR;
    PFN_vkBindImageMemory2KHR vkBindImageMemory2KHR;
#endif
#if VMA_MEMORY_BUDGET || VMA_VULKAN_VERSION >= 1001000
    PFN_vkGetPhysicalDeviceMemoryProperties2KHR vkGetPhysicalDeviceMemoryProperties2KHR;
#endif
} VmaVulkanFunctions;

/// Flags to be used in VmaRecordSettings::flags.
typedef enum VmaRecordFlagBits {
    /** \brief Enables flush after recording every function call.

    Enable it if you expect your application to crash, which may leave recording file truncated.
    It may degrade performance though.
    */
    VMA_RECORD_FLUSH_AFTER_CALL_BIT = 0x00000001,
    
    VMA_RECORD_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VmaRecordFlagBits;
typedef VkFlags VmaRecordFlags;

/// Parameters for recording calls to VMA functions. To be used in VmaAllocatorCreateInfo::pRecordSettings.
typedef struct VmaRecordSettings
{
    /// Flags for recording. Use #VmaRecordFlagBits enum.
    VmaRecordFlags flags;
    /** \brief Path to the file that should be written by the recording.

    Suggested extension: "csv".
    If the file already exists, it will be overwritten.
    It will be opened for the whole time #VmaAllocator object is alive.
    If opening this file fails, creation of the whole allocator object fails.
    */
    const char* pFilePath;
} VmaRecordSettings;

/// Description of a Allocator to be created.
typedef struct VmaAllocatorCreateInfo
{
    /// Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.
    VmaAllocatorCreateFlags flags;
    /// Vulkan physical device.
    /** It must be valid throughout whole lifetime of created allocator. */
    VkPhysicalDevice physicalDevice;
    /// Vulkan device.
    /** It must be valid throughout whole lifetime of created allocator. */
    VkDevice device;
    /// Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.
    /** Set to 0 to use default, which is currently 256 MiB. */
    VkDeviceSize preferredLargeHeapBlockSize;
    /// Custom CPU memory allocation callbacks. Optional.
    /** Optional, can be null. When specified, will also be used for all CPU-side memory allocations. */
    const VkAllocationCallbacks* pAllocationCallbacks;
    /// Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional.
    /** Optional, can be null. */
    const VmaDeviceMemoryCallbacks* pDeviceMemoryCallbacks;
    /** \brief Maximum number of additional frames that are in use at the same time as current frame.

    This value is used only when you make allocations with
    VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocation cannot become
    lost if allocation.lastUseFrameIndex >= allocator.currentFrameIndex - frameInUseCount.

    For example, if you double-buffer your command buffers, so resources used for
    rendering in previous frame may still be in use by the GPU at the moment you
    allocate resources needed for the current frame, set this value to 1.

    If you want to allow any allocations other than used in the current frame to
    become lost, set this value to 0.
    */
    uint32_t frameInUseCount;
    /** \brief Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap.

    If not NULL, it must be a pointer to an array of
    `VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on
    maximum number of bytes that can be allocated out of particular Vulkan memory
    heap.

    Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that
    heap. This is also the default in case of `pHeapSizeLimit` = NULL.

    If there is a limit defined for a heap:

    - If user tries to allocate more memory from that heap using this allocator,
      the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
    - If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the
      value of this limit will be reported instead when using vmaGetMemoryProperties().

    Warning! Using this feature may not be equivalent to installing a GPU with
    smaller amount of memory, because graphics driver doesn't necessary fail new
    allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is
    exceeded. It may return success and just silently migrate some device memory
    blocks to system RAM. This driver behavior can also be controlled using
    VK_AMD_memory_overallocation_behavior extension.
    */
    const VkDeviceSize* pHeapSizeLimit;
    /** \brief Pointers to Vulkan functions. Can be null if you leave define `VMA_STATIC_VULKAN_FUNCTIONS 1`.

    If you leave define `VMA_STATIC_VULKAN_FUNCTIONS 1` in configuration section,
    you can pass null as this member, because the library will fetch pointers to
    Vulkan functions internally in a static way, like:

        vulkanFunctions.vkAllocateMemory = &vkAllocateMemory;

    Fill this member if you want to provide your own pointers to Vulkan functions,
    e.g. fetched using `vkGetInstanceProcAddr()` and `vkGetDeviceProcAddr()`.
    */
    const VmaVulkanFunctions* pVulkanFunctions;
    /** \brief Parameters for recording of VMA calls. Can be null.

    If not null, it enables recording of calls to VMA functions to a file.
    If support for recording is not enabled using `VMA_RECORDING_ENABLED` macro,
    creation of the allocator object fails with `VK_ERROR_FEATURE_NOT_PRESENT`.
    */
    const VmaRecordSettings* pRecordSettings;
    /** \brief Optional handle to Vulkan instance object.

    Optional, can be null. Must be set if #VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT flas is used
    or if `vulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0)`.
    */
    VkInstance instance;
    /** \brief Optional. The highest version of Vulkan that the application is designed to use.
    
    It must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like: `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`.
    The patch version number specified is ignored. Only the major and minor versions are considered.
    It must be less or euqal (preferably equal) to value as passed to `vkCreateInstance` as `VkApplicationInfo::apiVersion`.
    Only versions 1.0 and 1.1 are supported by the current implementation.
    Leaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`.
    */
    uint32_t vulkanApiVersion;
} VmaAllocatorCreateInfo;

/// Creates Allocator object.
VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAllocator(
    const VmaAllocatorCreateInfo* pCreateInfo,
    VmaAllocator* pAllocator);

/// Destroys allocator object.
VMA_CALL_PRE void VMA_CALL_POST vmaDestroyAllocator(
    VmaAllocator allocator);

/**
PhysicalDeviceProperties are fetched from physicalDevice by the allocator.
You can access it here, without fetching it again on your own.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaGetPhysicalDeviceProperties(
    VmaAllocator allocator,
    const VkPhysicalDeviceProperties** ppPhysicalDeviceProperties);

/**
PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.
You can access it here, without fetching it again on your own.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryProperties(
    VmaAllocator allocator,
    const VkPhysicalDeviceMemoryProperties** ppPhysicalDeviceMemoryProperties);

/**
\brief Given Memory Type Index, returns Property Flags of this memory type.

This is just a convenience function. Same information can be obtained using
vmaGetMemoryProperties().
*/
VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryTypeProperties(
    VmaAllocator allocator,
    uint32_t memoryTypeIndex,
    VkMemoryPropertyFlags* pFlags);

/** \brief Sets index of the current frame.

This function must be used if you make allocations with
#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT and
#VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flags to inform the allocator
when a new frame begins. Allocations queried using vmaGetAllocationInfo() cannot
become lost in the current frame.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaSetCurrentFrameIndex(
    VmaAllocator allocator,
    uint32_t frameIndex);

/** \brief Calculated statistics of memory usage in entire allocator.
*/
typedef struct VmaStatInfo
{
    /// Number of `VkDeviceMemory` Vulkan memory blocks allocated.
    uint32_t blockCount;
    /// Number of #VmaAllocation allocation objects allocated.
    uint32_t allocationCount;
    /// Number of free ranges of memory between allocations.
    uint32_t unusedRangeCount;
    /// Total number of bytes occupied by all allocations.
    VkDeviceSize usedBytes;
    /// Total number of bytes occupied by unused ranges.
    VkDeviceSize unusedBytes;
    VkDeviceSize allocationSizeMin, allocationSizeAvg, allocationSizeMax;
    VkDeviceSize unusedRangeSizeMin, unusedRangeSizeAvg, unusedRangeSizeMax;
} VmaStatInfo;

/// General statistics from current state of Allocator.
typedef struct VmaStats
{
    VmaStatInfo memoryType[VK_MAX_MEMORY_TYPES];
    VmaStatInfo memoryHeap[VK_MAX_MEMORY_HEAPS];
    VmaStatInfo total;
} VmaStats;

/** \brief Retrieves statistics from current state of the Allocator.

This function is called "calculate" not "get" because it has to traverse all
internal data structures, so it may be quite slow. For faster but more brief statistics
suitable to be called every frame or every allocation, use vmaGetBudget().

Note that when using allocator from multiple threads, returned information may immediately
become outdated.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaCalculateStats(
    VmaAllocator allocator,
    VmaStats* pStats);

/** \brief Statistics of current memory usage and available budget, in bytes, for specific memory heap.
*/
typedef struct VmaBudget
{
    /** \brief Sum size of all `VkDeviceMemory` blocks allocated from particular heap, in bytes.
    */
    VkDeviceSize blockBytes;
    
    /** \brief Sum size of all allocations created in particular heap, in bytes.
    
    Usually less or equal than `blockBytes`.
    Difference `blockBytes - allocationBytes` is the amount of memory allocated but unused -
    available for new allocations or wasted due to fragmentation.
    
    It might be greater than `blockBytes` if there are some allocations in lost state, as they account
    to this value as well.
    */
    VkDeviceSize allocationBytes;
    
    /** \brief Estimated current memory usage of the program, in bytes.
    
    Fetched from system using `VK_EXT_memory_budget` extension if enabled.
    
    It might be different than `blockBytes` (usually higher) due to additional implicit objects
    also occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or
    `VkDeviceMemory` blocks allocated outside of this library, if any.
    */
    VkDeviceSize usage;
    
    /** \brief Estimated amount of memory available to the program, in bytes.
    
    Fetched from system using `VK_EXT_memory_budget` extension if enabled.
    
    It might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to factors
    external to the program, like other programs also consuming system resources.
    Difference `budget - usage` is the amount of additional memory that can probably
    be allocated without problems. Exceeding the budget may result in various problems.
    */
    VkDeviceSize budget;
} VmaBudget;

/** \brief Retrieves information about current memory budget for all memory heaps.

\param[out] pBudget Must point to array with number of elements at least equal to number of memory heaps in physical device used.

This function is called "get" not "calculate" because it is very fast, suitable to be called
every frame or every allocation. For more detailed statistics use vmaCalculateStats().

Note that when using allocator from multiple threads, returned information may immediately
become outdated.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaGetBudget(
    VmaAllocator allocator,
    VmaBudget* pBudget);

#ifndef VMA_STATS_STRING_ENABLED
#define VMA_STATS_STRING_ENABLED 1
#endif

#if VMA_STATS_STRING_ENABLED

/// Builds and returns statistics as string in JSON format.
/** @param[out] ppStatsString Must be freed using vmaFreeStatsString() function.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaBuildStatsString(
    VmaAllocator allocator,
    char** ppStatsString,
    VkBool32 detailedMap);

VMA_CALL_PRE void VMA_CALL_POST vmaFreeStatsString(
    VmaAllocator allocator,
    char* pStatsString);

#endif // #if VMA_STATS_STRING_ENABLED

/** \struct VmaPool
\brief Represents custom memory pool

Fill structure VmaPoolCreateInfo and call function vmaCreatePool() to create it.
Call function vmaDestroyPool() to destroy it.

For more information see [Custom memory pools](@ref choosing_memory_type_custom_memory_pools).
*/
VK_DEFINE_HANDLE(VmaPool)

typedef enum VmaMemoryUsage
{
    /** No intended memory usage specified.
    Use other members of VmaAllocationCreateInfo to specify your requirements.
    */
    VMA_MEMORY_USAGE_UNKNOWN = 0,
    /** Memory will be used on device only, so fast access from the device is preferred.
    It usually means device-local GPU (video) memory.
    No need to be mappable on host.
    It is roughly equivalent of `D3D12_HEAP_TYPE_DEFAULT`.

    Usage:
    
    - Resources written and read by device, e.g. images used as attachments.
    - Resources transferred from host once (immutable) or infrequently and read by
      device multiple times, e.g. textures to be sampled, vertex buffers, uniform
      (constant) buffers, and majority of other types of resources used on GPU.

    Allocation may still end up in `HOST_VISIBLE` memory on some implementations.
    In such case, you are free to map it.
    You can use #VMA_ALLOCATION_CREATE_MAPPED_BIT with this usage type.
    */
    VMA_MEMORY_USAGE_GPU_ONLY = 1,
    /** Memory will be mappable on host.
    It usually means CPU (system) memory.
    Guarantees to be `HOST_VISIBLE` and `HOST_COHERENT`.
    CPU access is typically uncached. Writes may be write-combined.
    Resources created in this pool may still be accessible to the device, but access to them can be slow.
    It is roughly equivalent of `D3D12_HEAP_TYPE_UPLOAD`.

    Usage: Staging copy of resources used as transfer source.
    */
    VMA_MEMORY_USAGE_CPU_ONLY = 2,
    /**
    Memory that is both mappable on host (guarantees to be `HOST_VISIBLE`) and preferably fast to access by GPU.
    CPU access is typically uncached. Writes may be write-combined.

    Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every draw call.
    */
    VMA_MEMORY_USAGE_CPU_TO_GPU = 3,
    /** Memory mappable on host (guarantees to be `HOST_VISIBLE`) and cached.
    It is roughly equivalent of `D3D12_HEAP_TYPE_READBACK`.

    Usage:

    - Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping.
    - Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision detection.
    */
    VMA_MEMORY_USAGE_GPU_TO_CPU = 4,
    /** CPU memory - memory that is preferably not `DEVICE_LOCAL`, but also not guaranteed to be `HOST_VISIBLE`.

    Usage: Staging copy of resources moved from GPU memory to CPU memory as part
    of custom paging/residency mechanism, to be moved back to GPU memory when needed.
    */
    VMA_MEMORY_USAGE_CPU_COPY = 5,
    /** Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`.
    Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.
    
    Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`.

    Allocations with this usage are always created as dedicated - it implies #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
    */
    VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED = 6,

    VMA_MEMORY_USAGE_MAX_ENUM = 0x7FFFFFFF
} VmaMemoryUsage;

/// Flags to be passed as VmaAllocationCreateInfo::flags.
typedef enum VmaAllocationCreateFlagBits {
    /** \brief Set this flag if the allocation should have its own memory block.
    
    Use it for special, big resources, like fullscreen images used as attachments.
   
    You should not use this flag if VmaAllocationCreateInfo::pool is not null.
    */
    VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT = 0x00000001,

    /** \brief Set this flag to only try to allocate from existing `VkDeviceMemory` blocks and never create new such block.
    
    If new allocation cannot be placed in any of the existing blocks, allocation
    fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error.
    
    You should not use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT and
    #VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT at the same time. It makes no sense.
    
    If VmaAllocationCreateInfo::pool is not null, this flag is implied and ignored. */
    VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT = 0x00000002,
    /** \brief Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.
    
    Pointer to mapped memory will be returned through VmaAllocationInfo::pMappedData.

    Is it valid to use this flag for allocation made from memory type that is not
    `HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is
    useful if you need an allocation that is efficient to use on GPU
    (`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that
    support it (e.g. Intel GPU).

    You should not use this flag together with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT.
    */
    VMA_ALLOCATION_CREATE_MAPPED_BIT = 0x00000004,
    /** Allocation created with this flag can become lost as a result of another
    allocation with #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flag, so you
    must check it before use.

    To check if allocation is not lost, call vmaGetAllocationInfo() and check if
    VmaAllocationInfo::deviceMemory is not `VK_NULL_HANDLE`.

    For details about supporting lost allocations, see Lost Allocations
    chapter of User Guide on Main Page.

    You should not use this flag together with #VMA_ALLOCATION_CREATE_MAPPED_BIT.
    */
    VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT = 0x00000008,
    /** While creating allocation using this flag, other allocations that were
    created with flag #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT can become lost.

    For details about supporting lost allocations, see Lost Allocations
    chapter of User Guide on Main Page.
    */
    VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT = 0x00000010,
    /** Set this flag to treat VmaAllocationCreateInfo::pUserData as pointer to a
    null-terminated string. Instead of copying pointer value, a local copy of the
    string is made and stored in allocation's `pUserData`. The string is automatically
    freed together with the allocation. It is also used in vmaBuildStatsString().
    */
    VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT = 0x00000020,
    /** Allocation will be created from upper stack in a double stack pool.

    This flag is only allowed for custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT flag.
    */
    VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT = 0x00000040,
    /** Create both buffer/image and allocation, but don't bind them together.
    It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions.
    The flag is meaningful only with functions that bind by default: vmaCreateBuffer(), vmaCreateImage().
    Otherwise it is ignored.
    */
    VMA_ALLOCATION_CREATE_DONT_BIND_BIT = 0x00000080,
    /** Create allocation only if additional device memory required for it, if any, won't exceed
    memory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
    */
    VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT = 0x00000100,

    /** Allocation strategy that chooses smallest possible free range for the
    allocation.
    */
    VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT  = 0x00010000,
    /** Allocation strategy that chooses biggest possible free range for the
    allocation.
    */
    VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT = 0x00020000,
    /** Allocation strategy that chooses first suitable free range for the
    allocation.

    "First" doesn't necessarily means the one with smallest offset in memory,
    but rather the one that is easiest and fastest to find.
    */
    VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT = 0x00040000,

    /** Allocation strategy that tries to minimize memory usage.
    */
    VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT = VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT,
    /** Allocation strategy that tries to minimize allocation time.
    */
    VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT = VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT,
    /** Allocation strategy that tries to minimize memory fragmentation.
    */
    VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT = VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT,

    /** A bit mask to extract only `STRATEGY` bits from entire set of flags.
    */
    VMA_ALLOCATION_CREATE_STRATEGY_MASK =
        VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT |
        VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT |
        VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT,

    VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VmaAllocationCreateFlagBits;
typedef VkFlags VmaAllocationCreateFlags;

typedef struct VmaAllocationCreateInfo
{
    /// Use #VmaAllocationCreateFlagBits enum.
    VmaAllocationCreateFlags flags;
    /** \brief Intended usage of memory.
    
    You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. \n
    If `pool` is not null, this member is ignored.
    */
    VmaMemoryUsage usage;
    /** \brief Flags that must be set in a Memory Type chosen for an allocation.
    
    Leave 0 if you specify memory requirements in other way. \n
    If `pool` is not null, this member is ignored.*/
    VkMemoryPropertyFlags requiredFlags;
    /** \brief Flags that preferably should be set in a memory type chosen for an allocation.
    
    Set to 0 if no additional flags are prefered. \n
    If `pool` is not null, this member is ignored. */
    VkMemoryPropertyFlags preferredFlags;
    /** \brief Bitmask containing one bit set for every memory type acceptable for this allocation.

    Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if
    it meets other requirements specified by this structure, with no further
    restrictions on memory type index. \n
    If `pool` is not null, this member is ignored.
    */
    uint32_t memoryTypeBits;
    /** \brief Pool that this allocation should be created in.

    Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:
    `usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored.
    */
    VmaPool pool;
    /** \brief Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData().
    
    If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either
    null or pointer to a null-terminated string. The string will be then copied to
    internal buffer, so it doesn't need to be valid after allocation call.
    */
    void* pUserData;
} VmaAllocationCreateInfo;

/**
\brief Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo.

This algorithm tries to find a memory type that:

- Is allowed by memoryTypeBits.
- Contains all the flags from pAllocationCreateInfo->requiredFlags.
- Matches intended usage.
- Has as many flags from pAllocationCreateInfo->preferredFlags as possible.

\return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result
from this function or any other allocating function probably means that your
device doesn't support any memory type with requested features for the specific
type of resource you want to use it for. Please check parameters of your
resource, like image layout (OPTIMAL versus LINEAR) or mip level count.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndex(
    VmaAllocator allocator,
    uint32_t memoryTypeBits,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    uint32_t* pMemoryTypeIndex);

/**
\brief Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.

It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
It internally creates a temporary, dummy buffer that never has memory bound.
It is just a convenience function, equivalent to calling:

- `vkCreateBuffer`
- `vkGetBufferMemoryRequirements`
- `vmaFindMemoryTypeIndex`
- `vkDestroyBuffer`
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForBufferInfo(
    VmaAllocator allocator,
    const VkBufferCreateInfo* pBufferCreateInfo,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    uint32_t* pMemoryTypeIndex);

/**
\brief Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.

It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.
It internally creates a temporary, dummy image that never has memory bound.
It is just a convenience function, equivalent to calling:

- `vkCreateImage`
- `vkGetImageMemoryRequirements`
- `vmaFindMemoryTypeIndex`
- `vkDestroyImage`
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForImageInfo(
    VmaAllocator allocator,
    const VkImageCreateInfo* pImageCreateInfo,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    uint32_t* pMemoryTypeIndex);

/// Flags to be passed as VmaPoolCreateInfo::flags.
typedef enum VmaPoolCreateFlagBits {
    /** \brief Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored.

    This is an optional optimization flag.

    If you always allocate using vmaCreateBuffer(), vmaCreateImage(),
    vmaAllocateMemoryForBuffer(), then you don't need to use it because allocator
    knows exact type of your allocations so it can handle Buffer-Image Granularity
    in the optimal way.

    If you also allocate using vmaAllocateMemoryForImage() or vmaAllocateMemory(),
    exact type of such allocations is not known, so allocator must be conservative
    in handling Buffer-Image Granularity, which can lead to suboptimal allocation
    (wasted memory). In that case, if you can make sure you always allocate only
    buffers and linear images or only optimal images out of this pool, use this flag
    to make allocator disregard Buffer-Image Granularity and so make allocations
    faster and more optimal.
    */
    VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT = 0x00000002,

    /** \brief Enables alternative, linear allocation algorithm in this pool.

    Specify this flag to enable linear allocation algorithm, which always creates
    new allocations after last one and doesn't reuse space from allocations freed in
    between. It trades memory consumption for simplified algorithm and data
    structure, which has better performance and uses less memory for metadata.

    By using this flag, you can achieve behavior of free-at-once, stack,
    ring buffer, and double stack. For details, see documentation chapter
    \ref linear_algorithm.

    When using this flag, you must specify VmaPoolCreateInfo::maxBlockCount == 1 (or 0 for default).

    For more details, see [Linear allocation algorithm](@ref linear_algorithm).
    */
    VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT = 0x00000004,

    /** \brief Enables alternative, buddy allocation algorithm in this pool.

    It operates on a tree of blocks, each having size that is a power of two and
    a half of its parent's size. Comparing to default algorithm, this one provides
    faster allocation and deallocation and decreased external fragmentation,
    at the expense of more memory wasted (internal fragmentation).

    For more details, see [Buddy allocation algorithm](@ref buddy_algorithm).
    */
    VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT = 0x00000008,

    /** Bit mask to extract only `ALGORITHM` bits from entire set of flags.
    */
    VMA_POOL_CREATE_ALGORITHM_MASK =
        VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT |
        VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT,

    VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VmaPoolCreateFlagBits;
typedef VkFlags VmaPoolCreateFlags;

/** \brief Describes parameter of created #VmaPool.
*/
typedef struct VmaPoolCreateInfo {
    /** \brief Vulkan memory type index to allocate this pool from.
    */
    uint32_t memoryTypeIndex;
    /** \brief Use combination of #VmaPoolCreateFlagBits.
    */
    VmaPoolCreateFlags flags;
    /** \brief Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in bytes. Optional.

    Specify nonzero to set explicit, constant size of memory blocks used by this
    pool.

    Leave 0 to use default and let the library manage block sizes automatically.
    Sizes of particular blocks may vary.
    */
    VkDeviceSize blockSize;
    /** \brief Minimum number of blocks to be always allocated in this pool, even if they stay empty.

    Set to 0 to have no preallocated blocks and allow the pool be completely empty.
    */
    size_t minBlockCount;
    /** \brief Maximum number of blocks that can be allocated in this pool. Optional.

    Set to 0 to use default, which is `SIZE_MAX`, which means no limit.
    
    Set to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated
    throughout whole lifetime of this pool.
    */
    size_t maxBlockCount;
    /** \brief Maximum number of additional frames that are in use at the same time as current frame.

    This value is used only when you make allocations with
    #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocation cannot become
    lost if allocation.lastUseFrameIndex >= allocator.currentFrameIndex - frameInUseCount.

    For example, if you double-buffer your command buffers, so resources used for
    rendering in previous frame may still be in use by the GPU at the moment you
    allocate resources needed for the current frame, set this value to 1.

    If you want to allow any allocations other than used in the current frame to
    become lost, set this value to 0.
    */
    uint32_t frameInUseCount;
} VmaPoolCreateInfo;

/** \brief Describes parameter of existing #VmaPool.
*/
typedef struct VmaPoolStats {
    /** \brief Total amount of `VkDeviceMemory` allocated from Vulkan for this pool, in bytes.
    */
    VkDeviceSize size;
    /** \brief Total number of bytes in the pool not used by any #VmaAllocation.
    */
    VkDeviceSize unusedSize;
    /** \brief Number of #VmaAllocation objects created from this pool that were not destroyed or lost.
    */
    size_t allocationCount;
    /** \brief Number of continuous memory ranges in the pool not used by any #VmaAllocation.
    */
    size_t unusedRangeCount;
    /** \brief Size of the largest continuous free memory region available for new allocation.

    Making a new allocation of that size is not guaranteed to succeed because of
    possible additional margin required to respect alignment and buffer/image
    granularity.
    */
    VkDeviceSize unusedRangeSizeMax;
    /** \brief Number of `VkDeviceMemory` blocks allocated for this pool.
    */
    size_t blockCount;
} VmaPoolStats;

/** \brief Allocates Vulkan device memory and creates #VmaPool object.

@param allocator Allocator object.
@param pCreateInfo Parameters of pool to create.
@param[out] pPool Handle to created pool.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreatePool(
	VmaAllocator allocator,
	const VmaPoolCreateInfo* pCreateInfo,
	VmaPool* pPool);

/** \brief Destroys #VmaPool object and frees Vulkan device memory.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaDestroyPool(
    VmaAllocator allocator,
    VmaPool pool);

/** \brief Retrieves statistics of existing #VmaPool object.

@param allocator Allocator object.
@param pool Pool object.
@param[out] pPoolStats Statistics of specified pool.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolStats(
    VmaAllocator allocator,
    VmaPool pool,
    VmaPoolStats* pPoolStats);

/** \brief Marks all allocations in given pool as lost if they are not used in current frame or VmaPoolCreateInfo::frameInUseCount back from now.

@param allocator Allocator object.
@param pool Pool.
@param[out] pLostAllocationCount Number of allocations marked as lost. Optional - pass null if you don't need this information.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaMakePoolAllocationsLost(
    VmaAllocator allocator,
    VmaPool pool,
    size_t* pLostAllocationCount);

/** \brief Checks magic number in margins around all allocations in given memory pool in search for corruptions.

Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,
`VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is
`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection).

Possible return values:

- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.
- `VK_SUCCESS` - corruption detection has been performed and succeeded.
- `VK_ERROR_VALIDATION_FAILED_EXT` - corruption detection has been performed and found memory corruptions around one of the allocations.
  `VMA_ASSERT` is also fired in that case.
- Other value: Error returned by Vulkan, e.g. memory mapping failure.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckPoolCorruption(VmaAllocator allocator, VmaPool pool);

/** \brief Retrieves name of a custom pool.

After the call `ppName` is either null or points to an internally-owned null-terminated string
containing name of the pool that was previously set. The pointer becomes invalid when the pool is
destroyed or its name is changed using vmaSetPoolName().
*/
VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolName(
    VmaAllocator allocator,
    VmaPool pool,
    const char** ppName);

/** \brief Sets name of a custom pool.

`pName` can be either null or pointer to a null-terminated string with new name for the pool.
Function makes internal copy of the string, so it can be changed or freed immediately after this call.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaSetPoolName(
    VmaAllocator allocator,
    VmaPool pool,
    const char* pName);

/** \struct VmaAllocation
\brief Represents single memory allocation.

It may be either dedicated block of `VkDeviceMemory` or a specific region of a bigger block of this type
plus unique offset.

There are multiple ways to create such object.
You need to fill structure VmaAllocationCreateInfo.
For more information see [Choosing memory type](@ref choosing_memory_type).

Although the library provides convenience functions that create Vulkan buffer or image,
allocate memory for it and bind them together,
binding of the allocation to a buffer or an image is out of scope of the allocation itself.
Allocation object can exist without buffer/image bound,
binding can be done manually by the user, and destruction of it can be done
independently of destruction of the allocation.

The object also remembers its size and some other information.
To retrieve this information, use function vmaGetAllocationInfo() and inspect
returned structure VmaAllocationInfo.

Some kinds allocations can be in lost state.
For more information, see [Lost allocations](@ref lost_allocations).
*/
VK_DEFINE_HANDLE(VmaAllocation)

/** \brief Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().
*/
typedef struct VmaAllocationInfo {
    /** \brief Memory type index that this allocation was allocated from.
    
    It never changes.
    */
    uint32_t memoryType;
    /** \brief Handle to Vulkan memory object.

    Same memory object can be shared by multiple allocations.
    
    It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost.

    If the allocation is lost, it is equal to `VK_NULL_HANDLE`.
    */
    VkDeviceMemory deviceMemory;
    /** \brief Offset into deviceMemory object to the beginning of this allocation, in bytes. (deviceMemory, offset) pair is unique to this allocation.

    It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost.
    */
    VkDeviceSize offset;
    /** \brief Size of this allocation, in bytes.

    It never changes, unless allocation is lost.
    */
    VkDeviceSize size;
    /** \brief Pointer to the beginning of this allocation as mapped data.

    If the allocation hasn't been mapped using vmaMapMemory() and hasn't been
    created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value null.

    It can change after call to vmaMapMemory(), vmaUnmapMemory().
    It can also change after call to vmaDefragment() if this allocation is passed to the function.
    */
    void* pMappedData;
    /** \brief Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vmaSetAllocationUserData().

    It can change after call to vmaSetAllocationUserData() for this allocation.
    */
    void* pUserData;
} VmaAllocationInfo;

/** \brief General purpose memory allocation.

@param[out] pAllocation Handle to allocated memory.
@param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().

You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().

It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),
vmaCreateBuffer(), vmaCreateImage() instead whenever possible.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemory(
    VmaAllocator allocator,
    const VkMemoryRequirements* pVkMemoryRequirements,
    const VmaAllocationCreateInfo* pCreateInfo,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo);

/** \brief General purpose memory allocation for multiple allocation objects at once.

@param allocator Allocator object.
@param pVkMemoryRequirements Memory requirements for each allocation.
@param pCreateInfo Creation parameters for each alloction.
@param allocationCount Number of allocations to make.
@param[out] pAllocations Pointer to array that will be filled with handles to created allocations.
@param[out] pAllocationInfo Optional. Pointer to array that will be filled with parameters of created allocations.

You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().

Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.
It is just a general purpose allocation function able to make multiple allocations at once.
It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.

All allocations are made using same parameters. All of them are created out of the same memory pool and type.
If any allocation fails, all allocations already made within this function call are also freed, so that when
returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryPages(
    VmaAllocator allocator,
    const VkMemoryRequirements* pVkMemoryRequirements,
    const VmaAllocationCreateInfo* pCreateInfo,
    size_t allocationCount,
    VmaAllocation* pAllocations,
    VmaAllocationInfo* pAllocationInfo);

/**
@param[out] pAllocation Handle to allocated memory.
@param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().

You should free the memory using vmaFreeMemory().
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForBuffer(
    VmaAllocator allocator,
    VkBuffer buffer,
    const VmaAllocationCreateInfo* pCreateInfo,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo);

/// Function similar to vmaAllocateMemoryForBuffer().
VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForImage(
    VmaAllocator allocator,
    VkImage image,
    const VmaAllocationCreateInfo* pCreateInfo,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo);

/** \brief Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage().

Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemory(
    VmaAllocator allocator,
    VmaAllocation allocation);

/** \brief Frees memory and destroys multiple allocations.

Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.
It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),
vmaAllocateMemoryPages() and other functions.
It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.

Allocations in `pAllocations` array can come from any memory pools and types.
Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemoryPages(
    VmaAllocator allocator,
    size_t allocationCount,
    VmaAllocation* pAllocations);

/** \brief Deprecated.

In version 2.2.0 it used to try to change allocation's size without moving or reallocating it.
In current version it returns `VK_SUCCESS` only if `newSize` equals current allocation's size.
Otherwise returns `VK_ERROR_OUT_OF_POOL_MEMORY`, indicating that allocation's size could not be changed.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaResizeAllocation(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkDeviceSize newSize);

/** \brief Returns current information about specified allocation and atomically marks it as used in current frame.

Current paramters of given allocation are returned in `pAllocationInfo`.

This function also atomically "touches" allocation - marks it as used in current frame,
just like vmaTouchAllocation().
If the allocation is in lost state, `pAllocationInfo->deviceMemory == VK_NULL_HANDLE`.

Although this function uses atomics and doesn't lock any mutex, so it should be quite efficient,
you can avoid calling it too often.

- You can retrieve same VmaAllocationInfo structure while creating your resource, from function
  vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change
  (e.g. due to defragmentation or allocation becoming lost).
- If you just want to check if allocation is not lost, vmaTouchAllocation() will work faster.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationInfo(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VmaAllocationInfo* pAllocationInfo);

/** \brief Returns `VK_TRUE` if allocation is not lost and atomically marks it as used in current frame.

If the allocation has been created with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag,
this function returns `VK_TRUE` if it's not in lost state, so it can still be used.
It then also atomically "touches" the allocation - marks it as used in current frame,
so that you can be sure it won't become lost in current frame or next `frameInUseCount` frames.

If the allocation is in lost state, the function returns `VK_FALSE`.
Memory of such allocation, as well as buffer or image bound to it, should not be used.
Lost allocation and the buffer/image still need to be destroyed.

If the allocation has been created without #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag,
this function always returns `VK_TRUE`.
*/
VMA_CALL_PRE VkBool32 VMA_CALL_POST vmaTouchAllocation(
    VmaAllocator allocator,
    VmaAllocation allocation);

/** \brief Sets pUserData in given allocation to new value.

If the allocation was created with VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT,
pUserData must be either null, or pointer to a null-terminated string. The function
makes local copy of the string and sets it as allocation's `pUserData`. String
passed as pUserData doesn't need to be valid for whole lifetime of the allocation -
you can free it after this call. String previously pointed by allocation's
pUserData is freed from memory.

If the flag was not used, the value of pointer `pUserData` is just copied to
allocation's `pUserData`. It is opaque, so you can use it however you want - e.g.
as a pointer, ordinal number or some handle to you own data.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationUserData(
    VmaAllocator allocator,
    VmaAllocation allocation,
    void* pUserData);

/** \brief Creates new allocation that is in lost state from the beginning.

It can be useful if you need a dummy, non-null allocation.

You still need to destroy created object using vmaFreeMemory().

Returned allocation is not tied to any specific memory pool or memory type and
not bound to any image or buffer. It has size = 0. It cannot be turned into
a real, non-empty allocation.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaCreateLostAllocation(
    VmaAllocator allocator,
    VmaAllocation* pAllocation);

/** \brief Maps memory represented by given allocation and returns pointer to it.

Maps memory represented by given allocation to make it accessible to CPU code.
When succeeded, `*ppData` contains pointer to first byte of this memory.
If the allocation is part of bigger `VkDeviceMemory` block, the pointer is
correctly offseted to the beginning of region assigned to this particular
allocation.

Mapping is internally reference-counted and synchronized, so despite raw Vulkan
function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`
multiple times simultaneously, it is safe to call this function on allocations
assigned to the same memory block. Actual Vulkan memory will be mapped on first
mapping and unmapped on last unmapping.

If the function succeeded, you must call vmaUnmapMemory() to unmap the
allocation when mapping is no longer needed or before freeing the allocation, at
the latest.

It also safe to call this function multiple times on the same allocation. You
must call vmaUnmapMemory() same number of times as you called vmaMapMemory().

It is also safe to call this function on allocation created with
#VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.
You must still call vmaUnmapMemory() same number of times as you called
vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the
"0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.

This function fails when used on allocation made in memory type that is not
`HOST_VISIBLE`.

This function always fails when called for allocation that was created with
#VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocations cannot be
mapped.

This function doesn't automatically flush or invalidate caches.
If the allocation is made from a memory types that is not `HOST_COHERENT`,
you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaMapMemory(
    VmaAllocator allocator,
    VmaAllocation allocation,
    void** ppData);

/** \brief Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().

For details, see description of vmaMapMemory().

This function doesn't automatically flush or invalidate caches.
If the allocation is made from a memory types that is not `HOST_COHERENT`,
you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaUnmapMemory(
    VmaAllocator allocator,
    VmaAllocation allocation);

/** \brief Flushes memory of given allocation.

Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation.
It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`.
Unmap operation doesn't do that automatically.

- `offset` must be relative to the beginning of allocation.
- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.
- `offset` and `size` don't have to be aligned.
  They are internally rounded down/up to multiply of `nonCoherentAtomSize`.
- If `size` is 0, this call is ignored.
- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,
  this call is ignored.

Warning! `offset` and `size` are relative to the contents of given `allocation`.
If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.
Do not pass allocation's offset as `offset`!!!
*/
VMA_CALL_PRE void VMA_CALL_POST vmaFlushAllocation(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size);

/** \brief Invalidates memory of given allocation.

Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation.
It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`.
Map operation doesn't do that automatically.

- `offset` must be relative to the beginning of allocation.
- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.
- `offset` and `size` don't have to be aligned.
  They are internally rounded down/up to multiply of `nonCoherentAtomSize`.
- If `size` is 0, this call is ignored.
- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,
  this call is ignored.

Warning! `offset` and `size` are relative to the contents of given `allocation`.
If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.
Do not pass allocation's offset as `offset`!!!
*/
VMA_CALL_PRE void VMA_CALL_POST vmaInvalidateAllocation(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size);

/** \brief Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.

@param memoryTypeBits Bit mask, where each bit set means that a memory type with that index should be checked.

Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,
`VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are
`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection).

Possible return values:

- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.
- `VK_SUCCESS` - corruption detection has been performed and succeeded.
- `VK_ERROR_VALIDATION_FAILED_EXT` - corruption detection has been performed and found memory corruptions around one of the allocations.
  `VMA_ASSERT` is also fired in that case.
- Other value: Error returned by Vulkan, e.g. memory mapping failure.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckCorruption(VmaAllocator allocator, uint32_t memoryTypeBits);

/** \struct VmaDefragmentationContext
\brief Represents Opaque object that represents started defragmentation process.

Fill structure #VmaDefragmentationInfo2 and call function vmaDefragmentationBegin() to create it.
Call function vmaDefragmentationEnd() to destroy it.
*/
VK_DEFINE_HANDLE(VmaDefragmentationContext)

/// Flags to be used in vmaDefragmentationBegin(). None at the moment. Reserved for future use.
typedef enum VmaDefragmentationFlagBits {
    VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VmaDefragmentationFlagBits;
typedef VkFlags VmaDefragmentationFlags;

/** \brief Parameters for defragmentation.

To be used with function vmaDefragmentationBegin().
*/
typedef struct VmaDefragmentationInfo2 {
    /** \brief Reserved for future use. Should be 0.
    */
    VmaDefragmentationFlags flags;
    /** \brief Number of allocations in `pAllocations` array.
    */
    uint32_t allocationCount;
    /** \brief Pointer to array of allocations that can be defragmented.

    The array should have `allocationCount` elements.
    The array should not contain nulls.
    Elements in the array should be unique - same allocation cannot occur twice.
    It is safe to pass allocations that are in the lost state - they are ignored.
    All allocations not present in this array are considered non-moveable during this defragmentation.
    */
    VmaAllocation* pAllocations;
    /** \brief Optional, output. Pointer to array that will be filled with information whether the allocation at certain index has been changed during defragmentation.

    The array should have `allocationCount` elements.
    You can pass null if you are not interested in this information.
    */
    VkBool32* pAllocationsChanged;
    /** \brief Numer of pools in `pPools` array.
    */
    uint32_t poolCount;
    /** \brief Either null or pointer to array of pools to be defragmented.

    All the allocations in the specified pools can be moved during defragmentation
    and there is no way to check if they were really moved as in `pAllocationsChanged`,
    so you must query all the allocations in all these pools for new `VkDeviceMemory`
    and offset using vmaGetAllocationInfo() if you might need to recreate buffers
    and images bound to them.

    The array should have `poolCount` elements.
    The array should not contain nulls.
    Elements in the array should be unique - same pool cannot occur twice.

    Using this array is equivalent to specifying all allocations from the pools in `pAllocations`.
    It might be more efficient.
    */
    VmaPool* pPools;
    /** \brief Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on CPU side, like `memcpy()`, `memmove()`.
    
    `VK_WHOLE_SIZE` means no limit.
    */
    VkDeviceSize maxCpuBytesToMove;
    /** \brief Maximum number of allocations that can be moved to a different place using transfers on CPU side, like `memcpy()`, `memmove()`.

    `UINT32_MAX` means no limit.
    */
    uint32_t maxCpuAllocationsToMove;
    /** \brief Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on GPU side, posted to `commandBuffer`.
    
    `VK_WHOLE_SIZE` means no limit.
    */
    VkDeviceSize maxGpuBytesToMove;
    /** \brief Maximum number of allocations that can be moved to a different place using transfers on GPU side, posted to `commandBuffer`.

    `UINT32_MAX` means no limit.
    */
    uint32_t maxGpuAllocationsToMove;
    /** \brief Optional. Command buffer where GPU copy commands will be posted.

    If not null, it must be a valid command buffer handle that supports Transfer queue type.
    It must be in the recording state and outside of a render pass instance.
    You need to submit it and make sure it finished execution before calling vmaDefragmentationEnd().

    Passing null means that only CPU defragmentation will be performed.
    */
    VkCommandBuffer commandBuffer;
} VmaDefragmentationInfo2;

/** \brief Deprecated. Optional configuration parameters to be passed to function vmaDefragment().

\deprecated This is a part of the old interface. It is recommended to use structure #VmaDefragmentationInfo2 and function vmaDefragmentationBegin() instead.
*/
typedef struct VmaDefragmentationInfo {
    /** \brief Maximum total numbers of bytes that can be copied while moving allocations to different places.
    
    Default is `VK_WHOLE_SIZE`, which means no limit.
    */
    VkDeviceSize maxBytesToMove;
    /** \brief Maximum number of allocations that can be moved to different place.

    Default is `UINT32_MAX`, which means no limit.
    */
    uint32_t maxAllocationsToMove;
} VmaDefragmentationInfo;

/** \brief Statistics returned by function vmaDefragment(). */
typedef struct VmaDefragmentationStats {
    /// Total number of bytes that have been copied while moving allocations to different places.
    VkDeviceSize bytesMoved;
    /// Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects.
    VkDeviceSize bytesFreed;
    /// Number of allocations that have been moved to different places.
    uint32_t allocationsMoved;
    /// Number of empty `VkDeviceMemory` objects that have been released to the system.
    uint32_t deviceMemoryBlocksFreed;
} VmaDefragmentationStats;

/** \brief Begins defragmentation process.

@param allocator Allocator object.
@param pInfo Structure filled with parameters of defragmentation.
@param[out] pStats Optional. Statistics of defragmentation. You can pass null if you are not interested in this information.
@param[out] pContext Context object that must be passed to vmaDefragmentationEnd() to finish defragmentation.
@return `VK_SUCCESS` and `*pContext == null` if defragmentation finished within this function call. `VK_NOT_READY` and `*pContext != null` if defragmentation has been started and you need to call vmaDefragmentationEnd() to finish it. Negative value in case of error.

Use this function instead of old, deprecated vmaDefragment().

Warning! Between the call to vmaDefragmentationBegin() and vmaDefragmentationEnd():

- You should not use any of allocations passed as `pInfo->pAllocations` or
  any allocations that belong to pools passed as `pInfo->pPools`,
  including calling vmaGetAllocationInfo(), vmaTouchAllocation(), or access
  their data.
- Some mutexes protecting internal data structures may be locked, so trying to
  make or free any allocations, bind buffers or images, map memory, or launch
  another simultaneous defragmentation in between may cause stall (when done on
  another thread) or deadlock (when done on the same thread), unless you are
  100% sure that defragmented allocations are in different pools.
- Information returned via `pStats` and `pInfo->pAllocationsChanged` are undefined.
  They become valid after call to vmaDefragmentationEnd().
- If `pInfo->commandBuffer` is not null, you must submit that command buffer
  and make sure it finished execution before calling vmaDefragmentationEnd().

For more information and important limitations regarding defragmentation, see documentation chapter:
[Defragmentation](@ref defragmentation).
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragmentationBegin(
    VmaAllocator allocator,
    const VmaDefragmentationInfo2* pInfo,
    VmaDefragmentationStats* pStats,
    VmaDefragmentationContext *pContext);

/** \brief Ends defragmentation process.

Use this function to finish defragmentation started by vmaDefragmentationBegin().
It is safe to pass `context == null`. The function then does nothing.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragmentationEnd(
    VmaAllocator allocator,
    VmaDefragmentationContext context);

/** \brief Deprecated. Compacts memory by moving allocations.

@param pAllocations Array of allocations that can be moved during this compation.
@param allocationCount Number of elements in pAllocations and pAllocationsChanged arrays.
@param[out] pAllocationsChanged Array of boolean values that will indicate whether matching allocation in pAllocations array has been moved. This parameter is optional. Pass null if you don't need this information.
@param pDefragmentationInfo Configuration parameters. Optional - pass null to use default values.
@param[out] pDefragmentationStats Statistics returned by the function. Optional - pass null if you don't need this information.
@return `VK_SUCCESS` if completed, negative error code in case of error.

\deprecated This is a part of the old interface. It is recommended to use structure #VmaDefragmentationInfo2 and function vmaDefragmentationBegin() instead.

This function works by moving allocations to different places (different
`VkDeviceMemory` objects and/or different offsets) in order to optimize memory
usage. Only allocations that are in `pAllocations` array can be moved. All other
allocations are considered nonmovable in this call. Basic rules:

- Only allocations made in memory types that have
  `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`
  flags can be compacted. You may pass other allocations but it makes no sense -
  these will never be moved.
- Custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT or
  #VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT flag are not defragmented. Allocations
  passed to this function that come from such pools are ignored.
- Allocations created with #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT or
  created as dedicated allocations for any other reason are also ignored.
- Both allocations made with or without #VMA_ALLOCATION_CREATE_MAPPED_BIT
  flag can be compacted. If not persistently mapped, memory will be mapped
  temporarily inside this function if needed.
- You must not pass same #VmaAllocation object multiple times in `pAllocations` array.

The function also frees empty `VkDeviceMemory` blocks.

Warning: This function may be time-consuming, so you shouldn't call it too often
(like after every resource creation/destruction).
You can call it on special occasions (like when reloading a game level or
when you just destroyed a lot of objects). Calling it every frame may be OK, but
you should measure that on your platform.

For more information, see [Defragmentation](@ref defragmentation) chapter.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragment(
    VmaAllocator allocator,
    VmaAllocation* pAllocations,
    size_t allocationCount,
    VkBool32* pAllocationsChanged,
    const VmaDefragmentationInfo *pDefragmentationInfo,
    VmaDefragmentationStats* pDefragmentationStats);

/** \brief Binds buffer to allocation.

Binds specified buffer to region of memory represented by specified allocation.
Gets `VkDeviceMemory` handle and offset from the allocation.
If you want to create a buffer, allocate memory for it and bind them together separately,
you should use this function for binding instead of standard `vkBindBufferMemory()`,
because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple
allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously
(which is illegal in Vulkan).

It is recommended to use function vmaCreateBuffer() instead of this one.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkBuffer buffer);

/** \brief Binds buffer to allocation with additional parameters.

@param allocationLocalOffset Additional offset to be added while binding, relative to the beginnig of the `allocation`. Normally it should be 0.
@param pNext A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure used internally. Normally it should be null.

This function is similar to vmaBindBufferMemory(), but it provides additional parameters.

If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag
or with VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_1`. Otherwise the call fails.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory2(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkDeviceSize allocationLocalOffset,
    VkBuffer buffer,
    const void* pNext);

/** \brief Binds image to allocation.

Binds specified image to region of memory represented by specified allocation.
Gets `VkDeviceMemory` handle and offset from the allocation.
If you want to create an image, allocate memory for it and bind them together separately,
you should use this function for binding instead of standard `vkBindImageMemory()`,
because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple
allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously
(which is illegal in Vulkan).

It is recommended to use function vmaCreateImage() instead of this one.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkImage image);

/** \brief Binds image to allocation with additional parameters.

@param allocationLocalOffset Additional offset to be added while binding, relative to the beginnig of the `allocation`. Normally it should be 0.
@param pNext A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure used internally. Normally it should be null.

This function is similar to vmaBindImageMemory(), but it provides additional parameters.

If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag
or with VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_1`. Otherwise the call fails.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory2(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkDeviceSize allocationLocalOffset,
    VkImage image,
    const void* pNext);

/**
@param[out] pBuffer Buffer that was created.
@param[out] pAllocation Allocation that was created.
@param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo().

This function automatically:

-# Creates buffer.
-# Allocates appropriate memory for it.
-# Binds the buffer with the memory.

If any of these operations fail, buffer and allocation are not created,
returned value is negative error code, *pBuffer and *pAllocation are null.

If the function succeeded, you must destroy both buffer and allocation when you
no longer need them using either convenience function vmaDestroyBuffer() or
separately, using `vkDestroyBuffer()` and vmaFreeMemory().

If VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,
VK_KHR_dedicated_allocation extension is used internally to query driver whether
it requires or prefers the new buffer to have dedicated allocation. If yes,
and if dedicated allocation is possible (VmaAllocationCreateInfo::pool is null
and VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated
allocation for this buffer, just like when using
VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBuffer(
    VmaAllocator allocator,
    const VkBufferCreateInfo* pBufferCreateInfo,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    VkBuffer* pBuffer,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo);

/** \brief Destroys Vulkan buffer and frees allocated memory.

This is just a convenience function equivalent to:

\code
vkDestroyBuffer(device, buffer, allocationCallbacks);
vmaFreeMemory(allocator, allocation);
\endcode

It it safe to pass null as buffer and/or allocation.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaDestroyBuffer(
    VmaAllocator allocator,
    VkBuffer buffer,
    VmaAllocation allocation);

/// Function similar to vmaCreateBuffer().
VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateImage(
    VmaAllocator allocator,
    const VkImageCreateInfo* pImageCreateInfo,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    VkImage* pImage,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo);

/** \brief Destroys Vulkan image and frees allocated memory.

This is just a convenience function equivalent to:

\code
vkDestroyImage(device, image, allocationCallbacks);
vmaFreeMemory(allocator, allocation);
\endcode

It it safe to pass null as image and/or allocation.
*/
VMA_CALL_PRE void VMA_CALL_POST vmaDestroyImage(
    VmaAllocator allocator,
    VkImage image,
    VmaAllocation allocation);

#ifdef __cplusplus
}
#endif

#endif // AMD_VULKAN_MEMORY_ALLOCATOR_H

// For Visual Studio IntelliSense.
#if defined(__cplusplus) && defined(__INTELLISENSE__)
#define VMA_IMPLEMENTATION
#endif

#ifdef VMA_IMPLEMENTATION
#undef VMA_IMPLEMENTATION

#include <cstdint>
#include <cstdlib>
#include <cstring>

/*******************************************************************************
CONFIGURATION SECTION

Define some of these macros before each #include of this header or change them
here if you need other then default behavior depending on your environment.
*/

/*
Define this macro to 1 to make the library fetch pointers to Vulkan functions
internally, like:

    vulkanFunctions.vkAllocateMemory = &vkAllocateMemory;

Define to 0 if you are going to provide you own pointers to Vulkan functions via
VmaAllocatorCreateInfo::pVulkanFunctions.
*/
#if !defined(VMA_STATIC_VULKAN_FUNCTIONS) && !defined(VK_NO_PROTOTYPES)
#define VMA_STATIC_VULKAN_FUNCTIONS 1
#endif

// Define this macro to 1 to make the library use STL containers instead of its own implementation.
//#define VMA_USE_STL_CONTAINERS 1

/* Set this macro to 1 to make the library including and using STL containers:
std::pair, std::vector, std::list, std::unordered_map.

Set it to 0 or undefined to make the library using its own implementation of
the containers.
*/
#if VMA_USE_STL_CONTAINERS
   #define VMA_USE_STL_VECTOR 1
   #define VMA_USE_STL_UNORDERED_MAP 1
   #define VMA_USE_STL_LIST 1
#endif

#ifndef VMA_USE_STL_SHARED_MUTEX
    // Compiler conforms to C++17.
    #if __cplusplus >= 201703L
        #define VMA_USE_STL_SHARED_MUTEX 1
    // Visual studio defines __cplusplus properly only when passed additional parameter: /Zc:__cplusplus
    // Otherwise it's always 199711L, despite shared_mutex works since Visual Studio 2015 Update 2.
    // See: https://blogs.msdn.microsoft.com/vcblog/2018/04/09/msvc-now-correctly-reports-__cplusplus/
    #elif defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 190023918 && __cplusplus == 199711L && _MSVC_LANG >= 201703L
        #define VMA_USE_STL_SHARED_MUTEX 1
    #else
        #define VMA_USE_STL_SHARED_MUTEX 0
    #endif
#endif

/*
THESE INCLUDES ARE NOT ENABLED BY DEFAULT.
Library has its own container implementation.
*/
#if VMA_USE_STL_VECTOR
   #include <vector>
#endif

#if VMA_USE_STL_UNORDERED_MAP
   #include <unordered_map>
#endif

#if VMA_USE_STL_LIST
   #include <list>
#endif

/*
Following headers are used in this CONFIGURATION section only, so feel free to
remove them if not needed.
*/
#include <cassert> // for assert
#include <algorithm> // for min, max
#include <mutex>

#ifndef VMA_NULL
   // Value used as null pointer. Define it to e.g.: nullptr, NULL, 0, (void*)0.
   #define VMA_NULL   nullptr
#endif

#if defined(__ANDROID_API__) && (__ANDROID_API__ < 16)
#include <cstdlib>
void *aligned_alloc(size_t alignment, size_t size)
{
    // alignment must be >= sizeof(void*)
    if(alignment < sizeof(void*))
    {
        alignment = sizeof(void*);
    }

    return memalign(alignment, size);
}
#elif defined(__APPLE__) || defined(__ANDROID__) || (defined(__linux__) && defined(__GLIBCXX__) && !defined(_GLIBCXX_HAVE_ALIGNED_ALLOC))
#include <cstdlib>
void *aligned_alloc(size_t alignment, size_t size)
{
    // alignment must be >= sizeof(void*)
    if(alignment < sizeof(void*))
    {
        alignment = sizeof(void*);
    }

    void *pointer;
    if(posix_memalign(&pointer, alignment, size) == 0)
        return pointer;
    return VMA_NULL;
}
#endif

// If your compiler is not compatible with C++11 and definition of
// aligned_alloc() function is missing, uncommeting following line may help:

//#include <malloc.h>

// Normal assert to check for programmer's errors, especially in Debug configuration.
#ifndef VMA_ASSERT
   #ifdef _DEBUG
       #define VMA_ASSERT(expr)         assert(expr)
   #else
       #define VMA_ASSERT(expr)
   #endif
#endif

// Assert that will be called very often, like inside data structures e.g. operator[].
// Making it non-empty can make program slow.
#ifndef VMA_HEAVY_ASSERT
   #ifdef _DEBUG
       #define VMA_HEAVY_ASSERT(expr)   //VMA_ASSERT(expr)
   #else
       #define VMA_HEAVY_ASSERT(expr)
   #endif
#endif

#ifndef VMA_ALIGN_OF
   #define VMA_ALIGN_OF(type)       (__alignof(type))
#endif

#ifndef VMA_SYSTEM_ALIGNED_MALLOC
   #if defined(_WIN32)
       #define VMA_SYSTEM_ALIGNED_MALLOC(size, alignment)   (_aligned_malloc((size), (alignment)))
   #else
       #define VMA_SYSTEM_ALIGNED_MALLOC(size, alignment)   (aligned_alloc((alignment), (size) ))
   #endif
#endif

#ifndef VMA_SYSTEM_FREE
   #if defined(_WIN32)
       #define VMA_SYSTEM_FREE(ptr)   _aligned_free(ptr)
   #else
       #define VMA_SYSTEM_FREE(ptr)   free(ptr)
   #endif
#endif

#ifndef VMA_MIN
   #define VMA_MIN(v1, v2)    (std::min((v1), (v2)))
#endif

#ifndef VMA_MAX
   #define VMA_MAX(v1, v2)    (std::max((v1), (v2)))
#endif

#ifndef VMA_SWAP
   #define VMA_SWAP(v1, v2)   std::swap((v1), (v2))
#endif

#ifndef VMA_SORT
   #define VMA_SORT(beg, end, cmp)  std::sort(beg, end, cmp)
#endif

#ifndef VMA_DEBUG_LOG
   #define VMA_DEBUG_LOG(format, ...)
   /*
   #define VMA_DEBUG_LOG(format, ...) do { \
       printf(format, __VA_ARGS__); \
       printf("\n"); \
   } while(false)
   */
#endif

// Define this macro to 1 to enable functions: vmaBuildStatsString, vmaFreeStatsString.
#if VMA_STATS_STRING_ENABLED
    static inline void VmaUint32ToStr(char* outStr, size_t strLen, uint32_t num)
    {
        snprintf(outStr, strLen, "%u", static_cast<unsigned int>(num));
    }
    static inline void VmaUint64ToStr(char* outStr, size_t strLen, uint64_t num)
    {
        snprintf(outStr, strLen, "%llu", static_cast<unsigned long long>(num));
    }
    static inline void VmaPtrToStr(char* outStr, size_t strLen, const void* ptr)
    {
        snprintf(outStr, strLen, "%p", ptr);
    }
#endif

#ifndef VMA_MUTEX
    class VmaMutex
    {
    public:
        void Lock() { m_Mutex.lock(); }
        void Unlock() { m_Mutex.unlock(); }
    private:
        std::mutex m_Mutex;
    };
    #define VMA_MUTEX VmaMutex
#endif

// Read-write mutex, where "read" is shared access, "write" is exclusive access.
#ifndef VMA_RW_MUTEX
    #if VMA_USE_STL_SHARED_MUTEX
        // Use std::shared_mutex from C++17.
        #include <shared_mutex>
        class VmaRWMutex
        {
        public:
            void LockRead() { m_Mutex.lock_shared(); }
            void UnlockRead() { m_Mutex.unlock_shared(); }
            void LockWrite() { m_Mutex.lock(); }
            void UnlockWrite() { m_Mutex.unlock(); }
        private:
            std::shared_mutex m_Mutex;
        };
        #define VMA_RW_MUTEX VmaRWMutex
    #elif defined(_WIN32) && defined(WINVER) && WINVER >= 0x0600
        // Use SRWLOCK from WinAPI.
        // Minimum supported client = Windows Vista, server = Windows Server 2008.
        class VmaRWMutex
        {
        public:
            VmaRWMutex() { InitializeSRWLock(&m_Lock); }
            void LockRead() { AcquireSRWLockShared(&m_Lock); }
            void UnlockRead() { ReleaseSRWLockShared(&m_Lock); }
            void LockWrite() { AcquireSRWLockExclusive(&m_Lock); }
            void UnlockWrite() { ReleaseSRWLockExclusive(&m_Lock); }
        private:
            SRWLOCK m_Lock;
        };
        #define VMA_RW_MUTEX VmaRWMutex
    #else
        // Less efficient fallback: Use normal mutex.
        class VmaRWMutex
        {
        public:
            void LockRead() { m_Mutex.Lock(); }
            void UnlockRead() { m_Mutex.Unlock(); }
            void LockWrite() { m_Mutex.Lock(); }
            void UnlockWrite() { m_Mutex.Unlock(); }
        private:
            VMA_MUTEX m_Mutex;
        };
        #define VMA_RW_MUTEX VmaRWMutex
    #endif // #if VMA_USE_STL_SHARED_MUTEX
#endif // #ifndef VMA_RW_MUTEX

/*
If providing your own implementation, you need to implement a subset of std::atomic.
*/
#ifndef VMA_ATOMIC_UINT32
    #include <atomic>
    #define VMA_ATOMIC_UINT32 std::atomic<uint32_t>
#endif

#ifndef VMA_ATOMIC_UINT64
    #include <atomic>
    #define VMA_ATOMIC_UINT64 std::atomic<uint64_t>
#endif

#ifndef VMA_DEBUG_ALWAYS_DEDICATED_MEMORY
    /**
    Every allocation will have its own memory block.
    Define to 1 for debugging purposes only.
    */
    #define VMA_DEBUG_ALWAYS_DEDICATED_MEMORY (0)
#endif

#ifndef VMA_DEBUG_ALIGNMENT
    /**
    Minimum alignment of all allocations, in bytes.
    Set to more than 1 for debugging purposes only. Must be power of two.
    */
    #define VMA_DEBUG_ALIGNMENT (1)
#endif

#ifndef VMA_DEBUG_MARGIN
    /**
    Minimum margin before and after every allocation, in bytes.
    Set nonzero for debugging purposes only.
    */
    #define VMA_DEBUG_MARGIN (0)
#endif

#ifndef VMA_DEBUG_INITIALIZE_ALLOCATIONS
    /**
    Define this macro to 1 to automatically fill new allocations and destroyed
    allocations with some bit pattern.
    */
    #define VMA_DEBUG_INITIALIZE_ALLOCATIONS (0)
#endif

#ifndef VMA_DEBUG_DETECT_CORRUPTION
    /**
    Define this macro to 1 together with non-zero value of VMA_DEBUG_MARGIN to
    enable writing magic value to the margin before and after every allocation and
    validating it, so that memory corruptions (out-of-bounds writes) are detected.
    */
    #define VMA_DEBUG_DETECT_CORRUPTION (0)
#endif

#ifndef VMA_DEBUG_GLOBAL_MUTEX
    /**
    Set this to 1 for debugging purposes only, to enable single mutex protecting all
    entry calls to the library. Can be useful for debugging multithreading issues.
    */
    #define VMA_DEBUG_GLOBAL_MUTEX (0)
#endif

#ifndef VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY
    /**
    Minimum value for VkPhysicalDeviceLimits::bufferImageGranularity.
    Set to more than 1 for debugging purposes only. Must be power of two.
    */
    #define VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY (1)
#endif

#ifndef VMA_SMALL_HEAP_MAX_SIZE
   /// Maximum size of a memory heap in Vulkan to consider it "small".
   #define VMA_SMALL_HEAP_MAX_SIZE (1024ull * 1024 * 1024)
#endif

#ifndef VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE
   /// Default size of a block allocated as single VkDeviceMemory from a "large" heap.
   #define VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE (256ull * 1024 * 1024)
#endif

#ifndef VMA_CLASS_NO_COPY
    #define VMA_CLASS_NO_COPY(className) \
        private: \
            className(const className&) = delete; \
            className& operator=(const className&) = delete;
#endif

static const uint32_t VMA_FRAME_INDEX_LOST = UINT32_MAX;

// Decimal 2139416166, float NaN, little-endian binary 66 E6 84 7F.
static const uint32_t VMA_CORRUPTION_DETECTION_MAGIC_VALUE = 0x7F84E666;

static const uint8_t VMA_ALLOCATION_FILL_PATTERN_CREATED   = 0xDC;
static const uint8_t VMA_ALLOCATION_FILL_PATTERN_DESTROYED = 0xEF;

/*******************************************************************************
END OF CONFIGURATION
*/

static const uint32_t VMA_ALLOCATION_INTERNAL_STRATEGY_MIN_OFFSET = 0x10000000u;

static VkAllocationCallbacks VmaEmptyAllocationCallbacks = {
    VMA_NULL, VMA_NULL, VMA_NULL, VMA_NULL, VMA_NULL, VMA_NULL };

// Returns number of bits set to 1 in (v).
static inline uint32_t VmaCountBitsSet(uint32_t v)
{
	uint32_t c = v - ((v >> 1) & 0x55555555);
	c = ((c >>  2) & 0x33333333) + (c & 0x33333333);
	c = ((c >>  4) + c) & 0x0F0F0F0F;
	c = ((c >>  8) + c) & 0x00FF00FF;
	c = ((c >> 16) + c) & 0x0000FFFF;
	return c;
}

// Aligns given value up to nearest multiply of align value. For example: VmaAlignUp(11, 8) = 16.
// Use types like uint32_t, uint64_t as T.
template <typename T>
static inline T VmaAlignUp(T val, T align)
{
	return (val + align - 1) / align * align;
}
// Aligns given value down to nearest multiply of align value. For example: VmaAlignUp(11, 8) = 8.
// Use types like uint32_t, uint64_t as T.
template <typename T>
static inline T VmaAlignDown(T val, T align)
{
    return val / align * align;
}

// Division with mathematical rounding to nearest number.
template <typename T>
static inline T VmaRoundDiv(T x, T y)
{
	return (x + (y / (T)2)) / y;
}

/*
Returns true if given number is a power of two.
T must be unsigned integer number or signed integer but always nonnegative.
For 0 returns true.
*/
template <typename T>
inline bool VmaIsPow2(T x)
{
    return (x & (x-1)) == 0;
}

// Returns smallest power of 2 greater or equal to v.
static inline uint32_t VmaNextPow2(uint32_t v)
{
	v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}
static inline uint64_t VmaNextPow2(uint64_t v)
{
	v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v |= v >> 32;
    v++;
    return v;
}

// Returns largest power of 2 less or equal to v.
static inline uint32_t VmaPrevPow2(uint32_t v)
{
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v = v ^ (v >> 1);
    return v;
}
static inline uint64_t VmaPrevPow2(uint64_t v)
{
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v |= v >> 32;
    v = v ^ (v >> 1);
    return v;
}

static inline bool VmaStrIsEmpty(const char* pStr)
{
    return pStr == VMA_NULL || *pStr == '\0';
}

#if VMA_STATS_STRING_ENABLED

static const char* VmaAlgorithmToStr(uint32_t algorithm)
{
    switch(algorithm)
    {
    case VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT:
        return "Linear";
    case VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT:
        return "Buddy";
    case 0:
        return "Default";
    default:
        VMA_ASSERT(0);
        return "";
    }
}

#endif // #if VMA_STATS_STRING_ENABLED

#ifndef VMA_SORT

template<typename Iterator, typename Compare>
Iterator VmaQuickSortPartition(Iterator beg, Iterator end, Compare cmp)
{
    Iterator centerValue = end; --centerValue;
    Iterator insertIndex = beg;
    for(Iterator memTypeIndex = beg; memTypeIndex < centerValue; ++memTypeIndex)
    {
        if(cmp(*memTypeIndex, *centerValue))
        {
            if(insertIndex != memTypeIndex)
            {
                VMA_SWAP(*memTypeIndex, *insertIndex);
            }
            ++insertIndex;
        }
    }
    if(insertIndex != centerValue)
    {
        VMA_SWAP(*insertIndex, *centerValue);
    }
    return insertIndex;
}

template<typename Iterator, typename Compare>
void VmaQuickSort(Iterator beg, Iterator end, Compare cmp)
{
    if(beg < end)
    {
        Iterator it = VmaQuickSortPartition<Iterator, Compare>(beg, end, cmp);
        VmaQuickSort<Iterator, Compare>(beg, it, cmp);
        VmaQuickSort<Iterator, Compare>(it + 1, end, cmp);
    }
}

#define VMA_SORT(beg, end, cmp) VmaQuickSort(beg, end, cmp)

#endif // #ifndef VMA_SORT

/*
Returns true if two memory blocks occupy overlapping pages.
ResourceA must be in less memory offset than ResourceB.

Algorithm is based on "Vulkan 1.0.39 - A Specification (with all registered Vulkan extensions)"
chapter 11.6 "Resource Memory Association", paragraph "Buffer-Image Granularity".
*/
static inline bool VmaBlocksOnSamePage(
    VkDeviceSize resourceAOffset,
    VkDeviceSize resourceASize,
    VkDeviceSize resourceBOffset,
    VkDeviceSize pageSize)
{
    VMA_ASSERT(resourceAOffset + resourceASize <= resourceBOffset && resourceASize > 0 && pageSize > 0);
    VkDeviceSize resourceAEnd = resourceAOffset + resourceASize - 1;
    VkDeviceSize resourceAEndPage = resourceAEnd & ~(pageSize - 1);
    VkDeviceSize resourceBStart = resourceBOffset;
    VkDeviceSize resourceBStartPage = resourceBStart & ~(pageSize - 1);
    return resourceAEndPage == resourceBStartPage;
}

enum VmaSuballocationType
{
    VMA_SUBALLOCATION_TYPE_FREE = 0,
    VMA_SUBALLOCATION_TYPE_UNKNOWN = 1,
    VMA_SUBALLOCATION_TYPE_BUFFER = 2,
    VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN = 3,
    VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR = 4,
    VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL = 5,
    VMA_SUBALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
};

/*
Returns true if given suballocation types could conflict and must respect
VkPhysicalDeviceLimits::bufferImageGranularity. They conflict if one is buffer
or linear image and another one is optimal image. If type is unknown, behave
conservatively.
*/
static inline bool VmaIsBufferImageGranularityConflict(
    VmaSuballocationType suballocType1,
    VmaSuballocationType suballocType2)
{
    if(suballocType1 > suballocType2)
    {
        VMA_SWAP(suballocType1, suballocType2);
    }
    
    switch(suballocType1)
    {
    case VMA_SUBALLOCATION_TYPE_FREE:
        return false;
    case VMA_SUBALLOCATION_TYPE_UNKNOWN:
        return true;
    case VMA_SUBALLOCATION_TYPE_BUFFER:
        return
            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN ||
            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL;
    case VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN:
        return
            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN ||
            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR ||
            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL;
    case VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR:
        return
            suballocType2 == VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL;
    case VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL:
        return false;
    default:
        VMA_ASSERT(0);
        return true;
    }
}

static void VmaWriteMagicValue(void* pData, VkDeviceSize offset)
{
#if VMA_DEBUG_MARGIN > 0 && VMA_DEBUG_DETECT_CORRUPTION
    uint32_t* pDst = (uint32_t*)((char*)pData + offset);
    const size_t numberCount = VMA_DEBUG_MARGIN / sizeof(uint32_t);
    for(size_t i = 0; i < numberCount; ++i, ++pDst)
    {
        *pDst = VMA_CORRUPTION_DETECTION_MAGIC_VALUE;
    }
#else
    // no-op
#endif
}

static bool VmaValidateMagicValue(const void* pData, VkDeviceSize offset)
{
#if VMA_DEBUG_MARGIN > 0 && VMA_DEBUG_DETECT_CORRUPTION
    const uint32_t* pSrc = (const uint32_t*)((const char*)pData + offset);
    const size_t numberCount = VMA_DEBUG_MARGIN / sizeof(uint32_t);
    for(size_t i = 0; i < numberCount; ++i, ++pSrc)
    {
        if(*pSrc != VMA_CORRUPTION_DETECTION_MAGIC_VALUE)
        {
            return false;
        }
    }
#endif
    return true;
}

/*
Fills structure with parameters of an example buffer to be used for transfers
during GPU memory defragmentation.
*/
static void VmaFillGpuDefragmentationBufferCreateInfo(VkBufferCreateInfo& outBufCreateInfo)
{
    memset(&outBufCreateInfo, 0, sizeof(outBufCreateInfo));
    outBufCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    outBufCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
    outBufCreateInfo.size = (VkDeviceSize)VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE; // Example size.
}

// Helper RAII class to lock a mutex in constructor and unlock it in destructor (at the end of scope).
struct VmaMutexLock
{
    VMA_CLASS_NO_COPY(VmaMutexLock)
public:
    VmaMutexLock(VMA_MUTEX& mutex, bool useMutex = true) :
        m_pMutex(useMutex ? &mutex : VMA_NULL)
    { if(m_pMutex) { m_pMutex->Lock(); } }
    ~VmaMutexLock()
    { if(m_pMutex) { m_pMutex->Unlock(); } }
private:
    VMA_MUTEX* m_pMutex;
};

// Helper RAII class to lock a RW mutex in constructor and unlock it in destructor (at the end of scope), for reading.
struct VmaMutexLockRead
{
    VMA_CLASS_NO_COPY(VmaMutexLockRead)
public:
    VmaMutexLockRead(VMA_RW_MUTEX& mutex, bool useMutex) :
        m_pMutex(useMutex ? &mutex : VMA_NULL)
    { if(m_pMutex) { m_pMutex->LockRead(); } }
    ~VmaMutexLockRead() { if(m_pMutex) { m_pMutex->UnlockRead(); } }
private:
    VMA_RW_MUTEX* m_pMutex;
};

// Helper RAII class to lock a RW mutex in constructor and unlock it in destructor (at the end of scope), for writing.
struct VmaMutexLockWrite
{
    VMA_CLASS_NO_COPY(VmaMutexLockWrite)
public:
    VmaMutexLockWrite(VMA_RW_MUTEX& mutex, bool useMutex) :
        m_pMutex(useMutex ? &mutex : VMA_NULL)
    { if(m_pMutex) { m_pMutex->LockWrite(); } }
    ~VmaMutexLockWrite() { if(m_pMutex) { m_pMutex->UnlockWrite(); } }
private:
    VMA_RW_MUTEX* m_pMutex;
};

#if VMA_DEBUG_GLOBAL_MUTEX
    static VMA_MUTEX gDebugGlobalMutex;
    #define VMA_DEBUG_GLOBAL_MUTEX_LOCK VmaMutexLock debugGlobalMutexLock(gDebugGlobalMutex, true);
#else
    #define VMA_DEBUG_GLOBAL_MUTEX_LOCK
#endif

// Minimum size of a free suballocation to register it in the free suballocation collection.
static const VkDeviceSize VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER = 16;

/*
Performs binary search and returns iterator to first element that is greater or
equal to (key), according to comparison (cmp).

Cmp should return true if first argument is less than second argument.

Returned value is the found element, if present in the collection or place where
new element with value (key) should be inserted.
*/
template <typename CmpLess, typename IterT, typename KeyT>
static IterT VmaBinaryFindFirstNotLess(IterT beg, IterT end, const KeyT &key, const CmpLess& cmp)
{
    size_t down = 0, up = (end - beg);
    while(down < up)
    {
        const size_t mid = (down + up) / 2;
        if(cmp(*(beg+mid), key))
        {
            down = mid + 1;
        }
        else
        {
            up = mid;
        }
    }
    return beg + down;
}

template<typename CmpLess, typename IterT, typename KeyT>
IterT VmaBinaryFindSorted(const IterT& beg, const IterT& end, const KeyT& value, const CmpLess& cmp)
{
    IterT it = VmaBinaryFindFirstNotLess<CmpLess, IterT, KeyT>(
        beg, end, value, cmp);
    if(it == end ||
        (!cmp(*it, value) && !cmp(value, *it)))
    {
        return it;
    }
    return end;
}

/*
Returns true if all pointers in the array are not-null and unique.
Warning! O(n^2) complexity. Use only inside VMA_HEAVY_ASSERT.
T must be pointer type, e.g. VmaAllocation, VmaPool.
*/
template<typename T>
static bool VmaValidatePointerArray(uint32_t count, const T* arr)
{
    for(uint32_t i = 0; i < count; ++i)
    {
        const T iPtr = arr[i];
        if(iPtr == VMA_NULL)
        {
            return false;
        }
        for(uint32_t j = i + 1; j < count; ++j)
        {
            if(iPtr == arr[j])
            {
                return false;
            }
        }
    }
    return true;
}

////////////////////////////////////////////////////////////////////////////////
// Memory allocation

static void* VmaMalloc(const VkAllocationCallbacks* pAllocationCallbacks, size_t size, size_t alignment)
{
    if((pAllocationCallbacks != VMA_NULL) &&
        (pAllocationCallbacks->pfnAllocation != VMA_NULL))
    {
        return (*pAllocationCallbacks->pfnAllocation)(
            pAllocationCallbacks->pUserData,
            size,
            alignment,
            VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
    }
    else
    {
        return VMA_SYSTEM_ALIGNED_MALLOC(size, alignment);
    }
}

static void VmaFree(const VkAllocationCallbacks* pAllocationCallbacks, void* ptr)
{
    if((pAllocationCallbacks != VMA_NULL) &&
        (pAllocationCallbacks->pfnFree != VMA_NULL))
    {
        (*pAllocationCallbacks->pfnFree)(pAllocationCallbacks->pUserData, ptr);
    }
    else
    {
        VMA_SYSTEM_FREE(ptr);
    }
}

template<typename T>
static T* VmaAllocate(const VkAllocationCallbacks* pAllocationCallbacks)
{
    return (T*)VmaMalloc(pAllocationCallbacks, sizeof(T), VMA_ALIGN_OF(T));
}

template<typename T>
static T* VmaAllocateArray(const VkAllocationCallbacks* pAllocationCallbacks, size_t count)
{
    return (T*)VmaMalloc(pAllocationCallbacks, sizeof(T) * count, VMA_ALIGN_OF(T));
}

#define vma_new(allocator, type)   new(VmaAllocate<type>(allocator))(type)

#define vma_new_array(allocator, type, count)   new(VmaAllocateArray<type>((allocator), (count)))(type)

template<typename T>
static void vma_delete(const VkAllocationCallbacks* pAllocationCallbacks, T* ptr)
{
    ptr->~T();
    VmaFree(pAllocationCallbacks, ptr);
}

template<typename T>
static void vma_delete_array(const VkAllocationCallbacks* pAllocationCallbacks, T* ptr, size_t count)
{
    if(ptr != VMA_NULL)
    {
        for(size_t i = count; i--; )
        {
            ptr[i].~T();
        }
        VmaFree(pAllocationCallbacks, ptr);
    }
}

static char* VmaCreateStringCopy(const VkAllocationCallbacks* allocs, const char* srcStr)
{
    if(srcStr != VMA_NULL)
    {
        const size_t len = strlen(srcStr);
        char* const result = vma_new_array(allocs, char, len + 1);
        memcpy(result, srcStr, len + 1);
        return result;
    }
    else
    {
        return VMA_NULL;
    }
}

static void VmaFreeString(const VkAllocationCallbacks* allocs, char* str)
{
    if(str != VMA_NULL)
    {
        const size_t len = strlen(str);
        vma_delete_array(allocs, str, len + 1);
    }
}

// STL-compatible allocator.
template<typename T>
class VmaStlAllocator
{
public:
    const VkAllocationCallbacks* const m_pCallbacks;
    typedef T value_type;
    
    VmaStlAllocator(const VkAllocationCallbacks* pCallbacks) : m_pCallbacks(pCallbacks) { }
    template<typename U> VmaStlAllocator(const VmaStlAllocator<U>& src) : m_pCallbacks(src.m_pCallbacks) { }

    T* allocate(size_t n) { return VmaAllocateArray<T>(m_pCallbacks, n); }
    void deallocate(T* p, size_t n) { VmaFree(m_pCallbacks, p); }

    template<typename U>
    bool operator==(const VmaStlAllocator<U>& rhs) const
    {
        return m_pCallbacks == rhs.m_pCallbacks;
    }
    template<typename U>
    bool operator!=(const VmaStlAllocator<U>& rhs) const
    {
        return m_pCallbacks != rhs.m_pCallbacks;
    }

    VmaStlAllocator& operator=(const VmaStlAllocator& x) = delete;
};

#if VMA_USE_STL_VECTOR

#define VmaVector std::vector

template<typename T, typename allocatorT>
static void VmaVectorInsert(std::vector<T, allocatorT>& vec, size_t index, const T& item)
{
    vec.insert(vec.begin() + index, item);
}

template<typename T, typename allocatorT>
static void VmaVectorRemove(std::vector<T, allocatorT>& vec, size_t index)
{
    vec.erase(vec.begin() + index);
}

#else // #if VMA_USE_STL_VECTOR

/* Class with interface compatible with subset of std::vector.
T must be POD because constructors and destructors are not called and memcpy is
used for these objects. */
template<typename T, typename AllocatorT>
class VmaVector
{
public:
    typedef T value_type;

    VmaVector(const AllocatorT& allocator) :
        m_Allocator(allocator),
        m_pArray(VMA_NULL),
        m_Count(0),
        m_Capacity(0)
    {
    }

    VmaVector(size_t count, const AllocatorT& allocator) :
        m_Allocator(allocator),
        m_pArray(count ? (T*)VmaAllocateArray<T>(allocator.m_pCallbacks, count) : VMA_NULL),
        m_Count(count),
        m_Capacity(count)
    {
    }
    
    // This version of the constructor is here for compatibility with pre-C++14 std::vector.
    // value is unused.
    VmaVector(size_t count, const T& value, const AllocatorT& allocator)
        : VmaVector(count, allocator) {}
    
    VmaVector(const VmaVector<T, AllocatorT>& src) :
        m_Allocator(src.m_Allocator),
        m_pArray(src.m_Count ? (T*)VmaAllocateArray<T>(src.m_Allocator.m_pCallbacks, src.m_Count) : VMA_NULL),
        m_Count(src.m_Count),
        m_Capacity(src.m_Count)
    {
        if(m_Count != 0)
        {
            memcpy(m_pArray, src.m_pArray, m_Count * sizeof(T));
        }
    }
    
    ~VmaVector()
    {
        VmaFree(m_Allocator.m_pCallbacks, m_pArray);
    }

    VmaVector& operator=(const VmaVector<T, AllocatorT>& rhs)
    {
        if(&rhs != this)
        {
            resize(rhs.m_Count);
            if(m_Count != 0)
            {
                memcpy(m_pArray, rhs.m_pArray, m_Count * sizeof(T));
            }
        }
        return *this;
    }
    
    bool empty() const { return m_Count == 0; }
    size_t size() const { return m_Count; }
    T* data() { return m_pArray; }
    const T* data() const { return m_pArray; }
    
    T& operator[](size_t index)
    {
        VMA_HEAVY_ASSERT(index < m_Count);
        return m_pArray[index];
    }
    const T& operator[](size_t index) const
    {
        VMA_HEAVY_ASSERT(index < m_Count);
        return m_pArray[index];
    }

    T& front()
    {
        VMA_HEAVY_ASSERT(m_Count > 0);
        return m_pArray[0];
    }
    const T& front() const
    {
        VMA_HEAVY_ASSERT(m_Count > 0);
        return m_pArray[0];
    }
    T& back()
    {
        VMA_HEAVY_ASSERT(m_Count > 0);
        return m_pArray[m_Count - 1];
    }
    const T& back() const
    {
        VMA_HEAVY_ASSERT(m_Count > 0);
        return m_pArray[m_Count - 1];
    }

    void reserve(size_t newCapacity, bool freeMemory = false)
    {
        newCapacity = VMA_MAX(newCapacity, m_Count);
        
        if((newCapacity < m_Capacity) && !freeMemory)
        {
            newCapacity = m_Capacity;
        }
        
        if(newCapacity != m_Capacity)
        {
            T* const newArray = newCapacity ? VmaAllocateArray<T>(m_Allocator, newCapacity) : VMA_NULL;
            if(m_Count != 0)
            {
                memcpy(newArray, m_pArray, m_Count * sizeof(T));
            }
            VmaFree(m_Allocator.m_pCallbacks, m_pArray);
            m_Capacity = newCapacity;
            m_pArray = newArray;
        }
    }

    void resize(size_t newCount, bool freeMemory = false)
    {
        size_t newCapacity = m_Capacity;
        if(newCount > m_Capacity)
        {
            newCapacity = VMA_MAX(newCount, VMA_MAX(m_Capacity * 3 / 2, (size_t)8));
        }
        else if(freeMemory)
        {
            newCapacity = newCount;
        }

        if(newCapacity != m_Capacity)
        {
            T* const newArray = newCapacity ? VmaAllocateArray<T>(m_Allocator.m_pCallbacks, newCapacity) : VMA_NULL;
            const size_t elementsToCopy = VMA_MIN(m_Count, newCount);
            if(elementsToCopy != 0)
            {
                memcpy(newArray, m_pArray, elementsToCopy * sizeof(T));
            }
            VmaFree(m_Allocator.m_pCallbacks, m_pArray);
            m_Capacity = newCapacity;
            m_pArray = newArray;
        }

        m_Count = newCount;
    }

    void clear(bool freeMemory = false)
    {
        resize(0, freeMemory);
    }

    void insert(size_t index, const T& src)
    {
        VMA_HEAVY_ASSERT(index <= m_Count);
        const size_t oldCount = size();
        resize(oldCount + 1);
        if(index < oldCount)
        {
            memmove(m_pArray + (index + 1), m_pArray + index, (oldCount - index) * sizeof(T));
        }
        m_pArray[index] = src;
    }

    void remove(size_t index)
    {
        VMA_HEAVY_ASSERT(index < m_Count);
        const size_t oldCount = size();
        if(index < oldCount - 1)
        {
            memmove(m_pArray + index, m_pArray + (index + 1), (oldCount - index - 1) * sizeof(T));
        }
        resize(oldCount - 1);
    }

    void push_back(const T& src)
    {
        const size_t newIndex = size();
        resize(newIndex + 1);
        m_pArray[newIndex] = src;
    }

    void pop_back()
    {
        VMA_HEAVY_ASSERT(m_Count > 0);
        resize(size() - 1);
    }

    void push_front(const T& src)
    {
        insert(0, src);
    }

    void pop_front()
    {
        VMA_HEAVY_ASSERT(m_Count > 0);
        remove(0);
    }

    typedef T* iterator;

    iterator begin() { return m_pArray; }
    iterator end() { return m_pArray + m_Count; }

private:
    AllocatorT m_Allocator;
    T* m_pArray;
    size_t m_Count;
    size_t m_Capacity;
};

template<typename T, typename allocatorT>
static void VmaVectorInsert(VmaVector<T, allocatorT>& vec, size_t index, const T& item)
{
    vec.insert(index, item);
}

template<typename T, typename allocatorT>
static void VmaVectorRemove(VmaVector<T, allocatorT>& vec, size_t index)
{
    vec.remove(index);
}

#endif // #if VMA_USE_STL_VECTOR

template<typename CmpLess, typename VectorT>
size_t VmaVectorInsertSorted(VectorT& vector, const typename VectorT::value_type& value)
{
    const size_t indexToInsert = VmaBinaryFindFirstNotLess(
        vector.data(),
        vector.data() + vector.size(),
        value,
        CmpLess()) - vector.data();
    VmaVectorInsert(vector, indexToInsert, value);
    return indexToInsert;
}

template<typename CmpLess, typename VectorT>
bool VmaVectorRemoveSorted(VectorT& vector, const typename VectorT::value_type& value)
{
    CmpLess comparator;
    typename VectorT::iterator it = VmaBinaryFindFirstNotLess(
        vector.begin(),
        vector.end(),
        value,
        comparator);
    if((it != vector.end()) && !comparator(*it, value) && !comparator(value, *it))
    {
        size_t indexToRemove = it - vector.begin();
        VmaVectorRemove(vector, indexToRemove);
        return true;
    }
    return false;
}

////////////////////////////////////////////////////////////////////////////////
// class VmaPoolAllocator

/*
Allocator for objects of type T using a list of arrays (pools) to speed up
allocation. Number of elements that can be allocated is not bounded because
allocator can create multiple blocks.
*/
template<typename T>
class VmaPoolAllocator
{
    VMA_CLASS_NO_COPY(VmaPoolAllocator)
public:
    VmaPoolAllocator(const VkAllocationCallbacks* pAllocationCallbacks, uint32_t firstBlockCapacity);
    ~VmaPoolAllocator();
    T* Alloc();
    void Free(T* ptr);

private:
    union Item
    {
        uint32_t NextFreeIndex;
        alignas(T) char Value[sizeof(T)];
    };

    struct ItemBlock
    {
        Item* pItems;
        uint32_t Capacity;
        uint32_t FirstFreeIndex;
    };
    
    const VkAllocationCallbacks* m_pAllocationCallbacks;
    const uint32_t m_FirstBlockCapacity;
    VmaVector< ItemBlock, VmaStlAllocator<ItemBlock> > m_ItemBlocks;

    ItemBlock& CreateNewBlock();
};

template<typename T>
VmaPoolAllocator<T>::VmaPoolAllocator(const VkAllocationCallbacks* pAllocationCallbacks, uint32_t firstBlockCapacity) :
    m_pAllocationCallbacks(pAllocationCallbacks),
    m_FirstBlockCapacity(firstBlockCapacity),
    m_ItemBlocks(VmaStlAllocator<ItemBlock>(pAllocationCallbacks))
{
    VMA_ASSERT(m_FirstBlockCapacity > 1);
}

template<typename T>
VmaPoolAllocator<T>::~VmaPoolAllocator()
{
    for(size_t i = m_ItemBlocks.size(); i--; )
        vma_delete_array(m_pAllocationCallbacks, m_ItemBlocks[i].pItems, m_ItemBlocks[i].Capacity);
    m_ItemBlocks.clear();
}

template<typename T>
T* VmaPoolAllocator<T>::Alloc()
{
    for(size_t i = m_ItemBlocks.size(); i--; )
    {
        ItemBlock& block = m_ItemBlocks[i];
        // This block has some free items: Use first one.
        if(block.FirstFreeIndex != UINT32_MAX)
        {
            Item* const pItem = &block.pItems[block.FirstFreeIndex];
            block.FirstFreeIndex = pItem->NextFreeIndex;
            T* result = (T*)&pItem->Value;
            new(result)T(); // Explicit constructor call.
            return result;
        }
    }

    // No block has free item: Create new one and use it.
    ItemBlock& newBlock = CreateNewBlock();
    Item* const pItem = &newBlock.pItems[0];
    newBlock.FirstFreeIndex = pItem->NextFreeIndex;
    T* result = (T*)&pItem->Value;
    new(result)T(); // Explicit constructor call.
    return result;
}

template<typename T>
void VmaPoolAllocator<T>::Free(T* ptr)
{
    // Search all memory blocks to find ptr.
    for(size_t i = m_ItemBlocks.size(); i--; )
    {
        ItemBlock& block = m_ItemBlocks[i];
        
        // Casting to union.
        Item* pItemPtr;
        memcpy(&pItemPtr, &ptr, sizeof(pItemPtr));
        
        // Check if pItemPtr is in address range of this block.
        if((pItemPtr >= block.pItems) && (pItemPtr < block.pItems + block.Capacity))
        {
            ptr->~T(); // Explicit destructor call.
            const uint32_t index = static_cast<uint32_t>(pItemPtr - block.pItems);
            pItemPtr->NextFreeIndex = block.FirstFreeIndex;
            block.FirstFreeIndex = index;
            return;
        }
    }
    VMA_ASSERT(0 && "Pointer doesn't belong to this memory pool.");
}

template<typename T>
typename VmaPoolAllocator<T>::ItemBlock& VmaPoolAllocator<T>::CreateNewBlock()
{
    const uint32_t newBlockCapacity = m_ItemBlocks.empty() ?
        m_FirstBlockCapacity : m_ItemBlocks.back().Capacity * 3 / 2;

    const ItemBlock newBlock = {
        vma_new_array(m_pAllocationCallbacks, Item, newBlockCapacity),
        newBlockCapacity,
        0 };

    m_ItemBlocks.push_back(newBlock);

    // Setup singly-linked list of all free items in this block.
    for(uint32_t i = 0; i < newBlockCapacity - 1; ++i)
        newBlock.pItems[i].NextFreeIndex = i + 1;
    newBlock.pItems[newBlockCapacity - 1].NextFreeIndex = UINT32_MAX;
    return m_ItemBlocks.back();
}

////////////////////////////////////////////////////////////////////////////////
// class VmaRawList, VmaList

#if VMA_USE_STL_LIST

#define VmaList std::list

#else // #if VMA_USE_STL_LIST

template<typename T>
struct VmaListItem
{
    VmaListItem* pPrev;
    VmaListItem* pNext;
    T Value;
};

// Doubly linked list.
template<typename T>
class VmaRawList
{
    VMA_CLASS_NO_COPY(VmaRawList)
public:
    typedef VmaListItem<T> ItemType;

    VmaRawList(const VkAllocationCallbacks* pAllocationCallbacks);
    ~VmaRawList();
    void Clear();

    size_t GetCount() const { return m_Count; }
    bool IsEmpty() const { return m_Count == 0; }

    ItemType* Front() { return m_pFront; }
    const ItemType* Front() const { return m_pFront; }
    ItemType* Back() { return m_pBack; }
    const ItemType* Back() const { return m_pBack; }

    ItemType* PushBack();
    ItemType* PushFront();
    ItemType* PushBack(const T& value);
    ItemType* PushFront(const T& value);
    void PopBack();
    void PopFront();
    
    // Item can be null - it means PushBack.
    ItemType* InsertBefore(ItemType* pItem);
    // Item can be null - it means PushFront.
    ItemType* InsertAfter(ItemType* pItem);

    ItemType* InsertBefore(ItemType* pItem, const T& value);
    ItemType* InsertAfter(ItemType* pItem, const T& value);

    void Remove(ItemType* pItem);

private:
    const VkAllocationCallbacks* const m_pAllocationCallbacks;
    VmaPoolAllocator<ItemType> m_ItemAllocator;
    ItemType* m_pFront;
    ItemType* m_pBack;
    size_t m_Count;
};

template<typename T>
VmaRawList<T>::VmaRawList(const VkAllocationCallbacks* pAllocationCallbacks) :
    m_pAllocationCallbacks(pAllocationCallbacks),
    m_ItemAllocator(pAllocationCallbacks, 128),
    m_pFront(VMA_NULL),
    m_pBack(VMA_NULL),
    m_Count(0)
{
}

template<typename T>
VmaRawList<T>::~VmaRawList()
{
    // Intentionally not calling Clear, because that would be unnecessary
    // computations to return all items to m_ItemAllocator as free.
}

template<typename T>
void VmaRawList<T>::Clear()
{
    if(IsEmpty() == false)
    {
        ItemType* pItem = m_pBack;
        while(pItem != VMA_NULL)
        {
            ItemType* const pPrevItem = pItem->pPrev;
            m_ItemAllocator.Free(pItem);
            pItem = pPrevItem;
        }
        m_pFront = VMA_NULL;
        m_pBack = VMA_NULL;
        m_Count = 0;
    }
}

template<typename T>
VmaListItem<T>* VmaRawList<T>::PushBack()
{
    ItemType* const pNewItem = m_ItemAllocator.Alloc();
    pNewItem->pNext = VMA_NULL;
    if(IsEmpty())
    {
        pNewItem->pPrev = VMA_NULL;
        m_pFront = pNewItem;
        m_pBack = pNewItem;
        m_Count = 1;
    }
    else
    {
        pNewItem->pPrev = m_pBack;
        m_pBack->pNext = pNewItem;
        m_pBack = pNewItem;
        ++m_Count;
    }
    return pNewItem;
}

template<typename T>
VmaListItem<T>* VmaRawList<T>::PushFront()
{
    ItemType* const pNewItem = m_ItemAllocator.Alloc();
    pNewItem->pPrev = VMA_NULL;
    if(IsEmpty())
    {
        pNewItem->pNext = VMA_NULL;
        m_pFront = pNewItem;
        m_pBack = pNewItem;
        m_Count = 1;
    }
    else
    {
        pNewItem->pNext = m_pFront;
        m_pFront->pPrev = pNewItem;
        m_pFront = pNewItem;
        ++m_Count;
    }
    return pNewItem;
}

template<typename T>
VmaListItem<T>* VmaRawList<T>::PushBack(const T& value)
{
    ItemType* const pNewItem = PushBack();
    pNewItem->Value = value;
    return pNewItem;
}

template<typename T>
VmaListItem<T>* VmaRawList<T>::PushFront(const T& value)
{
    ItemType* const pNewItem = PushFront();
    pNewItem->Value = value;
    return pNewItem;
}

template<typename T>
void VmaRawList<T>::PopBack()
{
    VMA_HEAVY_ASSERT(m_Count > 0);
    ItemType* const pBackItem = m_pBack;
    ItemType* const pPrevItem = pBackItem->pPrev;
    if(pPrevItem != VMA_NULL)
    {
        pPrevItem->pNext = VMA_NULL;
    }
    m_pBack = pPrevItem;
    m_ItemAllocator.Free(pBackItem);
    --m_Count;
}

template<typename T>
void VmaRawList<T>::PopFront()
{
    VMA_HEAVY_ASSERT(m_Count > 0);
    ItemType* const pFrontItem = m_pFront;
    ItemType* const pNextItem = pFrontItem->pNext;
    if(pNextItem != VMA_NULL)
    {
        pNextItem->pPrev = VMA_NULL;
    }
    m_pFront = pNextItem;
    m_ItemAllocator.Free(pFrontItem);
    --m_Count;
}

template<typename T>
void VmaRawList<T>::Remove(ItemType* pItem)
{
    VMA_HEAVY_ASSERT(pItem != VMA_NULL);
    VMA_HEAVY_ASSERT(m_Count > 0);

    if(pItem->pPrev != VMA_NULL)
    {
        pItem->pPrev->pNext = pItem->pNext;
    }
    else
    {
        VMA_HEAVY_ASSERT(m_pFront == pItem);
        m_pFront = pItem->pNext;
    }

    if(pItem->pNext != VMA_NULL)
    {
        pItem->pNext->pPrev = pItem->pPrev;
    }
    else
    {
        VMA_HEAVY_ASSERT(m_pBack == pItem);
        m_pBack = pItem->pPrev;
    }

    m_ItemAllocator.Free(pItem);
    --m_Count;
}

template<typename T>
VmaListItem<T>* VmaRawList<T>::InsertBefore(ItemType* pItem)
{
    if(pItem != VMA_NULL)
    {
        ItemType* const prevItem = pItem->pPrev;
        ItemType* const newItem = m_ItemAllocator.Alloc();
        newItem->pPrev = prevItem;
        newItem->pNext = pItem;
        pItem->pPrev = newItem;
        if(prevItem != VMA_NULL)
        {
            prevItem->pNext = newItem;
        }
        else
        {
            VMA_HEAVY_ASSERT(m_pFront == pItem);
            m_pFront = newItem;
        }
        ++m_Count;
        return newItem;
    }
    else
        return PushBack();
}

template<typename T>
VmaListItem<T>* VmaRawList<T>::InsertAfter(ItemType* pItem)
{
    if(pItem != VMA_NULL)
    {
        ItemType* const nextItem = pItem->pNext;
        ItemType* const newItem = m_ItemAllocator.Alloc();
        newItem->pNext = nextItem;
        newItem->pPrev = pItem;
        pItem->pNext = newItem;
        if(nextItem != VMA_NULL)
        {
            nextItem->pPrev = newItem;
        }
        else
        {
            VMA_HEAVY_ASSERT(m_pBack == pItem);
            m_pBack = newItem;
        }
        ++m_Count;
        return newItem;
    }
    else
        return PushFront();
}

template<typename T>
VmaListItem<T>* VmaRawList<T>::InsertBefore(ItemType* pItem, const T& value)
{
    ItemType* const newItem = InsertBefore(pItem);
    newItem->Value = value;
    return newItem;
}

template<typename T>
VmaListItem<T>* VmaRawList<T>::InsertAfter(ItemType* pItem, const T& value)
{
    ItemType* const newItem = InsertAfter(pItem);
    newItem->Value = value;
    return newItem;
}

template<typename T, typename AllocatorT>
class VmaList
{
    VMA_CLASS_NO_COPY(VmaList)
public:
    class iterator
    {
    public:
        iterator() :
            m_pList(VMA_NULL),
            m_pItem(VMA_NULL)
        {
        }

        T& operator*() const
        {
            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
            return m_pItem->Value;
        }
        T* operator->() const
        {
            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
            return &m_pItem->Value;
        }

        iterator& operator++()
        {
            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
            m_pItem = m_pItem->pNext;
            return *this;
        }
        iterator& operator--()
        {
            if(m_pItem != VMA_NULL)
            {
                m_pItem = m_pItem->pPrev;
            }
            else
            {
                VMA_HEAVY_ASSERT(!m_pList->IsEmpty());
                m_pItem = m_pList->Back();
            }
            return *this;
        }

        iterator operator++(int)
        {
            iterator result = *this;
            ++*this;
            return result;
        }
        iterator operator--(int)
        {
            iterator result = *this;
            --*this;
            return result;
        }

        bool operator==(const iterator& rhs) const
        {
            VMA_HEAVY_ASSERT(m_pList == rhs.m_pList);
            return m_pItem == rhs.m_pItem;
        }
        bool operator!=(const iterator& rhs) const
        {
            VMA_HEAVY_ASSERT(m_pList == rhs.m_pList);
            return m_pItem != rhs.m_pItem;
        }
        
    private:
        VmaRawList<T>* m_pList;
        VmaListItem<T>* m_pItem;

        iterator(VmaRawList<T>* pList, VmaListItem<T>* pItem) :
            m_pList(pList),
            m_pItem(pItem)
        {
        }

        friend class VmaList<T, AllocatorT>;
    };

    class const_iterator
    {
    public:
        const_iterator() :
            m_pList(VMA_NULL),
            m_pItem(VMA_NULL)
        {
        }

        const_iterator(const iterator& src) :
            m_pList(src.m_pList),
            m_pItem(src.m_pItem)
        {
        }
        
        const T& operator*() const
        {
            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
            return m_pItem->Value;
        }
        const T* operator->() const
        {
            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
            return &m_pItem->Value;
        }

        const_iterator& operator++()
        {
            VMA_HEAVY_ASSERT(m_pItem != VMA_NULL);
            m_pItem = m_pItem->pNext;
            return *this;
        }
        const_iterator& operator--()
        {
            if(m_pItem != VMA_NULL)
            {
                m_pItem = m_pItem->pPrev;
            }
            else
            {
                VMA_HEAVY_ASSERT(!m_pList->IsEmpty());
                m_pItem = m_pList->Back();
            }
            return *this;
        }

        const_iterator operator++(int)
        {
            const_iterator result = *this;
            ++*this;
            return result;
        }
        const_iterator operator--(int)
        {
            const_iterator result = *this;
            --*this;
            return result;
        }

        bool operator==(const const_iterator& rhs) const
        {
            VMA_HEAVY_ASSERT(m_pList == rhs.m_pList);
            return m_pItem == rhs.m_pItem;
        }
        bool operator!=(const const_iterator& rhs) const
        {
            VMA_HEAVY_ASSERT(m_pList == rhs.m_pList);
            return m_pItem != rhs.m_pItem;
        }
        
    private:
        const_iterator(const VmaRawList<T>* pList, const VmaListItem<T>* pItem) :
            m_pList(pList),
            m_pItem(pItem)
        {
        }

        const VmaRawList<T>* m_pList;
        const VmaListItem<T>* m_pItem;

        friend class VmaList<T, AllocatorT>;
    };

    VmaList(const AllocatorT& allocator) : m_RawList(allocator.m_pCallbacks) { }

    bool empty() const { return m_RawList.IsEmpty(); }
    size_t size() const { return m_RawList.GetCount(); }

    iterator begin() { return iterator(&m_RawList, m_RawList.Front()); }
    iterator end() { return iterator(&m_RawList, VMA_NULL); }

    const_iterator cbegin() const { return const_iterator(&m_RawList, m_RawList.Front()); }
    const_iterator cend() const { return const_iterator(&m_RawList, VMA_NULL); }

    void clear() { m_RawList.Clear(); }
    void push_back(const T& value) { m_RawList.PushBack(value); }
    void erase(iterator it) { m_RawList.Remove(it.m_pItem); }
    iterator insert(iterator it, const T& value) { return iterator(&m_RawList, m_RawList.InsertBefore(it.m_pItem, value)); }

private:
    VmaRawList<T> m_RawList;
};

#endif // #if VMA_USE_STL_LIST

////////////////////////////////////////////////////////////////////////////////
// class VmaMap

// Unused in this version.
#if 0

#if VMA_USE_STL_UNORDERED_MAP

#define VmaPair std::pair

#define VMA_MAP_TYPE(KeyT, ValueT) \
    std::unordered_map< KeyT, ValueT, std::hash<KeyT>, std::equal_to<KeyT>, VmaStlAllocator< std::pair<KeyT, ValueT> > >

#else // #if VMA_USE_STL_UNORDERED_MAP

template<typename T1, typename T2>
struct VmaPair
{
    T1 first;
    T2 second;

    VmaPair() : first(), second() { }
    VmaPair(const T1& firstSrc, const T2& secondSrc) : first(firstSrc), second(secondSrc) { }
};

/* Class compatible with subset of interface of std::unordered_map.
KeyT, ValueT must be POD because they will be stored in VmaVector.
*/
template<typename KeyT, typename ValueT>
class VmaMap
{
public:
    typedef VmaPair<KeyT, ValueT> PairType;
    typedef PairType* iterator;

    VmaMap(const VmaStlAllocator<PairType>& allocator) : m_Vector(allocator) { }

    iterator begin() { return m_Vector.begin(); }
    iterator end() { return m_Vector.end(); }

    void insert(const PairType& pair);
    iterator find(const KeyT& key);
    void erase(iterator it);
    
private:
    VmaVector< PairType, VmaStlAllocator<PairType> > m_Vector;
};

#define VMA_MAP_TYPE(KeyT, ValueT) VmaMap<KeyT, ValueT>

template<typename FirstT, typename SecondT>
struct VmaPairFirstLess
{
    bool operator()(const VmaPair<FirstT, SecondT>& lhs, const VmaPair<FirstT, SecondT>& rhs) const
    {
        return lhs.first < rhs.first;
    }
    bool operator()(const VmaPair<FirstT, SecondT>& lhs, const FirstT& rhsFirst) const
    {
        return lhs.first < rhsFirst;
    }
};

template<typename KeyT, typename ValueT>
void VmaMap<KeyT, ValueT>::insert(const PairType& pair)
{
    const size_t indexToInsert = VmaBinaryFindFirstNotLess(
        m_Vector.data(),
        m_Vector.data() + m_Vector.size(),
        pair,
        VmaPairFirstLess<KeyT, ValueT>()) - m_Vector.data();
    VmaVectorInsert(m_Vector, indexToInsert, pair);
}

template<typename KeyT, typename ValueT>
VmaPair<KeyT, ValueT>* VmaMap<KeyT, ValueT>::find(const KeyT& key)
{
    PairType* it = VmaBinaryFindFirstNotLess(
        m_Vector.data(),
        m_Vector.data() + m_Vector.size(),
        key,
        VmaPairFirstLess<KeyT, ValueT>());
    if((it != m_Vector.end()) && (it->first == key))
    {
        return it;
    }
    else
    {
        return m_Vector.end();
    }
}

template<typename KeyT, typename ValueT>
void VmaMap<KeyT, ValueT>::erase(iterator it)
{
    VmaVectorRemove(m_Vector, it - m_Vector.begin());
}

#endif // #if VMA_USE_STL_UNORDERED_MAP

#endif // #if 0

////////////////////////////////////////////////////////////////////////////////

class VmaDeviceMemoryBlock;

enum VMA_CACHE_OPERATION { VMA_CACHE_FLUSH, VMA_CACHE_INVALIDATE };

struct VmaAllocation_T
{
private:
    static const uint8_t MAP_COUNT_FLAG_PERSISTENT_MAP = 0x80;

    enum FLAGS
    {
        FLAG_USER_DATA_STRING = 0x01,
    };

public:
    enum ALLOCATION_TYPE
    {
        ALLOCATION_TYPE_NONE,
        ALLOCATION_TYPE_BLOCK,
        ALLOCATION_TYPE_DEDICATED,
    };

    /*
    This struct is allocated using VmaPoolAllocator.
    */

    void Ctor(uint32_t currentFrameIndex, bool userDataString)
    {
        m_Alignment = 1;
        m_Size = 0;
        m_MemoryTypeIndex = 0;
        m_pUserData = VMA_NULL;
        m_LastUseFrameIndex = currentFrameIndex;
        m_Type = (uint8_t)ALLOCATION_TYPE_NONE;
        m_SuballocationType = (uint8_t)VMA_SUBALLOCATION_TYPE_UNKNOWN;
        m_MapCount = 0;
        m_Flags = userDataString ? (uint8_t)FLAG_USER_DATA_STRING : 0;

#if VMA_STATS_STRING_ENABLED
        m_CreationFrameIndex = currentFrameIndex;
        m_BufferImageUsage = 0;
#endif
    }

    void Dtor()
    {
        VMA_ASSERT((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) == 0 && "Allocation was not unmapped before destruction.");

        // Check if owned string was freed.
        VMA_ASSERT(m_pUserData == VMA_NULL);
    }

    void InitBlockAllocation(
        VmaDeviceMemoryBlock* block,
        VkDeviceSize offset,
        VkDeviceSize alignment,
        VkDeviceSize size,
        uint32_t memoryTypeIndex,
        VmaSuballocationType suballocationType,
        bool mapped,
        bool canBecomeLost)
    {
        VMA_ASSERT(m_Type == ALLOCATION_TYPE_NONE);
        VMA_ASSERT(block != VMA_NULL);
        m_Type = (uint8_t)ALLOCATION_TYPE_BLOCK;
        m_Alignment = alignment;
        m_Size = size;
        m_MemoryTypeIndex = memoryTypeIndex;
        m_MapCount = mapped ? MAP_COUNT_FLAG_PERSISTENT_MAP : 0;
        m_SuballocationType = (uint8_t)suballocationType;
        m_BlockAllocation.m_Block = block;
        m_BlockAllocation.m_Offset = offset;
        m_BlockAllocation.m_CanBecomeLost = canBecomeLost;
    }

    void InitLost()
    {
        VMA_ASSERT(m_Type == ALLOCATION_TYPE_NONE);
        VMA_ASSERT(m_LastUseFrameIndex.load() == VMA_FRAME_INDEX_LOST);
        m_Type = (uint8_t)ALLOCATION_TYPE_BLOCK;
        m_MemoryTypeIndex = 0;
        m_BlockAllocation.m_Block = VMA_NULL;
        m_BlockAllocation.m_Offset = 0;
        m_BlockAllocation.m_CanBecomeLost = true;
    }

    void ChangeBlockAllocation(
        VmaAllocator hAllocator,
        VmaDeviceMemoryBlock* block,
        VkDeviceSize offset); 

    void ChangeOffset(VkDeviceSize newOffset);

    // pMappedData not null means allocation is created with MAPPED flag.
    void InitDedicatedAllocation(
        uint32_t memoryTypeIndex,
        VkDeviceMemory hMemory,
        VmaSuballocationType suballocationType,
        void* pMappedData,
        VkDeviceSize size)
    {
        VMA_ASSERT(m_Type == ALLOCATION_TYPE_NONE);
        VMA_ASSERT(hMemory != VK_NULL_HANDLE);
        m_Type = (uint8_t)ALLOCATION_TYPE_DEDICATED;
        m_Alignment = 0;
        m_Size = size;
        m_MemoryTypeIndex = memoryTypeIndex;
        m_SuballocationType = (uint8_t)suballocationType;
        m_MapCount = (pMappedData != VMA_NULL) ? MAP_COUNT_FLAG_PERSISTENT_MAP : 0;
        m_DedicatedAllocation.m_hMemory = hMemory;
        m_DedicatedAllocation.m_pMappedData = pMappedData;
    }

    ALLOCATION_TYPE GetType() const { return (ALLOCATION_TYPE)m_Type; }
    VkDeviceSize GetAlignment() const { return m_Alignment; }
    VkDeviceSize GetSize() const { return m_Size; }
    bool IsUserDataString() const { return (m_Flags & FLAG_USER_DATA_STRING) != 0; }
    void* GetUserData() const { return m_pUserData; }
    void SetUserData(VmaAllocator hAllocator, void* pUserData);
    VmaSuballocationType GetSuballocationType() const { return (VmaSuballocationType)m_SuballocationType; }

    VmaDeviceMemoryBlock* GetBlock() const
    {
        VMA_ASSERT(m_Type == ALLOCATION_TYPE_BLOCK);
        return m_BlockAllocation.m_Block;
    }
    VkDeviceSize GetOffset() const;
    VkDeviceMemory GetMemory() const;
    uint32_t GetMemoryTypeIndex() const { return m_MemoryTypeIndex; }
    bool IsPersistentMap() const { return (m_MapCount & MAP_COUNT_FLAG_PERSISTENT_MAP) != 0; }
    void* GetMappedData() const;
    bool CanBecomeLost() const;
    
    uint32_t GetLastUseFrameIndex() const
    {
        return m_LastUseFrameIndex.load();
    }
    bool CompareExchangeLastUseFrameIndex(uint32_t& expected, uint32_t desired)
    {
        return m_LastUseFrameIndex.compare_exchange_weak(expected, desired);
    }
    /*
    - If hAllocation.LastUseFrameIndex + frameInUseCount < allocator.CurrentFrameIndex,
      makes it lost by setting LastUseFrameIndex = VMA_FRAME_INDEX_LOST and returns true.
    - Else, returns false.
    
    If hAllocation is already lost, assert - you should not call it then.
    If hAllocation was not created with CAN_BECOME_LOST_BIT, assert.
    */
    bool MakeLost(uint32_t currentFrameIndex, uint32_t frameInUseCount);

    void DedicatedAllocCalcStatsInfo(VmaStatInfo& outInfo)
    {
        VMA_ASSERT(m_Type == ALLOCATION_TYPE_DEDICATED);
        outInfo.blockCount = 1;
        outInfo.allocationCount = 1;
        outInfo.unusedRangeCount = 0;
        outInfo.usedBytes = m_Size;
        outInfo.unusedBytes = 0;
        outInfo.allocationSizeMin = outInfo.allocationSizeMax = m_Size;
        outInfo.unusedRangeSizeMin = UINT64_MAX;
        outInfo.unusedRangeSizeMax = 0;
    }

    void BlockAllocMap();
    void BlockAllocUnmap();
    VkResult DedicatedAllocMap(VmaAllocator hAllocator, void** ppData);
    void DedicatedAllocUnmap(VmaAllocator hAllocator);

#if VMA_STATS_STRING_ENABLED
    uint32_t GetCreationFrameIndex() const { return m_CreationFrameIndex; }
    uint32_t GetBufferImageUsage() const { return m_BufferImageUsage; }

    void InitBufferImageUsage(uint32_t bufferImageUsage)
    {
        VMA_ASSERT(m_BufferImageUsage == 0);
        m_BufferImageUsage = bufferImageUsage;
    }

    void PrintParameters(class VmaJsonWriter& json) const;
#endif

private:
    VkDeviceSize m_Alignment;
    VkDeviceSize m_Size;
    void* m_pUserData;
    VMA_ATOMIC_UINT32 m_LastUseFrameIndex;
    uint32_t m_MemoryTypeIndex;
    uint8_t m_Type; // ALLOCATION_TYPE
    uint8_t m_SuballocationType; // VmaSuballocationType
    // Bit 0x80 is set when allocation was created with VMA_ALLOCATION_CREATE_MAPPED_BIT.
    // Bits with mask 0x7F are reference counter for vmaMapMemory()/vmaUnmapMemory().
    uint8_t m_MapCount;
    uint8_t m_Flags; // enum FLAGS

    // Allocation out of VmaDeviceMemoryBlock.
    struct BlockAllocation
    {
        VmaDeviceMemoryBlock* m_Block;
        VkDeviceSize m_Offset;
        bool m_CanBecomeLost;
    };

    // Allocation for an object that has its own private VkDeviceMemory.
    struct DedicatedAllocation
    {
        VkDeviceMemory m_hMemory;
        void* m_pMappedData; // Not null means memory is mapped.
    };

    union
    {
        // Allocation out of VmaDeviceMemoryBlock.
        BlockAllocation m_BlockAllocation;
        // Allocation for an object that has its own private VkDeviceMemory.
        DedicatedAllocation m_DedicatedAllocation;
    };

#if VMA_STATS_STRING_ENABLED
    uint32_t m_CreationFrameIndex;
    uint32_t m_BufferImageUsage; // 0 if unknown.
#endif

    void FreeUserDataString(VmaAllocator hAllocator);
};

/*
Represents a region of VmaDeviceMemoryBlock that is either assigned and returned as
allocated memory block or free.
*/
struct VmaSuballocation
{
    VkDeviceSize offset;
    VkDeviceSize size;
    VmaAllocation hAllocation;
    VmaSuballocationType type;
};

// Comparator for offsets.
struct VmaSuballocationOffsetLess
{
    bool operator()(const VmaSuballocation& lhs, const VmaSuballocation& rhs) const
    {
        return lhs.offset < rhs.offset;
    }
};
struct VmaSuballocationOffsetGreater
{
    bool operator()(const VmaSuballocation& lhs, const VmaSuballocation& rhs) const
    {
        return lhs.offset > rhs.offset;
    }
};

typedef VmaList< VmaSuballocation, VmaStlAllocator<VmaSuballocation> > VmaSuballocationList;

// Cost of one additional allocation lost, as equivalent in bytes.
static const VkDeviceSize VMA_LOST_ALLOCATION_COST = 1048576;

enum class VmaAllocationRequestType
{
    Normal,
    // Used by "Linear" algorithm.
    UpperAddress,
    EndOf1st,
    EndOf2nd,
};

/*
Parameters of planned allocation inside a VmaDeviceMemoryBlock.

If canMakeOtherLost was false:
- item points to a FREE suballocation.
- itemsToMakeLostCount is 0.

If canMakeOtherLost was true:
- item points to first of sequence of suballocations, which are either FREE,
  or point to VmaAllocations that can become lost.
- itemsToMakeLostCount is the number of VmaAllocations that need to be made lost for
  the requested allocation to succeed.
*/
struct VmaAllocationRequest
{
    VkDeviceSize offset;
    VkDeviceSize sumFreeSize; // Sum size of free items that overlap with proposed allocation.
    VkDeviceSize sumItemSize; // Sum size of items to make lost that overlap with proposed allocation.
    VmaSuballocationList::iterator item;
    size_t itemsToMakeLostCount;
    void* customData;
    VmaAllocationRequestType type;

    VkDeviceSize CalcCost() const
    {
        return sumItemSize + itemsToMakeLostCount * VMA_LOST_ALLOCATION_COST;
    }
};

/*
Data structure used for bookkeeping of allocations and unused ranges of memory
in a single VkDeviceMemory block.
*/
class VmaBlockMetadata
{
public:
    VmaBlockMetadata(VmaAllocator hAllocator);
    virtual ~VmaBlockMetadata() { }
    virtual void Init(VkDeviceSize size) { m_Size = size; }

    // Validates all data structures inside this object. If not valid, returns false.
    virtual bool Validate() const = 0;
    VkDeviceSize GetSize() const { return m_Size; }
    virtual size_t GetAllocationCount() const = 0;
    virtual VkDeviceSize GetSumFreeSize() const = 0;
    virtual VkDeviceSize GetUnusedRangeSizeMax() const = 0;
    // Returns true if this block is empty - contains only single free suballocation.
    virtual bool IsEmpty() const = 0;

    virtual void CalcAllocationStatInfo(VmaStatInfo& outInfo) const = 0;
    // Shouldn't modify blockCount.
    virtual void AddPoolStats(VmaPoolStats& inoutStats) const = 0;

#if VMA_STATS_STRING_ENABLED
    virtual void PrintDetailedMap(class VmaJsonWriter& json) const = 0;
#endif

    // Tries to find a place for suballocation with given parameters inside this block.
    // If succeeded, fills pAllocationRequest and returns true.
    // If failed, returns false.
    virtual bool CreateAllocationRequest(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VkDeviceSize bufferImageGranularity,
        VkDeviceSize allocSize,
        VkDeviceSize allocAlignment,
        bool upperAddress,
        VmaSuballocationType allocType,
        bool canMakeOtherLost,
        // Always one of VMA_ALLOCATION_CREATE_STRATEGY_* or VMA_ALLOCATION_INTERNAL_STRATEGY_* flags.
        uint32_t strategy,
        VmaAllocationRequest* pAllocationRequest) = 0;

    virtual bool MakeRequestedAllocationsLost(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VmaAllocationRequest* pAllocationRequest) = 0;

    virtual uint32_t MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount) = 0;

    virtual VkResult CheckCorruption(const void* pBlockData) = 0;

    // Makes actual allocation based on request. Request must already be checked and valid.
    virtual void Alloc(
        const VmaAllocationRequest& request,
        VmaSuballocationType type,
        VkDeviceSize allocSize,
        VmaAllocation hAllocation) = 0;

    // Frees suballocation assigned to given memory region.
    virtual void Free(const VmaAllocation allocation) = 0;
    virtual void FreeAtOffset(VkDeviceSize offset) = 0;

protected:
    const VkAllocationCallbacks* GetAllocationCallbacks() const { return m_pAllocationCallbacks; }

#if VMA_STATS_STRING_ENABLED
    void PrintDetailedMap_Begin(class VmaJsonWriter& json,
        VkDeviceSize unusedBytes,
        size_t allocationCount,
        size_t unusedRangeCount) const;
    void PrintDetailedMap_Allocation(class VmaJsonWriter& json,
        VkDeviceSize offset,
        VmaAllocation hAllocation) const;
    void PrintDetailedMap_UnusedRange(class VmaJsonWriter& json,
        VkDeviceSize offset,
        VkDeviceSize size) const;
    void PrintDetailedMap_End(class VmaJsonWriter& json) const;
#endif

private:
    VkDeviceSize m_Size;
    const VkAllocationCallbacks* m_pAllocationCallbacks;
};

#define VMA_VALIDATE(cond) do { if(!(cond)) { \
        VMA_ASSERT(0 && "Validation failed: " #cond); \
        return false; \
    } } while(false)

class VmaBlockMetadata_Generic : public VmaBlockMetadata
{
    VMA_CLASS_NO_COPY(VmaBlockMetadata_Generic)
public:
    VmaBlockMetadata_Generic(VmaAllocator hAllocator);
    virtual ~VmaBlockMetadata_Generic();
    virtual void Init(VkDeviceSize size);

    virtual bool Validate() const;
    virtual size_t GetAllocationCount() const { return m_Suballocations.size() - m_FreeCount; }
    virtual VkDeviceSize GetSumFreeSize() const { return m_SumFreeSize; }
    virtual VkDeviceSize GetUnusedRangeSizeMax() const;
    virtual bool IsEmpty() const;

    virtual void CalcAllocationStatInfo(VmaStatInfo& outInfo) const;
    virtual void AddPoolStats(VmaPoolStats& inoutStats) const;

#if VMA_STATS_STRING_ENABLED
    virtual void PrintDetailedMap(class VmaJsonWriter& json) const;
#endif

    virtual bool CreateAllocationRequest(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VkDeviceSize bufferImageGranularity,
        VkDeviceSize allocSize,
        VkDeviceSize allocAlignment,
        bool upperAddress,
        VmaSuballocationType allocType,
        bool canMakeOtherLost,
        uint32_t strategy,
        VmaAllocationRequest* pAllocationRequest);

    virtual bool MakeRequestedAllocationsLost(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VmaAllocationRequest* pAllocationRequest);

    virtual uint32_t MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount);

    virtual VkResult CheckCorruption(const void* pBlockData);

    virtual void Alloc(
        const VmaAllocationRequest& request,
        VmaSuballocationType type,
        VkDeviceSize allocSize,
        VmaAllocation hAllocation);

    virtual void Free(const VmaAllocation allocation);
    virtual void FreeAtOffset(VkDeviceSize offset);

    ////////////////////////////////////////////////////////////////////////////////
    // For defragmentation
    
    bool IsBufferImageGranularityConflictPossible(
        VkDeviceSize bufferImageGranularity,
        VmaSuballocationType& inOutPrevSuballocType) const;

private:
    friend class VmaDefragmentationAlgorithm_Generic;
    friend class VmaDefragmentationAlgorithm_Fast;

    uint32_t m_FreeCount;
    VkDeviceSize m_SumFreeSize;
    VmaSuballocationList m_Suballocations;
    // Suballocations that are free and have size greater than certain threshold.
    // Sorted by size, ascending.
    VmaVector< VmaSuballocationList::iterator, VmaStlAllocator< VmaSuballocationList::iterator > > m_FreeSuballocationsBySize;

    bool ValidateFreeSuballocationList() const;

    // Checks if requested suballocation with given parameters can be placed in given pFreeSuballocItem.
    // If yes, fills pOffset and returns true. If no, returns false.
    bool CheckAllocation(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VkDeviceSize bufferImageGranularity,
        VkDeviceSize allocSize,
        VkDeviceSize allocAlignment,
        VmaSuballocationType allocType,
        VmaSuballocationList::const_iterator suballocItem,
        bool canMakeOtherLost,
        VkDeviceSize* pOffset,
        size_t* itemsToMakeLostCount,
        VkDeviceSize* pSumFreeSize,
        VkDeviceSize* pSumItemSize) const;
    // Given free suballocation, it merges it with following one, which must also be free.
    void MergeFreeWithNext(VmaSuballocationList::iterator item);
    // Releases given suballocation, making it free.
    // Merges it with adjacent free suballocations if applicable.
    // Returns iterator to new free suballocation at this place.
    VmaSuballocationList::iterator FreeSuballocation(VmaSuballocationList::iterator suballocItem);
    // Given free suballocation, it inserts it into sorted list of
    // m_FreeSuballocationsBySize if it's suitable.
    void RegisterFreeSuballocation(VmaSuballocationList::iterator item);
    // Given free suballocation, it removes it from sorted list of
    // m_FreeSuballocationsBySize if it's suitable.
    void UnregisterFreeSuballocation(VmaSuballocationList::iterator item);
};

/*
Allocations and their references in internal data structure look like this:

if(m_2ndVectorMode == SECOND_VECTOR_EMPTY):

        0 +-------+
          |       |
          |       |
          |       |
          +-------+
          | Alloc |  1st[m_1stNullItemsBeginCount]
          +-------+
          | Alloc |  1st[m_1stNullItemsBeginCount + 1]
          +-------+
          |  ...  |
          +-------+
          | Alloc |  1st[1st.size() - 1]
          +-------+
          |       |
          |       |
          |       |
GetSize() +-------+

if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER):

        0 +-------+
          | Alloc |  2nd[0]
          +-------+
          | Alloc |  2nd[1]
          +-------+
          |  ...  |
          +-------+
          | Alloc |  2nd[2nd.size() - 1]
          +-------+
          |       |
          |       |
          |       |
          +-------+
          | Alloc |  1st[m_1stNullItemsBeginCount]
          +-------+
          | Alloc |  1st[m_1stNullItemsBeginCount + 1]
          +-------+
          |  ...  |
          +-------+
          | Alloc |  1st[1st.size() - 1]
          +-------+
          |       |
GetSize() +-------+

if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK):

        0 +-------+
          |       |
          |       |
          |       |
          +-------+
          | Alloc |  1st[m_1stNullItemsBeginCount]
          +-------+
          | Alloc |  1st[m_1stNullItemsBeginCount + 1]
          +-------+
          |  ...  |
          +-------+
          | Alloc |  1st[1st.size() - 1]
          +-------+
          |       |
          |       |
          |       |
          +-------+
          | Alloc |  2nd[2nd.size() - 1]
          +-------+
          |  ...  |
          +-------+
          | Alloc |  2nd[1]
          +-------+
          | Alloc |  2nd[0]
GetSize() +-------+

*/
class VmaBlockMetadata_Linear : public VmaBlockMetadata
{
    VMA_CLASS_NO_COPY(VmaBlockMetadata_Linear)
public:
    VmaBlockMetadata_Linear(VmaAllocator hAllocator);
    virtual ~VmaBlockMetadata_Linear();
    virtual void Init(VkDeviceSize size);

    virtual bool Validate() const;
    virtual size_t GetAllocationCount() const;
    virtual VkDeviceSize GetSumFreeSize() const { return m_SumFreeSize; }
    virtual VkDeviceSize GetUnusedRangeSizeMax() const;
    virtual bool IsEmpty() const { return GetAllocationCount() == 0; }

    virtual void CalcAllocationStatInfo(VmaStatInfo& outInfo) const;
    virtual void AddPoolStats(VmaPoolStats& inoutStats) const;

#if VMA_STATS_STRING_ENABLED
    virtual void PrintDetailedMap(class VmaJsonWriter& json) const;
#endif

    virtual bool CreateAllocationRequest(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VkDeviceSize bufferImageGranularity,
        VkDeviceSize allocSize,
        VkDeviceSize allocAlignment,
        bool upperAddress,
        VmaSuballocationType allocType,
        bool canMakeOtherLost,
        uint32_t strategy,
        VmaAllocationRequest* pAllocationRequest);

    virtual bool MakeRequestedAllocationsLost(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VmaAllocationRequest* pAllocationRequest);

    virtual uint32_t MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount);

    virtual VkResult CheckCorruption(const void* pBlockData);

    virtual void Alloc(
        const VmaAllocationRequest& request,
        VmaSuballocationType type,
        VkDeviceSize allocSize,
        VmaAllocation hAllocation);

    virtual void Free(const VmaAllocation allocation);
    virtual void FreeAtOffset(VkDeviceSize offset);

private:
    /*
    There are two suballocation vectors, used in ping-pong way.
    The one with index m_1stVectorIndex is called 1st.
    The one with index (m_1stVectorIndex ^ 1) is called 2nd.
    2nd can be non-empty only when 1st is not empty.
    When 2nd is not empty, m_2ndVectorMode indicates its mode of operation.
    */
    typedef VmaVector< VmaSuballocation, VmaStlAllocator<VmaSuballocation> > SuballocationVectorType;

    enum SECOND_VECTOR_MODE
    {
        SECOND_VECTOR_EMPTY,
        /*
        Suballocations in 2nd vector are created later than the ones in 1st, but they
        all have smaller offset.
        */
        SECOND_VECTOR_RING_BUFFER,
        /*
        Suballocations in 2nd vector are upper side of double stack.
        They all have offsets higher than those in 1st vector.
        Top of this stack means smaller offsets, but higher indices in this vector.
        */
        SECOND_VECTOR_DOUBLE_STACK,
    };

    VkDeviceSize m_SumFreeSize;
    SuballocationVectorType m_Suballocations0, m_Suballocations1;
    uint32_t m_1stVectorIndex;
    SECOND_VECTOR_MODE m_2ndVectorMode;

    SuballocationVectorType& AccessSuballocations1st() { return m_1stVectorIndex ? m_Suballocations1 : m_Suballocations0; }
    SuballocationVectorType& AccessSuballocations2nd() { return m_1stVectorIndex ? m_Suballocations0 : m_Suballocations1; }
    const SuballocationVectorType& AccessSuballocations1st() const { return m_1stVectorIndex ? m_Suballocations1 : m_Suballocations0; }
    const SuballocationVectorType& AccessSuballocations2nd() const { return m_1stVectorIndex ? m_Suballocations0 : m_Suballocations1; }
    
    // Number of items in 1st vector with hAllocation = null at the beginning.
    size_t m_1stNullItemsBeginCount;
    // Number of other items in 1st vector with hAllocation = null somewhere in the middle.
    size_t m_1stNullItemsMiddleCount;
    // Number of items in 2nd vector with hAllocation = null.
    size_t m_2ndNullItemsCount;

    bool ShouldCompact1st() const;
    void CleanupAfterFree();

    bool CreateAllocationRequest_LowerAddress(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VkDeviceSize bufferImageGranularity,
        VkDeviceSize allocSize,
        VkDeviceSize allocAlignment,
        VmaSuballocationType allocType,
        bool canMakeOtherLost,
        uint32_t strategy,
        VmaAllocationRequest* pAllocationRequest);
    bool CreateAllocationRequest_UpperAddress(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VkDeviceSize bufferImageGranularity,
        VkDeviceSize allocSize,
        VkDeviceSize allocAlignment,
        VmaSuballocationType allocType,
        bool canMakeOtherLost,
        uint32_t strategy,
        VmaAllocationRequest* pAllocationRequest);
};

/*
- GetSize() is the original size of allocated memory block.
- m_UsableSize is this size aligned down to a power of two.
  All allocations and calculations happen relative to m_UsableSize.
- GetUnusableSize() is the difference between them.
  It is repoted as separate, unused range, not available for allocations.

Node at level 0 has size = m_UsableSize.
Each next level contains nodes with size 2 times smaller than current level.
m_LevelCount is the maximum number of levels to use in the current object.
*/
class VmaBlockMetadata_Buddy : public VmaBlockMetadata
{
    VMA_CLASS_NO_COPY(VmaBlockMetadata_Buddy)
public:
    VmaBlockMetadata_Buddy(VmaAllocator hAllocator);
    virtual ~VmaBlockMetadata_Buddy();
    virtual void Init(VkDeviceSize size);

    virtual bool Validate() const;
    virtual size_t GetAllocationCount() const { return m_AllocationCount; }
    virtual VkDeviceSize GetSumFreeSize() const { return m_SumFreeSize + GetUnusableSize(); }
    virtual VkDeviceSize GetUnusedRangeSizeMax() const;
    virtual bool IsEmpty() const { return m_Root->type == Node::TYPE_FREE; }

    virtual void CalcAllocationStatInfo(VmaStatInfo& outInfo) const;
    virtual void AddPoolStats(VmaPoolStats& inoutStats) const;

#if VMA_STATS_STRING_ENABLED
    virtual void PrintDetailedMap(class VmaJsonWriter& json) const;
#endif

    virtual bool CreateAllocationRequest(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VkDeviceSize bufferImageGranularity,
        VkDeviceSize allocSize,
        VkDeviceSize allocAlignment,
        bool upperAddress,
        VmaSuballocationType allocType,
        bool canMakeOtherLost,
        uint32_t strategy,
        VmaAllocationRequest* pAllocationRequest);

    virtual bool MakeRequestedAllocationsLost(
        uint32_t currentFrameIndex,
        uint32_t frameInUseCount,
        VmaAllocationRequest* pAllocationRequest);

    virtual uint32_t MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount);

    virtual VkResult CheckCorruption(const void* pBlockData) { return VK_ERROR_FEATURE_NOT_PRESENT; }

    virtual void Alloc(
        const VmaAllocationRequest& request,
        VmaSuballocationType type,
        VkDeviceSize allocSize,
        VmaAllocation hAllocation);

    virtual void Free(const VmaAllocation allocation) { FreeAtOffset(allocation, allocation->GetOffset()); }
    virtual void FreeAtOffset(VkDeviceSize offset) { FreeAtOffset(VMA_NULL, offset); }

private:
    static const VkDeviceSize MIN_NODE_SIZE = 32;
    static const size_t MAX_LEVELS = 30;

    struct ValidationContext
    {
        size_t calculatedAllocationCount;
        size_t calculatedFreeCount;
        VkDeviceSize calculatedSumFreeSize;

        ValidationContext() :
            calculatedAllocationCount(0),
            calculatedFreeCount(0),
            calculatedSumFreeSize(0) { }
    };

    struct Node
    {
        VkDeviceSize offset;
        enum TYPE
        {
            TYPE_FREE,
            TYPE_ALLOCATION,
            TYPE_SPLIT,
            TYPE_COUNT
        } type;
        Node* parent;
        Node* buddy;

        union
        {
            struct
            {
                Node* prev;
                Node* next;
            } free;
            struct
            {
                VmaAllocation alloc;
            } allocation;
            struct
            {
                Node* leftChild;
            } split;
        };
    };

    // Size of the memory block aligned down to a power of two.
    VkDeviceSize m_UsableSize;
    uint32_t m_LevelCount;

    Node* m_Root;
    struct {
        Node* front;
        Node* back;
    } m_FreeList[MAX_LEVELS];
    // Number of nodes in the tree with type == TYPE_ALLOCATION.
    size_t m_AllocationCount;
    // Number of nodes in the tree with type == TYPE_FREE.
    size_t m_FreeCount;
    // This includes space wasted due to internal fragmentation. Doesn't include unusable size.
    VkDeviceSize m_SumFreeSize;

    VkDeviceSize GetUnusableSize() const { return GetSize() - m_UsableSize; }
    void DeleteNode(Node* node);
    bool ValidateNode(ValidationContext& ctx, const Node* parent, const Node* curr, uint32_t level, VkDeviceSize levelNodeSize) const;
    uint32_t AllocSizeToLevel(VkDeviceSize allocSize) const;
    inline VkDeviceSize LevelToNodeSize(uint32_t level) const { return m_UsableSize >> level; }
    // Alloc passed just for validation. Can be null.
    void FreeAtOffset(VmaAllocation alloc, VkDeviceSize offset);
    void CalcAllocationStatInfoNode(VmaStatInfo& outInfo, const Node* node, VkDeviceSize levelNodeSize) const;
    // Adds node to the front of FreeList at given level.
    // node->type must be FREE.
    // node->free.prev, next can be undefined.
    void AddToFreeListFront(uint32_t level, Node* node);
    // Removes node from FreeList at given level.
    // node->type must be FREE.
    // node->free.prev, next stay untouched.
    void RemoveFromFreeList(uint32_t level, Node* node);

#if VMA_STATS_STRING_ENABLED
    void PrintDetailedMapNode(class VmaJsonWriter& json, const Node* node, VkDeviceSize levelNodeSize) const;
#endif
};

/*
Represents a single block of device memory (`VkDeviceMemory`) with all the
data about its regions (aka suballocations, #VmaAllocation), assigned and free.

Thread-safety: This class must be externally synchronized.
*/
class VmaDeviceMemoryBlock
{
    VMA_CLASS_NO_COPY(VmaDeviceMemoryBlock)
public:
    VmaBlockMetadata* m_pMetadata;

    VmaDeviceMemoryBlock(VmaAllocator hAllocator);

    ~VmaDeviceMemoryBlock()
    {
        VMA_ASSERT(m_MapCount == 0 && "VkDeviceMemory block is being destroyed while it is still mapped.");
        VMA_ASSERT(m_hMemory == VK_NULL_HANDLE);
    }

    // Always call after construction.
    void Init(
        VmaAllocator hAllocator,
        VmaPool hParentPool,
        uint32_t newMemoryTypeIndex,
        VkDeviceMemory newMemory,
        VkDeviceSize newSize,
        uint32_t id,
        uint32_t algorithm);
    // Always call before destruction.
    void Destroy(VmaAllocator allocator);
    
    VmaPool GetParentPool() const { return m_hParentPool; }
    VkDeviceMemory GetDeviceMemory() const { return m_hMemory; }
    uint32_t GetMemoryTypeIndex() const { return m_MemoryTypeIndex; }
    uint32_t GetId() const { return m_Id; }
    void* GetMappedData() const { return m_pMappedData; }

    // Validates all data structures inside this object. If not valid, returns false.
    bool Validate() const;

    VkResult CheckCorruption(VmaAllocator hAllocator);

    // ppData can be null.
    VkResult Map(VmaAllocator hAllocator, uint32_t count, void** ppData);
    void Unmap(VmaAllocator hAllocator, uint32_t count);

    VkResult WriteMagicValueAroundAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize);
    VkResult ValidateMagicValueAroundAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize);

    VkResult BindBufferMemory(
        const VmaAllocator hAllocator,
        const VmaAllocation hAllocation,
        VkDeviceSize allocationLocalOffset,
        VkBuffer hBuffer,
        const void* pNext);
    VkResult BindImageMemory(
        const VmaAllocator hAllocator,
        const VmaAllocation hAllocation,
        VkDeviceSize allocationLocalOffset,
        VkImage hImage,
        const void* pNext);

private:
    VmaPool m_hParentPool; // VK_NULL_HANDLE if not belongs to custom pool.
    uint32_t m_MemoryTypeIndex;
    uint32_t m_Id;
    VkDeviceMemory m_hMemory;

    /*
    Protects access to m_hMemory so it's not used by multiple threads simultaneously, e.g. vkMapMemory, vkBindBufferMemory.
    Also protects m_MapCount, m_pMappedData.
    Allocations, deallocations, any change in m_pMetadata is protected by parent's VmaBlockVector::m_Mutex.
    */
    VMA_MUTEX m_Mutex;
    uint32_t m_MapCount;
    void* m_pMappedData;
};

struct VmaPointerLess
{
    bool operator()(const void* lhs, const void* rhs) const
    {
        return lhs < rhs;
    }
};

struct VmaDefragmentationMove
{
    size_t srcBlockIndex;
    size_t dstBlockIndex;
    VkDeviceSize srcOffset;
    VkDeviceSize dstOffset;
    VkDeviceSize size;
};

class VmaDefragmentationAlgorithm;

/*
Sequence of VmaDeviceMemoryBlock. Represents memory blocks allocated for a specific
Vulkan memory type.

Synchronized internally with a mutex.
*/
struct VmaBlockVector
{
    VMA_CLASS_NO_COPY(VmaBlockVector)
public:
    VmaBlockVector(
        VmaAllocator hAllocator,
        VmaPool hParentPool,
        uint32_t memoryTypeIndex,
        VkDeviceSize preferredBlockSize,
        size_t minBlockCount,
        size_t maxBlockCount,
        VkDeviceSize bufferImageGranularity,
        uint32_t frameInUseCount,
        bool explicitBlockSize,
        uint32_t algorithm);
    ~VmaBlockVector();

    VkResult CreateMinBlocks();

    VmaAllocator GetAllocator() const { return m_hAllocator; }
    VmaPool GetParentPool() const { return m_hParentPool; }
    bool IsCustomPool() const { return m_hParentPool != VMA_NULL; }
    uint32_t GetMemoryTypeIndex() const { return m_MemoryTypeIndex; }
    VkDeviceSize GetPreferredBlockSize() const { return m_PreferredBlockSize; }
    VkDeviceSize GetBufferImageGranularity() const { return m_BufferImageGranularity; }
    uint32_t GetFrameInUseCount() const { return m_FrameInUseCount; }
    uint32_t GetAlgorithm() const { return m_Algorithm; }

    void GetPoolStats(VmaPoolStats* pStats);

    bool IsEmpty();
    bool IsCorruptionDetectionEnabled() const;

    VkResult Allocate(
        uint32_t currentFrameIndex,
        VkDeviceSize size,
        VkDeviceSize alignment,
        const VmaAllocationCreateInfo& createInfo,
        VmaSuballocationType suballocType,
        size_t allocationCount,
        VmaAllocation* pAllocations);

    void Free(const VmaAllocation hAllocation);

    // Adds statistics of this BlockVector to pStats.
    void AddStats(VmaStats* pStats);

#if VMA_STATS_STRING_ENABLED
    void PrintDetailedMap(class VmaJsonWriter& json);
#endif

    void MakePoolAllocationsLost(
        uint32_t currentFrameIndex,
        size_t* pLostAllocationCount);
    VkResult CheckCorruption();

    // Saves results in pCtx->res.
    void Defragment(
        class VmaBlockVectorDefragmentationContext* pCtx,
        VmaDefragmentationStats* pStats,
        VkDeviceSize& maxCpuBytesToMove, uint32_t& maxCpuAllocationsToMove,
        VkDeviceSize& maxGpuBytesToMove, uint32_t& maxGpuAllocationsToMove,
        VkCommandBuffer commandBuffer);
    void DefragmentationEnd(
        class VmaBlockVectorDefragmentationContext* pCtx,
        VmaDefragmentationStats* pStats);

    ////////////////////////////////////////////////////////////////////////////////
    // To be used only while the m_Mutex is locked. Used during defragmentation.

    size_t GetBlockCount() const { return m_Blocks.size(); }
    VmaDeviceMemoryBlock* GetBlock(size_t index) const { return m_Blocks[index]; }
    size_t CalcAllocationCount() const;
    bool IsBufferImageGranularityConflictPossible() const;

private:
    friend class VmaDefragmentationAlgorithm_Generic;

    const VmaAllocator m_hAllocator;
    const VmaPool m_hParentPool;
    const uint32_t m_MemoryTypeIndex;
    const VkDeviceSize m_PreferredBlockSize;
    const size_t m_MinBlockCount;
    const size_t m_MaxBlockCount;
    const VkDeviceSize m_BufferImageGranularity;
    const uint32_t m_FrameInUseCount;
    const bool m_ExplicitBlockSize;
    const uint32_t m_Algorithm;
    VMA_RW_MUTEX m_Mutex;

    /* There can be at most one allocation that is completely empty (except when minBlockCount > 0) -
    a hysteresis to avoid pessimistic case of alternating creation and destruction of a VkDeviceMemory. */
    bool m_HasEmptyBlock;
    // Incrementally sorted by sumFreeSize, ascending.
    VmaVector< VmaDeviceMemoryBlock*, VmaStlAllocator<VmaDeviceMemoryBlock*> > m_Blocks;
    uint32_t m_NextBlockId;

    VkDeviceSize CalcMaxBlockSize() const;

    // Finds and removes given block from vector.
    void Remove(VmaDeviceMemoryBlock* pBlock);

    // Performs single step in sorting m_Blocks. They may not be fully sorted
    // after this call.
    void IncrementallySortBlocks();

    VkResult AllocatePage(
        uint32_t currentFrameIndex,
        VkDeviceSize size,
        VkDeviceSize alignment,
        const VmaAllocationCreateInfo& createInfo,
        VmaSuballocationType suballocType,
        VmaAllocation* pAllocation);

    // To be used only without CAN_MAKE_OTHER_LOST flag.
    VkResult AllocateFromBlock(
        VmaDeviceMemoryBlock* pBlock,
        uint32_t currentFrameIndex,
        VkDeviceSize size,
        VkDeviceSize alignment,
        VmaAllocationCreateFlags allocFlags,
        void* pUserData,
        VmaSuballocationType suballocType,
        uint32_t strategy,
        VmaAllocation* pAllocation);

    VkResult CreateBlock(VkDeviceSize blockSize, size_t* pNewBlockIndex);

    // Saves result to pCtx->res.
    void ApplyDefragmentationMovesCpu(
        class VmaBlockVectorDefragmentationContext* pDefragCtx,
        const VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves);
    // Saves result to pCtx->res.
    void ApplyDefragmentationMovesGpu(
        class VmaBlockVectorDefragmentationContext* pDefragCtx,
        const VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
        VkCommandBuffer commandBuffer);

    /*
    Used during defragmentation. pDefragmentationStats is optional. It's in/out
    - updated with new data.
    */
    void FreeEmptyBlocks(VmaDefragmentationStats* pDefragmentationStats);

    void UpdateHasEmptyBlock();
};

struct VmaPool_T
{
    VMA_CLASS_NO_COPY(VmaPool_T)
public:
    VmaBlockVector m_BlockVector;

    VmaPool_T(
        VmaAllocator hAllocator,
        const VmaPoolCreateInfo& createInfo,
        VkDeviceSize preferredBlockSize);
    ~VmaPool_T();

    uint32_t GetId() const { return m_Id; }
    void SetId(uint32_t id) { VMA_ASSERT(m_Id == 0); m_Id = id; }

    const char* GetName() const { return m_Name; }
    void SetName(const char* pName);

#if VMA_STATS_STRING_ENABLED
    //void PrintDetailedMap(class VmaStringBuilder& sb);
#endif

private:
    uint32_t m_Id;
    char* m_Name;
};

/*
Performs defragmentation:

- Updates `pBlockVector->m_pMetadata`.
- Updates allocations by calling ChangeBlockAllocation() or ChangeOffset().
- Does not move actual data, only returns requested moves as `moves`.
*/
class VmaDefragmentationAlgorithm
{
    VMA_CLASS_NO_COPY(VmaDefragmentationAlgorithm)
public:
    VmaDefragmentationAlgorithm(
        VmaAllocator hAllocator,
        VmaBlockVector* pBlockVector,
        uint32_t currentFrameIndex) :
        m_hAllocator(hAllocator),
        m_pBlockVector(pBlockVector),
        m_CurrentFrameIndex(currentFrameIndex)
    {
    }
    virtual ~VmaDefragmentationAlgorithm()
    {
    }

    virtual void AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged) = 0;
    virtual void AddAll() = 0;

    virtual VkResult Defragment(
        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
        VkDeviceSize maxBytesToMove,
        uint32_t maxAllocationsToMove) = 0;

    virtual VkDeviceSize GetBytesMoved() const = 0;
    virtual uint32_t GetAllocationsMoved() const = 0;

protected:
    VmaAllocator const m_hAllocator;
    VmaBlockVector* const m_pBlockVector;
    const uint32_t m_CurrentFrameIndex;

    struct AllocationInfo
    {
        VmaAllocation m_hAllocation;
        VkBool32* m_pChanged;

        AllocationInfo() :
            m_hAllocation(VK_NULL_HANDLE),
            m_pChanged(VMA_NULL)
        {
        }
        AllocationInfo(VmaAllocation hAlloc, VkBool32* pChanged) :
            m_hAllocation(hAlloc),
            m_pChanged(pChanged)
        {
        }
    };
};

class VmaDefragmentationAlgorithm_Generic : public VmaDefragmentationAlgorithm
{
    VMA_CLASS_NO_COPY(VmaDefragmentationAlgorithm_Generic)
public:
    VmaDefragmentationAlgorithm_Generic(
        VmaAllocator hAllocator,
        VmaBlockVector* pBlockVector,
        uint32_t currentFrameIndex,
        bool overlappingMoveSupported);
    virtual ~VmaDefragmentationAlgorithm_Generic();

    virtual void AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged);
    virtual void AddAll() { m_AllAllocations = true; }

    virtual VkResult Defragment(
        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
        VkDeviceSize maxBytesToMove,
        uint32_t maxAllocationsToMove);

    virtual VkDeviceSize GetBytesMoved() const { return m_BytesMoved; }
    virtual uint32_t GetAllocationsMoved() const { return m_AllocationsMoved; }

private:
    uint32_t m_AllocationCount;
    bool m_AllAllocations;

    VkDeviceSize m_BytesMoved;
    uint32_t m_AllocationsMoved;

    struct AllocationInfoSizeGreater
    {
        bool operator()(const AllocationInfo& lhs, const AllocationInfo& rhs) const
        {
            return lhs.m_hAllocation->GetSize() > rhs.m_hAllocation->GetSize();
        }
    };

    struct AllocationInfoOffsetGreater
    {
        bool operator()(const AllocationInfo& lhs, const AllocationInfo& rhs) const
        {
            return lhs.m_hAllocation->GetOffset() > rhs.m_hAllocation->GetOffset();
        }
    };

    struct BlockInfo
    {
        size_t m_OriginalBlockIndex;
        VmaDeviceMemoryBlock* m_pBlock;
        bool m_HasNonMovableAllocations;
        VmaVector< AllocationInfo, VmaStlAllocator<AllocationInfo> > m_Allocations;

        BlockInfo(const VkAllocationCallbacks* pAllocationCallbacks) :
            m_OriginalBlockIndex(SIZE_MAX),
            m_pBlock(VMA_NULL),
            m_HasNonMovableAllocations(true),
            m_Allocations(pAllocationCallbacks)
        {
        }

        void CalcHasNonMovableAllocations()
        {
            const size_t blockAllocCount = m_pBlock->m_pMetadata->GetAllocationCount();
            const size_t defragmentAllocCount = m_Allocations.size();
            m_HasNonMovableAllocations = blockAllocCount != defragmentAllocCount;
        }

        void SortAllocationsBySizeDescending()
        {
            VMA_SORT(m_Allocations.begin(), m_Allocations.end(), AllocationInfoSizeGreater());
        }

        void SortAllocationsByOffsetDescending()
        {
            VMA_SORT(m_Allocations.begin(), m_Allocations.end(), AllocationInfoOffsetGreater());
        }
    };

    struct BlockPointerLess
    {
        bool operator()(const BlockInfo* pLhsBlockInfo, const VmaDeviceMemoryBlock* pRhsBlock) const
        {
            return pLhsBlockInfo->m_pBlock < pRhsBlock;
        }
        bool operator()(const BlockInfo* pLhsBlockInfo, const BlockInfo* pRhsBlockInfo) const
        {
            return pLhsBlockInfo->m_pBlock < pRhsBlockInfo->m_pBlock;
        }
    };

    // 1. Blocks with some non-movable allocations go first.
    // 2. Blocks with smaller sumFreeSize go first.
    struct BlockInfoCompareMoveDestination
    {
        bool operator()(const BlockInfo* pLhsBlockInfo, const BlockInfo* pRhsBlockInfo) const
        {
            if(pLhsBlockInfo->m_HasNonMovableAllocations && !pRhsBlockInfo->m_HasNonMovableAllocations)
            {
                return true;
            }
            if(!pLhsBlockInfo->m_HasNonMovableAllocations && pRhsBlockInfo->m_HasNonMovableAllocations)
            {
                return false;
            }
            if(pLhsBlockInfo->m_pBlock->m_pMetadata->GetSumFreeSize() < pRhsBlockInfo->m_pBlock->m_pMetadata->GetSumFreeSize())
            {
                return true;
            }
            return false;
        }
    };

    typedef VmaVector< BlockInfo*, VmaStlAllocator<BlockInfo*> > BlockInfoVector;
    BlockInfoVector m_Blocks;

    VkResult DefragmentRound(
        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
        VkDeviceSize maxBytesToMove,
        uint32_t maxAllocationsToMove);

    size_t CalcBlocksWithNonMovableCount() const;

    static bool MoveMakesSense(
        size_t dstBlockIndex, VkDeviceSize dstOffset,
        size_t srcBlockIndex, VkDeviceSize srcOffset);
};

class VmaDefragmentationAlgorithm_Fast : public VmaDefragmentationAlgorithm
{
    VMA_CLASS_NO_COPY(VmaDefragmentationAlgorithm_Fast)
public:
    VmaDefragmentationAlgorithm_Fast(
        VmaAllocator hAllocator,
        VmaBlockVector* pBlockVector,
        uint32_t currentFrameIndex,
        bool overlappingMoveSupported);
    virtual ~VmaDefragmentationAlgorithm_Fast();

    virtual void AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged) { ++m_AllocationCount; }
    virtual void AddAll() { m_AllAllocations = true; }

    virtual VkResult Defragment(
        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
        VkDeviceSize maxBytesToMove,
        uint32_t maxAllocationsToMove);

    virtual VkDeviceSize GetBytesMoved() const { return m_BytesMoved; }
    virtual uint32_t GetAllocationsMoved() const { return m_AllocationsMoved; }

private:
    struct BlockInfo
    {
        size_t origBlockIndex;
    };

    class FreeSpaceDatabase
    {
    public:
        FreeSpaceDatabase()
        {
            FreeSpace s = {};
            s.blockInfoIndex = SIZE_MAX;
            for(size_t i = 0; i < MAX_COUNT; ++i)
            {
                m_FreeSpaces[i] = s;
            }
        }

        void Register(size_t blockInfoIndex, VkDeviceSize offset, VkDeviceSize size)
        {
            if(size < VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
            {
                return;
            }

            // Find first invalid or the smallest structure.
            size_t bestIndex = SIZE_MAX;
            for(size_t i = 0; i < MAX_COUNT; ++i)
            {
                // Empty structure.
                if(m_FreeSpaces[i].blockInfoIndex == SIZE_MAX)
                {
                    bestIndex = i;
                    break;
                }
                if(m_FreeSpaces[i].size < size &&
                    (bestIndex == SIZE_MAX || m_FreeSpaces[bestIndex].size > m_FreeSpaces[i].size))
                {
                    bestIndex = i;
                }
            }

            if(bestIndex != SIZE_MAX)
            {
                m_FreeSpaces[bestIndex].blockInfoIndex = blockInfoIndex;
                m_FreeSpaces[bestIndex].offset = offset;
                m_FreeSpaces[bestIndex].size = size;
            }
        }

        bool Fetch(VkDeviceSize alignment, VkDeviceSize size,
            size_t& outBlockInfoIndex, VkDeviceSize& outDstOffset)
        {
            size_t bestIndex = SIZE_MAX;
            VkDeviceSize bestFreeSpaceAfter = 0;
            for(size_t i = 0; i < MAX_COUNT; ++i)
            {
                // Structure is valid.
                if(m_FreeSpaces[i].blockInfoIndex != SIZE_MAX)
                {
                    const VkDeviceSize dstOffset = VmaAlignUp(m_FreeSpaces[i].offset, alignment);
                    // Allocation fits into this structure.
                    if(dstOffset + size <= m_FreeSpaces[i].offset + m_FreeSpaces[i].size)
                    {
                        const VkDeviceSize freeSpaceAfter = (m_FreeSpaces[i].offset + m_FreeSpaces[i].size) -
                            (dstOffset + size);
                        if(bestIndex == SIZE_MAX || freeSpaceAfter > bestFreeSpaceAfter)
                        {
                            bestIndex = i;
                            bestFreeSpaceAfter = freeSpaceAfter;
                        }
                    }
                }
            }
            
            if(bestIndex != SIZE_MAX)
            {
                outBlockInfoIndex = m_FreeSpaces[bestIndex].blockInfoIndex;
                outDstOffset = VmaAlignUp(m_FreeSpaces[bestIndex].offset, alignment);

                if(bestFreeSpaceAfter >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
                {
                    // Leave this structure for remaining empty space.
                    const VkDeviceSize alignmentPlusSize = (outDstOffset - m_FreeSpaces[bestIndex].offset) + size;
                    m_FreeSpaces[bestIndex].offset += alignmentPlusSize;
                    m_FreeSpaces[bestIndex].size -= alignmentPlusSize;
                }
                else
                {
                    // This structure becomes invalid.
                    m_FreeSpaces[bestIndex].blockInfoIndex = SIZE_MAX;
                }

                return true;
            }

            return false;
        }

    private:
        static const size_t MAX_COUNT = 4;

        struct FreeSpace
        {
            size_t blockInfoIndex; // SIZE_MAX means this structure is invalid.
            VkDeviceSize offset;
            VkDeviceSize size;
        } m_FreeSpaces[MAX_COUNT];
    };

    const bool m_OverlappingMoveSupported;

    uint32_t m_AllocationCount;
    bool m_AllAllocations;

    VkDeviceSize m_BytesMoved;
    uint32_t m_AllocationsMoved;

    VmaVector< BlockInfo, VmaStlAllocator<BlockInfo> > m_BlockInfos;

    void PreprocessMetadata();
    void PostprocessMetadata();
    void InsertSuballoc(VmaBlockMetadata_Generic* pMetadata, const VmaSuballocation& suballoc);
};

struct VmaBlockDefragmentationContext
{
    enum BLOCK_FLAG
    {
        BLOCK_FLAG_USED = 0x00000001,
    };
    uint32_t flags;
    VkBuffer hBuffer;
};

class VmaBlockVectorDefragmentationContext
{
    VMA_CLASS_NO_COPY(VmaBlockVectorDefragmentationContext)
public:
    VkResult res;
    bool mutexLocked;
    VmaVector< VmaBlockDefragmentationContext, VmaStlAllocator<VmaBlockDefragmentationContext> > blockContexts;

    VmaBlockVectorDefragmentationContext(
        VmaAllocator hAllocator,
        VmaPool hCustomPool, // Optional.
        VmaBlockVector* pBlockVector,
        uint32_t currFrameIndex);
    ~VmaBlockVectorDefragmentationContext();

    VmaPool GetCustomPool() const { return m_hCustomPool; }
    VmaBlockVector* GetBlockVector() const { return m_pBlockVector; }
    VmaDefragmentationAlgorithm* GetAlgorithm() const { return m_pAlgorithm; }

    void AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged);
    void AddAll() { m_AllAllocations = true; }

    void Begin(bool overlappingMoveSupported);

private:
    const VmaAllocator m_hAllocator;
    // Null if not from custom pool.
    const VmaPool m_hCustomPool;
    // Redundant, for convenience not to fetch from m_hCustomPool->m_BlockVector or m_hAllocator->m_pBlockVectors.
    VmaBlockVector* const m_pBlockVector;
    const uint32_t m_CurrFrameIndex;
    // Owner of this object.
    VmaDefragmentationAlgorithm* m_pAlgorithm;

    struct AllocInfo
    {
        VmaAllocation hAlloc;
        VkBool32* pChanged;
    };
    // Used between constructor and Begin.
    VmaVector< AllocInfo, VmaStlAllocator<AllocInfo> > m_Allocations;
    bool m_AllAllocations;
};

struct VmaDefragmentationContext_T
{
private:
    VMA_CLASS_NO_COPY(VmaDefragmentationContext_T)
public:
    VmaDefragmentationContext_T(
        VmaAllocator hAllocator,
        uint32_t currFrameIndex,
        uint32_t flags,
        VmaDefragmentationStats* pStats);
    ~VmaDefragmentationContext_T();

    void AddPools(uint32_t poolCount, VmaPool* pPools);
    void AddAllocations(
        uint32_t allocationCount,
        VmaAllocation* pAllocations,
        VkBool32* pAllocationsChanged);

    /*
    Returns:
    - `VK_SUCCESS` if succeeded and object can be destroyed immediately.
    - `VK_NOT_READY` if succeeded but the object must remain alive until vmaDefragmentationEnd().
    - Negative value if error occured and object can be destroyed immediately.
    */
    VkResult Defragment(
        VkDeviceSize maxCpuBytesToMove, uint32_t maxCpuAllocationsToMove,
        VkDeviceSize maxGpuBytesToMove, uint32_t maxGpuAllocationsToMove,
        VkCommandBuffer commandBuffer, VmaDefragmentationStats* pStats);

private:
    const VmaAllocator m_hAllocator;
    const uint32_t m_CurrFrameIndex;
    const uint32_t m_Flags;
    VmaDefragmentationStats* const m_pStats;
    // Owner of these objects.
    VmaBlockVectorDefragmentationContext* m_DefaultPoolContexts[VK_MAX_MEMORY_TYPES];
    // Owner of these objects.
    VmaVector< VmaBlockVectorDefragmentationContext*, VmaStlAllocator<VmaBlockVectorDefragmentationContext*> > m_CustomPoolContexts;
};

#if VMA_RECORDING_ENABLED

class VmaRecorder
{
public:
    VmaRecorder();
    VkResult Init(const VmaRecordSettings& settings, bool useMutex);
    void WriteConfiguration(
        const VkPhysicalDeviceProperties& devProps,
        const VkPhysicalDeviceMemoryProperties& memProps,
        uint32_t vulkanApiVersion,
        bool dedicatedAllocationExtensionEnabled,
        bool bindMemory2ExtensionEnabled,
        bool memoryBudgetExtensionEnabled);
    ~VmaRecorder();

    void RecordCreateAllocator(uint32_t frameIndex);
    void RecordDestroyAllocator(uint32_t frameIndex);
    void RecordCreatePool(uint32_t frameIndex,
        const VmaPoolCreateInfo& createInfo,
        VmaPool pool);
    void RecordDestroyPool(uint32_t frameIndex, VmaPool pool);
    void RecordAllocateMemory(uint32_t frameIndex,
        const VkMemoryRequirements& vkMemReq,
        const VmaAllocationCreateInfo& createInfo,
        VmaAllocation allocation);
    void RecordAllocateMemoryPages(uint32_t frameIndex,
        const VkMemoryRequirements& vkMemReq,
        const VmaAllocationCreateInfo& createInfo,
        uint64_t allocationCount,
        const VmaAllocation* pAllocations);
    void RecordAllocateMemoryForBuffer(uint32_t frameIndex,
        const VkMemoryRequirements& vkMemReq,
        bool requiresDedicatedAllocation,
        bool prefersDedicatedAllocation,
        const VmaAllocationCreateInfo& createInfo,
        VmaAllocation allocation);
    void RecordAllocateMemoryForImage(uint32_t frameIndex,
        const VkMemoryRequirements& vkMemReq,
        bool requiresDedicatedAllocation,
        bool prefersDedicatedAllocation,
        const VmaAllocationCreateInfo& createInfo,
        VmaAllocation allocation);
    void RecordFreeMemory(uint32_t frameIndex,
        VmaAllocation allocation);
    void RecordFreeMemoryPages(uint32_t frameIndex,
        uint64_t allocationCount,
        const VmaAllocation* pAllocations);
    void RecordSetAllocationUserData(uint32_t frameIndex,
        VmaAllocation allocation,
        const void* pUserData);
    void RecordCreateLostAllocation(uint32_t frameIndex,
        VmaAllocation allocation);
    void RecordMapMemory(uint32_t frameIndex,
        VmaAllocation allocation);
    void RecordUnmapMemory(uint32_t frameIndex,
        VmaAllocation allocation);
    void RecordFlushAllocation(uint32_t frameIndex,
        VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size);
    void RecordInvalidateAllocation(uint32_t frameIndex,
        VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size);
    void RecordCreateBuffer(uint32_t frameIndex,
        const VkBufferCreateInfo& bufCreateInfo,
        const VmaAllocationCreateInfo& allocCreateInfo,
        VmaAllocation allocation);
    void RecordCreateImage(uint32_t frameIndex,
        const VkImageCreateInfo& imageCreateInfo,
        const VmaAllocationCreateInfo& allocCreateInfo,
        VmaAllocation allocation);
    void RecordDestroyBuffer(uint32_t frameIndex,
        VmaAllocation allocation);
    void RecordDestroyImage(uint32_t frameIndex,
        VmaAllocation allocation);
    void RecordTouchAllocation(uint32_t frameIndex,
        VmaAllocation allocation);
    void RecordGetAllocationInfo(uint32_t frameIndex,
        VmaAllocation allocation);
    void RecordMakePoolAllocationsLost(uint32_t frameIndex,
        VmaPool pool);
    void RecordDefragmentationBegin(uint32_t frameIndex,
        const VmaDefragmentationInfo2& info,
        VmaDefragmentationContext ctx);
    void RecordDefragmentationEnd(uint32_t frameIndex,
        VmaDefragmentationContext ctx);
    void RecordSetPoolName(uint32_t frameIndex,
        VmaPool pool,
        const char* name);

private:
    struct CallParams
    {
        uint32_t threadId;
        double time;
    };

    class UserDataString
    {
    public:
        UserDataString(VmaAllocationCreateFlags allocFlags, const void* pUserData);
        const char* GetString() const { return m_Str; }

    private:
        char m_PtrStr[17];
        const char* m_Str;
    };

    bool m_UseMutex;
    VmaRecordFlags m_Flags;
    FILE* m_File;
    VMA_MUTEX m_FileMutex;
    int64_t m_Freq;
    int64_t m_StartCounter;

    void GetBasicParams(CallParams& outParams);

    // T must be a pointer type, e.g. VmaAllocation, VmaPool.
    template<typename T>
    void PrintPointerList(uint64_t count, const T* pItems)
    {
        if(count)
        {
            fprintf(m_File, "%p", pItems[0]);
            for(uint64_t i = 1; i < count; ++i)
            {
                fprintf(m_File, " %p", pItems[i]);
            }
        }
    }

    void PrintPointerList(uint64_t count, const VmaAllocation* pItems);
    void Flush();
};

#endif // #if VMA_RECORDING_ENABLED

/*
Thread-safe wrapper over VmaPoolAllocator free list, for allocation of VmaAllocation_T objects.
*/
class VmaAllocationObjectAllocator
{
    VMA_CLASS_NO_COPY(VmaAllocationObjectAllocator)
public:
    VmaAllocationObjectAllocator(const VkAllocationCallbacks* pAllocationCallbacks);

    VmaAllocation Allocate();
    void Free(VmaAllocation hAlloc);

private:
    VMA_MUTEX m_Mutex;
    VmaPoolAllocator<VmaAllocation_T> m_Allocator;
};

struct VmaCurrentBudgetData
{
    VMA_ATOMIC_UINT64 m_BlockBytes[VK_MAX_MEMORY_HEAPS];
    VMA_ATOMIC_UINT64 m_AllocationBytes[VK_MAX_MEMORY_HEAPS];

#if VMA_MEMORY_BUDGET
    VMA_ATOMIC_UINT32 m_OperationsSinceBudgetFetch;
    VMA_RW_MUTEX m_BudgetMutex;
    uint64_t m_VulkanUsage[VK_MAX_MEMORY_HEAPS];
    uint64_t m_VulkanBudget[VK_MAX_MEMORY_HEAPS];
    uint64_t m_BlockBytesAtBudgetFetch[VK_MAX_MEMORY_HEAPS];
#endif // #if VMA_MEMORY_BUDGET

    VmaCurrentBudgetData()
    {
        for(uint32_t heapIndex = 0; heapIndex < VK_MAX_MEMORY_HEAPS; ++heapIndex)
        {
            m_BlockBytes[heapIndex] = 0;
            m_AllocationBytes[heapIndex] = 0;
#if VMA_MEMORY_BUDGET
            m_VulkanUsage[heapIndex] = 0;
            m_VulkanBudget[heapIndex] = 0;
            m_BlockBytesAtBudgetFetch[heapIndex] = 0;
#endif
        }

#if VMA_MEMORY_BUDGET
        m_OperationsSinceBudgetFetch = 0;
#endif
    }

    void AddAllocation(uint32_t heapIndex, VkDeviceSize allocationSize)
    {
        m_AllocationBytes[heapIndex] += allocationSize;
#if VMA_MEMORY_BUDGET
        ++m_OperationsSinceBudgetFetch;
#endif
    }

    void RemoveAllocation(uint32_t heapIndex, VkDeviceSize allocationSize)
    {
        VMA_ASSERT(m_AllocationBytes[heapIndex] >= allocationSize); // DELME
        m_AllocationBytes[heapIndex] -= allocationSize;
#if VMA_MEMORY_BUDGET
        ++m_OperationsSinceBudgetFetch;
#endif
    }
};

// Main allocator object.
struct VmaAllocator_T
{
    VMA_CLASS_NO_COPY(VmaAllocator_T)
public:
    bool m_UseMutex;
    uint32_t m_VulkanApiVersion;
    bool m_UseKhrDedicatedAllocation; // Can be set only if m_VulkanApiVersion < VK_MAKE_VERSION(1, 1, 0).
    bool m_UseKhrBindMemory2; // Can be set only if m_VulkanApiVersion < VK_MAKE_VERSION(1, 1, 0).
    bool m_UseExtMemoryBudget;
    VkDevice m_hDevice;
    VkInstance m_hInstance;
    bool m_AllocationCallbacksSpecified;
    VkAllocationCallbacks m_AllocationCallbacks;
    VmaDeviceMemoryCallbacks m_DeviceMemoryCallbacks;
    VmaAllocationObjectAllocator m_AllocationObjectAllocator;
    
    // Each bit (1 << i) is set if HeapSizeLimit is enabled for that heap, so cannot allocate more than the heap size.
    uint32_t m_HeapSizeLimitMask;

    VkPhysicalDeviceProperties m_PhysicalDeviceProperties;
    VkPhysicalDeviceMemoryProperties m_MemProps;

    // Default pools.
    VmaBlockVector* m_pBlockVectors[VK_MAX_MEMORY_TYPES];

    // Each vector is sorted by memory (handle value).
    typedef VmaVector< VmaAllocation, VmaStlAllocator<VmaAllocation> > AllocationVectorType;
    AllocationVectorType* m_pDedicatedAllocations[VK_MAX_MEMORY_TYPES];
    VMA_RW_MUTEX m_DedicatedAllocationsMutex[VK_MAX_MEMORY_TYPES];

    VmaCurrentBudgetData m_Budget;

    VmaAllocator_T(const VmaAllocatorCreateInfo* pCreateInfo);
    VkResult Init(const VmaAllocatorCreateInfo* pCreateInfo);
    ~VmaAllocator_T();

    const VkAllocationCallbacks* GetAllocationCallbacks() const
    {
        return m_AllocationCallbacksSpecified ? &m_AllocationCallbacks : 0;
    }
    const VmaVulkanFunctions& GetVulkanFunctions() const
    {
        return m_VulkanFunctions;
    }

    VkDeviceSize GetBufferImageGranularity() const
    {
        return VMA_MAX(
            static_cast<VkDeviceSize>(VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY),
            m_PhysicalDeviceProperties.limits.bufferImageGranularity);
    }

    uint32_t GetMemoryHeapCount() const { return m_MemProps.memoryHeapCount; }
    uint32_t GetMemoryTypeCount() const { return m_MemProps.memoryTypeCount; }

    uint32_t MemoryTypeIndexToHeapIndex(uint32_t memTypeIndex) const
    {
        VMA_ASSERT(memTypeIndex < m_MemProps.memoryTypeCount);
        return m_MemProps.memoryTypes[memTypeIndex].heapIndex;
    }
    // True when specific memory type is HOST_VISIBLE but not HOST_COHERENT.
    bool IsMemoryTypeNonCoherent(uint32_t memTypeIndex) const
    {
        return (m_MemProps.memoryTypes[memTypeIndex].propertyFlags & (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) ==
            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
    }
    // Minimum alignment for all allocations in specific memory type.
    VkDeviceSize GetMemoryTypeMinAlignment(uint32_t memTypeIndex) const
    {
        return IsMemoryTypeNonCoherent(memTypeIndex) ?
            VMA_MAX((VkDeviceSize)VMA_DEBUG_ALIGNMENT, m_PhysicalDeviceProperties.limits.nonCoherentAtomSize) :
            (VkDeviceSize)VMA_DEBUG_ALIGNMENT;
    }

    bool IsIntegratedGpu() const
    {
        return m_PhysicalDeviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU;
    }

#if VMA_RECORDING_ENABLED
    VmaRecorder* GetRecorder() const { return m_pRecorder; }
#endif

    void GetBufferMemoryRequirements(
        VkBuffer hBuffer,
        VkMemoryRequirements& memReq,
        bool& requiresDedicatedAllocation,
        bool& prefersDedicatedAllocation) const;
    void GetImageMemoryRequirements(
        VkImage hImage,
        VkMemoryRequirements& memReq,
        bool& requiresDedicatedAllocation,
        bool& prefersDedicatedAllocation) const;

    // Main allocation function.
    VkResult AllocateMemory(
        const VkMemoryRequirements& vkMemReq,
        bool requiresDedicatedAllocation,
        bool prefersDedicatedAllocation,
        VkBuffer dedicatedBuffer,
        VkImage dedicatedImage,
        const VmaAllocationCreateInfo& createInfo,
        VmaSuballocationType suballocType,
        size_t allocationCount,
        VmaAllocation* pAllocations);

    // Main deallocation function.
    void FreeMemory(
        size_t allocationCount,
        const VmaAllocation* pAllocations);

    VkResult ResizeAllocation(
        const VmaAllocation alloc,
        VkDeviceSize newSize);

    void CalculateStats(VmaStats* pStats);

    void GetBudget(
        VmaBudget* outBudget, uint32_t firstHeap, uint32_t heapCount);

#if VMA_STATS_STRING_ENABLED
    void PrintDetailedMap(class VmaJsonWriter& json);
#endif

    VkResult DefragmentationBegin(
        const VmaDefragmentationInfo2& info,
        VmaDefragmentationStats* pStats,
        VmaDefragmentationContext* pContext);
    VkResult DefragmentationEnd(
        VmaDefragmentationContext context);

    void GetAllocationInfo(VmaAllocation hAllocation, VmaAllocationInfo* pAllocationInfo);
    bool TouchAllocation(VmaAllocation hAllocation);

    VkResult CreatePool(const VmaPoolCreateInfo* pCreateInfo, VmaPool* pPool);
    void DestroyPool(VmaPool pool);
    void GetPoolStats(VmaPool pool, VmaPoolStats* pPoolStats);

    void SetCurrentFrameIndex(uint32_t frameIndex);
    uint32_t GetCurrentFrameIndex() const { return m_CurrentFrameIndex.load(); }

    void MakePoolAllocationsLost(
        VmaPool hPool,
        size_t* pLostAllocationCount);
    VkResult CheckPoolCorruption(VmaPool hPool);
    VkResult CheckCorruption(uint32_t memoryTypeBits);

    void CreateLostAllocation(VmaAllocation* pAllocation);

    // Call to Vulkan function vkAllocateMemory with accompanying bookkeeping.
    VkResult AllocateVulkanMemory(const VkMemoryAllocateInfo* pAllocateInfo, VkDeviceMemory* pMemory);
    // Call to Vulkan function vkFreeMemory with accompanying bookkeeping.
    void FreeVulkanMemory(uint32_t memoryType, VkDeviceSize size, VkDeviceMemory hMemory);
    // Call to Vulkan function vkBindBufferMemory or vkBindBufferMemory2KHR.
    VkResult BindVulkanBuffer(
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset,
        VkBuffer buffer,
        const void* pNext);
    // Call to Vulkan function vkBindImageMemory or vkBindImageMemory2KHR.
    VkResult BindVulkanImage(
        VkDeviceMemory memory,
        VkDeviceSize memoryOffset,
        VkImage image,
        const void* pNext);

    VkResult Map(VmaAllocation hAllocation, void** ppData);
    void Unmap(VmaAllocation hAllocation);

    VkResult BindBufferMemory(
        VmaAllocation hAllocation,
        VkDeviceSize allocationLocalOffset,
        VkBuffer hBuffer,
        const void* pNext);
    VkResult BindImageMemory(
        VmaAllocation hAllocation,
        VkDeviceSize allocationLocalOffset,
        VkImage hImage,
        const void* pNext);

    void FlushOrInvalidateAllocation(
        VmaAllocation hAllocation,
        VkDeviceSize offset, VkDeviceSize size,
        VMA_CACHE_OPERATION op);

    void FillAllocation(const VmaAllocation hAllocation, uint8_t pattern);

    /*
    Returns bit mask of memory types that can support defragmentation on GPU as
    they support creation of required buffer for copy operations.
    */
    uint32_t GetGpuDefragmentationMemoryTypeBits();

private:
    VkDeviceSize m_PreferredLargeHeapBlockSize;

    VkPhysicalDevice m_PhysicalDevice;
    VMA_ATOMIC_UINT32 m_CurrentFrameIndex;
    VMA_ATOMIC_UINT32 m_GpuDefragmentationMemoryTypeBits; // UINT32_MAX means uninitialized.
    
    VMA_RW_MUTEX m_PoolsMutex;
    // Protected by m_PoolsMutex. Sorted by pointer value.
    VmaVector<VmaPool, VmaStlAllocator<VmaPool> > m_Pools;
    uint32_t m_NextPoolId;

    VmaVulkanFunctions m_VulkanFunctions;

#if VMA_RECORDING_ENABLED
    VmaRecorder* m_pRecorder;
#endif

    void ImportVulkanFunctions(const VmaVulkanFunctions* pVulkanFunctions);

    VkDeviceSize CalcPreferredBlockSize(uint32_t memTypeIndex);

    VkResult AllocateMemoryOfType(
        VkDeviceSize size,
        VkDeviceSize alignment,
        bool dedicatedAllocation,
        VkBuffer dedicatedBuffer,
        VkImage dedicatedImage,
        const VmaAllocationCreateInfo& createInfo,
        uint32_t memTypeIndex,
        VmaSuballocationType suballocType,
        size_t allocationCount,
        VmaAllocation* pAllocations);

    // Helper function only to be used inside AllocateDedicatedMemory.
    VkResult AllocateDedicatedMemoryPage(
        VkDeviceSize size,
        VmaSuballocationType suballocType,
        uint32_t memTypeIndex,
        const VkMemoryAllocateInfo& allocInfo,
        bool map,
        bool isUserDataString,
        void* pUserData,
        VmaAllocation* pAllocation);

    // Allocates and registers new VkDeviceMemory specifically for dedicated allocations.
    VkResult AllocateDedicatedMemory(
        VkDeviceSize size,
        VmaSuballocationType suballocType,
        uint32_t memTypeIndex,
        bool withinBudget,
        bool map,
        bool isUserDataString,
        void* pUserData,
        VkBuffer dedicatedBuffer,
        VkImage dedicatedImage,
        size_t allocationCount,
        VmaAllocation* pAllocations);

    void FreeDedicatedMemory(const VmaAllocation allocation);

    /*
    Calculates and returns bit mask of memory types that can support defragmentation
    on GPU as they support creation of required buffer for copy operations.
    */
    uint32_t CalculateGpuDefragmentationMemoryTypeBits() const;

#if VMA_MEMORY_BUDGET
    void UpdateVulkanBudget();
#endif // #if VMA_MEMORY_BUDGET
};

////////////////////////////////////////////////////////////////////////////////
// Memory allocation #2 after VmaAllocator_T definition

static void* VmaMalloc(VmaAllocator hAllocator, size_t size, size_t alignment)
{
    return VmaMalloc(&hAllocator->m_AllocationCallbacks, size, alignment);
}

static void VmaFree(VmaAllocator hAllocator, void* ptr)
{
    VmaFree(&hAllocator->m_AllocationCallbacks, ptr);
}

template<typename T>
static T* VmaAllocate(VmaAllocator hAllocator)
{
    return (T*)VmaMalloc(hAllocator, sizeof(T), VMA_ALIGN_OF(T));
}

template<typename T>
static T* VmaAllocateArray(VmaAllocator hAllocator, size_t count)
{
    return (T*)VmaMalloc(hAllocator, sizeof(T) * count, VMA_ALIGN_OF(T));
}

template<typename T>
static void vma_delete(VmaAllocator hAllocator, T* ptr)
{
    if(ptr != VMA_NULL)
    {
        ptr->~T();
        VmaFree(hAllocator, ptr);
    }
}

template<typename T>
static void vma_delete_array(VmaAllocator hAllocator, T* ptr, size_t count)
{
    if(ptr != VMA_NULL)
    {
        for(size_t i = count; i--; )
            ptr[i].~T();
        VmaFree(hAllocator, ptr);
    }
}

////////////////////////////////////////////////////////////////////////////////
// VmaStringBuilder

#if VMA_STATS_STRING_ENABLED

class VmaStringBuilder
{
public:
    VmaStringBuilder(VmaAllocator alloc) : m_Data(VmaStlAllocator<char>(alloc->GetAllocationCallbacks())) { }
    size_t GetLength() const { return m_Data.size(); }
    const char* GetData() const { return m_Data.data(); }

    void Add(char ch) { m_Data.push_back(ch); }
    void Add(const char* pStr);
    void AddNewLine() { Add('\n'); }
    void AddNumber(uint32_t num);
    void AddNumber(uint64_t num);
    void AddPointer(const void* ptr);

private:
    VmaVector< char, VmaStlAllocator<char> > m_Data;
};

void VmaStringBuilder::Add(const char* pStr)
{
    const size_t strLen = strlen(pStr);
    if(strLen > 0)
    {
        const size_t oldCount = m_Data.size();
        m_Data.resize(oldCount + strLen);
        memcpy(m_Data.data() + oldCount, pStr, strLen);
    }
}

void VmaStringBuilder::AddNumber(uint32_t num)
{
    char buf[11];
    buf[10] = '\0';
    char *p = &buf[10];
    do
    {
        *--p = '0' + (num % 10);
        num /= 10;
    }
    while(num);
    Add(p);
}

void VmaStringBuilder::AddNumber(uint64_t num)
{
    char buf[21];
    buf[20] = '\0';
    char *p = &buf[20];
    do
    {
        *--p = '0' + (num % 10);
        num /= 10;
    }
    while(num);
    Add(p);
}

void VmaStringBuilder::AddPointer(const void* ptr)
{
    char buf[21];
    VmaPtrToStr(buf, sizeof(buf), ptr);
    Add(buf);
}

#endif // #if VMA_STATS_STRING_ENABLED

////////////////////////////////////////////////////////////////////////////////
// VmaJsonWriter

#if VMA_STATS_STRING_ENABLED

class VmaJsonWriter
{
    VMA_CLASS_NO_COPY(VmaJsonWriter)
public:
    VmaJsonWriter(const VkAllocationCallbacks* pAllocationCallbacks, VmaStringBuilder& sb);
    ~VmaJsonWriter();

    void BeginObject(bool singleLine = false);
    void EndObject();
    
    void BeginArray(bool singleLine = false);
    void EndArray();
    
    void WriteString(const char* pStr);
    void BeginString(const char* pStr = VMA_NULL);
    void ContinueString(const char* pStr);
    void ContinueString(uint32_t n);
    void ContinueString(uint64_t n);
    void ContinueString_Pointer(const void* ptr);
    void EndString(const char* pStr = VMA_NULL);
    
    void WriteNumber(uint32_t n);
    void WriteNumber(uint64_t n);
    void WriteBool(bool b);
    void WriteNull();

private:
    static const char* const INDENT;

    enum COLLECTION_TYPE
    {
        COLLECTION_TYPE_OBJECT,
        COLLECTION_TYPE_ARRAY,
    };
    struct StackItem
    {
        COLLECTION_TYPE type;
        uint32_t valueCount;
        bool singleLineMode;
    };

    VmaStringBuilder& m_SB;
    VmaVector< StackItem, VmaStlAllocator<StackItem> > m_Stack;
    bool m_InsideString;

    void BeginValue(bool isString);
    void WriteIndent(bool oneLess = false);
};

const char* const VmaJsonWriter::INDENT = "  ";

VmaJsonWriter::VmaJsonWriter(const VkAllocationCallbacks* pAllocationCallbacks, VmaStringBuilder& sb) :
    m_SB(sb),
    m_Stack(VmaStlAllocator<StackItem>(pAllocationCallbacks)),
    m_InsideString(false)
{
}

VmaJsonWriter::~VmaJsonWriter()
{
    VMA_ASSERT(!m_InsideString);
    VMA_ASSERT(m_Stack.empty());
}

void VmaJsonWriter::BeginObject(bool singleLine)
{
    VMA_ASSERT(!m_InsideString);

    BeginValue(false);
    m_SB.Add('{');

    StackItem item;
    item.type = COLLECTION_TYPE_OBJECT;
    item.valueCount = 0;
    item.singleLineMode = singleLine;
    m_Stack.push_back(item);
}

void VmaJsonWriter::EndObject()
{
    VMA_ASSERT(!m_InsideString);

    WriteIndent(true);
    m_SB.Add('}');

    VMA_ASSERT(!m_Stack.empty() && m_Stack.back().type == COLLECTION_TYPE_OBJECT);
    m_Stack.pop_back();
}

void VmaJsonWriter::BeginArray(bool singleLine)
{
    VMA_ASSERT(!m_InsideString);

    BeginValue(false);
    m_SB.Add('[');

    StackItem item;
    item.type = COLLECTION_TYPE_ARRAY;
    item.valueCount = 0;
    item.singleLineMode = singleLine;
    m_Stack.push_back(item);
}

void VmaJsonWriter::EndArray()
{
    VMA_ASSERT(!m_InsideString);

    WriteIndent(true);
    m_SB.Add(']');

    VMA_ASSERT(!m_Stack.empty() && m_Stack.back().type == COLLECTION_TYPE_ARRAY);
    m_Stack.pop_back();
}

void VmaJsonWriter::WriteString(const char* pStr)
{
    BeginString(pStr);
    EndString();
}

void VmaJsonWriter::BeginString(const char* pStr)
{
    VMA_ASSERT(!m_InsideString);

    BeginValue(true);
    m_SB.Add('"');
    m_InsideString = true;
    if(pStr != VMA_NULL && pStr[0] != '\0')
    {
        ContinueString(pStr);
    }
}

void VmaJsonWriter::ContinueString(const char* pStr)
{
    VMA_ASSERT(m_InsideString);

    const size_t strLen = strlen(pStr);
    for(size_t i = 0; i < strLen; ++i)
    {
        char ch = pStr[i];
        if(ch == '\\')
        {
            m_SB.Add("\\\\");
        }
        else if(ch == '"')
        {
            m_SB.Add("\\\"");
        }
        else if(ch >= 32)
        {
            m_SB.Add(ch);
        }
        else switch(ch)
        {
        case '\b':
            m_SB.Add("\\b");
            break;
        case '\f':
            m_SB.Add("\\f");
            break;
        case '\n':
            m_SB.Add("\\n");
            break;
        case '\r':
            m_SB.Add("\\r");
            break;
        case '\t':
            m_SB.Add("\\t");
            break;
        default:
            VMA_ASSERT(0 && "Character not currently supported.");
            break;
        }
    }
}

void VmaJsonWriter::ContinueString(uint32_t n)
{
    VMA_ASSERT(m_InsideString);
    m_SB.AddNumber(n);
}

void VmaJsonWriter::ContinueString(uint64_t n)
{
    VMA_ASSERT(m_InsideString);
    m_SB.AddNumber(n);
}

void VmaJsonWriter::ContinueString_Pointer(const void* ptr)
{
    VMA_ASSERT(m_InsideString);
    m_SB.AddPointer(ptr);
}

void VmaJsonWriter::EndString(const char* pStr)
{
    VMA_ASSERT(m_InsideString);
    if(pStr != VMA_NULL && pStr[0] != '\0')
    {
        ContinueString(pStr);
    }
    m_SB.Add('"');
    m_InsideString = false;
}

void VmaJsonWriter::WriteNumber(uint32_t n)
{
    VMA_ASSERT(!m_InsideString);
    BeginValue(false);
    m_SB.AddNumber(n);
}

void VmaJsonWriter::WriteNumber(uint64_t n)
{
    VMA_ASSERT(!m_InsideString);
    BeginValue(false);
    m_SB.AddNumber(n);
}

void VmaJsonWriter::WriteBool(bool b)
{
    VMA_ASSERT(!m_InsideString);
    BeginValue(false);
    m_SB.Add(b ? "true" : "false");
}

void VmaJsonWriter::WriteNull()
{
    VMA_ASSERT(!m_InsideString);
    BeginValue(false);
    m_SB.Add("null");
}

void VmaJsonWriter::BeginValue(bool isString)
{
    if(!m_Stack.empty())
    {
        StackItem& currItem = m_Stack.back();
        if(currItem.type == COLLECTION_TYPE_OBJECT &&
            currItem.valueCount % 2 == 0)
        {
            VMA_ASSERT(isString);
        }

        if(currItem.type == COLLECTION_TYPE_OBJECT &&
            currItem.valueCount % 2 != 0)
        {
            m_SB.Add(": ");
        }
        else if(currItem.valueCount > 0)
        {
            m_SB.Add(", ");
            WriteIndent();
        }
        else
        {
            WriteIndent();
        }
        ++currItem.valueCount;
    }
}

void VmaJsonWriter::WriteIndent(bool oneLess)
{
    if(!m_Stack.empty() && !m_Stack.back().singleLineMode)
    {
        m_SB.AddNewLine();
        
        size_t count = m_Stack.size();
        if(count > 0 && oneLess)
        {
            --count;
        }
        for(size_t i = 0; i < count; ++i)
        {
            m_SB.Add(INDENT);
        }
    }
}

#endif // #if VMA_STATS_STRING_ENABLED

////////////////////////////////////////////////////////////////////////////////

void VmaAllocation_T::SetUserData(VmaAllocator hAllocator, void* pUserData)
{
    if(IsUserDataString())
    {
        VMA_ASSERT(pUserData == VMA_NULL || pUserData != m_pUserData);

        FreeUserDataString(hAllocator);

        if(pUserData != VMA_NULL)
        {
            m_pUserData = VmaCreateStringCopy(hAllocator->GetAllocationCallbacks(), (const char*)pUserData);
        }
    }
    else
    {
        m_pUserData = pUserData;
    }
}

void VmaAllocation_T::ChangeBlockAllocation(
    VmaAllocator hAllocator,
    VmaDeviceMemoryBlock* block,
    VkDeviceSize offset)
{
    VMA_ASSERT(block != VMA_NULL);
    VMA_ASSERT(m_Type == ALLOCATION_TYPE_BLOCK);

    // Move mapping reference counter from old block to new block.
    if(block != m_BlockAllocation.m_Block)
    {
        uint32_t mapRefCount = m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP;
        if(IsPersistentMap())
            ++mapRefCount;
        m_BlockAllocation.m_Block->Unmap(hAllocator, mapRefCount);
        block->Map(hAllocator, mapRefCount, VMA_NULL);
    }

    m_BlockAllocation.m_Block = block;
    m_BlockAllocation.m_Offset = offset;
}

void VmaAllocation_T::ChangeOffset(VkDeviceSize newOffset)
{
    VMA_ASSERT(m_Type == ALLOCATION_TYPE_BLOCK);
    m_BlockAllocation.m_Offset = newOffset;
}

VkDeviceSize VmaAllocation_T::GetOffset() const
{
    switch(m_Type)
    {
    case ALLOCATION_TYPE_BLOCK:
        return m_BlockAllocation.m_Offset;
    case ALLOCATION_TYPE_DEDICATED:
        return 0;
    default:
        VMA_ASSERT(0);
        return 0;
    }
}

VkDeviceMemory VmaAllocation_T::GetMemory() const
{
    switch(m_Type)
    {
    case ALLOCATION_TYPE_BLOCK:
        return m_BlockAllocation.m_Block->GetDeviceMemory();
    case ALLOCATION_TYPE_DEDICATED:
        return m_DedicatedAllocation.m_hMemory;
    default:
        VMA_ASSERT(0);
        return VK_NULL_HANDLE;
    }
}

void* VmaAllocation_T::GetMappedData() const
{
    switch(m_Type)
    {
    case ALLOCATION_TYPE_BLOCK:
        if(m_MapCount != 0)
        {
            void* pBlockData = m_BlockAllocation.m_Block->GetMappedData();
            VMA_ASSERT(pBlockData != VMA_NULL);
            return (char*)pBlockData + m_BlockAllocation.m_Offset;
        }
        else
        {
            return VMA_NULL;
        }
        break;
    case ALLOCATION_TYPE_DEDICATED:
        VMA_ASSERT((m_DedicatedAllocation.m_pMappedData != VMA_NULL) == (m_MapCount != 0));
        return m_DedicatedAllocation.m_pMappedData;
    default:
        VMA_ASSERT(0);
        return VMA_NULL;
    }
}

bool VmaAllocation_T::CanBecomeLost() const
{
    switch(m_Type)
    {
    case ALLOCATION_TYPE_BLOCK:
        return m_BlockAllocation.m_CanBecomeLost;
    case ALLOCATION_TYPE_DEDICATED:
        return false;
    default:
        VMA_ASSERT(0);
        return false;
    }
}

bool VmaAllocation_T::MakeLost(uint32_t currentFrameIndex, uint32_t frameInUseCount)
{
    VMA_ASSERT(CanBecomeLost());

    /*
    Warning: This is a carefully designed algorithm.
    Do not modify unless you really know what you're doing :)
    */
    uint32_t localLastUseFrameIndex = GetLastUseFrameIndex();
    for(;;)
    {
        if(localLastUseFrameIndex == VMA_FRAME_INDEX_LOST)
        {
            VMA_ASSERT(0);
            return false;
        }
        else if(localLastUseFrameIndex + frameInUseCount >= currentFrameIndex)
        {
            return false;
        }
        else // Last use time earlier than current time.
        {
            if(CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, VMA_FRAME_INDEX_LOST))
            {
                // Setting hAllocation.LastUseFrameIndex atomic to VMA_FRAME_INDEX_LOST is enough to mark it as LOST.
                // Calling code just needs to unregister this allocation in owning VmaDeviceMemoryBlock.
                return true;
            }
        }
    }
}

#if VMA_STATS_STRING_ENABLED

// Correspond to values of enum VmaSuballocationType.
static const char* VMA_SUBALLOCATION_TYPE_NAMES[] = {
    "FREE",
    "UNKNOWN",
    "BUFFER",
    "IMAGE_UNKNOWN",
    "IMAGE_LINEAR",
    "IMAGE_OPTIMAL",
};

void VmaAllocation_T::PrintParameters(class VmaJsonWriter& json) const
{
    json.WriteString("Type");
    json.WriteString(VMA_SUBALLOCATION_TYPE_NAMES[m_SuballocationType]);

    json.WriteString("Size");
    json.WriteNumber(m_Size);

    if(m_pUserData != VMA_NULL)
    {
        json.WriteString("UserData");
        if(IsUserDataString())
        {
            json.WriteString((const char*)m_pUserData);
        }
        else
        {
            json.BeginString();
            json.ContinueString_Pointer(m_pUserData);
            json.EndString();
        }
    }

    json.WriteString("CreationFrameIndex");
    json.WriteNumber(m_CreationFrameIndex);

    json.WriteString("LastUseFrameIndex");
    json.WriteNumber(GetLastUseFrameIndex());

    if(m_BufferImageUsage != 0)
    {
        json.WriteString("Usage");
        json.WriteNumber(m_BufferImageUsage);
    }
}

#endif

void VmaAllocation_T::FreeUserDataString(VmaAllocator hAllocator)
{
    VMA_ASSERT(IsUserDataString());
    VmaFreeString(hAllocator->GetAllocationCallbacks(), (char*)m_pUserData);
    m_pUserData = VMA_NULL;
}

void VmaAllocation_T::BlockAllocMap()
{
    VMA_ASSERT(GetType() == ALLOCATION_TYPE_BLOCK);

    if((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) < 0x7F)
    {
        ++m_MapCount;
    }
    else
    {
        VMA_ASSERT(0 && "Allocation mapped too many times simultaneously.");
    }
}

void VmaAllocation_T::BlockAllocUnmap()
{
    VMA_ASSERT(GetType() == ALLOCATION_TYPE_BLOCK);

    if((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) != 0)
    {
        --m_MapCount;
    }
    else
    {
        VMA_ASSERT(0 && "Unmapping allocation not previously mapped.");
    }
}

VkResult VmaAllocation_T::DedicatedAllocMap(VmaAllocator hAllocator, void** ppData)
{
    VMA_ASSERT(GetType() == ALLOCATION_TYPE_DEDICATED);

    if(m_MapCount != 0)
    {
        if((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) < 0x7F)
        {
            VMA_ASSERT(m_DedicatedAllocation.m_pMappedData != VMA_NULL);
            *ppData = m_DedicatedAllocation.m_pMappedData;
            ++m_MapCount;
            return VK_SUCCESS;
        }
        else
        {
            VMA_ASSERT(0 && "Dedicated allocation mapped too many times simultaneously.");
            return VK_ERROR_MEMORY_MAP_FAILED;
        }
    }
    else
    {
        VkResult result = (*hAllocator->GetVulkanFunctions().vkMapMemory)(
            hAllocator->m_hDevice,
            m_DedicatedAllocation.m_hMemory,
            0, // offset
            VK_WHOLE_SIZE,
            0, // flags
            ppData);
        if(result == VK_SUCCESS)
        {
            m_DedicatedAllocation.m_pMappedData = *ppData;
            m_MapCount = 1;
        }
        return result;
    }
}

void VmaAllocation_T::DedicatedAllocUnmap(VmaAllocator hAllocator)
{
    VMA_ASSERT(GetType() == ALLOCATION_TYPE_DEDICATED);

    if((m_MapCount & ~MAP_COUNT_FLAG_PERSISTENT_MAP) != 0)
    {
        --m_MapCount;
        if(m_MapCount == 0)
        {
            m_DedicatedAllocation.m_pMappedData = VMA_NULL;
            (*hAllocator->GetVulkanFunctions().vkUnmapMemory)(
                hAllocator->m_hDevice,
                m_DedicatedAllocation.m_hMemory);
        }
    }
    else
    {
        VMA_ASSERT(0 && "Unmapping dedicated allocation not previously mapped.");
    }
}

#if VMA_STATS_STRING_ENABLED

static void VmaPrintStatInfo(VmaJsonWriter& json, const VmaStatInfo& stat)
{
    json.BeginObject();

    json.WriteString("Blocks");
    json.WriteNumber(stat.blockCount);

    json.WriteString("Allocations");
    json.WriteNumber(stat.allocationCount);

    json.WriteString("UnusedRanges");
    json.WriteNumber(stat.unusedRangeCount);

    json.WriteString("UsedBytes");
    json.WriteNumber(stat.usedBytes);

    json.WriteString("UnusedBytes");
    json.WriteNumber(stat.unusedBytes);

    if(stat.allocationCount > 1)
    {
        json.WriteString("AllocationSize");
        json.BeginObject(true);
        json.WriteString("Min");
        json.WriteNumber(stat.allocationSizeMin);
        json.WriteString("Avg");
        json.WriteNumber(stat.allocationSizeAvg);
        json.WriteString("Max");
        json.WriteNumber(stat.allocationSizeMax);
        json.EndObject();
    }

    if(stat.unusedRangeCount > 1)
    {
        json.WriteString("UnusedRangeSize");
        json.BeginObject(true);
        json.WriteString("Min");
        json.WriteNumber(stat.unusedRangeSizeMin);
        json.WriteString("Avg");
        json.WriteNumber(stat.unusedRangeSizeAvg);
        json.WriteString("Max");
        json.WriteNumber(stat.unusedRangeSizeMax);
        json.EndObject();
    }

    json.EndObject();
}

#endif // #if VMA_STATS_STRING_ENABLED

struct VmaSuballocationItemSizeLess
{
    bool operator()(
        const VmaSuballocationList::iterator lhs,
        const VmaSuballocationList::iterator rhs) const
    {
        return lhs->size < rhs->size;
    }
    bool operator()(
        const VmaSuballocationList::iterator lhs,
        VkDeviceSize rhsSize) const
    {
        return lhs->size < rhsSize;
    }
};


////////////////////////////////////////////////////////////////////////////////
// class VmaBlockMetadata

VmaBlockMetadata::VmaBlockMetadata(VmaAllocator hAllocator) :
    m_Size(0),
    m_pAllocationCallbacks(hAllocator->GetAllocationCallbacks())
{
}

#if VMA_STATS_STRING_ENABLED

void VmaBlockMetadata::PrintDetailedMap_Begin(class VmaJsonWriter& json,
    VkDeviceSize unusedBytes,
    size_t allocationCount,
    size_t unusedRangeCount) const
{
    json.BeginObject();

    json.WriteString("TotalBytes");
    json.WriteNumber(GetSize());

    json.WriteString("UnusedBytes");
    json.WriteNumber(unusedBytes);

    json.WriteString("Allocations");
    json.WriteNumber((uint64_t)allocationCount);

    json.WriteString("UnusedRanges");
    json.WriteNumber((uint64_t)unusedRangeCount);

    json.WriteString("Suballocations");
    json.BeginArray();
}

void VmaBlockMetadata::PrintDetailedMap_Allocation(class VmaJsonWriter& json,
    VkDeviceSize offset,
    VmaAllocation hAllocation) const
{
    json.BeginObject(true);
        
    json.WriteString("Offset");
    json.WriteNumber(offset);

    hAllocation->PrintParameters(json);

    json.EndObject();
}

void VmaBlockMetadata::PrintDetailedMap_UnusedRange(class VmaJsonWriter& json,
    VkDeviceSize offset,
    VkDeviceSize size) const
{
    json.BeginObject(true);
        
    json.WriteString("Offset");
    json.WriteNumber(offset);

    json.WriteString("Type");
    json.WriteString(VMA_SUBALLOCATION_TYPE_NAMES[VMA_SUBALLOCATION_TYPE_FREE]);

    json.WriteString("Size");
    json.WriteNumber(size);

    json.EndObject();
}

void VmaBlockMetadata::PrintDetailedMap_End(class VmaJsonWriter& json) const
{
    json.EndArray();
    json.EndObject();
}

#endif // #if VMA_STATS_STRING_ENABLED

////////////////////////////////////////////////////////////////////////////////
// class VmaBlockMetadata_Generic

VmaBlockMetadata_Generic::VmaBlockMetadata_Generic(VmaAllocator hAllocator) :
    VmaBlockMetadata(hAllocator),
    m_FreeCount(0),
    m_SumFreeSize(0),
    m_Suballocations(VmaStlAllocator<VmaSuballocation>(hAllocator->GetAllocationCallbacks())),
    m_FreeSuballocationsBySize(VmaStlAllocator<VmaSuballocationList::iterator>(hAllocator->GetAllocationCallbacks()))
{
}

VmaBlockMetadata_Generic::~VmaBlockMetadata_Generic()
{
}

void VmaBlockMetadata_Generic::Init(VkDeviceSize size)
{
    VmaBlockMetadata::Init(size);

    m_FreeCount = 1;
    m_SumFreeSize = size;

    VmaSuballocation suballoc = {};
    suballoc.offset = 0;
    suballoc.size = size;
    suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
    suballoc.hAllocation = VK_NULL_HANDLE;

    VMA_ASSERT(size > VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER);
    m_Suballocations.push_back(suballoc);
    VmaSuballocationList::iterator suballocItem = m_Suballocations.end();
    --suballocItem;
    m_FreeSuballocationsBySize.push_back(suballocItem);
}

bool VmaBlockMetadata_Generic::Validate() const
{
    VMA_VALIDATE(!m_Suballocations.empty());
    
    // Expected offset of new suballocation as calculated from previous ones.
    VkDeviceSize calculatedOffset = 0;
    // Expected number of free suballocations as calculated from traversing their list.
    uint32_t calculatedFreeCount = 0;
    // Expected sum size of free suballocations as calculated from traversing their list.
    VkDeviceSize calculatedSumFreeSize = 0;
    // Expected number of free suballocations that should be registered in
    // m_FreeSuballocationsBySize calculated from traversing their list.
    size_t freeSuballocationsToRegister = 0;
    // True if previous visited suballocation was free.
    bool prevFree = false;

    for(VmaSuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
        suballocItem != m_Suballocations.cend();
        ++suballocItem)
    {
        const VmaSuballocation& subAlloc = *suballocItem;
        
        // Actual offset of this suballocation doesn't match expected one.
        VMA_VALIDATE(subAlloc.offset == calculatedOffset);

        const bool currFree = (subAlloc.type == VMA_SUBALLOCATION_TYPE_FREE);
        // Two adjacent free suballocations are invalid. They should be merged.
        VMA_VALIDATE(!prevFree || !currFree);

        VMA_VALIDATE(currFree == (subAlloc.hAllocation == VK_NULL_HANDLE));

        if(currFree)
        {
            calculatedSumFreeSize += subAlloc.size;
            ++calculatedFreeCount;
            if(subAlloc.size >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
            {
                ++freeSuballocationsToRegister;
            }

            // Margin required between allocations - every free space must be at least that large.
            VMA_VALIDATE(subAlloc.size >= VMA_DEBUG_MARGIN);
        }
        else
        {
            VMA_VALIDATE(subAlloc.hAllocation->GetOffset() == subAlloc.offset);
            VMA_VALIDATE(subAlloc.hAllocation->GetSize() == subAlloc.size);

            // Margin required between allocations - previous allocation must be free.
            VMA_VALIDATE(VMA_DEBUG_MARGIN == 0 || prevFree);
        }

        calculatedOffset += subAlloc.size;
        prevFree = currFree;
    }

    // Number of free suballocations registered in m_FreeSuballocationsBySize doesn't
    // match expected one.
    VMA_VALIDATE(m_FreeSuballocationsBySize.size() == freeSuballocationsToRegister);

    VkDeviceSize lastSize = 0;
    for(size_t i = 0; i < m_FreeSuballocationsBySize.size(); ++i)
    {
        VmaSuballocationList::iterator suballocItem = m_FreeSuballocationsBySize[i];
        
        // Only free suballocations can be registered in m_FreeSuballocationsBySize.
        VMA_VALIDATE(suballocItem->type == VMA_SUBALLOCATION_TYPE_FREE);
        // They must be sorted by size ascending.
        VMA_VALIDATE(suballocItem->size >= lastSize);

        lastSize = suballocItem->size;
    }

    // Check if totals match calculacted values.
    VMA_VALIDATE(ValidateFreeSuballocationList());
    VMA_VALIDATE(calculatedOffset == GetSize());
    VMA_VALIDATE(calculatedSumFreeSize == m_SumFreeSize);
    VMA_VALIDATE(calculatedFreeCount == m_FreeCount);

    return true;
}

VkDeviceSize VmaBlockMetadata_Generic::GetUnusedRangeSizeMax() const
{
    if(!m_FreeSuballocationsBySize.empty())
    {
        return m_FreeSuballocationsBySize.back()->size;
    }
    else
    {
        return 0;
    }
}

bool VmaBlockMetadata_Generic::IsEmpty() const
{
    return (m_Suballocations.size() == 1) && (m_FreeCount == 1);
}

void VmaBlockMetadata_Generic::CalcAllocationStatInfo(VmaStatInfo& outInfo) const
{
    outInfo.blockCount = 1;

    const uint32_t rangeCount = (uint32_t)m_Suballocations.size();
    outInfo.allocationCount = rangeCount - m_FreeCount;
    outInfo.unusedRangeCount = m_FreeCount;
    
    outInfo.unusedBytes = m_SumFreeSize;
    outInfo.usedBytes = GetSize() - outInfo.unusedBytes;

    outInfo.allocationSizeMin = UINT64_MAX;
    outInfo.allocationSizeMax = 0;
    outInfo.unusedRangeSizeMin = UINT64_MAX;
    outInfo.unusedRangeSizeMax = 0;

    for(VmaSuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
        suballocItem != m_Suballocations.cend();
        ++suballocItem)
    {
        const VmaSuballocation& suballoc = *suballocItem;
        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE)
        {
            outInfo.allocationSizeMin = VMA_MIN(outInfo.allocationSizeMin, suballoc.size);
            outInfo.allocationSizeMax = VMA_MAX(outInfo.allocationSizeMax, suballoc.size);
        }
        else
        {
            outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, suballoc.size);
            outInfo.unusedRangeSizeMax = VMA_MAX(outInfo.unusedRangeSizeMax, suballoc.size);
        }
    }
}

void VmaBlockMetadata_Generic::AddPoolStats(VmaPoolStats& inoutStats) const
{
    const uint32_t rangeCount = (uint32_t)m_Suballocations.size();

    inoutStats.size += GetSize();
    inoutStats.unusedSize += m_SumFreeSize;
    inoutStats.allocationCount += rangeCount - m_FreeCount;
    inoutStats.unusedRangeCount += m_FreeCount;
    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, GetUnusedRangeSizeMax());
}

#if VMA_STATS_STRING_ENABLED

void VmaBlockMetadata_Generic::PrintDetailedMap(class VmaJsonWriter& json) const
{
    PrintDetailedMap_Begin(json,
        m_SumFreeSize, // unusedBytes
        m_Suballocations.size() - (size_t)m_FreeCount, // allocationCount
        m_FreeCount); // unusedRangeCount

    size_t i = 0;
    for(VmaSuballocationList::const_iterator suballocItem = m_Suballocations.cbegin();
        suballocItem != m_Suballocations.cend();
        ++suballocItem, ++i)
    {
        if(suballocItem->type == VMA_SUBALLOCATION_TYPE_FREE)
        {
            PrintDetailedMap_UnusedRange(json, suballocItem->offset, suballocItem->size);
        }
        else
        {
            PrintDetailedMap_Allocation(json, suballocItem->offset, suballocItem->hAllocation);
        }
    }

    PrintDetailedMap_End(json);
}

#endif // #if VMA_STATS_STRING_ENABLED

bool VmaBlockMetadata_Generic::CreateAllocationRequest(
    uint32_t currentFrameIndex,
    uint32_t frameInUseCount,
    VkDeviceSize bufferImageGranularity,
    VkDeviceSize allocSize,
    VkDeviceSize allocAlignment,
    bool upperAddress,
    VmaSuballocationType allocType,
    bool canMakeOtherLost,
    uint32_t strategy,
    VmaAllocationRequest* pAllocationRequest)
{
    VMA_ASSERT(allocSize > 0);
    VMA_ASSERT(!upperAddress);
    VMA_ASSERT(allocType != VMA_SUBALLOCATION_TYPE_FREE);
    VMA_ASSERT(pAllocationRequest != VMA_NULL);
    VMA_HEAVY_ASSERT(Validate());

    pAllocationRequest->type = VmaAllocationRequestType::Normal;

    // There is not enough total free space in this block to fullfill the request: Early return.
    if(canMakeOtherLost == false &&
        m_SumFreeSize < allocSize + 2 * VMA_DEBUG_MARGIN)
    {
        return false;
    }

    // New algorithm, efficiently searching freeSuballocationsBySize.
    const size_t freeSuballocCount = m_FreeSuballocationsBySize.size();
    if(freeSuballocCount > 0)
    {
        if(strategy == VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT)
        {
            // Find first free suballocation with size not less than allocSize + 2 * VMA_DEBUG_MARGIN.
            VmaSuballocationList::iterator* const it = VmaBinaryFindFirstNotLess(
                m_FreeSuballocationsBySize.data(),
                m_FreeSuballocationsBySize.data() + freeSuballocCount,
                allocSize + 2 * VMA_DEBUG_MARGIN,
                VmaSuballocationItemSizeLess());
            size_t index = it - m_FreeSuballocationsBySize.data();
            for(; index < freeSuballocCount; ++index)
            {
                if(CheckAllocation(
                    currentFrameIndex,
                    frameInUseCount,
                    bufferImageGranularity,
                    allocSize,
                    allocAlignment,
                    allocType,
                    m_FreeSuballocationsBySize[index],
                    false, // canMakeOtherLost
                    &pAllocationRequest->offset,
                    &pAllocationRequest->itemsToMakeLostCount,
                    &pAllocationRequest->sumFreeSize,
                    &pAllocationRequest->sumItemSize))
                {
                    pAllocationRequest->item = m_FreeSuballocationsBySize[index];
                    return true;
                }
            }
        }
        else if(strategy == VMA_ALLOCATION_INTERNAL_STRATEGY_MIN_OFFSET)
        {
            for(VmaSuballocationList::iterator it = m_Suballocations.begin();
                it != m_Suballocations.end();
                ++it)
            {
                if(it->type == VMA_SUBALLOCATION_TYPE_FREE && CheckAllocation(
                    currentFrameIndex,
                    frameInUseCount,
                    bufferImageGranularity,
                    allocSize,
                    allocAlignment,
                    allocType,
                    it,
                    false, // canMakeOtherLost
                    &pAllocationRequest->offset,
                    &pAllocationRequest->itemsToMakeLostCount,
                    &pAllocationRequest->sumFreeSize,
                    &pAllocationRequest->sumItemSize))
                {
                    pAllocationRequest->item = it;
                    return true;
                }
            }
        }
        else // WORST_FIT, FIRST_FIT
        {
            // Search staring from biggest suballocations.
            for(size_t index = freeSuballocCount; index--; )
            {
                if(CheckAllocation(
                    currentFrameIndex,
                    frameInUseCount,
                    bufferImageGranularity,
                    allocSize,
                    allocAlignment,
                    allocType,
                    m_FreeSuballocationsBySize[index],
                    false, // canMakeOtherLost
                    &pAllocationRequest->offset,
                    &pAllocationRequest->itemsToMakeLostCount,
                    &pAllocationRequest->sumFreeSize,
                    &pAllocationRequest->sumItemSize))
                {
                    pAllocationRequest->item = m_FreeSuballocationsBySize[index];
                    return true;
                }
            }
        }
    }

    if(canMakeOtherLost)
    {
        // Brute-force algorithm. TODO: Come up with something better.

        bool found = false;
        VmaAllocationRequest tmpAllocRequest = {};
        tmpAllocRequest.type = VmaAllocationRequestType::Normal;
        for(VmaSuballocationList::iterator suballocIt = m_Suballocations.begin();
            suballocIt != m_Suballocations.end();
            ++suballocIt)
        {
            if(suballocIt->type == VMA_SUBALLOCATION_TYPE_FREE ||
                suballocIt->hAllocation->CanBecomeLost())
            {
                if(CheckAllocation(
                    currentFrameIndex,
                    frameInUseCount,
                    bufferImageGranularity,
                    allocSize,
                    allocAlignment,
                    allocType,
                    suballocIt,
                    canMakeOtherLost,
                    &tmpAllocRequest.offset,
                    &tmpAllocRequest.itemsToMakeLostCount,
                    &tmpAllocRequest.sumFreeSize,
                    &tmpAllocRequest.sumItemSize))
                {
                    if(strategy == VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT)
                    {
                        *pAllocationRequest = tmpAllocRequest;
                        pAllocationRequest->item = suballocIt;
                        break;
                    }
                    if(!found || tmpAllocRequest.CalcCost() < pAllocationRequest->CalcCost())
                    {
                        *pAllocationRequest = tmpAllocRequest;
                        pAllocationRequest->item = suballocIt;
                        found = true;
                    }
                }
            }
        }

        return found;
    }

    return false;
}

bool VmaBlockMetadata_Generic::MakeRequestedAllocationsLost(
    uint32_t currentFrameIndex,
    uint32_t frameInUseCount,
    VmaAllocationRequest* pAllocationRequest)
{
    VMA_ASSERT(pAllocationRequest && pAllocationRequest->type == VmaAllocationRequestType::Normal);

    while(pAllocationRequest->itemsToMakeLostCount > 0)
    {
        if(pAllocationRequest->item->type == VMA_SUBALLOCATION_TYPE_FREE)
        {
            ++pAllocationRequest->item;
        }
        VMA_ASSERT(pAllocationRequest->item != m_Suballocations.end());
        VMA_ASSERT(pAllocationRequest->item->hAllocation != VK_NULL_HANDLE);
        VMA_ASSERT(pAllocationRequest->item->hAllocation->CanBecomeLost());
        if(pAllocationRequest->item->hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
        {
            pAllocationRequest->item = FreeSuballocation(pAllocationRequest->item);
            --pAllocationRequest->itemsToMakeLostCount;
        }
        else
        {
            return false;
        }
    }

    VMA_HEAVY_ASSERT(Validate());
    VMA_ASSERT(pAllocationRequest->item != m_Suballocations.end());
    VMA_ASSERT(pAllocationRequest->item->type == VMA_SUBALLOCATION_TYPE_FREE);
    
    return true;
}

uint32_t VmaBlockMetadata_Generic::MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount)
{
    uint32_t lostAllocationCount = 0;
    for(VmaSuballocationList::iterator it = m_Suballocations.begin();
        it != m_Suballocations.end();
        ++it)
    {
        if(it->type != VMA_SUBALLOCATION_TYPE_FREE &&
            it->hAllocation->CanBecomeLost() &&
            it->hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
        {
            it = FreeSuballocation(it);
            ++lostAllocationCount;
        }
    }
    return lostAllocationCount;
}

VkResult VmaBlockMetadata_Generic::CheckCorruption(const void* pBlockData)
{
    for(VmaSuballocationList::iterator it = m_Suballocations.begin();
        it != m_Suballocations.end();
        ++it)
    {
        if(it->type != VMA_SUBALLOCATION_TYPE_FREE)
        {
            if(!VmaValidateMagicValue(pBlockData, it->offset - VMA_DEBUG_MARGIN))
            {
                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED BEFORE VALIDATED ALLOCATION!");
                return VK_ERROR_VALIDATION_FAILED_EXT;
            }
            if(!VmaValidateMagicValue(pBlockData, it->offset + it->size))
            {
                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED AFTER VALIDATED ALLOCATION!");
                return VK_ERROR_VALIDATION_FAILED_EXT;
            }
        }
    }

    return VK_SUCCESS;
}

void VmaBlockMetadata_Generic::Alloc(
    const VmaAllocationRequest& request,
    VmaSuballocationType type,
    VkDeviceSize allocSize,
    VmaAllocation hAllocation)
{
    VMA_ASSERT(request.type == VmaAllocationRequestType::Normal);
    VMA_ASSERT(request.item != m_Suballocations.end());
    VmaSuballocation& suballoc = *request.item;
    // Given suballocation is a free block.
    VMA_ASSERT(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);
    // Given offset is inside this suballocation.
    VMA_ASSERT(request.offset >= suballoc.offset);
    const VkDeviceSize paddingBegin = request.offset - suballoc.offset;
    VMA_ASSERT(suballoc.size >= paddingBegin + allocSize);
    const VkDeviceSize paddingEnd = suballoc.size - paddingBegin - allocSize;

    // Unregister this free suballocation from m_FreeSuballocationsBySize and update
    // it to become used.
    UnregisterFreeSuballocation(request.item);

    suballoc.offset = request.offset;
    suballoc.size = allocSize;
    suballoc.type = type;
    suballoc.hAllocation = hAllocation;

    // If there are any free bytes remaining at the end, insert new free suballocation after current one.
    if(paddingEnd)
    {
        VmaSuballocation paddingSuballoc = {};
        paddingSuballoc.offset = request.offset + allocSize;
        paddingSuballoc.size = paddingEnd;
        paddingSuballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
        VmaSuballocationList::iterator next = request.item;
        ++next;
        const VmaSuballocationList::iterator paddingEndItem =
            m_Suballocations.insert(next, paddingSuballoc);
        RegisterFreeSuballocation(paddingEndItem);
    }

    // If there are any free bytes remaining at the beginning, insert new free suballocation before current one.
    if(paddingBegin)
    {
        VmaSuballocation paddingSuballoc = {};
        paddingSuballoc.offset = request.offset - paddingBegin;
        paddingSuballoc.size = paddingBegin;
        paddingSuballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
        const VmaSuballocationList::iterator paddingBeginItem =
            m_Suballocations.insert(request.item, paddingSuballoc);
        RegisterFreeSuballocation(paddingBeginItem);
    }

    // Update totals.
    m_FreeCount = m_FreeCount - 1;
    if(paddingBegin > 0)
    {
        ++m_FreeCount;
    }
    if(paddingEnd > 0)
    {
        ++m_FreeCount;
    }
    m_SumFreeSize -= allocSize;
}

void VmaBlockMetadata_Generic::Free(const VmaAllocation allocation)
{
    for(VmaSuballocationList::iterator suballocItem = m_Suballocations.begin();
        suballocItem != m_Suballocations.end();
        ++suballocItem)
    {
        VmaSuballocation& suballoc = *suballocItem;
        if(suballoc.hAllocation == allocation)
        {
            FreeSuballocation(suballocItem);
            VMA_HEAVY_ASSERT(Validate());
            return;
        }
    }
    VMA_ASSERT(0 && "Not found!");
}

void VmaBlockMetadata_Generic::FreeAtOffset(VkDeviceSize offset)
{
    for(VmaSuballocationList::iterator suballocItem = m_Suballocations.begin();
        suballocItem != m_Suballocations.end();
        ++suballocItem)
    {
        VmaSuballocation& suballoc = *suballocItem;
        if(suballoc.offset == offset)
        {
            FreeSuballocation(suballocItem);
            return;
        }
    }
    VMA_ASSERT(0 && "Not found!");
}

bool VmaBlockMetadata_Generic::ValidateFreeSuballocationList() const
{
    VkDeviceSize lastSize = 0;
    for(size_t i = 0, count = m_FreeSuballocationsBySize.size(); i < count; ++i)
    {
        const VmaSuballocationList::iterator it = m_FreeSuballocationsBySize[i];

        VMA_VALIDATE(it->type == VMA_SUBALLOCATION_TYPE_FREE);
        VMA_VALIDATE(it->size >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER);
        VMA_VALIDATE(it->size >= lastSize);
        lastSize = it->size;
    }
    return true;
}

bool VmaBlockMetadata_Generic::CheckAllocation(
    uint32_t currentFrameIndex,
    uint32_t frameInUseCount,
    VkDeviceSize bufferImageGranularity,
    VkDeviceSize allocSize,
    VkDeviceSize allocAlignment,
    VmaSuballocationType allocType,
    VmaSuballocationList::const_iterator suballocItem,
    bool canMakeOtherLost,
    VkDeviceSize* pOffset,
    size_t* itemsToMakeLostCount,
    VkDeviceSize* pSumFreeSize,
    VkDeviceSize* pSumItemSize) const
{
    VMA_ASSERT(allocSize > 0);
    VMA_ASSERT(allocType != VMA_SUBALLOCATION_TYPE_FREE);
    VMA_ASSERT(suballocItem != m_Suballocations.cend());
    VMA_ASSERT(pOffset != VMA_NULL);
    
    *itemsToMakeLostCount = 0;
    *pSumFreeSize = 0;
    *pSumItemSize = 0;

    if(canMakeOtherLost)
    {
        if(suballocItem->type == VMA_SUBALLOCATION_TYPE_FREE)
        {
            *pSumFreeSize = suballocItem->size;
        }
        else
        {
            if(suballocItem->hAllocation->CanBecomeLost() &&
                suballocItem->hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
            {
                ++*itemsToMakeLostCount;
                *pSumItemSize = suballocItem->size;
            }
            else
            {
                return false;
            }
        }

        // Remaining size is too small for this request: Early return.
        if(GetSize() - suballocItem->offset < allocSize)
        {
            return false;
        }

        // Start from offset equal to beginning of this suballocation.
        *pOffset = suballocItem->offset;
    
        // Apply VMA_DEBUG_MARGIN at the beginning.
        if(VMA_DEBUG_MARGIN > 0)
        {
            *pOffset += VMA_DEBUG_MARGIN;
        }
    
        // Apply alignment.
        *pOffset = VmaAlignUp(*pOffset, allocAlignment);

        // Check previous suballocations for BufferImageGranularity conflicts.
        // Make bigger alignment if necessary.
        if(bufferImageGranularity > 1)
        {
            bool bufferImageGranularityConflict = false;
            VmaSuballocationList::const_iterator prevSuballocItem = suballocItem;
            while(prevSuballocItem != m_Suballocations.cbegin())
            {
                --prevSuballocItem;
                const VmaSuballocation& prevSuballoc = *prevSuballocItem;
                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, *pOffset, bufferImageGranularity))
                {
                    if(VmaIsBufferImageGranularityConflict(prevSuballoc.type, allocType))
                    {
                        bufferImageGranularityConflict = true;
                        break;
                    }
                }
                else
                    // Already on previous page.
                    break;
            }
            if(bufferImageGranularityConflict)
            {
                *pOffset = VmaAlignUp(*pOffset, bufferImageGranularity);
            }
        }
    
        // Now that we have final *pOffset, check if we are past suballocItem.
        // If yes, return false - this function should be called for another suballocItem as starting point.
        if(*pOffset >= suballocItem->offset + suballocItem->size)
        {
            return false;
        }
    
        // Calculate padding at the beginning based on current offset.
        const VkDeviceSize paddingBegin = *pOffset - suballocItem->offset;

        // Calculate required margin at the end.
        const VkDeviceSize requiredEndMargin = VMA_DEBUG_MARGIN;

        const VkDeviceSize totalSize = paddingBegin + allocSize + requiredEndMargin;
        // Another early return check.
        if(suballocItem->offset + totalSize > GetSize())
        {
            return false;
        }

        // Advance lastSuballocItem until desired size is reached.
        // Update itemsToMakeLostCount.
        VmaSuballocationList::const_iterator lastSuballocItem = suballocItem;
        if(totalSize > suballocItem->size)
        {
            VkDeviceSize remainingSize = totalSize - suballocItem->size;
            while(remainingSize > 0)
            {
                ++lastSuballocItem;
                if(lastSuballocItem == m_Suballocations.cend())
                {
                    return false;
                }
                if(lastSuballocItem->type == VMA_SUBALLOCATION_TYPE_FREE)
                {
                    *pSumFreeSize += lastSuballocItem->size;
                }
                else
                {
                    VMA_ASSERT(lastSuballocItem->hAllocation != VK_NULL_HANDLE);
                    if(lastSuballocItem->hAllocation->CanBecomeLost() &&
                        lastSuballocItem->hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
                    {
                        ++*itemsToMakeLostCount;
                        *pSumItemSize += lastSuballocItem->size;
                    }
                    else
                    {
                        return false;
                    }
                }
                remainingSize = (lastSuballocItem->size < remainingSize) ?
                    remainingSize - lastSuballocItem->size : 0;
            }
        }

        // Check next suballocations for BufferImageGranularity conflicts.
        // If conflict exists, we must mark more allocations lost or fail.
        if(bufferImageGranularity > 1)
        {
            VmaSuballocationList::const_iterator nextSuballocItem = lastSuballocItem;
            ++nextSuballocItem;
            while(nextSuballocItem != m_Suballocations.cend())
            {
                const VmaSuballocation& nextSuballoc = *nextSuballocItem;
                if(VmaBlocksOnSamePage(*pOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
                {
                    if(VmaIsBufferImageGranularityConflict(allocType, nextSuballoc.type))
                    {
                        VMA_ASSERT(nextSuballoc.hAllocation != VK_NULL_HANDLE);
                        if(nextSuballoc.hAllocation->CanBecomeLost() &&
                            nextSuballoc.hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
                        {
                            ++*itemsToMakeLostCount;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                {
                    // Already on next page.
                    break;
                }
                ++nextSuballocItem;
            }
        }
    }
    else
    {
        const VmaSuballocation& suballoc = *suballocItem;
        VMA_ASSERT(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);

        *pSumFreeSize = suballoc.size;

        // Size of this suballocation is too small for this request: Early return.
        if(suballoc.size < allocSize)
        {
            return false;
        }

        // Start from offset equal to beginning of this suballocation.
        *pOffset = suballoc.offset;
    
        // Apply VMA_DEBUG_MARGIN at the beginning.
        if(VMA_DEBUG_MARGIN > 0)
        {
            *pOffset += VMA_DEBUG_MARGIN;
        }
    
        // Apply alignment.
        *pOffset = VmaAlignUp(*pOffset, allocAlignment);
    
        // Check previous suballocations for BufferImageGranularity conflicts.
        // Make bigger alignment if necessary.
        if(bufferImageGranularity > 1)
        {
            bool bufferImageGranularityConflict = false;
            VmaSuballocationList::const_iterator prevSuballocItem = suballocItem;
            while(prevSuballocItem != m_Suballocations.cbegin())
            {
                --prevSuballocItem;
                const VmaSuballocation& prevSuballoc = *prevSuballocItem;
                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, *pOffset, bufferImageGranularity))
                {
                    if(VmaIsBufferImageGranularityConflict(prevSuballoc.type, allocType))
                    {
                        bufferImageGranularityConflict = true;
                        break;
                    }
                }
                else
                    // Already on previous page.
                    break;
            }
            if(bufferImageGranularityConflict)
            {
                *pOffset = VmaAlignUp(*pOffset, bufferImageGranularity);
            }
        }
    
        // Calculate padding at the beginning based on current offset.
        const VkDeviceSize paddingBegin = *pOffset - suballoc.offset;

        // Calculate required margin at the end.
        const VkDeviceSize requiredEndMargin = VMA_DEBUG_MARGIN;

        // Fail if requested size plus margin before and after is bigger than size of this suballocation.
        if(paddingBegin + allocSize + requiredEndMargin > suballoc.size)
        {
            return false;
        }

        // Check next suballocations for BufferImageGranularity conflicts.
        // If conflict exists, allocation cannot be made here.
        if(bufferImageGranularity > 1)
        {
            VmaSuballocationList::const_iterator nextSuballocItem = suballocItem;
            ++nextSuballocItem;
            while(nextSuballocItem != m_Suballocations.cend())
            {
                const VmaSuballocation& nextSuballoc = *nextSuballocItem;
                if(VmaBlocksOnSamePage(*pOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
                {
                    if(VmaIsBufferImageGranularityConflict(allocType, nextSuballoc.type))
                    {
                        return false;
                    }
                }
                else
                {
                    // Already on next page.
                    break;
                }
                ++nextSuballocItem;
            }
        }
    }

    // All tests passed: Success. pOffset is already filled.
    return true;
}

void VmaBlockMetadata_Generic::MergeFreeWithNext(VmaSuballocationList::iterator item)
{
    VMA_ASSERT(item != m_Suballocations.end());
    VMA_ASSERT(item->type == VMA_SUBALLOCATION_TYPE_FREE);
    
    VmaSuballocationList::iterator nextItem = item;
    ++nextItem;
    VMA_ASSERT(nextItem != m_Suballocations.end());
    VMA_ASSERT(nextItem->type == VMA_SUBALLOCATION_TYPE_FREE);

    item->size += nextItem->size;
    --m_FreeCount;
    m_Suballocations.erase(nextItem);
}

VmaSuballocationList::iterator VmaBlockMetadata_Generic::FreeSuballocation(VmaSuballocationList::iterator suballocItem)
{
    // Change this suballocation to be marked as free.
    VmaSuballocation& suballoc = *suballocItem;
    suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
    suballoc.hAllocation = VK_NULL_HANDLE;
    
    // Update totals.
    ++m_FreeCount;
    m_SumFreeSize += suballoc.size;

    // Merge with previous and/or next suballocation if it's also free.
    bool mergeWithNext = false;
    bool mergeWithPrev = false;
    
    VmaSuballocationList::iterator nextItem = suballocItem;
    ++nextItem;
    if((nextItem != m_Suballocations.end()) && (nextItem->type == VMA_SUBALLOCATION_TYPE_FREE))
    {
        mergeWithNext = true;
    }

    VmaSuballocationList::iterator prevItem = suballocItem;
    if(suballocItem != m_Suballocations.begin())
    {
        --prevItem;
        if(prevItem->type == VMA_SUBALLOCATION_TYPE_FREE)
        {
            mergeWithPrev = true;
        }
    }

    if(mergeWithNext)
    {
        UnregisterFreeSuballocation(nextItem);
        MergeFreeWithNext(suballocItem);
    }

    if(mergeWithPrev)
    {
        UnregisterFreeSuballocation(prevItem);
        MergeFreeWithNext(prevItem);
        RegisterFreeSuballocation(prevItem);
        return prevItem;
    }
    else
    {
        RegisterFreeSuballocation(suballocItem);
        return suballocItem;
    }
}

void VmaBlockMetadata_Generic::RegisterFreeSuballocation(VmaSuballocationList::iterator item)
{
    VMA_ASSERT(item->type == VMA_SUBALLOCATION_TYPE_FREE);
    VMA_ASSERT(item->size > 0);

    // You may want to enable this validation at the beginning or at the end of
    // this function, depending on what do you want to check.
    VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());

    if(item->size >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
    {
        if(m_FreeSuballocationsBySize.empty())
        {
            m_FreeSuballocationsBySize.push_back(item);
        }
        else
        {
            VmaVectorInsertSorted<VmaSuballocationItemSizeLess>(m_FreeSuballocationsBySize, item);
        }
    }

    //VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());
}


void VmaBlockMetadata_Generic::UnregisterFreeSuballocation(VmaSuballocationList::iterator item)
{
    VMA_ASSERT(item->type == VMA_SUBALLOCATION_TYPE_FREE);
    VMA_ASSERT(item->size > 0);

    // You may want to enable this validation at the beginning or at the end of
    // this function, depending on what do you want to check.
    VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());

    if(item->size >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
    {
        VmaSuballocationList::iterator* const it = VmaBinaryFindFirstNotLess(
            m_FreeSuballocationsBySize.data(),
            m_FreeSuballocationsBySize.data() + m_FreeSuballocationsBySize.size(),
            item,
            VmaSuballocationItemSizeLess());
        for(size_t index = it - m_FreeSuballocationsBySize.data();
            index < m_FreeSuballocationsBySize.size();
            ++index)
        {
            if(m_FreeSuballocationsBySize[index] == item)
            {
                VmaVectorRemove(m_FreeSuballocationsBySize, index);
                return;
            }
            VMA_ASSERT((m_FreeSuballocationsBySize[index]->size == item->size) && "Not found.");
        }
        VMA_ASSERT(0 && "Not found.");
    }

    //VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());
}

bool VmaBlockMetadata_Generic::IsBufferImageGranularityConflictPossible(
    VkDeviceSize bufferImageGranularity,
    VmaSuballocationType& inOutPrevSuballocType) const
{
    if(bufferImageGranularity == 1 || IsEmpty())
    {
        return false;
    }

    VkDeviceSize minAlignment = VK_WHOLE_SIZE;
    bool typeConflictFound = false;
    for(VmaSuballocationList::const_iterator it = m_Suballocations.cbegin();
        it != m_Suballocations.cend();
        ++it)
    {
        const VmaSuballocationType suballocType = it->type;
        if(suballocType != VMA_SUBALLOCATION_TYPE_FREE)
        {
            minAlignment = VMA_MIN(minAlignment, it->hAllocation->GetAlignment());
            if(VmaIsBufferImageGranularityConflict(inOutPrevSuballocType, suballocType))
            {
                typeConflictFound = true;
            }
            inOutPrevSuballocType = suballocType;
        }
    }

    return typeConflictFound || minAlignment >= bufferImageGranularity;
}

////////////////////////////////////////////////////////////////////////////////
// class VmaBlockMetadata_Linear

VmaBlockMetadata_Linear::VmaBlockMetadata_Linear(VmaAllocator hAllocator) :
    VmaBlockMetadata(hAllocator),
    m_SumFreeSize(0),
    m_Suballocations0(VmaStlAllocator<VmaSuballocation>(hAllocator->GetAllocationCallbacks())),
    m_Suballocations1(VmaStlAllocator<VmaSuballocation>(hAllocator->GetAllocationCallbacks())),
    m_1stVectorIndex(0),
    m_2ndVectorMode(SECOND_VECTOR_EMPTY),
    m_1stNullItemsBeginCount(0),
    m_1stNullItemsMiddleCount(0),
    m_2ndNullItemsCount(0)
{
}

VmaBlockMetadata_Linear::~VmaBlockMetadata_Linear()
{
}

void VmaBlockMetadata_Linear::Init(VkDeviceSize size)
{
    VmaBlockMetadata::Init(size);
    m_SumFreeSize = size;
}

bool VmaBlockMetadata_Linear::Validate() const
{
    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();

    VMA_VALIDATE(suballocations2nd.empty() == (m_2ndVectorMode == SECOND_VECTOR_EMPTY));
    VMA_VALIDATE(!suballocations1st.empty() ||
        suballocations2nd.empty() ||
        m_2ndVectorMode != SECOND_VECTOR_RING_BUFFER);

    if(!suballocations1st.empty())
    {
        // Null item at the beginning should be accounted into m_1stNullItemsBeginCount.
        VMA_VALIDATE(suballocations1st[m_1stNullItemsBeginCount].hAllocation != VK_NULL_HANDLE);
        // Null item at the end should be just pop_back().
        VMA_VALIDATE(suballocations1st.back().hAllocation != VK_NULL_HANDLE);
    }
    if(!suballocations2nd.empty())
    {
        // Null item at the end should be just pop_back().
        VMA_VALIDATE(suballocations2nd.back().hAllocation != VK_NULL_HANDLE);
    }

    VMA_VALIDATE(m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount <= suballocations1st.size());
    VMA_VALIDATE(m_2ndNullItemsCount <= suballocations2nd.size());

    VkDeviceSize sumUsedSize = 0;
    const size_t suballoc1stCount = suballocations1st.size();
    VkDeviceSize offset = VMA_DEBUG_MARGIN;

    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
    {
        const size_t suballoc2ndCount = suballocations2nd.size();
        size_t nullItem2ndCount = 0;
        for(size_t i = 0; i < suballoc2ndCount; ++i)
        {
            const VmaSuballocation& suballoc = suballocations2nd[i];
            const bool currFree = (suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);

            VMA_VALIDATE(currFree == (suballoc.hAllocation == VK_NULL_HANDLE));
            VMA_VALIDATE(suballoc.offset >= offset);

            if(!currFree)
            {
                VMA_VALIDATE(suballoc.hAllocation->GetOffset() == suballoc.offset);
                VMA_VALIDATE(suballoc.hAllocation->GetSize() == suballoc.size);
                sumUsedSize += suballoc.size;
            }
            else
            {
                ++nullItem2ndCount;
            }

            offset = suballoc.offset + suballoc.size + VMA_DEBUG_MARGIN;
        }

        VMA_VALIDATE(nullItem2ndCount == m_2ndNullItemsCount);
    }

    for(size_t i = 0; i < m_1stNullItemsBeginCount; ++i)
    {
        const VmaSuballocation& suballoc = suballocations1st[i];
        VMA_VALIDATE(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE &&
            suballoc.hAllocation == VK_NULL_HANDLE);
    }

    size_t nullItem1stCount = m_1stNullItemsBeginCount;

    for(size_t i = m_1stNullItemsBeginCount; i < suballoc1stCount; ++i)
    {
        const VmaSuballocation& suballoc = suballocations1st[i];
        const bool currFree = (suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);

        VMA_VALIDATE(currFree == (suballoc.hAllocation == VK_NULL_HANDLE));
        VMA_VALIDATE(suballoc.offset >= offset);
        VMA_VALIDATE(i >= m_1stNullItemsBeginCount || currFree);

        if(!currFree)
        {
            VMA_VALIDATE(suballoc.hAllocation->GetOffset() == suballoc.offset);
            VMA_VALIDATE(suballoc.hAllocation->GetSize() == suballoc.size);
            sumUsedSize += suballoc.size;
        }
        else
        {
            ++nullItem1stCount;
        }

        offset = suballoc.offset + suballoc.size + VMA_DEBUG_MARGIN;
    }
    VMA_VALIDATE(nullItem1stCount == m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount);

    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
    {
        const size_t suballoc2ndCount = suballocations2nd.size();
        size_t nullItem2ndCount = 0;
        for(size_t i = suballoc2ndCount; i--; )
        {
            const VmaSuballocation& suballoc = suballocations2nd[i];
            const bool currFree = (suballoc.type == VMA_SUBALLOCATION_TYPE_FREE);

            VMA_VALIDATE(currFree == (suballoc.hAllocation == VK_NULL_HANDLE));
            VMA_VALIDATE(suballoc.offset >= offset);

            if(!currFree)
            {
                VMA_VALIDATE(suballoc.hAllocation->GetOffset() == suballoc.offset);
                VMA_VALIDATE(suballoc.hAllocation->GetSize() == suballoc.size);
                sumUsedSize += suballoc.size;
            }
            else
            {
                ++nullItem2ndCount;
            }

            offset = suballoc.offset + suballoc.size + VMA_DEBUG_MARGIN;
        }

        VMA_VALIDATE(nullItem2ndCount == m_2ndNullItemsCount);
    }

    VMA_VALIDATE(offset <= GetSize());
    VMA_VALIDATE(m_SumFreeSize == GetSize() - sumUsedSize);

    return true;
}

size_t VmaBlockMetadata_Linear::GetAllocationCount() const
{
    return AccessSuballocations1st().size() - (m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount) +
        AccessSuballocations2nd().size() - m_2ndNullItemsCount;
}

VkDeviceSize VmaBlockMetadata_Linear::GetUnusedRangeSizeMax() const
{
    const VkDeviceSize size = GetSize();

    /*
    We don't consider gaps inside allocation vectors with freed allocations because
    they are not suitable for reuse in linear allocator. We consider only space that
    is available for new allocations.
    */
    if(IsEmpty())
    {
        return size;
    }
    
    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();

    switch(m_2ndVectorMode)
    {
    case SECOND_VECTOR_EMPTY:
        /*
        Available space is after end of 1st, as well as before beginning of 1st (which
        whould make it a ring buffer).
        */
        {
            const size_t suballocations1stCount = suballocations1st.size();
            VMA_ASSERT(suballocations1stCount > m_1stNullItemsBeginCount);
            const VmaSuballocation& firstSuballoc = suballocations1st[m_1stNullItemsBeginCount];
            const VmaSuballocation& lastSuballoc  = suballocations1st[suballocations1stCount - 1];
            return VMA_MAX(
                firstSuballoc.offset,
                size - (lastSuballoc.offset + lastSuballoc.size));
        }
        break;

    case SECOND_VECTOR_RING_BUFFER:
        /*
        Available space is only between end of 2nd and beginning of 1st.
        */
        {
            const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
            const VmaSuballocation& lastSuballoc2nd = suballocations2nd.back();
            const VmaSuballocation& firstSuballoc1st = suballocations1st[m_1stNullItemsBeginCount];
            return firstSuballoc1st.offset - (lastSuballoc2nd.offset + lastSuballoc2nd.size);
        }
        break;

    case SECOND_VECTOR_DOUBLE_STACK:
        /*
        Available space is only between end of 1st and top of 2nd.
        */
        {
            const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
            const VmaSuballocation& topSuballoc2nd = suballocations2nd.back();
            const VmaSuballocation& lastSuballoc1st = suballocations1st.back();
            return topSuballoc2nd.offset - (lastSuballoc1st.offset + lastSuballoc1st.size);
        }
        break;

    default:
        VMA_ASSERT(0);
        return 0;
    }
}

void VmaBlockMetadata_Linear::CalcAllocationStatInfo(VmaStatInfo& outInfo) const
{
    const VkDeviceSize size = GetSize();
    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
    const size_t suballoc1stCount = suballocations1st.size();
    const size_t suballoc2ndCount = suballocations2nd.size();

    outInfo.blockCount = 1;
    outInfo.allocationCount = (uint32_t)GetAllocationCount();
    outInfo.unusedRangeCount = 0;
    outInfo.usedBytes = 0;
    outInfo.allocationSizeMin = UINT64_MAX;
    outInfo.allocationSizeMax = 0;
    outInfo.unusedRangeSizeMin = UINT64_MAX;
    outInfo.unusedRangeSizeMax = 0;

    VkDeviceSize lastOffset = 0;

    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
    {
        const VkDeviceSize freeSpace2ndTo1stEnd = suballocations1st[m_1stNullItemsBeginCount].offset;
        size_t nextAlloc2ndIndex = 0;
        while(lastOffset < freeSpace2ndTo1stEnd)
        {
            // Find next non-null allocation or move nextAllocIndex to the end.
            while(nextAlloc2ndIndex < suballoc2ndCount &&
                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
            {
                ++nextAlloc2ndIndex;
            }

            // Found non-null allocation.
            if(nextAlloc2ndIndex < suballoc2ndCount)
            {
                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
            
                // 1. Process free space before this allocation.
                if(lastOffset < suballoc.offset)
                {
                    // There is free space from lastOffset to suballoc.offset.
                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
                    ++outInfo.unusedRangeCount;
                    outInfo.unusedBytes += unusedRangeSize;
                    outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
                    outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
                }
            
                // 2. Process this allocation.
                // There is allocation with suballoc.offset, suballoc.size.
                outInfo.usedBytes += suballoc.size;
                outInfo.allocationSizeMin = VMA_MIN(outInfo.allocationSizeMin, suballoc.size);
                outInfo.allocationSizeMax = VMA_MIN(outInfo.allocationSizeMax, suballoc.size);
            
                // 3. Prepare for next iteration.
                lastOffset = suballoc.offset + suballoc.size;
                ++nextAlloc2ndIndex;
            }
            // We are at the end.
            else
            {
                // There is free space from lastOffset to freeSpace2ndTo1stEnd.
                if(lastOffset < freeSpace2ndTo1stEnd)
                {
                    const VkDeviceSize unusedRangeSize = freeSpace2ndTo1stEnd - lastOffset;
                    ++outInfo.unusedRangeCount;
                    outInfo.unusedBytes += unusedRangeSize;
                    outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
                    outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
               }

                // End of loop.
                lastOffset = freeSpace2ndTo1stEnd;
            }
        }
    }

    size_t nextAlloc1stIndex = m_1stNullItemsBeginCount;
    const VkDeviceSize freeSpace1stTo2ndEnd =
        m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK ? suballocations2nd.back().offset : size;
    while(lastOffset < freeSpace1stTo2ndEnd)
    {
        // Find next non-null allocation or move nextAllocIndex to the end.
        while(nextAlloc1stIndex < suballoc1stCount &&
            suballocations1st[nextAlloc1stIndex].hAllocation == VK_NULL_HANDLE)
        {
            ++nextAlloc1stIndex;
        }

        // Found non-null allocation.
        if(nextAlloc1stIndex < suballoc1stCount)
        {
            const VmaSuballocation& suballoc = suballocations1st[nextAlloc1stIndex];
            
            // 1. Process free space before this allocation.
            if(lastOffset < suballoc.offset)
            {
                // There is free space from lastOffset to suballoc.offset.
                const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
                ++outInfo.unusedRangeCount;
                outInfo.unusedBytes += unusedRangeSize;
                outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
                outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
            }
            
            // 2. Process this allocation.
            // There is allocation with suballoc.offset, suballoc.size.
            outInfo.usedBytes += suballoc.size;
            outInfo.allocationSizeMin = VMA_MIN(outInfo.allocationSizeMin, suballoc.size);
            outInfo.allocationSizeMax = VMA_MIN(outInfo.allocationSizeMax, suballoc.size);
            
            // 3. Prepare for next iteration.
            lastOffset = suballoc.offset + suballoc.size;
            ++nextAlloc1stIndex;
        }
        // We are at the end.
        else
        {
            // There is free space from lastOffset to freeSpace1stTo2ndEnd.
            if(lastOffset < freeSpace1stTo2ndEnd)
            {
                const VkDeviceSize unusedRangeSize = freeSpace1stTo2ndEnd - lastOffset;
                ++outInfo.unusedRangeCount;
                outInfo.unusedBytes += unusedRangeSize;
                outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
                outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
           }

            // End of loop.
            lastOffset = freeSpace1stTo2ndEnd;
        }
    }

    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
    {
        size_t nextAlloc2ndIndex = suballocations2nd.size() - 1;
        while(lastOffset < size)
        {
            // Find next non-null allocation or move nextAllocIndex to the end.
            while(nextAlloc2ndIndex != SIZE_MAX &&
                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
            {
                --nextAlloc2ndIndex;
            }

            // Found non-null allocation.
            if(nextAlloc2ndIndex != SIZE_MAX)
            {
                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
            
                // 1. Process free space before this allocation.
                if(lastOffset < suballoc.offset)
                {
                    // There is free space from lastOffset to suballoc.offset.
                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
                    ++outInfo.unusedRangeCount;
                    outInfo.unusedBytes += unusedRangeSize;
                    outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
                    outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
                }
            
                // 2. Process this allocation.
                // There is allocation with suballoc.offset, suballoc.size.
                outInfo.usedBytes += suballoc.size;
                outInfo.allocationSizeMin = VMA_MIN(outInfo.allocationSizeMin, suballoc.size);
                outInfo.allocationSizeMax = VMA_MIN(outInfo.allocationSizeMax, suballoc.size);
            
                // 3. Prepare for next iteration.
                lastOffset = suballoc.offset + suballoc.size;
                --nextAlloc2ndIndex;
            }
            // We are at the end.
            else
            {
                // There is free space from lastOffset to size.
                if(lastOffset < size)
                {
                    const VkDeviceSize unusedRangeSize = size - lastOffset;
                    ++outInfo.unusedRangeCount;
                    outInfo.unusedBytes += unusedRangeSize;
                    outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusedRangeSize);
                    outInfo.unusedRangeSizeMax = VMA_MIN(outInfo.unusedRangeSizeMax, unusedRangeSize);
               }

                // End of loop.
                lastOffset = size;
            }
        }
    }

    outInfo.unusedBytes = size - outInfo.usedBytes;
}

void VmaBlockMetadata_Linear::AddPoolStats(VmaPoolStats& inoutStats) const
{
    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
    const VkDeviceSize size = GetSize();
    const size_t suballoc1stCount = suballocations1st.size();
    const size_t suballoc2ndCount = suballocations2nd.size();

    inoutStats.size += size;

    VkDeviceSize lastOffset = 0;

    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
    {
        const VkDeviceSize freeSpace2ndTo1stEnd = suballocations1st[m_1stNullItemsBeginCount].offset;
        size_t nextAlloc2ndIndex = m_1stNullItemsBeginCount;
        while(lastOffset < freeSpace2ndTo1stEnd)
        {
            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
            while(nextAlloc2ndIndex < suballoc2ndCount &&
                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
            {
                ++nextAlloc2ndIndex;
            }

            // Found non-null allocation.
            if(nextAlloc2ndIndex < suballoc2ndCount)
            {
                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
            
                // 1. Process free space before this allocation.
                if(lastOffset < suballoc.offset)
                {
                    // There is free space from lastOffset to suballoc.offset.
                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
                    inoutStats.unusedSize += unusedRangeSize;
                    ++inoutStats.unusedRangeCount;
                    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
                }
            
                // 2. Process this allocation.
                // There is allocation with suballoc.offset, suballoc.size.
                ++inoutStats.allocationCount;
            
                // 3. Prepare for next iteration.
                lastOffset = suballoc.offset + suballoc.size;
                ++nextAlloc2ndIndex;
            }
            // We are at the end.
            else
            {
                if(lastOffset < freeSpace2ndTo1stEnd)
                {
                    // There is free space from lastOffset to freeSpace2ndTo1stEnd.
                    const VkDeviceSize unusedRangeSize = freeSpace2ndTo1stEnd - lastOffset;
                    inoutStats.unusedSize += unusedRangeSize;
                    ++inoutStats.unusedRangeCount;
                    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
                }

                // End of loop.
                lastOffset = freeSpace2ndTo1stEnd;
            }
        }
    }

    size_t nextAlloc1stIndex = m_1stNullItemsBeginCount;
    const VkDeviceSize freeSpace1stTo2ndEnd =
        m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK ? suballocations2nd.back().offset : size;
    while(lastOffset < freeSpace1stTo2ndEnd)
    {
        // Find next non-null allocation or move nextAllocIndex to the end.
        while(nextAlloc1stIndex < suballoc1stCount &&
            suballocations1st[nextAlloc1stIndex].hAllocation == VK_NULL_HANDLE)
        {
            ++nextAlloc1stIndex;
        }

        // Found non-null allocation.
        if(nextAlloc1stIndex < suballoc1stCount)
        {
            const VmaSuballocation& suballoc = suballocations1st[nextAlloc1stIndex];
            
            // 1. Process free space before this allocation.
            if(lastOffset < suballoc.offset)
            {
                // There is free space from lastOffset to suballoc.offset.
                const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
                inoutStats.unusedSize += unusedRangeSize;
                ++inoutStats.unusedRangeCount;
                inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
            }
            
            // 2. Process this allocation.
            // There is allocation with suballoc.offset, suballoc.size.
            ++inoutStats.allocationCount;
            
            // 3. Prepare for next iteration.
            lastOffset = suballoc.offset + suballoc.size;
            ++nextAlloc1stIndex;
        }
        // We are at the end.
        else
        {
            if(lastOffset < freeSpace1stTo2ndEnd)
            {
                // There is free space from lastOffset to freeSpace1stTo2ndEnd.
                const VkDeviceSize unusedRangeSize = freeSpace1stTo2ndEnd - lastOffset;
                inoutStats.unusedSize += unusedRangeSize;
                ++inoutStats.unusedRangeCount;
                inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
            }

            // End of loop.
            lastOffset = freeSpace1stTo2ndEnd;
        }
    }

    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
    {
        size_t nextAlloc2ndIndex = suballocations2nd.size() - 1;
        while(lastOffset < size)
        {
            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
            while(nextAlloc2ndIndex != SIZE_MAX &&
                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
            {
                --nextAlloc2ndIndex;
            }

            // Found non-null allocation.
            if(nextAlloc2ndIndex != SIZE_MAX)
            {
                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
            
                // 1. Process free space before this allocation.
                if(lastOffset < suballoc.offset)
                {
                    // There is free space from lastOffset to suballoc.offset.
                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
                    inoutStats.unusedSize += unusedRangeSize;
                    ++inoutStats.unusedRangeCount;
                    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
                }
            
                // 2. Process this allocation.
                // There is allocation with suballoc.offset, suballoc.size.
                ++inoutStats.allocationCount;
            
                // 3. Prepare for next iteration.
                lastOffset = suballoc.offset + suballoc.size;
                --nextAlloc2ndIndex;
            }
            // We are at the end.
            else
            {
                if(lastOffset < size)
                {
                    // There is free space from lastOffset to size.
                    const VkDeviceSize unusedRangeSize = size - lastOffset;
                    inoutStats.unusedSize += unusedRangeSize;
                    ++inoutStats.unusedRangeCount;
                    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, unusedRangeSize);
                }

                // End of loop.
                lastOffset = size;
            }
        }
    }
}

#if VMA_STATS_STRING_ENABLED
void VmaBlockMetadata_Linear::PrintDetailedMap(class VmaJsonWriter& json) const
{
    const VkDeviceSize size = GetSize();
    const SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    const SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
    const size_t suballoc1stCount = suballocations1st.size();
    const size_t suballoc2ndCount = suballocations2nd.size();

    // FIRST PASS

    size_t unusedRangeCount = 0;
    VkDeviceSize usedBytes = 0;

    VkDeviceSize lastOffset = 0;

    size_t alloc2ndCount = 0;
    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
    {
        const VkDeviceSize freeSpace2ndTo1stEnd = suballocations1st[m_1stNullItemsBeginCount].offset;
        size_t nextAlloc2ndIndex = 0;
        while(lastOffset < freeSpace2ndTo1stEnd)
        {
            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
            while(nextAlloc2ndIndex < suballoc2ndCount &&
                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
            {
                ++nextAlloc2ndIndex;
            }

            // Found non-null allocation.
            if(nextAlloc2ndIndex < suballoc2ndCount)
            {
                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
            
                // 1. Process free space before this allocation.
                if(lastOffset < suballoc.offset)
                {
                    // There is free space from lastOffset to suballoc.offset.
                    ++unusedRangeCount;
                }
            
                // 2. Process this allocation.
                // There is allocation with suballoc.offset, suballoc.size.
                ++alloc2ndCount;
                usedBytes += suballoc.size;
            
                // 3. Prepare for next iteration.
                lastOffset = suballoc.offset + suballoc.size;
                ++nextAlloc2ndIndex;
            }
            // We are at the end.
            else
            {
                if(lastOffset < freeSpace2ndTo1stEnd)
                {
                    // There is free space from lastOffset to freeSpace2ndTo1stEnd.
                    ++unusedRangeCount;
                }

                // End of loop.
                lastOffset = freeSpace2ndTo1stEnd;
            }
        }
    }

    size_t nextAlloc1stIndex = m_1stNullItemsBeginCount;
    size_t alloc1stCount = 0;
    const VkDeviceSize freeSpace1stTo2ndEnd =
        m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK ? suballocations2nd.back().offset : size;
    while(lastOffset < freeSpace1stTo2ndEnd)
    {
        // Find next non-null allocation or move nextAllocIndex to the end.
        while(nextAlloc1stIndex < suballoc1stCount &&
            suballocations1st[nextAlloc1stIndex].hAllocation == VK_NULL_HANDLE)
        {
            ++nextAlloc1stIndex;
        }

        // Found non-null allocation.
        if(nextAlloc1stIndex < suballoc1stCount)
        {
            const VmaSuballocation& suballoc = suballocations1st[nextAlloc1stIndex];
            
            // 1. Process free space before this allocation.
            if(lastOffset < suballoc.offset)
            {
                // There is free space from lastOffset to suballoc.offset.
                ++unusedRangeCount;
            }
            
            // 2. Process this allocation.
            // There is allocation with suballoc.offset, suballoc.size.
            ++alloc1stCount;
            usedBytes += suballoc.size;
            
            // 3. Prepare for next iteration.
            lastOffset = suballoc.offset + suballoc.size;
            ++nextAlloc1stIndex;
        }
        // We are at the end.
        else
        {
            if(lastOffset < size)
            {
                // There is free space from lastOffset to freeSpace1stTo2ndEnd.
                ++unusedRangeCount;
            }

            // End of loop.
            lastOffset = freeSpace1stTo2ndEnd;
        }
    }

    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
    {
        size_t nextAlloc2ndIndex = suballocations2nd.size() - 1;
        while(lastOffset < size)
        {
            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
            while(nextAlloc2ndIndex != SIZE_MAX &&
                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
            {
                --nextAlloc2ndIndex;
            }

            // Found non-null allocation.
            if(nextAlloc2ndIndex != SIZE_MAX)
            {
                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
            
                // 1. Process free space before this allocation.
                if(lastOffset < suballoc.offset)
                {
                    // There is free space from lastOffset to suballoc.offset.
                    ++unusedRangeCount;
                }
            
                // 2. Process this allocation.
                // There is allocation with suballoc.offset, suballoc.size.
                ++alloc2ndCount;
                usedBytes += suballoc.size;
            
                // 3. Prepare for next iteration.
                lastOffset = suballoc.offset + suballoc.size;
                --nextAlloc2ndIndex;
            }
            // We are at the end.
            else
            {
                if(lastOffset < size)
                {
                    // There is free space from lastOffset to size.
                    ++unusedRangeCount;
                }

                // End of loop.
                lastOffset = size;
            }
        }
    }

    const VkDeviceSize unusedBytes = size - usedBytes;
    PrintDetailedMap_Begin(json, unusedBytes, alloc1stCount + alloc2ndCount, unusedRangeCount);

    // SECOND PASS
    lastOffset = 0;

    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
    {
        const VkDeviceSize freeSpace2ndTo1stEnd = suballocations1st[m_1stNullItemsBeginCount].offset;
        size_t nextAlloc2ndIndex = 0;
        while(lastOffset < freeSpace2ndTo1stEnd)
        {
            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
            while(nextAlloc2ndIndex < suballoc2ndCount &&
                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
            {
                ++nextAlloc2ndIndex;
            }

            // Found non-null allocation.
            if(nextAlloc2ndIndex < suballoc2ndCount)
            {
                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
            
                // 1. Process free space before this allocation.
                if(lastOffset < suballoc.offset)
                {
                    // There is free space from lastOffset to suballoc.offset.
                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
                    PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
                }
            
                // 2. Process this allocation.
                // There is allocation with suballoc.offset, suballoc.size.
                PrintDetailedMap_Allocation(json, suballoc.offset, suballoc.hAllocation);
            
                // 3. Prepare for next iteration.
                lastOffset = suballoc.offset + suballoc.size;
                ++nextAlloc2ndIndex;
            }
            // We are at the end.
            else
            {
                if(lastOffset < freeSpace2ndTo1stEnd)
                {
                    // There is free space from lastOffset to freeSpace2ndTo1stEnd.
                    const VkDeviceSize unusedRangeSize = freeSpace2ndTo1stEnd - lastOffset;
                    PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
                }

                // End of loop.
                lastOffset = freeSpace2ndTo1stEnd;
            }
        }
    }

    nextAlloc1stIndex = m_1stNullItemsBeginCount;
    while(lastOffset < freeSpace1stTo2ndEnd)
    {
        // Find next non-null allocation or move nextAllocIndex to the end.
        while(nextAlloc1stIndex < suballoc1stCount &&
            suballocations1st[nextAlloc1stIndex].hAllocation == VK_NULL_HANDLE)
        {
            ++nextAlloc1stIndex;
        }

        // Found non-null allocation.
        if(nextAlloc1stIndex < suballoc1stCount)
        {
            const VmaSuballocation& suballoc = suballocations1st[nextAlloc1stIndex];
            
            // 1. Process free space before this allocation.
            if(lastOffset < suballoc.offset)
            {
                // There is free space from lastOffset to suballoc.offset.
                const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
                PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
            }
            
            // 2. Process this allocation.
            // There is allocation with suballoc.offset, suballoc.size.
            PrintDetailedMap_Allocation(json, suballoc.offset, suballoc.hAllocation);
            
            // 3. Prepare for next iteration.
            lastOffset = suballoc.offset + suballoc.size;
            ++nextAlloc1stIndex;
        }
        // We are at the end.
        else
        {
            if(lastOffset < freeSpace1stTo2ndEnd)
            {
                // There is free space from lastOffset to freeSpace1stTo2ndEnd.
                const VkDeviceSize unusedRangeSize = freeSpace1stTo2ndEnd - lastOffset;
                PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
            }

            // End of loop.
            lastOffset = freeSpace1stTo2ndEnd;
        }
    }

    if(m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
    {
        size_t nextAlloc2ndIndex = suballocations2nd.size() - 1;
        while(lastOffset < size)
        {
            // Find next non-null allocation or move nextAlloc2ndIndex to the end.
            while(nextAlloc2ndIndex != SIZE_MAX &&
                suballocations2nd[nextAlloc2ndIndex].hAllocation == VK_NULL_HANDLE)
            {
                --nextAlloc2ndIndex;
            }

            // Found non-null allocation.
            if(nextAlloc2ndIndex != SIZE_MAX)
            {
                const VmaSuballocation& suballoc = suballocations2nd[nextAlloc2ndIndex];
            
                // 1. Process free space before this allocation.
                if(lastOffset < suballoc.offset)
                {
                    // There is free space from lastOffset to suballoc.offset.
                    const VkDeviceSize unusedRangeSize = suballoc.offset - lastOffset;
                    PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
                }
            
                // 2. Process this allocation.
                // There is allocation with suballoc.offset, suballoc.size.
                PrintDetailedMap_Allocation(json, suballoc.offset, suballoc.hAllocation);
            
                // 3. Prepare for next iteration.
                lastOffset = suballoc.offset + suballoc.size;
                --nextAlloc2ndIndex;
            }
            // We are at the end.
            else
            {
                if(lastOffset < size)
                {
                    // There is free space from lastOffset to size.
                    const VkDeviceSize unusedRangeSize = size - lastOffset;
                    PrintDetailedMap_UnusedRange(json, lastOffset, unusedRangeSize);
                }

                // End of loop.
                lastOffset = size;
            }
        }
    }

    PrintDetailedMap_End(json);
}
#endif // #if VMA_STATS_STRING_ENABLED

bool VmaBlockMetadata_Linear::CreateAllocationRequest(
    uint32_t currentFrameIndex,
    uint32_t frameInUseCount,
    VkDeviceSize bufferImageGranularity,
    VkDeviceSize allocSize,
    VkDeviceSize allocAlignment,
    bool upperAddress,
    VmaSuballocationType allocType,
    bool canMakeOtherLost,
    uint32_t strategy,
    VmaAllocationRequest* pAllocationRequest)
{
    VMA_ASSERT(allocSize > 0);
    VMA_ASSERT(allocType != VMA_SUBALLOCATION_TYPE_FREE);
    VMA_ASSERT(pAllocationRequest != VMA_NULL);
    VMA_HEAVY_ASSERT(Validate());
    return upperAddress ?
        CreateAllocationRequest_UpperAddress(
            currentFrameIndex, frameInUseCount, bufferImageGranularity,
            allocSize, allocAlignment, allocType, canMakeOtherLost, strategy, pAllocationRequest) :
        CreateAllocationRequest_LowerAddress(
            currentFrameIndex, frameInUseCount, bufferImageGranularity,
            allocSize, allocAlignment, allocType, canMakeOtherLost, strategy, pAllocationRequest);
}

bool VmaBlockMetadata_Linear::CreateAllocationRequest_UpperAddress(
    uint32_t currentFrameIndex,
    uint32_t frameInUseCount,
    VkDeviceSize bufferImageGranularity,
    VkDeviceSize allocSize,
    VkDeviceSize allocAlignment,
    VmaSuballocationType allocType,
    bool canMakeOtherLost,
    uint32_t strategy,
    VmaAllocationRequest* pAllocationRequest)
{
    const VkDeviceSize size = GetSize();
    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();

    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
    {
        VMA_ASSERT(0 && "Trying to use pool with linear algorithm as double stack, while it is already being used as ring buffer.");
        return false;
    }

    // Try to allocate before 2nd.back(), or end of block if 2nd.empty().
    if(allocSize > size)
    {
        return false;
    }
    VkDeviceSize resultBaseOffset = size - allocSize;
    if(!suballocations2nd.empty())
    {
        const VmaSuballocation& lastSuballoc = suballocations2nd.back();
        resultBaseOffset = lastSuballoc.offset - allocSize;
        if(allocSize > lastSuballoc.offset)
        {
            return false;
        }
    }

    // Start from offset equal to end of free space.
    VkDeviceSize resultOffset = resultBaseOffset;

    // Apply VMA_DEBUG_MARGIN at the end.
    if(VMA_DEBUG_MARGIN > 0)
    {
        if(resultOffset < VMA_DEBUG_MARGIN)
        {
            return false;
        }
        resultOffset -= VMA_DEBUG_MARGIN;
    }

    // Apply alignment.
    resultOffset = VmaAlignDown(resultOffset, allocAlignment);

    // Check next suballocations from 2nd for BufferImageGranularity conflicts.
    // Make bigger alignment if necessary.
    if(bufferImageGranularity > 1 && !suballocations2nd.empty())
    {
        bool bufferImageGranularityConflict = false;
        for(size_t nextSuballocIndex = suballocations2nd.size(); nextSuballocIndex--; )
        {
            const VmaSuballocation& nextSuballoc = suballocations2nd[nextSuballocIndex];
            if(VmaBlocksOnSamePage(resultOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
            {
                if(VmaIsBufferImageGranularityConflict(nextSuballoc.type, allocType))
                {
                    bufferImageGranularityConflict = true;
                    break;
                }
            }
            else
                // Already on previous page.
                break;
        }
        if(bufferImageGranularityConflict)
        {
            resultOffset = VmaAlignDown(resultOffset, bufferImageGranularity);
        }
    }

    // There is enough free space.
    const VkDeviceSize endOf1st = !suballocations1st.empty() ?
        suballocations1st.back().offset + suballocations1st.back().size :
        0;
    if(endOf1st + VMA_DEBUG_MARGIN <= resultOffset)
    {
        // Check previous suballocations for BufferImageGranularity conflicts.
        // If conflict exists, allocation cannot be made here.
        if(bufferImageGranularity > 1)
        {
            for(size_t prevSuballocIndex = suballocations1st.size(); prevSuballocIndex--; )
            {
                const VmaSuballocation& prevSuballoc = suballocations1st[prevSuballocIndex];
                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, resultOffset, bufferImageGranularity))
                {
                    if(VmaIsBufferImageGranularityConflict(allocType, prevSuballoc.type))
                    {
                        return false;
                    }
                }
                else
                {
                    // Already on next page.
                    break;
                }
            }
        }

        // All tests passed: Success.
        pAllocationRequest->offset = resultOffset;
        pAllocationRequest->sumFreeSize = resultBaseOffset + allocSize - endOf1st;
        pAllocationRequest->sumItemSize = 0;
        // pAllocationRequest->item unused.
        pAllocationRequest->itemsToMakeLostCount = 0;
        pAllocationRequest->type = VmaAllocationRequestType::UpperAddress;
        return true;
    }

    return false;
}

bool VmaBlockMetadata_Linear::CreateAllocationRequest_LowerAddress(
    uint32_t currentFrameIndex,
    uint32_t frameInUseCount,
    VkDeviceSize bufferImageGranularity,
    VkDeviceSize allocSize,
    VkDeviceSize allocAlignment,
    VmaSuballocationType allocType,
    bool canMakeOtherLost,
    uint32_t strategy,
    VmaAllocationRequest* pAllocationRequest)
{
    const VkDeviceSize size = GetSize();
    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();

    if(m_2ndVectorMode == SECOND_VECTOR_EMPTY || m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
    {
        // Try to allocate at the end of 1st vector.

        VkDeviceSize resultBaseOffset = 0;
        if(!suballocations1st.empty())
        {
            const VmaSuballocation& lastSuballoc = suballocations1st.back();
            resultBaseOffset = lastSuballoc.offset + lastSuballoc.size;
        }

        // Start from offset equal to beginning of free space.
        VkDeviceSize resultOffset = resultBaseOffset;

        // Apply VMA_DEBUG_MARGIN at the beginning.
        if(VMA_DEBUG_MARGIN > 0)
        {
            resultOffset += VMA_DEBUG_MARGIN;
        }

        // Apply alignment.
        resultOffset = VmaAlignUp(resultOffset, allocAlignment);

        // Check previous suballocations for BufferImageGranularity conflicts.
        // Make bigger alignment if necessary.
        if(bufferImageGranularity > 1 && !suballocations1st.empty())
        {
            bool bufferImageGranularityConflict = false;
            for(size_t prevSuballocIndex = suballocations1st.size(); prevSuballocIndex--; )
            {
                const VmaSuballocation& prevSuballoc = suballocations1st[prevSuballocIndex];
                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, resultOffset, bufferImageGranularity))
                {
                    if(VmaIsBufferImageGranularityConflict(prevSuballoc.type, allocType))
                    {
                        bufferImageGranularityConflict = true;
                        break;
                    }
                }
                else
                    // Already on previous page.
                    break;
            }
            if(bufferImageGranularityConflict)
            {
                resultOffset = VmaAlignUp(resultOffset, bufferImageGranularity);
            }
        }

        const VkDeviceSize freeSpaceEnd = m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK ?
            suballocations2nd.back().offset : size;

        // There is enough free space at the end after alignment.
        if(resultOffset + allocSize + VMA_DEBUG_MARGIN <= freeSpaceEnd)
        {
            // Check next suballocations for BufferImageGranularity conflicts.
            // If conflict exists, allocation cannot be made here.
            if(bufferImageGranularity > 1 && m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
            {
                for(size_t nextSuballocIndex = suballocations2nd.size(); nextSuballocIndex--; )
                {
                    const VmaSuballocation& nextSuballoc = suballocations2nd[nextSuballocIndex];
                    if(VmaBlocksOnSamePage(resultOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
                    {
                        if(VmaIsBufferImageGranularityConflict(allocType, nextSuballoc.type))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // Already on previous page.
                        break;
                    }
                }
            }

            // All tests passed: Success.
            pAllocationRequest->offset = resultOffset;
            pAllocationRequest->sumFreeSize = freeSpaceEnd - resultBaseOffset;
            pAllocationRequest->sumItemSize = 0;
            // pAllocationRequest->item, customData unused.
            pAllocationRequest->type = VmaAllocationRequestType::EndOf1st;
            pAllocationRequest->itemsToMakeLostCount = 0;
            return true;
        }
    }

    // Wrap-around to end of 2nd vector. Try to allocate there, watching for the
    // beginning of 1st vector as the end of free space.
    if(m_2ndVectorMode == SECOND_VECTOR_EMPTY || m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
    {
        VMA_ASSERT(!suballocations1st.empty());

        VkDeviceSize resultBaseOffset = 0;
        if(!suballocations2nd.empty())
        {
            const VmaSuballocation& lastSuballoc = suballocations2nd.back();
            resultBaseOffset = lastSuballoc.offset + lastSuballoc.size;
        }

        // Start from offset equal to beginning of free space.
        VkDeviceSize resultOffset = resultBaseOffset;

        // Apply VMA_DEBUG_MARGIN at the beginning.
        if(VMA_DEBUG_MARGIN > 0)
        {
            resultOffset += VMA_DEBUG_MARGIN;
        }

        // Apply alignment.
        resultOffset = VmaAlignUp(resultOffset, allocAlignment);

        // Check previous suballocations for BufferImageGranularity conflicts.
        // Make bigger alignment if necessary.
        if(bufferImageGranularity > 1 && !suballocations2nd.empty())
        {
            bool bufferImageGranularityConflict = false;
            for(size_t prevSuballocIndex = suballocations2nd.size(); prevSuballocIndex--; )
            {
                const VmaSuballocation& prevSuballoc = suballocations2nd[prevSuballocIndex];
                if(VmaBlocksOnSamePage(prevSuballoc.offset, prevSuballoc.size, resultOffset, bufferImageGranularity))
                {
                    if(VmaIsBufferImageGranularityConflict(prevSuballoc.type, allocType))
                    {
                        bufferImageGranularityConflict = true;
                        break;
                    }
                }
                else
                    // Already on previous page.
                    break;
            }
            if(bufferImageGranularityConflict)
            {
                resultOffset = VmaAlignUp(resultOffset, bufferImageGranularity);
            }
        }

        pAllocationRequest->itemsToMakeLostCount = 0;
        pAllocationRequest->sumItemSize = 0;
        size_t index1st = m_1stNullItemsBeginCount;

        if(canMakeOtherLost)
        {
            while(index1st < suballocations1st.size() &&
                resultOffset + allocSize + VMA_DEBUG_MARGIN > suballocations1st[index1st].offset)
            {
                // Next colliding allocation at the beginning of 1st vector found. Try to make it lost.
                const VmaSuballocation& suballoc = suballocations1st[index1st];
                if(suballoc.type == VMA_SUBALLOCATION_TYPE_FREE)
                {
                    // No problem.
                }
                else
                {
                    VMA_ASSERT(suballoc.hAllocation != VK_NULL_HANDLE);
                    if(suballoc.hAllocation->CanBecomeLost() &&
                        suballoc.hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
                    {
                        ++pAllocationRequest->itemsToMakeLostCount;
                        pAllocationRequest->sumItemSize += suballoc.size;
                    }
                    else
                    {
                        return false;
                    }
                }
                ++index1st;
            }

            // Check next suballocations for BufferImageGranularity conflicts.
            // If conflict exists, we must mark more allocations lost or fail.
            if(bufferImageGranularity > 1)
            {
                while(index1st < suballocations1st.size())
                {
                    const VmaSuballocation& suballoc = suballocations1st[index1st];
                    if(VmaBlocksOnSamePage(resultOffset, allocSize, suballoc.offset, bufferImageGranularity))
                    {
                        if(suballoc.hAllocation != VK_NULL_HANDLE)
                        {
                            // Not checking actual VmaIsBufferImageGranularityConflict(allocType, suballoc.type).
                            if(suballoc.hAllocation->CanBecomeLost() &&
                                suballoc.hAllocation->GetLastUseFrameIndex() + frameInUseCount < currentFrameIndex)
                            {
                                ++pAllocationRequest->itemsToMakeLostCount;
                                pAllocationRequest->sumItemSize += suballoc.size;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                    else
                    {
                        // Already on next page.
                        break;
                    }
                    ++index1st;
                }
            }

            // Special case: There is not enough room at the end for this allocation, even after making all from the 1st lost.
            if(index1st == suballocations1st.size() &&
                resultOffset + allocSize + VMA_DEBUG_MARGIN > size)
            {
                // TODO: This is a known bug that it's not yet implemented and the allocation is failing.
                VMA_DEBUG_LOG("Unsupported special case in custom pool with linear allocation algorithm used as ring buffer with allocations that can be lost.");
            }
        }

        // There is enough free space at the end after alignment.
        if((index1st == suballocations1st.size() && resultOffset + allocSize + VMA_DEBUG_MARGIN <= size) ||
            (index1st < suballocations1st.size() && resultOffset + allocSize + VMA_DEBUG_MARGIN <= suballocations1st[index1st].offset))
        {
            // Check next suballocations for BufferImageGranularity conflicts.
            // If conflict exists, allocation cannot be made here.
            if(bufferImageGranularity > 1)
            {
                for(size_t nextSuballocIndex = index1st;
                    nextSuballocIndex < suballocations1st.size();
                    nextSuballocIndex++)
                {
                    const VmaSuballocation& nextSuballoc = suballocations1st[nextSuballocIndex];
                    if(VmaBlocksOnSamePage(resultOffset, allocSize, nextSuballoc.offset, bufferImageGranularity))
                    {
                        if(VmaIsBufferImageGranularityConflict(allocType, nextSuballoc.type))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // Already on next page.
                        break;
                    }
                }
            }

            // All tests passed: Success.
            pAllocationRequest->offset = resultOffset;
            pAllocationRequest->sumFreeSize =
                (index1st < suballocations1st.size() ? suballocations1st[index1st].offset : size)
                - resultBaseOffset
                - pAllocationRequest->sumItemSize;
            pAllocationRequest->type = VmaAllocationRequestType::EndOf2nd;
            // pAllocationRequest->item, customData unused.
            return true;
        }
    }

    return false;
}

bool VmaBlockMetadata_Linear::MakeRequestedAllocationsLost(
    uint32_t currentFrameIndex,
    uint32_t frameInUseCount,
    VmaAllocationRequest* pAllocationRequest)
{
    if(pAllocationRequest->itemsToMakeLostCount == 0)
    {
        return true;
    }

    VMA_ASSERT(m_2ndVectorMode == SECOND_VECTOR_EMPTY || m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER);
    
    // We always start from 1st.
    SuballocationVectorType* suballocations = &AccessSuballocations1st();
    size_t index = m_1stNullItemsBeginCount;
    size_t madeLostCount = 0;
    while(madeLostCount < pAllocationRequest->itemsToMakeLostCount)
    {
        if(index == suballocations->size())
        {
            index = 0;
            // If we get to the end of 1st, we wrap around to beginning of 2nd of 1st.
            if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
            {
                suballocations = &AccessSuballocations2nd();
            }
            // else: m_2ndVectorMode == SECOND_VECTOR_EMPTY:
            // suballocations continues pointing at AccessSuballocations1st().
            VMA_ASSERT(!suballocations->empty());
        }
        VmaSuballocation& suballoc = (*suballocations)[index];
        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE)
        {
            VMA_ASSERT(suballoc.hAllocation != VK_NULL_HANDLE);
            VMA_ASSERT(suballoc.hAllocation->CanBecomeLost());
            if(suballoc.hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
            {
                suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
                suballoc.hAllocation = VK_NULL_HANDLE;
                m_SumFreeSize += suballoc.size;
                if(suballocations == &AccessSuballocations1st())
                {
                    ++m_1stNullItemsMiddleCount;
                }
                else
                {
                    ++m_2ndNullItemsCount;
                }
                ++madeLostCount;
            }
            else
            {
                return false;
            }
        }
        ++index;
    }

    CleanupAfterFree();
    //VMA_HEAVY_ASSERT(Validate()); // Already called by ClanupAfterFree().
    
    return true;
}

uint32_t VmaBlockMetadata_Linear::MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount)
{
    uint32_t lostAllocationCount = 0;
    
    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    for(size_t i = m_1stNullItemsBeginCount, count = suballocations1st.size(); i < count; ++i)
    {
        VmaSuballocation& suballoc = suballocations1st[i];
        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE &&
            suballoc.hAllocation->CanBecomeLost() &&
            suballoc.hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
        {
            suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
            suballoc.hAllocation = VK_NULL_HANDLE;
            ++m_1stNullItemsMiddleCount;
            m_SumFreeSize += suballoc.size;
            ++lostAllocationCount;
        }
    }

    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
    for(size_t i = 0, count = suballocations2nd.size(); i < count; ++i)
    {
        VmaSuballocation& suballoc = suballocations2nd[i];
        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE &&
            suballoc.hAllocation->CanBecomeLost() &&
            suballoc.hAllocation->MakeLost(currentFrameIndex, frameInUseCount))
        {
            suballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
            suballoc.hAllocation = VK_NULL_HANDLE;
            ++m_2ndNullItemsCount;
            m_SumFreeSize += suballoc.size;
            ++lostAllocationCount;
        }
    }

    if(lostAllocationCount)
    {
        CleanupAfterFree();
    }

    return lostAllocationCount;
}

VkResult VmaBlockMetadata_Linear::CheckCorruption(const void* pBlockData)
{
    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    for(size_t i = m_1stNullItemsBeginCount, count = suballocations1st.size(); i < count; ++i)
    {
        const VmaSuballocation& suballoc = suballocations1st[i];
        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE)
        {
            if(!VmaValidateMagicValue(pBlockData, suballoc.offset - VMA_DEBUG_MARGIN))
            {
                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED BEFORE VALIDATED ALLOCATION!");
                return VK_ERROR_VALIDATION_FAILED_EXT;
            }
            if(!VmaValidateMagicValue(pBlockData, suballoc.offset + suballoc.size))
            {
                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED AFTER VALIDATED ALLOCATION!");
                return VK_ERROR_VALIDATION_FAILED_EXT;
            }
        }
    }

    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
    for(size_t i = 0, count = suballocations2nd.size(); i < count; ++i)
    {
        const VmaSuballocation& suballoc = suballocations2nd[i];
        if(suballoc.type != VMA_SUBALLOCATION_TYPE_FREE)
        {
            if(!VmaValidateMagicValue(pBlockData, suballoc.offset - VMA_DEBUG_MARGIN))
            {
                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED BEFORE VALIDATED ALLOCATION!");
                return VK_ERROR_VALIDATION_FAILED_EXT;
            }
            if(!VmaValidateMagicValue(pBlockData, suballoc.offset + suballoc.size))
            {
                VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED AFTER VALIDATED ALLOCATION!");
                return VK_ERROR_VALIDATION_FAILED_EXT;
            }
        }
    }

    return VK_SUCCESS;
}

void VmaBlockMetadata_Linear::Alloc(
    const VmaAllocationRequest& request,
    VmaSuballocationType type,
    VkDeviceSize allocSize,
    VmaAllocation hAllocation)
{
    const VmaSuballocation newSuballoc = { request.offset, allocSize, hAllocation, type };

    switch(request.type)
    {
    case VmaAllocationRequestType::UpperAddress:
        {
            VMA_ASSERT(m_2ndVectorMode != SECOND_VECTOR_RING_BUFFER &&
                "CRITICAL ERROR: Trying to use linear allocator as double stack while it was already used as ring buffer.");
            SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();
            suballocations2nd.push_back(newSuballoc);
            m_2ndVectorMode = SECOND_VECTOR_DOUBLE_STACK;
        }
        break;
    case VmaAllocationRequestType::EndOf1st:
        {
            SuballocationVectorType& suballocations1st = AccessSuballocations1st();

            VMA_ASSERT(suballocations1st.empty() ||
                request.offset >= suballocations1st.back().offset + suballocations1st.back().size);
            // Check if it fits before the end of the block.
            VMA_ASSERT(request.offset + allocSize <= GetSize());

            suballocations1st.push_back(newSuballoc);
        }
        break;
    case VmaAllocationRequestType::EndOf2nd:
        {
            SuballocationVectorType& suballocations1st = AccessSuballocations1st();
            // New allocation at the end of 2-part ring buffer, so before first allocation from 1st vector.
            VMA_ASSERT(!suballocations1st.empty() &&
                request.offset + allocSize <= suballocations1st[m_1stNullItemsBeginCount].offset);
            SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();

            switch(m_2ndVectorMode)
            {
            case SECOND_VECTOR_EMPTY:
                // First allocation from second part ring buffer.
                VMA_ASSERT(suballocations2nd.empty());
                m_2ndVectorMode = SECOND_VECTOR_RING_BUFFER;
                break;
            case SECOND_VECTOR_RING_BUFFER:
                // 2-part ring buffer is already started.
                VMA_ASSERT(!suballocations2nd.empty());
                break;
            case SECOND_VECTOR_DOUBLE_STACK:
                VMA_ASSERT(0 && "CRITICAL ERROR: Trying to use linear allocator as ring buffer while it was already used as double stack.");
                break;
            default:
                VMA_ASSERT(0);
            }

            suballocations2nd.push_back(newSuballoc);
        }
        break;
    default:
        VMA_ASSERT(0 && "CRITICAL INTERNAL ERROR.");
    }

    m_SumFreeSize -= newSuballoc.size;
}

void VmaBlockMetadata_Linear::Free(const VmaAllocation allocation)
{
    FreeAtOffset(allocation->GetOffset());
}

void VmaBlockMetadata_Linear::FreeAtOffset(VkDeviceSize offset)
{
    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();

    if(!suballocations1st.empty())
    {
        // First allocation: Mark it as next empty at the beginning.
        VmaSuballocation& firstSuballoc = suballocations1st[m_1stNullItemsBeginCount];
        if(firstSuballoc.offset == offset)
        {
            firstSuballoc.type = VMA_SUBALLOCATION_TYPE_FREE;
            firstSuballoc.hAllocation = VK_NULL_HANDLE;
            m_SumFreeSize += firstSuballoc.size;
            ++m_1stNullItemsBeginCount;
            CleanupAfterFree();
            return;
        }
    }

    // Last allocation in 2-part ring buffer or top of upper stack (same logic).
    if(m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER ||
        m_2ndVectorMode == SECOND_VECTOR_DOUBLE_STACK)
    {
        VmaSuballocation& lastSuballoc = suballocations2nd.back();
        if(lastSuballoc.offset == offset)
        {
            m_SumFreeSize += lastSuballoc.size;
            suballocations2nd.pop_back();
            CleanupAfterFree();
            return;
        }
    }
    // Last allocation in 1st vector.
    else if(m_2ndVectorMode == SECOND_VECTOR_EMPTY)
    {
        VmaSuballocation& lastSuballoc = suballocations1st.back();
        if(lastSuballoc.offset == offset)
        {
            m_SumFreeSize += lastSuballoc.size;
            suballocations1st.pop_back();
            CleanupAfterFree();
            return;
        }
    }

    // Item from the middle of 1st vector.
    {
        VmaSuballocation refSuballoc;
        refSuballoc.offset = offset;
        // Rest of members stays uninitialized intentionally for better performance.
        SuballocationVectorType::iterator it = VmaBinaryFindSorted(
            suballocations1st.begin() + m_1stNullItemsBeginCount,
            suballocations1st.end(),
            refSuballoc,
            VmaSuballocationOffsetLess());
        if(it != suballocations1st.end())
        {
            it->type = VMA_SUBALLOCATION_TYPE_FREE;
            it->hAllocation = VK_NULL_HANDLE;
            ++m_1stNullItemsMiddleCount;
            m_SumFreeSize += it->size;
            CleanupAfterFree();
            return;
        }
    }

    if(m_2ndVectorMode != SECOND_VECTOR_EMPTY)
    {
        // Item from the middle of 2nd vector.
        VmaSuballocation refSuballoc;
        refSuballoc.offset = offset;
        // Rest of members stays uninitialized intentionally for better performance.
        SuballocationVectorType::iterator it = m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER ?
            VmaBinaryFindSorted(suballocations2nd.begin(), suballocations2nd.end(), refSuballoc, VmaSuballocationOffsetLess()) :
            VmaBinaryFindSorted(suballocations2nd.begin(), suballocations2nd.end(), refSuballoc, VmaSuballocationOffsetGreater());
        if(it != suballocations2nd.end())
        {
            it->type = VMA_SUBALLOCATION_TYPE_FREE;
            it->hAllocation = VK_NULL_HANDLE;
            ++m_2ndNullItemsCount;
            m_SumFreeSize += it->size;
            CleanupAfterFree();
            return;
        }
    }

    VMA_ASSERT(0 && "Allocation to free not found in linear allocator!");
}

bool VmaBlockMetadata_Linear::ShouldCompact1st() const
{
    const size_t nullItemCount = m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount;
    const size_t suballocCount = AccessSuballocations1st().size();
    return suballocCount > 32 && nullItemCount * 2 >= (suballocCount - nullItemCount) * 3;
}

void VmaBlockMetadata_Linear::CleanupAfterFree()
{
    SuballocationVectorType& suballocations1st = AccessSuballocations1st();
    SuballocationVectorType& suballocations2nd = AccessSuballocations2nd();

    if(IsEmpty())
    {
        suballocations1st.clear();
        suballocations2nd.clear();
        m_1stNullItemsBeginCount = 0;
        m_1stNullItemsMiddleCount = 0;
        m_2ndNullItemsCount = 0;
        m_2ndVectorMode = SECOND_VECTOR_EMPTY;
    }
    else
    {
        const size_t suballoc1stCount = suballocations1st.size();
        const size_t nullItem1stCount = m_1stNullItemsBeginCount + m_1stNullItemsMiddleCount;
        VMA_ASSERT(nullItem1stCount <= suballoc1stCount);

        // Find more null items at the beginning of 1st vector.
        while(m_1stNullItemsBeginCount < suballoc1stCount &&
            suballocations1st[m_1stNullItemsBeginCount].hAllocation == VK_NULL_HANDLE)
        {
            ++m_1stNullItemsBeginCount;
            --m_1stNullItemsMiddleCount;
        }

        // Find more null items at the end of 1st vector.
        while(m_1stNullItemsMiddleCount > 0 &&
            suballocations1st.back().hAllocation == VK_NULL_HANDLE)
        {
            --m_1stNullItemsMiddleCount;
            suballocations1st.pop_back();
        }

        // Find more null items at the end of 2nd vector.
        while(m_2ndNullItemsCount > 0 &&
            suballocations2nd.back().hAllocation == VK_NULL_HANDLE)
        {
            --m_2ndNullItemsCount;
            suballocations2nd.pop_back();
        }

        // Find more null items at the beginning of 2nd vector.
        while(m_2ndNullItemsCount > 0 &&
            suballocations2nd[0].hAllocation == VK_NULL_HANDLE)
        {
            --m_2ndNullItemsCount;
            VmaVectorRemove(suballocations2nd, 0);
        }

        if(ShouldCompact1st())
        {
            const size_t nonNullItemCount = suballoc1stCount - nullItem1stCount;
            size_t srcIndex = m_1stNullItemsBeginCount;
            for(size_t dstIndex = 0; dstIndex < nonNullItemCount; ++dstIndex)
            {
                while(suballocations1st[srcIndex].hAllocation == VK_NULL_HANDLE)
                {
                    ++srcIndex;
                }
                if(dstIndex != srcIndex)
                {
                    suballocations1st[dstIndex] = suballocations1st[srcIndex];
                }
                ++srcIndex;
            }
            suballocations1st.resize(nonNullItemCount);
            m_1stNullItemsBeginCount = 0;
            m_1stNullItemsMiddleCount = 0;
        }

        // 2nd vector became empty.
        if(suballocations2nd.empty())
        {
            m_2ndVectorMode = SECOND_VECTOR_EMPTY;
        }

        // 1st vector became empty.
        if(suballocations1st.size() - m_1stNullItemsBeginCount == 0)
        {
            suballocations1st.clear();
            m_1stNullItemsBeginCount = 0;

            if(!suballocations2nd.empty() && m_2ndVectorMode == SECOND_VECTOR_RING_BUFFER)
            {
                // Swap 1st with 2nd. Now 2nd is empty.
                m_2ndVectorMode = SECOND_VECTOR_EMPTY;
                m_1stNullItemsMiddleCount = m_2ndNullItemsCount;
                while(m_1stNullItemsBeginCount < suballocations2nd.size() &&
                    suballocations2nd[m_1stNullItemsBeginCount].hAllocation == VK_NULL_HANDLE)
                {
                    ++m_1stNullItemsBeginCount;
                    --m_1stNullItemsMiddleCount;
                }
                m_2ndNullItemsCount = 0;
                m_1stVectorIndex ^= 1;
            }
        }
    }

    VMA_HEAVY_ASSERT(Validate());
}


////////////////////////////////////////////////////////////////////////////////
// class VmaBlockMetadata_Buddy

VmaBlockMetadata_Buddy::VmaBlockMetadata_Buddy(VmaAllocator hAllocator) :
    VmaBlockMetadata(hAllocator),
    m_Root(VMA_NULL),
    m_AllocationCount(0),
    m_FreeCount(1),
    m_SumFreeSize(0)
{
    memset(m_FreeList, 0, sizeof(m_FreeList));
}

VmaBlockMetadata_Buddy::~VmaBlockMetadata_Buddy()
{
    DeleteNode(m_Root);
}

void VmaBlockMetadata_Buddy::Init(VkDeviceSize size)
{
    VmaBlockMetadata::Init(size);

    m_UsableSize = VmaPrevPow2(size);
    m_SumFreeSize = m_UsableSize;

    // Calculate m_LevelCount.
    m_LevelCount = 1;
    while(m_LevelCount < MAX_LEVELS &&
        LevelToNodeSize(m_LevelCount) >= MIN_NODE_SIZE)
    {
        ++m_LevelCount;
    }

    Node* rootNode = vma_new(GetAllocationCallbacks(), Node)();
    rootNode->offset = 0;
    rootNode->type = Node::TYPE_FREE;
    rootNode->parent = VMA_NULL;
    rootNode->buddy = VMA_NULL;

    m_Root = rootNode;
    AddToFreeListFront(0, rootNode);
}

bool VmaBlockMetadata_Buddy::Validate() const
{
    // Validate tree.
    ValidationContext ctx;
    if(!ValidateNode(ctx, VMA_NULL, m_Root, 0, LevelToNodeSize(0)))
    {
        VMA_VALIDATE(false && "ValidateNode failed.");
    }
    VMA_VALIDATE(m_AllocationCount == ctx.calculatedAllocationCount);
    VMA_VALIDATE(m_SumFreeSize == ctx.calculatedSumFreeSize);

    // Validate free node lists.
    for(uint32_t level = 0; level < m_LevelCount; ++level)
    {
        VMA_VALIDATE(m_FreeList[level].front == VMA_NULL ||
            m_FreeList[level].front->free.prev == VMA_NULL);

        for(Node* node = m_FreeList[level].front;
            node != VMA_NULL;
            node = node->free.next)
        {
            VMA_VALIDATE(node->type == Node::TYPE_FREE);
            
            if(node->free.next == VMA_NULL)
            {
                VMA_VALIDATE(m_FreeList[level].back == node);
            }
            else
            {
                VMA_VALIDATE(node->free.next->free.prev == node);
            }
        }
    }

    // Validate that free lists ar higher levels are empty.
    for(uint32_t level = m_LevelCount; level < MAX_LEVELS; ++level)
    {
        VMA_VALIDATE(m_FreeList[level].front == VMA_NULL && m_FreeList[level].back == VMA_NULL);
    }

    return true;
}

VkDeviceSize VmaBlockMetadata_Buddy::GetUnusedRangeSizeMax() const
{
    for(uint32_t level = 0; level < m_LevelCount; ++level)
    {
        if(m_FreeList[level].front != VMA_NULL)
        {
            return LevelToNodeSize(level);
        }
    }
    return 0;
}

void VmaBlockMetadata_Buddy::CalcAllocationStatInfo(VmaStatInfo& outInfo) const
{
    const VkDeviceSize unusableSize = GetUnusableSize();

    outInfo.blockCount = 1;

    outInfo.allocationCount = outInfo.unusedRangeCount = 0;
    outInfo.usedBytes = outInfo.unusedBytes = 0;

    outInfo.allocationSizeMax = outInfo.unusedRangeSizeMax = 0;
    outInfo.allocationSizeMin = outInfo.unusedRangeSizeMin = UINT64_MAX;
    outInfo.allocationSizeAvg = outInfo.unusedRangeSizeAvg = 0; // Unused.

    CalcAllocationStatInfoNode(outInfo, m_Root, LevelToNodeSize(0));

    if(unusableSize > 0)
    {
        ++outInfo.unusedRangeCount;
        outInfo.unusedBytes += unusableSize;
        outInfo.unusedRangeSizeMax = VMA_MAX(outInfo.unusedRangeSizeMax, unusableSize);
        outInfo.unusedRangeSizeMin = VMA_MIN(outInfo.unusedRangeSizeMin, unusableSize);
    }
}

void VmaBlockMetadata_Buddy::AddPoolStats(VmaPoolStats& inoutStats) const
{
    const VkDeviceSize unusableSize = GetUnusableSize();

    inoutStats.size += GetSize();
    inoutStats.unusedSize += m_SumFreeSize + unusableSize;
    inoutStats.allocationCount += m_AllocationCount;
    inoutStats.unusedRangeCount += m_FreeCount;
    inoutStats.unusedRangeSizeMax = VMA_MAX(inoutStats.unusedRangeSizeMax, GetUnusedRangeSizeMax());

    if(unusableSize > 0)
    {
        ++inoutStats.unusedRangeCount;
        // Not updating inoutStats.unusedRangeSizeMax with unusableSize because this space is not available for allocations.
    }
}

#if VMA_STATS_STRING_ENABLED

void VmaBlockMetadata_Buddy::PrintDetailedMap(class VmaJsonWriter& json) const
{
    // TODO optimize
    VmaStatInfo stat;
    CalcAllocationStatInfo(stat);

    PrintDetailedMap_Begin(
        json,
        stat.unusedBytes,
        stat.allocationCount,
        stat.unusedRangeCount);

    PrintDetailedMapNode(json, m_Root, LevelToNodeSize(0));

    const VkDeviceSize unusableSize = GetUnusableSize();
    if(unusableSize > 0)
    {
        PrintDetailedMap_UnusedRange(json,
            m_UsableSize, // offset
            unusableSize); // size
    }

    PrintDetailedMap_End(json);
}

#endif // #if VMA_STATS_STRING_ENABLED

bool VmaBlockMetadata_Buddy::CreateAllocationRequest(
    uint32_t currentFrameIndex,
    uint32_t frameInUseCount,
    VkDeviceSize bufferImageGranularity,
    VkDeviceSize allocSize,
    VkDeviceSize allocAlignment,
    bool upperAddress,
    VmaSuballocationType allocType,
    bool canMakeOtherLost,
    uint32_t strategy,
    VmaAllocationRequest* pAllocationRequest)
{
    VMA_ASSERT(!upperAddress && "VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT can be used only with linear algorithm.");

    // Simple way to respect bufferImageGranularity. May be optimized some day.
    // Whenever it might be an OPTIMAL image...
    if(allocType == VMA_SUBALLOCATION_TYPE_UNKNOWN ||
        allocType == VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN ||
        allocType == VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL)
    {
        allocAlignment = VMA_MAX(allocAlignment, bufferImageGranularity);
        allocSize = VMA_MAX(allocSize, bufferImageGranularity);
    }

    if(allocSize > m_UsableSize)
    {
        return false;
    }

    const uint32_t targetLevel = AllocSizeToLevel(allocSize);
    for(uint32_t level = targetLevel + 1; level--; )
    {
        for(Node* freeNode = m_FreeList[level].front;
            freeNode != VMA_NULL;
            freeNode = freeNode->free.next)
        {
            if(freeNode->offset % allocAlignment == 0)
            {
                pAllocationRequest->type = VmaAllocationRequestType::Normal;
                pAllocationRequest->offset = freeNode->offset;
                pAllocationRequest->sumFreeSize = LevelToNodeSize(level);
                pAllocationRequest->sumItemSize = 0;
                pAllocationRequest->itemsToMakeLostCount = 0;
                pAllocationRequest->customData = (void*)(uintptr_t)level;
                return true;
            }
        }
    }

    return false;
}

bool VmaBlockMetadata_Buddy::MakeRequestedAllocationsLost(
    uint32_t currentFrameIndex,
    uint32_t frameInUseCount,
    VmaAllocationRequest* pAllocationRequest)
{
    /*
    Lost allocations are not supported in buddy allocator at the moment.
    Support might be added in the future.
    */
    return pAllocationRequest->itemsToMakeLostCount == 0;
}

uint32_t VmaBlockMetadata_Buddy::MakeAllocationsLost(uint32_t currentFrameIndex, uint32_t frameInUseCount)
{
    /*
    Lost allocations are not supported in buddy allocator at the moment.
    Support might be added in the future.
    */
    return 0;
}

void VmaBlockMetadata_Buddy::Alloc(
    const VmaAllocationRequest& request,
    VmaSuballocationType type,
    VkDeviceSize allocSize,
    VmaAllocation hAllocation)
{
    VMA_ASSERT(request.type == VmaAllocationRequestType::Normal);

    const uint32_t targetLevel = AllocSizeToLevel(allocSize);
    uint32_t currLevel = (uint32_t)(uintptr_t)request.customData;
    
    Node* currNode = m_FreeList[currLevel].front;
    VMA_ASSERT(currNode != VMA_NULL && currNode->type == Node::TYPE_FREE);
    while(currNode->offset != request.offset)
    {
        currNode = currNode->free.next;
        VMA_ASSERT(currNode != VMA_NULL && currNode->type == Node::TYPE_FREE);
    }
    
    // Go down, splitting free nodes.
    while(currLevel < targetLevel)
    {
        // currNode is already first free node at currLevel.
        // Remove it from list of free nodes at this currLevel.
        RemoveFromFreeList(currLevel, currNode);
         
        const uint32_t childrenLevel = currLevel + 1;

        // Create two free sub-nodes.
        Node* leftChild = vma_new(GetAllocationCallbacks(), Node)();
        Node* rightChild = vma_new(GetAllocationCallbacks(), Node)();

        leftChild->offset = currNode->offset;
        leftChild->type = Node::TYPE_FREE;
        leftChild->parent = currNode;
        leftChild->buddy = rightChild;

        rightChild->offset = currNode->offset + LevelToNodeSize(childrenLevel);
        rightChild->type = Node::TYPE_FREE;
        rightChild->parent = currNode;
        rightChild->buddy = leftChild;

        // Convert current currNode to split type.
        currNode->type = Node::TYPE_SPLIT;
        currNode->split.leftChild = leftChild;

        // Add child nodes to free list. Order is important!
        AddToFreeListFront(childrenLevel, rightChild);
        AddToFreeListFront(childrenLevel, leftChild);

        ++m_FreeCount;
        //m_SumFreeSize -= LevelToNodeSize(currLevel) % 2; // Useful only when level node sizes can be non power of 2.
        ++currLevel;
        currNode = m_FreeList[currLevel].front;

        /*
        We can be sure that currNode, as left child of node previously split,
        also fullfills the alignment requirement.
        */
    }

    // Remove from free list.
    VMA_ASSERT(currLevel == targetLevel &&
        currNode != VMA_NULL &&
        currNode->type == Node::TYPE_FREE);
    RemoveFromFreeList(currLevel, currNode);

    // Convert to allocation node.
    currNode->type = Node::TYPE_ALLOCATION;
    currNode->allocation.alloc = hAllocation;

    ++m_AllocationCount;
    --m_FreeCount;
    m_SumFreeSize -= allocSize;
}

void VmaBlockMetadata_Buddy::DeleteNode(Node* node)
{
    if(node->type == Node::TYPE_SPLIT)
    {
        DeleteNode(node->split.leftChild->buddy);
        DeleteNode(node->split.leftChild);
    }

    vma_delete(GetAllocationCallbacks(), node);
}

bool VmaBlockMetadata_Buddy::ValidateNode(ValidationContext& ctx, const Node* parent, const Node* curr, uint32_t level, VkDeviceSize levelNodeSize) const
{
    VMA_VALIDATE(level < m_LevelCount);
    VMA_VALIDATE(curr->parent == parent);
    VMA_VALIDATE((curr->buddy == VMA_NULL) == (parent == VMA_NULL));
    VMA_VALIDATE(curr->buddy == VMA_NULL || curr->buddy->buddy == curr);
    switch(curr->type)
    {
    case Node::TYPE_FREE:
        // curr->free.prev, next are validated separately.
        ctx.calculatedSumFreeSize += levelNodeSize;
        ++ctx.calculatedFreeCount;
        break;
    case Node::TYPE_ALLOCATION:
        ++ctx.calculatedAllocationCount;
        ctx.calculatedSumFreeSize += levelNodeSize - curr->allocation.alloc->GetSize();
        VMA_VALIDATE(curr->allocation.alloc != VK_NULL_HANDLE);
        break;
    case Node::TYPE_SPLIT:
        {
            const uint32_t childrenLevel = level + 1;
            const VkDeviceSize childrenLevelNodeSize = levelNodeSize / 2;
            const Node* const leftChild = curr->split.leftChild;
            VMA_VALIDATE(leftChild != VMA_NULL);
            VMA_VALIDATE(leftChild->offset == curr->offset);
            if(!ValidateNode(ctx, curr, leftChild, childrenLevel, childrenLevelNodeSize))
            {
                VMA_VALIDATE(false && "ValidateNode for left child failed.");
            }
            const Node* const rightChild = leftChild->buddy;
            VMA_VALIDATE(rightChild->offset == curr->offset + childrenLevelNodeSize);
            if(!ValidateNode(ctx, curr, rightChild, childrenLevel, childrenLevelNodeSize))
            {
                VMA_VALIDATE(false && "ValidateNode for right child failed.");
            }
        }
        break;
    default:
        return false;
    }

    return true;
}

uint32_t VmaBlockMetadata_Buddy::AllocSizeToLevel(VkDeviceSize allocSize) const
{
    // I know this could be optimized somehow e.g. by using std::log2p1 from C++20.
    uint32_t level = 0;
    VkDeviceSize currLevelNodeSize = m_UsableSize;
    VkDeviceSize nextLevelNodeSize = currLevelNodeSize >> 1;
    while(allocSize <= nextLevelNodeSize && level + 1 < m_LevelCount)
    {
        ++level;
        currLevelNodeSize = nextLevelNodeSize;
        nextLevelNodeSize = currLevelNodeSize >> 1;
    }
    return level;
}

void VmaBlockMetadata_Buddy::FreeAtOffset(VmaAllocation alloc, VkDeviceSize offset)
{
    // Find node and level.
    Node* node = m_Root;
    VkDeviceSize nodeOffset = 0;
    uint32_t level = 0;
    VkDeviceSize levelNodeSize = LevelToNodeSize(0);
    while(node->type == Node::TYPE_SPLIT)
    {
        const VkDeviceSize nextLevelSize = levelNodeSize >> 1;
        if(offset < nodeOffset + nextLevelSize)
        {
            node = node->split.leftChild;
        }
        else
        {
            node = node->split.leftChild->buddy;
            nodeOffset += nextLevelSize;
        }
        ++level;
        levelNodeSize = nextLevelSize;
    }

    VMA_ASSERT(node != VMA_NULL && node->type == Node::TYPE_ALLOCATION);
    VMA_ASSERT(alloc == VK_NULL_HANDLE || node->allocation.alloc == alloc);

    ++m_FreeCount;
    --m_AllocationCount;
    m_SumFreeSize += alloc->GetSize();

    node->type = Node::TYPE_FREE;

    // Join free nodes if possible.
    while(level > 0 && node->buddy->type == Node::TYPE_FREE)
    {
        RemoveFromFreeList(level, node->buddy);
        Node* const parent = node->parent;

        vma_delete(GetAllocationCallbacks(), node->buddy);
        vma_delete(GetAllocationCallbacks(), node);
        parent->type = Node::TYPE_FREE;
        
        node = parent;
        --level;
        //m_SumFreeSize += LevelToNodeSize(level) % 2; // Useful only when level node sizes can be non power of 2.
        --m_FreeCount;
    }

    AddToFreeListFront(level, node);
}

void VmaBlockMetadata_Buddy::CalcAllocationStatInfoNode(VmaStatInfo& outInfo, const Node* node, VkDeviceSize levelNodeSize) const
{
    switch(node->type)
    {
    case Node::TYPE_FREE:
        ++outInfo.unusedRangeCount;
        outInfo.unusedBytes += levelNodeSize;
        outInfo.unusedRangeSizeMax = VMA_MAX(outInfo.unusedRangeSizeMax, levelNodeSize);
        outInfo.unusedRangeSizeMin = VMA_MAX(outInfo.unusedRangeSizeMin, levelNodeSize);
        break;
    case Node::TYPE_ALLOCATION:
        {
            const VkDeviceSize allocSize = node->allocation.alloc->GetSize();
            ++outInfo.allocationCount;
            outInfo.usedBytes += allocSize;
            outInfo.allocationSizeMax = VMA_MAX(outInfo.allocationSizeMax, allocSize);
            outInfo.allocationSizeMin = VMA_MAX(outInfo.allocationSizeMin, allocSize);

            const VkDeviceSize unusedRangeSize = levelNodeSize - allocSize;
            if(unusedRangeSize > 0)
            {
                ++outInfo.unusedRangeCount;
                outInfo.unusedBytes += unusedRangeSize;
                outInfo.unusedRangeSizeMax = VMA_MAX(outInfo.unusedRangeSizeMax, unusedRangeSize);
                outInfo.unusedRangeSizeMin = VMA_MAX(outInfo.unusedRangeSizeMin, unusedRangeSize);
            }
        }
        break;
    case Node::TYPE_SPLIT:
        {
            const VkDeviceSize childrenNodeSize = levelNodeSize / 2;
            const Node* const leftChild = node->split.leftChild;
            CalcAllocationStatInfoNode(outInfo, leftChild, childrenNodeSize);
            const Node* const rightChild = leftChild->buddy;
            CalcAllocationStatInfoNode(outInfo, rightChild, childrenNodeSize);
        }
        break;
    default:
        VMA_ASSERT(0);
    }
}

void VmaBlockMetadata_Buddy::AddToFreeListFront(uint32_t level, Node* node)
{
    VMA_ASSERT(node->type == Node::TYPE_FREE);

    // List is empty.
    Node* const frontNode = m_FreeList[level].front;
    if(frontNode == VMA_NULL)
    {
        VMA_ASSERT(m_FreeList[level].back == VMA_NULL);
        node->free.prev = node->free.next = VMA_NULL;
        m_FreeList[level].front = m_FreeList[level].back = node;
    }
    else
    {
        VMA_ASSERT(frontNode->free.prev == VMA_NULL);
        node->free.prev = VMA_NULL;
        node->free.next = frontNode;
        frontNode->free.prev = node;
        m_FreeList[level].front = node;
    }
}

void VmaBlockMetadata_Buddy::RemoveFromFreeList(uint32_t level, Node* node)
{
    VMA_ASSERT(m_FreeList[level].front != VMA_NULL);

    // It is at the front.
    if(node->free.prev == VMA_NULL)
    {
        VMA_ASSERT(m_FreeList[level].front == node);
        m_FreeList[level].front = node->free.next;
    }
    else
    {
        Node* const prevFreeNode = node->free.prev;
        VMA_ASSERT(prevFreeNode->free.next == node);
        prevFreeNode->free.next = node->free.next;
    }

    // It is at the back.
    if(node->free.next == VMA_NULL)
    {
        VMA_ASSERT(m_FreeList[level].back == node);
        m_FreeList[level].back = node->free.prev;
    }
    else
    {
        Node* const nextFreeNode = node->free.next;
        VMA_ASSERT(nextFreeNode->free.prev == node);
        nextFreeNode->free.prev = node->free.prev;
    }
}

#if VMA_STATS_STRING_ENABLED
void VmaBlockMetadata_Buddy::PrintDetailedMapNode(class VmaJsonWriter& json, const Node* node, VkDeviceSize levelNodeSize) const
{
    switch(node->type)
    {
    case Node::TYPE_FREE:
        PrintDetailedMap_UnusedRange(json, node->offset, levelNodeSize);
        break;
    case Node::TYPE_ALLOCATION:
        {   
            PrintDetailedMap_Allocation(json, node->offset, node->allocation.alloc);
            const VkDeviceSize allocSize = node->allocation.alloc->GetSize();
            if(allocSize < levelNodeSize)
            {
                PrintDetailedMap_UnusedRange(json, node->offset + allocSize, levelNodeSize - allocSize);
            }
        }
        break;
    case Node::TYPE_SPLIT:
        {
            const VkDeviceSize childrenNodeSize = levelNodeSize / 2;
            const Node* const leftChild = node->split.leftChild;
            PrintDetailedMapNode(json, leftChild, childrenNodeSize);
            const Node* const rightChild = leftChild->buddy;
            PrintDetailedMapNode(json, rightChild, childrenNodeSize);
        }
        break;
    default:
        VMA_ASSERT(0);
    }
}
#endif // #if VMA_STATS_STRING_ENABLED


////////////////////////////////////////////////////////////////////////////////
// class VmaDeviceMemoryBlock

VmaDeviceMemoryBlock::VmaDeviceMemoryBlock(VmaAllocator hAllocator) :
    m_pMetadata(VMA_NULL),
    m_MemoryTypeIndex(UINT32_MAX),
    m_Id(0),
    m_hMemory(VK_NULL_HANDLE),
    m_MapCount(0),
    m_pMappedData(VMA_NULL)
{
}

void VmaDeviceMemoryBlock::Init(
    VmaAllocator hAllocator,
    VmaPool hParentPool,
    uint32_t newMemoryTypeIndex,
    VkDeviceMemory newMemory,
    VkDeviceSize newSize,
    uint32_t id,
    uint32_t algorithm)
{
    VMA_ASSERT(m_hMemory == VK_NULL_HANDLE);

    m_hParentPool = hParentPool;
    m_MemoryTypeIndex = newMemoryTypeIndex;
    m_Id = id;
    m_hMemory = newMemory;

    switch(algorithm)
    {
    case VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT:
        m_pMetadata = vma_new(hAllocator, VmaBlockMetadata_Linear)(hAllocator);
        break;
    case VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT:
        m_pMetadata = vma_new(hAllocator, VmaBlockMetadata_Buddy)(hAllocator);
        break;
    default:
        VMA_ASSERT(0);
        // Fall-through.
    case 0:
        m_pMetadata = vma_new(hAllocator, VmaBlockMetadata_Generic)(hAllocator);
    }
    m_pMetadata->Init(newSize);
}

void VmaDeviceMemoryBlock::Destroy(VmaAllocator allocator)
{
    // This is the most important assert in the entire library.
    // Hitting it means you have some memory leak - unreleased VmaAllocation objects.
    VMA_ASSERT(m_pMetadata->IsEmpty() && "Some allocations were not freed before destruction of this memory block!");

    VMA_ASSERT(m_hMemory != VK_NULL_HANDLE);
    allocator->FreeVulkanMemory(m_MemoryTypeIndex, m_pMetadata->GetSize(), m_hMemory);
    m_hMemory = VK_NULL_HANDLE;

    vma_delete(allocator, m_pMetadata);
    m_pMetadata = VMA_NULL;
}

bool VmaDeviceMemoryBlock::Validate() const
{
    VMA_VALIDATE((m_hMemory != VK_NULL_HANDLE) &&
        (m_pMetadata->GetSize() != 0));
    
    return m_pMetadata->Validate();
}

VkResult VmaDeviceMemoryBlock::CheckCorruption(VmaAllocator hAllocator)
{
    void* pData = nullptr;
    VkResult res = Map(hAllocator, 1, &pData);
    if(res != VK_SUCCESS)
    {
        return res;
    }

    res = m_pMetadata->CheckCorruption(pData);

    Unmap(hAllocator, 1);

    return res;
}

VkResult VmaDeviceMemoryBlock::Map(VmaAllocator hAllocator, uint32_t count, void** ppData)
{
    if(count == 0)
    {
        return VK_SUCCESS;
    }

    VmaMutexLock lock(m_Mutex, hAllocator->m_UseMutex);
    if(m_MapCount != 0)
    {
        m_MapCount += count;
        VMA_ASSERT(m_pMappedData != VMA_NULL);
        if(ppData != VMA_NULL)
        {
            *ppData = m_pMappedData;
        }
        return VK_SUCCESS;
    }
    else
    {
        VkResult result = (*hAllocator->GetVulkanFunctions().vkMapMemory)(
            hAllocator->m_hDevice,
            m_hMemory,
            0, // offset
            VK_WHOLE_SIZE,
            0, // flags
            &m_pMappedData);
        if(result == VK_SUCCESS)
        {
            if(ppData != VMA_NULL)
            {
                *ppData = m_pMappedData;
            }
            m_MapCount = count;
        }
        return result;
    }
}

void VmaDeviceMemoryBlock::Unmap(VmaAllocator hAllocator, uint32_t count)
{
    if(count == 0)
    {
        return;
    }

    VmaMutexLock lock(m_Mutex, hAllocator->m_UseMutex);
    if(m_MapCount >= count)
    {
        m_MapCount -= count;
        if(m_MapCount == 0)
        {
            m_pMappedData = VMA_NULL;
            (*hAllocator->GetVulkanFunctions().vkUnmapMemory)(hAllocator->m_hDevice, m_hMemory);
        }
    }
    else
    {
        VMA_ASSERT(0 && "VkDeviceMemory block is being unmapped while it was not previously mapped.");
    }
}

VkResult VmaDeviceMemoryBlock::WriteMagicValueAroundAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize)
{
    VMA_ASSERT(VMA_DEBUG_MARGIN > 0 && VMA_DEBUG_MARGIN % 4 == 0 && VMA_DEBUG_DETECT_CORRUPTION);
    VMA_ASSERT(allocOffset >= VMA_DEBUG_MARGIN);

    void* pData;
    VkResult res = Map(hAllocator, 1, &pData);
    if(res != VK_SUCCESS)
    {
        return res;
    }

    VmaWriteMagicValue(pData, allocOffset - VMA_DEBUG_MARGIN);
    VmaWriteMagicValue(pData, allocOffset + allocSize);

    Unmap(hAllocator, 1);

    return VK_SUCCESS;
}

VkResult VmaDeviceMemoryBlock::ValidateMagicValueAroundAllocation(VmaAllocator hAllocator, VkDeviceSize allocOffset, VkDeviceSize allocSize)
{
    VMA_ASSERT(VMA_DEBUG_MARGIN > 0 && VMA_DEBUG_MARGIN % 4 == 0 && VMA_DEBUG_DETECT_CORRUPTION);
    VMA_ASSERT(allocOffset >= VMA_DEBUG_MARGIN);

    void* pData;
    VkResult res = Map(hAllocator, 1, &pData);
    if(res != VK_SUCCESS)
    {
        return res;
    }

    if(!VmaValidateMagicValue(pData, allocOffset - VMA_DEBUG_MARGIN))
    {
        VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED BEFORE FREED ALLOCATION!");
    }
    else if(!VmaValidateMagicValue(pData, allocOffset + allocSize))
    {
        VMA_ASSERT(0 && "MEMORY CORRUPTION DETECTED AFTER FREED ALLOCATION!");
    }

    Unmap(hAllocator, 1);

    return VK_SUCCESS;
}

VkResult VmaDeviceMemoryBlock::BindBufferMemory(
    const VmaAllocator hAllocator,
    const VmaAllocation hAllocation,
    VkDeviceSize allocationLocalOffset,
    VkBuffer hBuffer,
    const void* pNext)
{
    VMA_ASSERT(hAllocation->GetType() == VmaAllocation_T::ALLOCATION_TYPE_BLOCK &&
        hAllocation->GetBlock() == this);
    VMA_ASSERT(allocationLocalOffset < hAllocation->GetSize() &&
        "Invalid allocationLocalOffset. Did you forget that this offset is relative to the beginning of the allocation, not the whole memory block?");
    const VkDeviceSize memoryOffset = hAllocation->GetOffset() + allocationLocalOffset;
    // This lock is important so that we don't call vkBind... and/or vkMap... simultaneously on the same VkDeviceMemory from multiple threads.
    VmaMutexLock lock(m_Mutex, hAllocator->m_UseMutex);
    return hAllocator->BindVulkanBuffer(m_hMemory, memoryOffset, hBuffer, pNext);
}

VkResult VmaDeviceMemoryBlock::BindImageMemory(
    const VmaAllocator hAllocator,
    const VmaAllocation hAllocation,
    VkDeviceSize allocationLocalOffset,
    VkImage hImage,
    const void* pNext)
{
    VMA_ASSERT(hAllocation->GetType() == VmaAllocation_T::ALLOCATION_TYPE_BLOCK &&
        hAllocation->GetBlock() == this);
    VMA_ASSERT(allocationLocalOffset < hAllocation->GetSize() &&
        "Invalid allocationLocalOffset. Did you forget that this offset is relative to the beginning of the allocation, not the whole memory block?");
    const VkDeviceSize memoryOffset = hAllocation->GetOffset() + allocationLocalOffset;
    // This lock is important so that we don't call vkBind... and/or vkMap... simultaneously on the same VkDeviceMemory from multiple threads.
    VmaMutexLock lock(m_Mutex, hAllocator->m_UseMutex);
    return hAllocator->BindVulkanImage(m_hMemory, memoryOffset, hImage, pNext);
}

static void InitStatInfo(VmaStatInfo& outInfo)
{
    memset(&outInfo, 0, sizeof(outInfo));
    outInfo.allocationSizeMin = UINT64_MAX;
    outInfo.unusedRangeSizeMin = UINT64_MAX;
}

// Adds statistics srcInfo into inoutInfo, like: inoutInfo += srcInfo.
static void VmaAddStatInfo(VmaStatInfo& inoutInfo, const VmaStatInfo& srcInfo)
{
    inoutInfo.blockCount += srcInfo.blockCount;
    inoutInfo.allocationCount += srcInfo.allocationCount;
    inoutInfo.unusedRangeCount += srcInfo.unusedRangeCount;
    inoutInfo.usedBytes += srcInfo.usedBytes;
    inoutInfo.unusedBytes += srcInfo.unusedBytes;
    inoutInfo.allocationSizeMin = VMA_MIN(inoutInfo.allocationSizeMin, srcInfo.allocationSizeMin);
    inoutInfo.allocationSizeMax = VMA_MAX(inoutInfo.allocationSizeMax, srcInfo.allocationSizeMax);
    inoutInfo.unusedRangeSizeMin = VMA_MIN(inoutInfo.unusedRangeSizeMin, srcInfo.unusedRangeSizeMin);
    inoutInfo.unusedRangeSizeMax = VMA_MAX(inoutInfo.unusedRangeSizeMax, srcInfo.unusedRangeSizeMax);
}

static void VmaPostprocessCalcStatInfo(VmaStatInfo& inoutInfo)
{
    inoutInfo.allocationSizeAvg = (inoutInfo.allocationCount > 0) ?
        VmaRoundDiv<VkDeviceSize>(inoutInfo.usedBytes, inoutInfo.allocationCount) : 0;
    inoutInfo.unusedRangeSizeAvg = (inoutInfo.unusedRangeCount > 0) ?
        VmaRoundDiv<VkDeviceSize>(inoutInfo.unusedBytes, inoutInfo.unusedRangeCount) : 0;
}

VmaPool_T::VmaPool_T(
    VmaAllocator hAllocator,
    const VmaPoolCreateInfo& createInfo,
    VkDeviceSize preferredBlockSize) :
    m_BlockVector(
        hAllocator,
        this, // hParentPool
        createInfo.memoryTypeIndex,
        createInfo.blockSize != 0 ? createInfo.blockSize : preferredBlockSize,
        createInfo.minBlockCount,
        createInfo.maxBlockCount,
        (createInfo.flags & VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT) != 0 ? 1 : hAllocator->GetBufferImageGranularity(),
        createInfo.frameInUseCount,
        createInfo.blockSize != 0, // explicitBlockSize
        createInfo.flags & VMA_POOL_CREATE_ALGORITHM_MASK), // algorithm
    m_Id(0),
    m_Name(VMA_NULL)
{
}

VmaPool_T::~VmaPool_T()
{
}

void VmaPool_T::SetName(const char* pName)
{
    const VkAllocationCallbacks* allocs = m_BlockVector.GetAllocator()->GetAllocationCallbacks();
    VmaFreeString(allocs, m_Name);
    
    if(pName != VMA_NULL)
    {
        m_Name = VmaCreateStringCopy(allocs, pName);
    }
    else
    {
        m_Name = VMA_NULL;
    }
}

#if VMA_STATS_STRING_ENABLED

#endif // #if VMA_STATS_STRING_ENABLED

VmaBlockVector::VmaBlockVector(
    VmaAllocator hAllocator,
    VmaPool hParentPool,
    uint32_t memoryTypeIndex,
    VkDeviceSize preferredBlockSize,
    size_t minBlockCount,
    size_t maxBlockCount,
    VkDeviceSize bufferImageGranularity,
    uint32_t frameInUseCount,
    bool explicitBlockSize,
    uint32_t algorithm) :
    m_hAllocator(hAllocator),
    m_hParentPool(hParentPool),
    m_MemoryTypeIndex(memoryTypeIndex),
    m_PreferredBlockSize(preferredBlockSize),
    m_MinBlockCount(minBlockCount),
    m_MaxBlockCount(maxBlockCount),
    m_BufferImageGranularity(bufferImageGranularity),
    m_FrameInUseCount(frameInUseCount),
    m_ExplicitBlockSize(explicitBlockSize),
    m_Algorithm(algorithm),
    m_HasEmptyBlock(false),
    m_Blocks(VmaStlAllocator<VmaDeviceMemoryBlock*>(hAllocator->GetAllocationCallbacks())),
    m_NextBlockId(0)
{
}

VmaBlockVector::~VmaBlockVector()
{
    for(size_t i = m_Blocks.size(); i--; )
    {
        m_Blocks[i]->Destroy(m_hAllocator);
        vma_delete(m_hAllocator, m_Blocks[i]);
    }
}

VkResult VmaBlockVector::CreateMinBlocks()
{
    for(size_t i = 0; i < m_MinBlockCount; ++i)
    {
        VkResult res = CreateBlock(m_PreferredBlockSize, VMA_NULL);
        if(res != VK_SUCCESS)
        {
            return res;
        }
    }
    return VK_SUCCESS;
}

void VmaBlockVector::GetPoolStats(VmaPoolStats* pStats)
{
    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);

    const size_t blockCount = m_Blocks.size();

    pStats->size = 0;
    pStats->unusedSize = 0;
    pStats->allocationCount = 0;
    pStats->unusedRangeCount = 0;
    pStats->unusedRangeSizeMax = 0;
    pStats->blockCount = blockCount;

    for(uint32_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
    {
        const VmaDeviceMemoryBlock* const pBlock = m_Blocks[blockIndex];
        VMA_ASSERT(pBlock);
        VMA_HEAVY_ASSERT(pBlock->Validate());
        pBlock->m_pMetadata->AddPoolStats(*pStats);
    }
}

bool VmaBlockVector::IsEmpty()
{
    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);
    return m_Blocks.empty();
}

bool VmaBlockVector::IsCorruptionDetectionEnabled() const
{
    const uint32_t requiredMemFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
    return (VMA_DEBUG_DETECT_CORRUPTION != 0) &&
        (VMA_DEBUG_MARGIN > 0) &&
        (m_Algorithm == 0 || m_Algorithm == VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT) &&
        (m_hAllocator->m_MemProps.memoryTypes[m_MemoryTypeIndex].propertyFlags & requiredMemFlags) == requiredMemFlags;
}

static const uint32_t VMA_ALLOCATION_TRY_COUNT = 32;

VkResult VmaBlockVector::Allocate(
    uint32_t currentFrameIndex,
    VkDeviceSize size,
    VkDeviceSize alignment,
    const VmaAllocationCreateInfo& createInfo,
    VmaSuballocationType suballocType,
    size_t allocationCount,
    VmaAllocation* pAllocations)
{
    size_t allocIndex;
    VkResult res = VK_SUCCESS;

    if(IsCorruptionDetectionEnabled())
    {
        size = VmaAlignUp<VkDeviceSize>(size, sizeof(VMA_CORRUPTION_DETECTION_MAGIC_VALUE));
        alignment = VmaAlignUp<VkDeviceSize>(alignment, sizeof(VMA_CORRUPTION_DETECTION_MAGIC_VALUE));
    }

    {
        VmaMutexLockWrite lock(m_Mutex, m_hAllocator->m_UseMutex);
        for(allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
        {
            res = AllocatePage(
                currentFrameIndex,
                size,
                alignment,
                createInfo,
                suballocType,
                pAllocations + allocIndex);
            if(res != VK_SUCCESS)
            {
                break;
            }
        }
    }

    if(res != VK_SUCCESS)
    {
        // Free all already created allocations.
        while(allocIndex--)
        {
            Free(pAllocations[allocIndex]);
        }
        memset(pAllocations, 0, sizeof(VmaAllocation) * allocationCount);
    }

    return res;
}

VkResult VmaBlockVector::AllocatePage(
    uint32_t currentFrameIndex,
    VkDeviceSize size,
    VkDeviceSize alignment,
    const VmaAllocationCreateInfo& createInfo,
    VmaSuballocationType suballocType,
    VmaAllocation* pAllocation)
{
    const bool isUpperAddress = (createInfo.flags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT) != 0;
    bool canMakeOtherLost = (createInfo.flags & VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT) != 0;
    const bool mapped = (createInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0;
    const bool isUserDataString = (createInfo.flags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0;
    
    const bool withinBudget = (createInfo.flags & VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT) != 0;
    VkDeviceSize freeMemory;
    {
        const uint32_t heapIndex = m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex);
        VmaBudget heapBudget = {};
        m_hAllocator->GetBudget(&heapBudget, heapIndex, 1);
        freeMemory = (heapBudget.usage < heapBudget.budget) ? (heapBudget.budget - heapBudget.usage) : 0;
    }
    
    const bool canFallbackToDedicated = !IsCustomPool();
    const bool canCreateNewBlock =
        ((createInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) == 0) &&
        (m_Blocks.size() < m_MaxBlockCount) &&
        (freeMemory >= size || !canFallbackToDedicated);
    uint32_t strategy = createInfo.flags & VMA_ALLOCATION_CREATE_STRATEGY_MASK;

    // If linearAlgorithm is used, canMakeOtherLost is available only when used as ring buffer.
    // Which in turn is available only when maxBlockCount = 1.
    if(m_Algorithm == VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT && m_MaxBlockCount > 1)
    {
        canMakeOtherLost = false;
    }

    // Upper address can only be used with linear allocator and within single memory block.
    if(isUpperAddress &&
        (m_Algorithm != VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT || m_MaxBlockCount > 1))
    {
        return VK_ERROR_FEATURE_NOT_PRESENT;
    }

    // Validate strategy.
    switch(strategy)
    {
    case 0:
        strategy = VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT;
        break;
    case VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT:
    case VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT:
    case VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT:
        break;
    default:
        return VK_ERROR_FEATURE_NOT_PRESENT;
    }

    // Early reject: requested allocation size is larger that maximum block size for this block vector.
    if(size + 2 * VMA_DEBUG_MARGIN > m_PreferredBlockSize)
    {
        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
    }

    /*
    Under certain condition, this whole section can be skipped for optimization, so
    we move on directly to trying to allocate with canMakeOtherLost. That's the case
    e.g. for custom pools with linear algorithm.
    */
    if(!canMakeOtherLost || canCreateNewBlock)
    {
        // 1. Search existing allocations. Try to allocate without making other allocations lost.
        VmaAllocationCreateFlags allocFlagsCopy = createInfo.flags;
        allocFlagsCopy &= ~VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT;

        if(m_Algorithm == VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT)
        {
            // Use only last block.
            if(!m_Blocks.empty())
            {
                VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks.back();
                VMA_ASSERT(pCurrBlock);
                VkResult res = AllocateFromBlock(
                    pCurrBlock,
                    currentFrameIndex,
                    size,
                    alignment,
                    allocFlagsCopy,
                    createInfo.pUserData,
                    suballocType,
                    strategy,
                    pAllocation);
                if(res == VK_SUCCESS)
                {
                    VMA_DEBUG_LOG("    Returned from last block #%u", pCurrBlock->GetId());
                    return VK_SUCCESS;
                }
            }
        }
        else
        {
            if(strategy == VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT)
            {
                // Forward order in m_Blocks - prefer blocks with smallest amount of free space.
                for(size_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex )
                {
                    VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks[blockIndex];
                    VMA_ASSERT(pCurrBlock);
                    VkResult res = AllocateFromBlock(
                        pCurrBlock,
                        currentFrameIndex,
                        size,
                        alignment,
                        allocFlagsCopy,
                        createInfo.pUserData,
                        suballocType,
                        strategy,
                        pAllocation);
                    if(res == VK_SUCCESS)
                    {
                        VMA_DEBUG_LOG("    Returned from existing block #%u", pCurrBlock->GetId());
                        return VK_SUCCESS;
                    }
                }
            }
            else // WORST_FIT, FIRST_FIT
            {
                // Backward order in m_Blocks - prefer blocks with largest amount of free space.
                for(size_t blockIndex = m_Blocks.size(); blockIndex--; )
                {
                    VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks[blockIndex];
                    VMA_ASSERT(pCurrBlock);
                    VkResult res = AllocateFromBlock(
                        pCurrBlock,
                        currentFrameIndex,
                        size,
                        alignment,
                        allocFlagsCopy,
                        createInfo.pUserData,
                        suballocType,
                        strategy,
                        pAllocation);
                    if(res == VK_SUCCESS)
                    {
                        VMA_DEBUG_LOG("    Returned from existing block #%u", pCurrBlock->GetId());
                        return VK_SUCCESS;
                    }
                }
            }
        }

        // 2. Try to create new block.
        if(canCreateNewBlock)
        {
            // Calculate optimal size for new block.
            VkDeviceSize newBlockSize = m_PreferredBlockSize;
            uint32_t newBlockSizeShift = 0;
            const uint32_t NEW_BLOCK_SIZE_SHIFT_MAX = 3;

            if(!m_ExplicitBlockSize)
            {
                // Allocate 1/8, 1/4, 1/2 as first blocks.
                const VkDeviceSize maxExistingBlockSize = CalcMaxBlockSize();
                for(uint32_t i = 0; i < NEW_BLOCK_SIZE_SHIFT_MAX; ++i)
                {
                    const VkDeviceSize smallerNewBlockSize = newBlockSize / 2;
                    if(smallerNewBlockSize > maxExistingBlockSize && smallerNewBlockSize >= size * 2)
                    {
                        newBlockSize = smallerNewBlockSize;
                        ++newBlockSizeShift;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            size_t newBlockIndex = 0;
            VkResult res = (newBlockSize <= freeMemory || !canFallbackToDedicated) ?
                CreateBlock(newBlockSize, &newBlockIndex) : VK_ERROR_OUT_OF_DEVICE_MEMORY;
            // Allocation of this size failed? Try 1/2, 1/4, 1/8 of m_PreferredBlockSize.
            if(!m_ExplicitBlockSize)
            {
                while(res < 0 && newBlockSizeShift < NEW_BLOCK_SIZE_SHIFT_MAX)
                {
                    const VkDeviceSize smallerNewBlockSize = newBlockSize / 2;
                    if(smallerNewBlockSize >= size)
                    {
                        newBlockSize = smallerNewBlockSize;
                        ++newBlockSizeShift;
                        res = (newBlockSize <= freeMemory || !canFallbackToDedicated) ?
                            CreateBlock(newBlockSize, &newBlockIndex) : VK_ERROR_OUT_OF_DEVICE_MEMORY;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            if(res == VK_SUCCESS)
            {
                VmaDeviceMemoryBlock* const pBlock = m_Blocks[newBlockIndex];
                VMA_ASSERT(pBlock->m_pMetadata->GetSize() >= size);

                res = AllocateFromBlock(
                    pBlock,
                    currentFrameIndex,
                    size,
                    alignment,
                    allocFlagsCopy,
                    createInfo.pUserData,
                    suballocType,
                    strategy,
                    pAllocation);
                if(res == VK_SUCCESS)
                {
                    VMA_DEBUG_LOG("    Created new block #%u Size=%llu", pBlock->GetId(), newBlockSize);
                    return VK_SUCCESS;
                }
                else
                {
                    // Allocation from new block failed, possibly due to VMA_DEBUG_MARGIN or alignment.
                    return VK_ERROR_OUT_OF_DEVICE_MEMORY;
                }
            }
        }
    }

    // 3. Try to allocate from existing blocks with making other allocations lost.
    if(canMakeOtherLost)
    {
        uint32_t tryIndex = 0;
        for(; tryIndex < VMA_ALLOCATION_TRY_COUNT; ++tryIndex)
        {
            VmaDeviceMemoryBlock* pBestRequestBlock = VMA_NULL;
            VmaAllocationRequest bestRequest = {};
            VkDeviceSize bestRequestCost = VK_WHOLE_SIZE;

            // 1. Search existing allocations.
            if(strategy == VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT)
            {
                // Forward order in m_Blocks - prefer blocks with smallest amount of free space.
                for(size_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex )
                {
                    VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks[blockIndex];
                    VMA_ASSERT(pCurrBlock);
                    VmaAllocationRequest currRequest = {};
                    if(pCurrBlock->m_pMetadata->CreateAllocationRequest(
                        currentFrameIndex,
                        m_FrameInUseCount,
                        m_BufferImageGranularity,
                        size,
                        alignment,
                        (createInfo.flags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT) != 0,
                        suballocType,
                        canMakeOtherLost,
                        strategy,
                        &currRequest))
                    {
                        const VkDeviceSize currRequestCost = currRequest.CalcCost();
                        if(pBestRequestBlock == VMA_NULL ||
                            currRequestCost < bestRequestCost)
                        {
                            pBestRequestBlock = pCurrBlock;
                            bestRequest = currRequest;
                            bestRequestCost = currRequestCost;

                            if(bestRequestCost == 0)
                            {
                                break;
                            }
                        }
                    }
                }
            }
            else // WORST_FIT, FIRST_FIT
            {
                // Backward order in m_Blocks - prefer blocks with largest amount of free space.
                for(size_t blockIndex = m_Blocks.size(); blockIndex--; )
                {
                    VmaDeviceMemoryBlock* const pCurrBlock = m_Blocks[blockIndex];
                    VMA_ASSERT(pCurrBlock);
                    VmaAllocationRequest currRequest = {};
                    if(pCurrBlock->m_pMetadata->CreateAllocationRequest(
                        currentFrameIndex,
                        m_FrameInUseCount,
                        m_BufferImageGranularity,
                        size,
                        alignment,
                        (createInfo.flags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT) != 0,
                        suballocType,
                        canMakeOtherLost,
                        strategy,
                        &currRequest))
                    {
                        const VkDeviceSize currRequestCost = currRequest.CalcCost();
                        if(pBestRequestBlock == VMA_NULL ||
                            currRequestCost < bestRequestCost ||
                            strategy == VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT)
                        {
                            pBestRequestBlock = pCurrBlock;
                            bestRequest = currRequest;
                            bestRequestCost = currRequestCost;

                            if(bestRequestCost == 0 ||
                                strategy == VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            if(pBestRequestBlock != VMA_NULL)
            {
                if(mapped)
                {
                    VkResult res = pBestRequestBlock->Map(m_hAllocator, 1, VMA_NULL);
                    if(res != VK_SUCCESS)
                    {
                        return res;
                    }
                }

                if(pBestRequestBlock->m_pMetadata->MakeRequestedAllocationsLost(
                    currentFrameIndex,
                    m_FrameInUseCount,
                    &bestRequest))
                {
                    // Allocate from this pBlock.
                    *pAllocation = m_hAllocator->m_AllocationObjectAllocator.Allocate();
                    (*pAllocation)->Ctor(currentFrameIndex, isUserDataString);
                    pBestRequestBlock->m_pMetadata->Alloc(bestRequest, suballocType, size, *pAllocation);
                    UpdateHasEmptyBlock();
                    (*pAllocation)->InitBlockAllocation(
                        pBestRequestBlock,
                        bestRequest.offset,
                        alignment,
                        size,
                        m_MemoryTypeIndex,
                        suballocType,
                        mapped,
                        (createInfo.flags & VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT) != 0);
                    VMA_HEAVY_ASSERT(pBestRequestBlock->Validate());
                    VMA_DEBUG_LOG("    Returned from existing block");
                    (*pAllocation)->SetUserData(m_hAllocator, createInfo.pUserData);
                    m_hAllocator->m_Budget.AddAllocation(m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex), size);
                    if(VMA_DEBUG_INITIALIZE_ALLOCATIONS)
                    {
                        m_hAllocator->FillAllocation(*pAllocation, VMA_ALLOCATION_FILL_PATTERN_CREATED);
                    }
                    if(IsCorruptionDetectionEnabled())
                    {
                        VkResult res = pBestRequestBlock->WriteMagicValueAroundAllocation(m_hAllocator, bestRequest.offset, size);
                        VMA_ASSERT(res == VK_SUCCESS && "Couldn't map block memory to write magic value.");
                    }
                    return VK_SUCCESS;
                }
                // else: Some allocations must have been touched while we are here. Next try.
            }
            else
            {
                // Could not find place in any of the blocks - break outer loop.
                break;
            }
        }
        /* Maximum number of tries exceeded - a very unlike event when many other
        threads are simultaneously touching allocations making it impossible to make
        lost at the same time as we try to allocate. */
        if(tryIndex == VMA_ALLOCATION_TRY_COUNT)
        {
            return VK_ERROR_TOO_MANY_OBJECTS;
        }
    }

    return VK_ERROR_OUT_OF_DEVICE_MEMORY;
}

void VmaBlockVector::Free(
    const VmaAllocation hAllocation)
{
    VmaDeviceMemoryBlock* pBlockToDelete = VMA_NULL;

    bool budgetExceeded = false;
    {
        const uint32_t heapIndex = m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex);
        VmaBudget heapBudget = {};
        m_hAllocator->GetBudget(&heapBudget, heapIndex, 1);
        budgetExceeded = heapBudget.usage >= heapBudget.budget;
    }

    // Scope for lock.
    {
        VmaMutexLockWrite lock(m_Mutex, m_hAllocator->m_UseMutex);

        VmaDeviceMemoryBlock* pBlock = hAllocation->GetBlock();

        if(IsCorruptionDetectionEnabled())
        {
            VkResult res = pBlock->ValidateMagicValueAroundAllocation(m_hAllocator, hAllocation->GetOffset(), hAllocation->GetSize());
            VMA_ASSERT(res == VK_SUCCESS && "Couldn't map block memory to validate magic value.");
        }

        if(hAllocation->IsPersistentMap())
        {
            pBlock->Unmap(m_hAllocator, 1);
        }

        pBlock->m_pMetadata->Free(hAllocation);
        VMA_HEAVY_ASSERT(pBlock->Validate());

        VMA_DEBUG_LOG("  Freed from MemoryTypeIndex=%u", m_MemoryTypeIndex);

        const bool canDeleteBlock = m_Blocks.size() > m_MinBlockCount;
        // pBlock became empty after this deallocation.
        if(pBlock->m_pMetadata->IsEmpty())
        {
            // Already has empty block. We don't want to have two, so delete this one.
            if((m_HasEmptyBlock || budgetExceeded) && canDeleteBlock)
            {
                pBlockToDelete = pBlock;
                Remove(pBlock);
            }
            // else: We now have an empty block - leave it.
        }
        // pBlock didn't become empty, but we have another empty block - find and free that one.
        // (This is optional, heuristics.)
        else if(m_HasEmptyBlock && canDeleteBlock)
        {
            VmaDeviceMemoryBlock* pLastBlock = m_Blocks.back();
            if(pLastBlock->m_pMetadata->IsEmpty())
            {
                pBlockToDelete = pLastBlock;
                m_Blocks.pop_back();
            }
        }

        UpdateHasEmptyBlock();
        IncrementallySortBlocks();
    }

    // Destruction of a free block. Deferred until this point, outside of mutex
    // lock, for performance reason.
    if(pBlockToDelete != VMA_NULL)
    {
        VMA_DEBUG_LOG("    Deleted empty block");
        pBlockToDelete->Destroy(m_hAllocator);
        vma_delete(m_hAllocator, pBlockToDelete);
    }
}

VkDeviceSize VmaBlockVector::CalcMaxBlockSize() const
{
    VkDeviceSize result = 0;
    for(size_t i = m_Blocks.size(); i--; )
    {
        result = VMA_MAX(result, m_Blocks[i]->m_pMetadata->GetSize());
        if(result >= m_PreferredBlockSize)
        {
            break;
        }
    }
    return result;
}

void VmaBlockVector::Remove(VmaDeviceMemoryBlock* pBlock)
{
    for(uint32_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex)
    {
        if(m_Blocks[blockIndex] == pBlock)
        {
            VmaVectorRemove(m_Blocks, blockIndex);
            return;
        }
    }
    VMA_ASSERT(0);
}

void VmaBlockVector::IncrementallySortBlocks()
{
    if(m_Algorithm != VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT)
    {
        // Bubble sort only until first swap.
        for(size_t i = 1; i < m_Blocks.size(); ++i)
        {
            if(m_Blocks[i - 1]->m_pMetadata->GetSumFreeSize() > m_Blocks[i]->m_pMetadata->GetSumFreeSize())
            {
                VMA_SWAP(m_Blocks[i - 1], m_Blocks[i]);
                return;
            }
        }
    }
}

VkResult VmaBlockVector::AllocateFromBlock(
    VmaDeviceMemoryBlock* pBlock,
    uint32_t currentFrameIndex,
    VkDeviceSize size,
    VkDeviceSize alignment,
    VmaAllocationCreateFlags allocFlags,
    void* pUserData,
    VmaSuballocationType suballocType,
    uint32_t strategy,
    VmaAllocation* pAllocation)
{
    VMA_ASSERT((allocFlags & VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT) == 0);
    const bool isUpperAddress = (allocFlags & VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT) != 0;
    const bool mapped = (allocFlags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0;
    const bool isUserDataString = (allocFlags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0;

    VmaAllocationRequest currRequest = {};
    if(pBlock->m_pMetadata->CreateAllocationRequest(
        currentFrameIndex,
        m_FrameInUseCount,
        m_BufferImageGranularity,
        size,
        alignment,
        isUpperAddress,
        suballocType,
        false, // canMakeOtherLost
        strategy,
        &currRequest))
    {
        // Allocate from pCurrBlock.
        VMA_ASSERT(currRequest.itemsToMakeLostCount == 0);

        if(mapped)
        {
            VkResult res = pBlock->Map(m_hAllocator, 1, VMA_NULL);
            if(res != VK_SUCCESS)
            {
                return res;
            }
        }
            
        *pAllocation = m_hAllocator->m_AllocationObjectAllocator.Allocate();
        (*pAllocation)->Ctor(currentFrameIndex, isUserDataString);
        pBlock->m_pMetadata->Alloc(currRequest, suballocType, size, *pAllocation);
        UpdateHasEmptyBlock();
        (*pAllocation)->InitBlockAllocation(
            pBlock,
            currRequest.offset,
            alignment,
            size,
            m_MemoryTypeIndex,
            suballocType,
            mapped,
            (allocFlags & VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT) != 0);
        VMA_HEAVY_ASSERT(pBlock->Validate());
        (*pAllocation)->SetUserData(m_hAllocator, pUserData);
        m_hAllocator->m_Budget.AddAllocation(m_hAllocator->MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex), size);
        if(VMA_DEBUG_INITIALIZE_ALLOCATIONS)
        {
            m_hAllocator->FillAllocation(*pAllocation, VMA_ALLOCATION_FILL_PATTERN_CREATED);
        }
        if(IsCorruptionDetectionEnabled())
        {
            VkResult res = pBlock->WriteMagicValueAroundAllocation(m_hAllocator, currRequest.offset, size);
            VMA_ASSERT(res == VK_SUCCESS && "Couldn't map block memory to write magic value.");
        }
        return VK_SUCCESS;
    }
    return VK_ERROR_OUT_OF_DEVICE_MEMORY;
}

VkResult VmaBlockVector::CreateBlock(VkDeviceSize blockSize, size_t* pNewBlockIndex)
{
    VkMemoryAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };
    allocInfo.memoryTypeIndex = m_MemoryTypeIndex;
    allocInfo.allocationSize = blockSize;
    VkDeviceMemory mem = VK_NULL_HANDLE;
    VkResult res = m_hAllocator->AllocateVulkanMemory(&allocInfo, &mem);
    if(res < 0)
    {
        return res;
    }

    // New VkDeviceMemory successfully created.

    // Create new Allocation for it.
    VmaDeviceMemoryBlock* const pBlock = vma_new(m_hAllocator, VmaDeviceMemoryBlock)(m_hAllocator);
    pBlock->Init(
        m_hAllocator,
        m_hParentPool,
        m_MemoryTypeIndex,
        mem,
        allocInfo.allocationSize,
        m_NextBlockId++,
        m_Algorithm);

    m_Blocks.push_back(pBlock);
    if(pNewBlockIndex != VMA_NULL)
    {
        *pNewBlockIndex = m_Blocks.size() - 1;
    }

    return VK_SUCCESS;
}

void VmaBlockVector::ApplyDefragmentationMovesCpu(
    class VmaBlockVectorDefragmentationContext* pDefragCtx,
    const VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves)
{
    const size_t blockCount = m_Blocks.size();
    const bool isNonCoherent = m_hAllocator->IsMemoryTypeNonCoherent(m_MemoryTypeIndex);

    enum BLOCK_FLAG
    {
        BLOCK_FLAG_USED = 0x00000001,
        BLOCK_FLAG_MAPPED_FOR_DEFRAGMENTATION = 0x00000002,
    };

    struct BlockInfo
    {
        uint32_t flags;
        void* pMappedData;
    };
    VmaVector< BlockInfo, VmaStlAllocator<BlockInfo> >
        blockInfo(blockCount, BlockInfo(), VmaStlAllocator<BlockInfo>(m_hAllocator->GetAllocationCallbacks()));
    memset(blockInfo.data(), 0, blockCount * sizeof(BlockInfo));

    // Go over all moves. Mark blocks that are used with BLOCK_FLAG_USED.
    const size_t moveCount = moves.size();
    for(size_t moveIndex = 0; moveIndex < moveCount; ++moveIndex)
    {
        const VmaDefragmentationMove& move = moves[moveIndex];
        blockInfo[move.srcBlockIndex].flags |= BLOCK_FLAG_USED;
        blockInfo[move.dstBlockIndex].flags |= BLOCK_FLAG_USED;
    }

    VMA_ASSERT(pDefragCtx->res == VK_SUCCESS);

    // Go over all blocks. Get mapped pointer or map if necessary.
    for(size_t blockIndex = 0; pDefragCtx->res == VK_SUCCESS && blockIndex < blockCount; ++blockIndex)
    {
        BlockInfo& currBlockInfo = blockInfo[blockIndex];
        VmaDeviceMemoryBlock* pBlock = m_Blocks[blockIndex];
        if((currBlockInfo.flags & BLOCK_FLAG_USED) != 0)
        {
            currBlockInfo.pMappedData = pBlock->GetMappedData();
            // It is not originally mapped - map it.
            if(currBlockInfo.pMappedData == VMA_NULL)
            {
                pDefragCtx->res = pBlock->Map(m_hAllocator, 1, &currBlockInfo.pMappedData);
                if(pDefragCtx->res == VK_SUCCESS)
                {
                    currBlockInfo.flags |= BLOCK_FLAG_MAPPED_FOR_DEFRAGMENTATION;
                }
            }
        }
    }

    // Go over all moves. Do actual data transfer.
    if(pDefragCtx->res == VK_SUCCESS)
    {
        const VkDeviceSize nonCoherentAtomSize = m_hAllocator->m_PhysicalDeviceProperties.limits.nonCoherentAtomSize;
        VkMappedMemoryRange memRange = { VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE };

        for(size_t moveIndex = 0; moveIndex < moveCount; ++moveIndex)
        {
            const VmaDefragmentationMove& move = moves[moveIndex];

            const BlockInfo& srcBlockInfo = blockInfo[move.srcBlockIndex];
            const BlockInfo& dstBlockInfo = blockInfo[move.dstBlockIndex];

            VMA_ASSERT(srcBlockInfo.pMappedData && dstBlockInfo.pMappedData);

            // Invalidate source.
            if(isNonCoherent)
            {
                VmaDeviceMemoryBlock* const pSrcBlock = m_Blocks[move.srcBlockIndex];
                memRange.memory = pSrcBlock->GetDeviceMemory();
                memRange.offset = VmaAlignDown(move.srcOffset, nonCoherentAtomSize);
                memRange.size = VMA_MIN(
                    VmaAlignUp(move.size + (move.srcOffset - memRange.offset), nonCoherentAtomSize),
                    pSrcBlock->m_pMetadata->GetSize() - memRange.offset);
                (*m_hAllocator->GetVulkanFunctions().vkInvalidateMappedMemoryRanges)(m_hAllocator->m_hDevice, 1, &memRange);
            }

            // THE PLACE WHERE ACTUAL DATA COPY HAPPENS.
            memmove(
                reinterpret_cast<char*>(dstBlockInfo.pMappedData) + move.dstOffset,
                reinterpret_cast<char*>(srcBlockInfo.pMappedData) + move.srcOffset,
                static_cast<size_t>(move.size));

            if(IsCorruptionDetectionEnabled())
            {
                VmaWriteMagicValue(dstBlockInfo.pMappedData, move.dstOffset - VMA_DEBUG_MARGIN);
                VmaWriteMagicValue(dstBlockInfo.pMappedData, move.dstOffset + move.size);
            }

            // Flush destination.
            if(isNonCoherent)
            {
                VmaDeviceMemoryBlock* const pDstBlock = m_Blocks[move.dstBlockIndex];
                memRange.memory = pDstBlock->GetDeviceMemory();
                memRange.offset = VmaAlignDown(move.dstOffset, nonCoherentAtomSize);
                memRange.size = VMA_MIN(
                    VmaAlignUp(move.size + (move.dstOffset - memRange.offset), nonCoherentAtomSize),
                    pDstBlock->m_pMetadata->GetSize() - memRange.offset);
                (*m_hAllocator->GetVulkanFunctions().vkFlushMappedMemoryRanges)(m_hAllocator->m_hDevice, 1, &memRange);
            }
        }
    }

    // Go over all blocks in reverse order. Unmap those that were mapped just for defragmentation.
    // Regardless of pCtx->res == VK_SUCCESS.
    for(size_t blockIndex = blockCount; blockIndex--; )
    {
        const BlockInfo& currBlockInfo = blockInfo[blockIndex];
        if((currBlockInfo.flags & BLOCK_FLAG_MAPPED_FOR_DEFRAGMENTATION) != 0)
        {
            VmaDeviceMemoryBlock* pBlock = m_Blocks[blockIndex];
            pBlock->Unmap(m_hAllocator, 1);
        }
    }
}

void VmaBlockVector::ApplyDefragmentationMovesGpu(
    class VmaBlockVectorDefragmentationContext* pDefragCtx,
    const VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
    VkCommandBuffer commandBuffer)
{
    const size_t blockCount = m_Blocks.size();

    pDefragCtx->blockContexts.resize(blockCount);
    memset(pDefragCtx->blockContexts.data(), 0, blockCount * sizeof(VmaBlockDefragmentationContext));

    // Go over all moves. Mark blocks that are used with BLOCK_FLAG_USED.
    const size_t moveCount = moves.size();
    for(size_t moveIndex = 0; moveIndex < moveCount; ++moveIndex)
    {
        const VmaDefragmentationMove& move = moves[moveIndex];
        pDefragCtx->blockContexts[move.srcBlockIndex].flags |= VmaBlockDefragmentationContext::BLOCK_FLAG_USED;
        pDefragCtx->blockContexts[move.dstBlockIndex].flags |= VmaBlockDefragmentationContext::BLOCK_FLAG_USED;
    }

    VMA_ASSERT(pDefragCtx->res == VK_SUCCESS);

    // Go over all blocks. Create and bind buffer for whole block if necessary.
    {
        VkBufferCreateInfo bufCreateInfo;
        VmaFillGpuDefragmentationBufferCreateInfo(bufCreateInfo);

        for(size_t blockIndex = 0; pDefragCtx->res == VK_SUCCESS && blockIndex < blockCount; ++blockIndex)
        {
            VmaBlockDefragmentationContext& currBlockCtx = pDefragCtx->blockContexts[blockIndex];
            VmaDeviceMemoryBlock* pBlock = m_Blocks[blockIndex];
            if((currBlockCtx.flags & VmaBlockDefragmentationContext::BLOCK_FLAG_USED) != 0)
            {
                bufCreateInfo.size = pBlock->m_pMetadata->GetSize();
                pDefragCtx->res = (*m_hAllocator->GetVulkanFunctions().vkCreateBuffer)(
                    m_hAllocator->m_hDevice, &bufCreateInfo, m_hAllocator->GetAllocationCallbacks(), &currBlockCtx.hBuffer);
                if(pDefragCtx->res == VK_SUCCESS)
                {
                    pDefragCtx->res = (*m_hAllocator->GetVulkanFunctions().vkBindBufferMemory)(
                        m_hAllocator->m_hDevice, currBlockCtx.hBuffer, pBlock->GetDeviceMemory(), 0);
                }
            }
        }
    }

    // Go over all moves. Post data transfer commands to command buffer.
    if(pDefragCtx->res == VK_SUCCESS)
    {
        for(size_t moveIndex = 0; moveIndex < moveCount; ++moveIndex)
        {
            const VmaDefragmentationMove& move = moves[moveIndex];

            const VmaBlockDefragmentationContext& srcBlockCtx = pDefragCtx->blockContexts[move.srcBlockIndex];
            const VmaBlockDefragmentationContext& dstBlockCtx = pDefragCtx->blockContexts[move.dstBlockIndex];

            VMA_ASSERT(srcBlockCtx.hBuffer && dstBlockCtx.hBuffer);

            VkBufferCopy region = {
                move.srcOffset,
                move.dstOffset,
                move.size };
            (*m_hAllocator->GetVulkanFunctions().vkCmdCopyBuffer)(
                commandBuffer, srcBlockCtx.hBuffer, dstBlockCtx.hBuffer, 1, &region);
        }
    }

    // Save buffers to defrag context for later destruction.
    if(pDefragCtx->res == VK_SUCCESS && moveCount > 0)
    {
        pDefragCtx->res = VK_NOT_READY;
    }
}

void VmaBlockVector::FreeEmptyBlocks(VmaDefragmentationStats* pDefragmentationStats)
{
    for(size_t blockIndex = m_Blocks.size(); blockIndex--; )
    {
        VmaDeviceMemoryBlock* pBlock = m_Blocks[blockIndex];
        if(pBlock->m_pMetadata->IsEmpty())
        {
            if(m_Blocks.size() > m_MinBlockCount)
            {
                if(pDefragmentationStats != VMA_NULL)
                {
                    ++pDefragmentationStats->deviceMemoryBlocksFreed;
                    pDefragmentationStats->bytesFreed += pBlock->m_pMetadata->GetSize();
                }

                VmaVectorRemove(m_Blocks, blockIndex);
                pBlock->Destroy(m_hAllocator);
                vma_delete(m_hAllocator, pBlock);
            }
            else
            {
                break;
            }
        }
    }
    UpdateHasEmptyBlock();
}

void VmaBlockVector::UpdateHasEmptyBlock()
{
    m_HasEmptyBlock = false;
    for(size_t index = 0, count = m_Blocks.size(); index < count; ++index)
    {
        VmaDeviceMemoryBlock* const pBlock = m_Blocks[index];
        if(pBlock->m_pMetadata->IsEmpty())
        {
            m_HasEmptyBlock = true;
            break;
        }
    }
}

#if VMA_STATS_STRING_ENABLED

void VmaBlockVector::PrintDetailedMap(class VmaJsonWriter& json)
{
    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);

    json.BeginObject();

    if(IsCustomPool())
    {
        const char* poolName = m_hParentPool->GetName();
        if(poolName != VMA_NULL && poolName[0] != '\0')
        {
            json.WriteString("Name");
            json.WriteString(poolName);
        }

        json.WriteString("MemoryTypeIndex");
        json.WriteNumber(m_MemoryTypeIndex);

        json.WriteString("BlockSize");
        json.WriteNumber(m_PreferredBlockSize);

        json.WriteString("BlockCount");
        json.BeginObject(true);
        if(m_MinBlockCount > 0)
        {
            json.WriteString("Min");
            json.WriteNumber((uint64_t)m_MinBlockCount);
        }
        if(m_MaxBlockCount < SIZE_MAX)
        {
            json.WriteString("Max");
            json.WriteNumber((uint64_t)m_MaxBlockCount);
        }
        json.WriteString("Cur");
        json.WriteNumber((uint64_t)m_Blocks.size());
        json.EndObject();

        if(m_FrameInUseCount > 0)
        {
            json.WriteString("FrameInUseCount");
            json.WriteNumber(m_FrameInUseCount);
        }

        if(m_Algorithm != 0)
        {
            json.WriteString("Algorithm");
            json.WriteString(VmaAlgorithmToStr(m_Algorithm));
        }
    }
    else
    {
        json.WriteString("PreferredBlockSize");
        json.WriteNumber(m_PreferredBlockSize);
    }

    json.WriteString("Blocks");
    json.BeginObject();
    for(size_t i = 0; i < m_Blocks.size(); ++i)
    {
        json.BeginString();
        json.ContinueString(m_Blocks[i]->GetId());
        json.EndString();

        m_Blocks[i]->m_pMetadata->PrintDetailedMap(json);
    }
    json.EndObject();

    json.EndObject();
}

#endif // #if VMA_STATS_STRING_ENABLED

void VmaBlockVector::Defragment(
    class VmaBlockVectorDefragmentationContext* pCtx,
    VmaDefragmentationStats* pStats,
    VkDeviceSize& maxCpuBytesToMove, uint32_t& maxCpuAllocationsToMove,
    VkDeviceSize& maxGpuBytesToMove, uint32_t& maxGpuAllocationsToMove,
    VkCommandBuffer commandBuffer)
{
    pCtx->res = VK_SUCCESS;
    
    const VkMemoryPropertyFlags memPropFlags =
        m_hAllocator->m_MemProps.memoryTypes[m_MemoryTypeIndex].propertyFlags;
    const bool isHostVisible = (memPropFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0;

    const bool canDefragmentOnCpu = maxCpuBytesToMove > 0 && maxCpuAllocationsToMove > 0 &&
        isHostVisible;
    const bool canDefragmentOnGpu = maxGpuBytesToMove > 0 && maxGpuAllocationsToMove > 0 &&
        !IsCorruptionDetectionEnabled() &&
        ((1u << m_MemoryTypeIndex) & m_hAllocator->GetGpuDefragmentationMemoryTypeBits()) != 0;

    // There are options to defragment this memory type.
    if(canDefragmentOnCpu || canDefragmentOnGpu)
    {
        bool defragmentOnGpu;
        // There is only one option to defragment this memory type.
        if(canDefragmentOnGpu != canDefragmentOnCpu)
        {
            defragmentOnGpu = canDefragmentOnGpu;
        }
        // Both options are available: Heuristics to choose the best one.
        else
        {
            defragmentOnGpu = (memPropFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) != 0 ||
                m_hAllocator->IsIntegratedGpu();
        }

        bool overlappingMoveSupported = !defragmentOnGpu;

        if(m_hAllocator->m_UseMutex)
        {
            m_Mutex.LockWrite();
            pCtx->mutexLocked = true;
        }

        pCtx->Begin(overlappingMoveSupported);

        // Defragment.

        const VkDeviceSize maxBytesToMove = defragmentOnGpu ? maxGpuBytesToMove : maxCpuBytesToMove;
        const uint32_t maxAllocationsToMove = defragmentOnGpu ? maxGpuAllocationsToMove : maxCpuAllocationsToMove;
        VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> > moves = 
            VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >(VmaStlAllocator<VmaDefragmentationMove>(m_hAllocator->GetAllocationCallbacks()));
        pCtx->res = pCtx->GetAlgorithm()->Defragment(moves, maxBytesToMove, maxAllocationsToMove);

        // Accumulate statistics.
        if(pStats != VMA_NULL)
        {
            const VkDeviceSize bytesMoved = pCtx->GetAlgorithm()->GetBytesMoved();
            const uint32_t allocationsMoved = pCtx->GetAlgorithm()->GetAllocationsMoved();
            pStats->bytesMoved += bytesMoved;
            pStats->allocationsMoved += allocationsMoved;
            VMA_ASSERT(bytesMoved <= maxBytesToMove);
            VMA_ASSERT(allocationsMoved <= maxAllocationsToMove);
            if(defragmentOnGpu)
            {
                maxGpuBytesToMove -= bytesMoved;
                maxGpuAllocationsToMove -= allocationsMoved;
            }
            else
            {
                maxCpuBytesToMove -= bytesMoved;
                maxCpuAllocationsToMove -= allocationsMoved;
            }
        }
    
        if(pCtx->res >= VK_SUCCESS)
        {
            if(defragmentOnGpu)
            {
                ApplyDefragmentationMovesGpu(pCtx, moves, commandBuffer);
            }
            else
            {
                ApplyDefragmentationMovesCpu(pCtx, moves);
            }
        }
    }
}

void VmaBlockVector::DefragmentationEnd(
    class VmaBlockVectorDefragmentationContext* pCtx,
    VmaDefragmentationStats* pStats)
{
    // Destroy buffers.
    for(size_t blockIndex = pCtx->blockContexts.size(); blockIndex--; )
    {
        VmaBlockDefragmentationContext& blockCtx = pCtx->blockContexts[blockIndex];
        if(blockCtx.hBuffer)
        {
            (*m_hAllocator->GetVulkanFunctions().vkDestroyBuffer)(
                m_hAllocator->m_hDevice, blockCtx.hBuffer, m_hAllocator->GetAllocationCallbacks());
        }
    }

    if(pCtx->res >= VK_SUCCESS)
    {
        FreeEmptyBlocks(pStats);
    }

    if(pCtx->mutexLocked)
    {
        VMA_ASSERT(m_hAllocator->m_UseMutex);
        m_Mutex.UnlockWrite();
    }
}

size_t VmaBlockVector::CalcAllocationCount() const
{
    size_t result = 0;
    for(size_t i = 0; i < m_Blocks.size(); ++i)
    {
        result += m_Blocks[i]->m_pMetadata->GetAllocationCount();
    }
    return result;
}

bool VmaBlockVector::IsBufferImageGranularityConflictPossible() const
{
    if(m_BufferImageGranularity == 1)
    {
        return false;
    }
    VmaSuballocationType lastSuballocType = VMA_SUBALLOCATION_TYPE_FREE;
    for(size_t i = 0, count = m_Blocks.size(); i < count; ++i)
    {
        VmaDeviceMemoryBlock* const pBlock = m_Blocks[i];
        VMA_ASSERT(m_Algorithm == 0);
        VmaBlockMetadata_Generic* const pMetadata = (VmaBlockMetadata_Generic*)pBlock->m_pMetadata;
        if(pMetadata->IsBufferImageGranularityConflictPossible(m_BufferImageGranularity, lastSuballocType))
        {
            return true;
        }
    }
    return false;
}

void VmaBlockVector::MakePoolAllocationsLost(
    uint32_t currentFrameIndex,
    size_t* pLostAllocationCount)
{
    VmaMutexLockWrite lock(m_Mutex, m_hAllocator->m_UseMutex);
    size_t lostAllocationCount = 0;
    for(uint32_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex)
    {
        VmaDeviceMemoryBlock* const pBlock = m_Blocks[blockIndex];
        VMA_ASSERT(pBlock);
        lostAllocationCount += pBlock->m_pMetadata->MakeAllocationsLost(currentFrameIndex, m_FrameInUseCount);
    }
    if(pLostAllocationCount != VMA_NULL)
    {
        *pLostAllocationCount = lostAllocationCount;
    }
}

VkResult VmaBlockVector::CheckCorruption()
{
    if(!IsCorruptionDetectionEnabled())
    {
        return VK_ERROR_FEATURE_NOT_PRESENT;
    }

    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);
    for(uint32_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex)
    {
        VmaDeviceMemoryBlock* const pBlock = m_Blocks[blockIndex];
        VMA_ASSERT(pBlock);
        VkResult res = pBlock->CheckCorruption(m_hAllocator);
        if(res != VK_SUCCESS)
        {
            return res;
        }
    }
    return VK_SUCCESS;
}

void VmaBlockVector::AddStats(VmaStats* pStats)
{
    const uint32_t memTypeIndex = m_MemoryTypeIndex;
    const uint32_t memHeapIndex = m_hAllocator->MemoryTypeIndexToHeapIndex(memTypeIndex);

    VmaMutexLockRead lock(m_Mutex, m_hAllocator->m_UseMutex);

    for(uint32_t blockIndex = 0; blockIndex < m_Blocks.size(); ++blockIndex)
    {
        const VmaDeviceMemoryBlock* const pBlock = m_Blocks[blockIndex];
        VMA_ASSERT(pBlock);
        VMA_HEAVY_ASSERT(pBlock->Validate());
        VmaStatInfo allocationStatInfo;
        pBlock->m_pMetadata->CalcAllocationStatInfo(allocationStatInfo);
        VmaAddStatInfo(pStats->total, allocationStatInfo);
        VmaAddStatInfo(pStats->memoryType[memTypeIndex], allocationStatInfo);
        VmaAddStatInfo(pStats->memoryHeap[memHeapIndex], allocationStatInfo);
    }
}

////////////////////////////////////////////////////////////////////////////////
// VmaDefragmentationAlgorithm_Generic members definition

VmaDefragmentationAlgorithm_Generic::VmaDefragmentationAlgorithm_Generic(
    VmaAllocator hAllocator,
    VmaBlockVector* pBlockVector,
    uint32_t currentFrameIndex,
    bool overlappingMoveSupported) :
    VmaDefragmentationAlgorithm(hAllocator, pBlockVector, currentFrameIndex),
    m_AllocationCount(0),
    m_AllAllocations(false),
    m_BytesMoved(0),
    m_AllocationsMoved(0),
    m_Blocks(VmaStlAllocator<BlockInfo*>(hAllocator->GetAllocationCallbacks()))
{
    // Create block info for each block.
    const size_t blockCount = m_pBlockVector->m_Blocks.size();
    for(size_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
    {
        BlockInfo* pBlockInfo = vma_new(m_hAllocator, BlockInfo)(m_hAllocator->GetAllocationCallbacks());
        pBlockInfo->m_OriginalBlockIndex = blockIndex;
        pBlockInfo->m_pBlock = m_pBlockVector->m_Blocks[blockIndex];
        m_Blocks.push_back(pBlockInfo);
    }

    // Sort them by m_pBlock pointer value.
    VMA_SORT(m_Blocks.begin(), m_Blocks.end(), BlockPointerLess());
}

VmaDefragmentationAlgorithm_Generic::~VmaDefragmentationAlgorithm_Generic()
{
    for(size_t i = m_Blocks.size(); i--; )
    {
        vma_delete(m_hAllocator, m_Blocks[i]);
    }
}

void VmaDefragmentationAlgorithm_Generic::AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged)
{
    // Now as we are inside VmaBlockVector::m_Mutex, we can make final check if this allocation was not lost.
    if(hAlloc->GetLastUseFrameIndex() != VMA_FRAME_INDEX_LOST)
    {
        VmaDeviceMemoryBlock* pBlock = hAlloc->GetBlock();
        BlockInfoVector::iterator it = VmaBinaryFindFirstNotLess(m_Blocks.begin(), m_Blocks.end(), pBlock, BlockPointerLess());
        if(it != m_Blocks.end() && (*it)->m_pBlock == pBlock)
        {
            AllocationInfo allocInfo = AllocationInfo(hAlloc, pChanged);
            (*it)->m_Allocations.push_back(allocInfo);
        }
        else
        {
            VMA_ASSERT(0);
        }

        ++m_AllocationCount;
    }
}

VkResult VmaDefragmentationAlgorithm_Generic::DefragmentRound(
    VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
    VkDeviceSize maxBytesToMove,
    uint32_t maxAllocationsToMove)
{
    if(m_Blocks.empty())
    {
        return VK_SUCCESS;
    }

    // This is a choice based on research.
    // Option 1:
    uint32_t strategy = VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT;
    // Option 2:
    //uint32_t strategy = VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT;
    // Option 3:
    //uint32_t strategy = VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT;

    size_t srcBlockMinIndex = 0;
    // When FAST_ALGORITHM, move allocations from only last out of blocks that contain non-movable allocations.
    /*
    if(m_AlgorithmFlags & VMA_DEFRAGMENTATION_FAST_ALGORITHM_BIT)
    {
        const size_t blocksWithNonMovableCount = CalcBlocksWithNonMovableCount();
        if(blocksWithNonMovableCount > 0)
        {
            srcBlockMinIndex = blocksWithNonMovableCount - 1;
        }
    }
    */

    size_t srcBlockIndex = m_Blocks.size() - 1;
    size_t srcAllocIndex = SIZE_MAX;
    for(;;)
    {
        // 1. Find next allocation to move.
        // 1.1. Start from last to first m_Blocks - they are sorted from most "destination" to most "source".
        // 1.2. Then start from last to first m_Allocations.
        while(srcAllocIndex >= m_Blocks[srcBlockIndex]->m_Allocations.size())
        {
            if(m_Blocks[srcBlockIndex]->m_Allocations.empty())
            {
                // Finished: no more allocations to process.
                if(srcBlockIndex == srcBlockMinIndex)
                {
                    return VK_SUCCESS;
                }
                else
                {
                    --srcBlockIndex;
                    srcAllocIndex = SIZE_MAX;
                }
            }
            else
            {
                srcAllocIndex = m_Blocks[srcBlockIndex]->m_Allocations.size() - 1;
            }
        }
        
        BlockInfo* pSrcBlockInfo = m_Blocks[srcBlockIndex];
        AllocationInfo& allocInfo = pSrcBlockInfo->m_Allocations[srcAllocIndex];

        const VkDeviceSize size = allocInfo.m_hAllocation->GetSize();
        const VkDeviceSize srcOffset = allocInfo.m_hAllocation->GetOffset();
        const VkDeviceSize alignment = allocInfo.m_hAllocation->GetAlignment();
        const VmaSuballocationType suballocType = allocInfo.m_hAllocation->GetSuballocationType();

        // 2. Try to find new place for this allocation in preceding or current block.
        for(size_t dstBlockIndex = 0; dstBlockIndex <= srcBlockIndex; ++dstBlockIndex)
        {
            BlockInfo* pDstBlockInfo = m_Blocks[dstBlockIndex];
            VmaAllocationRequest dstAllocRequest;
            if(pDstBlockInfo->m_pBlock->m_pMetadata->CreateAllocationRequest(
                m_CurrentFrameIndex,
                m_pBlockVector->GetFrameInUseCount(),
                m_pBlockVector->GetBufferImageGranularity(),
                size,
                alignment,
                false, // upperAddress
                suballocType,
                false, // canMakeOtherLost
                strategy,
                &dstAllocRequest) &&
            MoveMakesSense(
                dstBlockIndex, dstAllocRequest.offset, srcBlockIndex, srcOffset))
            {
                VMA_ASSERT(dstAllocRequest.itemsToMakeLostCount == 0);

                // Reached limit on number of allocations or bytes to move.
                if((m_AllocationsMoved + 1 > maxAllocationsToMove) ||
                    (m_BytesMoved + size > maxBytesToMove))
                {
                    return VK_SUCCESS;
                }

                VmaDefragmentationMove move;
                move.srcBlockIndex = pSrcBlockInfo->m_OriginalBlockIndex;
                move.dstBlockIndex = pDstBlockInfo->m_OriginalBlockIndex;
                move.srcOffset = srcOffset;
                move.dstOffset = dstAllocRequest.offset;
                move.size = size;
                moves.push_back(move);

                pDstBlockInfo->m_pBlock->m_pMetadata->Alloc(
                    dstAllocRequest,
                    suballocType,
                    size,
                    allocInfo.m_hAllocation);
                pSrcBlockInfo->m_pBlock->m_pMetadata->FreeAtOffset(srcOffset);
                
                allocInfo.m_hAllocation->ChangeBlockAllocation(m_hAllocator, pDstBlockInfo->m_pBlock, dstAllocRequest.offset);

                if(allocInfo.m_pChanged != VMA_NULL)
                {
                    *allocInfo.m_pChanged = VK_TRUE;
                }

                ++m_AllocationsMoved;
                m_BytesMoved += size;

                VmaVectorRemove(pSrcBlockInfo->m_Allocations, srcAllocIndex);

                break;
            }
        }

        // If not processed, this allocInfo remains in pBlockInfo->m_Allocations for next round.

        if(srcAllocIndex > 0)
        {
            --srcAllocIndex;
        }
        else
        {
            if(srcBlockIndex > 0)
            {
                --srcBlockIndex;
                srcAllocIndex = SIZE_MAX;
            }
            else
            {
                return VK_SUCCESS;
            }
        }
    }
}

size_t VmaDefragmentationAlgorithm_Generic::CalcBlocksWithNonMovableCount() const
{
    size_t result = 0;
    for(size_t i = 0; i < m_Blocks.size(); ++i)
    {
        if(m_Blocks[i]->m_HasNonMovableAllocations)
        {
            ++result;
        }
    }
    return result;
}

VkResult VmaDefragmentationAlgorithm_Generic::Defragment(
    VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
    VkDeviceSize maxBytesToMove,
    uint32_t maxAllocationsToMove)
{
    if(!m_AllAllocations && m_AllocationCount == 0)
    {
        return VK_SUCCESS;
    }

    const size_t blockCount = m_Blocks.size();
    for(size_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
    {
        BlockInfo* pBlockInfo = m_Blocks[blockIndex];

        if(m_AllAllocations)
        {
            VmaBlockMetadata_Generic* pMetadata = (VmaBlockMetadata_Generic*)pBlockInfo->m_pBlock->m_pMetadata;
            for(VmaSuballocationList::const_iterator it = pMetadata->m_Suballocations.begin();
                it != pMetadata->m_Suballocations.end();
                ++it)
            {
                if(it->type != VMA_SUBALLOCATION_TYPE_FREE)
                {
                    AllocationInfo allocInfo = AllocationInfo(it->hAllocation, VMA_NULL);
                    pBlockInfo->m_Allocations.push_back(allocInfo);
                }
            }
        }

        pBlockInfo->CalcHasNonMovableAllocations();
        
        // This is a choice based on research.
        // Option 1:
        pBlockInfo->SortAllocationsByOffsetDescending();
        // Option 2:
        //pBlockInfo->SortAllocationsBySizeDescending();
    }

    // Sort m_Blocks this time by the main criterium, from most "destination" to most "source" blocks.
    VMA_SORT(m_Blocks.begin(), m_Blocks.end(), BlockInfoCompareMoveDestination());

    // This is a choice based on research.
    const uint32_t roundCount = 2;

    // Execute defragmentation rounds (the main part).
    VkResult result = VK_SUCCESS;
    for(uint32_t round = 0; (round < roundCount) && (result == VK_SUCCESS); ++round)
    {
        result = DefragmentRound(moves, maxBytesToMove, maxAllocationsToMove);
    }

    return result;
}

bool VmaDefragmentationAlgorithm_Generic::MoveMakesSense(
        size_t dstBlockIndex, VkDeviceSize dstOffset,
        size_t srcBlockIndex, VkDeviceSize srcOffset)
{
    if(dstBlockIndex < srcBlockIndex)
    {
        return true;
    }
    if(dstBlockIndex > srcBlockIndex)
    {
        return false;
    }
    if(dstOffset < srcOffset)
    {
        return true;
    }
    return false;
}

////////////////////////////////////////////////////////////////////////////////
// VmaDefragmentationAlgorithm_Fast

VmaDefragmentationAlgorithm_Fast::VmaDefragmentationAlgorithm_Fast(
    VmaAllocator hAllocator,
    VmaBlockVector* pBlockVector,
    uint32_t currentFrameIndex,
    bool overlappingMoveSupported) :
    VmaDefragmentationAlgorithm(hAllocator, pBlockVector, currentFrameIndex),
    m_OverlappingMoveSupported(overlappingMoveSupported),
    m_AllocationCount(0),
    m_AllAllocations(false),
    m_BytesMoved(0),
    m_AllocationsMoved(0),
    m_BlockInfos(VmaStlAllocator<BlockInfo>(hAllocator->GetAllocationCallbacks()))
{
    VMA_ASSERT(VMA_DEBUG_MARGIN == 0);

}

VmaDefragmentationAlgorithm_Fast::~VmaDefragmentationAlgorithm_Fast()
{
}

VkResult VmaDefragmentationAlgorithm_Fast::Defragment(
    VmaVector< VmaDefragmentationMove, VmaStlAllocator<VmaDefragmentationMove> >& moves,
    VkDeviceSize maxBytesToMove,
    uint32_t maxAllocationsToMove)
{
    VMA_ASSERT(m_AllAllocations || m_pBlockVector->CalcAllocationCount() == m_AllocationCount);

    const size_t blockCount = m_pBlockVector->GetBlockCount();
    if(blockCount == 0 || maxBytesToMove == 0 || maxAllocationsToMove == 0)
    {
        return VK_SUCCESS;
    }

    PreprocessMetadata();

    // Sort blocks in order from most destination.

    m_BlockInfos.resize(blockCount);
    for(size_t i = 0; i < blockCount; ++i)
    {
        m_BlockInfos[i].origBlockIndex = i;
    }

    VMA_SORT(m_BlockInfos.begin(), m_BlockInfos.end(), [this](const BlockInfo& lhs, const BlockInfo& rhs) -> bool {
        return m_pBlockVector->GetBlock(lhs.origBlockIndex)->m_pMetadata->GetSumFreeSize() <
            m_pBlockVector->GetBlock(rhs.origBlockIndex)->m_pMetadata->GetSumFreeSize();
    });

    // THE MAIN ALGORITHM

    FreeSpaceDatabase freeSpaceDb;

    size_t dstBlockInfoIndex = 0;
    size_t dstOrigBlockIndex = m_BlockInfos[dstBlockInfoIndex].origBlockIndex;
    VmaDeviceMemoryBlock* pDstBlock = m_pBlockVector->GetBlock(dstOrigBlockIndex);
    VmaBlockMetadata_Generic* pDstMetadata = (VmaBlockMetadata_Generic*)pDstBlock->m_pMetadata;
    VkDeviceSize dstBlockSize = pDstMetadata->GetSize();
    VkDeviceSize dstOffset = 0;

    bool end = false;
    for(size_t srcBlockInfoIndex = 0; !end && srcBlockInfoIndex < blockCount; ++srcBlockInfoIndex)
    {
        const size_t srcOrigBlockIndex = m_BlockInfos[srcBlockInfoIndex].origBlockIndex;
        VmaDeviceMemoryBlock* const pSrcBlock = m_pBlockVector->GetBlock(srcOrigBlockIndex);
        VmaBlockMetadata_Generic* const pSrcMetadata = (VmaBlockMetadata_Generic*)pSrcBlock->m_pMetadata;
        for(VmaSuballocationList::iterator srcSuballocIt = pSrcMetadata->m_Suballocations.begin();
            !end && srcSuballocIt != pSrcMetadata->m_Suballocations.end(); )
        {
            VmaAllocation_T* const pAlloc = srcSuballocIt->hAllocation;
            const VkDeviceSize srcAllocAlignment = pAlloc->GetAlignment();
            const VkDeviceSize srcAllocSize = srcSuballocIt->size;
            if(m_AllocationsMoved == maxAllocationsToMove ||
                m_BytesMoved + srcAllocSize > maxBytesToMove)
            {
                end = true;
                break;
            }
            const VkDeviceSize srcAllocOffset = srcSuballocIt->offset;

            // Try to place it in one of free spaces from the database.
            size_t freeSpaceInfoIndex;
            VkDeviceSize dstAllocOffset;
            if(freeSpaceDb.Fetch(srcAllocAlignment, srcAllocSize,
                freeSpaceInfoIndex, dstAllocOffset))
            {
                size_t freeSpaceOrigBlockIndex = m_BlockInfos[freeSpaceInfoIndex].origBlockIndex;
                VmaDeviceMemoryBlock* pFreeSpaceBlock = m_pBlockVector->GetBlock(freeSpaceOrigBlockIndex);
                VmaBlockMetadata_Generic* pFreeSpaceMetadata = (VmaBlockMetadata_Generic*)pFreeSpaceBlock->m_pMetadata;

                // Same block
                if(freeSpaceInfoIndex == srcBlockInfoIndex)
                {
                    VMA_ASSERT(dstAllocOffset <= srcAllocOffset);

                    // MOVE OPTION 1: Move the allocation inside the same block by decreasing offset.

                    VmaSuballocation suballoc = *srcSuballocIt;
                    suballoc.offset = dstAllocOffset;
                    suballoc.hAllocation->ChangeOffset(dstAllocOffset);
                    m_BytesMoved += srcAllocSize;
                    ++m_AllocationsMoved;
                    
                    VmaSuballocationList::iterator nextSuballocIt = srcSuballocIt;
                    ++nextSuballocIt;
                    pSrcMetadata->m_Suballocations.erase(srcSuballocIt);
                    srcSuballocIt = nextSuballocIt;

                    InsertSuballoc(pFreeSpaceMetadata, suballoc);

                    VmaDefragmentationMove move = {
                        srcOrigBlockIndex, freeSpaceOrigBlockIndex,
                        srcAllocOffset, dstAllocOffset,
                        srcAllocSize };
                    moves.push_back(move);
                }
                // Different block
                else
                {
                    // MOVE OPTION 2: Move the allocation to a different block.

                    VMA_ASSERT(freeSpaceInfoIndex < srcBlockInfoIndex);

                    VmaSuballocation suballoc = *srcSuballocIt;
                    suballoc.offset = dstAllocOffset;
                    suballoc.hAllocation->ChangeBlockAllocation(m_hAllocator, pFreeSpaceBlock, dstAllocOffset);
                    m_BytesMoved += srcAllocSize;
                    ++m_AllocationsMoved;

                    VmaSuballocationList::iterator nextSuballocIt = srcSuballocIt;
                    ++nextSuballocIt;
                    pSrcMetadata->m_Suballocations.erase(srcSuballocIt);
                    srcSuballocIt = nextSuballocIt;

                    InsertSuballoc(pFreeSpaceMetadata, suballoc);

                    VmaDefragmentationMove move = {
                        srcOrigBlockIndex, freeSpaceOrigBlockIndex,
                        srcAllocOffset, dstAllocOffset,
                        srcAllocSize };
                    moves.push_back(move);
                }
            }
            else
            {
                dstAllocOffset = VmaAlignUp(dstOffset, srcAllocAlignment);

                // If the allocation doesn't fit before the end of dstBlock, forward to next block.
                while(dstBlockInfoIndex < srcBlockInfoIndex &&
                    dstAllocOffset + srcAllocSize > dstBlockSize)
                {
                    // But before that, register remaining free space at the end of dst block.
                    freeSpaceDb.Register(dstBlockInfoIndex, dstOffset, dstBlockSize - dstOffset);

                    ++dstBlockInfoIndex;
                    dstOrigBlockIndex = m_BlockInfos[dstBlockInfoIndex].origBlockIndex;
                    pDstBlock = m_pBlockVector->GetBlock(dstOrigBlockIndex);
                    pDstMetadata = (VmaBlockMetadata_Generic*)pDstBlock->m_pMetadata;
                    dstBlockSize = pDstMetadata->GetSize();
                    dstOffset = 0;
                    dstAllocOffset = 0;
                }

                // Same block
                if(dstBlockInfoIndex == srcBlockInfoIndex)
                {
                    VMA_ASSERT(dstAllocOffset <= srcAllocOffset);

                    const bool overlap = dstAllocOffset + srcAllocSize > srcAllocOffset;

                    bool skipOver = overlap;
                    if(overlap && m_OverlappingMoveSupported && dstAllocOffset < srcAllocOffset)
                    {
                        // If destination and source place overlap, skip if it would move it
                        // by only < 1/64 of its size.
                        skipOver = (srcAllocOffset - dstAllocOffset) * 64 < srcAllocSize;
                    }

                    if(skipOver)
                    {
                        freeSpaceDb.Register(dstBlockInfoIndex, dstOffset, srcAllocOffset - dstOffset);

                        dstOffset = srcAllocOffset + srcAllocSize;
                        ++srcSuballocIt;
                    }
                    // MOVE OPTION 1: Move the allocation inside the same block by decreasing offset.
                    else
                    {
                        srcSuballocIt->offset = dstAllocOffset;
                        srcSuballocIt->hAllocation->ChangeOffset(dstAllocOffset);
                        dstOffset = dstAllocOffset + srcAllocSize;
                        m_BytesMoved += srcAllocSize;
                        ++m_AllocationsMoved;
                        ++srcSuballocIt;
                        VmaDefragmentationMove move = {
                            srcOrigBlockIndex, dstOrigBlockIndex,
                            srcAllocOffset, dstAllocOffset,
                            srcAllocSize };
                        moves.push_back(move);
                    }
                }
                // Different block
                else
                {
                    // MOVE OPTION 2: Move the allocation to a different block.

                    VMA_ASSERT(dstBlockInfoIndex < srcBlockInfoIndex);
                    VMA_ASSERT(dstAllocOffset + srcAllocSize <= dstBlockSize);

                    VmaSuballocation suballoc = *srcSuballocIt;
                    suballoc.offset = dstAllocOffset;
                    suballoc.hAllocation->ChangeBlockAllocation(m_hAllocator, pDstBlock, dstAllocOffset);
                    dstOffset = dstAllocOffset + srcAllocSize;
                    m_BytesMoved += srcAllocSize;
                    ++m_AllocationsMoved;

                    VmaSuballocationList::iterator nextSuballocIt = srcSuballocIt;
                    ++nextSuballocIt;
                    pSrcMetadata->m_Suballocations.erase(srcSuballocIt);
                    srcSuballocIt = nextSuballocIt;

                    pDstMetadata->m_Suballocations.push_back(suballoc);

                    VmaDefragmentationMove move = {
                        srcOrigBlockIndex, dstOrigBlockIndex,
                        srcAllocOffset, dstAllocOffset,
                        srcAllocSize };
                    moves.push_back(move);
                }
            }
        }
    }

    m_BlockInfos.clear();
    
    PostprocessMetadata();

    return VK_SUCCESS;
}

void VmaDefragmentationAlgorithm_Fast::PreprocessMetadata()
{
    const size_t blockCount = m_pBlockVector->GetBlockCount();
    for(size_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
    {
        VmaBlockMetadata_Generic* const pMetadata =
            (VmaBlockMetadata_Generic*)m_pBlockVector->GetBlock(blockIndex)->m_pMetadata;
        pMetadata->m_FreeCount = 0;
        pMetadata->m_SumFreeSize = pMetadata->GetSize();
        pMetadata->m_FreeSuballocationsBySize.clear();
        for(VmaSuballocationList::iterator it = pMetadata->m_Suballocations.begin();
            it != pMetadata->m_Suballocations.end(); )
        {
            if(it->type == VMA_SUBALLOCATION_TYPE_FREE)
            {
                VmaSuballocationList::iterator nextIt = it;
                ++nextIt;
                pMetadata->m_Suballocations.erase(it);
                it = nextIt;
            }
            else
            {
                ++it;
            }
        }
    }
}

void VmaDefragmentationAlgorithm_Fast::PostprocessMetadata()
{
    const size_t blockCount = m_pBlockVector->GetBlockCount();
    for(size_t blockIndex = 0; blockIndex < blockCount; ++blockIndex)
    {
        VmaBlockMetadata_Generic* const pMetadata =
            (VmaBlockMetadata_Generic*)m_pBlockVector->GetBlock(blockIndex)->m_pMetadata;
        const VkDeviceSize blockSize = pMetadata->GetSize();
        
        // No allocations in this block - entire area is free.
        if(pMetadata->m_Suballocations.empty())
        {
            pMetadata->m_FreeCount = 1;
            //pMetadata->m_SumFreeSize is already set to blockSize.
            VmaSuballocation suballoc = {
                0, // offset
                blockSize, // size
                VMA_NULL, // hAllocation
                VMA_SUBALLOCATION_TYPE_FREE };
            pMetadata->m_Suballocations.push_back(suballoc);
            pMetadata->RegisterFreeSuballocation(pMetadata->m_Suballocations.begin());
        }
        // There are some allocations in this block.
        else
        {
            VkDeviceSize offset = 0;
            VmaSuballocationList::iterator it;
            for(it = pMetadata->m_Suballocations.begin();
                it != pMetadata->m_Suballocations.end();
                ++it)
            {
                VMA_ASSERT(it->type != VMA_SUBALLOCATION_TYPE_FREE);
                VMA_ASSERT(it->offset >= offset);

                // Need to insert preceding free space.
                if(it->offset > offset)
                {
                    ++pMetadata->m_FreeCount;
                    const VkDeviceSize freeSize = it->offset - offset;
                    VmaSuballocation suballoc = {
                        offset, // offset
                        freeSize, // size
                        VMA_NULL, // hAllocation
                        VMA_SUBALLOCATION_TYPE_FREE };
                    VmaSuballocationList::iterator precedingFreeIt = pMetadata->m_Suballocations.insert(it, suballoc);
                    if(freeSize >= VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
                    {
                        pMetadata->m_FreeSuballocationsBySize.push_back(precedingFreeIt);
                    }
                }

                pMetadata->m_SumFreeSize -= it->size;
                offset = it->offset + it->size;
            }

            // Need to insert trailing free space.
            if(offset < blockSize)
            {
                ++pMetadata->m_FreeCount;
                const VkDeviceSize freeSize = blockSize - offset;
                VmaSuballocation suballoc = {
                    offset, // offset
                    freeSize, // size
                    VMA_NULL, // hAllocation
                    VMA_SUBALLOCATION_TYPE_FREE };
                VMA_ASSERT(it == pMetadata->m_Suballocations.end());
                VmaSuballocationList::iterator trailingFreeIt = pMetadata->m_Suballocations.insert(it, suballoc);
                if(freeSize > VMA_MIN_FREE_SUBALLOCATION_SIZE_TO_REGISTER)
                {
                    pMetadata->m_FreeSuballocationsBySize.push_back(trailingFreeIt);
                }
            }

            VMA_SORT(
                pMetadata->m_FreeSuballocationsBySize.begin(),
                pMetadata->m_FreeSuballocationsBySize.end(),
                VmaSuballocationItemSizeLess());
        }

        VMA_HEAVY_ASSERT(pMetadata->Validate());
    }
}

void VmaDefragmentationAlgorithm_Fast::InsertSuballoc(VmaBlockMetadata_Generic* pMetadata, const VmaSuballocation& suballoc)
{
    // TODO: Optimize somehow. Remember iterator instead of searching for it linearly.
    VmaSuballocationList::iterator it = pMetadata->m_Suballocations.begin();
    while(it != pMetadata->m_Suballocations.end())
    {
        if(it->offset < suballoc.offset)
        {
            ++it;
        }
    }
    pMetadata->m_Suballocations.insert(it, suballoc);
}

////////////////////////////////////////////////////////////////////////////////
// VmaBlockVectorDefragmentationContext

VmaBlockVectorDefragmentationContext::VmaBlockVectorDefragmentationContext(
    VmaAllocator hAllocator,
    VmaPool hCustomPool,
    VmaBlockVector* pBlockVector,
    uint32_t currFrameIndex) :
    res(VK_SUCCESS),
    mutexLocked(false),
    blockContexts(VmaStlAllocator<VmaBlockDefragmentationContext>(hAllocator->GetAllocationCallbacks())),
    m_hAllocator(hAllocator),
    m_hCustomPool(hCustomPool),
    m_pBlockVector(pBlockVector),
    m_CurrFrameIndex(currFrameIndex),
    m_pAlgorithm(VMA_NULL),
    m_Allocations(VmaStlAllocator<AllocInfo>(hAllocator->GetAllocationCallbacks())),
    m_AllAllocations(false)
{
}

VmaBlockVectorDefragmentationContext::~VmaBlockVectorDefragmentationContext()
{
    vma_delete(m_hAllocator, m_pAlgorithm);
}

void VmaBlockVectorDefragmentationContext::AddAllocation(VmaAllocation hAlloc, VkBool32* pChanged)
{
    AllocInfo info = { hAlloc, pChanged };
    m_Allocations.push_back(info);
}

void VmaBlockVectorDefragmentationContext::Begin(bool overlappingMoveSupported)
{
    const bool allAllocations = m_AllAllocations ||
        m_Allocations.size() == m_pBlockVector->CalcAllocationCount();

    /********************************
    HERE IS THE CHOICE OF DEFRAGMENTATION ALGORITHM.
    ********************************/

    /*
    Fast algorithm is supported only when certain criteria are met:
    - VMA_DEBUG_MARGIN is 0.
    - All allocations in this block vector are moveable.
    - There is no possibility of image/buffer granularity conflict.
    */
    if(VMA_DEBUG_MARGIN == 0 &&
        allAllocations &&
        !m_pBlockVector->IsBufferImageGranularityConflictPossible())
    {
        m_pAlgorithm = vma_new(m_hAllocator, VmaDefragmentationAlgorithm_Fast)(
            m_hAllocator, m_pBlockVector, m_CurrFrameIndex, overlappingMoveSupported);
    }
    else
    {
        m_pAlgorithm = vma_new(m_hAllocator, VmaDefragmentationAlgorithm_Generic)(
            m_hAllocator, m_pBlockVector, m_CurrFrameIndex, overlappingMoveSupported);
    }

    if(allAllocations)
    {
        m_pAlgorithm->AddAll();
    }
    else
    {
        for(size_t i = 0, count = m_Allocations.size(); i < count; ++i)
        {
            m_pAlgorithm->AddAllocation(m_Allocations[i].hAlloc, m_Allocations[i].pChanged);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
// VmaDefragmentationContext

VmaDefragmentationContext_T::VmaDefragmentationContext_T(
    VmaAllocator hAllocator,
    uint32_t currFrameIndex,
    uint32_t flags,
    VmaDefragmentationStats* pStats) :
    m_hAllocator(hAllocator),
    m_CurrFrameIndex(currFrameIndex),
    m_Flags(flags),
    m_pStats(pStats),
    m_CustomPoolContexts(VmaStlAllocator<VmaBlockVectorDefragmentationContext*>(hAllocator->GetAllocationCallbacks()))
{
    memset(m_DefaultPoolContexts, 0, sizeof(m_DefaultPoolContexts));
}

VmaDefragmentationContext_T::~VmaDefragmentationContext_T()
{
    for(size_t i = m_CustomPoolContexts.size(); i--; )
    {
        VmaBlockVectorDefragmentationContext* pBlockVectorCtx = m_CustomPoolContexts[i];
        pBlockVectorCtx->GetBlockVector()->DefragmentationEnd(pBlockVectorCtx, m_pStats);
        vma_delete(m_hAllocator, pBlockVectorCtx);
    }
    for(size_t i = m_hAllocator->m_MemProps.memoryTypeCount; i--; )
    {
        VmaBlockVectorDefragmentationContext* pBlockVectorCtx = m_DefaultPoolContexts[i];
        if(pBlockVectorCtx)
        {
            pBlockVectorCtx->GetBlockVector()->DefragmentationEnd(pBlockVectorCtx, m_pStats);
            vma_delete(m_hAllocator, pBlockVectorCtx);
        }
    }
}

void VmaDefragmentationContext_T::AddPools(uint32_t poolCount, VmaPool* pPools)
{
    for(uint32_t poolIndex = 0; poolIndex < poolCount; ++poolIndex)
    {
        VmaPool pool = pPools[poolIndex];
        VMA_ASSERT(pool);
        // Pools with algorithm other than default are not defragmented.
        if(pool->m_BlockVector.GetAlgorithm() == 0)
        {
            VmaBlockVectorDefragmentationContext* pBlockVectorDefragCtx = VMA_NULL;
            
            for(size_t i = m_CustomPoolContexts.size(); i--; )
            {
                if(m_CustomPoolContexts[i]->GetCustomPool() == pool)
                {
                    pBlockVectorDefragCtx = m_CustomPoolContexts[i];
                    break;
                }
            }
            
            if(!pBlockVectorDefragCtx)
            {
                pBlockVectorDefragCtx = vma_new(m_hAllocator, VmaBlockVectorDefragmentationContext)(
                    m_hAllocator,
                    pool,
                    &pool->m_BlockVector,
                    m_CurrFrameIndex);
                m_CustomPoolContexts.push_back(pBlockVectorDefragCtx);
            }

            pBlockVectorDefragCtx->AddAll();
        }
    }
}

void VmaDefragmentationContext_T::AddAllocations(
    uint32_t allocationCount,
    VmaAllocation* pAllocations,
    VkBool32* pAllocationsChanged)
{
    // Dispatch pAllocations among defragmentators. Create them when necessary.
    for(uint32_t allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
    {
        const VmaAllocation hAlloc = pAllocations[allocIndex];
        VMA_ASSERT(hAlloc);
        // DedicatedAlloc cannot be defragmented.
        if((hAlloc->GetType() == VmaAllocation_T::ALLOCATION_TYPE_BLOCK) &&
            // Lost allocation cannot be defragmented.
            (hAlloc->GetLastUseFrameIndex() != VMA_FRAME_INDEX_LOST))
        {
            VmaBlockVectorDefragmentationContext* pBlockVectorDefragCtx = VMA_NULL;

            const VmaPool hAllocPool = hAlloc->GetBlock()->GetParentPool();
            // This allocation belongs to custom pool.
            if(hAllocPool != VK_NULL_HANDLE)
            {
                // Pools with algorithm other than default are not defragmented.
                if(hAllocPool->m_BlockVector.GetAlgorithm() == 0)
                {
                    for(size_t i = m_CustomPoolContexts.size(); i--; )
                    {
                        if(m_CustomPoolContexts[i]->GetCustomPool() == hAllocPool)
                        {
                            pBlockVectorDefragCtx = m_CustomPoolContexts[i];
                            break;
                        }
                    }
                    if(!pBlockVectorDefragCtx)
                    {
                        pBlockVectorDefragCtx = vma_new(m_hAllocator, VmaBlockVectorDefragmentationContext)(
                            m_hAllocator,
                            hAllocPool,
                            &hAllocPool->m_BlockVector,
                            m_CurrFrameIndex);
                        m_CustomPoolContexts.push_back(pBlockVectorDefragCtx);
                    }
                }
            }
            // This allocation belongs to default pool.
            else
            {
                const uint32_t memTypeIndex = hAlloc->GetMemoryTypeIndex();
                pBlockVectorDefragCtx = m_DefaultPoolContexts[memTypeIndex];
                if(!pBlockVectorDefragCtx)
                {
                    pBlockVectorDefragCtx = vma_new(m_hAllocator, VmaBlockVectorDefragmentationContext)(
                        m_hAllocator,
                        VMA_NULL, // hCustomPool
                        m_hAllocator->m_pBlockVectors[memTypeIndex],
                        m_CurrFrameIndex);
                    m_DefaultPoolContexts[memTypeIndex] = pBlockVectorDefragCtx;
                }
            }

            if(pBlockVectorDefragCtx)
            {
                VkBool32* const pChanged = (pAllocationsChanged != VMA_NULL) ?
                    &pAllocationsChanged[allocIndex] : VMA_NULL;
                pBlockVectorDefragCtx->AddAllocation(hAlloc, pChanged);
            }
        }
    }
}

VkResult VmaDefragmentationContext_T::Defragment(
    VkDeviceSize maxCpuBytesToMove, uint32_t maxCpuAllocationsToMove,
    VkDeviceSize maxGpuBytesToMove, uint32_t maxGpuAllocationsToMove,
    VkCommandBuffer commandBuffer, VmaDefragmentationStats* pStats)
{
    if(pStats)
    {
        memset(pStats, 0, sizeof(VmaDefragmentationStats));
    }

    if(commandBuffer == VK_NULL_HANDLE)
    {
        maxGpuBytesToMove = 0;
        maxGpuAllocationsToMove = 0;
    }

    VkResult res = VK_SUCCESS;

    // Process default pools.
    for(uint32_t memTypeIndex = 0;
        memTypeIndex < m_hAllocator->GetMemoryTypeCount() && res >= VK_SUCCESS;
        ++memTypeIndex)
    {
        VmaBlockVectorDefragmentationContext* pBlockVectorCtx = m_DefaultPoolContexts[memTypeIndex];
        if(pBlockVectorCtx)
        {
            VMA_ASSERT(pBlockVectorCtx->GetBlockVector());
            pBlockVectorCtx->GetBlockVector()->Defragment(
                pBlockVectorCtx,
                pStats,
                maxCpuBytesToMove, maxCpuAllocationsToMove,
                maxGpuBytesToMove, maxGpuAllocationsToMove,
                commandBuffer);
            if(pBlockVectorCtx->res != VK_SUCCESS)
            {
                res = pBlockVectorCtx->res;
            }
        }
    }

    // Process custom pools.
    for(size_t customCtxIndex = 0, customCtxCount = m_CustomPoolContexts.size();
        customCtxIndex < customCtxCount && res >= VK_SUCCESS;
        ++customCtxIndex)
    {
        VmaBlockVectorDefragmentationContext* pBlockVectorCtx = m_CustomPoolContexts[customCtxIndex];
        VMA_ASSERT(pBlockVectorCtx && pBlockVectorCtx->GetBlockVector());
        pBlockVectorCtx->GetBlockVector()->Defragment(
            pBlockVectorCtx,
            pStats,
            maxCpuBytesToMove, maxCpuAllocationsToMove,
            maxGpuBytesToMove, maxGpuAllocationsToMove,
            commandBuffer);
        if(pBlockVectorCtx->res != VK_SUCCESS)
        {
            res = pBlockVectorCtx->res;
        }
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
// VmaRecorder

#if VMA_RECORDING_ENABLED

VmaRecorder::VmaRecorder() :
    m_UseMutex(true),
    m_Flags(0),
    m_File(VMA_NULL),
    m_Freq(INT64_MAX),
    m_StartCounter(INT64_MAX)
{
}

VkResult VmaRecorder::Init(const VmaRecordSettings& settings, bool useMutex)
{
    m_UseMutex = useMutex;
    m_Flags = settings.flags;

    QueryPerformanceFrequency((LARGE_INTEGER*)&m_Freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&m_StartCounter);

    // Open file for writing.
    errno_t err = fopen_s(&m_File, settings.pFilePath, "wb");
    if(err != 0)
    {
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    // Write header.
    fprintf(m_File, "%s\n", "Vulkan Memory Allocator,Calls recording");
    fprintf(m_File, "%s\n", "1,8");

    return VK_SUCCESS;
}

VmaRecorder::~VmaRecorder()
{
    if(m_File != VMA_NULL)
    {
        fclose(m_File);
    }
}

void VmaRecorder::RecordCreateAllocator(uint32_t frameIndex)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaCreateAllocator\n", callParams.threadId, callParams.time, frameIndex);
    Flush();
}

void VmaRecorder::RecordDestroyAllocator(uint32_t frameIndex)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaDestroyAllocator\n", callParams.threadId, callParams.time, frameIndex);
    Flush();
}

void VmaRecorder::RecordCreatePool(uint32_t frameIndex, const VmaPoolCreateInfo& createInfo, VmaPool pool)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaCreatePool,%u,%u,%llu,%llu,%llu,%u,%p\n", callParams.threadId, callParams.time, frameIndex,
        createInfo.memoryTypeIndex,
        createInfo.flags,
        createInfo.blockSize,
        (uint64_t)createInfo.minBlockCount,
        (uint64_t)createInfo.maxBlockCount,
        createInfo.frameInUseCount,
        pool);
    Flush();
}

void VmaRecorder::RecordDestroyPool(uint32_t frameIndex, VmaPool pool)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaDestroyPool,%p\n", callParams.threadId, callParams.time, frameIndex,
        pool);
    Flush();
}

void VmaRecorder::RecordAllocateMemory(uint32_t frameIndex,
        const VkMemoryRequirements& vkMemReq,
        const VmaAllocationCreateInfo& createInfo,
        VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    UserDataString userDataStr(createInfo.flags, createInfo.pUserData);
    fprintf(m_File, "%u,%.3f,%u,vmaAllocateMemory,%llu,%llu,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
        vkMemReq.size,
        vkMemReq.alignment,
        vkMemReq.memoryTypeBits,
        createInfo.flags,
        createInfo.usage,
        createInfo.requiredFlags,
        createInfo.preferredFlags,
        createInfo.memoryTypeBits,
        createInfo.pool,
        allocation,
        userDataStr.GetString());
    Flush();
}

void VmaRecorder::RecordAllocateMemoryPages(uint32_t frameIndex,
    const VkMemoryRequirements& vkMemReq,
    const VmaAllocationCreateInfo& createInfo,
    uint64_t allocationCount,
    const VmaAllocation* pAllocations)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    UserDataString userDataStr(createInfo.flags, createInfo.pUserData);
    fprintf(m_File, "%u,%.3f,%u,vmaAllocateMemoryPages,%llu,%llu,%u,%u,%u,%u,%u,%u,%p,", callParams.threadId, callParams.time, frameIndex,
        vkMemReq.size,
        vkMemReq.alignment,
        vkMemReq.memoryTypeBits,
        createInfo.flags,
        createInfo.usage,
        createInfo.requiredFlags,
        createInfo.preferredFlags,
        createInfo.memoryTypeBits,
        createInfo.pool);
    PrintPointerList(allocationCount, pAllocations);
    fprintf(m_File, ",%s\n", userDataStr.GetString());
    Flush();
}

void VmaRecorder::RecordAllocateMemoryForBuffer(uint32_t frameIndex,
    const VkMemoryRequirements& vkMemReq,
    bool requiresDedicatedAllocation,
    bool prefersDedicatedAllocation,
    const VmaAllocationCreateInfo& createInfo,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    UserDataString userDataStr(createInfo.flags, createInfo.pUserData);
    fprintf(m_File, "%u,%.3f,%u,vmaAllocateMemoryForBuffer,%llu,%llu,%u,%u,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
        vkMemReq.size,
        vkMemReq.alignment,
        vkMemReq.memoryTypeBits,
        requiresDedicatedAllocation ? 1 : 0,
        prefersDedicatedAllocation ? 1 : 0,
        createInfo.flags,
        createInfo.usage,
        createInfo.requiredFlags,
        createInfo.preferredFlags,
        createInfo.memoryTypeBits,
        createInfo.pool,
        allocation,
        userDataStr.GetString());
    Flush();
}

void VmaRecorder::RecordAllocateMemoryForImage(uint32_t frameIndex,
    const VkMemoryRequirements& vkMemReq,
    bool requiresDedicatedAllocation,
    bool prefersDedicatedAllocation,
    const VmaAllocationCreateInfo& createInfo,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    UserDataString userDataStr(createInfo.flags, createInfo.pUserData);
    fprintf(m_File, "%u,%.3f,%u,vmaAllocateMemoryForImage,%llu,%llu,%u,%u,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
        vkMemReq.size,
        vkMemReq.alignment,
        vkMemReq.memoryTypeBits,
        requiresDedicatedAllocation ? 1 : 0,
        prefersDedicatedAllocation ? 1 : 0,
        createInfo.flags,
        createInfo.usage,
        createInfo.requiredFlags,
        createInfo.preferredFlags,
        createInfo.memoryTypeBits,
        createInfo.pool,
        allocation,
        userDataStr.GetString());
    Flush();
}

void VmaRecorder::RecordFreeMemory(uint32_t frameIndex,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaFreeMemory,%p\n", callParams.threadId, callParams.time, frameIndex,
        allocation);
    Flush();
}

void VmaRecorder::RecordFreeMemoryPages(uint32_t frameIndex,
    uint64_t allocationCount,
    const VmaAllocation* pAllocations)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaFreeMemoryPages,", callParams.threadId, callParams.time, frameIndex);
    PrintPointerList(allocationCount, pAllocations);
    fprintf(m_File, "\n");
    Flush();
}

void VmaRecorder::RecordSetAllocationUserData(uint32_t frameIndex,
    VmaAllocation allocation,
    const void* pUserData)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    UserDataString userDataStr(
        allocation->IsUserDataString() ? VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT : 0,
        pUserData);
    fprintf(m_File, "%u,%.3f,%u,vmaSetAllocationUserData,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
        allocation,
        userDataStr.GetString());
    Flush();
}

void VmaRecorder::RecordCreateLostAllocation(uint32_t frameIndex,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaCreateLostAllocation,%p\n", callParams.threadId, callParams.time, frameIndex,
        allocation);
    Flush();
}

void VmaRecorder::RecordMapMemory(uint32_t frameIndex,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaMapMemory,%p\n", callParams.threadId, callParams.time, frameIndex,
        allocation);
    Flush();
}

void VmaRecorder::RecordUnmapMemory(uint32_t frameIndex,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaUnmapMemory,%p\n", callParams.threadId, callParams.time, frameIndex,
        allocation);
    Flush();
}

void VmaRecorder::RecordFlushAllocation(uint32_t frameIndex,
    VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaFlushAllocation,%p,%llu,%llu\n", callParams.threadId, callParams.time, frameIndex,
        allocation,
        offset,
        size);
    Flush();
}

void VmaRecorder::RecordInvalidateAllocation(uint32_t frameIndex,
    VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaInvalidateAllocation,%p,%llu,%llu\n", callParams.threadId, callParams.time, frameIndex,
        allocation,
        offset,
        size);
    Flush();
}

void VmaRecorder::RecordCreateBuffer(uint32_t frameIndex,
    const VkBufferCreateInfo& bufCreateInfo,
    const VmaAllocationCreateInfo& allocCreateInfo,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    UserDataString userDataStr(allocCreateInfo.flags, allocCreateInfo.pUserData);
    fprintf(m_File, "%u,%.3f,%u,vmaCreateBuffer,%u,%llu,%u,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
        bufCreateInfo.flags,
        bufCreateInfo.size,
        bufCreateInfo.usage,
        bufCreateInfo.sharingMode,
        allocCreateInfo.flags,
        allocCreateInfo.usage,
        allocCreateInfo.requiredFlags,
        allocCreateInfo.preferredFlags,
        allocCreateInfo.memoryTypeBits,
        allocCreateInfo.pool,
        allocation,
        userDataStr.GetString());
    Flush();
}

void VmaRecorder::RecordCreateImage(uint32_t frameIndex,
    const VkImageCreateInfo& imageCreateInfo,
    const VmaAllocationCreateInfo& allocCreateInfo,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    UserDataString userDataStr(allocCreateInfo.flags, allocCreateInfo.pUserData);
    fprintf(m_File, "%u,%.3f,%u,vmaCreateImage,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%p,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
        imageCreateInfo.flags,
        imageCreateInfo.imageType,
        imageCreateInfo.format,
        imageCreateInfo.extent.width,
        imageCreateInfo.extent.height,
        imageCreateInfo.extent.depth,
        imageCreateInfo.mipLevels,
        imageCreateInfo.arrayLayers,
        imageCreateInfo.samples,
        imageCreateInfo.tiling,
        imageCreateInfo.usage,
        imageCreateInfo.sharingMode,
        imageCreateInfo.initialLayout,
        allocCreateInfo.flags,
        allocCreateInfo.usage,
        allocCreateInfo.requiredFlags,
        allocCreateInfo.preferredFlags,
        allocCreateInfo.memoryTypeBits,
        allocCreateInfo.pool,
        allocation,
        userDataStr.GetString());
    Flush();
}

void VmaRecorder::RecordDestroyBuffer(uint32_t frameIndex,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaDestroyBuffer,%p\n", callParams.threadId, callParams.time, frameIndex,
        allocation);
    Flush();
}

void VmaRecorder::RecordDestroyImage(uint32_t frameIndex,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaDestroyImage,%p\n", callParams.threadId, callParams.time, frameIndex,
        allocation);
    Flush();
}

void VmaRecorder::RecordTouchAllocation(uint32_t frameIndex,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaTouchAllocation,%p\n", callParams.threadId, callParams.time, frameIndex,
        allocation);
    Flush();
}

void VmaRecorder::RecordGetAllocationInfo(uint32_t frameIndex,
    VmaAllocation allocation)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaGetAllocationInfo,%p\n", callParams.threadId, callParams.time, frameIndex,
        allocation);
    Flush();
}

void VmaRecorder::RecordMakePoolAllocationsLost(uint32_t frameIndex,
    VmaPool pool)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaMakePoolAllocationsLost,%p\n", callParams.threadId, callParams.time, frameIndex,
        pool);
    Flush();
}

void VmaRecorder::RecordDefragmentationBegin(uint32_t frameIndex,
    const VmaDefragmentationInfo2& info,
    VmaDefragmentationContext ctx)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaDefragmentationBegin,%u,", callParams.threadId, callParams.time, frameIndex,
        info.flags);
    PrintPointerList(info.allocationCount, info.pAllocations);
    fprintf(m_File, ",");
    PrintPointerList(info.poolCount, info.pPools);
    fprintf(m_File, ",%llu,%u,%llu,%u,%p,%p\n",
        info.maxCpuBytesToMove,
        info.maxCpuAllocationsToMove,
        info.maxGpuBytesToMove,
        info.maxGpuAllocationsToMove,
        info.commandBuffer,
        ctx);
    Flush();
}

void VmaRecorder::RecordDefragmentationEnd(uint32_t frameIndex,
    VmaDefragmentationContext ctx)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaDefragmentationEnd,%p\n", callParams.threadId, callParams.time, frameIndex,
        ctx);
    Flush();
}

void VmaRecorder::RecordSetPoolName(uint32_t frameIndex,
    VmaPool pool,
    const char* name)
{
    CallParams callParams;
    GetBasicParams(callParams);

    VmaMutexLock lock(m_FileMutex, m_UseMutex);
    fprintf(m_File, "%u,%.3f,%u,vmaSetPoolName,%p,%s\n", callParams.threadId, callParams.time, frameIndex,
        pool, name != VMA_NULL ? name : "");
    Flush();
}

VmaRecorder::UserDataString::UserDataString(VmaAllocationCreateFlags allocFlags, const void* pUserData)
{
    if(pUserData != VMA_NULL)
    {
        if((allocFlags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0)
        {
            m_Str = (const char*)pUserData;
        }
        else
        {
            sprintf_s(m_PtrStr, "%p", pUserData);
            m_Str = m_PtrStr;
        }
    }
    else
    {
        m_Str = "";
    }
}

void VmaRecorder::WriteConfiguration(
    const VkPhysicalDeviceProperties& devProps,
    const VkPhysicalDeviceMemoryProperties& memProps,
    uint32_t vulkanApiVersion,
    bool dedicatedAllocationExtensionEnabled,
    bool bindMemory2ExtensionEnabled,
    bool memoryBudgetExtensionEnabled)
{
    fprintf(m_File, "Config,Begin\n");

    fprintf(m_File, "VulkanApiVersion,%u,%u\n", VK_VERSION_MAJOR(vulkanApiVersion), VK_VERSION_MINOR(vulkanApiVersion));

    fprintf(m_File, "PhysicalDevice,apiVersion,%u\n", devProps.apiVersion);
    fprintf(m_File, "PhysicalDevice,driverVersion,%u\n", devProps.driverVersion);
    fprintf(m_File, "PhysicalDevice,vendorID,%u\n", devProps.vendorID);
    fprintf(m_File, "PhysicalDevice,deviceID,%u\n", devProps.deviceID);
    fprintf(m_File, "PhysicalDevice,deviceType,%u\n", devProps.deviceType);
    fprintf(m_File, "PhysicalDevice,deviceName,%s\n", devProps.deviceName);

    fprintf(m_File, "PhysicalDeviceLimits,maxMemoryAllocationCount,%u\n", devProps.limits.maxMemoryAllocationCount);
    fprintf(m_File, "PhysicalDeviceLimits,bufferImageGranularity,%llu\n", devProps.limits.bufferImageGranularity);
    fprintf(m_File, "PhysicalDeviceLimits,nonCoherentAtomSize,%llu\n", devProps.limits.nonCoherentAtomSize);

    fprintf(m_File, "PhysicalDeviceMemory,HeapCount,%u\n", memProps.memoryHeapCount);
    for(uint32_t i = 0; i < memProps.memoryHeapCount; ++i)
    {
        fprintf(m_File, "PhysicalDeviceMemory,Heap,%u,size,%llu\n", i, memProps.memoryHeaps[i].size);
        fprintf(m_File, "PhysicalDeviceMemory,Heap,%u,flags,%u\n", i, memProps.memoryHeaps[i].flags);
    }
    fprintf(m_File, "PhysicalDeviceMemory,TypeCount,%u\n", memProps.memoryTypeCount);
    for(uint32_t i = 0; i < memProps.memoryTypeCount; ++i)
    {
        fprintf(m_File, "PhysicalDeviceMemory,Type,%u,heapIndex,%u\n", i, memProps.memoryTypes[i].heapIndex);
        fprintf(m_File, "PhysicalDeviceMemory,Type,%u,propertyFlags,%u\n", i, memProps.memoryTypes[i].propertyFlags);
    }

    fprintf(m_File, "Extension,VK_KHR_dedicated_allocation,%u\n", dedicatedAllocationExtensionEnabled ? 1 : 0);
    fprintf(m_File, "Extension,VK_KHR_bind_memory2,%u\n", bindMemory2ExtensionEnabled ? 1 : 0);
    fprintf(m_File, "Extension,VK_EXT_memory_budget,%u\n", memoryBudgetExtensionEnabled ? 1 : 0);

    fprintf(m_File, "Macro,VMA_DEBUG_ALWAYS_DEDICATED_MEMORY,%u\n", VMA_DEBUG_ALWAYS_DEDICATED_MEMORY ? 1 : 0);
    fprintf(m_File, "Macro,VMA_DEBUG_ALIGNMENT,%llu\n", (VkDeviceSize)VMA_DEBUG_ALIGNMENT);
    fprintf(m_File, "Macro,VMA_DEBUG_MARGIN,%llu\n", (VkDeviceSize)VMA_DEBUG_MARGIN);
    fprintf(m_File, "Macro,VMA_DEBUG_INITIALIZE_ALLOCATIONS,%u\n", VMA_DEBUG_INITIALIZE_ALLOCATIONS ? 1 : 0);
    fprintf(m_File, "Macro,VMA_DEBUG_DETECT_CORRUPTION,%u\n", VMA_DEBUG_DETECT_CORRUPTION ? 1 : 0);
    fprintf(m_File, "Macro,VMA_DEBUG_GLOBAL_MUTEX,%u\n", VMA_DEBUG_GLOBAL_MUTEX ? 1 : 0);
    fprintf(m_File, "Macro,VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY,%llu\n", (VkDeviceSize)VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY);
    fprintf(m_File, "Macro,VMA_SMALL_HEAP_MAX_SIZE,%llu\n", (VkDeviceSize)VMA_SMALL_HEAP_MAX_SIZE);
    fprintf(m_File, "Macro,VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE,%llu\n", (VkDeviceSize)VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE);

    fprintf(m_File, "Config,End\n");
}

void VmaRecorder::GetBasicParams(CallParams& outParams)
{
    outParams.threadId = GetCurrentThreadId();

    LARGE_INTEGER counter;
    QueryPerformanceCounter(&counter);
    outParams.time = (double)(counter.QuadPart - m_StartCounter) / (double)m_Freq;
}

void VmaRecorder::PrintPointerList(uint64_t count, const VmaAllocation* pItems)
{
    if(count)
    {
        fprintf(m_File, "%p", pItems[0]);
        for(uint64_t i = 1; i < count; ++i)
        {
            fprintf(m_File, " %p", pItems[i]);
        }
    }
}

void VmaRecorder::Flush()
{
    if((m_Flags & VMA_RECORD_FLUSH_AFTER_CALL_BIT) != 0)
    {
        fflush(m_File);
    }
}

#endif // #if VMA_RECORDING_ENABLED

////////////////////////////////////////////////////////////////////////////////
// VmaAllocationObjectAllocator

VmaAllocationObjectAllocator::VmaAllocationObjectAllocator(const VkAllocationCallbacks* pAllocationCallbacks) :
    m_Allocator(pAllocationCallbacks, 1024)
{
}

VmaAllocation VmaAllocationObjectAllocator::Allocate()
{
    VmaMutexLock mutexLock(m_Mutex);
    return m_Allocator.Alloc();
}

void VmaAllocationObjectAllocator::Free(VmaAllocation hAlloc)
{
    VmaMutexLock mutexLock(m_Mutex);
    m_Allocator.Free(hAlloc);
}

////////////////////////////////////////////////////////////////////////////////
// VmaAllocator_T

VmaAllocator_T::VmaAllocator_T(const VmaAllocatorCreateInfo* pCreateInfo) :
    m_UseMutex((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT) == 0),
    m_VulkanApiVersion(pCreateInfo->vulkanApiVersion != 0 ? pCreateInfo->vulkanApiVersion : VK_API_VERSION_1_0),
    m_UseKhrDedicatedAllocation((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT) != 0),
    m_UseKhrBindMemory2((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT) != 0),
    m_UseExtMemoryBudget((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT) != 0),
    m_hDevice(pCreateInfo->device),
    m_hInstance(pCreateInfo->instance),
    m_AllocationCallbacksSpecified(pCreateInfo->pAllocationCallbacks != VMA_NULL),
    m_AllocationCallbacks(pCreateInfo->pAllocationCallbacks ?
        *pCreateInfo->pAllocationCallbacks : VmaEmptyAllocationCallbacks),
    m_AllocationObjectAllocator(&m_AllocationCallbacks),
    m_HeapSizeLimitMask(0),
    m_PreferredLargeHeapBlockSize(0),
    m_PhysicalDevice(pCreateInfo->physicalDevice),
    m_CurrentFrameIndex(0),
    m_GpuDefragmentationMemoryTypeBits(UINT32_MAX),
    m_Pools(VmaStlAllocator<VmaPool>(GetAllocationCallbacks())),
    m_NextPoolId(0)
#if VMA_RECORDING_ENABLED
    ,m_pRecorder(VMA_NULL)
#endif
{
    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
    {
        m_UseKhrDedicatedAllocation = false;
        m_UseKhrBindMemory2 = false;
    }

    if(VMA_DEBUG_DETECT_CORRUPTION)
    {
        // Needs to be multiply of uint32_t size because we are going to write VMA_CORRUPTION_DETECTION_MAGIC_VALUE to it.
        VMA_ASSERT(VMA_DEBUG_MARGIN % sizeof(uint32_t) == 0);
    }

    VMA_ASSERT(pCreateInfo->physicalDevice && pCreateInfo->device);

    if(m_VulkanApiVersion < VK_MAKE_VERSION(1, 1, 0))
    {
#if !(VMA_DEDICATED_ALLOCATION)
        if((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT) != 0)
        {
            VMA_ASSERT(0 && "VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT set but required extensions are disabled by preprocessor macros.");
        }
#endif
#if !(VMA_BIND_MEMORY2)
        if((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT) != 0)
        {
            VMA_ASSERT(0 && "VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT set but required extension is disabled by preprocessor macros.");
        }
#endif
    }
#if !(VMA_MEMORY_BUDGET)
    if((pCreateInfo->flags & VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT) != 0)
    {
        VMA_ASSERT(0 && "VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT set but required extension is disabled by preprocessor macros.");
    }
#endif
#if VMA_VULKAN_VERSION < 1001000
    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
    {
        VMA_ASSERT(0 && "vulkanApiVersion >= VK_API_VERSION_1_1 but required Vulkan version is disabled by preprocessor macros.");
    }
#endif

    memset(&m_DeviceMemoryCallbacks, 0 ,sizeof(m_DeviceMemoryCallbacks));
    memset(&m_PhysicalDeviceProperties, 0, sizeof(m_PhysicalDeviceProperties));
    memset(&m_MemProps, 0, sizeof(m_MemProps));
        
    memset(&m_pBlockVectors, 0, sizeof(m_pBlockVectors));
    memset(&m_pDedicatedAllocations, 0, sizeof(m_pDedicatedAllocations));
    memset(&m_VulkanFunctions, 0, sizeof(m_VulkanFunctions));

    if(pCreateInfo->pDeviceMemoryCallbacks != VMA_NULL)
    {
        m_DeviceMemoryCallbacks.pfnAllocate = pCreateInfo->pDeviceMemoryCallbacks->pfnAllocate;
        m_DeviceMemoryCallbacks.pfnFree = pCreateInfo->pDeviceMemoryCallbacks->pfnFree;
    }

    ImportVulkanFunctions(pCreateInfo->pVulkanFunctions);

    (*m_VulkanFunctions.vkGetPhysicalDeviceProperties)(m_PhysicalDevice, &m_PhysicalDeviceProperties);
    (*m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties)(m_PhysicalDevice, &m_MemProps);

    VMA_ASSERT(VmaIsPow2(VMA_DEBUG_ALIGNMENT));
    VMA_ASSERT(VmaIsPow2(VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY));
    VMA_ASSERT(VmaIsPow2(m_PhysicalDeviceProperties.limits.bufferImageGranularity));
    VMA_ASSERT(VmaIsPow2(m_PhysicalDeviceProperties.limits.nonCoherentAtomSize));

    m_PreferredLargeHeapBlockSize = (pCreateInfo->preferredLargeHeapBlockSize != 0) ?
        pCreateInfo->preferredLargeHeapBlockSize : static_cast<VkDeviceSize>(VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE);

    if(pCreateInfo->pHeapSizeLimit != VMA_NULL)
    {
        for(uint32_t heapIndex = 0; heapIndex < GetMemoryHeapCount(); ++heapIndex)
        {
            const VkDeviceSize limit = pCreateInfo->pHeapSizeLimit[heapIndex];
            if(limit != VK_WHOLE_SIZE)
            {
                m_HeapSizeLimitMask |= 1u << heapIndex;
                if(limit < m_MemProps.memoryHeaps[heapIndex].size)
                {
                    m_MemProps.memoryHeaps[heapIndex].size = limit;
                }
            }
        }
    }

    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
    {
        const VkDeviceSize preferredBlockSize = CalcPreferredBlockSize(memTypeIndex);

        m_pBlockVectors[memTypeIndex] = vma_new(this, VmaBlockVector)(
            this,
            VK_NULL_HANDLE, // hParentPool
            memTypeIndex,
            preferredBlockSize,
            0,
            SIZE_MAX,
            GetBufferImageGranularity(),
            pCreateInfo->frameInUseCount,
            false, // explicitBlockSize
            false); // linearAlgorithm
        // No need to call m_pBlockVectors[memTypeIndex][blockVectorTypeIndex]->CreateMinBlocks here,
        // becase minBlockCount is 0.
        m_pDedicatedAllocations[memTypeIndex] = vma_new(this, AllocationVectorType)(VmaStlAllocator<VmaAllocation>(GetAllocationCallbacks()));

    }
}

VkResult VmaAllocator_T::Init(const VmaAllocatorCreateInfo* pCreateInfo)
{
    VkResult res = VK_SUCCESS;

    if(pCreateInfo->pRecordSettings != VMA_NULL &&
        !VmaStrIsEmpty(pCreateInfo->pRecordSettings->pFilePath))
    {
#if VMA_RECORDING_ENABLED
        m_pRecorder = vma_new(this, VmaRecorder)();
        res = m_pRecorder->Init(*pCreateInfo->pRecordSettings, m_UseMutex);
        if(res != VK_SUCCESS)
        {
            return res;
        }
        m_pRecorder->WriteConfiguration(
            m_PhysicalDeviceProperties,
            m_MemProps,
            m_VulkanApiVersion,
            m_UseKhrDedicatedAllocation,
            m_UseKhrBindMemory2,
            m_UseExtMemoryBudget);
        m_pRecorder->RecordCreateAllocator(GetCurrentFrameIndex());
#else
        VMA_ASSERT(0 && "VmaAllocatorCreateInfo::pRecordSettings used, but not supported due to VMA_RECORDING_ENABLED not defined to 1.");
        return VK_ERROR_FEATURE_NOT_PRESENT;
#endif
    }

#if VMA_MEMORY_BUDGET
    if(m_UseExtMemoryBudget)
    {
        UpdateVulkanBudget();
    }
#endif // #if VMA_MEMORY_BUDGET

    return res;
}

VmaAllocator_T::~VmaAllocator_T()
{
#if VMA_RECORDING_ENABLED
    if(m_pRecorder != VMA_NULL)
    {
        m_pRecorder->RecordDestroyAllocator(GetCurrentFrameIndex());
        vma_delete(this, m_pRecorder);
    }
#endif
    
    VMA_ASSERT(m_Pools.empty());

    for(size_t i = GetMemoryTypeCount(); i--; )
    {
        if(m_pDedicatedAllocations[i] != VMA_NULL && !m_pDedicatedAllocations[i]->empty())
        {
            VMA_ASSERT(0 && "Unfreed dedicated allocations found.");
        }

        vma_delete(this, m_pDedicatedAllocations[i]);
        vma_delete(this, m_pBlockVectors[i]);
    }
}

void VmaAllocator_T::ImportVulkanFunctions(const VmaVulkanFunctions* pVulkanFunctions)
{
#if VMA_STATIC_VULKAN_FUNCTIONS == 1
    m_VulkanFunctions.vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)vkGetPhysicalDeviceProperties;
    m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)vkGetPhysicalDeviceMemoryProperties;
    m_VulkanFunctions.vkAllocateMemory = (PFN_vkAllocateMemory)vkAllocateMemory;
    m_VulkanFunctions.vkFreeMemory = (PFN_vkFreeMemory)vkFreeMemory;
    m_VulkanFunctions.vkMapMemory = (PFN_vkMapMemory)vkMapMemory;
    m_VulkanFunctions.vkUnmapMemory = (PFN_vkUnmapMemory)vkUnmapMemory;
    m_VulkanFunctions.vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)vkFlushMappedMemoryRanges;
    m_VulkanFunctions.vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)vkInvalidateMappedMemoryRanges;
    m_VulkanFunctions.vkBindBufferMemory = (PFN_vkBindBufferMemory)vkBindBufferMemory;
    m_VulkanFunctions.vkBindImageMemory = (PFN_vkBindImageMemory)vkBindImageMemory;
    m_VulkanFunctions.vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)vkGetBufferMemoryRequirements;
    m_VulkanFunctions.vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)vkGetImageMemoryRequirements;
    m_VulkanFunctions.vkCreateBuffer = (PFN_vkCreateBuffer)vkCreateBuffer;
    m_VulkanFunctions.vkDestroyBuffer = (PFN_vkDestroyBuffer)vkDestroyBuffer;
    m_VulkanFunctions.vkCreateImage = (PFN_vkCreateImage)vkCreateImage;
    m_VulkanFunctions.vkDestroyImage = (PFN_vkDestroyImage)vkDestroyImage;
    m_VulkanFunctions.vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer)vkCmdCopyBuffer;
#if VMA_VULKAN_VERSION >= 1001000
    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
    {
        VMA_ASSERT(m_hInstance != VK_NULL_HANDLE);
        m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR =
            (PFN_vkGetBufferMemoryRequirements2KHR)vkGetDeviceProcAddr(m_hDevice, "vkGetBufferMemoryRequirements2");
        m_VulkanFunctions.vkGetImageMemoryRequirements2KHR =
            (PFN_vkGetImageMemoryRequirements2KHR)vkGetDeviceProcAddr(m_hDevice, "vkGetImageMemoryRequirements2");
        m_VulkanFunctions.vkBindBufferMemory2KHR =
            (PFN_vkBindBufferMemory2KHR)vkGetDeviceProcAddr(m_hDevice, "vkBindBufferMemory2");
        m_VulkanFunctions.vkBindImageMemory2KHR =
            (PFN_vkBindImageMemory2KHR)vkGetDeviceProcAddr(m_hDevice, "vkBindImageMemory2");
        m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties2KHR =
            (PFN_vkGetPhysicalDeviceMemoryProperties2KHR)vkGetInstanceProcAddr(m_hInstance, "vkGetPhysicalDeviceMemoryProperties2");
    }
#endif
#if VMA_DEDICATED_ALLOCATION
    if(m_UseKhrDedicatedAllocation)
    {
        m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR =
            (PFN_vkGetBufferMemoryRequirements2KHR)vkGetDeviceProcAddr(m_hDevice, "vkGetBufferMemoryRequirements2KHR");
        m_VulkanFunctions.vkGetImageMemoryRequirements2KHR =
            (PFN_vkGetImageMemoryRequirements2KHR)vkGetDeviceProcAddr(m_hDevice, "vkGetImageMemoryRequirements2KHR");
    }
#endif
#if VMA_BIND_MEMORY2
    if(m_UseKhrBindMemory2)
    {
        m_VulkanFunctions.vkBindBufferMemory2KHR =
            (PFN_vkBindBufferMemory2KHR)vkGetDeviceProcAddr(m_hDevice, "vkBindBufferMemory2KHR");
        m_VulkanFunctions.vkBindImageMemory2KHR =
            (PFN_vkBindImageMemory2KHR)vkGetDeviceProcAddr(m_hDevice, "vkBindImageMemory2KHR");
    }
#endif // #if VMA_BIND_MEMORY2
#if VMA_MEMORY_BUDGET
    if(m_UseExtMemoryBudget && m_VulkanApiVersion < VK_MAKE_VERSION(1, 1, 0))
    {
        VMA_ASSERT(m_hInstance != VK_NULL_HANDLE);
        m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties2KHR =
            (PFN_vkGetPhysicalDeviceMemoryProperties2KHR)vkGetInstanceProcAddr(m_hInstance, "vkGetPhysicalDeviceMemoryProperties2KHR");
    }
#endif // #if VMA_MEMORY_BUDGET
#endif // #if VMA_STATIC_VULKAN_FUNCTIONS == 1

#define VMA_COPY_IF_NOT_NULL(funcName) \
    if(pVulkanFunctions->funcName != VMA_NULL) m_VulkanFunctions.funcName = pVulkanFunctions->funcName;

    if(pVulkanFunctions != VMA_NULL)
    {
        VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceProperties);
        VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceMemoryProperties);
        VMA_COPY_IF_NOT_NULL(vkAllocateMemory);
        VMA_COPY_IF_NOT_NULL(vkFreeMemory);
        VMA_COPY_IF_NOT_NULL(vkMapMemory);
        VMA_COPY_IF_NOT_NULL(vkUnmapMemory);
        VMA_COPY_IF_NOT_NULL(vkFlushMappedMemoryRanges);
        VMA_COPY_IF_NOT_NULL(vkInvalidateMappedMemoryRanges);
        VMA_COPY_IF_NOT_NULL(vkBindBufferMemory);
        VMA_COPY_IF_NOT_NULL(vkBindImageMemory);
        VMA_COPY_IF_NOT_NULL(vkGetBufferMemoryRequirements);
        VMA_COPY_IF_NOT_NULL(vkGetImageMemoryRequirements);
        VMA_COPY_IF_NOT_NULL(vkCreateBuffer);
        VMA_COPY_IF_NOT_NULL(vkDestroyBuffer);
        VMA_COPY_IF_NOT_NULL(vkCreateImage);
        VMA_COPY_IF_NOT_NULL(vkDestroyImage);
        VMA_COPY_IF_NOT_NULL(vkCmdCopyBuffer);
#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
        VMA_COPY_IF_NOT_NULL(vkGetBufferMemoryRequirements2KHR);
        VMA_COPY_IF_NOT_NULL(vkGetImageMemoryRequirements2KHR);
#endif
#if VMA_BIND_MEMORY2 || VMA_VULKAN_VERSION >= 1001000
        VMA_COPY_IF_NOT_NULL(vkBindBufferMemory2KHR);
        VMA_COPY_IF_NOT_NULL(vkBindImageMemory2KHR);
#endif
#if VMA_MEMORY_BUDGET
        VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceMemoryProperties2KHR);
#endif
    }

#undef VMA_COPY_IF_NOT_NULL

    // If these asserts are hit, you must either #define VMA_STATIC_VULKAN_FUNCTIONS 1
    // or pass valid pointers as VmaAllocatorCreateInfo::pVulkanFunctions.
    VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceProperties != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkAllocateMemory != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkFreeMemory != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkMapMemory != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkUnmapMemory != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkFlushMappedMemoryRanges != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkInvalidateMappedMemoryRanges != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkBindBufferMemory != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkBindImageMemory != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkGetBufferMemoryRequirements != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkGetImageMemoryRequirements != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkCreateBuffer != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkDestroyBuffer != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkCreateImage != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkDestroyImage != VMA_NULL);
    VMA_ASSERT(m_VulkanFunctions.vkCmdCopyBuffer != VMA_NULL);
#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0) || m_UseKhrDedicatedAllocation)
    {
        VMA_ASSERT(m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR != VMA_NULL);
        VMA_ASSERT(m_VulkanFunctions.vkGetImageMemoryRequirements2KHR != VMA_NULL);
    }
#endif
#if VMA_BIND_MEMORY2 || VMA_VULKAN_VERSION >= 1001000
    if(m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0) || m_UseKhrBindMemory2)
    {
        VMA_ASSERT(m_VulkanFunctions.vkBindBufferMemory2KHR != VMA_NULL);
        VMA_ASSERT(m_VulkanFunctions.vkBindImageMemory2KHR != VMA_NULL);
    }
#endif
#if VMA_MEMORY_BUDGET || VMA_VULKAN_VERSION >= 1001000
    if(m_UseExtMemoryBudget || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
    {
        VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties2KHR != VMA_NULL);
    }
#endif
}

VkDeviceSize VmaAllocator_T::CalcPreferredBlockSize(uint32_t memTypeIndex)
{
    const uint32_t heapIndex = MemoryTypeIndexToHeapIndex(memTypeIndex);
    const VkDeviceSize heapSize = m_MemProps.memoryHeaps[heapIndex].size;
    const bool isSmallHeap = heapSize <= VMA_SMALL_HEAP_MAX_SIZE;
    return VmaAlignUp(isSmallHeap ? (heapSize / 8) : m_PreferredLargeHeapBlockSize, (VkDeviceSize)32);
}

VkResult VmaAllocator_T::AllocateMemoryOfType(
    VkDeviceSize size,
    VkDeviceSize alignment,
    bool dedicatedAllocation,
    VkBuffer dedicatedBuffer,
    VkImage dedicatedImage,
    const VmaAllocationCreateInfo& createInfo,
    uint32_t memTypeIndex,
    VmaSuballocationType suballocType,
    size_t allocationCount,
    VmaAllocation* pAllocations)
{
    VMA_ASSERT(pAllocations != VMA_NULL);
    VMA_DEBUG_LOG("  AllocateMemory: MemoryTypeIndex=%u, AllocationCount=%zu, Size=%llu", memTypeIndex, allocationCount, size);

    VmaAllocationCreateInfo finalCreateInfo = createInfo;

    // If memory type is not HOST_VISIBLE, disable MAPPED.
    if((finalCreateInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0 &&
        (m_MemProps.memoryTypes[memTypeIndex].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
    {
        finalCreateInfo.flags &= ~VMA_ALLOCATION_CREATE_MAPPED_BIT;
    }
    // If memory is lazily allocated, it should be always dedicated.
    if(finalCreateInfo.usage == VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED)
    {
        finalCreateInfo.flags |= VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT;
    }

    VmaBlockVector* const blockVector = m_pBlockVectors[memTypeIndex];
    VMA_ASSERT(blockVector);

    const VkDeviceSize preferredBlockSize = blockVector->GetPreferredBlockSize();
    bool preferDedicatedMemory =
        VMA_DEBUG_ALWAYS_DEDICATED_MEMORY ||
        dedicatedAllocation ||
        // Heuristics: Allocate dedicated memory if requested size if greater than half of preferred block size.
        size > preferredBlockSize / 2;

    if(preferDedicatedMemory &&
        (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) == 0 &&
        finalCreateInfo.pool == VK_NULL_HANDLE)
    {
        finalCreateInfo.flags |= VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT;
    }

    if((finalCreateInfo.flags & VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT) != 0)
    {
        if((finalCreateInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) != 0)
        {
            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
        }
        else
        {
            return AllocateDedicatedMemory(
                size,
                suballocType,
                memTypeIndex,
                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT) != 0,
                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0,
                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0,
                finalCreateInfo.pUserData,
                dedicatedBuffer,
                dedicatedImage,
                allocationCount,
                pAllocations);
        }
    }
    else
    {
        VkResult res = blockVector->Allocate(
            m_CurrentFrameIndex.load(),
            size,
            alignment,
            finalCreateInfo,
            suballocType,
            allocationCount,
            pAllocations);
        if(res == VK_SUCCESS)
        {
            return res;
        }

        // 5. Try dedicated memory.
        if((finalCreateInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) != 0)
        {
            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
        }
        else
        {
            res = AllocateDedicatedMemory(
                size,
                suballocType,
                memTypeIndex,
                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT) != 0,
                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0,
                (finalCreateInfo.flags & VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT) != 0,
                finalCreateInfo.pUserData,
                dedicatedBuffer,
                dedicatedImage,
                allocationCount,
                pAllocations);
            if(res == VK_SUCCESS)
            {
                // Succeeded: AllocateDedicatedMemory function already filld pMemory, nothing more to do here.
                VMA_DEBUG_LOG("    Allocated as DedicatedMemory");
                return VK_SUCCESS;
            }
            else
            {
                // Everything failed: Return error code.
                VMA_DEBUG_LOG("    vkAllocateMemory FAILED");
                return res;
            }
        }
    }
}

VkResult VmaAllocator_T::AllocateDedicatedMemory(
    VkDeviceSize size,
    VmaSuballocationType suballocType,
    uint32_t memTypeIndex,
    bool withinBudget,
    bool map,
    bool isUserDataString,
    void* pUserData,
    VkBuffer dedicatedBuffer,
    VkImage dedicatedImage,
    size_t allocationCount,
    VmaAllocation* pAllocations)
{
    VMA_ASSERT(allocationCount > 0 && pAllocations);

    if(withinBudget)
    {
        const uint32_t heapIndex = MemoryTypeIndexToHeapIndex(memTypeIndex);
        VmaBudget heapBudget = {};
        GetBudget(&heapBudget, heapIndex, 1);
        if(heapBudget.usage + size * allocationCount > heapBudget.budget)
        {
            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
        }
    }

    VkMemoryAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };
    allocInfo.memoryTypeIndex = memTypeIndex;
    allocInfo.allocationSize = size;

#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
    VkMemoryDedicatedAllocateInfoKHR dedicatedAllocInfo = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR };
    if(m_UseKhrDedicatedAllocation || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
    {
        if(dedicatedBuffer != VK_NULL_HANDLE)
        {
            VMA_ASSERT(dedicatedImage == VK_NULL_HANDLE);
            dedicatedAllocInfo.buffer = dedicatedBuffer;
            allocInfo.pNext = &dedicatedAllocInfo;
        }
        else if(dedicatedImage != VK_NULL_HANDLE)
        {
            dedicatedAllocInfo.image = dedicatedImage;
            allocInfo.pNext = &dedicatedAllocInfo;
        }
    }
#endif // #if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000

    size_t allocIndex;
    VkResult res = VK_SUCCESS;
    for(allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
    {
        res = AllocateDedicatedMemoryPage(
            size,
            suballocType,
            memTypeIndex,
            allocInfo,
            map,
            isUserDataString,
            pUserData,
            pAllocations + allocIndex);
        if(res != VK_SUCCESS)
        {
            break;
        }
    }

    if(res == VK_SUCCESS)
    {
        // Register them in m_pDedicatedAllocations.
        {
            VmaMutexLockWrite lock(m_DedicatedAllocationsMutex[memTypeIndex], m_UseMutex);
            AllocationVectorType* pDedicatedAllocations = m_pDedicatedAllocations[memTypeIndex];
            VMA_ASSERT(pDedicatedAllocations);
            for(allocIndex = 0; allocIndex < allocationCount; ++allocIndex)
            {
                VmaVectorInsertSorted<VmaPointerLess>(*pDedicatedAllocations, pAllocations[allocIndex]);
            }
        }

        VMA_DEBUG_LOG("    Allocated DedicatedMemory Count=%zu, MemoryTypeIndex=#%u", allocationCount, memTypeIndex);
    }
    else
    {
        // Free all already created allocations.
        while(allocIndex--)
        {
            VmaAllocation currAlloc = pAllocations[allocIndex];
            VkDeviceMemory hMemory = currAlloc->GetMemory();
    
            /*
            There is no need to call this, because Vulkan spec allows to skip vkUnmapMemory
            before vkFreeMemory.

            if(currAlloc->GetMappedData() != VMA_NULL)
            {
                (*m_VulkanFunctions.vkUnmapMemory)(m_hDevice, hMemory);
            }
            */
    
            FreeVulkanMemory(memTypeIndex, currAlloc->GetSize(), hMemory);
            m_Budget.RemoveAllocation(MemoryTypeIndexToHeapIndex(memTypeIndex), currAlloc->GetSize());
            currAlloc->SetUserData(this, VMA_NULL);
            currAlloc->Dtor();
            m_AllocationObjectAllocator.Free(currAlloc);
        }

        memset(pAllocations, 0, sizeof(VmaAllocation) * allocationCount);
    }

    return res;
}

VkResult VmaAllocator_T::AllocateDedicatedMemoryPage(
    VkDeviceSize size,
    VmaSuballocationType suballocType,
    uint32_t memTypeIndex,
    const VkMemoryAllocateInfo& allocInfo,
    bool map,
    bool isUserDataString,
    void* pUserData,
    VmaAllocation* pAllocation)
{
    VkDeviceMemory hMemory = VK_NULL_HANDLE;
    VkResult res = AllocateVulkanMemory(&allocInfo, &hMemory);
    if(res < 0)
    {
        VMA_DEBUG_LOG("    vkAllocateMemory FAILED");
        return res;
    }

    void* pMappedData = VMA_NULL;
    if(map)
    {
        res = (*m_VulkanFunctions.vkMapMemory)(
            m_hDevice,
            hMemory,
            0,
            VK_WHOLE_SIZE,
            0,
            &pMappedData);
        if(res < 0)
        {
            VMA_DEBUG_LOG("    vkMapMemory FAILED");
            FreeVulkanMemory(memTypeIndex, size, hMemory);
            return res;
        }
    }

    *pAllocation = m_AllocationObjectAllocator.Allocate();
    (*pAllocation)->Ctor(m_CurrentFrameIndex.load(), isUserDataString);
    (*pAllocation)->InitDedicatedAllocation(memTypeIndex, hMemory, suballocType, pMappedData, size);
    (*pAllocation)->SetUserData(this, pUserData);
    m_Budget.AddAllocation(MemoryTypeIndexToHeapIndex(memTypeIndex), size);
    if(VMA_DEBUG_INITIALIZE_ALLOCATIONS)
    {
        FillAllocation(*pAllocation, VMA_ALLOCATION_FILL_PATTERN_CREATED);
    }

    return VK_SUCCESS;
}

void VmaAllocator_T::GetBufferMemoryRequirements(
    VkBuffer hBuffer,
    VkMemoryRequirements& memReq,
    bool& requiresDedicatedAllocation,
    bool& prefersDedicatedAllocation) const
{
#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
    if(m_UseKhrDedicatedAllocation || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
    {
        VkBufferMemoryRequirementsInfo2KHR memReqInfo = { VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR };
        memReqInfo.buffer = hBuffer;

        VkMemoryDedicatedRequirementsKHR memDedicatedReq = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR };

        VkMemoryRequirements2KHR memReq2 = { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR };
        memReq2.pNext = &memDedicatedReq;

        (*m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR)(m_hDevice, &memReqInfo, &memReq2);

        memReq = memReq2.memoryRequirements;
        requiresDedicatedAllocation = (memDedicatedReq.requiresDedicatedAllocation != VK_FALSE);
        prefersDedicatedAllocation  = (memDedicatedReq.prefersDedicatedAllocation  != VK_FALSE);
    }
    else
#endif // #if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
    {
        (*m_VulkanFunctions.vkGetBufferMemoryRequirements)(m_hDevice, hBuffer, &memReq);
        requiresDedicatedAllocation = false;
        prefersDedicatedAllocation  = false;
    }
}

void VmaAllocator_T::GetImageMemoryRequirements(
    VkImage hImage,
    VkMemoryRequirements& memReq,
    bool& requiresDedicatedAllocation,
    bool& prefersDedicatedAllocation) const
{
#if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
    if(m_UseKhrDedicatedAllocation || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0))
    {
        VkImageMemoryRequirementsInfo2KHR memReqInfo = { VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR };
        memReqInfo.image = hImage;

        VkMemoryDedicatedRequirementsKHR memDedicatedReq = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR };

        VkMemoryRequirements2KHR memReq2 = { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR };
        memReq2.pNext = &memDedicatedReq;

        (*m_VulkanFunctions.vkGetImageMemoryRequirements2KHR)(m_hDevice, &memReqInfo, &memReq2);

        memReq = memReq2.memoryRequirements;
        requiresDedicatedAllocation = (memDedicatedReq.requiresDedicatedAllocation != VK_FALSE);
        prefersDedicatedAllocation  = (memDedicatedReq.prefersDedicatedAllocation  != VK_FALSE);
    }
    else
#endif // #if VMA_DEDICATED_ALLOCATION || VMA_VULKAN_VERSION >= 1001000
    {
        (*m_VulkanFunctions.vkGetImageMemoryRequirements)(m_hDevice, hImage, &memReq);
        requiresDedicatedAllocation = false;
        prefersDedicatedAllocation  = false;
    }
}

VkResult VmaAllocator_T::AllocateMemory(
    const VkMemoryRequirements& vkMemReq,
    bool requiresDedicatedAllocation,
    bool prefersDedicatedAllocation,
    VkBuffer dedicatedBuffer,
    VkImage dedicatedImage,
    const VmaAllocationCreateInfo& createInfo,
    VmaSuballocationType suballocType,
    size_t allocationCount,
    VmaAllocation* pAllocations)
{
    memset(pAllocations, 0, sizeof(VmaAllocation) * allocationCount);

    VMA_ASSERT(VmaIsPow2(vkMemReq.alignment));

    if(vkMemReq.size == 0)
    {
        return VK_ERROR_VALIDATION_FAILED_EXT;
    }
    if((createInfo.flags & VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT) != 0 &&
        (createInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) != 0)
    {
        VMA_ASSERT(0 && "Specifying VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT together with VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT makes no sense.");
        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
    }
    if((createInfo.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0 &&
        (createInfo.flags & VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT) != 0)
    {
        VMA_ASSERT(0 && "Specifying VMA_ALLOCATION_CREATE_MAPPED_BIT together with VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT is invalid.");
        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
    }
    if(requiresDedicatedAllocation)
    {
        if((createInfo.flags & VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT) != 0)
        {
            VMA_ASSERT(0 && "VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT specified while dedicated allocation is required.");
            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
        }
        if(createInfo.pool != VK_NULL_HANDLE)
        {
            VMA_ASSERT(0 && "Pool specified while dedicated allocation is required.");
            return VK_ERROR_OUT_OF_DEVICE_MEMORY;
        }
    }
    if((createInfo.pool != VK_NULL_HANDLE) &&
        ((createInfo.flags & (VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT)) != 0))
    {
        VMA_ASSERT(0 && "Specifying VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT when pool != null is invalid.");
        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
    }

    if(createInfo.pool != VK_NULL_HANDLE)
    {
        const VkDeviceSize alignmentForPool = VMA_MAX(
            vkMemReq.alignment,
            GetMemoryTypeMinAlignment(createInfo.pool->m_BlockVector.GetMemoryTypeIndex()));

        VmaAllocationCreateInfo createInfoForPool = createInfo;
        // If memory type is not HOST_VISIBLE, disable MAPPED.
        if((createInfoForPool.flags & VMA_ALLOCATION_CREATE_MAPPED_BIT) != 0 &&
            (m_MemProps.memoryTypes[createInfo.pool->m_BlockVector.GetMemoryTypeIndex()].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
        {
            createInfoForPool.flags &= ~VMA_ALLOCATION_CREATE_MAPPED_BIT;
        }

        return createInfo.pool->m_BlockVector.Allocate(
            m_CurrentFrameIndex.load(),
            vkMemReq.size,
            alignmentForPool,
            createInfoForPool,
            suballocType,
            allocationCount,
            pAllocations);
    }
    else
    {
        // Bit mask of memory Vulkan types acceptable for this allocation.
        uint32_t memoryTypeBits = vkMemReq.memoryTypeBits;
        uint32_t memTypeIndex = UINT32_MAX;
        VkResult res = vmaFindMemoryTypeIndex(this, memoryTypeBits, &createInfo, &memTypeIndex);
        if(res == VK_SUCCESS)
        {
            VkDeviceSize alignmentForMemType = VMA_MAX(
                vkMemReq.alignment,
                GetMemoryTypeMinAlignment(memTypeIndex));

            res = AllocateMemoryOfType(
                vkMemReq.size,
                alignmentForMemType,
                requiresDedicatedAllocation || prefersDedicatedAllocation,
                dedicatedBuffer,
                dedicatedImage,
                createInfo,
                memTypeIndex,
                suballocType,
                allocationCount,
                pAllocations);
            // Succeeded on first try.
            if(res == VK_SUCCESS)
            {
                return res;
            }
            // Allocation from this memory type failed. Try other compatible memory types.
            else
            {
                for(;;)
                {
                    // Remove old memTypeIndex from list of possibilities.
                    memoryTypeBits &= ~(1u << memTypeIndex);
                    // Find alternative memTypeIndex.
                    res = vmaFindMemoryTypeIndex(this, memoryTypeBits, &createInfo, &memTypeIndex);
                    if(res == VK_SUCCESS)
                    {
                        alignmentForMemType = VMA_MAX(
                            vkMemReq.alignment,
                            GetMemoryTypeMinAlignment(memTypeIndex));
                        
                        res = AllocateMemoryOfType(
                            vkMemReq.size,
                            alignmentForMemType,
                            requiresDedicatedAllocation || prefersDedicatedAllocation,
                            dedicatedBuffer,
                            dedicatedImage,
                            createInfo,
                            memTypeIndex,
                            suballocType,
                            allocationCount,
                            pAllocations);
                        // Allocation from this alternative memory type succeeded.
                        if(res == VK_SUCCESS)
                        {
                            return res;
                        }
                        // else: Allocation from this memory type failed. Try next one - next loop iteration.
                    }
                    // No other matching memory type index could be found.
                    else
                    {
                        // Not returning res, which is VK_ERROR_FEATURE_NOT_PRESENT, because we already failed to allocate once.
                        return VK_ERROR_OUT_OF_DEVICE_MEMORY;
                    }
                }
            }
        }
        // Can't find any single memory type maching requirements. res is VK_ERROR_FEATURE_NOT_PRESENT.
        else
            return res;
    }
}

void VmaAllocator_T::FreeMemory(
    size_t allocationCount,
    const VmaAllocation* pAllocations)
{
    VMA_ASSERT(pAllocations);

    for(size_t allocIndex = allocationCount; allocIndex--; )
    {
        VmaAllocation allocation = pAllocations[allocIndex];

        if(allocation != VK_NULL_HANDLE)
        {
            if(TouchAllocation(allocation))
            {
                if(VMA_DEBUG_INITIALIZE_ALLOCATIONS)
                {
                    FillAllocation(allocation, VMA_ALLOCATION_FILL_PATTERN_DESTROYED);
                }

                switch(allocation->GetType())
                {
                case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
                    {
                        VmaBlockVector* pBlockVector = VMA_NULL;
                        VmaPool hPool = allocation->GetBlock()->GetParentPool();
                        if(hPool != VK_NULL_HANDLE)
                        {
                            pBlockVector = &hPool->m_BlockVector;
                        }
                        else
                        {
                            const uint32_t memTypeIndex = allocation->GetMemoryTypeIndex();
                            pBlockVector = m_pBlockVectors[memTypeIndex];
                        }
                        pBlockVector->Free(allocation);
                    }
                    break;
                case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
                    FreeDedicatedMemory(allocation);
                    break;
                default:
                    VMA_ASSERT(0);
                }
            }

            // Do this regardless of whether the allocation is lost. Lost allocations still account to Budget.AllocationBytes.
            m_Budget.RemoveAllocation(MemoryTypeIndexToHeapIndex(allocation->GetMemoryTypeIndex()), allocation->GetSize());
            allocation->SetUserData(this, VMA_NULL);
            allocation->Dtor();
            m_AllocationObjectAllocator.Free(allocation);
        }
    }
}

VkResult VmaAllocator_T::ResizeAllocation(
    const VmaAllocation alloc,
    VkDeviceSize newSize)
{
    // This function is deprecated and so it does nothing. It's left for backward compatibility.
    if(newSize == 0 || alloc->GetLastUseFrameIndex() == VMA_FRAME_INDEX_LOST)
    {
        return VK_ERROR_VALIDATION_FAILED_EXT;
    }
    if(newSize == alloc->GetSize())
    {
        return VK_SUCCESS;
    }
    return VK_ERROR_OUT_OF_POOL_MEMORY;
}

void VmaAllocator_T::CalculateStats(VmaStats* pStats)
{
    // Initialize.
    InitStatInfo(pStats->total);
    for(size_t i = 0; i < VK_MAX_MEMORY_TYPES; ++i)
        InitStatInfo(pStats->memoryType[i]);
    for(size_t i = 0; i < VK_MAX_MEMORY_HEAPS; ++i)
        InitStatInfo(pStats->memoryHeap[i]);
    
    // Process default pools.
    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
    {
        VmaBlockVector* const pBlockVector = m_pBlockVectors[memTypeIndex];
        VMA_ASSERT(pBlockVector);
        pBlockVector->AddStats(pStats);
    }

    // Process custom pools.
    {
        VmaMutexLockRead lock(m_PoolsMutex, m_UseMutex);
        for(size_t poolIndex = 0, poolCount = m_Pools.size(); poolIndex < poolCount; ++poolIndex)
        {
            m_Pools[poolIndex]->m_BlockVector.AddStats(pStats);
        }
    }

    // Process dedicated allocations.
    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
    {
        const uint32_t memHeapIndex = MemoryTypeIndexToHeapIndex(memTypeIndex);
        VmaMutexLockRead dedicatedAllocationsLock(m_DedicatedAllocationsMutex[memTypeIndex], m_UseMutex);
        AllocationVectorType* const pDedicatedAllocVector = m_pDedicatedAllocations[memTypeIndex];
        VMA_ASSERT(pDedicatedAllocVector);
        for(size_t allocIndex = 0, allocCount = pDedicatedAllocVector->size(); allocIndex < allocCount; ++allocIndex)
        {
            VmaStatInfo allocationStatInfo;
            (*pDedicatedAllocVector)[allocIndex]->DedicatedAllocCalcStatsInfo(allocationStatInfo);
            VmaAddStatInfo(pStats->total, allocationStatInfo);
            VmaAddStatInfo(pStats->memoryType[memTypeIndex], allocationStatInfo);
            VmaAddStatInfo(pStats->memoryHeap[memHeapIndex], allocationStatInfo);
        }
    }

    // Postprocess.
    VmaPostprocessCalcStatInfo(pStats->total);
    for(size_t i = 0; i < GetMemoryTypeCount(); ++i)
        VmaPostprocessCalcStatInfo(pStats->memoryType[i]);
    for(size_t i = 0; i < GetMemoryHeapCount(); ++i)
        VmaPostprocessCalcStatInfo(pStats->memoryHeap[i]);
}

void VmaAllocator_T::GetBudget(VmaBudget* outBudget, uint32_t firstHeap, uint32_t heapCount)
{
#if VMA_MEMORY_BUDGET
    if(m_UseExtMemoryBudget)
    {
        if(m_Budget.m_OperationsSinceBudgetFetch < 30)
        {
            VmaMutexLockRead lockRead(m_Budget.m_BudgetMutex, m_UseMutex);
            for(uint32_t i = 0; i < heapCount; ++i, ++outBudget)
            {
                const uint32_t heapIndex = firstHeap + i;

                outBudget->blockBytes = m_Budget.m_BlockBytes[heapIndex];
                outBudget->allocationBytes = m_Budget.m_AllocationBytes[heapIndex];

                if(m_Budget.m_VulkanUsage[heapIndex] + outBudget->blockBytes > m_Budget.m_BlockBytesAtBudgetFetch[heapIndex])
                {
                    outBudget->usage = m_Budget.m_VulkanUsage[heapIndex] +
                        outBudget->blockBytes - m_Budget.m_BlockBytesAtBudgetFetch[heapIndex];
                }
                else
                {
                    outBudget->usage = 0;
                }

                // Have to take MIN with heap size because explicit HeapSizeLimit is included in it.
                outBudget->budget = VMA_MIN(
                    m_Budget.m_VulkanBudget[heapIndex], m_MemProps.memoryHeaps[heapIndex].size);
            }
        }
        else
        {
            UpdateVulkanBudget(); // Outside of mutex lock
            GetBudget(outBudget, firstHeap, heapCount); // Recursion
        }
    }
    else
#endif
    {
        for(uint32_t i = 0; i < heapCount; ++i, ++outBudget)
        {
            const uint32_t heapIndex = firstHeap + i;

            outBudget->blockBytes = m_Budget.m_BlockBytes[heapIndex];
            outBudget->allocationBytes = m_Budget.m_AllocationBytes[heapIndex];

            outBudget->usage = outBudget->blockBytes;
            outBudget->budget = m_MemProps.memoryHeaps[heapIndex].size * 8 / 10; // 80% heuristics.
        }
    }
}

static const uint32_t VMA_VENDOR_ID_AMD = 4098;

VkResult VmaAllocator_T::DefragmentationBegin(
    const VmaDefragmentationInfo2& info,
    VmaDefragmentationStats* pStats,
    VmaDefragmentationContext* pContext)
{
    if(info.pAllocationsChanged != VMA_NULL)
    {
        memset(info.pAllocationsChanged, 0, info.allocationCount * sizeof(VkBool32));
    }

    *pContext = vma_new(this, VmaDefragmentationContext_T)(
        this, m_CurrentFrameIndex.load(), info.flags, pStats);

    (*pContext)->AddPools(info.poolCount, info.pPools);
    (*pContext)->AddAllocations(
        info.allocationCount, info.pAllocations, info.pAllocationsChanged);

    VkResult res = (*pContext)->Defragment(
        info.maxCpuBytesToMove, info.maxCpuAllocationsToMove,
        info.maxGpuBytesToMove, info.maxGpuAllocationsToMove,
        info.commandBuffer, pStats);

    if(res != VK_NOT_READY)
    {
        vma_delete(this, *pContext);
        *pContext = VMA_NULL;
    }

    return res;
}

VkResult VmaAllocator_T::DefragmentationEnd(
    VmaDefragmentationContext context)
{
    vma_delete(this, context);
    return VK_SUCCESS;
}

void VmaAllocator_T::GetAllocationInfo(VmaAllocation hAllocation, VmaAllocationInfo* pAllocationInfo)
{
    if(hAllocation->CanBecomeLost())
    {
        /*
        Warning: This is a carefully designed algorithm.
        Do not modify unless you really know what you're doing :)
        */
        const uint32_t localCurrFrameIndex = m_CurrentFrameIndex.load();
        uint32_t localLastUseFrameIndex = hAllocation->GetLastUseFrameIndex();
        for(;;)
        {
            if(localLastUseFrameIndex == VMA_FRAME_INDEX_LOST)
            {
                pAllocationInfo->memoryType = UINT32_MAX;
                pAllocationInfo->deviceMemory = VK_NULL_HANDLE;
                pAllocationInfo->offset = 0;
                pAllocationInfo->size = hAllocation->GetSize();
                pAllocationInfo->pMappedData = VMA_NULL;
                pAllocationInfo->pUserData = hAllocation->GetUserData();
                return;
            }
            else if(localLastUseFrameIndex == localCurrFrameIndex)
            {
                pAllocationInfo->memoryType = hAllocation->GetMemoryTypeIndex();
                pAllocationInfo->deviceMemory = hAllocation->GetMemory();
                pAllocationInfo->offset = hAllocation->GetOffset();
                pAllocationInfo->size = hAllocation->GetSize();
                pAllocationInfo->pMappedData = VMA_NULL;
                pAllocationInfo->pUserData = hAllocation->GetUserData();
                return;
            }
            else // Last use time earlier than current time.
            {
                if(hAllocation->CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, localCurrFrameIndex))
                {
                    localLastUseFrameIndex = localCurrFrameIndex;
                }
            }
        }
    }
    else
    {
#if VMA_STATS_STRING_ENABLED
        uint32_t localCurrFrameIndex = m_CurrentFrameIndex.load();
        uint32_t localLastUseFrameIndex = hAllocation->GetLastUseFrameIndex();
        for(;;)
        {
            VMA_ASSERT(localLastUseFrameIndex != VMA_FRAME_INDEX_LOST);
            if(localLastUseFrameIndex == localCurrFrameIndex)
            {
                break;
            }
            else // Last use time earlier than current time.
            {
                if(hAllocation->CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, localCurrFrameIndex))
                {
                    localLastUseFrameIndex = localCurrFrameIndex;
                }
            }
        }
#endif

        pAllocationInfo->memoryType = hAllocation->GetMemoryTypeIndex();
        pAllocationInfo->deviceMemory = hAllocation->GetMemory();
        pAllocationInfo->offset = hAllocation->GetOffset();
        pAllocationInfo->size = hAllocation->GetSize();
        pAllocationInfo->pMappedData = hAllocation->GetMappedData();
        pAllocationInfo->pUserData = hAllocation->GetUserData();
    }
}

bool VmaAllocator_T::TouchAllocation(VmaAllocation hAllocation)
{
    // This is a stripped-down version of VmaAllocator_T::GetAllocationInfo.
    if(hAllocation->CanBecomeLost())
    {
        uint32_t localCurrFrameIndex = m_CurrentFrameIndex.load();
        uint32_t localLastUseFrameIndex = hAllocation->GetLastUseFrameIndex();
        for(;;)
        {
            if(localLastUseFrameIndex == VMA_FRAME_INDEX_LOST)
            {
                return false;
            }
            else if(localLastUseFrameIndex == localCurrFrameIndex)
            {
                return true;
            }
            else // Last use time earlier than current time.
            {
                if(hAllocation->CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, localCurrFrameIndex))
                {
                    localLastUseFrameIndex = localCurrFrameIndex;
                }
            }
        }
    }
    else
    {
#if VMA_STATS_STRING_ENABLED
        uint32_t localCurrFrameIndex = m_CurrentFrameIndex.load();
        uint32_t localLastUseFrameIndex = hAllocation->GetLastUseFrameIndex();
        for(;;)
        {
            VMA_ASSERT(localLastUseFrameIndex != VMA_FRAME_INDEX_LOST);
            if(localLastUseFrameIndex == localCurrFrameIndex)
            {
                break;
            }
            else // Last use time earlier than current time.
            {
                if(hAllocation->CompareExchangeLastUseFrameIndex(localLastUseFrameIndex, localCurrFrameIndex))
                {
                    localLastUseFrameIndex = localCurrFrameIndex;
                }
            }
        }
#endif

        return true;
    }
}

VkResult VmaAllocator_T::CreatePool(const VmaPoolCreateInfo* pCreateInfo, VmaPool* pPool)
{
    VMA_DEBUG_LOG("  CreatePool: MemoryTypeIndex=%u, flags=%u", pCreateInfo->memoryTypeIndex, pCreateInfo->flags);

    VmaPoolCreateInfo newCreateInfo = *pCreateInfo;

    if(newCreateInfo.maxBlockCount == 0)
    {
        newCreateInfo.maxBlockCount = SIZE_MAX;
    }
    if(newCreateInfo.minBlockCount > newCreateInfo.maxBlockCount)
    {
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    const VkDeviceSize preferredBlockSize = CalcPreferredBlockSize(newCreateInfo.memoryTypeIndex);

    *pPool = vma_new(this, VmaPool_T)(this, newCreateInfo, preferredBlockSize);

    VkResult res = (*pPool)->m_BlockVector.CreateMinBlocks();
    if(res != VK_SUCCESS)
    {
        vma_delete(this, *pPool);
        *pPool = VMA_NULL;
        return res;
    }

    // Add to m_Pools.
    {
        VmaMutexLockWrite lock(m_PoolsMutex, m_UseMutex);
        (*pPool)->SetId(m_NextPoolId++);
        VmaVectorInsertSorted<VmaPointerLess>(m_Pools, *pPool);
    }

    return VK_SUCCESS;
}

void VmaAllocator_T::DestroyPool(VmaPool pool)
{
    // Remove from m_Pools.
    {
        VmaMutexLockWrite lock(m_PoolsMutex, m_UseMutex);
        bool success = VmaVectorRemoveSorted<VmaPointerLess>(m_Pools, pool);
        VMA_ASSERT(success && "Pool not found in Allocator.");
    }

    vma_delete(this, pool);
}

void VmaAllocator_T::GetPoolStats(VmaPool pool, VmaPoolStats* pPoolStats)
{
    pool->m_BlockVector.GetPoolStats(pPoolStats);
}

void VmaAllocator_T::SetCurrentFrameIndex(uint32_t frameIndex)
{
    m_CurrentFrameIndex.store(frameIndex);

#if VMA_MEMORY_BUDGET
    if(m_UseExtMemoryBudget)
    {
        UpdateVulkanBudget();
    }
#endif // #if VMA_MEMORY_BUDGET
}

void VmaAllocator_T::MakePoolAllocationsLost(
    VmaPool hPool,
    size_t* pLostAllocationCount)
{
    hPool->m_BlockVector.MakePoolAllocationsLost(
        m_CurrentFrameIndex.load(),
        pLostAllocationCount);
}

VkResult VmaAllocator_T::CheckPoolCorruption(VmaPool hPool)
{
    return hPool->m_BlockVector.CheckCorruption();
}

VkResult VmaAllocator_T::CheckCorruption(uint32_t memoryTypeBits)
{
    VkResult finalRes = VK_ERROR_FEATURE_NOT_PRESENT;

    // Process default pools.
    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
    {
        if(((1u << memTypeIndex) & memoryTypeBits) != 0)
        {
            VmaBlockVector* const pBlockVector = m_pBlockVectors[memTypeIndex];
            VMA_ASSERT(pBlockVector);
            VkResult localRes = pBlockVector->CheckCorruption();
            switch(localRes)
            {
            case VK_ERROR_FEATURE_NOT_PRESENT:
                break;
            case VK_SUCCESS:
                finalRes = VK_SUCCESS;
                break;
            default:
                return localRes;
            }
        }
    }

    // Process custom pools.
    {
        VmaMutexLockRead lock(m_PoolsMutex, m_UseMutex);
        for(size_t poolIndex = 0, poolCount = m_Pools.size(); poolIndex < poolCount; ++poolIndex)
        {
            if(((1u << m_Pools[poolIndex]->m_BlockVector.GetMemoryTypeIndex()) & memoryTypeBits) != 0)
            {
                VkResult localRes = m_Pools[poolIndex]->m_BlockVector.CheckCorruption();
                switch(localRes)
                {
                case VK_ERROR_FEATURE_NOT_PRESENT:
                    break;
                case VK_SUCCESS:
                    finalRes = VK_SUCCESS;
                    break;
                default:
                    return localRes;
                }
            }
        }
    }

    return finalRes;
}

void VmaAllocator_T::CreateLostAllocation(VmaAllocation* pAllocation)
{
    *pAllocation = m_AllocationObjectAllocator.Allocate();
    (*pAllocation)->Ctor(VMA_FRAME_INDEX_LOST, false);
    (*pAllocation)->InitLost();
}

VkResult VmaAllocator_T::AllocateVulkanMemory(const VkMemoryAllocateInfo* pAllocateInfo, VkDeviceMemory* pMemory)
{
    const uint32_t heapIndex = MemoryTypeIndexToHeapIndex(pAllocateInfo->memoryTypeIndex);

    // HeapSizeLimit is in effect for this heap.
    if((m_HeapSizeLimitMask & (1u << heapIndex)) != 0)
    {
        const VkDeviceSize heapSize = m_MemProps.memoryHeaps[heapIndex].size;
        VkDeviceSize blockBytes = m_Budget.m_BlockBytes[heapIndex];
        for(;;)
        {
            const VkDeviceSize blockBytesAfterAllocation = blockBytes + pAllocateInfo->allocationSize;
            if(blockBytesAfterAllocation > heapSize)
            {
                return VK_ERROR_OUT_OF_DEVICE_MEMORY;
            }
            if(m_Budget.m_BlockBytes[heapIndex].compare_exchange_strong(blockBytes, blockBytesAfterAllocation))
            {
                break;
            }
        }
    }
    else
    {
        m_Budget.m_BlockBytes[heapIndex] += pAllocateInfo->allocationSize;
    }

    // VULKAN CALL vkAllocateMemory.
    VkResult res = (*m_VulkanFunctions.vkAllocateMemory)(m_hDevice, pAllocateInfo, GetAllocationCallbacks(), pMemory);

    if(res == VK_SUCCESS)
    {
#if VMA_MEMORY_BUDGET
        ++m_Budget.m_OperationsSinceBudgetFetch;
#endif

        // Informative callback.
        if(m_DeviceMemoryCallbacks.pfnAllocate != VMA_NULL)
        {
            (*m_DeviceMemoryCallbacks.pfnAllocate)(this, pAllocateInfo->memoryTypeIndex, *pMemory, pAllocateInfo->allocationSize);
        }
    }
    else
    {
        m_Budget.m_BlockBytes[heapIndex] -= pAllocateInfo->allocationSize;
    }

    return res;
}

void VmaAllocator_T::FreeVulkanMemory(uint32_t memoryType, VkDeviceSize size, VkDeviceMemory hMemory)
{
    // Informative callback.
    if(m_DeviceMemoryCallbacks.pfnFree != VMA_NULL)
    {
        (*m_DeviceMemoryCallbacks.pfnFree)(this, memoryType, hMemory, size);
    }

    // VULKAN CALL vkFreeMemory.
    (*m_VulkanFunctions.vkFreeMemory)(m_hDevice, hMemory, GetAllocationCallbacks());

    m_Budget.m_BlockBytes[MemoryTypeIndexToHeapIndex(memoryType)] -= size;
}

VkResult VmaAllocator_T::BindVulkanBuffer(
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset,
    VkBuffer buffer,
    const void* pNext)
{
    if(pNext != VMA_NULL)
    {
#if VMA_VULKAN_VERSION >= 1001000 || VMA_BIND_MEMORY2
        if((m_UseKhrBindMemory2 || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0)) &&
            m_VulkanFunctions.vkBindBufferMemory2KHR != VMA_NULL)
        {
            VkBindBufferMemoryInfoKHR bindBufferMemoryInfo = { VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR };
            bindBufferMemoryInfo.pNext = pNext;
            bindBufferMemoryInfo.buffer = buffer;
            bindBufferMemoryInfo.memory = memory;
            bindBufferMemoryInfo.memoryOffset = memoryOffset;
            return (*m_VulkanFunctions.vkBindBufferMemory2KHR)(m_hDevice, 1, &bindBufferMemoryInfo);
        }
        else
#endif // #if VMA_VULKAN_VERSION >= 1001000 || VMA_BIND_MEMORY2
        {
            return VK_ERROR_EXTENSION_NOT_PRESENT;
        }
    }
    else
    {
        return (*m_VulkanFunctions.vkBindBufferMemory)(m_hDevice, buffer, memory, memoryOffset);
    }
}

VkResult VmaAllocator_T::BindVulkanImage(
    VkDeviceMemory memory,
    VkDeviceSize memoryOffset,
    VkImage image,
    const void* pNext)
{
    if(pNext != VMA_NULL)
    {
#if VMA_VULKAN_VERSION >= 1001000 || VMA_BIND_MEMORY2
        if((m_UseKhrBindMemory2 || m_VulkanApiVersion >= VK_MAKE_VERSION(1, 1, 0)) &&
            m_VulkanFunctions.vkBindImageMemory2KHR != VMA_NULL)
        {
            VkBindImageMemoryInfoKHR bindBufferMemoryInfo = { VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR };
            bindBufferMemoryInfo.pNext = pNext;
            bindBufferMemoryInfo.image = image;
            bindBufferMemoryInfo.memory = memory;
            bindBufferMemoryInfo.memoryOffset = memoryOffset;
            return (*m_VulkanFunctions.vkBindImageMemory2KHR)(m_hDevice, 1, &bindBufferMemoryInfo);
        }
        else
#endif // #if VMA_BIND_MEMORY2
        {
            return VK_ERROR_EXTENSION_NOT_PRESENT;
        }
    }
    else
    {
        return (*m_VulkanFunctions.vkBindImageMemory)(m_hDevice, image, memory, memoryOffset);
    }
}

VkResult VmaAllocator_T::Map(VmaAllocation hAllocation, void** ppData)
{
    if(hAllocation->CanBecomeLost())
    {
        return VK_ERROR_MEMORY_MAP_FAILED;
    }

    switch(hAllocation->GetType())
    {
    case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
        {
            VmaDeviceMemoryBlock* const pBlock = hAllocation->GetBlock();
            char *pBytes = VMA_NULL;
            VkResult res = pBlock->Map(this, 1, (void**)&pBytes);
            if(res == VK_SUCCESS)
            {
                *ppData = pBytes + (ptrdiff_t)hAllocation->GetOffset();
                hAllocation->BlockAllocMap();
            }
            return res;
        }
    case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
        return hAllocation->DedicatedAllocMap(this, ppData);
    default:
        VMA_ASSERT(0);
        return VK_ERROR_MEMORY_MAP_FAILED;
    }
}

void VmaAllocator_T::Unmap(VmaAllocation hAllocation)
{
    switch(hAllocation->GetType())
    {
    case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
        {
            VmaDeviceMemoryBlock* const pBlock = hAllocation->GetBlock();
            hAllocation->BlockAllocUnmap();
            pBlock->Unmap(this, 1);
        }
        break;
    case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
        hAllocation->DedicatedAllocUnmap(this);
        break;
    default:
        VMA_ASSERT(0);
    }
}

VkResult VmaAllocator_T::BindBufferMemory(
    VmaAllocation hAllocation,
    VkDeviceSize allocationLocalOffset,
    VkBuffer hBuffer,
    const void* pNext)
{
    VkResult res = VK_SUCCESS;
    switch(hAllocation->GetType())
    {
    case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
        res = BindVulkanBuffer(hAllocation->GetMemory(), allocationLocalOffset, hBuffer, pNext);
        break;
    case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
    {
        VmaDeviceMemoryBlock* const pBlock = hAllocation->GetBlock();
        VMA_ASSERT(pBlock && "Binding buffer to allocation that doesn't belong to any block. Is the allocation lost?");
        res = pBlock->BindBufferMemory(this, hAllocation, allocationLocalOffset, hBuffer, pNext);
        break;
    }
    default:
        VMA_ASSERT(0);
    }
    return res;
}

VkResult VmaAllocator_T::BindImageMemory(
    VmaAllocation hAllocation,
    VkDeviceSize allocationLocalOffset,
    VkImage hImage,
    const void* pNext)
{
    VkResult res = VK_SUCCESS;
    switch(hAllocation->GetType())
    {
    case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
        res = BindVulkanImage(hAllocation->GetMemory(), allocationLocalOffset, hImage, pNext);
        break;
    case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
    {
        VmaDeviceMemoryBlock* pBlock = hAllocation->GetBlock();
        VMA_ASSERT(pBlock && "Binding image to allocation that doesn't belong to any block. Is the allocation lost?");
        res = pBlock->BindImageMemory(this, hAllocation, allocationLocalOffset, hImage, pNext);
        break;
    }
    default:
        VMA_ASSERT(0);
    }
    return res;
}

void VmaAllocator_T::FlushOrInvalidateAllocation(
    VmaAllocation hAllocation,
    VkDeviceSize offset, VkDeviceSize size,
    VMA_CACHE_OPERATION op)
{
    const uint32_t memTypeIndex = hAllocation->GetMemoryTypeIndex();
    if(size > 0 && IsMemoryTypeNonCoherent(memTypeIndex))
    {
        const VkDeviceSize allocationSize = hAllocation->GetSize();
        VMA_ASSERT(offset <= allocationSize);

        const VkDeviceSize nonCoherentAtomSize = m_PhysicalDeviceProperties.limits.nonCoherentAtomSize;

        VkMappedMemoryRange memRange = { VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE };
        memRange.memory = hAllocation->GetMemory();
        
        switch(hAllocation->GetType())
        {
        case VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:
            memRange.offset = VmaAlignDown(offset, nonCoherentAtomSize);
            if(size == VK_WHOLE_SIZE)
            {
                memRange.size = allocationSize - memRange.offset;
            }
            else
            {
                VMA_ASSERT(offset + size <= allocationSize);
                memRange.size = VMA_MIN(
                    VmaAlignUp(size + (offset - memRange.offset), nonCoherentAtomSize),
                    allocationSize - memRange.offset);
            }
            break;

        case VmaAllocation_T::ALLOCATION_TYPE_BLOCK:
        {
            // 1. Still within this allocation.
            memRange.offset = VmaAlignDown(offset, nonCoherentAtomSize);
            if(size == VK_WHOLE_SIZE)
            {
                size = allocationSize - offset;
            }
            else
            {
                VMA_ASSERT(offset + size <= allocationSize);
            }
            memRange.size = VmaAlignUp(size + (offset - memRange.offset), nonCoherentAtomSize);

            // 2. Adjust to whole block.
            const VkDeviceSize allocationOffset = hAllocation->GetOffset();
            VMA_ASSERT(allocationOffset % nonCoherentAtomSize == 0);
            const VkDeviceSize blockSize = hAllocation->GetBlock()->m_pMetadata->GetSize();
            memRange.offset += allocationOffset;
            memRange.size = VMA_MIN(memRange.size, blockSize - memRange.offset);
            
            break;
        }
        
        default:
            VMA_ASSERT(0);
        }

        switch(op)
        {
        case VMA_CACHE_FLUSH:
            (*GetVulkanFunctions().vkFlushMappedMemoryRanges)(m_hDevice, 1, &memRange);
            break;
        case VMA_CACHE_INVALIDATE:
            (*GetVulkanFunctions().vkInvalidateMappedMemoryRanges)(m_hDevice, 1, &memRange);
            break;
        default:
            VMA_ASSERT(0);
        }
    }
    // else: Just ignore this call.
}

void VmaAllocator_T::FreeDedicatedMemory(const VmaAllocation allocation)
{
    VMA_ASSERT(allocation && allocation->GetType() == VmaAllocation_T::ALLOCATION_TYPE_DEDICATED);

    const uint32_t memTypeIndex = allocation->GetMemoryTypeIndex();
    {
        VmaMutexLockWrite lock(m_DedicatedAllocationsMutex[memTypeIndex], m_UseMutex);
        AllocationVectorType* const pDedicatedAllocations = m_pDedicatedAllocations[memTypeIndex];
        VMA_ASSERT(pDedicatedAllocations);
        bool success = VmaVectorRemoveSorted<VmaPointerLess>(*pDedicatedAllocations, allocation);
        VMA_ASSERT(success);
    }

    VkDeviceMemory hMemory = allocation->GetMemory();
    
    /*
    There is no need to call this, because Vulkan spec allows to skip vkUnmapMemory
    before vkFreeMemory.

    if(allocation->GetMappedData() != VMA_NULL)
    {
        (*m_VulkanFunctions.vkUnmapMemory)(m_hDevice, hMemory);
    }
    */
    
    FreeVulkanMemory(memTypeIndex, allocation->GetSize(), hMemory);

    VMA_DEBUG_LOG("    Freed DedicatedMemory MemoryTypeIndex=%u", memTypeIndex);
}

uint32_t VmaAllocator_T::CalculateGpuDefragmentationMemoryTypeBits() const
{
    VkBufferCreateInfo dummyBufCreateInfo;
    VmaFillGpuDefragmentationBufferCreateInfo(dummyBufCreateInfo);

    uint32_t memoryTypeBits = 0;

    // Create buffer.
    VkBuffer buf = VK_NULL_HANDLE;
    VkResult res = (*GetVulkanFunctions().vkCreateBuffer)(
        m_hDevice, &dummyBufCreateInfo, GetAllocationCallbacks(), &buf);
    if(res == VK_SUCCESS)
    {
        // Query for supported memory types.
        VkMemoryRequirements memReq;
        (*GetVulkanFunctions().vkGetBufferMemoryRequirements)(m_hDevice, buf, &memReq);
        memoryTypeBits = memReq.memoryTypeBits;

        // Destroy buffer.
        (*GetVulkanFunctions().vkDestroyBuffer)(m_hDevice, buf, GetAllocationCallbacks());
    }

    return memoryTypeBits;
}

#if VMA_MEMORY_BUDGET

void VmaAllocator_T::UpdateVulkanBudget()
{
    VMA_ASSERT(m_UseExtMemoryBudget);

    VkPhysicalDeviceMemoryProperties2KHR memProps = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR };

    VkPhysicalDeviceMemoryBudgetPropertiesEXT budgetProps = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT };
    memProps.pNext = &budgetProps;

    GetVulkanFunctions().vkGetPhysicalDeviceMemoryProperties2KHR(m_PhysicalDevice, &memProps);

    {
        VmaMutexLockWrite lockWrite(m_Budget.m_BudgetMutex, m_UseMutex);

        for(uint32_t heapIndex = 0; heapIndex < GetMemoryHeapCount(); ++heapIndex)
        {
            m_Budget.m_VulkanUsage[heapIndex] = budgetProps.heapUsage[heapIndex];
            m_Budget.m_VulkanBudget[heapIndex] = budgetProps.heapBudget[heapIndex];
            m_Budget.m_BlockBytesAtBudgetFetch[heapIndex] = m_Budget.m_BlockBytes[heapIndex].load();
        }
        m_Budget.m_OperationsSinceBudgetFetch = 0;
    }
}

#endif // #if VMA_MEMORY_BUDGET

void VmaAllocator_T::FillAllocation(const VmaAllocation hAllocation, uint8_t pattern)
{
    if(VMA_DEBUG_INITIALIZE_ALLOCATIONS &&
        !hAllocation->CanBecomeLost() &&
        (m_MemProps.memoryTypes[hAllocation->GetMemoryTypeIndex()].propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0)
    {
        void* pData = VMA_NULL;
        VkResult res = Map(hAllocation, &pData);
        if(res == VK_SUCCESS)
        {
            memset(pData, (int)pattern, (size_t)hAllocation->GetSize());
            FlushOrInvalidateAllocation(hAllocation, 0, VK_WHOLE_SIZE, VMA_CACHE_FLUSH);
            Unmap(hAllocation);
        }
        else
        {
            VMA_ASSERT(0 && "VMA_DEBUG_INITIALIZE_ALLOCATIONS is enabled, but couldn't map memory to fill allocation.");
        }
    }
}

uint32_t VmaAllocator_T::GetGpuDefragmentationMemoryTypeBits()
{
    uint32_t memoryTypeBits = m_GpuDefragmentationMemoryTypeBits.load();
    if(memoryTypeBits == UINT32_MAX)
    {
        memoryTypeBits = CalculateGpuDefragmentationMemoryTypeBits();
        m_GpuDefragmentationMemoryTypeBits.store(memoryTypeBits);
    }
    return memoryTypeBits;
}

#if VMA_STATS_STRING_ENABLED

void VmaAllocator_T::PrintDetailedMap(VmaJsonWriter& json)
{
    bool dedicatedAllocationsStarted = false;
    for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
    {
        VmaMutexLockRead dedicatedAllocationsLock(m_DedicatedAllocationsMutex[memTypeIndex], m_UseMutex);
        AllocationVectorType* const pDedicatedAllocVector = m_pDedicatedAllocations[memTypeIndex];
        VMA_ASSERT(pDedicatedAllocVector);
        if(pDedicatedAllocVector->empty() == false)
        {
            if(dedicatedAllocationsStarted == false)
            {
                dedicatedAllocationsStarted = true;
                json.WriteString("DedicatedAllocations");
                json.BeginObject();
            }

            json.BeginString("Type ");
            json.ContinueString(memTypeIndex);
            json.EndString();
                
            json.BeginArray();

            for(size_t i = 0; i < pDedicatedAllocVector->size(); ++i)
            {
                json.BeginObject(true);
                const VmaAllocation hAlloc = (*pDedicatedAllocVector)[i];
                hAlloc->PrintParameters(json);
                json.EndObject();
            }

            json.EndArray();
        }
    }
    if(dedicatedAllocationsStarted)
    {
        json.EndObject();
    }

    {
        bool allocationsStarted = false;
        for(uint32_t memTypeIndex = 0; memTypeIndex < GetMemoryTypeCount(); ++memTypeIndex)
        {
            if(m_pBlockVectors[memTypeIndex]->IsEmpty() == false)
            {
                if(allocationsStarted == false)
                {
                    allocationsStarted = true;
                    json.WriteString("DefaultPools");
                    json.BeginObject();
                }

                json.BeginString("Type ");
                json.ContinueString(memTypeIndex);
                json.EndString();

                m_pBlockVectors[memTypeIndex]->PrintDetailedMap(json);
            }
        }
        if(allocationsStarted)
        {
            json.EndObject();
        }
    }

    // Custom pools
    {
        VmaMutexLockRead lock(m_PoolsMutex, m_UseMutex);
        const size_t poolCount = m_Pools.size();
        if(poolCount > 0)
        {
            json.WriteString("Pools");
            json.BeginObject();
            for(size_t poolIndex = 0; poolIndex < poolCount; ++poolIndex)
            {
                json.BeginString();
                json.ContinueString(m_Pools[poolIndex]->GetId());
                json.EndString();

                m_Pools[poolIndex]->m_BlockVector.PrintDetailedMap(json);
            }
            json.EndObject();
        }
    }
}

#endif // #if VMA_STATS_STRING_ENABLED

////////////////////////////////////////////////////////////////////////////////
// Public interface

VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAllocator(
    const VmaAllocatorCreateInfo* pCreateInfo,
    VmaAllocator* pAllocator)
{
    VMA_ASSERT(pCreateInfo && pAllocator);
    VMA_ASSERT(pCreateInfo->vulkanApiVersion == 0 ||
        (VK_VERSION_MAJOR(pCreateInfo->vulkanApiVersion) == 1 && VK_VERSION_MINOR(pCreateInfo->vulkanApiVersion) <= 1));
    VMA_DEBUG_LOG("vmaCreateAllocator");
    *pAllocator = vma_new(pCreateInfo->pAllocationCallbacks, VmaAllocator_T)(pCreateInfo);
    return (*pAllocator)->Init(pCreateInfo);
}

VMA_CALL_PRE void VMA_CALL_POST vmaDestroyAllocator(
    VmaAllocator allocator)
{
    if(allocator != VK_NULL_HANDLE)
    {
        VMA_DEBUG_LOG("vmaDestroyAllocator");
        VkAllocationCallbacks allocationCallbacks = allocator->m_AllocationCallbacks;
        vma_delete(&allocationCallbacks, allocator);
    }
}

VMA_CALL_PRE void VMA_CALL_POST vmaGetPhysicalDeviceProperties(
    VmaAllocator allocator,
    const VkPhysicalDeviceProperties **ppPhysicalDeviceProperties)
{
    VMA_ASSERT(allocator && ppPhysicalDeviceProperties);
    *ppPhysicalDeviceProperties = &allocator->m_PhysicalDeviceProperties;
}

VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryProperties(
    VmaAllocator allocator,
    const VkPhysicalDeviceMemoryProperties** ppPhysicalDeviceMemoryProperties)
{
    VMA_ASSERT(allocator && ppPhysicalDeviceMemoryProperties);
    *ppPhysicalDeviceMemoryProperties = &allocator->m_MemProps;
}

VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryTypeProperties(
    VmaAllocator allocator,
    uint32_t memoryTypeIndex,
    VkMemoryPropertyFlags* pFlags)
{
    VMA_ASSERT(allocator && pFlags);
    VMA_ASSERT(memoryTypeIndex < allocator->GetMemoryTypeCount());
    *pFlags = allocator->m_MemProps.memoryTypes[memoryTypeIndex].propertyFlags;
}

VMA_CALL_PRE void VMA_CALL_POST vmaSetCurrentFrameIndex(
    VmaAllocator allocator,
    uint32_t frameIndex)
{
    VMA_ASSERT(allocator);
    VMA_ASSERT(frameIndex != VMA_FRAME_INDEX_LOST);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    allocator->SetCurrentFrameIndex(frameIndex);
}

VMA_CALL_PRE void VMA_CALL_POST vmaCalculateStats(
    VmaAllocator allocator,
    VmaStats* pStats)
{
    VMA_ASSERT(allocator && pStats);
    VMA_DEBUG_GLOBAL_MUTEX_LOCK
    allocator->CalculateStats(pStats);
}

VMA_CALL_PRE void VMA_CALL_POST vmaGetBudget(
    VmaAllocator allocator,
    VmaBudget* pBudget)
{
    VMA_ASSERT(allocator && pBudget);
    VMA_DEBUG_GLOBAL_MUTEX_LOCK
    allocator->GetBudget(pBudget, 0, allocator->GetMemoryHeapCount());
}

#if VMA_STATS_STRING_ENABLED

VMA_CALL_PRE void VMA_CALL_POST vmaBuildStatsString(
    VmaAllocator allocator,
    char** ppStatsString,
    VkBool32 detailedMap)
{
    VMA_ASSERT(allocator && ppStatsString);
    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    VmaStringBuilder sb(allocator);
    {
        VmaJsonWriter json(allocator->GetAllocationCallbacks(), sb);
        json.BeginObject();

        VmaBudget budget[VK_MAX_MEMORY_HEAPS];
        allocator->GetBudget(budget, 0, allocator->GetMemoryHeapCount());

        VmaStats stats;
        allocator->CalculateStats(&stats);

        json.WriteString("Total");
        VmaPrintStatInfo(json, stats.total);
    
        for(uint32_t heapIndex = 0; heapIndex < allocator->GetMemoryHeapCount(); ++heapIndex)
        {
            json.BeginString("Heap ");
            json.ContinueString(heapIndex);
            json.EndString();
            json.BeginObject();

            json.WriteString("Size");
            json.WriteNumber(allocator->m_MemProps.memoryHeaps[heapIndex].size);

            json.WriteString("Flags");
            json.BeginArray(true);
            if((allocator->m_MemProps.memoryHeaps[heapIndex].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT) != 0)
            {
                json.WriteString("DEVICE_LOCAL");
            }
            json.EndArray();

            json.WriteString("Budget");
            json.BeginObject();
            {
                json.WriteString("BlockBytes");
                json.WriteNumber(budget[heapIndex].blockBytes);
                json.WriteString("AllocationBytes");
                json.WriteNumber(budget[heapIndex].allocationBytes);
                json.WriteString("Usage");
                json.WriteNumber(budget[heapIndex].usage);
                json.WriteString("Budget");
                json.WriteNumber(budget[heapIndex].budget);
            }
            json.EndObject();

            if(stats.memoryHeap[heapIndex].blockCount > 0)
            {
                json.WriteString("Stats");
                VmaPrintStatInfo(json, stats.memoryHeap[heapIndex]);
            }

            for(uint32_t typeIndex = 0; typeIndex < allocator->GetMemoryTypeCount(); ++typeIndex)
            {
                if(allocator->MemoryTypeIndexToHeapIndex(typeIndex) == heapIndex)
                {
                    json.BeginString("Type ");
                    json.ContinueString(typeIndex);
                    json.EndString();

                    json.BeginObject();

                    json.WriteString("Flags");
                    json.BeginArray(true);
                    VkMemoryPropertyFlags flags = allocator->m_MemProps.memoryTypes[typeIndex].propertyFlags;
                    if((flags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) != 0)
                    {
                        json.WriteString("DEVICE_LOCAL");
                    }
                    if((flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0)
                    {
                        json.WriteString("HOST_VISIBLE");
                    }
                    if((flags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) != 0)
                    {
                        json.WriteString("HOST_COHERENT");
                    }
                    if((flags & VK_MEMORY_PROPERTY_HOST_CACHED_BIT) != 0)
                    {
                        json.WriteString("HOST_CACHED");
                    }
                    if((flags & VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT) != 0)
                    {
                        json.WriteString("LAZILY_ALLOCATED");
                    }
                    json.EndArray();

                    if(stats.memoryType[typeIndex].blockCount > 0)
                    {
                        json.WriteString("Stats");
                        VmaPrintStatInfo(json, stats.memoryType[typeIndex]);
                    }

                    json.EndObject();
                }
            }

            json.EndObject();
        }
        if(detailedMap == VK_TRUE)
        {
            allocator->PrintDetailedMap(json);
        }

        json.EndObject();
    }

    const size_t len = sb.GetLength();
    char* const pChars = vma_new_array(allocator, char, len + 1);
    if(len > 0)
    {
        memcpy(pChars, sb.GetData(), len);
    }
    pChars[len] = '\0';
    *ppStatsString = pChars;
}

VMA_CALL_PRE void VMA_CALL_POST vmaFreeStatsString(
    VmaAllocator allocator,
    char* pStatsString)
{
    if(pStatsString != VMA_NULL)
    {
        VMA_ASSERT(allocator);
        size_t len = strlen(pStatsString);
        vma_delete_array(allocator, pStatsString, len + 1);
    }
}

#endif // #if VMA_STATS_STRING_ENABLED

/*
This function is not protected by any mutex because it just reads immutable data.
*/
VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndex(
    VmaAllocator allocator,
    uint32_t memoryTypeBits,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    uint32_t* pMemoryTypeIndex)
{
    VMA_ASSERT(allocator != VK_NULL_HANDLE);
    VMA_ASSERT(pAllocationCreateInfo != VMA_NULL);
    VMA_ASSERT(pMemoryTypeIndex != VMA_NULL);

    if(pAllocationCreateInfo->memoryTypeBits != 0)
    {
        memoryTypeBits &= pAllocationCreateInfo->memoryTypeBits;
    }
    
    uint32_t requiredFlags = pAllocationCreateInfo->requiredFlags;
    uint32_t preferredFlags = pAllocationCreateInfo->preferredFlags;
    uint32_t notPreferredFlags = 0;

    // Convert usage to requiredFlags and preferredFlags.
    switch(pAllocationCreateInfo->usage)
    {
    case VMA_MEMORY_USAGE_UNKNOWN:
        break;
    case VMA_MEMORY_USAGE_GPU_ONLY:
        if(!allocator->IsIntegratedGpu() || (preferredFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
        {
            preferredFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
        }
        break;
    case VMA_MEMORY_USAGE_CPU_ONLY:
        requiredFlags |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
        break;
    case VMA_MEMORY_USAGE_CPU_TO_GPU:
        requiredFlags |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
        if(!allocator->IsIntegratedGpu() || (preferredFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0)
        {
            preferredFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
        }
        break;
    case VMA_MEMORY_USAGE_GPU_TO_CPU:
        requiredFlags |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
        preferredFlags |= VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
        break;
    case VMA_MEMORY_USAGE_CPU_COPY:
        notPreferredFlags |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
        break;
    case VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED:
        requiredFlags |= VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;
        break;
    default:
        VMA_ASSERT(0);
        break;
    }

    *pMemoryTypeIndex = UINT32_MAX;
    uint32_t minCost = UINT32_MAX;
    for(uint32_t memTypeIndex = 0, memTypeBit = 1;
        memTypeIndex < allocator->GetMemoryTypeCount();
        ++memTypeIndex, memTypeBit <<= 1)
    {
        // This memory type is acceptable according to memoryTypeBits bitmask.
        if((memTypeBit & memoryTypeBits) != 0)
        {
            const VkMemoryPropertyFlags currFlags =
                allocator->m_MemProps.memoryTypes[memTypeIndex].propertyFlags;
            // This memory type contains requiredFlags.
            if((requiredFlags & ~currFlags) == 0)
            {
                // Calculate cost as number of bits from preferredFlags not present in this memory type.
                uint32_t currCost = VmaCountBitsSet(preferredFlags & ~currFlags) +
                    VmaCountBitsSet(currFlags & notPreferredFlags);
                // Remember memory type with lowest cost.
                if(currCost < minCost)
                {
                    *pMemoryTypeIndex = memTypeIndex;
                    if(currCost == 0)
                    {
                        return VK_SUCCESS;
                    }
                    minCost = currCost;
                }
            }
        }
    }
    return (*pMemoryTypeIndex != UINT32_MAX) ? VK_SUCCESS : VK_ERROR_FEATURE_NOT_PRESENT;
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForBufferInfo(
    VmaAllocator allocator,
    const VkBufferCreateInfo* pBufferCreateInfo,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    uint32_t* pMemoryTypeIndex)
{
    VMA_ASSERT(allocator != VK_NULL_HANDLE);
    VMA_ASSERT(pBufferCreateInfo != VMA_NULL);
    VMA_ASSERT(pAllocationCreateInfo != VMA_NULL);
    VMA_ASSERT(pMemoryTypeIndex != VMA_NULL);

    const VkDevice hDev = allocator->m_hDevice;
    VkBuffer hBuffer = VK_NULL_HANDLE;
    VkResult res = allocator->GetVulkanFunctions().vkCreateBuffer(
        hDev, pBufferCreateInfo, allocator->GetAllocationCallbacks(), &hBuffer);
    if(res == VK_SUCCESS)
    {
        VkMemoryRequirements memReq = {};
        allocator->GetVulkanFunctions().vkGetBufferMemoryRequirements(
            hDev, hBuffer, &memReq);

        res = vmaFindMemoryTypeIndex(
            allocator,
            memReq.memoryTypeBits,
            pAllocationCreateInfo,
            pMemoryTypeIndex);

        allocator->GetVulkanFunctions().vkDestroyBuffer(
            hDev, hBuffer, allocator->GetAllocationCallbacks());
    }
    return res;
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForImageInfo(
    VmaAllocator allocator,
    const VkImageCreateInfo* pImageCreateInfo,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    uint32_t* pMemoryTypeIndex)
{
    VMA_ASSERT(allocator != VK_NULL_HANDLE);
    VMA_ASSERT(pImageCreateInfo != VMA_NULL);
    VMA_ASSERT(pAllocationCreateInfo != VMA_NULL);
    VMA_ASSERT(pMemoryTypeIndex != VMA_NULL);

    const VkDevice hDev = allocator->m_hDevice;
    VkImage hImage = VK_NULL_HANDLE;
    VkResult res = allocator->GetVulkanFunctions().vkCreateImage(
        hDev, pImageCreateInfo, allocator->GetAllocationCallbacks(), &hImage);
    if(res == VK_SUCCESS)
    {
        VkMemoryRequirements memReq = {};
        allocator->GetVulkanFunctions().vkGetImageMemoryRequirements(
            hDev, hImage, &memReq);

        res = vmaFindMemoryTypeIndex(
            allocator,
            memReq.memoryTypeBits,
            pAllocationCreateInfo,
            pMemoryTypeIndex);

        allocator->GetVulkanFunctions().vkDestroyImage(
            hDev, hImage, allocator->GetAllocationCallbacks());
    }
    return res;
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreatePool(
	VmaAllocator allocator,
	const VmaPoolCreateInfo* pCreateInfo,
	VmaPool* pPool)
{
    VMA_ASSERT(allocator && pCreateInfo && pPool);
    
    VMA_DEBUG_LOG("vmaCreatePool");
    
    VMA_DEBUG_GLOBAL_MUTEX_LOCK
    
    VkResult res = allocator->CreatePool(pCreateInfo, pPool);
    
#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordCreatePool(allocator->GetCurrentFrameIndex(), *pCreateInfo, *pPool);
    }
#endif
    
    return res;
}

VMA_CALL_PRE void VMA_CALL_POST vmaDestroyPool(
    VmaAllocator allocator,
    VmaPool pool)
{
    VMA_ASSERT(allocator);
    
    if(pool == VK_NULL_HANDLE)
    {
        return;
    }
    
    VMA_DEBUG_LOG("vmaDestroyPool");
    
    VMA_DEBUG_GLOBAL_MUTEX_LOCK
    
#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordDestroyPool(allocator->GetCurrentFrameIndex(), pool);
    }
#endif

    allocator->DestroyPool(pool);
}

VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolStats(
    VmaAllocator allocator,
    VmaPool pool,
    VmaPoolStats* pPoolStats)
{
    VMA_ASSERT(allocator && pool && pPoolStats);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    allocator->GetPoolStats(pool, pPoolStats);
}

VMA_CALL_PRE void VMA_CALL_POST vmaMakePoolAllocationsLost(
    VmaAllocator allocator,
    VmaPool pool,
    size_t* pLostAllocationCount)
{
    VMA_ASSERT(allocator && pool);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordMakePoolAllocationsLost(allocator->GetCurrentFrameIndex(), pool);
    }
#endif

    allocator->MakePoolAllocationsLost(pool, pLostAllocationCount);
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckPoolCorruption(VmaAllocator allocator, VmaPool pool)
{
    VMA_ASSERT(allocator && pool);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    VMA_DEBUG_LOG("vmaCheckPoolCorruption");

    return allocator->CheckPoolCorruption(pool);
}

VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolName(
    VmaAllocator allocator,
    VmaPool pool,
    const char** ppName)
{
    VMA_ASSERT(allocator && pool);
    
    VMA_DEBUG_LOG("vmaGetPoolName");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    *ppName = pool->GetName();
}

VMA_CALL_PRE void VMA_CALL_POST vmaSetPoolName(
    VmaAllocator allocator,
    VmaPool pool,
    const char* pName)
{
    VMA_ASSERT(allocator && pool);

    VMA_DEBUG_LOG("vmaSetPoolName");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    pool->SetName(pName);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordSetPoolName(allocator->GetCurrentFrameIndex(), pool, pName);
    }
#endif
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemory(
    VmaAllocator allocator,
    const VkMemoryRequirements* pVkMemoryRequirements,
    const VmaAllocationCreateInfo* pCreateInfo,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo)
{
    VMA_ASSERT(allocator && pVkMemoryRequirements && pCreateInfo && pAllocation);

    VMA_DEBUG_LOG("vmaAllocateMemory");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

	VkResult result = allocator->AllocateMemory(
        *pVkMemoryRequirements,
        false, // requiresDedicatedAllocation
        false, // prefersDedicatedAllocation
        VK_NULL_HANDLE, // dedicatedBuffer
        VK_NULL_HANDLE, // dedicatedImage
        *pCreateInfo,
        VMA_SUBALLOCATION_TYPE_UNKNOWN,
        1, // allocationCount
        pAllocation);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordAllocateMemory(
            allocator->GetCurrentFrameIndex(),
            *pVkMemoryRequirements,
            *pCreateInfo,
            *pAllocation);
    }
#endif
        
    if(pAllocationInfo != VMA_NULL && result == VK_SUCCESS)
    {
        allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
    }

	return result;
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryPages(
    VmaAllocator allocator,
    const VkMemoryRequirements* pVkMemoryRequirements,
    const VmaAllocationCreateInfo* pCreateInfo,
    size_t allocationCount,
    VmaAllocation* pAllocations,
    VmaAllocationInfo* pAllocationInfo)
{
    if(allocationCount == 0)
    {
        return VK_SUCCESS;
    }

    VMA_ASSERT(allocator && pVkMemoryRequirements && pCreateInfo && pAllocations);

    VMA_DEBUG_LOG("vmaAllocateMemoryPages");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

	VkResult result = allocator->AllocateMemory(
        *pVkMemoryRequirements,
        false, // requiresDedicatedAllocation
        false, // prefersDedicatedAllocation
        VK_NULL_HANDLE, // dedicatedBuffer
        VK_NULL_HANDLE, // dedicatedImage
        *pCreateInfo,
        VMA_SUBALLOCATION_TYPE_UNKNOWN,
        allocationCount,
        pAllocations);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordAllocateMemoryPages(
            allocator->GetCurrentFrameIndex(),
            *pVkMemoryRequirements,
            *pCreateInfo,
            (uint64_t)allocationCount,
            pAllocations);
    }
#endif
        
    if(pAllocationInfo != VMA_NULL && result == VK_SUCCESS)
    {
        for(size_t i = 0; i < allocationCount; ++i)
        {
            allocator->GetAllocationInfo(pAllocations[i], pAllocationInfo + i);
        }
    }

	return result;
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForBuffer(
    VmaAllocator allocator,
    VkBuffer buffer,
    const VmaAllocationCreateInfo* pCreateInfo,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo)
{
    VMA_ASSERT(allocator && buffer != VK_NULL_HANDLE && pCreateInfo && pAllocation);

    VMA_DEBUG_LOG("vmaAllocateMemoryForBuffer");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    VkMemoryRequirements vkMemReq = {};
    bool requiresDedicatedAllocation = false;
    bool prefersDedicatedAllocation = false;
    allocator->GetBufferMemoryRequirements(buffer, vkMemReq,
        requiresDedicatedAllocation,
        prefersDedicatedAllocation);

    VkResult result = allocator->AllocateMemory(
        vkMemReq,
        requiresDedicatedAllocation,
        prefersDedicatedAllocation,
        buffer, // dedicatedBuffer
        VK_NULL_HANDLE, // dedicatedImage
        *pCreateInfo,
        VMA_SUBALLOCATION_TYPE_BUFFER,
        1, // allocationCount
        pAllocation);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordAllocateMemoryForBuffer(
            allocator->GetCurrentFrameIndex(),
            vkMemReq,
            requiresDedicatedAllocation,
            prefersDedicatedAllocation,
            *pCreateInfo,
            *pAllocation);
    }
#endif

    if(pAllocationInfo && result == VK_SUCCESS)
    {
        allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
    }

	return result;
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForImage(
    VmaAllocator allocator,
    VkImage image,
    const VmaAllocationCreateInfo* pCreateInfo,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo)
{
    VMA_ASSERT(allocator && image != VK_NULL_HANDLE && pCreateInfo && pAllocation);

    VMA_DEBUG_LOG("vmaAllocateMemoryForImage");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    VkMemoryRequirements vkMemReq = {};
    bool requiresDedicatedAllocation = false;
    bool prefersDedicatedAllocation  = false;
    allocator->GetImageMemoryRequirements(image, vkMemReq,
        requiresDedicatedAllocation, prefersDedicatedAllocation);

    VkResult result = allocator->AllocateMemory(
        vkMemReq,
        requiresDedicatedAllocation,
        prefersDedicatedAllocation,
        VK_NULL_HANDLE, // dedicatedBuffer
        image, // dedicatedImage
        *pCreateInfo,
        VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN,
        1, // allocationCount
        pAllocation);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordAllocateMemoryForImage(
            allocator->GetCurrentFrameIndex(),
            vkMemReq,
            requiresDedicatedAllocation,
            prefersDedicatedAllocation,
            *pCreateInfo,
            *pAllocation);
    }
#endif

    if(pAllocationInfo && result == VK_SUCCESS)
    {
        allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
    }

	return result;
}

VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemory(
    VmaAllocator allocator,
    VmaAllocation allocation)
{
    VMA_ASSERT(allocator);
    
    if(allocation == VK_NULL_HANDLE)
    {
        return;
    }
    
    VMA_DEBUG_LOG("vmaFreeMemory");
    
    VMA_DEBUG_GLOBAL_MUTEX_LOCK

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordFreeMemory(
            allocator->GetCurrentFrameIndex(),
            allocation);
    }
#endif
    
    allocator->FreeMemory(
        1, // allocationCount
        &allocation);
}

VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemoryPages(
    VmaAllocator allocator,
    size_t allocationCount,
    VmaAllocation* pAllocations)
{
    if(allocationCount == 0)
    {
        return;
    }

    VMA_ASSERT(allocator);
    
    VMA_DEBUG_LOG("vmaFreeMemoryPages");
    
    VMA_DEBUG_GLOBAL_MUTEX_LOCK

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordFreeMemoryPages(
            allocator->GetCurrentFrameIndex(),
            (uint64_t)allocationCount,
            pAllocations);
    }
#endif
    
    allocator->FreeMemory(allocationCount, pAllocations);
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaResizeAllocation(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkDeviceSize newSize)
{
    VMA_ASSERT(allocator && allocation);
    
    VMA_DEBUG_LOG("vmaResizeAllocation");
    
    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    return allocator->ResizeAllocation(allocation, newSize);
}

VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationInfo(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VmaAllocationInfo* pAllocationInfo)
{
    VMA_ASSERT(allocator && allocation && pAllocationInfo);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordGetAllocationInfo(
            allocator->GetCurrentFrameIndex(),
            allocation);
    }
#endif

    allocator->GetAllocationInfo(allocation, pAllocationInfo);
}

VMA_CALL_PRE VkBool32 VMA_CALL_POST vmaTouchAllocation(
    VmaAllocator allocator,
    VmaAllocation allocation)
{
    VMA_ASSERT(allocator && allocation);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordTouchAllocation(
            allocator->GetCurrentFrameIndex(),
            allocation);
    }
#endif

    return allocator->TouchAllocation(allocation);
}

VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationUserData(
    VmaAllocator allocator,
    VmaAllocation allocation,
    void* pUserData)
{
    VMA_ASSERT(allocator && allocation);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    allocation->SetUserData(allocator, pUserData);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordSetAllocationUserData(
            allocator->GetCurrentFrameIndex(),
            allocation,
            pUserData);
    }
#endif
}

VMA_CALL_PRE void VMA_CALL_POST vmaCreateLostAllocation(
    VmaAllocator allocator,
    VmaAllocation* pAllocation)
{
    VMA_ASSERT(allocator && pAllocation);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK;

    allocator->CreateLostAllocation(pAllocation);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordCreateLostAllocation(
            allocator->GetCurrentFrameIndex(),
            *pAllocation);
    }
#endif
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaMapMemory(
    VmaAllocator allocator,
    VmaAllocation allocation,
    void** ppData)
{
    VMA_ASSERT(allocator && allocation && ppData);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    VkResult res = allocator->Map(allocation, ppData);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordMapMemory(
            allocator->GetCurrentFrameIndex(),
            allocation);
    }
#endif

    return res;
}

VMA_CALL_PRE void VMA_CALL_POST vmaUnmapMemory(
    VmaAllocator allocator,
    VmaAllocation allocation)
{
    VMA_ASSERT(allocator && allocation);

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordUnmapMemory(
            allocator->GetCurrentFrameIndex(),
            allocation);
    }
#endif

    allocator->Unmap(allocation);
}

VMA_CALL_PRE void VMA_CALL_POST vmaFlushAllocation(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)
{
    VMA_ASSERT(allocator && allocation);

    VMA_DEBUG_LOG("vmaFlushAllocation");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    allocator->FlushOrInvalidateAllocation(allocation, offset, size, VMA_CACHE_FLUSH);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordFlushAllocation(
            allocator->GetCurrentFrameIndex(),
            allocation, offset, size);
    }
#endif
}

VMA_CALL_PRE void VMA_CALL_POST vmaInvalidateAllocation(VmaAllocator allocator, VmaAllocation allocation, VkDeviceSize offset, VkDeviceSize size)
{
    VMA_ASSERT(allocator && allocation);

    VMA_DEBUG_LOG("vmaInvalidateAllocation");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    allocator->FlushOrInvalidateAllocation(allocation, offset, size, VMA_CACHE_INVALIDATE);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordInvalidateAllocation(
            allocator->GetCurrentFrameIndex(),
            allocation, offset, size);
    }
#endif
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckCorruption(VmaAllocator allocator, uint32_t memoryTypeBits)
{
    VMA_ASSERT(allocator);

    VMA_DEBUG_LOG("vmaCheckCorruption");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    return allocator->CheckCorruption(memoryTypeBits);
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragment(
    VmaAllocator allocator,
    VmaAllocation* pAllocations,
    size_t allocationCount,
    VkBool32* pAllocationsChanged,
    const VmaDefragmentationInfo *pDefragmentationInfo,
    VmaDefragmentationStats* pDefragmentationStats)
{
    // Deprecated interface, reimplemented using new one.

    VmaDefragmentationInfo2 info2 = {};
    info2.allocationCount = (uint32_t)allocationCount;
    info2.pAllocations = pAllocations;
    info2.pAllocationsChanged = pAllocationsChanged;
    if(pDefragmentationInfo != VMA_NULL)
    {
        info2.maxCpuAllocationsToMove = pDefragmentationInfo->maxAllocationsToMove;
        info2.maxCpuBytesToMove = pDefragmentationInfo->maxBytesToMove;
    }
    else
    {
        info2.maxCpuAllocationsToMove = UINT32_MAX;
        info2.maxCpuBytesToMove = VK_WHOLE_SIZE;
    }
    // info2.flags, maxGpuAllocationsToMove, maxGpuBytesToMove, commandBuffer deliberately left zero.

    VmaDefragmentationContext ctx;
    VkResult res = vmaDefragmentationBegin(allocator, &info2, pDefragmentationStats, &ctx);
    if(res == VK_NOT_READY)
    {
        res = vmaDefragmentationEnd( allocator, ctx);
    }
    return res;
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragmentationBegin(
    VmaAllocator allocator,
    const VmaDefragmentationInfo2* pInfo,
    VmaDefragmentationStats* pStats,
    VmaDefragmentationContext *pContext)
{
    VMA_ASSERT(allocator && pInfo && pContext);

    // Degenerate case: Nothing to defragment.
    if(pInfo->allocationCount == 0 && pInfo->poolCount == 0)
    {
        return VK_SUCCESS;
    }

    VMA_ASSERT(pInfo->allocationCount == 0 || pInfo->pAllocations != VMA_NULL);
    VMA_ASSERT(pInfo->poolCount == 0 || pInfo->pPools != VMA_NULL);
    VMA_HEAVY_ASSERT(VmaValidatePointerArray(pInfo->allocationCount, pInfo->pAllocations));
    VMA_HEAVY_ASSERT(VmaValidatePointerArray(pInfo->poolCount, pInfo->pPools));

    VMA_DEBUG_LOG("vmaDefragmentationBegin");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    VkResult res = allocator->DefragmentationBegin(*pInfo, pStats, pContext);

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordDefragmentationBegin(
            allocator->GetCurrentFrameIndex(), *pInfo, *pContext);
    }
#endif

    return res;
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaDefragmentationEnd(
    VmaAllocator allocator,
    VmaDefragmentationContext context)
{
    VMA_ASSERT(allocator);

    VMA_DEBUG_LOG("vmaDefragmentationEnd");

    if(context != VK_NULL_HANDLE)
    {
        VMA_DEBUG_GLOBAL_MUTEX_LOCK

#if VMA_RECORDING_ENABLED
        if(allocator->GetRecorder() != VMA_NULL)
        {
            allocator->GetRecorder()->RecordDefragmentationEnd(
                allocator->GetCurrentFrameIndex(), context);
        }
#endif

        return allocator->DefragmentationEnd(context);
    }
    else
    {
        return VK_SUCCESS;
    }
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkBuffer buffer)
{
    VMA_ASSERT(allocator && allocation && buffer);

    VMA_DEBUG_LOG("vmaBindBufferMemory");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    return allocator->BindBufferMemory(allocation, 0, buffer, VMA_NULL);
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory2(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkDeviceSize allocationLocalOffset,
    VkBuffer buffer,
    const void* pNext)
{
    VMA_ASSERT(allocator && allocation && buffer);

    VMA_DEBUG_LOG("vmaBindBufferMemory2");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    return allocator->BindBufferMemory(allocation, allocationLocalOffset, buffer, pNext);
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkImage image)
{
    VMA_ASSERT(allocator && allocation && image);

    VMA_DEBUG_LOG("vmaBindImageMemory");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    return allocator->BindImageMemory(allocation, 0, image, VMA_NULL);
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory2(
    VmaAllocator allocator,
    VmaAllocation allocation,
    VkDeviceSize allocationLocalOffset,
    VkImage image,
    const void* pNext)
{
    VMA_ASSERT(allocator && allocation && image);

    VMA_DEBUG_LOG("vmaBindImageMemory2");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

        return allocator->BindImageMemory(allocation, allocationLocalOffset, image, pNext);
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBuffer(
    VmaAllocator allocator,
    const VkBufferCreateInfo* pBufferCreateInfo,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    VkBuffer* pBuffer,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo)
{
    VMA_ASSERT(allocator && pBufferCreateInfo && pAllocationCreateInfo && pBuffer && pAllocation);

    if(pBufferCreateInfo->size == 0)
    {
        return VK_ERROR_VALIDATION_FAILED_EXT;
    }
    
    VMA_DEBUG_LOG("vmaCreateBuffer");
    
    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    *pBuffer = VK_NULL_HANDLE;
    *pAllocation = VK_NULL_HANDLE;

    // 1. Create VkBuffer.
    VkResult res = (*allocator->GetVulkanFunctions().vkCreateBuffer)(
        allocator->m_hDevice,
        pBufferCreateInfo,
        allocator->GetAllocationCallbacks(),
        pBuffer);
    if(res >= 0)
    {
        // 2. vkGetBufferMemoryRequirements.
        VkMemoryRequirements vkMemReq = {};
        bool requiresDedicatedAllocation = false;
        bool prefersDedicatedAllocation  = false;
        allocator->GetBufferMemoryRequirements(*pBuffer, vkMemReq,
            requiresDedicatedAllocation, prefersDedicatedAllocation);

        // Make sure alignment requirements for specific buffer usages reported
        // in Physical Device Properties are included in alignment reported by memory requirements.
        if((pBufferCreateInfo->usage & VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT) != 0)
        {
           VMA_ASSERT(vkMemReq.alignment %
              allocator->m_PhysicalDeviceProperties.limits.minTexelBufferOffsetAlignment == 0);
        }
        if((pBufferCreateInfo->usage & VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT) != 0)
        {
           VMA_ASSERT(vkMemReq.alignment %
              allocator->m_PhysicalDeviceProperties.limits.minUniformBufferOffsetAlignment == 0);
        }
        if((pBufferCreateInfo->usage & VK_BUFFER_USAGE_STORAGE_BUFFER_BIT) != 0)
        {
           VMA_ASSERT(vkMemReq.alignment %
              allocator->m_PhysicalDeviceProperties.limits.minStorageBufferOffsetAlignment == 0);
        }

        // 3. Allocate memory using allocator.
        res = allocator->AllocateMemory(
            vkMemReq,
            requiresDedicatedAllocation,
            prefersDedicatedAllocation,
            *pBuffer, // dedicatedBuffer
            VK_NULL_HANDLE, // dedicatedImage
            *pAllocationCreateInfo,
            VMA_SUBALLOCATION_TYPE_BUFFER,
            1, // allocationCount
            pAllocation);

#if VMA_RECORDING_ENABLED
        if(allocator->GetRecorder() != VMA_NULL)
        {
            allocator->GetRecorder()->RecordCreateBuffer(
                allocator->GetCurrentFrameIndex(),
                *pBufferCreateInfo,
                *pAllocationCreateInfo,
                *pAllocation);
        }
#endif

        if(res >= 0)
        {
            // 3. Bind buffer with memory.
            if((pAllocationCreateInfo->flags & VMA_ALLOCATION_CREATE_DONT_BIND_BIT) == 0)
            {
                res = allocator->BindBufferMemory(*pAllocation, 0, *pBuffer, VMA_NULL);
            }
            if(res >= 0)
            {
                // All steps succeeded.
                #if VMA_STATS_STRING_ENABLED
                    (*pAllocation)->InitBufferImageUsage(pBufferCreateInfo->usage);
                #endif
                if(pAllocationInfo != VMA_NULL)
                {
                    allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
                }

                return VK_SUCCESS;
            }
            allocator->FreeMemory(
                1, // allocationCount
                pAllocation);
            *pAllocation = VK_NULL_HANDLE;
            (*allocator->GetVulkanFunctions().vkDestroyBuffer)(allocator->m_hDevice, *pBuffer, allocator->GetAllocationCallbacks());
            *pBuffer = VK_NULL_HANDLE;
            return res;
        }
        (*allocator->GetVulkanFunctions().vkDestroyBuffer)(allocator->m_hDevice, *pBuffer, allocator->GetAllocationCallbacks());
        *pBuffer = VK_NULL_HANDLE;
        return res;
    }
    return res;
}

VMA_CALL_PRE void VMA_CALL_POST vmaDestroyBuffer(
    VmaAllocator allocator,
    VkBuffer buffer,
    VmaAllocation allocation)
{
    VMA_ASSERT(allocator);

    if(buffer == VK_NULL_HANDLE && allocation == VK_NULL_HANDLE)
    {
        return;
    }

    VMA_DEBUG_LOG("vmaDestroyBuffer");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordDestroyBuffer(
            allocator->GetCurrentFrameIndex(),
            allocation);
    }
#endif

    if(buffer != VK_NULL_HANDLE)
    {
        (*allocator->GetVulkanFunctions().vkDestroyBuffer)(allocator->m_hDevice, buffer, allocator->GetAllocationCallbacks());
    }

    if(allocation != VK_NULL_HANDLE)
    {
        allocator->FreeMemory(
            1, // allocationCount
            &allocation);
    }
}

VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateImage(
    VmaAllocator allocator,
    const VkImageCreateInfo* pImageCreateInfo,
    const VmaAllocationCreateInfo* pAllocationCreateInfo,
    VkImage* pImage,
    VmaAllocation* pAllocation,
    VmaAllocationInfo* pAllocationInfo)
{
    VMA_ASSERT(allocator && pImageCreateInfo && pAllocationCreateInfo && pImage && pAllocation);

    if(pImageCreateInfo->extent.width == 0 ||
        pImageCreateInfo->extent.height == 0 ||
        pImageCreateInfo->extent.depth == 0 ||
        pImageCreateInfo->mipLevels == 0 ||
        pImageCreateInfo->arrayLayers == 0)
    {
        return VK_ERROR_VALIDATION_FAILED_EXT;
    }

    VMA_DEBUG_LOG("vmaCreateImage");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

    *pImage = VK_NULL_HANDLE;
    *pAllocation = VK_NULL_HANDLE;

    // 1. Create VkImage.
    VkResult res = (*allocator->GetVulkanFunctions().vkCreateImage)(
        allocator->m_hDevice,
        pImageCreateInfo,
        allocator->GetAllocationCallbacks(),
        pImage);
    if(res >= 0)
    {
        VmaSuballocationType suballocType = pImageCreateInfo->tiling == VK_IMAGE_TILING_OPTIMAL ?
            VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL :
            VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR;
        
        // 2. Allocate memory using allocator.
        VkMemoryRequirements vkMemReq = {};
        bool requiresDedicatedAllocation = false;
        bool prefersDedicatedAllocation  = false;
        allocator->GetImageMemoryRequirements(*pImage, vkMemReq,
            requiresDedicatedAllocation, prefersDedicatedAllocation);

        res = allocator->AllocateMemory(
            vkMemReq,
            requiresDedicatedAllocation,
            prefersDedicatedAllocation,
            VK_NULL_HANDLE, // dedicatedBuffer
            *pImage, // dedicatedImage
            *pAllocationCreateInfo,
            suballocType,
            1, // allocationCount
            pAllocation);

#if VMA_RECORDING_ENABLED
        if(allocator->GetRecorder() != VMA_NULL)
        {
            allocator->GetRecorder()->RecordCreateImage(
                allocator->GetCurrentFrameIndex(),
                *pImageCreateInfo,
                *pAllocationCreateInfo,
                *pAllocation);
        }
#endif

        if(res >= 0)
        {
            // 3. Bind image with memory.
            if((pAllocationCreateInfo->flags & VMA_ALLOCATION_CREATE_DONT_BIND_BIT) == 0)
            {
                res = allocator->BindImageMemory(*pAllocation, 0, *pImage, VMA_NULL);
            }
            if(res >= 0)
            {
                // All steps succeeded.
                #if VMA_STATS_STRING_ENABLED
                    (*pAllocation)->InitBufferImageUsage(pImageCreateInfo->usage);
                #endif
                if(pAllocationInfo != VMA_NULL)
                {
                    allocator->GetAllocationInfo(*pAllocation, pAllocationInfo);
                }

                return VK_SUCCESS;
            }
            allocator->FreeMemory(
                1, // allocationCount
                pAllocation);
            *pAllocation = VK_NULL_HANDLE;
            (*allocator->GetVulkanFunctions().vkDestroyImage)(allocator->m_hDevice, *pImage, allocator->GetAllocationCallbacks());
            *pImage = VK_NULL_HANDLE;
            return res;
        }
        (*allocator->GetVulkanFunctions().vkDestroyImage)(allocator->m_hDevice, *pImage, allocator->GetAllocationCallbacks());
        *pImage = VK_NULL_HANDLE;
        return res;
    }
    return res;
}

VMA_CALL_PRE void VMA_CALL_POST vmaDestroyImage(
    VmaAllocator allocator,
    VkImage image,
    VmaAllocation allocation)
{
    VMA_ASSERT(allocator);

    if(image == VK_NULL_HANDLE && allocation == VK_NULL_HANDLE)
    {
        return;
    }

    VMA_DEBUG_LOG("vmaDestroyImage");

    VMA_DEBUG_GLOBAL_MUTEX_LOCK

#if VMA_RECORDING_ENABLED
    if(allocator->GetRecorder() != VMA_NULL)
    {
        allocator->GetRecorder()->RecordDestroyImage(
            allocator->GetCurrentFrameIndex(),
            allocation);
    }
#endif

    if(image != VK_NULL_HANDLE)
    {
        (*allocator->GetVulkanFunctions().vkDestroyImage)(allocator->m_hDevice, image, allocator->GetAllocationCallbacks());
    }
    if(allocation != VK_NULL_HANDLE)
    {
        allocator->FreeMemory(
            1, // allocationCount
            &allocation);
    }
}

#endif // #ifdef VMA_IMPLEMENTATION

```

`Modules/Vulkan/Public/vk_platform.h`:

```h
/* */
/* File: vk_platform.h */
/* */
/*
** Copyright (c) 2014-2020 The Khronos Group Inc.
**
** SPDX-License-Identifier: Apache-2.0
*/


#ifndef VK_PLATFORM_H_
#define VK_PLATFORM_H_

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

/*
***************************************************************************************************
*   Platform-specific directives and type declarations
***************************************************************************************************
*/

/* Platform-specific calling convention macros.
 *
 * Platforms should define these so that Vulkan clients call Vulkan commands
 * with the same calling conventions that the Vulkan implementation expects.
 *
 * VKAPI_ATTR - Placed before the return type in function declarations.
 *              Useful for C++11 and GCC/Clang-style function attribute syntax.
 * VKAPI_CALL - Placed after the return type in function declarations.
 *              Useful for MSVC-style calling convention syntax.
 * VKAPI_PTR  - Placed between the '(' and '*' in function pointer types.
 *
 * Function declaration:  VKAPI_ATTR void VKAPI_CALL vkCommand(void);
 * Function pointer type: typedef void (VKAPI_PTR *PFN_vkCommand)(void);
 */
#if defined(_WIN32)
    /* On Windows, Vulkan commands use the stdcall convention */
    #define VKAPI_ATTR
    #define VKAPI_CALL __stdcall
    #define VKAPI_PTR  VKAPI_CALL
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH < 7
    #error "Vulkan isn't supported for the 'armeabi' NDK ABI"
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7 && defined(__ARM_32BIT_STATE)
    /* On Android 32-bit ARM targets, Vulkan functions use the "hardfloat" */
    /* calling convention, i.e. float parameters are passed in registers. This */
    /* is true even if the rest of the application passes floats on the stack, */
    /* as it does by default when compiling for the armeabi-v7a NDK ABI. */
    #define VKAPI_ATTR __attribute__((pcs("aapcs-vfp")))
    #define VKAPI_CALL
    #define VKAPI_PTR  VKAPI_ATTR
#else
    /* On other platforms, use the default calling convention */
    #define VKAPI_ATTR
    #define VKAPI_CALL
    #define VKAPI_PTR
#endif

#include <stddef.h>

#if !defined(VK_NO_STDINT_H)
    #if defined(_MSC_VER) && (_MSC_VER < 1600)
        typedef signed   __int8  int8_t;
        typedef unsigned __int8  uint8_t;
        typedef signed   __int16 int16_t;
        typedef unsigned __int16 uint16_t;
        typedef signed   __int32 int32_t;
        typedef unsigned __int32 uint32_t;
        typedef signed   __int64 int64_t;
        typedef unsigned __int64 uint64_t;
    #else
        #include <stdint.h>
    #endif
#endif /* !defined(VK_NO_STDINT_H) */

#ifdef __cplusplus
} /* extern "C" */
#endif /* __cplusplus */

#endif

```

`README.md`:

```md
Toon
===
[![CircleCI](https://circleci.com/gh/benjinx/Toon.svg?style=svg)](https://circleci.com/gh/benjinx/Toon)
[![Build Status](https://ci.appveyor.com/api/projects/status/github/benjinx/Toon?svg=true)](https://ci.appveyor.com/project/benjinx/Toon)

A modular C++ Game Engine, designed to easily create Graphics demos. (Later support for Physics, Networking, and more).

Building
---

#### Linux && Windows

```
git clone https://github.com/benjinx/Toon.git
cd Toon
mkdir build && cd build
cmake ..
cmake --build .
```

Running Examples
---

The examples are built to run from their source directories. To facilitate this, there are convenience targets prefixed with `run-`.

### Example

```
cmake --build . --target run-HelloWorld
```

## Contributing

### Pull Requests

Use the "Branch and Pull Request" model for contributing changes.

```

`Scripts/ci-install-vulkan.ps1`:

```ps1

$version = "1.2.154.1"

$n = 1
do {
    Invoke-WebRequest "https://sdk.lunarg.com/sdk/download/$version/windows/VulkanSDK-$version-Installer.exe" -OutFile VulkanSDK-Installer.exe
    if ($?) {
        break
    }
    $n++
    Start-Sleep -s 10
} while ($n -le 10)

.\VulkanSDK-Installer.exe /S

$Env:VULKAN_SDK="C:\VulkanSDK\$version"

```

`Scripts/generate-launch-targets.py`:

```py
#!/usr/bin/env python3

import os
import sys
import json
import copy

isWindows = (os.name == 'nt')

toonproj = sys.argv[1]      # Path to .toonproj
binaryDir = sys.argv[2]     # CMAKE_BINARY_DIR
executable = sys.argv[3]    # Path to executable
assetPath = sys.argv[4]     # Asset search path, separated by ';'
modulePath = sys.argv[5]    # Module search path, separated by ';'

assetPath = assetPath.replace(';', os.pathsep)
modulePath = modulePath.replace(';', os.pathsep)

projectDirectory = os.path.dirname(toonproj)

project = {}
try:
    file = open(toonproj, 'r')
    project = json.load(file)
except:
    pass

def add_or_update_config(data, configurations):
    found = False
    for i in range(0, len(configurations)):
        if configurations[i]['name'] == data['name']:
            configurations[i] = data
            found = True
            break
    
    if not found:
        configurations.append(data)

if os.path.isdir('.vscode'):
    filename = '.vscode/launch.json'

    launch = {}
    try:
        file = open(filename, 'r')
        launch = json.load(file)
    except:
        pass

    if 'version' not in launch:
        launch['version'] = '0.2.0'

    if 'configurations' not in launch:
        launch['configurations'] = []

    default = {
        'name': '',
        'type': 'cppdbg',
        'request': 'launch',
        'program': os.path.join(binaryDir, executable),
        'cwd': projectDirectory,
        'environment': [
            {
                'name': 'TOON_ASSET_PATH',
                'value': assetPath
            }
        ],
        'externalConsole': False
    }
    
    if isWindows:
        default['type'] = 'cppvsdbg'
        default['externalConsole'] = True
        default['environment'].append({
            'name': 'PATH',
            'value': '${env:PATH};' + modulePath
        })
    else:
        default['environment'].append({
            'name': 'LD_LIBRARY_PATH',
            'value': modulePath
        })

    if 'configurations' in project:
        for name,config in project['configurations'].items():
            data = copy.deepcopy(default)
            data['name'] = "{} ({})".format(project['name'], name)
            data['args'] = [ toonproj, '-c', name ]

            add_or_update_config(data, launch['configurations'])
    else:
        data = copy.copy(default)
        data['name'] = project['name']
        data['args'] = [ toonproj ]

        add_or_update_config(data, launch['configurations'])

    file = open(filename, 'w')
    json.dump(launch, file, indent=4)

if isWindows and os.path.isdir('.vs'):
    filename = '.vs/launch.vs.json'

    launch = {}
    try:
        file = open(filename, 'r')
        launch = json.load(file)
    except:
        pass

    if 'version' not in launch:
        launch['version'] = '0.2.1'

    if 'configurations' not in launch:
        launch['configurations'] = []

    default = {
        'name': '',
        'type': 'default', # dll
        # 'exe': executable,
        'project': 'CMakeLists.txt',
        'projectTarget': '{} ({})'.format(os.path.basename(executable), executable),
        'cwd': projectDirectory,
        'env': {
            'PATH': '${env.PATH};' + modulePath,
            'TOON_ASSET_PATH': assetPath,
        },
    }

    if 'configurations' in project:
        for name,config in project['configurations'].items():
            data = copy.deepcopy(default)
            data['name'] = "%s (%s)" % (project['name'], name)
            data['args'] = [ toonproj, '-c', name ]

            add_or_update_config(data, launch['configurations'])
    else:
        data = copy.copy(default)
        data['name'] = project['name']
        data['args'] = [ toonproj ]

        add_or_update_config(data, launch['configurations'])

    file = open(filename, 'w')
    json.dump(launch, file, indent=4)

```

`ThirdParty/CMakeLists.txt`:

```txt
CMAKE_MINIMUM_REQUIRED(VERSION 3.15 FATAL_ERROR)

LIST(INSERT CMAKE_MODULE_PATH 0 "${CMAKE_SOURCE_DIR}/../CMake")

INCLUDE(Policies)
INCLUDE(ExternalProject)

PROJECT(thirdparty)

FIND_PACKAGE(patch REQUIRED)

SET(REQUIRED_DEPENDENCIES "" CACHE STRING "")

# See /CMakeLists.txt for explanation
STRING(REPLACE ":" ";" REQUIRED_DEPENDENCIES "${REQUIRED_DEPENDENCIES}")

# glm

IF("glm" IN_LIST REQUIRED_DEPENDENCIES)
    SET(glm_ROOT       ${CMAKE_BINARY_DIR}/glm/cmake)
    SET(glm_SOURCE_DIR ${CMAKE_BINARY_DIR}/glm)

    FIND_PACKAGE(glm CONFIG QUIET)

    IF(NOT glm_FOUND OR NOT TARGET glm::glm)
        ExternalProject_Add(
            thirdparty-glm
            URL                 "https://github.com/g-truc/glm/releases/download/0.9.9.8/glm-0.9.9.8.zip"
            URL_HASH            MD5=69895110052f0d711c9c54fbf385f6f5
            SOURCE_DIR          ${glm_SOURCE_DIR}
            CONFIGURE_COMMAND   ""
            BUILD_COMMAND       ""
            INSTALL_COMMAND     ""
            UPDATE_COMMAND      ""
        )
    ENDIF()
ENDIF()

# GSL

IF("GSL" IN_LIST REQUIRED_DEPENDENCIES)
    SET(GSL_ROOT       ${CMAKE_BINARY_DIR}/GSL)
    SET(GSL_SOURCE_DIR ${CMAKE_BINARY_DIR}/GSL_src)

    FIND_PACKAGE(GSL QUIET)

    IF(NOT GSL_FOUND)
        ExternalProject_Add(
            ThirdParty_GSL
            URL                 "https://github.com/microsoft/GSL/archive/v3.1.0.tar.gz"
            URL_HASH            MD5=b6910c54113f921b03dc06642cf7f11c
            SOURCE_DIR          ${GSL_SOURCE_DIR}
            CMAKE_ARGS          -DCMAKE_INSTALL_PREFIX=${GSL_ROOT}
                                -DGSL_TEST=OFF
            BUILD_COMMAND       ""
            UPDATE_COMMAND      ""
        )
    ENDIF()
ENDIF()

# nlohmann_json

IF("nlohmann_json" IN_LIST REQUIRED_DEPENDENCIES)
    SET(nlohmann_json_ROOT       ${CMAKE_BINARY_DIR}/nlohmann_json)
    SET(nlohmann_json_SOURCE_DIR ${CMAKE_BINARY_DIR}/nlohmann_json_src)

    FIND_PACKAGE(nlohmann_json CONFIG QUIET)

    IF(NOT nlohmann_json_FOUND)
        ExternalProject_Add(
            thirdparty-nlohmann_json
            URL                 "https://github.com/nlohmann/json/archive/v3.9.1.tar.gz"
            URL_HASH            MD5=e386222fb57dd2fcb8a7879fc016d037
            SOURCE_DIR          ${nlohmann_json_SOURCE_DIR}
            CMAKE_ARGS          -DCMAKE_INSTALL_PREFIX=${nlohmann_json_ROOT}
                                -DJSON_BuildTests=OFF
            BUILD_COMMAND       ""
            UPDATE_COMMAND      ""
        )
    ENDIF()
ENDIF()

# SDL2

IF("SDL2" IN_LIST REQUIRED_DEPENDENCIES)
    SET(SDL2_ROOT         ${CMAKE_BINARY_DIR}/SDL2)
    SET(SDL2_SOURCE_DIR   ${CMAKE_BINARY_DIR}/SDL2_src)
    SET(SDL2_BINARY_DIR   ${CMAKE_BINARY_DIR}/SDL2_bin)

    FIND_PACKAGE(SDL2 2.0.6 CONFIG QUIET)

    IF(CMAKE_GENERATOR STREQUAL "Visual Studio 16 2019")
    SET(_SDL2_PATCH_COMMAND ${patch_COMMAND} ${SDL2_SOURCE_DIR}/CMakeLists.txt -i ${CMAKE_SOURCE_DIR}/SDL2_vcruntime.patch )
    ENDIF()

    IF (NOT SDL2_FOUND)
        ExternalProject_Add(
            thirdparty-SDL2
            URL                 "https://www.libsdl.org/release/SDL2-2.0.12.tar.gz"
            URL_HASH            MD5=783b6f2df8ff02b19bb5ce492b99c8ff
            SOURCE_DIR          ${SDL2_SOURCE_DIR}
            BINARY_DIR          ${SDL2_BINARY_DIR}
            CMAKE_ARGS          -DCMAKE_INSTALL_PREFIX=${SDL2_ROOT}
                                -DBUILD_SHARED_LIBS=ON
            UPDATE_COMMAND      ""
            BUILD_COMMAND       ""
            TEST_COMMAND        ""
            INSTALL_COMMAND     ${CMAKE_COMMAND} --build . --target install --config Release
            COMMAND             ${CMAKE_COMMAND} --build . --target install --config Debug
            PATCH_COMMAND       ${_SDL2_PATCH_COMMAND}
        )
    ENDIF()
ENDIF()

# GTest

IF("GTest" IN_LIST REQUIRED_DEPENDENCIES)
    SET(GTEST_ROOT       ${CMAKE_BINARY_DIR}/GTest)
    SET(GTEST_SOURCE_DIR ${CMAKE_BINARY_DIR}/GTest_src)
    SET(GTEST_BINARY_DIR ${CMAKE_BINARY_DIR}/GTest_bin)

    SET(GTEST_MSVC_SEARCH "MD")
    FIND_PACKAGE(GTest QUIET)

    IF(NOT GTEST_FOUND)
        ExternalProject_Add(
            ThirdParty_GTest
            URL                 "https://github.com/google/googletest/archive/release-1.10.0.tar.gz"
            URL_HASH            MD5=ecd1fa65e7de707cd5c00bdac56022cd
            SOURCE_DIR          ${GTEST_SOURCE_DIR}
            BINARY_DIR          ${GTEST_BINARY_DIR}
            CMAKE_ARGS          -DCMAKE_INSTALL_PREFIX=${GTEST_ROOT}
                                -DCMAKE_POSITION_INDEPENDENT_CODE=ON
                                -DBUILD_SHARED_LIBS=ON
            BUILD_COMMAND       ""
            UPDATE_COMMAND      ""
            TEST_COMMAND        ""
            INSTALL_COMMAND     ${CMAKE_COMMAND} --build . --target install --config Release
        )
    ENDIF()
ENDIF()

# cflags

IF("cflags" IN_LIST REQUIRED_DEPENDENCIES)
    SET(cflags_ROOT       ${CMAKE_BINARY_DIR}/cflags)
    SET(cflags_SOURCE_DIR ${CMAKE_BINARY_DIR}/cflags_src)

    FIND_PACKAGE(cflags CONFIG QUIET)

    IF(NOT cflags_FOUND)
        ExternalProject_Add(
            ThirdParty_cflags
            URL                 "https://github.com/WhoBrokeTheBuild/cflags/archive/v2.0.1.zip"
            URL_HASH            MD5=957b2e6a481efd96c0ce72f291176cb4
            SOURCE_DIR          ${cflags_SOURCE_DIR}
            CMAKE_ARGS          -DCMAKE_INSTALL_PREFIX=${cflags_ROOT}
            BUILD_COMMAND       ""
            UPDATE_COMMAND      ""
        )
    ENDIF()
ENDIF()


```

`ThirdParty/SDL2_vcruntime.patch`:

```patch
1425c1425
<   list(APPEND EXTRA_LIBS user32 gdi32 winmm imm32 ole32 oleaut32 version uuid advapi32 setupapi shell32)
---
>   list(APPEND EXTRA_LIBS user32 gdi32 winmm imm32 ole32 oleaut32 version uuid advapi32 setupapi shell32 vcruntime)

```

`appveyor.yml`:

```yml
# Specify version format
version: "{build}"

os:
  - Visual Studio 2019

platform:
  - x64

configuration:
  - Debug
  - Release

init:
  - cmd: cmake --version
  - cmd: msbuild /version

clone_folder: C:\projects\Toon

before_build:
  - ps: . C:\projects\Toon\Scripts\ci-install-vulkan.ps1
  - ps: cmake --version
  - ps: Get-ChildItem "env:"

build_script:
  - cmd: cd C:\projects\Toon
  - cmd: mkdir Build
  - cmd: cd Build
  # TODO -DBUILD_TESTS=ON
  - cmd: cmake -G "Visual Studio 16 2019" -A x64 -DVERBOSE_LOGGING=ON ..
  - cmd: cmake --build .
  # - cmd: cmake --build . --target RUN_TESTS

test: off

```

`old/Assets/shaders/axis.frag`:

```frag
/*
    Draw Color
    By Benji Campbell
    Fragment shader that displays color received from previous pipeline stage.
*/

#version 330 core

// varying
in vertexData
{
    vec4 color;
} pass;

// target
layout (location = 0) out vec4 fragColor;

void main()
{
    fragColor = pass.color;
}

```

`old/Assets/shaders/axis.vert`:

```vert
/*
    Pass Color
    By Benji Campbell
    Vertex shader that passes attributes down pipeline.
*/

#version 330 core

// attributes
layout (location = 0) in vec4 position;
layout (location = 6) in vec4 color;

// uniforms
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;

//
out vertexData
{
    vec4 color;
} pass;

void main()
{
    gl_Position = projMat * viewMat  * modelMat * position;
    pass.color = color;
}
```

`old/Assets/shaders/defaultLighting.frag`:

```frag
#version 330 core

struct Material {
    vec3 diffuse,
         emissive;

    float metallic,
          roughness,
          normalScale,
          occlusionStrength;
};

// Varyings
in vertexData
{
    vec3 fragPos;
    vec3 normal;
} pass;

// Uniforms
uniform vec4 eyePos;
uniform vec4 lightVec;
uniform vec3 lightColor;

uniform Material material;

// Targets
layout (location = 0) out vec4 fragColor;

void main()
{

    vec3 lc = vec3(1.0, 1.0, 1.0);
    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
      
    // diffuse 
    vec3 norm = normalize(pass.normal);
    vec3 lightDir = normalize(lightVec.xyz - pass.fragPos);

    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * material.diffuse;
    
    // specular
    vec3 specular = vec3(0.0, 0.0, 0.0);

    // We dot the normal and lightDir to make sure it won't 'leak'
    if (dot(norm, lightDir) >= 0.0f) {
        float specularStrength = 0.5;
        vec3 viewDir = normalize(eyePos.xyz - pass.fragPos);
        vec3 reflectDir = reflect(-lightDir, norm);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
        specular = specularStrength * spec * lightColor;
    }

    vec3 result = (ambient + diffuse + specular) * material.diffuse;
    fragColor = vec4(result, 1.0);
}

```

`old/Assets/shaders/defaultLighting.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;

// Uniforms
uniform mat4 mvp;
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;

// Varyings
out vertexData
{
    vec3 fragPos;
    vec3 normal;
} pass;

void main()
{
    pass.fragPos = vec3(modelMat * vec4(position.xyz, 1.0));
    pass.normal = mat3(transpose(inverse(modelMat))) * normal.xyz;

    gl_Position =  projMat * viewMat * vec4(pass.fragPos, 1.0);
}
```

`old/Assets/shaders/misc/compile-spirv-shaders.bat`:

```bat
C:/VulkanSDK/1.0.42.1/Bin32/glslangValidator.exe -V shader.vert
C:/VulkanSDK/1.0.42.1/Bin32/glslangValidator.exe -V shader.frag
pause
```

`old/Assets/shaders/misc/gammaCorrection.frag`:

```frag
#version 330 core

// Varyings
in vertexData
{
    vec4 fragPos;
    vec4 normal;
    vec4 lightPos;
    vec4 eyePos;
    vec2 texCoords;
} pass;

// Uniforms
uniform sampler2D diffuseTex;

uniform float gammaAmount;

// Targets
layout (location = 0) out vec4 fragColor;

void main()
{
    vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);
    vec4 diffTex = texture(diffuseTex, pass.texCoords);

    float amb = 0.1;
    vec4 ambient = amb * lightColor;

    vec4 lightDir = normalize(pass.lightPos - pass.fragPos);
    float diff = max(dot(pass.normal, lightDir), 0.0);
    vec4 diffuse = diff * diffTex * lightColor;

    vec4 viewDir = normalize(pass.eyePos - pass.fragPos);
    vec4 reflectDir = reflect(-lightDir, pass.normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    vec4 specular = spec * lightColor;

    float gamma = gammaAmount;
    fragColor = vec4(pow((ambient.xyz + diffuse.xyz + specular.xyz), vec3(gamma)), 1.0f);
}
```

`old/Assets/shaders/misc/gammaCorrection.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec4 position;
layout (location = 2) in vec4 normal;
layout (location = 8) in vec2 texCoords;

// Uniforms
uniform mat4 modelMat;
uniform mat4 mvp;
uniform vec4 lightPos;
uniform vec4 eyePos;

// Varyings
out vertexData
{
    vec4 fragPos;
    vec4 normal;
    vec4 lightPos;
    vec4 eyePos;
    vec2 texCoords;
} pass;

void main()
{
    gl_Position = mvp * position;

    pass.fragPos = modelMat * position;
    pass.normal = modelMat * normal;
    pass.lightPos = lightPos;
    pass.eyePos = eyePos;
    pass.texCoords = texCoords;
}
```

`old/Assets/shaders/misc/toonShader.frag`:

```frag
#version 330 core

// Varyings
in vertexData
{
    vec4 fragPos;
    vec4 normal;
    vec4 lightPos;
    vec4 eyePos;
    vec2 texCoords;
} pass;

// Uniforms
uniform sampler2D diffuseTex;

uniform vec3 lightCol;
uniform vec3 objCol;

// Targets
layout (location = 0) out vec4 fragColor;

void main()
{
    vec4 lightColor = vec4(lightCol, 1.0);
    vec4 objColor = vec4(objCol, 1.0);
    vec4 diffTex = texture(diffuseTex, pass.texCoords);

    float amb = 0.1;
    vec4 ambient = amb * lightColor;

    vec4 lightDir = normalize(pass.lightPos - pass.fragPos);

    float intensity = dot(pass.normal, lightDir);
    intensity = clamp(intensity, 0.1f, 1.0f);

    vec4 diffuse;

    if (intensity > 0.95)
        diffuse = objColor * vec4(0.95, 0.95, 0.95, 1.0);
    else if (intensity > 0.5)
        diffuse = objColor * vec4(0.5, 0.5, 0.5, 1.0);
    else if (intensity > 0.25)
        diffuse = objColor * vec4(0.25, 0.25, 0.25, 1.0);
    else
        diffuse = objColor * vec4(0.01, 0.01, 0.01, 1.0);

    fragColor = vec4((ambient.xyz + diffuse.xyz), 1.0f);
}
```

`old/Assets/shaders/misc/toonShader.vert`:

```vert
#version 330

// Attributes
layout (location = 0) in vec4 position;
layout (location = 2) in vec4 normal;
layout (location = 8) in vec2 texCoords;

// Uniforms
uniform mat4 modelMat;
uniform mat4 mvp;
uniform vec4 lightPos;
uniform vec4 eyePos;

// Varyings
out vertexData
{
    vec4 fragPos;
    vec4 normal;
    vec4 lightPos;
    vec4 eyePos;
    vec2 texCoords;
} pass;

void main()
{
    gl_Position = mvp * position;

    pass.fragPos = modelMat * position;
    pass.normal = modelMat * normal;
    pass.lightPos = lightPos;
    pass.eyePos = eyePos;
    pass.texCoords = texCoords;
}
```

`old/Assets/shaders/passThruColor.frag`:

```frag
/*
    Draw Color
    By Benji Campbell
    Fragment shader that displays color received from previous pipeline stage.
*/

#version 330 core

// varyings
in vertexData
{
    vec2 texCoords;
} pass;

// uniforms
uniform vec3 passColor;

// target
layout (location = 0) out vec4 fragColor;

void main()
{
    fragColor = vec4(passColor, 1.0); // use for color
}

```

`old/Assets/shaders/passThruColor.frag.glsl`:

```glsl
/*
    Draw Color
    By Benji Campbell
    Fragment shader that displays color received from previous pipeline stage.
*/

#version 450 core

// varyings
layout (location = 0) in vertexData
{
    vec4 norm;
} pass;


// // uniforms
// uniform vec3 passColor;

// target
layout (location = 0) out vec4 fragColor;

void main()
{
    fragColor = vec4(abs(pass.norm.xyz), 1.0);
    //fragColor = vec4(0.0, 1.0, 0.0, 1.0); // use for color
}

```

`old/Assets/shaders/passThruColor.vert`:

```vert
/*
    Pass Color
    By Benji Campbell
    Vertex shader that passes attributes down pipeline.
*/

#version 330 core

// attributes
layout (location = 0) in vec4 position;
layout (location = 2) in vec2 texCoords;

// uniforms
uniform mat4 mvp;

// varyings
out vertexData
{
    vec2 texCoords;
} pass;

void main()
{
    gl_Position = mvp * position;
    pass.texCoords = vec2(texCoords.x, 1.0 - texCoords.y);
}
```

`old/Assets/shaders/passThruColor.vert.glsl`:

```glsl
/*
    Pass Color
    By Benji Campbell
    Vertex shader that passes attributes down pipeline.
*/

#version 450 core

// attributes
layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
//layout (location = 2) in vec2 texCoords;

// uniforms
layout (binding = 0, std140) uniform TransformData
{
    mat4 Model;
    mat4 View;
    mat4 Proj;
    mat4 mvp;
};

// varyings
layout (location = 0) out vertexData
{
    vec4 norm;
} pass;

void main()
{
    pass.norm = normal;
    gl_Position = mvp * position;
    //gl_Position = position;
    //pass.texCoords = vec2(texCoords.x, 1.0 - texCoords.y);
}
```

`old/Assets/shaders/passThruTexture.frag`:

```frag
/*
    Draw Color
    By Benji Campbell
    Fragment shader that displays color received from previous pipeline stage.
*/

#version 330 core

struct Material {
    sampler2D diffuseMap;
};

// varyings
in vertexData
{
    vec2 texCoords;
} pass;

// uniforms
uniform Material material;

// target
layout (location = 0) out vec4 fragColor;

void main()
{
    vec3 objectColor = texture(material.diffuseMap, pass.texCoords).rgb;
    fragColor = vec4(objectColor, 1.0); // use for diffuse
}

```

`old/Assets/shaders/passThruTexture.vert`:

```vert
/*
    Pass Color
    By Benji Campbell
    Vertex shader that passes attributes down pipeline.
*/

#version 330 core

// attributes
layout (location = 0) in vec4 position;
layout (location = 2) in vec2 texCoords;

// uniforms
uniform mat4 mvp;

// varyings
out vertexData
{
    vec2 texCoords;
} pass;

void main()
{
    gl_Position = mvp * position;
    pass.texCoords = vec2(texCoords.x, texCoords.y);
}
```

`old/Assets/shaders/passThruUV.frag`:

```frag
/*
    Draw Color
    By Benji Campbell
    Fragment shader that displays color received from previous pipeline stage.
*/

#version 330 core

// varyings
in vertexData
{
    vec2 texCoords;
} pass;

// uniforms
uniform vec3 passColor;

// target
layout (location = 0) out vec4 fragColor;

void main()
{
    fragColor = vec4(pass.texCoords.x, pass.texCoords.y, 0.0, 1.0); // use for color
}

```

`old/Assets/shaders/passThruUV.vert`:

```vert
/*
    Pass UV/TexCoords as color
    By Benji Campbell
    Vertex shader that passes attributes down pipeline.
*/

#version 330 core

// attributes
layout (location = 0) in vec4 position;
layout (location = 2) in vec2 texCoords;

// uniforms
uniform mat4 mvp;

// varyings
out vertexData
{
    vec2 texCoords;
} pass;

void main()
{
    gl_Position = mvp * position;
    pass.texCoords = vec2(texCoords.x, 1.0 - texCoords.y);
}
```

`old/Assets/shaders/skybox.frag`:

```frag
#version 330 core
out vec4 FragColor;

in vec3 TexCoords;
uniform samplerCube cubemap;

void main()
{
	FragColor = texture(cubemap, TexCoords);
}
```

`old/Assets/shaders/skybox.frag.glsl`:

```glsl
#version 330 core
out vec4 FragColor;

in vec3 TexCoords;
uniform samplerCube cubemap;

void main()
{
	FragColor = texture(cubemap, TexCoords);
}
```

`old/Assets/shaders/skybox.vert`:

```vert
#version 330 core
layout (location = 0) in vec3 position;

out vec3 TexCoords;

uniform mat4 viewMat;
uniform mat4 projMat;

void main()
{
	TexCoords = position;
	vec4 pos = projMat * viewMat * vec4(position, 1.0);

     // An optimization:
     // By forcing the z to be 1 via w
     // We can trick it into thinking it's always in the back on the depth test.
     gl_Position = pos.xyww;
}
```

`old/Assets/shaders/skybox.vert.glsl`:

```glsl
#version 330 core
layout (location = 0) in vec3 position;

out vec3 TexCoords;

uniform mat4 viewMat;
uniform mat4 projMat;

void main()
{
	TexCoords = position;
	vec4 pos = projMat * viewMat * vec4(position, 1.0);

     // An optimization:
     // By forcing the z to be 1 via w
     // We can trick it into thinking it's always in the back on the depth test.
     gl_Position = pos.xyww;
}
```

`old/Assets/shaders/toonShader.frag`:

```frag
#version 410

// Varyings
in vertexData
{
	vec4 fragPos;
	vec4 normal;
	vec4 lightPos;
	vec4 eyePos;
	vec2 texCoords;
} pass;

// Uniforms
uniform sampler2D diffuseTex;

uniform vec3 lightCol;
uniform vec3 objCol;

// Targets
layout (location = 0) out vec4 fragColor;

void main()
{
	vec4 lightColor = vec4(lightCol, 1.0);
	vec4 objColor = vec4(objCol, 1.0);
	vec4 diffTex = texture(diffuseTex, pass.texCoords);

	float amb = 0.1;
	vec4 ambient = amb * lightColor;

	vec4 lightDir = normalize(pass.lightPos - pass.fragPos);

	float intensity = dot(pass.normal, lightDir);
	intensity = clamp(intensity, 0.1f, 1.0f);

	vec4 diffuse;

	if (intensity > 0.95)
		diffuse = objColor * vec4(0.95, 0.95, 0.95, 1.0);
	else if (intensity > 0.5)
		diffuse = objColor * vec4(0.5, 0.5, 0.5, 1.0);
	else if (intensity > 0.25)
		diffuse = objColor * vec4(0.25, 0.25, 0.25, 1.0);
	else
		diffuse = objColor * vec4(0.01, 0.01, 0.01, 1.0);

	fragColor = vec4((ambient.xyz + diffuse.xyz), 1.0f);
}
```

`old/Assets/shaders/toonShader.vert`:

```vert
#version 410

// Attributes
layout (location = 0) in vec4 position;
layout (location = 2) in vec4 normal;
layout (location = 8) in vec2 texCoords;

// Uniforms
uniform mat4 modelMat;
uniform mat4 mvp;
uniform vec4 lightPos;
uniform vec4 eyePos;

// Varyings
out vertexData
{
	vec4 fragPos;
	vec4 normal;
	vec4 lightPos;
	vec4 eyePos;
	vec2 texCoords;
} pass;

void main()
{
	gl_Position = mvp * position;

	pass.fragPos = modelMat * position;
	pass.normal = modelMat * normal;
	pass.lightPos = lightPos;
	pass.eyePos = eyePos;
	pass.texCoords = texCoords;
}
```

`old/CMakeLists.txt`:

```txt
CMAKE_MINIMUM_REQUIRED(VERSION 3.12 FATAL_ERROR)

# Allow for custom CMake modules
LIST(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake")

INCLUDE(Policies)

###
### Project
###

PROJECT(Toon)

###
### Options
###

OPTION(BUILD_DEMOS      "Build Demo Projects"                               ON)
OPTION(BUILD_THIRDPARTY "Build Missing ThirdParty Dependencies"             ON)
OPTION(BUILD_PACKAGES   "Build Packages"                                    OFF)

OPTION(VERBOSE_LOGGING "Build Toon with Verbose Logging enabled" OFF)
IF(VERBOSE_LOGGING)
    MESSAGE(STATUS "Verbose On.")
    ADD_DEFINITIONS(-DTOON_ENABLE_VERBOSE_LOGGING)
ENDIF()

###
### Configuration
###

INCLUDE(Macros)
INCLUDE(Compiler)
INCLUDE(Version)

# Allow for custom organization of files in VisualStudio
SET_PROPERTY(GLOBAL PROPERTY USE_FOLDERS ON)

# Don't use the install RPATH when building
SET(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
SET(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")

# Limit Configuration Types
IF(CMAKE_CONFIGURATION_TYPES)
    SET(CMAKE_CONFIGURATION_TYPES Debug Release)
ENDIF()

###
### Third Party Dependencies
###

IF(BUILD_THIRDPARTY)
    SET(THIRDPARTY_SOURCE_DIR ${CMAKE_SOURCE_DIR}/thirdparty)
    SET(THIRDPARTY_BINARY_DIR ${CMAKE_BINARY_DIR}/thirdparty)

    FILE(MAKE_DIRECTORY ${THIRDPARTY_BINARY_DIR})

    SET(glm_ROOT            ${THIRDPARTY_BINARY_DIR}/glm)
    SET(nlohmann_json_ROOT  ${THIRDPARTY_BINARY_DIR}/nlohmann_json)
    SET(SDL2_ROOT           ${THIRDPARTY_BINARY_DIR}/SDL2)
    
    EXECUTE_PROCESS(
        COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" 
            -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}
            -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}
            ${THIRDPARTY_SOURCE_DIR}
            WORKING_DIRECTORY ${THIRDPARTY_BINARY_DIR}
        RESULT_VARIABLE _result
    )
    IF(_result)
        MESSAGE("${_result}")
        MESSAGE(FATAL_ERROR "Failed to configure thirdparty projects")
    ENDIF()

    SET(_THIRDPARTY_BUILD_COMMAND ${CMAKE_COMMAND} --build . )
    IF(CMAKE_GENERATOR STREQUAL "Unix Makefiles")
        SET(_THIRDPARTY_BUILD_COMMAND ${CMAKE_MAKE_PROGRAM} -l )
    ENDIF()

    EXECUTE_PROCESS(
        COMMAND ${_THIRDPARTY_BUILD_COMMAND}
        WORKING_DIRECTORY ${THIRDPARTY_BINARY_DIR}
        RESULT_VARIABLE _result
    )

    IF(_result)
        MESSAGE("${_result}")
        MESSAGE(FATAL_ERROR "Failed to build thirdparty projects")
    ENDIF()
ENDIF()

FIND_PACKAGE(glm CONFIG REQUIRED)
FIND_PACKAGE(nlohmann_json CONFIG REQUIRED)
FIND_PACKAGE(SDL2 2.0.6 CONFIG)

GET_TARGET_PROPERTY(_location SDL2::SDL2 IMPORTED_LOCATION_RELEASE)
GET_FILENAME_COMPONENT(SDL2_RUNTIME_DIR ${_location} DIRECTORY)

# Allow VS to find .dll's
SET(RUNTIME_SEARCH_PATH 
    ${SDL2_RUNTIME_DIR}
)

FILE(RELATIVE_PATH 
    RESOURCE_PATH 
    ${CMAKE_BINARY_DIR} 
    ${CMAKE_SOURCE_DIR}/resources
)
                        
SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})

###
### Engine
###

CONFIGURE_FILE(
    ${CMAKE_SOURCE_DIR}/include/Config.hpp.in
    ${CMAKE_BINARY_DIR}/Config.hpp
)

# Glob
FILE(GLOB_RECURSE 
    _ENGINE_RESOURCES
    "${CMAKE_SOURCE_DIR}/Resources/*"
)

FILE(GLOB_RECURSE 
    _ENGINE_INCLUDES
    "${CMAKE_SOURCE_DIR}/include/*.hpp"
    "${CMAKE_SOURCE_DIR}/include/*.h"
)

FILE(GLOB_RECURSE 
    _ENGINE_SOURCES  
    "${CMAKE_SOURCE_DIR}/src/*.cpp"
    "${CMAKE_SOURCE_DIR}/src/*.c"
    "${CMAKE_SOURCE_DIR}/src/*.hpp"
    "${CMAKE_SOURCE_DIR}/src/*.h"
)

# Add source to executables
ADD_LIBRARY(
    ${PROJECT_NAME}
    ${CMAKE_BINARY_DIR}/Config.hpp
    ${_ENGINE_INCLUDES}
    ${_ENGINE_SOURCES}
    #${_ENGINE_RESOURCES}
)

# Include Dirs
TARGET_INCLUDE_DIRECTORIES(
    ${PROJECT_NAME}
    PUBLIC
        $<INSTALL_INTERFACE:include>
        $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include>
        $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/>
    PRIVATE
        ${CMAKE_SOURCE_DIR}/include
        ${CMAKE_SOURCE_DIR}/include/imgui
        ${CMAKE_SOURCE_DIR}/src
        ${CMAKE_BINARY_DIR}
)

TARGET_COMPILE_OPTIONS(
    ${PROJECT_NAME}
    PUBLIC
        # Disable unknown pragmas warning, C++ exceptions
        $<$<CXX_COMPILER_ID:GNU>:-Wall -Wno-unknown-pragmas>
        $<$<CXX_COMPILER_ID:Clang>:-Wall -Wno-unknown-pragmas>
        $<$<CXX_COMPILER_ID:MSVC>:/MP /wd4068 /GR- /std:c++17>
)

# Folders to filters
FOREACH(file IN ITEMS ${_ENGINE_INCLUDES} ${_ENGINE_SOURCES})
    FILE(RELATIVE_PATH file_path ${CMAKE_SOURCE_DIR} ${file})
    GET_FILENAME_COMPONENT(file_path ${file_path} DIRECTORY)
    FILE(TO_NATIVE_PATH ${file_path} file_path)
    SOURCE_GROUP(${file_path} FILES ${file})
ENDFOREACH()

# Link all libraries
TARGET_LINK_LIBRARIES(
    ${PROJECT_NAME}
    glm::glm
    nlohmann_json::nlohmann_json
    SDL2::SDL2
)

IF(TARGET SDL2::SDL2main)
    TARGET_LINK_LIBRARIES(
        ${PROJECT_NAME}
        SDL2::SDL2main
    )
ENDIF()

INSTALL(TARGETS ${PROJECT_NAME}
    EXPORT ToonTargets
    INCLUDES DESTINATION include
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
)

INCLUDE(CMakePackageConfigHelpers)

WRITE_BASIC_package_VERSION_FILE(
    "${CMAKE_BINARY_DIR}/ToonConfigVersion.cmake"
    VERSION ${PROJECT_VERSION}
    COMPATIBILITY AnyNewerVersion
)

INSTALL(EXPORT ToonTargets
    FILE ToonTargets.cmake
    NAMESPACE Toon::
    DESTINATION lib/cmake/Toon
)

CONFIGURE_package_CONFIG_FILE(
    "${CMAKE_SOURCE_DIR}/cmake/ToonConfig.cmake.in"
    "${CMAKE_BINARY_DIR}/ToonConfig.cmake"
    INSTALL_DESTINATION lib/cmake/Toon
)

INSTALL(EXPORT ToonTargets 
    DESTINATION lib/cmake/Toon
)

INSTALL(FILES 
    "${CMAKE_BINARY_DIR}/ToonConfigVersion.cmake" 
    "${CMAKE_BINARY_DIR}/ToonConfig.cmake"
    DESTINATION lib/cmake/Toon
)

FIND_PACKAGE(PkgConfig QUIET)

IF(PKG_CONFIG_FOUND)
    CONFIGURE_FILE(
        "${CMAKE_SOURCE_DIR}/cmake/Toon.pc.in"
        "${CMAKE_BINARY_DIR}/Toon.pc"
        @ONLY
    )

    INSTALL(FILES
        "${CMAKE_BINARY_DIR}/Toon.pc"
        DESTINATION share/pkgconfig
    )
ENDIF()

INSTALL(DIRECTORY
    "${CMAKE_SOURCE_DIR}/include/"
    DESTINATION include
    PATTERN "*.in" EXCLUDE
)


###
### Demos
###

# Allow custom targets to find .dlls
SET(CMAKE_MSVC_RUN_PATH "${RUNTIME_SEARCH_PATH}")

IF(BUILD_DEMOS)
    ADD_SUBDIRECTORY(demos)

    SET_PROPERTY(DIRECTORY ${CMAKE_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT "HelloWorld")
ENDIF()

###
### Packaging
###

IF(BUILD_PACKAGES)
    ADD_SUBDIRECTORY(packages)
ENDIF()

```

`old/demos/CMakeLists.txt`:

```txt

SUBDIRLIST(DEMO_LIST ${CMAKE_CURRENT_SOURCE_DIR})
SET(RUN_DEMO_LIST "")

FOREACH(demo ${DEMO_LIST})
    ADD_SUBDIRECTORY(${demo})

    ADD_DEPENDENCIES(
        ${demo}
        ${PROJECT_NAME}
    )
    SET_TARGET_PROPERTIES(
        ${demo}
        PROPERTIES FOLDER "Demos"
        VS_DEBUGGER_WORKING_DIRECTORY "${CMAKE_BINARY_DIR}"
    )
    IF(NOT DEFINED ENV{CI})
        ADD_CUSTOM_TARGET(
            run-${demo}
            COMMAND $<TARGET_FILE:${demo}>
            DEPENDS ${demo}
            WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        )
        SET_TARGET_PROPERTIES(
            run-${demo}
            PROPERTIES FOLDER "Automation"
        )
        ADD_CUSTOM_TARGET(
            valgrind-${demo}
            COMMAND valgrind $<TARGET_FILE:${demo}>
            DEPENDS ${demo}
            WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        )
        SET_TARGET_PROPERTIES(
            valgrind-${demo}
            PROPERTIES FOLDER "Automation"
        )
    ENDIF()
    LIST(APPEND RUN_DEMO_LIST "run-${demo}")
ENDFOREACH()

ADD_CUSTOM_TARGET(
    demos
    DEPENDS ${DEMO_LIST}
)
SET_TARGET_PROPERTIES(
    demos
    PROPERTIES FOLDER "Demos"
)

IF(NOT DEFINED ENV{CI})
    ADD_CUSTOM_TARGET(
        run-demos
        DEPENDS ${RUN_DEMO_LIST}
    )
    SET_TARGET_PROPERTIES(
        run-demos
        PROPERTIES FOLDER "Automation"
    )
ENDIF()

SET(DEMO_LIST "${DEMO_LIST}" PARENT_SCOPE)

```

`old/demos/Cubemap/CMakeLists.txt`:

```txt

GET_FILENAME_COMPONENT(EXAMPLE "${CMAKE_CURRENT_LIST_DIR}" NAME)

ADD_EXECUTABLE(${EXAMPLE}
    src/Main.cpp
    src/GameScene.hpp
    src/GameScene.cpp
)

TARGET_LINK_LIBRARIES(${EXAMPLE}
    ${PROJECT_NAME}
)
 
FILE(RELATIVE_PATH BINARY_RESOURCE_PATH "${CMAKE_BINARY_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/resources")
FILE(RELATIVE_PATH SOURCE_RESOURCE_PATH "${CMAKE_CURRENT_SOURCE_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/resources")

TARGET_COMPILE_DEFINITIONS(${EXAMPLE}
    PUBLIC -DRESOURCE_PATH="${SOURCE_RESOURCE_PATH}:${BINARY_RESOURCE_PATH}:${CMAKE_SOURCE_DIR}/resources:${RESOURCE_PATH}"
)

IF(MSVC)
    SET_TARGET_PROPERTIES(
        ${EXAMPLE} 
        PROPERTIES 
            VS_DEBUGGER_ENVIRONMENT "PATH=%PATH%;${RUNTIME_SEARCH_PATH}"
    )
ENDIF()

```

`old/demos/Cubemap/resources/shaders/reflection.frag`:

```frag
#version 330 core

// Varyings
in vertexData
{
    vec3 fragPos;
    vec3 normal;
} pass;

// Uniforms
uniform vec3 eyePos;
uniform samplerCube cubemap;

// Targets
layout (location = 0) out vec4 FragColor;


void main()
{
    vec3 I = normalize(pass.fragPos - eyePos);
    vec3 R = reflect(I, normalize(pass.normal));
	FragColor = vec4(texture(cubemap, R).rgb, 1.0);
}
```

`old/demos/Cubemap/resources/shaders/reflection.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 normal;

// Uniforms
uniform mat4 mvp;
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;

// Varyings
out vertexData
{
    vec3 fragPos;
    vec3 normal;
} pass;

void main()
{
    pass.normal = mat3(transpose(inverse(modelMat))) * normal;

    pass.fragPos = vec3(modelMat * vec4(position, 1.0));
	gl_Position = projMat * viewMat * vec4(pass.fragPos, 1.0);
}
```

`old/demos/Cubemap/resources/shaders/refraction.frag`:

```frag
#version 330 core

// Varyings
in vertexData
{
    vec3 fragPos;
    vec3 normal;
} pass;

// Uniforms
uniform vec3 eyePos;
uniform samplerCube cubemap;

// Targets
layout (location = 0) out vec4 FragColor;

void main()
{
    float ratio = 1.00 / 1.53;
    vec3 I = normalize(pass.fragPos - eyePos);
    vec3 R = refract(I, normalize(pass.normal), ratio);
	FragColor = vec4(texture(cubemap, R).rgb, 1.0);
}
```

`old/demos/Cubemap/resources/shaders/refraction.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 normal;

// Uniforms
uniform mat4 mvp;
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;

// Varyings
out vertexData
{
    vec3 fragPos;
    vec3 normal;
} pass;

void main()
{
    pass.normal = mat3(transpose(inverse(modelMat))) * normal;

    pass.fragPos = vec3(modelMat * vec4(position, 1.0));
	gl_Position = projMat * viewMat * vec4(pass.fragPos, 1.0);
}
```

`old/demos/Cubemap/src/GameScene.cpp`:

```cpp
#include "GameScene.hpp"

#include <stb/stb_image.h>

void GameScene::Start()
{
    Scene::Start();

    App* app = App::Inst();

    // Camera
    Camera * camera = (Camera *)AddEntity("Camera", std::make_unique<Camera>());
    camera->SetPosition(glm::vec3(0.0f, 0.0f, 5.0f));
    app->SetCurrentCamera(camera);

    // Shaders
    printf("\nLoading Shaders\n");

    app->AddShader("reflection", new Shader({
        "shaders/reflection.vert",
        "shaders/reflection.frag" }));

    app->AddShader("refraction", new Shader({
        "shaders/refraction.vert",
        "shaders/refraction.frag" }));

    std::vector<std::string> faces = {
        "images/skyboxes/demo/right.jpg",
        "images/skyboxes/demo/left.jpg",
        "images/skyboxes/demo/top.jpg",
        "images/skyboxes/demo/bottom.jpg",
        "images/skyboxes/demo/front.jpg",
        "images/skyboxes/demo/back.jpg",
    };

    // Call skybox here
    CreateSkybox(faces);

    Entity* Cube = AddEntity("Cube");
    StaticMeshComponent* CubeMesh = Cube->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());

    CubeMesh->SetShader(app->GetShader("reflection"));

    if (CubeMesh->Load("models/Primitives/pCube.glb"))
    {
        Cube->SetPosition(glm::vec3(-1.5f, -1.0f, 0.0f));
        //Cube->SetRotation(glm::vec3(20.0f, 0.0f, 20.0f));
        //Cube->SetScale(glm::vec3(1.0f, 1.0f, 1.0f));
    }

    // UI
    DevUI::Start();

    // UI
    DevUI::RegisterOptionsFunc([=]() {
        ImGui::RadioButton("Enable Reflection", (int*)&_mMode, (int)Mode::REFLECTION);
        ImGui::RadioButton("Enable Refraction", (int*)&_mMode, (int)Mode::REFRACTION);

        App* app = App::Inst();

        switch (_mMode)
        {
        case Mode::REFLECTION:
            CubeMesh->SetShader(app->GetShader("reflection"));
            break;
        case Mode::REFRACTION:
            CubeMesh->SetShader(app->GetShader("refraction"));
            break;
        }
    });
}

void GameScene::Update(float dt)
{
    App* app = App::Inst();

    Scene::Update(dt);
}

void GameScene::Render()
{
    App* app = App::Inst();

    glm::vec3 eyePos = app->GetCurrentCamera()->GetPosition();

    auto refection = app->GetShader("reflection");
    refection->Use();
    refection->SetVec3("eyePos", eyePos);

    auto refraction = app->GetShader("refraction");
    refraction->Use();
    refraction->SetVec3("eyePos", eyePos);

    // Use this after using an objects shader 
    // to get the skybox info
    GetSkybox()->PreRender();

    // Render everything else after
    Scene::Render();
}
```

`old/demos/Cubemap/src/GameScene.hpp`:

```hpp
#ifndef GAMESCENE_H
#define GAMESCENE_H

#include <Toon.hpp>

enum class Mode : int
{
    REFLECTION,
    REFRACTION,
};

class GameScene : public Scene
{
public:
    GameScene() {};

    void Start() override;
    void Update(float dt) override;
    void Render() override;

private:
    Mode _mMode = Mode::REFLECTION;
};

#endif // GAMESCENE_H
```

`old/demos/Cubemap/src/Main.cpp`:

```cpp
#include <Toon.hpp>

#include "GameScene.hpp"

int main(int argc, char * argv[])
{
    Utils::SetAssetPath(RESOURCE_PATH);
    const auto& paths = Utils::GetResourcePaths();

    App app;
    Scene* gameScene = new GameScene();

    app.SetCurrentScene(gameScene);

    if (!app.Start())
    {
        return EXIT_FAILURE;
    }

    app.Run();

    delete gameScene;

    return EXIT_SUCCESS;
}


```

`old/demos/LightCasters/CMakeLists.txt`:

```txt

GET_FILENAME_COMPONENT(EXAMPLE "${CMAKE_CURRENT_LIST_DIR}" NAME)

ADD_EXECUTABLE(${EXAMPLE}
    src/Main.cpp
    src/GameScene.hpp
    src/GameScene.cpp
)

TARGET_LINK_LIBRARIES(${EXAMPLE}
    ${PROJECT_NAME}
)

FILE(RELATIVE_PATH EXAMPLE_RESOURCE_PATH "${CMAKE_BINARY_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/resources")

TARGET_COMPILE_DEFINITIONS(${EXAMPLE}
    PUBLIC -DRESOURCE_PATH="${EXAMPLE_RESOURCE_PATH}:${RESOURCE_PATH}"
)

IF(MSVC)
    SET_TARGET_PROPERTIES(
        ${EXAMPLE} 
        PROPERTIES 
            VS_DEBUGGER_ENVIRONMENT "PATH=%PATH%;${RUNTIME_SEARCH_PATH}"
    )
ENDIF()

```

`old/demos/LightCasters/resources/shaders/lightCasters.frag`:

```frag
#version 330 core

struct Material {
    sampler2D diffuseMap;
};

struct DirLight {
    vec4 direction;
};

struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;
};

struct SpotLight {
    vec3 position;
    vec4 direction;

    float cutoff;
    float outerCutoff;
};

struct LightCheck {
    bool Directional;
    bool Point;
    bool Spot;
};

// Varyings
in vertexData
{
    vec3 fragPos;
    vec3 normal;
    vec2 texCoords;
} pass;

// Uniforms
uniform vec3 lightColor;
uniform vec4 eyePos;

uniform Material material;
uniform DirLight dirLight;
uniform PointLight pointLight;
uniform SpotLight spotlight;
uniform LightCheck lightCheck;

// Targets
layout (location = 0) out vec4 fragColor;

vec3 CalculateDirectionalLight(DirLight light, vec3 normal, vec3 viewDir)
{
    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    // diffuse
    vec3 lightDir = normalize(-light.direction.xyz);
    float diff = max(dot(pass.normal, lightDir), 0.0);

    // specular
    float specularStrength = 0.5;
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);

    // combine results
    vec3 diffuse = diff * lightColor;
    vec3 specular = specularStrength * spec * lightColor;
    return (ambient + diffuse + specular);
}

vec3 CalculatePointLight(PointLight light, vec3 normal, vec3 viewDir)
{
    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    // diffuse
    vec3 lightDir = normalize(light.position - pass.fragPos);
    float diff = max(dot(pass.normal, lightDir), 0.0);

    // specular
    float specularStrength = 0.5;
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);

    // attenuation calculations
    float dist = length(light.position - pass.fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * dist +
                        light.quadratic * (dist * dist));

    // combine results
    vec3 diffuse = diff * lightColor;
    vec3 specular = specularStrength * spec * lightColor;
            
    // Apply attenuation
    //ambient *= attenuation;
    diffuse *= attenuation;
    specular *= attenuation;

    return (ambient + diffuse + specular);
}

vec3 CalculateSpotlight(SpotLight light, vec3 normal, vec3 viewDir)
{
    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    // diffuse 
    vec3 lightDir = normalize(light.position.xyz - pass.fragPos);
    float diff = max(dot(pass.normal, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;

    // specular
    float specularStrength = 0.5;
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);
    vec3 specular = specularStrength * spec * lightColor;


    float theta = dot(lightDir, normalize(-light.direction.xyz));
    float epsilon = light.cutoff - light.outerCutoff;
    float intensity = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);

    diffuse *= intensity;
    specular *= intensity;

    vec3 result;

    if (theta > light.cutoff)
    {
        result = (ambient + diffuse + specular) * lightColor;
    }
    else // use ambient light so scene isn't completely dark outside of spotlight.
    {
        //diffuse /= 8.0;
        result = (ambient + diffuse) * lightColor;
    }

    return result;
}

void main()
{

    // Setup
    vec3 normal = normalize(pass.normal);
    vec3 viewDir = normalize(eyePos.xyz - pass.fragPos);
    vec3 objectColor = texture(material.diffuseMap, pass.texCoords).rgb;

    // Directional Light
    vec3 result;
    if (lightCheck.Directional)
        result += CalculateDirectionalLight(dirLight, normal, viewDir);

    // Point Light
    if (lightCheck.Point)
        result += CalculatePointLight(pointLight, normal, viewDir);

    // Spot Light
    if (lightCheck.Spot)
        result += CalculateSpotlight(spotlight, normal, viewDir);

    // Apply the textures
    result *= objectColor;

    // Limit the amount because it's bright
    //result *= 0.75;

    fragColor = vec4(result, 1.0);
}

```

`old/demos/LightCasters/resources/shaders/lightCasters.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
layout (location = 2) in vec2 texCoords;

// Uniforms
uniform mat4 mvp;
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;

// Varyings
out vertexData
{
    vec3 fragPos;
    vec3 normal;
    vec2 texCoords;
} pass;

void main()
{
    pass.fragPos = vec3(modelMat * vec4(position.xyz, 1.0));
    pass.normal = mat3(transpose(inverse(modelMat))) * normal.xyz;
    pass.texCoords = vec2(texCoords.x, 1.0 - texCoords.y);

    gl_Position =  projMat * viewMat * vec4(pass.fragPos, 1.0);
}

```

`old/demos/LightCasters/src/GameScene.cpp`:

```cpp
#include "GameScene.hpp"

#include <Light.hpp>

#include <imgui/imgui.h>

void GameScene::Start()
{
    Scene::Start();

    // Object setup
    printf("\nLoading Models/Materials\n");

    // Camera
    Camera * camera = (Camera *)AddEntity("Camera", std::make_unique<Camera>());
    camera->SetPosition(glm::vec3(0.0f, 0.0f, 5.0f));
    App::Inst()->SetCurrentCamera(camera);

    // Shaders
    printf("\nLoading Shaders\n");

    App* app = App::Inst();
    app->AddShader("passThru", new Shader({
        "shaders/passThruColor.vert",
        "shaders/passThruColor.frag" }));

    app->AddShader("lightCasters", new Shader({
        "shaders/lightCasters.vert",
        "shaders/lightCasters.frag" }));

    // Initialize Objs
    auto Plane = AddEntity("Plane");
    StaticMeshComponent* PlaneMesh = Plane->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    PlaneMesh->SetShader(app->GetShader("lightCasters"));

    auto Sphere = AddEntity("Sphere");
    StaticMeshComponent* SphereMesh = Sphere->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    SphereMesh->SetShader(app->GetShader("lightCasters"));

    auto Cube = AddEntity("Cube");
    StaticMeshComponent* CubeMesh = Cube->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    CubeMesh->SetShader(app->GetShader("lightCasters"));

    auto Torus = AddEntity("Torus");
    StaticMeshComponent* TorusMesh = Torus->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    TorusMesh->SetShader(app->GetShader("lightCasters"));

    // Scene Objs
    if (PlaneMesh->Load("models/Primitives/pPlane.glb"))
    {
        Plane->SetPosition(glm::vec3(0.0f, -2.5f, 0.0f));
        Plane->SetRotation(glm::vec3(0.0f, 0.0f, 0.0f));
        Plane->SetScale(glm::vec3(5.0f, 5.0f, 5.0f));
    }

    if (SphereMesh->Load("models/Primitives/pSphere.glb"))
    {
        Sphere->SetPosition(glm::vec3(1.5f, 0.0f, 2.0f));
        Sphere->SetRotation(glm::vec3(90.0f, 0.0f, 0.0f));
        Sphere->SetScale(glm::vec3(0.5f, 0.5f, 0.5f));
    }

    if (CubeMesh->Load("models/Primitives/pCube.glb"))
    {
        Cube->SetPosition(glm::vec3(-1.5f, -1.0f, 0.0f));
        Cube->SetRotation(glm::vec3(20.0f, 0.0f, 20.0f));
        Cube->SetScale(glm::vec3(1.0f, 1.0f, 1.0f));
    }

    if (TorusMesh->Load("models/Primitives/pTorus.glb"))
    {
        Torus->SetPosition(glm::vec3(1.0f, 1.0f, -1.0f));
        Torus->SetRotation(glm::vec3(-90.0f, -90.0f, 0.0f));
        Torus->SetScale(glm::vec3(0.5f, 0.5f, 0.5f));
    }
    
    // Lights

    auto dirLight = AddEntity("dLight", std::make_unique<DirectionalLight>());
    dirLight->SetPosition(glm::vec3(0.0f));
    dirLight->SetRotation(glm::vec3(-0.2f, -1.0f, -0.3f));

    auto pLight = AddEntity("pLight",
        std::make_unique<PointLight>(
            glm::vec3(0.0f, 0.0f, 0.0f),
            1.0f,
            0.09f,
            0.032f
        ));
    
    auto sLight = AddEntity("sLight",
        std::make_unique<SpotLight>(
            App::Inst()->GetCurrentCamera()->GetPosition(),
            glm::cos(glm::radians(12.5f)),
            glm::cos(glm::radians(17.5f))
        ));

    // UI
    DevUI::RegisterOptionsFunc([this]() {
        ImGui::Checkbox("Enable Directional Light", &_mDirLight);
        ImGui::Checkbox("Enable Point Light", &_mPointLight);
        ImGui::Checkbox("Enable Spot Light", &_mSpotLight);
    });
}

void GameScene::Update(float dt)
{
    Scene::Update(dt);

    // Get the application for ease.
    App* app = App::Inst();

    // Get reference to each shader
    Shader* passThru = app->GetShader("passThru");
    Shader* lightCasters = app->GetShader("lightCasters");

    // Set Shader values

    // Set Light Color
    passThru->Use();
    glm::vec3 lightColor = glm::vec3(1.0f, 1.0f, 1.0f);
    passThru->SetVec3("passColor", lightColor);

    // Set Light Position
    lightCasters->Use();
    lightCasters->SetVec3("lightColor", lightColor);

    // Directional Lighting
    // Set Directional Light Position
    if (_mDirLight)
    {
        lightCasters->SetBool("lightCheck.Directional", true);
                
        glm::vec3 dir = FindEntity("dLight")->GetWorldRotation() * Utils::GetWorldForward();
        lightCasters->SetVec4("dirLight.direction", glm::vec4(dir, 0.0f));
    }
    else
        lightCasters->SetBool("lightCheck.Directional", false);

    // Point Lighting
    if (_mPointLight)
    {
        auto pLight = (PointLight*)FindEntity("pLight");

        lightCasters->SetBool("lightCheck.Point", true);
        lightCasters->SetFloat("pointLight.constant", pLight->GetConstant());
        lightCasters->SetFloat("pointLight.linear", pLight->GetLinear());
        lightCasters->SetFloat("pointLight.quadratic", pLight->GetQuadratic());

        lightCasters->SetVec4("pointLight.position", glm::vec4(pLight->GetPosition(), 1.0f));
    }
    else
        lightCasters->SetBool("lightCheck.Point", false);

    // Spotlight Lighting
    if (_mSpotLight)
    {
        auto sLight = (SpotLight*)FindEntity("sLight");

        lightCasters->SetBool("lightCheck.Spot", true);
        lightCasters->SetVec3("spotlight.position", sLight->GetPosition());

        // Change 0.0f to 1.0f to just enable spotlight
        glm::vec4 camFront = glm::vec4(App::Inst()->GetCurrentCamera()->GetForward(), 1.0f);
        lightCasters->SetVec4("spotlight.direction", camFront);

        lightCasters->SetFloat("spotlight.cutoff", sLight->GetCutOff());
        lightCasters->SetFloat("spotlight.outerCutoff", sLight->GetOuterCutOff());
    }
    else
        lightCasters->SetBool("lightCheck.Spot", false);

    // Rotate objects
    FindEntity("Sphere")->SetRotation(FindEntity("Sphere")->GetWorldRotation()
        * glm::angleAxis(glm::radians(-0.25f) * dt, glm::vec3(1.0f, 0.0f, 0.0f)));
    FindEntity("Cube")->SetRotation(FindEntity("Cube")->GetWorldRotation()
        * glm::angleAxis(glm::radians(-0.25f) * dt, glm::vec3(0.0f, 1.0f, 0.0f)));
    FindEntity("Torus")->SetRotation(FindEntity("Torus")->GetWorldRotation()
        * glm::angleAxis(glm::radians(-0.25f) * dt, glm::vec3(0.0f, 1.0f, 1.0f)));
}

```

`old/demos/LightCasters/src/GameScene.hpp`:

```hpp
#ifndef GAMESCENE_H
#define GAMESCENE_H

#include <Toon.hpp>

class GameScene : public Scene
{
public:
    GameScene() {};

    void Start() override;
    void Update(float dt) override;

private:
    bool _mDirLight, _mPointLight, _mSpotLight;

};

#endif // GAMESCENE_H
```

`old/demos/LightCasters/src/Main.cpp`:

```cpp
#include <Toon.hpp>

#include "GameScene.hpp"

int main(int argc, char * argv[])
{
    Utils::SetAssetPath(RESOURCE_PATH);
    const auto& paths = Utils::GetResourcePaths();

    App app;
    Scene* gameScene = new GameScene();

    app.SetCurrentScene(gameScene);

    if (!app.Start())
    {
        return EXIT_FAILURE;
    }

    app.Run();

    delete gameScene;

    return EXIT_SUCCESS;
}


```

`old/demos/NormalMapping/CMakeLists.txt`:

```txt

GET_FILENAME_COMPONENT(EXAMPLE "${CMAKE_CURRENT_LIST_DIR}" NAME)

ADD_EXECUTABLE(${EXAMPLE}
    src/Main.cpp
    src/GameScene.hpp
    src/GameScene.cpp
)

TARGET_LINK_LIBRARIES(${EXAMPLE}
    ${PROJECT_NAME}
)

FILE(RELATIVE_PATH EXAMPLE_RESOURCE_PATH "${CMAKE_BINARY_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/resources")

TARGET_COMPILE_DEFINITIONS(${EXAMPLE}
    PUBLIC -DRESOURCE_PATH="${EXAMPLE_RESOURCE_PATH}:${RESOURCE_PATH}"
)

IF(MSVC)
    SET_TARGET_PROPERTIES(
        ${EXAMPLE} 
        PROPERTIES 
            VS_DEBUGGER_ENVIRONMENT "PATH=%PATH%;${RUNTIME_SEARCH_PATH}"
    )
ENDIF()

```

`old/demos/NormalMapping/resources/shaders/normalMapping.frag`:

```frag
#version 330 core

struct Material {
    vec3 diffuse;
    sampler2D diffuseMap;
    sampler2D normalMap;
    bool hasDiffuseMap;
    bool hasNormalMap;
};

// Uniforms
uniform Material material;
uniform vec3 lightColor;

// Varyings
in vertexData
{
    vec3 fragPos;
    vec2 texCoords;
    vec3 lightDir;
    vec3 eyeDir;
    vec3 normal;
} pass;

// Targets
layout (location = 0) out vec4 fragColor;

void main()
{
    vec3 objectColor = texture(material.diffuseMap, pass.texCoords).rgb;
    
    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * objectColor;
    
    // diffuse
    vec3 N;
    if (material.hasNormalMap)
        N = normalize(texture(material.normalMap, pass.texCoords).rgb * 2.0 - 1.0);
    else
        N = pass.normal;
    
    vec3 L = pass.lightDir;
    float diff = max(dot(N, L), 0.0);
    vec3 diffuse;
    if (material.hasDiffuseMap)
        diffuse = diff * objectColor;
    else
        diffuse = diff * lightColor;
    
    // specular
    //float specularStrength = 0.5;
    vec3 V = pass.eyeDir;
    vec3 halfwayDir = normalize(L + V);
    float spec = pow(max(dot(N, halfwayDir), 0.0), 32.0);
    vec3 specular = spec * lightColor;
        
    vec3 result = ambient + diffuse + specular;
    fragColor = vec4(result, 1.0);
}
```

`old/demos/NormalMapping/resources/shaders/normalMapping.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
layout (location = 2) in vec2 texCoords;
layout (location = 3) in vec4 tangent;

// Uniforms
uniform mat4 mvp;
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;
uniform vec4 lightPos;
uniform vec4 eyePos;

// Varyings
out vertexData
{
    vec3 fragPos;
    vec2 texCoords;
    vec3 lightDir;
    vec3 eyeDir;
    vec3 normal;
} pass;

void main()
{
    pass.fragPos = vec3(modelMat * vec4(position.xyz, 1.0));
    pass.texCoords = vec2(texCoords.x, 1.0 - texCoords.y);
    
    mat3 worldSpaceMatrix = transpose(inverse(mat3(modelMat)));
    vec3 T = normalize(worldSpaceMatrix * tangent.xyz);
    vec3 N = normalize(worldSpaceMatrix * normal.xyz);
    T = normalize(T - dot(T, N) * N);
    vec3 B = cross(N, T);// * tangent.w;
    
    mat3 TBN = mat3(T, B, N);
    
    vec3 tangentLightPos = lightPos.xyz * TBN;
    vec3 tangentEyePos = eyePos.xyz * TBN;
    vec3 tangentFragPos = pass.fragPos * TBN;
    pass.normal = N;
    
    pass.lightDir = normalize(tangentLightPos - tangentFragPos);
    pass.eyeDir = normalize(tangentEyePos - tangentFragPos);
    
    gl_Position =  mvp * vec4(position.xyz, 1.0);
}
```

`old/demos/NormalMapping/src/GameScene.cpp`:

```cpp
#include "GameScene.hpp"

void GameScene::Start()
{
    Scene::Start();

    // Object setup
    printf("\nLoading Models/Materials\n");

    // Camera
    Camera * camera = (Camera *)AddEntity("Camera", std::make_unique<Camera>());
    camera->SetPosition(glm::vec3(0.0f, 0.0f, 5.0f));
    App::Inst()->SetCurrentCamera(camera);

    // Light Source
    auto Light = AddEntity();
    Light->SetName("Light");
    Light->SetPosition(glm::vec3(0.0f, 0.0f, 0.0f));

    // Shaders
    printf("\nLoading Shaders\n");

    App* app = App::Inst();
    app->AddShader("passThru", new Shader({
        "shaders/passThruColor.vert",
        "shaders/passThruColor.frag" }));

    app->AddShader("normalMapping", new Shader({
        "shaders/normalMapping.vert",
        "shaders/normalMapping.frag" }));

    // Initialize Objs
    auto Earth = AddEntity("Earth");
    StaticMeshComponent* EarthMesh = Earth->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    EarthMesh->SetShader(app->GetShader("normalMapping"));

    auto Moon = AddEntity("Moon");
    StaticMeshComponent* MoonMesh = Moon->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    MoonMesh->SetShader(app->GetShader("normalMapping"));

    auto Mars = AddEntity("Mars");
    StaticMeshComponent* MarsMesh = Mars->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    MarsMesh->SetShader(app->GetShader("normalMapping"));

    // Scene Objs
    if (EarthMesh->Load("models/earth.glb"))
    {
        Earth->SetPosition(glm::vec3(2.0f, 0.0f, 0.0f));
        Earth->SetScale(glm::vec3(1.0f, 1.0f, 1.0f));
        Earth->SetRotation(glm::vec3(0.0f, 0.0f, 9.5f));
    }

    if (MoonMesh->Load("models/moon.glb"))
    {
        Moon->SetPosition(glm::vec3(-1.0f, 0.0f, 0.0f));
        Moon->SetScale(glm::vec3(0.2f, 0.2f, 0.2f));
    }

    if (MarsMesh->Load("models/mars.glb"))
    {
        Mars->SetPosition(glm::vec3(10.0f, 0.0f, 0.0f));
        Mars->SetScale(glm::vec3(1.2f, 1.2f, 1.2f));
    }
}

void GameScene::Update(float dt)
{
    Scene::Update(dt);

    // Get the application for ease.
    App* app = App::Inst();

    // Get reference to each shader
    Shader* passThru = app->GetShader("passThru");
    Shader* normalMapping = app->GetShader("normalMapping");

    // Set Shader values

    // Set Light Color
    passThru->Use();
    glm::vec3 lightColor = glm::vec3(1.0f, 1.0f, 1.0f);
    passThru->SetVec3("passColor", lightColor);

    // Set Light Position
    normalMapping->Use();

    normalMapping->SetVec3("lightColor", lightColor);
    glm::vec4 lightPos = glm::vec4(FindEntity("Light")->GetPosition(), 1.0f);
    normalMapping->SetVec4("lightPos", lightPos);

    glm::vec3 camPos = App::Inst()->GetCurrentCamera()->GetPosition();
    glm::vec4 eyePos = glm::vec4(camPos.x, camPos.y, camPos.z, 1.0f);
    normalMapping->SetVec4("eyePos", eyePos);

    // Rotate objects
    FindEntity("Earth")->SetRotation(FindEntity("Earth")->GetWorldRotation()
        * glm::angleAxis(glm::radians(-0.5f) * dt, glm::vec3(0.0f, 1.0f, 0.0f)));
    
    FindEntity("Moon")->SetRotation(FindEntity("Moon")->GetWorldRotation()
        * glm::angleAxis(glm::radians(-0.185f) * dt, glm::vec3(0.0f, 1.0f, 0.0f)));

    const auto& earthPos = FindEntity("Earth")->GetPosition();
    const auto& moonPos = FindEntity("Moon")->GetPosition();
    const auto& marsPos = FindEntity("Mars")->GetPosition();

    _mAngle += 0.5f * dt;

    if (_mAngle > 360.0f)
        _mAngle = 0.0f;

    float radian = glm::radians(_mAngle);

    float radius = glm::distance(moonPos, earthPos);

    float x = earthPos.x + (radius * cosf(radian));
    float z = earthPos.z + (radius * sinf(radian));

    glm::vec3 newPos = glm::vec3(x, 0.0f, -z);
    
    FindEntity("Moon")->SetPosition(newPos);
    
    _mMarsAngle += 0.5f * dt;

    if (_mMarsAngle > 360.0f)
        _mMarsAngle = 0.0f;

    float marsRadian = glm::radians(_mMarsAngle);

    float marsRadius = glm::distance(marsPos, glm::vec3(lightPos.x, lightPos.y, lightPos.z));

    float marsX = lightPos.x + (marsRadius * cosf(marsRadian));
    float marsZ = lightPos.z + (marsRadius * sinf(marsRadian));

    glm::vec3 newMarsPos = glm::vec3(marsX, 0.0f, -marsZ);

    //FindEntity("Mars")->SetPosition(newMarsPos);
}

```

`old/demos/NormalMapping/src/GameScene.hpp`:

```hpp
#ifndef GAMESCENE_H
#define GAMESCENE_H

#include <Toon.hpp>

class GameScene : public Scene
{
public:
    GameScene() {};

    void Start() override;
    void Update(float dt) override;

private:

    float _mAngle = 0;
    float _mMarsAngle = 0;
};

#endif // GAMESCENE_H
```

`old/demos/NormalMapping/src/Main.cpp`:

```cpp
#include <Toon.hpp>

#include "GameScene.hpp"

int main(int argc, char * argv[])
{
    Utils::SetAssetPath(RESOURCE_PATH);
    const auto& paths = Utils::GetResourcePaths();

    App app;
    Scene* gameScene = new GameScene();

    app.SetCurrentScene(gameScene);

    if (!app.Start())
    {
        return EXIT_FAILURE;
    }

    app.Run();

    delete gameScene;

    return EXIT_SUCCESS;
}


```

`old/demos/Sandbox/CMakeLists.txt`:

```txt

GET_FILENAME_COMPONENT(EXAMPLE "${CMAKE_CURRENT_LIST_DIR}" NAME)

ADD_EXECUTABLE(${EXAMPLE}
    src/Main.cpp
    src/GameScene.hpp
    src/GameScene.cpp
)

TARGET_LINK_LIBRARIES(${EXAMPLE}
    ${PROJECT_NAME}
)
 
FILE(RELATIVE_PATH BINARY_RESOURCE_PATH "${CMAKE_BINARY_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/resources")
FILE(RELATIVE_PATH SOURCE_RESOURCE_PATH "${CMAKE_CURRENT_SOURCE_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/resources")

TARGET_COMPILE_DEFINITIONS(${EXAMPLE}
    PUBLIC -DRESOURCE_PATH="${SOURCE_RESOURCE_PATH}:${BINARY_RESOURCE_PATH}:${CMAKE_SOURCE_DIR}/resources:${RESOURCE_PATH}"
)

IF(MSVC)
    SET_TARGET_PROPERTIES(
        ${EXAMPLE} 
        PROPERTIES 
            VS_DEBUGGER_ENVIRONMENT "PATH=%PATH%;${RUNTIME_SEARCH_PATH}"
    )
ENDIF()

```

`old/demos/Sandbox/resources/models/bulbasaur.mtl`:

```mtl
# Blender MTL File: 'None'
# Material Count: 1

newmtl None
Ns 0
Ka 0.000000 0.000000 0.000000
Kd 0.23529 0.70196 0.44313
Ks 0.8 0.8 0.8
d 1
illum 2

```

`old/demos/Sandbox/resources/models/bulbasaur.obj`:

```obj
# Blender v2.79 (sub 0) OBJ File: ''
# www.blender.org
mtllib bulbasaur.mtl
o bulbasaur_starter_1gen_flowalistik
v -0.105275 0.000000 0.378966
v -0.136409 0.000000 0.292046
v -0.033721 0.000000 0.240741
v -0.041956 0.000000 0.341460
v -0.013294 0.000000 0.401932
v 0.008957 0.000000 0.340577
v 0.064739 0.000000 0.383228
v -0.199942 0.000000 0.067112
v 0.068985 0.000000 0.206684
v -0.111984 0.000000 0.030053
v -0.285304 0.154632 0.040269
v -0.184498 0.301102 -0.058640
v -0.267106 0.252118 0.279071
v -0.168735 0.408850 0.199142
v -0.177436 0.341984 0.032774
v -0.103560 0.059273 0.324493
v -0.041630 0.060754 0.318314
v 0.008925 0.061502 0.313722
v 0.038661 0.061942 0.311022
v -0.041598 0.234710 0.342646
v -0.132999 0.235691 0.350639
v -0.014504 0.234524 0.340103
v 0.007976 0.234370 0.337993
v 0.061081 0.231512 0.334067
v 0.066284 0.106111 0.211982
v -0.233156 0.597211 0.241398
v -0.236709 0.523823 -0.060765
v -0.173035 0.860148 0.142215
v -0.097055 0.744573 0.015148
v 0.244075 0.199514 0.378936
v -0.244602 0.367816 -0.311637
v -0.015275 0.839044 -0.009582
v -0.108919 0.604223 -0.239301
v -0.075969 0.474066 -0.557196
v 0.244075 0.965660 0.168664
v 0.244075 0.862266 0.033353
v -0.121267 0.321436 -0.612367
v -0.338511 0.332432 -0.456853
v 0.244075 0.411348 -0.621705
v 0.244075 0.299422 -0.695164
v -0.234408 0.743584 -0.327954
v -0.091091 0.589000 -0.648597
v 0.244075 0.551354 -0.746038
v -0.077735 0.907309 -0.043480
v 0.244075 0.951858 0.043084
v -0.210317 0.877079 -0.408258
v -0.083613 0.736006 -0.691002
v 0.244075 0.680948 -0.803284
v -0.055391 1.009050 -0.089982
v 0.244075 1.083475 -0.020144
v 0.126239 1.156221 -0.571994
v 0.156259 1.117000 -0.641477
v 0.244075 1.104882 -0.668513
v 0.166927 1.191117 -0.511279
v 0.244075 1.208802 -0.473833
v 0.244075 1.123863 -0.560321
v -0.337404 0.179637 -0.180714
v -0.313477 0.069462 -0.200216
v -0.283108 0.070574 -0.182801
v -0.245229 0.069390 -0.161856
v -0.207350 0.068206 -0.140911
v -0.182383 0.067301 -0.127143
v -0.278093 0.000000 -0.181208
v -0.261693 0.000000 -0.111249
v -0.198215 0.000000 -0.145476
v -0.168391 0.000000 -0.085458
v -0.347321 0.000000 -0.155881
v -0.280036 0.000000 -0.374380
v -0.071604 0.000000 -0.235586
v -0.082775 0.169707 -0.240460
v -0.022141 0.000000 -0.550882
v 0.148712 0.000000 0.139202
v 0.244075 0.000000 0.182505
v 0.030196 0.000000 -0.119250
v 0.148137 0.164308 -0.679355
v 0.244075 0.206071 -0.697549
v 0.244075 0.000000 -0.478209
v 0.122865 0.489466 0.614411
v -0.110123 0.484923 0.514783
v 0.123088 0.574116 0.617289
v -0.144029 0.563375 0.502885
v 0.058988 0.729558 0.452161
v -0.019418 0.735595 0.393983
v -0.023867 0.620031 0.427129
v 0.058709 0.616146 0.485927
v 0.244075 0.891923 0.484650
v 0.244075 1.022669 0.231891
v 0.039824 0.983529 0.224472
v -0.080850 0.892662 0.340851
v -0.118888 1.051213 0.160760
v -0.037483 0.785501 0.422148
v 0.066259 0.767615 0.477830
v 0.060226 0.609063 0.567481
v -0.070566 0.611167 0.509181
v 0.244075 0.500724 0.646986
v -0.181093 1.051213 0.217182
v -0.084499 1.051213 0.230147
v 0.593425 0.000000 0.378966
v 0.530106 0.000000 0.341460
v 0.521871 0.000000 0.240741
v 0.624559 0.000000 0.292046
v 0.501444 0.000000 0.401932
v 0.479193 0.000000 0.340577
v 0.423411 0.000000 0.383228
v 0.688092 0.000000 0.067112
v 0.419165 0.000000 0.206684
v 0.600134 0.000000 0.030053
v 0.672648 0.301102 -0.058640
v 0.773454 0.154632 0.040269
v 0.755255 0.252118 0.279071
v 0.665586 0.341984 0.032774
v 0.656885 0.408850 0.199142
v 0.591710 0.059273 0.324493
v 0.529780 0.060754 0.318314
v 0.479225 0.061502 0.313722
v 0.449489 0.061942 0.311022
v 0.621149 0.235691 0.350639
v 0.529748 0.234710 0.342646
v 0.502654 0.234524 0.340103
v 0.480174 0.234370 0.337993
v 0.427069 0.231512 0.334067
v 0.421866 0.106111 0.211982
v 0.724859 0.523823 -0.060765
v 0.721306 0.597211 0.241398
v 0.585205 0.744573 0.015148
v 0.661185 0.860148 0.142215
v 0.732752 0.367816 -0.311637
v 0.597069 0.604223 -0.239301
v 0.503425 0.839044 -0.009582
v 0.564119 0.474066 -0.557196
v 0.826661 0.332432 -0.456853
v 0.609417 0.321436 -0.612367
v 0.579241 0.589000 -0.648597
v 0.722557 0.743584 -0.327954
v 0.565885 0.907309 -0.043480
v 0.571763 0.736006 -0.691002
v 0.698467 0.877079 -0.408258
v 0.543541 1.009050 -0.089982
v 0.331891 1.117000 -0.641477
v 0.361911 1.156221 -0.571994
v 0.321223 1.191117 -0.511279
v 0.825554 0.179637 -0.180714
v 0.670533 0.067301 -0.127143
v 0.695500 0.068206 -0.140911
v 0.733379 0.069390 -0.161856
v 0.771258 0.070574 -0.182801
v 0.801627 0.069462 -0.200216
v 0.749842 0.000000 -0.111249
v 0.766243 0.000000 -0.181208
v 0.656541 0.000000 -0.085458
v 0.686365 0.000000 -0.145476
v 0.835470 0.000000 -0.155881
v 0.768185 0.000000 -0.374380
v 0.559754 0.000000 -0.235586
v 0.570925 0.169707 -0.240460
v 0.510291 0.000000 -0.550882
v 0.339438 0.000000 0.139202
v 0.457954 0.000000 -0.119250
v 0.340013 0.164308 -0.679355
v 0.598273 0.484923 0.514783
v 0.365285 0.489466 0.614411
v 0.632178 0.563375 0.502885
v 0.365062 0.574116 0.617289
v 0.429162 0.729558 0.452161
v 0.429440 0.616146 0.485927
v 0.512017 0.620031 0.427129
v 0.507568 0.735595 0.393983
v 0.569000 0.892662 0.340851
v 0.448326 0.983529 0.224472
v 0.607038 1.051213 0.160760
v 0.421891 0.767615 0.477830
v 0.525633 0.785501 0.422148
v 0.558716 0.611167 0.509181
v 0.427924 0.609063 0.567481
v 0.669243 1.051213 0.217182
v 0.572648 1.051213 0.230147
vn 0.0000 -1.0000 -0.0000
vn -0.3519 -0.3453 -0.8700
vn -0.3647 -0.3428 -0.8657
vn -0.8660 -0.4364 0.2441
vn -0.8662 -0.4357 0.2447
vn -0.8696 0.4722 -0.1443
vn -0.8611 0.4904 -0.1346
vn -0.8921 0.3195 0.3195
vn 0.0845 0.3544 0.9313
vn 0.4026 0.6130 0.6798
vn 0.0405 0.8148 0.5783
vn -0.8911 0.1657 0.4224
vn 0.9298 0.1477 0.3372
vn 0.0468 0.7665 0.6406
vn -0.5739 0.3274 0.7506
vn 0.0848 -0.1380 0.9868
vn 0.1015 -0.1292 0.9864
vn 0.0916 -0.1380 0.9862
vn 0.0653 -0.1429 0.9876
vn 0.0721 0.6651 0.7432
vn 0.0742 0.6659 0.7423
vn 0.0905 0.6746 0.7326
vn -0.4773 -0.2034 0.8549
vn -0.4802 -0.2065 0.8525
vn -0.3255 0.5837 0.7439
vn 0.9619 0.0108 0.2731
vn 0.9120 0.4095 0.0219
vn 0.7225 -0.0295 -0.6908
vn 0.6975 0.0534 -0.7146
vn 0.9673 -0.1552 0.2006
vn -0.8592 0.4886 -0.1521
vn -0.9354 -0.3410 0.0938
vn -0.9603 -0.2380 0.1459
vn -0.8575 0.0020 -0.5145
vn -0.8180 0.5611 -0.1266
vn -0.2849 -0.6747 0.6809
vn -0.9593 -0.2252 0.1702
vn -0.9611 -0.2167 0.1712
vn -0.7602 0.5832 -0.2862
vn -0.7629 0.5805 -0.2846
vn -0.7754 0.5521 -0.3064
vn -0.7863 0.5355 -0.3083
vn -0.2350 0.7723 -0.5902
vn -0.1844 0.3952 0.8999
vn -0.5134 0.4224 -0.7470
vn -0.4511 0.8893 0.0750
vn -0.0609 0.5477 -0.8345
vn -0.1824 0.3817 -0.9061
vn -0.7408 -0.6717 -0.0073
vn -0.9865 -0.1593 -0.0370
vn -0.2825 -0.6196 -0.7323
vn -0.2704 -0.6393 -0.7199
vn -0.7159 -0.3572 0.5999
vn -0.7456 -0.2897 0.6001
vn -0.2448 -0.1047 0.9639
vn -0.1818 0.2988 0.9368
vn -0.9221 -0.0632 -0.3817
vn -0.3507 -0.2430 -0.9044
vn -0.2972 -0.3858 -0.8734
vn -0.8949 0.3326 0.2977
vn -0.8927 0.3394 0.2964
vn -0.3029 0.4127 0.8590
vn -0.2895 0.4498 0.8449
vn -0.6726 0.4812 -0.5622
vn -0.6734 0.4953 -0.5489
vn -0.2477 0.2766 -0.9285
vn -0.2657 0.2921 -0.9187
vn -0.6434 0.7654 -0.0087
vn -0.6403 0.7681 -0.0068
vn -0.3305 0.9097 0.2513
vn -0.2877 0.9251 0.2479
vn 0.2798 0.8828 -0.3774
vn 0.0824 0.9816 -0.1722
vn 0.2657 0.7481 -0.6080
vn 0.1739 0.7026 -0.6900
vn -0.7346 0.5924 0.3307
vn -0.4744 -0.2523 0.8434
vn -0.4743 -0.2523 0.8435
vn -0.4743 -0.2522 0.8435
vn -0.4739 -0.2515 0.8439
vn -0.4842 -0.0147 0.8748
vn -0.9048 0.3694 0.2121
vn -0.4827 -0.1227 0.8672
vn -0.8920 0.0891 0.4432
vn -0.3715 0.6030 0.7060
vn 0.4746 0.0046 0.8802
vn 0.3432 0.0456 0.9381
vn -0.4058 0.6240 0.6678
vn -0.9208 0.2677 -0.2836
vn -0.9756 -0.1936 -0.1032
vn -0.9742 -0.1982 -0.1080
vn 0.7486 0.4546 0.4826
vn 0.8916 0.0715 0.4471
vn 0.6123 -0.2172 0.7602
vn -0.3004 -0.6871 0.6616
vn -0.2879 -0.6719 0.6824
vn -0.7335 -0.5907 0.3363
vn -0.7154 -0.6762 0.1757
vn 0.1846 -0.7169 -0.6722
vn 0.1837 -0.7164 -0.6731
vn -0.1968 0.0250 -0.9801
vn -0.2185 0.0411 -0.9750
vn -0.8175 -0.5744 -0.0423
vn -0.7522 -0.0306 0.6582
vn -0.5622 -0.3193 -0.7628
vn -0.5404 -0.2909 -0.7895
vn -0.3853 -0.2866 -0.8772
vn -0.2797 -0.6730 0.6847
vn -0.2848 -0.6766 0.6790
vn -0.3925 -0.0302 0.9193
vn -0.5650 0.2475 0.7871
vn -0.5558 0.2385 0.7964
vn -0.1837 0.8731 0.4516
vn -0.2030 0.8627 0.4631
vn -0.1323 0.6949 -0.7068
vn -0.1172 0.7376 -0.6650
vn -0.8750 0.3327 0.3516
vn -0.8771 0.3368 0.3425
vn -0.7034 0.2634 -0.6602
vn 0.4838 0.4033 -0.7767
vn -0.8963 -0.3635 0.2540
vn -0.8998 -0.3492 0.2615
vn -0.3566 0.4688 0.8081
vn -0.3555 0.4640 0.8114
vn -0.3605 0.4861 0.7961
vn -0.3589 0.4435 0.8212
vn -0.3593 0.4697 0.8064
vn -0.3695 0.4742 0.7991
vn -0.3743 0.4701 0.7993
vn -0.3608 0.4666 0.8075
vn -0.5230 -0.5546 0.6472
vn -0.4840 -0.4239 0.7656
vn -0.9800 0.0590 0.1901
vn -0.9984 0.0510 0.0230
vn -0.0149 0.9961 0.0868
vn -0.0255 0.9953 0.0930
vn 0.8586 0.1105 0.5006
vn 0.8860 0.0613 0.4596
vn 0.0058 0.3833 0.9236
vn -0.1377 -0.6585 0.7399
vn -0.2566 -0.0322 0.9660
vn -0.6499 0.2537 -0.7165
vn -0.8734 -0.2093 0.4396
vn -0.6853 -0.6687 0.2884
vn 0.4577 0.8597 -0.2268
vn 0.3319 0.5451 0.7698
vn -0.1096 0.5673 0.8162
vn 0.0000 1.0000 0.0000
vn 0.3647 -0.3428 -0.8657
vn 0.3519 -0.3453 -0.8700
vn 0.8662 -0.4357 0.2447
vn 0.8660 -0.4364 0.2441
vn 0.8611 0.4904 -0.1346
vn 0.8696 0.4722 -0.1443
vn 0.8921 0.3195 0.3195
vn -0.4026 0.6130 0.6798
vn -0.0845 0.3544 0.9313
vn 0.8911 0.1657 0.4224
vn -0.0405 0.8148 0.5783
vn -0.9298 0.1477 0.3372
vn 0.5739 0.3274 0.7506
vn -0.0468 0.7665 0.6406
vn -0.1015 -0.1292 0.9864
vn -0.0848 -0.1380 0.9868
vn -0.0916 -0.1380 0.9862
vn -0.0653 -0.1429 0.9876
vn -0.0721 0.6651 0.7432
vn -0.0742 0.6659 0.7423
vn -0.0905 0.6746 0.7326
vn 0.4802 -0.2065 0.8525
vn 0.4773 -0.2034 0.8549
vn 0.3255 0.5837 0.7439
vn -0.9120 0.4095 0.0219
vn -0.9619 0.0108 0.2731
vn -0.6975 0.0534 -0.7146
vn -0.7225 -0.0295 -0.6908
vn -0.9673 -0.1552 0.2006
vn 0.8592 0.4886 -0.1521
vn 0.9603 -0.2380 0.1459
vn 0.9354 -0.3410 0.0938
vn 0.8180 0.5611 -0.1266
vn 0.8575 0.0020 -0.5145
vn 0.2849 -0.6747 0.6809
vn 0.9611 -0.2167 0.1712
vn 0.9593 -0.2252 0.1702
vn 0.7629 0.5805 -0.2846
vn 0.7602 0.5832 -0.2862
vn 0.7863 0.5355 -0.3083
vn 0.7754 0.5521 -0.3064
vn 0.1844 0.3952 0.8999
vn 0.2350 0.7723 -0.5902
vn 0.4511 0.8893 0.0750
vn 0.5134 0.4224 -0.7470
vn 0.1824 0.3817 -0.9061
vn 0.0609 0.5477 -0.8345
vn 0.9865 -0.1593 -0.0370
vn 0.7408 -0.6717 -0.0073
vn 0.2704 -0.6393 -0.7199
vn 0.2825 -0.6196 -0.7323
vn 0.7456 -0.2897 0.6001
vn 0.7159 -0.3572 0.5999
vn 0.1818 0.2988 0.9368
vn 0.2448 -0.1047 0.9639
vn 0.9221 -0.0632 -0.3817
vn 0.2972 -0.3858 -0.8734
vn 0.3507 -0.2430 -0.9044
vn 0.8927 0.3394 0.2964
vn 0.8949 0.3326 0.2977
vn 0.2895 0.4498 0.8449
vn 0.3029 0.4127 0.8590
vn 0.6734 0.4953 -0.5489
vn 0.6726 0.4812 -0.5622
vn 0.2657 0.2921 -0.9187
vn 0.2477 0.2766 -0.9285
vn 0.6403 0.7681 -0.0068
vn 0.6434 0.7654 -0.0087
vn 0.2877 0.9251 0.2479
vn 0.3305 0.9097 0.2513
vn -0.2798 0.8828 -0.3774
vn -0.0824 0.9816 -0.1722
vn -0.2657 0.7481 -0.6080
vn -0.1739 0.7026 -0.6900
vn 0.7346 0.5924 0.3307
vn 0.4739 -0.2515 0.8439
vn 0.4743 -0.2522 0.8435
vn 0.4743 -0.2523 0.8435
vn 0.4744 -0.2523 0.8434
vn 0.9048 0.3694 0.2121
vn 0.4842 -0.0147 0.8748
vn 0.8920 0.0891 0.4432
vn 0.4827 -0.1227 0.8672
vn -0.4746 0.0046 0.8802
vn 0.3715 0.6030 0.7060
vn 0.4058 0.6240 0.6678
vn -0.3432 0.0456 0.9381
vn 0.9208 0.2677 -0.2836
vn 0.9742 -0.1982 -0.1080
vn 0.9756 -0.1936 -0.1032
vn -0.7486 0.4546 0.4826
vn -0.6123 -0.2172 0.7602
vn -0.8916 0.0715 0.4471
vn 0.2879 -0.6719 0.6824
vn 0.3004 -0.6871 0.6616
vn 0.7154 -0.6762 0.1757
vn 0.7335 -0.5907 0.3363
vn -0.1837 -0.7164 -0.6731
vn -0.1846 -0.7169 -0.6722
vn 0.2185 0.0411 -0.9750
vn 0.1968 0.0250 -0.9801
vn 0.7522 -0.0306 0.6582
vn 0.8175 -0.5744 -0.0423
vn 0.5404 -0.2909 -0.7895
vn 0.5622 -0.3193 -0.7628
vn 0.3853 -0.2866 -0.8772
vn 0.2848 -0.6766 0.6790
vn 0.2797 -0.6730 0.6847
vn 0.3925 -0.0302 0.9193
vn 0.5558 0.2385 0.7964
vn 0.5650 0.2475 0.7871
vn 0.2030 0.8627 0.4631
vn 0.1837 0.8731 0.4516
vn 0.1172 0.7376 -0.6650
vn 0.1323 0.6949 -0.7068
vn 0.8771 0.3368 0.3425
vn 0.8750 0.3327 0.3516
vn -0.4838 0.4033 -0.7767
vn 0.7034 0.2634 -0.6602
vn 0.8998 -0.3492 0.2615
vn 0.8963 -0.3635 0.2540
vn 0.3555 0.4640 0.8114
vn 0.3566 0.4688 0.8081
vn 0.3589 0.4435 0.8212
vn 0.3605 0.4861 0.7961
vn 0.3695 0.4742 0.7991
vn 0.3593 0.4697 0.8064
vn 0.3608 0.4666 0.8075
vn 0.3743 0.4701 0.7993
vn 0.4840 -0.4239 0.7656
vn 0.5230 -0.5546 0.6472
vn 0.9984 0.0510 0.0230
vn 0.9800 0.0590 0.1901
vn 0.0255 0.9953 0.0930
vn 0.0149 0.9961 0.0868
vn -0.8860 0.0613 0.4596
vn -0.8586 0.1105 0.5006
vn -0.0058 0.3833 0.9236
vn 0.1377 -0.6585 0.7399
vn 0.2566 -0.0322 0.9660
vn 0.6499 0.2537 -0.7165
vn 0.8734 -0.2093 0.4396
vn 0.6853 -0.6687 0.2884
vn -0.3319 0.5451 0.7698
vn -0.4577 0.8597 -0.2268
vn 0.1096 0.5673 0.8162
usemtl None
s off
f 1//1 2//1 3//1
f 3//1 4//1 1//1
f 4//1 3//1 5//1
f 5//1 3//1 6//1
f 3//1 7//1 6//1
f 8//1 3//1 2//1
f 3//1 9//1 7//1
f 8//1 10//1 3//1
f 10//1 9//1 3//1
f 8//2 11//2 12//2
f 12//3 10//3 8//3
f 2//4 13//4 11//4
f 11//5 8//5 2//5
f 13//6 14//6 15//6
f 15//7 11//7 13//7
f 1//8 16//8 2//8
f 4//9 17//9 16//9
f 16//10 1//10 4//10
f 5//11 18//11 17//11
f 17//12 4//12 5//12
f 6//13 18//13 5//13
f 7//14 19//14 18//14
f 18//15 6//15 7//15
f 17//16 20//16 21//16
f 21//17 16//17 17//17
f 18//18 22//18 20//18
f 20//18 17//18 18//18
f 18//18 23//18 22//18
f 19//19 24//19 23//19
f 23//18 18//18 19//18
f 20//20 14//20 21//20
f 22//21 14//21 20//21
f 23//21 14//21 22//21
f 24//22 14//22 23//22
f 13//23 2//23 16//23
f 16//24 21//24 13//24
f 21//25 14//25 13//25
f 9//26 25//26 19//26
f 19//27 7//27 9//27
f 10//28 12//28 25//28
f 25//29 9//29 10//29
f 19//30 25//30 24//30
f 11//31 15//31 12//31
f 14//32 26//32 27//32
f 27//33 15//33 14//33
f 26//34 28//34 29//34
f 29//35 27//35 26//35
f 25//36 30//36 24//36
f 15//37 27//37 31//37
f 31//38 12//38 15//38
f 29//39 32//39 33//39
f 33//40 27//40 29//40
f 27//41 33//41 34//41
f 34//42 31//42 27//42
f 29//43 35//43 36//43
f 36//44 32//44 29//44
f 34//45 37//45 38//45
f 38//46 31//46 34//46
f 34//47 39//47 40//47
f 40//48 37//48 34//48
f 33//49 41//49 42//49
f 42//50 34//50 33//50
f 34//51 42//51 43//51
f 43//52 39//52 34//52
f 32//53 44//53 41//53
f 41//54 33//54 32//54
f 36//55 45//55 44//55
f 44//56 32//56 36//56
f 41//57 46//57 47//57
f 47//57 42//57 41//57
f 42//58 47//58 48//58
f 48//59 43//59 42//59
f 44//60 49//60 46//60
f 46//61 41//61 44//61
f 45//62 50//62 49//62
f 49//63 44//63 45//63
f 46//64 51//64 52//64
f 52//65 47//65 46//65
f 47//66 52//66 53//66
f 53//67 48//67 47//67
f 49//68 54//68 51//68
f 51//69 46//69 49//69
f 50//70 55//70 54//70
f 54//71 49//71 50//71
f 51//72 56//72 52//72
f 52//73 56//73 53//73
f 54//74 56//74 51//74
f 55//75 56//75 54//75
f 31//76 38//76 57//76
f 57//76 12//76 31//76
f 57//77 58//77 59//77
f 57//78 59//78 60//78
f 57//78 60//78 61//78
f 57//79 61//79 62//79
f 57//80 62//80 12//80
f 60//81 59//81 63//81
f 63//82 64//82 60//82
f 62//83 61//83 65//83
f 65//84 66//84 62//84
f 61//85 60//85 64//85
f 64//86 65//86 61//86
f 67//87 63//87 59//87
f 59//88 58//88 67//88
f 58//89 68//89 67//89
f 58//90 57//90 38//90
f 38//91 68//91 58//91
f 66//92 69//92 62//92
f 69//93 70//93 12//93
f 12//94 62//94 69//94
f 69//1 68//1 71//1
f 65//1 68//1 69//1
f 69//1 66//1 65//1
f 65//1 64//1 63//1
f 63//1 68//1 65//1
f 67//1 68//1 63//1
f 25//95 72//95 73//95
f 73//96 30//96 25//96
f 12//97 74//97 72//97
f 72//98 25//98 12//98
f 71//99 75//99 76//99
f 76//100 77//100 71//100
f 40//101 76//101 75//101
f 75//102 37//102 40//102
f 74//103 12//103 70//103
f 70//104 69//104 74//104
f 38//105 37//105 71//105
f 71//106 68//106 38//106
f 37//107 75//107 71//107
f 69//1 71//1 77//1
f 77//1 74//1 69//1
f 74//1 77//1 73//1
f 73//1 72//1 74//1
f 30//108 78//108 79//108
f 79//109 24//109 30//109
f 78//110 80//110 81//110
f 81//110 79//110 78//110
f 82//111 83//111 84//111
f 84//112 85//112 82//112
f 86//113 87//113 88//113
f 88//114 89//114 86//114
f 35//115 29//115 88//115
f 88//116 87//116 35//116
f 89//117 28//117 26//117
f 26//118 81//118 89//118
f 29//119 28//119 90//119
f 90//120 88//120 29//120
f 26//121 14//121 79//121
f 79//122 81//122 26//122
f 86//123 89//123 91//123
f 91//124 92//124 86//124
f 81//125 80//125 93//125
f 93//126 94//126 81//126
f 86//127 92//127 93//127
f 93//128 80//128 86//128
f 81//129 94//129 91//129
f 91//130 89//130 81//130
f 91//131 83//131 82//131
f 82//132 92//132 91//132
f 92//133 82//133 85//133
f 85//134 93//134 92//134
f 93//135 85//135 84//135
f 84//136 94//136 93//136
f 94//137 84//137 83//137
f 83//138 91//138 94//138
f 80//139 95//139 86//139
f 78//140 30//140 95//140
f 78//141 95//141 80//141
f 90//142 28//142 96//142
f 96//143 28//143 89//143
f 14//144 24//144 79//144
f 88//145 90//145 97//145
f 97//146 89//146 88//146
f 96//147 89//147 97//147
f 97//148 90//148 96//148
f 98//1 99//1 100//1
f 100//1 101//1 98//1
f 99//1 102//1 100//1
f 102//1 103//1 100//1
f 100//1 103//1 104//1
f 105//1 101//1 100//1
f 100//1 104//1 106//1
f 105//1 100//1 107//1
f 107//1 100//1 106//1
f 105//149 107//149 108//149
f 108//150 109//150 105//150
f 101//151 105//151 109//151
f 109//152 110//152 101//152
f 110//153 109//153 111//153
f 111//154 112//154 110//154
f 98//155 101//155 113//155
f 99//156 98//156 113//156
f 113//157 114//157 99//157
f 102//158 99//158 114//158
f 114//159 115//159 102//159
f 103//160 102//160 115//160
f 104//161 103//161 115//161
f 115//162 116//162 104//162
f 114//163 113//163 117//163
f 117//164 118//164 114//164
f 115//165 114//165 118//165
f 118//165 119//165 115//165
f 115//165 119//165 120//165
f 116//165 115//165 120//165
f 120//166 121//166 116//166
f 118//167 117//167 112//167
f 119//168 118//168 112//168
f 120//168 119//168 112//168
f 121//169 120//169 112//169
f 110//170 117//170 113//170
f 113//171 101//171 110//171
f 117//172 110//172 112//172
f 106//173 104//173 116//173
f 116//174 122//174 106//174
f 107//175 106//175 122//175
f 122//176 108//176 107//176
f 116//177 121//177 122//177
f 109//178 108//178 111//178
f 112//179 111//179 123//179
f 123//180 124//180 112//180
f 124//181 123//181 125//181
f 125//182 126//182 124//182
f 122//183 121//183 30//183
f 111//184 108//184 127//184
f 127//185 123//185 111//185
f 125//186 123//186 128//186
f 128//187 129//187 125//187
f 123//188 127//188 130//188
f 130//189 128//189 123//189
f 125//190 129//190 36//190
f 36//191 35//191 125//191
f 130//192 127//192 131//192
f 131//193 132//193 130//193
f 130//194 132//194 40//194
f 40//195 39//195 130//195
f 128//196 130//196 133//196
f 133//197 134//197 128//197
f 130//198 39//198 43//198
f 43//199 133//199 130//199
f 129//200 128//200 134//200
f 134//201 135//201 129//201
f 36//202 129//202 135//202
f 135//203 45//203 36//203
f 134//204 133//204 136//204
f 136//204 137//204 134//204
f 133//205 43//205 48//205
f 48//206 136//206 133//206
f 135//207 134//207 137//207
f 137//208 138//208 135//208
f 45//209 135//209 138//209
f 138//210 50//210 45//210
f 137//211 136//211 139//211
f 139//212 140//212 137//212
f 136//213 48//213 53//213
f 53//214 139//214 136//214
f 138//215 137//215 140//215
f 140//216 141//216 138//216
f 50//217 138//217 141//217
f 141//218 55//218 50//218
f 140//219 139//219 56//219
f 139//220 53//220 56//220
f 141//221 140//221 56//221
f 55//222 141//222 56//222
f 127//223 108//223 142//223
f 142//223 131//223 127//223
f 142//224 108//224 143//224
f 142//225 143//225 144//225
f 142//226 144//226 145//226
f 142//226 145//226 146//226
f 142//227 146//227 147//227
f 145//228 148//228 149//228
f 149//229 146//229 145//229
f 143//230 150//230 151//230
f 151//231 144//231 143//231
f 144//232 151//232 148//232
f 148//233 145//233 144//233
f 152//234 147//234 146//234
f 146//235 149//235 152//235
f 147//236 152//236 153//236
f 147//237 153//237 131//237
f 131//238 142//238 147//238
f 150//239 143//239 154//239
f 154//240 143//240 108//240
f 108//241 155//241 154//241
f 154//1 156//1 153//1
f 151//1 150//1 154//1
f 154//1 153//1 151//1
f 151//1 153//1 149//1
f 149//1 148//1 151//1
f 152//1 149//1 153//1
f 122//242 30//242 73//242
f 73//243 157//243 122//243
f 108//244 122//244 157//244
f 157//245 158//245 108//245
f 156//246 77//246 76//246
f 76//247 159//247 156//247
f 40//248 132//248 159//248
f 159//249 76//249 40//249
f 158//250 154//250 155//250
f 155//251 108//251 158//251
f 131//252 153//252 156//252
f 156//253 132//253 131//253
f 132//254 156//254 159//254
f 154//1 158//1 77//1
f 77//1 156//1 154//1
f 158//1 157//1 73//1
f 73//1 77//1 158//1
f 30//255 121//255 160//255
f 160//256 161//256 30//256
f 161//257 160//257 162//257
f 162//257 163//257 161//257
f 164//258 165//258 166//258
f 166//259 167//259 164//259
f 86//260 168//260 169//260
f 169//261 87//261 86//261
f 35//262 87//262 169//262
f 169//263 125//263 35//263
f 168//264 162//264 124//264
f 124//265 126//265 168//265
f 125//266 169//266 170//266
f 170//267 126//267 125//267
f 124//268 162//268 160//268
f 160//269 112//269 124//269
f 86//270 171//270 172//270
f 172//271 168//271 86//271
f 162//272 173//272 174//272
f 174//273 163//273 162//273
f 86//274 163//274 174//274
f 174//275 171//275 86//275
f 162//276 168//276 172//276
f 172//277 173//277 162//277
f 172//278 171//278 164//278
f 164//279 167//279 172//279
f 171//280 174//280 165//280
f 165//281 164//281 171//281
f 174//282 173//282 166//282
f 166//283 165//283 174//283
f 173//284 172//284 167//284
f 167//285 166//285 173//285
f 163//286 86//286 95//286
f 161//287 95//287 30//287
f 161//288 163//288 95//288
f 170//289 175//289 126//289
f 175//290 168//290 126//290
f 112//291 160//291 121//291
f 169//292 168//292 176//292
f 176//293 170//293 169//293
f 175//294 176//294 168//294
f 176//148 175//148 170//148

```

`old/demos/Sandbox/resources/shaders/advLighting.frag`:

```frag
#version 330 core

struct Material {
    sampler2D diffuseMap;
};

// Varyings
in vertexData
{
    vec3 fragPos;
    vec3 normal;
    vec2 texCoords;
} pass;

// Uniforms
uniform vec3 lightColor;
uniform vec4 lightVec;
uniform vec4 eyePos;

uniform Material material;

// Targets
layout (location = 0) out vec4 fragColor;

void main()
{
    vec3 objectColor = texture(material.diffuseMap, pass.texCoords).rgb;

    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
      
    // diffuse 
    vec3 norm = normalize(pass.normal);
    vec3 lightDir = normalize(lightVec.xyz - pass.fragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Specular
    vec3 specular = vec3(0.0, 0.0, 0.0);

    // We dot the normal and lightDir to make sure it won't 'leak'
    if (dot(norm, lightDir) >= 0.0f) {
        // specular
        float specularStrength = 0.5;
        vec3 viewDir = normalize(eyePos.xyz - pass.fragPos);
        vec3 halfwayDir = normalize(lightDir + viewDir);
        float spec = pow(max(dot(norm, halfwayDir), 0.0), 32.0);
        specular = specularStrength * spec * lightColor;
    }
        
    vec3 result = (ambient + diffuse + specular) * objectColor;
    fragColor = vec4(result, 1.0);
}

```

`old/demos/Sandbox/resources/shaders/advLighting.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
layout (location = 2) in vec2 texCoords;

// Uniforms
uniform mat4 mvp;
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;

// Varyings
out vertexData
{
    vec3 fragPos;
    vec3 normal;
    vec2 texCoords;
} pass;

void main()
{
    pass.fragPos = vec3(modelMat * vec4(position.xyz, 1.0));
    pass.normal = mat3(transpose(inverse(modelMat))) * normal.xyz;
    pass.texCoords = vec2(texCoords.x, 1.0 - texCoords.y);

    gl_Position =  projMat * viewMat * vec4(pass.fragPos, 1.0);
}
```

`old/demos/Sandbox/resources/shaders/normalMapping.frag`:

```frag
#version 330 core

struct Material {
    vec3 diffuse;
    sampler2D diffuseMap;
    sampler2D normalMap;
    bool hasDiffuseMap;
    bool hasNormalMap;
};

// Uniforms
uniform Material material;
uniform vec3 lightColor;

// Varyings
in vertexData
{
    vec3 fragPos;
    vec2 texCoords;
    vec3 lightDir;
    vec3 eyeDir;
    vec3 normal;
} pass;

// Targets
layout (location = 0) out vec4 fragColor;

void main()
{
    vec3 objectColor = texture(material.diffuseMap, pass.texCoords).rgb;
    
    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * objectColor;
    
    // diffuse
    vec3 N;
    if (material.hasNormalMap)
        N = normalize(texture(material.normalMap, pass.texCoords).rgb * 2.0 - 1.0);
    else
        N = pass.normal;
    
    vec3 L = pass.lightDir;
    float diff = max(dot(N, L), 0.0);
    vec3 diffuse;
    if (material.hasDiffuseMap)
        diffuse = diff * objectColor;
    else
        diffuse = diff * lightColor;
    
    // specular
    //float specularStrength = 0.5;
    vec3 V = pass.eyeDir;
    vec3 halfwayDir = normalize(L + V);
    float spec = pow(max(dot(N, halfwayDir), 0.0), 32.0);
    vec3 specular = spec * lightColor;
        
    vec3 result = ambient + diffuse + specular;
    fragColor = vec4(result, 1.0);
}
```

`old/demos/Sandbox/resources/shaders/normalMapping.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
layout (location = 2) in vec2 texCoords;
layout (location = 3) in vec4 tangent;

// Uniforms
uniform mat4 mvp;
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;
uniform vec4 lightPos;
uniform vec4 eyePos;

// Varyings
out vertexData
{
    vec3 fragPos;
    vec2 texCoords;
    vec3 lightDir;
    vec3 eyeDir;
    vec3 normal;
} pass;

void main()
{
    pass.fragPos = vec3(modelMat * vec4(position.xyz, 1.0));
    pass.texCoords = vec2(texCoords.x, 1.0 - texCoords.y);
    
    mat3 worldSpaceMatrix = transpose(inverse(mat3(modelMat)));
    vec3 T = normalize(worldSpaceMatrix * tangent.xyz);
    vec3 N = normalize(worldSpaceMatrix * normal.xyz);
    T = normalize(T - dot(T, N) * N);
    vec3 B = cross(N, T);// * tangent.w;
    
    mat3 TBN = mat3(T, B, N);
    
    vec3 tangentLightPos = lightPos.xyz * TBN;
    vec3 tangentEyePos = eyePos.xyz * TBN;
    vec3 tangentFragPos = pass.fragPos * TBN;
    pass.normal = N;
    
    pass.lightDir = normalize(tangentLightPos - tangentFragPos);
    pass.eyeDir = normalize(tangentEyePos - tangentFragPos);
    
    gl_Position =  mvp * vec4(position.xyz, 1.0);
}
```

`old/demos/Sandbox/resources/shaders/stencil.frag`:

```frag
/*
    Stencil Shader
    By Benji Campbell
*/

#version 330 core

// target
layout (location = 0) out vec4 fragColor;

void main()
{
    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
}

```

`old/demos/Sandbox/resources/shaders/stencil.vert`:

```vert
/*
    Stencil Shader
    By Benji Campbell
*/

#version 330 core

// attributes
layout (location = 0) in vec4 position;
// uniforms
uniform mat4 mvp;

void main()
{
    gl_Position = mvp * position;
}
```

`old/demos/Sandbox/resources/shaders/time.frag`:

```frag
#version 330 core

// Varyings
in vertexData
{
    vec3 fragPos;
    vec3 normal;
    vec2 texCoords;
} pass;

uniform float glfwtime;

// Targets
layout (location = 0) out vec4 fragColor;

void main()
{
    vec3 col = 0.5 + 0.5 * cos(glfwtime + pass.fragPos);

    fragColor = vec4(col, 1.0);
}

```

`old/demos/Sandbox/resources/shaders/time.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec4 position;
layout (location = 2) in vec4 normal;
layout (location = 8) in vec2 texCoords;

// Uniforms
uniform mat4 mvp;
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;

// Varyings
out vertexData
{
    vec3 fragPos;
    vec3 normal;
    vec2 texCoords;
} pass;

void main()
{
    pass.fragPos = vec3(modelMat * vec4(position.xyz, 1.0));
    pass.normal = mat3(transpose(inverse(modelMat))) * normal.xyz;
    pass.texCoords = texCoords;

    gl_Position =  projMat * viewMat * vec4(pass.fragPos, 1.0);
}
```

`old/demos/Sandbox/src/GameScene.cpp`:

```cpp
#include "GameScene.hpp"

void GameScene::Start()
{
    Scene::Start();

    LogTest();

    // Light Source
    auto Light = AddEntity("Light");
    Light->SetPosition(glm::vec3(0.0f, 0.0f, 2.0f));

    // Shaders
    printf("\nLoading Shaders\n");

    App* app = App::Inst();
    app->AddShader("passThru", new Shader({
        "shaders/passThruColor.vert",
        "shaders/passThruColor.frag" }));

    app->AddShader("normalMapping", new Shader({
        "shaders/normalMapping.vert",
        "shaders/normalMapping.frag" }));

    app->AddShader("advLighting", new Shader({
        "shaders/advLighting.vert",
        "shaders/advLighting.frag" }));
    
    app->AddShader("stencil", new Shader({
        "shaders/stencil.vert",
        "shaders/stencil.frag" }));

    // Scene Objs
     _mHelm = AddEntity("helm");
     _mHelmMesh = _mHelm->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
     _mHelmMesh->SetShader(app->GetShader("normalMapping"));

     if (_mHelmMesh->Load("models/DamagedHelm.glb"))
     {
         _mHelm->SetPosition(glm::vec3(2.0f, 0.0f, 1.0f));
         //_mHelm->SetPosition(glm::vec3(0.0f, 0.0f, 0.0f));
         _mHelm->SetRotation(glm::vec3(0.0f, 9.5f, 9.5f));
     }

    // _mCube = AddEntity("Cube");
    // _mCubeMesh = _mCube->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    // _mCubeMesh->SetShader(app->GetShader("advLighting"));

    // //if (_mCubeMesh->Load("models/Primitives/pCube.glb"))
    // if (_mCubeMesh->Load("models/LowPolyMale_Rigging_AnimationStomp.glb"))
    // {
    //     _mCube->SetPosition(glm::vec3(-2.0f, 0.0f, 1.0f));
    // }

    if (!LoadScene("models/LowPolyMale_Rigging_AnimationStomp2.glb"))
    {
       ToonLogWarn("Could not load scene!");
    }
    
    // if (!LoadScene("models/Donut_Texture_Displacement.glb"))
    // {
    //    ToonLogWarn("Could not load scene!");
    // }

    // Camera
    Camera * camera = (Camera *)AddEntity("Camera", std::make_unique<Camera>());
    camera->SetPosition(glm::vec3(0.0f, 0.0f, 5.0f));
    App::Inst()->SetCurrentCamera(camera);
}

void GameScene::Update(float dt)
{
    Scene::Update(dt);

    App* app = App::Inst();

    //
    auto norm = app->GetShader("normalMapping");
    glm::vec3 lightColor = glm::vec3(1.0f, 1.0f, 1.0f);
    norm->Use();
    norm->SetVec3("lightColor", lightColor);
    glm::vec4 lightPos = glm::vec4(FindEntity("Light")->GetWorldPosition(), 1.0f);
    norm->SetVec4("lightPos", lightPos);

    auto adv = app->GetShader("advLighting");
    adv->Use();
    adv->SetVec3("lightColor", lightColor);
    adv->SetVec4("lightVec", lightPos);
    
    adv->SetVec4("eyePos", glm::vec4(app->GetCurrentCamera()->GetPosition(), 1.0f));
}

void GameScene::Render()
{
    auto app = App::Inst();

    Scene::Render();
}

void GameScene::LogTest()
{
    // Log Test
    printf("\n");
    ToonLogInfo("Info");
    ToonLogWarn("Warning");
    ToonLogError("Error");
    ToonLogPerf("Perf");
    LogVerbose("Verb");
    ToonLogLoad("Load");
}
```

`old/demos/Sandbox/src/GameScene.hpp`:

```hpp
#ifndef GAMESCENE_H
#define GAMESCENE_H

#include <Toon.hpp>

class GameScene : public Scene
{
public:
    GameScene() {};

    void Start() override;
    void Update(float dt) override;
    void Render() override;
    void LogTest();

private:
    StaticMeshComponent* _mHelmMesh;
    StaticMeshComponent* _mCubeMesh;
    Entity* _mHelm;
    Entity* _mCube;
};

#endif // GAMESCENE_H
```

`old/demos/Sandbox/src/Main.cpp`:

```cpp
#include <Toon.hpp>

#include "GameScene.hpp"

int main(int argc, char * argv[])
{
    Utils::SetAssetPath(RESOURCE_PATH);
    const auto& paths = Utils::GetResourcePaths();
    for (auto& p : paths) {
        ToonLogInfo("%s", p);
    }

    App app;
    Scene* gameScene = new GameScene();

    app.SetCurrentScene(gameScene);

    if (!app.Start())
    {
        return EXIT_FAILURE;
    }

    app.Run();

    delete gameScene;

    return EXIT_SUCCESS;
}

```

`old/demos/Stencil/CMakeLists.txt`:

```txt

GET_FILENAME_COMPONENT(EXAMPLE "${CMAKE_CURRENT_LIST_DIR}" NAME)

ADD_EXECUTABLE(${EXAMPLE}
    src/Main.cpp
    src/GameScene.hpp
    src/GameScene.cpp
)

TARGET_LINK_LIBRARIES(${EXAMPLE}
    ${PROJECT_NAME}
)
 
FILE(RELATIVE_PATH BINARY_RESOURCE_PATH "${CMAKE_BINARY_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/resources")
FILE(RELATIVE_PATH SOURCE_RESOURCE_PATH "${CMAKE_CURRENT_SOURCE_DIR}" "${CMAKE_CURRENT_SOURCE_DIR}/resources")

TARGET_COMPILE_DEFINITIONS(${EXAMPLE}
    PUBLIC -DRESOURCE_PATH="${SOURCE_RESOURCE_PATH}:${BINARY_RESOURCE_PATH}:${CMAKE_SOURCE_DIR}/resources:${RESOURCE_PATH}"
)

IF(MSVC)
    SET_TARGET_PROPERTIES(
        ${EXAMPLE} 
        PROPERTIES 
            VS_DEBUGGER_ENVIRONMENT "PATH=%PATH%;${RUNTIME_SEARCH_PATH}"
    )
ENDIF()

```

`old/demos/Stencil/resources/shaders/advLighting.frag`:

```frag
#version 330 core

struct Material {
    sampler2D diffuseMap;
};

// Varyings
in vertexData
{
    vec3 fragPos;
    vec3 normal;
    vec2 texCoords;
} pass;

// Uniforms
uniform vec3 lightColor;
uniform vec4 lightVec;
uniform vec4 eyePos;

uniform Material material;

// Targets
layout (location = 0) out vec4 fragColor;

void main()
{
    vec3 objectColor = texture(material.diffuseMap, pass.texCoords).rgb;

    // ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
      
    // diffuse 
    vec3 norm = normalize(pass.normal);
    vec3 lightDir = normalize(lightVec.xyz - pass.fragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Specular
    vec3 specular = vec3(0.0, 0.0, 0.0);

    // We dot the normal and lightDir to make sure it won't 'leak'
    if (dot(norm, lightDir) >= 0.0f) {
        // specular
        float specularStrength = 0.5;
        vec3 viewDir = normalize(eyePos.xyz - pass.fragPos);
        vec3 halfwayDir = normalize(lightDir + viewDir);
        float spec = pow(max(dot(norm, halfwayDir), 0.0), 32.0);
        specular = specularStrength * spec * lightColor;
    }
        
    vec3 result = (ambient + diffuse + specular) * objectColor;
    fragColor = vec4(result, 1.0);
}

```

`old/demos/Stencil/resources/shaders/advLighting.vert`:

```vert
#version 330 core

// Attributes
layout (location = 0) in vec4 position;
layout (location = 1) in vec4 normal;
layout (location = 2) in vec2 texCoords;

// Uniforms
uniform mat4 mvp;
uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;

// Varyings
out vertexData
{
    vec3 fragPos;
    vec3 normal;
    vec2 texCoords;
} pass;

void main()
{
    pass.fragPos = vec3(modelMat * vec4(position.xyz, 1.0));
    pass.normal = mat3(transpose(inverse(modelMat))) * normal.xyz;
    pass.texCoords = vec2(texCoords.x, 1.0 - texCoords.y);

    gl_Position =  projMat * viewMat * vec4(pass.fragPos, 1.0);
}
```

`old/demos/Stencil/resources/shaders/stencil.frag`:

```frag
/*
    Stencil Shader
    By Benji Campbell
*/

#version 330 core

// target
layout (location = 0) out vec4 fragColor;

void main()
{
    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
}

```

`old/demos/Stencil/resources/shaders/stencil.vert`:

```vert
/*
    Stencil Shader
    By Benji Campbell
*/

#version 330 core

// attributes
layout (location = 0) in vec4 position;
// uniforms
uniform mat4 mvp;

void main()
{
    gl_Position = mvp * position;
}
```

`old/demos/Stencil/src/GameScene.cpp`:

```cpp
#include "GameScene.hpp"

void GameScene::Start()
{
    Scene::Start();

    App* app = App::Inst();

    // Camera
    Camera * camera = (Camera *)AddEntity("Camera", std::make_unique<Camera>());
    camera->SetPosition(glm::vec3(0.0f, 0.0f, 5.0f));
    app->SetCurrentCamera(camera);

    // Shaders
    printf("\nLoading Shaders\n");

    app->AddShader("stencil", new Shader({
        "shaders/stencil.vert",
        "shaders/stencil.frag" }));

    // Scene Objs
    _mPlane = AddEntity("Plane");
    _mPlaneMesh = _mPlane->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    _mPlaneMesh->SetShader(app->GetShader("defaultLighting"));

    _mSphere = AddEntity("Sphere");
    _mSphereMesh = _mSphere->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    _mSphereMesh->SetShader(app->GetShader("defaultLighting"));

    _mCube = AddEntity("Cube");
    _mCubeMesh = _mCube->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    _mCubeMesh->SetShader(app->GetShader("defaultLighting"));

    _mTorus = AddEntity("Torus");
    _mTorusMesh = _mTorus->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>());
    _mTorusMesh->SetShader(app->GetShader("defaultLighting"));

    // Scene Objs
    if (_mPlaneMesh->Load("models/Primitives/pPlane.glb"))
    {
        _mPlane->SetPosition(glm::vec3(0.0f, -2.5f, 0.0f));
        _mPlane->SetRotation(glm::vec3(0.0f, 0.0f, 0.0f));
        _mPlane->SetScale(glm::vec3(5.0f, 5.0f, 5.0f));
    }

    if (_mSphereMesh->Load("models/Primitives/pSphere.glb"))
    {
        _mSphere->SetPosition(glm::vec3(1.5f, 0.0f, 2.0f));
        _mSphere->SetRotation(glm::vec3(90.0f, 0.0f, 0.0f));
        _mSphere->SetScale(glm::vec3(0.5f, 0.5f, 0.5f));
    }

    if (_mCubeMesh->Load("models/Primitives/pCube.glb"))
    {
        _mCube->SetPosition(glm::vec3(-1.5f, -1.0f, 0.0f));
        _mCube->SetRotation(glm::vec3(20.0f, 0.0f, 20.0f));
        _mCube->SetScale(glm::vec3(1.0f, 1.0f, 1.0f));
    }

    if (_mTorusMesh->Load("models/Primitives/pTorus.glb"))
    {
        _mTorus->SetPosition(glm::vec3(1.0f, 1.0f, -1.0f));
        _mTorus->SetRotation(glm::vec3(-90.0f, -90.0f, 0.0f));
        _mTorus->SetScale(glm::vec3(0.5f, 0.5f, 0.5f));
    }

    // Setup for Stencil Testing
    glEnable(GL_STENCIL_TEST);
    glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
    glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
}

void GameScene::Update(float dt)
{
    Scene::Update(dt);
}

void GameScene::Render()
{

    //glStencilMask(0xFF); // each bit is written to the stencil buffer as is 
    //glStencilMask(0x00); // each bit ends up as 0 in the stencil buffer (disabling writes)

    auto app = App::Inst();

    glClear(GL_STENCIL_BUFFER_BIT);

    glStencilFunc(GL_ALWAYS, 1, 0xFF);
    glStencilMask(0xFF);
    _mPlaneMesh->SetShader(app->GetShader("defaultLighting"));
    _mPlane->SetScale(glm::vec3(5.0f));
    //_mPlane->Render();
    //_mPlane->RenderAxis();
    _mSphereMesh->SetShader(app->GetShader("defaultLighting"));
    _mSphere->SetScale(glm::vec3(0.5f));
    _mCubeMesh->SetShader(app->GetShader("defaultLighting"));
    _mCube->SetScale(glm::vec3(1.0f));
    _mTorusMesh->SetShader(app->GetShader("defaultLighting"));
    _mTorus->SetScale(glm::vec3(0.5f));
    Scene::Render();

    // Render the outline
    glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
    glStencilMask(0x00);
    glDisable(GL_DEPTH_TEST);
    _mPlaneMesh->SetShader(app->GetShader("stencil"));
    _mPlane->SetScale(glm::vec3(5.05f));
    _mSphereMesh->SetShader(app->GetShader("stencil"));
    _mSphere->SetScale(glm::vec3(0.55f));
    _mCubeMesh->SetShader(app->GetShader("stencil"));
    _mCube->SetScale(glm::vec3(1.05f));
    _mTorusMesh->SetShader(app->GetShader("stencil"));
    _mTorus->SetScale(glm::vec3(0.55f));
    Scene::Render();

    glStencilMask(0xFF);
    glStencilFunc(GL_ALWAYS, 1, 0xFF);
    glEnable(GL_DEPTH_TEST);

}
```

`old/demos/Stencil/src/GameScene.hpp`:

```hpp
#ifndef GAMESCENE_H
#define GAMESCENE_H

#include <Toon.hpp>

class GameScene : public Scene
{
public:
    GameScene() {};

    void Start() override;
    void Update(float dt) override;
    void Render() override;

private:
    Entity* _mPlane;
    Entity* _mSphere;
    Entity* _mCube;
    Entity* _mTorus;
    StaticMeshComponent* _mPlaneMesh;
    StaticMeshComponent* _mSphereMesh;
    StaticMeshComponent* _mCubeMesh;
    StaticMeshComponent* _mTorusMesh;
};

#endif // GAMESCENE_H
```

`old/demos/Stencil/src/Main.cpp`:

```cpp
#include <Toon.hpp>

#include "GameScene.hpp"

int main(int argc, char * argv[])
{
    Utils::SetAssetPath(RESOURCE_PATH);
    const auto& paths = Utils::GetResourcePaths();
    for (auto& p : paths) {
        ToonLogInfo("%s", p);
    }

    App app;
    Scene* gameScene = new GameScene();

    app.SetCurrentScene(gameScene);

    if (!app.Start())
    {
        return EXIT_FAILURE;
    }

    app.Run();

    delete gameScene;

    return EXIT_SUCCESS;
}

```

`old/include/glTF2.hpp`:

```hpp
#ifndef GLTF2_HPP
#define GLTF2_HPP

#include <Entity.hpp>
#include <Mesh.hpp>

#include <string>
#include <vector>
#include <memory>

namespace glTF2 {

    std::vector<std::unique_ptr<Entity>> LoadSceneFromFile(const std::string& filename);

    std::vector<Mesh::Primitive> LoadPrimitivesFromFile(const std::string& filename);

} // namespace glTF2

#endif // GLTF2_HPP
```

`old/src/glTF2.cpp`:

```cpp
#include "glTF2.hpp"

//#include <ToonBenchmark.hpp>
#include <Utils.hpp>
#include <nlohmann/json.hpp>
#include <Material.hpp>
#include <Texture.hpp>
#include <Camera.hpp>
#include <Log.hpp>
#include <glm/glm.hpp>
#include <Skin.hpp>
#include <Joint.hpp>
#include <StaticMeshComponent.hpp>
#include <RiggedMeshComponent.hpp>
#include <Light.hpp>

#include <algorithm>
#include <cstdint>
#include <fstream>
#include <memory>
#include <vector>
#include <string>
#include <unordered_map>

#include <stb/stb_image.h>

#include <Base64.hpp>

using namespace nlohmann;

namespace glTF2 {

	const uint32_t Magic = 0x46546C67; // glTF

	enum class ChunkType : uint32_t
	{
		JSON = 0x4E4F534A, // JSON
		BIN = 0x004E4942, // BIN
	};


	glm::vec3 parseVec3(const json& value, glm::vec3 def)
	{
		if (value.is_array() && value.size() == 3) {
			const auto& v = value.get<std::vector<float>>();
			return glm::make_vec3(v.data());
		}
		return def;
	}

	glm::vec4 parseVec4(const json& value, glm::vec4 def)
	{
		if (value.is_array() && value.size() == 4) {
			const auto& v = value.get<std::vector<float>>();
			return glm::make_vec4(v.data());
		}
		return def;
	}

	glm::quat parseQuat(const json& value, glm::quat def)
	{
		if (value.is_array() && value.size() == 4) {
			const auto& v = value.get<std::vector<float>>();
			return glm::quat(v[3], v[0], v[1], v[2]);
		}
		return def;
	}

	std::vector<std::vector<uint8_t>> loadBuffers(const json& data, const std::string& dir)
	{
		std::vector<std::vector<uint8_t>> buffers;

		auto it = data.find("buffers");
		if (it != data.end()) {
			if (it.value().is_array()) {
				auto& array = it.value();
				for (auto& object : array) {
					if (object.is_object()) {
						size_t byteLength = object.value<size_t>("byteLength", 0);
						const auto& uri = object.value("uri", "");

						if (uri.compare(0, strlen("data:"), "data:") == 0) {
							size_t pivot = uri.find(',');
							buffers.push_back(macaron::Base64::Decode(uri.substr(pivot + 1)));
						}
						else {
							LogVerbose("glTF buffer %zu, %s", byteLength, uri);

							std::ifstream bufferFile(dir + "/" + uri, std::ios::in | std::ios::binary);
							if (!bufferFile.is_open()) {
								ToonLogError("Failed to open glTF data file '%s'", uri);
								continue;
							}

							buffers.push_back(std::vector<uint8_t>(byteLength));
							auto& buffer = buffers.back();

							bufferFile.read(reinterpret_cast<char *>(buffer.data()), byteLength);
							bufferFile.close();

							ToonLogLoad("glTF data file '%s'", uri);

							if (buffer.size() != byteLength) {
								ToonLogWarn("Buffer size mismatch %zu != %zu", buffer.size(), byteLength);
							}
						}
					}
				}
			}
		}

		return buffers;
	}

	struct bufferView_t {
		int buffer;
		size_t byteLength;
		size_t byteOffset;
		size_t byteStride;
		GLenum target;
	};

	std::vector<bufferView_t> loadBufferViews(const json& data)
	{
		std::vector<bufferView_t> bufferViews;

		const auto it = data.find("bufferViews");
		if (it != data.cend()) {
			if (it.value().is_array()) {
				const auto& array = it.value();
				for (const auto& object : array) {
					if (object.is_object()) {
						bufferViews.push_back(bufferView_t{
							object.value("buffer", -1),
							object.value<size_t>("byteLength", 0),
							object.value<size_t>("byteOffset", 0),
							object.value<size_t>("byteStride", 0),
							object.value<GLenum>("target", GL_INVALID_ENUM),
						});

						LogVerbose("BufferView %zu, %zu, %zu, %zu",
							bufferViews.back().buffer,
							bufferViews.back().byteLength,
							bufferViews.back().byteOffset,
							bufferViews.back().target);
					}
				}
			}
		}

		return bufferViews;
	}

	struct accessor_t {
		int bufferView;
		std::string type;
		size_t byteOffset;
		GLenum componentType;
		bool normalized;
		size_t count;
		// TODO: min, max
	};

	std::vector<accessor_t> loadAccessors(const json& data)
	{
		std::vector<accessor_t> accessors;

		const auto& it = data.find("accessors");
		if (it != data.cend()) {
			if (it.value().is_array()) {
				const auto& array = it.value();
				for (const auto& object : array) {
					if (object.is_object()) {
						accessors.push_back(accessor_t{
							object.value("bufferView", -1),
							object.value("type", ""),
							object.value<size_t>("byteOffset", 0),
							object.value<GLenum>("componentType", GL_INVALID_ENUM),
							object.value<bool>("normalized", false),
							object.value<size_t>("count", 0),
							// TODO: min, max
						});
					}
				}
			}
		}

		return accessors;
	}

	struct image_t {
		glm::ivec2 size;
		int components;
		std::unique_ptr<uint8_t> data;
	};

	std::vector<image_t> loadImages(
		const json& data,
		const std::string& dir,
		const std::vector<bufferView_t>& bufferViews,
		const std::vector<std::vector<uint8_t>>& buffers)
	{
		std::vector<image_t> images;

		const auto it = data.find("images");
		if (it != data.cend()) {
			if (it.value().is_array()) {
				const auto& array = it.value();
				for (const auto& object : array) {
					if (object.is_object()) {
						images.push_back(image_t{});
						auto& image = images.back();

						const auto& uri = object.value("uri", "");
						if (!uri.empty()) {
							const auto& imageFilename = dir + "/" + uri;
							image.data.reset(stbi_load(
								imageFilename.c_str(),
								&image.size.x,
								&image.size.y,
								&image.components,
								STBI_rgb_alpha)
								);
							image.components = STBI_rgb_alpha;

							if (!image.data) {
								ToonLogError("Failed to load glTF image file '%s'", imageFilename);
								continue;
							}

							ToonLogLoad("glTF image file '%s'", uri);
						}
						else {
							int bufferViewIndex = object.value("bufferView", -1);
							//const auto& mimeType = object.value("mimeType", "");

							const auto& bufferView = bufferViews[bufferViewIndex];
							const auto& buffer = buffers[bufferView.buffer];

                            stbi_set_flip_vertically_on_load(true);

							image.data.reset(stbi_load_from_memory(
								buffer.data() + bufferView.byteOffset,
								bufferView.byteLength,
								&image.size.x,
								&image.size.y,
								&image.components,
								STBI_rgb_alpha)
								);
							image.components = STBI_rgb_alpha;
						}
					}
				}
			}
		}

		return images;
	}

	std::vector<Texture::Options> loadSamplers(const json& data)
	{
		std::vector<Texture::Options> samplers;

		const auto it = data.find("samplers");
		if (it != data.cend()) {
			if (it.value().is_array()) {
				const auto& array = it.value();
				for (const auto& object : array) {
					if (object.is_object()) {
						samplers.push_back(Texture::Options{});
						auto& sampler = samplers.back();

						sampler.MagFilter = object.value<GLenum>("magFilter", sampler.MagFilter);
						sampler.MinFilter = object.value<GLenum>("minFilter", sampler.MinFilter);
						sampler.WrapS = object.value<GLenum>("wrapS", sampler.WrapS);
						sampler.WrapT = object.value<GLenum>("wrapT", sampler.WrapT);
					}
				}
			}
		}

		return samplers;
	}

	std::vector<std::shared_ptr<Texture>> loadTextures(
		const json& data,
		const std::vector<image_t>& images,
		const std::vector<Texture::Options> samplers)
	{
		std::vector<std::shared_ptr<Texture>> textures;

		const auto it = data.find("textures");
		if (it != data.cend()) {
			if (it.value().is_array()) {
				const auto& array = it.value();
				for (const auto& object : array) {
					if (object.is_object()) {
						int sampler = object.value("sampler", -1);
						int source = object.value("source", -1);

						if (source < 0) {
							ToonLogError("Invalid glTF texture source %d", source);
							continue;
						}

						const auto& image = images[source];
						textures.push_back(std::make_shared<Texture>(
							image.data.get(),
							image.size,
							image.components,
							(sampler >= 0 ? samplers[sampler] : Texture::Options())
							));

						LogVerbose("Texture %zu, %zu", sampler, source);
					}
				}
			}
		}

		return textures;
	}

	struct camera_perspective_t {
	};

	struct camera_orthographic_t {
	};

	struct camera_t {
		std::string type;

		// Perspective
		float aspectRatio;
		float yfov;

		// Orthographic
		float xmag;
		float ymag;

		// Both
		float zfar;
		float znear;
	};

    struct light_t {
        glm::vec3 color;
        int intensity;
        std::string type;

        float innerConeAngle;
        float outerConeAngle;
    };

	struct skin_t {
		std::string name;
		std::vector<int> joints;
	};

    std::vector<light_t> loadLights(const json& data)
    {
        std::vector<light_t> lights;

		nlohmann::json lightData;

		auto it = data.find("extensions");
		if (it != data.cend())
		{
			auto it2 = it.value().find("KHR_lights_punctual");
			if (it2 != it.value().cend())
			{
				auto it3 = it2.value().find("lights");
				if (it3 != it2.value().cend())
				{
					lightData = it3.value();
				}
			}
		}

        if (lightData.is_array())
        {
            for (const auto& it : lightData)
            {
                lights.push_back(light_t{});

                auto& light = lights.back();

                light.intensity = it.value("intensity", 1);
                light.type = it.value("type", "point");

                light.color = parseVec3(it.find("color").value(), glm::vec3(1));
                
                auto spot = it.find("spot");

                if (spot != it.end())
                {
                    light.innerConeAngle = spot.value().value("innerConeAngle", 0.1f);
                    light.outerConeAngle = spot.value().value("outerConeAngle", 0.1f);
                }
            }
        }

        return lights;
    }

	std::vector<camera_t> loadCameras(const json& data)
	{
		std::vector<camera_t> cameras;

		const auto& it = data.find("cameras");
		if (it != data.cend()) {
			if (it.value().is_array()) {
				const auto& array = it.value();
				for (const auto& object : array) {
					if (object.is_object()) {
						cameras.push_back(camera_t{
							object.value("type", ""),
						});
						auto& camera = cameras.back();

						if (camera.type == "perspective") {
							auto typeIt = object.find("perspective");
							if (typeIt != object.end()) {
								auto& perspective = typeIt.value();
								camera.aspectRatio = perspective.value("aspectRatio", 0.f);
								camera.yfov = perspective.value("yfov", 0.f);
								camera.zfar = perspective.value("zfar", 0.f);
								camera.znear = perspective.value("znear", 0.f);
							}
						}
						else if (camera.type == "orthographic") {
							auto typeIt = object.find("orthographic");
							if (typeIt != object.end()) {
								auto& orthographic = typeIt.value();
								camera.xmag = orthographic.value("xmag", 0.f);
								camera.ymag = orthographic.value("ymag", 0.f);
								camera.zfar = orthographic.value("zfar", 0.f);
								camera.znear = orthographic.value("znear", 0.f);
							}
						}
						else {
							ToonLogWarn("Unknown camera type '%s'", camera.type);
						}
					}
				}
			}
		}

		return cameras;
	}

	std::vector<std::shared_ptr<Material>> loadMaterials(
		const json& data,
		const std::vector<std::shared_ptr<Texture>>& textures)
	{
		std::vector<std::shared_ptr<Material>> materials;

		auto parseTexture = [&textures](const json& value) -> std::shared_ptr < Texture > {
			if (value.is_object()) {
				int index = value.value("index", -1);
				int texCoord = value.value("texCoord", 0);

				if (index < 0 || index >(int)textures.size()) {
					ToonLogError("Invalid glTF texture index %d", index);
					return nullptr;
				}

				if (texCoord > 0) {
					ToonLogWarn("Multiple TEXCOORDs not supported");
				}

				return textures[index];
			}
			return nullptr;
		};

		const auto it = data.find("materials");
		if (it != data.cend()) {
			const auto& array = it.value();
			for (const auto& object : array) {
				if (object.is_object()) {
					materials.push_back(std::make_shared<Material>());
					auto& material = materials.back();

					LogVerbose("glTF material %s", object.value("name", ""));

					auto valIt = object.find("normalTexture");
					if (valIt != object.end()) {
						const auto& value = valIt.value();
                        material->SetMap(Material::NORMAL, parseTexture(value));
						if (value.is_object()) {
							material->SetNormalScale(value.value("scale", 1.0f));
						}
					}

					valIt = object.find("emissiveFactor");
					if (valIt != object.end()) {
					    material->SetEmissiveFactor(parseVec3(valIt.value(), material->GetEmissiveFactor()));
                    }

					valIt = object.find("emissiveTexture");
					if (valIt != object.end()) {
                        material->SetMap(Material::EMISSIVE, parseTexture(valIt.value()));
					}

					valIt = object.find("occlusionTexture");
					if (valIt != object.end()) {
						const auto& value = valIt.value();
                        material->SetMap(Material::AMBIENT_OCCLUSION, parseTexture(valIt.value()));
                        if (value.is_object()) {
                            material->SetOcclusionStrength(value.value("strength", 1.0f));
						}
					}

					const auto groupIt = object.find("pbrMetallicRoughness");
					if (groupIt != object.cend()) {
						const auto& group = groupIt.value();
						if (group.is_object()) {
							valIt = group.find("baseColorFactor");
							if (valIt != group.end()) {
                                material->SetBaseColorFactor(parseVec4(valIt.value(), material->GetBaseColorFactor()));
							}

							valIt = group.find("baseColorTexture");
							if (valIt != group.end()) {
                                material->SetMap(Material::BASE_COLOR, parseTexture(valIt.value()));
                                material->SetMap(Material::DIFFUSE, parseTexture(valIt.value()));
							}

							valIt = group.find("metallicFactor");
							if (valIt != group.end()) {
                                material->SetMetallicFactor(valIt.value().get<float>());
							}

							valIt = group.find("roughnessFactor");
							if (valIt != group.end()) {
								material->SetRoughnessFactor(valIt.value().get<float>());
							}

							valIt = group.find("metallicRoughnessTexture");
							if (valIt != group.end()) {
								const auto& value = valIt.value();
                                material->SetMap(Material::METALLIC_ROUGHNESS, parseTexture(value));
							}
						}
					}
				}
			}
		}

		return materials;
	}

	std::vector<Mesh::Primitive> loadPrimitives(
		const json& data,
		const std::vector<bufferView_t>& bufferViews,
		const std::vector<std::vector<uint8_t>>& buffers,
		const std::vector<accessor_t>& accessors,
		const std::vector<std::shared_ptr<Material>>& materials)
	{
		std::vector<Mesh::Primitive> primitives;

		std::shared_ptr<Material> defaultMaterial(new Material());

		std::vector<GLuint> vbos;

		const auto& primIt = data.find("primitives");
		if (primIt != data.end()) {
			const auto& primArray = primIt.value();
			if (primArray.is_array()) {
				for (const auto& primitive : primArray) {
					if (primitive.is_object()) {
						GLuint vao;
						glGenVertexArrays(1, &vao);
						glBindVertexArray(vao);

						int indices = primitive.value("indices", -1);
						if (indices < 0) {
							// TODO: glDrawArrays support
							ToonLogError("glDrawArrays not supported");
							continue;
						}

						const auto& indexAccessor = accessors[indices];

						{
							const auto& bufferView = bufferViews[indexAccessor.bufferView];
							const auto& buffer = buffers[bufferView.buffer];

							GLenum target = (bufferView.target == GL_INVALID_ENUM ? GL_ELEMENT_ARRAY_BUFFER : bufferView.target);

							GLuint vbo;
							glGenBuffers(1, &vbo);
							vbos.push_back(vbo);

							glBindBuffer(target, vbo);
							glBufferData(target, bufferView.byteLength,
								buffer.data() + bufferView.byteOffset, GL_STATIC_DRAW);
						}

						const auto& attrIt = primitive.find("attributes");
						if (attrIt != primitive.end()) {
							const auto& attribs = attrIt.value();
							if (attribs.is_object()) {
								for (const auto&[attrib, accessorIndex] : attribs.items()) {
									auto& accessor = accessors[accessorIndex];
									auto& bufferView = bufferViews[accessor.bufferView];
									auto& buffer = buffers[bufferView.buffer];
									int byteStride = (int)bufferView.byteStride;

									LogVerbose("glTF attribute %s", attrib);

									GLenum target = (bufferView.target == GL_INVALID_ENUM ? GL_ARRAY_BUFFER : bufferView.target);

									GLuint vbo;
									glGenBuffers(1, &vbo);
									vbos.push_back(vbo);

									glBindBuffer(target, vbo);
									glBufferData(target, bufferView.byteLength,
										buffer.data() + bufferView.byteOffset, GL_STATIC_DRAW);

									GLint size = -1;
									if (accessor.type == "SCALAR") {
										size = 1;
									}
									else if (accessor.type == "VEC2") {
										size = 2;
									}
									else if (accessor.type == "VEC3") {
										size = 3;
									}
									else if (accessor.type == "VEC4") {
										size = 4;
									}

									GLint vaa = -1;
									if (attrib == "POSITION") {
										vaa = Mesh::AttributeID::POSITION;
									}
									else if (attrib == "NORMAL") {
										vaa = Mesh::AttributeID::NORMAL;
									}
									else if (attrib == "TANGENT") {
										vaa = Mesh::AttributeID::TANGENT;
									}
									else if (attrib == "TEXCOORD_0") {
										vaa = Mesh::AttributeID::TEXCOORD;
									}
									else if (attrib == "JOINTS_0") {
										vaa = Mesh::AttributeID::JOINTS_0;
									}
									else if (attrib == "WEIGHTS_0") {
										vaa = Mesh::AttributeID::WEIGHTS_0;
									}

									if (vaa > -1) {
										glEnableVertexAttribArray(vaa);
										glVertexAttribPointer(
											vaa,
											size,
											accessor.componentType,
											accessor.normalized,
											byteStride,
											(void*)accessor.byteOffset
											);
									}
									else {
										ToonLogWarn("Ignoring glTF attribute %s", attrib);
									}
								}
							}
						}

						int materialIndex = primitive.value("material", -1);

						std::shared_ptr<Material> material;
						if (materialIndex >= 0) {
							material = materials[materialIndex];
						}
						else {
							material = defaultMaterial;
						}

						LogVerbose("Primitive %u", vao);

						primitives.push_back({
							vao,
							primitive.value<GLenum>("mode", GL_TRIANGLES),
							(GLsizei)indexAccessor.count,
							(GLenum)indexAccessor.componentType,
							(GLsizei)indexAccessor.byteOffset,
							material,
						});
					}
				}
			}
		}

		return primitives;
	}

	std::vector<Mesh::Primitive> loadAllPrimitives(
		const json& data,
		const std::vector<bufferView_t>& bufferViews,
		const std::vector<std::vector<uint8_t>>& buffers,
		const std::vector<accessor_t>& accessors,
		const std::vector<std::shared_ptr<Material>>& materials)
	{
		std::vector<Mesh::Primitive> primitives;

		const auto it = data.find("meshes");
		if (it != data.cend()) {
			const auto& array = it.value();
			for (const auto& object : array) {
				if (object.is_object()) {
					LogVerbose("glTF mesh %s", object.value("name", ""));

					auto tmp = loadPrimitives(object, bufferViews, buffers, accessors, materials);
					for (auto&& p : tmp) {
						primitives.push_back(std::move(p));
					}
				}
			}
		}

		return primitives;
	}

	std::vector<std::shared_ptr<Mesh>> loadMeshes(
		const json& data,
		const std::vector<bufferView_t>& bufferViews,
		const std::vector<std::vector<uint8_t>>& buffers,
		const std::vector<accessor_t>& accessors,
		const std::vector<std::shared_ptr<Material>>& materials)
	{
		std::vector<std::shared_ptr<Mesh>> meshes;

		const auto it = data.find("meshes");
		if (it != data.cend()) {
			const auto& array = it.value();
			for (const auto& object : array) {
				if (object.is_object()) {
					LogVerbose("glTF mesh %s", object.value("name", ""));

					meshes.push_back(std::make_shared<Mesh>(
						loadPrimitives(object, bufferViews, buffers, accessors, materials)
						));
				}
			}
		}

		return meshes;
	}

	std::vector<skin_t> loadSkins(const json& data)
	{
		// Create Skeleton
		std::vector<skin_t> skins;

		// Open up the skin data
		auto it = data.find("skins");
		if (it != data.cend()) {
			const auto& array = it.value();
			for (const auto& object : array) {
				if (object.is_object()) {
					skins.push_back(skin_t{});
					auto& skeleton = skins.back();

					auto valIt = object.find("name");
					if (valIt != object.end()) {
						const auto& value = valIt.value();
						skeleton.name = value;
					}

					valIt = object.find("joints");
					if (valIt != object.end()) {
					    const auto& value = valIt.value();
						skeleton.joints = value.get<std::vector<int>>();
                    }

				}
			}
		}

		return skins;
	}

	std::vector<std::unique_ptr<Entity>> loadNodes(
		const json& data,
		const std::vector<camera_t>& cameras,
        const std::vector<light_t>& lights,
		const std::vector<std::shared_ptr<Mesh>>& meshes,
		const std::vector<skin_t>& skins
		)
	{
		std::vector<std::unique_ptr<Entity>> entitys;

		std::function<std::unique_ptr<Entity>(const json&, const json&)>
        loadNode = [&](const json& nodes, const json& data)
        -> std::unique_ptr<Entity>
        {
            Entity * entity = nullptr;

			auto it = data.begin();

            int cameraIndex = data.value("camera", -1);

            auto lightPath = "/extensions/KHR_lights_punctual/light"_json_pointer;

            if (data.contains(lightPath))
            {
                auto lightIndexObject = data[lightPath];

                int lightIndex = lightIndexObject.get<int>();

                const auto& lightData = lights[lightIndex];

                Light * light = nullptr;

                if (lightData.type == "point")
                {
                    PointLight * pointLight = new PointLight();
                    light = (Light*)pointLight;
                }
                else if (lightData.type == "directional")
                {
                    DirectionalLight * directionalLight = new DirectionalLight();
                    light = (Light*)directionalLight;
                }
                else if (lightData.type == "spot")
                {
                    SpotLight * spotLight = new SpotLight();
                    light = (Light*)spotLight;
                    spotLight->SetCutOff(lightData.innerConeAngle);
                    spotLight->SetOuterCutOff(lightData.outerConeAngle);
                }

                light->SetIntensity(lightData.intensity);
                light->SetColor(lightData.color);

                entity = light;
            }
            else if (cameraIndex >= 0)
            {
				Camera * camera = new Camera();
				const auto& c = cameras[cameraIndex];
				if (c.type == "perspective") {
					camera->SetMode(Camera::Mode::Perspective);

					// TODO: aspectRatio

					if (c.yfov > 0.f) {
						camera->SetFOVY(c.yfov);
					}

					if (c.znear > 0.f && c.zfar > 0.f) {
						camera->SetClip(c.znear, c.zfar);
					}
				}
				else if (c.type == "orthographic") {
					camera->SetMode(Camera::Mode::Orthographic);

					if (c.xmag > 0.f && c.ymag > 0.f) {
						camera->SetViewportSize(c.xmag, c.ymag);
					}

					if (c.znear > 0.f && c.zfar > 0.f) {
						camera->SetClip(c.znear, c.zfar);
					}
				}
				entity = camera;
			}
			else {
				entity = new Entity();
			}

			int meshIndex = data.value("mesh", -1);
			if (meshIndex >= 0) {
				LogVerbose("Adding MeshComponent");
                entity->AddComponent<StaticMeshComponent>(std::make_unique<StaticMeshComponent>(meshes[meshIndex]));
			}

			it = data.find("name");
			if (it != data.end()) {
				entity->SetName(it.value());
				ToonLogWarn("Name: %s", entity->GetName());
				if (it.value() == "Armature")
				{
					ToonLogError("Armature");
				}
				//if (it.value() == "Hair")
				//{
				//	ToonLogError("Hair");
				//}
				//if (it.value() == "Character")
				//{
				//	ToonLogError("Character");
				//}
			}

			it = data.find("translation");
			if (it != data.end()) {
				entity->SetPosition(parseVec3(it.value(), entity->GetPosition()));
				ToonLogWarn("Position: %f, %f, %f", entity->GetPosition().x, entity->GetPosition().y, entity->GetPosition().z);
			}

			it = data.find("rotation");
			if (it != data.end()) {
				entity->SetRotation(parseQuat(it.value(), entity->GetRotation()));
				ToonLogWarn("Rotation: %f, %f, %f", entity->GetRotation().x, entity->GetRotation().y, entity->GetRotation().z);
			}

			it = data.find("scale");
			if (it != data.end()) {
				entity->SetScale(parseVec3(it.value(), entity->GetScale()));
				ToonLogWarn("Scale: %f, %f, %f", entity->GetScale().x, entity->GetScale().y, entity->GetScale().z);
			}

            it = data.find("children");
            if (it != data.end()) {
                for (const auto& child : it.value())
                {
					bool isJoint = false;
					for (const auto& skin : skins)
					{
						auto itr = std::find(skin.joints.begin(), skin.joints.end(), child.get<int>());
						if (itr != skin.joints.end()) {
							isJoint = true;
						}
					}

					if (isJoint) {
						LogVerbose("Skipping childnode due to being joint.");
						continue;
					}

					ToonLogInfo("Parent: %s", entity->GetName());
                    entity->AddChild(loadNode(nodes, nodes[child.get<int>()]));
                }
            }

			return std::unique_ptr<Entity>(entity);
		};

		std::vector<int> sceneNodeIndexes;

		int defaultSceneIndex = data.value("defaultScene", 0);
		const auto scenesIt = data.find("scenes");
		if (scenesIt != data.cend()) {
			const auto& array = scenesIt.value();
			if (array.is_array()) {
				const auto& scene = array[defaultSceneIndex];
				sceneNodeIndexes = scene["nodes"].get<std::vector<int>>();
			}
		}

		const auto nodesIt = data.find("nodes");
		if (nodesIt != data.cend()) {
			const auto& array = nodesIt.value();
			if (array.is_array()) {
				for (int index : sceneNodeIndexes) {
					const auto& object = array[index];

					bool isJoint = false;
					for (const auto& skin : skins)
					{
						auto it = std::find(skin.joints.begin(), skin.joints.end(), index);
						if (it != skin.joints.end()) {
							isJoint = true;
						}
					}

					if (isJoint) {
						LogVerbose("Skipping node due to being a joint.");
						continue;
					}

					if (object.is_object()) {
						LogVerbose("glTF node %s", object.value("name", ""));
						auto entity = loadNode(array, object);
						if (entity) {
							entitys.push_back(std::move(entity));
						}
					}
				}
			}
		}

		return entitys;
	}

	std::tuple<json, std::vector<std::vector<uint8_t>>, std::string>
		loadFile(const std::string& filename)
	{
		static auto error = std::make_tuple(json(), std::vector<std::vector<uint8_t>>(), "");
		const auto& paths = Utils::GetResourcePaths();

		std::ifstream file;
		std::string fullPath;
		for (const auto& p : paths) {
			fullPath = p + filename;

            LogVerbose("Path: %s", p);
			LogVerbose("Checking %s", fullPath);

			file.open(fullPath.c_str(), std::ios::in | std::ios::binary);
			if (file.is_open()) {
				break;
			}
		}

		if (!file.is_open()) {
			ToonLogError("Failed to load glTF, '%s'", filename);
			return error;
		}

		const auto& dir = Utils::GetDirname(fullPath);
		const auto& ext = Utils::GetExtension(filename);
		bool binary = (ext == "glb");

		std::vector<std::vector<uint8_t>> dataChunks;

		json data;
		if (binary) {
			uint32_t magic = 0;
			uint32_t version = 0;
			uint32_t length = 0;

			// TODO: Endianness

			file.read(reinterpret_cast<char *>(&magic), sizeof(magic));
			if (magic != Magic) {
				ToonLogError("Invalid binary glTF file");
				return error;
			}

			file.read(reinterpret_cast<char *>(&version), sizeof(version));
			if (version != 2) {
				ToonLogError("Invalid binary glTF container version %d", version);
				return error;
			}

			file.read(reinterpret_cast<char *>(&length), sizeof(length));

			uint32_t jsonChunkLength = 0;
			uint32_t jsonChunkType = 0;

			file.read(reinterpret_cast<char *>(&jsonChunkLength), sizeof(jsonChunkLength));
			file.read(reinterpret_cast<char *>(&jsonChunkType), sizeof(jsonChunkType));

			if ((ChunkType)jsonChunkType != ChunkType::JSON) {
				ToonLogError("The first chunk of a binary glTF must be JSON, found %08x", jsonChunkType);
				return error;
			}

			std::vector<char> jsonChunk(jsonChunkLength + 1);
			file.read(jsonChunk.data(), jsonChunkLength);
			jsonChunk.back() = '\0';

			data = json::parse(jsonChunk.data());

			uint32_t dataChunkLength = 0;
			uint32_t dataChunkType = 0;
			while (file.read(reinterpret_cast<char *>(&dataChunkLength), sizeof(dataChunkLength))) {
				file.read(reinterpret_cast<char *>(&dataChunkType), sizeof(dataChunkType));

				if ((ChunkType)dataChunkType != ChunkType::BIN) {
					ToonLogError("The second chunk of a binary glTF must be BIN, found %08x", dataChunkType);
					return error;
				}

				dataChunks.push_back(std::vector<uint8_t>(dataChunkLength));
				auto& dataChunk = dataChunks.back();

				file.read(reinterpret_cast<char *>(dataChunk.data()), dataChunkLength);
			}

		}
		else {
			file >> data;
		}

		if (auto it = data.find("asset"); it != data.end()) {
			const auto& object = it.value();
			if (object.is_object()) {

				const auto& version = object.value("version", "");

				LogVerbose("glTF Generator %s", object.value("generator", ""));
				LogVerbose("glTF Version %s", object.value("version", ""));

				if (version != "2.0") {
					ToonLogError("only glTF 2.0 is supported");
					return error;
				}
			}
			else {
				ToonLogError("glTF missing required asset entry");
				return error;
			}
		}

        // Should take both into some list then compare required to used and log an error if we don't have the right ones.

		if (auto it = data.find("extensionsRequired"); it != data.end()) {
			const auto& array = it.value();
			if (array.is_array()) {
				for (const auto& extension : array) {
					//ToonLogError("Missing glTF required extension '%s'", extension);
                    ToonLogInfo("glTF Required Extension found: %s", extension);
				}
			}
		}

		if (auto it = data.find("extensionsUsed"); it != data.end()) {
			const auto& array = it.value();
			if (array.is_array()) {
				for (const auto& extension : array) {
					//ToonLogWarn("Missing glTF extension '%s'", extension);
                    ToonLogInfo("glTF Extension found: %s", extension);
				}
			}
		}

        ////

		return std::make_tuple(data, dataChunks, dir);
	}

	std::vector<std::unique_ptr<Entity>> LoadSceneFromFile(const std::string& filename)
	{
		//DuskBenchStart();

		const auto&[data, dataChunks, dir] = loadFile(filename);

		// TODO: Allow other buffers in GLB
		const auto& buffers = (dataChunks.empty() ? loadBuffers(data, dir) : dataChunks);
		const auto& bufferViews = loadBufferViews(data);
		const auto& accessors = loadAccessors(data);
		const auto& images = loadImages(data, dir, bufferViews, buffers);
		const auto& samplers = loadSamplers(data);
		const auto& textures = loadTextures(data, images, samplers);
		const auto& cameras = loadCameras(data);
		const auto& materials = loadMaterials(data, textures);
		const auto& meshes = loadMeshes(data, bufferViews, buffers, accessors, materials);
        const auto& lights = loadLights(data);
		const auto& skins = loadSkins(data);
		auto entitys = loadNodes(data, cameras, lights, meshes, skins);

		//DuskBenchEnd("glTF2::LoadSceneFromFile");
		return entitys;
	}

	std::vector<Mesh::Primitive> LoadPrimitivesFromFile(const std::string& filename)
	{
		//DuskBenchStart();

		const auto&[data, dataChunks, dir] = loadFile(filename);

		// TODO: Allow other buffers in GLB
		const auto& buffers = (dataChunks.empty() ? loadBuffers(data, dir) : dataChunks);
		const auto& bufferViews = loadBufferViews(data);
		const auto& accessors = loadAccessors(data);
		const auto& images = loadImages(data, dir, bufferViews, buffers);
		const auto& samplers = loadSamplers(data);
		const auto& textures = loadTextures(data, images, samplers);
		const auto& materials = loadMaterials(data, textures);
		auto primitives = loadAllPrimitives(data, bufferViews, buffers, accessors, materials);

		//DuskBenchEnd("glTF2::LoadMeshFromFile");
		return primitives;
	}

} // namespace glTF2
```