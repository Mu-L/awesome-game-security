Project Path: arc_neverlosecc_source2gen_7hisr045

Source Tree:

```txt
arc_neverlosecc_source2gen_7hisr045
├── ACKNOWLEDGEMENTS
├── CMakeLists.txt
├── LICENSE.txt
├── README.md
├── conanfile.py
├── scripts
│   ├── generate_static.py
│   ├── license_template.txt
│   ├── license_template_header.txt
│   ├── run.sh
│   ├── test.sh
│   └── update_copyrights.py
├── sdk-static
│   ├── c
│   │   ├── CMakeLists.txt
│   │   ├── conanfile.py
│   │   └── include
│   │       └── source2sdk
│   │           └── source2gen
│   │               └── source2gen.h
│   └── cpp
│       ├── CMakeLists.txt
│       ├── conanfile.py
│       └── include
│           └── source2sdk
│               └── source2gen
│                   └── source2gen.hpp
├── sdk-static.toml
├── source2gen
│   ├── CMakeLists.txt
│   ├── include
│   │   ├── Include.h
│   │   ├── options.hpp
│   │   ├── sdk
│   │   │   ├── interfaceregs.h
│   │   │   ├── interfaces
│   │   │   │   ├── client
│   │   │   │   │   └── game
│   │   │   │   │       └── datamap_t.h
│   │   │   │   ├── common
│   │   │   │   │   ├── CBufferString.h
│   │   │   │   │   ├── CInterlockedInt.h
│   │   │   │   │   ├── CTSList.h
│   │   │   │   │   ├── CThreadMutex.h
│   │   │   │   │   ├── CThreadSpinMutex.h
│   │   │   │   │   ├── CThreadSpinRWLock.h
│   │   │   │   │   ├── CUtlMap.h
│   │   │   │   │   ├── CUtlMemory.h
│   │   │   │   │   ├── CUtlMemoryPoolBase.h
│   │   │   │   │   ├── CUtlRBTree.h
│   │   │   │   │   ├── CUtlString.h
│   │   │   │   │   ├── CUtlTSHash.h
│   │   │   │   │   └── CUtlVector.h
│   │   │   │   ├── schemasystem
│   │   │   │   │   └── schema.h
│   │   │   │   └── tier0
│   │   │   │       └── IMemAlloc.h
│   │   │   └── sdk.h
│   │   └── tools
│   │       ├── codegen
│   │       │   ├── c.h
│   │       │   ├── codegen.h
│   │       │   ├── cpp.h
│   │       │   └── detail
│   │       │       └── c_family.h
│   │       ├── field_parser.h
│   │       ├── fnv.h
│   │       ├── loader
│   │       │   ├── loader.h
│   │       │   ├── loader_linux.h
│   │       │   ├── loader_shared.h
│   │       │   └── loader_windows.h
│   │       ├── platform.h
│   │       ├── util.h
│   │       └── virtual.h
│   ├── src
│   │   ├── main.cpp
│   │   ├── options.cpp
│   │   ├── sdk
│   │   │   ├── interfaces
│   │   │   │   └── common
│   │   │   │       └── CBufferString.cpp
│   │   │   └── sdk.cpp
│   │   ├── startup
│   │   │   └── startup.cpp
│   │   └── tools
│   │       └── field_parser.cpp
│   └── test
│       ├── CMakeLists.txt
│       └── src
│           └── codegen
│               ├── test.c.cpp
│               └── test.cpp.cpp
├── source2gen-loader
│   ├── CMakeLists.txt
│   ├── include
│   │   └── steam_resolver.h
│   └── src
│       └── main.cpp
└── vendor
    └── CMakeLists.txt

```

`ACKNOWLEDGEMENTS`:

```
praydog/Source2Gen, https://github.com/praydog/Source2Gen/blob/43ea0e22dfc0732dc0103fa630f1828da6d5af84/LICENSE.md

    The MIT License (MIT)

    Copyright (c) 2015 praydog

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.21.0 FATAL_ERROR)

project(
    source2gen
    VERSION 0.1.0
    DESCRIPTION "Source2 games SDK generator"
    LANGUAGES CXX
    HOMEPAGE_URL "https://github.com/neverlosecc/source2gen"
)

if(CMAKE_SIZEOF_VOID_P EQUAL 4)
    message(FATAL_ERROR "source2gen: 32-bit targets are not supported")
endif()

set(CMAKE_TOOLCHAIN_FILE ${CMAKE_BINARY_DIR}/conan_toolchain.cmake)

set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

set(CMAKE_CXX_STANDARD 23 CACHE STRING "Default C++ standard")
message(STATUS "source2gen: C++ standard set to ${CMAKE_CXX_STANDARD}")
set(CMAKE_CXX_STANDARD_REQUIRED ON CACHE BOOL "Require C++ standard")
set(CMAKE_CXX_EXTENSIONS OFF CACHE BOOL "Allow C++ extensions")

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

set(CMAKE_POSITION_INDEPENDENT_CODE ON)

if(${CMAKE_SOURCE_DIR} STREQUAL ${CMAKE_BINARY_DIR})
    message(FATAL_ERROR "In-source builds are not allowed. Please make a new directory (called a build directory) and run CMake from there. You may need to remove CMakeCache.txt. ")
endif()

if(NOT CMAKE_BUILD_TYPE)
    message(STATUS "source2gen: Setting build type to 'Release' as none was specified.")
    set(CMAKE_BUILD_TYPE "Release")
endif()

if(NOT CMAKE_BUILD_TYPE STREQUAL "Debug" AND NOT CMAKE_BUILD_TYPE STREQUAL "Release")
    message(FATAL_ERROR "source2gen: Invalid value for CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")
endif()

find_package(argparse REQUIRED)

set(SOURCE2GEN_SUPPORTED_GAMES
    CS2
    DOTA2
    SBOX
    ARTIFACT2
    ARTIFACT1
    UNDERLORDS
    DESKJOB
    HL_ALYX
    THE_LAB_ROBOT_REPAIR
    DEADLOCK
)

option(SOURCE2GEN_GAME "Game to generate" "CS2")

if(NOT SOURCE2GEN_GAME)
    message(STATUS "source2gen: No game specified. Using default: CS2")
    set(SOURCE2GEN_GAME "CS2")
endif()

if(NOT SOURCE2GEN_GAME IN_LIST SOURCE2GEN_SUPPORTED_GAMES)
    message(FATAL_ERROR "source2gen: Invalid value for SOURCE2GEN_GAME: ${SOURCE2GEN_GAME}")
endif()

# Generating sdk-static
find_package(Python3 REQUIRED COMPONENTS Interpreter)
execute_process(
    COMMAND ${Python3_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/generate_static.py
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    RESULT_VARIABLE SDK_STATIC_SCRIPT_RESULT
    OUTPUT_VARIABLE SDK_STATIC_SCRIPT_OUTPUT
    ERROR_VARIABLE SDK_STATIC_SCRIPT_ERROR
)

if(NOT SDK_STATIC_SCRIPT_RESULT EQUAL 0)
    message(WARNING "Failed to generate sdk-static: ${SDK_STATIC_SCRIPT_ERROR}")
else()
    string(REGEX REPLACE "\n$" "" SDK_STATIC_SCRIPT_OUTPUT_TRIMMED "${SDK_STATIC_SCRIPT_OUTPUT}")
    message(STATUS "Generated sdk-static:\n${SDK_STATIC_SCRIPT_OUTPUT_TRIMMED}")
endif()

# This one should be included before we include any other projects
add_subdirectory(vendor)

add_subdirectory(source2gen)
add_subdirectory(source2gen-loader)

```

`LICENSE.txt`:

```txt
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2023 neverlosecc

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# Source2Gen

Source2Gen is a tool designed to generate SDKs for Source 2 games.

Example SDKs generated with this tool can be found at [neverlosecc/source2sdk](https://github.com/neverlosecc/source2sdk/tree/cs2).

---

## Features

- Extracts SDK definitions from Source 2 binaries with minimal effort
- Supports multiple Source 2 games (full list below)
- Emits **C++23**, **C23**, or **IDA-compatible C** headers
- Cross-platform: Windows and Linux

---

## Usage

### Windows

Launch `source2gen-loader.exe`:

```commandline
source2gen-loader.exe
```

The loader will attempt to automatically detect the game path.  
To specify the game directory manually:

```commandline
source2gen-loader.exe --game-path "C:\\Games\\CS2"
```

Additional arguments can be passed directly to source2gen via the loader, for example:

```commandline
source2gen-loader.exe --game-path "C:\\Games\\CS2" --emit-language c
```

---

### Linux (alpha-quality support)

Run the provided wrapper script:

```bash
./scripts/run.sh "$HOME/.steam/steam/steamapps/cs2/" [options]
```

Generated SDKs will appear under the `./sdk` directory.

For manual or debugging use, invoke directly:

```bash
LD_LIBRARY_PATH=$HOME/.steam/steam/steamapps/cs2/game/bin/linuxsteamrt64/:$HOME/.steam/steam/steamapps/cs2/game/csgo/bin/linuxsteamrt64/ \
  ./build/source2gen
```

**Note:** Linux support is experimental. Expect issues, incomplete output, or errors. Contributions to improve Linux support are encouraged.

---

## Using the Generated SDK

By default, the SDK contains dummy implementations for certain types, located in [sdk-static](sdk-static/cpp/include/source2sdk/source2gen/source2gen.hpp)

It is recommended to replace these dummy implementations with actual implementations specific to your needs.

---

## Output languages (`--emit-language`)

| Language   | Minimum Language Standard        |
|------------|----------------------------------|
| `cpp`      | C++23                            |
| `c`        | C23                              |
| `c-ida`    | C (single file: `sdk/ida.h`)     |

---

### Using IDA-compatible output (`c-ida`)

1. In IDA, navigate to **File -> Load File -> Parse C Header File...**
2. Select `sdk/ida.h`
3. Wait for compilation to complete (this may take some time)

All defined types will then be available under **Local Types** in IDA.

> [!NOTE]  
> The IDA support was tested on IDA Pro 9.1, all the "older" versions of IDA might not proceed the output well, feel free to open the issues in case you run into any issues though.

---

## Limitations

Some entities are omitted or replaced with dummy implementations in the generated SDK due to technical limitations:

- **Overlapping fields:** when multiple fields occupy the same memory location
- **Misaligned fields:** fields whose type alignment requirements prevent correct in-structure offset placement
- **Misaligned types:** class/struct types where padding would be needed beyond the original size to meet alignment rules
- **Entities using C++ templates**

Some of these limitations might be addressed in future versions using compiler-specific extensions.

---

## Development Setup

### Prerequisites

**Windows**

- Visual Studio 2019 or newer (build inside the "Developer Command Prompt")
- CMake
- Conan

**Linux**

- g++-13 or newer
- CMake
- Conan

---

### Clone repository

```bash
git clone --recurse-submodules https://github.com/neverlosecc/source2gen.git
```

---

### Selecting your game and building

Supported games:

`CS2` (default), `SBOX`, `ARTIFACT2`, `ARTIFACT1`, `DOTA2`, `UNDERLORDS`, `DESKJOB`, `DEADLOCK`, `HL_ALYX`, `THE_LAB_ROBOT_REPAIR`

Example build targeting DEADLOCK:

```bash
conan build -o "game=DEADLOCK" --build=missing .
```

Replace `DEADLOCK` with the chosen target.

---

### Running tests

Run unit tests (Linux):

```bash
LD_LIBRARY_PATH=$HOME/.steam/steam/steamapps/cs2/game/bin/linuxsteamrt64/:$HOME/.steam/steam/steamapps/cs2/game/csgo/bin/linuxsteamrt64/ \
  ./build/Release/bin/source2gen-test
```

Test whether the generated SDK compiles:

```bash
./scripts/test-cpp.sh ~/games/cs2/
```

---

## Internal Design

### C Generator

Implements the `codegen::IGenerator` interface, designed to be language-agnostic. Notable considerations:

- Namespaces and module information are encoded into identifiers to avoid conflicts
- Enumerator names include the enum name prefix to minimize name collisions
- Classes are emitted as `struct` in C/C++
- Uses of `struct`, `union`, `enum` types are prefixed with the "struct", "union", "enum" keyword respectively (see `codegen::TypeCategory`)
- Static fields are omitted for C output (the only currently known use case of C is to generate IDA headers)

---

### C-IDA Generator

Implemented as a wrapper on top of the C generator:

- Sets options `--no-static-assertions` and `--no-static-members`
- Performs postprocessing:
  - Merges all generated files into a single header (`sdk/ida.h`)
  - Removes system includes

---

## Credits

Special thanks to project contributors:

- [es3n1n](https://github.com/es3n1n)
- [cpz](https://github.com/cpz)
- [Cre3per](https://github.com/Cre3per) (Linux support)
- [Soufiw](https://github.com/Soufiw)
- [anarh1st47](https://github.com/anarh1st47)
- [praydog](https://github.com/praydog) (author of the original [Source2Gen](https://github.com/praydog/Source2Gen) tool)

If you have contributed and are not listed here, please submit a [pull request](https://github.com/neverlosecc/source2gen/pulls).

---

## Dependencies

- [Conan](https://github.com/conan-io/conan) - C and C++ package manager
- [CMake](https://github.com/Kitware/CMake) - Build system
- [ValveFileVDF](https://github.com/TinyTinni/ValveFileVDF) - VDF file parser
- [argparse](https://github.com/p-ranav/argparse) - C++ argument parser
- [Abseil](https://github.com/abseil/abseil-cpp) - Common C++ libraries from Google
- [GoogleTest](https://github.com/google/googletest) - Testing framework

```

`conanfile.py`:

```py
from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMake, cmake_layout, CMakeDeps


class pkgRecipe(ConanFile):
    name = "source2gen"
    version = "0.0.0"
    package_type = "application"

    requires = [
        "abseil/20240722.0",
        "argparse/3.2",
        "gtest/1.15.0",
    ]

    options = {
      "game": [
          "CS2",
          "DOTA2",
          "SBOX",
          "ARTIFACT2",
          "ARTIFACT1",
          "UNDERLORDS",
          "DESKJOB",
          "HL_ALYX",
          "THE_LAB_ROBOT_REPAIR",
          "DEADLOCK",
      ],
    }
    default_options = {
      "game": "CS2",
    }

    settings = "os", "compiler", "build_type", "arch"

    exports_sources = "CMakeLists.txt", "source2gen/*"

    def layout(self):
        cmake_layout(self)

    def generate(self):
        deps = CMakeDeps(self)
        deps.generate()
        tc = CMakeToolchain(self)
        tc.generate()

    def build(self):
        variables = {
          "SOURCE2GEN_GAME": self.options.game,
        }

        cmake = CMake(self)
        cmake.configure(variables=variables)
        cmake.build()

    def package(self):
        cmake = CMake(self)
        cmake.install()

```

`scripts/generate_static.py`:

```py
try:
    import tomllib
except ImportError:
    try:
        import tomli as tomllib
    except ImportError as err:
        msg = "Please install tomli to read TOML files. You can do this by running 'pip install tomli'."
        raise ImportError(msg) from err

from pathlib import Path
from typing import NotRequired, TypeAlias, TypedDict


AUTOGENERATED_WARNING = '// Autogenerated! Do not edit.'

ClassDef = TypedDict(
    'ClassDef',
    {
        'size': int | str,
        'note': NotRequired[str],
        'template-arguments-count': NotRequired[int],
        'template-arguments': NotRequired[list[str]],
    },
)
ClassDefs: TypeAlias = dict[str, ClassDef]


def status(msg: str) -> None:
    print(f'--   {msg}', flush=True)  # noqa: T201


def format_size(size: int | str) -> str:
    if isinstance(size, int):
        return f'0x{size:02x}'
    return size


def cpp_gen_template(template_args: list[str] | None, template_args_count: int | None) -> str | None:
    if template_args is None and template_args_count is None:
        return None

    if template_args_count is not None:
        if template_args:
            msg = 'template-arguments-count and template-arguments cannot be used together'
            raise ValueError(msg)

        template_args = ['typename' for _ in range(template_args_count)]

    args = ', '.join(template_args)
    return f'template <{args}>' if args else ''


def classes_iter(classes: ClassDefs) -> tuple[str, ClassDef]:
    yield from sorted(classes.items(), key=lambda c: c[0])


def assemble_cpp(classes: ClassDefs) -> str:
    result = [
        AUTOGENERATED_WARNING,
        '#pragma once',
        '#include <string_view>',
        '',
    ]

    for name, class_def in classes_iter(classes):
        if template := cpp_gen_template(class_def.get('template-arguments'), class_def.get('template-arguments-count')):
            result.append(template)

        if note := class_def.get('note'):
            result.append(f'// {note}')

        size = format_size(class_def['size'])
        result.append(f'using {name} = char[{size}];')

    result.extend(
        (
            '',
            '// intentionally left undefined. if you want to access static fields, add your own sdk.',
            'namespace interfaces {',
            '    struct SchemaStaticFieldData_t {',
            '        void* m_pInstance{};',
            '    };',
            '',
            '    struct CSchemaClassInfo {',
            '        auto GetStaticFields() -> SchemaStaticFieldData_t**;',
            '    };',
            '',
            '    struct CSchemaSystemTypeScope {',
            '        auto FindDeclaredClass(std::string_view) -> CSchemaClassInfo*;',
            '    };',
            '',
            '    struct schema_t {',
            '        auto FindTypeScopeForModule(std::string_view) -> CSchemaSystemTypeScope*;',
            '    };',
            '',
            '    extern schema_t* g_schema;',
            '} // namespace interfaces',
        )
    )

    return '\n'.join(result) + '\n'


def assemble_c(classes: ClassDefs) -> str:
    result = [
        AUTOGENERATED_WARNING,
        '#pragma once',
        '',
    ]

    for name, class_def in classes_iter(classes):
        if class_def.get('template-arguments') or class_def.get('template-arguments-count'):
            result.append(f'// skipped template {name}')
            continue

        if note := class_def.get('note'):
            result.append(f'// {note}')

        size = format_size(class_def['size'])
        result.append(f'typedef char {name}[{size}];')

    return '\n'.join(result) + '\n'


def dump_to(cwd: Path, language: str, filename: str, content: str) -> None:
    cpp_dir = cwd / 'sdk-static' / language / 'include' / 'source2sdk' / 'source2gen'
    cpp_dir.mkdir(parents=True, exist_ok=True)

    output_file = cpp_dir / filename
    output_file.write_text(content)

    status(f'Wrote {len(content)} bytes to {language}/{filename}')


def main() -> None:
    cwd = Path(__file__).parent.parent.resolve().absolute()
    toml_file: ClassDefs = tomllib.loads((cwd / 'sdk-static.toml').read_text(encoding='utf-8'))

    status(f'Read {len(toml_file)} types from sdk-static.toml')

    cpp = assemble_cpp(toml_file)
    dump_to(cwd, 'cpp', 'source2gen.hpp', cpp)

    c = assemble_c(toml_file)
    dump_to(cwd, 'c', 'source2gen.h', c)


if __name__ == '__main__':
    main()

```

`scripts/license_template.txt`:

```txt
source2gen - Source2 games SDK generator
Copyright %year% neverlosecc

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.


```

`scripts/license_template_header.txt`:

```txt
Copyright (C) %year% neverlosecc
See end of file for extended copyright information.

```

`scripts/run.sh`:

```sh
#!/bin/bash

set -Eueo pipefail

GAME_DIRECTORY="${1:-}"
shift
SCRIPT_DIRECTORY="$(dirname "$(readlink -f "$0")")"
PROJECT_ROOT="${SCRIPT_DIRECTORY}/../"
BINARY=""

find_second_bin_directory() {
    local game_path="$1"

    local found;found="$(find "${game_path}" -name libclient.so)"

    if [ -z "${found}" ]; then
      echo "Error: unable to find second bin directory" >&2
      exit 1
    else
      dirname "${found}"
    fi
}

if [ -z "${GAME_DIRECTORY}" ]; then
  echo "usage: run.sh <path/to/game/directory>"
  echo "eg   : run.sh $HOME/.steam/steam/steamapps/cs2/"
  exit 1
fi

for subdirectory in \
  "build/bin/source2gen" \
  "build/debug/bin/source2gen" \
  "build/release/bin/source2gen" \
  "build/Debug/bin/source2gen" \
  "build/Release/bin/source2gen"
  do
  target="${PROJECT_ROOT}/${subdirectory}"
  if [ -f "${target}" ]; then
    BINARY="${target}"
    break
  fi
done

if [ -z "${BINARY}" ]; then
  echo "source2gen binary not found. set LD_PRELOAD_PATH and run source2gen by hand."
  exit 1
else
  FIRST_BIN_DIRECTORY="${GAME_DIRECTORY}/game/bin/linuxsteamrt64/"
  SECOND_BIN_DIRECTORY=$(find_second_bin_directory "$GAME_DIRECTORY")
  export LD_LIBRARY_PATH="${FIRST_BIN_DIRECTORY}:${SECOND_BIN_DIRECTORY}:${LD_LIBRARY_PATH:-}"
  echo "setting LD_LIBRARY_PATH to ${LD_LIBRARY_PATH}"
  set -x
  if [ -z "${DEBUGGER:-}" ]; then
    "${BINARY}" "${@}"
  else
    "${DEBUGGER}" -- "${BINARY}" "${@}"
  fi
fi

```

`scripts/test.sh`:

```sh
#!/bin/bash

# examples:
# scripts/test-cpp.sh ~/games/cs2/
# scripts/test-cpp.sh ~/games/cs2/ cpp

# this is a rudimentary test script to test the C++ output.
# we should switch to a test framework (like GTest) and test
# individual functions and classes instead for better test
# performance, faster debugging, and without using the file system.

set -Eeuxo pipefail

SCRIPT_DIRECTORY="$(dirname "$(readlink -f "$0")")"
PROJECT_ROOT="${SCRIPT_DIRECTORY}/../"

CS2_DIRECTORY="${1}"
TEST_LANGUAGE="${2:-}"

test_language()
{
    local language="${1}"
    # remove contents of sdk directory instead of the directory itself
    # because the user might have a shell open in the sdk directory.
    rm -rf "${PROJECT_ROOT}/sdk/"*
    "${PROJECT_ROOT}/scripts/run.sh" "${CS2_DIRECTORY}" --emit-language "${language}"

    pushd "${PROJECT_ROOT}/sdk/"
    # conan invokes cmake, which compiles "compile-test" binary to check if the SDK compiles
    conan create .
    popd

    echo "success: ${language}"
}

if [ -z ${TEST_LANGUAGE} ]; then
    test_language "cpp"
    test_language "c"
else
    test_language "${TEST_LANGUAGE}"
fi

```

`scripts/update_copyrights.py`:

```py
from pathlib import Path
from datetime import datetime
from typing import List


EXTENSIONS = ['.cpp', '.cc', '.cxx', '.c', '.hpp', '.h']


current_dir = Path(__file__).parent
current_year = str(datetime.utcnow().year)


def format_buffer(s: str) -> str:
    return s.replace('%year%', current_year)


with open(current_dir / 'license_template.txt', 'r') as f:
    license_template = format_buffer(f.read())

with open(current_dir / 'license_template_header.txt', 'r') as f:
    license_template_header = format_buffer(f.read())


def get_comment_chr(file_name: str) -> str:
    return '#' if file_name.endswith('.py') else '//'


def to_comments(file_name: str, buffer: str) -> str:
    comment_chr: str = get_comment_chr(file_name)
    return '\n'.join([f'{comment_chr} {line}'.strip() for line in buffer.splitlines()])


def remove_copyright(file_name: str, lines: List[str]) -> List[str]:
    comment_chr: str = get_comment_chr(file_name)

    ends_at: int = 0
    for i, line in enumerate(lines):
        if line.startswith(comment_chr):
            continue

        ends_at = max(0, i)
        break

    starts_at_bottom: int = len(lines) - 1
    for i, line in reversed(list(enumerate(lines))):
        if line.startswith(comment_chr) or line == '':
            continue

        starts_at_bottom = min(len(lines) - 1, i + 1)
        break

    return lines[ends_at:starts_at_bottom]


def append_copyright_to(p: Path) -> None:
    header = to_comments(p.name, license_template_header).splitlines()
    full = to_comments(p.name, license_template).splitlines()

    with open(p, 'r') as f:
        file_lines = f.read().splitlines()

    def _is_copyrighted() -> bool:
        index = header[0].find(current_year)
        assert index != -1
        return file_lines[0][:index] == header[0][:index]
    
    is_copyrighted = _is_copyrighted()
    if is_copyrighted:
        file_lines = remove_copyright(p.name, file_lines)

    file_lines = header + file_lines + [''] + full + ['']
    with open(p, 'w') as f:
        f.write('\n'.join(file_lines))


def iter_dir(p: Path) -> None:
    for file in p.iterdir():
        if file.is_dir():
            iter_dir(file)
            continue

        for ext in EXTENSIONS:
            if not file.name.endswith(ext):
                continue

            append_copyright_to(file)
            break


if __name__ == '__main__':
    iter_dir(Path(__file__).parent.parent)


```

`sdk-static.toml`:

```toml
[CAnimValue]
template-arguments-count = 1
size = 0x08

[CAnimVariant]
size = 0x11

[CAnimScriptParam]
template-arguments-count = 1
size = 0x08
note = "size is a guess"

[CBufferString]
size = 0x10

[CColorGradient]
size = 0x18

[CCompressor]
template-arguments-count = 1
size = 0x01
note = "size doesn't matter. only used as a pointer"

[CEntityHandle]
size = 0x04

[CEntityIndex]
size = 0x04

[CGlobalSymbol]
size = 0x08

[CKV3MemberNameWithStorage]
size = 0x38

[CNetworkedQuantizedFloat]
size = 0x08

[CParticleNamedValueRef]
size = 0x40

[CPiecewiseCurve]
size = 0x40

[CPlayerSlot]
size = 0x04

[CPulseValueFullType]
size = 0x10
note = "size is 8 bytes bigger in Deadlock"

[CResourceName]
size = 0xe0

[CSplitScreenSlot]
size = 0x04

[CTransform]
size = 0x20

[CUtlBinaryBlock]
size = 0x18

[CUtlHashtable]
template-arguments-count = 2
size = 0x20

[CUtlStringTokenWithStorage]
size = 0x18

[CUtlStringToken]
size = 0x04

[CUtlString]
size = 0x08

[CUtlSymbolLarge]
size = 0x08

[CUtlSymbol]
size = 0x02

[CAnimGraphParamOptionalRef]
template-arguments-count = 1
size = 0x20

[CAnimGraphParamRef]
template-arguments-count = 1
size = 0x20

[CBitVec]
template-arguments = ["int N"]
size = "(N + 7) / 8"

[CEntityOutputTemplate]
template-arguments-count = 1
size = 0x28

[CHandle]
template-arguments-count = 1
size = 0x04

[C_NetworkUtlVectorBase]
template-arguments-count = 1
size = 0x18

[CNetworkUtlVectorBase]
template-arguments-count = 1
size = 0x18

[CSoundEventName]
size = 0x10

[CUtlLeanVector]
template-arguments-count = 1
size = 0x10

[CUtlOrderedMap]
template-arguments-count = 2
size = 0x28

[CUtlPair]
template-arguments-count = 2
size = 0x01
note = "size doesn't matter. only used as a pointer"

[CUtlVector]
template-arguments-count = 1
size = 0x18

[CUtlVectorFixedGrowable]
template-arguments = ["typename Ty"]
size = "0x18 + ((sizeof(Ty) < 4) ? 4 : sizeof(Ty))"
note = "size is a guess that fits both occurrences of this type in CS2"

[CUtlLeanVectorFixedGrowable]
template-arguments = ["typename Ty"]
size = "0x10 + ((sizeof(Ty) < 4) ? 4 : sizeof(Ty))"

[C_UtlVectorEmbeddedNetworkVar]
template-arguments-count = 1
size = 0x50

[CUtlVectorEmbeddedNetworkVar]
template-arguments-count = 1
size = 0x50

[CUtlVectorSIMDPaddedVector]
size = 0x18

[CSmartPtr]
template-arguments-count = 1
size = 0x08

[CResourceArray]
template-arguments-count = 1
size = 0x08

[CResourceString]
size = 0x08
note = "size unknown"

[CResourcePointer]
template-arguments-count = 1
size = 0x08

[CResourceNameTyped]
template-arguments-count = 1
size = 0xe0

[CStrongHandle]
template-arguments-count = 1
size = 0x08

[CStrongHandleCopyable]
template-arguments-count = 1
size = 0x08

[CStrongHandleVoid]
size = 0x08
note = "size doesn't matter. only used as a pointer"

[CVariantBase]
template-arguments-count = 1
size = 0x10

[CWeakHandle]
template-arguments-count = 1
size = 0x18

[CSmartPropAttributeVector]
size = 0x40

[CSmartPropAttributeFloat]
size = 0x40

[CSmartPropAttributeBool]
size = 0x40

[CSmartPropAttributeColor]
size = 0x40

[CSmartPropAttributeInt]
size = 0x40

[CSmartPropAttributeModelName]
size = 0x40

[CSmartPropAttributeMaterialGroup]
size = 0x40

[CSmartPropAttributeVector2D]
size = 0x40

[CSmartPropVariableComparison]
size = 0x20

[CSmartPropAttributeAngles]
size = 0x40

[CSmartPropAttributeStateName]
size = 0x40

[CSmartPropAttributeVariableValue]
size = 0x40

[Color]
size = 0x04

[DegreeEuler]
size = 0x0c

[FourVectors]
size = 0x30

[HSCRIPT]
size = 0x08

[KeyValues3]
size = 0x10

[KeyValues]
size = 0x01
note = "size doesn't matter. only used as a pointer"

[QAngle]
size = 0x0c

[QuaternionStorage]
size = 0x10

[Quaternion]
size = 0x10

[RadianEuler]
size = 0x0c

[RotationVector]
size = 0x0c

[SphereBase_t]
template-arguments-count = 1
size = 0x10

[Vector2D]
size = 0x08

[Vector4D]
size = 0x10

[VectorAligned]
size = 0x10

[Vector]
size = 0x0c

[WorldGroupId_t]
size = 0x04

[float32]
size = 0x04

[fltx4]
size = 0x10

[matrix3x4_t]
size = 0x30

[matrix3x4a_t]
size = 0x30

[Range_t]
size = 0x08

[V_uuid_t]
size = 0x10

[CAnimGraphTagOptionalRef]
size = 0x18

[CPanoramaImageName]
size = 0x10

[CAnimGraphTagRef]
size = 0x18

[CAttachmentNameSymbolWithStorage]
size = 0x20

[CGlobalSymbolCaseSensitive]
size = 0x08

[CKV3MemberNameSet]
size = 0x10

[CSmartPropAttributeMaterialName]
size = 0x40

[PulseSymbol_t]
size = 0x10

[panorama_CPanelPtr]
size = 0x08

```

`sdk-static/c/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.30)

set(CMAKE_EXPORT_COMPILE_COMMANDS On)
# Lowest standard we meet. Feel free to bump if we need a newer standard.
# Need C23 for enums with fixed underlying types
set(CMAKE_C_STANDARD 23)
set(CMAKE_C_STANDARD_REQUIRED ON)
set(CMAKE_C_EXTENSIONS OFF)

project(source2sdk
  LANGUAGES C
)

file(GLOB_RECURSE source2sdk_headers "./**.h")

add_library(${PROJECT_NAME} INTERFACE)
target_include_directories(${PROJECT_NAME} INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include)
set_target_properties(${PROJECT_NAME} PROPERTIES PUBLIC_HEADER "${source2sdk_headers}")

set_target_properties(${PROJECT_NAME} PROPERTIES LINKER_LANGUAGE C)

install(
  DIRECTORY "${CMAKE_SOURCE_DIR}/include"
  DESTINATION .
)

# Add a target that includes all headers of the generated library to check for compile-time errors

foreach(el ${source2sdk_headers})
    string(APPEND generated_cpp_contents "#include \"${el}\"\n")
endforeach()

set(generated_cpp_file "${CMAKE_BINARY_DIR}/all_headers.c")

file(WRITE ${generated_cpp_file} ${generated_cpp_contents})

add_library(${PROJECT_NAME}-compile-test ${generated_cpp_file})
set_target_properties(${PROJECT_NAME}-compile-test PROPERTIES LINKER_LANGUAGE C)
target_link_libraries(${PROJECT_NAME}-compile-test ${PROJECT_NAME})

target_compile_options(${PROJECT_NAME}-compile-test PRIVATE
    "-Wfatal-errors"
    "-pedantic-errors"
)

```

`sdk-static/c/conanfile.py`:

```py
from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMake, cmake_layout, CMakeDeps


# TODO: We should set `version` and `name` to reflect what game this sdk is for
class source2sdkRecipe(ConanFile):
    name = "source2sdk"
    version = "0.0.0"
    package_type = "library"

    author = "source2gen"
    url = "https://github.com/neverlosecc/source2gen"
    description = "Source2 SDK"
    topics = ("source2")

    settings = "os", "compiler", "build_type", "arch"
    options = {"shared": [True, False], "fPIC": [True, False]}
    default_options = {"shared": False, "fPIC": True}

    exports_sources = "CMakeLists.txt", "include/*"

    def config_options(self):
        if self.settings.os == "Windows":
            self.options.rm_safe("fPIC")

    def configure(self):
        if self.options.shared:
            self.options.rm_safe("fPIC")

    def layout(self):
        cmake_layout(self)

    def generate(self):
        deps = CMakeDeps(self)
        deps.generate()
        tc = CMakeToolchain(self)
        tc.generate()

    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()

    def package(self):
        cmake = CMake(self)
        cmake.install()

    def package_info(self):
        self.cpp_info.bindirs = []
        self.cpp_info.libdirs = []


```

`sdk-static/c/include/source2sdk/source2gen/source2gen.h`:

```h
// Autogenerated! Do not edit.
#pragma once

// skipped template CAnimGraphParamOptionalRef
// skipped template CAnimGraphParamRef
typedef char CAnimGraphTagOptionalRef[0x18];
typedef char CAnimGraphTagRef[0x18];
// skipped template CAnimScriptParam
// skipped template CAnimValue
typedef char CAnimVariant[0x11];
typedef char CAttachmentNameSymbolWithStorage[0x20];
// skipped template CBitVec
typedef char CBufferString[0x10];
typedef char CColorGradient[0x18];
// skipped template CCompressor
typedef char CEntityHandle[0x04];
typedef char CEntityIndex[0x04];
// skipped template CEntityOutputTemplate
typedef char CGlobalSymbol[0x08];
typedef char CGlobalSymbolCaseSensitive[0x08];
// skipped template CHandle
typedef char CKV3MemberNameSet[0x10];
typedef char CKV3MemberNameWithStorage[0x38];
// skipped template CNetworkUtlVectorBase
typedef char CNetworkedQuantizedFloat[0x08];
typedef char CPanoramaImageName[0x10];
typedef char CParticleNamedValueRef[0x40];
typedef char CPiecewiseCurve[0x40];
typedef char CPlayerSlot[0x04];
// size is 8 bytes bigger in Deadlock
typedef char CPulseValueFullType[0x10];
// skipped template CResourceArray
typedef char CResourceName[0xe0];
// skipped template CResourceNameTyped
// skipped template CResourcePointer
// size unknown
typedef char CResourceString[0x08];
typedef char CSmartPropAttributeAngles[0x40];
typedef char CSmartPropAttributeBool[0x40];
typedef char CSmartPropAttributeColor[0x40];
typedef char CSmartPropAttributeFloat[0x40];
typedef char CSmartPropAttributeInt[0x40];
typedef char CSmartPropAttributeMaterialGroup[0x40];
typedef char CSmartPropAttributeMaterialName[0x40];
typedef char CSmartPropAttributeModelName[0x40];
typedef char CSmartPropAttributeStateName[0x40];
typedef char CSmartPropAttributeVariableValue[0x40];
typedef char CSmartPropAttributeVector[0x40];
typedef char CSmartPropAttributeVector2D[0x40];
typedef char CSmartPropVariableComparison[0x20];
// skipped template CSmartPtr
typedef char CSoundEventName[0x10];
typedef char CSplitScreenSlot[0x04];
// skipped template CStrongHandle
// skipped template CStrongHandleCopyable
// size doesn't matter. only used as a pointer
typedef char CStrongHandleVoid[0x08];
typedef char CTransform[0x20];
typedef char CUtlBinaryBlock[0x18];
// skipped template CUtlHashtable
// skipped template CUtlLeanVector
// skipped template CUtlLeanVectorFixedGrowable
// skipped template CUtlOrderedMap
// skipped template CUtlPair
typedef char CUtlString[0x08];
typedef char CUtlStringToken[0x04];
typedef char CUtlStringTokenWithStorage[0x18];
typedef char CUtlSymbol[0x02];
typedef char CUtlSymbolLarge[0x08];
// skipped template CUtlVector
// skipped template CUtlVectorEmbeddedNetworkVar
// skipped template CUtlVectorFixedGrowable
typedef char CUtlVectorSIMDPaddedVector[0x18];
// skipped template CVariantBase
// skipped template CWeakHandle
// skipped template C_NetworkUtlVectorBase
// skipped template C_UtlVectorEmbeddedNetworkVar
typedef char Color[0x04];
typedef char DegreeEuler[0x0c];
typedef char FourVectors[0x30];
typedef char HSCRIPT[0x08];
// size doesn't matter. only used as a pointer
typedef char KeyValues[0x01];
typedef char KeyValues3[0x10];
typedef char PulseSymbol_t[0x10];
typedef char QAngle[0x0c];
typedef char Quaternion[0x10];
typedef char QuaternionStorage[0x10];
typedef char RadianEuler[0x0c];
typedef char Range_t[0x08];
typedef char RotationVector[0x0c];
// skipped template SphereBase_t
typedef char V_uuid_t[0x10];
typedef char Vector[0x0c];
typedef char Vector2D[0x08];
typedef char Vector4D[0x10];
typedef char VectorAligned[0x10];
typedef char WorldGroupId_t[0x04];
typedef char float32[0x04];
typedef char fltx4[0x10];
typedef char matrix3x4_t[0x30];
typedef char matrix3x4a_t[0x30];
typedef char panorama_CPanelPtr[0x08];

```

`sdk-static/cpp/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.30)

set(CMAKE_EXPORT_COMPILE_COMMANDS On)
# Lowest standard we meet. Feel free to bump if we need a newer standard.
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

project(source2sdk
  LANGUAGES CXX
)

file(GLOB_RECURSE source2sdk_headers "./**.hpp")

add_library(${PROJECT_NAME} INTERFACE)
target_include_directories(${PROJECT_NAME} INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include)
set_target_properties(${PROJECT_NAME} PROPERTIES PUBLIC_HEADER "${source2sdk_headers}")

set_target_properties(${PROJECT_NAME} PROPERTIES LINKER_LANGUAGE CXX)

install(
  DIRECTORY "${CMAKE_SOURCE_DIR}/include"
  DESTINATION .
)

# Add a target that includes all headers of the generated library to check for compile-time errors

foreach(el ${source2sdk_headers})
    string(APPEND generated_cpp_contents "#include \"${el}\"\n")
endforeach()

set(generated_cpp_file "${CMAKE_BINARY_DIR}/all_headers.cpp")

file(WRITE ${generated_cpp_file} ${generated_cpp_contents})

add_library(${PROJECT_NAME}-compile-test ${generated_cpp_file})
set_target_properties(${PROJECT_NAME}-compile-test PROPERTIES LINKER_LANGUAGE CXX)
target_link_libraries(${PROJECT_NAME}-compile-test ${PROJECT_NAME})

target_compile_options(${PROJECT_NAME}-compile-test PRIVATE
    "-Wfatal-errors"
    "-pedantic-errors"
)

```

`sdk-static/cpp/conanfile.py`:

```py
from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMake, cmake_layout, CMakeDeps


# TODO: We should set `version` and `name` to reflect what game this sdk is for
class source2sdkRecipe(ConanFile):
    name = "source2sdk"
    version = "0.0.0"
    package_type = "library"

    author = "source2gen"
    url = "https://github.com/neverlosecc/source2gen"
    description = "Source2 SDK"
    topics = ("source2",)

    settings = "os", "compiler", "build_type", "arch"
    options = {"shared": [True, False], "fPIC": [True, False]}
    default_options = {"shared": False, "fPIC": True}

    exports_sources = "CMakeLists.txt", "include/*"

    def config_options(self):
        if self.settings.os == "Windows":
            self.options.rm_safe("fPIC")

    def configure(self):
        if self.options.shared:
            self.options.rm_safe("fPIC")

    def layout(self):
        cmake_layout(self)

    def generate(self):
        deps = CMakeDeps(self)
        deps.generate()
        tc = CMakeToolchain(self)
        tc.generate()

    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()

    def package(self):
        cmake = CMake(self)
        cmake.install()

    def package_info(self):
        self.cpp_info.bindirs = []
        self.cpp_info.libdirs = []


```

`sdk-static/cpp/include/source2sdk/source2gen/source2gen.hpp`:

```hpp
// Autogenerated! Do not edit.
#pragma once
#include <string_view>

template <typename>
using CAnimGraphParamOptionalRef = char[0x20];
template <typename>
using CAnimGraphParamRef = char[0x20];
using CAnimGraphTagOptionalRef = char[0x18];
using CAnimGraphTagRef = char[0x18];
template <typename>
// size is a guess
using CAnimScriptParam = char[0x08];
template <typename>
using CAnimValue = char[0x08];
using CAnimVariant = char[0x11];
using CAttachmentNameSymbolWithStorage = char[0x20];
template <int N>
using CBitVec = char[(N + 7) / 8];
using CBufferString = char[0x10];
using CColorGradient = char[0x18];
template <typename>
// size doesn't matter. only used as a pointer
using CCompressor = char[0x01];
using CEntityHandle = char[0x04];
using CEntityIndex = char[0x04];
template <typename>
using CEntityOutputTemplate = char[0x28];
using CGlobalSymbol = char[0x08];
using CGlobalSymbolCaseSensitive = char[0x08];
template <typename>
using CHandle = char[0x04];
using CKV3MemberNameSet = char[0x10];
using CKV3MemberNameWithStorage = char[0x38];
template <typename>
using CNetworkUtlVectorBase = char[0x18];
using CNetworkedQuantizedFloat = char[0x08];
using CPanoramaImageName = char[0x10];
using CParticleNamedValueRef = char[0x40];
using CPiecewiseCurve = char[0x40];
using CPlayerSlot = char[0x04];
// size is 8 bytes bigger in Deadlock
using CPulseValueFullType = char[0x10];
template <typename>
using CResourceArray = char[0x08];
using CResourceName = char[0xe0];
template <typename>
using CResourceNameTyped = char[0xe0];
template <typename>
using CResourcePointer = char[0x08];
// size unknown
using CResourceString = char[0x08];
using CSmartPropAttributeAngles = char[0x40];
using CSmartPropAttributeBool = char[0x40];
using CSmartPropAttributeColor = char[0x40];
using CSmartPropAttributeFloat = char[0x40];
using CSmartPropAttributeInt = char[0x40];
using CSmartPropAttributeMaterialGroup = char[0x40];
using CSmartPropAttributeMaterialName = char[0x40];
using CSmartPropAttributeModelName = char[0x40];
using CSmartPropAttributeStateName = char[0x40];
using CSmartPropAttributeVariableValue = char[0x40];
using CSmartPropAttributeVector = char[0x40];
using CSmartPropAttributeVector2D = char[0x40];
using CSmartPropVariableComparison = char[0x20];
template <typename>
using CSmartPtr = char[0x08];
using CSoundEventName = char[0x10];
using CSplitScreenSlot = char[0x04];
template <typename>
using CStrongHandle = char[0x08];
template <typename>
using CStrongHandleCopyable = char[0x08];
// size doesn't matter. only used as a pointer
using CStrongHandleVoid = char[0x08];
using CTransform = char[0x20];
using CUtlBinaryBlock = char[0x18];
template <typename, typename>
using CUtlHashtable = char[0x20];
template <typename>
using CUtlLeanVector = char[0x10];
template <typename Ty>
using CUtlLeanVectorFixedGrowable = char[0x10 + ((sizeof(Ty) < 4) ? 4 : sizeof(Ty))];
template <typename, typename>
using CUtlOrderedMap = char[0x28];
template <typename, typename>
// size doesn't matter. only used as a pointer
using CUtlPair = char[0x01];
using CUtlString = char[0x08];
using CUtlStringToken = char[0x04];
using CUtlStringTokenWithStorage = char[0x18];
using CUtlSymbol = char[0x02];
using CUtlSymbolLarge = char[0x08];
template <typename>
using CUtlVector = char[0x18];
template <typename>
using CUtlVectorEmbeddedNetworkVar = char[0x50];
template <typename Ty>
// size is a guess that fits both occurrences of this type in CS2
using CUtlVectorFixedGrowable = char[0x18 + ((sizeof(Ty) < 4) ? 4 : sizeof(Ty))];
using CUtlVectorSIMDPaddedVector = char[0x18];
template <typename>
using CVariantBase = char[0x10];
template <typename>
using CWeakHandle = char[0x18];
template <typename>
using C_NetworkUtlVectorBase = char[0x18];
template <typename>
using C_UtlVectorEmbeddedNetworkVar = char[0x50];
using Color = char[0x04];
using DegreeEuler = char[0x0c];
using FourVectors = char[0x30];
using HSCRIPT = char[0x08];
// size doesn't matter. only used as a pointer
using KeyValues = char[0x01];
using KeyValues3 = char[0x10];
using PulseSymbol_t = char[0x10];
using QAngle = char[0x0c];
using Quaternion = char[0x10];
using QuaternionStorage = char[0x10];
using RadianEuler = char[0x0c];
using Range_t = char[0x08];
using RotationVector = char[0x0c];
template <typename>
using SphereBase_t = char[0x10];
using V_uuid_t = char[0x10];
using Vector = char[0x0c];
using Vector2D = char[0x08];
using Vector4D = char[0x10];
using VectorAligned = char[0x10];
using WorldGroupId_t = char[0x04];
using float32 = char[0x04];
using fltx4 = char[0x10];
using matrix3x4_t = char[0x30];
using matrix3x4a_t = char[0x30];
using panorama_CPanelPtr = char[0x08];

// intentionally left undefined. if you want to access static fields, add your own sdk.
namespace interfaces {
    struct SchemaStaticFieldData_t {
        void* m_pInstance{};
    };

    struct CSchemaClassInfo {
        auto GetStaticFields() -> SchemaStaticFieldData_t**;
    };

    struct CSchemaSystemTypeScope {
        auto FindDeclaredClass(std::string_view) -> CSchemaClassInfo*;
    };

    struct schema_t {
        auto FindTypeScopeForModule(std::string_view) -> CSchemaSystemTypeScope*;
    };

    extern schema_t* g_schema;
} // namespace interfaces

```

`source2gen-loader/CMakeLists.txt`:

```txt
# We have decided that while loader **can** work on linux, there's no maintainer for it.
# For now loader will be only for windows, if there would be demand for it on linux we'll come up with something.
if (WIN32)
    add_executable(source2gen-loader)

    file(GLOB_RECURSE source2gen_loader_SOURCES "src/**.cpp")
    file(GLOB_RECURSE source2gen_loader_HEADERS "include/**.h")

    target_sources(source2gen-loader PRIVATE ${source2gen_loader_SOURCES} ${source2gen_loader_HEADERS})
    target_include_directories(source2gen-loader PRIVATE
        "include"
    )

    target_link_libraries(source2gen-loader PRIVATE
        ValveFileVDF
    )

    if(MSVC)
        target_link_options(source2gen-loader PRIVATE "/pdbaltpath:%_PDB%")
    endif()

    target_compile_definitions(source2gen-loader PRIVATE
        "${SOURCE2GEN_GAME}"
        "_CRT_SECURE_NO_WARNINGS"
        "NOMINMAX"
        "WIN32_LEAN_AND_MEAN"
        "_WIN32_WINNT=0x601"
    )

    add_dependencies(source2gen-loader source2gen)
endif()

```

`source2gen-loader/include/steam_resolver.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include <windows.h>

#include <filesystem>
#include <fstream>
#include <optional>
#include <string>

#include "vdf_parser.hpp"

namespace steam_resolver {
    [[nodiscard]] inline std::optional<std::filesystem::path> find_game(const std::size_t app_id) {
        HKEY reg_tree;
        if (RegOpenKeyW(HKEY_CURRENT_USER, L"SOFTWARE\\Valve\\Steam", &reg_tree)) {
            return std::nullopt;
        }

        DWORD steam_path_size = MAX_PATH;
        std::wstring steam_path_str;
        steam_path_str.resize(steam_path_size);

        const auto query_stat =
            RegQueryValueExW(reg_tree, L"SteamPath", nullptr, nullptr, reinterpret_cast<LPBYTE>(steam_path_str.data()), &steam_path_size);
        RegCloseKey(reg_tree);

        if (query_stat) {
            return std::nullopt;
        }

        steam_path_str.resize(steam_path_size / sizeof(wchar_t) - 1);

        const auto library_folders_path = std::filesystem::path{steam_path_str} / "steamapps" / "libraryfolders.vdf";
        if (!exists(library_folders_path)) {
            return std::nullopt;
        }

        std::ifstream library_folders_stream(library_folders_path);
        const auto library_folders = tyti::vdf::read(library_folders_stream);

        const auto app_id_str = std::to_string(app_id);

        for (const auto& [index, info] : library_folders.childs) {
            const auto steam_apps_path = std::filesystem::path(info->attribs.at("path")) / "steamapps";
            const auto apps_it = info->childs.at("apps");

            const auto app_it = apps_it->attribs.find(app_id_str);
            if (app_it == std::end(apps_it->attribs)) {
                continue;
            }

            std::filesystem::path manifest_path = steam_apps_path / std::format("appmanifest_{}.acf", app_id_str);
            if (!exists(manifest_path)) [[unlikely]] {
                continue;
            }

            std::ifstream manifest_stream(manifest_path);
            const auto manifest = tyti::vdf::read(manifest_stream);
            const auto install_dir = manifest.attribs.at("installdir");

            return steam_apps_path / "common" / install_dir;
        }

        return std::nullopt;
    }
} // namespace steam_resolver

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen-loader/src/main.cpp`:

```cpp
#include <cassert>
#include <print>
#include <ranges>
#include <span>

#include "steam_resolver.h"

namespace {
    constexpr std::size_t kGameId =
#if defined(CS2)
        730
#elif defined(DOTA2)
        570
#elif defined(SBOX)
        590830
#elif defined(ARTIFACT2)
        2082270
#elif defined(ARTIFACT1)
        583950
#elif defined(UNDERLORDS)
        1046930
#elif defined(DESKJOB)
        1902490
#elif defined(HL_ALYX)
        546560
#elif defined(THE_LAB_ROBOT_REPAIR)
        450390
#elif defined(DEADLOCK)
        1422450
#else
    #error
#endif
        ;

    constexpr auto kEnvVarName = "PATH";
    constexpr auto kEnvVarPathSep = ";";
    constexpr auto kPlatformDirName = "win64";
    constexpr auto kExecutableName = "source2gen.exe";

    [[nodiscard]] std::optional<std::string> getenv_impl(const std::string& key) {
        const char* val = std::getenv(key.c_str());
        if (val == nullptr) {
            return std::nullopt;
        }
        return std::string(val);
    }

    [[nodiscard]] std::filesystem::path find_second_bin_directory(const std::filesystem::path& game_path) {
        for (const auto& it : std::filesystem::directory_iterator{game_path / "game"}) {
            if (!it.is_directory()) {
                continue;
            }

            const auto path = it.path() / "bin" / kPlatformDirName;
            if (!exists(path)) {
                continue;
            }

            return path;
        }

        throw std::runtime_error("unable to find second bin directory");
    }

    struct Config {
        std::optional<std::filesystem::path> game_path = std::nullopt;
    };

    [[nodiscard]] Config parse_arguments(std::vector<std::string>& arguments) {
        using Iter = std::decay_t<decltype(arguments)>::iterator;
        Config result;

        auto show_help = [&]() -> void {
            std::println("Usage: source2gen-loader [--help] [--game-path VAR]\n\n"
                         "More cli options that will be forwarded to source2gen can be seen via:\n"
                         "\tsource2gen --help\n\n"
                         "Optional arguments:\n"
                         "--help              shows help message and exits\n"
                         "--game-path         set the game path manually (ignore the game path resolver)");
            std::exit(0);
        };

        auto read_val = [&](Iter& it, std::string_view command) -> std::optional<std::string> {
            if (*it != command) {
                return std::nullopt;
            }

            const auto next_it = std::next(it);
            if (next_it == arguments.end()) {
                throw std::runtime_error(std::format("{} requires a value", command));
            }

            auto value = *next_it;
            it = arguments.erase(it, std::next(next_it));
            return value;
        };

        for (auto it = arguments.begin(); it != arguments.end();) {
            if (*it == "--help") {
                show_help();
                continue;
            }

            if (auto game_path = read_val(it, "--game-path"); game_path.has_value()) {
                result.game_path = *game_path;
                continue;
            }

            it = std::next(it);
        }

        return result;
    }

} // namespace

int main(const int argc, char* argv[]) try {
    std::span args_raw(argv, argc);
    std::vector<std::string> arguments(args_raw.begin(), args_raw.end());

    const auto config = parse_arguments(arguments);

    std::println("*** loading for game with app_id={:d}", kGameId);
    auto path = config.game_path;
    if (!path.has_value()) {
        path = steam_resolver::find_game(kGameId);
    }

    if (!path.has_value()) {
        std::println(stderr,
                     "game directory not found!\n"
                     "please specify it via the command line option like this:\n"
                     "\t* {} --game-path c:\\Some\\Path\\",
                     argv[0]);
        return 1;
    }

    /// This should never happen
    assert(path.has_value() && "no path found?");

    /// But this could happen
    if (!exists(*path)) {
        std::println(stderr, "specified game path {} does not exist", path->string());
        return 1;
    }

    std::println("*** game path resolved to {}", path->string());
    std::println("*** setting up the env");

    /// Uses the same priority as declared
    const auto main_binaries_path = (*path / "game" / "bin" / kPlatformDirName).string();
    const auto second_binaries_path = find_second_bin_directory(*path).string();
    std::array dll_paths = {
        second_binaries_path,
        main_binaries_path,
    };

    /// We are adding our folders to the very start of the env var
    std::string new_path_val;
    for (const auto& [i, dll_path] : std::views::enumerate(dll_paths)) {
        if (i > 0) {
            new_path_val += kEnvVarPathSep;
        }
        new_path_val += dll_path;
    }
    if (const auto old_val = getenv_impl(kEnvVarName); old_val.has_value()) {
        new_path_val += kEnvVarPathSep + *old_val;
    }

    _putenv_s(kEnvVarName, new_path_val.c_str());
    SetDllDirectoryA(main_binaries_path.c_str());

    /// Erase source2gen-loader.exe
    assert(!arguments.empty());
    arguments.erase(arguments.begin());

    std::string invoke_cmd = kExecutableName;
    invoke_cmd += " " + (arguments | std::views::join_with(' ') | std::ranges::to<std::string>());

    std::println("*** loading source2gen: {}", invoke_cmd);
    std::fflush(stdout);

    std::system(invoke_cmd.c_str());
    return 0;
} catch (const std::runtime_error& error) {
    std::println(stderr, "Fatal error: {}", error.what());
    return 1;
}

```

`source2gen/CMakeLists.txt`:

```txt
find_package(absl REQUIRED)
find_package(argparse REQUIRED)

file(GLOB_RECURSE source2gen_SOURCES "src/**.cpp")
list(REMOVE_ITEM source2gen_SOURCES "${CMAKE_CURRENT_SOURCE_DIR}/src/main.cpp")
file(GLOB_RECURSE source2gen_HEADERS "include/**.h" "include/**.hpp")

# We build a library first, because we can link the library against tests.
# main.cpp is compiled separately and also linked against the library.
add_library(lib${PROJECT_NAME} ${source2gen_SOURCES})

target_include_directories(lib${PROJECT_NAME} PUBLIC
  ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_link_libraries(lib${PROJECT_NAME}
  argparse::argparse
  abseil::abseil
)

if(MSVC)
    target_compile_options(lib${PROJECT_NAME} PRIVATE "/bigobj")
    target_link_options(lib${PROJECT_NAME} PRIVATE "/pdbaltpath:%_PDB%")
endif()

if(${CMAKE_BUILD_TYPE} STREQUAL "Debug")
    target_compile_definitions(lib${PROJECT_NAME} PRIVATE "source2gen_DEBUG" "_DEBUG")
endif()

if(${CMAKE_BUILD_TYPE} STREQUAL "Release")
    target_compile_definitions(lib${PROJECT_NAME} PRIVATE "source2gen_RELEASE" "NDEBUG")
endif()

if(${CMAKE_CXX_COMPILER_ID} STREQUAL "Clang" OR
    ${CMAKE_CXX_COMPILER_ID} STREQUAL "AppleClang" OR
    ${CMAKE_CXX_COMPILER_ID} STREQUAL "GNU")
    target_compile_options(lib${PROJECT_NAME} PRIVATE
        -Wall
        -Wextra
        -pedantic-errors
        -Wno-address-of-packed-member
        $<$<NOT:$<CXX_COMPILER_ID:GNU>>:-Wno-implicit-exception-spec-mismatch>
        -Wno-invalid-offsetof
        $<IF:$<CXX_COMPILER_ID:GNU>,-Wno-attributes,-Wno-unknown-attributes>
    )

    target_compile_definitions(lib${PROJECT_NAME} PUBLIC
        "FORCEINLINE="
        "__forceinline="
        "__thiscall="
        "__cdecl="
    )
endif()

target_compile_definitions(lib${PROJECT_NAME} PRIVATE
    "${SOURCE2GEN_GAME}"
    "_CRT_SECURE_NO_WARNINGS"
    "NOMINMAX"
    "WIN32_LEAN_AND_MEAN"
    "_WIN32_WINNT=0x601"
)

add_executable(${PROJECT_NAME} "src/main.cpp")
target_link_libraries(${PROJECT_NAME} lib${PROJECT_NAME})

add_subdirectory("test")

```

`source2gen/include/Include.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include "options.hpp"
#include <string_view>

namespace source2_gen {
    /// Logs errors. Calls @ref std::abort() on fatal errors.
    /// @return true on success
    bool Dump(Options options);
} // namespace source2_gen

constexpr std::string_view kPoweredByMessage = {"Powered by github.com/neverlosecc/source2gen"};
constexpr std::string_view kCreatedBySource2genMessage = {"Created using source2gen - github.com/neverlosecc/source2gen"};

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/options.hpp`:

```hpp
#pragma once

#include <optional>

namespace source2_gen {
    enum class Language {
        cpp,
        c,
        /// C, but can be parsed by IDA.
        /// Derivations from @ref c
        /// - single file
        /// - no `#include` macros
        /// - no `static_assert`
        c_ida,
    };

    struct Options {
        Language emit_language{};
        bool static_members{};
        bool static_assertions{};

        /// @return @ref std::nullopt if "--help" was passed or parsing failed
        [[nodiscard]]
        static std::optional<source2_gen::Options> parse_args(int argc, char* argv[]);
    };
} // namespace source2_gen

```

`source2gen/include/sdk/interfaceregs.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include <cassert>
#include <cstdint>
#include <string_view>

#include <tools/loader/loader.h>

namespace sdk {
    using InstantiateInterfaceFn = void* (*)();

    class InterfaceReg {
    public:
        InstantiateInterfaceFn m_create_fn_;
        const char* m_name_;
        InterfaceReg* m_next_;
    };

    inline const InterfaceReg* GetInterfaces(const char* library) {
        auto* const library_handle = loader::find_module_handle(library);
        assert(library_handle != nullptr &&
               "Tried to call GetInterfaces() on a library that is not loaded. Is the library listed in get_required_modules()?");

        const auto maybe_createinterface_symbol = loader::find_module_symbol<uintptr_t>(library_handle, "CreateInterface");

        return maybe_createinterface_symbol
            .transform([](auto createinterface_symbol) {
                const auto interface_list = [=] {
                    if constexpr (current_platform == platform::windows) {
                        return createinterface_symbol + *reinterpret_cast<int32_t*>(createinterface_symbol + 3) + 7;
                    } else if constexpr (current_platform == platform::linux) {
                        const auto createinterface_impl = createinterface_symbol + *reinterpret_cast<int32_t*>(createinterface_symbol + 1) + 5;
                        const auto createinterface_mov = createinterface_impl + 0x10;

                        return createinterface_mov + *reinterpret_cast<int32_t*>(createinterface_mov + 3) + 7;
                    }
                }();

                return *reinterpret_cast<InterfaceReg**>(interface_list);
            })
            .value_or(nullptr);
    }

    template <typename T = void*>
    T* GetInterface(const char* library, const char* partial_version) {
        for (const InterfaceReg* current = GetInterfaces(library); current != nullptr; current = current->m_next_) {
            if (std::string_view(current->m_name_).find(partial_version) != std::string_view::npos)
                return reinterpret_cast<T*>(current->m_create_fn_());
        }

        return nullptr;
    }
} // namespace sdk

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/client/game/datamap_t.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include <sdk/interfaces/common/CUtlVector.h>

class ISaveRestoreOps;
class typedescription_t;
class IPredictionCopyOps;

enum {
    FTYPEDESC_NONE = 0
};

enum DatamapFlags : int {
    // This field is masked for global entity save/restore
    FTYPEDESC_GLOBAL = (1 << 0),
    // This field is saved to disk
    FTYPEDESC_SAVE = (1 << 1),
    // This field can be requested and written to by string name at load time
    FTYPEDESC_KEY = (1 << 2),
    // This field can be written to by string name at run time, and a function called
    FTYPEDESC_INPUT = (1 << 3),
    // This field propogates it's value to all targets whenever it changes
    FTYPEDESC_OUTPUT = (1 << 4),
    // This is a table entry for a member function pointer
    FTYPEDESC_FUNCTIONTABLE = (1 << 5),
    // This field is a pointer, not an embedded object
    FTYPEDESC_PTR = (1 << 6),
    // The field is an override for one in a base class (only used by prediction system for now)
    FTYPEDESC_OVERRIDE = (1 << 7),
    // Flags used by other systems (e.g., prediction system)
    FTYPEDESC_INSENDTABLE = (1 << 8),
    // This field is present in a network SendTable
    // The field is local to the client or server only (not referenced by prediction code and not replicated by
    // networking
    FTYPEDESC_PRIVATE = (1 << 9),
    // The field is part of the prediction typedescription, but doesn't get compared when checking for errors
    FTYPEDESC_NOERRORCHECK = (1 << 10),
    // The field is a model index (used for debugging output)
    FTYPEDESC_MODELINDEX = (1 << 11),
    // The field is an index into file data, used for byteswapping.
    FTYPEDESC_INDEX = (1 << 12),
    FTYPEDESC_OVERRIDE_RECURSIVE = (1 << 13),
    FTYPEDESC_SCHEMA_INITIALIZED = (1 << 14),
    FTYPEDESC_GEN_ARRAY_KEYNAMES_0 = (1 << 15),
    FTYPEDESC_GEN_ARRAY_KEYNAMES_1 = (1 << 16),
    FTYPEDESC_ADDITIONAL_FIELDS = (1 << 17),
    FTYPEDESC_EXPLICIT_BASE = (1 << 18),
    FTYPEDESC_PROCEDURAL_KEYFIELD = (1 << 19),
    // Used if the typedesc is enum, no datamap_t info would be available
    FTYPEDESC_ENUM = (1 << 20),
    FTYPEDESC_REMOVED_KEYFIELD = (1 << 21),
    FTYPEDESC_WAS_INPUT = (1 << 22),
    FTYPEDESC_WAS_OUTPUT = (1 << 23)
};

enum {
    TD_OFFSET_NORMAL = 0,
    TD_OFFSET_PACKED = 1,

    // Must be last
    TD_OFFSET_COUNT,
};

enum PredictionCopyType_t {
    PC_NON_NETWORKED_ONLY = 0,
    PC_NETWORKED_ONLY,

    PC_COPYTYPE_COUNT,
    PC_EVERYTHING = PC_COPYTYPE_COUNT,
};

// Registered binary: schemasystem.dll (project 'schemasystem')
// Alignment: 1
// Size: 0x51
enum class fieldtype_t : uint8_t {
    FIELD_VOID = 0x0,
    FIELD_FLOAT32 = 0x1,
    FIELD_STRING = 0x2,
    FIELD_VECTOR = 0x3,
    FIELD_QUATERNION = 0x4,
    FIELD_INT32 = 0x5,
    FIELD_BOOLEAN = 0x6,
    FIELD_INT16 = 0x7,
    FIELD_CHARACTER = 0x8,
    FIELD_COLOR32 = 0x9,
    FIELD_EMBEDDED = 0xa,
    FIELD_CUSTOM = 0xb,
    FIELD_CLASSPTR = 0xc,
    FIELD_EHANDLE = 0xd,
    FIELD_POSITION_VECTOR = 0xe,
    FIELD_TIME = 0xf,
    FIELD_TICK = 0x10,
    FIELD_SOUNDNAME = 0x11,
    FIELD_INPUT = 0x12,
    FIELD_FUNCTION = 0x13,
    FIELD_VMATRIX = 0x14,
    FIELD_VMATRIX_WORLDSPACE = 0x15,
    FIELD_MATRIX3X4_WORLDSPACE = 0x16,
    FIELD_INTERVAL = 0x17,
    FIELD_UNUSED = 0x18,
    FIELD_VECTOR2D = 0x19,
    FIELD_INT64 = 0x1a,
    FIELD_VECTOR4D = 0x1b,
    FIELD_RESOURCE = 0x1c,
    FIELD_TYPEUNKNOWN = 0x1d,
    FIELD_CSTRING = 0x1e,
    FIELD_HSCRIPT = 0x1f,
    FIELD_VARIANT = 0x20,
    FIELD_UINT64 = 0x21,
    FIELD_FLOAT64 = 0x22,
    FIELD_POSITIVEINTEGER_OR_NULL = 0x23,
    FIELD_HSCRIPT_NEW_INSTANCE = 0x24,
    FIELD_UINT32 = 0x25,
    FIELD_UTLSTRINGTOKEN = 0x26,
    FIELD_QANGLE = 0x27,
    FIELD_NETWORK_ORIGIN_CELL_QUANTIZED_VECTOR = 0x28,
    FIELD_HMATERIAL = 0x29,
    FIELD_HMODEL = 0x2a,
    FIELD_NETWORK_QUANTIZED_VECTOR = 0x2b,
    FIELD_NETWORK_QUANTIZED_FLOAT = 0x2c,
    FIELD_DIRECTION_VECTOR_WORLDSPACE = 0x2d,
    FIELD_QANGLE_WORLDSPACE = 0x2e,
    FIELD_QUATERNION_WORLDSPACE = 0x2f,
    FIELD_HSCRIPT_LIGHTBINDING = 0x30,
    FIELD_V8_VALUE = 0x31,
    FIELD_V8_OBJECT = 0x32,
    FIELD_V8_ARRAY = 0x33,
    FIELD_V8_CALLBACK_INFO = 0x34,
    FIELD_UTLSTRING = 0x35,
    FIELD_NETWORK_ORIGIN_CELL_QUANTIZED_POSITION_VECTOR = 0x36,
    FIELD_HRENDERTEXTURE = 0x37,
    FIELD_HPARTICLESYSTEMDEFINITION = 0x38,
    FIELD_UINT8 = 0x39,
    FIELD_UINT16 = 0x3a,
    FIELD_CTRANSFORM = 0x3b,
    FIELD_CTRANSFORM_WORLDSPACE = 0x3c,
    FIELD_HPOSTPROCESSING = 0x3d,
    FIELD_MATRIX3X4 = 0x3e,
    FIELD_SHIM = 0x3f,
    FIELD_CMOTIONTRANSFORM = 0x40,
    FIELD_CMOTIONTRANSFORM_WORLDSPACE = 0x41,
    FIELD_ATTACHMENT_HANDLE = 0x42,
    FIELD_AMMO_INDEX = 0x43,
    FIELD_CONDITION_ID = 0x44,
    FIELD_AI_SCHEDULE_BITS = 0x45,
    FIELD_MODIFIER_HANDLE = 0x46,
    FIELD_ROTATION_VECTOR = 0x47,
    FIELD_ROTATION_VECTOR_WORLDSPACE = 0x48,
    FIELD_HVDATA = 0x49,
    FIELD_SCALE32 = 0x4a,
    FIELD_STRING_AND_TOKEN = 0x4b,
    FIELD_ENGINE_TIME = 0x4c,
    FIELD_ENGINE_TICK = 0x4d,
    FIELD_WORLD_GROUP_ID = 0x4e,
    FIELD_GLOBALSYMBOL = 0x4f,
    FIELD_TYPECOUNT = 0x50,
};

// Each datamap_t is broken down into two flattened arrays of fields,
//  one for PC_NETWORKED_DATA and one for PC_NON_NETWORKED_ONLY (optimized_datamap_t::datamapinfo_t::flattenedoffsets_t)
// Each flattened array is sorted by offset for better cache performance
// Finally, contiguous "runs" off offsets are precomputed (optimized_datamap_t::datamapinfo_t::datacopyruns_t) for fast
// copy operations

// A data run is a set of DEFINE_PRED_FIELD fields in a c++ object which are contiguous and can be processing
//  using a single memcpy operation
struct datarun_t {
    datarun_t(): m_nStartFlatField(0), m_nEndFlatField(0), m_nLength(0) {
        for (int & i : m_nStartOffset) {
            i = 0;
#ifdef _X360
            // These are the offsets of the next run, for priming the L1 cache
            m_nPrefetchOffset[i] = 0;
#endif
        }
    }

    // Indices of start/end fields in the flattened typedescription_t list
    int m_nStartFlatField;
    int m_nEndFlatField;

    // Offsets for run in the packed/unpacked data (I think the run starts need to be properly aligned)
    int m_nStartOffset[TD_OFFSET_COUNT]{};
#ifdef _X360
    // These are the offsets of the next run, for priming the L1 cache
    int m_nPrefetchOffset[TD_OFFSET_COUNT];
#endif
    int m_nLength;
};

struct datacopyruns_t {
public:
    CUtlVector<datarun_t> m_vecRuns;
};

struct flattenedoffsets_t {
    CUtlVector<typedescription_t> m_Flattened;
    int m_nPackedSize{}; // Contiguous memory to pack all of these together for TD_OFFSET_PACKED
    int m_nPackedStartOffset{};
};

struct datamapinfo_t {
    // Flattened list, with FIELD_EMBEDDED, FTYPEDESC_PRIVATE,
    //  and FTYPEDESC_OVERRIDE (overridden) fields removed
    flattenedoffsets_t m_Flat;
    datacopyruns_t m_CopyRuns;
};

struct optimized_datamap_t {
    // Optimized info for PC_NON_NETWORKED and PC_NETWORKED data
    datamapinfo_t m_Info[PC_COPYTYPE_COUNT];
};

class datamap_t {
public:
    typedescription_t* m_pTypeDescription;
    std::uint64_t m_iTypeDescriptionCount;
    const char* m_pszClassName; // Ex: C_DOTAPlayer
    datamap_t* m_pBaseDatamap; // Ex: For C_DOTAPlayer it would be next baseclass C_BasePlayer, can be NULL
    int m_nPackedSize;
    optimized_datamap_t* m_pOptimizedDataMap;
};

class typedescription_t {
public:
    [[nodiscard]] std::string GetFieldName() const {
        if (m_pszFieldName)
            return {m_pszFieldName};

        return {};
    }

    [[nodiscard]] std::string GetExternalFieldName() const {
        if (m_pszExternalName)
            return {m_pszExternalName};

        return {};
    }

public:
    fieldtype_t m_iFieldType;
    const char* m_pszFieldName;
    int m_iOffset; // Local offset value
    std::uint16_t m_nFieldSize;
    DatamapFlags m_nFlags;
    // the name of the variable in the map/fgd data, or the name of the action
    const char* m_pszExternalName;
    // pointer to the function set for save/restoring of custom data types
    ISaveRestoreOps* m_pSaveRestoreOps;
    // for associating function with string names
    void* m_pInputFn;

    IF_LINUX(char _pad_0x38[0x08];)

    // For embedding additional datatables inside this one
    union {
        datamap_t* m_pDataMap;
        const char* m_pszEnumName;
    };

    // Stores the actual member variable size in bytes
    int m_iFieldSizeInBytes;

    // Tolerance for field errors for float fields
    float m_flFieldTolerance;

    // For raw fields (including children of embedded stuff) this is the flattened offset
    int m_flFlatOffset[TD_OFFSET_COUNT];
    std::uint16_t m_uFlatGroup;

    IPredictionCopyOps* pPredictionCopyOps;
    datamap_t* m_pPredictionCopyDataMap;

    ~typedescription_t();
};

static_assert(offsetof(typedescription_t, m_pszFieldName) == 0x08);
static_assert(offsetof(typedescription_t, m_pDataMap)== platform_specific{.windows = 0x38, .linux = 0x40});
static_assert(sizeof(typedescription_t)== platform_specific{.windows = 0x68, .linux = 0x70});

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CBufferString.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include "sdk/interfaces/tier0/IMemAlloc.h"
#include <cstddef>
#include <cstring>

template <std::size_t MAX_SIZE, bool AllowHeapAllocation>
class CBufferStringGrowable;

/*
        Main idea of CBufferString is to provide the base class for the CBufferStringGrowable wich implements stack allocation
        with the ability to convert to the heap allocation if allowed.

        Example usage of CBufferStringGrowable class:

        * Basic buffer allocation:
        ```
                CBufferStringGrowable<256> buff;
                buff.Insert(0, "Hello World!");
                printf("Result: %s\n", buff.Get());
        ```
        additionaly the heap allocation of the buffer could be disabled, by providing ``AllowHeapAllocation`` template argument,
        by disabling heap allocation, if the buffer capacity is not enough to perform the operation, the app would exit with an Assert;

        * Additional usage:
        CBufferString::IsStackAllocated() - could be used to check if the buffer is stack allocated;
        CBufferString::IsHeapAllocated() - could be used to check if the buffer is heap allocated;
        CBufferString::Get() - would return a pointer to the data, or an empty string if it's not allocated.

        * Additionaly current length of the buffer could be read via CBufferString::GetTotalNumber()
        and currently allocated amount of bytes could be read via CBufferString::GetAllocatedNumber()

        * Most, if not all the functions would ensure the buffer capacity and enlarge it when needed,
        in case of stack allocated buffers, it would switch to heap allocation instead.
*/

class CBufferString {
protected:
    // You shouldn't be initializing this class, use CBufferStringGrowable instead.
    CBufferString() = default;

public:
    enum EAllocationOption_t {
        UNK1 = -1,
        UNK2 = 0,
        UNK3 = (1 << 1),
        UNK4 = (1 << 8),
        UNK5 = (1 << 9),
        ALLOW_HEAP_ALLOCATION = (1 << 31)
    };

    enum EAllocationFlags_t {
        LENGTH_MASK = (1 << 30) - 1,
        FLAGS_MASK = ~LENGTH_MASK,

        STACK_ALLOCATION_MARKER = (1 << 30),
        HEAP_ALLOCATION_MARKER = (1 << 31)
    };

    // Casts to CBufferStringGrowable. Very dirty solution until someone figures out the sane one.
    template <std::size_t MAX_SIZE = 8, bool AllowHeapAllocation = true, typename T = CBufferStringGrowable<MAX_SIZE, AllowHeapAllocation>>
    T* ToGrowable() {
        return (T*)this;
    }

    void MoveFrom(CBufferString& src);
};

template <std::size_t MAX_SIZE, bool AllowHeapAllocation = true>
class CBufferStringGrowable : public CBufferString {
    friend class CBufferString;

public:
    CBufferStringGrowable(): m_nTotalCount(0), m_nAllocated(STACK_ALLOCATION_MARKER | (MAX_SIZE & LENGTH_MASK)) {
        memset(m_Memory.m_szString, 0, sizeof(m_Memory.m_szString));
        if (AllowHeapAllocation) {
            m_nAllocated |= ALLOW_HEAP_ALLOCATION;
        }
    }

    CBufferStringGrowable(const CBufferStringGrowable& other): m_nTotalCount(0), m_nAllocated(STACK_ALLOCATION_MARKER | (MAX_SIZE & LENGTH_MASK)) {
        memset(m_Memory.m_szString, 0, sizeof(m_Memory.m_szString));
        if (AllowHeapAllocation) {
            m_nAllocated |= ALLOW_HEAP_ALLOCATION;
        }
        MoveFrom(const_cast<CBufferStringGrowable&>(other));
    }

    ~CBufferStringGrowable() {
        if (IsHeapAllocated() && m_Memory.m_pString) {
            GetMemAlloc()->Free((void*)m_Memory.m_pString);
        }
    }

    inline CBufferStringGrowable& operator=(const CBufferStringGrowable& src) {
        MoveFrom(const_cast<CBufferStringGrowable&>(src));
        return *this;
    }

    [[nodiscard]] inline int GetAllocatedNumber() const {
        return m_nAllocated & LENGTH_MASK;
    }

    [[nodiscard]] inline int GetTotalNumber() const {
        return m_nTotalCount & LENGTH_MASK;
    }

    [[nodiscard]] inline bool IsStackAllocated() const {
        return (m_nAllocated & STACK_ALLOCATION_MARKER) != 0;
    }

    [[nodiscard]] inline bool IsHeapAllocated() const {
        return (m_nTotalCount & HEAP_ALLOCATION_MARKER) != 0;
    }

    inline bool IsInputStringUnsafe(const char* pData) const {
        return ((void*)pData >= this && (void*)pData < &this[1]) ||
               (GetAllocatedNumber() != 0 && pData >= Get() && pData < (Get() + GetAllocatedNumber()));
    }

    [[nodiscard]] inline const char* Get() const {
        if (IsStackAllocated()) {
            return m_Memory.m_szString;
        } else if (GetAllocatedNumber() != 0) {
            return m_Memory.m_pString;
        }

        return "";
    }

    inline void Clear() {
        if (GetAllocatedNumber() != 0) {
            if (IsStackAllocated())
                m_Memory.m_szString[0] = '\0';
            else
                m_Memory.m_pString[0] = '\0';
        }
        m_nTotalCount &= ~LENGTH_MASK;
    }

private:
    int m_nTotalCount;
    int m_nAllocated;

    union {
        char* m_pString;
        char m_szString[MAX_SIZE];
    } m_Memory;
};

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CInterlockedInt.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

//-----------------------------------------------------------------------------
//
// A super-fast thread-safe integer A simple class encapsulating the notion of an
// atomic integer used across threads that uses the built in and faster
// "interlocked" functionality rather than a full-blown mutex. Useful for simple
// things like reference counts, etc.
//
//-----------------------------------------------------------------------------

template <typename T>
class CInterlockedIntT {
public:
    CInterlockedIntT(): m_value(0) {
        static_assert(sizeof(T) == sizeof(std::int32_t));
    }
    explicit CInterlockedIntT(T value): m_value(value) { }

    T operator()() const {
        return m_value;
    }
    /* implicit */ operator T() const {
        return m_value;
    }

    bool operator!() const {
        return (m_value == 0);
    }
    bool operator==(T rhs) const {
        return (m_value == rhs);
    }
    bool operator!=(T rhs) const {
        return (m_value != rhs);
    }

    T Get() {
        return m_value;
    }

private:
    volatile T m_value;
};

using CInterlockedInt = CInterlockedIntT<int>;
using CInterlockedUInt = CInterlockedIntT<unsigned>;

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CTSList.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include <cstdint>
#include <emmintrin.h>

// decls for aligning data
#if TARGET_OS == WINDOWS
    #define DECL_ALIGN(x) __declspec(align(x))
#else
    #define DECL_ALIGN(x)
#endif

#ifdef _WIN64
constexpr auto TSLIST_HEAD_ALIGNMENT = 16;
constexpr auto TSLIST_NODE_ALIGNMENT = 16;
#else
constexpr auto TSLIST_HEAD_ALIGNMENT = 8;
constexpr auto TSLIST_NODE_ALIGNMENT = 8;
#endif

#ifdef _MSC_VER
    #define TSLIST_HEAD_ALIGN DECL_ALIGN(TSLIST_HEAD_ALIGNMENT)
    #define TSLIST_NODE_ALIGN DECL_ALIGN(TSLIST_NODE_ALIGNMENT)
    #define TSLIST_HEAD_ALIGN_POST
    #define TSLIST_NODE_ALIGN_POST
#elif defined(__GNUC__)
    #define TSLIST_HEAD_ALIGN
    #define TSLIST_NODE_ALIGN
    #define TSLIST_HEAD_ALIGN_POST DECL_ALIGN(TSLIST_HEAD_ALIGNMENT)
    #define TSLIST_NODE_ALIGN_POST DECL_ALIGN(TSLIST_NODE_ALIGNMENT)
#else
    #error
#endif

struct TSLIST_NODE_ALIGN TSLNodeBase_t {
    TSLNodeBase_t* Next; // name to match Windows
} TSLIST_NODE_ALIGN_POST;

typedef __m128i int128;

union TSLIST_HEAD_ALIGN TSLHead_t {
    struct Value_t {
        TSLNodeBase_t* Next;
        std::int16_t Depth;
        std::int16_t Sequence;
        std::int32_t Padding;
    } value;

    struct Value32_t {
        TSLNodeBase_t* Next_do_not_use_me;
        std::int32_t DepthAndSequence;
    } value32;

    int128 value64x128;
} TSLIST_HEAD_ALIGN_POST;

class TSLIST_HEAD_ALIGN CTSListBase {
public:
    [[nodiscard]] int Count() const {
        return m_Head.value.Depth;
    }

public:
    TSLHead_t m_Head;
} TSLIST_HEAD_ALIGN_POST;

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CThreadMutex.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include "tools/platform.h"
#include <cstddef>
#include <cstdint>

#ifdef _WIN32
typedef std::uint32_t ThreadId_t;
#else
typedef std::uint64_t ThreadId_t;
#endif

constexpr auto kTtSizeofCriticalsection = 40;

class CThreadMutex {
public:
    std::byte m_CriticalSection[kTtSizeofCriticalsection];

    // Debugging (always herge to allow mixed debug/release builds w/o changing size)
    ThreadId_t m_currentOwnerID;
    std::uint16_t m_lockCount;
    bool m_bTrace;
    const char* m_pDebugName;
};
static_assert(sizeof(CThreadMutex) == platform_specific{.windows = 0x38, .linux = 0x40});

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CThreadSpinMutex.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include "CThreadMutex.h"
#include <type_traits>

#if defined(CS2) || defined(DOTA2) || defined(DEADLOCK)
constexpr auto kThreadSpinMutex = 2;
#else
constexpr auto kThreadSpinMutex = 1;
#endif

class CThreadSpinMutexV1 {
public:
    CThreadSpinMutexV1(const char* pDebugName = NULL): m_ownerID(0), m_depth(0), m_pszDebugName(pDebugName) { }

private:
    volatile ThreadId_t m_ownerID;
    int m_depth;
    const char* m_pszDebugName;
};
static_assert(sizeof(CThreadSpinMutexV1) == platform_specific{.windows = 0x10, .linux = 0x18});

class CThreadSpinMutexV2 {
public:
    CThreadSpinMutexV2([[maybe_unused]] const char* pDebugName = NULL): m_ownerID(0), m_depth(0) { }

private:
    volatile ThreadId_t m_ownerID;
    int m_depth;
};
static_assert(sizeof(CThreadSpinMutexV2) == platform_specific{.windows = 0x8, .linux = 0x10});

using CThreadSpinMutex = std::conditional_t<kThreadSpinMutex == 1, CThreadSpinMutexV1, CThreadSpinMutexV2>;
using CThreadFastMutex = CThreadSpinMutex;

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CThreadSpinRWLock.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include "sdk/interfaces/common/CThreadMutex.h"
#include <type_traits>

class CThreadSpinRWLock {
public:
    struct LockInfo_t {
        std::uint32_t m_writerId;
        std::int32_t m_nReaders;
    };

public:
    void* m_pThreadSpin;
    LockInfo_t m_lockInfo;
    const char* m_pszDebugName;
};

static_assert(sizeof(CThreadSpinRWLock) == 0x18);
// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CUtlMap.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include "CUtlRBTree.h"

struct base_utlmap_t {
public:
    // This enum exists so that FOR_EACH_MAP and FOR_EACH_MAP_FAST cannot accidentally
    // be used on a type that is not a CUtlMap. If the code compiles then all is well.
    // The check for IsUtlMap being true should be free.
    // Using an enum rather than a static const bool ensures that this trick works even
    // with optimizations disabled on gcc.
    enum {
        IsUtlMap = true
    };
};

//-----------------------------------------------------------------------------
// An associative container. Pretty much identical to std::map.
//-----------------------------------------------------------------------------
template <typename K, typename T, typename I = unsigned short>
class CUtlMap {
public:
    typedef K KeyType_t;
    typedef T ElemType_t;
    typedef I IndexType_t;

    // Less func typedef
    // Returns true if the first parameter is "less" than the second
    typedef bool (*LessFunc_t)(const KeyType_t&, const KeyType_t&);

    // constructor, destructor
    // Left at growSize = 0, the memory will first allocate 1 element and double in size
    // at each increment.
    // LessFunc_t is required, but may be set after the constructor using SetLessFunc() below
    explicit CUtlMap(int growSize = 0, int initSize = 0, LessFunc_t lessfunc = 0): m_Tree(growSize, initSize, CKeyLess(lessfunc)) { }

    explicit CUtlMap(LessFunc_t lessfunc): m_Tree(CKeyLess(lessfunc)) { }

    void EnsureCapacity(int num) {
        m_Tree.EnsureCapacity(num);
    }

    // gets particular elements
    ElemType_t& Element(IndexType_t i) {
        return m_Tree.Element(i).elem;
    }
    const ElemType_t& Element(IndexType_t i) const {
        return m_Tree.Element(i).elem;
    }
    ElemType_t& operator[](IndexType_t i) {
        return m_Tree.Element(i).elem;
    }
    const ElemType_t& operator[](IndexType_t i) const {
        return m_Tree.Element(i).elem;
    }
    KeyType_t& Key(IndexType_t i) {
        return m_Tree.Element(i).key;
    }
    const KeyType_t& Key(IndexType_t i) const {
        return m_Tree.Element(i).key;
    }

    // Num elements
    [[nodiscard]] unsigned int Count() const {
        return m_Tree.Count();
    }

    // Max "size" of the vector
    [[nodiscard]] IndexType_t MaxElement() const {
        return m_Tree.MaxElement();
    }

    // Checks if a node is valid and in the map
    [[nodiscard]] bool IsValidIndex(IndexType_t i) const {
        return m_Tree.IsValidIndex(i);
    }

    // Checks if the map as a whole is valid
    [[nodiscard]] bool IsValid() const {
        return m_Tree.IsValid();
    }

    // Invalid index
    static IndexType_t InvalidIndex() {
        return CTree::InvalidIndex();
    }

    // Insert method (inserts in order)
    IndexType_t Insert(const KeyType_t& key, const ElemType_t& insert) {
        Node_t node;
        node.key = key;
        node.elem = insert;
        return m_Tree.Insert(node);
    }

    IndexType_t Insert(const KeyType_t& key) {
        Node_t node;
        node.key = key;
        return m_Tree.Insert(node);
    }

    // Find method
    IndexType_t Find(const KeyType_t& key) const {
        Node_t dummyNode;
        dummyNode.key = key;
        return m_Tree.Find(dummyNode);
    }

    // Iteration
    IndexType_t FirstInorder() const {
        return m_Tree.FirstInorder();
    }
    IndexType_t NextInorder(IndexType_t i) const {
        return m_Tree.NextInorder(i);
    }
    IndexType_t PrevInorder(IndexType_t i) const {
        return m_Tree.PrevInorder(i);
    }
    IndexType_t LastInorder() const {
        return m_Tree.LastInorder();
    }

    struct Node_t {
        Node_t() = default;

        Node_t(const Node_t& from): key(from.key), elem(from.elem) { }

        KeyType_t key;
        ElemType_t elem;
    };

    class CKeyLess {
    public:
        explicit CKeyLess(LessFunc_t lessFunc): m_LessFunc(lessFunc) { }

        bool operator!() const {
            return !m_LessFunc;
        }

        bool operator()(const Node_t& left, const Node_t& right) const {
            return m_LessFunc(left.key, right.key);
        }

        LessFunc_t m_LessFunc;
    };

    typedef CUtlRBTree<Node_t, I, CKeyLess> CTree;

    CTree* AccessTree() {
        return &m_Tree;
    }

protected:
    CTree m_Tree;
};

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CUtlMemory.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include "tools/virtual.h"
#include <sdk/interfaces/tier0/IMemAlloc.h>

template <class T>
inline T* Construct(T* pMemory) {
    return ::new (pMemory) T;
}

template <class T, typename ARG1>
inline T* Construct(T* pMemory, ARG1 a1) {
    return ::new (pMemory) T(a1);
}

template <class T, typename ARG1, typename ARG2>
inline T* Construct(T* pMemory, ARG1 a1, ARG2 a2) {
    return ::new (pMemory) T(a1, a2);
}

template <class T, typename ARG1, typename ARG2, typename ARG3>
inline T* Construct(T* pMemory, ARG1 a1, ARG2 a2, ARG3 a3) {
    return ::new (pMemory) T(a1, a2, a3);
}

template <class T, typename ARG1, typename ARG2, typename ARG3, typename ARG4>
inline T* Construct(T* pMemory, ARG1 a1, ARG2 a2, ARG3 a3, ARG4 a4) {
    return ::new (pMemory) T(a1, a2, a3, a4);
}

template <class T, typename ARG1, typename ARG2, typename ARG3, typename ARG4, typename ARG5>
inline T* Construct(T* pMemory, ARG1 a1, ARG2 a2, ARG3 a3, ARG4 a4, ARG5 a5) {
    return ::new (pMemory) T(a1, a2, a3, a4, a5);
}

template <class T>
inline T* CopyConstruct(T* pMemory, const T& src) {
    return ::new (pMemory) T(src);
}

template <class T>
inline void Destruct(T* pMemory) {
    pMemory->~T();

#ifdef _DEBUG
    memset(pMemory, 0xDD, sizeof(T));
#endif
}

template <class T, class I = int>
class CUtlMemory {
public:
    // constructor, destructor
    explicit CUtlMemory(int nGrowSize = 0, int nInitAllocationCount = 0);
    CUtlMemory(T* pMemory, int numElements);
    CUtlMemory(const T* pMemory, int numElements);
    ~CUtlMemory();

    // Set the size by which the memory grows
    void Init(int nGrowSize = 0, int nInitSize = 0);

    class Iterator_t {
    public:
        explicit Iterator_t(I i): index(i) { }

        I index;

        bool operator==(const Iterator_t& it) const {
            return index == it.index;
        }
        bool operator!=(const Iterator_t& it) const {
            return index != it.index;
        }
    };

    Iterator_t First() const {
        return Iterator_t(IsIdxValid(0) ? 0 : InvalidIndex());
    }

    Iterator_t Next(const Iterator_t& it) const {
        return Iterator_t(IsIdxValid(it.index + 1) ? it.index + 1 : InvalidIndex());
    }

    I GetIndex(const Iterator_t& it) const {
        return it.index;
    }
    bool IsIdxAfter(I i, const Iterator_t& it) const {
        return i > it.index;
    }
    bool IsValidIterator(const Iterator_t& it) const {
        return IsIdxValid(it.index);
    }
    Iterator_t InvalidIterator() const {
        return Iterator_t(InvalidIndex());
    }

    // element access
    T& operator[](I i);
    const T& operator[](I i) const;
    T& Element(I i);
    const T& Element(I i) const;

    bool IsIdxValid(I i) const;

    static const I INVALID_INDEX = (I)-1; // For use with COMPILE_TIME_ASSERT
    static I InvalidIndex() {
        return INVALID_INDEX;
    }

    T* Base();
    const T* Base() const;

    void SetExternalBuffer(T* pMemory, int numElements);
    void SetExternalBuffer(const T* pMemory, int numElements);
    void AssumeMemory(T* pMemory, int numElements);
    T* Detach();
    void* DetachMemory();

    void Swap(CUtlMemory<T, I>& mem);
    void ConvertToGrowableMemory(int nGrowSize);
    [[nodiscard]] int NumAllocated() const;
    [[nodiscard]] int Count() const;
    void Grow(int num = 1);
    void EnsureCapacity(int num);
    void Purge();
    void Purge(int numElements);
    [[nodiscard]] bool IsExternallyAllocated() const;
    [[nodiscard]] bool IsReadOnly() const;
    void SetGrowSize(int size);

protected:
    void ValidateGrowSize() const { }

    enum {
        EXTERNAL_BUFFER_MARKER = -1,
        EXTERNAL_CONST_BUFFER_MARKER = -2,
    };

public:
    T* m_pMemory;
    int m_nAllocationCount;
    int m_nGrowSize;
};

static_assert(sizeof(CUtlMemory<int, int>) == 0x10);

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------

template <class T, class I>
CUtlMemory<T, I>::CUtlMemory(int nGrowSize, int nInitAllocationCount): m_pMemory(0), m_nAllocationCount(nInitAllocationCount), m_nGrowSize(nGrowSize) {
    ValidateGrowSize();
    assert(nGrowSize >= 0);
    if (m_nAllocationCount) {
        m_pMemory = (T*)GetMemAlloc()->Alloc(m_nAllocationCount * sizeof(T));
    }
}

template <class T, class I>
CUtlMemory<T, I>::CUtlMemory(T* pMemory, int numElements): m_pMemory(pMemory), m_nAllocationCount(numElements) {
    // Special marker indicating externally supplied modifyable memory
    m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template <class T, class I>
CUtlMemory<T, I>::CUtlMemory(const T* pMemory, int numElements): m_pMemory((T*)pMemory), m_nAllocationCount(numElements) {
    // Special marker indicating externally supplied modifyable memory
    m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template <class T, class I>
CUtlMemory<T, I>::~CUtlMemory() {
    Purge();
}

template <class T, class I>
void CUtlMemory<T, I>::Init(int nGrowSize /*= 0*/, int nInitSize /*= 0*/) {
    Purge();

    m_nGrowSize = nGrowSize;
    m_nAllocationCount = nInitSize;
    ValidateGrowSize();
    assert(nGrowSize >= 0);
    if (m_nAllocationCount) {
        m_pMemory = (T*)GetMemAlloc()->Alloc(m_nAllocationCount * sizeof(T));
    }
}

//-----------------------------------------------------------------------------
// Fast swap
//-----------------------------------------------------------------------------
template <class T>
FORCEINLINE void V_swap(T& x, T& y) {
    T temp = x;
    x = y;
    y = temp;
}

template <class T, class I>
void CUtlMemory<T, I>::Swap(CUtlMemory<T, I>& mem) {
    V_swap(m_nGrowSize, mem.m_nGrowSize);
    V_swap(m_pMemory, mem.m_pMemory);
    V_swap(m_nAllocationCount, mem.m_nAllocationCount);
}

//-----------------------------------------------------------------------------
// Switches the buffer from an external memory buffer to a reallocatable buffer
//-----------------------------------------------------------------------------
template <class T, class I>
void CUtlMemory<T, I>::ConvertToGrowableMemory(int nGrowSize) {
    if (!IsExternallyAllocated())
        return;

    m_nGrowSize = nGrowSize;
    if (m_nAllocationCount) {
        int nNumBytes = m_nAllocationCount * sizeof(T);
        T* pMemory = (T*)GetMemAlloc()->Alloc(nNumBytes);
        memcpy(pMemory, m_pMemory, nNumBytes);
        m_pMemory = pMemory;
    } else {
        m_pMemory = NULL;
    }
}

//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template <class T, class I>
void CUtlMemory<T, I>::SetExternalBuffer(T* pMemory, int numElements) {
    // Blow away any existing allocated memory
    Purge();

    m_pMemory = pMemory;
    m_nAllocationCount = numElements;

    // Indicate that we don't own the memory
    m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template <class T, class I>
void CUtlMemory<T, I>::SetExternalBuffer(const T* pMemory, int numElements) {
    // Blow away any existing allocated memory
    Purge();

    m_pMemory = const_cast<T*>(pMemory);
    m_nAllocationCount = numElements;

    // Indicate that we don't own the memory
    m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template <class T, class I>
void CUtlMemory<T, I>::AssumeMemory(T* pMemory, int numElements) {
    // Blow away any existing allocated memory
    Purge();

    // Take the pointer but don't mark us as external
    m_pMemory = pMemory;
    m_nAllocationCount = numElements;
}

template <class T, class I>
void* CUtlMemory<T, I>::DetachMemory() {
    if (IsExternallyAllocated()) {
        return nullptr;
    }

    void* pMemory = m_pMemory;
    m_pMemory = 0;
    m_nAllocationCount = 0;
    return pMemory;
}

template <class T, class I>
inline T* CUtlMemory<T, I>::Detach() {
    return (T*)DetachMemory();
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template <class T, class I>
inline T& CUtlMemory<T, I>::operator[](I i) {
    assert(!IsReadOnly());
    assert(IsIdxValid(i));
    return m_pMemory[i];
}

template <class T, class I>
inline const T& CUtlMemory<T, I>::operator[](I i) const {
    assert(IsIdxValid(i));
    return m_pMemory[i];
}

template <class T, class I>
inline T& CUtlMemory<T, I>::Element(I i) {
    assert(!IsReadOnly());
    assert(IsIdxValid(i));
    return m_pMemory[i];
}

template <class T, class I>
inline const T& CUtlMemory<T, I>::Element(I i) const {
    assert(IsIdxValid(i));
    return m_pMemory[i];
}

//-----------------------------------------------------------------------------
// is the memory externally allocated?
//-----------------------------------------------------------------------------
template <class T, class I>
bool CUtlMemory<T, I>::IsExternallyAllocated() const {
    return (m_nGrowSize < 0);
}

//-----------------------------------------------------------------------------
// is the memory read only?
//-----------------------------------------------------------------------------
template <class T, class I>
bool CUtlMemory<T, I>::IsReadOnly() const {
    return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);
}

template <class T, class I>
void CUtlMemory<T, I>::SetGrowSize(int nSize) {
    assert(!IsExternallyAllocated());
    assert(nSize >= 0);
    m_nGrowSize = nSize;
    ValidateGrowSize();
}

//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------
template <class T, class I>
inline T* CUtlMemory<T, I>::Base() {
    assert(!IsReadOnly());
    return m_pMemory;
}

template <class T, class I>
inline const T* CUtlMemory<T, I>::Base() const {
    return m_pMemory;
}

//-----------------------------------------------------------------------------
// Size
//-----------------------------------------------------------------------------
template <class T, class I>
inline int CUtlMemory<T, I>::NumAllocated() const {
    return m_nAllocationCount;
}

template <class T, class I>
inline int CUtlMemory<T, I>::Count() const {
    return m_nAllocationCount;
}

//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template <class T, class I>
inline bool CUtlMemory<T, I>::IsIdxValid(I i) const {
    // GCC warns if I is an unsigned type and we do a ">= 0" against it (since the comparison is always 0).
    // We Get the warning even if we cast inside the expression. It only goes away if we assign to another variable.
    long x = i;
    return (x >= 0) && (x < m_nAllocationCount);
}

//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
inline int UtlMemory_CalcNewAllocationCount(int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem) {
    if (nGrowSize) {
        nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);
    } else {
        if (!nAllocationCount) {
            // Compute an allocation which is at least as big as a cache line...
            nAllocationCount = (31 + nBytesItem) / nBytesItem;
        }

        while (nAllocationCount < nNewSize) {
#ifndef _X360
            nAllocationCount *= 2;
#else
            int nNewAllocationCount = (nAllocationCount * 9) / 8; // 12.5 %
            if (nNewAllocationCount > nAllocationCount)
                nAllocationCount = nNewAllocationCount;
            else
                nAllocationCount *= 2;
#endif
        }
    }

    return nAllocationCount;
}

template <class T, class I>
void CUtlMemory<T, I>::Grow(int num) {
    assert(num > 0);

    if (IsExternallyAllocated()) {
        // Can't grow a buffer whose memory was externally allocated
        assert(0);
        return;
    }

    auto oldAllocationCount = m_nAllocationCount;
    // Make sure we have at least numallocated + num allocations.
    // Use the grow rules specified for this memory (in m_nGrowSize)
    int nAllocationRequested = m_nAllocationCount + num;

    int nNewAllocationCount = UtlMemory_CalcNewAllocationCount(m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T));

    // if m_nAllocationRequested wraps index type I, recalculate
    if ((int)(I)nNewAllocationCount < nAllocationRequested) {
        if ((int)(I)nNewAllocationCount == 0 && (int)(I)(nNewAllocationCount - 1) >= nAllocationRequested) {
            --nNewAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1
        } else {
            if ((int)(I)nAllocationRequested != nAllocationRequested) {
                // we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
                assert(0);
                return;
            }
            while ((int)(I)nNewAllocationCount < nAllocationRequested) {
                nNewAllocationCount = (nNewAllocationCount + nAllocationRequested) / 2;
            }
        }
    }

    m_nAllocationCount = nNewAllocationCount;

    if (m_pMemory) {
        auto ptr = GetMemAlloc()->Alloc(m_nAllocationCount * sizeof(T));

        memcpy(ptr, m_pMemory, oldAllocationCount * sizeof(T));
        m_pMemory = (T*)ptr;
    } else {
        m_pMemory = (T*)GetMemAlloc()->Alloc(m_nAllocationCount * sizeof(T));
    }
}

//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template <class T, class I>
inline void CUtlMemory<T, I>::EnsureCapacity(int num) {
    if (m_nAllocationCount >= num)
        return;

    if (IsExternallyAllocated()) {
        // Can't grow a buffer whose memory was externally allocated
        assert(0);
        return;
    }
    m_nAllocationCount = num;

    if (m_pMemory) {
        m_pMemory = (T*)GetMemAlloc()->Realloc(m_pMemory, m_nAllocationCount * sizeof(T));
    } else {
        m_pMemory = (T*)GetMemAlloc()->Alloc(m_nAllocationCount * sizeof(T));
    }
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template <class T, class I>
void CUtlMemory<T, I>::Purge() {
    if (!IsExternallyAllocated()) {
        if (m_pMemory) {
            GetMemAlloc()->Free((void*)m_pMemory);
            m_pMemory = 0;
        }
        m_nAllocationCount = 0;
    }
}

template <class T, class I>
void CUtlMemory<T, I>::Purge(int numElements) {
    assert(numElements >= 0);

    if (numElements > m_nAllocationCount) {
        // Ensure this isn't a grow request in disguise.
        assert(numElements <= m_nAllocationCount);
        return;
    }

    // If we have zero elements, do a purge:
    if (numElements == 0) {
        Purge();
        return;
    }

    if (IsExternallyAllocated()) {
        // Can't shrink a buffer whose memory was externally allocated, fail silently like purge
        return;
    }

    // If the number of elements is the same as the allocation count, we are done.
    if (numElements == m_nAllocationCount) {
        return;
    }

    if (!m_pMemory) {
        // Allocation count is non zero, but memory is null.
        assert(m_pMemory);
        return;
    }
    m_nAllocationCount = numElements;
    m_pMemory = (T*)GetMemAlloc()->Realloc(m_pMemory, m_nAllocationCount * sizeof(T));
}

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CUtlMemoryPoolBase.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include "tools/platform.h"
#include <cstdint>
#include <sdk/interfaces/common/CInterlockedInt.h>
#include <sdk/interfaces/common/CThreadMutex.h>
#include <sdk/interfaces/common/CTSList.h>
#include <type_traits>

#if defined(CS2) || defined(DOTA2) || defined(DEADLOCK)
constexpr auto kUtlMemoryPoolBaseVersion = 2;
#else
constexpr auto kUtlMemoryPoolBaseVersion = 1;
#endif

// Ways the memory pool can grow when it needs to make a new blob.
enum class MemoryPoolGrowType_t : std::int32_t {
    UTLMEMORYPOOL_GROW_NONE = 0, // Don't allow new blobs.
    UTLMEMORYPOOL_GROW_FAST = 1, // New blob size is numElements * (i+1)  (ie: the blocks it allocates get larger and larger each time it allocates one).
    UTLMEMORYPOOL_GROW_SLOW = 2, // New blob size is numElements.
    UTLMEMORYPOOL_GROW_RBTREE = 3 // No blobs. All blocks are stored in RBTree.
};

enum MemAllocAttribute_t {
    MemAllocAttribute_Unk0 = 0,
    MemAllocAttribute_Unk1 = 1,
    MemAllocAttribute_Unk2 = 2
};

class CUtlMemoryPoolBaseV1 {
public:
    struct FreeList_t {
        FreeList_t* m_pNext;
    };

    class CBlob {
    public:
        CBlob* m_pNext;
        int m_NumBytes; // Number of bytes in this blob.
        char m_Data[1];
        char m_Padding[3]; // to int align the struct
    };

    int m_BlockSize{};
    int m_BlocksPerBlob{};

    MemoryPoolGrowType_t m_GrowMode{};

    CInterlockedInt m_BlocksAllocated{};
    CInterlockedInt m_PeakAlloc{};

    std::uint16_t m_nAlignment{};
    std::uint16_t m_NumBlobs{};

    FreeList_t** m_ppTailOfFreeList{};
    FreeList_t* m_pHeadOfFreeList{};

    CBlob** m_ppBlobTail{};
    CBlob* m_pBlobHead{};

    MemAllocAttribute_t m_AllocAttribute{};

    bool m_Unk1{};
};
static_assert(sizeof(CUtlMemoryPoolBaseV1) == 0x40);

class CUtlMemoryPoolBaseV2 {
public:
    struct FreeList_t {
        FreeList_t* m_pNext;
    };

    class CBlob {
    public:
        CBlob* m_pNext;
        int m_NumBytes; // Number of bytes in this blob.
        char m_Data[1];
        char m_Padding[3]; // to int align the struct
    };

    int m_BlockSize{};
    int m_BlocksPerBlob{};

    MemoryPoolGrowType_t m_GrowMode{};

    CInterlockedInt m_BlocksAllocated{};
    CInterlockedInt m_PeakAlloc{};
    std::uint16_t m_nAlignment{};
    std::uint16_t m_NumBlobs{};

    CTSListBase m_FreeBlocks{};

    MemAllocAttribute_t m_AllocAttribute{};

    CThreadMutex m_Mutex{};

    CBlob* m_pBlobHead{};

    int m_TotalSize{}; // m_BlocksPerBlob * (m_NumBlobs + 1) + (m_nAligment + 14)
};
static_assert(sizeof(CUtlMemoryPoolBaseV2) == platform_specific{.windows = 0x80, .linux = 0x90});

using CUtlMemoryPoolBase = std::conditional_t<kUtlMemoryPoolBaseVersion == 1, CUtlMemoryPoolBaseV1, CUtlMemoryPoolBaseV2>;

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CUtlRBTree.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include "CUtlMemory.h"

//-----------------------------------------------------------------------------
// A red-black binary search tree
//-----------------------------------------------------------------------------

template <class I>
struct UtlRBTreeLinks_t {
    I m_Left;
    I m_Right;
    I m_Parent;
    I m_Tag;
};

template <class T, class I>
struct UtlRBTreeNode_t : public UtlRBTreeLinks_t<I> {
    T m_Data;
};

class Node_t;

template <class T, class I = unsigned short, typename L = bool (*)(const T&, const T&), class M = CUtlMemory<UtlRBTreeNode_t<T, I>, I>>
class CUtlRBTree {
public:
    typedef T KeyType_t;
    typedef T ElemType_t;
    typedef I IndexType_t;

    // Less func typedef
    // Returns true if the first parameter is "less" than the second
    typedef L LessFunc_t;

    void EnsureCapacity(int num);

    // gets particular elements
    T& Element(I i) {
        return m_Elements[i].m_Data;
    }
    T const& Element(I i) const {
        return m_Elements[i].m_Data;
    }
    T& operator[](I i) {
        return m_Elements[i].m_Data;
    }
    T const& operator[](I i) const {
        return m_Elements[i].m_Data;
    }

    // Gets the root
    I Root() const {
        return m_Root;
    }

    // Num elements
    [[nodiscard]] unsigned int Count() const {
        return (unsigned int)m_NumElements;
    }

    // Max "size" of the vector
    // it's not generally safe to iterate from index 0 to MaxElement()-1
    // it IS safe to do so when using CUtlMemory as the allocator,
    // but we should really remove patterns using this anyway, for safety and generality
    I MaxElement() const {
        return (I)m_Elements.NumAllocated();
    }

    // Gets the children
    I Parent(I i) const {
        return Links(i).m_Parent;
    }
    I LeftChild(I i) const {
        return Links(i).m_Left;
    }
    I RightChild(I i) const {
        return Links(i).m_Right;
    }

    // Tests if a node is a left or right child
    bool IsLeftChild(I i) const {
        return LeftChild(Parent(i)) == i;
    }
    bool IsRightChild(I i) const {
        return RightChild(Parent(i)) == i;
    }

    // Tests if root or leaf
    bool IsRoot(I i) const {
        return i == m_Root;
    }
    bool IsLeaf(I i) const {
        return (LeftChild(i) == InvalidIndex()) && (RightChild(i) == InvalidIndex());
    }

    // Checks if a node is valid and in the tree
    bool IsValidIndex(I i) const {
        if (!m_Elements.IsIdxValid(i))
            return false;

        if (m_Elements.IsIdxAfter(i, m_LastAlloc))
            return false; // don't read values that have been allocated, but not constructed

        return LeftChild(i) != i;
    }

    // Checks if the tree as a whole is valid
    [[nodiscard]] bool IsValid() const {
        if (!Count())
            return true;

        if (m_LastAlloc == m_Elements.InvalidIterator())
            return false;

        if (!m_Elements.IsIdxValid(Root()))
            return false;

        if (Parent(Root()) != InvalidIndex())
            return false;

        return true;
    }

    // Invalid index
    static I InvalidIndex() {
        return (I)M::InvalidIndex();
    }

    // returns the tree depth (not a very fast operation)
    int Depth(I node) const {
        if (node == InvalidIndex())
            return 0;

        int depthright = Depth(RightChild(node));
        int depthleft = Depth(LeftChild(node));
        return std::max(depthright, depthleft) + 1;
    }

    [[nodiscard]] int Depth() const {
        return Depth(Root());
    }

    // Find method
    I Find(T const& search) const {
        I current = m_Root;
        while (current != InvalidIndex()) {
            if (m_LessFunc(search, Element(current)))
                current = LeftChild(current);
            else if (m_LessFunc(Element(current), search))
                current = RightChild(current);
            else
                break;
        }
        return current;
    }

    bool HasElement(T const& search) const {
        return Find(search) != InvalidIndex();
    }

    // Iteration
    I FirstInorder() const {
        I i = m_Root;
        while (LeftChild(i) != InvalidIndex())
            i = LeftChild(i);
        return i;
    }

    I NextInorder(I i) const {
        // Don't go into an infinite loop if it's a bad index
        Assert(IsValidIndex(i));
        if (!IsValidIndex(i))
            return InvalidIndex();

        if (RightChild(i) != InvalidIndex()) {
            i = RightChild(i);
            while (LeftChild(i) != InvalidIndex())
                i = LeftChild(i);
            return i;
        }

        I parent = Parent(i);
        while (IsRightChild(i)) {
            i = parent;
            if (i == InvalidIndex())
                break;
            parent = Parent(i);
        }
        return parent;
    }

    I PrevInorder(I i) const {
        // Don't go into an infinite loop if it's a bad index
        Assert(IsValidIndex(i));
        if (!IsValidIndex(i))
            return InvalidIndex();

        if (LeftChild(i) != InvalidIndex()) {
            i = LeftChild(i);
            while (RightChild(i) != InvalidIndex())
                i = RightChild(i);
            return i;
        }

        I parent = Parent(i);
        while (IsLeftChild(i)) {
            i = parent;
            if (i == InvalidIndex())
                break;
            parent = Parent(i);
        }
        return parent;
    }

    I LastInorder() const {
        I i = m_Root;
        while (RightChild(i) != InvalidIndex())
            i = RightChild(i);
        return i;
    }

    I FirstPreorder() const {
        return m_Root;
    }

    I NextPreorder(I i) const {
        if (LeftChild(i) != InvalidIndex())
            return LeftChild(i);

        if (RightChild(i) != InvalidIndex())
            return RightChild(i);

        I parent = Parent(i);
        while (parent != InvalidIndex()) {
            if (IsLeftChild(i) && (RightChild(parent) != InvalidIndex()))
                return RightChild(parent);
            i = parent;
            parent = Parent(parent);
        }
        return InvalidIndex();
    }

    I PrevPreorder([[maybe_unused]] I i) const {
        // not implemented yet
        return InvalidIndex();
    }

    I LastPreorder() const {
        I i = m_Root;
        while (true) {
            while (RightChild(i) != InvalidIndex())
                i = RightChild(i);

            if (LeftChild(i) != InvalidIndex())
                i = LeftChild(i);
            else
                break;
        }
        return i;
    }

    I FirstPostorder() const {
        I i = m_Root;
        while (!IsLeaf(i)) {
            if (LeftChild(i))
                i = LeftChild(i);
            else
                i = RightChild(i);
        }
        return i;
    }

    I NextPostorder(I i) const {
        I parent = Parent(i);
        if (parent == InvalidIndex())
            return InvalidIndex();

        if (IsRightChild(i))
            return parent;

        if (RightChild(parent) == InvalidIndex())
            return parent;

        i = RightChild(parent);
        while (!IsLeaf(i)) {
            if (LeftChild(i))
                i = LeftChild(i);
            else
                i = RightChild(i);
        }
        return i;
    }

private:
    // Can't copy the tree this way!
    CUtlRBTree<T, I, L, M>& operator=(const CUtlRBTree<T, I, L, M>& other);

protected:
    enum NodeColor_t {
        RED = 0,
        BLACK
    };

    typedef UtlRBTreeNode_t<T, I> Node_t;
    typedef UtlRBTreeLinks_t<I> Links_t;

    // Gets at the links
    Links_t const& Links(I i) const {
        // Sentinel node, makes life easier
        static Links_t s_Sentinel = {InvalidIndex(), InvalidIndex(), InvalidIndex(), CUtlRBTree<T, I, L, M>::BLACK};

        return (i != InvalidIndex()) ? *(Links_t*)&m_Elements[i] : *(Links_t*)&s_Sentinel;
    }
    Links_t& Links(I i) {
        return *(Links_t*)&m_Elements[i];
    }

    // Checks if a link is red or black
    bool IsRed(I i) const {
        return (Links(i).m_Tag == RED);
    }
    bool IsBlack(I i) const {
        return (Links(i).m_Tag == BLACK);
    }

    // copy constructors not allowed
    CUtlRBTree(CUtlRBTree<T, I, L, M> const& tree);

    // Used for sorting.
    LessFunc_t m_LessFunc;

    M m_Elements;
    I m_Root;
    I m_NumElements;
    I m_FirstFree;
    typename M::Iterator_t m_LastAlloc; // the last index allocated

    Node_t* m_pElements;

    M const& Elements() const {
        return m_Elements;
    }
};

static_assert(sizeof(CUtlRBTree<int>) == 0x28);

template <class T, class I, typename L, class M>
inline void CUtlRBTree<T, I, L, M>::EnsureCapacity(int num) {
    m_Elements.EnsureCapacity(num);
}

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CUtlString.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

class CUtlString {
public:
    [[nodiscard]] const char* Get() const {
        return reinterpret_cast<const char*>(m_Memory.m_pMemory);
    }

    CUtlMemory<std::uint8_t> m_Memory;
    int m_nActualLength;
};

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CUtlTSHash.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include "sdk/interfaces/common/CThreadSpinMutex.h"
#include "sdk/interfaces/common/CThreadSpinRWLock.h"
#include "sdk/interfaces/common/CUtlMemory.h"
#include "sdk/interfaces/common/CUtlMemoryPoolBase.h"
#include <climits>
#include <cstdint>
#include <type_traits>
#include <vector>

#if defined(CS2) || defined(DOTA2) || defined(DEADLOCK)
constexpr auto kUtlTsHashVersion = 2;
#else
constexpr auto kUtlTsHashVersion = 1;
#endif

//=============================================================================
//
// Threadsafe Hash
//
// Number of buckets must be a power of 2.
// Key must be intp sized (32-bits on x32, 64-bits on x64)
// Designed for a usage pattern where the data is semi-static, and there
// is a well-defined point where we are guaranteed no queries are occurring.
//
// Insertions are added into a thread-safe list, and when Commit() is called,
// the insertions are moved into a lock-free list
//
// Elements are never individually removed; clears must occur at a time
// when we and guaranteed no queries are occurring
//
using UtlTsHashHandleT = std::uint64_t;

template <class T>
class ITSHashConstructor {
public:
    virtual void Construct(T* pElement) = 0;
};

template <class T>
class CDefaultTSHashConstructor : public ITSHashConstructor<T> {
public:
    virtual void Construct(T* pElement) {
        ::Construct(pElement);
    }
};

inline unsigned HashIntConventional(const int n) // faster but less effective
{
    // first byte
    unsigned hash = 0xAAAAAAAA + (n & 0xFF);
    // second byte
    hash = (hash << 5) + hash + ((n >> 8) & 0xFF);
    // third byte
    hash = (hash << 5) + hash + ((n >> 16) & 0xFF);
    // fourth byte
    hash = (hash << 5) + hash + ((n >> 24) & 0xFF);

    return hash;

    /* this is the old version, which would cause a load-hit-store on every
       line on a PowerPC, and therefore took hundreds of clocks to execute!

    byte *p = (byte *)&n;
    unsigned hash = 0xAAAAAAAA + *p++;
    hash = ( ( hash << 5 ) + hash ) + *p++;
    hash = ( ( hash << 5 ) + hash ) + *p++;
    return ( ( hash << 5 ) + hash ) + *p;
    */
}
template <class KEYTYPE = std::uint64_t>
class CUtlTSHashGenericHash {
public:
    static int Hash(const KEYTYPE& key, int nBucketMask) {
        int nHash = HashIntConventional((std::uint64_t)key);
        if (nBucketMask <= USHRT_MAX) {
            nHash ^= (nHash >> 16);
        }
        if (nBucketMask <= UCHAR_MAX) {
            nHash ^= (nHash >> 8);
        }
        return (nHash & nBucketMask);
    }

    static bool Compare(const KEYTYPE& lhs, const KEYTYPE& rhs) {
        return lhs == rhs;
    }
};

template <class KEYTYPE>
class CUtlTSHashUseKeyHashMethod {
public:
    static int Hash(const KEYTYPE& key, int nBucketMask) {
        std::uint32_t nHash = key.HashValue();
        return static_cast<int>(nHash & nBucketMask);
    }

    static bool Compare(const KEYTYPE& lhs, const KEYTYPE& rhs) {
        return lhs == rhs;
    }
};

template <class T, class Keytype = std::uint64_t, int BucketCount = 256, class HashFuncs = CUtlTSHashGenericHash<Keytype>>
class CUtlTSHashV1 {
public:
    // Invalid handle.
    static UtlTsHashHandleT InvalidHandle() {
        return static_cast<UtlTsHashHandleT>(0);
    }

    // Returns the number of elements in the hash table
    [[nodiscard]] int BlockSize() const {
        return m_EntryMemory.m_BlocksPerBlob;
    }

    [[nodiscard]] int PeakAlloc() const {
        return m_EntryMemory.m_PeakAlloc;
    }

    // Returns elements in the table
    std::vector<T> GetElements();

public:
    // Templatized for memory tracking purposes
    template <typename Data_t>
    struct HashFixedDataInternal_t {
        Keytype m_uiKey;
        HashFixedDataInternal_t<Data_t>* m_pNext;
        Data_t m_Data;
    };

    using HashFixedData_t = HashFixedDataInternal_t<T>;

    // @note: @og: Actually this is hacky-way to obtain data
    template <typename Data_t>
    struct HashBucketFixedDataInternal_t {
        Keytype m_Keytype;
        HashFixedDataInternal_t<Data_t>* m_pNext;
        Data_t m_Data;
    };

    using HashBucketFixedData_t = HashBucketFixedDataInternal_t<T>;

    template <typename Data_t>
    struct HashBucketDataInternalT {
        Data_t m_Data;
        HashBucketFixedData_t* m_pNext;
        Keytype m_Keytype;
    };

    using HashBucketDataT = HashBucketDataInternalT<T>;

    struct CBlob_Unallocated_t {
        CBlob_Unallocated_t* m_pNext = nullptr; // 0x0000
        Keytype m_NumBytes; // 0x0008
        Keytype m_Data; // 0x0010
        Keytype m_Padding; // 0x0018
        std::array<HashBucketDataT, BucketCount> m_List; // 0x0020
    };

    struct HashBucket_t {
        CThreadSpinRWLock m_AddLock;
        HashFixedData_t* m_pFirst;
        HashFixedData_t* m_pFirstUncommitted;
    };

    CUtlMemoryPoolBase m_EntryMemory;
    std::array<HashBucket_t, BucketCount> m_aBuckets;

#if defined(DOTA2) || defined(DEADLOCK)
    bool m_bNeedsCommit;
    CInterlockedInt m_ContentionCheck;
#endif
};

// @note: @og: notice this is hacky-way to obtain elements from CUtlTSHash but its works, so why not
template <class T, class Keytype, int BucketCount, class HashFuncs>
std::vector<T> CUtlTSHashV1<T, Keytype, BucketCount, HashFuncs>::GetElements() {
    std::vector<T> list;

    const int n_count = PeakAlloc();
    auto n_index = 0;

    if (!m_EntryMemory.m_pBlobHead)
        return list;

    auto unallocated_data = reinterpret_cast<CBlob_Unallocated_t*>(m_EntryMemory.m_pBlobHead);
    for (auto element = unallocated_data; element; element = element->m_pNext) {
        for (auto i = 0; i < BucketCount; i++) {
            list.emplace_back(element->m_List.at(i).m_Data);
            n_index++;

            if (n_index >= n_count)
                break;
        }
    }
    return list;
}

template <class T, class Keytype = std::uint64_t, int BucketCount = 256, class HashFuncs = CUtlTSHashGenericHash<Keytype>>
class CUtlTSHashV2 {
public:
    // Invalid handle.
    static UtlTsHashHandleT InvalidHandle() {
        return static_cast<UtlTsHashHandleT>(0);
    }

    // Returns the number of elements in the hash table
    [[nodiscard]] int BlockSize() const {
        return m_EntryMemory.m_BlockSize;
    }
    [[nodiscard]] int PeakAlloc() const {
        return m_EntryMemory.m_PeakAlloc;
    }
    [[nodiscard]] int BlocksAllocated() const {
        return m_EntryMemory.m_BlocksAllocated;
    }
    [[nodiscard]] int Count() const {
        return BlocksAllocated() == 0 ? PeakAlloc() : BlocksAllocated();
    }

    // Returns elements in the table
    std::vector<T> GetElements(int nFirstElement = 0);

private:
    template <typename Predicate>
    std::vector<T> merge_without_duplicates(const std::vector<T>& allocated_list, const std::vector<T>& un_allocated_list, Predicate pred);

public:
    class HashAllocatedBlob_t {
    public:
        HashAllocatedBlob_t* m_unAllocatedNext; // 0x0000
        char pad_0008[8]; // 0x0008
        T m_unAllocatedData; // 0x0010
        char pad_0018[8]; // 0x0018
    }; // Size: 0x0020

    // Templatized for memory tracking purposes
    template <typename Data_t>
    struct HashFixedDataInternal_t {
        Keytype m_uiKey;
        HashFixedDataInternal_t<Data_t>* m_pNext;
        Data_t m_Data;
    };

    typedef HashFixedDataInternal_t<T> HashFixedData_t;

    class HashBucket_t {
    public:
        CThreadSpinRWLock* m_AddLock; // 0x0000
        HashFixedData_t* m_pFirst; // 0x008
        HashFixedData_t* m_pFirstUncommitted; // 0x0010
        IF_LINUX(char pad_0x18[0x08];)
    }; // Size: 0x0018
    // clang-19 requires an explicit template type for platform_specific
    static_assert(sizeof(HashBucket_t) == platform_specific<int>{.windows = 0x18, .linux = 0x20});

    CUtlMemoryPoolBase m_EntryMemory;

    IF_LINUX(char pad[0x04]);
    std::array<HashBucket_t, BucketCount> m_aBuckets;
    bool m_bNeedsCommit{};
    CInterlockedInt m_ContentionCheck;
};

template <typename T>
bool ptr_compare(const T& item1, const T& item2) {
    return item1 == item2;
}

template <class T, class Keytype, int BucketCount, class HashFuncs>
template <typename Predicate>
inline std::vector<T> CUtlTSHashV2<T, Keytype, BucketCount, HashFuncs>::merge_without_duplicates(const std::vector<T>& allocated_list,
                                                                                                 const std::vector<T>& un_allocated_list, Predicate pred) {
    std::vector<T> merged_list = allocated_list;

    for (const auto& item : un_allocated_list) {
        if (std::ranges::find_if(allocated_list, [&](const T& elem) { return pred(elem, item); }) == allocated_list.end()) {
            merged_list.push_back(item);
        }
    }

    return merged_list;
}

template <class T, class Keytype, int BucketCount, class HashFuncs>
std::vector<T> CUtlTSHashV2<T, Keytype, BucketCount, HashFuncs>::GetElements(int nFirstElement) {
    int n_count = BlocksAllocated();
    std::vector<T> AllocatedList;
    if (n_count > 0) {
        int nIndex = 0;
        for (int i = 0; i < BucketCount; i++) {
            const HashBucket_t& bucket = m_aBuckets[i];
            for (HashFixedData_t* pElement = bucket.m_pFirstUncommitted; pElement; pElement = pElement->m_pNext) {
                if (--nFirstElement >= 0)
                    continue;

                if (pElement->m_Data == nullptr)
                    continue;

                AllocatedList.emplace_back(pElement->m_Data);
                ++nIndex;

                if (nIndex >= n_count)
                    break;
            }
        }
    }

    /// @note: @og: basically, its hacky-way to obtain first-time commited information to memory
#if defined(CS2_OLD)
    n_count = PeakAlloc();
#elif defined(DOTA2) || defined(CS2) || defined(DEADLOCK)
    n_count = PeakAlloc() - BlocksAllocated();
#endif
    std::vector<T> unAllocatedList;
    if (n_count > 0) {
        int nIndex = 0;
        auto m_unBuckets = *reinterpret_cast<HashAllocatedBlob_t**>(&m_EntryMemory.m_FreeBlocks.m_Head.value32);
        for (auto unallocated_element = m_unBuckets; unallocated_element; unallocated_element = unallocated_element->m_unAllocatedNext) {
            if (unallocated_element->m_unAllocatedData == nullptr)
                continue;

            unAllocatedList.emplace_back(unallocated_element->m_unAllocatedData);
            ++nIndex;

            if (nIndex >= n_count)
                break;
        }
    }

#if defined(CS2_OLD)
    return unAllocatedList.size() > AllocatedList.size() ? unAllocatedList : AllocatedList;
#elif defined(DOTA2) || defined(CS2) || defined(DEADLOCK)
    return merge_without_duplicates(AllocatedList, unAllocatedList, ptr_compare<T>);
#endif
}

template <class Ty>
using CUtlTSHash = std::conditional_t<kUtlTsHashVersion == 1, CUtlTSHashV1<Ty>, CUtlTSHashV2<Ty>>;

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/common/CUtlVector.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include <cassert>
#include <sdk/interfaces/tier0/IMemAlloc.h>

template <class T>
class CUtlVector {
public:
    CUtlVector() {
        m_Size = 0;
        m_pElements = nullptr;
    }

    T& Element(int i);
    const T& Element(int i) const;

    T& operator[](int i) {
        return m_pElements[i];
    }

    [[nodiscard]] int Count() const {
        return m_Size;
    }

    int m_Size;
    T* m_pElements;

    // Adds an element, uses default constructor
    int AddToHead();
    int AddToTail();
    int InsertBefore(int elem);
    int InsertAfter(int elem);
    // Adds an element, uses copy constructor
    int AddToHead(const T& src);
    int AddToTail(const T& src);
    int InsertBefore(int elem, const T& src);
    int InsertAfter(int elem, const T& src);

    // Grows the vector
    void GrowVector(int num = 1);

    // Shifts elements....
    void ShiftElementsRight(int elem, int num = 1);
    void ShiftElementsLeft(int elem, int num = 1);

    // Element removal
    void FastRemove(int elem); // doesn't preserve order
    void Remove(int elem); // preserves order, shifts elements
    bool FindAndRemove(const T& src); // removes first occurrence of src, preserves order, shifts elements
    bool FindAndFastRemove(const T& src); // removes first occurrence of src, doesn't preserve order

    // Finds an element (element needs operator== defined)
    int GetOffset(const T& src) const;
};

template <typename T>
inline T& CUtlVector<T>::Element(int i) {
    assert(i < m_Size);
    return m_pElements[i];
}

template <typename T>
inline const T& CUtlVector<T>::Element(int i) const {
    assert(i < m_Size);
    return m_pElements[i];
}

template <typename T>
void CUtlVector<T>::GrowVector(int num) {
    m_Size += num;
    if (m_pElements)
        m_pElements = (T*)GetMemAlloc()->Realloc(m_pElements, m_Size * sizeof(T));
    else
        m_pElements = (T*)GetMemAlloc()->Alloc(m_Size * sizeof(T));
}

//-----------------------------------------------------------------------------
// Adds an element, uses default constructor
//-----------------------------------------------------------------------------
template <typename T>
inline int CUtlVector<T>::AddToHead() {
    return InsertBefore(0);
}

template <typename T>
inline int CUtlVector<T>::AddToTail() {
    return InsertBefore(m_Size);
}

template <typename T>
inline int CUtlVector<T>::InsertAfter(int elem) {
    return InsertBefore(elem + 1);
}

template <typename T>
int CUtlVector<T>::InsertBefore(int elem) {
    // Can insert at the end
    GrowVector();
    ShiftElementsRight(elem);
    Construct(&Element(elem));
    return elem;
}

//-----------------------------------------------------------------------------
// Adds an element, uses copy constructor
//-----------------------------------------------------------------------------
template <typename T>
inline int CUtlVector<T>::AddToHead(const T& src) {
    return InsertBefore(0, src);
}

template <typename T>
inline int CUtlVector<T>::AddToTail(const T& src) {
    return InsertBefore(m_Size, src);
}

template <typename T>
inline int CUtlVector<T>::InsertAfter(int elem, const T& src) {
    return InsertBefore(elem + 1, src);
}

template <typename T>
int CUtlVector<T>::InsertBefore(int elem, const T& src) {
    GrowVector();
    ShiftElementsRight(elem);
    CopyConstruct(&Element(elem), src);
    return elem;
}

//-----------------------------------------------------------------------------
// Shifts elements
//-----------------------------------------------------------------------------
template <typename T>
void CUtlVector<T>::ShiftElementsRight(int elem, int num) {
    int numToMove = m_Size - elem - num;
    if ((numToMove > 0) && (num > 0))
        memmove(&Element(elem + num), &Element(elem), numToMove * sizeof(T));
}

template <typename T>
void CUtlVector<T>::ShiftElementsLeft(int elem, int num) {
    int numToMove = m_Size - elem - num;
    if ((numToMove > 0) && (num > 0)) {
        memmove(&Element(elem), &Element(elem + num), numToMove * sizeof(T));

#ifdef _DEBUG
        memset(&Element(m_Size - num), 0xDD, num * sizeof(T));
#endif
    }
}

//-----------------------------------------------------------------------------
// Element removal
//-----------------------------------------------------------------------------
template <typename T>
void CUtlVector<T>::FastRemove(int elem) {
    Destruct(&Element(elem));
    if (m_Size > 0) {
        if (elem != m_Size - 1)
            memcpy(&Element(elem), &Element(m_Size - 1), sizeof(T));
        --m_Size;
    }
}

template <typename T>
void CUtlVector<T>::Remove(int elem) {
    Destruct(&Element(elem));
    ShiftElementsLeft(elem);
    --m_Size;
}

template <typename T>
bool CUtlVector<T>::FindAndRemove(const T& src) {
    int elem = GetOffset(src);
    if (elem != -1) {
        Remove(elem);
        return true;
    }
    return false;
}

template <typename T>
bool CUtlVector<T>::FindAndFastRemove(const T& src) {
    int elem = GetOffset(src);
    if (elem != -1) {
        FastRemove(elem);
        return true;
    }
    return false;
}

//-----------------------------------------------------------------------------
// Finds an element (element needs operator== defined)
//-----------------------------------------------------------------------------
template <typename T>
int CUtlVector<T>::GetOffset(const T& src) const {
    for (auto i = 0; i < Count(); ++i) {
        if (Element(i) == src)
            return i;
    }
    return -1;
}

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/schemasystem/schema.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include "sdk/interfaceregs.h"
#include "tools/platform.h"
#include <algorithm>
#include <array>
#include <cstdint>
#include <limits>
#include <optional>
#include <ranges>
#include <sdk/interfaces/client/game/datamap_t.h>
#include <sdk/interfaces/common/CBufferString.h>
#include <sdk/interfaces/common/CUtlMap.h>
#include <sdk/interfaces/common/CUtlTSHash.h>
#include <string_view>
#include <tools/platform.h>
#include <tools/virtual.h>
#include <vector>

#if defined(SBOX)
// untested might be wrong

constexpr auto kSchemaSystemVersion = 1;
constexpr auto kSchemaSystem_PAD0 = 0x5420;
constexpr auto kSchemaSystem_PAD1 = 0x120;
constexpr auto kSchemaSystemTypeScope_PAD0 = 0x7;

enum {
    kSchemaType_GetSizeWithAlignOf = 4,
    kSchemaSystem_GetClassInfoBinaryName = 21,
    kSchemaSystem_GetClassProjectName = 22,
    kSchemaSystem_GetEnumBinaryName = 23,
    kSchemaSystem_GetEnumProjectName = 24,
    kSchemaSystem_ValidateClasses = 34,
    kSchemaSystemTypeScope_DeclaredClass = 13,
    kSchemaSystemTypeScope_DeclaredEnum = kSchemaSystemTypeScope_DeclaredClass + 1,
    kSchemaSystemTypeScope_GetScopeName = 28,
    kSchemaSystemTypeScope_IsGlobalScope = kSchemaSystemTypeScope_GetScopeName + 1,
};

#elif defined(ARTIFACT2)

// untested

constexpr auto kSchemaSystemVersion = 1;
constexpr auto kSchemaSystem_PAD0 = 0x5430;
constexpr auto kSchemaSystem_PAD1 = 0x120;
constexpr auto kSchemaSystemTypeScope_PAD0 = 0x7;

enum {
    kSchemaType_GetSizeWithAlignOf = 4,
    kSchemaSystem_GetClassInfoBinaryName = 21,
    kSchemaSystem_GetClassProjectName = 22,
    kSchemaSystem_GetEnumBinaryName = 23,
    kSchemaSystem_GetEnumProjectName = 24,
    kSchemaSystem_ValidateClasses = 34,
    kSchemaSystemTypeScope_DeclaredClass = 13,
    kSchemaSystemTypeScope_DeclaredEnum = kSchemaSystemTypeScope_DeclaredClass + 1,
    kSchemaSystemTypeScope_GetScopeName = 28,
    kSchemaSystemTypeScope_IsGlobalScope = kSchemaSystemTypeScope_GetScopeName + 1,
};

#elif defined(ARTIFACT1)

// untested

constexpr auto kSchemaSystemVersion = 1;
constexpr auto kSchemaSystem_PAD0 = 0x4428;
constexpr auto kSchemaSystem_PAD1 = 0x120;
constexpr auto kSchemaSystemTypeScope_PAD0 = 0x7;

enum {
    kSchemaType_GetSizeWithAlignOf = 4,
    kSchemaSystem_GetClassInfoBinaryName = 21,
    kSchemaSystem_GetClassProjectName = 22,
    kSchemaSystem_GetEnumBinaryName = 23,
    kSchemaSystem_GetEnumProjectName = 24,
    kSchemaSystem_ValidateClasses = 34,
    kSchemaSystemTypeScope_DeclaredClass = 13,
    kSchemaSystemTypeScope_DeclaredEnum = kSchemaSystemTypeScope_DeclaredClass + 1,
    kSchemaSystemTypeScope_GetScopeName = 28,
    kSchemaSystemTypeScope_IsGlobalScope = kSchemaSystemTypeScope_GetScopeName + 1,
};

#elif defined(UNDERLORDS)

constexpr auto kSchemaSystemVersion = 1;
constexpr auto kSchemaSystem_PAD0 = 0x5420;
constexpr auto kSchemaSystem_PAD1 = 0x120;
constexpr auto kSchemaSystemTypeScope_PAD0 = 0x7;

enum {
    kSchemaType_GetSizeWithAlignOf = 4,
    kSchemaSystem_ValidateClasses = 34,
    kSchemaSystem_GetClassInfoBinaryName = 21,
    kSchemaSystem_GetClassProjectName = 22,
    kSchemaSystem_GetEnumBinaryName = 23,
    kSchemaSystem_GetEnumProjectName = 24,
    kSchemaSystemTypeScope_DeclaredClass = 13,
    kSchemaSystemTypeScope_DeclaredEnum = kSchemaSystemTypeScope_DeclaredClass + 1,
    kSchemaSystemTypeScope_GetScopeName = 28,
    kSchemaSystemTypeScope_IsGlobalScope = kSchemaSystemTypeScope_GetScopeName + 1,
};

#elif defined(DESKJOB)

// untested

constexpr auto kSchemaSystemVersion = 1;
constexpr auto kSchemaSystem_PAD0 = 0x3A0;
constexpr auto kSchemaSystemTypeScope_PAD0 = 0x7;

enum {
    kSchemaType_GetSizeWithAlignOf = 3,
    kSchemaSystem_ValidateClasses = 34,
    kSchemaSystem_GetClassInfoBinaryName = 21,
    kSchemaSystem_GetClassProjectName = 22,
    kSchemaSystem_GetEnumBinaryName = 23,
    kSchemaSystem_GetEnumProjectName = 24,
    kSchemaSystemTypeScope_DeclaredClass = 13,
    kSchemaSystemTypeScope_DeclaredEnum = kSchemaSystemTypeScope_DeclaredClass + 1,
    kSchemaSystemTypeScope_GetScopeName = 30,
    kSchemaSystemTypeScope_IsGlobalScope = kSchemaSystemTypeScope_GetScopeName + 1,
};

#elif defined(HL_ALYX)
    #error unimplemented
#elif defined(THE_LAB_ROBOT_REPAIR)
    #error unimplemented
#elif defined(DOTA2) || defined(CS2) || defined(DEADLOCK)

constexpr auto kSchemaSystemVersion = platform_specific{.windows = 2, .linux = 1}.get();
constexpr auto kSchemaSystem_PAD0 = platform_specific{.windows = 0x188, .linux = 0x188 + 0x68}.get();
constexpr auto kSchemaSystem_PAD1 = 0x120;
constexpr auto kSchemaSystemTypeScope_PAD0 = 0x7;

enum {
    kSchemaType_GetSizeWithAlignOf = 3,
    kSchemaSystem_ValidateClasses = 35,
    kSchemaSystem_GetClassInfoBinaryName = 22,
    kSchemaSystem_GetClassModuleName = kSchemaSystem_GetClassInfoBinaryName + 1,
    kSchemaSystem_GetEnumBinaryName = kSchemaSystem_GetClassModuleName + 1,
    kSchemaSystem_GetEnumProjectName = kSchemaSystem_GetEnumBinaryName + 1,
    kSchemaSystemTypeScope_DeclaredClass = 14,
    kSchemaSystemTypeScope_DeclaredEnum = kSchemaSystemTypeScope_DeclaredClass + 1,
    kSchemaSystemTypeScope_GetScopeName = 28,
    kSchemaSystemTypeScope_IsGlobalScope = kSchemaSystemTypeScope_GetScopeName + 1,
};

#elif defined(CS2_OLD)

/// Some functions differ between games and platforms. At least for now, 2 has
/// return-value-optimization, 1 doesn't.
constexpr auto kSchemaSystemVersion = platform_specific{.windows = 2, .linux = 1}.get();
constexpr auto kSchemaSystem_PAD0 = platform_specific{.windows = 0x190, .linux = 0x1F8}.get();
constexpr auto kSchemaSystem_PAD1 = 0x120;
constexpr auto kSchemaSystemTypeScope_PAD0 = 0x7;

enum {
    kSchemaType_GetSizeWithAlignOf = 3,
    kSchemaSystem_ValidateClasses = 35,
    kSchemaSystem_GetClassInfoBinaryName = 22,
    kSchemaSystem_GetClassProjectName = 23,
    kSchemaSystem_GetEnumBinaryName = 24,
    kSchemaSystem_GetEnumProjectName = 25,
    kSchemaSystemTypeScope_DeclaredClass = 14,
    kSchemaSystemTypeScope_DeclaredEnum = kSchemaSystemTypeScope_DeclaredClass + 1,
    kSchemaSystemTypeScope_GetScopeName = 32,
    kSchemaSystemTypeScope_IsGlobalScope = kSchemaSystemTypeScope_GetScopeName + 1,
};

#else
    #error No implementation defined, please set SOURCE2GEN_GAME and re-generate the project
#endif

class ISaveRestoreOps;
class CSchemaEnumInfo;
class CSchemaClassInfo;
class CSchemaSystemTypeScope;
class CSchemaType;
class CSchemaSystem;

struct SchemaMetadataEntryData_t;
struct SchemaClassInfoData_t;

// @note: @og: now CSchemaClassBinding is the same class\structure as CSchemaClassBinding\SchemaClassInfoData_t
using CSchemaClassBinding = CSchemaClassInfo;

// @note: @og: now CSchemaEnumBinding is the same class\structure as CSchemaEnumInfoData\SchemaEnumInfoData_t
using CSchemaEnumBinding = CSchemaEnumInfo;

#if defined(CS2) || defined(DOTA2) || defined(DEADLOCK)
enum SchemaClassFlags_t {
    SCHEMA_CF1_HAS_VIRTUAL_MEMBERS = (1 << 0),
    SCHEMA_CF1_IS_ABSTRACT = (1 << 1),
    SCHEMA_CF1_HAS_TRIVIAL_CONSTRUCTOR = (1 << 2),
    SCHEMA_CF1_HAS_TRIVIAL_DESTRUCTOR = (1 << 3),
    SCHEMA_CF1_LIMITED_METADATA = (1 << 4),
    SCHEMA_CF1_INHERITANCE_DEPTH_CALCULATED = (1 << 5),
    SCHEMA_CF1_MODULE_LOCAL_TYPE_SCOPE = (1 << 6),
    SCHEMA_CF1_GLOBAL_TYPE_SCOPE = (1 << 7),
    SCHEMA_CF1_CONSTRUCT_ALLOWED = (1 << 8),
    SCHEMA_CF1_CONSTRUCT_DISALLOWED = (1 << 9),
    SCHEMA_CF1_INFO_TAG_MNetworkAssumeNotNetworkable = (1 << 10),
    SCHEMA_CF1_INFO_TAG_MNetworkNoBase = (1 << 11),
    SCHEMA_CF1_INFO_TAG_MIgnoreTypeScopeMetaChecks = (1 << 12),
    SCHEMA_CF1_INFO_TAG_MDisableDataDescValidation = (1 << 13),
    SCHEMA_CF1_INFO_TAG_MClassHasEntityLimitedDataDesc = (1 << 14),
    SCHEMA_CF1_INFO_TAG_MClassHasCustomAlignedNewDelete = (1 << 15),
    SCHEMA_CF1_INFO_TAG_MNonConstructibleClassBase = (1 << 16),
    SCHEMA_CF1_INFO_TAG_MConstructibleClassBase = (1 << 17),
    SCHEMA_CF1_INFO_TAG_MHasKV3TransferPolymorphicClassname = (1 << 18),
};
#else
enum SchemaClassFlags_t {
    SCHEMA_CF1_HAS_VIRTUAL_MEMBERS = 1,
    SCHEMA_CF1_IS_ABSTRACT = 2,
    SCHEMA_CF1_HAS_TRIVIAL_CONSTRUCTOR = 4,
    SCHEMA_CF1_HAS_TRIVIAL_DESTRUCTOR = 8,
    SCHEMA_CF1_HAS_NOSCHEMA_MEMBERS = 16,
    SCHEMA_CF1_IS_PARENT_CLASSES_PARSED = 32,
    SCHEMA_CF1_IS_LOCAL_TYPE_SCOPE = 64,
    SCHEMA_CF1_IS_GLOBAL_TYPE_SCOPE = 128,
    SCHEMA_CF1_IS_SCHEMA_VALIDATED = 1024,
};
#endif

struct CSchemaVarName {
    const char* m_pszName;
    const char* m_pszType;
};

struct CSchemaNetworkValue {
    union {
        const char* m_pszValue;
        int m_nValue;
        float m_fValue;
        std::uintptr_t m_pPointer;
        CSchemaVarName m_VarValue;
        std::array<char, 8> m_szValue;
    };
};

struct SchemaMetadataEntryData_t {
    const char* m_szName;
    CSchemaNetworkValue* m_pNetworkValue;
};

struct SchemaEnumeratorInfoData_t {
    const char* m_szName;

    union {
        std::uint8_t m_uint8;
        std::uint16_t m_uint16;
        std::uint32_t m_uint32;
        std::uint64_t m_uint64;
    };

    std::int32_t m_nMetadataSize;
    SchemaMetadataEntryData_t* m_pMetadata;
};

enum class SchemaEnumFlags_t : std::uint16_t {
    SCHEMA_EF_IS_REGISTERED = (1 << 0),
    SCHEMA_EF_MODULE_LOCAL_TYPE_SCOPE = (1 << 1),
    SCHEMA_EF_GLOBAL_TYPE_SCOPE = (1 << 2),
};

class SchemaEnumInfoData_t {
public:
    SchemaEnumInfoData_t* m_pSelf; // 0x0000
    const char* m_pszName; // 0x0008
    const char* m_pszModule; // 0x0010
    std::uint8_t m_unSizeOf; // 0x0018
    std::uint8_t m_unAlignOf; // 0x0019
    SchemaEnumFlags_t m_unFlags; // 0x001A
    std::int16_t m_nEnumeratorCount; // 0x001C
    std::int16_t m_nStaticMetadataSize; // 0x001E
    SchemaEnumeratorInfoData_t* m_pEnumerators;
    SchemaMetadataEntryData_t* m_pStaticMetadata;
    CSchemaSystemTypeScope* m_pTypeScope; // 0x0030
    std::int64_t m_nMinEnumeratorValue; // 0x0038
    std::int64_t m_nMaxEnumeratorValue; // 0x0040
};
static_assert(sizeof(SchemaEnumInfoData_t) == 0x48);

class CSchemaEnumInfo : public SchemaEnumInfoData_t {
public:
    [[nodiscard]] std::vector<SchemaEnumeratorInfoData_t> GetEnumeratorValues() const {
        return {m_pEnumerators, m_pEnumerators + m_nEnumeratorCount};
    }

    [[nodiscard]] std::vector<SchemaMetadataEntryData_t> GetStaticMetadata() const {
        return {m_pStaticMetadata, m_pStaticMetadata + m_nStaticMetadataSize};
    }
};

enum class ETypeCategory : std::uint8_t {
    Schema_Builtin = 0,
    Schema_Ptr,
    Schema_Bitfield,
    Schema_FixedArray,
    Schema_Atomic,
    Schema_DeclaredClass,
    Schema_DeclaredEnum,
    Schema_None
};

#if defined(CS2)
enum class EAtomicCategory : std::uint8_t {
    Atomic_Basic = 0,
    Atomic_T,
    Atomic_CollectionOfT,
    Atomic_TF,
    Atomic_TT,
    Atomic_TTF,
    Atomic_I,
    Atomic_None
};
#else
enum class EAtomicCategory : std::uint8_t {
    Atomic_Basic = 0,
    Atomic_T,
    Atomic_CollectionOfT,
    Atomic_TT,
    Atomic_I,
    Atomic_None
};
#endif

enum class SchemaBuiltinType_t : std::uint32_t {
    Schema_Builtin_none = 0,
    Schema_Builtin_void,
    Schema_Builtin_char,
    Schema_Builtin_int8,
    Schema_Builtin_uint8,
    Schema_Builtin_int16,
    Schema_Builtin_uint16,
    Schema_Builtin_int32,
    Schema_Builtin_uint32,
    Schema_Builtin_int64,
    Schema_Builtin_uint64,
    Schema_Builtin_float32,
    Schema_Builtin_float64,
    Schema_Builtin_bool,
    Schema_Builtin_count
};

constexpr auto kSchemaBuiltinTypeCount = static_cast<std::size_t>(SchemaBuiltinType_t::Schema_Builtin_count);

class CSchemaType_DeclaredClass;
class CSchemaType_DeclaredEnum;

class CSchemaType {
public:
    [[nodiscard]] bool IsValid() {
        return Virtual::Get<bool (*)(void*)>(this, 0)(this);
    }

    [[nodiscard]] std::string ToString() {
        static CBufferStringGrowable<1024> szBuf;
        (void)Virtual::Get<const char*(__thiscall*)(void*, CBufferString&, bool bDontClearBuff)>(this, 1)(this, szBuf, false);
        return szBuf.Get();
    }

    void SpewDescription(std::uint32_t unLogChannel, const char* szName) {
        Virtual::Get<void (*)(void*, std::uint32_t, const char*)>(this, 2)(this, unLogChannel, szName);
    }

    // @note: @og: gets size with align
    [[nodiscard]] bool GetSizeWithAlignOf(int* nOutSize, std::uint8_t* unOutAlign) const {
        return reinterpret_cast<int (*)(const void*, int*, std::uint8_t*)>(vftable[kSchemaType_GetSizeWithAlignOf])(this, nOutSize, unOutAlign);
    }

    [[nodiscard]] bool CanReinterpretAs(CSchemaType* pType) {
        return reinterpret_cast<bool (*)(void*, CSchemaType*)>(vftable[kSchemaType_GetSizeWithAlignOf + 1])(this, pType);
    }

    // @note: @og: Can be used on CSchemaClassInfo. (Uses multiple inheritance depth verify that current CSchemaType->m_pClassInfo is inherits from pType)
    [[nodiscard]] bool IsA(CSchemaType* pType) {
        return Virtual::Get<bool (*)(void*, CSchemaType*)>(this, 7)(this, pType);
    }

public:
    // @note: @og: wrapper around GetSizeWithAlignOf, this one gets CSchemaClassInfo->m_nSizeOf
    [[nodiscard]] std::optional<int> GetSize() {
        return GetSizeAndAlignment().transform([](auto e) { return std::get<0>(e); });
    }

    /// @return {size, alignment}
    [[nodiscard]] std::optional<std::pair<int, std::optional<int>>> GetSizeAndAlignment() const {
        std::uint8_t alignment = 0;
        int size = 0;

        return GetSizeWithAlignOf(&size, &alignment) ?
                   std::make_optional(std::make_pair(size, (alignment == 0xff) ? std::nullopt : std::make_optional(static_cast<int>(alignment)))) :
                   std::nullopt;
    }

    /// @return @ref nullptr if this @ref GetTypeCategory() is not @ref ETypeCategory::Schema_DeclaredClass
    const CSchemaType_DeclaredClass* GetAsDeclaredClass() const;
    const CSchemaType_DeclaredEnum* GetAsDeclaredEnum() const;

    // @todo: @og: find out to what class pointer points.
    [[nodiscard]] CSchemaType* GetRefClass() const;

    [[nodiscard]] ETypeCategory GetTypeCategory() const {
#if defined(CS2) || defined(DOTA2) || defined(DEADLOCK)
        return m_unTypeCategory;
#else
        return Virtual::Get<ETypeCategory (*)(CSchemaType*)>(this, 0)(this);
#endif
    }

    [[nodiscard]] EAtomicCategory GetAtomicCategory() const {
#if defined(CS2) || defined(DOTA2) || defined(DEADLOCK)
        return m_unAtomicCategory;
#else
        return Virtual::Get<EAtomicCategory (*)(CSchemaType*)>(this, 1)(this);
#endif
    }

public:
    std::uintptr_t* vftable; // 0x0000
    const char* m_pszName; // 0x0008

    CSchemaSystemTypeScope* m_pTypeScope; // 0x0010

#if defined(CS2) || defined(DOTA2) || defined(DEADLOCK)
    ETypeCategory m_unTypeCategory; // 0x0018
    EAtomicCategory m_unAtomicCategory; // 0x0019
    IF_LINUX(char _pad_0x20[0x02];)
#endif
} IF_LINUX(__attribute__((packed)));

static_assert(offsetof(CSchemaType, m_pTypeScope) == 0x10);
static_assert(sizeof(CSchemaType) == platform_specific{.windows = 0x20, .linux = 0x1C});

class CSchemaType_Ptr : public CSchemaType {
public:
    CSchemaType* m_pObjectType;
};

/// @return For pointers/references, the type that is being pointed to
[[nodiscard]] inline CSchemaType* CSchemaType::GetRefClass() const {
    if (GetTypeCategory() != ETypeCategory::Schema_Ptr)
        return nullptr;

    auto ptr = reinterpret_cast<const CSchemaType_Ptr*>(this)->m_pObjectType;
    while (ptr && ptr->GetTypeCategory() == ETypeCategory::Schema_Ptr)
        ptr = reinterpret_cast<const CSchemaType_Ptr*>(ptr)->m_pObjectType;

    return ptr;
}

using CSchemaType_NoschemaType = CSchemaType;

class CSchemaType_Builtin : public CSchemaType {
public:
    SchemaBuiltinType_t m_eBuiltinType;
    std::uint8_t m_unSize;
    IF_LINUX(char _pad_0x24[0x04];)
};

static_assert(offsetof(CSchemaType_Builtin, m_eBuiltinType) == platform_specific{.windows = 0x20, .linux = 0x1c});
static_assert(offsetof(CSchemaType_Builtin, m_unSize) == platform_specific{.windows = 0x24, .linux = 0x20});
static_assert(sizeof(CSchemaType_Builtin) == 0x28);

class CSchemaType_DeclaredClass : public CSchemaType {
public:
    /// never @ref nullptr
    CSchemaClassInfo* m_pClassInfo;
    bool m_bGlobalPromotionRequired;
};

static_assert(offsetof(CSchemaType_DeclaredClass, m_pClassInfo) == 0x20);
static_assert(sizeof(CSchemaType_DeclaredClass) == 0x30);

class CSchemaType_DeclaredEnum : public CSchemaType {
public:
    CSchemaEnumBinding* m_pClassInfo;
    bool m_bGlobalPromotionRequired;
};

struct SchemaAtomicTypeInfo_t {
    const char* m_pszName1;
    const char* m_pszName2;

    int m_nAtomicID;

    int m_nStaticMetadataCount;
    SchemaMetadataEntryData_t* m_pStaticMetadata;
};

class CSchemaType_Atomic : public CSchemaType {
public:
    SchemaAtomicTypeInfo_t* m_pAtomicInfo;
    int m_nAtomicID;
    std::uint16_t m_unSize;
    std::uint8_t m_unAlignment;
};

class CSchemaType_Atomic_T : public CSchemaType_Atomic {
public:
    CSchemaType* m_pTemplateType;
};

enum class SchemaAtomicFunctionIndex : std::int32_t {
    Schema_Atomic_Get_Count = 0,
    Schema_Atomic_Get_Element_Const,
    Schema_Atomic_Get_Element,
    Schema_Atomic_Swap_Elements,
    Schema_Atomic_Insert_Before,
    Schema_Atomic_Remove_Multiple,
    Schema_Atomic_Set_Count,
};

using SchemaAtomicFunction = void (*)(SchemaAtomicFunctionIndex, void*, void*, void*);

class CSchemaType_Atomic_CollectionOfT : public CSchemaType_Atomic_T {
public:
    SchemaAtomicFunction m_pFn;
    std::uint16_t m_unElementSize;
};

static_assert(offsetof(CSchemaType_Atomic_CollectionOfT, m_pFn) == 0x38);

class CSchemaType_Atomic_TF : public CSchemaType_Atomic_T {
public:
    int m_nFuncPtrSize;
};

class CSchemaType_Atomic_TT : public CSchemaType_Atomic_T {
public:
    CSchemaType* m_pTemplateType2;
};

class CSchemaType_Atomic_TTF : public CSchemaType_Atomic_TT {
public:
    int m_nFuncPtrSize;
};

class CSchemaType_Atomic_I : public CSchemaType_Atomic {
public:
    int m_nInteger;
};

class CSchemaType_Bitfield : public CSchemaType {
public:
    int m_nSize;
};

class CSchemaType_FixedArray : public CSchemaType {
public:
    int m_nElementCount;
    std::uint16_t m_unElementSize;
    std::uint8_t m_unElementAlignment;
    CSchemaType* m_pElementType;
};

inline const CSchemaType_DeclaredClass* CSchemaType::GetAsDeclaredClass() const {
    if (GetTypeCategory() == ETypeCategory::Schema_DeclaredClass) {
        return static_cast<const CSchemaType_DeclaredClass*>(this);
    } else {
        return nullptr;
    }
}

inline const CSchemaType_DeclaredEnum* CSchemaType::GetAsDeclaredEnum() const {
    if (GetTypeCategory() == ETypeCategory::Schema_DeclaredEnum) {
        return static_cast<const CSchemaType_DeclaredEnum*>(this);
    } else {
        return nullptr;
    }
}

struct AtomicTypeInfo_T_t {
    int m_nAtomicID;
    CSchemaType* m_pTemplateType;
    SchemaAtomicFunction m_pfnManipulator;
};

struct AtomicTypeInfo_TF_t {
    int m_nAtomicID;
    CSchemaType* m_pTemplateType;
    int m_nFuncPtrSize;
};

struct AtomicTypeInfo_TT_t {
    int m_nAtomicID;
    CSchemaType* m_pTemplateType;
    CSchemaType* m_pTemplateType2;
};

struct AtomicTypeInfo_TTF_t {
    int m_nAtomicID;
    CSchemaType* m_pTemplateType;
    CSchemaType* m_pTemplateType2;
    int m_nFuncPtrSize;
};

struct AtomicTypeInfo_I_t {
    int m_nAtomicID;
    int m_nInteger;
};

struct SchemaClassFieldData_t {
    const char* m_pszName; // 0x0000
    CSchemaType* m_pSchemaType; // 0x0008
    std::int32_t m_nSingleInheritanceOffset; // 0x0010
    std::int32_t m_nMetadataSize; // 0x0014
    SchemaMetadataEntryData_t* m_pMetadata; // 0x0018
};

static_assert(sizeof(SchemaClassFieldData_t) == 0x20);

struct SchemaStaticFieldData_t {
    const char* m_pszName; // 0x0000
    CSchemaType* m_pSchemaType; // 0x0008
    void* m_pInstance; // 0x0010
    int m_nStaticMetadataCount; // 0x0018
    SchemaMetadataEntryData_t* m_pStaticMetadata; // 0x0020
};

struct SchemaBaseClassInfoData_t {
    std::uint32_t m_unOffset; // 0x0000
    CSchemaClassInfo* m_pClass; // 0x0008
};

using SchemaFieldMetadataOverrideSetData_t = datamap_t;
using SchemaFieldMetadataOverrideData_t = typedescription_t;

struct SchemaClassInfoData_t {
public:
    enum class SchemaClassInfoFunctionIndex : std::int32_t {
        kRegisterClassSchema = 0,
        kPreRegisterClassSchema = 1,
        kCopyInstance = 2,
        kCreateInstance = 3,
        kDestroyInstance = 4,
        kCreateInstanceWithMemory = 5,
        kDestroyInstanceWithMemory = 6,
        kSchemaDynamicBinding = 7
    };

public:
    SchemaClassInfoData_t* m_pSelf; // 0x0000
    const char* m_pszName; // 0x0008
    const char* m_pszModule; // 0x0010

    int m_nSizeOf; // 0x0018

    std::int16_t m_nFieldSize; // 0x001C

    std::int16_t m_nStaticMetadataSize; // 0x0020
    std::uint8_t m_unAlignOf; // 0x0022

    std::int8_t m_nBaseClassSize; // 0x0023

    // @note: @og: if there is no derived or base class, then it will be 1 otherwise derived class size + 1.
    std::int16_t m_nMultipleInheritanceDepth; // 0x0024
    std::int16_t m_nSingleInheritanceDepth; // 0x0026

    SchemaClassFieldData_t* m_pFields; // 0x0028

    SchemaBaseClassInfoData_t* m_pBaseClasses; // 0x0038
    SchemaFieldMetadataOverrideSetData_t* m_pFieldMetadataOverrides; // 0x0040
    SchemaMetadataEntryData_t* m_pStaticMetadata; // 0x0048
    CSchemaSystemTypeScope* m_pTypeScope; // 0x0050

    CSchemaType* m_pSchemaType; // 0x0058
    SchemaClassFlags_t m_nClassFlags:32; // 0x0060

    std::uint32_t m_unSequence; // 0x0064 // @note: @og: idk
    void* m_pFn; // 0x0068

public:
    template <typename RetTy = void*, typename... Ty>
    [[nodiscard]] RetTy CallFunction(SchemaClassInfoFunctionIndex index, Ty... args) const {
        return reinterpret_cast<RetTy (*)(SchemaClassInfoFunctionIndex, Ty...)>(m_pFn)(index, std::forward<Ty>(args)...);
    }
};

static_assert(offsetof(SchemaClassInfoData_t, m_pFn) == 0x60, "Offset of m_pFn should be 0x60");

class CSchemaClassInfo : public SchemaClassInfoData_t {
public:
    [[nodiscard]] std::string_view GetName() const {
        if (m_pszName)
            return {m_pszName};
        return {};
    }

    [[nodiscard]] std::string_view GetModule() const {
        if (m_pszModule)
            return {m_pszModule};
        return {};
    }

    [[nodiscard]] std::optional<CSchemaClassInfo*> GetBaseClass() const {
        if (m_nBaseClassSize && m_pBaseClasses)
            return m_pBaseClasses->m_pClass;
        return std::nullopt;
    }

    // TODO: when we have AddressSanitizer, try returning std::span instead of std::vector. Repeats for other functions.
    [[nodiscard]] std::vector<SchemaClassFieldData_t> GetFields() const {
        return {m_pFields, m_pFields + m_nFieldSize};
    }

    [[nodiscard]] std::vector<SchemaMetadataEntryData_t> GetStaticMetadata() const {
        return {m_pStaticMetadata, m_pStaticMetadata + m_nStaticMetadataSize};
    }

    [[nodiscard]] std::string_view GetPrevClassName() const {
        if (!m_pBaseClasses || !m_pBaseClasses->m_pClass)
            return {};
        return m_pBaseClasses->m_pClass->GetName();
    }

    [[nodiscard]] bool IsA(CSchemaType* pInheritance) const {
        if (!m_pSchemaType)
            return false;

        return m_pSchemaType->IsA(pInheritance);
    }

    [[nodiscard]] bool HasVirtualTable() const {
        return (m_nClassFlags & SCHEMA_CF1_HAS_VIRTUAL_MEMBERS) != 0;
    }

    [[nodiscard]] bool RecursiveHasVirtualTable() const {
        return HasVirtualTable() || (m_pBaseClasses && m_pBaseClasses->m_pClass && m_pBaseClasses->m_pClass->HasVirtualTable());
    }

    [[nodiscard]] bool IsInherits(const std::string_view from) const {
        if (!m_nBaseClassSize || !m_pBaseClasses || !m_pBaseClasses->m_pClass)
            return false;
        if (m_pBaseClasses->m_pClass->GetName() == from)
            return true;
        return false;
    }

    [[nodiscard]] bool IsRecursiveInherits(const std::string_view from) const {
        return IsInherits(from) || (m_pBaseClasses && m_pBaseClasses->m_pClass && m_pBaseClasses->m_pClass->IsRecursiveInherits(from));
    }

    [[nodiscard]] int GetSize() const {
        return m_nSizeOf;
    }

    /// @return Alignment as registered in the game
    [[nodiscard]] std::optional<int> GetRegisteredAlignment() const {
        return m_unAlignOf == std::numeric_limits<std::uint8_t>::max() ? std::nullopt : std::make_optional(static_cast<int>(m_unAlignOf));
    }

    // @note: @og: Copy instance from original to new created with all data from original, returns new_instance
    auto CopyInstance(void* instance, void* new_instance) const {
        return CallFunction<void*>(SchemaClassInfoFunctionIndex::kCreateInstance, instance, new_instance);
    }

    // @note: @og: Creates default instance with engine allocated memory (e.g. if SchemaClassInfoData_t is C_BaseEntity, then Instance will be
    // C_BaseEntity)
    [[nodiscard]] auto CreateInstance() const {
        return CallFunction<void*>(SchemaClassInfoFunctionIndex::kCreateInstance);
    }

    // @note: @og: Creates default instance with your own allocated memory (e.g. if SchemaClassInfoData_t is C_BaseEntity, then Instance will be
    // C_BaseEntity)
    auto CreateInstance(void* memory) const {
        return CallFunction<void*>(SchemaClassInfoFunctionIndex::kCreateInstanceWithMemory, memory);
    }

    // @note: @og: Destroy instance (e.g.: C_BaseEntity 1st VT fn with 0 flag)
    auto DestroyInstance(void* instance) const {
        return CallFunction<void*>(SchemaClassInfoFunctionIndex::kDestroyInstanceWithMemory, instance);
    }

    // @note: @og: Destroy instance with de-allocating memory (e.g.: C_BaseEntity 1st VT fn with 1 flag)
    auto DestroyInstanceWithMemory(void* instance) const {
        return CallFunction<void*>(SchemaClassInfoFunctionIndex::kDestroyInstanceWithMemory, instance);
    }

    [[nodiscard]] auto SchemaClassBinding(void* entity) const {
        return CallFunction<CSchemaClassBinding*>(SchemaClassInfoFunctionIndex::kSchemaDynamicBinding, entity);
    }
};

struct TypeAndCountInfo_t {
    int m_nElementCount;
    CSchemaType* m_pElementType;
};

template <class K, class V>
class CSchemaPtrMap {
public:
    CUtlMap<K, V> m_Map;

#if TARGET_OS == LINUX
    char pad_0x28[0x08];
#endif

#if !defined(DOTA2) && !defined(CS2) && !defined(DEADLOCK)
    CThreadFastMutex m_Mutex;
#endif
};

#if defined(DOTA2) || defined(CS2) || defined(DEADLOCK)
static_assert(sizeof(CSchemaPtrMap<int, int>) == platform_specific{.windows = 0x28, .linux = 0x30}.get());
#else
static_assert(sizeof(CSchemaPtrMap<int, int>) == platform_specific{.windows = 0x30, .linux = 0x30}.get());
#endif

class CSchemaSystemTypeScope {
public:
    void* InsertNewClassBinding(const std::string_view szName, void* a2) {
        assert((std::strlen(szName.data()) == szName.size()) && "need a zero-terminated string");

        return Virtual::Get<void* (*)(CSchemaSystemTypeScope*, const char*, void*)>(this, 0)(this, szName.data(), a2);
    }

    void* InsertNewEnumBinding(const std::string_view szName, void* a2) {
        assert((std::strlen(szName.data()) == szName.size()) && "need a zero-terminated string");

        return Virtual::Get<void* (*)(CSchemaSystemTypeScope*, const char*, void*)>(this, 1)(this, szName.data(), a2);
    }

    [[nodiscard]] CSchemaClassInfo* FindDeclaredClass(const std::string_view szName) const {
        assert((std::strlen(szName.data()) == szName.size()) && "need a zero-terminated string");

        if constexpr (kSchemaSystemVersion == 2) {
            CSchemaClassInfo* class_info;

            Virtual::Get<void(__thiscall*)(const void*, CSchemaClassInfo**, const char*)>(this, 2)(this, &class_info, szName.data());
            return class_info;
        } else {
            return Virtual::Get<CSchemaClassInfo*(__thiscall*)(const void*, const char*)>(this, 2)(this, szName.data());
        }
    }

    [[nodiscard]] CSchemaEnumInfo* FindDeclaredEnum(const std::string_view szName) const {
        assert((std::strlen(szName.data()) == szName.size()) && "need a zero-terminated string");

        if constexpr (kSchemaSystemVersion == 2) {
            CSchemaEnumInfo* enum_info;

            Virtual::Get<void(__thiscall*)(const void*, CSchemaEnumInfo**, const char*)>(this, 3)(this, &enum_info, szName.data());
            return enum_info;
        } else {
            return Virtual::Get<CSchemaEnumInfo*(__thiscall*)(const void*, const char*)>(this, 3)(this, szName.data());
        }
    }

    [[nodiscard]] CSchemaType* FindSchemaTypeByName(const std::string_view szName) {
        assert((std::strlen(szName.data()) == szName.size()) && "need a zero-terminated string");

        if constexpr (kSchemaSystemVersion == 2) {
            CSchemaType* schema_type;

            Virtual::Get<void(__thiscall*)(void*, CSchemaType**, const char*)>(this, 4)(this, &schema_type, szName.data());
            return schema_type;
        } else {
            return Virtual::Get<CSchemaType*(__thiscall*)(void*, const char*)>(this, 4)(this, szName.data());
        }
    }

    [[nodiscard]] CSchemaType_Builtin* Type_Builtin(const SchemaBuiltinType_t type) {
        if constexpr (kSchemaSystemVersion == 2) {
            CSchemaType_Builtin* type_builtin;

            Virtual::Get<void(__thiscall*)(void*, CSchemaType_Builtin**, SchemaBuiltinType_t)>(this, 5)(this, &type_builtin, type);
            return type_builtin;
        } else {
            return Virtual::Get<CSchemaType_Builtin*(__thiscall*)(void*, SchemaBuiltinType_t)>(this, 5)(this, type);
        }
    }

    [[nodiscard]] CSchemaType_DeclaredClass* Type_DeclaredClass(const std::string_view szName) {
        if constexpr (kSchemaSystemVersion == 2) {
            CSchemaType_DeclaredClass* declared_class;

            Virtual::Get<void(__thiscall*)(void*, CSchemaType_DeclaredClass**, const char*)>(this, kSchemaSystemTypeScope_DeclaredClass)(
                this, &declared_class, szName.data());

            return declared_class;
        } else {
            return Virtual::Get<CSchemaType_DeclaredClass*(__thiscall*)(void*, const char*)>(this, kSchemaSystemTypeScope_DeclaredClass)(this,
                                                                                                                                         szName.data());
        }
    }

    [[nodiscard]] CSchemaType_DeclaredEnum* Type_DeclaredEnum(const std::string_view szName) {
        if constexpr (kSchemaSystemVersion == 2) {
            CSchemaType_DeclaredEnum* declared_class;

            Virtual::Get<void(__thiscall*)(void*, CSchemaType_DeclaredEnum**, const char*)>(this, kSchemaSystemTypeScope_DeclaredEnum)(
                this, &declared_class, szName.data());

            return declared_class;
        } else {
            return Virtual::Get<CSchemaType_DeclaredEnum*(__thiscall*)(void*, const char*)>(this, kSchemaSystemTypeScope_DeclaredEnum)(this,
                                                                                                                                       szName.data());
        }
    }

    [[nodiscard]] const char* GetScopeName() {
        return Virtual::Get<const char*(__thiscall*)(void*)>(this, kSchemaSystemTypeScope_GetScopeName)(this);
    }

    [[nodiscard]] bool IsGlobalScope() {
        return Virtual::Get<bool(__thiscall*)(void*)>(this, kSchemaSystemTypeScope_IsGlobalScope)(this);
    }

    [[nodiscard]] std::string BGetScopeName() const {
        return m_szName.data();
    }

    [[nodiscard]] CUtlTSHash<CSchemaClassBinding*> GetClassBindings() const {
        return m_ClassBindings;
    }

    [[nodiscard]] CUtlTSHash<CSchemaEnumBinding*> GetEnumBindings() const {
        return m_EnumBindings;
    }

    [[nodiscard]] CUtlMap<std::uint16_t, CSchemaType_DeclaredClass*>& GetDeclaredClasses() {
        return m_DeclaredClasses.m_Map;
    }

    [[nodiscard]] CUtlMap<std::uint16_t, CSchemaType_DeclaredEnum*>& GetDeclaredEnums() {
        return m_DeclaredEnums.m_Map;
    }

private:
    void* vftable = nullptr;
    std::array<char, 256> m_szName = {}; // 0x0008
    CSchemaSystemTypeScope* m_pGlobalTypeScope = nullptr; // 0x0108
    bool m_bBuiltinTypesInitialized = false; // 0x0110
    IF_LINUX(char _pad_0x114[0x04];)
    std::array<CSchemaType_Builtin, kSchemaBuiltinTypeCount> m_BuiltinTypes = {}; // 0x0118
    CSchemaPtrMap<CSchemaType*, CSchemaType_Ptr*> m_Ptrs; // 0x0348
    CSchemaPtrMap<int, CSchemaType_Atomic*> m_Atomics; // 0x0378
    CSchemaPtrMap<AtomicTypeInfo_T_t, CSchemaType_Atomic_T*> m_AtomicsT; // 0x03A8
    CSchemaPtrMap<AtomicTypeInfo_T_t, CSchemaType_Atomic_CollectionOfT*> m_AtomicsCollectionOfT; // 0x03D8

#if defined(CS2_OLD)
    CSchemaPtrMap<AtomicTypeInfo_TF_t, CSchemaType_Atomic_TF*> m_AtomicsTF; // 0x0408
#endif

    CSchemaPtrMap<AtomicTypeInfo_TT_t, CSchemaType_Atomic_TT*> m_AtomicsTT; // 0x0438

#if defined(CS2_OLD)
    CSchemaPtrMap<AtomicTypeInfo_TTF_t, CSchemaType_Atomic_TTF*> m_AtomicsTTF; // 0x0468
#endif

    CSchemaPtrMap<AtomicTypeInfo_I_t, CSchemaType_Atomic_I*> m_AtomicsI; // 0x0498
    CSchemaPtrMap<std::uint16_t, CSchemaType_DeclaredClass*> m_DeclaredClasses; // 0x04C8
    CSchemaPtrMap<std::uint16_t, CSchemaType_DeclaredEnum*> m_DeclaredEnums; // 0x04F8
    CSchemaPtrMap<int, const SchemaAtomicTypeInfo_t*> m_AtomicInfos; // 0x0528
    CSchemaPtrMap<TypeAndCountInfo_t, CSchemaType_FixedArray*> m_FixedArrays; // 0x0558
    CSchemaPtrMap<int, CSchemaType_Bitfield*> m_Bitfields; // 0x0588

#if !defined(DOTA2) && !defined(CS2) && !defined(DEADLOCK)
    CSchemaType_NoschemaType m_pNoschemaType = {};
#endif

    CUtlTSHash<CSchemaClassBinding*> m_ClassBindings = {}; // 0x05C0
    CUtlTSHash<CSchemaEnumBinding*> m_EnumBindings = {}; // 0x2E50
};

enum SchemaTypeScope_t : std::uint8_t {
    SCHEMA_TYPESCOPE_GLOBAL = 0,
    SCHEMA_TYPESCOPE_LOCAL,
    SCHEMA_TYPESCOPE_DEFAULT,
};

class CSchemaSystem {
public:
    [[nodiscard]] CSchemaSystemTypeScope* GlobalTypeScope() {
        return Virtual::Get<CSchemaSystemTypeScope*(__thiscall*)(void*)>(this, 11)(this);
    }

    [[nodiscard]] CSchemaSystemTypeScope* FindTypeScopeForModule(const std::string_view pszModuleName) {
        return Virtual::Get<CSchemaSystemTypeScope*(__thiscall*)(void*, const char*, void*)>(this, 13)(this, pszModuleName.data(), nullptr);
    }

    [[nodiscard]] CSchemaSystemTypeScope* GetTypeScopeForBinding(const SchemaTypeScope_t nType, const std::string_view pszBinding) {
        return Virtual::Get<CSchemaSystemTypeScope*(__thiscall*)(void*, SchemaTypeScope_t, const char*)>(this, 14)(this, nType, pszBinding.data());
    }

    // @note: @og: E.g: engine2.dll!CEntityComponent
    [[nodiscard]] CSchemaClassBinding* FindClassByScopedName(const std::string_view pszScopedName) {
        if constexpr (kSchemaSystemVersion == 2) {
            CSchemaClassBinding* binding;

            Virtual::Get<void(__thiscall*)(void*, CSchemaClassBinding**, const char*)>(this, 16)(this, &binding, pszScopedName.data());
            return binding;
        } else {
            return Virtual::Get<CSchemaClassBinding*(__thiscall*)(void*, const char*)>(this, 16)(this, pszScopedName.data());
        }
    }

    [[nodiscard]] std::string ScopedNameForClass(const CSchemaClassBinding* pBinding) {
        static CBufferStringGrowable<1024> szBuf;
        Virtual::Get<const char*(__thiscall*)(void*, const CSchemaClassBinding*, CBufferString*)>(this, 17)(this, pBinding, &szBuf);
        return szBuf.Get();
    }

    // @note: @og: E.g: engine2.dll!SpawnDebugRestrictionOverrideState_t
    [[nodiscard]] CSchemaEnumBinding* FindEnumByScopedName(const std::string_view pszScopedName) {
        if constexpr (kSchemaSystemVersion == 2) {
            CSchemaEnumBinding* binding;

            Virtual::Get<void(__thiscall*)(void*, CSchemaEnumBinding**, const char*)>(this, 18)(this, &binding, pszScopedName.data());
            return binding;
        } else {
            return Virtual::Get<CSchemaEnumBinding*(__thiscall*)(void*, const char*)>(this, 18)(this, pszScopedName.data());
        }
    }

    [[nodiscard]] std::string ScopedNameForEnum(CSchemaEnumBinding* pBinding) {
        static CBufferStringGrowable<1024> szBuf;
        Virtual::Get<const char*(__thiscall*)(void*, CSchemaEnumBinding*, CBufferString*)>(this, 19)(this, pBinding, &szBuf);
        return szBuf.Get();
    }

    [[nodiscard]] const char* GetClassInfoBinaryName(CSchemaClassBinding* pBinding) {
        return Virtual::Get<const char*(__thiscall*)(void*, CSchemaClassBinding*)>(this, kSchemaSystem_GetClassInfoBinaryName)(this, pBinding);
    }

    [[nodiscard]] const char* GetClassModuleName(CSchemaClassBinding* pBinding) {
        // Returns pBinding->m_pszModule
        return Virtual::Get<const char*(__thiscall*)(void*, CSchemaClassBinding*)>(this, kSchemaSystem_GetClassModuleName)(this, pBinding);
    }

    [[nodiscard]] const char* GetEnumBinaryName(CSchemaEnumBinding* pBinding) {
        return Virtual::Get<const char*(__thiscall*)(void*, CSchemaEnumBinding*)>(this, kSchemaSystem_GetEnumBinaryName)(this, pBinding);
    }

    [[nodiscard]] const char* GetEnumProjectName(const CSchemaEnumBinding* pBinding) {
        return Virtual::Get<const char*(__thiscall*)(void*, const CSchemaEnumBinding*)>(this, kSchemaSystem_GetEnumProjectName)(this, pBinding);
    }

    CSchemaClassBinding* ValidateClasses(CSchemaClassBinding** ppBinding) {
        return Virtual::Get<CSchemaClassBinding*(__thiscall*)(void*, CSchemaClassBinding**)>(this, kSchemaSystem_ValidateClasses)(this, ppBinding);
    }

    void PrintSchemaStats() {
        Virtual::Get<void(__thiscall*)(void*)>(this, 30)(this);
    }

    // @note: @og: there 2 options, "enum" or "class"
    void PrintSchemaMetaStats(const char* pszOptions) {
        Virtual::Get<void(__thiscall*)(void*, const char*)>(this, 31)(this, pszOptions);
    }

    [[nodiscard]] CUtlVector<CSchemaSystemTypeScope*> GetTypeScopes() const {
        return m_TypeScopes;
    }

    [[nodiscard]] std::int32_t GetRegistration() const {
        return m_nRegistrations;
    }

    [[nodiscard]] std::int32_t GetIgnored() const {
        return m_nIgnored;
    }

    [[nodiscard]] std::int32_t GetRedundant() const {
        return m_nRedundant;
    }

    [[nodiscard]] std::size_t GetIgnoredBytes() const {
        return m_nIgnoredBytes;
    }

private:
    char pad_0x0000[kSchemaSystem_PAD0] = {}; // 0x0000
    CUtlVector<CSchemaSystemTypeScope*> m_TypeScopes = {}; // linux: 0x01F0
    char pad_0x01A0[kSchemaSystem_PAD1] = {}; // 0x01A0
    std::int32_t m_nRegistrations = 0; // 0x02C0
    std::int32_t m_nIgnored = 0; // 0x02C4
    std::int32_t m_nRedundant = 0; // 0x02C8
    std::size_t m_nIgnoredBytes = 0; // 0x02CC

public:
    [[nodiscard]] static CSchemaSystem* GetInstance() {
        return sdk::GetInterface<CSchemaSystem>(loader::get_module_file_name("schemasystem").c_str(), "SchemaSystem_0");
    }
};

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/interfaces/tier0/IMemAlloc.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4191)
#endif

#include "tools/platform.h"
#include "tools/virtual.h"
#include <cstddef>

class IMemAlloc {
public:
    void* Alloc(std::size_t nSize) {
        return Virtual::Get<void*(__thiscall*)(IMemAlloc*, std::size_t)>(this, platform_specific{.windows = 1, .linux = 2})(this, nSize);
    }

    void* AllocAligned(std::size_t nSize, std::size_t nAlign);

    void* Realloc(void* pMemory, std::size_t nSize) {
        return Virtual::Get<void*(__thiscall*)(IMemAlloc*, void*, std::size_t)>(this, platform_specific{.windows = 2, .linux = 3})(this, pMemory, nSize);
    }

    void* ReallocAligned(void* pMemory, std::size_t nSize, std::size_t nAlign);

    void* Calloc(std::size_t nNum, std::size_t nSize);

    void Free(void* pMemory) {
        return Virtual::Get<void(__thiscall*)(IMemAlloc*, void*)>(this, platform_specific{.windows = 3, .linux = 4})(this, pMemory);
    }

    void FreeAligned(void* pMemory);

    [[nodiscard]] std::size_t GetSizeAligned(void* pMemory);

    [[nodiscard]] std::size_t GetSize(void* pMemory) {
        return Virtual::Get<std::size_t(__thiscall*)(IMemAlloc*, void*)>(this, platform_specific{.windows = 17, .linux = 18})(this, pMemory);
    }
};

extern IMemAlloc* GetMemAlloc();

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/sdk/sdk.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include <sdk/interfaces/schemasystem/schema.h>

#include "options.hpp"
#include <filesystem>
#include <map>
#include <sdk/interfaceregs.h>
#include <sdk/interfaces/client/game/datamap_t.h>
#include <sdk/interfaces/schemasystem/schema.h>
#include <string>
#include <unordered_set>

namespace sdk {
    inline CSchemaSystem* g_schema = nullptr;

    /// Unique identifier for a type in the source2 engine
    struct TypeIdentifier {
        std::string module{};
        std::string name{};

        auto operator<=>(const TypeIdentifier&) const = default;
    };

    /// Stores results of expensive function calls, like those that recurse through classes.
    struct GeneratorCache {
        /// Key is {module,class}
        /// If an entry exists for a class, but its value is @ref std::nullopt, we have already tried finding its alignment but couldn't figure it out.
        std::map<TypeIdentifier, std::optional<int>> class_alignment{};
        /// Key is {module,class}
        std::map<TypeIdentifier, bool> class_has_standard_layout{};
    };

    // Wrapping the file list in a struct in case we need to return more properties in the future
    struct GeneratorResult {
        /// All generated files
        std::unordered_set<std::filesystem::path> generated_files{};
    };

    GeneratorResult GenerateTypeScopeSdk(const source2_gen::Options& options, GeneratorCache& cache, std::string_view module_name,
                                         const std::unordered_set<const CSchemaEnumBinding*>& enums,
                                         const std::unordered_set<const CSchemaClassBinding*>& classes);
} // namespace sdk

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/codegen/c.h`:

```h
#pragma once

#include "codegen.h"
#include "detail/c_family.h"
#include "tools/fnv.h"
#include <absl/strings/str_join.h>
#include <absl/strings/str_split.h>
#include <cassert>
#include <list>
#include <set>
#include <sstream>

namespace codegen {
    struct generator_c_t final : public IGenerator {
        std::string get_uint(std::size_t bits_count) const override {
            return detail::c_family::get_uint(bits_count);
        }

        std::optional<std::string> find_built_in(std::string_view source_name) const override {
            const auto found =
                std::ranges::find(detail::c_family::kNumericTypes, source_name, &decltype(detail::c_family::kNumericTypes)::value_type::first);

            if (found != detail::c_family::kNumericTypes.end()) {
                return std::string{found->second};
            } else {
                return std::nullopt;
            }
        }

        std::string get_file_extension() const override {
            return "h";
        }

        std::string escape_type_name(std::string_view name) const override {
            return detail::c_family::escape_name(name);
        }

        self_ref preamble() override {
            push_line("#pragma once");
            push_line("");
            include("source2sdk/source2gen/source2gen", IncludeOptions{.local = true, .system = false});
            include("stdbool", IncludeOptions{.local = false, .system = true});
            include("stddef", IncludeOptions{.local = false, .system = true});
            include("stdint", IncludeOptions{.local = false, .system = true});

            return *this;
        }

        self_ref include(std::string_view module_or_file_name, IncludeOptions options) override {
            const auto open_bracket = options.local ? '"' : '<';
            const auto close_bracket = options.local ? '"' : '>';
            // ignore options.system because C system headers have file extensions
            const auto maybe_file_extension = ("." + get_file_extension());

            return push_line(std::format("#include {}{}{}{}", open_bracket, module_or_file_name, maybe_file_extension, close_bracket));
        }

        self_ref pack_push(const std::size_t alignment) override {
            return push_line(std::format("#pragma pack(push, {})", alignment));
        }

        self_ref pack_pop() override {
            return push_line("#pragma pack(pop)");
        }

        self_ref next_line() override {
            return push_line("");
        }

        // @todo: @es3n1n: `self_ref prev_line()`

        self_ref access_modifier([[maybe_unused]] const std::string& modifier) override {
            return *this;
        }

        self_ref begin_class(const std::string& class_name, const std::string& access_modifier = "public") override {
            return begin_struct(class_name, access_modifier);
        }

        self_ref begin_class_with_base_type(const std::string& class_name, const std::string& base_type,
                                            const std::string& access_modifier = "public") override {
            return begin_struct_with_base_type(class_name, base_type, access_modifier);
        }

        self_ref end_class() override {
            return end_struct();
        }

        self_ref begin_struct(std::string_view name, [[maybe_unused]] const std::string& access_modifier = "public") override {
            assert(!_current_class_or_enum.has_value() && "nested types are not supported");
            _current_class_or_enum = name;

            // calling encode_current_namespace() here is not ideal because the
            // user has no way of knowing (other than reassembling) what the
            // generated type is actually called in case they want to refer to
            // it later.
            return begin_block(std::format("struct {}", encode_current_namespace(detail::c_family::escape_name(name))));
        }

        self_ref begin_struct_with_base_type(const std::string& name, const std::string& base_type,
                                             [[maybe_unused]] const std::string& access_modifier = "public") override {
            assert(!base_type.empty() && "use begin_struct() for structs with no base type");
            assert(!_current_class_or_enum.has_value() && "nested types are not supported");

            _current_class_or_enum = name;

            begin_block(std::format("struct {}", encode_current_namespace(detail::c_family::escape_name(name))));
            return prop(Prop{.type_category = TypeCategory::class_or_struct, .type_name = base_type, .name = "base"});
        }

        self_ref end_struct() override {
            assert(_current_class_or_enum.has_value() && "called end_struct() without calling begin_struct()");

            if (!_current_struct_has_properties) {
                comment("This is an empty struct. There is no data in this struct. A pad has been generated for compliance with C.");
                prop(Prop{.type_name = "char", .name = "pad_do_not_access"}, true);
            }

            end_block();

            _current_class_or_enum = std::nullopt;
            _current_struct_has_properties = false;

            return *this;
        }

        self_ref begin_namespace(std::string_view namespace_name) override {
            _namespaces.emplace_back(namespace_name);
            comment(std::format("namespace {}", namespace_name));
            return comment("{");
        }

        self_ref end_namespace() override {
            _namespaces.pop_back();
            // This semicolon is unnecessary. We're keeping it for consistency
            // with the cpp generator, where it's also unnecessary, but not as
            // easy to remove.
            comment("};");
            return push_line("");
        }

        self_ref begin_enum(const std::string& enum_name, const std::string& base_typename = "") override {
            assert(!_current_class_or_enum.has_value() && "nested types are not supported");
            _current_class_or_enum = enum_name;
            return begin_block(std::format("enum {}{}", encode_current_namespace(detail::c_family::escape_name(enum_name)),
                                           base_typename.empty() ? base_typename : (" : " + base_typename)));
        }

        self_ref end_enum() override {
            _current_class_or_enum = std::nullopt;
            return end_block();
        }

        self_ref enum_item(const std::string& name, std::uint64_t value) override {
            assert(_current_class_or_enum.has_value() && "called enum_item() without calling begin_enum_class()");

            return push_line(std::format("{}_{} = {:#x},", detail::c_family::escape_name(_current_class_or_enum.value()), name, value));
        }

        // @todo: @es3n1n: add func params
        self_ref begin_function(const std::string& prefix, const std::string& type_name, const std::string& func_name,
                                const bool increment_tabs_count = true, const bool move_cursor_to_next_line = true) override {
            return begin_block(std::format("{}{} {}()", prefix, type_name, detail::c_family::escape_name(func_name)), increment_tabs_count,
                               move_cursor_to_next_line);
        }

        self_ref end_function(const bool decrement_tabs_count = true, const bool move_cursor_to_next_line = true) override {
            return end_block(decrement_tabs_count, move_cursor_to_next_line);
        }

        self_ref return_value(const std::string& value, const bool move_cursor_to_next_line = true) override {
            return push_line(std::format("return {};", value), move_cursor_to_next_line);
        }

        self_ref static_field_getter([[maybe_unused]] const std::string& type_name, [[maybe_unused]] const std::string& prop_name,
                                     [[maybe_unused]] const std::string& mod_name, [[maybe_unused]] const std::string& decl_class,
                                     [[maybe_unused]] const std::size_t index) override {
            // not implemented
            return *this;
        }

        self_ref static_assert_size(std::string_view type_name, int expected_size, const bool move_cursor_to_next_line) override {
            assert(expected_size > 0);

            return push_line(std::format("static_assert(sizeof(struct {}) == {:#x});", detail::c_family::escape_name(type_name), expected_size),
                             move_cursor_to_next_line);
        }

        self_ref static_assert_offset(std::string_view class_name, std::string_view prop_name, int expected_offset,
                                      const bool move_cursor_to_next_line) override {
            assert(expected_offset >= 0);

            return push_line(std::format("static_assert(offsetof(struct {}, {}) == {:#x});", detail::c_family::escape_name(class_name),
                                         detail::c_family::escape_name(prop_name), expected_offset),
                             move_cursor_to_next_line);
        }

        self_ref comment(const std::string& text, const bool move_cursor_to_next_line = true) override {
            return push_line(std::format("// {}", text), move_cursor_to_next_line);
        }

        self_ref begin_multi_line_comment(const bool move_cursor_to_next_line = true) override {
            return push_line("/*", move_cursor_to_next_line);
        }

        self_ref end_multi_line_comment(const bool move_cursor_to_next_line = true) override {
            return push_line("*/", move_cursor_to_next_line);
        }

        self_ref prop(Prop prop, bool move_cursor_to_next_line = true) override {
            _current_struct_has_properties = true;

            const auto type_category_prefix = [&]() -> std::string_view {
                switch (prop.type_category) {
                    using enum TypeCategory;
                case built_in:
                    return "";
                case class_or_struct:
                    return "struct ";
                case union_:
                    return "union ";
                case enum_:
                    return "enum ";
                }
                return "";
            }();

            const auto line =
                std::format("{}{} {}{};{}", type_category_prefix, detail::c_family::escape_name(prop.type_name), detail::c_family::escape_name(prop.name),
                            prop.bitfield_size.has_value() ? std::format(": {}", prop.bitfield_size.value()) : "", move_cursor_to_next_line ? "" : " ");
            return push_line(line, move_cursor_to_next_line);
        }

        self_ref forward_declaration(const std::string& text) override {
            // @note: @es3n1n: forward decl only once
            const auto fwd_decl_hash = fnv32::hash_runtime(text.data());
            if (_forward_decls.contains(fwd_decl_hash))
                return *this;

            _forward_decls.insert(fwd_decl_hash);

            // @fixme: split method to class_forward_declaration & struct_forward_declaration
            // one for `struct uwu_t` and the other one for `class c_uwu`
            return push_line(std::format("struct {};", encode_current_namespace(detail::c_family::escape_name(text))));
        }

        self_ref struct_padding(Padding options, bool move_cursor_to_next_line) override {
            const auto is_bitfield = std::holds_alternative<Padding::Bits>(options.size);

            std::string type_name = is_bitfield ? detail::c_family::guess_bitfield_type(std::get<Padding::Bits>(options.size).value) : "uint8_t";

            auto pad_name =
                options.pad_offset.has_value() ? std::format("_pad{:04x}", options.pad_offset.value()) : std::format("_pad{:d}", _pads_count++);
            if (!is_bitfield)
                pad_name = pad_name + std::format("[{:#x}]", std::get<Padding::Bytes>(options.size).value);

            return prop(Prop{.type_name = type_name,
                             .name = pad_name,
                             .bitfield_size = is_bitfield ? std::make_optional(std::get<Padding::Bits>(options.size).value) : std::nullopt},
                        move_cursor_to_next_line);
        }

        self_ref begin_bitfield_block() override {
            return comment("start of bitfield block");
        }

        self_ref end_bitfield_block(const bool move_cursor_to_next_line = true) override {
            return comment("end of bitfield block", move_cursor_to_next_line);
        }

        self_ref restore_tabs_count() override {
            _tabs_count = _tabs_count_backup;
            return *this;
        }

        self_ref reset_tabs_count() override {
            _tabs_count_backup = _tabs_count;
            _tabs_count = 0;
            return *this;
        }

    public:
        [[nodiscard]] std::string str() const override {
            return _stream.str();
        }

    private:
        self_ref begin_block(const std::string& text, const bool increment_tabs_count = true, const bool move_cursor_to_next_line = true) {
            push_line(text, move_cursor_to_next_line);

            // @note: @es3n1n: we should reset tabs count if we aren't moving cursor to
            // the next line
            const auto backup_tabs_count = _tabs_count;
            if (!move_cursor_to_next_line)
                _tabs_count = 0;

            push_line("{", move_cursor_to_next_line);

            // @note: @es3n1n: restore tabs count
            if (!move_cursor_to_next_line)
                _tabs_count = backup_tabs_count;

            if (increment_tabs_count)
                inc_tabs_count(kTabsPerBlock);

            return *this;
        }

        self_ref end_block(const bool decrement_tabs_count = true, const bool move_cursor_to_next_line = true) {
            if (decrement_tabs_count)
                dec_tabs_count(kTabsPerBlock);

            push_line("};");
            if (move_cursor_to_next_line)
                next_line();

            return *this;
        }

        self_ref push_line(const std::string& line, bool move_cursor_to_next_line = true) {
            _stream << std::string(_tabs_count * kIndentWidth, kSpaceSym) // insert spaces
                    << line;

            if (move_cursor_to_next_line) {
                _stream << std::endl;
            }
            return *this;
        }

        [[nodiscard]]
        std::string encode_current_namespace(std::string_view name) {
            return absl::StrJoin(std::list{_namespaces, {std::string{name}}} | std::views::join, "_");
        }

        self_ref inc_tabs_count(const std::size_t count = 1) {
            _tabs_count_backup = _tabs_count;
            _tabs_count += count;
            return *this;
        }

        self_ref dec_tabs_count(const std::size_t count = 1) {
            _tabs_count_backup = _tabs_count;
            if (_tabs_count)
                _tabs_count -= count;
            return *this;
        }

    private:
        struct StaticField {
            std::string type_name{};
            std::string prop_name{};
            std::string mod_name{};
            std::string decl_class{};
            std::size_t index{};
        };

    private:
        std::stringstream _stream = {};
        std::size_t _tabs_count = 0, _tabs_count_backup = 0;
        std::size_t _pads_count = 0;
        std::optional<std::string> _current_class_or_enum{std::nullopt};
        bool _current_struct_has_properties = false;
        std::list<std::string> _namespaces{};
        std::set<fnv32::hash> _forward_decls = {};
    };
} // namespace codegen

```

`source2gen/include/tools/codegen/codegen.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <variant>

namespace codegen {
    constexpr char kSpaceSym = ' ';
    constexpr char kIndentWidth = 4;
    constexpr std::size_t kTabsPerBlock = 1; // @note: @es3n1n: how many (kSpaceSym * kIndentWidth) characters shall we place per each block

    /// used to add type specifier prefixes
    /// e.g. "struct" in "struct CBaseEntity entity;" for the C generator
    enum class TypeCategory {
        /// char, int, etc.
        built_in,
        class_or_struct,
        union_,
        enum_,
    };

    // Properties of this struct are not perfectly language-agnostic.
    // We encode array syntax in `name` for example.
    // That's dirty but keeps the design simple.
    struct Prop {
        /// most underlying type, e.g. a "struct**" is "struct"
        TypeCategory type_category{};
        /// fully qualified
        std::string type_name{};
        std::string name{};
        std::optional<size_t> bitfield_size{};
    };

    struct Padding {
        struct Bytes {
            std::size_t value{};
        };
        struct Bits {
            std::size_t value{};
        };

        /**
         * May be @ref std::nullopt in unions
         */
        std::optional<std::ptrdiff_t> pad_offset{};
        std::variant<Bytes, Bits> size;
    };

    struct IncludeOptions {
        /**
         * Treat the included file as a local file, e.g. in C++ use quoatation marks for includes.
         */
        bool local{false};

        /**
         * Treat the included file as a system file, e.g. in C++ don't add a file extension.
         */
        bool system{false};
    };

    struct IGenerator {
        using self_ref = IGenerator&;

        /**
         * The fully qualified type name of the (unsigned) integer type with the given width.
         */
        virtual std::string get_uint(std::size_t bits_count) const = 0;

        /**
         * Maps the following Source2 type names to the fully qualified type name in the target language.
         *
         * - float32
         * - float64
         * - int8
         * - int16
         * - int32
         * - int64
         * - uint8
         * - uint16
         * - uint32
         * - uint64
         *
         * @return @ref std::nullopt if @p source_name is not listed above
         */
        virtual std::optional<std::string> find_built_in(std::string_view source_name) const = 0;

        /**
         * @return Extension to be used for generated files. Only 1 extension is
         * supported per language.
         */
        [[nodiscard]]
        virtual std::string get_file_extension() const = 0;

        /**
         * @param name Name of a type, e.g. of a struct, without qualifiers.
         * @return Escaped name, e.g. with underscores instead of spaces, that
         * can be used to generate types.
         */
        [[nodiscard]]
        virtual std::string escape_type_name(std::string_view name) const = 0;

        /**
         * Can be used by implementations to generate language-specific
         * preambles, such as header guards in C.
         */
        virtual self_ref preamble() = 0;

        virtual self_ref include(std::string_view module_or_file_name, IncludeOptions options) = 0;

        virtual self_ref pack_push(const std::size_t alignment = 1) = 0;

        virtual self_ref pack_pop() = 0;

        virtual self_ref next_line() = 0;

        virtual self_ref access_modifier(const std::string& modifier) = 0;

        virtual self_ref begin_class(const std::string& class_name, const std::string& access_modifier = "public") = 0;

        virtual self_ref begin_class_with_base_type(const std::string& class_name, const std::string& base_type,
                                                    const std::string& access_modifier = "public") = 0;

        virtual self_ref end_class() = 0;

        virtual self_ref begin_struct(std::string_view name, const std::string& access_modifier = "public") = 0;

        virtual self_ref begin_struct_with_base_type(const std::string& name, const std::string& base_type,
                                                     const std::string& access_modifier = "public") = 0;

        virtual self_ref end_struct() = 0;

        virtual self_ref begin_namespace(std::string_view namespace_name) = 0;

        virtual self_ref end_namespace() = 0;

        virtual self_ref begin_enum(const std::string& enum_name, const std::string& base_typename = "") = 0;

        virtual self_ref end_enum() = 0;

        virtual self_ref enum_item(const std::string& name, std::uint64_t value) = 0;

        virtual self_ref begin_function(const std::string& prefix, const std::string& type_name, const std::string& func_name,
                                        bool increment_tabs_count = true, bool move_cursor_to_next_line = true) = 0;

        virtual self_ref end_function(bool decrement_tabs_count, bool move_cursor_to_next_line = true) = 0;

        virtual self_ref return_value(const std::string& value, bool move_cursor_to_next_line = true) = 0;

        virtual self_ref static_field_getter(const std::string& type_name, const std::string& prop_name, const std::string& mod_name,
                                             const std::string& decl_class, const std::size_t index) = 0;

        virtual self_ref static_assert_size(std::string_view type_name, int expected_size, const bool move_cursor_to_next_line = true) = 0;

        /// @param class_name Fully qualified
        virtual self_ref static_assert_offset(std::string_view class_name, std::string_view prop_name, int expected_offset,
                                              const bool move_cursor_to_next_line = true) = 0;

        virtual self_ref comment(const std::string& text, bool move_cursor_to_next_line = true) = 0;

        /// Not to be used for inline comments
        virtual self_ref begin_multi_line_comment(const bool move_cursor_to_next_line = true) = 0;

        /// Not to be used for inline comments
        virtual self_ref end_multi_line_comment(const bool move_cursor_to_next_line = true) = 0;

        virtual self_ref prop(Prop prop, bool move_cursor_to_next_line = true) = 0;

        virtual self_ref forward_declaration(const std::string& text) = 0;

        virtual self_ref struct_padding(Padding options, bool move_cursor_to_next_line = true) = 0;

        virtual self_ref begin_bitfield_block() = 0;

        virtual self_ref end_bitfield_block(bool move_cursor_to_next_line) = 0;

        virtual self_ref restore_tabs_count() = 0;

        virtual self_ref reset_tabs_count() = 0;

        virtual std::string str() const = 0;

        virtual ~IGenerator() = default;
    };

} // namespace codegen

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/codegen/cpp.h`:

```h
#pragma once
#include <absl/strings/str_join.h>
#include <absl/strings/str_split.h>
#include <array>
#include <cassert>
#include <cstdint>

#include <set>
#include <sstream>
#include <string>
#include <type_traits>

#include "codegen.h"
#include "detail/c_family.h"
#include "tools/fnv.h"
#include <cassert>
#include <list>
#include <set>
#include <sstream>

namespace codegen {
    struct generator_cpp_t final : public IGenerator {
        using self_ref = std::add_lvalue_reference_t<generator_cpp_t>;

        std::string get_uint(std::size_t bits_count) const override {
            return std::format("std::{}", detail::c_family::get_uint(bits_count));
        }

        std::optional<std::string> find_built_in(std::string_view source_name) const override {
            const auto found =
                std::ranges::find(detail::c_family::kNumericTypes, source_name, &decltype(detail::c_family::kNumericTypes)::value_type::first);

            if (found != detail::c_family::kNumericTypes.end()) {
                // Add "std::" prefix to fixed-width integer types
                if (found->second.ends_with("_t")) {
                    return std::format("std::{}", found->second);
                } else {
                    return std::string{found->second};
                }
            } else {
                return std::nullopt;
            }
        }

        std::string get_file_extension() const override {
            return "hpp";
        }

        std::string escape_type_name(std::string_view name) const override {
            return detail::c_family::escape_name(name);
        }

        self_ref preamble() override {
            push_line("#pragma once");
            push_line("");
            include("source2sdk/source2gen/source2gen", IncludeOptions{.local = true, .system = false});
            include("cstddef", IncludeOptions{.local = false, .system = true});
            include("cstdint", IncludeOptions{.local = false, .system = true});

            return *this;
        }

        self_ref include(std::string_view module_or_file_name, IncludeOptions options) override {
            const auto open_bracket = options.local ? '"' : '<';
            const auto close_bracket = options.local ? '"' : '>';
            const auto maybe_file_extension = options.system ? "" : ("." + get_file_extension());

            return push_line(std::format("#include {}{}{}{}", open_bracket, module_or_file_name, maybe_file_extension, close_bracket));
        }

        self_ref pack_push(const std::size_t alignment) override {
            return push_line(std::format("#pragma pack(push, {})", alignment));
        }

        self_ref pack_pop() override {
            return push_line("#pragma pack(pop)");
        }

        self_ref next_line() override {
            return push_line("");
        }

        // @todo: @es3n1n: `self_ref prev_line()`

        self_ref access_modifier(const std::string& modifier) override {
            dec_tabs_count(1);
            push_line(std::format("{}:", modifier));
            restore_tabs_count();

            return *this;
        }

        self_ref begin_class(const std::string& class_name, const std::string& access_modifier = "public") override {
            return begin_block(std::format("class {}", detail::c_family::escape_name(class_name)), access_modifier);
        }

        self_ref begin_class_with_base_type(const std::string& class_name, const std::string& base_type,
                                            const std::string& access_modifier = "public") override {
            if (base_type.empty())
                return begin_class(std::cref(class_name), access_modifier);

            return begin_block(std::format("class {} : public {}", detail::c_family::escape_name(class_name), base_type), access_modifier);
        }

        self_ref end_class() override {
            return end_block();
        }

        self_ref begin_struct(std::string_view name, const std::string& access_modifier = "public") override {
            return begin_block(std::format("struct {}", detail::c_family::escape_name(name)), access_modifier);
        }

        self_ref begin_struct_with_base_type(const std::string& name, const std::string& base_type,
                                             const std::string& access_modifier = "public") override {
            if (base_type.empty())
                return begin_struct(name, access_modifier);

            return begin_block(std::format("struct {} : public {}", detail::c_family::escape_name(name), base_type), access_modifier);
        }

        self_ref end_struct() override {
            return end_block();
        }

        self_ref begin_namespace(std::string_view namespace_name) override {
            return begin_block(std::format("namespace {}", namespace_name));
        }

        self_ref end_namespace() override {
            return end_block();
        }

        self_ref begin_enum(const std::string& enum_name, const std::string& base_typename = "") override {
            return begin_block(
                std::format("enum class {}{}", detail::c_family::escape_name(enum_name), base_typename.empty() ? base_typename : (" : " + base_typename)));
        }

        self_ref end_enum() override {
            return end_block();
        }

        self_ref enum_item(const std::string& name, std::uint64_t value) override {
            return push_line(std::format("{} = {:#x},", name, value));
        }

        // @todo: @es3n1n: add func params
        self_ref begin_function(const std::string& prefix, const std::string& type_name, const std::string& func_name,
                                const bool increment_tabs_count = true, const bool move_cursor_to_next_line = true) override {
            return begin_block(std::format("{}{} {}()", prefix, type_name, detail::c_family::escape_name(func_name)), "", increment_tabs_count,
                               move_cursor_to_next_line);
        }

        self_ref end_function(const bool decrement_tabs_count = true, const bool move_cursor_to_next_line = true) override {
            return end_block(decrement_tabs_count, move_cursor_to_next_line);
        }

        self_ref return_value(const std::string& value, const bool move_cursor_to_next_line = true) override {
            return push_line(std::format("return {};", value), move_cursor_to_next_line);
        }

        self_ref static_field_getter(const std::string& type_name, const std::string& prop_name, const std::string& mod_name,
                                     const std::string& decl_class, const std::size_t index) override {
            begin_function("static ", type_name, std::format("&Get_{}", prop_name), false, false);

            // @note: @es3n1n: reset tabs count temporary
            //
            const auto backup_tabs_count = _tabs_count;
            _tabs_count = 0;

            const auto getter = std::format(
                R"(*reinterpret_cast<{}*>(interfaces::g_schema->FindTypeScopeForModule("{}")->FindDeclaredClass("{}")->GetStaticFields()[{}]->m_pInstance))",
                type_name, mod_name, decl_class, index);
            return_value(getter, false);
            end_function(false, true);

            // @note: @es3n1n: restore tabs count
            //
            _tabs_count = backup_tabs_count;
            return *this;
        }

        self_ref static_assert_size(std::string_view type_name, int expected_size, const bool move_cursor_to_next_line) override {
            assert(expected_size > 0);

            return push_line(std::format("static_assert(sizeof({}) == {:#x});", type_name, expected_size), move_cursor_to_next_line);
        }

        self_ref static_assert_offset(std::string_view class_name, std::string_view prop_name, int expected_offset,
                                      const bool move_cursor_to_next_line) override {
            assert(expected_offset >= 0);

            return push_line(std::format("static_assert(offsetof({}, {}) == {:#x});", class_name, prop_name, expected_offset), move_cursor_to_next_line);
        }

        self_ref comment(const std::string& text, const bool move_cursor_to_next_line = true) override {
            return push_line(std::format("// {}", text), move_cursor_to_next_line);
        }

        self_ref begin_multi_line_comment(const bool move_cursor_to_next_line = true) override {
            return push_line("/*", move_cursor_to_next_line);
        }

        self_ref end_multi_line_comment(const bool move_cursor_to_next_line = true) override {
            return push_line("*/", move_cursor_to_next_line);
        }

        self_ref prop(Prop prop, bool move_cursor_to_next_line = true) override {
            const auto line =
                std::format("{} {}{};{}", prop.type_name, prop.name, prop.bitfield_size.has_value() ? std::format(": {}", prop.bitfield_size.value()) : "",
                            move_cursor_to_next_line ? "" : " ");
            return push_line(line, move_cursor_to_next_line);
        }

        self_ref forward_declaration(const std::string& text) override {
            // @note: @es3n1n: forward decl only once
            const auto fwd_decl_hash = fnv32::hash_runtime(text.data());
            if (_forward_decls.contains(fwd_decl_hash))
                return *this;

            _forward_decls.insert(fwd_decl_hash);

            // @fixme: split method to class_forward_declaration & struct_forward_declaration
            // one for `struct uwu_t` and the other one for `class c_uwu`
            return push_line(std::format("struct {};", detail::c_family::escape_name(text)));
        }

        self_ref struct_padding(Padding options, bool move_cursor_to_next_line) override {
            const auto is_bitfield{std::holds_alternative<Padding::Bits>(options.size)};

            // @note: @es3n1n: mark private fields as maybe_unused to silence -Wunused-private-field
            std::string type_name = is_bitfield ? detail::c_family::guess_bitfield_type(std::get<Padding::Bits>(options.size).value) : "uint8_t";

            auto pad_name =
                options.pad_offset.has_value() ? std::format("_pad{:04x}", options.pad_offset.value()) : std::format("_pad{:d}", _pads_count++);

            if (!is_bitfield)
                pad_name = pad_name + std::format("[{:#x}]", std::get<Padding::Bytes>(options.size).value);

            return prop(Prop{.type_name = type_name,
                             .name = pad_name,
                             .bitfield_size = is_bitfield ? std::make_optional(std::get<Padding::Bits>(options.size).value) : std::nullopt},
                        move_cursor_to_next_line);
        }

        self_ref begin_bitfield_block() override {
            return comment("start of bitfield block");
        }

        self_ref end_bitfield_block(const bool move_cursor_to_next_line = true) override {
            return comment("end of bitfield block", move_cursor_to_next_line);
        }

        self_ref restore_tabs_count() override {
            _tabs_count = _tabs_count_backup;
            return *this;
        }

        self_ref reset_tabs_count() override {
            _tabs_count_backup = _tabs_count;
            _tabs_count = 0;
            return *this;
        }

    public:
        [[nodiscard]] std::string str() const override {
            return _stream.str();
        }

    private:
        self_ref begin_block(const std::string& text, const std::string& access_modifier = "", const bool increment_tabs_count = true,
                             const bool move_cursor_to_next_line = true) {
            push_line(text, move_cursor_to_next_line);

            // @note: @es3n1n: we should reset tabs count if we aren't moving cursor to
            // the next line
            const auto backup_tabs_count = _tabs_count;
            if (!move_cursor_to_next_line)
                _tabs_count = 0;

            push_line("{", move_cursor_to_next_line);

            if (!access_modifier.empty())
                push_line(std::format("{}:", access_modifier), move_cursor_to_next_line);

            // @note: @es3n1n: restore tabs count
            if (!move_cursor_to_next_line)
                _tabs_count = backup_tabs_count;

            if (increment_tabs_count)
                inc_tabs_count(kTabsPerBlock);

            return *this;
        }

        self_ref end_block(const bool decrement_tabs_count = true, const bool move_cursor_to_next_line = true) {
            if (decrement_tabs_count)
                dec_tabs_count(kTabsPerBlock);

            push_line("};", move_cursor_to_next_line);
            return *this;
        }

        self_ref push_line(const std::string& line, bool move_cursor_to_next_line = true) {
            _stream << std::string(_tabs_count * kIndentWidth, kSpaceSym) // insert spaces
                    << line;

            if (move_cursor_to_next_line) {
                _stream << std::endl;
            }
            return *this;
        }

        self_ref inc_tabs_count(const std::size_t count = 1) {
            _tabs_count_backup = _tabs_count;
            _tabs_count += count;
            return *this;
        }

        self_ref dec_tabs_count(const std::size_t count = 1) {
            _tabs_count_backup = _tabs_count;
            if (_tabs_count)
                _tabs_count -= count;
            return *this;
        }

    private:
        std::stringstream _stream = {};
        std::size_t _tabs_count = 0, _tabs_count_backup = 0;
        std::size_t _pads_count = 0;
        std::set<fnv32::hash> _forward_decls = {};
    };
} // namespace codegen

```

`source2gen/include/tools/codegen/detail/c_family.h`:

```h
#pragma once

#include <absl/strings/str_join.h>
#include <absl/strings/str_split.h>
#include <array>
#include <cassert>
#include <cstddef>
#include <format>
#include <ranges>
#include <stdexcept>
#include <string>
#include <string_view>
#include <utility>

namespace codegen::detail::c_family {
    constexpr std::array kBlacklistedCharacters = {':', ';', '\\', '/'};

    // @note: @es3n1n: a list of possible integral types for bitfields (would be used in `guess_bitfield_type`)
    //
    constexpr auto kBitfieldIntegralTypes = std::to_array<std::pair<std::size_t, std::string_view>>({
        // clang-format off
        {8, "uint8_t"},
        {16, "uint16_t"},
        {32, "uint32_t"},
        {64, "uint64_t"},

        // @todo: @es3n1n: define uint128_t/uint256_t/... as custom structs in the very beginning of the file
        {128, "uint128_t"},
        {256, "uint256_t"},
        {512, "uint512_t"},
        // clang-format on
    });

    /// Without a namespace qualifier.
    /// Key is a @ref CSchemaType::m_pszName.
    constexpr auto kNumericTypes = std::to_array<std::pair<std::string_view, std::string_view>>({
        // clang-format off
        {"float32", "float"},
        {"float64", "double"},

        {"int8", "int8_t"},
        {"int16", "int16_t"},
        {"int32", "int32_t"},
        {"int64", "int64_t"},

        {"uint8", "uint8_t"},
        {"uint16", "uint16_t"},
        {"uint32", "uint32_t"},
        {"uint64", "uint64_t"} // clang-format on
    });

    [[nodiscard]]
    inline std::string guess_bitfield_type(const std::size_t bits_count) {
        for (const auto& p : kBitfieldIntegralTypes) {
            if (bits_count > p.first)
                continue;

            return std::string{p.second};
        }

        throw std::runtime_error(std::format("{} : Unable to guess bitfield type with size {}", __FUNCTION__, bits_count));
    }

    /**
     * Panics on error
     * @return Without namespace qualifier
     */
    [[nodiscard]]
    inline std::string get_uint(const std::size_t bits_count) {
        const auto found = std::ranges::find_if(kBitfieldIntegralTypes, [=](const auto& e) { return std::get<0>(e) == bits_count; });

        if (found != kBitfieldIntegralTypes.end()) {
            return std::string{found->second};
        } else {
            throw std::runtime_error(std::format("{} : Unable to guess bitfield type with size {}", __FUNCTION__, bits_count));
        }
    }

    /**
     * @param name Unqualified. If this is qualified, namespace separators will be replaced with underscores.
     * @return A name that can be used to name entities
     */
    [[nodiscard]]
    inline std::string escape_name(std::string_view name) {
        std::string result;
        result.resize(name.size());

        for (std::size_t i = 0; i < name.size(); i++)
            result[i] =
                std::ranges::find(detail::c_family::kBlacklistedCharacters, name[i]) == std::end(detail::c_family::kBlacklistedCharacters) ? name[i] : '_';

        const auto starts_with_underscore{!result.empty() && result[0] == '_'};

        // collapse multiple underscores into one
        // because names containing double underscores are reserved in C
        result = absl::StrJoin(absl::StrSplit(result, '_', absl::SkipWhitespace{}), "_");

        // restore underscore if we had one at the beginning, e.g. "_pad_10"
        if (starts_with_underscore)
            result = '_' + result;

        return result;
    }
} // namespace codegen::detail::c_family

```

`source2gen/include/tools/field_parser.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include "codegen/codegen.h"
#include <cstddef>
#include <format>
#include <optional>
#include <sdk/interfaces/client/game/datamap_t.h>
#include <string>
#include <string_view>
#include <vector>

namespace field_parser {
    class field_info_t {
    public:
        std::string m_type; // fully qualified name
        fieldtype_t m_field_type = fieldtype_t::FIELD_UNUSED; // var type
        std::string m_name; // var name

        // array sizes, for example {13, 37} for multi dimensional array "[13][37]"
        std::vector<std::size_t> m_array_sizes = {};

        std::size_t m_bitfield_size = 0ull; // bitfield size, set to 0 if var isn't a bitfield

    public:
        [[nodiscard]] bool is_bitfield() const noexcept {
            return static_cast<bool>(m_bitfield_size);
        }

        [[nodiscard]] bool is_array() const noexcept {
            return !m_array_sizes.empty();
        }

    public:
        [[nodiscard]] std::size_t total_array_size() const {
            std::size_t result = 0ull;

            for (auto size : m_array_sizes) {
                if (!result) {
                    result = size;
                    continue;
                }

                result *= size;
            }

            return result;
        }

    public:
        [[nodiscard]] std::string formatted_array_sizes() const {
            std::string result;

            for (std::size_t size : m_array_sizes)
                result += std::format("[{}]", size);

            return result;
        }

        [[nodiscard]] std::string formatted_name() const {
            if (is_array())
                return std::format("{}{}", m_name, formatted_array_sizes());

            return m_name;
        }
    };

    [[nodiscard]]
    std::pair<std::string, std::string> split_type_name_pointers(const std::string& type_name);

    [[nodiscard]]
    std::string guess_bitfield_type(std::size_t bits_count);

    /// @return @ref std::nullopt if type_name is not a built-in type
    [[nodiscard]]
    std::optional<std::string_view> type_name_to_cpp(std::string_view type_name);

    [[nodiscard]]
    field_info_t parse(const codegen::IGenerator& generator, const std::string& type_name, const std::string& name,
                       const std::vector<std::size_t>& array_sizes);

    [[nodiscard]]
    field_info_t parse(fieldtype_t field_type, const std::string& name, std::size_t array_size);
} // namespace field_parser

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/fnv.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include <cstdint>
#include <type_traits>

// Implements FNV-1a hash algorithm
namespace detail {
    template <typename Type, Type OffsetBasis, Type Prime>
    struct SizeDependantData {
        using type = Type;

        constexpr static auto k_offset_basis = OffsetBasis;
        constexpr static auto k_prime = Prime;
    };

    template <std::size_t Bits>
    struct SizeSelector : std::false_type { };

    template <>
    struct SizeSelector<32> : SizeDependantData<std::uint32_t, 0x811c9dc5ul, 16777619ul> { };

    template <>
    struct SizeSelector<64> : SizeDependantData<std::uint64_t, 0xcbf29ce484222325ull, 1099511628211ull> { };

    template <std::size_t Size>
    class FnvHash {
    private:
        using data_t = SizeSelector<Size>;

    public:
        using hash = typename data_t::type;

    private:
        constexpr static auto k_offset_basis = data_t::k_offset_basis;
        constexpr static auto k_prime = data_t::k_prime;

    public:
        static __forceinline constexpr auto hash_init() -> hash {
            return k_offset_basis;
        }

        static __forceinline constexpr auto hash_byte(hash current, std::uint8_t byte) -> hash {
            return (current ^ byte) * k_prime;
        }

        template <std::size_t N>
        static __forceinline constexpr auto hash_constexpr(const char (&str)[N], const std::size_t size = N - 1 /* do not hash the null */
                                                           ) -> hash {
            const auto prev_hash = size == 1 ? hash_init() : hash_constexpr(str, size - 1);
            const auto cur_hash = hash_byte(prev_hash, str[size - 1]);
            return cur_hash;
        }

        static auto __forceinline hash_runtime(const char* str) -> hash {
            auto result = hash_init();
            do
                result = hash_byte(result, *str++);
            while (*str != '\0');

            return result;
        }
    };
} // namespace detail

using fnv32 = ::detail::FnvHash<32>;
#define FNV32(str) (std::integral_constant<fnv32::hash, fnv32::hash_constexpr(str)>::value)

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/loader/loader.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include "tools/platform.h"
#include <expected>
#include <string>
#include <string_view>

#if defined(_MSC_VER)
#pragma warning(disable:4715)
#endif

#include "loader_shared.h"
#if TARGET_OS == WINDOWS
    #include "loader_windows.h"
#elif TARGET_OS == LINUX
    #include "loader_linux.h"
#endif

/// Prefer using loader::get_module_file_name(). Only use these macros if you
/// cannot use C++ allocations, e.g. before tier0 has been loaded.
#if TARGET_OS == WINDOWS
    #define LOADER_GET_MODULE_FILE_NAME(expr) LOADER_WINDOWS_GET_MODULE_FILE_NAME(expr)
#elif TARGET_OS == LINUX
    #define LOADER_GET_MODULE_FILE_NAME(expr) LOADER_LINUX_GET_MODULE_FILE_NAME(expr)
#endif

/// Wrapping the functions in the `Platform` namespace causes compiler errors
/// even when they're unused in the code base (Fail fast). It also provides a
/// uniform interface for the caller.
namespace loader {
#if TARGET_OS == WINDOWS
    namespace platform = windows;
#elif TARGET_OS == LINUX
    namespace platform = linux;
#endif

    using module_handle_t = platform::module_handle_t;

    [[nodiscard]] inline auto get_module_file_name(std::string name) -> std::string {
        return platform::get_module_file_name(std::move(name));
    }

    [[nodiscard]] inline auto find_module_handle(std::string_view name) -> module_handle_t {
        return platform::find_module_handle(name);
    }

    [[nodiscard]] inline auto load_module(std::string_view name) -> std::expected<module_handle_t, ModuleLookupError> {
        return platform::load_module(name);
    }

    template <typename Ty = module_handle_t>
    [[nodiscard]] inline auto find_module_symbol(module_handle_t handle, std::string_view name) -> std::expected<Ty, ModuleLookupError> {
        return platform::find_module_symbol<Ty>(handle, name);
    }
} // namespace loader

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/loader/loader_linux.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include <algorithm>
#include <cassert>
#include <cstring>
#include <dlfcn.h>
#include <expected>
#include <string>
#include <string_view>

#include "loader_shared.h"

// keep in sync with get_module_file_name()
#define LOADER_LINUX_GET_MODULE_FILE_NAME(name) "lib" name ".so"

namespace loader::linux {
    using module_handle_t = void*;

    // keep in sync with LOADER_LINUX_GET_MODULE_FILE_NAME
    [[nodiscard]] inline auto get_module_file_name(std::string name) -> std::string {
        return name.insert(0, "lib").append(".so");
    }

    [[nodiscard]] inline auto find_module_handle(std::string_view name) -> module_handle_t {
        return dlopen(name.data(), RTLD_LAZY | RTLD_NOLOAD);
    }

    [[nodiscard]] inline auto load_module(std::string_view name) -> std::expected<module_handle_t, ModuleLookupError> {
        if (auto* const handle = dlopen(name.data(), RTLD_LAZY)) {
            return handle;
        }
        return std::unexpected(ModuleLookupError::from_string(dlerror()));
    }

    template <typename Ty>
    [[nodiscard]] inline auto find_module_symbol(module_handle_t handle, std::string_view name) -> std::expected<Ty, ModuleLookupError> {
        assert(handle != nullptr && "If you need RTLD_DEFAULT, write a new function to avoid magic values. Most of the time when handle=nullptr, a "
                                    "developer made a mistake and we want to catch that.");
        auto* const result = dlsym(handle, name.data());
        if (result == nullptr) {
            return std::unexpected(ModuleLookupError::from_string(dlerror()));
        }
        return reinterpret_cast<Ty>(result);
    }
} // namespace loader::linux

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/loader/loader_shared.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include <cstring>
#include <string>

namespace loader {
    class ModuleLookupError {
    public:
        /// @return Lifetime bound to this @ref ModuleLookupError
        [[nodiscard]] auto as_string() const -> std::string_view {
            return this->m_errorMessage;
        }

        static auto from_string(std::string_view str) {
            return ModuleLookupError{str};
        }

    private:
        // we can't use allocating C++ functions (std::string) in here because
        // callers might try to load modules before an g_pMemAlloc has been
        // found.
        char m_errorMessage[512]{};

        explicit ModuleLookupError(std::string_view str) {
            std::strncpy(this->m_errorMessage, str.data(), std::min(std::size(m_errorMessage), std::size(str)));
        }
    };
} // namespace loader

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/loader/loader_windows.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once
#include <algorithm>
#include <cassert>
#include <cstring>
#include <string>
#include <Windows.h>

#include "loader_shared.h"

// keep in sync with get_module_file_name()
#define LOADER_WINDOWS_GET_MODULE_FILE_NAME(name) name ".dll"

namespace loader::windows {
    using module_handle_t = HMODULE;

    namespace detail {
        inline ModuleLookupError win32_error(DWORD error = GetLastError()) {
            LPSTR pBuffer = nullptr;

            const auto size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, error,
                                             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<LPSTR>(&pBuffer), 0, nullptr);

            const auto result = ModuleLookupError::from_string(pBuffer);

            LocalFree(pBuffer);
            return result;
        }
    } // namespace detail

    // keep in sync with LOADER_WINDOWS_GET_MODULE_FILE_NAME
    [[nodiscard]] inline auto get_module_file_name(std::string name) -> std::string {
        return name.append(".dll");
    }

    [[nodiscard]] inline auto find_module_handle(std::string_view name) -> module_handle_t {
        return GetModuleHandleA(name.data());
    }

    [[nodiscard]] inline auto load_module(std::string_view name) -> std::expected<module_handle_t, ModuleLookupError> {
        auto result = LoadLibraryA(name.data());
        if (result == reinterpret_cast<HINSTANCE>(0)) {
            return std::unexpected(detail::win32_error());
        }

        return result;
    }

    template <typename Ty>
    [[nodiscard]] inline auto find_module_symbol(module_handle_t handle, std::string_view name) -> std::expected<Ty, ModuleLookupError> {
        assert(handle != nullptr);
        if (auto const h_module = GetProcAddress(handle, name.data())) {
            return reinterpret_cast<Ty>(h_module);
        }

        return std::unexpected(detail::win32_error());
    }
} // namespace loader::windows

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/platform.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

/// Some environments automatically define the bare macro `linux` (in
/// addition to the portable feature-test macro `__linux__`). This pollutes 
/// the global namespace and collides with our `platform::linux`.
#if defined(linux)
    #undef linux
#endif

#define WINDOWS 0
#define LINUX 1

/// Names copied from Rust https://doc.rust-lang.org/reference/conditional-compilation.html#target_os
#if defined(_WIN32)
    #define TARGET_OS WINDOWS
#elif defined(__linux__)
    #define TARGET_OS LINUX
#else
    #error unsupported operating system
#endif

// we're using __VA_ARGS__ to allow the use of commas, e.g. IF_WINDOWS(element,)
#if TARGET_OS == WINDOWS
    #define IF_WINDOWS(...) __VA_ARGS__
    #define IF_LINUX(...)
#elif TARGET_OS == LINUX
    #define IF_WINDOWS(...)
    #define IF_LINUX(...) __VA_ARGS__
#endif

enum class platform {
    windows,
    linux,
};

constexpr platform current_platform =
#if TARGET_OS == WINDOWS
    platform::windows;
#elif TARGET_OS == LINUX
    platform::linux;
#else
    #error
#endif

template <class Value>
struct [[nodiscard]] platform_specific {
    Value windows;
    Value linux;

    [[nodiscard]] consteval auto get() {
        switch (current_platform) {
        case platform::windows:
            return this->windows;
        case platform::linux:
            return this->linux;
        }
    }

    /* implicit */ [[nodiscard]] consteval operator Value() {
        return this->get();
    }
};

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/util.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include <concepts>
#include <format>
#include <ranges>
#include <string>
#include <string_view>
#include <tools/loader/loader.h>

namespace util {
    inline std::string PrettifyNum(int num) {
        static const auto fn =
            loader::find_module_symbol<const char* (*)(int)>(loader::find_module_handle(loader::get_module_file_name("tier0")), "V_PrettifyNum");

        if (fn.has_value()) {
            std::string_view res = (*fn)(num);
            if (!res.empty()) {
                return res.data();
            }
        }

        return std::to_string(num);
    }

    /// Useful for optional integers, e.g.
    /// ```cpp
    /// const std::optional<int> offset = try_get_offset();
    /// std::cout << std::format("offset: {}\n", offset.transform(to_hex_string).value_or("unknown"));
    /// ```
    inline std::string to_hex_string(const std::uintptr_t i) {
        return std::format("{:#x}", i);
    }

    [[nodiscard]] inline std::string EscapePath(std::string_view path) {
        std::string result(path);
        std::ranges::replace(result, ':', '_');
        return result;
    }

    [[nodiscard]] inline bool IsStruct(std::string_view name) {
        return name.ends_with("_t");
    }
} // namespace util

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/include/tools/virtual.h`:

```h
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#pragma once

#include <cstdint>

namespace Virtual {
    template <typename T>
    inline T Get(void* instance, const unsigned int index) {
        return (*static_cast<T**>(static_cast<void*>(instance)))[index];
    }

    template <typename T>
    inline T Get(const void* instance, const unsigned int index) {
        return (*static_cast<T* const*>(static_cast<const void*>(instance)))[index];
    }

    template <typename T>
    inline T Read(const std::uintptr_t location) {
        return *reinterpret_cast<T*>(location);
    }

    template <typename T>
    inline void Write(const std::uintptr_t location, const T& data) {
        *reinterpret_cast<T*>(location) = data;
    }
} // namespace Virtual

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/src/main.cpp`:

```cpp
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#include "options.hpp"
#include "tools/platform.h"
#include <Include.h>
#include <iostream>
#include <optional>

int main(const int argc, char* argv[]) {
    int exit_code = 1;

    const auto options = source2_gen::Options::parse_args(argc, argv);
    if (options.has_value() && Dump(*options)) {
        std::cout << std::format("Successfully dumped Source 2 SDK, now you can safely close this console.") << std::endl;
        std::cout << kPoweredByMessage << std::endl;
        exit_code = 0;
    }

    /// Errors would be logged in the `source2_gen::Dump` itself
    /// We don't want to call getch on linux as the program would be started within a terminal anyway.
#if TARGET_OS == WINDOWS
    (void)std::getchar();
#endif
    return exit_code;
}

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/src/options.cpp`:

```cpp
#include "options.hpp"
#include <argparse/argparse.hpp>
#include <iostream>

[[nodiscard]]
static std::optional<source2_gen::Language> parse_language(std::string_view str) {
    using enum source2_gen::Language;

    if (str == "c") {
        return c;
    } else if (str == "c-ida") {
        return c_ida;
    } else if (str == "cpp") {
        return cpp;
    } else {
        return std::nullopt;
    }
}

std::optional<source2_gen::Options> source2_gen::Options::parse_args(int argc, char* argv[]) {
    argparse::ArgumentParser parser{"source2gen"};

    parser.add_argument("--emit-language")
        .choices("cpp", "c", "c-ida")
        .default_value("cpp")
        .help("Programming language to be used for the generated SDK [cpp, c, c-ida]");
    parser.add_argument("--no-static-members").default_value(false).help("Don't generate getters for static member variables");
    parser.add_argument("--no-static-assertions")
        .default_value(false)
        .help("Don't generate static assertions for class size and field offsets (Generated SDK might not work. You can get banned for writing to wrong "
              "offsets!)");

    try {
        parser.parse_args(argc, argv);
    } catch (const std::runtime_error& e) {
        std::cerr << e.what() << std::endl;
        return std::nullopt;
    }

    const auto language{parse_language(parser.get<std::string>("emit-language"))};

    if (!language.has_value()) {
        std::cerr << "invalid value for --emit-language" << std::endl;
        return std::nullopt;
    }

    return source2_gen::Options{.emit_language = language.value(),
                                .static_members = (language.value() != Language::c_ida) && !parser.is_used("no-static-members"),
                                .static_assertions = (language.value() != Language::c_ida) && !parser.is_used("no-static-assertions")};
}

```

`source2gen/src/sdk/interfaces/common/CBufferString.cpp`:

```cpp
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#include <cassert>
#include <sdk/interfaces/common/CBufferString.h>
#include <tools/loader/loader.h>

void CBufferString::MoveFrom(CBufferString& src) {
    using func_t = void (*)(CBufferString*, CBufferString&);
    static const auto func = []() -> func_t {
        const auto module_handle = loader::find_module_handle("tier0");
        const auto exported_fn = loader::find_module_symbol(module_handle, "?MoveFrom@CBufferString@@QEAAXAEAV1@@Z");
        assert(exported_fn.has_value());
        return reinterpret_cast<func_t>(*exported_fn);
    }();

    return func(this, src);
}

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/src/sdk/sdk.cpp`:

```cpp
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.

// ReSharper disable CppClangTidyClangDiagnosticLanguageExtensionToken
#include "sdk/sdk.h"
#include "Include.h"
#include "tools/codegen/c.h"
#include "tools/codegen/codegen.h"
#include "tools/codegen/cpp.h"
#include "tools/field_parser.h"
#include "tools/util.h"
#include <absl/strings/str_replace.h>
#include <cstdlib>

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <functional>
#include <iostream>
#include <list>
#include <ranges>
#include <set>
#include <span>
#include <string_view>
#include <unordered_set>
#include <utility>
#include <variant>
#include <vector>

namespace {
    enum class NameSource {
        include,
        forward_declaration,
    };

    struct NameLookup {
        std::string module{};

        /// Decayed
        std::string type_name{};

        NameSource source{};

        auto operator<=>(const NameLookup&) const = default;
    };

    struct BitfieldEntry {
        std::string name{};
        std::size_t size{};
        /// Lifetime of fields' pointers bound to the source2's @ref CSchemaClassInfo
        std::vector<SchemaMetadataEntryData_t> metadata{};
    };

    struct ClassAssemblyState {
        std::optional<std::ptrdiff_t> last_field_size = std::nullopt;
        std::optional<std::ptrdiff_t> last_field_offset = std::nullopt;
        bool assembling_bitfield = false;
        std::vector<BitfieldEntry> bitfield = {};
        std::int32_t bitfield_start = 0;

        std::ptrdiff_t collision_end_offset = 0ull; // @fixme: @es3n1n: todo proper collision fix and remove this var
    };

    /**
     * Project structure is
     * <kOutDirName>
     * - CMakeLists.txt
     * - ...
     * - include/
     *   - <kSdkDirName>
     *     - some_module
     *       - some_header.hpp
     */
    constexpr std::string_view kOutDirName = "sdk";
    constexpr std::string_view kIncludeDirName = "source2sdk";

    constinit std::array string_metadata_entries = {
        FNV32("MCellForDomain"),
        FNV32("MCustomFGDMetadata"),
        FNV32("MFieldVerificationName"),
        FNV32("MKV3TransferName"),
        FNV32("MNetworkAlias"),
        FNV32("MNetworkChangeCallback"),
        FNV32("MNetworkEncoder"),
        FNV32("MNetworkExcludeByName"),
        FNV32("MNetworkExcludeByUserGroup"),
        FNV32("MNetworkIncludeByName"),
        FNV32("MNetworkIncludeByUserGroup"),
        FNV32("MNetworkReplayCompatField"),
        FNV32("MNetworkSerializer"),
        FNV32("MNetworkTypeAlias"),
        FNV32("MNetworkUserGroup"),
        FNV32("MNetworkUserGroupProxy"),
        FNV32("MParticleReplacementOp"),
        FNV32("MPropertyArrayElementNameKey"),
        FNV32("MPropertyAttributeChoiceName"),
        FNV32("MPropertyAttributeEditor"),
        FNV32("MPropertyAttributeRange"),
        FNV32("MPropertyAttributeSuggestionName"),
        FNV32("MPropertyCustomEditor"),
        FNV32("MPropertyCustomFGDType"),
        FNV32("MPropertyDescription"),
        FNV32("MPropertyDescription"),
        FNV32("MPropertyExtendedEditor"),
        FNV32("MPropertyFriendlyName"),
        FNV32("MPropertyFriendlyName"),
        FNV32("MPropertyGroupName"),
        FNV32("MPropertyIconName"),
        FNV32("MPropertyStartGroup"),
        FNV32("MPropertySuppressExpr"),
        FNV32("MPulseCellOutflowHookInfo"),
        FNV32("MPulseEditorHeaderIcon"),
#if !defined(DEADLOCK) && !defined(DOTA2)
        FNV32("MPulseProvideFeatureTag"),
#endif
        FNV32("MResourceBlockType"),
        FNV32("MScriptDescription"),
        FNV32("MSrc1ImportAttributeName"),
        FNV32("MSrc1ImportDmElementType"),
        FNV32("MVDataOutlinerIcon"),
        FNV32("MVDataOutlinerIconExpr"),
        FNV32("MVDataUniqueMonotonicInt"),
        FNV32("MVectorIsSometimesCoordinate"),
    };

    constinit std::array string_class_metadata_entries = {
        FNV32("MResourceTypeForInfoType"),
        FNV32("MDiskDataForResourceType"),
    };

    constinit std::array var_name_string_class_metadata_entries = {
        FNV32("MNetworkVarNames"), FNV32("MNetworkOverride"), FNV32("MNetworkVarTypeOverride"), FNV32("MScriptDescription"), FNV32("MParticleDomainTag"),
    };

    constinit std::array integer_metadata_entries = {
        FNV32("MNetworkVarEmbeddedFieldOffsetDelta"),
        FNV32("MNetworkBitCount"),
        FNV32("MNetworkPriority"),
        FNV32("MParticleOperatorType"),
        FNV32("MPropertySortPriority"),
        FNV32("MParticleMinVersion"),
        FNV32("MParticleMaxVersion"),
#if defined(DEADLOCK) || defined(DOTA2)
        FNV32("MPulseProvideFeatureTag"),
#endif
        FNV32("MNetworkEncodeFlags"),
        FNV32("MResourceVersion"),
        FNV32("MVDataNodeType"),
        FNV32("MVDataOverlayType"),
        FNV32("MAlignment"),
        FNV32("MGenerateArrayKeynamesFirstIndex"),
    };

    constinit std::array float_metadata_entries = {
        FNV32("MNetworkMinValue"),
        FNV32("MNetworkMaxValue"),
    };

    void warn(std::string_view message) {
        std::cerr << "warning: " << message << '\n';
    }

    // @note: @es3n1n: some more utils
    //
    std::string GetMetadataValue(const SchemaMetadataEntryData_t& metadata_entry) {
        std::string value;

        const auto value_hash_name = fnv32::hash_runtime(metadata_entry.m_szName);

        if (std::ranges::find(var_name_string_class_metadata_entries, value_hash_name) != var_name_string_class_metadata_entries.end()) {
            const auto& var_value = metadata_entry.m_pNetworkValue->m_VarValue;
            const auto check_ptr = [](const char* ptr) -> bool {
                /// @note: hotfix for the deadlock 14/09/24 update,
                ///     where they filled some ptrs with -1 instead of nullptr
                return ptr != nullptr && ptr != reinterpret_cast<const char*>(-1);
            };

            if (check_ptr(var_value.m_pszType) && check_ptr(var_value.m_pszName))
                value = std::format("{} {}", var_value.m_pszType, var_value.m_pszName);
            else if (check_ptr(var_value.m_pszName) && !check_ptr(var_value.m_pszType))
                value = var_value.m_pszName;
            else if (!check_ptr(var_value.m_pszName) && check_ptr(var_value.m_pszType))
                value = var_value.m_pszType;
        } else if (std::ranges::find(string_class_metadata_entries, value_hash_name) != string_class_metadata_entries.end()) {
            /// Explicitly convert to std::string with the size as the string may not end with a nullterm
            /// But if this string does contain a null terminator, we should properly handle this too
            const auto& szValue = metadata_entry.m_pNetworkValue->m_szValue;
            const auto null_pos = std::find(szValue.begin(), szValue.end(), 0x00);
            const auto size = null_pos != szValue.end() ? std::distance(szValue.begin(), null_pos) : szValue.size();

            value = std::string(metadata_entry.m_pNetworkValue->m_szValue.data(), size);
        } else if (std::ranges::find(string_metadata_entries, value_hash_name) != string_metadata_entries.end()) {
            value = metadata_entry.m_pNetworkValue->m_pszValue;
        } else if (std::ranges::find(integer_metadata_entries, value_hash_name) != integer_metadata_entries.end()) {
            value = std::to_string(metadata_entry.m_pNetworkValue->m_nValue);
        } else if (std::ranges::find(float_metadata_entries, value_hash_name) != float_metadata_entries.end()) {
            value = std::to_string(metadata_entry.m_pNetworkValue->m_fValue);
        }

        return value;
    }

    /// https://en.cppreference.com/w/cpp/language/classes#Standard-layout_class
    /// Doesn't check for all requirements, but is strict enough for what we are doing.
    [[nodiscard]] bool IsStandardLayoutClass(std::map<sdk::TypeIdentifier, bool>& cache, const CSchemaClassInfo& class_) {
        const auto id = sdk::TypeIdentifier{.module = std::string{class_.GetModule()}, .name = std::string{class_.GetName()}};

        if (const auto found = cache.find(id); found != cache.end()) {
            return found->second;
        }

        // only one class in the hierarchy has non-static data members.
        // assumes that source2 only has single inheritance.
        {
            const auto* pClass = &class_;
            int classes_with_fields = 0;
            do {
                // also check size because not all members are registered with
                // the schema system.
                classes_with_fields += ((pClass->m_nSizeOf > 1) || (pClass->m_nFieldSize != 0)) ? 1 : 0;

                if (classes_with_fields > 1) {
                    return cache.emplace(id, false).first->second;
                }

                pClass = (pClass->m_pBaseClasses == nullptr) ? nullptr : pClass->m_pBaseClasses->m_pClass;
            } while (pClass != nullptr);
        }

        const auto has_non_standard_layout_field = std::ranges::any_of(
            class_.GetFields() | std::ranges::views::transform([&](const SchemaClassFieldData_t& e) {
                if (const auto* e_class = e.m_pSchemaType->GetAsDeclaredClass(); e_class != nullptr && e_class->m_pClassInfo != nullptr) {
                    return !IsStandardLayoutClass(cache, *e_class->m_pClassInfo);
                } else {
                    // Everything that is not a class has no effect
                    return false;
                }
            }),
            std::identity{});

        if (has_non_standard_layout_field) {
            return cache.emplace(id, false).first->second;
        }

        return cache.emplace(id, true).first->second;
    }

    /// Gets the alignment of a class by recursing through all of its fields.
    /// Does not guess, the returned value is correct if set.
    /// @param cache Used to look up and store alignment of fields
    /// @return @ref GetRegisteredAlignment() if set. Otherwise tries to determine the alignment by recursing through all fields.
    /// Returns @ref std::nullopt if one or more fields have unknown alignment.
    [[nodiscard]] std::optional<int> GetClassAlignmentRecursive(std::map<sdk::TypeIdentifier, std::optional<int>>& cache, const CSchemaClassInfo& class_) {
        const auto id = sdk::TypeIdentifier{.module = std::string{class_.GetModule()}, .name = std::string{class_.GetName()}};

        if (const auto found = cache.find(id); found != cache.end()) {
            return found->second;
        }

        return class_.GetRegisteredAlignment().or_else([&]() {
            int base_alignment = 0;

            if (class_.m_pBaseClasses != nullptr) {
                if (const auto maybe_base_alignment = GetClassAlignmentRecursive(cache, *class_.m_pBaseClasses->m_pClass)) {
                    base_alignment = maybe_base_alignment.value();
                } else {
                    // we have a base class, but it has unknown alignment
                    return cache.emplace(id, std::nullopt).first->second;
                }
            }

            auto field_alignments = class_.GetFields() | std::ranges::views::transform([&](const SchemaClassFieldData_t& e) {
                                        if (const auto* e_class = e.m_pSchemaType->GetAsDeclaredClass(); e_class != nullptr) {
                                            return GetClassAlignmentRecursive(cache, *e_class->m_pClassInfo);
                                        } else {
                                            return e.m_pSchemaType->GetSizeAndAlignment().and_then([](const auto& e) { return std::get<1>(e); });
                                        }
                                    });

            if (field_alignments.empty()) {
                // This is an empty class. The generator will add a single pad with alignment 1.
                return cache.emplace(id, std::make_optional((base_alignment == 0) ? 1 : base_alignment)).first->second;
            } else if (std::ranges::all_of(field_alignments, &std::optional<int>::has_value)) {
                int max_alignment = base_alignment;
                for (const auto& e : field_alignments) {
                    max_alignment = std::max(max_alignment, e.value());
                }
                return cache.emplace(id, std::make_optional(max_alignment)).first->second;
            } else {
                // there are fields with unknown alignment
                return cache.emplace(id, std::nullopt).first->second;
            }
        });
    }

    /// @return For class types, returns @ref GetClassAlignmentRecursive(). Otherwise returns the immediately available size.
    [[nodiscard]]
    std::optional<int> GetAlignmentOfTypeRecursive(std::map<sdk::TypeIdentifier, std::optional<int>>& cache, const CSchemaType& type) {
        if (const auto* class_ = type.GetAsDeclaredClass(); class_ != nullptr && class_->m_pClassInfo != nullptr) {
            return GetClassAlignmentRecursive(cache, *class_->m_pClassInfo);
        } else {
            return type.GetSizeAndAlignment().and_then([](const auto& e) { return std::get<1>(e); });
        }
    }

    [[nodiscard]]
    codegen::TypeCategory GetTypeCategory(const SchemaClassFieldData_t& field) {
        using enum codegen::TypeCategory;

        // these cases and sub-cases aren't exactly correct, but they do the job.
        // we can improve the classification when we need more details.
        switch (field.m_pSchemaType->GetTypeCategory()) {
        case ETypeCategory::Schema_DeclaredEnum:
            return enum_;
        case ETypeCategory::Schema_DeclaredClass:
            return class_or_struct;
        case ETypeCategory::Schema_FixedArray: {
            auto* schema = reinterpret_cast<const CSchemaType_FixedArray*>(field.m_pSchemaType);
            switch (schema->m_pElementType->m_unTypeCategory) {
            case ETypeCategory::Schema_DeclaredEnum:
                return enum_;
            case ETypeCategory::Schema_DeclaredClass:
            case ETypeCategory::Schema_Ptr:
                return class_or_struct;
            default:
                return built_in;
            }
        }
        case ETypeCategory::Schema_Ptr: {
            if (const auto ref_class = field.m_pSchemaType->GetRefClass(); ref_class != nullptr) {
                // there are only pointers to structs/classes in source2, not to enums
                if (ref_class->GetTypeCategory() == ETypeCategory::Schema_DeclaredClass) {
                    return class_or_struct;
                }
            }
            return built_in;
        }
        default:
            return built_in;
        }
    }

    void PrintClassInfo(sdk::GeneratorCache& cache, codegen::IGenerator::self_ref generator, const CSchemaClassBinding& class_) {
        generator.comment(std::format("Registered alignment: {}", class_.GetRegisteredAlignment().transform(&util::to_hex_string).value_or("unknown")));
        generator.comment(
            std::format("Alignment: {}", GetClassAlignmentRecursive(cache.class_alignment, class_).transform(&util::to_hex_string).value_or("unknown")));
        generator.comment(std::format("Standard-layout class: {}", IsStandardLayoutClass(cache.class_has_standard_layout, class_)));
        generator.comment(std::format("Size: {:#x}", class_.m_nSizeOf));

        if ((class_.m_nClassFlags & SCHEMA_CF1_HAS_VIRTUAL_MEMBERS) != 0) // @note: @og: its means that class probably does have vtable
            generator.comment("Has VTable");
        if ((class_.m_nClassFlags & SCHEMA_CF1_IS_ABSTRACT) != 0)
            generator.comment("Is Abstract");
        if ((class_.m_nClassFlags & SCHEMA_CF1_HAS_TRIVIAL_CONSTRUCTOR) != 0)
            generator.comment("Has Trivial Constructor");
        if ((class_.m_nClassFlags & SCHEMA_CF1_HAS_TRIVIAL_DESTRUCTOR) != 0)
            generator.comment("Has Trivial Destructor");

#if defined(CS2) || defined(DOTA2)
        if ((class_.m_nClassFlags & SCHEMA_CF1_CONSTRUCT_ALLOWED) != 0)
            generator.comment("Construct allowed");
        if ((class_.m_nClassFlags & SCHEMA_CF1_CONSTRUCT_DISALLOWED) != 0)
            generator.comment("Construct disallowed");
        if ((class_.m_nClassFlags & SCHEMA_CF1_INFO_TAG_MConstructibleClassBase) != 0)
            generator.comment("MConstructibleClassBase");
        if ((class_.m_nClassFlags & SCHEMA_CF1_INFO_TAG_MClassHasCustomAlignedNewDelete) != 0)
            generator.comment("MClassHasCustomAlignedNewDelete");
        if ((class_.m_nClassFlags & SCHEMA_CF1_INFO_TAG_MClassHasEntityLimitedDataDesc) != 0)
            generator.comment("MClassHasEntityLimitedDataDesc");
        if ((class_.m_nClassFlags & SCHEMA_CF1_INFO_TAG_MDisableDataDescValidation) != 0)
            generator.comment("MDisableDataDescValidation");
        if ((class_.m_nClassFlags & SCHEMA_CF1_INFO_TAG_MIgnoreTypeScopeMetaChecks) != 0)
            generator.comment("MIgnoreTypeScopeMetaChecks");
        if ((class_.m_nClassFlags & SCHEMA_CF1_INFO_TAG_MNetworkNoBase) != 0)
            generator.comment("MNetworkNoBase");
        if ((class_.m_nClassFlags & SCHEMA_CF1_INFO_TAG_MNetworkAssumeNotNetworkable) != 0)
            generator.comment("MNetworkAssumeNotNetworkable");
#endif

        if (class_.m_nStaticMetadataSize > 0)
            generator.comment("");

        for (const auto& metadata : class_.GetStaticMetadata()) {
            if (const auto value = GetMetadataValue(metadata); !value.empty())
                generator.comment(std::format("static metadata: {} \"{}\"", metadata.m_szName, value));
            else
                generator.comment(std::format("static metadata: {}", metadata.m_szName));
        }
    }

    void PrintEnumInfo(codegen::IGenerator::self_ref generator, const CSchemaEnumBinding& enum_binding) {
        generator.comment(std::format("Enumerator count: {}", enum_binding.m_nEnumeratorCount))
            .comment(std::format("Alignment: {}", enum_binding.m_unAlignOf))
            .comment(std::format("Size: {:#x}", enum_binding.m_unSizeOf));

        if (enum_binding.m_nStaticMetadataSize > 0)
            generator.comment("");

        for (const auto& metadata : enum_binding.GetStaticMetadata()) {
            generator.comment(std::format("metadata: {}", metadata.m_szName));
        }
    }

    void AssembleEnum(codegen::IGenerator::self_ref generator, const CSchemaEnumBinding& schema_enum_binding) {
        // @note: @es3n1n: get type name by align size
        //
        const auto underlying_type_name = generator.get_uint(schema_enum_binding.m_unAlignOf * 8);

        // @note: @es3n1n: print meta info
        //
        PrintEnumInfo(generator, schema_enum_binding);

        // @note: @es3n1n: begin enum class
        //
        generator.begin_enum(schema_enum_binding.m_pszName, underlying_type_name);

        // @note: @og: build max based on numeric_limits of unAlignOf
        //
        const auto print_enum_item = [schema_enum_binding, &generator](const SchemaEnumeratorInfoData_t& field) {
            switch (schema_enum_binding.m_unAlignOf) {
            case 1:
                generator.enum_item(field.m_szName, field.m_uint8);
                break;
            case 2:
                generator.enum_item(field.m_szName, field.m_uint16);
                break;
            case 4:
                generator.enum_item(field.m_szName, field.m_uint32);
                break;
            case 8:
                generator.enum_item(field.m_szName, field.m_uint64);
                break;
            default:
                generator.enum_item(field.m_szName, field.m_uint64);
            }
        };

        // @note: @es3n1n: assemble enum items
        //
        for (const auto& field : schema_enum_binding.GetEnumeratorValues()) {
            // @note: @og: dump enum metadata
            //
            for (auto j = 0; j < field.m_nMetadataSize; j++) {
                auto field_metadata = field.m_pMetadata[j];

                if (auto data = GetMetadataValue(field_metadata); data.empty())
                    generator.comment(field_metadata.m_szName);
                else
                    generator.comment(std::format("{} \"{}\"", field_metadata.m_szName, data));
            }

            print_enum_item(field);
        }

        // @note: @es3n1n: we are done with this enum
        //
        generator.end_enum();
    }

    /// @return {type_name, array_sizes}
    std::pair<std::string, std::vector<std::size_t>> ParseArray(const CSchemaType& type) {
        const auto* ptr = type.GetRefClass();
        const auto& actual_type = ptr ? *ptr : type;

        std::string base_type;
        std::vector<std::size_t> sizes;

        if (actual_type.GetTypeCategory() == ETypeCategory::Schema_FixedArray) {
            // dump all sizes.
            auto* schema = reinterpret_cast<const CSchemaType_FixedArray*>(&actual_type);
            while (true) {
                sizes.emplace_back(schema->m_nElementCount);
                schema = reinterpret_cast<const CSchemaType_FixedArray*>(schema->m_pElementType);

                if (schema->GetTypeCategory() != ETypeCategory::Schema_FixedArray) {
                    base_type = schema->m_pszName;
                    break;
                }
            }
        }

        return {base_type, sizes};
    }

    /// @return Lifetime is bound to string viewed by @p type_name
    [[nodiscard]]
    std::string_view DecayTypeName(std::string_view type_name) {
        if (const auto found = type_name.find('['); found != std::string_view::npos) {
            // "array[123]" -> "array"
            type_name = type_name.substr(0, found);
        }
        if (const auto found = type_name.find('*'); found != std::string_view::npos) {
            // "pointer***" -> "pointer"
            type_name = type_name.substr(0, found);
        }

        return type_name;
    }

    /// @return @ref std::nullopt if the type is not contained in a module visible in @p scope
    std::optional<std::string> GetModuleOfTypeInScope(const CSchemaSystemTypeScope& scope, std::string_view type_name) {
        assert((DecayTypeName(type_name) == type_name) &&
               "you need to decay your type names before using them for lookups. you probably need to decay them anyway if you intend to you them for "
               "anything really, so do it before calling this function.");

        if (const auto* class_ = scope.FindDeclaredClass(std::string{type_name})) {
            return class_->m_pszModule;
        } else if (const auto* enum_ = scope.FindDeclaredEnum(std::string{type_name})) {
            return enum_->m_pszModule;
        } else {
            return std::nullopt;
        }
    }

    /// @return @ref std::nullopt if the type is not contained in a module visible in its scope, e.g. because it is a built-in type
    std::optional<std::string> GetModuleOfType(const CSchemaType& type) {
        if (type.m_pTypeScope != nullptr) {
            return GetModuleOfTypeInScope(*type.m_pTypeScope, DecayTypeName(type.m_pszName));
        } else {
            return std::nullopt;
        }
    }

    /// @param type_name Unqualified
    [[nodiscard]] std::string EscapeTypeName(const codegen::IGenerator& generator, const std::string_view type_name) {
        // This is a hack to support nested types.
        // When we define nested types, they're not actually nested, but contain their outer class' name in their name,
        // e.g. "struct Player { struct Hand {}; };" is emitted as
        // "struct Player {}; struct Player__Hand{};".
        // But when used as a property, types expect `Hand` in `Player`, i.e. `Player::Hand m_hand;`
        // Instead of doing this hackery, we should probably declare nested classes as nested classes.
        return absl::StrReplaceAll(generator.escape_type_name(type_name), {{"::", "_"}});
    }

    /// Adds the module specifier to @p type_name, if @p type_name is declared in @p scope. Otherwise returns @p type_name unmodified.
    std::string MaybeWithModuleName(const codegen::IGenerator& generator, const CSchemaSystemTypeScope& scope, const std::string_view type_name) {
        const auto escaped_type_name = EscapeTypeName(generator, type_name);
        return GetModuleOfTypeInScope(scope, type_name)
            .transform([&](const auto module_name) { return std::format("source2sdk::{}::{}", module_name, escaped_type_name); })
            .value_or(escaped_type_name);
    }

    /// Decomposes a templated type into its components, keeping template
    /// syntax for later reassembly by @ref ReassembleRetypedTemplate().
    /// e.g. "HashMap<int, Vector<float>>" -> ["HashMap", '<', "int", ',', "Vector", '<', "float", '>', '>']
    /// @return std::string for types, char for syntax (',', '<', '>'). Spaces are removed.
    [[nodiscard]]
    std::vector<std::variant<std::string, char>> DecomposeTemplate(std::string_view type_name) {
        // TODO: use a library for this once we have a package manager
        const auto trim = [](std::string_view str) {
            if (const auto found = str.find_first_not_of(' '); found != std::string_view::npos) {
                str.remove_prefix(found);
            } else {
                return std::string_view{};
            }

            if (const auto found = str.find_last_not_of(' '); found != std::string_view::npos) {
                str.remove_suffix(str.size() - (found + 1));
            }

            return str;
        };

        /// Preserves separators in output. Removes space.
        const auto split_trim = [trim](std::string_view str, std::string_view separators) -> std::vector<std::variant<std::string, char>> {
            std::vector<std::variant<std::string, char>> result{};
            std::string_view remainder = str;

            while (true) {
                if (const auto found = remainder.find_first_of(separators); found != std::string_view::npos) {
                    if (const auto part = trim(remainder.substr(0, found)); !part.empty()) {
                        result.emplace_back(std::string{part});
                    }
                    result.emplace_back(remainder[found]);
                    remainder.remove_prefix(found + 1);
                } else {
                    if (const auto part = trim(remainder); !part.empty()) {
                        result.emplace_back(std::string{part});
                    }
                    break;
                }
            }

            return result;
        };

        return split_trim(type_name, "<,>");
    }

    /// e.g. "HashMap<int, CUtlVector<float>>" -> ["HashMap", "int", "CUtlVector", "float"]
    /// @return An empty list if @p type_name is not a template or has no template parameters
    [[nodiscard]]
    std::vector<std::string> ParseTemplateRecursive(std::string_view type_name) {
        std::vector<std::string> result{};

        // remove the topmost type and all syntax entries
        for (const auto& el : DecomposeTemplate(type_name)) {
            if (std::holds_alternative<std::string>(el)) {
                result.emplace_back(std::get<std::string>(el));
            }
        }

        return result;
    }

    std::unique_ptr<codegen::IGenerator> GetGeneratorForLanguage(source2_gen::Language language) {
        switch (language) {
        case source2_gen::Language::cpp:
            return std::make_unique<codegen::generator_cpp_t>();
        case source2_gen::Language::c:
            return std::make_unique<codegen::generator_c_t>();
        case source2_gen::Language::c_ida:
            // c-ida uses the c generator.
            // generator options are adjusted by Dump()
            // postprocessing happens in PostProcessCIDA()
            return std::make_unique<codegen::generator_c_t>();
        }

        assert(false && "unhandled enumerator");
        std::abort();
    }

    /// Adds module qualifiers and resolves built-in types.
    std::string ReassembleRetypedTemplate(const codegen::IGenerator& generator, const CSchemaSystemTypeScope& scope,
                                          const std::vector<std::variant<std::string, char>>& decomposed) {
        std::string result{};

        for (const auto& el : decomposed) {
            std::visit(
                [&](const auto& e) {
                    if constexpr (std::is_same_v<std::decay_t<decltype(e)>, char>) {
                        result += e;
                    } else {
                        if (const auto built_in = generator.find_built_in(e)) {
                            result += built_in.value();
                        } else {
                            // e is a dirty name, e.g. "CPlayer*[10]". We need to add the module, but keep it dirty.
                            const auto type_name = DecayTypeName(e);
                            const auto type_name_with_module = MaybeWithModuleName(generator, scope, type_name);
                            const auto dirty_type_name_with_module = std::string{e}.replace(e.find(type_name), type_name.length(), type_name_with_module);
                            result += dirty_type_name_with_module;
                        }
                    }
                },
                el);
        }

        return result;
    }

    /// @return {type_name, array_sizes} where type_name is a fully qualified name
    std::pair<std::string, std::vector<std::size_t>> GetType(const codegen::IGenerator& generator, const CSchemaType& type) {
        const auto [type_name, array_sizes] = ParseArray(type);

        assert(type_name.empty() == array_sizes.empty());

        const auto type_name_with_modules =
            ReassembleRetypedTemplate(generator, *type.m_pTypeScope, DecomposeTemplate(type_name.empty() ? type.m_pszName : type_name));

        if (!type_name.empty() && !array_sizes.empty())
            return {type_name_with_modules, array_sizes};

        return {type_name_with_modules, {}};
    }

    // We assume that everything that is not a pointer is odr-used.
    // This assumption not correct, e.g. template classes that internally store pointers are
    // not always odr-users of a type. It's good enough for what we do though.
    [[nodiscard]]
    constexpr bool IsOdrUse(std::string_view type_name) {
        return !type_name.contains('*');
    }

    /// @return All names used by @p type. Returns multiple names for template
    /// types.
    [[nodiscard]]
    std::set<NameLookup> GetRequiredNamesForType(const CSchemaType& type) {
        // m_pTypeScope can be nullptr for built-in types
        if (type.m_pTypeScope != nullptr) {
            std::set<NameLookup> result{};

            const auto destructured = ParseTemplateRecursive(type.m_pszName);

            // This is a slight hack to break dependency cycles. Some template types don't odr-use
            // their template arguments during their declaration, think std::unique_ptr.
            // There's no foolproof way to detect those template types, so we're hardcoding the ones that are
            // known to cause circular dependencies.
            static std::unordered_set<std::string_view> non_odr_containers{"CHandle"};
            bool is_used_in_non_odr_container = false;

            for (const auto& dirty_type_name : destructured) {
                const auto type_name = DecayTypeName(dirty_type_name);

                if (auto module{GetModuleOfTypeInScope(*type.m_pTypeScope, type_name)}) {
                    const auto source =
                        (!is_used_in_non_odr_container && IsOdrUse(dirty_type_name)) ? NameSource::include : NameSource::forward_declaration;

                    result.emplace(NameLookup{.module = std::move(module.value()), .type_name = std::string{type_name}, .source = source});
                }

                is_used_in_non_odr_container = non_odr_containers.contains(type_name);
            }

            return result;
        } else {
            return {};
        }
    }

    /// @return All names that are required to define @p classes
    std::set<NameLookup> GetRequiredNamesForClass(const CSchemaClassBinding& class_) {
        std::set<NameLookup> result{};

        for (const auto& field : std::span{class_.m_pFields, static_cast<std::size_t>(class_.m_nFieldSize)}) {
            const auto names = GetRequiredNamesForType(*field.m_pSchemaType);
            result.insert(names.begin(), names.end());
        }

        if (const auto* base_classes = class_.m_pBaseClasses; base_classes != nullptr) {
            assert(base_classes->m_pClass->m_pSchemaType != nullptr && "didn't think this could happen, feel free to touch");
            // source2gen doesn't support multiple inheritance, only check class[0]
            const auto includes = GetRequiredNamesForType(*base_classes[0].m_pClass->m_pSchemaType);
            result.insert(includes.begin(), includes.end());
        }

        const auto is_self = [self_module{GetModuleOfType(*class_.m_pSchemaType).value()}, self_type_name{class_.GetName()}](const auto& that) {
            return (that.module == self_module) && (that.type_name == self_type_name);
        };

        // don't forward-declare or include self. happens for self-referencing types, e.g. entity2::CEntityComponentHelper
        if (const auto found = std::ranges::find_if(result, is_self); found != result.end()) {
            result.erase(found);
        }

        return result;
    }

    [[nodiscard]]
    ClassAssemblyState AssembleBitfield(codegen::IGenerator& generator, ClassAssemblyState&& state) {
        state.assembling_bitfield = false;

        std::size_t exact_bitfield_size_bits = 0;
        for (const auto& entry : state.bitfield) {
            exact_bitfield_size_bits += entry.size;
        }
        const auto type_name = field_parser::guess_bitfield_type(exact_bitfield_size_bits);

        generator.begin_bitfield_block();

        for (const auto& entry : state.bitfield) {
            for (const auto& field_metadata : entry.metadata) {
                if (auto data = GetMetadataValue(field_metadata); data.empty())
                    generator.comment(std::format("metadata: {}", field_metadata.m_szName));
                else
                    generator.comment(std::format("metadata: {} \"{}\"", field_metadata.m_szName, data));
            }

            generator.prop(codegen::Prop{.type_name = type_name, .name = entry.name, .bitfield_size = entry.size}, true);
        }

        generator.end_bitfield_block(false).reset_tabs_count().comment(std::format("{:d} bits", exact_bitfield_size_bits)).restore_tabs_count();

        state.bitfield.clear();
        state.last_field_offset = state.last_field_offset.value_or(0) + state.last_field_size.value_or(0);
        // call to bit_ceil() relies on guess_bitfield_type() returning the next highest power of 2
        state.last_field_size = std::bit_ceil(std::max(std::size_t{8}, exact_bitfield_size_bits)) / 8;

        return state;
    }

    /// Does not insert a pad if it would have size 0
    void InsertPadUntil(codegen::IGenerator::self_ref generator, const ClassAssemblyState& state, std::int32_t offset, bool verbose) {
        if (verbose) {
            generator.comment(std::format("last_field_offset={} last_field_size={}",
                                          state.last_field_offset.transform(&util::to_hex_string).value_or("none"),
                                          state.last_field_size.transform(&util::to_hex_string).value_or("none")));
        }

        const auto expected_offset = state.last_field_offset.value_or(0) + state.last_field_size.value_or(0);

        // insert padding only if needed
        if (expected_offset < static_cast<std::int64_t>(offset) && !state.assembling_bitfield) {
            generator
                .struct_padding(
                    codegen::Padding{
                        .pad_offset = expected_offset,
                        .size = codegen::Padding::Bytes{static_cast<std::size_t>(offset - expected_offset)},
                    },
                    false)
                .reset_tabs_count()
                .comment(std::format("{:#x}", expected_offset))
                .restore_tabs_count();
        }
    }

    void AssembleClass(const source2_gen::Options& options, sdk::GeneratorCache& cache, codegen::IGenerator::self_ref generator,
                       const CSchemaClassBinding& class_) {
        static constexpr std::size_t source2_max_align = 8;

        // TODO: when we have a CLI parser: pass this property in from the outside
        constexpr bool verbose = false;

        struct cached_datamap_t {
            std::string type_;
            std::string name_;
            std::ptrdiff_t offset_;
        };

        // @note: @es3n1n: get class info, assemble it
        //
        const auto* class_parent = class_.m_pBaseClasses ? class_.m_pBaseClasses->m_pClass : nullptr;
        const auto class_size = class_.GetSize();
        const auto class_alignment = GetClassAlignmentRecursive(cache.class_alignment, class_);
        // Source2 has alignof(max_align_t)=8, i.e. every class whose size is a multiple of 8 is aligned.
        const auto class_is_aligned = (class_size % class_alignment.value_or(source2_max_align)) == 0;
        const auto is_struct = util::IsStruct(class_.m_pszName);

        if (!class_is_aligned) {
            const auto warning = [&]() {
                if (class_alignment.has_value()) {
                    // ceil size to next possible aligned size
                    const auto aligned_size = class_size + (class_alignment.value() - (class_size % class_alignment.value())) % class_alignment.value();

                    return std::format("Type {} is misaligned. Its size should be {:#x}, but with proper alignment it has size {:#x}.", class_.GetName(),
                                       class_size, aligned_size);
                } else {
                    return std::format("Type {} appears to be misaligned. Its alignment is unknown and it is not aligned to max_align_t ({}).",
                                       class_.GetName(), source2_max_align);
                }
            }();
            warn(warning);
            generator.comment(warning);
            generator.comment("It has been replaced by a dummy. You can try uncommenting the struct below.");
            generator.begin_struct(class_.GetName());
            generator.struct_padding(codegen::Padding{.pad_offset = 0, .size = codegen::Padding::Bytes{static_cast<std::size_t>(class_size)}}, false);
            generator.end_struct();
        }

        PrintClassInfo(cache, generator, class_);

        // @note: @es3n1n: get parent name
        //
        const std::string parent_class_name =
            (class_parent != nullptr) ? MaybeWithModuleName(generator, *class_parent->m_pTypeScope, class_parent->m_pszName) : "";
        const std::optional<std::ptrdiff_t> parent_class_size = class_parent ? std::make_optional(class_parent->m_nSizeOf) : std::nullopt;

        if (!class_is_aligned) {
            generator.begin_multi_line_comment();
        }

        // @note: @es3n1n: field assembling state
        //
        ClassAssemblyState state = {.last_field_size = parent_class_size};

        // @note: @es3n1n: if we need to pad first field or if there's no fields in this class
        // and we need to properly pad it to make sure its size is the same as we expect it
        //
        const auto* first_field = (class_.m_pFields == nullptr) ? nullptr : &class_.m_pFields[0];
        const std::optional<std::ptrdiff_t> first_field_offset =
            (first_field != nullptr) ? std::make_optional(first_field->m_nSingleInheritanceOffset) : std::nullopt;

        // @todo: @es3n1n: if for some mysterious reason this class describes fields
        // of the base class we should handle it too.
        if ((class_parent != nullptr) && first_field_offset.has_value() && first_field_offset.value() < parent_class_size.value()) {
            const auto warning = std::format("Collision detected: {} and its base {} have {:#x} overlapping byte(s)", class_.GetName(), parent_class_name,
                                             parent_class_size.value() - first_field_offset.value());
            warn(warning);
            generator.comment(warning);
            state.collision_end_offset = parent_class_size.value();
        }

        // @note: @es3n1n: start class
        //
        generator.pack_push(1); // we are aligning stuff ourselves
        if (is_struct) {
            if (class_parent != nullptr) {
                generator.begin_struct_with_base_type(class_.m_pszName, parent_class_name);
            } else {
                generator.begin_struct(class_.m_pszName);
            }
        } else {
            if (class_parent != nullptr) {
                generator.begin_class_with_base_type(class_.m_pszName, parent_class_name);
            } else {
                generator.begin_class(class_.m_pszName);
            }
        }

        /// If fields cannot be emitted, e.g. because of collisions, they're added to
        /// this set so we can ignore them when asserting offsets.
        std::unordered_set<std::string> skipped_fields{};
        std::list<std::pair<std::string, std::ptrdiff_t>> cached_fields{};
        std::list<cached_datamap_t> cached_datamap_fields{};

        for (const auto& field : class_.GetFields()) {
            // Fall back to size=1 because there are no 0-sized types.
            // `RenderPrimitiveType_t` is the only type (in CS2 9035763) without size information.
            const auto field_size = field.m_pSchemaType->GetSize().value_or(1);
            const auto field_alignment = GetAlignmentOfTypeRecursive(cache.class_alignment, *field.m_pSchemaType);

            // @note: @es3n1n: parsing type
            //
            // type_name is fully qualified
            const auto [type_name, array_sizes] = GetType(generator, *field.m_pSchemaType);
            const auto var_info = field_parser::parse(generator, type_name, field.m_pszName, array_sizes);

            // @fixme: @es3n1n: todo proper collision fix and remove this block
            if (state.collision_end_offset && field.m_nSingleInheritanceOffset < state.collision_end_offset) {
                skipped_fields.emplace(field.m_pszName);
                // A warning has already been logged at the start of the class
                generator.comment(
                    std::format("Skipped field \"{}\" @ {:#x} because of the struct collision", field.m_pszName, field.m_nSingleInheritanceOffset));
                generator.comment("", false)
                    .reset_tabs_count()
                    .prop(codegen::Prop{.type_category = GetTypeCategory(field), .type_name = var_info.m_type, .name = var_info.formatted_name()})
                    .restore_tabs_count();
                continue;
            }

            // Collect all bitfield entries and emit them later. We need to know
            // how large the bitfield is in order to choose the right type. We
            // only know how large the bitfield is once we've reached its end.
            if (var_info.is_bitfield()) {
                if (!state.assembling_bitfield) {
                    state.assembling_bitfield = true;
                    state.bitfield_start = field.m_nSingleInheritanceOffset;
                }

                state.bitfield.emplace_back(BitfieldEntry{
                    .name = var_info.m_name,
                    .size = var_info.m_bitfield_size,
                    .metadata = std::vector(field.m_pMetadata, field.m_pMetadata + field.m_nMetadataSize),
                });
                continue;
            }

            // At this point, we're never still inside a bitfield. If `assembling_bitfield` is set, that means we're at the first field following a
            // bitfield, but the bitfield has not been emitted yet.
            // note: in CS2, there are no types with padding before a bitfield
            InsertPadUntil(generator, state, state.assembling_bitfield ? state.bitfield_start : field.m_nSingleInheritanceOffset, verbose);

            // This is the first field after a bitfield, i.e. the active bitfield has ended. Emit the bitfield we have collected.
            if (state.assembling_bitfield) {
                state = AssembleBitfield(generator, std::move(state));

                // We need another pad here because the current loop iteration is already on a non-bitfield field which will get emitted right away.
                InsertPadUntil(generator, state, field.m_nSingleInheritanceOffset, verbose);
            }

            // @note: @es3n1n: dump metadata
            //
            for (auto j = 0; j < field.m_nMetadataSize; j++) {
                const auto field_metadata = field.m_pMetadata[j];

                if (auto data = GetMetadataValue(field_metadata); data.empty())
                    generator.comment(std::format("metadata: {}", field_metadata.m_szName));
                else
                    generator.comment(std::format("metadata: {} \"{}\"", field_metadata.m_szName, data));
            }

            // @note: @es3n1n: update state
            //
            state.last_field_offset = field.m_nSingleInheritanceOffset;
            state.last_field_size = static_cast<std::size_t>(field_size);

            if (const auto e_class = field.m_pSchemaType->GetAsDeclaredClass(); e_class != nullptr && e_class->m_pClassInfo == nullptr) {
                // missing class info

                /// @note: @es3n1n: game bug:
                ///     There are some classes that have literally no info about them in schema,
                ///     for these fields we'll just insert a pad.
                generator.comment(std::format("game bug: prop with no declared class info ({})", e_class->m_pszName));
                generator.prop(codegen::Prop{.type_category = codegen::TypeCategory::built_in,
                                             .type_name = "char",
                                             .name = std::format("{}[{:#x}]", var_info.m_name, field_size)},
                               false);
            } else if ((field.m_nSingleInheritanceOffset % field_alignment.value_or(source2_max_align)) != 0) {
                // misaligned field

                const auto warning =
                    field_alignment.has_value() ?
                        std::format("Property {}::{} is misaligned.", class_.GetName(), field.m_pszName) :
                        std::format("Property {}::{} appears to be misaligned. Its alignment is unknown and it is not aligned to max_align_t ({}).",
                                    class_.GetName(), field.m_pszName, source2_max_align);
                warn(warning);
                generator.comment(warning);
                generator.prop(codegen::Prop{.type_category = codegen::TypeCategory::built_in,
                                             .type_name = "char",
                                             .name = std::format("{}[{:#x}]", var_info.m_name, field_size)},
                               true);
                generator.comment("", false)
                    .reset_tabs_count()
                    .prop(codegen::Prop{.type_category = GetTypeCategory(field), .type_name = var_info.m_type, .name = var_info.formatted_name()}, false)
                    .restore_tabs_count();
            } else if (std::string{field.m_pSchemaType->m_pszName}.contains('<')) {
                // template type

                // This is a workaround to get the size of template types right.
                // There are types that have non-type template parameters, e.g.
                // `CUtlLeanVectorFixedGrowable<int, 10>`. The non-type template parameter affects the size of the template type, but the schema system
                // doesn't store information about non-type template parameters. The schema system just says `CUtlLeanVectorFixedGrowable<int>`, which
                // is insufficient to generate a `CUtlLeanVectorFixedGrowable` with correct size.`
                // To still keep the rest of the class in order, we replace all template fields with char arrays.
                // We're applying this workaround to all template type, even those that don't have non-type template parameters, because we can't tell
                // them apart. So we're certainly commenting out more than is necessary.
                generator.comment(std::format(
                    "{} has a template type with potentially unknown template parameters. You can try uncommenting the field below.", var_info.m_name));
                generator.comment("", false);
                generator.reset_tabs_count()
                    .prop(codegen::Prop{.type_category = GetTypeCategory(field), .type_name = var_info.m_type, .name = var_info.formatted_name()}, true)
                    .restore_tabs_count();
                generator.prop(codegen::Prop{.type_category = codegen::TypeCategory::built_in,
                                             .type_name = "char",
                                             .name = std::format("{}[{:#x}]", var_info.m_name, field_size)},
                               false);
            } else {
                // This is the "all normal, all good" `prop()` call
                generator.prop(codegen::Prop{.type_category = GetTypeCategory(field), .type_name = var_info.m_type, .name = var_info.formatted_name()},
                               false);
            }

            if (verbose) {
                generator.reset_tabs_count()
                    .comment(std::format("type.name=\"{}\" offset={:#x} size={:#x} alignment={}", std::string_view{field.m_pSchemaType->m_pszName},
                                         field.m_nSingleInheritanceOffset, field_size,
                                         field_alignment.transform(&util::to_hex_string).value_or("unknown")),
                             false)
                    .restore_tabs_count();
            } else {
                generator.reset_tabs_count().comment(std::format("{:#x}", field.m_nSingleInheritanceOffset), false).restore_tabs_count();
            }
            cached_fields.emplace_back(var_info.formatted_name(), field.m_nSingleInheritanceOffset);

            generator.next_line();
        }

        // @note: @es3n1n: if struct ends with bitfield we should end bitfield before ending the class
        //
        if (state.assembling_bitfield) {
            state = AssembleBitfield(generator, std::move(state));
        }

        // pad the class end.
        const auto last_field_end = state.last_field_offset.value_or(0) + state.last_field_size.value_or(0);
        const auto end_pad = class_size - last_field_end;

        // The `(class_size != 1)` check is here because of empty classes. If
        // we generated a pad for empty classes, they'd no longer have standard-layout.
        // The pad isn't necessary for such classes, because the compiler will make them have size=1.
        if ((end_pad != 0) && (class_size != 1)) {
            generator.struct_padding(
                codegen::Padding{
                    .pad_offset = last_field_end,
                    .size = codegen::Padding::Bytes{static_cast<std::size_t>(end_pad)},
                },
                true);
        } else if (static_cast<std::size_t>(class_size) < static_cast<std::size_t>(last_field_end)) [[unlikely]] {
            throw std::runtime_error{std::format("{} overflows by {:#x} byte(s). Its last field ends at {:#x}, but {} ends at {:#x}", class_.GetName(),
                                                 -end_pad, last_field_end, class_.GetName(), class_size)};
        }

        // The current class may be defined in multiple scopes. It doesn't matter which one we use, as all definitions are the same..
        // TODO: verify the above statement. Are static fields really shared between scopes?
        const std::string scope_name{class_.m_pTypeScope->BGetScopeName()};

        if (class_.m_pFieldMetadataOverrides && class_.m_pFieldMetadataOverrides->m_iTypeDescriptionCount > 1) {
            const auto& dm = class_.m_pFieldMetadataOverrides;

            for (std::uint64_t s = 0; s < dm->m_iTypeDescriptionCount; s++) {
                auto* t = &dm->m_pTypeDescription[s];
                if (!t)
                    continue;

                if (t->GetFieldName().empty())
                    continue;

                const auto var_info = field_parser::parse(t->m_iFieldType, t->GetFieldName(), t->m_nFieldSize);

                std::string field_type = var_info.m_type;
                if (t->m_iFieldType == fieldtype_t::FIELD_EMBEDDED) {
                    field_type = t->m_pDataMap->m_pszClassName;
                }

                std::string field_name = var_info.formatted_name();

                // @note: @og: if schema dump already has this field, then just skip it

                if (const auto it =
                        std::ranges::find_if(cached_fields, [t, field_name](const auto& f) { return f.first == field_name && f.second == t->m_iOffset; });
                    it != cached_fields.end())
                    continue;

                cached_datamap_fields.emplace_back(field_type, field_name, t->m_iOffset);
            }

            if (!cached_datamap_fields.empty()) {
                if (class_.m_nFieldSize)
                    generator.next_line();

                generator.comment("Datamap fields:");
                for (auto& [field_type, field_name, field_offset] : cached_datamap_fields) {
                    generator.comment(std::format("{} {}; // {:#x}", field_type, field_name, field_offset));
                }
            }
        }

        if (!class_.m_nFieldSize && !class_.m_nStaticMetadataSize)
            generator.comment("No schema binary for binding");

        if (is_struct) {
            generator.end_struct();
        } else {
            generator.end_class();
        }

        generator.pack_pop();
        generator.next_line();

        const bool is_standard_layout_class = IsStandardLayoutClass(cache.class_has_standard_layout, class_);

        if (options.static_assertions) {
            // TODO: when we have a CLI parser: allow users to generate assertions in non-standard-layout classes. Those assertions are
            // conditionally-supported by compilers.
            if (is_standard_layout_class) {
                for (const auto& field :
                     class_.GetFields() | std::ranges::views::filter([&](const auto& e) { return !skipped_fields.contains(e.m_pszName); })) {
                    if (field.m_pSchemaType->m_unTypeCategory == ETypeCategory::Schema_Bitfield) {
                        generator.comment(std::format("Cannot assert offset of bitfield {}::{}", class_.m_pszName, field.m_pszName));
                    } else {
                        generator.static_assert_offset(MaybeWithModuleName(generator, *class_.m_pTypeScope, class_.m_pszName), field.m_pszName,
                                                       field.m_nSingleInheritanceOffset);
                    }
                }
            } else {
                if (class_.m_nFieldSize != 0) {
                    generator.comment(std::format("Cannot assert offsets of fields in {} because it is not a standard-layout class", class_.m_pszName));
                }
            }
        }

        if (!class_is_aligned) {
            generator.end_multi_line_comment();
        }

        generator.next_line();

        if (options.static_assertions) {
            generator.static_assert_size(MaybeWithModuleName(generator, *class_.m_pTypeScope, class_.m_pszName), class_size);
        }
    }

    [[nodiscard]]
    std::filesystem::path GetFilePathForType(const codegen::IGenerator& generator, std::string_view module_name, std::string_view type_name) {
        return std::format("{}/include/{}/{}/{}.{}", kOutDirName, kIncludeDirName, module_name, EscapeTypeName(generator, DecayTypeName(type_name)),
                           generator.get_file_extension());
    }

    /// @return Path to the generated file
    std::filesystem::path GenerateEnumSdk(const source2_gen::Options& options, std::string_view module_name, const CSchemaEnumBinding& enum_) {
        // @note: @es3n1n: init codegen
        //
        auto p_generator = GetGeneratorForLanguage(options.emit_language);
        auto& generator = *p_generator;

        generator.preamble();

        // @note: @es3n1n: print banner
        //
        generator.next_line()
            .comment("/////////////////////////////////////////////////////////////")
            .comment(std::format("Module: {}", module_name))
            .comment(std::string{kCreatedBySource2genMessage})
            .comment("/////////////////////////////////////////////////////////////")
            .next_line();

        generator.begin_namespace("source2sdk");
        generator.begin_namespace(module_name);

        // @note: @es3n1n: assemble props
        //
        AssembleEnum(generator, enum_);

        generator.end_namespace();
        generator.end_namespace();

        // @note: @es3n1n: write generated data to output file
        //
        if (!std::filesystem::exists(kOutDirName))
            std::filesystem::create_directories(kOutDirName);

        const auto out_file_path = GetFilePathForType(generator, module_name, enum_.m_pszName).string();

        std::ofstream f(out_file_path, std::ios::out);
        f << generator.str();
        if (!f.good()) {
            std::cerr << std::format("Could not write to {}: {}", out_file_path, std::strerror(errno)) << std::endl;
            // This std::exit() is bad. Instead, we could return the dumped
            // header name and content to the caller in a std::expected. Let the
            // caller write the file. That would also allow the caller to choose
            // the output directory and handle errors.
            std::exit(1);
        }

        return out_file_path;
    }

    /// @return Path to the generated file
    std::filesystem::path GenerateClassSdk(const source2_gen::Options& options, sdk::GeneratorCache& cache, std::string_view module_name,
                                           const CSchemaClassBinding& class_) {
        // @note: @es3n1n: init codegen
        //
        auto p_generator = GetGeneratorForLanguage(options.emit_language);
        auto& generator = *p_generator;

        generator.preamble();

        const auto names = GetRequiredNamesForClass(class_);

        for (const auto& include : names | std::views::filter([](const auto& el) { return el.source == NameSource::include; })) {
            generator.include(std::format("{}/{}/{}", kIncludeDirName, include.module, EscapeTypeName(generator, include.type_name)),
                              codegen::IncludeOptions{
                                  .local = true,
                                  .system = false,
                              });
        }

        for (const auto& forward_declaration : names | std::views::filter([](const auto& el) { return el.source == NameSource::forward_declaration; })) {
            generator.begin_namespace("source2sdk");
            generator.begin_namespace(forward_declaration.module);
            generator.forward_declaration(forward_declaration.type_name);
            generator.end_namespace();
            generator.end_namespace();
        }

        // @note: @es3n1n: print banner
        //
        generator.next_line()
            .comment("/////////////////////////////////////////////////////////////")
            .comment(std::format("Module: {}", module_name))
            .comment(std::string{kCreatedBySource2genMessage})
            .comment("/////////////////////////////////////////////////////////////")
            .next_line();

        generator.begin_namespace("source2sdk");
        generator.begin_namespace(module_name);

        // @note: @es3n1n: assemble props
        //
        AssembleClass(options, cache, generator, class_);

        generator.end_namespace();
        generator.end_namespace();

        // @note: @es3n1n: write generated data to output file
        //
        const auto out_file_path = GetFilePathForType(generator, module_name, class_.m_pszName).string();
        std::ofstream f(out_file_path, std::ios::out);
        f << generator.str();
        if (!f.good()) {
            std::cerr << std::format("Could not write to {}: {}", out_file_path, std::strerror(errno)) << std::endl;
            // This std::exit() is bad. Instead, we could return the dumped
            // header name and content to the caller in a std::expected. Let the
            // caller write the file. That would also allow the caller to choose
            // the output directory and handle errors.
            std::exit(1);
        }

        return out_file_path;
    }
} // namespace

namespace sdk {
    GeneratorResult GenerateTypeScopeSdk(const source2_gen::Options& options, GeneratorCache& cache, std::string_view module_name,
                                         const std::unordered_set<const CSchemaEnumBinding*>& enums,
                                         const std::unordered_set<const CSchemaClassBinding*>& classes) {
        // @note: @es3n1n: print debug info
        //
        std::cout << std::format("{}: Assembling module {} with {} enum(s) and {} class(es)", __FUNCTION__, module_name, enums.size(), classes.size())
                  << std::endl;

        const std::filesystem::path out_directory_path = std::format("{}/include/{}/{}", kOutDirName, kIncludeDirName, module_name);

        if (!std::filesystem::exists(out_directory_path))
            std::filesystem::create_directories(out_directory_path);

        GeneratorResult result{};

        std::ranges::for_each(enums, [&](const auto* el) { result.generated_files.emplace(GenerateEnumSdk(options, module_name, *el)); });
        std::ranges::for_each(classes, [&](const auto* el) { result.generated_files.emplace(GenerateClassSdk(options, cache, module_name, *el)); });

        return result;
    }
} // namespace sdk

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/src/startup/startup.cpp`:

```cpp
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#include "options.hpp"
#include "tools/util.h"
#include <array>
#include <filesystem>
#include <fstream>
#include <Include.h>
#include <iostream>
#include <iterator>
#include <sdk/sdk.h>
#include <span>
#include <string>
#include <tools/loader/loader.h>
#include <tools/platform.h>
#include <unordered_map>
#include <unordered_set>
#include <utility>

namespace {
    [[nodiscard]] auto GetRequiredModules() {
        // clang-format off
        return std::to_array<std::string>({
            loader::get_module_file_name("client"),
            loader::get_module_file_name("engine2"),
            loader::get_module_file_name("schemasystem"),
            loader::get_module_file_name("tier0"),

#if defined(DOTA2)
            loader::get_module_file_name("navsystem"),
#elif defined(CS2)
            loader::get_module_file_name("matchmaking"),
#endif

            loader::get_module_file_name("animationsystem"),
            loader::get_module_file_name("host"),
            loader::get_module_file_name("materialsystem2"),
            loader::get_module_file_name("meshsystem"),
            loader::get_module_file_name("networksystem"),
            loader::get_module_file_name("panorama"),
            loader::get_module_file_name("particles"),
            loader::get_module_file_name("pulse_system"),
            IF_WINDOWS(loader::get_module_file_name("rendersystemdx11"),)
            loader::get_module_file_name("resourcesystem"),
            loader::get_module_file_name("scenefilecache"),
            loader::get_module_file_name("scenesystem"),
            loader::get_module_file_name("server"),
            loader::get_module_file_name("soundsystem"),
            loader::get_module_file_name("vphysics2"),
            loader::get_module_file_name("worldrenderer"),
            IF_WINDOWS(loader::get_module_file_name("assetpreview"),)
        });
        // clang-format on
    }
} // namespace

namespace source2_gen {
    // TODO: this duplicate of the constant in sdk.h. We should let the user specify the sdk path via Options.
    constexpr std::string_view kOutDirName = "sdk";

    struct module_dump {
        std::unordered_set<const CSchemaEnumBinding*> enums{};
        std::unordered_set<const CSchemaClassBinding*> classes{};
    };

    /// @return Key is the module name
    std::unordered_map<std::string, module_dump> CollectModules(std::span<CSchemaSystemTypeScope*> type_scopes) {
        struct unique_module_dump {
            /// Key is the enum name. Used for de-duplication.
            std::unordered_map<std::string, CSchemaEnumBinding*> enums{};
            /// Key is the class name. Used for de-duplication.
            std::unordered_map<std::string, CSchemaClassBinding*> classes{};
        };

        // Key is the module name, e.g. SchemaEnumInfoData_t::m_pszModule.
        std::unordered_map<std::string, unique_module_dump> dumped_modules{};

        for (const auto* current_scope : type_scopes) {
            auto current_enums = current_scope->GetEnumBindings();
            for (auto el : current_enums.GetElements()) {
                auto& dump{dumped_modules.emplace(el->m_pszModule, unique_module_dump{}).first->second};
                dump.enums.emplace(el->m_pszName, el);
            }

            auto current_classes = current_scope->GetClassBindings();
            for (auto el : current_classes.GetElements()) {
                auto& dump{dumped_modules.emplace(el->m_pszModule, unique_module_dump{}).first->second};
                dump.classes.emplace(el->m_pszName, el);
            }
        }

        std::unordered_map<std::string, module_dump> result{};

        for (const auto& [module_name, unique_dump] : dumped_modules) {
            constexpr auto to_set = [](const auto& pair) {
                return pair.second;
            };

            module_dump dump{};

            std::ranges::transform(unique_dump.enums, std::inserter(dump.enums, dump.enums.end()), to_set);

            std::ranges::transform(unique_dump.classes, std::inserter(dump.classes, dump.classes.end()), to_set);

            result.emplace(module_name, dump);
        }

        return result;
    }

    /// A very basic C preprocessor.
    /// Writes contents of @p path to @p out while expanding `#include` directives
    void ExpandIncludesRecursive(std::ofstream& out, std::unordered_set<std::filesystem::path>& seen_files, const std::filesystem::path& path) {
        std::ifstream f(path);
        if (!f.good()) {
            std::cerr << std::format("Could not read from {}: {}", path.string(), std::strerror(errno)) << std::endl;
            std::exit(1);
        }

        std::string line{};
        while (std::getline(f, line)) {
            if (line.starts_with('#')) {
                constexpr std::string_view prefix = "#include \"source2sdk/";

                if (line.starts_with(prefix)) {
                    const std::filesystem::path include_path{std::string{kOutDirName} + "/include/source2sdk/" +
                                                             line.substr(prefix.length(), line.length() - (prefix.length() + 1))};
                    if (!seen_files.contains(include_path)) {
                        seen_files.emplace(include_path);
                        ExpandIncludesRecursive(out, seen_files, include_path);
                    }
                }
            } else {
                out << line << '\n';
            }
        }
    }

    // Post-processes an already-generated C SDK so it can be parsed by IDA.
    // - merges all files into a single file by resolving `#include`s
    void PostProcessCIDA(const std::unordered_set<std::filesystem::path>& generated_files) {
        const auto out_file_path = std::string{kOutDirName} + "/ida.h";
        std::ofstream out(out_file_path, std::ios::out);

        std::unordered_set<std::filesystem::path> seen_files{};

        for (const auto& file : generated_files) {
            ExpandIncludesRecursive(out, seen_files, file);
        }
    }

    [[nodiscard]]
    constexpr std::string_view GetStaticSdkName(source2_gen::Language language) {
        using enum source2_gen::Language;
        switch (language) {
        case cpp:
            return "cpp";
        case c:
        case c_ida:
            return "c";
        }

        assert(false && "unhandled enumerator");
    }

    [[nodiscard]]
    std::filesystem::path FindSdkStatic(const Options& options) {
        const auto directories = std::format("sdk-static/{}", GetStaticSdkName(options.emit_language));

        /// Try from the current cwd first
        if (auto path = std::filesystem::path(directories); is_directory(path)) {
            return path;
        }

        /// On windows, cwd will be `source2gen\build\bin\Release`.
        /// Let's walk back until we find our directory.
        constexpr std::size_t kDepth = 4;
        auto cwd = std::filesystem::current_path();
        for (std::size_t i = 0; i < kDepth; ++i) {
            cwd = cwd.parent_path();

            if (auto path = cwd / directories; is_directory(path)) {
                return path;
            }
        }

        throw std::runtime_error(std::format("Unable to find sdk-static: {}", directories));
    }

    bool Dump(Options options) try {
        std::locale::global(std::locale(""));
        std::cout.imbue(std::locale());

        const auto modules = GetRequiredModules();

        for (const auto& name : modules) {
            std::cout << std::format("{}: Loading {}", __FUNCTION__, name) << std::endl;

            if (loader::load_module(name).has_value()) {
                continue;
            }

            // cannot use any functions that use `new` because we've
            // overridden `new` in IMemAlloc.cpp and it relies on
            // libraries being loaded.
            std::cerr << std::format("{}: Unable to load module {}, is {} set?", __FUNCTION__, name, IF_WINDOWS("PATH") IF_LINUX("LD_LIBRARY_PATH"))
                      << std::endl;
            return false;
        }

        std::cout << std::format("{}: Starting", __FUNCTION__) << std::endl;

        // @note: @es3n1n: Capture interfaces
        //
        sdk::g_schema = CSchemaSystem::GetInstance();
        if (!sdk::g_schema) {
            std::cerr << std::format("{}: Unable to obtain Schema interface", __FUNCTION__) << std::endl;
            return false;
        }

        for (const auto& name : modules) {
            auto* handle = loader::find_module_handle(name);
            assert(handle != nullptr && "we loaded modules at startup, where did they go?");

            using InstallSchemaBindingsTy = std::uint8_t (*)(const char*, CSchemaSystem*);
            if (auto InstallSchemaBindings = loader::find_module_symbol<InstallSchemaBindingsTy>(handle, "InstallSchemaBindings");
                InstallSchemaBindings.has_value()) {
                if ((*InstallSchemaBindings)("SchemaSystem_001", sdk::g_schema)) {
                    continue;
                }

                std::cerr << std::format("{}: Unable to install schema bindings in {}", __FUNCTION__, name) << std::endl;
                return false;
            }

            std::cout << std::format("{}: No schemas in {}", __FUNCTION__, name) << std::endl;
        }

        // @note: @es3n1n: Obtaining type scopes and generating sdk
        const auto type_scopes = sdk::g_schema->GetTypeScopes();
        assert(type_scopes.Count() > 0 && "sdk is outdated");

        const std::unordered_map all_modules = CollectModules(std::span{type_scopes.m_pElements, static_cast<std::size_t>(type_scopes.m_Size)});

        sdk::GeneratorCache cache{};
        std::unordered_set<std::filesystem::path> generated_files{};

        for (const auto& [module_name, dump] : all_modules) {
            const auto result = sdk::GenerateTypeScopeSdk(options, cache, module_name, dump.enums, dump.classes);
            std::ranges::move(result.generated_files, std::inserter(generated_files, generated_files.end()));
        }

        // Throws an exception with descriptive message. No need for explicit error handling.
        // Need to do this before PostProcessCIDA() because sdk-static contains types that are
        // missing in the generated sdk.
        std::filesystem::copy(FindSdkStatic(options), kOutDirName,
                              std::filesystem::copy_options::recursive | std::filesystem::copy_options::overwrite_existing);

        if (options.emit_language == source2_gen::Language::c_ida) {
            PostProcessCIDA(generated_files);
        }

        std::cout << std::format("Schema stats: {} registrations; {} were redundant; {} were ignored ({} bytes of ignored data)",
                                 util::PrettifyNum(sdk::g_schema->GetRegistration()), util::PrettifyNum(sdk::g_schema->GetRedundant()),
                                 util::PrettifyNum(sdk::g_schema->GetIgnored()), util::PrettifyNum(sdk::g_schema->GetIgnoredBytes()))
                  << std::endl;

        return true;
    } catch (const std::runtime_error& err) {
        std::cout << std::format("{} :: ERROR :: {}", __FUNCTION__, err.what()) << std::endl;
        return false;
    }
} // namespace source2_gen

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/src/tools/field_parser.cpp`:

```cpp
// Copyright (C) 2024 neverlosecc
// See end of file for extended copyright information.
#include "tools/field_parser.h"
#include "tools/codegen/codegen.h"
#include <algorithm>
#include <array>
#include <bit>
#include <Include.h>
#include <sdk/interfaces/client/game/datamap_t.h>

namespace field_parser {
    namespace detail {
        namespace {
            using namespace std::string_view_literals;

            // The real prefix is "bitfield:", but we're escaping names
            // before parsing them
            constexpr std::string_view kBitfieldTypePrefix = "bitfield_"sv;

            // @note: @es3n1n: a list of possible integral types for bitfields (would be used in `guess_bitfield_type`)
            //
            constexpr auto kBitfieldIntegralTypes = std::to_array<std::pair<std::size_t, std::string_view>>({
                {8, "uint8_t"},
                {16, "uint16_t"},
                {32, "uint32_t"},
                {64, "uint64_t"},
            });

            constexpr auto kDatamapToCpp = std::to_array<std::pair<fieldtype_t, std::string_view>>({
                {fieldtype_t::FIELD_FLOAT32, "float"sv},
                {fieldtype_t::FIELD_TIME, "GameTime_t"sv},
                {fieldtype_t::FIELD_ENGINE_TIME, "float"sv},
                {fieldtype_t::FIELD_FLOAT64, "double"sv},
                {fieldtype_t::FIELD_INT16, "int16_t"sv},
                {fieldtype_t::FIELD_INT32, "int32_t"sv},
                {fieldtype_t::FIELD_INT64, "int64_t"sv},
                {fieldtype_t::FIELD_UINT8, "uint8_t"sv},
                {fieldtype_t::FIELD_UINT16, "uint16_t"sv},
                {fieldtype_t::FIELD_UINT32, "uint32_t"sv},
                {fieldtype_t::FIELD_UINT64, "uint64_t"sv},
                {fieldtype_t::FIELD_BOOLEAN, "bool"sv},
                {fieldtype_t::FIELD_CHARACTER, "char"sv},
                {fieldtype_t::FIELD_VOID, "void"sv},
                {fieldtype_t::FIELD_STRING, "CUtlSymbolLarge"sv},
                {fieldtype_t::FIELD_VECTOR, "Vector"sv},
                {fieldtype_t::FIELD_POSITION_VECTOR, "Vector"sv},
                {fieldtype_t::FIELD_NETWORK_ORIGIN_CELL_QUANTIZED_VECTOR, "Vector"sv},
                {fieldtype_t::FIELD_DIRECTION_VECTOR_WORLDSPACE, "Vector"sv},
                {fieldtype_t::FIELD_NETWORK_QUANTIZED_VECTOR, "Vector"sv},
                {fieldtype_t::FIELD_VECTOR2D, "Vector2D"sv},
                {fieldtype_t::FIELD_VECTOR4D, "Vector4D"sv},
                {fieldtype_t::FIELD_QANGLE, "QAngle"sv},
                {fieldtype_t::FIELD_QANGLE_WORLDSPACE, "QAngle"sv},
                {fieldtype_t::FIELD_QUATERNION, "Quaternion"sv},
                {fieldtype_t::FIELD_CSTRING, "const char *"sv},
                {fieldtype_t::FIELD_UTLSTRING, "CUtlString"sv},
                {fieldtype_t::FIELD_UTLSTRINGTOKEN, "CUtlStringToken"sv},
                {fieldtype_t::FIELD_COLOR32, "Color"sv},
                {fieldtype_t::FIELD_WORLD_GROUP_ID, "WorldGroupId_t"sv},
                {fieldtype_t::FIELD_ROTATION_VECTOR, "RotationVector"sv},
                {fieldtype_t::FIELD_CTRANSFORM_WORLDSPACE, "CTransform"sv},
                {fieldtype_t::FIELD_EHANDLE, "CHandle< CBaseEntity >"sv},
                {fieldtype_t::FIELD_CUSTOM, "void"sv},
                {fieldtype_t::FIELD_HMODEL, "CStrongHandle< InfoForResourceTypeCModel >"sv},
                {fieldtype_t::FIELD_HMATERIAL, "CStrongHandle< InfoForResourceTypeIMaterial2 >"sv},
                {fieldtype_t::FIELD_SHIM, "SHIM"sv},
                {fieldtype_t::FIELD_FUNCTION, "void*"sv},
            });
        } // namespace

        // @note: @es3n1n: basically the same thing as std::atoi
        // but an exception would be thrown if we are unable to parse the string
        //
        int wrapped_atoi(const char* s) {
            const int result = std::atoi(s);

            if (result == 0 && s && s[0] != '0')
                throw std::runtime_error(std::format("{} : Unable to parse '{}'", __FUNCTION__, s));

            return result;
        }

        /// only sets @p result.m_type if @p type_name indicates that this field is a bitfield
        void parse_bitfield(const codegen::IGenerator& generator, field_info_t& result, const std::string& type_name) {
            // @note: @es3n1n: in source2 schema, every bitfield var name would start with the "bitfield:" prefix
            // so if there's no such prefix we would just skip the bitfield parsing.
            if (type_name.size() < kBitfieldTypePrefix.size())
                return;

            if (const auto s = type_name.substr(0, kBitfieldTypePrefix.size()); s != kBitfieldTypePrefix.data())
                return;

            // @note: @es3n1n: type_name starts with the "bitfield:" prefix,
            // now we can parse the bitfield size
            const auto bitfield_size_str = type_name.substr(kBitfieldTypePrefix.size(), type_name.size() - kBitfieldTypePrefix.size());
            const auto bitfield_size = static_cast<unsigned int>(wrapped_atoi(bitfield_size_str.data()));

            // @note: @es3n1n: saving parsed value
            result.m_bitfield_size = bitfield_size;
            result.m_type = generator.get_uint(std::max(8u, std::bit_ceil(bitfield_size)));
        }

        // @note: @es3n1n: we are assuming that this function would be executed right after
        // @ref parse_bitfield() and the type would be already set if item is a bitfield
        // or array
        //
        void parse_type(const codegen::IGenerator& generator, field_info_t& result, const std::string& type_name) {
            auto [unwrapped_name, unwrapped_pointers] = split_type_name_pointers(type_name);

            if (const auto found = generator.find_built_in(unwrapped_name); found.has_value()) {
                result.m_type = found.value() + unwrapped_pointers;
            } else {
                // result.m_type may already be set if parse_bitfield() identified a bitfield
                if (result.m_type.empty()) {
                    result.m_type = type_name;
                }
            }
        }

        // @note: @og: as above just modified for datamaps
        void parse_type(field_info_t& result, const fieldtype_t& type_name) {
            if (result.m_field_type == fieldtype_t::FIELD_UNUSED)
                result.m_field_type = type_name;

            // @note: @es3n1n: applying kDatamapToCpp rules
            for (auto& rule : kDatamapToCpp) {
                if (result.m_field_type != rule.first)
                    continue;

                result.m_type = rule.second;
                break;
            }
        }
    } // namespace detail

    std::pair<std::string, std::string> split_type_name_pointers(const std::string& type_name) {
        const auto pos = type_name.find('*');
        const auto base = (pos == std::string::npos) ? type_name : type_name.substr(0, pos);
        const auto pointers = (pos == std::string::npos) ? "" : type_name.substr(pos);

        return std::make_pair(base, pointers);
    }

    std::string guess_bitfield_type(const std::size_t bits_count) {
        for (auto p : detail::kBitfieldIntegralTypes) {
            if (bits_count > p.first)
                continue;

            return p.second.data();
        }

        throw std::runtime_error(std::format("{} : Unable to guess bitfield type with size {}", __FUNCTION__, bits_count));
    }

    field_info_t parse(const codegen::IGenerator& generator, const std::string& type_name, const std::string& name,
                       const std::vector<std::size_t>& array_sizes) {
        field_info_t result = {};
        result.m_name = name;

        std::copy(array_sizes.begin(), array_sizes.end(), std::back_inserter(result.m_array_sizes));

        detail::parse_bitfield(generator, result, type_name);
        detail::parse_type(generator, result, type_name);

        return result;
    }

    field_info_t parse(fieldtype_t field_type, const std::string& name, std::size_t array_sizes) {
        field_info_t result = {};
        result.m_name = name;

        if (array_sizes > 1)
            result.m_array_sizes.emplace_back(array_sizes);

        detail::parse_type(result, field_type);

        return result;
    }
} // namespace field_parser

// source2gen - Source2 games SDK generator
// Copyright 2024 neverlosecc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

```

`source2gen/test/CMakeLists.txt`:

```txt
project(${CMAKE_PROJECT_NAME}-test)

find_package(GTest REQUIRED)

add_executable(${PROJECT_NAME}
  "src/codegen/test.c.cpp"
  "src/codegen/test.cpp.cpp"
)

target_link_libraries(${PROJECT_NAME}
  GTest::gtest_main
  lib${CMAKE_PROJECT_NAME}
)

```

`source2gen/test/src/codegen/test.c.cpp`:

```cpp
#include "tools/codegen/c.h"
#include "tools/codegen/codegen.h"
#include <gtest/gtest.h>

TEST(CodeGenC, Simple) {
    auto builder = codegen::generator_c_t{};

    builder.preamble();
    builder.next_line();
    builder.comment("it's a-me", true);
    builder.forward_declaration("Mario");

    EXPECT_EQ(builder.str(), "#pragma once\n"
                             "\n"
                             "#include \"source2sdk/source2gen/source2gen.h\"\n"
                             "#include <stdbool.h>\n"
                             "#include <stddef.h>\n"
                             "#include <stdint.h>\n"
                             "\n"
                             "// it's a-me\n"
                             "struct Mario;\n"
                             "");
}

TEST(CodeGenC, Class) {
    auto builder = codegen::generator_c_t{};

    builder.begin_class("Test", "public");
    builder.access_modifier("private"); // noop
    builder.end_class();

    EXPECT_EQ(builder.str(), "struct Test\n"
                             "{\n"
                             "    // This is an empty struct. There is no data in this struct. A pad has been generated for compliance with C.\n"
                             "    char pad_do_not_access;\n"
                             "};\n"
                             "\n");
}

TEST(CodeGenC, ClassWithBase) {
    auto builder = codegen::generator_c_t{};

    builder.begin_class_with_base_type("Player", "Entity", "public");

    EXPECT_EQ(builder.str(), "struct Player\n"
                             "{\n"
                             "    struct Entity base;\n");
}

TEST(CodeGenC, ClassContents) {
    auto builder = codegen::generator_c_t{};

    builder.begin_class("Test", "public");
    builder.static_field_getter("int", "power", "tier0", "Game", 19);
    builder.prop(codegen::Prop{.type_name = "int", .name = "up"});
    builder.prop(codegen::Prop{.type_name = "uint8_t", .name = "down", .bitfield_size = 7});
    builder.end_class();

    EXPECT_EQ(builder.str(), "struct Test\n"
                             "{\n"
                             "    int up;\n"
                             "    uint8_t down: 7;\n"
                             "};\n"
                             "\n");
}

TEST(CodeGenC, EscapesClassMembers) {
    auto builder = codegen::generator_c_t{};

    builder.begin_class("Test", "public");
    builder.prop(codegen::Prop{.type_name = "CPlayer::Head", .name = "very::big"});
    builder.end_class();

    EXPECT_EQ(builder.str(), "struct Test\n"
                             "{\n"
                             "    CPlayer_Head very_big;\n"
                             "};\n"
                             "\n");
}

TEST(CodeGenC, Struct) {
    auto builder = codegen::generator_c_t{};

    builder.begin_struct("Test", "public");
    builder.end_struct();

    EXPECT_EQ(builder.str(), "struct Test\n"
                             "{\n"
                             "    // This is an empty struct. There is no data in this struct. A pad has been generated for compliance with C.\n"
                             "    char pad_do_not_access;\n"
                             "};\n"
                             "\n");
}

TEST(CodeGenC, StructWithBase) {
    auto builder = codegen::generator_c_t{};

    builder.begin_struct_with_base_type("Player", "Entity", "public");

    EXPECT_EQ(builder.str(), "struct Player\n"
                             "{\n"
                             "    struct Entity base;\n");
}

TEST(CodeGenC, StructWithContents) {
    auto builder = codegen::generator_c_t{};

    builder.begin_struct("Test", "public");
    builder.struct_padding(
        codegen::Padding{
            .pad_offset = 0x100,
            .size = codegen::Padding::Bytes{0x200},
        },
        true);
    builder.struct_padding(
        codegen::Padding{
            .pad_offset = 0x300,
            .size = codegen::Padding::Bits{7},
        },
        true);
    builder.end_struct();

    EXPECT_EQ(builder.str(), "struct Test\n"
                             "{\n"
                             "    uint8_t _pad0100[0x200];\n"
                             "    uint8_t _pad0300: 7;\n"
                             "};\n"
                             "\n");
}

TEST(CodeGenC, Namespace) {
    auto builder = codegen::generator_c_t{};

    builder.begin_namespace("sourcesdk");
    builder.end_namespace();

    EXPECT_EQ(builder.str(), "// namespace sourcesdk\n"
                             "// {\n"
                             "// };\n"
                             "\n");
}

TEST(CodeGenC, Enum) {
    auto builder = codegen::generator_c_t{};

    builder.begin_enum("Choice");
    builder.enum_item("Chocolate", 7);
    builder.enum_item("Strawberries", 9);
    builder.end_enum();

    EXPECT_EQ(builder.str(), "enum Choice\n"
                             "{\n"
                             "    Choice_Chocolate = 0x7,\n"
                             "    Choice_Strawberries = 0x9,\n"
                             "};\n"
                             "\n");
}

TEST(CodeGenC, Function) {
    auto builder = codegen::generator_c_t{};

    builder.begin_function("static ", "int", "jump", true, true);
    builder.return_value("1234", true);
    builder.end_function(true, true);

    EXPECT_EQ(builder.str(), "static int jump()\n"
                             "{\n"
                             "    return 1234;\n"
                             "};\n" // this semicolon is unnecessary in C
                             "\n");
}

TEST(CodeGenC, BitfieldBlock) {
    auto builder = codegen::generator_c_t{};

    builder.begin_bitfield_block();
    builder.end_bitfield_block(true);

    EXPECT_EQ(builder.str(), "// start of bitfield block\n"
                             "// end of bitfield block\n");
}

```

`source2gen/test/src/codegen/test.cpp.cpp`:

```cpp
#include "tools/codegen/codegen.h"
#include "tools/codegen/cpp.h"
#include <gtest/gtest.h>

TEST(CodeGenCpp, Simple) {
    auto builder = codegen::generator_cpp_t{};

    builder.preamble();
    builder.next_line();
    builder.comment("it's a-me", true);
    builder.forward_declaration("Mario");

    EXPECT_EQ(builder.str(), "#pragma once\n"
                             "\n"
                             "#include \"source2sdk/source2gen/source2gen.hpp\"\n"
                             "#include <cstddef>\n"
                             "#include <cstdint>\n"
                             "\n"
                             "// it's a-me\n"
                             "struct Mario;\n"
                             "");
}

TEST(CodeGenCpp, Class) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_class("Test", "public");
    builder.access_modifier("private");
    builder.end_class();

    EXPECT_EQ(builder.str(), "class Test\n"
                             "{\n"
                             "public:\n"
                             "private:\n"
                             "};\n");
}

TEST(CodeGenCpp, ClassWithBase) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_class_with_base_type("Player", "Entity", "public");

    EXPECT_EQ(builder.str(), "class Player : public Entity\n"
                             "{\n"
                             "public:\n");
}

TEST(CodeGenCpp, ClassContents) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_class("Test", "public");
    builder.static_field_getter("int", "power", "tier0", "Game", 19);
    builder.prop(codegen::Prop{.type_category = codegen::TypeCategory::built_in, .type_name = "int", .name = "up"});
    builder.end_class();

    EXPECT_EQ(builder.str(), "class Test\n"
                             "{\n"
                             "public:\n"
                             "    static int &Get_power(){return "
                             "*reinterpret_cast<int*>(interfaces::g_schema->FindTypeScopeForModule(\"tier0\")->FindDeclaredClass(\"Game\")->"
                             "GetStaticFields()[19]->m_pInstance);};\n"
                             "    int up;\n"
                             "};\n");
}

TEST(CodeGenCpp, Struct) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_struct("Test", "public");
    builder.end_struct();

    EXPECT_EQ(builder.str(), "struct Test\n"
                             "{\n"
                             "public:\n"
                             "};\n");
}

TEST(CodeGenCpp, StructWithBase) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_struct_with_base_type("Player", "Entity", "public");

    EXPECT_EQ(builder.str(), "struct Player : public Entity\n"
                             "{\n"
                             "public:\n");
}

TEST(CodeGenCpp, StructWithContents) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_struct("Test", "public");
    builder.struct_padding(
        codegen::Padding{
            .pad_offset = 0x100,
            .size = codegen::Padding::Bytes{0x200},
        },
        true);
    builder.struct_padding(
        codegen::Padding{
            .pad_offset = 0x300,
            .size = codegen::Padding::Bits{7},
        },
        true);
    builder.end_struct();

    EXPECT_EQ(builder.str(), "struct Test\n"
                             "{\n"
                             "public:\n"
                             "    uint8_t _pad0100[0x200];\n"
                             "    uint8_t _pad0300: 7;\n"
                             "};\n");
}

TEST(CodeGenCpp, Namespace) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_namespace("sourcesdk");
    builder.end_namespace();

    EXPECT_EQ(builder.str(), "namespace sourcesdk\n"
                             "{\n"
                             "};\n" // this semicolon is unnecessary in C++
    );
}

TEST(CodeGenCpp, Enum) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_enum("Choice");
    builder.enum_item("Chocolate", 7);
    builder.enum_item("Strawberries", 9);
    builder.end_enum();

    EXPECT_EQ(builder.str(), "enum class Choice\n"
                             "{\n"
                             "    Chocolate = 0x7,\n"
                             "    Strawberries = 0x9,\n"
                             "};\n");
}

TEST(CodeGenCpp, Function) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_function("static ", "int", "jump", true, true);
    builder.return_value("1234", true);
    builder.end_function(true, true);

    EXPECT_EQ(builder.str(), "static int jump()\n"
                             "{\n"
                             "    return 1234;\n"
                             "};\n" // this semicolon is unnecessary in C++
    );
}

TEST(CodeGenCpp, BitfieldBlock) {
    auto builder = codegen::generator_cpp_t{};

    builder.begin_bitfield_block();
    builder.end_bitfield_block(true);

    EXPECT_EQ(builder.str(), "// start of bitfield block\n"
                             "// end of bitfield block\n");
}

```

`vendor/CMakeLists.txt`:

```txt
include(FetchContent)

FetchContent_Declare(ValveFileVDF SYSTEM
    GIT_REPOSITORY
    "https://github.com/TinyTinni/ValveFileVDF"
    GIT_TAG
    "2d4c60eb160bc413ef4bafb0c1fd5ccf92ae4705"
)
FetchContent_MakeAvailable(ValveFileVDF)

```