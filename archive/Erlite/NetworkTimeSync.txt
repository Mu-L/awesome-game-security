Project Path: arc_Erlite_NetworkTimeSync_szybpkab

Source Tree:

```txt
arc_Erlite_NetworkTimeSync_szybpkab
├── LICENSE.txt
├── NetworkTimeSync.uplugin
├── README.MD
├── Resources
│   └── Icon128.png
└── Source
    └── NetworkTimeSync
        ├── NetworkTimeSync.Build.cs
        ├── Private
        │   ├── NetworkTimeSubsystem.cpp
        │   ├── NetworkTimeSync.cpp
        │   └── NetworkTimeSyncComponent.cpp
        └── Public
            ├── NetworkTimeSubsystem.h
            ├── NetworkTimeSync.h
            ├── NetworkTimeSyncComponent.h
            └── NetworkTimeSyncSettings.h

```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) 2022 Younes Meziane

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`NetworkTimeSync.uplugin`:

```uplugin
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "1.0",
	"FriendlyName": "NetworkTimeSync",
	"Description": "A simple implementation of a NTP clock algorithm for more accurate network time sync between server and clients.",
	"Category": "Other",
	"CreatedBy": "Younes Meziane",
	"CreatedByURL": "https://erlite.dev/",
	"DocsURL": "",
	"MarketplaceURL": "",
	"SupportURL": "",
	"CanContainContent": true,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "NetworkTimeSync",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		}
	]
}
```

`README.MD`:

```MD

# NetworkTimeSync

 

A simple C++ (and Blueprint compatible) plugin that aims to provide a more accurate server world time to clients.

## Installation

Simply place the contents of this repository in a `Plugins/NetworkTimeSync/` folder of your project.

You must then enable the plugin in your Project Settings, and in your `ProjectName.Build.cs` file.

```cs
PublicDependencyModuleNames.Add("NetworkTimeSync");
```

Once compiled and enabled, simply add the `UNetworkTimeSyncComponent` to your Player Controller. This component will be in charge of synchronizing network time, every 10 seconds by default.

![image](https://user-images.githubusercontent.com/25248023/169562656-6253804e-c176-496e-aa28-5ba9b9afb97e.png)


## Usage

The `NetworkTimeSubsystem` is a GameInstance subsystem, which will contain the latest server world time.
You can access it in C++ via the GameInstance, or by using the static provided:

```cpp
// via the GameInstance
if (UGameInstance* GI = GetWorld()->GetGameInstance())
{
  UNetworkTimeSubsystem* NetworkTime = GI->GetSubsystem<UNetworkTimeSubsystem>();
  const float ServerTime = NetworkTime->GetServerWorldTime();
}

// or, you can use the static with a world context object.
UNetworkTimeSubsystem* NetworkTime = UNetworkTimeSubsystem::Get(this);
// May return null with an invalid world context object.
if (NetworkTime)
{
  const float ServerTime = NetworkTime->GetServerWorldTime();
}
```

For Blueprints, you can simply access it via the generated node:

![image](https://user-images.githubusercontent.com/25248023/169562756-5a5710e7-eb52-40ee-a8cb-47fb732b52ab.png)

All you have to do is replace any calls to the GameState's `GetServerWorldTimeSeconds()` function with this one.

## Configuration

You can configure the synchronization interval in your Project Settings.

By default, it will reliably synchronize every ten seconds. You may want to increase or decrease that interval based on your preference.

> Warning: if you decrease the interval for it to synchronize very often, enable `Use Unreliable RPCs` to avoid saturating your bandwidth with RPCs.

![image](https://user-images.githubusercontent.com/25248023/169563307-fdc768b3-020f-4e75-9f29-3a9a753a5ca8.png)


```

`Source/NetworkTimeSync/NetworkTimeSync.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class NetworkTimeSync : ModuleRules
{
	public NetworkTimeSync(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.Add("Core");

		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore",
				"DeveloperSettings"
				// ... add private dependencies that you statically link with here ...	
			}
		);
	}
}

```

`Source/NetworkTimeSync/Private/NetworkTimeSubsystem.cpp`:

```cpp
/*
MIT License

Copyright (c) 2022 Younes Meziane

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#include "NetworkTimeSubsystem.h"
#include "NetworkTimeSync.h"

UNetworkTimeSubsystem* UNetworkTimeSubsystem::Get(UObject* WorldContextObject)
{
	ensureMsgf(WorldContextObject, TEXT("Cannot get network time subsystem from a null world context object."));
    if (IsValid(WorldContextObject))
    {
    	if (const UWorld* World = WorldContextObject->GetWorld())
    	{
    		if (const UGameInstance* GI = World->GetGameInstance())
    		{
    			return GI->GetSubsystem<UNetworkTimeSubsystem>();
    		}
    	}
    }
    
	return nullptr;
}

float UNetworkTimeSubsystem::GetServerWorldTime() const
{
	return GetWorld()->GetTimeSeconds() + ServerWorldTimeDelta;
}

void UNetworkTimeSubsystem::OnServerWorldTimeReceived(const float ClientTime, const float ServerTime)
{
	const float RoundTripTime = GetWorld()->GetTimeSeconds() - ClientTime;
	if (RoundTripTime < ShortestRoundTripTime)
	{
		ShortestRoundTripTime = RoundTripTime;
		// Obviously, RTT / 2 isn't representative of all networking conditions since it assumes that RTT is perfectly split 50/50.
		// Better than nothing.
		const float OldDelta = ServerWorldTimeDelta;
		ServerWorldTimeDelta = ServerTime - ClientTime - (ShortestRoundTripTime / 2.0f);
		UE_LOG(LogNetworkTimeSync, Log, TEXT("Received new server world time: %f | ClientTimestamp: %f, ServerTimestamp: %f, RTT: %f, WorldTimeDelta: %f"),
			GetServerWorldTime(), ClientTime, ServerTime, RoundTripTime, ServerWorldTimeDelta);
		
		OnNetworkClockSynchronized.Broadcast(OldDelta, ServerWorldTimeDelta);
	}
}

```

`Source/NetworkTimeSync/Private/NetworkTimeSync.cpp`:

```cpp
/*
MIT License

Copyright (c) 2022 Younes Meziane

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#include "NetworkTimeSync.h"

#define LOCTEXT_NAMESPACE "FNetworkTimeSyncModule"

DEFINE_LOG_CATEGORY(LogNetworkTimeSync);

void FNetworkTimeSyncModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
}

void FNetworkTimeSyncModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}

#undef LOCTEXT_NAMESPACE
	
IMPLEMENT_MODULE(FNetworkTimeSyncModule, NetworkTimeSync)
```

`Source/NetworkTimeSync/Private/NetworkTimeSyncComponent.cpp`:

```cpp
/*
MIT License

Copyright (c) 2022 Younes Meziane

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#include "NetworkTimeSyncComponent.h"

#include "NetworkTimeSubsystem.h"
#include "NetworkTimeSyncSettings.h"

UNetworkTimeSyncComponent::UNetworkTimeSyncComponent()
{
	PrimaryComponentTick.bCanEverTick = false;
	SetIsReplicatedByDefault(true);
}

void UNetworkTimeSyncComponent::BeginPlay()
{
	Super::BeginPlay();

	NetworkTimeSubsystem = UNetworkTimeSubsystem::Get(this);
	ensureAlwaysMsgf(NetworkTimeSubsystem.IsValid(), TEXT("Failed to retrieve network time subsystem within UNetworkTimeSyncComponent."));
    
	const UNetworkTimeSyncSettings* Settings = GetDefault<UNetworkTimeSyncSettings>();
	ensureAlwaysMsgf(Settings, TEXT("Failed to retrieve network time sync settings."));

	// This should never happen, but I'd rather avoid crashing your editor.
	if (!NetworkTimeSubsystem.IsValid() || !Settings)
	{
		return;
	}
	
	bUseUnreliableRPCs = Settings->bUseUnreliableRPCs;
	if (IsNetMode(NM_Client))
	{
		GetWorld()->GetTimerManager().SetTimer(Handle_SynchronizeNetworkTime, this, &UNetworkTimeSyncComponent::SynchronizeNetworkTime,
			FMath::Max(Settings->NetworkSyncIntervalSeconds, 1.0f), true);

		SynchronizeNetworkTime();
	}
}

void UNetworkTimeSyncComponent::SynchronizeNetworkTime()
{
	if (bUseUnreliableRPCs)
	{
		Server_UnreliableRequestWorldTime(GetWorld()->GetTimeSeconds());
	}
	else
	{
		Server_ReliableRequestWorldTime(GetWorld()->GetTimeSeconds());
	}
}

void UNetworkTimeSyncComponent::Server_ReliableRequestWorldTime_Implementation(const float ClientTimestamp)
{
	if (bUseUnreliableRPCs)
	{
		Client_UnreliableSendWorldTime(ClientTimestamp, GetWorld()->GetTimeSeconds());
	}
	else
	{
		Client_ReliableSendWorldTime(ClientTimestamp, GetWorld()->GetTimeSeconds());
	}
}

void UNetworkTimeSyncComponent::Server_UnreliableRequestWorldTime_Implementation(const float ClientTimestamp)
{
	if (bUseUnreliableRPCs)
	{
		Client_UnreliableSendWorldTime(ClientTimestamp, GetWorld()->GetTimeSeconds());
	}
	else
	{
		Client_ReliableSendWorldTime(ClientTimestamp, GetWorld()->GetTimeSeconds());
	}
}

void UNetworkTimeSyncComponent::Client_ReliableSendWorldTime_Implementation(const float ClientTimestamp, const float ServerTimestamp)
{
	if (NetworkTimeSubsystem.IsValid())
	{
		NetworkTimeSubsystem->OnServerWorldTimeReceived(ClientTimestamp, ServerTimestamp);
	}
}

void UNetworkTimeSyncComponent::Client_UnreliableSendWorldTime_Implementation(const float ClientTimestamp, const float ServerTimestamp)
{
	if (NetworkTimeSubsystem.IsValid())
	{
		NetworkTimeSubsystem->OnServerWorldTimeReceived(ClientTimestamp, ServerTimestamp);
	}
}
```

`Source/NetworkTimeSync/Public/NetworkTimeSubsystem.h`:

```h
/*
MIT License

Copyright (c) 2022 Younes Meziane

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "NetworkTimeSubsystem.generated.h"

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnNetworkClockSynchronized, float, OldServerDelta, float, NewServerDelta);

/**
 * Subsystem used to retrieve a more accurate server world time.
 */
UCLASS()
class NETWORKTIMESYNC_API UNetworkTimeSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()

public:

	/**
	 * Retrieve the network time subsystem from a world context object.
	 * @param WorldContextObject A valid world context object to retrieve the subsystem from.
	 */
	static UNetworkTimeSubsystem* Get(UObject* WorldContextObject);
	
	/** Returns the synchronized time between the server and client. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Network Time Subsystem")
	float GetServerWorldTime() const;

	/** Returns the shortest round trip time recorded upon synchronization. Clientside only. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Network Time Subsystem")
	FORCEINLINE float GetShortestRoundTripTime() const { return ShortestRoundTripTime; }

	/** Returns the delta time between the server's world time seconds and the client's. Clientside only. */
	UFUNCTION(BlueprintCallable, BlueprintPure, Category = "Network Time Subsystem")
	FORCEINLINE float GetServerWorldTimeDelta() const { return ServerWorldTimeDelta; }

	/**
	 * Delegate fired on clients when synchronizing the clock.
	 * Only called if accuracy increased.
	 */
	UPROPERTY(BlueprintAssignable, Category = "Network Time Subsystem")
	FOnNetworkClockSynchronized OnNetworkClockSynchronized;

protected:

	friend class UNetworkTimeSyncComponent;
	
	/** Called by the UNetworkTimeSyncComponent when it receives an updated world time from the server. */
	void OnServerWorldTimeReceived(const float ClientTime, const float ServerTime);

	/**
	 * The shortest round trip time recorded upon synchronization.
	 * Clientside only.
	 */
	float ShortestRoundTripTime = TNumericLimits<float>::Max();

	/**
	 * The delta time between the server's world time seconds and the client's.
	 * Clientside only.
	 */
	float ServerWorldTimeDelta = 0.0f;
};

```

`Source/NetworkTimeSync/Public/NetworkTimeSync.h`:

```h
/*
MIT License

Copyright (c) 2022 Younes Meziane

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

DECLARE_LOG_CATEGORY_EXTERN(LogNetworkTimeSync, Log, All);

class FNetworkTimeSyncModule : public IModuleInterface
{
public:

	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

```

`Source/NetworkTimeSync/Public/NetworkTimeSyncComponent.h`:

```h
/*
MIT License

Copyright (c) 2022 Younes Meziane

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "NetworkTimeSyncComponent.generated.h"

class UNetworkTimeSubsystem;
UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class NETWORKTIMESYNC_API UNetworkTimeSyncComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	
	UNetworkTimeSyncComponent();

protected:
	
	virtual void BeginPlay() override;

	/** Called on an interval to regularly synchronize network time with the server. */
	UFUNCTION()
	void SynchronizeNetworkTime();

	UFUNCTION(Server, Reliable)
	void Server_ReliableRequestWorldTime(const float ClientTimestamp);

	UFUNCTION(Server, Unreliable)
	void Server_UnreliableRequestWorldTime(const float ClientTimestamp);

	UFUNCTION(Client, Reliable)
	void Client_ReliableSendWorldTime(const float ClientTimestamp, const float ServerTimestamp);

	UFUNCTION(Client, Unreliable)
	void Client_UnreliableSendWorldTime(const float ClientTimestamp, const float ServerTimestamp);

	UPROPERTY()
	FTimerHandle Handle_SynchronizeNetworkTime;
	
	TWeakObjectPtr<UNetworkTimeSubsystem> NetworkTimeSubsystem;
	
	/** Whether or not to use unreliable RPCs when synchronizing network time. */
	bool bUseUnreliableRPCs = false;
};

```

`Source/NetworkTimeSync/Public/NetworkTimeSyncSettings.h`:

```h
/*
MIT License

Copyright (c) 2022 Younes Meziane

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#pragma once

#include "CoreMinimal.h"
#include "Engine/DeveloperSettings.h"
#include "NetworkTimeSyncSettings.generated.h"

/**
 * Contains configuration for the UNetworkTimeSubsystem.
 */
UCLASS(Config = "Game", DefaultConfig, Meta = (DisplayName = "Network Time Sync Settings"))
class NETWORKTIMESYNC_API UNetworkTimeSyncSettings : public UDeveloperSettings
{
	GENERATED_BODY()

public:

	/** Whether or not to use unreliable RPCs to synchronize time. Enable if you set the interval to update frequently. */
	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category = "Settings")
	bool bUseUnreliableRPCs = false;

	/**
	 * Time between each synchronization attempt in seconds.
	 * For very frequent updates, enable bUseUnreliableRPCs to avoid saturating the bandwidth and killing your game.
	 */
	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category = "Settings", Meta = (ClampMin = "1.0", ValueMin = "1.0"))
	float NetworkSyncIntervalSeconds = 10.0f;
};

```